{
    "functions": {
        "FUN_00000410": {
            "entrypoint": "0x00000410",
            "current_name": "initialize_uart_00000410",
            "code": "\nint initializeUart_00000410(EVP_PKEY_CTX *pkeyContext)\n\n{\n  uart_stdio_init();\n  return (int)pkeyContext;\n}\n\n",
            "renaming": {
                "FUN_00000410": "initialize_uart_00000410",
                "ctx": "pkeyContext"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "uart_stdio_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000041c": {
            "entrypoint": "0x0000041c",
            "current_name": "FUNC_0000041c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0000041c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000041c": "FUNC_0000041c"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00000428": {
            "entrypoint": "0x00000428",
            "current_name": "increase_heap_00000428",
            "code": "\nvoid * increaseHeap_00000428(_reenteent *reent,ptreentdiff_t increment)\n\n{\n  uint disableState;\n  ptreentdiff_t localIncrement;\n  _reenteent *localReent;\n  uint restoreState;\n  void *result;\n  \n  disableState = ireentq_disable();\n  result = heap_top;\n  if ((&_ereentam < heap_top + increment) || (heap_top + increment < &_sheap)) {\n    reent->_ereentreentno = 0xc;\n    result = (void *)0xffffffff;\n  }\n  else {\n    heap_top = heap_top + increment;\n  }\n  ireentq_resulttoreente(disableState);\n  reentetureentn result;\n}\n\n",
            "renaming": {
                "FUN_00000428": "increase_heap_00000428",
                "r": "reent",
                "incr": "increment",
                "incr_local": "localIncrement",
                "r_local": "localReent",
                "state_00": "disableState",
                "state": "restoreState",
                "res": "result"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "irq_restore",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000490": {
            "entrypoint": "0x00000490",
            "current_name": "read_uart_data_00000490",
            "code": "\n_ssize_t read_uart_data_00000490(_reent_pointereent *reent_pointer,int fd,void *data_buffer,size_t buffer_length)\n\n{\n  int read_result;\n  size_t local_buffer_length;\n  void *local_data_buffer;\n  int local_file_descriptor;\n  _reent_pointereent *local_reent_pointer;\n  \n  read_result = uareent_pointert_stdio_reent_pointeread((chareent_pointer *)data_buffer,buffer_length);\n  reent_pointeretureent_pointern read_result;\n}\n\n",
            "renaming": {
                "FUN_00000490": "read_uart_data_00000490",
                "r": "reent_pointer",
                "buffer": "data_buffer",
                "count": "buffer_length",
                "count_local": "local_buffer_length",
                "buffer_local": "local_data_buffer",
                "fd_local": "local_file_descriptor",
                "r_local": "local_reent_pointer",
                "iVar1": "read_result"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "uart_stdio_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000004b2": {
            "entrypoint": "0x000004b2",
            "current_name": "write_to_uart_000004b2",
            "code": "\n_ssize_t write_to_uart_000004b2(_reent_ptreent *reent_ptr,int fd,void *buffer,size_t buffer_size)\n\n{\n  int iVareent_ptr1;\n  size_t local_buffer_size;\n  void *local_buffer;\n  int local_file_descriptor;\n  _reent_ptreent *local_reent;\n  \n  iVareent_ptr1 = uareent_ptrt_stdio_wreent_ptrite((chareent_ptr *)buffer,buffer_size);\n  reent_ptretureent_ptrn iVareent_ptr1;\n}\n\n",
            "renaming": {
                "FUN_000004b2": "write_to_uart_000004b2",
                "r": "reent_ptr",
                "data": "buffer",
                "count": "buffer_size",
                "count_local": "local_buffer_size",
                "data_local": "local_buffer",
                "fd_local": "local_file_descriptor",
                "r_local": "local_reent"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "uart_stdio_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000004d4": {
            "entrypoint": "0x000004d4",
            "current_name": "set_file_descriptor_error_000004d4",
            "code": "\nint setFileDescriptorError_000004d4(_reenteent *reent,int fd)\n\n{\n  int localFileDescriptor;\n  _reenteent *localReent;\n  \n  reent->_ereentreentno = 0x13;\n  reentetureentn -1;\n}\n\n",
            "renaming": {
                "FUN_000004d4": "set_file_descriptor_error_000004d4",
                "r": "reent",
                "fd_local": "localFileDescriptor",
                "r_local": "localReent"
            },
            "calling": [
                "__sclose"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000004f2": {
            "entrypoint": "0x000004f2",
            "current_name": "set_file_cursor_position_000004f2",
            "code": "\nOffsetType setFileCursorPosition_000004f2(Reent *reentPointer,int fd,OffsetType position,int direction)\n\n{\n  int localDirection;\n  OffsetType localPosition;\n  int localFileDescriptor;\n  Reent *localReent;\n  \n  reentPointer->_ereentPointerreentPointerno = 0x13;\n  reentPointeretureentPointern -1;\n}\n\n",
            "renaming": {
                "_off_t": "OffsetType",
                "_reent": "Reent",
                "FUN_000004f2": "set_file_cursor_position_000004f2",
                "r": "reentPointer",
                "pos": "position",
                "dir": "direction",
                "dir_local": "localDirection",
                "pos_local": "localPosition",
                "fd_local": "localFileDescriptor",
                "r_local": "localReent"
            },
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000514": {
            "entrypoint": "0x00000514",
            "current_name": "set_file_status_error_00000514",
            "code": "\nint setFileStatusError_00000514(_reentrancyStructureeent *reentrancyStructure,int fd,fileStatusat *fileStatus)\n\n{\n  fileStatusat *fileStatus_local;\n  int fd_local;\n  _reentrancyStructureeent *reentrancyStructure_local;\n  \n  reentrancyStructure->_ereentrancyStructurereentrancyStructureno = 0x13;\n  reentrancyStructureetureentrancyStructuren -1;\n}\n\n",
            "renaming": {
                "FUN_00000514": "set_file_status_error_00000514",
                "r": "reentrancyStructure",
                "st": "fileStatus"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000534": {
            "entrypoint": "0x00000534",
            "current_name": "check_standard_file_descriptors_00000534",
            "code": "\nint checkStandardFileDescriptors_00000534(_reenteent *reent,int fd)\n\n{\n  int isValidDescriptor;\n  int localFileDescriptor;\n  _reenteent *localReent;\n  \n  reent->_ereentreentno = 0;\n  if (((fd == 0) || (fd == 1)) || (fd == 2)) {\n    isValidDescriptor = 1;\n  }\n  else {\n    isValidDescriptor = 0;\n  }\n  reentetureentn isValidDescriptor;\n}\n\n",
            "renaming": {
                "FUN_00000534": "check_standard_file_descriptors_00000534",
                "r": "reent",
                "iVar1": "isValidDescriptor",
                "fd_local": "localFileDescriptor",
                "r_local": "localReent"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000566": {
            "entrypoint": "0x00000566",
            "current_name": "decode_u_int32_00000566",
            "code": "\nuint decodeUInt32_00000566(uint inputValue)\n\n{\n  byte byte1;\n  byte byte2;\n  byte byte3;\n  byte byte4;\n  uint decodedValue;\n  uint localInputValue;\n  \n  byte2 = (byte)inputValue;\n  byte3 = (byte)(inputValue >> 8);\n  byte4 = (byte)(inputValue >> 0x10);\n  byte1 = (byte)(inputValue >> 0x18);\n  decodedValue = LZCOUNT((uint)(byte)((((((((byte2 & 1) << 1 | byte2 >> 1 & 1) << 1 | byte2 >> 2 & 1) << 1\n                                  | byte2 >> 3 & 1) << 1 | byte2 >> 4 & 1) << 1 | byte2 >> 5 & 1) <<\n                                1 | byte2 >> 6 & 1) << 1 | byte2 >> 7) << 0x18 |\n                  (uint)(byte)((((((((byte3 & 1) << 1 | byte3 >> 1 & 1) << 1 | byte3 >> 2 & 1) << 1\n                                  | byte3 >> 3 & 1) << 1 | byte3 >> 4 & 1) << 1 | byte3 >> 5 & 1) <<\n                                1 | byte3 >> 6 & 1) << 1 | byte3 >> 7) << 0x10 |\n                  (uint)(byte)((((((((byte4 & 1) << 1 | byte4 >> 1 & 1) << 1 | byte4 >> 2 & 1) << 1\n                                  | byte4 >> 3 & 1) << 1 | byte4 >> 4 & 1) << 1 | byte4 >> 5 & 1) <<\n                                1 | byte4 >> 6 & 1) << 1 | byte4 >> 7) << 8 |\n                  (uint)(byte)((((((((byte1 & 1) << 1 | byte1 >> 1 & 1) << 1 | byte1 >> 2 & 1) << 1\n                                  | byte1 >> 3 & 1) << 1 | byte1 >> 4 & 1) << 1 | byte1 >> 5 & 1) <<\n                                1 | byte1 >> 6 & 1) << 1 | byte1 >> 7));\n  if (inputValue == 0) {\n    decodedValue = 0xffffffff;\n  }\n  return decodedValue;\n}\n\n",
            "renaming": {
                "FUN_00000566": "decode_u_int32_00000566",
                "v": "inputValue",
                "bVar1": "byte1",
                "bVar2": "byte2",
                "bVar3": "byte3",
                "bVar4": "byte4",
                "uVar5": "decodedValue",
                "v_local": "localInputValue"
            },
            "calling": [
                "sched_run"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000058e": {
            "entrypoint": "0x0000058e",
            "current_name": "insert_node_in_list_0000058e",
            "code": "\nvoid insertNodeInList_0000058e(cnode_t *currentNode,cnode_t *insertedNode)\n\n{\n  cnode_t *currentInsertedNode;\n  cnode_t *currentListNode;\n  \n  if (currentNode->next == (node *)0x0) {\n    insertedNode->next = insertedNode;\n  }\n  else {\n    insertedNode->next = currentNode->next->next;\n    currentNode->next->next = insertedNode;\n  }\n  currentNode->next = insertedNode;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000058e": "insert_node_in_list_0000058e",
                "list": "currentNode",
                "new_node": "insertedNode",
                "new_node_local": "currentInsertedNode",
                "list_local": "currentListNode",
                "list_node": "node"
            },
            "calling": [
                "sched_set_status"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000005ca": {
            "entrypoint": "0x000005ca",
            "current_name": "extract_and_remove_next_node_000005ca",
            "code": "\ncinputList_node_t * extractAndRemoveNextNode_000005ca(cinputList_node_t *inputList)\n\n{\n  inputList_node *nextNode;\n  cinputList_node_t *localList;\n  cinputList_node_t *firstNode;\n  \n  if (inputList->next == (inputList_node *)0x0) {\n    nextNode = (inputList_node *)0x0;\n  }\n  else {\n    nextNode = inputList->next->next;\n    if (nextNode == inputList->next) {\n      inputList->next = (inputList_node *)0x0;\n    }\n    else {\n      inputList->next->next = nextNode->next;\n    }\n  }\n  return nextNode;\n}\n\n",
            "renaming": {
                "FUN_000005ca": "extract_and_remove_next_node_000005ca",
                "list": "inputList",
                "plVar1": "nextNode",
                "list_local": "localList",
                "first": "firstNode"
            },
            "calling": [
                "sched_set_status"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000610": {
            "entrypoint": "0x00000610",
            "current_name": "context_switch_00000610",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint contextSwitch_00000610(void)\n\n{\n  thread_t *previousThread;\n  uint lsbBitIndex;\n  list_node *nextRunqueueNode;\n  int switchOccurred;\n  thread_t *currentThread;\n  int nextRunqueue;\n  clist_node_t *unusedVar;\n  thread_t *newThread;\n  \n  previousThread = activeThread;\n  contextSwitch_00000610Request = 0;\n  lsbBitIndex = bitarithm_lsb(bitCache);\n  nextRunqueueNode = (runqueues[lsbBitIndex].next)->next;\n  if (previousThread == (thread_t *)(nextRunqueueNode + -2)) {\n    switchOccurred = 0;\n  }\n  else {\n    if ((previousThread != (thread_t *)0x0) && (previousThread->status == '\\t')) {\n      previousThread->status = '\\n';\n    }\n    *(undefined *)&nextRunqueueNode[-1].next = 9;\n    activeProcessID = *(kernel_pid_t *)((int)&nextRunqueueNode[-1].next + 2);\n    switchOccurred = 1;\n    activeThread = (thread_t *)(nextRunqueueNode + -2);\n  }\n  return switchOccurred;\n}\n\n",
            "renaming": {
                "FUN_00000610": "context_switch_00000610",
                "ptVar1": "previousThread",
                "uVar2": "lsbBitIndex",
                "plVar3": "nextRunqueueNode",
                "iVar4": "switchOccurred",
                "active_thread": "currentThread",
                "nextrq": "nextRunqueue",
                "__m____": "unusedVar",
                "next_thread": "newThread",
                "sched_active_thread": "activeThread",
                "sched_context_switch_request": "contextSwitchRequest",
                "runqueue_bitcache": "bitCache",
                "sched_runqueues": "runqueues",
                "sched_active_pid": "activeProcessID"
            },
            "calling": [
                "isr_svc"
            ],
            "called": [
                "bitarithm_lsb"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000698": {
            "entrypoint": "0x00000698",
            "current_name": "update_process_status_00000698",
            "code": "\nvoid updateProcessStatus_00000698(thread_t *currentProcess,uint newStatus)\n\n{\n  uint localStatus;\n  thread_t *localProcess;\n  \n  if (newStatus < 9) {\n    if ((8 < currentProcess->newStatus) &&\n       (listPop(runQueueArray + currentProcess->priority),\n       runQueueArray[currentProcess->priority].nextNode == (ListNode *)0x0)) {\n      bitCache = bitCache & ~(1 << currentProcess->priority);\n    }\n  }\n  else if (currentProcess->newStatus < 9) {\n    listPush(runQueueArray + currentProcess->priority,&currentProcess->runQueueEntry);\n    bitCache = bitCache | 1 << currentProcess->priority;\n  }\n  currentProcess->newStatus = (uint8_t)newStatus;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000698": "update_process_status_00000698",
                "process": "currentProcess",
                "status": "newStatus",
                "status_local": "localStatus",
                "process_local": "localProcess",
                "sched_runqueues": "runQueueArray",
                "runqueue_bitcache": "bitCache",
                "clist_lpop": "listPop",
                "clist_rpush": "listPush",
                "next": "nextNode",
                "list_node": "ListNode",
                "rq_entry": "runQueueEntry"
            },
            "calling": [
                "mutex_unlock",
                "thread_create",
                "_mutex_lock",
                "sched_task_exit"
            ],
            "called": [
                "clist_rpush",
                "clist_lpop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000738": {
            "entrypoint": "0x00000738",
            "current_name": "check_and_request_context_switch_00000738",
            "code": "\nvoid checkAndRequestContextSwitch_00000738(uint16_t requestedPriority)\n\n{\n  int iVar1;\n  uint16_t localPriority;\n  uint16_t currentPriority;\n  thread_t *currentThread;\n  int threadOnRunqueue;\n  \n  if ((sched_currentThread->status < 9) || (requestedPriority < sched_currentThread->priority)) {\n    iVar1 = irq_is_in();\n    if (iVar1 == 0) {\n      thread_yield_higher();\n    }\n    else {\n      sched_context_switch_request = 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000738": "check_and_request_context_switch_00000738",
                "other_prio": "requestedPriority",
                "other_prio_local": "localPriority",
                "current_prio": "currentPriority",
                "active_thread": "currentThread",
                "on_runqueue": "threadOnRunqueue"
            },
            "calling": [
                "mutex_unlock",
                "thread_create"
            ],
            "called": [
                "thread_yield_higher",
                "irq_is_in"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000794": {
            "entrypoint": "0x00000794",
            "current_name": "cleanup_and_exit_00000794",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid cleanupAndExit_00000794(void)\n\n{\n  disableInterrupts();\n  threadTable[activeProcessID] = (Thread *)0x0;\n  numberOfThreads = numberOfThreads + -1;\n  setThreadStatus(activeThread,0);\n  activeThread = (Thread *)0x0;\n                    \n  switchToNextContext();\n}\n\n",
            "renaming": {
                "FUN_00000794": "cleanup_and_exit_00000794",
                "irq_disable": "disableInterrupts",
                "sched_threads": "threadTable",
                "sched_active_pid": "activeProcessID",
                "thread_t": "Thread",
                "sched_num_threads": "numberOfThreads",
                "sched_set_status": "setThreadStatus",
                "sched_active_thread": "activeThread",
                "cpu_switch_context_exit": "switchToNextContext"
            },
            "calling": [],
            "called": [
                "sched_set_status",
                "cpu_switch_context_exit",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000007dc": {
            "entrypoint": "0x000007dc",
            "current_name": "thread_task_000007dc",
            "code": "\nchar * threadTask_000007dc(thread_taskFunction_t taskFunction,voindexd *argument,voindexd *stackStart,indexnt stackSize)\n\n{\n  uindexnt adjustedStackSize;\n  indexnt adjustedStackSizeLocal;\n  voindexd *stackStartLocal;\n  voindexd *argumentLocal;\n  thread_taskFunction_t taskFunctionLocal;\n  indexnt index1;\n  indexnt index;\n  uindexnt32_t *stack;\n  \n  adjustedStackSize = stackSize + (indexnt)stackStart & 0xfffffffc;\n  stack = (uindexnt32_t *)(adjustedStackSize - 4);\n  *stack = 0x77777777;\n  indexf (((uindexnt)stack & 7) != 0) {\n    stack = (uindexnt32_t *)(adjustedStackSize - 8);\n    *stack = 0x88888888;\n  }\n  stack[-1] = 0x1000000;\n  stack[-2] = (uindexnt32_t)taskFunction;\n  stack[-3] = 0x795;\n  stack = stack + -4;\n  *stack = 0;\n  for (index = 3; 0 < index; index = index + -1) {\n    stack = stack + -1;\n    *stack = index;\n  }\n  stack = stack + -1;\n  *stack = (uindexnt32_t)argument;\n  for (index1 = 0xb; 3 < index1; index1 = index1 + -1) {\n    stack = stack + -1;\n    *stack = index1;\n  }\n  stack[-1] = 0xfffffffd;\n  return (char *)(stack + -1);\n}\n\n",
            "renaming": {
                "FUN_000007dc": "thread_task_000007dc",
                "task_func": "taskFunction",
                "arg": "argument",
                "stack_start": "stackStart",
                "stack_size": "stackSize",
                "uVar1": "adjustedStackSize",
                "stack_size_local": "adjustedStackSizeLocal",
                "stack_start_local": "stackStartLocal",
                "arg_local": "argumentLocal",
                "task_func_local": "taskFunctionLocal",
                "i_1": "index1",
                "i": "index",
                "stk": "stack"
            },
            "calling": [
                "thread_create"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000008b8": {
            "entrypoint": "0x000008b8",
            "current_name": "count_used_words_000008b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint countUsedWords_000008b8(void)\n\n{\n  ptrToWordsdiff_t usedWordCount;\n  uint32_t *ptrToWords;\n  \n  for (ptrToWords = (uint32_t *)stackPtr; (*ptrToWords == 0xe7fee7fe && (ptrToWords < &heapTop)); ptrToWords = ptrToWords + 1) {\n  }\n  return ((int)&heapTop - (int)ptrToWords >> 2) << 2;\n}\n\n",
            "renaming": {
                "FUN_000008b8": "count_used_words_000008b8",
                "num_used_words": "usedWordCount",
                "ptr": "ptrToWords",
                "isr_stack": "stackPtr",
                "heap_top": "heapTop"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000900": {
            "entrypoint": "0x00000900",
            "current_name": "get_main_stack_pointer_00000900",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * get_main_stack_pointer_00000900(void)\n\n{\n  void *main_stack_pointer;\n  uint32_t output;\n  void *main_stack_pointer;\n  \n  main_stack_pointer = (void *)getMainStackPointer();\n  return main_stack_pointer;\n}\n\n",
            "renaming": {
                "FUN_00000900": "get_main_stack_pointer_00000900",
                "pvVar1": "main_stack_pointer",
                "result": "output",
                "msp": "main_stack_pointer"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000091c": {
            "entrypoint": "0x0000091c",
            "current_name": "get_isr_stack_pointer_0000091c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * get_isr_stack_pointer_0000091c(void)\n\n{\n  return stack_pointer;\n}\n\n",
            "renaming": {
                "FUN_0000091c": "get_isr_stack_pointer_0000091c",
                "isr_stack": "stack_pointer"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000930": {
            "entrypoint": "0x00000930",
            "current_name": "enable_interrupts_and_trigger_software_interrupt_00000930",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableInterruptsAndTriggerSoftwareInterrupt_00000930(void)\n\n{\n  enableInterrupts();\n  triggerSoftwareInterrupt(1);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00000930": "enable_interrupts_and_trigger_software_interrupt_00000930",
                "irq_enable": "enableInterrupts",
                "software_interrupt": "triggerSoftwareInterrupt"
            },
            "calling": [
                "kernel_init",
                "sched_task_exit"
            ],
            "called": [
                "irq_enable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000093c": {
            "entrypoint": "0x0000093c",
            "current_name": "enable_interrupt_flag_0000093c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid enableInterruptFlag_0000093c(void)\n\n{\n  _DAT_e000ed04 = _DAT_e000ed04 | 0x10000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000093c": "enable_interrupt_flag_0000093c"
            },
            "calling": [
                "sched_switch",
                "cortexm_isr_end",
                "cortexm_isr_end",
                "_mutex_lock",
                "cortexm_isr_end"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000958": {
            "entrypoint": "0x00000958",
            "current_name": "execute_interrupt_service_routine_00000958",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid executeInterruptServiceRoutine_00000958(void)\n\n{\n  bool isPrivilegedMode;\n  int iVar2;\n  code *jmpTableFuncPtr;\n  undefined4 saved_r4;\n  undefined4 saved_r5;\n  undefined4 saved_r6;\n  undefined4 saved_r7;\n  undefined4 saved_r8;\n  undefined4 saved_r9;\n  undefined4 saved_r10;\n  undefined4 saved_r11;\n  undefined4 saved_lr;\n  code **newStackPointer;\n  \n  iVar2 = getProcessStackPointer();\n  *(undefined4 *)(iVar2 + -4) = saved_r11;\n  *(undefined4 *)(iVar2 + -8) = saved_r10;\n  *(undefined4 *)(iVar2 + -0xc) = saved_r9;\n  *(undefined4 *)(iVar2 + -0x10) = saved_r8;\n  *(undefined4 *)(iVar2 + -0x14) = saved_r7;\n  *(undefined4 *)(iVar2 + -0x18) = saved_r6;\n  *(undefined4 *)(iVar2 + -0x1c) = saved_r5;\n  *(undefined4 *)(iVar2 + -0x20) = saved_r4;\n  *(undefined4 *)(iVar2 + -0x24) = saved_lr;\n  activeThread->sp = (char *)(undefined4 *)(iVar2 + -0x24);\n  executeSupervisorCall();\n  runScheduler();\n  jmpTableFuncPtr = *(code **)activeThread->sp;\n  newStackPointer = (code **)((int)activeThread->sp + 0x24);\n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    setProcessStackPointer(newStackPointer);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jmpTableFuncPtr)(jmpTableFuncPtr,newStackPointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000958": "execute_interrupt_service_routine_00000958",
                "unaff_r4": "saved_r4",
                "unaff_r5": "saved_r5",
                "unaff_r6": "saved_r6",
                "unaff_r7": "saved_r7",
                "unaff_r8": "saved_r8",
                "unaff_r9": "saved_r9",
                "unaff_r10": "saved_r10",
                "unaff_r11": "saved_r11",
                "in_lr": "saved_lr",
                "isr_svc": "executeSupervisorCall",
                "sched_active_thread": "activeThread",
                "sched_run": "runScheduler",
                "UNRECOVERED_JUMPTABLE": "jmpTableFuncPtr",
                "ppcVar3": "newStackPointer",
                "bVar1": "isPrivilegedMode"
            },
            "calling": [],
            "called": [
                "isr_svc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000974": {
            "entrypoint": "0x00000974",
            "current_name": "run_scheduler_00000974",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid runScheduler_00000974(void)\n\n{\n  bool isPrivileged;\n  code *jumpTable;\n  code **stackPointer;\n  \n  sched_run();\n  jumpTable = *(code **)sched_active_thread->sp;\n  stackPointer = (code **)((int)sched_active_thread->sp + 0x24);\n  isPrivileged = (bool)checkPrivilegedMode();\n  if (isPrivileged) {\n    updateStackPointer(stackPointer);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)(jumpTable,stackPointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000974": "run_scheduler_00000974",
                "UNRECOVERED_JUMPTABLE": "jumpTable",
                "ppcVar2": "stackPointer",
                "bVar1": "isPrivileged",
                "isCurrentModePrivileged": "checkPrivilegedMode",
                "setProcessStackPointer": "updateStackPointer"
            },
            "calling": [
                "isr_pendsv"
            ],
            "called": [
                "sched_run"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000978": {
            "entrypoint": "0x00000978",
            "current_name": "execute_jump_table_function_00000978",
            "code": "\nvoid executeJumpTableFunction_00000978(void)\n\n{\n  bool isPrivilegedMode;\n  code *jumpTable;\n  code **stackPointer;\n  \n  jumpTable = *(code **)activeThread->sp;\n  stackPointer = (code **)((int)activeThread->sp + 0x24);\n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    setProcessStackPointer(stackPointer);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)(jumpTable,stackPointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000978": "execute_jump_table_function_00000978",
                "sched_active_thread": "activeThread",
                "bVar1": "isPrivilegedMode",
                "UNRECOVERED_JUMPTABLE": "jumpTable",
                "ppcVar2": "stackPointer"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000990": {
            "entrypoint": "0x00000990",
            "current_name": "FUNC_00000990",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00000990(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000990": "FUNC_00000990"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0000099c": {
            "entrypoint": "0x0000099c",
            "current_name": "initialize_system_0000099c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_0000099c(void)\n\n{\n  uint32_t userStack;\n  uint32_t *topPointer;\n  uint32_t *sourcePointer;\n  uint32_t *destinationPointer;\n  \n  topPointer = &userStack;\n  sourcePointer = (uint32_t *)&_etext;\n  pre_startup();\n  destinationPointer = (uint32_t *)isr_stack;\n  while (destinationPointer < &userStack) {\n    *destinationPointer = 0xe7fee7fe;\n    destinationPointer = destinationPointer + 1;\n  }\n  destinationPointer = (uint32_t *)&heap_topPointer;\n  while (destinationPointer < &sched_num_threads) {\n    *destinationPointer = *sourcePointer;\n    sourcePointer = sourcePointer + 1;\n    destinationPointer = destinationPointer + 1;\n  }\n  destinationPointer = (uint32_t *)&sched_num_threads;\n  while (destinationPointer < &_sheap) {\n    *destinationPointer = 0;\n    destinationPointer = destinationPointer + 1;\n  }\n  post_startup();\n  board_init();\n  __libc_init_array();\n  kernel_init();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000099c": "initialize_system_0000099c",
                "uStack_18": "userStack",
                "top": "topPointer",
                "src": "sourcePointer",
                "dst": "destinationPointer"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "post_startup",
                "pre_startup",
                "kernel_init",
                "board_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000a30": {
            "entrypoint": "0x00000a30",
            "current_name": "handle_nmi_exception_00000a30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_nmi_exception_00000a30(void)\n\n{\n                    \n  panic(nmi_handler_panic,\"NMI HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000a30": "handle_nmi_exception_00000a30",
                "PANIC_NMI_HANDLER": "nmi_handler_panic",
                "core_panic": "panic"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000a40": {
            "entrypoint": "0x00000a40",
            "current_name": "calculate_stack_offset_00000a40",
            "code": "\nint calculateStackOffset_00000a40(uint32_t requiredSize)\n\n{\n  uint32_t localRequired;\n  uint32_t *stackPointer;\n  \n  return (int)(&stack0xe000ffe8 + -requiredSize);\n}\n\n",
            "renaming": {
                "FUN_00000a40": "calculate_stack_offset_00000a40",
                "required": "requiredSize",
                "required_local": "localRequired",
                "sp": "stackPointer"
            },
            "calling": [
                "hard_fault_handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000a64": {
            "entrypoint": "0x00000a64",
            "current_name": "handle_stack_corruption_00000a64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleStackCorruption_00000a64(void)\n\n{\n  uint32_t *stackPointer;\n  uint32_t isCorrupted;\n  uint32_t argument;\n  undefined4 argument2;\n  undefined4 argument3;\n  undefined4 argument4;\n  undefined4 argument5;\n  undefined4 argument6;\n  undefined4 argument7;\n  undefined4 argument8;\n  uint linkRegister;\n  \n  if ((&_eram < &stack0x00000000) || (&stack0x00000000 < isr_stack + 0x159)) {\n    isCorrupted = 1;\n    register0x00000054 = (BADSPACEBASE *)&heap_top;\n  }\n  else {\n    isCorrupted = 0;\n  }\n  if ((linkRegister & 4) == 0) {\n    stackPointer = (uint32_t *)getMainStackPointer();\n  }\n  else {\n    stackPointer = (uint32_t *)getProcessStackPointer();\n  }\n  *(undefined4 *)((int)register0x00000054 + -4) = argument8;\n  *(undefined4 *)((int)register0x00000054 + -8) = argument7;\n  *(undefined4 *)((int)register0x00000054 + -0xc) = argument6;\n  *(undefined4 *)((int)register0x00000054 + -0x10) = argument5;\n  *(undefined4 *)((int)register0x00000054 + -0x14) = argument4;\n  *(undefined4 *)((int)register0x00000054 + -0x18) = argument3;\n  *(undefined4 *)((int)register0x00000054 + -0x1c) = argument2;\n  *(uint32_t *)((int)register0x00000054 + -0x20) = argument;\n                    \n  hard_fault_handler(stackPointer,isCorrupted,linkRegister,(uint32_t *)((int)register0x00000054 + -0x20));\n}\n\n",
            "renaming": {
                "FUN_00000a64": "handle_stack_corruption_00000a64",
                "unaff_r4": "argument",
                "unaff_r5": "argument2",
                "unaff_r6": "argument3",
                "unaff_r7": "argument4",
                "unaff_r8": "argument5",
                "unaff_r9": "argument6",
                "unaff_r10": "argument7",
                "unaff_r11": "argument8",
                "in_lr": "linkRegister",
                "corrupted": "isCorrupted",
                "sp": "stackPointer"
            },
            "calling": [],
            "called": [
                "hard_fault_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000aa8": {
            "entrypoint": "0x00000aa8",
            "current_name": "handle_hard_fault_00000aa8",
            "code": "\n\n\nvoid handleHardFault_00000aa8(uint32_t *stackPointer,uint32_t isCorrupted,uint32_t exceptionReturn,uint32_t *r4ToR11Stack)\n\n{\n  uint cfsr;\n  undefined4 hfsr;\n  undefined4 dfsr;\n  undefined4 afsr;\n  undefined4 bfar;\n  undefined4 mmfar;\n  int stackOverflow;\n  uint32_t r0;\n  uint32_t r1;\n  uint32_t r2;\n  uint32_t r3;\n  uint32_t r12;\n  uint32_t *localR4ToR11Stack;\n  uint32_t localExceptionReturn;\n  uint32_t localIsCorrupted;\n  uint32_t *localStackPointer;\n  int remainingStackSize;\n  uint32_t psr;\n  uint32_t linkRegister;\n  uint32_t r12;\n  uint32_t r3;\n  uint32_t r2;\n  uint32_t r1;\n  uint32_t r0;\n  uint32_t afsr;\n  uint32_t dfsr;\n  uint32_t hfsr;\n  uint32_t cfsr;\n  uint32_t mmfar;\n  uint32_t bfar;\n  uint32_t *originalStackPointer;\n  uint32_t programCounter;\n  \n  mmfar = _DAT_e000ed3c;\n  bfar = _DAT_e000ed38;\n  afsr = _DAT_e000ed34;\n  dfsr = _DAT_e000ed30;\n  hfsr = _DAT_e000ed2c;\n  cfsr = _DAT_e000ed28;\n  programCounter = 0;\n  if (isr_stack._0_4_ != -0x18011802) {\n    puts(\"\\nISR stack overflowed\");\n  }\n  if (isCorrupted == 0) {\n    r0 = *stackPointer;\n    r1 = stackPointer[1];\n    r2 = stackPointer[2];\n    r3 = stackPointer[4];\n    r12 = stackPointer[5];\n    programCounter = stackPointer[6];\n    puts(\"\\nContext before hardfault:\");\n    iprintf(\"   r0: 0x%08lx\\n   r1: 0x%08lx\\n   r2: 0x%08lx\\n   r3: 0x%08lx\\n\",r0,r1,r2);\n    iprintf(\"  r12: 0x%08lx\\n   linkRegister: 0x%08lx\\n   programCounter: 0x%08lx\\n  psr: 0x%08lx\\n\\n\",r3,r12,programCounter);\n  }\n  else {\n    puts(\"Stack pointer isCorrupted, reset to top of stack\");\n  }\n  puts(\"FSR/FAR:\");\n  iprintf(\" CFSR: 0x%08lx\\n\",cfsr);\n  iprintf(\" HFSR: 0x%08lx\\n\",hfsr);\n  iprintf(\" DFSR: 0x%08lx\\n\",dfsr);\n  iprintf(\" AFSR: 0x%08lx\\n\",mmfar);\n  if ((cfsr & 0x8000) != 0) {\n    iprintf(\" BFAR: 0x%08lx\\n\",bfar);\n  }\n  if ((cfsr & 0x80) != 0) {\n    iprintf(\"MMFAR: 0x%08lx\\n\",afsr);\n  }\n  puts(\"Misc\");\n  iprintf(\"EXC_RET: 0x%08lx\\n\",exceptionReturn);\n  if (isCorrupted == 0) {\n    puts(\"Attempting to reconstruct state for debugging...\");\n    iprintf(\"In GDB:\\n  set $programCounter=0x%lx\\n  frame 0\\n  bt\\n\",programCounter);\n    stackOverflow = _stack_size_left(0x158);\n    if (stackOverflow < 0) {\n      iprintf(\"\\nISR stack overflowed by at least %d bytes.\\n\",-stackOverflow);\n    }\n  }\n  software_bkpt(1);\n                    \n  core_panic(PANIC_HARD_FAULT,\"HARD FAULT HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000aa8": "handle_hard_fault_00000aa8",
                "sp": "stackPointer",
                "corrupted": "isCorrupted",
                "exc_return": "exceptionReturn",
                "r4_to_r11_stack": "r4ToR11Stack",
                "uVar1": "cfsr",
                "uVar2": "hfsr",
                "uVar3": "dfsr",
                "uVar4": "afsr",
                "uVar5": "bfar",
                "uVar6": "mmfar",
                "iVar7": "stackOverflow",
                "uVar8": "r0",
                "uVar9": "r1",
                "uVar10": "r2",
                "uVar11": "r3",
                "uVar12": "r12",
                "r4_to_r11_stack_local": "localR4ToR11Stack",
                "exc_return_local": "localExceptionReturn",
                "corrupted_local": "localIsCorrupted",
                "sp_local": "localStackPointer",
                "stack_left": "remainingStackSize",
                "lr": "linkRegister",
                "orig_sp": "originalStackPointer",
                "pc": "programCounter"
            },
            "calling": [
                "hard_fault_default"
            ],
            "called": [
                "core_panic",
                "iprintf",
                "puts",
                "_stack_size_left"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000c80": {
            "entrypoint": "0x00000c80",
            "current_name": "handle_memory_management_00000c80",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleMemoryManagement_00000c80(void)\n\n{\n                    \n  triggerCorePanic(memoryErrorMessage,\"MEM MANAGE HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000c80": "handle_memory_management_00000c80",
                "PANIC_MEM_MANAGE": "memoryErrorMessage",
                "core_panic": "triggerCorePanic"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000c90": {
            "entrypoint": "0x00000c90",
            "current_name": "handle_bus_fault_00000c90",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleBusFault_00000c90(void)\n\n{\n                    \n  core_panic(busFaultMessage,\"BUS FAULT HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000c90": "handle_bus_fault_00000c90",
                "PANIC_BUS_FAULT": "busFaultMessage"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000ca0": {
            "entrypoint": "0x00000ca0",
            "current_name": "handle_usage_fault_00000ca0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleUsageFault_00000ca0(void)\n\n{\n                    \n  triggerPanic(usageFaultErrorCode,\"USAGE FAULT HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000ca0": "handle_usage_fault_00000ca0",
                "PANIC_USAGE_FAULT": "usageFaultErrorCode",
                "core_panic": "triggerPanic"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cb0": {
            "entrypoint": "0x00000cb0",
            "current_name": "handle_debug_monitor_00000cb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_debug_monitor_00000cb0(void)\n\n{\n                    \n  core_panic(PANIC_DEBUG_MON,\"DEBUG MON HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000cb0": "handle_debug_monitor_00000cb0"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cc0": {
            "entrypoint": "0x00000cc0",
            "current_name": "handle_dummy_00000cc0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_dummy_00000cc0(void)\n\n{\n                    \n  core_panic(dummy_handler_message,\"DUMMY HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000cc0": "handle_dummy_00000cc0",
                "PANIC_DUMMY_HANDLER": "dummy_handler_message"
            },
            "calling": [
                "dummy_handler"
            ],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cd0": {
            "entrypoint": "0x00000cd0",
            "current_name": "check_interrupts_status_00000cd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint checkInterruptsStatus_00000cd0(void)\n\n{\n  bool isPrivileged;\n  uint interruptsStatus;\n  uint32_t interruptsEnabledMask;\n  uint32_t interruptsMask;\n  \n  interruptsStatus = 0;\n  isPrivileged = (bool)isPrivilegedMode();\n  if (isPrivileged) {\n    interruptsStatus = areIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return interruptsStatus;\n}\n\n",
            "renaming": {
                "FUN_00000cd0": "check_interrupts_status_00000cd0",
                "isCurrentModePrivileged": "isPrivilegedMode",
                "isIRQinterruptsEnabled": "areIRQinterruptsEnabled",
                "uVar2": "interruptsStatus",
                "bVar1": "isPrivileged",
                "result": "interruptsEnabledMask",
                "mask": "interruptsMask"
            },
            "calling": [
                "pm_off",
                "core_panic",
                "mutex_unlock",
                "kernel_init",
                "kinetis_mcg_init",
                "thread_create",
                "_sbrk_r",
                "_mutex_lock",
                "sched_task_exit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cf0": {
            "entrypoint": "0x00000cf0",
            "current_name": "get_ir_qinterrupt_status_00000cf0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint getIRQinterruptStatus_00000cf0(void)\n\n{\n  bool isCurrentModePrivileged;\n  uint interruptsEnabled;\n  uint32_t irqStatus;\n  \n  enableIRQinterrupts();\n  interruptsEnabled = 0;\n  isCurrentModePrivileged = (bool)isCurrentModePrivileged();\n  if (isCurrentModePrivileged) {\n    interruptsEnabled = isIRQinterruptsEnabled();\n  }\n  return interruptsEnabled;\n}\n\n",
            "renaming": {
                "FUN_00000cf0": "get_ir_qinterrupt_status_00000cf0",
                "bVar1": "isCurrentModePrivileged",
                "uVar2": "interruptsEnabled",
                "result": "irqStatus"
            },
            "calling": [
                "cpu_switch_context_exit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d0c": {
            "entrypoint": "0x00000d0c",
            "current_name": "enable_interrupts_if_privileged_00000d0c",
            "code": "\nvoid enableInterruptsIfPrivileged_00000d0c(uint inputState)\n\n{\n  bool isPrivileged;\n  uint localState;\n  \n  isPrivileged = (bool)isCurrentModePrivileged();\n  if (isPrivileged) {\n    enableIRQinterrupts((inputState & 1) == 1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000d0c": "enable_interrupts_if_privileged_00000d0c",
                "state": "inputState",
                "bVar1": "isPrivileged",
                "state_local": "localState"
            },
            "calling": [
                "mutex_unlock",
                "kinetis_mcg_init",
                "thread_create",
                "_sbrk_r",
                "_mutex_lock"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d2a": {
            "entrypoint": "0x00000d2a",
            "current_name": "get_exception_number_00000d2a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint getExceptionNumber_00000d2a(void)\n\n{\n  bool isPrivilegedMode;\n  uint exceptionNumber;\n  uint32_t result;\n  \n  exceptionNumber = 0;\n  isPrivilegedMode = (bool)checkPrivilegedMode();\n  if (isPrivilegedMode) {\n    exceptionNumber = fetchCurrentExceptionNumber();\n    exceptionNumber = exceptionNumber & 0x1f;\n  }\n  return exceptionNumber;\n}\n\n",
            "renaming": {
                "FUN_00000d2a": "get_exception_number_00000d2a",
                "bVar1": "isPrivilegedMode",
                "uVar2": "exceptionNumber",
                "isCurrentModePrivileged": "checkPrivilegedMode",
                "getCurrentExceptionNumber": "fetchCurrentExceptionNumber"
            },
            "calling": [
                "sched_switch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d44": {
            "entrypoint": "0x00000d44",
            "current_name": "calculate_memory_address_00000d44",
            "code": "\nvoid * calculateMemoryAddress_00000d44(void *ptrArg,uintptrArg_t bitArg)\n\n{\n  uintptrArg_t localBit;\n  void *localPtr;\n  \n  return (void *)(bitArg * 4 + ((uint)ptrArg & 0xf0000000 | ((uint)ptrArg & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00000d44": "calculate_memory_address_00000d44",
                "ptr": "ptrArg",
                "bit": "bitArg",
                "bit_local": "localBit",
                "ptr_local": "localPtr"
            },
            "calling": [
                "bit_clear32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d76": {
            "entrypoint": "0x00000d76",
            "current_name": "clear_bit_in_ptr_00000d76",
            "code": "\nvoid clearBitInPtr_00000d76(uint32_t *ptr,uint8_t bitIndex)\n\n{\n  undefined4 *bitbandPtr;\n  uint8_t localBit;\n  uint32_t *localPtr;\n  \n  bitbandPtr = (undefined4 *)bitIndexband_addr(ptr,(uint)bitIndex);\n  *bitbandPtr = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000d76": "clear_bit_in_ptr_00000d76",
                "bit": "bitIndex",
                "bit_local": "localBit",
                "ptr_local": "localPtr",
                "puVar1": "bitbandPtr"
            },
            "calling": [
                "cpu_errata_fixes"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d9c": {
            "entrypoint": "0x00000d9c",
            "current_name": "clear_peripheral_bit_00000d9c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clear_PERIPHERAL_BIT_00000d9c(void)\n\n{\n  clear_bit_in_32bit((uint32_t *)0x40048040,'\\0');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000d9c": "clear_peripheral_bit_00000d9c",
                "bit_clear32": "clear_bit_in_32bit"
            },
            "calling": [
                "pre_startup"
            ],
            "called": [
                "bit_clear32"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000db0": {
            "entrypoint": "0x00000db0",
            "current_name": "disable_watchdog_and_fix_cpu_errata_00000db0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_watchdog_and_fix_cpu_errata_00000db0(void)\n\n{\n  wdog_disable();\n  cpu_errata_fixes();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000db0": "disable_watchdog_and_fix_cpu_errata_00000db0"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "wdog_disable",
                "cpu_errata_fixes"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000dc0": {
            "entrypoint": "0x00000dc0",
            "current_name": "initialize_default_handler_00000dc0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_default_handler_00000dc0(void)\n\n{\n  handle_default();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000dc0": "initialize_default_handler_00000dc0",
                "dummy_handler_default": "handle_default"
            },
            "calling": [],
            "called": [
                "dummy_handler_default"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000dcc": {
            "entrypoint": "0x00000dcc",
            "current_name": "initialize_registers_00000dcc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeRegisters_00000dcc(void)\n\n{\n  _DAT_4005200e = 0xd928;\n  _DAT_40052000 = 0xd2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000dcc": "initialize_registers_00000dcc"
            },
            "calling": [
                "pre_startup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000df4": {
            "entrypoint": "0x00000df4",
            "current_name": "initialize_uart_interface_00000df4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_uart_interface_00000df4(void)\n\n{\n  initialize_uart(0,0x1c200,write_callback + 1,&uart_input_buffer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000df4": "initialize_uart_interface_00000df4",
                "uart_init": "initialize_uart",
                "isrpipe_write_one": "write_callback",
                "uart_stdio_isrpipe": "uart_input_buffer"
            },
            "calling": [
                "_init"
            ],
            "called": [
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e14": {
            "entrypoint": "0x00000e14",
            "current_name": "read_data_from_uart_00000e14",
            "code": "\nint readDataFromUart_00000e14(char *dataBuffer,int dataCount)\n\n{\n  int readResult;\n  int localDataCount;\n  char *localDataBuffer;\n  \n  readResult = isrpipe_read(&uart_stdio_isrpipe,dataBuffer,dataCount);\n  return readResult;\n}\n\n",
            "renaming": {
                "FUN_00000e14": "read_data_from_uart_00000e14",
                "buffer": "dataBuffer",
                "count": "dataCount",
                "iVar1": "readResult",
                "count_local": "localDataCount",
                "buffer_local": "localDataBuffer"
            },
            "calling": [
                "_read_r"
            ],
            "called": [
                "isrpipe_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e38": {
            "entrypoint": "0x00000e38",
            "current_name": "write_buffer_to_uart_00000e38",
            "code": "\nint writeBufferToUART_00000e38(char *inputBuffer,int bufferLength)\n\n{\n  int localLength;\n  char *localBuffer;\n  \n  uart_write(0,(uint8_t *)inputBuffer,bufferLength);\n  return bufferLength;\n}\n\n",
            "renaming": {
                "FUN_00000e38": "write_buffer_to_uart_00000e38",
                "buffer": "inputBuffer",
                "len": "bufferLength",
                "len_local": "localLength",
                "buffer_local": "localBuffer"
            },
            "calling": [
                "_write_r"
            ],
            "called": [
                "uart_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e58": {
            "entrypoint": "0x00000e58",
            "current_name": "disable_interrupts_00000e58",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disableInterrupts_00000e58(void)\n\n{\n  disableIRQ();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00000e58": "disable_interrupts_00000e58",
                "irq_disable": "disableIRQ"
            },
            "calling": [
                "core_panic"
            ],
            "called": [
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e64": {
            "entrypoint": "0x00000e64",
            "current_name": "initialize_gpio_00000e64",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_GPIO_00000e64(void)\n\n{\n  _DAT_40048038 = _DAT_40048038 | 0x200;\n  _DAT_40049048 = _DAT_40049048 & 0xfefff8ff;\n  initialize_cpu();\n  initialize_gpio_pin(0x2056,GPIO_OUT);\n  initialize_gpio_pin(0x511a,GPIO_OUT);\n  initialize_gpio_pin(0x2055,GPIO_OUT);\n  set_gpio_pin(0x2056);\n  set_gpio_pin(0x511a);\n  set_gpio_pin(0x2055);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000e64": "initialize_gpio_00000e64",
                "cpu_init": "initialize_cpu",
                "gpio_init": "initialize_gpio_pin",
                "gpio_set": "set_gpio_pin"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "gpio_set",
                "cpu_init",
                "gpio_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000ed8": {
            "entrypoint": "0x00000ed8",
            "current_name": "print_lr_address_00000ed8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid print_LR_address_00000ed8(void)\n\n{\n  undefined4 input_LR;\n  uint32_t *LR_pointer;\n  \n  iprintf(\"%p\\n\",input_LR);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000ed8": "print_lr_address_00000ed8",
                "in_lr": "input_LR",
                "lr_ptr": "LR_pointer"
            },
            "calling": [
                "core_panic"
            ],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000ef8": {
            "entrypoint": "0x00000ef8",
            "current_name": "FUNC_00000ef8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000ef8": "FUNC_00000ef8"
            },
            "calling": [
                "core_panic"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00000f04": {
            "entrypoint": "0x00000f04",
            "current_name": "handle_kernel_panic_00000f04",
            "code": "\nvoid handleKernelPanic_00000f04(core_panic_t error_code,char *panic_message)\n\n{\n  undefined4 uStack_18;\n  undefined4 uStack_14;\n  char *local_message;\n  core_panic_t local_error_code;\n  \n  local_message = panic_message;\n  local_error_code = error_code;\n  if (crashed == 0) {\n    crashed = 1;\n    if (error_code == PANIC_ASSERT_FAIL) {\n      cpu_print_last_instruction();\n    }\n    iprintf(\"*** RIOT kernel panic:\\n%s\\n\\n\",local_message);\n    ps();\n    iprintf(\"\\n\");\n    iprintf(\"*** halted.\\n\\n\");\n  }\n  irq_disable();\n  panic_arch();\n  uStack_14 = 0xf4d;\n  pm_off();\n  uStack_18 = (int)&uStack_18 + 1;\n  auto_init();\n  iprintf(\"main(): This is RIOT! (Version: 2018.04-vm-HEAD)\\n\");\n  main();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000f04": "handle_kernel_panic_00000f04",
                "crash_code": "error_code",
                "message": "panic_message",
                "message_local": "local_message",
                "crash_code_local": "local_error_code"
            },
            "calling": [
                "debug_mon_default",
                "uart_init",
                "hard_fault_handler",
                "thread_add_to_list",
                "usage_fault_default",
                "bus_fault_default",
                "fmt_s32_dfp",
                "nmi_default",
                "mem_manage_default",
                "cib_init",
                "dummy_handler_default"
            ],
            "called": [
                "pm_off",
                "ps",
                "panic_arch",
                "cpu_print_last_instruction",
                "iprintf",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000f5c": {
            "entrypoint": "0x00000f5c",
            "current_name": "initialize_00000f5c",
            "code": "\nvoid * initialize_00000f5c(void *arg)\n\n{\n  void *local_arg;\n  \n  initialize_00000f5c_auto();\n  print_message(\"main(): This is RIOT! (Version: 2018.04-vm-HEAD)\\n\");\n  main();\n  return (void *)0x0;\n}\n\n",
            "renaming": {
                "FUN_00000f5c": "initialize_00000f5c",
                "arg_local": "local_arg",
                "auto_init": "initialize_auto",
                "iprintf": "print_message"
            },
            "calling": [],
            "called": [
                "auto_init",
                "iprintf",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000f80": {
            "entrypoint": "0x00000f80",
            "current_name": "infinite_loop_00000f80",
            "code": "\nvoid * infiniteLoop_00000f80(void *arg_local)\n\n{\n  void *arg_local_local;\n  \n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00000f80": "infinite_loop_00000f80",
                "arg": "arg_local"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000f8c": {
            "entrypoint": "0x00000f8c",
            "current_name": "initialize_system_00000f8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_system_00000f8c(void)\n\n{\n  irq_disable();\n  thread_create(idle_stack_pointer,0x100,'\\x0f',0xc,idle_thread_function + 1,(void *)0x0,idle_thread_name);\n  thread_create(main_stack_pointer,0x600,'\\a',0xc,main_trampoline_function + 1,(void *)0x0,main_thread_name);\n                    \n  cpu_switch_context_exit();\n}\n\n",
            "renaming": {
                "FUN_00000f8c": "initialize_system_00000f8c",
                "idle_stack": "idle_stack_pointer",
                "main_stack": "main_stack_pointer",
                "idle_thread": "idle_thread_function",
                "main_trampoline": "main_trampoline_function",
                "idle_name": "idle_thread_name",
                "main_name": "main_thread_name"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "cpu_switch_context_exit",
                "thread_create",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000fec": {
            "entrypoint": "0x00000fec",
            "current_name": "initialize_circular_buffer_00000fec",
            "code": "\nvoid initializeCircularBuffer_00000fec(circularBuffer_t *circularBuffer,uint bufferSize)\n\n{\n  uint localBufferSize;\n  circularBuffer_t *localCircularBuffer;\n  circularBuffer_t c;\n  \n  if ((bufferSize & bufferSize - 1) != 0) {\n                    \n    core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n  }\n  circularBuffer->read_count = 0;\n  circularBuffer->write_count = 0;\n  circularBuffer->mask = bufferSize - 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000fec": "initialize_circular_buffer_00000fec",
                "cib": "circularBuffer",
                "size": "bufferSize",
                "size_local": "localBufferSize",
                "cib_local": "localCircularBuffer"
            },
            "calling": [
                "thread_create"
            ],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001034": {
            "entrypoint": "0x00001034",
            "current_name": "insert_thread_into_list_00001034",
            "code": "\nvoid insertThreadIntoList_00001034(threadList_node_t *threadList,currentThread_t *currentThread)\n\n{\n  currentThread_t *currentListThread;\n  threadList_node_t *currentListNode;\n  currentThread_t *threadInList;\n  cthreadList_node_t *unusedPtr;\n  threadList_node_t *newThreadNode;\n  uint16_t currentThreadPriority;\n  \n  if (currentThread->status < 9) {\n    currentListNode = threadList;\n    while ((currentListNode->next != (threadList_node *)0x0 &&\n           (*(byte *)((int)&currentListNode->next[-1].next + 1) <= currentThread->priority))) {\n      currentListNode = currentListNode->next;\n    }\n    (currentThread->rq_entry).next = currentListNode->next;\n    currentListNode->next = &currentThread->rq_entry;\n    return;\n  }\n                    \n  core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n}\n\n",
            "renaming": {
                "FUN_00001034": "insert_thread_into_list_00001034",
                "list": "threadList",
                "thread": "currentThread",
                "thread_local": "currentListThread",
                "list_local": "currentListNode",
                "list_entry": "threadInList",
                "__m____": "unusedPtr",
                "new_node": "newThreadNode",
                "my_prio": "currentThreadPriority"
            },
            "calling": [
                "_mutex_lock"
            ],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000010a0": {
            "entrypoint": "0x000010a0",
            "current_name": "calculate_stack_space_000010a0",
            "code": "\nuintptr_t calculate_stack_space_000010a0(char *stack_data)\n\n{\n  char *local_stack_ptr;\n  uintptr_t free_stack_space;\n  uintptr_t *stack_ptr;\n  \n  for (stack_ptr = (uintptr_t *)stack_data; (uintptr_t *)*stack_ptr == stack_ptr; stack_ptr = stack_ptr + 1) {\n  }\n  return (int)stack_ptr - (int)stack_data;\n}\n\n",
            "renaming": {
                "FUN_000010a0": "calculate_stack_space_000010a0",
                "stack": "stack_data",
                "stack_local": "local_stack_ptr",
                "space_free": "free_stack_space",
                "stackp": "stack_ptr"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000010d4": {
            "entrypoint": "0x000010d4",
            "current_name": "create_thread_000010d4",
            "code": "\nkernel_threadID_t\ncreateThread_000010d4(char *stackBuffer,iterationnt stackBufferSize,char threadPriority,iterationnt threadFlags,threadTaskFunc_t threadFunction,voiterationd *threadArgument\n            ,char *threadName)\n\n{\n  uiterationnt previousState;\n  char *pointerVar1;\n  iterationnt intVar2;\n  uiterationnt adjustedStackSize;\n  threadStruct *newThread;\n  iterationnt localThreadFlags;\n  char localThreadPriority;\n  iterationnt localStackSize;\n  char *localStackBuffer;\n  uiterationnt threadState;\n  uiterationntptr_t *stackBoundary;\n  threadStruct *cb;\n  uiterationntptr_t stackMisalignment;\n  iterationnt totalStackSize;\n  uiterationntptr_t *currentStackPointer;\n  kernel_threadID_t iteration;\n  kernel_threadID_t threadID;\n  \n  iterationf ((byte)threadPriority < 0x10) {\n    localStackSize = stackBufferSize;\n    localStackBuffer = stackBuffer;\n    iterationf (((uiterationnt)stackBuffer & 3) != 0) {\n      intVar2 = 4 - ((uiterationnt)stackBuffer & 3);\n      localStackBuffer = stackBuffer + intVar2;\n      localStackSize = stackBufferSize - intVar2;\n    }\n    adjustedStackSize = localStackSize - 0x30U & 0xfffffffc;\n    newThread = (threadStruct *)(localStackBuffer + adjustedStackSize);\n    iterationf ((threadFlags & 8U) == 0) {\n      *(char **)localStackBuffer = localStackBuffer;\n    }\n    else {\n      for (currentStackPointer = (uiterationntptr_t *)localStackBuffer; currentStackPointer < localStackBuffer + adjustedStackSize; currentStackPointer = currentStackPointer + 1\n          ) {\n        *currentStackPointer = (uiterationntptr_t)currentStackPointer;\n      }\n    }\n    previousState = disableInterrupt();\n    threadID = 0;\n    for (iteration = 1; iteration < 0x21; iteration = iteration + 1) {\n      iterationf (schedulerThreads[iteration] == (threadStruct *)0x0) {\n        threadID = iteration;\n        break;\n      }\n    }\n    iterationf (threadID == 0) {\n      restoreInterrupt(previousState);\n      threadID = -0x8b;\n    }\n    else {\n      schedulerThreads[threadID] = newThread;\n      newThread->threadID = threadID;\n      pointerVar1 = thread_stackBuffer_iterationniterationt(threadFunction,threadArgument,localStackBuffer,adjustedStackSize);\n      newThread->sp = pointerVar1;\n      newThread->stackBuffer_start = localStackBuffer;\n      newThread->adjustedStackSize = stackBufferSize;\n      newThread->threadName = threadName;\n      newThread->threadPriority = threadPriority;\n      newThread->status = '\\0';\n      (newThread->rq_entry).next = (listNode *)0x0;\n      newThread->waiterationt_data = (voiterationd *)0x0;\n      (newThread->msg_waiterationters).next = (listNode *)0x0;\n      initMessageQueue(&newThread->messageQueue,0);\n      newThread->messageArray = (messageType *)0x0;\n      schedulerNumThreads = schedulerNumThreads + 1;\n      iterationf ((threadFlags & 1U) == 0) {\n        setThreadStatus(newThread,10);\n        iterationf ((threadFlags & 4U) == 0) {\n          restoreInterrupt(previousState);\n          switchThread((unsignedShort)(byte)threadPriority);\n          return threadID;\n        }\n      }\n      else {\n        setThreadStatus(newThread,1);\n      }\n      restoreInterrupt(previousState);\n    }\n  }\n  else {\n    threadID = -0x16;\n  }\n  return threadID;\n}\n\n",
            "renaming": {
                "FUN_000010d4": "create_thread_000010d4",
                "stack": "stackBuffer",
                "stacksize": "stackBufferSize",
                "priority": "threadPriority",
                "flags": "threadFlags",
                "function": "threadFunction",
                "arg": "threadArgument",
                "name": "threadName",
                "state_00": "previousState",
                "pcVar1": "pointerVar1",
                "iVar2": "intVar2",
                "stack_size": "adjustedStackSize",
                "process": "newThread",
                "flags_local": "localThreadFlags",
                "priority_local": "localThreadPriority",
                "stacksize_local": "localStackSize",
                "stack_local": "localStackBuffer",
                "state": "threadState",
                "stackmax": "stackBoundary",
                "misalignment": "stackMisalignment",
                "total_stacksize": "totalStackSize",
                "stackp": "currentStackPointer",
                "i": "iteration",
                "pid": "threadID",
                "sched_threads": "schedulerThreads",
                "sched_num_threads": "schedulerNumThreads",
                "sched_set_status": "setThreadStatus",
                "sched_switch": "switchThread",
                "msg_t": "messageType",
                "cib_init": "initMessageQueue",
                "msg_queue": "messageQueue",
                "msg_array": "messageArray",
                "thread_t": "threadStruct",
                "thread_task_func_t": "threadTaskFunc_t",
                "irq_disable": "disableInterrupt",
                "irq_restore": "restoreInterrupt",
                "list_node": "listNode",
                "ushort": "unsignedShort"
            },
            "calling": [
                "kernel_init"
            ],
            "called": [
                "irq_restore",
                "sched_set_status",
                "sched_switch",
                "cib_init",
                "irq_disable",
                "thread_stack_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001274": {
            "entrypoint": "0x00001274",
            "current_name": "initialize_system_00001274",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_system_00001274(void)\n\n{\n  cortexm_init();\n  DAT_4007e000 = DAT_4007e000 | 0x28;\n  kinetis_mcg_init();\n  periph_init();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001274": "initialize_system_00001274"
            },
            "calling": [
                "board_init"
            ],
            "called": [
                "kinetis_mcg_init",
                "periph_init",
                "cortexm_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000129c": {
            "entrypoint": "0x0000129c",
            "current_name": "lock_mutex_0000129c",
            "code": "\nvoid lockMutex_0000129c(mutexPtr_t *mutexPtr)\n\n{\n  mutexPtr_t *localMutexPtr;\n  \n  _mutexPtr_lock(mutexPtr,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000129c": "lock_mutex_0000129c",
                "mutex": "mutexPtr",
                "mutex_local": "localMutexPtr"
            },
            "calling": [
                "isrpipe_read"
            ],
            "called": [
                "_mutex_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000012b4": {
            "entrypoint": "0x000012b4",
            "current_name": "add_character_to_isr_pipe_000012b4",
            "code": "\nint addCharacterToISRPipe_000012b4(pipe_t *pipe,char c)\n\n{\n  int returnCode;\n  char localCharacter;\n  pipe_t *localPipe;\n  int result;\n  \n  returnCode = tsrb_add_one(&pipe->tsrb,c);\n  mutex_unlock(&pipe->mutex);\n  return returnCode;\n}\n\n",
            "renaming": {
                "FUN_000012b4": "add_character_to_isr_pipe_000012b4",
                "isrpipe": "pipe",
                "c_local": "localCharacter",
                "isrpipe_local": "localPipe",
                "res": "result",
                "iVar1": "returnCode"
            },
            "calling": [],
            "called": [
                "mutex_unlock",
                "tsrb_add_one"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000012e2": {
            "entrypoint": "0x000012e2",
            "current_name": "read_isrpipe_000012e2",
            "code": "\nint read_isrpipe_000012e2(input_isrpipe_t *input_isrpipe,char *output_buffer,size_t buffer_size)\n\n{\n  int iVar1;\n  size_t local_buffer_size;\n  char *local_buffer;\n  input_isrpipe_t *local_isrpipe;\n  int result;\n  \n  while( true ) {\n    iVar1 = tsrb_get(&input_isrpipe->tsrb,output_buffer,buffer_size);\n    if (iVar1 != 0) break;\n    mutex_lock(&input_isrpipe->mutex);\n  }\n  return iVar1;\n}\n\n",
            "renaming": {
                "FUN_000012e2": "read_isrpipe_000012e2",
                "isrpipe": "input_isrpipe",
                "buffer": "output_buffer",
                "count": "buffer_size",
                "count_local": "local_buffer_size",
                "buffer_local": "local_buffer",
                "isrpipe_local": "local_isrpipe",
                "res": "result"
            },
            "calling": [
                "uart_stdio_read"
            ],
            "called": [
                "tsrb_get",
                "mutex_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001318": {
            "entrypoint": "0x00001318",
            "current_name": "set_interrupt_enable_00001318",
            "code": "\nvoid setInterruptEnable_00001318(interruptNumber_Type interruptNumber)\n\n{\n  interruptNumber_Type localInterruptNumber;\n  \n  *(int *)(((uint)(int)interruptNumber >> 5) * 4 + -0x1fff1f00) = 1 << (interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001318": "set_interrupt_enable_00001318",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "uart_init_uart"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001348": {
            "entrypoint": "0x00001348",
            "current_name": "check_and_yield_00001348",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid check_and_yield_00001348(void)\n\n{\n  if (switch_request != 0) {\n    yield_higher();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001348": "check_and_yield_00001348",
                "sched_context_switch_request": "switch_request",
                "thread_yield_higher": "yield_higher"
            },
            "calling": [
                "irq_handler_uart"
            ],
            "called": [
                "thread_yield_higher"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001360": {
            "entrypoint": "0x00001360",
            "current_name": "calculate_offset_00001360",
            "code": "\nvoid * calculateOffset_00001360(void *originalPointer,uintoriginalPointer_t bitOffset)\n\n{\n  uintoriginalPointer_t localBitOffset;\n  void *localPointer;\n  \n  return (void *)(bitOffset * 4 + ((uint)originalPointer & 0xf0000000 | ((uint)originalPointer & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00001360": "calculate_offset_00001360",
                "ptr": "originalPointer",
                "bit": "bitOffset",
                "bit_local": "localBitOffset",
                "ptr_local": "localPointer"
            },
            "calling": [
                "bit_set32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001392": {
            "entrypoint": "0x00001392",
            "current_name": "set_bit_in_pointer_00001392",
            "code": "\nvoid setBitInPointer_00001392(uint32_t *ptr,uint8_t bit)\n\n{\n  undefined4 *bitPointer;\n  uint8_t bit_local;\n  uint32_t *ptr_local;\n  \n  bitPointer = (undefined4 *)bitband_addr(ptr,(uint)bit);\n  *bitPointer = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001392": "set_bit_in_pointer_00001392",
                "puVar1": "bitPointer"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000013b8": {
            "entrypoint": "0x000013b8",
            "current_name": "initialize_uart_000013b8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0000142e) */\n\nint initialize_uart_000013b8(uart_instance_t uart_instance,uint32_t desired_baudrate,uart_instance_receive_callback_t receive_callback,void *callback_arg)\n\n{\n  void *local_arg;\n  uart_instance_receive_callback_t local_rx_cb;\n  uint32_t local_baudrate;\n  uart_instance_t local_uart;\n  \n  if (uart_instance == 0) {\n    config[0].receive_callback = receive_callback;\n    config[0].callback_arg = callback_arg;\n    uart_instance_init_pins(0);\n    bit_set32((uint32_t *)&DAT_40048034,'\\n');\n    uart_instance_init_uart_instance(0,desired_baudrate);\n    return 0;\n  }\n                    \n  core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n}\n\n",
            "renaming": {
                "FUN_000013b8": "initialize_uart_000013b8",
                "uart": "uart_instance",
                "baudrate": "desired_baudrate",
                "rx_cb": "receive_callback",
                "arg": "callback_arg",
                "arg_local": "local_arg",
                "rx_cb_local": "local_rx_cb",
                "baudrate_local": "local_baudrate",
                "uart_local": "local_uart"
            },
            "calling": [
                "uart_stdio_init"
            ],
            "called": [
                "uart_init_uart",
                "core_panic",
                "uart_init_pins",
                "bit_set32"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001448": {
            "entrypoint": "0x00001448",
            "current_name": "initialize_uart_00001448",
            "code": "\nvoid initialize_uart_00001448(selected_uart_t selected_uart)\n\n{\n  selected_uart_t local_uart;\n  \n  if (configurations[selected_uart].rx_pin != 0xffff) {\n    gpio_init_port(configurations[selected_uart].rx_pin,configurations[selected_uart].rx_pcr);\n  }\n  if (configurations[selected_uart].tx_pin != 0xffff) {\n    gpio_init_port(configurations[selected_uart].tx_pin,configurations[selected_uart].tx_pcr);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001448": "initialize_uart_00001448",
                "uart": "selected_uart",
                "uart_local": "local_uart",
                "uart_config": "configurations",
                "pin_rx": "rx_pin",
                "pcr_rx": "rx_pcr",
                "pin_tx": "tx_pin",
                "pcr_tx": "tx_pcr"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "gpio_init_port"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000014c4": {
            "entrypoint": "0x000014c4",
            "current_name": "configure_uart_000014c4",
            "code": "\nvoid configureUART_000014c4(uartType_t uartType,uint32_t baudrateValue)\n\n{\n  byte *uartDevPtr;\n  uint uartFreq;\n  uint baudrateDiv;\n  uint32_t baudrateLocal;\n  uartType_t uartLocal;\n  uint8_t txFifoSize;\n  uint8_t brfaValue;\n  uint16_t ubdValue;\n  uint32_t clkValue;\n  UART_Type *uartDevice;\n  \n  uartDevPtr = (byte *)uartType_config[uartType].uartDevice;\n  uartFreq = uartType_config[uartType].freq;\n  uartDevPtr[3] = uartDevPtr[3] & 0xf3;\n  uartDevPtr[2] = uartType_config[uartType].mode;\n  baudrateDiv = uartFreq / (baudrateValue << 4);\n  *uartDevPtr = (byte)(baudrateDiv >> 8) & 0x1f;\n  uartDevPtr[1] = (byte)baudrateDiv;\n  uartDevPtr[10] = (byte)((uartFreq << 2) / baudrateValue + 1 >> 1) & 0x1f;\n  uartDevPtr[0x10] = uartDevPtr[0x10] | 0x88;\n  if ((uartDevPtr[0x10] & 0x70) == 0) {\n    uartDevPtr[0x13] = 0;\n  }\n  else {\n    uartDevPtr[0x13] = (char)(2 << (uartDevPtr[0x10] >> 4 & 7)) - 1;\n  }\n  uartDevPtr[0x15] = 1;\n  uartDevPtr[0x11] = 0xc0;\n  uartDevPtr[3] = uartDevPtr[3] | 0x2c;\n  NVIC_EnableIRQ(uartType_config[uartType].irqn);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000014c4": "configure_uart_000014c4",
                "uart": "uartType",
                "baudrate": "baudrateValue",
                "pbVar1": "uartDevPtr",
                "uVar2": "uartFreq",
                "uVar3": "baudrateDiv",
                "baudrate_local": "baudrateLocal",
                "uart_local": "uartLocal",
                "txfifo_size": "txFifoSize",
                "brfa": "brfaValue",
                "ubd": "ubdValue",
                "clk": "clkValue",
                "dev": "uartDevice"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "NVIC_EnableIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000015d0": {
            "entrypoint": "0x000015d0",
            "current_name": "copy_data_to_uart_000015d0",
            "code": "\nvoindexd copyDataToUart_000015d0(uartPort_t uartPort,uindexnt8_t *sourceData,sindexze_t dataLength)\n\n{\n  voindexd *pvVar1;\n  sindexze_t localDataLength;\n  uindexnt8_t *localSourceData;\n  uartPort_t localUartPort;\n  UART_Type *uartDevice;\n  sindexze_t index;\n  \n  pvVar1 = uartPort_confindexg[uartPort].uartDevice;\n  for (index = 0; index < dataLength; index = index + 1) {\n    do {\n    } whindexle (-1 < *(char *)((indexnt)pvVar1 + 4));\n    *(uindexnt8_t *)((indexnt)pvVar1 + 7) = sourceData[index];\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000015d0": "copy_data_to_uart_000015d0",
                "uart": "uartPort",
                "data": "sourceData",
                "len": "dataLength",
                "len_local": "localDataLength",
                "data_local": "localSourceData",
                "uart_local": "localUartPort",
                "dev": "uartDevice",
                "i": "index"
            },
            "calling": [
                "uart_stdio_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001628": {
            "entrypoint": "0x00001628",
            "current_name": "handle_received_data_00001628",
            "code": "\nvoid handleReceivedData_00001628(uartInstance_t uartInstance)\n\n{\n  uartInstance_t localUartInstance;\n  uint8_t receivedData;\n  UART_Type *uartDevice;\n  \n  if (((*(byte *)((int)uartInstance_config[uartInstance].uartDevice + 4) & 0x20) != 0) &&\n     (config[uartInstance].rx_cb != (uartInstance_rx_cb_t)0x0)) {\n    (*config[uartInstance].rx_cb)(config[uartInstance].arg,*(uint8_t *)((int)uartInstance_config[uartInstance].uartDevice + 7));\n  }\n  cortexm_isr_end();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001628": "handle_received_data_00001628",
                "uart": "uartInstance",
                "uart_local": "localUartInstance",
                "data": "receivedData",
                "dev": "uartDevice"
            },
            "calling": [
                "isr_uart0_rx_tx"
            ],
            "called": [
                "cortexm_isr_end"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001688": {
            "entrypoint": "0x00001688",
            "current_name": "initialize_uart_irq_handler_00001688",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_uart_irq_handler_00001688(void)\n\n{\n  irq_handler_uart(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001688": "initialize_uart_irq_handler_00001688"
            },
            "calling": [],
            "called": [
                "irq_handler_uart"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001696": {
            "entrypoint": "0x00001696",
            "current_name": "calculate_memory_address_00001696",
            "code": "\nvoid * calculateMemoryAddress_00001696(void *ptr,uintptr_t bit)\n\n{\n  uintptr_t bitValue;\n  void *inputValue;\n  \n  return (void *)(bit * 4 + ((uint)ptr & 0xf0000000 | ((uint)ptr & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00001696": "calculate_memory_address_00001696",
                "bit_local": "bitValue",
                "ptr_local": "inputValue"
            },
            "calling": [
                "bit_clear8",
                "bit_set8",
                "bit_set32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000016c8": {
            "entrypoint": "0x000016c8",
            "current_name": "set_bit_000016c8",
            "code": "\nvoid setBit_000016c8(uint32_t *ptr,uint8_t bit)\n\n{\n  undefined4 *puVar1;\n  uint8_t setBit_000016c8_local;\n  uint32_t *ptr_local;\n  \n  puVar1 = (undefined4 *)bitband_addr(ptr,(uint)bit);\n  *puVar1 = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000016c8": "set_bit_000016c8",
                "bit_local": "setBit_local"
            },
            "calling": [
                "kinetis_mcg_init_erclk32k"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000016ec": {
            "entrypoint": "0x000016ec",
            "current_name": "set_bit_to1_000016ec",
            "code": "\nvoid setBitTo1_000016ec(uint8_t *ptr_buffer,uint8_t bit_position)\n\n{\n  undefined *puVar1;\n  uint8_t bit_value;\n  uint8_t *processed_ptr;\n  \n  puVar1 = (undefined *)bit_positionband_addr(ptr_buffer,(uint)bit_position);\n  *puVar1 = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000016ec": "set_bit_to1_000016ec",
                "ptr": "ptr_buffer",
                "bit": "bit_position",
                "bit_local": "bit_value",
                "ptr_local": "processed_ptr"
            },
            "calling": [
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_blpi",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_blpe"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001710": {
            "entrypoint": "0x00001710",
            "current_name": "clear_bit_00001710",
            "code": "\nvoid clearBit_00001710(uint8_t *ptr,uint8_t bit)\n\n{\n  undefined *puVar1;\n  uint8_t bit_local;\n  uint8_t *ptr_local;\n  \n  puVar1 = (undefined *)bitband_addr(ptr,(uint)bit);\n  *puVar1 = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001710": "clear_bit_00001710"
            },
            "calling": [
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_disable_pll"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001734": {
            "entrypoint": "0x00001734",
            "current_name": "clear_bit_in_memory_address_00001734",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearBitInMemoryAddress_00001734(void)\n\n{\n  bit_clear8(&DAT_40064005,'\\x06');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001734": "clear_bit_in_memory_address_00001734"
            },
            "calling": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_blpi",
                "kinetis_mcg_set_blpe"
            ],
            "called": [
                "bit_clear8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001748": {
            "entrypoint": "0x00001748",
            "current_name": "update_fll_factor_00001748",
            "code": "\nvoid updateFLLFactor_00001748(kinetis_mcg_fll_t newFactor)\n\n{\n  kinetis_mcg_fll_t localFactor;\n  \n  DAT_40064003 = newFactor | DAT_40064003 & ~KINETIS_MCG_FLL_FACTOR_2929;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001748": "update_fll_factor_00001748",
                "factor": "newFactor",
                "factor_local": "localFactor"
            },
            "calling": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_safe_mode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001778": {
            "entrypoint": "0x00001778",
            "current_name": "set_bits_and_clear_bit_00001778",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0000179c) */\n/* WARNING: Removing unreachable block (ram,0x000017b2) */\n/* WARNING: Removing unreachable block (ram,0x000017c0) */\n/* WARNING: Unknown calling convention */\n\nvoid set_bits_and_clear_bit_00001778(void)\n\n{\n  DAT_40064001 = DAT_40064001 & 0xcf | 0x20;\n  bit_clear8(&DAT_40064001,'\\x02');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001778": "set_bits_and_clear_bit_00001778"
            },
            "calling": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fee"
            ],
            "called": [
                "bit_clear8",
                "bit_set8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000017dc": {
            "entrypoint": "0x000017dc",
            "current_name": "initialize_data_000017dc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeData_000017dc(void)\n\n{\n  bit_set32((uint32_t *)&DAT_4004803c,'\\x1d');\n  if ((_DAT_4003d010 & 0x100) == 0) {\n    _DAT_4003d010 = 0x104;\n  }\n  _DAT_40047000 = _DAT_40047000 & 0xfff3ffff | 0x80000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000017dc": "initialize_data_000017dc"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "bit_set32"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000182c": {
            "entrypoint": "0x0000182c",
            "current_name": "clear_flags_0000182c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0000187c) */\n/* WARNING: Removing unreachable block (ram,0x0000186a) */\n/* WARNING: Removing unreachable block (ram,0x00001898) */\n/* WARNING: Unknown calling convention */\n\nvoid clearFlags_0000182c(void)\n\n{\n  uint8_t temporary;\n  \n  DAT_40064008 = DAT_40064008 & 0xd0;\n  bit_set8(&DAT_40064001,'\\0');\n  bit_clear8(&DAT_40064000,'\\x01');\n  bit_clear8(&DAT_40064000,'\\0');\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000182c": "clear_flags_0000182c",
                "tmp": "temporary"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "bit_clear8",
                "bit_set8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000018bc": {
            "entrypoint": "0x000018bc",
            "current_name": "initialize_fll_000018bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeFLL_000018bc(void)\n\n{\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_1464);\n  DAT_40064000 = DAT_40064000 & 0x3b | 4;\n  bit_clear8(&DAT_40064001,'\\x01');\n  do {\n  } while ((DAT_40064006 & 0x10) == 0);\n  do {\n  } while ((DAT_40064006 & 0xc) != 0);\n  mcgMode = KINETIS_MCG_MODE_FEI;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000018bc": "initialize_fll_000018bc",
                "current_mode": "mcgMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000191c": {
            "entrypoint": "0x0000191c",
            "current_name": "initialize_fee_mode_0000191c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeFEEMode_0000191c(void)\n\n{\n  kinetis_mcg_enable_osc();\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_1920);\n  DAT_40064000 = DAT_40064000 & 0x3b;\n  do {\n  } while ((DAT_40064006 & 0xc) != 0);\n  current_mode = KINETIS_MCG_MODE_FEE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000191c": "initialize_fee_mode_0000191c"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001960": {
            "entrypoint": "0x00001960",
            "current_name": "initialize_clock_system_00001960",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeClockSystem_00001960(void)\n\n{\n  kinetis_mcg_set_fll_factor(FLL_FACTOR_1464);\n  bit_clear8(&DAT_40064001,'\\x01');\n  DAT_40064000 = DAT_40064000 & 0x3b | 0x44;\n  do {\n  } while ((DAT_40064006 & 0xc) != 4);\n  do {\n  } while ((DAT_40064006 & 0x10) == 0);\n  currentMode = KINETIS_MCG_MODE_FBI;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001960": "initialize_clock_system_00001960",
                "KINETIS_MCG_FLL_FACTOR_1464": "FLL_FACTOR_1464",
                "current_mode": "currentMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000019c0": {
            "entrypoint": "0x000019c0",
            "current_name": "initialize_system_000019c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_000019c0(void)\n\n{\n  enableOscillator();\n  setFllFactor(KINETIS_MCG_FLL_FACTOR_1920);\n  clearBit8(&DAT_40064001,'\\x01');\n  DAT_40064000 = DAT_40064000 & 0x3b | 0x80;\n  do {\n  } while ((DAT_40064006 & 0xc) != 8);\n  disablePll();\n  systemMode = KINETIS_MCG_MODE_FBE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000019c0": "initialize_system_000019c0",
                "kinetis_mcg_enable_osc": "enableOscillator",
                "kinetis_mcg_set_fll_factor": "setFllFactor",
                "bit_clear8": "clearBit8",
                "kinetis_mcg_disable_pll": "disablePll",
                "current_mode": "systemMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_fll_factor",
                "kinetis_mcg_disable_pll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001a18": {
            "entrypoint": "0x00001a18",
            "current_name": "initialize_mcg_00001a18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeMCG_00001a18(void)\n\n{\n  bit_set8(&DAT_40064001,'\\x01');\n  disableMCGPll();\n  mcgMode = KINETIS_MCG_MODE_BLPI;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001a18": "initialize_mcg_00001a18",
                "kinetis_mcg_disable_pll": "disableMCGPll",
                "current_mode": "mcgMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001a3c": {
            "entrypoint": "0x00001a3c",
            "current_name": "set_mode_to_bootloader_00001a3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_mode_to_bootloader_00001a3c(void)\n\n{\n  bit_set8(&DAT_40064001,'\\x01');\n  disable_pll();\n  mcg_mode = KINETIS_MCG_MODE_BLPE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001a3c": "set_mode_to_bootloader_00001a3c",
                "kinetis_mcg_disable_pll": "disable_pll",
                "current_mode": "mcg_mode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001a60": {
            "entrypoint": "0x00001a60",
            "current_name": "initialize_clock_00001a60",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeClock_00001a60(void)\n\n{\n  bit_clear8(&DAT_40064001,'\\x01');\n  DAT_40064000 = DAT_40064000 & 0x3f | 0x80;\n  do {\n  } while ((DAT_40064006 & 0xc) != 8);\n  bit_set8(&DAT_40064005,'\\x06');\n  do {\n  } while ((DAT_40064006 & 0x20) == 0);\n  do {\n  } while ((DAT_40064006 & 0x40) == 0);\n  clockMode = KINETIS_MCG_MODE_PBE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001a60": "initialize_clock_00001a60",
                "current_mode": "clockMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "bit_set8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ad4": {
            "entrypoint": "0x00001ad4",
            "current_name": "set_mode_to_pee_00001ad4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setModeToPEE_00001ad4(void)\n\n{\n  DAT_40064000 = DAT_40064000 & 0x3f;\n  do {\n  } while ((DAT_40064006 & 0xc) != 0xc);\n  mcgMode = KINETIS_MCG_MODE_PEE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ad4": "set_mode_to_pee_00001ad4",
                "current_mode": "mcgMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001b10": {
            "entrypoint": "0x00001b10",
            "current_name": "set_mcg_mode_00001b10",
            "code": "\nint setMCGMode_00001b10(kinetis_mcg_requestedMode_t requestedMode)\n\n{\n  int iVar1;\n  kinetis_mcg_requestedMode_t currentMode;\n  \n  if (requestedMode < KINETIS_MCG_MODE_NUMOF) {\n    do {\n      switch(modeRoutingMatrix[currentMode][requestedMode]) {\n      case '\\0':\n        setFEIMode();\n        break;\n      case '\\x01':\n        setFEEMode();\n        break;\n      case '\\x02':\n        setFBIMode();\n        break;\n      case '\\x03':\n        setFBEMode();\n        break;\n      case '\\x04':\n        setBLPIMode();\n        break;\n      case '\\x05':\n        setBLPEMode();\n        break;\n      case '\\x06':\n        setPBEMode();\n        break;\n      case '\\a':\n        setPEEMode();\n        break;\n      default:\n        return -1;\n      }\n    } while (requestedMode != currentMode);\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = -1;\n  }\n  return iVar1;\n}\n\n",
            "renaming": {
                "FUN_00001b10": "set_mcg_mode_00001b10",
                "mode": "requestedMode",
                "mode_local": "currentMode",
                "mcg_mode_routing": "modeRoutingMatrix",
                "current_mode": "currentMode",
                "kinetis_mcg_set_fei": "setFEIMode",
                "kinetis_mcg_set_fee": "setFEEMode",
                "kinetis_mcg_set_fbi": "setFBIMode",
                "kinetis_mcg_set_fbe": "setFBEMode",
                "kinetis_mcg_set_blpi": "setBLPIMode",
                "kinetis_mcg_set_blpe": "setBLPEMode",
                "kinetis_mcg_set_pbe": "setPBEMode",
                "kinetis_mcg_set_pee": "setPEEMode"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_blpi",
                "kinetis_mcg_set_pee",
                "kinetis_mcg_set_blpe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001bb8": {
            "entrypoint": "0x00001bb8",
            "current_name": "initialize_mcu_00001bb8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeMCU_00001bb8(void)\n\n{\n  if ((DAT_40064001 & 2) != 0) {\n    bit_clear8(&DAT_40064001,'\\x01');\n  }\n  if ((DAT_40064005 & 0x40) != 0) {\n    if ((DAT_40064000 & 0xc0) == 0) {\n      DAT_40064000 = DAT_40064000 & 0x3f | 0x80;\n      do {\n      } while ((DAT_40064006 & 0xc) != 8);\n    }\n    bit_clear8(&DAT_40064005,'\\x06');\n    do {\n    } while ((DAT_40064006 & 0x20) != 0);\n  }\n  setFLLFactor(fllFactor640);\n  DAT_40064000 = DAT_40064000 & 0x3b | 4;\n  do {\n  } while ((DAT_40064006 & 0x10) == 0);\n  do {\n  } while ((DAT_40064006 & 0xc) != 0);\n  mcuMode = KINETIS_MCG_MODE_FEI;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001bb8": "initialize_mcu_00001bb8",
                "kinetis_mcg_set_fll_factor": "setFLLFactor",
                "KINETIS_MCG_FLL_FACTOR_640": "fllFactor640",
                "current_mode": "mcuMode"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001c84": {
            "entrypoint": "0x00001c84",
            "current_name": "initialize_system_00001c84",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_00001c84(void)\n\n{\n  uint interruptState;\n  uint interruptMask;\n  \n  interruptState = irq_disable();\n  kinetis_mcg_set_safe_mode();\n  _DAT_40048044 = 0x220000;\n  DAT_4006400c = 0;\n  DAT_40064000 = DAT_40064000 & 199 | 0x38;\n  DAT_40064004 = 0x13;\n  DAT_40064005 = 0;\n  kinetis_mcg_init_mcgirclk();\n  kinetis_mcg_init_erclk32k();\n  kinetis_mcg_set_mode(KINETIS_MCG_MODE_PEE);\n  irq_restore(interruptState);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001c84": "initialize_system_00001c84",
                "state": "interruptState",
                "mask": "interruptMask"
            },
            "calling": [
                "cpu_init"
            ],
            "called": [
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_init_erclk32k",
                "irq_restore",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_set_mode",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001cf0": {
            "entrypoint": "0x00001cf0",
            "current_name": "check_and_yield_higher_priority_thread_00001cf0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid check_and_yield_higher_priority_thread_00001cf0(void)\n\n{\n  if (sched_context_switch_request != 0) {\n    check_and_yield_higher();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001cf0": "check_and_yield_higher_priority_thread_00001cf0",
                "thread_yield_higher": "check_and_yield_higher"
            },
            "calling": [
                "irq_handler"
            ],
            "called": [
                "thread_yield_higher"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d08": {
            "entrypoint": "0x00001d08",
            "current_name": "calculate_offset_00001d08",
            "code": "\nvoid * calculate_offset_00001d08(void *input_ptr,uintinput_ptr_t input_bit)\n\n{\n  uintinput_ptr_t shifted_bit;\n  void *shifted_ptr;\n  \n  return (void *)(input_bit * 4 + ((uint)input_ptr & 0xf0000000 | ((uint)input_ptr & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00001d08": "calculate_offset_00001d08",
                "ptr": "input_ptr",
                "bit": "input_bit",
                "bit_local": "shifted_bit",
                "ptr_local": "shifted_ptr"
            },
            "calling": [
                "bit_set32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d3a": {
            "entrypoint": "0x00001d3a",
            "current_name": "set_bit_00001d3a",
            "code": "\nvoid setBit_00001d3a(uint32_t *pointer,uint8_t bitIndex)\n\n{\n  undefined4 *bitPointer;\n  uint8_t localBit;\n  uint32_t *localPointer;\n  \n  bitPointer = (undefined4 *)bitIndexband_addr(pointer,(uint)bitIndex);\n  *bitPointer = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001d3a": "set_bit_00001d3a",
                "ptr": "pointer",
                "bit": "bitIndex",
                "bit_local": "localBit",
                "ptr_local": "localPointer",
                "puVar1": "bitPointer"
            },
            "calling": [
                "clk_en"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d5e": {
            "entrypoint": "0x00001d5e",
            "current_name": "get_port_from_pin_00001d5e",
            "code": "\nPORT_Type * getPortFromPin_00001d5e(gpio_t pin)\n\n{\n  gpio_t localPin;\n  \n  return (PORT_Type *)(pin & 0x7000 | 0x40048000);\n}\n\n",
            "renaming": {
                "FUN_00001d5e": "get_port_from_pin_00001d5e",
                "pin_local": "localPin"
            },
            "calling": [
                "gpio_init_port",
                "gpio_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d80": {
            "entrypoint": "0x00001d80",
            "current_name": "map_pin_to_gpio_00001d80",
            "code": "\nGPIOType * mapPinToGPIO_00001d80(gpio_t pinCode)\n\n{\n  gpio_t localPin;\n  \n  return (GPIOType *)(pinCode & 0x1c0 | 0x400ff000);\n}\n\n",
            "renaming": {
                "FUN_00001d80": "map_pin_to_gpio_00001d80",
                "pin": "pinCode",
                "pin_local": "localPin",
                "GPIO_Type": "GPIOType"
            },
            "calling": [
                "gpio_set",
                "gpio_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001da2": {
            "entrypoint": "0x00001da2",
            "current_name": "extract_bits_from_pin_00001da2",
            "code": "\nint extractBitsFromPin_00001da2(gpio_t pin)\n\n{\n  gpio_t localPin;\n  \n  return pin >> 6 & 7;\n}\n\n",
            "renaming": {
                "FUN_00001da2": "extract_bits_from_pin_00001da2",
                "pin_local": "localPin"
            },
            "calling": [
                "gpio_init_port",
                "clk_en"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001dc0": {
            "entrypoint": "0x00001dc0",
            "current_name": "extract_gpio_pin_00001dc0",
            "code": "\nint extract_gpio_pin_00001dc0(gpio_t input_pin)\n\n{\n  gpio_t local_pin;\n  \n  return input_pin & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_00001dc0": "extract_gpio_pin_00001dc0",
                "pin": "input_pin",
                "pin_local": "local_pin"
            },
            "calling": [
                "gpio_init_port",
                "gpio_set",
                "gpio_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ddc": {
            "entrypoint": "0x00001ddc",
            "current_name": "set_pin_bit_00001ddc",
            "code": "\nvoid setPinBit_00001ddc(gpio_t gpioPin)\n\n{\n  int portNumber;\n  gpio_t localPin;\n  \n  portNumber = port_num(gpioPin);\n  bit_set32((uint32_t *)&DAT_40048038,(char)portNumber + '\\t');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ddc": "set_pin_bit_00001ddc",
                "pin": "gpioPin",
                "iVar1": "portNumber",
                "pin_local": "localPin"
            },
            "calling": [
                "gpio_init_port"
            ],
            "called": [
                "bit_set32",
                "port_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001e0c": {
            "entrypoint": "0x00001e0c",
            "current_name": "get_pin_value_00001e0c",
            "code": "\nint getPinValue_00001e0c(int portNumber,int pinNumber)\n\n{\n  int localPin;\n  int localPort;\n  \n  return isr_map[(pinNumber >> 3) + portNumber * 4] >> ((pinNumber & 7U) << 2) & 0xf;\n}\n\n",
            "renaming": {
                "FUN_00001e0c": "get_pin_value_00001e0c",
                "port": "portNumber",
                "pin": "pinNumber",
                "pin_local": "localPin",
                "port_local": "localPort"
            },
            "calling": [
                "ctx_clear",
                "irq_handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001e44": {
            "entrypoint": "0x00001e44",
            "current_name": "update_isr_map_00001e44",
            "code": "\nvoid updateIsrMap_00001e44(int portNum,int pinNum,int context)\n\n{\n  int shiftedPin;\n  int localContext;\n  int localPin;\n  int localPort;\n  \n  shiftedPin = pinNum >> 3;\n  isr_map[shiftedPin + portNum * 4] = isr_map[shiftedPin + portNum * 4] & ~(0xf << ((pinNum & 7U) << 2));\n  isr_map[shiftedPin + portNum * 4] = isr_map[shiftedPin + portNum * 4] | context << ((pinNum & 7U) << 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001e44": "update_isr_map_00001e44",
                "port": "portNum",
                "pin": "pinNum",
                "ctx": "context",
                "iVar1": "shiftedPin",
                "ctx_local": "localContext",
                "pin_local": "localPin",
                "port_local": "localPort"
            },
            "calling": [
                "ctx_clear"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ec4": {
            "entrypoint": "0x00001ec4",
            "current_name": "initialize_pin_00001ec4",
            "code": "\nvoid initializePin_00001ec4(int portNumber,int pinNumber)\n\n{\n  int context;\n  int localPin;\n  int localPort;\n  int contextVariable;\n  \n  context = get_contextVariable(portNumber,pinNumber);\n  write_map(portNumber,pinNumber,context);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ec4": "initialize_pin_00001ec4",
                "port": "portNumber",
                "pin": "pinNumber",
                "ctx_00": "context",
                "pin_local": "localPin",
                "port_local": "localPort",
                "ctx": "contextVariable"
            },
            "calling": [
                "gpio_init_port"
            ],
            "called": [
                "get_ctx",
                "write_map"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001eea": {
            "entrypoint": "0x00001eea",
            "current_name": "configure_gpio_00001eea",
            "code": "\nint configureGPIO_00001eea(gpio_t pin,gpio_mode_t mode)\n\n{\n  uint pinNumber;\n  GPIO_Type *gpioPtr;\n  PORT_Type *portPtr;\n  int pinIndex;\n  gpio_mode_t localMode;\n  gpio_t localPin;\n  \n  gpio_init_port(pin,0);\n  if ((char)mode < '\\0') {\n    pinNumber = pin_num(pin);\n    gpioPtr = gpio(pin);\n    gpioPtr->PDDR = gpioPtr->PDDR | 1 << (pinNumber & 0xff);\n  }\n  else {\n    pinNumber = pin_num(pin);\n    gpioPtr = gpio(pin);\n    gpioPtr->PDDR = gpioPtr->PDDR & ~(1 << (pinNumber & 0xff));\n  }\n  portPtr = port(pin);\n  pinIndex = pin_num(pin);\n  portPtr->PCR[pinIndex] = mode & 0x23 | 0x100;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00001eea": "configure_gpio_00001eea",
                "uVar1": "pinNumber",
                "pGVar2": "gpioPtr",
                "pPVar3": "portPtr",
                "iVar4": "pinIndex",
                "mode_local": "localMode",
                "pin_local": "localPin"
            },
            "calling": [
                "board_init"
            ],
            "called": [
                "gpio_init_port",
                "gpio",
                "port",
                "pin_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001f80": {
            "entrypoint": "0x00001f80",
            "current_name": "initialize_gpio_00001f80",
            "code": "\nvoid initializeGPIO_00001f80(gpio_t gpioPin,uint32_t newPcrValue)\n\n{\n  PORT_Type *portTypePtr;\n  int pinIndex;\n  int pinNumber;\n  uint oldPcrValue;\n  uint32_t localPcrValue;\n  gpio_t localGpioPin;\n  uint32_t isrState;\n  \n  clk_en(gpioPin);\n  portTypePtr = port(gpioPin);\n  pinIndex = gpioPin_num(gpioPin);\n  oldPcrValue = portTypePtr->PCR[pinIndex];\n  portTypePtr = port(gpioPin);\n  pinIndex = gpioPin_num(gpioPin);\n  portTypePtr->PCR[pinIndex] = newPcrValue;\n  if ((oldPcrValue & 0xf0000) != 0) {\n    pinIndex = port_num(gpioPin);\n    pinNumber = gpioPin_num(gpioPin);\n    ctx_clear(pinIndex,pinNumber);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001f80": "initialize_gpio_00001f80",
                "pin": "gpioPin",
                "pcr": "newPcrValue",
                "pPVar1": "portTypePtr",
                "iVar2": "pinIndex",
                "pin_00": "pinNumber",
                "uVar3": "oldPcrValue",
                "pcr_local": "localPcrValue",
                "pin_local": "localGpioPin",
                "isr_state": "isrState"
            },
            "calling": [
                "uart_init_pins",
                "gpio_init"
            ],
            "called": [
                "port",
                "pin_num",
                "ctx_clear",
                "clk_en",
                "port_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ff6": {
            "entrypoint": "0x00001ff6",
            "current_name": "set_pin_high_00001ff6",
            "code": "\nvoid setPinHigh_00001ff6(gpio_t pinNumber)\n\n{\n  uint pinNum;\n  GPIO_Type *gpioPtr;\n  gpio_t localPin;\n  \n  pinNum = pinNumber_num(pinNumber);\n  gpioPtr = gpio(pinNumber);\n  gpioPtr->PSOR = 1 << (pinNum & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ff6": "set_pin_high_00001ff6",
                "pin": "pinNumber",
                "uVar1": "pinNum",
                "pGVar2": "gpioPtr",
                "pin_local": "localPin"
            },
            "calling": [
                "board_init"
            ],
            "called": [
                "gpio",
                "pin_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002028": {
            "entrypoint": "0x00002028",
            "current_name": "process_interrupts_00002028",
            "code": "\nvoindexd processInterrupts_00002028(PORT_Type *portPointer,indexnt portNumber)\n\n{\n  indexnt contextIndex;\n  uindexnt interruptFlag;\n  indexnt localPortNumber;\n  PORT_Type *localPortPointer;\n  indexnt context;\n  uindexnt32_t portStatus;\n  indexnt index;\n  \n  interruptFlag = portPointer->ISFR;\n  for (index = 0; index < 0x20; index = index + 1) {\n    indexf (((interruptFlag & 1 << (index & 0xffU)) != 0) && ((portPointer->PCR[index] & 0xf0000) != 0)) {\n      portPointer->ISFR = 1 << (index & 0xffU);\n      contextIndex = get_context(portNumber,index);\n      (*indexsr_context[contextIndex].cb)(indexsr_context[contextIndex].arg);\n    }\n  }\n  cortexm_indexsr_end();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002028": "process_interrupts_00002028",
                "port": "portPointer",
                "port_num": "portNumber",
                "iVar1": "contextIndex",
                "uVar2": "interruptFlag",
                "port_num_local": "localPortNumber",
                "port_local": "localPortPointer",
                "ctx": "context",
                "status": "portStatus",
                "i": "index"
            },
            "calling": [
                "isr_portc",
                "isr_portd",
                "isr_porte",
                "isr_portb",
                "isr_porta"
            ],
            "called": [
                "get_ctx",
                "cortexm_isr_end"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020b8": {
            "entrypoint": "0x000020b8",
            "current_name": "handle_irq_000020b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_irq_000020b8(void)\n\n{\n  irq_handler((PORT_Type *)0x40049000,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020b8": "handle_irq_000020b8"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020cc": {
            "entrypoint": "0x000020cc",
            "current_name": "initialize_irq_handler_000020cc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIRQHandler_000020cc(void)\n\n{\n  irq_handler((PORT_Type *)0x4004a000,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020cc": "initialize_irq_handler_000020cc"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020e0": {
            "entrypoint": "0x000020e0",
            "current_name": "initialize_port_000020e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePort_000020e0(void)\n\n{\n  irq_handler((PORT_Type *)0x4004b000,2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020e0": "initialize_port_000020e0"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020f4": {
            "entrypoint": "0x000020f4",
            "current_name": "initialize_interrupt_handler_000020f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeInterruptHandler_000020f4(void)\n\n{\n  irq_handler((PORT_Type *)0x4004c000,3);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020f4": "initialize_interrupt_handler_000020f4"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002108": {
            "entrypoint": "0x00002108",
            "current_name": "initialize_irq_handler_00002108",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIRQHandler_00002108(void)\n\n{\n  irq_handler((port *)0x4004d000,4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002108": "initialize_irq_handler_00002108",
                "PORT_Type": "port"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000211c": {
            "entrypoint": "0x0000211c",
            "current_name": "print_thread_information_0000211c",
            "code": "\n/* WARNING: Unknown callthreadIndexng conventthreadIndexon */\n\nvothreadIndexd printThreadInformation_0000211c(vothreadIndexd)\n\n{\n  byte status;\n  threadIndexnt stackUsage;\n  vothreadIndexd *isrStackStartPtr;\n  vothreadIndexd *isrStackPointerPtr;\n  uthreadIndexntthreadPointertr_t freeStackSpace;\n  thread_t *threadPtr;\n  char *threadPointercVar7;\n  char queuedName [2];\n  threadIndexnt stackSize;\n  char *queued;\n  char *serviceName;\n  threadIndexnt threadState;\n  thread_t *threadPointer;\n  vothreadIndexd *isrStackPointer;\n  vothreadIndexd *isrStackStart;\n  threadIndexnt isrStackUsage;\n  kernel_threadPointerthreadIndexd_t threadIndex;\n  threadIndexnt overallUsed;\n  threadIndexnt overallStackSize;\n  \n  queuedName[0] = '_';\n  queuedName[1] = 'Q';\n  overallUsed = 0;\n  threadIndexthreadPointerrthreadIndexntf(\"\\tthreadPointerthreadIndexd | %-21s| %-9sQ | threadPointerrthreadIndex | stack  ( used) | base addr  | current     \\n\",&DAT_000070b8,\n          \"threadState\");\n  stackUsage = thread_threadIndexsr_stack_usage();\n  isrStackStartPtr = thread_threadIndexsr_stack_start();\n  isrStackPointerPtr = thread_threadIndexsr_stack_threadPointerothreadIndexnter();\n  threadIndexthreadPointerrthreadIndexntf(\"\\t  - | threadIndexsr_stack            | -        - |   - | %6threadIndex (%5threadIndex) | %10threadPointer | %10threadPointer\\n\",0x200,stackUsage,\n          isrStackStartPtr,isrStackPointerPtr);\n  overallStackSize = 0x200;\n  threadIndexf (0 < stackUsage) {\n    overallUsed = stackUsage;\n  }\n  for (threadIndex = 1; threadIndex < 0x21; threadIndex = threadIndex + 1) {\n    threadPtr = sched_threads[threadIndex];\n    threadIndexf (threadPtr != (thread_t *)0x0) {\n      status = threadPtr->status;\n      threadPointercVar7 = threadState_names[status];\n      stackUsage = threadPtr->stack_sthreadIndexze;\n      overallStackSize = stackUsage + overallStackSize;\n      freeStackSpace = thread_measure_stack_free(threadPtr->stack_start);\n      stackUsage = stackUsage - freeStackSpace;\n      overallUsed = stackUsage + overallUsed;\n      threadIndexthreadPointerrthreadIndexntf(\"\\t%3hthreadIndex | %-20s | %-8s %.1s | %3threadIndex | %6threadIndex (%5threadIndex) | %10threadPointer | %10threadPointer \\n\",(threadIndexnt)threadPtr->threadPointerthreadIndexd,\n              threadPtr->name,threadPointercVar7,queuedName + (8 < status),(uthreadIndexnt)threadPtr->threadPointerrthreadIndexorthreadIndexty,\n              threadPtr->stack_sthreadIndexze,stackUsage,threadPtr->stack_start,threadPtr->sthreadPointer);\n    }\n  }\n  threadIndexthreadPointerrthreadIndexntf(\"\\t%5s %-21s|%13s%6s %6threadIndex (%5threadIndex)\\n\",&DAT_00007190,&DAT_00007194,&DAT_00007190,&DAT_00007190,\n          overallStackSize,overallUsed);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000211c": "print_thread_information_0000211c",
                "queued_name": "queuedName",
                "stacksz": "stackSize",
                "sname": "serviceName",
                "state": "threadState",
                "p": "threadPointer",
                "isr_sp": "isrStackPointer",
                "isr_start": "isrStackStart",
                "isr_usage": "isrStackUsage",
                "i": "threadIndex",
                "overall_used": "overallUsed",
                "overall_stacksz": "overallStackSize",
                "bVar1": "status",
                "iVar2": "stackUsage",
                "pvVar3": "isrStackStartPtr",
                "pvVar4": "isrStackPointerPtr",
                "uVar5": "freeStackSpace",
                "ptVar6": "threadPtr"
            },
            "calling": [
                "core_panic",
                "_ps_handler"
            ],
            "called": [
                "thread_isr_stack_start",
                "thread_isr_stack_usage",
                "iprintf",
                "thread_isr_stack_pointer",
                "thread_measure_stack_free"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002270": {
            "entrypoint": "0x00002270",
            "current_name": "get_byte_value_00002270",
            "code": "\nint getByteValue_00002270(tsringBuffer_t *ringBuffer)\n\n{\n  byte byteValue;\n  uint writeCount;\n  bool isReadEqualToWrite;\n  tsringBuffer_t *localRingBuffer;\n  \n  writeCount = ringBuffer->writes;\n  isReadEqualToWrite = ringBuffer->reads == writeCount;\n  if (isReadEqualToWrite) {\n    writeCount = 1;\n  }\n  byteValue = (byte)writeCount;\n  if (!isReadEqualToWrite) {\n    byteValue = 0;\n  }\n  return (uint)byteValue;\n}\n\n",
            "renaming": {
                "FUN_00002270": "get_byte_value_00002270",
                "rb": "ringBuffer",
                "bVar1": "byteValue",
                "uVar2": "writeCount",
                "bVar3": "isReadEqualToWrite",
                "rb_local": "localRingBuffer"
            },
            "calling": [
                "tsrb_get"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002294": {
            "entrypoint": "0x00002294",
            "current_name": "check_buffer_status_00002294",
            "code": "\nint checkBufferStatus_00002294(tsbuffer_t *buffer)\n\n{\n  byte bufferStatus;\n  uint bufferSize;\n  bool isBufferFull;\n  tsbuffer_t *localBuffer;\n  \n  bufferSize = buffer->size;\n  isBufferFull = buffer->writes - buffer->reads == bufferSize;\n  if (isBufferFull) {\n    bufferSize = 1;\n  }\n  bufferStatus = (byte)bufferSize;\n  if (!isBufferFull) {\n    bufferStatus = 0;\n  }\n  return (uint)bufferStatus;\n}\n\n",
            "renaming": {
                "FUN_00002294": "check_buffer_status_00002294",
                "rb": "buffer",
                "bVar1": "bufferStatus",
                "uVar2": "bufferSize",
                "bVar3": "isBufferFull",
                "rb_local": "localBuffer"
            },
            "calling": [
                "tsrb_add_one"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000022be": {
            "entrypoint": "0x000022be",
            "current_name": "write_to_ring_buffer_000022be",
            "code": "\nvoid writeToRingBuffer_000022be(tsringBuffer_t *ringBuffer,char c)\n\n{\n  uint writeIndex;\n  char localCharacter;\n  tsringBuffer_t *localBuffer;\n  \n  writeIndex = ringBuffer->writes;\n  ringBuffer->writes = writeIndex + 1;\n  ringBuffer->buf[writeIndex & ringBuffer->size - 1] = c;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000022be": "write_to_ring_buffer_000022be",
                "rb": "ringBuffer",
                "uVar1": "writeIndex",
                "c_local": "localCharacter",
                "rb_local": "localBuffer"
            },
            "calling": [
                "tsrb_add_one"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000022f0": {
            "entrypoint": "0x000022f0",
            "current_name": "get_next_item_from_ring_buffer_000022f0",
            "code": "\nchar get_next_item_from_ring_buffer_000022f0(tsring_buffer_t *ring_buffer)\n\n{\n  uint reads_count;\n  tsring_buffer_t *ring_buffer_local;\n  \n  reads_count = ring_buffer->reads;\n  ring_buffer->reads = reads_count + 1;\n  return ring_buffer->buf[reads_count & ring_buffer->size - 1];\n}\n\n",
            "renaming": {
                "FUN_000022f0": "get_next_item_from_ring_buffer_000022f0",
                "rb": "ring_buffer",
                "uVar1": "reads_count",
                "rb_local": "ring_buffer_local"
            },
            "calling": [
                "tsrb_get"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000231c": {
            "entrypoint": "0x0000231c",
            "current_name": "copy_from_tsrb_0000231c",
            "code": "\nisizet copy_from_tsrb_0000231c(tsring_buffer_t *ring_buffer,char *destination,size_t size)\n\n{\n  char current_char;\n  isizet is_empty;\n  size_t remaining_size;\n  char *current_destination;\n  tsring_buffer_t *current_ring_buffer;\n  size_t temporary_size;\n  \n  current_destination = destination;\n  temporary_size = size;\n  while ((temporary_size != 0 && (is_empty = tsring_buffer_empty(ring_buffer), is_empty == 0))) {\n    current_char = _pop(ring_buffer);\n    *current_destination = current_char;\n    temporary_size = temporary_size - 1;\n    current_destination = current_destination + 1;\n  }\n  retursize size - temporary_size;\n}\n\n",
            "renaming": {
                "FUN_0000231c": "copy_from_tsrb_0000231c",
                "rb": "ring_buffer",
                "dst": "destination",
                "n": "size",
                "n_local": "remaining_size",
                "dst_local": "current_destination",
                "rb_local": "current_ring_buffer",
                "tmp": "temporary_size",
                "iVar2": "is_empty",
                "cVar1": "current_char"
            },
            "calling": [
                "isrpipe_read"
            ],
            "called": [
                "tsrb_empty",
                "_pop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002364": {
            "entrypoint": "0x00002364",
            "current_name": "push_character_to_ring_buffer_00002364",
            "code": "\nint push_character_to_ring_buffer_00002364(tsring_buffer_t *ring_buffer,char c)\n\n{\n  int is_ring_buffer_full;\n  char local_character;\n  tsring_buffer_t *local_ring_buffer;\n  \n  is_ring_buffer_full = tsring_buffer_full(ring_buffer);\n  if (is_ring_buffer_full == 0) {\n    _push(ring_buffer,c);\n    is_ring_buffer_full = 0;\n  }\n  else {\n    is_ring_buffer_full = -1;\n  }\n  return is_ring_buffer_full;\n}\n\n",
            "renaming": {
                "FUN_00002364": "push_character_to_ring_buffer_00002364",
                "rb": "ring_buffer",
                "iVar1": "is_ring_buffer_full",
                "c_local": "local_character",
                "rb_local": "local_ring_buffer"
            },
            "calling": [
                "isrpipe_write_one"
            ],
            "called": [
                "_push",
                "tsrb_full"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002396": {
            "entrypoint": "0x00002396",
            "current_name": "initialize_rtc_00002396",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_rtc_00002396(void)\n\n{\n  initialize_real_time_clock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002396": "initialize_rtc_00002396",
                "rtc_init": "initialize_real_time_clock"
            },
            "calling": [
                "cpu_init"
            ],
            "called": [
                "rtc_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000023a4": {
            "entrypoint": "0x000023a4",
            "current_name": "run_shell_command_000023a4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint runShellCommand_000023a4(void)\n\n{\n  char commandBuffer [128];\n  \n  startForkserver(0);\n  puts(\"Welcome to RIOT!\");\n                    \n  shell_run((shell_command_t *)0x0,commandBuffer,0x80);\n}\n\n",
            "renaming": {
                "FUN_000023a4": "run_shell_command_000023a4",
                "line_buf": "commandBuffer"
            },
            "calling": [
                "main_trampoline"
            ],
            "called": [
                "startForkserver",
                "puts",
                "shell_run"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000023c8": {
            "entrypoint": "0x000023c8",
            "current_name": "execute_software_interrupt_000023c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_software_interrupt_000023c8(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_000023c8": "execute_software_interrupt_000023c8"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000023d0": {
            "entrypoint": "0x000023d0",
            "current_name": "perform_afl_call_000023d0",
            "code": "\nint performAflCall_000023d0(int ticks)\n\n{\n  uint32_t aflResult;\n  int localTicks;\n  \n  if (noHyperCall == 0) {\n    aflResult = aflCall(1,ticks,0);\n  }\n  else {\n    aflResult = 0;\n  }\n  return aflResult;\n}\n\n",
            "renaming": {
                "FUN_000023d0": "perform_afl_call_000023d0",
                "uVar1": "aflResult",
                "ticks_local": "localTicks"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002400": {
            "entrypoint": "0x00002400",
            "current_name": "FUNC_00002400",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00002400(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002400": "FUNC_00002400"
            },
            "calling": [
                "main_trampoline"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0000240c": {
            "entrypoint": "0x0000240c",
            "current_name": "extract_next_node_0000240c",
            "code": "\ninputList_node_t * extractNextNode_0000240c(inputList_node_t *inputList)\n\n{\n  inputList_node *currentNode;\n  inputList_node_t *localList;\n  inputList_node_t *listHead;\n  \n  currentNode = inputList->next;\n  if (currentNode != (inputList_node *)0x0) {\n    inputList->next = currentNode->next;\n  }\n  return currentNode;\n}\n\n",
            "renaming": {
                "FUN_0000240c": "extract_next_node_0000240c",
                "list": "inputList",
                "plVar1": "currentNode",
                "list_local": "localList",
                "head": "listHead"
            },
            "calling": [
                "mutex_unlock"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002434": {
            "entrypoint": "0x00002434",
            "current_name": "acquire_mutex_00002434",
            "code": "\nint acquireMutex_00002434(mutex_t *mutex,int isBlocking)\n\n{\n  currentThread_t *currentThread;\n  uint irqState;\n  int result;\n  int isBlockingLocal;\n  mutex_t *mutexLocal;\n  uint irqStateLocal;\n  currentThread_t *currentThread;\n  \n  irqState = irq_disable();\n  currentThread = sched_active_currentThread;\n  if ((mutex->queue).next == (list_node *)0x0) {\n    (mutex->queue).next = (list_node *)0xffffffff;\n    irq_restore(irqState);\n    result = 1;\n  }\n  else if (isBlocking == 0) {\n    irq_restore(irqState);\n    result = 0;\n  }\n  else {\n    sched_set_status(sched_active_currentThread,2);\n    if ((mutex->queue).next == (list_node *)0xffffffff) {\n      (mutex->queue).next = &currentThread->rq_entry;\n      ((mutex->queue).next)->next = (list_node *)0x0;\n    }\n    else {\n      currentThread_add_to_list(&mutex->queue,currentThread);\n    }\n    irq_restore(irqState);\n    currentThread_yield_higher();\n    result = 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00002434": "acquire_mutex_00002434",
                "blocking": "isBlocking",
                "thread": "currentThread",
                "state": "irqState",
                "iVar1": "result",
                "blocking_local": "isBlockingLocal",
                "mutex_local": "mutexLocal",
                "irqstate": "irqStateLocal",
                "me": "currentThread"
            },
            "calling": [
                "mutex_lock"
            ],
            "called": [
                "irq_restore",
                "sched_set_status",
                "thread_yield_higher",
                "thread_add_to_list",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000024bc": {
            "entrypoint": "0x000024bc",
            "current_name": "process_next_thread_000024bc",
            "code": "\nvoid processNextThread_000024bc(threadMutex_t *threadMutex)\n\n{\n  byte statusByte;\n  uint interruptState;\n  list_node_t *removedNode;\n  threadMutex_t *localMutex;\n  uint16_t threadPriority;\n  uint interruptState2;\n  clist_node_t *nextCListNode;\n  list_node_t *nextListNode;\n  thread_t *currentThread;\n  \n  interruptState = irq_disable();\n  if ((threadMutex->queue).nextListNode == (list_node *)0x0) {\n    irq_restore(interruptState);\n  }\n  else if ((threadMutex->queue).nextListNode == (list_node *)0xffffffff) {\n    (threadMutex->queue).nextListNode = (list_node *)0x0;\n    irq_restore(interruptState);\n  }\n  else {\n    removedNode = list_remove_head(&threadMutex->queue);\n    sched_set_status((thread_t *)(removedNode + -2),10);\n    if ((threadMutex->queue).nextListNode == (list_node *)0x0) {\n      (threadMutex->queue).nextListNode = (list_node *)0xffffffff;\n    }\n    statusByte = *(byte *)((int)&removedNode[-1].nextListNode + 1);\n    irq_restore(interruptState);\n    sched_switch((ushort)statusByte);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000024bc": "process_next_thread_000024bc",
                "mutex": "threadMutex",
                "state": "interruptState",
                "plVar2": "removedNode",
                "mutex_local": "localMutex",
                "process_priority": "threadPriority",
                "irqstate": "interruptState2",
                "__m____": "nextCListNode",
                "next": "nextListNode",
                "process": "currentThread",
                "bVar1": "statusByte"
            },
            "calling": [
                "isrpipe_write_one"
            ],
            "called": [
                "irq_restore",
                "sched_set_status",
                "sched_switch",
                "list_remove_head",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002538": {
            "entrypoint": "0x00002538",
            "current_name": "set_interrupt_priority_00002538",
            "code": "\nvoid setInterruptPriority_00002538(interruptNumber_Type interruptNumber,uint32_t interruptPriority)\n\n{\n  uint32_t localPriority;\n  interruptNumber_Type localInterruptNumber;\n  \n  if (interruptNumber < DMA0_interruptNumber) {\n    (&DAT_e000ed14)[(byte)interruptNumber & 0xf] = (char)((interruptPriority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interruptNumber + -0x1fff1c00) = (char)((interruptPriority & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002538": "set_interrupt_priority_00002538",
                "IRQn": "interruptNumber",
                "priority": "interruptPriority",
                "priority_local": "localPriority",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "cortexm_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000258c": {
            "entrypoint": "0x0000258c",
            "current_name": "initialize_interrupt_controller_0000258c",
            "code": "\n\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd initializeInterruptController_0000258c(voindexd)\n\n{\n  uindexnt index;\n  \n  _DAT_e000ed08 = 0;\n  NVIC_SetPrindexorindexty(PendSV_Interrupt,1);\n  NVIC_SetPrindexorindexty(SVCall_Interrupt,1);\n  for (index = 0; index < 0x66; index = index + 1) {\n    NVIC_SetPrindexorindexty((IRQ_Type)index,1);\n  }\n  _DAT_e000ed10 = _DAT_e000ed10 | 0x10;\n  _DAT_e000ed14 = _DAT_e000ed14 | 0x200;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000258c": "initialize_interrupt_controller_0000258c",
                "i": "index",
                "PendSV_IRQn": "PendSV_Interrupt",
                "SVCall_IRQn": "SVCall_Interrupt",
                "IRQn_Type": "IRQ_Type"
            },
            "calling": [
                "cpu_init"
            ],
            "called": [
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000025f4": {
            "entrypoint": "0x000025f4",
            "current_name": "initialize_real_time_timer_000025f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_real_time_timer_000025f4(void)\n\n{\n  initialize_rtt();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000025f4": "initialize_real_time_timer_000025f4",
                "rtt_init": "initialize_rtt"
            },
            "calling": [
                "periph_init"
            ],
            "called": [
                "rtt_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002600": {
            "entrypoint": "0x00002600",
            "current_name": "set_rtt_counter_00002600",
            "code": "\nintimeStamp setRTTCounter_00002600(timeStampm *inputTime)\n\n{\n  uintimeStamp32_timeStamp counterValue;\n  timeStampm *localTime;\n  inputTime_timeStamp timeStamp;\n  \n  counterValue = mkinputTime((timeStampm *)inputTime);\n  rtimeStamptimeStamp_setimeStamp_counterValue(counterValue);\n  retimeStampurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002600": "set_rtt_counter_00002600",
                "time": "inputTime",
                "counter": "counterValue",
                "time_local": "localTime",
                "t": "timeStamp"
            },
            "calling": [
                "_rtc_settime"
            ],
            "called": [
                "mktime",
                "rtt_set_counter"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002624": {
            "entrypoint": "0x00002624",
            "current_name": "convert_time_to_utc_00002624",
            "code": "\nincounterValue convertTimeToUTC_00002624(counterValuem *localTime)\n\n{\n  counterValuem *localTimePointer;\n  localTime_counterValue counterValue;\n  \n  counterValue._0_4_ = rcounterValuecounterValue_gecounterValue_councounterValueer();\n  counterValue._4_4_ = 0;\n  gmlocalTime_r((localTime_counterValue *)&counterValue,(counterValuem *)localTime);\n  recounterValueurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002624": "convert_time_to_utc_00002624",
                "time": "localTime",
                "t": "counterValue",
                "time_local": "localTimePointer"
            },
            "calling": [
                "_rtc_gettime"
            ],
            "called": [
                "rtt_get_counter",
                "gmtime_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002654": {
            "entrypoint": "0x00002654",
            "current_name": "set_alarm_callback_00002654",
            "code": "\nincurrentTime setAlarmCallback_00002654(currentTimem *inputTime,rcurrentTimec_alarmTime_cb_currentTime cb,void *argument)\n\n{\n  uincurrentTime32_currentTime alarmTime;\n  void *localArgument;\n  rcurrentTimec_alarmTime_cb_currentTime localCallback;\n  currentTimem *localTime;\n  inputTime_currentTime currentTime;\n  \n  alarmTime = mkinputTime((currentTimem *)inputTime);\n  rcurrentTimec_callback.cb = cb;\n  rcurrentTimecurrentTime_securrentTime_alarmTime(alarmTime,rcurrentTimec_cb + 1,argument);\n  recurrentTimeurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002654": "set_alarm_callback_00002654",
                "time": "inputTime",
                "arg": "argument",
                "alarm": "alarmTime",
                "arg_local": "localArgument",
                "cb_local": "localCallback",
                "time_local": "localTime",
                "t": "currentTime"
            },
            "calling": [
                "_rtc_setalarm"
            ],
            "called": [
                "mktime",
                "rtt_set_alarm"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002690": {
            "entrypoint": "0x00002690",
            "current_name": "convert_alarm_to_time_00002690",
            "code": "\ninalarm convertAlarmToTime_00002690(alarmm *inputTime)\n\n{\n  alarmm *localTime;\n  inputTime_alarm alarm;\n  \n  alarmLow = ralarmalarm_gealarm_alarm();\n  alarmHigh = 0;\n  gminputTime_r((inputTime_alarm *)&alarm,(alarmm *)inputTime);\n  realarmurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002690": "convert_alarm_to_time_00002690",
                "time": "inputTime",
                "time_local": "localTime",
                "t": "alarm",
                "t._0_4_": "alarmLow",
                "t._4_4_": "alarmHigh"
            },
            "calling": [
                "_rtc_getalarm"
            ],
            "called": [
                "rtt_get_alarm",
                "gmtime_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026c0": {
            "entrypoint": "0x000026c0",
            "current_name": "clear_rtt_alarm_000026c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearRttAlarm_000026c0(void)\n\n{\n  rtt_clear_alarm();\n  rtcAlarmCallback.cb = (rtc_alarm_cb_t)0x0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026c0": "clear_rtt_alarm_000026c0",
                "rtc_callback": "rtcAlarmCallback"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtt_clear_alarm"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026d8": {
            "entrypoint": "0x000026d8",
            "current_name": "power_on_real_time_timer_000026d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid powerOnRealTimeTimer_000026d8(void)\n\n{\n  rtt_poweron();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026d8": "power_on_real_time_timer_000026d8"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtt_poweron"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026e4": {
            "entrypoint": "0x000026e4",
            "current_name": "power_off_000026e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid powerOff_000026e4(void)\n\n{\n  powerOff_000026e4Func();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026e4": "power_off_000026e4",
                "rtt_poweroff": "powerOffFunc"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtt_poweroff"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026f0": {
            "entrypoint": "0x000026f0",
            "current_name": "execute_rtc_alarm_callback_000026f0",
            "code": "\nvoid executeRtcAlarmCallback_000026f0(void *argument)\n\n{\n  void *localArgument;\n  \n  if (rtc_callback.cb != (rtc_alarm_cb_t)0x0) {\n    (*rtc_callback.cb)(argument);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026f0": "execute_rtc_alarm_callback_000026f0",
                "arg": "argument",
                "arg_local": "localArgument"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002714": {
            "entrypoint": "0x00002714",
            "current_name": "set_irq_bit_00002714",
            "code": "\nvoid setIrqBit_00002714(interruptNumber_Type interruptNumber)\n\n{\n  interruptNumber_Type localInterruptNumber;\n  \n  *(int *)(((uint)(int)interruptNumber >> 5) * 4 + -0x1fff1f00) = 1 << (interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002714": "set_irq_bit_00002714",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "rtt_set_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002744": {
            "entrypoint": "0x00002744",
            "current_name": "set_interrupt_priority_00002744",
            "code": "\nvoid setInterruptPriority_00002744(interruptNumber_Type interruptNumber,uint32_t interruptPriority)\n\n{\n  uint32_t localPriority;\n  interruptNumber_Type localInterruptNumber;\n  \n  if (interruptNumber < DMA0_interruptNumber) {\n    (&DAT_e000ed14)[(byte)interruptNumber & 0xf] = (char)((interruptPriority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interruptNumber + -0x1fff1c00) = (char)((interruptPriority & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002744": "set_interrupt_priority_00002744",
                "IRQn": "interruptNumber",
                "priority": "interruptPriority",
                "priority_local": "localPriority",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "rtt_set_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002798": {
            "entrypoint": "0x00002798",
            "current_name": "check_and_yield_00002798",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid check_and_yield_00002798(void)\n\n{\n  if (switch_request != 0) {\n    yield_higher();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002798": "check_and_yield_00002798",
                "sched_context_switch_request": "switch_request",
                "thread_yield_higher": "yield_higher"
            },
            "calling": [
                "isr_rtc"
            ],
            "called": [
                "thread_yield_higher"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000027b0": {
            "entrypoint": "0x000027b0",
            "current_name": "initialize_rtc_000027b0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_RTC_000027b0(void)\n\n{\n  RTC_Type *RTC_instance;\n  \n  _DAT_4004803c = _DAT_4004803c | 0x20000000;\n  if ((_DAT_4003d014 & 1) != 0) {\n    _DAT_4003d000 = 0;\n  }\n  _DAT_4003d010 = 0x104;\n  _DAT_4003d008 = 0xffffff42;\n  _DAT_4003d01c = 0;\n  RTC_instance_poweron();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000027b0": "initialize_rtc_000027b0",
                "rtt": "RTC_instance"
            },
            "calling": [
                "rtc_init"
            ],
            "called": [
                "rtt_poweron"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000281c": {
            "entrypoint": "0x0000281c",
            "current_name": "get_rtt_value_0000281c",
            "code": "\n/* WARNING: Removcounterng unreachable block (ram,0x00002840) */\n/* WARNING: Removcounterng unreachable block (ram,0x0000284c) */\n\n/* WARNING: Unknown callcounterng convenrtt_valuecounteron */\n\nucounternrtt_value32_rtt_value get_rtt_value_0000281c(vocounterd)\n\n{\n  RTC_Type *rtc_instance;\n  counternrtt_value counter;\n  ucounternrtt_value32_rtt_value rtt_value;\n  \n  rertt_valueurn _DAT_4003d000;\n}\n\n",
            "renaming": {
                "FUN_0000281c": "get_rtt_value_0000281c",
                "rtt": "rtc_instance",
                "i": "counter",
                "t": "rtt_value"
            },
            "calling": [
                "rtc_get_time"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000285c": {
            "entrypoint": "0x0000285c",
            "current_name": "set_counter_0000285c",
            "code": "\n\n\nvoid setCounter_0000285c(uint32_t newCounter)\n\n{\n  uint32_t localCounter;\n  RTC_Type *realTimeClock;\n  \n  _DAT_4003d000 = newCounter;\n  _DAT_4003d014 = _DAT_4003d014 & 0xffffffef | 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000285c": "set_counter_0000285c",
                "counter": "newCounter",
                "counter_local": "localCounter",
                "rtt": "realTimeClock"
            },
            "calling": [
                "rtc_set_time"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002894": {
            "entrypoint": "0x00002894",
            "current_name": "configure_rtt_alarm_00002894",
            "code": "\n\n\nvoid configureRTTAlarm_00002894(uint32_t alarmValue,rttModule_cb_t cb,void *argument)\n\n{\n  void *localArgument;\n  rttModule_cb_t localCallback;\n  uint32_t localAlarmValue;\n  RTC_Type *rttModule;\n  \n  _DAT_4003d008 = alarmValue - 1;\n  _DAT_4003d01c = _DAT_4003d01c & 0xfffffffb | 4;\n  rttModule_callback.alarmValue_cb = cb;\n  rttModule_callback.alarmValue_argument = argument;\n  NVIC_SetPriority(RTC_IRQn,10);\n  NVIC_EnableIRQ(RTC_IRQn);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002894": "configure_rtt_alarm_00002894",
                "alarm": "alarmValue",
                "arg": "argument",
                "arg_local": "localArgument",
                "cb_local": "localCallback",
                "alarm_local": "localAlarmValue",
                "rtt": "rttModule"
            },
            "calling": [
                "rtc_set_alarm"
            ],
            "called": [
                "NVIC_EnableIRQ",
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000028f0": {
            "entrypoint": "0x000028f0",
            "current_name": "increment_rtc_value_000028f0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t increment_RTC_value_000028f0(void)\n\n{\n  RTC_Type *rtc_pointer;\n  \n  return _DAT_4003d008 + 1;\n}\n\n",
            "renaming": {
                "FUN_000028f0": "increment_rtc_value_000028f0",
                "rtt": "rtc_pointer"
            },
            "calling": [
                "rtc_get_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002910": {
            "entrypoint": "0x00002910",
            "current_name": "initialize_rtc_00002910",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeRTC_00002910(void)\n\n{\n  RTC_Type *rtc;\n  \n  _DAT_4003d01c = _DAT_4003d01c & 0xfffffffb;\n  _DAT_4003d008 = 0;\n  alarmCallback = (rtc_cb_t)0x0;\n  alarmArgument = (void *)0x0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002910": "initialize_rtc_00002910",
                "rtt": "rtc",
                "rtt_callback.alarm_cb": "alarmCallback",
                "rtt_callback.alarm_arg": "alarmArgument"
            },
            "calling": [
                "rtc_clear_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000294c": {
            "entrypoint": "0x0000294c",
            "current_name": "enable_rtt_interrupts_0000294c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid enableRttInterrupts_0000294c(void)\n\n{\n  RTC_Type *rtcInstance;\n  \n  _DAT_4003d014 = _DAT_4003d014 | 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000294c": "enable_rtt_interrupts_0000294c",
                "rtt": "rtcInstance"
            },
            "calling": [
                "rtc_poweron",
                "rtt_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002970": {
            "entrypoint": "0x00002970",
            "current_name": "disable_interrupts_00002970",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid disableInterrupts_00002970(void)\n\n{\n  RTC_Type *realTimeClock;\n  \n  _DAT_4003d014 = _DAT_4003d014 & 0xffffffef;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002970": "disable_interrupts_00002970",
                "rtt": "realTimeClock"
            },
            "calling": [
                "rtc_poweroff"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002994": {
            "entrypoint": "0x00002994",
            "current_name": "handle_rtt_interrupt_00002994",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_rtt_interrupt_00002994(void)\n\n{\n  RTC_Type *real_time_counter;\n  \n  if (((_DAT_4003d014 & 4) != 0) && (callback_functions.alarm_callback != (real_time_counter_callback_type)0x0)) {\n    _DAT_4003d01c = _DAT_4003d01c & 0xfffffffb;\n    (*callback_functions.alarm_callback)(callback_functions.alarm_argument);\n  }\n  if (((_DAT_4003d014 & 2) != 0) && (callback_functions.overflow_callback != (real_time_counter_callback_type)0x0)) {\n    (*callback_functions.overflow_callback)(callback_functions.overflow_argument);\n  }\n  cortexm_isr_end();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002994": "handle_rtt_interrupt_00002994",
                "rtt": "real_time_counter",
                "rtt_callback": "callback_functions",
                "alarm_cb": "alarm_callback",
                "rtt_cb_t": "real_time_counter_callback_type",
                "alarm_arg": "alarm_argument",
                "overflow_cb": "overflow_callback",
                "overflow_arg": "overflow_argument"
            },
            "calling": [],
            "called": [
                "cortexm_isr_end"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002a00": {
            "entrypoint": "0x00002a00",
            "current_name": "print_character_00002a00",
            "code": "\nvoid printCharacter_00002a00(int c)\n\n{\n  int c_local;\n  \n  putchar(c);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002a00": "print_character_00002a00"
            },
            "calling": [
                "print_prompt",
                "readline"
            ],
            "called": [
                "putchar"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002a18": {
            "entrypoint": "0x00002a18",
            "current_name": "find_command_handler_00002a18",
            "code": "\nshell_input_command_handler_t find_command_handler_00002a18(shell_input_command_t *commands,char *input_command)\n\n{\n  indexnt comparison_result;\n  char *current_command;\n  shell_input_command_t *local_commands;\n  shell_input_command_t *all_command_lists [2];\n  uindexnt index;\n  shell_input_command_t *current_entry;\n  \n  all_command_lists[0] = commands;\n  all_command_lists[1] = (shell_input_command_t *)&_shell_commands;\n  index = 0;\n  do {\n    indexf (1 < index) {\n      return (shell_input_command_handler_t)0x0;\n    }\n    current_entry = all_command_lists[index];\n    indexf (current_entry != (shell_input_command_t *)0x0) {\n      for (; current_entry->name != (char *)0x0; current_entry = current_entry + 1) {\n        comparison_result = strcmp(current_entry->name,input_command);\n        indexf (comparison_result == 0) {\n          return current_entry->handler;\n        }\n      }\n    }\n    index = index + 1;\n  } whindexle( true );\n}\n\n",
            "renaming": {
                "FUN_00002a18": "find_command_handler_00002a18",
                "command_list": "commands",
                "command": "input_command",
                "command_local": "current_command",
                "command_list_local": "local_commands",
                "command_lists": "all_command_lists",
                "i": "index",
                "entry": "current_entry",
                "iVar1": "comparison_result"
            },
            "calling": [
                "handle_input_line"
            ],
            "called": [
                "strcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002a88": {
            "entrypoint": "0x00002a88",
            "current_name": "print_shell_command_list_00002a88",
            "code": "\nvoindexd printShellCommandList_00002a88(shell_command_t *inputCommands)\n\n{\n  shell_command_t *localCommands;\n  shell_command_t *allCommands [2];\n  uindexnt index;\n  shell_command_t *currentEntry;\n  \n  indexprindexntf(\"%-20s %s\\n\",\"Command\",\"Descrindexptindexon\");\n  puts(\"---------------------------------------\");\n  allCommands[0] = inputCommands;\n  allCommands[1] = (shell_command_t *)&_shell_inputCommands;\n  for (index = 0; index < 2; index = index + 1) {\n    currentEntry = allCommands[index];\n    indexf (currentEntry != (shell_command_t *)0x0) {\n      for (; currentEntry->name != (char *)0x0; currentEntry = currentEntry + 1) {\n        indexprindexntf(\"%-20s %s\\n\",currentEntry->name,currentEntry->desc);\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002a88": "print_shell_command_list_00002a88",
                "command_list": "inputCommands",
                "command_list_local": "localCommands",
                "command_lists": "allCommands",
                "i": "index",
                "entry": "currentEntry"
            },
            "calling": [
                "handle_input_line"
            ],
            "called": [
                "puts",
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002b10": {
            "entrypoint": "0x00002b10",
            "current_name": "parse_shell_command_00002b10",
            "code": "\nvoindexd parseShellCommand_00002b10(shell_command_t *commandList,char *inputLine)\n\n{\n  indexnt comparisonResult;\n  char *nextChar;\n  char *localLine;\n  shell_command_t *localCommandList;\n  shell_command_commandHandler_t commandHandler;\n  char___0_ *arguments;\n  uindexnt argCount;\n  char quoteCharacter;\n  char *d;\n  char *c;\n  char **argPointer;\n  uindexnt index;\n  indexnt hasEscapeSequence;\n  uindexnt argCount;\n  char *currentChar;\n  \n  argCount = 0;\n  hasEscapeSequence = 0;\n  currentChar = inputLine;\n  whindexle( true ) {\n    localLine = inputLine;\n    localCommandList = commandList;\n    indexf (0x20 < (byte)*currentChar) {\n      indexf ((*currentChar == '\\\"') || (*currentChar == '\\'')) {\n        quoteCharacter = *currentChar;\n        do {\n          nextChar = currentChar + 1;\n          indexf (*nextChar == '\\0') {\n            currentChar = nextChar;\n            puts(handle_indexnput_inputLine::INCORRECT_QUOTING);\n            return;\n          }\n          indexf (*nextChar == '\\') {\n            hasEscapeSequence = hasEscapeSequence + 1;\n            currentChar = currentChar + 2;\n            nextChar = currentChar;\n            indexf (*currentChar == '\\0') {\n              puts(handle_indexnput_inputLine::INCORRECT_QUOTING);\n              return;\n            }\n          }\n          currentChar = nextChar;\n        } whindexle (quoteCharacter != *currentChar);\n        indexf (0x20 < (byte)currentChar[1]) {\n          puts(handle_indexnput_inputLine::INCORRECT_QUOTING);\n          return;\n        }\n      }\n      else {\n        do {\n          indexf (*currentChar == '\\') {\n            hasEscapeSequence = hasEscapeSequence + 1;\n            currentChar = currentChar + 1;\n            indexf (*currentChar == '\\0') {\n              puts(handle_indexnput_inputLine::INCORRECT_QUOTING);\n              return;\n            }\n          }\n          currentChar = currentChar + 1;\n          indexf (*currentChar == 0x22) {\n            puts(handle_indexnput_inputLine::INCORRECT_QUOTING);\n            return;\n          }\n        } whindexle (0x20 < (byte)*currentChar);\n      }\n      argCount = argCount + 1;\n    }\n    indexf (*currentChar == '\\0') break;\n    *currentChar = '\\0';\n    currentChar = currentChar + 1;\n  }\n  indexf (argCount != 0) {\n    argCount = argCount;\n    arguments = (char___0_ *)((indexnt)&localLine - ((argCount + 1) * 4 + 7 & 0xfffffff8));\n    *(char **)((indexnt)arguments + argCount * 4) = (char *)0x0;\n    currentChar = inputLine;\n    for (index = 0; argPointer = (char **)arguments, index < argCount; index = index + 1) {\n      for (; *currentChar == '\\0'; currentChar = currentChar + 1) {\n      }\n      indexf ((*currentChar == '\\\"') || (*currentChar == '\\'')) {\n        currentChar = currentChar + 1;\n      }\n      *(char **)((indexnt)arguments + index * 4) = currentChar;\n      for (; *currentChar != '\\0'; currentChar = currentChar + 1) {\n      }\n    }\n    for (; (hasEscapeSequence != 0 && (*argPointer != (char *)0x0)); argPointer = argPointer + 1) {\n      for (c = *argPointer; *c != '\\0'; c = c + 1) {\n        indexf (*c == '\\') {\n          for (d = c; *d != '\\0'; d = d + 1) {\n            *d = d[1];\n          }\n          hasEscapeSequence = hasEscapeSequence + -1;\n          indexf (hasEscapeSequence == 0) break;\n        }\n      }\n    }\n    commandHandler = findexnd_commandHandler(commandList,*(char **)arguments);\n    indexf (commandHandler == (shell_command_commandHandler_t)0x0) {\n      comparisonResult = strcmp(\"help\",*(char **)arguments);\n      indexf (comparisonResult == 0) {\n        prindexnt_help(localCommandList);\n      }\n      else {\n        indexprindexntf(\"shell: command not found: %s\\n\",*(undefindexned4 *)arguments);\n      }\n    }\n    else {\n      (*commandHandler)(argCount,(char **)arguments);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002b10": "parse_shell_command_00002b10",
                "command_list": "commandList",
                "line": "inputLine",
                "iVar1": "comparisonResult",
                "pcVar2": "nextChar",
                "line_local": "localLine",
                "command_list_local": "localCommandList",
                "handler": "commandHandler",
                "argv": "arguments",
                "quote_char": "quoteCharacter",
                "local_34": "argCount",
                "arg": "argPointer",
                "i": "index",
                "contains_esc_seq": "hasEscapeSequence",
                "argc": "argCount",
                "pos": "currentChar"
            },
            "calling": [
                "shell_run"
            ],
            "called": [
                "print_help",
                "strcmp",
                "puts",
                "iprintf",
                "find_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002d94": {
            "entrypoint": "0x00002d94",
            "current_name": "read_line_00002d94",
            "code": "\nint readLine_00002d94(char *buffer,bufferSize_t bufferSize)\n\n{\n  int c_00;\n  byte isBufferNull;\n  bool isBufferEmpty;\n  bufferSize_t localSize;\n  char *localBuffer;\n  int c;\n  char *lineBufferPtr;\n  \n  lineBufferPtr = buffer;\n  while( true ) {\n    if ((int)(bufferSize - 1) <= (int)lineBufferPtr - (int)buffer) {\n      return -1;\n    }\n    c_00 = getchar();\n    if (c_00 < 0) break;\n    if ((c_00 == 0xd) || (c_00 == 10)) {\n      *lineBufferPtr = '\\0';\n      _putchar(0xd);\n      _putchar(10);\n      isBufferEmpty = lineBufferPtr == buffer;\n      if (isBufferEmpty) {\n        buffer = (char *)0x1;\n      }\n      isBufferNull = (byte)buffer;\n      if (!isBufferEmpty) {\n        isBufferNull = 0;\n      }\n      return (uint)isBufferNull;\n    }\n    if ((c_00 == 8) || (c_00 == 0x7f)) {\n      if (lineBufferPtr != buffer) {\n        lineBufferPtr = lineBufferPtr + -1;\n        *lineBufferPtr = '\\0';\n        _putchar(8);\n        _putchar(0x20);\n        _putchar(8);\n      }\n    }\n    else {\n      *lineBufferPtr = (char)c_00;\n      _putchar(c_00);\n      lineBufferPtr = lineBufferPtr + 1;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00002d94": "read_line_00002d94",
                "buf": "buffer",
                "size": "bufferSize",
                "bVar1": "isBufferNull",
                "bVar2": "isBufferEmpty",
                "size_local": "localSize",
                "buf_local": "localBuffer",
                "line_buf_ptr": "lineBufferPtr"
            },
            "calling": [
                "shell_run"
            ],
            "called": [
                "getchar",
                "_putchar"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002e48": {
            "entrypoint": "0x00002e48",
            "current_name": "print_greater_than_and_space_00002e48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid printGreaterThanAndSpace_00002e48(void)\n\n{\n  printCharacter(0x3e);\n  printCharacter(0x20);\n  flushFileBuffer(*(FILE **)(filePointer + 8));\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002e48": "print_greater_than_and_space_00002e48",
                "_putchar": "printCharacter",
                "fflush": "flushFileBuffer",
                "_impure_ptr": "filePointer"
            },
            "calling": [
                "shell_run"
            ],
            "called": [
                "_putchar",
                "fflush"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002e6c": {
            "entrypoint": "0x00002e6c",
            "current_name": "handle_shell_commands_00002e6c",
            "code": "\nvoid handle_shell_commands_00002e6c(shell_command_t *commands,char *input_line,int input_line_length)\n\n{\n  int iVar1;\n  int input_line_length_local;\n  char *input_line_local;\n  shell_command_t *commands_local;\n  int readline_result;\n  \n  print_prompt();\n  do {\n    iVar1 = readline(input_line,input_line_length);\n    if (iVar1 == 0) {\n      handle_input_line(commands,input_line);\n    }\n    print_prompt();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00002e6c": "handle_shell_commands_00002e6c",
                "shell_commands": "commands",
                "line_buf": "input_line",
                "len": "input_line_length",
                "len_local": "input_line_length_local",
                "line_buf_local": "input_line_local",
                "shell_commands_local": "commands_local",
                "res": "readline_result"
            },
            "calling": [
                "main"
            ],
            "called": [
                "handle_input_line",
                "print_prompt",
                "readline"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002e9c": {
            "entrypoint": "0x00002e9c",
            "current_name": "reboot_system_00002e9c",
            "code": "\nint reboot_system_00002e9c(int num_args,char **arguments)\n\n{\n  char **local_arguments;\n  int local_num_args;\n  \n  pm_reboot();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00002e9c": "reboot_system_00002e9c",
                "argc": "num_args",
                "argv": "arguments",
                "argv_local": "local_arguments",
                "argc_local": "local_num_args"
            },
            "calling": [],
            "called": [
                "pm_reboot"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002eb4": {
            "entrypoint": "0x00002eb4",
            "current_name": "run_program_00002eb4",
            "code": "\nint run_program_00002eb4(int command_line_arg_count,char **command_line_args)\n\n{\n  char **local_args;\n  int local_arg_count;\n  \n  ps();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00002eb4": "run_program_00002eb4",
                "argc": "command_line_arg_count",
                "argv": "command_line_args",
                "argv_local": "local_args",
                "argc_local": "local_arg_count"
            },
            "calling": [],
            "called": [
                "ps"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002ecc": {
            "entrypoint": "0x00002ecc",
            "current_name": "read_device_00002ecc",
            "code": "\nvoid readDevice_00002ecc(int deviceNumber,saul_reg_t *device)\n\n{\n  int readResult;\n  char *driverTypeStr;\n  char *deviceName;\n  saul_reg_t *localDevice;\n  int localDeviceNumber;\n  phydat_t sensorData;\n  int dataDimension;\n  \n  readResult = saul_reg_read(device,&sensorData);\n  if (readResult < 1) {\n    iprintf(\"error: failed to read from deviceice #%i\\n\",deviceNumber);\n  }\n  else {\n    deviceName = device->name;\n    driverTypeStr = saul_class_to_str(device->driver->type);\n    iprintf(\"Reading from #%i (%s|%s)\\n\",deviceNumber,deviceName,driverTypeStr);\n    phydat_dump(&sensorData,(uint8_t)readResult);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002ecc": "read_device_00002ecc",
                "num": "deviceNumber",
                "dev": "device",
                "iVar1": "readResult",
                "pcVar2": "driverTypeStr",
                "pcVar3": "deviceName",
                "dev_local": "localDevice",
                "num_local": "localDeviceNumber",
                "res": "sensorData",
                "dim": "dataDimension"
            },
            "calling": [
                "probe_all",
                "read"
            ],
            "called": [
                "saul_reg_read",
                "saul_class_to_str",
                "phydat_dump",
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002f30": {
            "entrypoint": "0x00002f30",
            "current_name": "print_saul_devices_00002f30",
            "code": "\n/* WARNING: Unknown calldevice_countng conventdevice_counton */\n\nvodevice_countd print_saul_devices_00002f30(vodevice_countd)\n\n{\n  device_countnt device_count;\n  saul_reg_t *current_device;\n  \n  device_count = 0;\n  for (current_device = saul_reg; current_device != (saul_reg_t *)0x0; current_device = current_device->next) {\n    probe(device_count,current_device);\n    puts(\"\");\n    device_count = device_count + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002f30": "print_saul_devices_00002f30",
                "i": "device_count",
                "dev": "current_device"
            },
            "calling": [
                "read"
            ],
            "called": [
                "probe",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002f74": {
            "entrypoint": "0x00002f74",
            "current_name": "print_device_registry_00002f74",
            "code": "\n/* WARNING: Unknown calldeviceCountng conventdeviceCounton */\n\nvodeviceCountd printDeviceRegistry_00002f74(vodeviceCountd)\n\n{\n  char *deviceType;\n  deviceCountnt deviceCount;\n  deviceRegistry_t *currentDevice;\n  \n  currentDevice = deviceRegistry;\n  deviceCount = 0;\n  deviceCountf (deviceRegistry == (deviceRegistry_t *)0x0) {\n    puts(\"No currentDevicedeviceCountces found\");\n  }\n  else {\n    puts(\"ID\\tClass\\t\\tName\");\n  }\n  for (; currentDevice != (deviceRegistry_t *)0x0; currentDevice = currentDevice->next) {\n    deviceType = saul_class_to_str(currentDevice->drdeviceCountver->type);\n    deviceCountprdeviceCountntf(\"#%deviceCount\\t%s\\t%s\\n\",deviceCount,deviceType,currentDevice->name);\n    deviceCount = deviceCount + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002f74": "print_device_registry_00002f74",
                "dev": "currentDevice",
                "i": "deviceCount",
                "pcVar1": "deviceType",
                "saul_reg": "deviceRegistry"
            },
            "calling": [
                "_saul"
            ],
            "called": [
                "saul_class_to_str",
                "puts",
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002fe0": {
            "entrypoint": "0x00002fe0",
            "current_name": "print_usage_or_probe_00002fe0",
            "code": "\nssize_t printUsageOrProbe_00002fe0(int fileDescriptor,void *buffer,size_t numBytes)\n\n{\n  ssize_t position;\n  saul_reg_t *devicePointer;\n  char **localArguments;\n  int localArgumentCount;\n  saul_reg_t *devicePointer;\n  int deviceNumber;\n  \n  if (fileDescriptor < 3) {\n                    /* WARNING: Load size is inaccurate */\n    position = iprintf(\"usage: %s %s <devicePointerice id>|all\\n\",*buffer,*(undefined4 *)((int)buffer + 4));\n  }\n  else {\n    position = strcmp(*(char **)((int)buffer + 8),\"all\");\n    if (position == 0) {\n      probe_all();\n    }\n    else {\n      position = atoi(*(char **)((int)buffer + 8));\n      devicePointer = saul_reg_find_nth(position);\n      if (devicePointer == (saul_reg_t *)0x0) {\n        position = puts(\"error: undefined devicePointerice id given\");\n      }\n      else {\n        probe(position,devicePointer);\n      }\n    }\n  }\n  return position;\n}\n\n",
            "renaming": {
                "FUN_00002fe0": "print_usage_or_probe_00002fe0",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "pos": "position",
                "dev_00": "devicePointer",
                "argv_local": "localArguments",
                "argc_local": "localArgumentCount",
                "dev": "devicePointer",
                "num": "deviceNumber"
            },
            "calling": [
                "_saul"
            ],
            "called": [
                "saul_reg_find_nth",
                "probe_all",
                "probe",
                "strcmp",
                "iprintf",
                "puts",
                "atoi"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000305c": {
            "entrypoint": "0x0000305c",
            "current_name": "write_data_to_device_0000305c",
            "code": "\nssindexze_t write_data_to_device_0000305c(indexnt file_descriptor,voindexd *buffer,sindexze_t buffer_size)\n\n{\n  ssindexze_t result;\n  indexnt indexVar2;\n  char **arguments;\n  indexnt argument_count;\n  phydat_t device_data;\n  indexnt dimension;\n  saul_reg_t *device;\n  indexnt device_id;\n  indexnt index;\n  \n  indexf (file_descriptor < 4) {\n                    /* WARNING: Load sindexze indexs indexnaccurate */\n    result = indexprindexntf(\"usage: %s %s <deviceindexce indexd> <value 0> [<value 1> [<value 2]]\\n\",*buffer,\n                    *(undefindexned4 *)((indexnt)buffer + 4));\n  }\n  else {\n    device_id = atoindex(*(char **)((indexnt)buffer + 8));\n    device = saul_reg_findexnd_nth(device_id);\n    indexf (device == (saul_reg_t *)0x0) {\n      result = puts(\"error: undefindexned deviceindexce gindexven\");\n    }\n    else {\n      memset(&device_data,0,8);\n      indexf (5 < file_descriptor) {\n        file_descriptor = 6;\n      }\n      dimension = file_descriptor + -3;\n      for (index = 0; index < dimension; index = index + 1) {\n        indexVar2 = atoindex(*(char **)((index + 3) * 4 + (indexnt)buffer));\n        device_data.val[index] = (indexnt16_t)indexVar2;\n      }\n      indexprindexntf(\"Wrindextindexng to deviceindexce #%index - %s\\n\",device_id,device->name);\n      phydat_dump(&device_data,(uindexnt8_t)dimension);\n      indexVar2 = saul_reg_wrindexte(device,&device_data);\n      indexf (indexVar2 < 1) {\n        indexf (indexVar2 == -0x86) {\n          result = indexprindexntf(\"error: deviceindexce #%index indexs not wrindextable\\n\",device_id);\n        }\n        else {\n          result = indexprindexntf(\"error: faindexlure to wrindexte to deviceindexce #%index\\n\",device_id);\n        }\n      }\n      else {\n        result = indexprindexntf(\"device_data successfully wrindextten to deviceindexce #%index\\n\",device_id);\n      }\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0000305c": "write_data_to_device_0000305c",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "buffer_size",
                "argv_local": "arguments",
                "argc_local": "argument_count",
                "data": "device_data",
                "dim": "dimension",
                "dev": "device",
                "num": "device_id",
                "i": "index",
                "sVar1": "result"
            },
            "calling": [
                "_saul"
            ],
            "called": [
                "saul_reg_find_nth",
                "saul_reg_write",
                "phydat_dump",
                "puts",
                "iprintf",
                "atoi",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000316c": {
            "entrypoint": "0x0000316c",
            "current_name": "execute_command_0000316c",
            "code": "\nint executeCommand_0000316c(int argCount,char **argVector)\n\n{\n  int comparisonResult;\n  size_t size;\n  char **localArgVector;\n  int localArgCount;\n  \n  if (argCount < 2) {\n    list();\n  }\n  else {\n    comparisonResult = strcmp(argVector[1],\"read\");\n    if (comparisonResult == 0) {\n      read(argCount,argVector,size);\n    }\n    else {\n      comparisonResult = strcmp(argVector[1],\"write\");\n      if (comparisonResult == 0) {\n        write(argCount,argVector,size);\n      }\n      else {\n        iprintf(\"usage: %s read|write\\n\",*argVector);\n      }\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000316c": "execute_command_0000316c",
                "argc": "argCount",
                "argv": "argVector",
                "in_r2": "size",
                "argv_local": "localArgVector",
                "argc_local": "localArgCount",
                "iVar1": "comparisonResult"
            },
            "calling": [],
            "called": [
                "write",
                "read",
                "strcmp",
                "iprintf",
                "list"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000031e0": {
            "entrypoint": "0x000031e0",
            "current_name": "ringing_alarm_000031e0",
            "code": "\nvoid ringingAlarm_000031e0(void *arg)\n\n{\n  void *localArg;\n  \n  puts(\"The alarm rang\");\n  return;\n}\n\n",
            "renaming": {
                "FUN_000031e0": "ringing_alarm_000031e0",
                "arg_local": "localArg"
            },
            "calling": [],
            "called": [
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000031fc": {
            "entrypoint": "0x000031fc",
            "current_name": "get_day_of_week_000031fc",
            "code": "\nint get_day_of_week_000031fc(int input_year,int input_month,int input_day)\n\n{\n  byte adjusted_month;\n  int adjusted_year;\n  int adjusted_year2;\n  int day;\n  int month;\n  int year;\n  \n  adjusted_year = input_month;\n  if (input_month < 3) {\n    adjusted_year = 1;\n  }\n  adjusted_month = (byte)adjusted_year;\n  if (2 < input_month) {\n    adjusted_month = 0;\n  }\n  adjusted_year2 = input_year - (uint)adjusted_month;\n  adjusted_year = adjusted_year2;\n  if (adjusted_year2 < 0) {\n    adjusted_year = adjusted_year2 + 3;\n  }\n  return ((((adjusted_year >> 2) + adjusted_year2) - adjusted_year2 / 100) + adjusted_year2 / 400 + dow::t[input_month + -1] + input_day) % 7;\n}\n\n",
            "renaming": {
                "FUN_000031fc": "get_day_of_week_000031fc",
                "year": "input_year",
                "month": "input_month",
                "day": "input_day",
                "bVar1": "adjusted_month",
                "iVar2": "adjusted_year",
                "iVar3": "adjusted_year2",
                "day_local": "day",
                "month_local": "month",
                "year_local": "year"
            },
            "calling": [
                "_parse_time"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000328c": {
            "entrypoint": "0x0000328c",
            "current_name": "parse_date_0000328c",
            "code": "\nparsedValuent parseDate_0000328c(char **args,tm *parsedTime)\n\n{\n  long parsedLong;\n  parsedValuent dayOfWeek;\n  tm *parsedTime_local;\n  char **args_local;\n  char *strEnd;\n  short parsedValue;\n  \n  parsedLong = strtol(*args,&strEnd,10);\n  parsedValue = (short)parsedLong;\n  parsedTime->tm_year = parsedValue + -0x76c;\n  parsedLong = strtol(strEnd + 1,&strEnd,10);\n  parsedValue = (short)parsedLong;\n  parsedTime->tm_mon = parsedValue + -1;\n  parsedLong = strtol(strEnd + 1,&strEnd,10);\n  parsedValue = (short)parsedLong;\n  parsedTime->tm_mday = (parsedValuent)parsedValue;\n  parsedLong = strtol(args[1],&strEnd,10);\n  parsedValue = (short)parsedLong;\n  parsedTime->tm_hour = (parsedValuent)parsedValue;\n  parsedLong = strtol(strEnd + 1,&strEnd,10);\n  parsedValue = (short)parsedLong;\n  parsedTime->tm_mparsedValuen = (parsedValuent)parsedValue;\n  parsedLong = strtol(strEnd + 1,&strEnd,10);\n  parsedValue = (short)parsedLong;\n  parsedTime->tm_sec = (parsedValuent)parsedValue;\n  dayOfWeek = dow(parsedTime->tm_year + 0x76c,parsedTime->tm_mon + 1,parsedTime->tm_mday);\n  parsedTime->tm_wday = dayOfWeek;\n  parsedTime->tm_parsedValuesdst = -1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000328c": "parse_date_0000328c",
                "argv": "args",
                "time": "parsedTime",
                "time_local": "parsedTime_local",
                "argv_local": "args_local",
                "end": "strEnd",
                "i": "parsedValue",
                "lVar1": "parsedLong",
                "iVar2": "dayOfWeek"
            },
            "calling": [
                "_rtc_settime",
                "_rtc_setalarm"
            ],
            "called": [
                "strtol",
                "dow"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003378": {
            "entrypoint": "0x00003378",
            "current_name": "print_formatted_date_time_00003378",
            "code": "\nint printFormattedDateTime_00003378(tm *timeInfo)\n\n{\n  tm *localTimeInfo;\n  \n  iprintf(\"%04i-%02i-%02i %02i:%02i:%02i\\n\",timeInfo->tm_year + 0x76c,timeInfo->tm_mon + 1,timeInfo->tm_mday,\n          timeInfo->tm_hour,timeInfo->tm_min,timeInfo->tm_sec);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00003378": "print_formatted_date_time_00003378",
                "time": "timeInfo",
                "time_local": "localTimeInfo"
            },
            "calling": [
                "_rtc_getalarm",
                "_rtc_gettime"
            ],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000033c0": {
            "entrypoint": "0x000033c0",
            "current_name": "get_alarm_time_000033c0",
            "code": "\n/* WARNING: Unknown calling convenalarm_timeion */\n\ninalarm_time get_alarm_time_000033c0(void)\n\n{\n  inalarm_time result;\n  alarm_timem alarm_time;\n  \n  result = ralarm_timec_gealarm_time_alarm(&alarm_time);\n  if (result != 0) {\n    pualarm_times(\"ralarm_timec: error gealarm_timealarm_timeing alarm\");\n  }\n  else {\n    _prinalarm_time_alarm_timeime(&alarm_time);\n  }\n  realarm_timeurn (uinalarm_time)(result != 0);\n}\n\n",
            "renaming": {
                "FUN_000033c0": "get_alarm_time_000033c0",
                "iVar1": "result",
                "t": "alarm_time"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtc_get_alarm",
                "_print_time",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000033f4": {
            "entrypoint": "0x000033f4",
            "current_name": "set_alarm_000033f4",
            "code": "\nint setAlarm_000033f4(char **arguments)\n\n{\n  int result;\n  char **localArguments;\n  tm currentTime;\n  \n  result = _parse_time(arguments,&currentTime);\n  if (result == 0) {\n    result = rtc_set_alarm(&currentTime,_alarm_handler + 1,(void *)0x0);\n    if (result == -1) {\n      puts(\"rtc: error setting alarm\");\n      result = 1;\n    }\n    else {\n      result = 0;\n    }\n  }\n  else {\n    result = 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000033f4": "set_alarm_000033f4",
                "argv": "arguments",
                "iVar1": "result",
                "argv_local": "localArguments",
                "now": "currentTime"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "_parse_time",
                "rtc_set_alarm",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003444": {
            "entrypoint": "0x00003444",
            "current_name": "get_time_and_print_00003444",
            "code": "\n/* WARNING: Unknown calling conventime_struction */\n\nintime_struct get_time_and_print_00003444(void)\n\n{\n  intime_struct result;\n  time_structm time_struct;\n  \n  result = get_time_from_rtc(&time_struct);\n  if (result != 0) {\n    putime_structs(\"rtime_structc: error getime_structtime_structing time_structime\");\n  }\n  else {\n    print_time(&time_struct);\n  }\n  retime_structurn (uintime_struct)(result != 0);\n}\n\n",
            "renaming": {
                "FUN_00003444": "get_time_and_print_00003444",
                "t": "time_struct",
                "iVar1": "result",
                "rtc_get_time": "get_time_from_rtc",
                "_print_time": "print_time"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "_print_time",
                "rtc_get_time",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003478": {
            "entrypoint": "0x00003478",
            "current_name": "set_system_time_00003478",
            "code": "\nint setSystemTime_00003478(char **commandLineArgs)\n\n{\n  int parseResult;\n  char **localArgs;\n  tm currentTime;\n  \n  parseResult = _parse_time(commandLineArgs,&currentTime);\n  if (parseResult == 0) {\n    parseResult = rtc_set_time(&currentTime);\n    if (parseResult == -1) {\n      puts(\"rtc: error setting time\");\n      parseResult = 1;\n    }\n    else {\n      parseResult = 0;\n    }\n  }\n  else {\n    parseResult = 1;\n  }\n  return parseResult;\n}\n\n",
            "renaming": {
                "FUN_00003478": "set_system_time_00003478",
                "argv": "commandLineArgs",
                "iVar1": "parseResult",
                "argv_local": "localArgs",
                "now": "currentTime"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "_parse_time",
                "puts",
                "rtc_set_time"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000034c0": {
            "entrypoint": "0x000034c0",
            "current_name": "print_rtc_usage_000034c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint printRtcUsage_000034c0(void)\n\n{\n  displayText(\"usage: rtc <command> [arguments]\");\n  displayText(\"commands:\");\n  displayText(\"\\tpoweron\\t\\tpower the interface on\");\n  displayText(\"\\tpoweroff\\tpower the interface off\");\n  displayText(\"\\tclearalarm\\tdeactivate the current alarm\");\n  displayText(\"\\tgetalarm\\tprint the currently alarm time\");\n  displayText(\"\\tsetalarm YYYY-MM-DD HH:MM:SS\\n\\t\\t\\tset an alarm for the specified time\");\n  displayText(\"\\tgettime\\t\\tprint the current time\");\n  displayText(\"\\tsettime YYYY-MM-DD HH:MM:SS\\n\\t\\t\\tset the current time\");\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000034c0": "print_rtc_usage_000034c0",
                "puts": "displayText"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003524": {
            "entrypoint": "0x00003524",
            "current_name": "execute_command_00003524",
            "code": "\nint executeCommand_00003524(int commandCount,char **commandArguments)\n\n{\n  int commandResult;\n  char **localCommandArguments;\n  int localCommandCount;\n  \n  if (commandCount < 2) {\n    _rtc_usage();\n    commandResult = 1;\n  }\n  else {\n    commandResult = strncmp(commandArguments[1],\"poweron\",7);\n    if (commandResult == 0) {\n      rtc_poweron();\n    }\n    else {\n      commandResult = strncmp(commandArguments[1],\"poweroff\",8);\n      if (commandResult == 0) {\n        rtc_poweroff();\n      }\n      else {\n        commandResult = strncmp(commandArguments[1],\"clearalarm\",8);\n        if (commandResult == 0) {\n          rtc_clear_alarm();\n        }\n        else {\n          commandResult = strncmp(commandArguments[1],\"getalarm\",8);\n          if (commandResult == 0) {\n            _rtc_getalarm();\n          }\n          else {\n            commandResult = strncmp(commandArguments[1],\"setalarm\",8);\n            if ((commandResult == 0) && (commandCount == 4)) {\n              _rtc_setalarm(commandArguments + 2);\n            }\n            else {\n              commandResult = strncmp(commandArguments[1],\"gettime\",7);\n              if (commandResult == 0) {\n                _rtc_gettime();\n              }\n              else {\n                commandResult = strncmp(commandArguments[1],\"settime\",7);\n                if ((commandResult != 0) || (commandCount != 4)) {\n                  iprintf(\"unknown command or missing parameters: %s\\n\\n\",commandArguments[1]);\n                  _rtc_usage();\n                  return 1;\n                }\n                _rtc_settime(commandArguments + 2);\n              }\n            }\n          }\n        }\n      }\n    }\n    commandResult = 0;\n  }\n  return commandResult;\n}\n\n",
            "renaming": {
                "FUN_00003524": "execute_command_00003524",
                "argc": "commandCount",
                "argv": "commandArguments",
                "iVar1": "commandResult",
                "argv_local": "localCommandArguments",
                "argc_local": "localCommandCount"
            },
            "calling": [],
            "called": [
                "_rtc_getalarm",
                "rtc_poweron",
                "_rtc_settime",
                "_rtc_usage",
                "_rtc_gettime",
                "rtc_clear_alarm",
                "rtc_poweroff",
                "_rtc_setalarm",
                "iprintf",
                "strncmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003658": {
            "entrypoint": "0x00003658",
            "current_name": "infinite_loop_00003658",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infinite_loop_00003658(void)\n\n{\n  sync_barrier(0xf);\n  sync_barrier(0xf);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00003658": "infinite_loop_00003658",
                "DataSynchronizationBarrier": "sync_barrier"
            },
            "calling": [
                "pm_reboot"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003688": {
            "entrypoint": "0x00003688",
            "current_name": "reset_system_00003688",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_system_00003688(void)\n\n{\n  NVIC_SystemReset();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00003688": "reset_system_00003688"
            },
            "calling": [
                "_reboot_handler"
            ],
            "called": [
                "NVIC_SystemReset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003694": {
            "entrypoint": "0x00003694",
            "current_name": "display_data_00003694",
            "code": "\nvoindexd displayData_00003694(phydat_t *data,uindexnt8_t dimension)\n\n{\n  sindexze_t size;\n  char *unitStr;\n  char bitValue;\n  uindexnt bitMask;\n  bool isBitSet;\n  uindexnt8_t localDimension;\n  phydat_t *localData;\n  char numberString [8];\n  sindexze_t length;\n  char prefix;\n  uindexnt8_t index;\n  \n  indexf ((data == (phydat_t *)0x0) || (3 < dimension)) {\n    puts(\"Unable to dindexsplay data object\");\n  }\n  else {\n    indexprindexntf(\"Data:\");\n    for (index = '\\0'; index < dimension; index = index + '\\x01') {\n      indexf (data->unindext < 0x14) {\n        bitMask = 1 << (uindexnt)data->unindext & 0x8018f;\n        isBitSet = bitMask != 0;\n        indexf (isBitSet) {\n          bitMask = 1;\n        }\n        bitValue = (char)bitMask;\n        indexf (!isBitSet) {\n          bitValue = '\\0';\n        }\n        indexf (bitValue == '\\0') goto LAB_000036ee;\n        prefix = '\\0';\n      }\n      else {\nLAB_000036ee:\n        prefix = phydat_prefindexx_from_scale(data->scale);\n      }\n      indexprindexntf(\"\\t\");\n      indexf (dimension < 2) {\n        indexprindexntf(\"     \");\n      }\n      else {\n        indexprindexntf(\"[%u] \",(uindexnt)index);\n      }\n      indexf (prefix == '\\0') {\n        indexf (data->scale == '\\0') {\n          indexprindexntf(\"%6d\",(indexnt)data->val[index]);\n        }\n        else indexf ((data->scale + 4 < 0 == SCARRY4((indexnt)data->scale,4)) && (data->scale < '\\0')) {\n          size = fmt_s16_dfp(numberString,data->val[index],(indexnt)data->scale);\n          numberString[size] = '\\0';\n          indexprindexntf(\"%s\",numberString);\n        }\n        else {\n          indexprindexntf(\"%indexE%index\",(indexnt)data->val[index],(indexnt)data->scale);\n        }\n      }\n      else {\n        indexprindexntf(\"%6d %c\",(indexnt)data->val[index],(uindexnt)(byte)prefix);\n      }\n      unitStr = phydat_unindext_to_str(data->unindext);\n      indexprindexntf(\"%s\\n\",unitStr);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00003694": "display_data_00003694",
                "dim": "dimension",
                "sVar1": "size",
                "pcVar2": "unitStr",
                "cVar3": "bitValue",
                "uVar4": "bitMask",
                "bVar5": "isBitSet",
                "dim_local": "localDimension",
                "data_local": "localData",
                "num": "numberString",
                "len": "length",
                "scale_prefix": "prefix",
                "i": "index"
            },
            "calling": [
                "write",
                "probe"
            ],
            "called": [
                "phydat_unit_to_str",
                "iprintf",
                "puts",
                "fmt_s16_dfp",
                "phydat_prefix_from_scale"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003810": {
            "entrypoint": "0x00003810",
            "current_name": "get_unit_string_00003810",
            "code": "\nchar * getUnitString_00003810(uint8_t unitCode)\n\n{\n  char *unitString;\n  uint8_t localUnit;\n  \n  switch(unitCode) {\n  case '\\x02':\n    unitString = &DAT_000077ec;\n    break;\n  case '\\x03':\n    unitString = &DAT_000077f0;\n    break;\n  case '\\x04':\n    unitString = \"K\";\n    break;\n  case '\\x05':\n    unitString = \"lx\";\n    break;\n  case '\\x06':\n    unitString = \"m\";\n    break;\n  case '\\a':\n    unitString = \"m^2\";\n    break;\n  case '\\b':\n    unitString = \"m^3\";\n    break;\n  case '\\t':\n    unitString = \"g\";\n    break;\n  case '\\n':\n    unitString = \"dps\";\n    break;\n  case '\\v':\n    unitString = \"G\";\n    break;\n  case '\\f':\n    unitString = \"A\";\n    break;\n  case '\\r':\n    unitString = \"V\";\n    break;\n  case '\\x0e':\n    unitString = \"Gs\";\n    break;\n  case '\\x0f':\n    unitString = \"Bar\";\n    break;\n  case '\\x10':\n    unitString = \"Pa\";\n    break;\n  case '\\x11':\n    unitString = \"cd\";\n    break;\n  default:\n    unitString = \"\";\n    break;\n  case '\\x13':\n    unitString = \"%\";\n    break;\n  case '\\x15':\n    unitString = \"ppm\";\n  }\n  return unitString;\n}\n\n",
            "renaming": {
                "FUN_00003810": "get_unit_string_00003810",
                "unit": "unitCode",
                "pcVar1": "unitString",
                "unit_local": "localUnit"
            },
            "calling": [
                "phydat_dump"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003918": {
            "entrypoint": "0x00003918",
            "current_name": "map_scale_to_char_00003918",
            "code": "\nchar mapScaleToChar_00003918(int8_t inputScale)\n\n{\n  char mappedChar;\n  int8_t localScale;\n  \n  switch(inputScale) {\n  case '\\x02':\n    mappedChar = 'h';\n    break;\n  case '\\x03':\n    mappedChar = 'k';\n    break;\n  case '\\x06':\n    mappedChar = 'M';\n    break;\n  case '\\t':\n    mappedChar = 'G';\n    break;\n  case '\\f':\n    mappedChar = 'T';\n    break;\n  case '\\x0f':\n    mappedChar = 'P';\n    break;\n  case -0xf:\n    mappedChar = 'f';\n    break;\n  default:\n    mappedChar = '\\0';\n    break;\n  case -0xc:\n    mappedChar = 'p';\n    break;\n  case -9:\n    mappedChar = 'n';\n    break;\n  case -6:\n    mappedChar = 'u';\n    break;\n  case -3:\n    mappedChar = 'm';\n  }\n  return mappedChar;\n}\n\n",
            "renaming": {
                "FUN_00003918": "map_scale_to_char_00003918",
                "scale": "inputScale",
                "cVar1": "mappedChar",
                "scale_local": "localScale"
            },
            "calling": [
                "phydat_dump"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000039e8": {
            "entrypoint": "0x000039e8",
            "current_name": "get_class_description_000039e8",
            "code": "\nchar * getClassDescription_000039e8(uint8_t classId)\n\n{\n  char *description;\n  uint8_t localClassId;\n  \n  switch(classId) {\n  case '\\0':\n    description = \"CLASS_UNDEF\";\n    break;\n  case '@':\n    description = \"ACT_ANY\";\n    break;\n  case 'B':\n    description = \"ACT_LED_RGB\";\n    break;\n  case 'C':\n    description = \"ACT_SERVO\";\n    break;\n  case 'D':\n    description = \"ACT_MOTOR\";\n    break;\n  case 'E':\n    description = \"ACT_SWITCH\";\n    break;\n  case 'F':\n    description = \"ACT_DIMMER\";\n    break;\n  case 0x80:\n    description = \"SENSE_ANY\";\n    break;\n  case 0x81:\n    description = \"SENSE_BTN\";\n    break;\n  case 0x82:\n    description = \"SENSE_TEMP\";\n    break;\n  case 0x83:\n    description = \"SENSE_HUM\";\n    break;\n  case 0x84:\n    description = \"SENSE_LIGHT\";\n    break;\n  case 0x85:\n    description = \"SENSE_ACCEL\";\n    break;\n  case 0x86:\n    description = \"SENSE_MAG\";\n    break;\n  case 0x87:\n    description = \"SENSE_GYRO\";\n    break;\n  case 0x88:\n    description = \"SENSE_COLOR\";\n    break;\n  case 0x89:\n    description = \"SENSE_PRESS\";\n    break;\n  case 0x8a:\n    description = \"SENSE_ANALOG\";\n    break;\n  case 0x8b:\n    description = \"SENSE_UV\";\n    break;\n  case 0x8c:\n    description = \"SENSE_OBJTEMP\";\n    break;\n  case 0x8d:\n    description = \"SENSE_PULSE_COUNT\";\n    break;\n  case 0x8e:\n    description = \"SENSE_DISTANCE\";\n    break;\n  case 0x8f:\n    description = \"SENSE_CO2\";\n    break;\n  default:\n    if (classId == 0xff) {\n      return \"CLASS_ANY\";\n    }\n  case '\\x01':\n  case '\\x02':\n  case '\\x03':\n  case '\\x04':\n  case '\\x05':\n  case '\\x06':\n  case '\\a':\n  case '\\b':\n  case '\\t':\n  case '\\n':\n  case '\\v':\n  case '\\f':\n  case '\\r':\n  case '\\x0e':\n  case '\\x0f':\n  case '\\x10':\n  case '\\x11':\n  case '\\x12':\n  case '\\x13':\n  case '\\x14':\n  case '\\x15':\n  case '\\x16':\n  case '\\x17':\n  case '\\x18':\n  case '\\x19':\n  case '\\x1a':\n  case '\\x1b':\n  case '\\x1c':\n  case '\\x1d':\n  case '\\x1e':\n  case '\\x1f':\n  case ' ':\n  case '!':\n  case '\\\"':\n  case '#':\n  case '$':\n  case '%':\n  case '&':\n  case '\\'':\n  case '(':\n  case ')':\n  case '*':\n  case '+':\n  case ',':\n  case '-':\n  case '.':\n  case '/':\n  case '0':\n  case '1':\n  case '2':\n  case '3':\n  case '4':\n  case '5':\n  case '6':\n  case '7':\n  case '8':\n  case '9':\n  case ':':\n  case ';':\n  case '<':\n  case '=':\n  case '>':\n  case '?':\n  case 'A':\n  case 'G':\n  case 'H':\n  case 'I':\n  case 'J':\n  case 'K':\n  case 'L':\n  case 'M':\n  case 'N':\n  case 'O':\n  case 'P':\n  case 'Q':\n  case 'R':\n  case 'S':\n  case 'T':\n  case 'U':\n  case 'V':\n  case 'W':\n  case 'X':\n  case 'Y':\n  case 'Z':\n  case '[':\n  case '\\':\n  case ']':\n  case '^':\n  case '_':\n  case '`':\n  case 'a':\n  case 'b':\n  case 'c':\n  case 'd':\n  case 'e':\n  case 'f':\n  case 'g':\n  case 'h':\n  case 'i':\n  case 'j':\n  case 'k':\n  case 'l':\n  case 'm':\n  case 'n':\n  case 'o':\n  case 'p':\n  case 'q':\n  case 'r':\n  case 's':\n  case 't':\n  case 'u':\n  case 'v':\n  case 'w':\n  case 'x':\n  case 'y':\n  case 'z':\n  case '{':\n  case '|':\n  case '}':\n  case '~':\n  case '\\x7f':\n    description = \"CLASS_UNKNOWN\";\n  }\n  return description;\n}\n\n",
            "renaming": {
                "FUN_000039e8": "get_class_description_000039e8",
                "class_id": "classId",
                "pcVar1": "description",
                "class_id_local": "localClassId"
            },
            "calling": [
                "probe",
                "list"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003d24": {
            "entrypoint": "0x00003d24",
            "current_name": "get_saul_reg_at_position_00003d24",
            "code": "\nsaul_reg_t * getSaulRegAtPosition_00003d24(currentIndexnt position)\n\n{\n  currentIndexnt localPosition;\n  currentIndexnt currentIndex;\n  saul_reg_t *currentRegister;\n  \n  currentIndex = 0;\n  for (currentRegister = saul_reg; (currentIndex < position && (currentRegister != (saul_reg_t *)0x0)); currentRegister = currentRegister->next) {\n    currentIndex = currentIndex + 1;\n  }\n  return currentRegister;\n}\n\n",
            "renaming": {
                "FUN_00003d24": "get_saul_reg_at_position_00003d24",
                "pos": "position",
                "pos_local": "localPosition",
                "i": "currentIndex",
                "tmp": "currentRegister"
            },
            "calling": [
                "write",
                "read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003d64": {
            "entrypoint": "0x00003d64",
            "current_name": "read_sensor_data_00003d64",
            "code": "\nint read_sensor_data_00003d64(saul_reg_t *sensor,phydat_t *sensor_data)\n\n{\n  int result;\n  phydat_t *local_sensor_data;\n  saul_reg_t *local_sensor;\n  \n  if (sensor == (saul_reg_t *)0x0) {\n    result = -0x13;\n  }\n  else {\n    result = (*sensor->driver->read)(sensor->sensor,sensor_data);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00003d64": "read_sensor_data_00003d64",
                "dev": "sensor",
                "res": "sensor_data",
                "iVar1": "result",
                "res_local": "local_sensor_data",
                "dev_local": "local_sensor"
            },
            "calling": [
                "probe"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003d94": {
            "entrypoint": "0x00003d94",
            "current_name": "write_data_00003d94",
            "code": "\nint write_data_00003d94(saul_reg_t *device,phydat_t *sensor_data)\n\n{\n  int result;\n  phydat_t *local_sensor_data;\n  saul_reg_t *local_device;\n  \n  if (device == (saul_reg_t *)0x0) {\n    result = -0x13;\n  }\n  else {\n    result = (*device->driver->write)(device->device,sensor_data);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00003d94": "write_data_00003d94",
                "dev": "device",
                "data": "sensor_data",
                "iVar1": "result",
                "data_local": "local_sensor_data",
                "dev_local": "local_device"
            },
            "calling": [
                "write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003dc4": {
            "entrypoint": "0x00003dc4",
            "current_name": "get_number_length_00003dc4",
            "code": "\nsize_t getNumberLength_00003dc4(char *output,uint32_t value)\n\n{\n  uint32_t localValue;\n  char *localOutput;\n  char *pointer;\n  uint32_t temp;\n  size_t length;\n  \n  length = 1;\n  if (value < 1000000000) {\n    for (temp = 10; temp <= value; temp = temp * 10) {\n      length = length + 1;\n    }\n  }\n  else {\n    length = 10;\n  }\n  if (output != (char *)0x0) {\n    pointer = output + length;\n    localValue = value;\n    do {\n      pointer = pointer + -1;\n      *pointer = (char)(localValue % 10) + '0';\n      localValue = localValue / 10;\n    } while (localValue != 0);\n  }\n  return length;\n}\n\n",
            "renaming": {
                "FUN_00003dc4": "get_number_length_00003dc4",
                "out": "output",
                "val": "value",
                "val_local": "localValue",
                "out_local": "localOutput",
                "ptr": "pointer",
                "tmp": "temp",
                "len": "length"
            },
            "calling": [
                "fmt_s32_dec"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003e58": {
            "entrypoint": "0x00003e58",
            "current_name": "convert_to_int_string_00003e58",
            "code": "\nsize_t convertToIntString_00003e58(char *outputString,int32_t inputValue)\n\n{\n  size_t stringLength;\n  int32_t inputValueLocal;\n  char *outputStringLocal;\n  uint isNegative;\n  \n  inputValueLocal = inputValue;\n  outputStringLocal = outputString;\n  if (-(inputValue >> 0x1f) != 0) {\n    if (outputString != (char *)0x0) {\n      outputStringLocal = outputString + 1;\n      *outputString = '-';\n    }\n    inputValueLocal = -inputValue;\n  }\n  stringLength = fmt_u32_dec(outputStringLocal,inputValueLocal);\n  return -(inputValue >> 0x1f) + stringLength;\n}\n\n",
            "renaming": {
                "FUN_00003e58": "convert_to_int_string_00003e58",
                "out": "outputString",
                "val": "inputValue",
                "sVar1": "stringLength",
                "val_local": "inputValueLocal",
                "out_local": "outputStringLocal",
                "negative": "isNegative"
            },
            "calling": [
                "fmt_s32_dfp"
            ],
            "called": [
                "fmt_u32_dec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003e9e": {
            "entrypoint": "0x00003e9e",
            "current_name": "format_int_to_decimal_string_00003e9e",
            "code": "\nsize_t formatIntToDecimalString_00003e9e(char *outputString,int16_t value,int decimalPlaces)\n\n{\n  size_t formattedSize;\n  int decimalPlaces_local;\n  int16_t value_local;\n  char *outputString_local;\n  \n  formattedSize = fmt_s32_dfp(outputString,(int)value,decimalPlaces);\n  return formattedSize;\n}\n\n",
            "renaming": {
                "FUN_00003e9e": "format_int_to_decimal_string_00003e9e",
                "out": "outputString",
                "val": "value",
                "fp_digits": "decimalPlaces",
                "fp_digits_local": "decimalPlaces_local",
                "val_local": "value_local",
                "out_local": "outputString_local",
                "sVar1": "formattedSize"
            },
            "calling": [
                "phydat_dump"
            ],
            "called": [
                "fmt_s32_dfp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003ec4": {
            "entrypoint": "0x00003ec4",
            "current_name": "format_and_pad_floating_point_number_00003ec4",
            "code": "\nsize_t formatAndPadFloatingPointNumber_00003ec4(char *outputBuffer,int32_t value,int fractionalDigits)\n\n{\n  size_t resultSize;\n  uint valueDivided;\n  int index;\n  int fractionalDigitsLocal;\n  int32_t valueLocal;\n  char *outputBufferLocal;\n  uint divisionLength;\n  int32_t absoluteValue;\n  uint32_t e;\n  int32_t division;\n  uint position;\n  \n  if (fractionalDigits + 7 < 0 != SCARRY4(fractionalDigits,7)) {\n                    \n    core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n  }\n  position = 0;\n  if (fractionalDigits == 0) {\n    position = fmt_s32_dec(outputBuffer,value);\n  }\n  else if (fractionalDigits < 1) {\n    valueDivided = (uint)value / _tenmap[-fractionalDigits];\n    division = value - _tenmap[-fractionalDigits] * valueDivided;\n    if (division < 0) {\n      division = -division;\n    }\n    if ((valueDivided == 0) && (value < 0)) {\n      if (outputBuffer != (char *)0x0) {\n        *outputBuffer = '-';\n      }\n      position = 1;\n    }\n    if (outputBuffer == (char *)0x0) {\n      resultSize = fmt_s32_dec((char *)0x0,valueDivided);\n      position = resultSize + 1 + position;\n    }\n    else {\n      resultSize = fmt_s32_dec(outputBuffer + position,valueDivided);\n      index = position + resultSize;\n      position = index + 1;\n      outputBuffer[index] = '.';\n      resultSize = fmt_s32_dec(outputBuffer + position,division);\n      fmt_lpad(outputBuffer + position,resultSize,-fractionalDigits,'0');\n    }\n    position = -fractionalDigits + position;\n  }\n  else {\n    resultSize = fmt_s32_dec(outputBuffer,value);\n    if (outputBuffer != (char *)0x0) {\n      memset(outputBuffer + resultSize,0x30,fractionalDigits);\n    }\n    position = fractionalDigits + resultSize;\n  }\n  return position;\n}\n\n",
            "renaming": {
                "FUN_00003ec4": "format_and_pad_floating_point_number_00003ec4",
                "out": "outputBuffer",
                "val": "value",
                "fp_digits": "fractionalDigits",
                "sVar1": "resultSize",
                "val_00": "valueDivided",
                "iVar2": "index",
                "fp_digits_local": "fractionalDigitsLocal",
                "val_local": "valueLocal",
                "out_local": "outputBufferLocal",
                "div_len": "divisionLength",
                "abs": "absoluteValue",
                "div": "division",
                "pos": "position"
            },
            "calling": [
                "fmt_s16_dfp"
            ],
            "called": [
                "core_panic",
                "fmt_s32_dec",
                "fmt_lpad",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003ff4": {
            "entrypoint": "0x00003ff4",
            "current_name": "pad_and_fill_00003ff4",
            "code": "\nsize_t padAndFill_00003ff4(char *output,size_t input_length,size_t padding_length,char padding_character)\n\n{\n  size_t result;\n  char padding_character_local;\n  size_t padding_length_local;\n  size_t input_length_local;\n  char *output_local;\n  size_t counter;\n  \n  result = input_length;\n  if ((input_length < padding_length) && (result = padding_length, output != (char *)0x0)) {\n    memmove(output + (padding_length - input_length),output,input_length);\n    memset(output,(uicountert)(byte)padding_character,padding_length - input_length);\n  }\n  returcounter result;\n}\n\n",
            "renaming": {
                "FUN_00003ff4": "pad_and_fill_00003ff4",
                "out": "output",
                "in_len": "input_length",
                "pad_len": "padding_length",
                "pad_char": "padding_character",
                "sVar1": "result",
                "pad_char_local": "padding_character_local",
                "pad_len_local": "padding_length_local",
                "in_len_local": "input_length_local",
                "out_local": "output_local",
                "n": "counter"
            },
            "calling": [
                "fmt_s32_dfp"
            ],
            "called": [
                "memmove",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004042": {
            "entrypoint": "0x00004042",
            "current_name": "convert_string_to_long_00004042",
            "code": "\nint convertStringToLong_00004042(char *string)\n\n{\n  long convertedValue;\n  \n  convertedValue = strtol(string,(char **)0x0,10);\n  return convertedValue;\n}\n\n",
            "renaming": {
                "FUN_00004042": "convert_string_to_long_00004042",
                "__nptr": "string",
                "lVar1": "convertedValue"
            },
            "calling": [
                "write",
                "read"
            ],
            "called": [
                "strtol"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000404c": {
            "entrypoint": "0x0000404c",
            "current_name": "process_data_0000404c",
            "code": "\nundefined4 processData_0000404c(uint *inputArray,int *infoArray)\n\n{\n  int status;\n  int *tempPtr;\n  uint value;\n  ushort flags;\n  int increment;\n  code *callbackFunc;\n  int total;\n  uint originalValue;\n  bool isZero;\n  \n  flags = *(ushort *)(infoArray + 3);\n  value = (uint)flags;\n  if ((int)(value << 0x1c) < 0) {\n    status = infoArray[4];\n    if (status != 0) {\n      increment = value << 0x1e;\n      isZero = increment == 0;\n      total = *infoArray;\n      if (isZero) {\n        increment = infoArray[5];\n      }\n      *infoArray = status;\n      if (!isZero) {\n        increment = 0;\n      }\n      infoArray[2] = increment;\n      for (total = total - status; 0 < total; total = total - increment) {\n        increment = (*(code *)infoArray[10])(inputArray,infoArray[8],status,total);\n        if (increment < 1) {\n          *(ushort *)(infoArray + 3) = *(ushort *)(infoArray + 3) | 0x40;\n          return 0xffffffff;\n        }\n        status = status + increment;\n      }\n    }\n  }\n  else {\n    if ((infoArray[1] < 1) && (infoArray[0x10] < 1)) {\n      return 0;\n    }\n    callbackFunc = (code *)infoArray[0xb];\n    if (callbackFunc == (code *)0x0) {\n      return 0;\n    }\n    originalValue = *inputArray;\n    *inputArray = 0;\n    if ((flags & 0x1000) == 0) {\n      status = (*callbackFunc)(inputArray,infoArray[8],value & 0x1000,1);\n      if ((status == -1) && (value = *inputArray, value != 0)) {\n        if ((value == 0x1d) || (value == 0x16)) {\n          *inputArray = originalValue;\n          return 0;\n        }\n        flags = *(ushort *)(infoArray + 3);\n        goto LAB_00004104;\n      }\n    }\n    else {\n      status = infoArray[0x15];\n    }\n    if (((int)((uint)*(ushort *)(infoArray + 3) << 0x1d) < 0) &&\n       (status = status - infoArray[1], infoArray[0xd] != 0)) {\n      status = status - infoArray[0x10];\n    }\n    status = (*(code *)infoArray[0xb])(inputArray,infoArray[8],status,0);\n    flags = *(ushort *)(infoArray + 3);\n    if ((status == -1) &&\n       ((0x1d < *inputArray || (-1 < (int)((0x20400001U >> (*inputArray & 0xff)) << 0x1f))))) {\nLAB_00004104:\n      *(ushort *)(infoArray + 3) = flags | 0x40;\n      return 0xffffffff;\n    }\n    infoArray[1] = 0;\n    *infoArray = infoArray[4];\n    if (((int)((uint)flags << 0x13) < 0) && ((status != -1 || (*inputArray == 0)))) {\n      infoArray[0x15] = status;\n    }\n    tempPtr = (int *)infoArray[0xd];\n    *inputArray = originalValue;\n    if (tempPtr != (int *)0x0) {\n      if (tempPtr != infoArray + 0x11) {\n        _free_r(inputArray);\n      }\n      infoArray[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000404c": "process_data_0000404c",
                "param_1": "inputArray",
                "param_2": "infoArray",
                "iVar1": "status",
                "piVar2": "tempPtr",
                "uVar3": "value",
                "uVar4": "flags",
                "iVar5": "increment",
                "pcVar6": "callbackFunc",
                "iVar7": "total",
                "uVar8": "originalValue",
                "bVar9": "isZero"
            },
            "calling": [
                "_fflush_r",
                "__srefill_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004158": {
            "entrypoint": "0x00004158",
            "current_name": "handle_flush_00004158",
            "code": "\nundefined4 handle_flush_00004158(int input_stream,undefined4 *file_stream)\n\n{\n  undefined4 return_value;\n  \n  if (file_stream[4] != 0) {\n    if ((input_stream != 0) && (*(int *)(input_stream + 0x18) == 0)) {\n      __sinit();\n    }\n    if (file_stream == &__sf_fake_stdin) {\n      file_stream = *(undefined4 **)(input_stream + 4);\n    }\n    else if (file_stream == (undefined4 *)&__sf_fake_stdout) {\n      file_stream = *(undefined4 **)(input_stream + 8);\n    }\n    else if (file_stream == (undefined4 *)&__sf_fake_stderr) {\n      file_stream = *(undefined4 **)(input_stream + 0xc);\n    }\n    if (*(short *)(file_stream + 3) != 0) {\n      if ((-1 < (int)(file_stream[0x19] << 0x1f)) && (-1 < (int)*(short *)(file_stream + 3) << 0x16)) {\n        __retarget_lock_acquire_recursive(file_stream[0x16]);\n      }\n      return_value = __sflush_r(input_stream,file_stream);\n      if ((int)(file_stream[0x19] << 0x1f) < 0) {\n        return return_value;\n      }\n      if ((int)((uint)*(ushort *)(file_stream + 3) << 0x16) < 0) {\n        return return_value;\n      }\n      __retarget_lock_release_recursive(file_stream[0x16]);\n      return return_value;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00004158": "handle_flush_00004158",
                "param_1": "input_stream",
                "param_2": "file_stream",
                "uVar1": "return_value"
            },
            "calling": [
                "__swbuf_r",
                "fflush",
                "__srefill_r"
            ],
            "called": [
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__sflush_r",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000041d0": {
            "entrypoint": "0x000041d0",
            "current_name": "flush_file_000041d0",
            "code": "\nint flushFile_000041d0(FILE *fileStream)\n\n{\n  int result;\n  \n  if (fileStream == (FILE *)0x0) {\n    result = walkUnownedBuffers(unownedBuffers,0x4159);\n    return result;\n  }\n  result = flushStream(streamData,fileStream);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000041d0": "flush_file_000041d0",
                "__stream": "fileStream",
                "iVar1": "result",
                "_fwalk_reent": "walkUnownedBuffers",
                "&impure_data": "unownedBuffers",
                "_fflush_r": "flushStream",
                "_impure_ptr": "streamData"
            },
            "calling": [
                "lflush",
                "print_prompt"
            ],
            "called": [
                "_fwalk_reent",
                "_fflush_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000041f4": {
            "entrypoint": "0x000041f4",
            "current_name": "initialize_data_000041f4",
            "code": "\nvoid initializeData_000041f4(undefined4 *data,undefined2 value1,undefined2 value2)\n\n{\n  *data = 0;\n  data[1] = 0;\n  data[4] = 0;\n  data[5] = 0;\n  data[2] = 0;\n  *(undefined2 *)(data + 3) = value1;\n  data[25] = 0;\n  *(undefined2 *)((int)data + 0xe) = value2;\n  data[6] = 0;\n  memset(data + 0x17,0,8);\n  data[9] = 0x4dc9;\n  data[10] = 0x4def;\n  data[11] = 0x4e27;\n  data[8] = data;\n  data[12] = 0x4e4b;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000041f4": "initialize_data_000041f4",
                "param_1": "data",
                "param_2": "value1",
                "param_3": "value2",
                "param_1[1]": "data[1]",
                "param_1[4]": "data[4]",
                "param_1[5]": "data[5]",
                "param_1[2]": "data[2]",
                "param_1[0x19]": "data[25]",
                "param_1[6]": "data[6]",
                "param_1[9]": "data[9]",
                "param_1[10]": "data[10]",
                "param_1[0xb]": "data[11]",
                "param_1[8]": "data[8]",
                "param_1[0xc]": "data[12]"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000423c": {
            "entrypoint": "0x0000423c",
            "current_name": "initialize_file_walk_0000423c",
            "code": "\nvoid initializeFileWalk_0000423c(undefined4 reentStructure)\n\n{\n  fileWalk(reentStructure,0x4159);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000423c": "initialize_file_walk_0000423c",
                "param_1": "reentStructure",
                "_fwalk_reent": "fileWalk"
            },
            "calling": [],
            "called": [
                "_fwalk_reent"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004248": {
            "entrypoint": "0x00004248",
            "current_name": "allocate_memory_00004248",
            "code": "\nundefined4 * allocateMemory_00004248(undefined4 size,int count)\n\n{\n  undefined4 *ptr;\n  int offset;\n  \n  offset = (count + -1) * 0x68;\n  ptr = (undefined4 *)_malloc_r(size,offset + 0x74);\n  if (ptr != (undefined4 *)0x0) {\n    *ptr = 0;\n    ptr[1] = count;\n    ptr[2] = ptr + 3;\n    memset(ptr + 3,0,offset + 0x68);\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_00004248": "allocate_memory_00004248",
                "param_1": "size",
                "param_2": "count",
                "puVar1": "ptr",
                "iVar2": "offset"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "_malloc_r",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004274": {
            "entrypoint": "0x00004274",
            "current_name": "acquire_recursive_lock_00004274",
            "code": "\nvoid acquire_recursive_lock_00004274(void)\n\n{\n  __retarget_lock_acquire_recursive(&recursive_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004274": "acquire_recursive_lock_00004274",
                "__lock___sfp_recursive_mutex": "recursive_mutex"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004280": {
            "entrypoint": "0x00004280",
            "current_name": "release_lock_00004280",
            "code": "\nvoid releaseLock_00004280(void)\n\n{\n  __retarget_lock_release_recursive(&lock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004280": "release_lock_00004280",
                "__lock___sfp_recursive_mutex": "lock"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000428c": {
            "entrypoint": "0x0000428c",
            "current_name": "acquire_recursive_lock_0000428c",
            "code": "\nvoid acquireRecursiveLock_0000428c(void)\n\n{\n  __retarget_lock_acquire_recursive(&lock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000428c": "acquire_recursive_lock_0000428c",
                "__lock___sinit_recursive_mutex": "lock"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004298": {
            "entrypoint": "0x00004298",
            "current_name": "release_recursive_lock_00004298",
            "code": "\nvoid releaseRecursiveLock_00004298(void)\n\n{\n  __retarget_lock_release_recursive(&lock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004298": "release_recursive_lock_00004298",
                "__lock___sinit_recursive_mutex": "lock"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000042a4": {
            "entrypoint": "0x000042a4",
            "current_name": "initialize_data_000042a4",
            "code": "\nvoid initializeData_000042a4(undefined1 *dataPointer)\n\n{\n  undefined4 returnValue;\n  undefined1 *impureDataPointer;\n  \n  __sinit_lock_acquire();\n  if (*(int *)(dataPointer + 0x18) == 0) {\n    *(undefined4 *)(dataPointer + 0x48) = 0;\n    *(undefined4 *)(dataPointer + 0x4c) = 0;\n    *(undefined4 *)(dataPointer + 0x50) = 0;\n    impureDataPointer = &impure_data;\n    *(undefined4 *)(dataPointer + 0x28) = 0x423d;\n    if (dataPointer == &impure_data) {\n      impureDataPointer = (undefined1 *)0x1;\n    }\n    if (dataPointer == &impure_data) {\n      *(undefined1 **)(dataPointer + 0x18) = impureDataPointer;\n    }\n    returnValue = __sfp(dataPointer);\n    *(undefined4 *)(dataPointer + 4) = returnValue;\n    returnValue = __sfp(dataPointer);\n    *(undefined4 *)(dataPointer + 8) = returnValue;\n    returnValue = __sfp(dataPointer);\n    *(undefined4 *)(dataPointer + 0xc) = returnValue;\n    std(*(undefined4 *)(dataPointer + 4),4,0);\n    std(*(undefined4 *)(dataPointer + 8),9,1);\n    std(*(undefined4 *)(dataPointer + 0xc),0x12,2);\n    *(undefined4 *)(dataPointer + 0x18) = 1;\n  }\n  __sinit_lock_release();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000042a4": "initialize_data_000042a4",
                "param_1": "dataPointer",
                "uVar1": "returnValue",
                "puVar2": "impureDataPointer"
            },
            "calling": [
                "__sfp",
                "_fflush_r",
                "_puts_r",
                "iprintf",
                "_putc_r",
                "_getc_r",
                "__srefill_r",
                "putchar",
                "__swbuf_r",
                "getchar",
                "__srget_r",
                "_vfprintf_r",
                "__swsetup_r"
            ],
            "called": [
                "__sfp",
                "std",
                "__sinit_lock_acquire",
                "__sinit_lock_release"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004314": {
            "entrypoint": "0x00004314",
            "current_name": "initialize_locks_00004314",
            "code": "\nint * initializeLocks_00004314(undefined4 *errorFlag)\n\n{\n  int *currentPtr;\n  int *dataPtr;\n  int **linkedListPtr;\n  \n  acquireLock();\n  if (DAT_1fff029c == 0) {\n    initializeImpureData(impureDataPtr);\n  }\n  linkedListPtr = (int **)&DAT_1fff02cc;\n  do {\n    currentPtr = linkedListPtr[1];\n    dataPtr = linkedListPtr[2];\n    while (currentPtr = (int *)((int)currentPtr + -1), -1 < (int)currentPtr) {\n      if (*(short *)(dataPtr + 3) == 0) {\n        dataValue1 = -0xffff;\n        dataValue2 = 0;\n        initializeRecursiveLock(dataPtr + 0x16);\n        releaseLock();\n        value1 = 0;\n        value2 = 0;\n        value3 = 0;\n        value4 = 0;\n        *dataPtr = 0;\n        value6 = 0;\n        memset(dataPtr + 0x17,0,8);\n        value7 = 0;\n        value8 = 0;\n        value9 = 0;\n        value10 = 0;\n        return dataPtr;\n      }\n      dataPtr = dataPtr + 0x1a;\n    }\n    if (*linkedListPtr == (int *)0x0) {\n      currentPtr = (int *)__sfmoreglue(errorFlag,4);\n      *linkedListPtr = currentPtr;\n      if (currentPtr == (int *)0x0) {\n        releaseLock();\n        *errorFlag = 0xc;\n        return (int *)0x0;\n      }\n    }\n    linkedListPtr = (int **)*linkedListPtr;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00004314": "initialize_locks_00004314",
                "param_1": "errorFlag",
                "piVar1": "currentPtr",
                "piVar2": "dataPtr",
                "ppiVar3": "linkedListPtr",
                "__sfp_lock_acquire": "acquireLock",
                "__sinit": "initializeImpureData",
                "&impure_data": "impureDataPtr",
                "__sfp_lock_release": "releaseLock",
                "piVar2[3]": "dataValue1",
                "piVar2[0x19]": "dataValue2",
                "__retarget_lock_init_recursive": "initializeRecursiveLock",
                "piVar2[1]": "value1",
                "piVar2[2]": "value2",
                "piVar2[4]": "value3",
                "piVar2[5]": "value4",
                "piVar2[6]": "value6",
                "piVar2[0xd]": "value7",
                "piVar2[0xe]": "value8",
                "piVar2[0x12]": "value9",
                "piVar2[0x13]": "value10"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__sfmoreglue",
                "__sfp_lock_acquire",
                "__sinit",
                "__sfp_lock_release",
                "__retarget_lock_init_recursive",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000043a0": {
            "entrypoint": "0x000043a0",
            "current_name": "check_conditions_000043a0",
            "code": "\nuint check_conditions_000043a0(int base_address,code *function_ptr)\n\n{\n  uint result;\n  int *sublist_ptr;\n  int sublist_item;\n  uint combined_result;\n  int remaining_iterations;\n  \n  sublist_ptr = (int *)(base_address + 0x48);\n  combined_result = 0;\n  do {\n    remaining_iterations = sublist_ptr[1];\n    sublist_item = sublist_ptr[2];\n    while (remaining_iterations = remaining_iterations + -1, -1 < remaining_iterations) {\n      if ((1 < *(ushort *)(sublist_item + 0xc)) && (*(short *)(sublist_item + 0xe) != -1)) {\n        result = (*function_ptr)(sublist_item);\n        combined_result = combined_result | result;\n      }\n      sublist_item = sublist_item + 0x68;\n    }\n    sublist_ptr = (int *)*sublist_ptr;\n  } while (sublist_ptr != (int *)0x0);\n  return combined_result;\n}\n\n",
            "renaming": {
                "FUN_000043a0": "check_conditions_000043a0",
                "param_1": "base_address",
                "param_2": "function_ptr",
                "piVar2": "sublist_ptr",
                "iVar3": "sublist_item",
                "uVar1": "result",
                "uVar4": "combined_result",
                "iVar5": "remaining_iterations"
            },
            "calling": [
                "__srefill_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000043da": {
            "entrypoint": "0x000043da",
            "current_name": "process_data_000043da",
            "code": "\nuint processData_000043da(int dataOffset,code *callback,undefined4 arg1,undefined4 arg2)\n\n{\n  uint result;\n  int incrementValue;\n  int *ptrArray;\n  int ptrIndex;\n  uint combinedResult;\n  int loopCounter;\n  \n  ptrArray = (int *)(dataOffset + 0x48);\n  combinedResult = 0;\n  do {\n    loopCounter = ptrArray[1];\n    ptrIndex = ptrArray[2];\n    while (loopCounter = loopCounter + -1, -1 < loopCounter) {\n      if ((1 < *(ushort *)(ptrIndex + 0xc)) && (incrementValue = *(short *)(ptrIndex + 0xe) + 1, incrementValue != 0)) {\n        result = (*callback)(dataOffset,ptrIndex,arg1,incrementValue,arg2);\n        combinedResult = combinedResult | result;\n      }\n      ptrIndex = ptrIndex + 0x68;\n    }\n    ptrArray = (int *)*ptrArray;\n  } while (ptrArray != (int *)0x0);\n  return combinedResult;\n}\n\n",
            "renaming": {
                "FUN_000043da": "process_data_000043da",
                "param_1": "dataOffset",
                "param_2": "callback",
                "param_3": "arg1",
                "param_4": "arg2",
                "uVar1": "result",
                "iVar2": "incrementValue",
                "piVar3": "ptrArray",
                "iVar4": "ptrIndex",
                "uVar5": "combinedResult",
                "iVar6": "loopCounter"
            },
            "calling": [
                "_cleanup_r",
                "fflush"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004418": {
            "entrypoint": "0x00004418",
            "current_name": "read_character_from_console_00004418",
            "code": "\n\n\nint readCharacterFromConsole_00004418(void)\n\n{\n  int pointer;\n  \n  pointer = pointer;\n  if ((pointer != 0) && (*(int *)(pointer + 0x18) == 0)) {\n    initializeStream(pointer);\n  }\n  pointer = getCharacter(pointer,*(undefined4 *)(pointer + 4));\n  return pointer;\n}\n\n",
            "renaming": {
                "FUN_00004418": "read_character_from_console_00004418",
                "iVar1": "pointer",
                "_impure_ptr": "pointer",
                "__sinit": "initializeStream",
                "_getc_r": "getCharacter"
            },
            "calling": [
                "readline"
            ],
            "called": [
                "__sinit",
                "_getc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000443c": {
            "entrypoint": "0x0000443c",
            "current_name": "get_time_components_0000443c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000044a8) */\n\ntm * getTimeComponents_0000443c(time_t *timeInput,tm *timeOutput)\n\n{\n  int quotientRemainder;\n  uint totalSeconds;\n  uint remainingSeconds;\n  uint daysFromEpoch;\n  int dayOfYear;\n  uint leapYears;\n  time_t inputSeconds;\n  time_t inputSecondsPart;\n  uint century;\n  bool isNegative;\n  \n  inputSeconds = *timeInput;\n  inputSecondsPart = timeInput[1];\n  quotientRemainder = __aeabi_ldivmod(inputSeconds,inputSecondsPart,0x15180,0);\n  remainingSeconds = 0x15180;\n  __aeabi_ldivmod(inputSeconds,inputSecondsPart,0x15180,0);\n  isNegative = (int)remainingSeconds < 0;\n  if (isNegative) {\n    remainingSeconds = remainingSeconds + 0x15180;\n  }\n  if (isNegative) {\n    totalSeconds = quotientRemainder + 0xafa6b;\n  }\n  else {\n    totalSeconds = quotientRemainder + 0xafa6c;\n  }\n  timeOutput->tm_hour = remainingSeconds / 0xe10;\n  timeOutput->tm_min = (remainingSeconds % 0xe10) / 0x3c;\n  timeOutput->tm_sec = (remainingSeconds % 0xe10) % 0x3c;\n  timeOutput->tm_wday = (totalSeconds + 3) % 7;\n  remainingSeconds = totalSeconds;\n  if ((int)totalSeconds < 0) {\n    remainingSeconds = totalSeconds - 0x23ab0;\n  }\n  totalSeconds = (remainingSeconds / 0x23ab1) * -0x23ab1 + totalSeconds;\n  daysFromEpoch = ((totalSeconds / 0x8eac + totalSeconds) - totalSeconds / 0x5b4) - totalSeconds / 0x23ab0;\n  leapYears = daysFromEpoch / 0x16d;\n  totalSeconds = (leapYears / 100 - daysFromEpoch / 0x5b4) + totalSeconds + leapYears * -0x16d;\n  century = totalSeconds * 5 + 2;\n  daysFromEpoch = century / 0x99;\n  if (century < 0x5fa) {\n    quotientRemainder = 2;\n  }\n  else {\n    quotientRemainder = -10;\n  }\n  century = daysFromEpoch + quotientRemainder;\n  quotientRemainder = (remainingSeconds / 0x23ab1) * 400 + leapYears;\n  if (century < 2) {\n    quotientRemainder = quotientRemainder + 1;\n  }\n  if (totalSeconds < 0x132) {\n    if (((leapYears & 3) == 0) && (leapYears != (leapYears / 100) * 100)) {\n      remainingSeconds = 1;\n    }\n    else {\n      remainingSeconds = (uint)(leapYears % 400 == 0);\n    }\n    dayOfYear = totalSeconds + 0x3b + remainingSeconds;\n  }\n  else {\n    dayOfYear = totalSeconds - 0x132;\n  }\n  timeOutput->tm_yday = dayOfYear;\n  timeOutput->tm_mday = (totalSeconds + 1) - (daysFromEpoch * 0x99 + 2) / 5;\n  timeOutput->tm_mon = century;\n  timeOutput->tm_year = quotientRemainder + -0x76c;\n  timeOutput->tm_isdst = 0;\n  return timeOutput;\n}\n\n",
            "renaming": {
                "FUN_0000443c": "get_time_components_0000443c",
                "__timer": "timeInput",
                "__tp": "timeOutput",
                "iVar1": "quotientRemainder",
                "uVar2": "totalSeconds",
                "uVar3": "remainingSeconds",
                "uVar4": "daysFromEpoch",
                "iVar5": "dayOfYear",
                "uVar6": "leapYears",
                "tVar7": "inputSeconds",
                "tVar8": "inputSecondsPart",
                "uVar9": "century",
                "bVar10": "isNegative"
            },
            "calling": [
                "rtc_get_alarm",
                "rtc_get_time"
            ],
            "called": [
                "__aeabi_ldivmod"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000459c": {
            "entrypoint": "0x0000459c",
            "current_name": "finalize_and_execute_0000459c",
            "code": "\nvoid finalize_and_execute_0000459c(EVP_PKEY_CTX *pkey_context)\n\n{\n  code **code_pointer;\n  int loop_counter;\n  \n  code_pointer = (code **)&__fini_array_end;\n  for (loop_counter = 0; loop_counter != 0; loop_counter = loop_counter + 1) {\n    pkey_context = (EVP_PKEY_CTX *)(**code_pointer)();\n    code_pointer = code_pointer + 1;\n  }\n  _init(pkey_context);\n  code_pointer = (code **)&__fini_array_end;\n  for (loop_counter = 0; loop_counter != 0; loop_counter = loop_counter + 1) {\n    (**code_pointer)();\n    code_pointer = code_pointer + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000459c": "finalize_and_execute_0000459c",
                "param_1": "pkey_context",
                "ppcVar1": "code_pointer",
                "iVar2": "loop_counter"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000045e4": {
            "entrypoint": "0x000045e4",
            "current_name": "FUNC_000045e4",
            "code": "\nvoid FUNC_000045e4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045e4": "FUNC_000045e4"
            },
            "calling": [
                "__sfp"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045e6": {
            "entrypoint": "0x000045e6",
            "current_name": "FUNC_000045e6",
            "code": "\nvoid FUNC_000045e6(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045e6": "FUNC_000045e6"
            },
            "calling": [
                "__tz_lock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045e8": {
            "entrypoint": "0x000045e8",
            "current_name": "FUNC_000045e8",
            "code": "\nvoid FUNC_000045e8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045e8": "FUNC_000045e8"
            },
            "calling": [
                "__env_lock",
                "_fflush_r",
                "__sfp_lock_acquire",
                "__malloc_lock",
                "_puts_r",
                "_vfprintf_r",
                "__sinit_lock_acquire",
                "_putc_r",
                "_getc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045ea": {
            "entrypoint": "0x000045ea",
            "current_name": "FUNC_000045ea",
            "code": "\nvoid FUNC_000045ea(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045ea": "FUNC_000045ea"
            },
            "calling": [
                "__tz_unlock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045ec": {
            "entrypoint": "0x000045ec",
            "current_name": "FUNC_000045ec",
            "code": "\nvoid FUNC_000045ec(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045ec": "FUNC_000045ec"
            },
            "calling": [
                "_fflush_r",
                "_puts_r",
                "__sfp_lock_release",
                "__malloc_unlock",
                "_vfprintf_r",
                "_putc_r",
                "__env_unlock",
                "_getc_r",
                "__sinit_lock_release"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045ee": {
            "entrypoint": "0x000045ee",
            "current_name": "memcpy_reverse_000045ee",
            "code": "\nvoid * memcpy_reverse_000045ee(void *destination,void *source,size_t size)\n\n{\n  undefined *dest_ptr;\n  undefined *src_ptr;\n  \n  src_ptr = (undefined *)((int)source + size);\n  if ((source < destination) && (destination < src_ptr)) {\n    dest_ptr = (undefined *)(size + (int)destination);\n    while (dest_ptr != (undefined *)destination) {\n      src_ptr = src_ptr + -1;\n      dest_ptr = dest_ptr + -1;\n      *dest_ptr = *src_ptr;\n    }\n  }\n  else {\n    dest_ptr = (undefined *)((int)destination + -1);\n    for (; (undefined *)source != src_ptr; source = (void *)((int)source + 1)) {\n      dest_ptr = dest_ptr + 1;\n      *dest_ptr = *source;\n                    /* WARNING: Load size is inaccurate */\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_000045ee": "memcpy_reverse_000045ee",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr"
            },
            "calling": [
                "fmt_lpad"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004622": {
            "entrypoint": "0x00004622",
            "current_name": "memset_00004622",
            "code": "\nvoid * memset_00004622(void *destination,int value,size_t num_bytes)\n\n{\n  undefined *pointer;\n  \n  for (pointer = (undefined *)destination; pointer != (undefined *)(num_bytes + (int)destination); pointer = pointer + 1) {\n    *pointer = (char)value;\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_00004622": "memset_00004622",
                "__s": "destination",
                "__c": "value",
                "__n": "num_bytes",
                "puVar1": "pointer"
            },
            "calling": [
                "__sfmoreglue",
                "__sfp",
                "std",
                "fmt_lpad",
                "write",
                "fmt_s32_dfp"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004634": {
            "entrypoint": "0x00004634",
            "current_name": "update_date_00004634",
            "code": "\nvoid updateDate_00004634(uint *dateArray,uint days,undefined4 flag)\n\n{\n  int monthDays;\n  uint temp;\n  uint temp2;\n  int month;\n  bool negativeFlag;\n  uint *divResult;\n  uint remainder;\n  undefined4 stackVar;\n  \n  divResult = dateArray;\n  remainder = days;\n  stackVar = flag;\n  if (0x3b < *dateArray) {\n    div((int)&divResult,*dateArray);\n    temp = dateArray[1] + (int)divResult;\n    dateArray[1] = temp;\n    if ((int)remainder < 0) {\n      temp = temp - 1;\n      *dateArray = remainder + 0x3c;\n    }\n    else {\n      *dateArray = remainder;\n    }\n    if ((int)remainder < 0) {\n      dateArray[1] = temp;\n    }\n  }\n  if (0x3b < dateArray[1]) {\n    div((int)&divResult,dateArray[1]);\n    negativeFlag = (int)remainder < 0;\n    temp2 = dateArray[2] + (int)divResult;\n    dateArray[2] = temp2;\n    temp = remainder;\n    if (negativeFlag) {\n      temp = remainder + 0x3c;\n      temp2 = temp2 - 1;\n    }\n    if (!negativeFlag) {\n      dateArray[1] = temp;\n    }\n    if (negativeFlag) {\n      dateArray[1] = temp;\n    }\n    if (negativeFlag) {\n      dateArray[2] = temp2;\n    }\n  }\n  if (0x17 < dateArray[2]) {\n    div((int)&divResult,dateArray[2]);\n    negativeFlag = (int)remainder < 0;\n    temp2 = dateArray[3] + (int)divResult;\n    dateArray[3] = temp2;\n    temp = remainder;\n    if (negativeFlag) {\n      temp = remainder + 0x18;\n      temp2 = temp2 - 1;\n    }\n    if (!negativeFlag) {\n      dateArray[2] = temp;\n    }\n    if (negativeFlag) {\n      dateArray[2] = temp;\n    }\n    if (negativeFlag) {\n      dateArray[3] = temp2;\n    }\n  }\n  if (0xb < dateArray[4]) {\n    div((int)&divResult,dateArray[4]);\n    negativeFlag = (int)remainder < 0;\n    temp = dateArray[5] + (int)divResult;\n    dateArray[5] = temp;\n    if (negativeFlag) {\n      remainder = remainder + 0xc;\n      temp = temp - 1;\n    }\n    if (!negativeFlag) {\n      dateArray[4] = remainder;\n    }\n    if (negativeFlag) {\n      dateArray[4] = remainder;\n    }\n    if (negativeFlag) {\n      dateArray[5] = temp;\n    }\n  }\n  temp = dateArray[5];\n  if ((temp & 3) == 0) {\n    if (temp == (temp / 100) * 100) {\n      if ((temp + 0x76c) % 400 == 0) {\n        month = 0x1d;\n      }\n      else {\n        month = 0x1c;\n      }\n    }\n    else {\n      month = 0x1d;\n    }\n  }\n  else {\n    month = 0x1c;\n  }\n  if ((int)dateArray[3] < 1) {\n    while ((int)dateArray[3] < 1) {\n      temp = dateArray[4];\n      dateArray[4] = temp - 1;\n      if (temp - 1 == 0xffffffff) {\n        temp2 = dateArray[5];\n        temp = temp2 - 1;\n        dateArray[4] = 0xb;\n        dateArray[5] = temp;\n        if ((temp & 3) == 0) {\n          if (temp == (temp / 100) * 100) {\n            if ((temp2 + 0x76b) % 400 == 0) {\n              month = 0x1d;\n            }\n            else {\n              month = 0x1c;\n            }\n          }\n          else {\n            month = 0x1d;\n          }\n        }\n        else {\n          month = 0x1c;\n        }\n      }\n      monthDays = month;\n      if (dateArray[4] != 1) {\n        monthDays = *(int *)(&DAYS_IN_MONTH + dateArray[4] * 4);\n      }\n      dateArray[3] = monthDays + dateArray[3];\n    }\n  }\n  else {\n    while( true ) {\n      temp = dateArray[4];\n      monthDays = month;\n      if (temp != 1) {\n        monthDays = *(int *)(&DAYS_IN_MONTH + temp * 4);\n      }\n      if ((int)dateArray[3] <= monthDays) break;\n      dateArray[3] = dateArray[3] - monthDays;\n      dateArray[4] = temp + 1;\n      if (temp + 1 == 0xc) {\n        temp2 = dateArray[5];\n        temp = temp2 + 1;\n        dateArray[4] = 0;\n        dateArray[5] = temp;\n        if ((temp & 3) == 0) {\n          if (temp % 100 == 0) {\n            if ((temp2 + 0x76d) % 400 == 0) {\n              month = 0x1d;\n            }\n            else {\n              month = 0x1c;\n            }\n          }\n          else {\n            month = 0x1d;\n          }\n        }\n        else {\n          month = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004634": "update_date_00004634",
                "param_1": "dateArray",
                "param_2": "days",
                "param_3": "flag",
                "iVar1": "monthDays",
                "uVar2": "temp",
                "uVar3": "temp2",
                "iVar4": "month",
                "bVar5": "negativeFlag",
                "local_20": "divResult",
                "local_1c": "remainder",
                "uStack_18": "stackVar"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "div"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000047e4": {
            "entrypoint": "0x000047e4",
            "current_name": "calculate_time_000047e4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\ntime_t calculateTime_000047e4(tm *timeStructure)\n\n{\n  longlong timeInSeconds;\n  int *tzInfo;\n  uint daysInMonth;\n  int dayOfYearTemp;\n  int dayOfYearTemp2;\n  int daysInYear;\n  uint tzOffset;\n  uint leapYearTemp;\n  uint jan1Offset;\n  int dayOfYear;\n  uint year;\n  uint isDst;\n  uint isDstTemp;\n  uint secondsOffset;\n  time_t tVar15;\n  bool bVar16;\n  \n  tzInfo = (int *)__gettzinfo();\n  validate_structure(timeStructure);\n  year = timeStructure->tm_year;\n  dayOfYear = timeStructure->tm_mday + -1 + *(int *)(&_DAYS_BEFORE_MONTH + timeStructure->tm_mon * 4);\n  if (((1 < timeStructure->tm_mon) && ((year & 3) == 0)) &&\n     ((year != (year / 100) * 100 || (year + 0x76c == ((year + 0x76c) / 400) * 400)))) {\n    dayOfYear = dayOfYear + 1;\n  }\n  timeStructure->tm_yday = dayOfYear;\n  if (20000 < (int)&DAT_00002710 + year) {\n    return -1;\n  }\n  if ((int)year < 0x47) {\n    if (year != 0x46) {\n      for (leapYearTemp = 0x45; (int)year < (int)leapYearTemp; leapYearTemp = leapYearTemp - 1) {\n        if ((leapYearTemp & 3) == 0) {\n          if (leapYearTemp == (leapYearTemp / 100) * 100) {\n            if ((leapYearTemp + 0x76c) % 400 == 0) {\n              daysInYear = 0x16e;\n            }\n            else {\n              daysInYear = 0x16d;\n            }\n          }\n          else {\n            daysInYear = 0x16e;\n          }\n        }\n        else {\n          daysInYear = 0x16d;\n        }\n        dayOfYear = dayOfYear - daysInYear;\n      }\n      if ((leapYearTemp & 3) == 0) {\n        if (year == (year / 100) * 100) {\n          daysInYear = 0x16d;\n          if ((year + 0x76c) % 400 == 0) {\n            daysInYear = 0x16e;\n          }\n        }\n        else {\n          daysInYear = 0x16e;\n        }\n      }\n      else {\n        daysInYear = 0x16d;\n      }\n      dayOfYear = dayOfYear - daysInYear;\n    }\n  }\n  else {\n    leapYearTemp = 0x46;\n    do {\n      if ((leapYearTemp & 3) == 0) {\n        if (leapYearTemp % 100 == 0) {\n          if ((leapYearTemp + 0x76c) % 400 == 0) {\n            daysInYear = 0x16e;\n          }\n          else {\n            daysInYear = 0x16d;\n          }\n        }\n        else {\n          daysInYear = 0x16e;\n        }\n      }\n      else {\n        daysInYear = 0x16d;\n      }\n      leapYearTemp = leapYearTemp + 1;\n      dayOfYear = dayOfYear + daysInYear;\n    } while (year != leapYearTemp);\n  }\n  timeInSeconds = (longlong)dayOfYear * 0x15180 +\n          (longlong)(timeStructure->tm_hour * 0xe10 + timeStructure->tm_min * 0x3c + timeStructure->tm_sec);\n  secondsOffset = (uint)timeInSeconds;\n  daysInYear = (int)((ulonglong)timeInSeconds >> 0x20);\n  __tz_lock();\n  _tzset_unlocked();\n  leapYearTemp = _daylight;\n  if (_daylight == 0) {\nLAB_00004934:\n    tVar15 = secondsOffset + tzInfo[10];\n  }\n  else {\n    isDstTemp = timeStructure->tm_isdst;\n    isDst = isDstTemp;\n    if (0 < (int)isDstTemp) {\n      isDst = 1;\n    }\n    if ((tzInfo[1] == timeStructure->tm_year + 0x76c) || (dayOfYearTemp = __tzcalc_limits(), dayOfYearTemp != 0)) {\n      jan1Offset = tzInfo[0x14];\n      daysInMonth = tzInfo[0x12];\n      tzOffset = tzInfo[10];\n      leapYearTemp = daysInMonth - tzOffset;\n      dayOfYearTemp = (tzInfo[0x13] - ((int)tzOffset >> 0x1f)) - (uint)(daysInMonth < tzOffset);\n      if (((int)((daysInYear - dayOfYearTemp) - (uint)(secondsOffset < leapYearTemp)) < 0 ==\n           (SBORROW4(daysInYear,dayOfYearTemp) != SBORROW4(daysInYear - dayOfYearTemp,(uint)(secondsOffset < leapYearTemp)))) &&\n         (dayOfYearTemp2 = (tzInfo[0x13] - ((int)jan1Offset >> 0x1f)) - (uint)(daysInMonth < jan1Offset),\n         bVar16 = secondsOffset < daysInMonth - jan1Offset,\n         (int)((daysInYear - dayOfYearTemp2) - (uint)bVar16) < 0 !=\n         (SBORROW4(daysInYear,dayOfYearTemp2) != SBORROW4(daysInYear - dayOfYearTemp2,(uint)bVar16)))) goto LAB_00004a88;\n      daysInMonth = tzInfo[8] - jan1Offset;\n      dayOfYearTemp2 = (tzInfo[9] - ((int)jan1Offset >> 0x1f)) - (uint)((uint)tzInfo[8] < jan1Offset);\n      if (*tzInfo != 0) {\n        if ((int)((daysInYear - dayOfYearTemp2) - (uint)(secondsOffset < daysInMonth)) < 0 ==\n            (SBORROW4(daysInYear,dayOfYearTemp2) != SBORROW4(daysInYear - dayOfYearTemp2,(uint)(secondsOffset < daysInMonth))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        leapYearTemp = 0;\n        if ((int)isDstTemp < 0) goto LAB_00004934;\nLAB_00004a14:\n        isDstTemp = isDst ^ leapYearTemp;\n        isDst = leapYearTemp;\n        if (isDstTemp == 1) {\n          if (leapYearTemp == 0) {\n            daysInYear = jan1Offset - tzOffset;\n          }\n          else {\n            daysInYear = tzOffset - jan1Offset;\n          }\n          dayOfYearTemp = timeStructure->tm_mday;\n          secondsOffset = secondsOffset + daysInYear;\n          timeStructure->tm_sec = timeStructure->tm_sec + daysInYear;\n          validate_structure(timeStructure);\n          dayOfYearTemp = timeStructure->tm_mday - dayOfYearTemp;\n          if (dayOfYearTemp != 0) {\n            if (dayOfYearTemp < 2) {\n              if (dayOfYearTemp == -2 || dayOfYearTemp + 2 < 0 != SCARRY4(dayOfYearTemp,2)) {\n                dayOfYearTemp = 1;\n              }\n            }\n            else {\n              dayOfYearTemp = -1;\n            }\n            daysInYear = dayOfYearTemp + timeStructure->tm_yday;\n            dayOfYear = dayOfYear + dayOfYearTemp;\n            if (daysInYear < 0) {\n              leapYearTemp = year - 1;\n              if ((leapYearTemp & 3) == 0) {\n                if (leapYearTemp == (leapYearTemp / 100) * 100) {\n                  daysInYear = 0x16d;\n                  if ((year + 0x76b) % 400 != 0) {\n                    daysInYear = 0x16c;\n                  }\n                }\n                else {\n                  daysInYear = 0x16d;\n                }\n              }\n              else {\n                daysInYear = 0x16c;\n              }\n            }\n            else {\n              if ((year & 3) == 0) {\n                if (year == (year / 100) * 100) {\n                  dayOfYearTemp = 0x16d;\n                  if ((year + 0x76c) % 400 == 0) {\n                    dayOfYearTemp = 0x16e;\n                  }\n                }\n                else {\n                  dayOfYearTemp = 0x16e;\n                }\n              }\n              else {\n                dayOfYearTemp = 0x16d;\n              }\n              if (dayOfYearTemp <= daysInYear) {\n                daysInYear = daysInYear - dayOfYearTemp;\n              }\n            }\n            timeStructure->tm_yday = daysInYear;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((daysInYear - dayOfYearTemp2) - (uint)(secondsOffset < daysInMonth)) < 0 !=\n          (SBORROW4(daysInYear,dayOfYearTemp2) != SBORROW4(daysInYear - dayOfYearTemp2,(uint)(secondsOffset < daysInMonth)))) {\nLAB_0000491e:\n        if ((int)((daysInYear - dayOfYearTemp) - (uint)(secondsOffset < leapYearTemp)) < 0 ==\n            (SBORROW4(daysInYear,dayOfYearTemp) != SBORROW4(daysInYear - dayOfYearTemp,(uint)(secondsOffset < leapYearTemp))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)isDstTemp) {\n        leapYearTemp = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      leapYearTemp = isDst;\n      if (isDst != 1) goto LAB_00004934;\n    }\n    tVar15 = secondsOffset + tzInfo[0x14];\n    leapYearTemp = 1;\n  }\n  __tz_unlock();\n  timeStructure->tm_isdst = leapYearTemp;\n  timeStructure->tm_wday = (dayOfYear + 4U) % 7;\n  return tVar15;\n}\n\n",
            "renaming": {
                "FUN_000047e4": "calculate_time_000047e4",
                "__tp": "timeStructure",
                "lVar1": "timeInSeconds",
                "piVar2": "tzInfo",
                "uVar3": "daysInMonth",
                "iVar4": "dayOfYearTemp",
                "iVar5": "dayOfYearTemp2",
                "iVar6": "daysInYear",
                "iVar10": "dayOfYear",
                "uVar7": "tzOffset",
                "uVar8": "leapYearTemp",
                "uVar9": "jan1Offset",
                "uVar11": "year",
                "uVar12": "isDst",
                "uVar13": "isDstTemp",
                "uVar14": "secondsOffset"
            },
            "calling": [
                "rtc_set_alarm",
                "rtc_set_time"
            ],
            "called": [
                "_tzset_unlocked",
                "validate_structure",
                "__tz_lock",
                "__gettzinfo",
                "__tz_unlock",
                "__tzcalc_limits"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004b34": {
            "entrypoint": "0x00004b34",
            "current_name": "allocate_memory_00004b34",
            "code": "\nvoid allocateMemory_00004b34(undefined4 *errorCode,int size,undefined4 arg3,undefined4 arg4)\n\n{\n  int *ptr1;\n  int **extraoutPtr;\n  int **listPtr1;\n  int **listPtr2;\n  int **listPtr3;\n  int **allocatedPtr;\n  bool isSameSize;\n  \n  if (size == 0) {\n    return;\n  }\n  allocatedPtr = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    allocatedPtr = (int **)((int)allocatedPtr + *(int *)(size + -4));\n  }\n  __malloc_lock();\n  listPtr2 = (int **)&__malloc_free_list;\n  if (__malloc_free_list == (int **)0x0) {\n    allocatedPtr[1] = (int *)0x0;\n    listPtr1 = extraoutPtr;\n    __malloc_free_list = allocatedPtr;\n  }\n  else {\n    listPtr3 = __malloc_free_list;\n    if (allocatedPtr < __malloc_free_list) {\n      listPtr1 = (int **)*allocatedPtr;\n      listPtr2 = (int **)((int)allocatedPtr + (int)listPtr1);\n      isSameSize = __malloc_free_list == listPtr2;\n      if (isSameSize) {\n        listPtr2 = (int **)*__malloc_free_list;\n        __malloc_free_list = (int **)__malloc_free_list[1];\n      }\n      allocatedPtr[1] = (int *)__malloc_free_list;\n      __malloc_free_list = allocatedPtr;\n      if (isSameSize) {\n        listPtr2 = (int **)((int)listPtr2 + (int)listPtr1);\n        *allocatedPtr = (int *)listPtr2;\n      }\n    }\n    else {\n      do {\n        listPtr2 = listPtr3;\n        listPtr3 = (int **)listPtr2[1];\n        if (listPtr3 == (int **)0x0) break;\n      } while (listPtr3 <= allocatedPtr);\n      listPtr1 = (int **)*listPtr2;\n      if ((int **)((int)listPtr2 + (int)listPtr1) == allocatedPtr) {\n        listPtr1 = (int **)((int)listPtr1 + (int)*allocatedPtr);\n        *listPtr2 = (int *)listPtr1;\n        if (listPtr3 == (int **)((int)listPtr2 + (int)listPtr1)) {\n          ptr1 = *listPtr3;\n          listPtr2[1] = listPtr3[1];\n          listPtr1 = (int **)((int)listPtr1 + (int)ptr1);\n          *listPtr2 = (int *)listPtr1;\n        }\n      }\n      else if (allocatedPtr < (int **)((int)listPtr2 + (int)listPtr1)) {\n        *errorCode = 0xc;\n      }\n      else {\n        listPtr1 = (int **)((int)allocatedPtr + (int)*allocatedPtr);\n        isSameSize = listPtr3 == listPtr1;\n        if (isSameSize) {\n          listPtr1 = (int **)*listPtr3;\n          listPtr3 = (int **)listPtr3[1];\n        }\n        allocatedPtr[1] = (int *)listPtr3;\n        if (isSameSize) {\n          listPtr1 = (int **)((int)listPtr1 + (int)*allocatedPtr);\n          *allocatedPtr = (int *)listPtr1;\n        }\n        listPtr2[1] = (int *)allocatedPtr;\n      }\n    }\n  }\n  __malloc_unlock(errorCode,listPtr1,listPtr2,arg4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004b34": "allocate_memory_00004b34",
                "param_1": "errorCode",
                "param_2": "size",
                "param_3": "arg3",
                "param_4": "arg4",
                "piVar1": "ptr1",
                "extraout_r1": "extraoutPtr",
                "ppiVar2": "listPtr1",
                "ppiVar3": "listPtr2",
                "ppiVar4": "listPtr3",
                "ppiVar5": "allocatedPtr",
                "bVar6": "isSameSize"
            },
            "calling": [
                "_realloc_r",
                "__ssrefill_r",
                "free",
                "__sflush_r",
                "__srefill_r",
                "__swsetup_r"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004bd0": {
            "entrypoint": "0x00004bd0",
            "current_name": "allocate_memory_00004bd0",
            "code": "\nuint allocate_memory_00004bd0(_reent *reent_ptr,uint size)\n\n{\n  uint *current_block;\n  void *temp_ptr;\n  int remaining_space;\n  uint block_diff;\n  uint *previous_block;\n  uint new_block_size;\n  \n  new_block_size = (size + 3 & 0xfffffffc) + 8;\n  if (new_block_size < 0xc) {\n    new_block_size = 0xc;\n  }\n  if (((int)new_block_size < 0) || (new_block_size < size)) {\n    reent_ptr->_errno = 0xc;\n  }\n  else {\n    __malloc_lock();\n    current_block = __malloc_free_list;\n    for (previous_block = __malloc_free_list; previous_block != (uint *)0x0; previous_block = (uint *)previous_block[1]) {\n      block_diff = *previous_block - new_block_size;\n      if (-1 < (int)block_diff) {\n        if (0xb < block_diff) {\n          *previous_block = block_diff;\n          previous_block = (uint *)((int)previous_block + block_diff);\n          goto LAB_00004c34;\n        }\n        if (current_block == previous_block) {\n          __malloc_free_list = (uint *)previous_block[1];\n        }\n        if (current_block != previous_block) {\n          current_block[1] = (uint)(uint *)previous_block[1];\n        }\n        goto LAB_00004c42;\n      }\n      current_block = previous_block;\n    }\n    if (__malloc_sbrk_start == (void *)0x0) {\n      __malloc_sbrk_start = _sbrk_r(reent_ptr,0);\n    }\n    current_block = (uint *)_sbrk_r(reent_ptr,new_block_size);\n    if ((current_block != (uint *)0xffffffff) &&\n       ((previous_block = (uint *)((int)current_block + 3U & 0xfffffffc), current_block == previous_block ||\n        (temp_ptr = _sbrk_r(reent_ptr,(int)previous_block - (int)current_block), temp_ptr != (void *)0xffffffff)))) {\nLAB_00004c34:\n      *previous_block = new_block_size;\nLAB_00004c42:\n      __malloc_unlock(reent_ptr);\n      new_block_size = (int)previous_block + 0xbU & 0xfffffff8;\n      remaining_space = new_block_size - (int)(previous_block + 1);\n      if (remaining_space == 0) {\n        return new_block_size;\n      }\n      *(uint *)((int)previous_block + remaining_space) = (int)(previous_block + 1) - new_block_size;\n      return new_block_size;\n    }\n    reent_ptr->_errno = 0xc;\n    __malloc_unlock(reent_ptr);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00004bd0": "allocate_memory_00004bd0",
                "param_1": "reent_ptr",
                "param_2": "size",
                "puVar1": "current_block",
                "pvVar2": "temp_ptr",
                "iVar3": "remaining_space",
                "uVar4": "block_diff",
                "puVar5": "previous_block",
                "uVar6": "new_block_size"
            },
            "calling": [
                "__sfmoreglue",
                "__submore",
                "__smakebuf_r",
                "_realloc_r",
                "_tzset_unlocked_r"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock",
                "_sbrk_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004c84": {
            "entrypoint": "0x00004c84",
            "current_name": "print_formatted_output_00004c84",
            "code": "\nint print_formatted_output_00004c84(char *format_string,...)\n\n{\n  int impure_ptr;\n  undefined4 param_r1;\n  undefined4 param_r2;\n  undefined4 param_r3;\n  char *format_ptr;\n  undefined4 param_c;\n  undefined4 param_8;\n  undefined4 param_4;\n  \n  impure_ptr = _impure_ptr;\n  format_ptr = format_string;\n  param_c = param_r1;\n  param_8 = param_r2;\n  param_4 = param_r3;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  impure_ptr = _vfprintf_r(impure_ptr,*(undefined4 *)(impure_ptr + 8),format_string,&param_c,format_ptr,&param_c);\n  return impure_ptr;\n}\n\n",
            "renaming": {
                "FUN_00004c84": "print_formatted_output_00004c84",
                "__format": "format_string",
                "iVar1": "impure_ptr",
                "in_r1": "param_r1",
                "in_r2": "param_r2",
                "in_r3": "param_r3",
                "pcVar2": "format_ptr",
                "uStack_c": "param_c",
                "uStack_8": "param_8",
                "uStack_4": "param_4"
            },
            "calling": [
                "main_trampoline",
                "read",
                "hard_fault_handler",
                "_rtc_handler",
                "handle_input_line",
                "cpu_print_last_instruction",
                "probe",
                "phydat_dump",
                "core_panic",
                "_saul",
                "write",
                "print_help",
                "ps",
                "_print_time",
                "list"
            ],
            "called": [
                "__sinit",
                "_vfprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004cb4": {
            "entrypoint": "0x00004cb4",
            "current_name": "put_char_with_impure_check_00004cb4",
            "code": "\nint putCharWithImpureCheck_00004cb4(int character)\n\n{\n  int impurePtr;\n  undefined4 unused;\n  \n  impurePtr = impurePtr;\n  if ((impurePtr != 0) && (*(int *)(impurePtr + 0x18) == 0)) {\n    __sinit(impurePtr);\n  }\n  impurePtr = _putc_r(impurePtr,character,*(undefined4 *)(impurePtr + 8),unused);\n  return impurePtr;\n}\n\n",
            "renaming": {
                "FUN_00004cb4": "put_char_with_impure_check_00004cb4",
                "__c": "character",
                "iVar1": "impurePtr",
                "in_r3": "unused",
                "_impure_ptr": "impurePtr"
            },
            "calling": [
                "_putchar"
            ],
            "called": [
                "__sinit",
                "_putc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004cdc": {
            "entrypoint": "0x00004cdc",
            "current_name": "write_to_output_stream_00004cdc",
            "code": "\nundefined4 write_to_output_stream_00004cdc(int output_stream,int input)\n\n{\n  char current_char;\n  int result;\n  char *char_ptr;\n  char **stream_ptr;\n  undefined4 status;\n  char *input_ptr;\n  \n  if ((output_stream != 0) && (*(int *)(output_stream + 0x18) == 0)) {\n    __sinit();\n  }\n  stream_ptr = *(char ***)(output_stream + 8);\n  if (*(int *)(output_stream + 0x18) == 0) {\n    __sinit(output_stream);\n  }\n  if (stream_ptr == (char **)&__sf_fake_stdin) {\n    stream_ptr = *(char ***)(output_stream + 4);\n  }\n  else if (stream_ptr == (char **)&__sf_fake_stdout) {\n    stream_ptr = *(char ***)(output_stream + 8);\n  }\n  else if (stream_ptr == (char **)&__sf_fake_stderr) {\n    stream_ptr = *(char ***)(output_stream + 0xc);\n  }\n  if ((-1 < (int)stream_ptr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(stream_ptr + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(stream_ptr[0x16]);\n  }\n  if ((((int)((uint)*(ushort *)(stream_ptr + 3) << 0x1c) < 0) && (stream_ptr[4] != (char *)0x0)) ||\n     (result = __swsetup_r(output_stream,stream_ptr), result == 0)) {\n    input_ptr = (char *)(input + -1);\n    do {\n      while( true ) {\n        input_ptr = input_ptr + 1;\n        current_char = *input_ptr;\n        char_ptr = stream_ptr[2] + -1;\n        stream_ptr[2] = char_ptr;\n        if (current_char == '\\0') {\n          if (-1 < (int)char_ptr) {\n            input_ptr = *stream_ptr;\n            status = 10;\n            *stream_ptr = input_ptr + 1;\n            *input_ptr = '\\n';\n            goto LAB_00004d64;\n          }\n          result = __swbuf_r(output_stream,10,stream_ptr);\n          if (result != -1) {\n            status = 10;\n            goto LAB_00004d64;\n          }\n          goto LAB_00004d60;\n        }\n        if (((int)char_ptr < 0) && (((int)char_ptr < (int)stream_ptr[6] || (current_char == '\\n')))) break;\n        char_ptr = *stream_ptr;\n        *stream_ptr = char_ptr + 1;\n        *char_ptr = current_char;\n      }\n      result = __swbuf_r(output_stream,current_char,stream_ptr);\n    } while (result != -1);\n  }\nLAB_00004d60:\n  status = 0xffffffff;\nLAB_00004d64:\n  if ((-1 < (int)stream_ptr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(stream_ptr + 3) << 0x16))) {\n    __retarget_lock_release_recursive(stream_ptr[0x16]);\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_00004cdc": "write_to_output_stream_00004cdc",
                "param_1": "output_stream",
                "param_2": "input",
                "cVar1": "current_char",
                "iVar2": "result",
                "pcVar3": "char_ptr",
                "ppcVar4": "stream_ptr",
                "uVar5": "status",
                "pcVar6": "input_ptr"
            },
            "calling": [
                "puts"
            ],
            "called": [
                "__swbuf_r",
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004db8": {
            "entrypoint": "0x00004db8",
            "current_name": "print_string_00004db8",
            "code": "\nint print_string_00004db8(char *string_to_print)\n\n{\n  int print_result;\n  \n  print_result = _puts_r(_impure_ptr,string_to_print);\n  return print_result;\n}\n\n",
            "renaming": {
                "FUN_00004db8": "print_string_00004db8",
                "__s": "string_to_print",
                "iVar1": "print_result"
            },
            "calling": [
                "_rtc_usage",
                "_rtc_gettime",
                "read",
                "hard_fault_handler",
                "handle_input_line",
                "_alarm_handler",
                "phydat_dump",
                "_rtc_setalarm",
                "main",
                "_rtc_getalarm",
                "probe_all",
                "_rtc_settime",
                "write",
                "print_help",
                "list"
            ],
            "called": [
                "_puts_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004dc8": {
            "entrypoint": "0x00004dc8",
            "current_name": "read_and_update_00004dc8",
            "code": "\nvoid readAndUpdate_00004dc8(_reent *reent,int data,void *buffer,size_t size)\n\n{\n  _ssize_t readResult;\n  uint updatedValue;\n  bool isReadSuccessful;\n  \n  readResult = _read_r(reent,(int)*(short *)(data + 0xe),buffer,size);\n  isReadSuccessful = -1 < readResult;\n  if (isReadSuccessful) {\n    updatedValue = *(int *)(data + 0x54) + readResult;\n  }\n  else {\n    updatedValue = *(ushort *)(data + 0xc) & 0xffffefff;\n  }\n  if (isReadSuccessful) {\n    *(uint *)(data + 0x54) = updatedValue;\n  }\n  if (!isReadSuccessful) {\n    *(short *)(data + 0xc) = (short)updatedValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004dc8": "read_and_update_00004dc8",
                "param_1": "reent",
                "param_2": "data",
                "param_3": "buffer",
                "param_4": "size",
                "_Var1": "readResult",
                "uVar2": "updatedValue",
                "bVar3": "isReadSuccessful"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004dea": {
            "entrypoint": "0x00004dea",
            "current_name": "initialize_00004dea",
            "code": "\nundefined4 initialize_00004dea(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00004dea": "initialize_00004dea"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004dee": {
            "entrypoint": "0x00004dee",
            "current_name": "rewrite_and_write_file_00004dee",
            "code": "\nvoid rewrite_and_write_file_00004dee(_reent *reent,int file_descriptor,void *buffer,size_t buffer_length)\n\n{\n  if ((int)((uint)*(ushort *)(file_descriptor + 0xc) << 0x17) < 0) {\n    _lseek_r(reent,(int)*(short *)(file_descriptor + 0xe),0,2);\n  }\n  *(ushort *)(file_descriptor + 0xc) = *(ushort *)(file_descriptor + 0xc) & 0xefff;\n  _write_r(reent,(int)*(short *)(file_descriptor + 0xe),buffer,buffer_length);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004dee": "rewrite_and_write_file_00004dee",
                "param_1": "reent",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_length"
            },
            "calling": [],
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e26": {
            "entrypoint": "0x00004e26",
            "current_name": "update_file_position_00004e26",
            "code": "\nvoid updateFilePosition_00004e26(_reent *reent,int buffer,_off_t offset,int whence)\n\n{\n  _off_t newPosition;\n  ushort status;\n  bool isError;\n  \n  newPosition = _lseek_r(reent,(int)*(short *)(buffer + 0xe),offset,whence);\n  isError = newPosition == -1;\n  if (isError) {\n    status = *(ushort *)(buffer + 0xc) & 0xefff;\n  }\n  else {\n    *(_off_t *)(buffer + 0x54) = newPosition;\n    status = *(ushort *)(buffer + 0xc) | 0x1000;\n  }\n  if (isError) {\n    *(ushort *)(buffer + 0xc) = status;\n  }\n  if (!isError) {\n    *(ushort *)(buffer + 0xc) = status;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004e26": "update_file_position_00004e26",
                "param_1": "reent",
                "param_2": "buffer",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "newPosition",
                "uVar2": "status",
                "bVar3": "isError"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e4a": {
            "entrypoint": "0x00004e4a",
            "current_name": "close_file_00004e4a",
            "code": "\nvoid closeFile_00004e4a(_reent *reentPointer,int filePointer)\n\n{\n  _close_r(reentPointer,(int)*(short *)(filePointer + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004e4a": "close_file_00004e4a",
                "param_1": "reentPointer",
                "param_2": "filePointer"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e52": {
            "entrypoint": "0x00004e52",
            "current_name": "compare_strings_00004e52",
            "code": "\nint compareStrings_00004e52(char *str1,char *str2)\n\n{\n  byte currentChar;\n  uint str1Char;\n  bool isEqual;\n  \n  do {\n    str1Char = (uint)(byte)*str1;\n    currentChar = *str2;\n    isEqual = str1Char == 1;\n    if (str1Char != 0) {\n      isEqual = str1Char == currentChar;\n    }\n    str1 = (char *)((byte *)str1 + 1);\n    str2 = (char *)((byte *)str2 + 1);\n  } while (isEqual);\n  return str1Char - currentChar;\n}\n\n",
            "renaming": {
                "FUN_00004e52": "compare_strings_00004e52",
                "__s1": "str1",
                "__s2": "str2",
                "bVar1": "currentChar",
                "uVar2": "str1Char",
                "bVar3": "isEqual"
            },
            "calling": [
                "_saul",
                "read",
                "handle_input_line",
                "strcmp",
                "find_handler",
                "_tzset_unlocked_r"
            ],
            "called": [
                "strcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e66": {
            "entrypoint": "0x00004e66",
            "current_name": "compare_strings_00004e66",
            "code": "\nint compareStrings_00004e66(char *string1,char *string2,size_t length)\n\n{\n  byte *currentCharString1;\n  int difference;\n  byte *currentCharString2;\n  uint currentCharASCII;\n  \n  if (length == 0) {\n    difference = 0;\n  }\n  else {\n    currentCharString2 = (byte *)(string2 + -1);\n    currentCharString1 = (byte *)string1;\n    do {\n      currentCharASCII = (uint)*currentCharString1;\n      currentCharString2 = currentCharString2 + 1;\n      if ((currentCharASCII != *currentCharString2) || (currentCharString1 + 1 == (byte *)(string1 + length))) break;\n      currentCharString1 = currentCharString1 + 1;\n    } while (currentCharASCII != 0);\n    difference = currentCharASCII - *currentCharString2;\n  }\n  return difference;\n}\n\n",
            "renaming": {
                "FUN_00004e66": "compare_strings_00004e66",
                "__s1": "string1",
                "__s2": "string2",
                "__n": "length",
                "pbVar1": "currentCharString1",
                "iVar2": "difference",
                "pbVar3": "currentCharString2",
                "uVar4": "currentCharASCII"
            },
            "calling": [
                "_findenv_r",
                "_rtc_handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e8c": {
            "entrypoint": "0x00004e8c",
            "current_name": "parse_number_00004e8c",
            "code": "\nuint parseNumber_00004e8c(undefined4 *result,byte *input,byte **remaining,uint base)\n\n{\n  uint parsedNumber;\n  uint currentChar;\n  uint isNegative;\n  uint digitValue;\n  int parseState;\n  uint maxIntDivBase;\n  uint maxIntResult;\n  byte *currentCharPointer;\n  byte *nextCharPointer;\n  \n  nextCharPointer = input;\n  do {\n    currentCharPointer = nextCharPointer;\n    nextCharPointer = currentCharPointer + 1;\n    currentChar = (uint)*currentCharPointer;\n    isNegative = (byte)(&DAT_00007a99)[currentChar] & 8;\n  } while (((&DAT_00007a99)[currentChar] & 8) != 0);\n  if (currentChar == 0x2d) {\n    currentChar = (uint)*nextCharPointer;\n    isNegative = 1;\n    nextCharPointer = currentCharPointer + 2;\n  }\n  else if (currentChar == 0x2b) {\n    currentChar = (uint)*nextCharPointer;\n    nextCharPointer = currentCharPointer + 2;\n  }\n  if (base == 0) {\n    if (currentChar != 0x30) {\n      base = 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((base != 0x10) || (currentChar != 0x30)) goto LAB_00004ed6;\n  if ((*nextCharPointer & 0xdf) == 0x58) {\n    currentChar = (uint)nextCharPointer[1];\n    base = 0x10;\n    nextCharPointer = nextCharPointer + 2;\n  }\n  else {\n    currentChar = 0x30;\n    if (base == 0) {\n      base = 8;\n    }\n  }\nLAB_00004ed6:\n  maxIntDivBase = isNegative + 0x7fffffff;\n  parseState = 0;\n  maxIntResult = maxIntDivBase / base;\n  parsedNumber = 0;\n  do {\n    digitValue = currentChar - 0x30;\n    if (9 < digitValue) {\n      if (currentChar - 0x41 < 0x1a) {\n        digitValue = currentChar - 0x37;\n      }\n      else {\n        if (0x19 < currentChar - 0x61) break;\n        digitValue = currentChar - 0x57;\n      }\n    }\n    if ((int)base <= (int)digitValue) break;\n    if (parseState != -1) {\n      if ((maxIntResult < parsedNumber) || ((maxIntResult == parsedNumber && ((int)(maxIntDivBase - base * maxIntResult) < (int)digitValue)))) {\n        parseState = -1;\n      }\n      else {\n        parsedNumber = parsedNumber * base + digitValue;\n        parseState = 1;\n      }\n    }\n    currentChar = (uint)*nextCharPointer;\n    nextCharPointer = nextCharPointer + 1;\n  } while( true );\n  if (parseState == -1) {\n    *result = 0x22;\n    parsedNumber = maxIntDivBase;\n    if (remaining == (byte **)0x0) {\n      return maxIntDivBase;\n    }\n  }\n  else {\n    if (isNegative != 0) {\n      parsedNumber = -parsedNumber;\n    }\n    if (remaining == (byte **)0x0) {\n      return parsedNumber;\n    }\n    if (parseState == 0) goto LAB_00004f64;\n  }\n  input = nextCharPointer + -1;\nLAB_00004f64:\n  *remaining = input;\n  return parsedNumber;\n}\n\n",
            "renaming": {
                "FUN_00004e8c": "parse_number_00004e8c",
                "param_1": "result",
                "param_2": "input",
                "param_3": "remaining",
                "param_4": "base",
                "uVar1": "parsedNumber",
                "uVar2": "currentChar",
                "uVar3": "isNegative",
                "uVar4": "digitValue",
                "iVar5": "parseState",
                "uVar6": "maxIntDivBase",
                "uVar7": "maxIntResult",
                "pbVar8": "currentCharPointer",
                "pbVar9": "nextCharPointer"
            },
            "calling": [
                "strtol",
                "_strtol_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004f80": {
            "entrypoint": "0x00004f80",
            "current_name": "FUN_00004f80",
            "code": "\nuint _strtol_l_isra_0(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint uVar7;\n  byte *pbVar8;\n  byte *pbVar9;\n  \n  pbVar9 = param_2;\n  do {\n    pbVar8 = pbVar9;\n    pbVar9 = pbVar8 + 1;\n    uVar2 = (uint)*pbVar8;\n    uVar3 = (byte)(&DAT_00007a99)[uVar2] & 8;\n  } while (((&DAT_00007a99)[uVar2] & 8) != 0);\n  if (uVar2 == 0x2d) {\n    uVar2 = (uint)*pbVar9;\n    uVar3 = 1;\n    pbVar9 = pbVar8 + 2;\n  }\n  else if (uVar2 == 0x2b) {\n    uVar2 = (uint)*pbVar9;\n    pbVar9 = pbVar8 + 2;\n  }\n  if (param_4 == 0) {\n    if (uVar2 != 0x30) {\n      param_4 = 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((param_4 != 0x10) || (uVar2 != 0x30)) goto LAB_00004ed6;\n  if ((*pbVar9 & 0xdf) == 0x58) {\n    uVar2 = (uint)pbVar9[1];\n    param_4 = 0x10;\n    pbVar9 = pbVar9 + 2;\n  }\n  else {\n    uVar2 = 0x30;\n    if (param_4 == 0) {\n      param_4 = 8;\n    }\n  }\nLAB_00004ed6:\n  uVar6 = uVar3 + 0x7fffffff;\n  iVar5 = 0;\n  uVar7 = uVar6 / param_4;\n  uVar1 = 0;\n  do {\n    uVar4 = uVar2 - 0x30;\n    if (9 < uVar4) {\n      if (uVar2 - 0x41 < 0x1a) {\n        uVar4 = uVar2 - 0x37;\n      }\n      else {\n        if (0x19 < uVar2 - 0x61) break;\n        uVar4 = uVar2 - 0x57;\n      }\n    }\n    if ((int)param_4 <= (int)uVar4) break;\n    if (iVar5 != -1) {\n      if ((uVar7 < uVar1) || ((uVar7 == uVar1 && ((int)(uVar6 - param_4 * uVar7) < (int)uVar4)))) {\n        iVar5 = -1;\n      }\n      else {\n        uVar1 = uVar1 * param_4 + uVar4;\n        iVar5 = 1;\n      }\n    }\n    uVar2 = (uint)*pbVar9;\n    pbVar9 = pbVar9 + 1;\n  } while( true );\n  if (iVar5 == -1) {\n    *param_1 = 0x22;\n    uVar1 = uVar6;\n    if (param_3 == (byte **)0x0) {\n      return uVar6;\n    }\n  }\n  else {\n    if (uVar3 != 0) {\n      uVar1 = -uVar1;\n    }\n    if (param_3 == (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar5 == 0) goto LAB_00004f64;\n  }\n  param_2 = pbVar9 + -1;\nLAB_00004f64:\n  *param_3 = param_2;\n  return uVar1;\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "_strtol_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004f84": {
            "entrypoint": "0x00004f84",
            "current_name": "parse_integer_00004f84",
            "code": "\nlong parseInteger_00004f84(char *inputString,char **remainingString,int base)\n\n{\n  long parsedInteger;\n  \n  parsedInteger = _strtol_l_isra_0(_impure_ptr,inputString,remainingString,base);\n  return parsedInteger;\n}\n\n",
            "renaming": {
                "FUN_00004f84": "parse_integer_00004f84",
                "__nptr": "inputString",
                "__endptr": "remainingString",
                "__base": "base",
                "lVar1": "parsedInteger"
            },
            "calling": [
                "_parse_time",
                "atoi"
            ],
            "called": [
                "_strtol_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004f98": {
            "entrypoint": "0x00004f98",
            "current_name": "calculate_day_of_week_00004f98",
            "code": "\nundefined4 calculateDayOfWeek_00004f98(uint year)\n\n{\n  uint *tzinfo;\n  undefined4 result;\n  uint dayOfWeekOffset;\n  int totalDaysOffset;\n  uint *calendarData;\n  int extraDaysOffset;\n  uint isLeapYear;\n  int monthOffset;\n  int correctedDayOfWeek;\n  uint isSpecialLeapYear;\n  \n  tzinfo = (uint *)__gettzinfo();\n  if ((int)year < 0x7b2) {\n    result = 0;\n  }\n  else {\n    extraDaysOffset = (year - 0x7b2) * 0x16d + ((int)(year - 0x7b1) >> 2) +\n            (year - 0x76d) / 0xffffff9c + (year - 0x641) / 400;\n    tzinfo[1] = year;\n    isSpecialLeapYear = (uint)(year % 400 == 0);\n    calendarData = tzinfo;\n    do {\n      dayOfWeekOffset = calendarData[5];\n      if (*(char *)(calendarData + 2) == 'J') {\n        if ((((year & 3) == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n          if ((int)dayOfWeekOffset < 0x3c) {\n            totalDaysOffset = 0;\n          }\n          else {\n            totalDaysOffset = 1;\n          }\n        }\n        else {\n          totalDaysOffset = 0;\n        }\n        totalDaysOffset = totalDaysOffset + extraDaysOffset + dayOfWeekOffset + -1;\n      }\n      else if (*(char *)(calendarData + 2) == 'D') {\n        totalDaysOffset = extraDaysOffset + dayOfWeekOffset;\n      }\n      else {\n        isLeapYear = isSpecialLeapYear;\n        if (((year & 3) == 0) && (year % 100 != 0)) {\n          isLeapYear = 1;\n        }\n        monthOffset = 0;\n        totalDaysOffset = extraDaysOffset;\n        while( true ) {\n          monthOffset = monthOffset + 1;\n          if ((int)calendarData[3] <= monthOffset) break;\n          totalDaysOffset = totalDaysOffset + *(int *)(&UNK_00007b98 + monthOffset * 4 + isLeapYear * 0x30);\n        }\n        correctedDayOfWeek = dayOfWeekOffset - (totalDaysOffset + 4U) % 7;\n        if (correctedDayOfWeek < 0) {\n          correctedDayOfWeek = correctedDayOfWeek + 7;\n        }\n        for (correctedDayOfWeek = (calendarData[4] - 1) * 7 + correctedDayOfWeek;\n            *(int *)(&UNK_00007b98 + monthOffset * 4 + isLeapYear * 0x30) <= correctedDayOfWeek; correctedDayOfWeek = correctedDayOfWeek + -7) {\n        }\n        totalDaysOffset = totalDaysOffset + correctedDayOfWeek;\n      }\n      dayOfWeekOffset = calendarData[10] + totalDaysOffset * 0x15180 + calendarData[6];\n      calendarData[8] = dayOfWeekOffset;\n      calendarData[9] = (int)dayOfWeekOffset >> 0x1f;\n      calendarData = calendarData + 10;\n    } while (tzinfo + 0x14 != calendarData);\n    dayOfWeekOffset = tzinfo[9];\n    isSpecialLeapYear = tzinfo[0x13];\n    *tzinfo = (uint)((int)((dayOfWeekOffset - isSpecialLeapYear) - (uint)(tzinfo[8] < tzinfo[0x12])) < 0 !=\n                    (SBORROW4(dayOfWeekOffset,isSpecialLeapYear) !=\n                    SBORROW4(dayOfWeekOffset - isSpecialLeapYear,(uint)(tzinfo[8] < tzinfo[0x12]))));\n    result = 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00004f98": "calculate_day_of_week_00004f98",
                "param_1": "year",
                "puVar1": "tzinfo",
                "uVar2": "result",
                "uVar3": "dayOfWeekOffset",
                "iVar4": "totalDaysOffset",
                "puVar5": "calendarData",
                "iVar6": "extraDaysOffset",
                "uVar7": "isLeapYear",
                "iVar8": "monthOffset",
                "iVar9": "correctedDayOfWeek",
                "uVar10": "isSpecialLeapYear"
            },
            "calling": [
                "mktime",
                "_tzset_unlocked_r"
            ],
            "called": [
                "__gettzinfo"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000050e8": {
            "entrypoint": "0x000050e8",
            "current_name": "acquire_tz_mutex_000050e8",
            "code": "\nvoid acquire_tz_mutex_000050e8(void)\n\n{\n  lock_acquire(&tz_mutex_lock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000050e8": "acquire_tz_mutex_000050e8",
                "__retarget_lock_acquire": "lock_acquire",
                "__lock___tz_mutex": "tz_mutex_lock"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "__retarget_lock_acquire"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000050f4": {
            "entrypoint": "0x000050f4",
            "current_name": "release_lock_000050f4",
            "code": "\nvoid releaseLock_000050f4(void)\n\n{\n  releaseLock_000050f4(lockMutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000050f4": "release_lock_000050f4",
                "__retarget_lock_release": "releaseLock",
                "&__lock___tz_mutex": "lockMutex"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "__retarget_lock_release"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005100": {
            "entrypoint": "0x00005100",
            "current_name": "initialize_timezone_00005100",
            "code": "\nvoid initializeTimezone_00005100(void)\n\n{\n  updateTimezone(timezoneData);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005100": "initialize_timezone_00005100",
                "_tzset_unlocked_r": "updateTimezone",
                "_impure_ptr": "timezoneData"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "_tzset_unlocked_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000510c": {
            "entrypoint": "0x0000510c",
            "current_name": "initialize_timezone_0000510c",
            "code": "\nvoid initializeTimezone_0000510c(undefined4 param)\n\n{\n  int tzinfo;\n  char *tzEnv;\n  size_t envLength;\n  int comparisonResult;\n  int scanResult;\n  ulong parsedValue;\n  undefined indicator;\n  char *scanPtr;\n  bool firstScan;\n  ushort *hourPtr;\n  int *offsetPtr;\n  ushort *minutePtr;\n  int *secondPtr;\n  ushort hour;\n  ushort minute;\n  ushort second;\n  ushort stdHour;\n  ushort stdMinute;\n  ushort stdSecond;\n  int scanOffset;\n  char *timezoneStd [2];\n  \n  tzinfo = __getTimezoneInfo();\n  tzEnv = (char *)_getReverseEnv_r(param,&DAT_00007a5c);\n  if (tzEnv == (char *)0x0) {\n    _timezoneName = &DAT_00007a5f;\n    DAT_1fff02e8 = &DAT_00007a5f;\n    _daylightSaving = tzEnv;\n    _timezoneOffset = tzEnv;\n    free(previousTzEnv);\n    previousTzEnv = (char *)0x0;\n  }\n  else if ((previousTzEnv == (char *)0x0) || (comparisonResult = strcmp(tzEnv,previousTzEnv), comparisonResult != 0)) {\n    free(previousTzEnv);\n    envLength = getLength(tzEnv);\n    previousTzEnv = (char *)_reverseAllocate_r(param,envLength + 1);\n    if (previousTzEnv != (char *)0x0) {\n      copyString(previousTzEnv,tzEnv);\n    }\n    if (*tzEnv == ':') {\n      tzEnv = tzEnv + 1;\n    }\n    comparisonResult = scanFormatted(tzEnv,\"%10[^0-9,+-]%n\",&__timezoneStandardName,&scanOffset);\n    if (0 < comparisonResult) {\n      scanPtr = tzEnv + scanOffset;\n      if (tzEnv[scanOffset] == '-') {\n        scanPtr = scanPtr + 1;\n        comparisonResult = -1;\n      }\n      else {\n        if (tzEnv[scanOffset] == '+') {\n          scanPtr = scanPtr + 1;\n        }\n        comparisonResult = 1;\n      }\n      minute = 0;\n      second = 0;\n      hourPtr = &minute;\n      offsetPtr = &scanOffset;\n      minutePtr = &second;\n      secondPtr = &scanOffset;\n      scanResult = scanFormatted(scanPtr,\"%hu%n:%hu%n:%hu%n\",&hour,&scanOffset,&minute,&scanOffset,&second,\n                      &scanOffset);\n      if (0 < scanResult) {\n        *(uint *)(tzinfo + 0x28) =\n             ((uint)hour * 0xe10 + (uint)minute * 0x3c + (uint)second) * comparisonResult;\n        _timezoneName = &__timezoneStandardName;\n        scanPtr = scanPtr + scanOffset;\n        comparisonResult = scanFormatted(scanPtr,\"%10[^0-9,+-]%n\",&__timezoneDstName,&scanOffset,hourPtr,offsetPtr,minutePtr,\n                        secondPtr);\n        if (comparisonResult < 1) {\n          DAT_1fff02e8 = _timezoneName;\n          _timezoneOffset = *(char **)(tzinfo + 0x28);\n          _daylightSaving = (char *)0x0;\n        }\n        else {\n          DAT_1fff02e8 = &__timezoneDstName;\n          tzEnv = scanPtr + scanOffset;\n          if (scanPtr[scanOffset] == '-') {\n            tzEnv = tzEnv + 1;\n            comparisonResult = -1;\n          }\n          else {\n            if (scanPtr[scanOffset] == '+') {\n              tzEnv = tzEnv + 1;\n            }\n            comparisonResult = 1;\n          }\n          hour = 0;\n          minute = 0;\n          second = 0;\n          scanOffset = 0;\n          scanResult = scanFormatted(tzEnv,\"%hu%n:%hu%n:%hu%n\",&hour,&scanOffset,&minute,&scanOffset,\n                          &second,&scanOffset);\n          if (scanResult < 1) {\n            comparisonResult = *(int *)(tzinfo + 0x28) + -0xe10;\n          }\n          else {\n            comparisonResult = ((uint)hour * 0xe10 + (uint)minute * 0x3c + (uint)second) * comparisonResult;\n          }\n          *(int *)(tzinfo + 0x50) = comparisonResult;\n          tzEnv = tzEnv + scanOffset;\n          firstScan = false;\n          comparisonResult = tzinfo;\n          while( true ) {\n            if (*tzEnv == ',') {\n              tzEnv = tzEnv + 1;\n            }\n            if (*tzEnv == 'M') {\n              scanResult = scanFormatted(tzEnv,\"M%hu%n.%hu%n.%hu%n\",&stdHour,&scanOffset,&stdMinute,&scanOffset,\n                              &stdSecond,&scanOffset);\n              if (scanResult != 3) {\n                return;\n              }\n              if (0xb < stdHour - 1) {\n                return;\n              }\n              if (4 < stdMinute - 1) {\n                return;\n              }\n              if (6 < stdSecond) {\n                return;\n              }\n              *(uint *)(comparisonResult + 0xc) = (uint)stdHour;\n              *(uint *)(comparisonResult + 0x10) = (uint)stdMinute;\n              *(undefined *)(comparisonResult + 8) = 0x4d;\n              *(uint *)(comparisonResult + 0x14) = (uint)stdSecond;\n              scanPtr = tzEnv + scanOffset;\n            }\n            else {\n              if (*tzEnv == 'J') {\n                tzEnv = tzEnv + 1;\n                indicator = 0x4a;\n              }\n              else {\n                indicator = 0x44;\n              }\n              parsedValue = stringToUnsignedLong(tzEnv,timezoneStd,10);\n              stdSecond = (ushort)parsedValue;\n              scanPtr = timezoneStd[0];\n              if (timezoneStd[0] == tzEnv) {\n                if (firstScan) {\n                  *(undefined *)(tzinfo + 0x30) = 0x4d;\n                  *(undefined4 *)(tzinfo + 0x34) = 0xb;\n                  *(undefined4 *)(tzinfo + 0x38) = 1;\n                  *(undefined4 *)(tzinfo + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(tzinfo + 8) = 0x4d;\n                  *(undefined4 *)(tzinfo + 0xc) = 3;\n                  *(undefined4 *)(tzinfo + 0x10) = 2;\n                  *(undefined4 *)(tzinfo + 0x14) = 0;\n                }\n              }\n              else {\n                *(undefined *)(comparisonResult + 8) = indicator;\n                *(ulong *)(comparisonResult + 0x14) = parsedValue & 0xffff;\n              }\n            }\n            hour = 2;\n            minute = 0;\n            second = 0;\n            scanOffset = 0;\n            if (*scanPtr == '/') {\n              scanFormatted(scanPtr,\"/%hu%n:%hu%n:%hu%n\",&hour,&scanOffset,&minute,&scanOffset,&second,\n                      &scanOffset);\n            }\n            *(uint *)(comparisonResult + 0x18) =\n                 (uint)hour * 0xe10 + (uint)minute * 0x3c + (uint)second;\n            comparisonResult = comparisonResult + 0x28;\n            tzEnv = scanPtr + scanOffset;\n            if (firstScan) break;\n            firstScan = true;\n          }\n          __calculateTimezoneLimits(*(undefined4 *)(tzinfo + 4));\n          _timezoneOffset = *(char **)(tzinfo + 0x28);\n          _daylightSaving = (char *)(*(int *)(tzinfo + 0x50) - (int)_timezoneOffset);\n          if (_daylightSaving != (char *)0x0) {\n            _daylightSaving = (char *)0x1;\n          }\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000510c": "initialize_timezone_0000510c",
                "param_1": "param",
                "iVar1": "tzinfo",
                "pcVar2": "tzEnv",
                "sVar3": "envLength",
                "iVar4": "comparisonResult",
                "iVar5": "scanResult",
                "uVar6": "parsedValue",
                "uVar7": "indicator",
                "pcVar8": "scanPtr",
                "bVar9": "firstScan",
                "puVar10": "hourPtr",
                "piVar11": "offsetPtr",
                "puVar12": "minutePtr",
                "piVar13": "secondPtr",
                "local_3c": "hour",
                "local_3a": "minute",
                "local_38": "second",
                "local_36": "stdHour",
                "local_34": "stdMinute",
                "local_32": "stdSecond",
                "local_30": "scanOffset",
                "local_2c": "timezoneStd",
                "__gettzinfo": "__getTimezoneInfo",
                "_getenv_r": "_getReverseEnv_r",
                "_tzname": "_timezoneName",
                "_daylight": "_daylightSaving",
                "_timezone": "_timezoneOffset",
                "prev_tzenv": "previousTzEnv",
                "strlen": "getLength",
                "_malloc_r": "_reverseAllocate_r",
                "strcpy": "copyString",
                "siscanf": "scanFormatted",
                "strtoul": "stringToUnsignedLong",
                "__tzname_std": "__timezoneStandardName",
                "__tzname_dst": "__timezoneDstName",
                "_tzcalc_limits": "_calculateTimezoneLimits"
            },
            "calling": [
                "_tzset_unlocked"
            ],
            "called": [
                "_malloc_r",
                "_getenv_r",
                "__gettzinfo",
                "siscanf",
                "free",
                "strlen",
                "strtoul",
                "strcmp",
                "__tzcalc_limits",
                "strcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005404": {
            "entrypoint": "0x00005404",
            "current_name": "process_input_00005404",
            "code": "\nuint processInput_00005404(int input_buffer_start,uint input_length,int *stream,undefined4 value)\n\n{\n  int result;\n  uint ushort_value;\n  undefined *ptr;\n  \n  if ((input_buffer_start != 0) && (*(int *)(input_buffer_start + 0x18) == 0)) {\n    initializeStream();\n  }\n  if (stream == fake_stdin_ptr) {\n    stream = *(int **)(input_buffer_start + 4);\n  }\n  else if (stream == (int *)&fake_stdout) {\n    stream = *(int **)(input_buffer_start + 8);\n  }\n  else if (stream == (int *)&fake_stderr) {\n    stream = *(int **)(input_buffer_start + 0xc);\n  }\n  stream[2] = stream[6];\n  ushort_value = (uint)*(ushort *)(stream + 3);\n  result = ushort_value << 0x1c;\n  if (((result < 0) && (ushort_value = stream[4], ushort_value != 0)) ||\n     (result = setupStream(input_buffer_start,stream,result,ushort_value,value), result == 0)) {\n    result = *stream - stream[4];\n    input_length = input_length & 0xff;\n    if ((result < stream[5]) || (result = flushStream(input_buffer_start,stream), result == 0)) {\n      stream[2] = stream[2] + -1;\n      ptr = (undefined *)*stream;\n      *stream = (int)(ptr + 1);\n      *ptr = (char)input_length;\n      if (stream[5] != result + 1) {\n        if (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1f)) {\n          return input_length;\n        }\n        if (input_length != 10) {\n          return input_length;\n        }\n      }\n      result = flushStream(input_buffer_start,stream);\n      if (result == 0) {\n        return input_length;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00005404": "process_input_00005404",
                "param_1": "input_buffer_start",
                "param_2": "input_length",
                "param_3": "stream",
                "param_4": "value",
                "iVar1": "result",
                "uVar2": "ushort_value",
                "puVar3": "ptr",
                "__sinit": "initializeStream",
                "&__sf_fake_stdin": "fake_stdin_ptr",
                "__sf_fake_stdout": "fake_stdout",
                "__sf_fake_stderr": "fake_stderr",
                "__swsetup_r": "setupStream",
                "_fflush_r": "flushStream"
            },
            "calling": [
                "__sfputc_r",
                "_puts_r",
                "_putc_r"
            ],
            "called": [
                "__sinit",
                "_fflush_r",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000054a8": {
            "entrypoint": "0x000054a8",
            "current_name": "decode_and_process_data_000054a8",
            "code": "\nuint decode_and_process_data_000054a8(undefined4 *input_buffer,undefined4 *stream_data)\n\n{\n  ushort temp1;\n  int global_data_ptr;\n  ushort temp2;\n  uint stream_length;\n  uint temp3;\n  \n  global_data_ptr = _impure_ptr;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  if (stream_data == &__sf_fake_stdin) {\n    stream_data = *(undefined4 **)(global_data_ptr + 4);\n  }\n  else if (stream_data == (undefined4 *)&__sf_fake_stdout) {\n    stream_data = *(undefined4 **)(global_data_ptr + 8);\n  }\n  else if (stream_data == (undefined4 *)&__sf_fake_stderr) {\n    stream_data = *(undefined4 **)(global_data_ptr + 0xc);\n  }\n  stream_length = (uint)*(ushort *)(stream_data + 3);\n  temp2 = *(ushort *)(stream_data + 3);\n  if (-1 < (int)(stream_length << 0x1c)) {\n    if (-1 < (int)(stream_length << 0x1b)) {\n      *input_buffer = 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(stream_length << 0x1d) < 0) {\n      if ((undefined4 *)stream_data[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)stream_data[0xd] != stream_data + 0x11) {\n          _free_r(input_buffer);\n        }\n        stream_data[0xd] = 0;\n      }\n      *(ushort *)(stream_data + 3) = *(ushort *)(stream_data + 3) & 0xffdb;\n      stream_data[1] = 0;\n      *stream_data = stream_data[4];\n    }\n    *(ushort *)(stream_data + 3) = *(ushort *)(stream_data + 3) | 8;\n  }\n  if ((stream_data[4] == 0) && ((*(ushort *)(stream_data + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(input_buffer,stream_data);\n  }\n  temp1 = *(ushort *)(stream_data + 3);\n  stream_length = (uint)temp1;\n  temp2 = *(ushort *)(stream_data + 3);\n  temp3 = stream_length & 1;\n  if ((temp1 & 1) == 0) {\n    if (-1 < (int)(stream_length << 0x1e)) {\n      temp3 = stream_data[5];\n    }\n    stream_data[2] = temp3;\n  }\n  else {\n    stream_data[2] = 0;\n    stream_data[6] = -stream_data[5];\n  }\n  if (stream_data[4] != 0) {\n    return 0;\n  }\n  if ((temp1 & 0x80) == 0) {\n    return stream_length & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(stream_data + 3) = temp2 | 0x40;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_000054a8": "decode_and_process_data_000054a8",
                "param_1": "input_buffer",
                "param_2": "stream_data",
                "uVar1": "temp1",
                "iVar2": "global_data_ptr",
                "uVar3": "temp2",
                "uVar4": "stream_length",
                "uVar5": "temp3"
            },
            "calling": [
                "__swbuf_r",
                "_puts_r",
                "_vfprintf_r"
            ],
            "called": [
                "__smakebuf_r",
                "__sinit",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005584": {
            "entrypoint": "0x00005584",
            "current_name": "divide_and_remainder_00005584",
            "code": "\ndiv_t divideAndRemainder_00005584(int numerator,int denominator)\n\n{\n  uint temp;\n  int remainder;\n  uint quotient;\n  div_t result;\n  \n  quotient = (uint)denominator / temp;\n  remainder = denominator - temp * quotient;\n  if (denominator < 0) {\n    if (0 < remainder) {\n      quotient = quotient - 1;\n      remainder = remainder + temp;\n    }\n  }\n  else if (remainder < 0) {\n    quotient = quotient + 1;\n    remainder = remainder - temp;\n  }\n  *(uint *)numerator = quotient;\n  *(int *)(numerator + 4) = remainder;\n  result.rem = denominator;\n  result.quot = numerator;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00005584": "divide_and_remainder_00005584",
                "__numer": "numerator",
                "__denom": "denominator",
                "in_r2": "temp",
                "iVar1": "remainder",
                "uVar2": "quotient",
                "dVar3": "result"
            },
            "calling": [
                "validate_structure"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000055ac": {
            "entrypoint": "0x000055ac",
            "current_name": "read_byte_from_stream_000055ac",
            "code": "\nuint read_byte_from_stream_000055ac(int stream_handle,byte **stream_ptr)\n\n{\n  uint byte_read;\n  byte *stream_data;\n  \n  if ((stream_handle != 0) && (*(int *)(stream_handle + 0x18) == 0)) {\n    initialize_stream();\n  }\n  if (stream_ptr == (byte **)&fake_stdin_ptr) {\n    stream_ptr = *(byte ***)(stream_handle + 4);\n  }\n  else if (stream_ptr == (byte **)&fake_stdout_ptr) {\n    stream_ptr = *(byte ***)(stream_handle + 8);\n  }\n  else if (stream_ptr == (byte **)&fake_stderr_ptr) {\n    stream_ptr = *(byte ***)(stream_handle + 0xc);\n  }\n  if ((-1 < (int)stream_flag1 << 0x1f) && (-1 < (int)((uint)*(ushort *)(stream_ptr + 3) << 0x16))) {\n    acquire_recursive_lock(stream_lock);\n  }\n  stream_data = stream_ptr[1];\n  stream_ptr[1] = stream_data + -1;\n  if ((int)(stream_data + -1) < 0) {\n    byte_read = read_byte_from_buffer(stream_handle,stream_ptr);\n  }\n  else {\n    stream_data = *stream_ptr;\n    *stream_ptr = stream_data + 1;\n    byte_read = (uint)*stream_data;\n  }\n  if ((-1 < (int)stream_flag1 << 0x1f) && (-1 < (int)((uint)*(ushort *)(stream_ptr + 3) << 0x16))) {\n    release_recursive_lock(stream_lock);\n  }\n  return byte_read;\n}\n\n",
            "renaming": {
                "FUN_000055ac": "read_byte_from_stream_000055ac",
                "param_1": "stream_handle",
                "param_2": "stream_ptr",
                "uVar1": "byte_read",
                "pbVar2": "stream_data",
                "__sinit": "initialize_stream",
                "__sf_fake_stdin": "fake_stdin_ptr",
                "__sf_fake_stdout": "fake_stdout_ptr",
                "__sf_fake_stderr": "fake_stderr_ptr",
                "__retarget_lock_acquire_recursive": "acquire_recursive_lock",
                "param_2[0x19]": "stream_flag1",
                "__srget_r": "read_byte_from_buffer",
                "param_2[0x16]": "stream_lock",
                "__retarget_lock_release_recursive": "release_recursive_lock"
            },
            "calling": [
                "getchar"
            ],
            "called": [
                "__sinit",
                "__srget_r",
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000562c": {
            "entrypoint": "0x0000562c",
            "current_name": "find_environment_variable_0000562c",
            "code": "\nchar * findEnvironmentVariable_0000562c(undefined4 param,char *variableName,int *resultIndex)\n\n{\n  char currentChar;\n  char **currentEnv;\n  int comparisonResult;\n  char *currentEntry;\n  char **nextEnv;\n  size_t variableNameLength;\n  \n  __env_lock();\n  currentEntry = variableName;\n  if (environ != (char **)0x0) {\n    do {\n      currentChar = *currentEntry;\n      if (currentChar == '\\0') {\n        variableNameLength = (int)currentEntry - (int)variableName;\n        currentEnv = environ;\n        while( true ) {\n          nextEnv = currentEnv;\n          if (*nextEnv == (char *)0x0) break;\n          comparisonResult = strncmp(*nextEnv,variableName,variableNameLength);\n          currentEnv = nextEnv + 1;\n          if ((comparisonResult == 0) && (currentEntry = *nextEnv, currentEntry[variableNameLength] == '=')) {\n            *resultIndex = (int)nextEnv - (int)environ >> 2;\n            __env_unlock(param);\n            return currentEntry + variableNameLength + 1;\n          }\n        }\n        break;\n      }\n      currentEntry = currentEntry + 1;\n    } while (currentChar != '=');\n  }\n  __env_unlock(param);\n  return (char *)0x0;\n}\n\n",
            "renaming": {
                "FUN_0000562c": "find_environment_variable_0000562c",
                "param_1": "param",
                "param_2": "variableName",
                "param_3": "resultIndex",
                "cVar1": "currentChar",
                "ppcVar2": "currentEnv",
                "iVar3": "comparisonResult",
                "pcVar4": "currentEntry",
                "ppcVar5": "nextEnv",
                "__n": "variableNameLength"
            },
            "calling": [
                "_getenv_r"
            ],
            "called": [
                "__env_lock",
                "__env_unlock",
                "strncmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000056a0": {
            "entrypoint": "0x000056a0",
            "current_name": "find_environment_000056a0",
            "code": "\nvoid find_environment_000056a0(undefined4 arg1,undefined4 arg2,undefined4 arg3,undefined4 arg4)\n\n{\n  undefined4 stack_param2;\n  undefined4 stack_param3;\n  \n  stack_param2 = arg2;\n  stack_param3 = arg3;\n  _findenv_r(arg1,arg2,&stack_param2,arg4,arg1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000056a0": "find_environment_000056a0",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4",
                "uStack_c": "stack_param2",
                "uStack_8": "stack_param3"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "_findenv_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000056b0": {
            "entrypoint": "0x000056b0",
            "current_name": "get_timezone_information_000056b0",
            "code": "\nundefined1 * get_timezone_information_000056b0(void)\n\n{\n  return timezone_information;\n}\n\n",
            "renaming": {
                "FUN_000056b0": "get_timezone_information_000056b0",
                "&tzinfo": "timezone_information"
            },
            "calling": [
                "mktime",
                "__tzcalc_limits",
                "_tzset_unlocked_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000056b8": {
            "entrypoint": "0x000056b8",
            "current_name": "get_file_permissions_000056b8",
            "code": "\nundefined4 get_file_permissions_000056b8(_reent *reent,int file_descriptor,undefined4 *permission_flags,uint *is_executable)\n\n{\n  int result;\n  undefined4 default_permission;\n  stat file_stat;\n  \n  if ((*(short *)(file_descriptor + 0xe) < 0) ||\n     (result = _fstat_r(reent,(int)*(short *)(file_descriptor + 0xe),&file_stat), result < 0)) {\n    *is_executable = 0;\n    if ((int)((uint)*(ushort *)(file_descriptor + 0xc) << 0x18) < 0) {\n      default_permission = 0x40;\n      goto LAB_000056f8;\n    }\n  }\n  else {\n    *is_executable = (uint)((file_stat.st_mode & 0xf000) == 0x2000);\n  }\n  default_permission = 0x400;\nLAB_000056f8:\n  *permission_flags = default_permission;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000056b8": "get_file_permissions_000056b8",
                "param_1": "reent",
                "param_2": "file_descriptor",
                "param_3": "permission_flags",
                "param_4": "is_executable",
                "iVar1": "result",
                "uVar2": "default_permission",
                "sStack_68": "file_stat"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005700": {
            "entrypoint": "0x00005700",
            "current_name": "initialize_file_00005700",
            "code": "\nvoid initializeFile_00005700(_reent *fileContext,int *fileDescriptor)\n\n{\n  ushort bufferSize;\n  int memoryAllocation;\n  _reent *localFileContext;\n  int *localFileDescriptor;\n  \n  if (-1 < (int)((uint)*(ushort *)(fileDescriptor + 3) << 0x1e)) {\n    localFileContext = fileContext;\n    localFileDescriptor = fileDescriptor;\n    bufferSize = __swhatbuf_r(fileContext,fileDescriptor,&localFileContext,&localFileDescriptor);\n    memoryAllocation = _malloc_r(fileContext,localFileContext);\n    if (memoryAllocation != 0) {\n      fileContext->__cleanup = _cleanup_r + 1;\n      *fileDescriptor = memoryAllocation;\n      *(ushort *)(fileDescriptor + 3) = *(ushort *)(fileDescriptor + 3) | 0x80;\n      fileDescriptor[5] = (int)localFileContext;\n      fileDescriptor[4] = memoryAllocation;\n      if ((localFileDescriptor != (int *)0x0) &&\n         (memoryAllocation = _isatty_r(fileContext,(int)*(short *)((int)fileDescriptor + 0xe)), memoryAllocation != 0)) {\n        *(ushort *)(fileDescriptor + 3) = *(ushort *)(fileDescriptor + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(fileDescriptor + 3) = bufferSize | *(ushort *)(fileDescriptor + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(fileDescriptor + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(fileDescriptor + 3) = *(ushort *)(fileDescriptor + 3) & 0xfffc | 2;\n  }\n  *fileDescriptor = (int)fileDescriptor + 0x47;\n  fileDescriptor[4] = (int)fileDescriptor + 0x47;\n  fileDescriptor[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005700": "initialize_file_00005700",
                "param_1": "fileContext",
                "param_2": "fileDescriptor",
                "uVar1": "bufferSize",
                "iVar2": "memoryAllocation",
                "local_18": "localFileContext",
                "local_14": "localFileDescriptor"
            },
            "calling": [
                "__srefill_r",
                "__swsetup_r"
            ],
            "called": [
                "_malloc_r",
                "_isatty_r",
                "__swhatbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005780": {
            "entrypoint": "0x00005780",
            "current_name": "free_memory_00005780",
            "code": "\nvoid freeMemory_00005780(void *memoryBlock)\n\n{\n  freeFunction(impurePointer,memoryBlock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005780": "free_memory_00005780",
                "__ptr": "memoryBlock",
                "_free_r": "freeFunction",
                "_impure_ptr": "impurePointer"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005790": {
            "entrypoint": "0x00005790",
            "current_name": "acquire_malloc_recursive_lock_00005790",
            "code": "\nvoid acquireMallocRecursiveLock_00005790(void)\n\n{\n  __retarget_lock_acquire_recursive(&__lock___malloc_recursive_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005790": "acquire_malloc_recursive_lock_00005790"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000579c": {
            "entrypoint": "0x0000579c",
            "current_name": "release_malloc_recursive_lock_0000579c",
            "code": "\nvoid releaseMallocRecursiveLock_0000579c(void)\n\n{\n  __retarget_lock_release_recursive(&lock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000579c": "release_malloc_recursive_lock_0000579c",
                "__lock___malloc_recursive_mutex": "lock"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000057a8": {
            "entrypoint": "0x000057a8",
            "current_name": "write_to_buffer_000057a8",
            "code": "\nint writeToBuffer_000057a8(undefined4 buffer,int character,undefined4 *bufferState)\n\n{\n  int index;\n  undefined *currentByte;\n  \n  index = bufferState[2] + -1;\n  bufferState[2] = index;\n  if ((index < 0) && ((index < (int)bufferState[6] || (character == 10)))) {\n    index = __swbuf_r();\n    return index;\n  }\n  currentByte = (undefined *)*bufferState;\n  *bufferState = currentByte + 1;\n  *currentByte = (char)character;\n  return character;\n}\n\n",
            "renaming": {
                "FUN_000057a8": "write_to_buffer_000057a8",
                "param_1": "buffer",
                "param_2": "character",
                "param_3": "bufferState",
                "iVar1": "index",
                "puVar2": "currentByte"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__swbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000057d2": {
            "entrypoint": "0x000057d2",
            "current_name": "write_to_stream_000057d2",
            "code": "\nint write_to_stream_000057d2(undefined4 stream,undefined4 buffer_size,undefined *data,int length)\n\n{\n  int result;\n  undefined *end_of_data;\n  int remaining_length;\n  \n  end_of_data = data + length;\n  remaining_length = length;\n  do {\n    if (data == end_of_data) {\n      return 0;\n    }\n    result = __sfputc_r(stream,*data,buffer_size,length,remaining_length);\n    length = result + 1;\n    data = data + 1;\n  } while (length != 0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000057d2": "write_to_stream_000057d2",
                "param_1": "stream",
                "param_2": "buffer_size",
                "param_3": "data",
                "param_4": "length",
                "iVar1": "result",
                "puVar2": "end_of_data",
                "iVar3": "remaining_length"
            },
            "calling": [
                "_vfprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000057f8": {
            "entrypoint": "0x000057f8",
            "current_name": "formatted_print_000057f8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000059f0) */\n\nint formattedPrint_000057f8(int stream,undefined4 *format,byte *str,int *args)\n\n{\n  bool bVar1;\n  int length;\n  int result;\n  void *formatSpecifier;\n  int *argsPtr;\n  byte *ptr;\n  int lockFlag;\n  byte *ptrNext;\n  int *argsPtrTemp;\n  uint flags;\n  int precision;\n  undefined4 width;\n  int argIndex;\n  int totalLength;\n  byte ch;\n  undefined spaceFlag;\n  undefined plusFlag;\n  undefined hashFlag;\n  undefined4 specifierFlag;\n  \n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (format == &__sf_fake_stdin) {\n    format = *(undefined4 **)(stream + 4);\n  }\n  else if (format == (undefined4 *)&__sf_fake_stdout) {\n    format = *(undefined4 **)(stream + 8);\n  }\n  else if (format == (undefined4 *)&__sf_fake_stderr) {\n    format = *(undefined4 **)(stream + 0xc);\n  }\n  if ((-1 < (int)(format[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(format + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(format[0x16]);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(format + 3) << 0x1c)) || (format[4] == 0)) &&\n     (length = __swsetup_r(stream,format), length != 0)) {\n    if ((-1 < (int)(format[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(format + 3) << 0x16)))\n    {\n      __retarget_lock_release_recursive(format[0x16]);\n    }\n    return -1;\n  }\n  totalLength = 0;\n  spaceFlag = 0x20;\n  plusFlag = 0x30;\n  ptrNext = str;\n  argsPtrTemp = args;\nLAB_0000588e:\n  ptr = ptrNext;\n  if (*ptr != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  ptrNext = ptr + 1;\n  if (*ptr == 0x25) {\nLAB_0000589a:\n    length = (int)ptr - (int)str;\n    if (length != 0) {\n      result = __sfputs_r(stream,format,str,length);\n      if (result == -1) {\nLAB_00005a06:\n        if ((-1 < (int)(format[0x19] << 0x1f)) &&\n           (-1 < (int)((uint)*(ushort *)(format + 3) << 0x16))) {\n          __retarget_lock_release_recursive(format[0x16]);\n        }\n        if ((int)((uint)*(ushort *)(format + 3) << 0x19) < 0) {\n          return -1;\n        }\n        return totalLength;\n      }\n      totalLength = totalLength + length;\n    }\n    if (*ptr == 0) goto LAB_00005a06;\n    precision = -1;\n    width = 0;\n    flags = 0;\n    argIndex = 0;\n    hashFlag = 0;\n    specifierFlag = 0;\n    ptrNext = ptr + 1;\n    while( true ) {\n      ptr = ptrNext + 1;\n      formatSpecifier = memchr(\"#-0+ \",(uint)*ptrNext,5);\n      if (formatSpecifier == (void *)0x0) break;\n      flags = 1 << ((int)formatSpecifier - 0x7bfcU & 0xff) | flags;\n      ptrNext = ptr;\n    }\n    if ((int)(flags << 0x1b) < 0) {\n      hashFlag = 0x20;\n    }\n    if ((int)(flags << 0x1c) < 0) {\n      hashFlag = 0x2b;\n    }\n    if (*ptrNext == 0x2a) {\n      argsPtr = argsPtrTemp + 1;\n      argIndex = *argsPtrTemp;\n      argsPtrTemp = argsPtr;\n      if (argIndex < 0) {\n        argIndex = -argIndex;\n        flags = flags | 2;\n      }\n    }\n    else {\n      bVar1 = false;\n      length = argIndex;\n      ptr = ptrNext;\n      while( true ) {\n        if (9 < *ptr - 0x30) break;\n        length = length * 10 + (*ptr - 0x30);\n        bVar1 = true;\n        ptr = ptr + 1;\n      }\n      if (bVar1) {\n        argIndex = length;\n      }\n    }\n    if (*ptr == 0x2e) {\n      if (ptr[1] == 0x2a) {\n        precision = *argsPtrTemp;\n        if (precision < 0) {\n          precision = -1;\n        }\n        ptr = ptr + 2;\n        argsPtrTemp = argsPtrTemp + 1;\n      }\n      else {\n        bVar1 = false;\n        precision = 0;\n        length = 0;\n        while( true ) {\n          ptr = ptr + 1;\n          if (9 < *ptr - 0x30) break;\n          length = length * 10 + (*ptr - 0x30);\n          bVar1 = true;\n        }\n        if (bVar1) {\n          precision = length;\n        }\n      }\n    }\n    formatSpecifier = memchr(&DAT_00007c02,(uint)*ptr,3);\n    if (formatSpecifier != (void *)0x0) {\n      flags = flags | 0x40 << ((int)formatSpecifier - 0x7c02U & 0xff);\n      ptr = ptr + 1;\n    }\n    str = ptr + 1;\n    ch = *ptr;\n    formatSpecifier = memchr(\"efgEFG\",(uint)ch,6);\n    if (formatSpecifier == (void *)0x0) {\n      lockFlag = _printf_i(stream,&flags,format,0x57d3,&argsPtrTemp);\n      if (lockFlag == -1) goto LAB_00005a06;\n    }\n    else {\n      argsPtrTemp = (int *)(((int)argsPtrTemp + 7U & 0xfffffff8) + 8);\n    }\n    totalLength = totalLength + lockFlag;\n    ptrNext = str;\n  }\n  goto LAB_0000588e;\n}\n\n",
            "renaming": {
                "FUN_000057f8": "formatted_print_000057f8",
                "param_1": "stream",
                "param_2": "format",
                "param_3": "str",
                "param_4": "args",
                "iVar2": "length",
                "iVar3": "result",
                "pvVar4": "formatSpecifier",
                "piVar5": "argsPtr",
                "pbVar6": "ptr",
                "pbVar7": "ptrNext",
                "unaff_r7": "lockFlag",
                "local_8c": "argsPtrTemp",
                "local_88": "flags",
                "local_84": "precision",
                "uStack_80": "width",
                "local_7c": "argIndex",
                "local_74": "totalLength",
                "local_70": "ch",
                "local_6f": "spaceFlag",
                "local_6e": "plusFlag",
                "local_45": "hashFlag",
                "local_30": "specifierFlag"
            },
            "calling": [
                "iprintf"
            ],
            "called": [
                "_printf_i",
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__sfputs_r",
                "__retarget_lock_release_recursive",
                "memchr",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005a58": {
            "entrypoint": "0x00005a58",
            "current_name": "calculate_required_size_00005a58",
            "code": "\nundefined4\ncalculateRequiredSize_00005a58(undefined4 param1,uint *input,uint *output,undefined4 param4,code *callback)\n\n{\n  int index;\n  undefined4 result;\n  int returnValue;\n  uint maxSize;\n  uint count;\n  bool isNonZero;\n  \n  maxSize = input[4];\n  if ((int)input[4] < (int)input[2]) {\n    maxSize = input[2];\n  }\n  *output = maxSize;\n  if (*(char *)((int)input + 0x43) != '\\0') {\n    *output = maxSize + 1;\n  }\n  if ((int)(*input << 0x1a) < 0) {\n    *output = *output + 2;\n  }\n  if ((*input & 6) == 0) {\n    for (index = 0; index < (int)(input[3] - *output); index = index + 1) {\n      returnValue = (*callback)(param1,param4,(int)input + 0x19,1);\n      if (returnValue == -1) goto LAB_00005afc;\n    }\n  }\n  maxSize = (uint)*(byte *)((int)input + 0x43);\n  if (maxSize != 0) {\n    maxSize = 1;\n  }\n  if ((int)(*input << 0x1a) < 0) {\n    *(undefined *)((int)input + maxSize + 0x43) = 0x30;\n    *(undefined *)((int)input + maxSize + 0x44) = *(undefined *)((int)input + 0x45);\n    maxSize = maxSize + 2;\n  }\n  index = (*callback)(param1,param4,(int)input + 0x43,maxSize);\n  if (index == -1) {\nLAB_00005afc:\n    result = 0xffffffff;\n  }\n  else {\n    maxSize = input[3];\n    isNonZero = (*input & 6) == 4;\n    if (isNonZero) {\n      maxSize = maxSize - *output;\n    }\n    if (isNonZero) {\n      maxSize = maxSize & ~((int)maxSize >> 0x1f);\n    }\n    else {\n      maxSize = 0;\n    }\n    if ((int)input[4] < (int)input[2]) {\n      maxSize = maxSize + (input[2] - input[4]);\n    }\n    for (count = 0; maxSize != count; count = count + 1) {\n      index = (*callback)(param1,param4,(int)input + 0x1a,1);\n      if (index == -1) goto LAB_00005afc;\n    }\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00005a58": "calculate_required_size_00005a58",
                "param_1": "param1",
                "param_2": "input",
                "param_3": "output",
                "param_4": "param4",
                "param_5": "callback",
                "iVar1": "index",
                "uVar2": "result",
                "iVar3": "returnValue",
                "uVar4": "maxSize",
                "uVar5": "count",
                "bVar6": "isNonZero"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005b34": {
            "entrypoint": "0x00005b34",
            "current_name": "print_formatted_value_00005b34",
            "code": "\ncode * printFormattedValue_00005b34(undefined4 formatString,uint *argList,undefined4 locale,code *printer,uint **argPtr\n                   )\n\n{\n  bool isPositive;\n  byte firstChar;\n  int result;\n  code *formattedString;\n  char *hexTable;\n  void *nullBytePtr;\n  int fmtResult;\n  char *buffer;\n  uint remainder;\n  uint *argPtrCurrent;\n  uint base;\n  uint **ppuVar11;\n  char **ppcVar12;\n  uint fieldWidth;\n  char *dstPtr;\n  uint *origArgPtr;\n  undefined4 origLocale;\n  code *origPrinter;\n  \n  firstChar = *(byte *)(argList + 6);\n  buffer = (char *)((int)argList + 0x43);\n  origArgPtr = argList;\n  origLocale = locale;\n  origPrinter = printer;\n  if (0x78 < firstChar) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)argList + 0x42) = firstChar;\nLAB_00005bdc:\n    buffer = (char *)((int)argList + 0x42);\n    remainder = 1;\nLAB_00005d28:\n    argList[4] = remainder;\n    *(undefined *)((int)argList + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (firstChar < 99) {\n    if (firstChar == 0) goto LAB_00005d06;\n    if (firstChar == 0x58) {\n      hexTable = \"0123456789ABCDEF\";\n      *(undefined *)((int)argList + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(firstChar) {\n  case 99:\n    remainder = **argPtr;\n    *argPtr = *argPtr + 1;\n    *(char *)((int)argList + 0x42) = (char)remainder;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    base = *argList;\n    argPtrCurrent = *argPtr;\n    if ((int)(base << 0x18) < 0) {\n      remainder = *argPtrCurrent;\n      *argPtr = argPtrCurrent + 1;\n    }\n    else {\n      remainder = *argPtrCurrent;\n      *argPtr = argPtrCurrent + 1;\n      if ((base & 0x40) != 0) {\n        remainder = (uint)(short)remainder;\n      }\n    }\n    if ((int)remainder < 0) {\n      remainder = -remainder;\n      *(undefined *)((int)argList + 0x43) = 0x2d;\n    }\n    hexTable = \"0123456789ABCDEF\";\n    base = 10;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    ppuVar11 = (uint **)*argPtr;\n    base = *argList;\n    remainder = argList[5];\n    *argPtr = (uint *)(ppuVar11 + 1);\n    argPtrCurrent = *ppuVar11;\n    if (((int)(base << 0x18) < 0) || (-1 < (int)(base << 0x19))) {\n      *argPtrCurrent = remainder;\n    }\n    else {\n      *(short *)argPtrCurrent = (short)remainder;\n    }\nLAB_00005d06:\n    argList[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    argPtrCurrent = *argPtr;\n    remainder = *argList;\n    *argPtr = argPtrCurrent + 1;\n    if (((int)(remainder << 0x18) < 0) || (-1 < (int)(remainder << 0x19))) {\n      remainder = *argPtrCurrent;\n    }\n    else {\n      remainder = (uint)*(ushort *)argPtrCurrent;\n    }\n    hexTable = \"0123456789ABCDEF\";\n    if (firstChar == 0x6f) {\n      base = 8;\n    }\n    else {\n      base = 10;\n    }\n    break;\n  case 0x70:\n    *argList = *argList | 0x20;\n  case 0x78:\n    hexTable = \"0123456789abcdef\";\n    *(undefined *)((int)argList + 0x45) = 0x78;\nLAB_00005ca8:\n    base = *argList;\n    remainder = **argPtr;\n    *argPtr = *argPtr + 1;\n    if ((-1 < (int)(base << 0x18)) && ((int)(base << 0x19) < 0)) {\n      remainder = remainder & 0xffff;\n    }\n    if ((int)(base << 0x1f) < 0) {\n      *argList = base | 0x20;\n    }\n    if (remainder == 0) {\n      *argList = *argList & 0xffffffdf;\n    }\n    base = 0x10;\n    break;\n  case 0x73:\n    ppcVar12 = (char **)*argPtr;\n    *argPtr = (uint *)(ppcVar12 + 1);\n    buffer = *ppcVar12;\n    nullBytePtr = memchr(buffer,0,argList[1]);\n    if (nullBytePtr != (void *)0x0) {\n      argList[1] = (int)nullBytePtr - (int)buffer;\n    }\n    remainder = argList[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)argList + 0x43) = 0;\nLAB_00005c36:\n  fieldWidth = argList[1];\n  argList[2] = fieldWidth;\n  if (-1 < (int)fieldWidth) {\n    *argList = *argList & 0xfffffffb;\n  }\n  dstPtr = buffer;\n  if ((remainder != 0) || (fieldWidth != 0)) {\n    do {\n      dstPtr = dstPtr + -1;\n      *dstPtr = hexTable[remainder - base * (remainder / base)];\n      isPositive = base <= remainder;\n      remainder = remainder / base;\n    } while (isPositive);\n  }\n  if (((base == 8) && ((int)(*argList << 0x1f) < 0)) && ((int)argList[1] <= (int)argList[4])) {\n    dstPtr[-1] = '0';\n    dstPtr = dstPtr + -1;\n  }\n  argList[4] = (int)buffer - (int)dstPtr;\n  buffer = dstPtr;\nLAB_00005c84:\n  result = _printf_common(formatString,argList,&origPrinter,locale,printer,origArgPtr,origLocale);\n  if ((result == -1) || (result = (*printer)(formatString,locale,buffer,argList[4]), result == -1)) {\nLAB_00005c98:\n    formattedString = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*argList << 0x1e) < 0) {\n      for (result = 0; result < (int)(argList[3] - (int)origPrinter); result = result + 1) {\n        fmtResult = (*printer)(formatString,locale,(int)argList + 0x19,1);\n        if (fmtResult == -1) goto LAB_00005c98;\n      }\n    }\n    formattedString = (code *)argList[3];\n    if ((int)(code *)argList[3] < (int)origPrinter) {\n      formattedString = origPrinter;\n    }\n  }\n  return formattedString;\n}\n\n",
            "renaming": {
                "FUN_00005b34": "print_formatted_value_00005b34",
                "param_1": "formatString",
                "param_2": "argList",
                "param_3": "locale",
                "param_4": "printer",
                "param_5": "argPtr",
                "bVar1": "isPositive",
                "bVar2": "firstChar",
                "iVar3": "result",
                "pcVar4": "formattedString",
                "pcVar5": "hexTable",
                "pvVar6": "nullBytePtr",
                "iVar7": "fmtResult",
                "__s": "buffer",
                "uVar8": "remainder",
                "puVar9": "argPtrCurrent",
                "uVar10": "base",
                "uVar13": "fieldWidth",
                "pcVar14": "dstPtr",
                "puVar15": "origArgPtr",
                "uVar16": "origLocale",
                "local_24": "origPrinter"
            },
            "calling": [
                "_vfprintf_r"
            ],
            "called": [
                "_printf_common",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005d80": {
            "entrypoint": "0x00005d80",
            "current_name": "write_character_to_file_00005d80",
            "code": "\nuint writeCharacterToFile_00005d80(int fileDescriptor,uint character,undefined4 *fileStruct)\n\n{\n  int remainingChars;\n  undefined *bufferPointer;\n  \n  if ((fileDescriptor != 0) && (*(int *)(fileDescriptor + 0x18) == 0)) {\n    __sinit();\n  }\n  if (fileStruct == &__sf_fake_stdin) {\n    fileStruct = *(undefined4 **)(fileDescriptor + 4);\n  }\n  else if (fileStruct == (undefined4 *)&__sf_fake_stdout) {\n    fileStruct = *(undefined4 **)(fileDescriptor + 8);\n  }\n  else if (fileStruct == (undefined4 *)&__sf_fake_stderr) {\n    fileStruct = *(undefined4 **)(fileDescriptor + 0xc);\n  }\n  if ((-1 < (int)(fileStruct[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(fileStruct + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(fileStruct[0x16]);\n  }\n  remainingChars = fileStruct[2] + -1;\n  fileStruct[2] = remainingChars;\n  if ((remainingChars < 0) && ((remainingChars < (int)fileStruct[6] || ((character & 0xff) == 10)))) {\n    character = __swbuf_r(fileDescriptor,character,fileStruct);\n  }\n  else {\n    bufferPointer = (undefined *)*fileStruct;\n    *fileStruct = bufferPointer + 1;\n    *bufferPointer = (char)character;\n    character = character & 0xff;\n  }\n  if ((-1 < (int)(fileStruct[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(fileStruct + 3) << 0x16))) {\n    __retarget_lock_release_recursive(fileStruct[0x16]);\n  }\n  return character;\n}\n\n",
            "renaming": {
                "FUN_00005d80": "write_character_to_file_00005d80",
                "param_1": "fileDescriptor",
                "param_2": "character",
                "param_3": "fileStruct",
                "iVar1": "remainingChars",
                "puVar2": "bufferPointer"
            },
            "calling": [
                "putchar"
            ],
            "called": [
                "__swbuf_r",
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005e10": {
            "entrypoint": "0x00005e10",
            "current_name": "read_byte_from_stream_00005e10",
            "code": "\nuint readByteFromStream_00005e10(int stream,byte **streamBuffer)\n\n{\n  int refillStatus;\n  uint byteValue;\n  byte *currentByte;\n  \n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (streamBuffer == (byte **)&__sf_fake_stdin) {\n    streamBuffer = *(byte ***)(stream + 4);\n  }\n  else if (streamBuffer == (byte **)&__sf_fake_stdout) {\n    streamBuffer = *(byte ***)(stream + 8);\n  }\n  else if (streamBuffer == (byte **)&__sf_fake_stderr) {\n    streamBuffer = *(byte ***)(stream + 0xc);\n  }\n  refillStatus = __srefill_r(stream,streamBuffer);\n  if (refillStatus == 0) {\n    streamBuffer[1] = streamBuffer[1] + -1;\n    currentByte = *streamBuffer;\n    *streamBuffer = currentByte + 1;\n    byteValue = (uint)*currentByte;\n  }\n  else {\n    byteValue = 0xffffffff;\n  }\n  return byteValue;\n}\n\n",
            "renaming": {
                "FUN_00005e10": "read_byte_from_stream_00005e10",
                "param_1": "stream",
                "param_2": "streamBuffer",
                "iVar1": "refillStatus",
                "uVar2": "byteValue",
                "pbVar3": "currentByte"
            },
            "calling": [
                "_getc_r"
            ],
            "called": [
                "__sinit",
                "__srefill_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005e68": {
            "entrypoint": "0x00005e68",
            "current_name": "scan_formatted_string_00005e68",
            "code": "\nint scanFormattedString_00005e68(char *inputString,char *formatString,...)\n\n{\n  int iVar1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *strPtr1;\n  size_t stringLength;\n  undefined2 bufferSize;\n  undefined2 defaultValue;\n  char *strPtr2;\n  size_t remainingLength;\n  undefined4 someValue1;\n  undefined4 someValue2;\n  undefined4 someValue3;\n  undefined4 stackVar1;\n  undefined4 stackVar2;\n  \n  bufferSize = 0x204;\n  strPtr1 = inputString;\n  strPtr2 = inputString;\n  stackVar1 = in_r2;\n  stackVar2 = in_r3;\n  stringLength = strlen(inputString);\n  someValue1 = 0x4deb;\n  someValue2 = 0;\n  someValue3 = 0;\n  defaultValue = 0xffff;\n  remainingLength = stringLength;\n  iVar1 = customScanf(somePtr,&strPtr1,formatString,&stackVar1);\n  return iVar1;\n}\n\n",
            "renaming": {
                "FUN_00005e68": "scan_formatted_string_00005e68",
                "__s": "inputString",
                "__format": "formatString",
                "local_80": "strPtr1",
                "local_7c": "stringLength",
                "local_74": "bufferSize",
                "local_72": "defaultValue",
                "local_70": "strPtr2",
                "local_6c": "remainingLength",
                "local_5c": "someValue1",
                "local_4c": "someValue2",
                "local_38": "someValue3",
                "uStack_8": "stackVar1",
                "uStack_4": "stackVar2",
                "_impure_ptr": "somePtr",
                "__ssvfiscanf_r": "customScanf"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "__ssvfiscanf_r",
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005ebc": {
            "entrypoint": "0x00005ebc",
            "current_name": "copy_string_00005ebc",
            "code": "\nchar * copyString_00005ebc(char *destination,char *source)\n\n{\n  char currentCharacter;\n  char *destinationPtr;\n  \n  destinationPtr = destination;\n  do {\n    currentCharacter = *source;\n    *destinationPtr = currentCharacter;\n    source = source + 1;\n    destinationPtr = destinationPtr + 1;\n  } while (currentCharacter != '\\0');\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_00005ebc": "copy_string_00005ebc",
                "__dest": "destination",
                "__src": "source",
                "cVar1": "currentCharacter",
                "pcVar2": "destinationPtr"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005ecc": {
            "entrypoint": "0x00005ecc",
            "current_name": "calculate_string_length_00005ecc",
            "code": "\nsize_t calculateStringLength_00005ecc(char *str)\n\n{\n  char currentChar;\n  char *nextCharPtr;\n  char *currentCharPtr;\n  \n  currentCharPtr = str;\n  do {\n    nextCharPtr = currentCharPtr + 1;\n    currentChar = *currentCharPtr;\n    currentCharPtr = nextCharPtr;\n  } while (currentChar != '\\0');\n  return (size_t)(nextCharPtr + (-1 - (int)str));\n}\n\n",
            "renaming": {
                "FUN_00005ecc": "calculate_string_length_00005ecc",
                "__s": "str",
                "cVar1": "currentChar",
                "pcVar2": "nextCharPtr",
                "pcVar3": "currentCharPtr"
            },
            "calling": [
                "siscanf",
                "_tzset_unlocked_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005edc": {
            "entrypoint": "0x00005edc",
            "current_name": "parse_unsigned_int_00005edc",
            "code": "\nuint parseUnsignedInt_00005edc(undefined4 *result,byte *str,byte **endptr,uint base)\n\n{\n  uint value;\n  uint ch;\n  byte negative;\n  int status;\n  uint digit;\n  uint max;\n  byte *ptr;\n  byte *cur;\n  \n  cur = str;\n  do {\n    ptr = cur;\n    cur = ptr + 1;\n    ch = (uint)*ptr;\n    negative = (&DAT_00007a99)[ch] & 8;\n  } while (((&DAT_00007a99)[ch] & 8) != 0);\n  if (ch == 0x2d) {\n    ch = (uint)*cur;\n    negative = 1;\n    cur = ptr + 2;\n  }\n  else if (ch == 0x2b) {\n    ch = (uint)*cur;\n    cur = ptr + 2;\n  }\n  if (base == 0) {\n    if (ch != 0x30) {\n      base = 10;\n      goto LAB_00005f26;\n    }\n  }\n  else if ((base != 0x10) || (ch != 0x30)) goto LAB_00005f26;\n  if ((*cur & 0xdf) == 0x58) {\n    ch = (uint)cur[1];\n    base = 0x10;\n    cur = cur + 2;\n  }\n  else {\n    ch = 0x30;\n    if (base == 0) {\n      base = 8;\n    }\n  }\nLAB_00005f26:\n  status = 0;\n  max = 0xffffffff / base;\n  value = 0;\n  do {\n    digit = ch - 0x30;\n    if (9 < digit) {\n      if (ch - 0x41 < 0x1a) {\n        digit = ch - 0x37;\n      }\n      else {\n        if (0x19 < ch - 0x61) break;\n        digit = ch - 0x57;\n      }\n    }\n    if ((int)base <= (int)digit) break;\n    if (((status < 0) || (max < value)) ||\n       ((max == value && ((int)~(base * max) < (int)digit)))) {\n      status = -1;\n    }\n    else {\n      value = value * base + digit;\n      status = 1;\n    }\n    ch = (uint)*cur;\n    cur = cur + 1;\n  } while( true );\n  if (status < 0) {\n    *result = 0x22;\n    value = 0xffffffff;\n    if (endptr == (byte **)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (negative != 0) {\n      value = -value;\n    }\n    if (endptr == (byte **)0x0) {\n      return value;\n    }\n    if (status == 0) goto LAB_00005fb8;\n  }\n  str = cur + -1;\nLAB_00005fb8:\n  *endptr = str;\n  return value;\n}\n\n",
            "renaming": {
                "FUN_00005edc": "parse_unsigned_int_00005edc",
                "param_1": "result",
                "param_2": "str",
                "param_3": "endptr",
                "param_4": "base",
                "uVar1": "value",
                "uVar2": "ch",
                "bVar3": "negative",
                "iVar4": "status",
                "uVar5": "digit",
                "uVar6": "max",
                "pbVar7": "ptr",
                "pbVar8": "cur"
            },
            "calling": [
                "_strtoul_r",
                "strtoul"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005fd4": {
            "entrypoint": "0x00005fd4",
            "current_name": "FUN_00005fd4",
            "code": "\nuint _strtoul_l_isra_0(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  byte bVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  byte *pbVar7;\n  byte *pbVar8;\n  \n  pbVar8 = param_2;\n  do {\n    pbVar7 = pbVar8;\n    pbVar8 = pbVar7 + 1;\n    uVar2 = (uint)*pbVar7;\n    bVar3 = (&DAT_00007a99)[uVar2] & 8;\n  } while (((&DAT_00007a99)[uVar2] & 8) != 0);\n  if (uVar2 == 0x2d) {\n    uVar2 = (uint)*pbVar8;\n    bVar3 = 1;\n    pbVar8 = pbVar7 + 2;\n  }\n  else if (uVar2 == 0x2b) {\n    uVar2 = (uint)*pbVar8;\n    pbVar8 = pbVar7 + 2;\n  }\n  if (param_4 == 0) {\n    if (uVar2 != 0x30) {\n      param_4 = 10;\n      goto LAB_00005f26;\n    }\n  }\n  else if ((param_4 != 0x10) || (uVar2 != 0x30)) goto LAB_00005f26;\n  if ((*pbVar8 & 0xdf) == 0x58) {\n    uVar2 = (uint)pbVar8[1];\n    param_4 = 0x10;\n    pbVar8 = pbVar8 + 2;\n  }\n  else {\n    uVar2 = 0x30;\n    if (param_4 == 0) {\n      param_4 = 8;\n    }\n  }\nLAB_00005f26:\n  iVar4 = 0;\n  uVar6 = 0xffffffff / param_4;\n  uVar1 = 0;\n  do {\n    uVar5 = uVar2 - 0x30;\n    if (9 < uVar5) {\n      if (uVar2 - 0x41 < 0x1a) {\n        uVar5 = uVar2 - 0x37;\n      }\n      else {\n        if (0x19 < uVar2 - 0x61) break;\n        uVar5 = uVar2 - 0x57;\n      }\n    }\n    if ((int)param_4 <= (int)uVar5) break;\n    if (((iVar4 < 0) || (uVar6 < uVar1)) ||\n       ((uVar6 == uVar1 && ((int)~(param_4 * uVar6) < (int)uVar5)))) {\n      iVar4 = -1;\n    }\n    else {\n      uVar1 = uVar1 * param_4 + uVar5;\n      iVar4 = 1;\n    }\n    uVar2 = (uint)*pbVar8;\n    pbVar8 = pbVar8 + 1;\n  } while( true );\n  if (iVar4 < 0) {\n    *param_1 = 0x22;\n    uVar1 = 0xffffffff;\n    if (param_3 == (byte **)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (bVar3 != 0) {\n      uVar1 = -uVar1;\n    }\n    if (param_3 == (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar4 == 0) goto LAB_00005fb8;\n  }\n  param_2 = pbVar8 + -1;\nLAB_00005fb8:\n  *param_3 = param_2;\n  return uVar1;\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "_strtoul_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005fd8": {
            "entrypoint": "0x00005fd8",
            "current_name": "parse_unsigned_number_00005fd8",
            "code": "\nulong parseUnsignedNumber_00005fd8(char *numberString,char **endPointer,int base)\n\n{\n  ulong result;\n  \n  result = _strtoul_l_isra_0(_impure_ptr,numberString,endPointer,base);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00005fd8": "parse_unsigned_number_00005fd8",
                "__nptr": "numberString",
                "__endptr": "endPointer",
                "__base": "base",
                "uVar1": "result"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "_strtoul_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005fec": {
            "entrypoint": "0x00005fec",
            "current_name": "acquire_recursive_lock_00005fec",
            "code": "\nvoid acquireRecursiveLock_00005fec(void)\n\n{\n  __retarget_lock_acquire_recursive(&lock_env_recursive_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005fec": "acquire_recursive_lock_00005fec",
                "__lock___env_recursive_mutex": "lock_env_recursive_mutex"
            },
            "calling": [
                "_findenv_r"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005ff8": {
            "entrypoint": "0x00005ff8",
            "current_name": "release_recursive_lock_00005ff8",
            "code": "\nvoid release_recursive_lock_00005ff8(void)\n\n{\n  __retarget_lock_release_recursive(&__lock___env_recursive_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005ff8": "release_recursive_lock_00005ff8"
            },
            "calling": [
                "_findenv_r"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006010": {
            "entrypoint": "0x00006010",
            "current_name": "search_byte_00006010",
            "code": "\nvoid * searchByte_00006010(void *source,int targetByte,size_t length)\n\n{\n  byte currentByte;\n  char currentByte1;\n  char currentByte2;\n  char currentByte3;\n  char currentByte4;\n  byte *ptr1;\n  uint *ptr2;\n  byte *ptr3;\n  uint maskedByte;\n  uint offset;\n  uint alignedLength;\n  uint xorVal1;\n  uint xorVal2;\n  bool bit1;\n  bool bit2;\n  bool bit3;\n  bool bit4;\n  \n  maskedByte = targetByte & 0xff;\n  if ((int)length < 0x10) {\njoined_r0x00006070:\n    do {\n      if (length == 0) {\n        return (void *)0x0;\n      }\n                    /* WARNING: Load size is inaccurate */\n      ptr2 = (uint *)((int)source + 1);\n      currentByte = *source;\n      length = length - 1;\n      source = ptr2;\n    } while (currentByte != maskedByte);\n  }\n  else {\n    offset = (uint)source & 7;\n    while( true ) {\n      if (offset == 0) {\n        offset = maskedByte | maskedByte << 8;\n        offset = offset | offset << 0x10;\n        alignedLength = length & 0xfffffff8;\n        do {\n          ptr2 = (uint *)((int)source + 8);\n                    /* WARNING: Load size is inaccurate */\n          alignedLength = alignedLength - 8;\n          xorVal1 = *source ^ offset;\n          xorVal2 = *(uint *)((int)source + 4) ^ offset;\n          currentByte1 = -((char)xorVal1 == '\\0');\n          currentByte2 = -((char)(xorVal1 >> 8) == '\\0');\n          currentByte3 = -((char)(xorVal1 >> 0x10) == '\\0');\n          currentByte4 = -((char)(xorVal1 >> 0x18) == '\\0');\n          xorVal1 = CONCAT13(currentByte4,CONCAT12(currentByte3,CONCAT11(currentByte2,currentByte1)));\n          bit1 = (char)xorVal2 != '\\0';\n          bit2 = (char)(xorVal2 >> 8) != '\\0';\n          bit3 = (char)(xorVal2 >> 0x10) != '\\0';\n          bit4 = (char)(xorVal2 >> 0x18) != '\\0';\n          xorVal2 = CONCAT13(bit4 * currentByte4 - !bit4,\n                            CONCAT12(bit3 * currentByte3 - !bit3,\n                                     CONCAT11(bit2 * currentByte2 - !bit2,bit1 * currentByte1 - !bit1)));\n          if (xorVal2 != 0) {\n            if (xorVal1 == 0) {\n              ptr3 = (byte *)((int)source + 5);\n              xorVal1 = xorVal2;\n            }\n            else {\n              ptr3 = (byte *)((int)source + 1);\n            }\n            if ((xorVal1 & 1) == 0) {\n              bit1 = (xorVal1 & 0x100) == 0;\n              ptr1 = ptr3 + 1;\n              if (bit1) {\n                bit1 = (xorVal1 & 0x18000) == 0;\n                ptr1 = ptr3 + 2;\n              }\n              ptr3 = ptr1;\n              if (bit1) {\n                ptr3 = ptr3 + 1;\n              }\n            }\n            return ptr3 + -1;\n          }\n          source = ptr2;\n        } while (alignedLength != 0);\n        length = length & 7;\n        goto joined_r0x00006070;\n      }\n                    /* WARNING: Load size is inaccurate */\n      ptr2 = (uint *)((int)source + 1);\n      length = length - 1;\n      if (*source == maskedByte) break;\n      offset = (uint)ptr2 & 7;\n      source = ptr2;\n      if (length == 0) {\n        return (void *)0x0;\n      }\n    }\n  }\n  return (byte *)((int)ptr2 + -1);\n}\n\n",
            "renaming": {
                "FUN_00006010": "search_byte_00006010",
                "__s": "source",
                "__c": "targetByte",
                "__n": "length",
                "bVar1": "currentByte",
                "cVar2": "currentByte1",
                "cVar3": "currentByte2",
                "cVar4": "currentByte3",
                "cVar5": "currentByte4",
                "pbVar6": "ptr1",
                "puVar7": "ptr2",
                "pbVar8": "ptr3",
                "uVar9": "maskedByte",
                "uVar10": "offset",
                "uVar11": "alignedLength",
                "uVar12": "xorVal1",
                "uVar13": "xorVal2",
                "bVar14": "bit1",
                "bVar15": "bit2",
                "bVar16": "bit3",
                "bVar17": "bit4"
            },
            "calling": [
                "_printf_i",
                "__ssvfiscanf_r",
                "_vfprintf_r",
                "_scanf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000060b0": {
            "entrypoint": "0x000060b0",
            "current_name": "copy_memory_000060b0",
            "code": "\nvoid * copy_memory_000060b0(void *destination,void *source,size_t length)\n\n{\n  undefined *src_ptr;\n  undefined *src_end;\n  undefined *dest_ptr;\n  \n  src_end = (undefined *)(length + (int)source);\n  dest_ptr = (undefined *)((int)destination + -1);\n  if ((undefined *)source != src_end) {\n    do {\n                    /* WARNING: Load size is inaccurate */\n      src_ptr = (undefined *)((int)source + 1);\n      dest_ptr = dest_ptr + 1;\n      *dest_ptr = *source;\n      source = src_ptr;\n    } while (src_ptr != src_end);\n    return destination;\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_000060b0": "copy_memory_000060b0",
                "__dest": "destination",
                "__src": "source",
                "__n": "length",
                "puVar1": "src_ptr",
                "puVar2": "src_end",
                "puVar3": "dest_ptr"
            },
            "calling": [
                "__submore",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000060cc": {
            "entrypoint": "0x000060cc",
            "current_name": "resize_and_copy_memory_000060cc",
            "code": "\nvoid * resizeAndCopyMemory_000060cc(undefined4 allocator,void *sourceBuffer,uint sourceSize,undefined4 otherParam)\n\n{\n  void *destinationBuffer;\n  uint usableSize;\n  \n  if (sourceBuffer != (void *)0x0) {\n    if (sourceSize == 0) {\n      _free_r();\n      destinationBuffer = (void *)0x0;\n    }\n    else {\n      usableSize = _malloc_usable_size_r();\n      destinationBuffer = sourceBuffer;\n      if ((usableSize < sourceSize) && (destinationBuffer = (void *)_malloc_r(allocator,sourceSize), destinationBuffer != (void *)0x0))\n      {\n        memcpy(destinationBuffer,sourceBuffer,sourceSize);\n        _free_r(allocator,sourceBuffer);\n      }\n    }\n    return destinationBuffer;\n  }\n  destinationBuffer = (void *)_malloc_r(allocator,sourceSize,sourceSize,otherParam);\n  return destinationBuffer;\n}\n\n",
            "renaming": {
                "FUN_000060cc": "resize_and_copy_memory_000060cc",
                "param_1": "allocator",
                "param_2": "sourceBuffer",
                "param_3": "sourceSize",
                "param_4": "otherParam",
                "pvVar1": "destinationBuffer",
                "uVar2": "usableSize"
            },
            "calling": [
                "__submore"
            ],
            "called": [
                "_malloc_r",
                "memcpy",
                "_malloc_usable_size_r",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006118": {
            "entrypoint": "0x00006118",
            "current_name": "update_value_00006118",
            "code": "\nuint updateValue_00006118(undefined4 status,uint value,uint *data,undefined4 config)\n\n{\n  int result;\n  uint currentValue;\n  uint originalValue;\n  \n  if (value == 0xffffffff) {\nLAB_00006120:\n    value = 0xffffffff;\n  }\n  else {\n    *(ushort *)(data + 3) = *(ushort *)(data + 3) & 0xffdf;\n    currentValue = data[1];\n    value = value & 0xff;\n    if (data[0xd] == 0) {\n      originalValue = *data;\n      if (((data[4] != 0) && (data[4] < originalValue)) && (*(byte *)(originalValue - 1) == value)) {\n        *data = originalValue - 1;\n        data[1] = currentValue + 1;\n        return value;\n      }\n      data[0xf] = originalValue;\n      data[0x10] = currentValue;\n      data[0xd] = (uint)(data + 0x11);\n      data[0xe] = 3;\n      *(undefined *)((int)data + 0x46) = (char)value;\n      *data = (uint)(undefined *)((int)data + 0x46);\n      currentValue = 1;\n    }\n    else {\n      if (((int)data[0xe] <= (int)currentValue) &&\n         (result = __submore(status,data,currentValue,data[0xe],config), result != 0))\n      goto LAB_00006120;\n      currentValue = *data;\n      *data = currentValue - 1;\n      *(char *)(currentValue - 1) = (char)value;\n      currentValue = data[1] + 1;\n    }\n    data[1] = currentValue;\n  }\n  return value;\n}\n\n",
            "renaming": {
                "FUN_00006118": "update_value_00006118",
                "param_1": "status",
                "param_2": "value",
                "param_3": "data",
                "param_4": "config",
                "iVar1": "result",
                "uVar2": "currentValue",
                "uVar3": "originalValue"
            },
            "calling": [],
            "called": [
                "__submore"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006192": {
            "entrypoint": "0x00006192",
            "current_name": "cleanup_and_set_flags_00006192",
            "code": "\nundefined4 cleanupAndSetFlags_00006192(undefined4 result,undefined4 *data)\n\n{\n  if ((undefined4 *)data[13] != (undefined4 *)0x0) {\n    if ((undefined4 *)data[13] != data + 0x11) {\n      _free_r();\n    }\n    data[1] = data[16];\n    data[13] = 0;\n    if (data[16] != 0) {\n      *data = data[15];\n      return 0;\n    }\n  }\n  *data = data[4];\n  data[1] = 0;\n  *(ushort *)(data + 3) = *(ushort *)(data + 3) | 0x20;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00006192": "cleanup_and_set_flags_00006192",
                "param_1": "result",
                "param_2": "data",
                "param_2[0xd]": "data[13]",
                "param_2[1]": "data[1]",
                "param_2[0x10]": "data[16]",
                "param_2[0xf]": "data[15]",
                "param_2[4]": "data[4]"
            },
            "calling": [
                "__ssvfiscanf_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000061cc": {
            "entrypoint": "0x000061cc",
            "current_name": "parse_and_process_input_000061cc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006482) */\n\nint parse_and_process_input_000061cc(undefined4 param_1,byte **param_2,byte *param_3,int **param_4)\n\n{\n  int result;\n  void *ptr;\n  uint current_char;\n  byte *next_char;\n  uint char_category;\n  int **output_param;\n  undefined local_buffer [256];\n  uint field_flags;\n  undefined4 base_value;\n  uint temp_flags;\n  int return_value;\n  int char_count;\n  undefined *buffer_ptr;\n  int scan_fn_selector;\n  undefined4 magic_value;\n  code *read_function;\n  \n  return_value = 0;\n  char_count = 0;\n  magic_value = 0x6119;\n  read_function = __ssrefill_r + 1;\n  output_param = param_4;\n  buffer_ptr = local_buffer;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      char_category = (uint)*param_3;\n      if (char_category == 0) {\n        return return_value;\n      }\n      current_char = (byte)(&DAT_00007a99)[char_category] & 8;\n      next_char = param_3 + 1;\n      if (((&DAT_00007a99)[char_category] & 8) == 0) break;\n      while (((param_3 = next_char, 0 < (int)param_2[1] ||\n              (result = (*read_function)(param_1,param_2), result == 0)) &&\n             ((int)((uint)(byte)(&DAT_00007a99)[**param_2] << 0x1c) < 0))) {\n        char_count = char_count + 1;\n        param_2[1] = param_2[1] + -1;\n        *param_2 = *param_2 + 1;\n      }\n    }\n    if (char_category == 0x25) break;\nLAB_00006352:\n    if (((int)param_2[1] < 1) && (result = (*read_function)(param_1,param_2), result != 0))\n    goto LAB_00006380;\n    if (**param_2 != char_category) {\n      return return_value;\n    }\n    *param_2 = *param_2 + 1;\n    char_count = char_count + 1;\n    param_2[1] = param_2[1] + -1;\n    param_3 = next_char;\n  }\n  temp_flags = current_char;\n  field_flags = current_char;\n  if (param_3[1] == 0x2a) {\n    next_char = param_3 + 2;\n    field_flags = 0x10;\n  }\n  while( true ) {\n    current_char = (uint)*next_char;\n    if (9 < current_char - 0x30) break;\n    next_char = next_char + 1;\n    temp_flags = (temp_flags * 10 + current_char) - 0x30;\n  }\n  ptr = memchr(&DAT_00007c02,current_char,3);\n  if (ptr != (void *)0x0) {\n    field_flags = 1 << ((int)ptr - 0x7c02U & 0xff) | field_flags;\n    next_char = next_char + 1;\n  }\n  param_3 = next_char + 1;\n  current_char = (uint)*next_char;\n  if (current_char < 0x79) {\n    if (0x57 < current_char) {\n      switch(current_char) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        param_3 = (byte *)__sccl(local_buffer,param_3);\n        field_flags = field_flags | 0x40;\n        scan_fn_selector = 1;\n        break;\n      case 99:\n        field_flags = field_flags | 0x40;\n        scan_fn_selector = 0;\n        break;\n      case 100:\n      case 0x75:\n        base_value = 10;\nLAB_000063a0:\n        if (current_char < 0x6f) {\n          scan_fn_selector = 3;\n        }\n        else {\n          scan_fn_selector = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        scan_fn_selector = 5;\n        break;\n      case 0x69:\n        base_value = 0;\n        scan_fn_selector = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(field_flags << 0x1b)) {\n          if ((int)(field_flags << 0x1f) < 0) {\n            *(short *)*output_param = (short)char_count;\n            output_param = output_param + 1;\n          }\n          else {\n            **output_param = char_count;\n            output_param = output_param + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        base_value = 8;\n        scan_fn_selector = 4;\n        break;\n      case 0x70:\n        field_flags = field_flags | 0x20;\n      case 0x58:\n      case 0x78:\n        field_flags = field_flags | 0x200;\n        base_value = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        scan_fn_selector = 2;\n      }\nLAB_000063ac:\n      if (((int)param_2[1] < 1) && (result = (*read_function)(param_1,param_2), result != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(field_flags << 0x19)) {\n        while ((int)((uint)(byte)(&DAT_00007a99)[**param_2] << 0x1c) < 0) {\n          char_count = char_count + 1;\n          next_char = param_2[1];\n          param_2[1] = next_char + -1;\n          if ((int)(next_char + -1) < 1) {\n            result = (*read_function)(param_1,param_2);\n            if (result != 0) goto LAB_00006380;\n          }\n          else {\n            *param_2 = *param_2 + 1;\n          }\n        }\n      }\n      if (scan_fn_selector < 3) {\n        result = _scanf_chars(param_1,&field_flags,param_2,&output_param);\n      }\n      else {\n        if (4 < scan_fn_selector) goto LAB_000061f6;\n        result = _scanf_i(param_1,&field_flags,param_2,&output_param);\n      }\n      if (result == 1) {\n        return return_value;\n      }\n      if (result == 2) {\nLAB_00006380:\n        if (return_value == 0) {\nLAB_00006388:\n          return_value = -1;\n        }\n        else if ((*(ushort *)(param_2 + 3) & 0x40) != 0) {\n          return_value = -1;\n        }\n        return return_value;\n      }\n      goto LAB_000061f6;\n    }\n    next_char = param_3;\n    if (current_char == 0x25) goto LAB_00006352;\n    if (current_char < 0x26) {\n      if (current_char != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (current_char - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  scan_fn_selector = 3;\n  base_value = 10;\n  goto LAB_000063ac;\n}\n\n",
            "renaming": {
                "FUN_000061cc": "parse_and_process_input_000061cc",
                "iVar1": "result",
                "pvVar2": "ptr",
                "uVar3": "current_char",
                "pbVar4": "next_char",
                "uVar5": "char_category",
                "local_2b0": "output_param",
                "auStack_2ac": "local_buffer",
                "local_1ac": "field_flags",
                "local_1a8": "base_value",
                "local_1a4": "temp_flags",
                "local_1a0": "return_value",
                "local_19c": "char_count",
                "local_198": "buffer_ptr",
                "local_194": "scan_fn_selector",
                "local_30": "magic_value",
                "local_2c": "read_function"
            },
            "calling": [
                "siscanf"
            ],
            "called": [
                "__sccl",
                "__ssrefill_r",
                "_scanf_chars",
                "_scanf_i",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000064bc": {
            "entrypoint": "0x000064bc",
            "current_name": "process_data_000064bc",
            "code": "\nundefined4 process_data_000064bc(undefined4 input_param,uint *data_array,byte **byte_array,undefined4 *output_param)\n\n{\n  int result;\n  uint counter;\n  byte **byte_ptr_ptr;\n  byte *byte_ptr;\n  byte *current_byte;\n  byte *next_byte;\n  int loop_counter;\n  \n  if (data_array[2] == 0) {\n    if (data_array[6] == 0) {\n      counter = 1;\n    }\n    else {\n      counter = 0xffffffff;\n    }\n    data_array[2] = counter;\n  }\n  if (-1 < (int)(*data_array << 0x1b)) {\n    byte_ptr_ptr = (byte **)*output_param;\n    *output_param = byte_ptr_ptr + 1;\n    current_byte = *byte_ptr_ptr;\n  }\n  loop_counter = 0;\n  do {\n    counter = data_array[6];\n    if (counter != 0) {\n      if (counter == 1) {\n        if (*(char *)(data_array[5] + (uint)**byte_array) == '\\0') {\n          if (loop_counter == 0) {\n            return 1;\n          }\nLAB_0000654a:\n          if (((*data_array & 0x10) == 0) && (data_array[3] = data_array[3] + 1, data_array[6] != 0)) {\n            *current_byte = 0;\n          }\n          data_array[4] = loop_counter + data_array[4];\n          return 0;\n        }\n      }\n      else if ((counter != 2) || ((int)((uint)(byte)(&DAT_00007a99)[**byte_array] << 0x1c) < 0))\n      goto LAB_0000654a;\n    }\n    next_byte = current_byte;\n    if (-1 < (int)(*data_array << 0x1b)) {\n      next_byte = current_byte + 1;\n      *current_byte = **byte_array;\n    }\n    byte_ptr = byte_array[1];\n    *byte_array = *byte_array + 1;\n    counter = data_array[2] - 1;\n    byte_array[1] = byte_ptr + -1;\n    loop_counter = loop_counter + 1;\n    data_array[2] = counter;\n    current_byte = next_byte;\n    if ((counter == 0) ||\n       (((int)(byte_ptr + -1) < 1 &&\n        (result = (*(code *)data_array[0x60])(input_param,byte_array,counter,(code *)data_array[0x60],output_param),\n        result != 0)))) goto LAB_0000654a;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000064bc": "process_data_000064bc",
                "param_1": "input_param",
                "param_2": "data_array",
                "param_3": "byte_array",
                "param_4": "output_param",
                "iVar1": "result",
                "uVar2": "counter",
                "ppbVar3": "byte_ptr_ptr",
                "pbVar4": "byte_ptr",
                "unaff_r6": "current_byte",
                "pbVar5": "next_byte",
                "iVar6": "loop_counter"
            },
            "calling": [
                "__ssvfiscanf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000656c": {
            "entrypoint": "0x0000656c",
            "current_name": "parse_input_0000656c",
            "code": "\nundefined4 parseInput_0000656c(undefined4 status,uint *flags,byte **input,undefined4 *output)\n\n{\n  code *strToNumFunc;\n  void *foundChar;\n  int result;\n  undefined4 parsedValue;\n  uint maxChars;\n  byte *currentChar;\n  uint inputLength;\n  undefined4 *outputPtr;\n  uint *newOutputPtr;\n  uint *nextOutputPtr;\n  uint *flagsPtr;\n  int overflowCount;\n  int index;\n  undefined *local_34 [4];\n  \n  characterSet1 = &DAT_00007c2f;\n  characterSet2 = &DAT_00007c32;\n  characterSet3 = &DAT_00007c35;\n  strToNumFunc = _strtol_r;\n  if (flags[6] != 3) {\n    strToNumFunc = _strtoul_r;\n  }\n  inputLength = flags[2];\n  maxChars = inputLength - 1;\n  if (0x15c < maxChars) {\n    overflowCount = inputLength - 0x15d;\n    inputLength = 0x15d;\n  }\n  if (0x15c < maxChars) {\n    flags[2] = inputLength;\n  }\n  flagsPtr = flags + 7;\n  if (maxChars < 0x15d) {\n    overflowCount = 0;\n  }\n  *flags = *flags | 0xd00;\n  index = 0;\n  nextOutputPtr = flagsPtr;\n  do {\n    foundChar = memchr(local_34[index],(uint)**input,2);\n    if (foundChar != (void *)0x0) {\n      if (index == 1) {\n        if (flags[1] == 0) {\n          flags[1] = 8;\n          *flags = *flags | 0x200;\n        }\n        maxChars = *flags & 0xfffffaff;\nLAB_000065f4:\n        *flags = maxChars;\n      }\n      else if (index == 2) {\n        if ((*flags & 0x600) != 0x200) goto LAB_00006624;\n        flags[1] = 0x10;\n        maxChars = *flags | 0x100;\n        goto LAB_000065f4;\n      }\n      maxChars = flags[2];\n      flags[2] = maxChars - 1;\n      if (maxChars != 0) {\n        currentChar = *input;\n        *input = currentChar + 1;\n        newOutputPtr = (uint *)((int)nextOutputPtr + 1);\n        *(byte *)nextOutputPtr = *currentChar;\n        currentChar = input[1];\n        input[1] = currentChar + -1;\n        nextOutputPtr = newOutputPtr;\n        if (((int)(currentChar + -1) < 1) &&\n           (result = (*(code *)flags[0x60])(status,input), result != 0)) {\n          index = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    index = index + 1;\n  } while (index != 3);\n  if (flags[1] == 0) {\n    flags[1] = 10;\n  }\n  __sccl(flags[5],\"01234567]\" + (8 - flags[1]));\n  index = 0;\n  while( true ) {\n    newOutputPtr = nextOutputPtr;\n    if (flags[2] == 0) break;\n    currentChar = *input;\n    maxChars = (uint)*currentChar;\n    if (*(char *)(flags[5] + maxChars) == '\\0') break;\n    if ((maxChars == 0x30) && ((int)(*flags << 0x14) < 0)) {\n      index = index + 1;\n      if (overflowCount != 0) {\n        overflowCount = overflowCount + -1;\n        flags[2] = flags[2] + 1;\n      }\n    }\n    else {\n      *flags = *flags & 0xfffff6ff;\n      newOutputPtr = (uint *)((int)nextOutputPtr + 1);\n      *(byte *)nextOutputPtr = *currentChar;\n    }\n    currentChar = input[1];\n    input[1] = currentChar + -1;\n    if ((int)(currentChar + -1) < 1) {\n      result = (*(code *)flags[0x60])(status,input);\n      if (result != 0) break;\n    }\n    else {\n      *input = *input + 1;\n    }\n    flags[2] = flags[2] - 1;\n    nextOutputPtr = newOutputPtr;\n  }\nLAB_000066ca:\n  if ((int)(*flags << 0x17) < 0) {\n    if (flagsPtr < newOutputPtr) {\n      (*(code *)flags[0x5f])(status,*(byte *)((int)newOutputPtr + -1),input);\n      newOutputPtr = (uint *)((int)newOutputPtr + -1);\n    }\n    if (newOutputPtr == flagsPtr) {\n      return 1;\n    }\n  }\n  if ((*flags & 0x10) == 0) {\n    *(byte *)newOutputPtr = 0;\n    parsedValue = (*(strToNumFunc + 1))(status,flagsPtr,0,flags[1]);\n    outputPtr = (undefined4 *)*output;\n    maxChars = *flags;\n    *output = outputPtr + 1;\n    outputPtr = (undefined4 *)*outputPtr;\n    if ((maxChars & 0x20) == 0) {\n      if ((int)(maxChars << 0x1f) < 0) {\n        *(short *)outputPtr = (short)parsedValue;\n      }\n      else {\n        *outputPtr = parsedValue;\n      }\n    }\n    else {\n      *outputPtr = parsedValue;\n    }\n    flags[3] = flags[3] + 1;\n  }\n  flags[4] = (uint)((int)newOutputPtr + flags[4] + (index - (int)flagsPtr));\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000656c": "parse_input_0000656c",
                "param_1": "status",
                "param_2": "flags",
                "param_3": "input",
                "param_4": "output",
                "pcVar1": "strToNumFunc",
                "pvVar2": "foundChar",
                "iVar3": "result",
                "uVar4": "parsedValue",
                "uVar5": "maxChars",
                "pbVar6": "currentChar",
                "uVar7": "inputLength",
                "puVar8": "outputPtr",
                "puVar9": "newOutputPtr",
                "puVar10": "nextOutputPtr",
                "puVar11": "flagsPtr",
                "unaff_r9": "overflowCount",
                "iVar12": "index",
                "local_34[0]": "characterSet1",
                "local_34[1]": "characterSet2",
                "local_34[2]": "characterSet3"
            },
            "calling": [
                "__ssvfiscanf_r"
            ],
            "called": [
                "__sccl",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006754": {
            "entrypoint": "0x00006754",
            "current_name": "flush_file_00006754",
            "code": "\nint flushFile_00006754(FILE *filePointer)\n\n{\n  int result;\n  \n  if ((*(ushort *)&filePointer->_IO_read_base & 9) == 9) {\n    result = fflush(filePointer);\n    return result;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00006754": "flush_file_00006754",
                "param_1": "filePointer",
                "iVar1": "result"
            },
            "calling": [],
            "called": [
                "fflush"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006768": {
            "entrypoint": "0x00006768",
            "current_name": "process_file_00006768",
            "code": "\nundefined4\nprocessFile_00006768(undefined4 *fileData,undefined4 *stream,undefined4 flags,undefined4 size)\n\n{\n  undefined2 tempVar1;\n  int tempVar2;\n  undefined4 result;\n  ushort flagsValue;\n  uint shiftValue;\n  \n  if ((fileData != (undefined4 *)0x0) && (fileData[6] == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = (undefined4 *)fileData[1];\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stdout) {\n    stream = (undefined4 *)fileData[2];\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stderr) {\n    stream = (undefined4 *)fileData[3];\n  }\n  flagsValue = *(ushort *)(stream + 3);\n  stream[1] = 0;\n  shiftValue = (uint)*(ushort *)(stream + 3);\n  if ((int)(shiftValue << 0x1a) < 0) {\n    return 0xffffffff;\n  }\n  if ((int)(shiftValue << 0x1d) < 0) {\n    if ((undefined4 *)stream[0xd] != (undefined4 *)0x0) {\n      if ((undefined4 *)stream[0xd] != stream + 0x11) {\n        _free_r(fileData);\n      }\n      stream[1] = stream[0x10];\n      stream[0xd] = 0;\n      if (stream[0x10] != 0) {\n        *stream = stream[0xf];\n        return 0;\n      }\n    }\n  }\n  else {\n    if (-1 < (int)(shiftValue << 0x1b)) {\n      *fileData = 9;\n      flagsValue = flagsValue | 0x40;\n      goto LAB_000067b8;\n    }\n    if ((int)(shiftValue << 0x1c) < 0) {\n      tempVar2 = _fflush_r(fileData,stream,shiftValue << 0x1c,shiftValue,size);\n      if (tempVar2 != 0) {\n        return 0xffffffff;\n      }\n      stream[2] = 0;\n      *(ushort *)(stream + 3) = *(ushort *)(stream + 3) & 0xfff7;\n      stream[6] = 0;\n    }\n    *(ushort *)(stream + 3) = *(ushort *)(stream + 3) | 4;\n  }\n  if (stream[4] == 0) {\n    __smakebuf_r(fileData,stream);\n  }\n  flagsValue = *(ushort *)(stream + 3);\n  tempVar1 = *(undefined2 *)(stream + 3);\n  if ((flagsValue & 3) != 0) {\n    *(undefined2 *)(stream + 3) = 1;\n    _fwalk(&impure_data,0x6755);\n    *(undefined2 *)(stream + 3) = tempVar1;\n    if ((flagsValue & 9) == 9) {\n      __sflush_r(fileData,stream);\n    }\n  }\n  result = stream[4];\n  *stream = result;\n  tempVar2 = (*(code *)stream[9])(fileData,stream[8],result,stream[5]);\n  stream[1] = tempVar2;\n  if (0 < tempVar2) {\n    return 0;\n  }\n  flagsValue = *(ushort *)(stream + 3);\n  if (tempVar2 != 0) {\n    result = 0;\n  }\n  else {\n    flagsValue = flagsValue | 0x20;\n  }\n  if (tempVar2 != 0) {\n    stream[1] = result;\n    flagsValue = flagsValue | 0x40;\n  }\nLAB_000067b8:\n  *(ushort *)(stream + 3) = flagsValue;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00006768": "process_file_00006768",
                "param_1": "fileData",
                "param_2": "stream",
                "param_3": "flags",
                "param_4": "size",
                "uVar1": "tempVar1",
                "iVar2": "tempVar2",
                "uVar3": "result",
                "uVar4": "flagsValue",
                "uVar5": "shiftValue"
            },
            "calling": [
                "__srget_r"
            ],
            "called": [
                "_fflush_r",
                "__sinit",
                "__smakebuf_r",
                "_fwalk",
                "__sflush_r",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000687c": {
            "entrypoint": "0x0000687c",
            "current_name": "convert_binary_to_bool_array_0000687c",
            "code": "\nbyte * convertBinaryToBoolArray_0000687c(int arraySize,byte *binaryData)\n\n{\n  byte *result;\n  uint tempVarTwo;\n  int tempVarThree;\n  uint tempVarFour;\n  uint tempVarFive;\n  uint tempVarSix;\n  bool isFirstByteEqual;\n  \n  tempVarFour = (uint)*binaryData;\n  isFirstByteEqual = tempVarFour == 0x5e;\n  if (isFirstByteEqual) {\n    tempVarFour = (uint)binaryData[1];\n    binaryData = binaryData + 2;\n  }\n  else {\n    binaryData = binaryData + 1;\n  }\n  tempVarThree = arraySize + -1;\n  do {\n    tempVarThree = tempVarThree + 1;\n    *(bool *)tempVarThree = isFirstByteEqual;\n  } while (tempVarThree != arraySize + 0xff);\n  if (tempVarFour == 0) {\n    result = binaryData + -1;\n  }\n  else {\nLAB_000068aa:\n    do {\n      tempVarFive = tempVarFour;\n      *(bool *)(arraySize + tempVarFive) = !isFirstByteEqual;\n      binaryData = binaryData + 1;\n      while( true ) {\n        tempVarFour = (uint)binaryData[-1];\n        if (tempVarFour != 0x2d) break;\n        tempVarSix = (uint)*binaryData;\n        if ((tempVarSix == 0x5d) || (tempVarTwo = tempVarFive, (int)tempVarSix < (int)tempVarFive)) goto LAB_000068aa;\n        do {\n          tempVarTwo = tempVarTwo + 1;\n          *(bool *)(arraySize + tempVarTwo) = !isFirstByteEqual;\n        } while ((int)tempVarTwo < (int)tempVarSix);\n        tempVarThree = ~tempVarFive + tempVarSix;\n        if ((int)tempVarSix <= (int)tempVarFive) {\n          tempVarThree = 0;\n        }\n        tempVarFive = tempVarFive + 1 + tempVarThree;\n        binaryData = binaryData + 2;\n      }\n      result = binaryData;\n    } while ((tempVarFour != 0x5d) && (result = binaryData + -1, tempVarFour != 0));\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0000687c": "convert_binary_to_bool_array_0000687c",
                "param_1": "arraySize",
                "param_2": "binaryData",
                "pbVar1": "result",
                "uVar2": "tempVarTwo",
                "iVar3": "tempVarThree",
                "uVar4": "tempVarFour",
                "uVar5": "tempVarFive",
                "uVar6": "tempVarSix",
                "bVar7": "isFirstByteEqual"
            },
            "calling": [
                "__ssvfiscanf_r",
                "_scanf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000068f0": {
            "entrypoint": "0x000068f0",
            "current_name": "initialize_flash_config_000068f0",
            "code": "\nundefined4 initializeFlashConfig_000068f0(undefined4 param1,void **param2)\n\n{\n  void *memoryBlock;\n  void *configFieldSize;\n  \n  if ((void **)param2[0xd] == param2 + 0x11) {\n    memoryBlock = (void *)_malloc_r(param1,0x400);\n    if (memoryBlock != (void *)0x0) {\n      param2[0xe] = flash_configuration_field;\n      param2[0xd] = memoryBlock;\n      *(undefined *)((int)memoryBlock + 0x3ff) = *(undefined *)((int)param2 + 0x46);\n      *(undefined *)((int)memoryBlock + 0x3fe) = *(undefined *)((int)param2 + 0x45);\n      *(undefined *)((int)memoryBlock + 0x3fd) = *(undefined *)(param2 + 0x11);\n      *param2 = (void *)((int)memoryBlock + 0x3fd);\n      return 0;\n    }\n  }\n  else {\n    configFieldSize = param2[0xe];\n    memoryBlock = (void *)_realloc_r(param1,param2[0xd],(void *)((int)configFieldSize << 1));\n    if (memoryBlock != (void *)0x0) {\n      memcpy((void *)((int)memoryBlock + (int)configFieldSize),memoryBlock,(size_t)configFieldSize);\n      param2[0xd] = memoryBlock;\n      param2[0xe] = (void *)((int)configFieldSize << 1);\n      *param2 = (void *)((int)memoryBlock + (int)configFieldSize);\n      return 0;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_000068f0": "initialize_flash_config_000068f0",
                "param_1": "param1",
                "param_2": "param2",
                "pvVar1": "memoryBlock",
                "__n": "configFieldSize"
            },
            "calling": [
                "_sungetc_r"
            ],
            "called": [
                "_malloc_r",
                "memcpy",
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006964": {
            "entrypoint": "0x00006964",
            "current_name": "calculate_sum_00006964",
            "code": "\nint calculateSum_00006964(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = *(int *)(param_2 + -4) + -4;\n  if (*(int *)(param_2 + -4) < 0) {\n    iVar1 = iVar1 + *(int *)(param_2 + iVar1);\n  }\n  return iVar1;\n}\n\n",
            "renaming": {
                "FUN_00006964": "calculate_sum_00006964"
            },
            "calling": [
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006974": {
            "entrypoint": "0x00006974",
            "current_name": "divide_and_modulo_00006974",
            "code": "\nint divideAndModulo_00006974(int dividend,int divisor,int secondDividend,int secondDivisor)\n\n{\n  int result;\n  undefined temp [8];\n  \n  if ((secondDivisor == 0) && (secondDividend == 0)) {\n    if (divisor < 0) {\n      dividend = 0;\n      divisor = -0x80000000;\n    }\n    else if (divisor != 0 || dividend != 0) {\n      divisor = 0x7fffffff;\n      dividend = -1;\n    }\n    result = __aeabi_idiv0(dividend,divisor);\n    return result;\n  }\n  if (divisor < 0) {\n    result = -divisor - (uint)(dividend != 0);\n    if (secondDivisor < 0) {\n      result = __udivmoddi4(-dividend,result,-secondDividend,-secondDivisor - (uint)(secondDividend != 0),temp);\n      return result;\n    }\n    result = __udivmoddi4(-dividend,result,secondDividend,secondDivisor,temp);\n    return -result;\n  }\n  if (secondDivisor < 0) {\n    result = __udivmoddi4(dividend,divisor,-secondDividend,-secondDivisor - (uint)(secondDividend != 0),temp);\n    return -result;\n  }\n  result = __udivmoddi4();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00006974": "divide_and_modulo_00006974",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "secondDividend",
                "param_4": "secondDivisor",
                "iVar1": "result",
                "local_8": "temp"
            },
            "calling": [
                "gmtime_r"
            ],
            "called": [
                "__aeabi_idiv0",
                "__udivmoddi4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006a14": {
            "entrypoint": "0x00006a14",
            "current_name": "div_with_remainder_00006a14",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong divWithRemainder_00006a14(uint dividend,uint quotient_1,uint divisor,uint quotient_2,uint *remainder)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  uint temp_1;\n  int shift_amount;\n  uint temp_2;\n  uint divisor_bits;\n  uint temp_3;\n  uint temp_4;\n  uint temp_5;\n  uint temp_6;\n  uint temp_7;\n  bool carry_flag;\n  ulonglong result;\n  \n  if (quotient_2 == 0) {\n    if (quotient_1 < divisor) {\n      shift_amount = LZCOUNT(divisor);\n      temp_3 = divisor;\n      if (shift_amount != 0) {\n        temp_3 = divisor << shift_amount;\n        quotient_1 = dividend >> (0x20U - shift_amount & 0xff) | quotient_1 << shift_amount;\n        dividend = dividend << shift_amount;\n      }\n      temp_4 = temp_3 >> 0x10;\n      temp_6 = quotient_1 / temp_4;\n      temp_2 = dividend >> 0x10 | (quotient_1 - temp_4 * temp_6) * 0x10000;\n      temp_1 = temp_6 * (temp_3 & 0xffff);\n      divisor_bits = temp_6;\n      if (temp_2 <= temp_1 && temp_1 - temp_2 != 0) {\n        carry_flag = CARRY4(temp_3,temp_2);\n        temp_2 = temp_3 + temp_2;\n        divisor_bits = temp_6 - 1;\n        if ((carry_flag == false) && (temp_2 <= temp_1 && temp_1 - temp_2 != 0)) {\n          divisor_bits = temp_6 - 2;\n          temp_2 = temp_2 + temp_3;\n        }\n      }\n      temp_6 = (temp_2 - temp_1) / temp_4;\n      temp_4 = dividend & 0xffff | ((temp_2 - temp_1) - temp_4 * temp_6) * 0x10000;\n      temp_2 = temp_6 * (temp_3 & 0xffff);\n      temp_1 = temp_6;\n      if (temp_4 <= temp_2 && temp_2 - temp_4 != 0) {\n        carry_flag = CARRY4(temp_3,temp_4);\n        temp_4 = temp_3 + temp_4;\n        temp_1 = temp_6 - 1;\n        if ((carry_flag == false) && (temp_4 <= temp_2 && temp_2 - temp_4 != 0)) {\n          temp_1 = temp_6 - 2;\n          temp_4 = temp_4 + temp_3;\n        }\n      }\n      temp_4 = temp_4 - temp_2;\n      temp_1 = temp_1 | divisor_bits << 0x10;\n      temp_3 = 0;\n    }\n    else {\n      if (divisor == 0) {\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x6abc);\n        result = (*UNRECOVERED_JUMPTABLE)();\n        return result;\n      }\n      shift_amount = LZCOUNT(divisor);\n      if (shift_amount == 0) {\n        quotient_1 = quotient_1 - divisor;\n        temp_7 = divisor >> 0x10;\n        temp_5 = divisor & 0xffff;\n        temp_3 = 1;\n        divisor_bits = divisor;\n      }\n      else {\n        divisor_bits = divisor << shift_amount;\n        temp_7 = divisor_bits >> 0x10;\n        temp_1 = quotient_1 >> (0x20U - shift_amount & 0xff);\n        temp_3 = dividend >> (0x20U - shift_amount & 0xff) | quotient_1 << shift_amount;\n        temp_2 = temp_1 / temp_7;\n        temp_5 = divisor_bits & 0xffff;\n        temp_6 = temp_3 >> 0x10 | (temp_1 - temp_7 * temp_2) * 0x10000;\n        temp_4 = temp_2 * temp_5;\n        dividend = dividend << shift_amount;\n        temp_1 = temp_2;\n        if (temp_6 <= temp_4 && temp_4 - temp_6 != 0) {\n          carry_flag = CARRY4(divisor_bits,temp_6);\n          temp_6 = divisor_bits + temp_6;\n          temp_1 = temp_2 - 1;\n          if ((carry_flag == false) && (temp_6 <= temp_4 && temp_4 - temp_6 != 0)) {\n            temp_1 = temp_2 - 2;\n            temp_6 = temp_6 + divisor_bits;\n          }\n        }\n        temp_2 = (temp_6 - temp_4) / temp_7;\n        quotient_1 = temp_3 & 0xffff | ((temp_6 - temp_4) - temp_7 * temp_2) * 0x10000;\n        temp_4 = temp_2 * temp_5;\n        temp_3 = temp_2;\n        if (quotient_1 <= temp_4 && temp_4 - quotient_1 != 0) {\n          carry_flag = CARRY4(divisor_bits,quotient_1);\n          quotient_1 = divisor_bits + quotient_1;\n          temp_3 = temp_2 - 1;\n          if ((carry_flag == false) && (quotient_1 <= temp_4 && temp_4 - quotient_1 != 0)) {\n            temp_3 = temp_2 - 2;\n            quotient_1 = quotient_1 + divisor_bits;\n          }\n        }\n        quotient_1 = quotient_1 - temp_4;\n        temp_3 = temp_3 | temp_1 << 0x10;\n      }\n      temp_6 = quotient_1 / temp_7;\n      temp_4 = dividend >> 0x10 | (quotient_1 - temp_7 * temp_6) * 0x10000;\n      temp_1 = temp_5 * temp_6;\n      temp_2 = temp_6;\n      if (temp_4 <= temp_1 && temp_1 - temp_4 != 0) {\n        carry_flag = CARRY4(divisor_bits,temp_4);\n        temp_4 = divisor_bits + temp_4;\n        temp_2 = temp_6 - 1;\n        if ((carry_flag == false) && (temp_4 <= temp_1 && temp_1 - temp_4 != 0)) {\n          temp_2 = temp_6 - 2;\n          temp_4 = temp_4 + divisor_bits;\n        }\n      }\n      temp_6 = (temp_4 - temp_1) / temp_7;\n      temp_4 = dividend & 0xffff | ((temp_4 - temp_1) - temp_7 * temp_6) * 0x10000;\n      temp_5 = temp_5 * temp_6;\n      temp_1 = temp_6;\n      if (temp_4 <= temp_5 && temp_5 - temp_4 != 0) {\n        carry_flag = CARRY4(divisor_bits,temp_4);\n        temp_4 = divisor_bits + temp_4;\n        temp_1 = temp_6 - 1;\n        if ((carry_flag == false) && (temp_4 <= temp_5 && temp_5 - temp_4 != 0)) {\n          temp_1 = temp_6 - 2;\n          temp_4 = temp_4 + divisor_bits;\n        }\n      }\n      temp_4 = temp_4 - temp_5;\n      temp_1 = temp_1 | temp_2 << 0x10;\n    }\n    if (remainder != (uint *)0x0) {\n      *remainder = temp_4 >> LZCOUNT(divisor);\n      remainder[1] = 0;\n    }\n  }\n  else if (quotient_1 < quotient_2) {\n    if (remainder != (uint *)0x0) {\n      *remainder = dividend;\n      remainder[1] = quotient_1;\n      return 0;\n    }\n    temp_1 = 0;\n    temp_3 = 0;\n  }\n  else {\n    shift_amount = LZCOUNT(quotient_2);\n    if (shift_amount != 0) {\n      temp_5 = 0x20 - shift_amount;\n      temp_2 = divisor >> (temp_5 & 0xff) | quotient_2 << shift_amount;\n      temp_7 = temp_2 >> 0x10;\n      temp_1 = quotient_1 >> (temp_5 & 0xff);\n      temp_3 = dividend >> (temp_5 & 0xff) | quotient_1 << shift_amount;\n      temp_4 = temp_1 / temp_7;\n      divisor_bits = temp_3 >> 0x10 | (temp_1 - temp_7 * temp_4) * 0x10000;\n      temp_6 = temp_4 * (temp_2 & 0xffff);\n      dividend = dividend << shift_amount;\n      temp_1 = temp_4;\n      if (divisor_bits <= temp_6 && temp_6 - divisor_bits != 0) {\n        carry_flag = CARRY4(temp_2,divisor_bits);\n        divisor_bits = temp_2 + divisor_bits;\n        temp_1 = temp_4 - 1;\n        if ((carry_flag == false) && (divisor_bits <= temp_6 && temp_6 - divisor_bits != 0)) {\n          temp_1 = temp_4 - 2;\n          divisor_bits = divisor_bits + temp_2;\n        }\n      }\n      temp_4 = (divisor_bits - temp_6) / temp_7;\n      divisor_bits = temp_3 & 0xffff | ((divisor_bits - temp_6) - temp_7 * temp_4) * 0x10000;\n      temp_6 = temp_4 * (temp_2 & 0xffff);\n      temp_3 = temp_4;\n      if (divisor_bits <= temp_6 && temp_6 - divisor_bits != 0) {\n        carry_flag = CARRY4(temp_2,divisor_bits);\n        divisor_bits = temp_2 + divisor_bits;\n        temp_3 = temp_4 - 1;\n        if ((carry_flag == false) && (divisor_bits <= temp_6 && temp_6 - divisor_bits != 0)) {\n          temp_3 = temp_4 - 2;\n          divisor_bits = divisor_bits + temp_2;\n        }\n      }\n      temp_3 = temp_3 | temp_1 << 0x10;\n      result = (ulonglong)temp_3 * (ulonglong)(divisor << shift_amount);\n      if (CONCAT44(divisor_bits - temp_6,dividend) < result) {\n        result = result - CONCAT44(temp_2,divisor << shift_amount);\n        temp_3 = temp_3 - 1;\n      }\n      if (remainder != (uint *)0x0) {\n        temp_1 = ((divisor_bits - temp_6) - (int)(result >> 0x20)) - (uint)(dividend < (uint)result);\n        *remainder = temp_1 << (temp_5 & 0xff) | dividend - (uint)result >> shift_amount;\n        remainder[1] = temp_1 >> shift_amount;\n      }\n      return (ulonglong)temp_3;\n    }\n    if ((quotient_2 < quotient_1) || (divisor <= dividend)) {\n      carry_flag = dividend < divisor;\n      dividend = dividend - divisor;\n      quotient_1 = (quotient_1 - quotient_2) - (uint)carry_flag;\n      temp_1 = 1;\n    }\n    else {\n      temp_1 = 0;\n    }\n    temp_3 = 0;\n    if (remainder != (uint *)0x0) {\n      *remainder = dividend;\n      remainder[1] = quotient_1;\n    }\n  }\n  return CONCAT44(temp_3,temp_1);\n}\n\n",
            "renaming": {
                "FUN_00006a14": "div_with_remainder_00006a14",
                "param_1": "dividend",
                "param_2": "quotient_1",
                "param_3": "divisor",
                "param_4": "quotient_2",
                "param_5": "remainder",
                "uVar1": "temp_1",
                "iVar2": "shift_amount",
                "uVar3": "temp_2",
                "uVar4": "divisor_bits",
                "uVar5": "temp_3",
                "uVar6": "temp_4",
                "uVar7": "temp_5",
                "uVar8": "temp_6",
                "uVar9": "temp_7",
                "bVar10": "carry_flag",
                "uVar11": "result"
            },
            "calling": [
                "__aeabi_ldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006cd4": {
            "entrypoint": "0x00006cd4",
            "current_name": "FUNC_00006cd4",
            "code": "\nvoid FUNC_00006cd4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00006cd4": "FUNC_00006cd4"
            },
            "calling": [
                "__aeabi_ldivmod"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 143037,
    "layers": [
        [
            "FUN_00000410",
            "FUN_00000428",
            "FUN_00000490",
            "FUN_000004b2",
            "FUN_000004d4",
            "FUN_000004f2",
            "FUN_00000514",
            "FUN_00000534",
            "FUN_00000566",
            "FUN_0000058e",
            "FUN_000005ca",
            "FUN_00000610",
            "FUN_00000698",
            "FUN_00000738",
            "FUN_00000794",
            "FUN_000007dc",
            "FUN_000008b8",
            "FUN_00000900",
            "FUN_0000091c",
            "FUN_00000930",
            "FUN_0000093c",
            "FUN_00000958",
            "FUN_00000974",
            "FUN_00000978",
            "FUN_0000099c",
            "FUN_00000a30",
            "FUN_00000a40",
            "FUN_00000a64",
            "FUN_00000aa8",
            "FUN_00000c80",
            "FUN_00000c90",
            "FUN_00000ca0",
            "FUN_00000cb0",
            "FUN_00000cc0",
            "FUN_00000cd0",
            "FUN_00000cf0",
            "FUN_00000d0c",
            "FUN_00000d2a",
            "FUN_00000d44",
            "FUN_00000d76",
            "FUN_00000d9c",
            "FUN_00000db0",
            "FUN_00000dc0",
            "FUN_00000dcc",
            "FUN_00000df4",
            "FUN_00000e14",
            "FUN_00000e38",
            "FUN_00000e58",
            "FUN_00000e64",
            "FUN_00000ed8",
            "FUN_00000f04",
            "FUN_00000f5c",
            "FUN_00000f80",
            "FUN_00000f8c",
            "FUN_00000fec",
            "FUN_00001034",
            "FUN_000010a0",
            "FUN_000010d4",
            "FUN_00001274",
            "FUN_0000129c",
            "FUN_000012b4",
            "FUN_000012e2",
            "FUN_00001318",
            "FUN_00001348",
            "FUN_00001360",
            "FUN_00001392",
            "FUN_000013b8",
            "FUN_00001448",
            "FUN_000014c4",
            "FUN_000015d0",
            "FUN_00001628",
            "FUN_00001688",
            "FUN_00001696",
            "FUN_000016c8",
            "FUN_000016ec",
            "FUN_00001710",
            "FUN_00001734",
            "FUN_00001748",
            "FUN_00001778",
            "FUN_000017dc",
            "FUN_0000182c",
            "FUN_000018bc",
            "FUN_0000191c",
            "FUN_00001960",
            "FUN_000019c0",
            "FUN_00001a18",
            "FUN_00001a3c",
            "FUN_00001a60",
            "FUN_00001ad4",
            "FUN_00001b10",
            "FUN_00001bb8",
            "FUN_00001c84",
            "FUN_00001cf0",
            "FUN_00001d08",
            "FUN_00001d3a",
            "FUN_00001d5e",
            "FUN_00001d80",
            "FUN_00001da2",
            "FUN_00001dc0",
            "FUN_00001ddc",
            "FUN_00001e0c",
            "FUN_00001e44",
            "FUN_00001ec4",
            "FUN_00001eea",
            "FUN_00001f80",
            "FUN_00001ff6",
            "FUN_00002028",
            "FUN_000020b8",
            "FUN_000020cc",
            "FUN_000020e0",
            "FUN_000020f4",
            "FUN_00002108",
            "FUN_0000211c",
            "FUN_00002270",
            "FUN_00002294",
            "FUN_000022be",
            "FUN_000022f0",
            "FUN_0000231c",
            "FUN_00002364",
            "FUN_00002396",
            "FUN_000023a4",
            "FUN_000023c8",
            "FUN_000023d0",
            "FUN_0000240c",
            "FUN_00002434",
            "FUN_000024bc",
            "FUN_00002538",
            "FUN_0000258c",
            "FUN_000025f4",
            "FUN_00002600",
            "FUN_00002624",
            "FUN_00002654",
            "FUN_00002690",
            "FUN_000026c0",
            "FUN_000026d8",
            "FUN_000026e4",
            "FUN_000026f0",
            "FUN_00002714",
            "FUN_00002744",
            "FUN_00002798",
            "FUN_000027b0",
            "FUN_0000281c",
            "FUN_0000285c",
            "FUN_00002894",
            "FUN_000028f0",
            "FUN_00002910",
            "FUN_0000294c",
            "FUN_00002970",
            "FUN_00002994",
            "FUN_00002a00",
            "FUN_00002a18",
            "FUN_00002a88",
            "FUN_00002b10",
            "FUN_00002d94",
            "FUN_00002e48",
            "FUN_00002e6c",
            "FUN_00002e9c",
            "FUN_00002eb4",
            "FUN_00002ecc",
            "FUN_00002f30",
            "FUN_00002f74",
            "FUN_00002fe0",
            "FUN_0000305c",
            "FUN_0000316c",
            "FUN_000031e0",
            "FUN_000031fc",
            "FUN_0000328c",
            "FUN_00003378",
            "FUN_000033c0",
            "FUN_000033f4",
            "FUN_00003444",
            "FUN_00003478",
            "FUN_000034c0",
            "FUN_00003524",
            "FUN_00003658",
            "FUN_00003688",
            "FUN_00003694",
            "FUN_00003810",
            "FUN_00003918",
            "FUN_000039e8",
            "FUN_00003d24",
            "FUN_00003d64",
            "FUN_00003d94",
            "FUN_00003dc4",
            "FUN_00003e58",
            "FUN_00003e9e",
            "FUN_00003ec4",
            "FUN_00003ff4",
            "FUN_00004042",
            "FUN_0000404c",
            "FUN_00004158",
            "FUN_000041d0",
            "FUN_000041f4",
            "FUN_0000423c",
            "FUN_00004248",
            "FUN_00004274",
            "FUN_00004280",
            "FUN_0000428c",
            "FUN_00004298",
            "FUN_000042a4",
            "FUN_00004314",
            "FUN_000043a0",
            "FUN_000043da",
            "FUN_00004418",
            "FUN_0000443c",
            "FUN_0000459c",
            "FUN_000045ee",
            "FUN_00004622",
            "FUN_00004634",
            "FUN_000047e4",
            "FUN_00004b34",
            "FUN_00004bd0",
            "FUN_00004c84",
            "FUN_00004cb4",
            "FUN_00004cdc",
            "FUN_00004db8",
            "FUN_00004dc8",
            "FUN_00004dea",
            "FUN_00004dee",
            "FUN_00004e26",
            "FUN_00004e4a",
            "FUN_00004e52",
            "FUN_00004e66",
            "FUN_00004e8c",
            "FUN_00004f84",
            "FUN_00004f98",
            "FUN_000050e8",
            "FUN_000050f4",
            "FUN_00005100",
            "FUN_0000510c",
            "FUN_00005404",
            "FUN_000054a8",
            "FUN_00005584",
            "FUN_000055ac",
            "FUN_0000562c",
            "FUN_000056a0",
            "FUN_000056b0",
            "FUN_000056b8",
            "FUN_00005700",
            "FUN_00005780",
            "FUN_00005790",
            "FUN_0000579c",
            "FUN_000057a8",
            "FUN_000057d2",
            "FUN_000057f8",
            "FUN_00005a58",
            "FUN_00005b34",
            "FUN_00005d80",
            "FUN_00005e10",
            "FUN_00005e68",
            "FUN_00005ebc",
            "FUN_00005ecc",
            "FUN_00005edc",
            "FUN_00005fd8",
            "FUN_00005fec",
            "FUN_00005ff8",
            "FUN_00006010",
            "FUN_000060b0",
            "FUN_000060cc",
            "FUN_00006118",
            "FUN_00006192",
            "FUN_000061cc",
            "FUN_000064bc",
            "FUN_0000656c",
            "FUN_00006754",
            "FUN_00006768",
            "FUN_0000687c",
            "FUN_000068f0",
            "FUN_00006964",
            "FUN_00006974",
            "FUN_00006a14"
        ]
    ],
    "locked_functions": []
}