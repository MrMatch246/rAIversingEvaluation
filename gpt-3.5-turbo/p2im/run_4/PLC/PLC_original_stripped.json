{
    "functions": {
        "FUN_080001ac": {
            "entrypoint": "0x080001ac",
            "current_name": "initialize_completed_flag_080001ac",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080001b8) */\n\nundefined4 initializeCompletedFlag_080001ac(undefined4 inputParameter)\n\n{\n  if ((char)completionFlag == '\\0') {\n    completionFlag._0_1_ = '\\x01';\n  }\n  return inputParameter;\n}\n\n",
            "renaming": {
                "FUN_080001ac": "initialize_completed_flag_080001ac",
                "param_1": "inputParameter",
                "completed_8667": "completionFlag"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080001d0": {
            "entrypoint": "0x080001d0",
            "current_name": "FUNC_080001d0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080001d4) */\n/* WARNING: Removing unreachable block (ram,0x080001ee) */\n/* WARNING: Removing unreachable block (ram,0x080001e4) */\n/* WARNING: Removing unreachable block (ram,0x08000200) */\n/* WARNING: Removing unreachable block (ram,0x080001f4) */\n\nvoid FUNC_080001d0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080001d0": "FUNC_080001d0"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000218": {
            "entrypoint": "0x08000218",
            "current_name": "calculate_string_length_08000218",
            "code": "\nsize_t calculate_string_length_08000218(char *string)\n\n{\n  char current_char;\n  char *next_char;\n  char *current_position;\n  \n  current_position = string;\n  do {\n    next_char = current_position + 1;\n    current_char = *current_position;\n    current_position = next_char;\n  } while (current_char != '\\0');\n  return (size_t)(next_char + (-1 - (int)string));\n}\n\n",
            "renaming": {
                "FUN_08000218": "calculate_string_length_08000218",
                "__s": "string",
                "cVar1": "current_char",
                "pcVar2": "next_char",
                "pcVar3": "current_position"
            },
            "calling": [
                "printNumber"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000230": {
            "entrypoint": "0x08000230",
            "current_name": "find_character_08000230",
            "code": "\nvoid * find_character_08000230(void *string,int character,size_t length)\n\n{\n  byte current_byte;\n  char char_check_1;\n  char char_check_2;\n  char char_check_3;\n  char char_check_4;\n  byte *byte_pointer_1;\n  uint *uint_pointer;\n  byte *byte_pointer_2;\n  uint character_uint;\n  uint byte_uint;\n  uint length_uint;\n  uint xor_result_1;\n  uint xor_result_2;\n  bool is_nonzero_1;\n  bool is_nonzero_2;\n  bool is_nonzero_3;\n  bool is_nonzero_4;\n  \n  character_uint = character & 0xff;\n  if ((int)length < 0x10) {\njoined_r0x08000290:\n    do {\n      if (length == 0) {\n        return (void *)0x0;\n      }\n                    /* WARNING: Load size is inaccurate */\n      uint_pointer = (uint *)((int)string + 1);\n      current_byte = *string;\n      length = length - 1;\n      string = uint_pointer;\n    } while (current_byte != character_uint);\n  }\n  else {\n    byte_uint = (uint)string & 7;\n    while( true ) {\n      if (byte_uint == 0) {\n        byte_uint = character_uint | character_uint << 8;\n        byte_uint = byte_uint | byte_uint << 0x10;\n        length_uint = length & 0xfffffff8;\n        do {\n          uint_pointer = (uint *)((int)string + 8);\n                    /* WARNING: Load size is inaccurate */\n          length_uint = length_uint - 8;\n          xor_result_1 = *string ^ byte_uint;\n          xor_result_2 = *(uint *)((int)string + 4) ^ byte_uint;\n          char_check_1 = -((char)xor_result_1 == '\\0');\n          char_check_2 = -((char)(xor_result_1 >> 8) == '\\0');\n          char_check_3 = -((char)(xor_result_1 >> 0x10) == '\\0');\n          char_check_4 = -((char)(xor_result_1 >> 0x18) == '\\0');\n          xor_result_1 = CONCAT13(char_check_4,CONCAT12(char_check_3,CONCAT11(char_check_2,char_check_1)));\n          is_nonzero_1 = (char)xor_result_2 != '\\0';\n          is_nonzero_2 = (char)(xor_result_2 >> 8) != '\\0';\n          is_nonzero_3 = (char)(xor_result_2 >> 0x10) != '\\0';\n          is_nonzero_4 = (char)(xor_result_2 >> 0x18) != '\\0';\n          xor_result_2 = CONCAT13(is_nonzero_4 * char_check_4 - !is_nonzero_4,\n                            CONCAT12(is_nonzero_3 * char_check_3 - !is_nonzero_3,\n                                     CONCAT11(is_nonzero_2 * char_check_2 - !is_nonzero_2,is_nonzero_1 * char_check_1 - !is_nonzero_1)));\n          if (xor_result_2 != 0) {\n            if (xor_result_1 == 0) {\n              byte_pointer_2 = (byte *)((int)string + 5);\n              xor_result_1 = xor_result_2;\n            }\n            else {\n              byte_pointer_2 = (byte *)((int)string + 1);\n            }\n            if ((xor_result_1 & 1) == 0) {\n              is_nonzero_1 = (xor_result_1 & 0x100) == 0;\n              byte_pointer_1 = byte_pointer_2 + 1;\n              if (is_nonzero_1) {\n                is_nonzero_1 = (xor_result_1 & 0x18000) == 0;\n                byte_pointer_1 = byte_pointer_2 + 2;\n              }\n              byte_pointer_2 = byte_pointer_1;\n              if (is_nonzero_1) {\n                byte_pointer_2 = byte_pointer_2 + 1;\n              }\n            }\n            return byte_pointer_2 + -1;\n          }\n          string = uint_pointer;\n        } while (length_uint != 0);\n        length = length & 7;\n        goto joined_r0x08000290;\n      }\n                    /* WARNING: Load size is inaccurate */\n      uint_pointer = (uint *)((int)string + 1);\n      length = length - 1;\n      if (*string == character_uint) break;\n      byte_uint = (uint)uint_pointer & 7;\n      string = uint_pointer;\n      if (length == 0) {\n        return (void *)0x0;\n      }\n    }\n  }\n  return (byte *)((int)uint_pointer + -1);\n}\n\n",
            "renaming": {
                "FUN_08000230": "find_character_08000230",
                "__s": "string",
                "__c": "character",
                "__n": "length",
                "bVar1": "current_byte",
                "cVar2": "char_check_1",
                "cVar3": "char_check_2",
                "cVar4": "char_check_3",
                "cVar5": "char_check_4",
                "pbVar6": "byte_pointer_1",
                "puVar7": "uint_pointer",
                "pbVar8": "byte_pointer_2",
                "uVar9": "character_uint",
                "uVar10": "byte_uint",
                "uVar11": "length_uint",
                "uVar12": "xor_result_1",
                "uVar13": "xor_result_2",
                "bVar14": "is_nonzero_1",
                "bVar15": "is_nonzero_2",
                "bVar16": "is_nonzero_3",
                "bVar17": "is_nonzero_4"
            },
            "calling": [
                "_printf_i",
                "_vfiprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080002d0": {
            "entrypoint": "0x080002d0",
            "current_name": "divide_or_throw_exception_080002d0",
            "code": "\nvoid divideOrThrowException_080002d0(int dividend,int divisor,int unk1,int unk2)\n\n{\n  if ((unk2 == 0) && (unk1 == 0)) {\n    if (divisor != 0 || dividend != 0) {\n      divisor = -1;\n      dividend = -1;\n    }\n    __aeabi_idiv0(dividend,divisor);\n    return;\n  }\n  __udivmoddi4();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080002d0": "divide_or_throw_exception_080002d0",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "unk1",
                "param_4": "unk2"
            },
            "calling": [
                "HAL_RCC_GetSysClockFreq"
            ],
            "called": [
                "__aeabi_idiv0",
                "__udivmoddi4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000300": {
            "entrypoint": "0x08000300",
            "current_name": "div_mod_08000300",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080005aa) */\n\nulonglong divMod_08000300(uint dividend,uint dividend_lower,uint divisor,uint remainder,uint *quotient)\n\n{\n  ulonglong result;\n  uint temp;\n  uint quotient_lower;\n  uint quotient_upper;\n  uint remainder_lower;\n  uint remainder_upper;\n  uint temp_quotient;\n  uint temp_remainder;\n  uint divisor_lower;\n  int shift_count;\n  bool carry_flag;\n  \n  if (remainder == 0) {\n    if (dividend_lower < divisor) {\n      shift_count = LZCOUNT(divisor);\n      if (shift_count != 0) {\n        divisor = divisor << shift_count;\n        dividend_lower = dividend >> (0x20U - shift_count & 0xff) | dividend_lower << shift_count;\n        dividend = dividend << shift_count;\n      }\n      temp_remainder = divisor >> 0x10;\n      remainder_upper = dividend_lower / temp_remainder;\n      remainder_lower = dividend >> 0x10 | (dividend_lower - temp_remainder * remainder_upper) * 0x10000;\n      quotient_upper = remainder_upper * (divisor & 0xffff);\n      quotient_lower = remainder_upper;\n      if (remainder_lower <= quotient_upper && quotient_upper - remainder_lower != 0) {\n        carry_flag = CARRY4(remainder_lower,divisor);\n        remainder_lower = remainder_lower + divisor;\n        quotient_lower = remainder_upper - 1;\n        if ((carry_flag == false) && (remainder_lower <= quotient_upper && quotient_upper - remainder_lower != 0)) {\n          quotient_lower = remainder_upper - 2;\n          remainder_lower = remainder_lower + divisor;\n        }\n      }\n      remainder_upper = (remainder_lower - quotient_upper) / temp_remainder;\n      remainder_lower = dividend & 0xffff | ((remainder_lower - quotient_upper) - temp_remainder * remainder_upper) * 0x10000;\n      temp_remainder = remainder_upper * (divisor & 0xffff);\n      quotient_upper = remainder_upper;\n      if (remainder_lower <= temp_remainder && temp_remainder - remainder_lower != 0) {\n        carry_flag = CARRY4(remainder_lower,divisor);\n        remainder_lower = remainder_lower + divisor;\n        quotient_upper = remainder_upper - 1;\n        if ((carry_flag == false) && (remainder_lower <= temp_remainder && temp_remainder - remainder_lower != 0)) {\n          quotient_upper = remainder_upper - 2;\n          remainder_lower = remainder_lower + divisor;\n        }\n      }\n      remainder_lower = remainder_lower - temp_remainder;\n      quotient_upper = quotient_upper | quotient_lower << 0x10;\n      quotient_lower = 0;\n    }\n    else {\n      if (divisor == 0) {\n        divisor = 1 / 0;\n      }\n      shift_count = LZCOUNT(divisor);\n      if (shift_count == 0) {\n        dividend_lower = dividend_lower - divisor;\n        remainder_lower = divisor >> 0x10;\n        divisor_lower = divisor & 0xffff;\n        quotient_lower = 1;\n      }\n      else {\n        divisor = divisor << shift_count;\n        remainder_lower = divisor >> 0x10;\n        quotient_upper = dividend_lower >> (0x20U - shift_count & 0xff);\n        temp_quotient = dividend >> (0x20U - shift_count & 0xff) | dividend_lower << shift_count;\n        quotient_lower = quotient_upper / remainder_lower;\n        divisor_lower = divisor & 0xffff;\n        temp_remainder = temp_quotient >> 0x10 | (quotient_upper - remainder_lower * quotient_lower) * 0x10000;\n        remainder_upper = quotient_lower * divisor_lower;\n        dividend = dividend << shift_count;\n        quotient_upper = quotient_lower;\n        if (temp_remainder <= remainder_upper && remainder_upper - temp_remainder != 0) {\n          carry_flag = CARRY4(temp_remainder,divisor);\n          temp_remainder = temp_remainder + divisor;\n          quotient_upper = quotient_lower - 1;\n          if ((carry_flag == false) && (temp_remainder <= remainder_upper && remainder_upper - temp_remainder != 0)) {\n            quotient_upper = quotient_lower - 2;\n            temp_remainder = temp_remainder + divisor;\n          }\n        }\n        temp = (temp_remainder - remainder_upper) / remainder_lower;\n        dividend_lower = temp_quotient & 0xffff | ((temp_remainder - remainder_upper) - remainder_lower * temp) * 0x10000;\n        remainder_upper = temp * divisor_lower;\n        quotient_lower = temp;\n        if (dividend_lower <= remainder_upper && remainder_upper - dividend_lower != 0) {\n          carry_flag = CARRY4(dividend_lower,divisor);\n          dividend_lower = dividend_lower + divisor;\n          quotient_lower = temp - 1;\n          if ((carry_flag == false) && (dividend_lower <= remainder_upper && remainder_upper - dividend_lower != 0)) {\n            quotient_lower = temp - 2;\n            dividend_lower = dividend_lower + divisor;\n          }\n        }\n        dividend_lower = dividend_lower - remainder_upper;\n        quotient_lower = quotient_lower | quotient_upper << 0x10;\n      }\n      temp_quotient = dividend_lower / remainder_lower;\n      temp_remainder = dividend >> 0x10 | (dividend_lower - remainder_lower * temp_quotient) * 0x10000;\n      quotient_upper = divisor_lower * temp_quotient;\n      remainder_upper = temp_quotient;\n      if (temp_remainder <= quotient_upper && quotient_upper - temp_remainder != 0) {\n        carry_flag = CARRY4(temp_remainder,divisor);\n        temp_remainder = temp_remainder + divisor;\n        remainder_upper = temp_quotient - 1;\n        if ((carry_flag == false) && (temp_remainder <= quotient_upper && quotient_upper - temp_remainder != 0)) {\n          remainder_upper = temp_quotient - 2;\n          temp_remainder = temp_remainder + divisor;\n        }\n      }\n      temp_quotient = (temp_remainder - quotient_upper) / remainder_lower;\n      remainder_lower = dividend & 0xffff | ((temp_remainder - quotient_upper) - remainder_lower * temp_quotient) * 0x10000;\n      divisor_lower = divisor_lower * temp_quotient;\n      quotient_upper = temp_quotient;\n      if (remainder_lower <= divisor_lower && divisor_lower - remainder_lower != 0) {\n        carry_flag = CARRY4(remainder_lower,divisor);\n        remainder_lower = remainder_lower + divisor;\n        quotient_upper = temp_quotient - 1;\n        if ((carry_flag == false) && (remainder_lower <= divisor_lower && divisor_lower - remainder_lower != 0)) {\n          quotient_upper = temp_quotient - 2;\n          remainder_lower = remainder_lower + divisor;\n        }\n      }\n      remainder_lower = remainder_lower - divisor_lower;\n      quotient_upper = quotient_upper | remainder_upper << 0x10;\n    }\n    if (quotient != (uint *)0x0) {\n      *quotient = remainder_lower >> shift_count;\n      quotient[1] = 0;\n      return CONCAT44(quotient_lower,quotient_upper);\n    }\n  }\n  else if (dividend_lower < remainder) {\n    if (quotient != (uint *)0x0) {\n      *quotient = dividend;\n      quotient[1] = dividend_lower;\n      return 0;\n    }\n    quotient_upper = 0;\n    quotient_lower = 0;\n  }\n  else {\n    shift_count = LZCOUNT(remainder);\n    if (shift_count != 0) {\n      temp_remainder = 0x20 - shift_count;\n      quotient_lower = divisor >> (temp_remainder & 0xff) | remainder << shift_count;\n      divisor_lower = quotient_lower >> 0x10;\n      quotient_upper = dividend_lower >> (temp_remainder & 0xff);\n      temp = dividend >> (temp_remainder & 0xff) | dividend_lower << shift_count;\n      temp_quotient = quotient_upper / divisor_lower;\n      remainder_upper = temp >> 0x10 | (quotient_upper - divisor_lower * temp_quotient) * 0x10000;\n      remainder_lower = temp_quotient * (quotient_lower & 0xffff);\n      dividend = dividend << shift_count;\n      quotient_upper = temp_quotient;\n      if (remainder_upper <= remainder_lower && remainder_lower - remainder_upper != 0) {\n        carry_flag = CARRY4(remainder_upper,quotient_lower);\n        remainder_upper = remainder_upper + quotient_lower;\n        quotient_upper = temp_quotient - 1;\n        if ((carry_flag == false) && (remainder_upper <= remainder_lower && remainder_lower - remainder_upper != 0)) {\n          quotient_upper = temp_quotient - 2;\n          remainder_upper = remainder_upper + quotient_lower;\n        }\n      }\n      temp_quotient = (remainder_upper - remainder_lower) / divisor_lower;\n      remainder_upper = temp & 0xffff | ((remainder_upper - remainder_lower) - divisor_lower * temp_quotient) * 0x10000;\n      divisor_lower = temp_quotient * (quotient_lower & 0xffff);\n      remainder_lower = temp_quotient;\n      if (remainder_upper <= divisor_lower && divisor_lower - remainder_upper != 0) {\n        carry_flag = CARRY4(remainder_upper,quotient_lower);\n        remainder_upper = remainder_upper + quotient_lower;\n        remainder_lower = temp_quotient - 1;\n        if ((carry_flag == false) && (remainder_upper <= divisor_lower && divisor_lower - remainder_upper != 0)) {\n          remainder_lower = temp_quotient - 2;\n          remainder_upper = remainder_upper + quotient_lower;\n        }\n      }\n      remainder_lower = remainder_lower | quotient_upper << 0x10;\n      result = (ulonglong)remainder_lower * (ulonglong)(divisor << shift_count);\n      if (CONCAT44(remainder_upper - divisor_lower,dividend) < result) {\n        result = result - CONCAT44(quotient_lower,divisor << shift_count);\n        remainder_lower = remainder_lower - 1;\n      }\n      if (quotient != (uint *)0x0) {\n        quotient_upper = ((remainder_upper - divisor_lower) - (int)(result >> 0x20)) - (uint)(dividend < (uint)result);\n        *quotient = quotient_upper << (temp_remainder & 0xff) | dividend - (uint)result >> shift_count;\n        quotient[1] = quotient_upper >> shift_count;\n      }\n      return (ulonglong)remainder_lower;\n    }\n    if ((remainder < dividend_lower) || (divisor <= dividend)) {\n      carry_flag = dividend < divisor;\n      dividend = dividend - divisor;\n      dividend_lower = (dividend_lower - remainder) - (uint)carry_flag;\n      quotient_upper = 1;\n    }\n    else {\n      quotient_upper = 0;\n    }\n    quotient_lower = 0;\n    if (quotient != (uint *)0x0) {\n      *quotient = dividend;\n      quotient[1] = dividend_lower;\n      return (ulonglong)quotient_upper;\n    }\n  }\n  return CONCAT44(quotient_lower,quotient_upper);\n}\n\n",
            "renaming": {
                "FUN_08000300": "div_mod_08000300",
                "param_1": "dividend",
                "param_2": "dividend_lower",
                "param_3": "divisor",
                "param_4": "remainder",
                "param_5": "quotient",
                "uVar1": "result",
                "uVar2": "temp",
                "uVar3": "quotient_lower",
                "uVar4": "quotient_upper",
                "uVar5": "remainder_lower",
                "uVar6": "remainder_upper",
                "uVar7": "temp_quotient",
                "uVar8": "temp_remainder",
                "uVar9": "divisor_lower",
                "iVar10": "shift_count",
                "bVar11": "carry_flag"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005dc": {
            "entrypoint": "0x080005dc",
            "current_name": "FUNC_080005dc",
            "code": "\nvoid FUNC_080005dc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080005dc": "FUNC_080005dc"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080005e0": {
            "entrypoint": "0x080005e0",
            "current_name": "interrupt_and_return_080005e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t interrupt_and_return_080005e0(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_080005e0": "interrupt_and_return_080005e0"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005e4": {
            "entrypoint": "0x080005e4",
            "current_name": "perform_afl_call_080005e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint performAflCall_080005e4(int numTicks)\n\n{\n  uint32_t result;\n  \n  if (noHyperCall != 0) {\n    return 0;\n  }\n  result = aflCall(1,numTicks,0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080005e4": "perform_afl_call_080005e4",
                "ticks": "numTicks",
                "uVar1": "result"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000600": {
            "entrypoint": "0x08000600",
            "current_name": "initialize_modbus_08000600",
            "code": "\n/* DWARF original prototype: void  begin(Modbus * modbusInstance, long baudRate) */\n\nvoid __modbusInstancecall Modbus::initializeModbus_08000600(Modbus *modbusInstance,long baudRate)\n\n{\n  uint8_t serialNumber;\n  int serialReadResult;\n  \n  serialNumber = modbusInstance->u8serno;\n  if (serialNumber == '\\x02') {\n    modbusInstance->port = &Serial3;\n  }\n  else if (serialNumber == '\\x03') {\n    modbusInstance->port = &Serial3;\n  }\n  else if (serialNumber == '\\x01') {\n    modbusInstance->port = &Serial3;\n  }\n  else {\n    modbusInstance->port = &Serial3;\n  }\n  HardwareSerial::begin(modbusInstance->port,baudRate,'\\x06');\n  if (1 < modbusInstance->u8txenpin) {\n    pinMode((uint)modbusInstance->u8txenpin,1);\n    digitalWrite((uint)modbusInstance->u8txenpin,0);\n  }\n  do {\n    serialReadResult = (*(modbusInstance->port->super_Stream).super_Print._vptr_Print[3])();\n  } while (-1 < serialReadResult);\n  modbusInstance->u8BufferSize = '\\0';\n  modbusInstance->u8lastRec = '\\0';\n  modbusInstance->u16errCnt = 0;\n  modbusInstance->u16OutCnt = 0;\n  modbusInstance->u16InCnt = 0;\n  return;\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "u32speed": "baudRate",
                "uVar1": "serialNumber",
                "iVar2": "serialReadResult",
                "FUN_08000600": "initialize_modbus_08000600"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "begin",
                "pinMode",
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800066c": {
            "entrypoint": "0x0800066c",
            "current_name": "initialize_modbus_0800066c",
            "code": "\n/* DWARF original prototype: void  init(Modbus * this, uint8_t u8id, uint8_t u8serno, uint8_t\n   u8txenpin) */\n\nint __thiscall Modbus::initializeModbus_0800066c(Modbus *this,EVP_PKEY_CTX *ctx)\n\n{\n  int inputParameter;\n  uint8_t inputValue;\n  \n  this->u8id = (uint8_t)ctx;\n  if (3 < inputParameter) {\n    inputParameter = 0;\n  }\n  this->u8serno = (uint8_t)inputParameter;\n  this->u8txenpin = inputValue;\n  this->u16timeOut = 1000;\n  return (int)this;\n}\n\n",
            "renaming": {
                "FUN_0800066c": "initialize_modbus_0800066c",
                "in_r2": "inputParameter",
                "in_r3": "inputValue"
            },
            "calling": [
                "Modbus"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000682": {
            "entrypoint": "0x08000682",
            "current_name": "initialize_modbus_08000682",
            "code": "\n/* DWARF original prototype: Modbus *  Modbus(Modbus * modbusInstance, uint8_t deviceId, uint8_t serialNumber, uint8_t\n   txEnablePin) */\n\nModbus * __modbusInstancecall\nModbus::initializeModbus_08000682(Modbus *modbusInstance,uint8_t deviceId,uint8_t serialNumber,uint8_t txEnablePin)\n\n{\n  initialize(modbusInstance,(keyContext *)(uint)deviceId);\n  return modbusInstance;\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "u8id": "deviceId",
                "u8serno": "serialNumber",
                "u8txenpin": "txEnablePin",
                "init": "initialize",
                "EVP_PKEY_CTX": "keyContext",
                "FUN_08000682": "initialize_modbus_08000682"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000690": {
            "entrypoint": "0x08000690",
            "current_name": "initialize_modbus_08000690",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeModbus_08000690(int shouldInitialize,int priority)\n\n{\n  if (shouldInitialize != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    modbusConstructor(&modbusInstance,'\\x01','\\0','\\0');\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000690": "initialize_modbus_08000690",
                "__initialize_p": "shouldInitialize",
                "__priority": "priority",
                "Modbus::Modbus": "modbusConstructor",
                "slave": "modbusInstance"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN6ModbusC2Ev"
            ],
            "called": [
                "Modbus"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006b4": {
            "entrypoint": "0x080006b4",
            "current_name": "get_rx_buffer_080006b4",
            "code": "\n/* DWARF original prototype: int8_t  getRxBuffer_080006b4(Modbus * modbus) */\n\nint8_t __modbuscall Modbus::getRxBuffer_080006b4(Modbus *modbus)\n\n{\n  bool isBufferFull;\n  int streamReturnValue;\n  byte bufferIndex;\n  \n  if (1 < modbus->txEnablePin) {\n    setTxEnablePinState((uint)modbus->txEnablePin,0);\n  }\n  modbus->bufferSize = '\\0';\n  if (modbus->serialNumber < 4) {\n    isBufferFull = false;\n    while (streamReturnValue = (*(modbus->serialPort->superStream).superPrint.vptrPrint[2])(), streamReturnValue != 0) {\n      bufferIndex = modbus->bufferSize;\n      streamReturnValue = (*(modbus->serialPort->superStream).superPrint.vptrPrint[3])();\n      modbus->buffer[bufferIndex] = (uint8_t)streamReturnValue;\n      bufferIndex = modbus->bufferSize + 1;\n      modbus->bufferSize = bufferIndex;\n      if (0x3f < bufferIndex) {\n        isBufferFull = true;\n      }\n    }\n  }\n  else {\n    isBufferFull = false;\n  }\n  modbus->inputCount = modbus->inputCount + 1;\n  if (isBufferFull) {\n    modbus->errorCount = modbus->errorCount + 1;\n    return -3;\n  }\n  return modbus->bufferSize;\n}\n\n",
            "renaming": {
                "FUN_080006b4": "get_rx_buffer_080006b4",
                "this": "modbus",
                "bVar1": "isBufferFull",
                "iVar2": "streamReturnValue",
                "bVar3": "bufferIndex",
                "u8txenpin": "txEnablePin",
                "digitalWrite": "setTxEnablePinState",
                "u8BufferSize": "bufferSize",
                "u8serno": "serialNumber",
                "port": "serialPort",
                "super_Stream": "superStream",
                "super_Print": "superPrint",
                "_vptr_Print": "vptrPrint",
                "au8Buffer": "buffer",
                "u16InCnt": "inputCount",
                "u16errCnt": "errorCount"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000728": {
            "entrypoint": "0x08000728",
            "current_name": "calculate_crc_08000728",
            "code": "\n/* DWARF original prototype: uint16_t  calcCRC(Modbus * modbusInstance, uint8_t dataLength) */\n\nuint16_t __modbusInstancecall Modbus::calculateCRC_08000728(Modbus *modbusInstance,uint8_t dataLength)\n\n{\n  uchar bitIndex;\n  uint crc;\n  uint flag;\n  uint bit;\n  uint i;\n  \n  crc = 0xffff;\n  for (i = 0; i < dataLength; i = i + 1 & 0xff) {\n    crc = crc ^ modbusInstance->dataBuffer[i];\n    for (bitIndex = 1; bitIndex < 9; bitIndex = bitIndex + 1) {\n      bit = crc & 1;\n      crc = crc >> 1;\n      if (bit != 0) {\n        crc = crc ^ 0xa001;\n      }\n    }\n  }\n  return (ushort)(crc << 8) | (ushort)(crc >> 8);\n}\n\n",
            "renaming": {
                "FUN_08000728": "calculate_crc_08000728",
                "this": "modbusInstance",
                "u8length": "dataLength",
                "j": "bitIndex",
                "uVar1": "crc",
                "uVar2": "bit",
                "uVar3": "i",
                "au8Buffer": "dataBuffer"
            },
            "calling": [
                "sendTxBuffer"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800076c": {
            "entrypoint": "0x0800076c",
            "current_name": "send_tx_buffer_0800076c",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080007ec */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendTxBuffer_0800076c(Modbus * this) */\n\nvoid __thiscall Modbus::sendTxBuffer_0800076c(Modbus *this)\n\n{\n  byte length;\n  uint16_t crc;\n  uint16_t crc;\n  int returnValue;\n  uint32_t currentTime;\n  uint nextIndex;\n  \n  length = this->u8BufferSize;\n  crc = calcCRC(this,length);\n  this->au8Buffer[length] = (uint8_t)(crc >> 8);\n  nextIndex = length + 1 & 0xff;\n  this->au8Buffer[nextIndex] = (uint8_t)crc;\n  this->u8BufferSize = (char)nextIndex + '\\x01';\n  if (1 < this->u8txenpin) {\n    digitalWrite((uint)this->u8txenpin,1);\n  }\n  if (this->u8serno < 4) {\n    (*(this->port->super_Stream).super_Print._vptr_Print[1])\n              (this->port,this->au8Buffer,(uint)this->u8BufferSize);\n  }\n  if (1 < this->u8txenpin) {\n    digitalWrite((uint)this->u8txenpin,0);\n  }\n  if (this->u8serno < 4) {\n    do {\n      returnValue = (*(this->port->super_Stream).super_Print._vptr_Print[3])();\n    } while (-1 < returnValue);\n  }\n  this->u8BufferSize = '\\0';\n  currentTime = millis();\n  this->u32timeOut = currentTime + this->u16timeOut;\n  this->u16OutCnt = this->u16OutCnt + 1;\n  return;\n}\n\n",
            "renaming": {
                "u8length": "length",
                "uVar1": "crc",
                "u16crc": "crc",
                "iVar2": "returnValue",
                "uVar3": "currentTime",
                "uVar4": "nextIndex",
                "FUN_0800076c": "send_tx_buffer_0800076c"
            },
            "calling": [
                "process_FC1",
                "process_FC3",
                "process_FC15",
                "process_FC5",
                "process_FC6",
                "poll",
                "process_FC16"
            ],
            "called": [
                "calcCRC",
                "digitalWrite",
                "millis"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080007f0": {
            "entrypoint": "0x080007f0",
            "current_name": "validate_request_080007f0",
            "code": "\n/* DWARF original prototype: uint8_t  validateRequest_080007f0(Modbus * modbusObj) */\n\nuint8_t __modbusObjcall Modbus::validateRequest_080007f0(Modbus *modbusObj)\n\n{\n  bool isValid;\n  uint16_t regValue1;\n  uint16_t regValue2;\n  uint index;\n  uint8_t registerSize;\n  \n  index = 0;\n  do {\n    if (7 < index) {\n      isValid = false;\nLAB_0800080a:\n      if (!isValid) {\n        modbusObj->u16errCnt = modbusObj->u16errCnt + 1;\n        return '\\x01';\n      }\n      switch(modbusObj->au8Buffer[1]) {\n      case '\\x01':\n      case '\\x02':\n      case '\\x0f':\n        goto switchD_08000816_caseD_1;\n      case '\\x03':\n      case '\\x04':\n      case '\\x10':\n        regValue1 = makeWord(modbusObj->au8Buffer[2],modbusObj->au8Buffer[3]);\n        regValue2 = makeWord(modbusObj->au8Buffer[4],modbusObj->au8Buffer[5]);\n        if (modbusObj->registerSizeize < (byte)((char)regValue2 + (char)regValue1)) {\n          return '\\x02';\n        }\n        return '\\0';\n      case '\\x05':\n        regValue1 = makeWord(modbusObj->au8Buffer[2],modbusObj->au8Buffer[3]);\n        if ((uint)modbusObj->registerSizeize < ((uint)regValue1 << 0x14) >> 0x18) {\n          return '\\x02';\n        }\n        return '\\0';\n      case '\\x06':\n        regValue1 = makeWord(modbusObj->au8Buffer[2],modbusObj->au8Buffer[3]);\n        if (modbusObj->registerSizeize < (byte)regValue1) {\n          return '\\x02';\n        }\n        return '\\0';\n      default:\n        return '\\0';\n      }\n    }\n    if (\"\\x01\\x02\\x03\\x04\\x05\\x06\\x0f\\x10\"[index] == modbusObj->au8Buffer[1]) {\n      isValid = true;\n      goto LAB_0800080a;\n    }\n    index = index + 1 & 0xff;\n  } while( true );\nswitchD_08000816_caseD_1:\n  regValue1 = makeWord(modbusObj->au8Buffer[2],modbusObj->au8Buffer[3]);\n  regValue2 = makeWord(modbusObj->au8Buffer[4],modbusObj->au8Buffer[5]);\n  if ((uint)modbusObj->registerSizeize <\n      ((((uint)regValue1 << 0xc) >> 0x10) + (((uint)regValue2 << 0xc) >> 0x10) & 0xff)) {\n    return '\\x02';\n  }\n  return '\\0';\n}\n\n",
            "renaming": {
                "this": "modbusObj",
                "bVar1": "isValid",
                "uVar2": "regValue1",
                "uVar3": "regValue2",
                "uVar4": "index",
                "u8regs": "registerSize",
                "FUN_080007f0": "validate_request_080007f0"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008cc": {
            "entrypoint": "0x080008cc",
            "current_name": "build_exception_080008cc",
            "code": "\n/* DWARF original prototype: void  buildException_080008cc(Modbus * modbus, uint8_t exceptionCode) */\n\nvoid __modbuscall Modbus::buildException_080008cc(Modbus *modbus,uint8_t exceptionCode)\n\n{\n  byte bufferByte;\n  uint8_t functionCode;\n  \n  bufferByte = modbus->au8Buffer[1];\n  modbus->au8Buffer[0] = modbus->u8id;\n  modbus->au8Buffer[1] = bufferByte ^ 0x80;\n  modbus->au8Buffer[2] = exceptionCode;\n  modbus->u8BufferSize = '\\x03';\n  return;\n}\n\n",
            "renaming": {
                "FUN_080008cc": "build_exception_080008cc",
                "this": "modbus",
                "u8exception": "exceptionCode",
                "bVar1": "bufferByte",
                "u8func": "functionCode"
            },
            "calling": [
                "poll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008e2": {
            "entrypoint": "0x080008e2",
            "current_name": "generate_modbus_response_080008e2",
            "code": "\n/* DWARF original prototype: int8_t  process_FC1(Modbus * modbusInstance, uint16_t * inputRegisters, uint8_t registerSize) */\n\nint8_t __modbusInstancecall Modbus::generateModbusResponse_080008e2(Modbus *modbusInstance,uint16_t *inputRegisters,uint8_t registerSize)\n\n{\n  uint16_t startAddress;\n  uint16_t bitCount;\n  uint16_t currentCoil;\n  uint loopIndex;\n  uint bitIndex;\n  uint8_t byteCount;\n  uint8_t byteCount;\n  uint8_t bufferSize;\n  uint16_t startCoil;\n  \n  startAddress = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n  bitCount = makeWord(modbusInstance->au8Buffer[4],modbusInstance->au8Buffer[5]);\n  byteCount = (uint8_t)(((uint)bitCount << 0x15) >> 0x18);\n  if ((bitCount & 7) != 0) {\n    byteCount = byteCount + '\\x01';\n  }\n  modbusInstance->au8Buffer[2] = byteCount;\n  modbusInstance->u8BufferSize = '\\x03';\n  bitIndex = 0;\n  for (loopIndex = 0; loopIndex < bitCount; loopIndex = loopIndex + 1 & 0xffff) {\n    if (((int)(uint)inputRegisters[(loopIndex + startAddress) * 0x100000 >> 0x18] >> (loopIndex + startAddress & 0xf) & 1U) == 0) {\n      modbusInstance->au8Buffer[modbusInstance->u8BufferSize] =\n           modbusInstance->au8Buffer[modbusInstance->u8BufferSize] & ~(byte)(1 << bitIndex);\n    }\n    else {\n      modbusInstance->au8Buffer[modbusInstance->u8BufferSize] = modbusInstance->au8Buffer[modbusInstance->u8BufferSize] | (byte)(1 << bitIndex)\n      ;\n    }\n    bitIndex = bitIndex + 1 & 0xff;\n    if (7 < bitIndex) {\n      modbusInstance->u8BufferSize = modbusInstance->u8BufferSize + '\\x01';\n      bitIndex = 0;\n    }\n  }\n  if ((bitCount & 7) != 0) {\n    modbusInstance->u8BufferSize = modbusInstance->u8BufferSize + '\\x01';\n  }\n  byteCount = modbusInstance->u8BufferSize;\n  sendTxBuffer(modbusInstance);\n  return byteCount + '\\x02';\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "regs": "inputRegisters",
                "u8size": "registerSize",
                "uVar1": "startAddress",
                "uVar2": "bitCount",
                "u16Coilno": "currentCoil",
                "uVar3": "loopIndex",
                "uVar4": "bitIndex",
                "uVar5": "byteCount",
                "u8bytesno": "byteCount",
                "u8CopyBufferSize": "bufferSize",
                "u16StartCoil": "startCoil",
                "FUN_080008e2": "generate_modbus_response_080008e2"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "process_fc3_08000998",
            "code": "\n/* DWARF orindexgindexnal prototype: indexnt8_t  process_FC3_08000998(Modbus * modbus_instance, uindexnt16_t * register_array, uindexnt8_t register_array_size) */\n\nindexnt8_t __modbus_instancecall Modbus::process_FC3_08000998(Modbus *modbus_instance,uindexnt16_t *register_array,uindexnt8_t register_array_size)\n\n{\n  uint8_t buffer_size;\n  uindexnt8_t uVar2;\n  uindexnt8_t register_number;\n  uindexnt16_t start_address;\n  uindexnt16_t register_count;\n  uindexnt current_address;\n  uindexnt next_address;\n  uindexnt8_t copy_buffer_size;\n  uindexnt8_t start_address;\n  uindexnt8_t index;\n  \n  start_address = makeWord(modbus_instance->au8Buffer[2],modbus_instance->au8Buffer[3]);\n  register_count = makeWord(modbus_instance->au8Buffer[4],modbus_instance->au8Buffer[5]);\n  modbus_instance->au8Buffer[2] = (uint8_t)register_count << 1;\n  modbus_instance->u8BufferSindexze = '\\x03';\n  for (current_address = (uindexnt)(uint8_t)start_address; current_address < (uindexnt)(uint8_t)start_address + (uindexnt)(uint8_t)register_count;\n      current_address = current_address + 1 & 0xff) {\n    buffer_size = modbus_instance->u8BufferSindexze;\n    modbus_instance->au8Buffer[buffer_size] = (uindexnt8_t)(register_array[current_address] >> 8);\n    next_address = buffer_size + 1 & 0xff;\n    uVar2 = (uindexnt8_t)next_address;\n    modbus_instance->u8BufferSindexze = uVar2;\n    modbus_instance->au8Buffer[next_address] = *(uindexnt8_t *)(register_array + current_address);\n    modbus_instance->u8BufferSindexze = uVar2 + '\\x01';\n  }\n  uVar2 = modbus_instance->u8BufferSindexze;\n  send_transmit_buffer(modbus_instance);\n  return uVar2 + '\\x02';\n}\n\n",
            "renaming": {
                "this": "modbus_instance",
                "regs": "register_array",
                "u8size": "register_array_size",
                "byte": "uint8_t",
                "u8regsno": "register_number",
                "uVar3": "start_address",
                "uVar4": "register_count",
                "uVar5": "current_address",
                "uVar6": "next_address",
                "u8CopyBufferSize": "copy_buffer_size",
                "u8StartAdd": "start_address",
                "i": "index",
                "bVar1": "buffer_size",
                "sendTxBuffer": "send_transmit_buffer",
                "FUN_08000998": "process_fc3_08000998"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a00": {
            "entrypoint": "0x08000a00",
            "current_name": "update_coil_status_08000a00",
            "code": "\n/* DWARF original prototype: int8_t  process_FC5(Modbus * modbusInstance, uint16_t * coilStatusRegisters, uint8_t registerSize) */\n\nint8_t __modbusInstancecall Modbus::updateCoilStatus_08000a00(Modbus *modbusInstance,uint16_t *coilStatusRegisters,uint8_t registerSize)\n\n{\n  uint8_t currentBit;\n  uint16_t word;\n  uint16_t coil;\n  uint bitMask;\n  uint8_t currentRegister;\n  uint registerIndex;\n  \n  word = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n  registerIndex = ((uint)word << 0x14) >> 0x18;\n  bitMask = word & 0xf;\n  if (modbusInstance->au8Buffer[4] == 0xff) {\n    coilStatusRegisters[registerIndex] = (ushort)(1 << bitMask) | coilStatusRegisters[registerIndex];\n  }\n  else {\n    coilStatusRegisters[registerIndex] = coilStatusRegisters[registerIndex] & ~(ushort)(1 << bitMask);\n  }\n  modbusInstance->u8BufferSize = '\\x06';\n  sendTxBuffer(modbusInstance);\n  return '\\b';\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "regs": "coilStatusRegisters",
                "u8size": "registerSize",
                "u8currentBit": "currentBit",
                "uVar1": "word",
                "u16coil": "coil",
                "uVar2": "bitMask",
                "u8currentRegister": "currentRegister",
                "uVar3": "registerIndex",
                "FUN_08000a00": "update_coil_status_08000a00"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a4e": {
            "entrypoint": "0x08000a4e",
            "current_name": "update_registers_08000a4e",
            "code": "\n/* DWARF original prototype: int8_t  process_FC6(Modbus * modbus, uint16_t * registers, uint8_t size) */\n\nint8_t __modbuscall Modbus::updateRegisters_08000a4e(Modbus *modbus,uint16_t *registers,uint8_t size)\n\n{\n  uint16_t address;\n  uint16_t value;\n  uint16_t tempValue;\n  uint8_t tempAddress;\n  \n  address = makeWord(modbus->au8Buffer[2],modbus->au8Buffer[3]);\n  value = makeWord(modbus->au8Buffer[4],modbus->au8Buffer[5]);\n  registers[(byte)address] = value;\n  modbus->u8BufferSize = '\\x06';\n  sendTxBuffer(modbus);\n  return '\\b';\n}\n\n",
            "renaming": {
                "this": "modbus",
                "regs": "registers",
                "u8size": "size",
                "uVar1": "address",
                "uVar2": "value",
                "u16val": "tempValue",
                "u8add": "tempAddress",
                "FUN_08000a4e": "update_registers_08000a4e"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a7a": {
            "entrypoint": "0x08000a7a",
            "current_name": "update_coil_registers_08000a7a",
            "code": "\n/* DWARF original prototype: int8_t  process_FC15(Modbus * modbusInstance, uint16_t * coilRegisters, uint8_t registerSize) */\n\nint8_t __modbusInstancecall Modbus::updateCoilRegisters_08000a7a(Modbus *modbusInstance,uint16_t *coilRegisters,uint8_t registerSize)\n\n{\n  uint16_t startAddress;\n  uint16_t numCoils;\n  uint16_t currentCoil;\n  uint count;\n  uint bitIndex;\n  uint8_t currentBit;\n  uint bitOffset;\n  uint16_t startCoil;\n  uint8_t currentRegister;\n  uint registerIndex;\n  uint bufferIndex;\n  \n  startAddress = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n  numCoils = makeWord(modbusInstance->au8Buffer[4],modbusInstance->au8Buffer[5]);\n  bitIndex = 0;\n  bufferIndex = 7;\n  for (count = 0; count < numCoils; count = count + 1 & 0xffff) {\n    registerIndex = (count + startAddress) * 0x100000 >> 0x18;\n    bitOffset = count + startAddress & 0xf;\n    if (((int)(uint)modbusInstance->au8Buffer[bufferIndex] >> bitIndex & 1U) == 0) {\n      coilRegisters[registerIndex] = coilRegisters[registerIndex] & ~(ushort)(1 << bitOffset);\n    }\n    else {\n      coilRegisters[registerIndex] = (ushort)(1 << bitOffset) | coilRegisters[registerIndex];\n    }\n    bitIndex = bitIndex + 1 & 0xff;\n    if (7 < bitIndex) {\n      bufferIndex = bufferIndex + 1 & 0xff;\n      bitIndex = 0;\n    }\n  }\n  modbusInstance->bufferSize = '\\x06';\n  sendTxBuffer(modbusInstance);\n  return '\\b';\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "regs": "coilRegisters",
                "u8size": "registerSize",
                "uVar1": "startAddress",
                "uVar2": "numCoils",
                "u16Coilno": "currentCoil",
                "uVar3": "count",
                "uVar4": "bitIndex",
                "u8currentBit": "currentBit",
                "uVar5": "bitOffset",
                "u16StartCoil": "startCoil",
                "u8currentRegister": "currentRegister",
                "uVar6": "registerIndex",
                "uVar7": "bufferIndex",
                "u8BufferSize": "bufferSize",
                "FUN_08000a7a": "update_coil_registers_08000a7a"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b04": {
            "entrypoint": "0x08000b04",
            "current_name": "process_fc16_08000b04",
            "code": "\n/* DWARF orindexgindexnal prototype: indexnt8_t  process_FC16_08000b04(Modbus * modbusInstance, uindexnt16_t * registers, uindexnt8_t registerCount) */\n\nindexnt8_t __modbusInstancecall Modbus::process_FC16_08000b04(Modbus *modbusInstance,uindexnt16_t *registers,uindexnt8_t registerCount)\n\n{\n  byte byte1;\n  byte byte2;\n  uindexnt8_t newSize;\n  uindexnt16_t temp;\n  uindexnt16_t temporary;\n  uindexnt8_t copyBufferSize;\n  uindexnt8_t index;\n  uindexnt counter;\n  uindexnt8_t registersNumber;\n  uindexnt8_t startAddress;\n  \n  byte1 = modbusInstance->au8Buffer[3];\n  byte2 = modbusInstance->au8Buffer[5];\n  modbusInstance->au8Buffer[4] = '\\0';\n  modbusInstance->au8Buffer[5] = byte2;\n  modbusInstance->u8BufferSindexze = '\\x06';\n  for (counter = 0; counter < byte2; counter = counter + 1 & 0xff) {\n    temp = makeWord(modbusInstance->au8Buffer[counter * 2 + 7],modbusInstance->au8Buffer[counter * 2 + 8]);\n    registers[byte1 + counter] = temp;\n  }\n  newSize = modbusInstance->u8BufferSindexze;\n  sendTxBuffer(modbusInstance);\n  return newSize + '\\x02';\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "regs": "registers",
                "u8size": "registerCount",
                "bVar1": "byte1",
                "bVar2": "byte2",
                "uVar3": "newSize",
                "uVar4": "temp",
                "temp": "temporary",
                "u8CopyBufferSize": "copyBufferSize",
                "i": "index",
                "uVar5": "counter",
                "u8regsno": "registersNumber",
                "u8StartAdd": "startAddress",
                "FUN_08000b04": "process_fc16_08000b04"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b54": {
            "entrypoint": "0x08000b54",
            "current_name": "poll_modbus_registers_08000b54",
            "code": "\n/* DWARF original prototype: int8_t  poll(Modbus * modbus_instance, uint16_t * regs, uint8_t register_size) */\n\nint __modbus_instancecall Modbus::poll_modbus_registers_08000b54(Modbus *modbus_instance,pollfd *poll_file_descriptors,nfds_t number_of_fds,int timeout)\n\n{\n  uint8_t register_size;\n  uint8_t exception_result;\n  int8_t state;\n  uint8_t exception;\n  int8_t processing_result;\n  uint port_data;\n  uint32_t current_time;\n  uint8_t current_register;\n  uint unaff_r5;\n  int result;\n  \n  modbus_instance->registers = (uint16_t *)poll_file_descriptors;\n  register_size = (uint8_t)number_of_fds;\n  modbus_instance->registers_size = register_size;\n  if (modbus_instance->serial_number < 4) {\n    port_data = (*(modbus_instance->port->super_Stream).super_Print._vptr_Print[2])();\n    unaff_r5 = port_data & 0xff;\n  }\n  if (unaff_r5 == 0) {\n    result = 0;\n  }\n  else if ((int)unaff_r5 < 8) {\n    result = 0;\n  }\n  else {\n    exception_result = getRxBuffer(modbus_instance);\n    result = buffer_data_result;\n    modbus_instance->u8lastError = exception_result;\n    if (modbus_instance->au8Buffer[0] == modbus_instance->u8id) {\n      exception_result = validateRequest(modbus_instance);\n      if (exception_result == '\\0') {\n        current_time = millis();\n        modbus_instance->u32timeOut = modbus_instance->u16timeOut + current_time;\n        modbus_instance->u8lastError = '\\0';\n        switch(modbus_instance->au8Buffer[1]) {\n        case '\\x01':\n        case '\\x02':\n          processing_result = process_function_code_1(modbus_instance,(uint16_t *)poll_file_descriptors,register_size);\n          result = (int)processing_result;\n          break;\n        case '\\x03':\n        case '\\x04':\n          processing_result = process_function_code_3(modbus_instance,(uint16_t *)poll_file_descriptors,register_size);\n          result = (int)processing_result;\n          break;\n        case '\\x05':\n          processing_result = process_function_code_5(modbus_instance,(uint16_t *)poll_file_descriptors,register_size);\n          result = (int)processing_result;\n          break;\n        case '\\x06':\n          processing_result = process_function_code_6(modbus_instance,(uint16_t *)poll_file_descriptors,register_size);\n          result = (int)processing_result;\n          break;\n        case '\\x0f':\n          processing_result = process_function_code_15(modbus_instance,(uint16_t *)poll_file_descriptors,register_size);\n          result = (int)processing_result;\n          break;\n        case '\\x10':\n          processing_result = process_function_code_16(modbus_instance,(uint16_t *)poll_file_descriptors,register_size);\n          result = (int)processing_result;\n        }\n      }\n      else {\n        if (exception_result != 0xff) {\n          build_exception(modbus_instance,exception_result);\n          send_transmit_buffer(modbus_instance);\n        }\n        modbus_instance->u8lastError = exception_result;\n        result = buffer_data_result;\n      }\n    }\n    else {\n      result = 0;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "this": "modbus_instance",
                "__fds": "poll_file_descriptors",
                "__nfds": "number_of_fds",
                "__timeout": "timeout",
                "u8size": "register_size",
                "uVar1": "exception_result",
                "i8state": "state",
                "u8exception": "exception",
                "iVar2": "processing_result",
                "uVar3": "port_data",
                "uVar4": "current_time",
                "u8current": "current_register",
                "iVar5": "result",
                "au16regs": "registers",
                "u8regsize": "registers_size",
                "u8serno": "serial_number",
                "(int)(char)uVar1": "buffer_data_result",
                "process_FC1": "process_function_code_1",
                "process_FC3": "process_function_code_3",
                "process_FC5": "process_function_code_5",
                "process_FC6": "process_function_code_6",
                "process_FC15": "process_function_code_15",
                "process_FC16": "process_function_code_16",
                "buildException": "build_exception",
                "sendTxBuffer": "send_transmit_buffer",
                "FUN_08000b54": "poll_modbus_registers_08000b54"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "sendTxBuffer",
                "process_FC1",
                "process_FC3",
                "process_FC15",
                "process_FC6",
                "process_FC5",
                "getRxBuffer",
                "validateRequest",
                "buildException",
                "process_FC16",
                "millis"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c4c": {
            "entrypoint": "0x08000c4c",
            "current_name": "initialize_modbus_08000c4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeModbus_08000c4c(void)\n\n{\n  startForkserver(0);\n  ModbusLibrary::begin(&modbusSlave,0x4b00);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c4c": "initialize_modbus_08000c4c",
                "Modbus": "ModbusLibrary",
                "slave": "modbusSlave"
            },
            "calling": [
                "main"
            ],
            "called": [
                "startForkserver",
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c64": {
            "entrypoint": "0x08000c64",
            "current_name": "poll_modbus_slave_08000c64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid pollModbusSlave_08000c64(void)\n\n{\n  int inputParam;\n  \n  Modbus::poll(&modbusSlave,(pollfd *)dataBuffer,0x10,inputParam);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c64": "poll_modbus_slave_08000c64",
                "in_r3": "inputParam",
                "slave": "modbusSlave",
                "au16data": "dataBuffer"
            },
            "calling": [
                "main"
            ],
            "called": [
                "poll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c7c": {
            "entrypoint": "0x08000c7c",
            "current_name": "initialize_08000c7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_08000c7c(void)\n\n{\n  perform_static_initialization(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c7c": "initialize_08000c7c",
                "__static_initialization_and_destruction_0": "perform_static_initialization"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c8c": {
            "entrypoint": "0x08000c8c",
            "current_name": "initialize_system_08000c8c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_08000c8c(void)\n\n{\n  uint32_t hclkFreq;\n  uint32_t tmpReg;\n  uint32_t tmpReg1;\n  RCC_OscInitTypeDef rccOscInit;\n  RCC_ClkInitTypeDef rccClkInit;\n  \n  _DAT_40023840 = _DAT_40023840 | 0x10000000;\n  _DAT_40007000 = _DAT_40007000 | 0xc000;\n  rccOscInit.OscillatorType = 1;\n  rccOscInit.HSEState = 0x50000;\n  rccOscInit.PLL.PLLState = 2;\n  rccOscInit.PLL.PLLSource = 0x400000;\n  rccOscInit.PLL.PLLM = 8;\n  rccOscInit.PLL.PLLN = 0x150;\n  rccOscInit.PLL.PLLP = 2;\n  rccOscInit.PLL.PLLQ = 7;\n  HAL_RCC_OscConfig((RCC_OscInitTypeDef_conflict *)&rccOscInit);\n  HAL_PWREx_EnableOverDrive();\n  rccClkInit.ClockType = 0xf;\n  rccClkInit.SYSCLKSource = 2;\n  rccClkInit.AHBCLKDivider = 0;\n  rccClkInit.APB1CLKDivider = 0x1400;\n  rccClkInit.APB2CLKDivider = 0x1000;\n  HAL_RCC_ClockConfig((RCC_ClkInitTypeDef_conflict *)&rccClkInit,5);\n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFreq / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c8c": "initialize_system_08000c8c",
                "RCC_OscInitStruct": "rccOscInit",
                "RCC_ClkInitStruct": "rccClkInit",
                "uVar1": "hclkFreq",
                "tmpreg": "tmpReg",
                "tmpreg_1": "tmpReg1"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_PWREx_EnableOverDrive",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d3c": {
            "entrypoint": "0x08000d3c",
            "current_name": "initialize_system_08000d3c",
            "code": "\n/* WARNING: This function may have set the stack pointer */\n\nvoid initializeSystem_08000d3c(void)\n\n{\n  int index;\n  undefined4 *ptr;\n  code *jumpTable;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &completed_8667; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&_sidata + index);\n  }\n  for (ptr = &completed_8667; ptr < &_ebss; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x8000d72;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08000d72. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000d3c": "initialize_system_08000d3c",
                "iVar1": "index",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "main",
                "SystemInit",
                "__libc_init_array"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d8c": {
            "entrypoint": "0x08000d8c",
            "current_name": "infinite_loop_08000d8c",
            "code": "\nvoid infiniteLoop_08000d8c(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08000d8c": "infinite_loop_08000d8c"
            },
            "calling": [
                "CAN2_SCE_IRQHandler"
            ],
            "called": [
                "CAN2_SCE_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d8e": {
            "entrypoint": "0x08000d8e",
            "current_name": "initialize_hardware_config_08000d8e",
            "code": "\nint initializeHardwareConfig_08000d8e(EVP_PKEY_CTX *context)\n\n{\n  hw_config_init();\n  return (int)context;\n}\n\n",
            "renaming": {
                "FUN_08000d8e": "initialize_hardware_config_08000d8e",
                "ctx": "context"
            },
            "calling": [
                "premain"
            ],
            "called": [
                "hw_config_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d96": {
            "entrypoint": "0x08000d96",
            "current_name": "FUNC_08000d96",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08000d96(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000d96": "FUNC_08000d96"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000d98": {
            "entrypoint": "0x08000d98",
            "current_name": "configure_sys_tick_08000d98",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureSysTick_08000d98(uint32_t priority)\n\n{\n  uint32_t configStatus;\n  \n  configStatus = HAL_SYSTICK_Config((uint32_t)((ulonglong)SystemCoreClock / (1000 / (ulonglong)uwTickFreq))\n                            );\n  if (configStatus != 0) {\n    return HAL_ERROR;\n  }\n  if (0xf < priority) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn,priority,0);\n  uwTickPrio = priority;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08000d98": "configure_sys_tick_08000d98",
                "TickPriority": "priority",
                "uVar1": "configStatus"
            },
            "calling": [
                "HAL_Init",
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000de4": {
            "entrypoint": "0x08000de4",
            "current_name": "initialize_hal_08000de4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHALStatus initializeHAL_08000de4(void)\n\n{\n  _DAT_40023c00 = _DAT_40023c00 | 0x700;\n  setPriorityGrouping(3);\n  initializeTick(0xf);\n  initializeMsp();\n  return HALSuccess;\n}\n\n",
            "renaming": {
                "FUN_08000de4": "initialize_hal_08000de4",
                "HAL_StatusTypeDef": "HALStatus",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializeMsp",
                "HAL_OK": "HALSuccess"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_InitTick",
                "HAL_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e18": {
            "entrypoint": "0x08000e18",
            "current_name": "update_tick_value_08000e18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateTickValue_08000e18(void)\n\n{\n  currentTick = tickFrequency + currentTick;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e18": "update_tick_value_08000e18",
                "uwTick": "currentTick",
                "uwTickFreq": "tickFrequency"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e30": {
            "entrypoint": "0x08000e30",
            "current_name": "get_system_tick_08000e30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemTick_08000e30(void)\n\n{\n  return systemTick;\n}\n\n",
            "renaming": {
                "FUN_08000e30": "get_system_tick_08000e30",
                "uwTick": "systemTick"
            },
            "calling": [
                "HAL_PWREx_EnableOverDrive",
                "UART_WaitOnFlagUntilTimeout",
                "uart_debug_write",
                "GetCurrentMilli",
                "HAL_RCC_OscConfig",
                "HAL_UART_Transmit",
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e3c": {
            "entrypoint": "0x08000e3c",
            "current_name": "configure_priority_group_08000e3c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configurePriorityGroup_08000e3c(uint32_t newPriorityGroup)\n\n{\n  uint32_t registerValue;\n  \n  _DAT_e000ed0c = (newPriorityGroup & 7) << 8 | _DAT_e000ed0c & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e3c": "configure_priority_group_08000e3c",
                "PriorityGroup": "newPriorityGroup",
                "reg_value": "registerValue"
            },
            "calling": [
                "premain",
                "HAL_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e60": {
            "entrypoint": "0x08000e60",
            "current_name": "configure_irq_priority_08000e60",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureIRQPriority_08000e60(IRQn IRQn,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint irqnValue;\n  uint irqnOffset;\n  uint32_t priorityGroupTmp;\n  uint32_t subPriorityBits;\n  uint32_t preemptPriorityBits;\n  \n  irqnValue = (uint)IRQn;\n  irqnOffset = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  preemptPriorityBits = 7 - irqnOffset;\n  if (3 < preemptPriorityBits) {\n    preemptPriorityBits = 4;\n  }\n  if (irqnOffset + 4 < 7) {\n    subPriorityBits = 0;\n  }\n  else {\n    subPriorityBits = irqnOffset - 3;\n  }\n  irqnOffset = (preemptPriority & (1 << (preemptPriorityBits & 0xff)) - 1U) << (subPriorityBits & 0xff) |\n          (1 << (subPriorityBits & 0xff)) - 1U & subPriority;\n  if ((int)irqnValue < 0) {\n    *(char *)((irqnValue & 0xf) + 0xe000ed14) = (char)(irqnOffset << 4);\n  }\n  else {\n    *(char *)(irqnValue + 0xe000e400) = (char)(irqnOffset << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e60": "configure_irq_priority_08000e60",
                "IRQn_Type_conflict": "IRQn",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "uVar1": "irqnValue",
                "uVar2": "irqnOffset",
                "PriorityGroupTmp": "priorityGroupTmp",
                "SubPriorityBits": "subPriorityBits",
                "PreemptPriorityBits": "preemptPriorityBits"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback",
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ec4": {
            "entrypoint": "0x08000ec4",
            "current_name": "set_irq_priority_08000ec4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_irq_priority_08000ec4(interrupt_number_Type_conflict interrupt_number)\n\n{\n  uint irq_as_uint;\n  \n  irq_as_uint = (uint)interrupt_number;\n  if (-1 < irq_as_int) {\n    *(int *)((irq_as_uint >> 5) * 4 + -0x1fff1f00) = 1 << (irq_as_uint & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ec4": "set_irq_priority_08000ec4",
                "IRQn": "interrupt_number",
                "uVar1": "irq_as_uint",
                "(int)uVar1": "irq_as_int"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ee0": {
            "entrypoint": "0x08000ee0",
            "current_name": "initialize_ticks_08000ee0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t initializeTicks_08000ee0(uint32_t ticksCount)\n\n{\n  if (ticksCount - 1 < 0x1000000) {\n    _DAT_e000e014 = ticksCount - 1;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08000ee0": "initialize_ticks_08000ee0",
                "TicksNumb": "ticksCount"
            },
            "calling": [
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f0c": {
            "entrypoint": "0x08000f0c",
            "current_name": "initialize_irq_08000f0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIRQ_08000f0c(irqNumber_Type_conflict irqNumber)\n\n{\n  uint unsignedVar1;\n  \n  unsignedVar1 = (uint)irqNumber;\n  if (-1 < (int)unsignedVar1) {\n    *(int *)(((unsignedVar1 >> 5) + 0x60) * 4 + -0x1fff1f00) = 1 << (unsignedVar1 & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f0c": "initialize_irq_08000f0c",
                "IRQn": "irqNumber",
                "uVar1": "unsignedVar1"
            },
            "calling": [
                "USART3_IRQHandler",
                "USART6_IRQHandler",
                "UART7_IRQHandler",
                "UART4_IRQHandler",
                "UART8_IRQHandler",
                "USART1_IRQHandler",
                "USART2_IRQHandler",
                "UART5_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f2c": {
            "entrypoint": "0x08000f2c",
            "current_name": "set_clk_source_08000f2c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid set_CLKSource_08000f2c(uint32_t source)\n\n{\n  if (source != 4) {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n    return;\n  }\n  _DAT_e000e010 = _DAT_e000e010 | 4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f2c": "set_clk_source_08000f2c",
                "CLKSource": "source"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f4c": {
            "entrypoint": "0x08000f4c",
            "current_name": "FUNC_08000f4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08000f4c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f4c": "FUNC_08000f4c"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000f4e": {
            "entrypoint": "0x08000f4e",
            "current_name": "handle_sys_tick_callback_08000f4e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickCallback_08000f4e(void)\n\n{\n  HAL_SYSTICK_Callback();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f4e": "handle_sys_tick_callback_08000f4e"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f56": {
            "entrypoint": "0x08000f56",
            "current_name": "initialize_dac_08000f56",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatusTypeDef initializeDAC_08000f56(DAC_HandleTypeDef *dacHandle)\n\n{\n  if (dacHandle != (DAC_HandleTypeDef *)0x0) {\n    dacHandle->State = DAC_STATE_BUSY;\n    deinitializeDAC_08000f56(dacHandle);\n    dacHandle->ErrorCode = 0;\n    dacHandle->State = DAC_STATE_RESET;\n    dacHandle->Lock = UNLOCKED;\n    return OK;\n  }\n  return ERROR;\n}\n\n",
            "renaming": {
                "FUN_08000f56": "initialize_dac_08000f56",
                "hdac": "dacHandle",
                "HAL_StatusTypeDef": "StatusTypeDef",
                "HAL_DAC_STATE_BUSY": "DAC_STATE_BUSY",
                "HAL_DAC_MspDeInit": "deinitializeDAC",
                "HAL_DAC_STATE_RESET": "DAC_STATE_RESET",
                "HAL_UNLOCKED": "UNLOCKED",
                "HAL_OK": "OK",
                "HAL_ERROR": "ERROR"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [
                "HAL_DAC_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f72": {
            "entrypoint": "0x08000f72",
            "current_name": "disable_dac_channel_08000f72",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef disableDACChannel_08000f72(DAC_HandleTypeDef *DAC_handle,uint32_t channel)\n\n{\n  DAC_handle->DAC_instance->control_register = DAC_handle->DAC_instance->control_register & ~(1 << (channel & 0xff));\n  DAC_handle->DAC_state = HAL_DAC_STATE_READY;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08000f72": "disable_dac_channel_08000f72",
                "hdac": "DAC_handle",
                "Channel": "channel",
                "Instance": "DAC_instance",
                "CR": "control_register",
                "State": "DAC_state"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f8c": {
            "entrypoint": "0x08000f8c",
            "current_name": "abort_dma_08000f8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef abortDMA_08000f8c(DMA_HandleTypeDef *dmaHandle)\n\n{\n  if (dmaHandle->State != DMA_STATE_BUSY) {\n    dmaHandle->ErrorCode = 0x80;\n    return ERROR;\n  }\n  dmaHandle->State = DMA_STATE_ABORT;\n  dmaHandle->Instance->CR = dmaHandle->Instance->CR & 0xfffffffe;\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_08000f8c": "abort_dma_08000f8c",
                "hdma": "dmaHandle",
                "HAL_DMA_STATE_BUSY": "DMA_STATE_BUSY",
                "HAL_DMA_STATE_ABORT": "DMA_STATE_ABORT",
                "HAL_ERROR": "ERROR",
                "HAL_OK": "OK"
            },
            "calling": [
                "I2C_ITError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fb4": {
            "entrypoint": "0x08000fb4",
            "current_name": "initialize_gpio_08000fb4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeGPIO_08000fb4(GPIOType *gpio,GPIOInitType *gpioInit)\n\n{\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint32_t temp6;\n  int index;\n  uint temp8;\n  int index2;\n  uint32_t tempRegister;\n  \n  for (temp3 = 0; temp3 < 0x10; temp3 = temp3 + 1) {\n    temp2 = 1 << (temp3 & 0xff);\n    temp4 = temp2 & gpioInit->Pin;\n    temp1 = _DAT_40013c0c;\n    if (temp2 == temp4) {\n      if ((gpioInit->Mode == 2) || (gpioInit->Mode == 0x12)) {\n        index2 = (temp3 & 7) << 2;\n        gpio->AFR[temp3 >> 3] =\n             gpio->AFR[temp3 >> 3] & ~(0xf << index2) | gpioInit->Alternate << index2;\n      }\n      temp8 = temp3 << 1;\n      temp1 = ~(3 << (temp8 & 0xff));\n      gpio->MODER = gpio->MODER & temp1 | (gpioInit->Mode & 3) << (temp8 & 0xff);\n      temp6 = gpioInit->Mode;\n      if (((temp6 - 1 < 2) || (temp6 == 0x11)) || (temp6 == 0x12)) {\n        gpio->OSPEEDR = gpio->OSPEEDR & temp1 | gpioInit->Speed << (temp8 & 0xff);\n        gpio->OTYPER =\n             gpio->OTYPER & ~temp2 | ((gpioInit->Mode << 0x1b) >> 0x1f) << (temp3 & 0xff);\n      }\n      gpio->PUPDR = temp1 & gpio->PUPDR | gpioInit->Pull << (temp8 & 0xff);\n      temp1 = _DAT_40013c0c;\n      if ((gpioInit->Mode & 0x10000000) != 0) {\n        _DAT_40023844 = _DAT_40023844 | 0x4000;\n        index2 = (temp3 & 3) << 2;\n        if (gpio == (GPIOType *)0x40020000) {\n          index = 0;\n        }\n        else if (gpio == (GPIOType *)0x40020400) {\n          index = 1;\n        }\n        else if (gpio == (GPIOType *)0x40020800) {\n          index = 2;\n        }\n        else if (gpio == (GPIOType *)0x40020c00) {\n          index = 3;\n        }\n        else if (gpio == (GPIOType *)0x40021000) {\n          index = 4;\n        }\n        else if (gpio == (GPIOType *)0x40021400) {\n          index = 5;\n        }\n        else if (gpio == (GPIOType *)0x40021800) {\n          index = 6;\n        }\n        else if (gpio == (GPIOType *)0x40021c00) {\n          index = 7;\n        }\n        else if (gpio == (GPIOType *)0x40022000) {\n          index = 8;\n        }\n        else if (gpio == (GPIOType *)0x40022400) {\n          index = 9;\n        }\n        else {\n          index = 10;\n        }\n        *(uint *)(((temp3 >> 2) + 2) * 4 + 0x40013800) =\n             *(uint *)(((temp3 >> 2) + 2) * 4 + 0x40013800) & ~(0xf << index2) | index << index2;\n        temp1 = ~temp4;\n        temp2 = _DAT_40013c00 & temp1;\n        if ((gpioInit->Mode & 0x10000) != 0) {\n          temp2 = temp4 | _DAT_40013c00;\n        }\n        temp8 = temp1 & _DAT_40013c04;\n        if ((gpioInit->Mode & 0x20000) != 0) {\n          temp8 = temp4 | _DAT_40013c04;\n        }\n        temp5 = temp1 & _DAT_40013c08;\n        if ((gpioInit->Mode & 0x100000) != 0) {\n          temp5 = temp4 | _DAT_40013c08;\n        }\n        _DAT_40013c00 = temp2;\n        _DAT_40013c04 = temp8;\n        _DAT_40013c08 = temp5;\n        temp1 = temp1 & _DAT_40013c0c;\n        if ((gpioInit->Mode & 0x200000) != 0) {\n          temp1 = temp4 | _DAT_40013c0c;\n        }\n      }\n    }\n    _DAT_40013c0c = temp1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fb4": "initialize_gpio_08000fb4",
                "GPIO_TypeDef": "GPIOType",
                "GPIO_InitTypeDef": "GPIOInitType",
                "GPIOx": "gpio",
                "GPIO_Init": "gpioInit",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "uVar6": "temp6",
                "iVar7": "index",
                "uVar8": "temp8",
                "iVar9": "index2",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "digital_io_init",
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001198": {
            "entrypoint": "0x08001198",
            "current_name": "set_pin_state_08001198",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinState_08001198(GPIO_TypeDef *port,uint16_t pin,pinState state)\n\n{\n  if (state == GPIO_PIN_RESET) {\n    port->BSRR = (uint)pin << 0x10;\n    return;\n  }\n  port->BSRR = (uint)pin;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001198": "set_pin_state_08001198",
                "GPIOx": "port",
                "GPIO_Pin": "pin",
                "PinState": "state"
            },
            "calling": [
                "digital_io_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011a4": {
            "entrypoint": "0x080011a4",
            "current_name": "handle_gpio_interrupt_080011a4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_gpio_interrupt_080011a4(uint16_t pin)\n\n{\n  if ((_DAT_40013c14 & pin) != 0) {\n    _DAT_40013c14 = (uint)pin;\n    HAL_GPIO_EXTI_Callback(pin);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080011a4": "handle_gpio_interrupt_080011a4",
                "GPIO_Pin": "pin"
            },
            "calling": [
                "EXTI15_10_IRQHandler",
                "EXTI1_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI9_5_IRQHandler",
                "EXTI0_IRQHandler",
                "EXTI2_IRQHandler",
                "EXTI4_IRQHandler"
            ],
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011c0": {
            "entrypoint": "0x080011c0",
            "current_name": "handle_i2_c_event_080011c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CEvent_080011c0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  if (i2cHandle->Mode == I2C_MODE_MEMORY) {\n    if (i2cHandle->EventCount == 0) {\n      i2cHandle->Instance->DR = i2cHandle->Devaddress & 0xfe;\n    }\n    else {\n      i2cHandle->Instance->DR = i2cHandle->Devaddress & 0xff | 1;\n    }\n  }\n  else if ((i2cHandle->Init).AddressingMode == 0x4000) {\n    if (i2cHandle->State == I2C_STATE_BUSY_TRANSMITTING) {\n      i2cHandle->Instance->DR = i2cHandle->Devaddress & 0xfe;\n    }\n    else {\n      i2cHandle->Instance->DR = i2cHandle->Devaddress & 0xff | 1;\n    }\n  }\n  else if (i2cHandle->EventCount == 0) {\n    i2cHandle->Instance->DR = (i2cHandle->Devaddress << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (i2cHandle->EventCount == 1) {\n    i2cHandle->Instance->DR = (i2cHandle->Devaddress << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return I2C_STATUS_OK;\n}\n\n",
            "renaming": {
                "FUN_080011c0": "handle_i2_c_event_080011c0",
                "hi2c": "i2cHandle",
                "HAL_I2C_MODE_MEM": "I2C_MODE_MEMORY",
                "HAL_I2C_STATE_BUSY_TX": "I2C_STATE_BUSY_TRANSMITTING",
                "HAL_OK": "I2C_STATUS_OK"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800124a": {
            "entrypoint": "0x0800124a",
            "current_name": "set_i2_c_device_address_0800124a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef set_I2C_device_address_0800124a(I2C_HandleTypeDef *I2C_handle)\n\n{\n  I2C_handle->I2C_instance->data_register = I2C_handle->device_address & 0xff;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800124a": "set_i2_c_device_address_0800124a",
                "hi2c": "I2C_handle",
                "Instance": "I2C_instance",
                "DR": "data_register",
                "Devaddress": "device_address"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001256": {
            "entrypoint": "0x08001256",
            "current_name": "update_i2_c_state_08001256",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef updateI2CState_08001256(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t tempVar1;\n  I2C_TypeDef *i2cInstance;\n  uint32_t previousState;\n  uint32_t tempReg;\n  uint32_t tempReg1;\n  uint32_t tempReg2;\n  uint32_t tempReg3;\n  uint32_t tempReg4;\n  uint32_t tempReg5;\n  uint32_t tempReg6;\n  uint32_t tempReg7;\n  uint32_t tempReg8;\n  uint32_t tempReg9;\n  \n  tempVar1 = i2cHandle->XferOptions;\n  if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) &&\n     ((i2cHandle->EventCount != 0 || (i2cHandle->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((i2cHandle->EventCount == 0) && ((i2cHandle->Init).AddressingMode == 0xc000)) {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n      i2cHandle->EventCount = i2cHandle->EventCount + 1;\n    }\n    else {\n      if (i2cHandle->XferCount == 0) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      }\n      else if (i2cHandle->XferCount == 1) {\n        if (tempVar1 == 0xffff0000) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cInstance = i2cHandle->Instance;\n          if ((i2cInstance->CR2 & 0x800) == 0) {\n            i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n          }\n          else {\n            i2cInstance->CR1 = i2cInstance->CR1 & 0xfffffbff;\n          }\n        }\n        else if (((tempVar1 == 4) || (tempVar1 == 8)) || (i2cHandle->PreviousState == 0x12)) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        }\n        else if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n      }\n      else if (i2cHandle->XferCount == 2) {\n        if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x800;\n        }\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      else {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      i2cHandle->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001256": "update_i2_c_state_08001256",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "uVar1": "tempVar1",
                "pIVar2": "i2cInstance",
                "Prev_State": "previousState",
                "tmpreg": "tempReg",
                "tmpreg_1": "tempReg1",
                "tmpreg_2": "tempReg2",
                "tmpreg_3": "tempReg3",
                "tmpreg_4": "tempReg4",
                "tmpreg_5": "tempReg5",
                "tmpreg_6": "tempReg6",
                "tmpreg_7": "tempReg7",
                "tmpreg_8": "tempReg8",
                "tmpreg_9": "tempReg9"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001420": {
            "entrypoint": "0x08001420",
            "current_name": "transfer_data_08001420",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef transferData_08001420(I2C_HandleTypeDef *i2cStruct)\n\n{\n  byte *pbVar1;\n  \n  if (i2cStruct->transferCount != 0) {\n    pbVar1 = i2cStruct->bufferPointer;\n    i2cStruct->bufferPointer = pbVar1 + 1;\n    i2cStruct->i2cInstance->dataRegister = (uint)*pbVar1;\n    i2cStruct->transferCount = i2cStruct->transferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001420": "transfer_data_08001420",
                "hi2c": "i2cStruct",
                "XferCount": "transferCount",
                "pBuffPtr": "bufferPointer",
                "Instance": "i2cInstance",
                "DR": "dataRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001440": {
            "entrypoint": "0x08001440",
            "current_name": "read_data_from_i2_c_08001440",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef read_data_from_I2C_08001440(I2C_HandleTypeDef *I2C_handle)\n\n{\n  uint8_t *byte_ptr;\n  \n  if (I2C_handle->transfer_count != 0) {\n    byte_ptr = I2C_handle->buffer_pointer;\n    I2C_handle->buffer_pointer = byte_ptr + 1;\n    *byte_ptr = (uint8_t)I2C_handle->I2C_instance->DR;\n    I2C_handle->transfer_count = I2C_handle->transfer_count - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001440": "read_data_from_i2_c_08001440",
                "hi2c": "I2C_handle",
                "puVar1": "byte_ptr",
                "XferCount": "transfer_count",
                "pBuffPtr": "buffer_pointer",
                "Instance": "I2C_instance"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001460": {
            "entrypoint": "0x08001460",
            "current_name": "set_i2_c_listen_mode_08001460",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nsetI2CListenMode_08001460(I2C_HandleTypeDef *i2cHandle,uint8_t *dataBuffer,uint16_t dataSize,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef status;\n  I2C_TypeDef *i2cInstance;\n  uint32_t temporaryRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (dataBuffer == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (dataSize == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = dataBuffer;\n      i2cHandle->XferCount = dataSize;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->XferdataSize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001460": "set_i2_c_listen_mode_08001460",
                "hi2c": "i2cHandle",
                "pData": "dataBuffer",
                "Size": "dataSize",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014ec": {
            "entrypoint": "0x080014ec",
            "current_name": "set_i2_c_state_for_listen_080014ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nsetI2CStateForListen_080014ec(I2C_HandleTypeDef *i2cHandle,uint8_t *dataPtr,uint16_t dataSize,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef status;\n  I2C_TypeDef *i2cInstance;\n  uint32_t temporaryRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (dataPtr == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (dataSize == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = dataPtr;\n      i2cHandle->XferCount = dataSize;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->XferdataSize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080014ec": "set_i2_c_state_for_listen_080014ec",
                "hi2c": "i2cHandle",
                "pData": "dataPtr",
                "Size": "dataSize",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001578": {
            "entrypoint": "0x08001578",
            "current_name": "configure_i2_c_and_enable_08001578",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureI2CAndEnable_08001578(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2C_TypeDef *i2cInstance;\n  \n  if (i2cHandle->State != HAL_I2C_READY) {\n    return HAL_ERROR_BUSY;\n  }\n  i2cHandle->State = HAL_I2C_LISTEN;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR1 & 1) == 0) {\n    i2cInstance->CR1 = i2cInstance->CR1 | 1;\n  }\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n  i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x300;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001578": "configure_i2_c_and_enable_08001578",
                "hi2c": "i2cHandle",
                "HAL_I2C_STATE_READY": "HAL_I2C_READY",
                "HAL_BUSY": "HAL_ERROR_BUSY",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_LISTEN",
                "pIVar1": "i2cInstance"
            },
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b6": {
            "entrypoint": "0x080015b6",
            "current_name": "FUNC_080015b6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080015b6(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b6": "FUNC_080015b6"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015b8": {
            "entrypoint": "0x080015b8",
            "current_name": "FUNC_080015b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080015b8(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b8": "FUNC_080015b8"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015ba": {
            "entrypoint": "0x080015ba",
            "current_name": "FUNC_080015ba",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080015ba(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015ba": "FUNC_080015ba"
            },
            "calling": [
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_AF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015bc": {
            "entrypoint": "0x080015bc",
            "current_name": "transfer_data_080015bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef transferData_080015bc(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef currentI2CState;\n  byte *bufferPointer;\n  \n  currentI2CState = i2cHandle->State;\n  if (i2cHandle->transferCount != 0) {\n    bufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPointer + 1;\n    i2cHandle->Instance->DR = (uint)*bufferPointer;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    if ((i2cHandle->transferCount == 0) && (currentI2CState == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      i2cHandle->PreviousState = 0x21;\n      i2cHandle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(i2cHandle);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080015bc": "transfer_data_080015bc",
                "hi2c": "i2cHandle",
                "HVar1": "currentI2CState",
                "pbVar2": "bufferPointer",
                "XferCount": "transferCount"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800160c": {
            "entrypoint": "0x0800160c",
            "current_name": "FUNC_0800160c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800160c(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800160c": "FUNC_0800160c"
            },
            "calling": [
                "I2C_Slave_STOPF",
                "I2C_SlaveReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800160e": {
            "entrypoint": "0x0800160e",
            "current_name": "transfer_data_0800160e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef transferData_0800160e(I2C_HandleTypeDef *i2cHandler)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  uint8_t *bufferPointer;\n  \n  currentState = i2cHandler->State;\n  if (i2cHandler->transferCount != 0) {\n    bufferPointer = i2cHandler->pBuffPtr;\n    i2cHandler->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandler->i2cInstance->dataRegister;\n    i2cHandler->transferCount = i2cHandler->transferCount - 1;\n    if ((i2cHandler->transferCount == 0) && (currentState == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2cHandler->i2cInstance->controlRegister2 = i2cHandler->i2cInstance->controlRegister2 & 0xfffffbff;\n      i2cHandler->previousState = 0x22;\n      i2cHandler->State = HAL_I2C_STATE_LISTEN;\n      i2cSlaveRxCpltCallback(i2cHandler);\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800160e": "transfer_data_0800160e",
                "hi2c": "i2cHandler",
                "HVar1": "currentState",
                "puVar2": "bufferPointer",
                "XferCount": "transferCount",
                "Instance": "i2cInstance",
                "DR": "dataRegister",
                "CR2": "controlRegister2",
                "PreviousState": "previousState",
                "HAL_I2C_SlaveRxCpltCallback": "i2cSlaveRxCpltCallback"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800165a": {
            "entrypoint": "0x0800165a",
            "current_name": "handle_i2_c_address_match_0800165a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CAddressMatch_0800165a(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint16_t addressMatchCode;\n  \n  if ((i2cHandle->Instance->SR2 & 0x80) == 0) {\n    addressMatchCode = *(uint16_t *)&(i2cHandle->Init).OwnAddress1;\n  }\n  else {\n    addressMatchCode = *(uint16_t *)&(i2cHandle->Init).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(i2cHandle,(i2cHandle->Instance->SR2 & 4) == 0,addressMatchCode);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800165a": "handle_i2_c_address_match_0800165a",
                "hi2c": "i2cHandle",
                "AddrMatchCode": "addressMatchCode"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001684": {
            "entrypoint": "0x08001684",
            "current_name": "handle_i2_c_state_transition_08001684",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CStateTransition_08001684(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t xferOptions;\n  uint32_t currentState;\n  \n  if (((i2cHandle->XferOptions == 4) || (i2cHandle->XferOptions == 8)) &&\n     (i2cHandle->State == HAL_I2C_STATE_LISTEN)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandle);\n  }\n  else if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->PreviousState = 0x21;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback(i2cHandle);\n  }\n  else {\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001684": "handle_i2_c_state_transition_08001684",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "xferOptions",
                "CurrentState": "currentState"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001718": {
            "entrypoint": "0x08001718",
            "current_name": "FUNC_08001718",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001718(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001718": "FUNC_08001718"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800171a": {
            "entrypoint": "0x0800171a",
            "current_name": "handle_i2_c_transfer_0800171a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CTransfer_0800171a(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  uint32_t currentI2CState;\n  byte *bufferPointer;\n  uint32_t currentTransferOptions;\n  uint32_t transferSize;\n  \n  currentState = i2cHandle->State;\n  transferSize = i2cHandle->XferOptions;\n  if ((i2cHandle->XferSize == 0) && (currentState == I2C_STATE_BUSY_TX)) {\n    if ((transferSize == 4) || ((transferSize == 8 || (transferSize == 0xffff0000)))) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = I2C_STATE_READY;\n      if (i2cHandle->Mode == I2C_MODE_MEM) {\n        i2cHandle->Mode = I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(i2cHandle);\n      }\n      else {\n        i2cHandle->Mode = I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n      i2cHandle->PreviousState = 0x11;\n      i2cHandle->Mode = I2C_MODE_NONE;\n      i2cHandle->State = I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(i2cHandle);\n    }\n  }\n  else if ((currentState == I2C_STATE_BUSY_TX) ||\n          ((i2cHandle->Mode == I2C_MODE_MEM && (currentState == HAL_I2C_STATE_BUSY_RX)))) {\n    if (i2cHandle->XferCount == 0) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n    }\n    else if (i2cHandle->Mode == I2C_MODE_MEM) {\n      if (i2cHandle->EventCount == 0) {\n        if (i2cHandle->MemaddSize == 1) {\n          i2cHandle->Instance->DR = i2cHandle->Memaddress & 0xff;\n          i2cHandle->EventCount = i2cHandle->EventCount + 2;\n        }\n        else {\n          i2cHandle->Instance->DR = (i2cHandle->Memaddress << 0x10) >> 0x18;\n          i2cHandle->EventCount = i2cHandle->EventCount + 1;\n        }\n      }\n      else if (i2cHandle->EventCount == 1) {\n        i2cHandle->Instance->DR = i2cHandle->Memaddress & 0xff;\n        i2cHandle->EventCount = i2cHandle->EventCount + 1;\n      }\n      else if (i2cHandle->EventCount == 2) {\n        if (i2cHandle->State == HAL_I2C_STATE_BUSY_RX) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n        }\n        else if (i2cHandle->State == I2C_STATE_BUSY_TX) {\n          bufferPointer = i2cHandle->pBuffPtr;\n          i2cHandle->pBuffPtr = bufferPointer + 1;\n          i2cHandle->Instance->DR = (uint)*bufferPointer;\n          i2cHandle->XferCount = i2cHandle->XferCount - 1;\n        }\n      }\n    }\n    else {\n      bufferPointer = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPointer + 1;\n      i2cHandle->Instance->DR = (uint)*bufferPointer;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800171a": "handle_i2_c_transfer_0800171a",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "CurrentState": "currentI2CState",
                "pbVar2": "bufferPointer",
                "CurrentXferOptions": "currentTransferOptions",
                "uVar3": "transferSize",
                "HAL_I2C_STATE_BUSY_TX": "I2C_STATE_BUSY_TX",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_I2C_MODE_MEM": "I2C_MODE_MEM",
                "HAL_I2C_MODE_NONE": "I2C_MODE_NONE"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001864": {
            "entrypoint": "0x08001864",
            "current_name": "handle_i2_c_transfer_08001864",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CTransfer_08001864(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t transferOptions;\n  uint32_t currentTransferOptions;\n  byte *bufferPtr;\n  \n  transferOptions = i2cHandle->XferOptions;\n  if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    if (i2cHandle->XferCount == 0) {\n      if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        i2cHandle->PreviousState = 0;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(i2cHandle);\n        }\n        else {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(i2cHandle);\n        }\n      }\n      else {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->PreviousState = 0x11;\n        i2cHandle->Mode = HAL_I2C_MODE_NONE;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      bufferPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPtr + 1;\n      i2cHandle->Instance->DR = (uint)*bufferPtr;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001864": "handle_i2_c_transfer_08001864",
                "hi2c": "i2cHandle",
                "uVar1": "transferOptions",
                "CurrentXferOptions": "currentTransferOptions",
                "pbVar2": "bufferPtr"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001902": {
            "entrypoint": "0x08001902",
            "current_name": "FUNC_08001902",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001902(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001902": "FUNC_08001902"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001904": {
            "entrypoint": "0x08001904",
            "current_name": "handle_i2_c_rx_transfer_08001904",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatus handleI2CRxTransfer_08001904(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint8_t *bufferPtr;\n  \n  if (i2cHandle->State == I2C_STATE_BUSY_RX) {\n    if (i2cHandle->XferCount < 4) {\n      if (i2cHandle->XferCount < 2) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        bufferPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = bufferPtr + 1;\n        *bufferPtr = (uint8_t)i2cHandle->Instance->DR;\n        i2cHandle->XferCount = i2cHandle->XferCount - 1;\n        i2cHandle->State = I2C_STATE_READY;\n        i2cHandle->PreviousState = 0;\n        if (i2cHandle->Mode == I2C_MODE_MEM) {\n          i2cHandle->Mode = I2C_MODE_NONE;\n          I2C_MemRxCpltCallback(i2cHandle);\n        }\n        else {\n          i2cHandle->Mode = I2C_MODE_NONE;\n          I2C_MasterRxCpltCallback(i2cHandle);\n        }\n      }\n    }\n    else {\n      bufferPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPtr + 1;\n      *bufferPtr = (uint8_t)i2cHandle->Instance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n      if (i2cHandle->XferCount == 3) {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      }\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001904": "handle_i2_c_rx_transfer_08001904",
                "hi2c": "i2cHandle",
                "puVar1": "bufferPtr",
                "HAL_StatusTypeDef": "Status",
                "HAL_I2C_STATE_BUSY_RX": "I2C_STATE_BUSY_RX",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_I2C_MODE_MEM": "I2C_MODE_MEM",
                "HAL_I2C_MODE_NONE": "I2C_MODE_NONE",
                "HAL_I2C_MasterRxCpltCallback": "I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback": "I2C_MemRxCpltCallback"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080019a0": {
            "entrypoint": "0x080019a0",
            "current_name": "process_i2_c_data_080019a0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef processI2CData_080019a0(I2C_HandleTypeDef *i2cHandler)\n\n{\n  uint32_t currentTransferOptions;\n  uint8_t *bufferPointer;\n  \n  if (i2cHandler->transferCount == 4) {\n    i2cHandler->i2cInstance->controlRegister2 = i2cHandler->i2cInstance->controlRegister2 & 0xfffffbff;\n    bufferPointer = i2cHandler->EWJdataRegisterKGIJI;\n    i2cHandler->EWJdataRegisterKGIJI = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandler->i2cInstance->dataRegister;\n    i2cHandler->transferCount = i2cHandler->transferCount - 1;\n  }\n  else if (i2cHandler->transferCount == 3) {\n    i2cHandler->i2cInstance->controlRegister2 = i2cHandler->i2cInstance->controlRegister2 & 0xfffffbff;\n    i2cHandler->i2cInstance->controlRegister1 = i2cHandler->i2cInstance->controlRegister1 & 0xfffffbff;\n    bufferPointer = i2cHandler->EWJdataRegisterKGIJI;\n    i2cHandler->EWJdataRegisterKGIJI = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandler->i2cInstance->dataRegister;\n    i2cHandler->transferCount = i2cHandler->transferCount - 1;\n  }\n  else if (i2cHandler->transferCount == 2) {\n    if (i2cHandler->ZGNdataRegisterOXWMF - 1 < 2) {\n      i2cHandler->i2cInstance->controlRegister1 = i2cHandler->i2cInstance->controlRegister1 & 0xfffffbff;\n      i2cHandler->i2cInstance->controlRegister1 = i2cHandler->i2cInstance->controlRegister1 | 0x100;\n    }\n    else {\n      i2cHandler->i2cInstance->controlRegister1 = i2cHandler->i2cInstance->controlRegister1 | 0x200;\n    }\n    bufferPointer = i2cHandler->EWJdataRegisterKGIJI;\n    i2cHandler->EWJdataRegisterKGIJI = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandler->i2cInstance->dataRegister;\n    i2cHandler->transferCount = i2cHandler->transferCount - 1;\n    bufferPointer = i2cHandler->EWJdataRegisterKGIJI;\n    i2cHandler->EWJdataRegisterKGIJI = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandler->i2cInstance->dataRegister;\n    i2cHandler->transferCount = i2cHandler->transferCount - 1;\n    i2cHandler->i2cInstance->controlRegister2 = i2cHandler->i2cInstance->controlRegister2 & 0xfffffcff;\n    i2cHandler->GLHDXSXdataRegisterC = HAL_I2C_STATE_READY;\n    i2cHandler->previousState = 0;\n    if (i2cHandler->mode == HAL_I2C_MODE_MEM) {\n      i2cHandler->mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MemRxCpltCallback(i2cHandler);\n    }\n    else {\n      i2cHandler->mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MasterRxCpltCallback(i2cHandler);\n    }\n  }\n  else {\n    bufferPointer = i2cHandler->EWJdataRegisterKGIJI;\n    i2cHandler->EWJdataRegisterKGIJI = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandler->i2cInstance->dataRegister;\n    i2cHandler->transferCount = i2cHandler->transferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080019a0": "process_i2_c_data_080019a0",
                "hi2c": "i2cHandler",
                "CurrentXferOptions": "currentTransferOptions",
                "puVar1": "bufferPointer",
                "XferCount": "transferCount",
                "Instance": "i2cInstance",
                "CR2": "controlRegister2",
                "pBuffPtr": "dataBufferPointer",
                "DR": "dataRegister",
                "CR1": "controlRegister1",
                "XferOptions": "transferOptions",
                "State": "currentState",
                "PreviousState": "previousState",
                "Mode": "mode"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001aac": {
            "entrypoint": "0x08001aac",
            "current_name": "FUNC_08001aac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001aac(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001aac": "FUNC_08001aac"
            },
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "reset_i2_c_state_08001ab0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetI2CState_08001ab0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t *dataPtr;\n  I2C_TypeDef *i2cInstance;\n  \n  if (i2cHandle->State - 0x29 < 2) {\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((i2cHandle->State != HAL_I2C_STATE_ABORT) && ((i2cHandle->Instance->CR2 & 0x800) == 0)) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n    }\n    i2cHandle->PreviousState = 0;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  }\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) == 0) {\n    if (i2cHandle->State == HAL_I2C_STATE_ABORT) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->ErrorCode = 0;\n      if ((i2cInstance->SR1 & 0x40) != 0) {\n        dataPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = dataPtr + 1;\n        *dataPtr = (uint8_t)i2cInstance->DR;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(i2cHandle);\n    }\n    else {\n      if ((i2cInstance->SR1 & 0x40) != 0) {\n        dataPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = dataPtr + 1;\n        *dataPtr = (uint8_t)i2cInstance->DR;\n      }\n      HAL_I2C_ErrorCallback(i2cHandle);\n    }\n  }\n  else {\n    i2cInstance->CR2 = i2cInstance->CR2 & 0xfffff7ff;\n    if (i2cHandle->hdmatx->State == HAL_DMA_STATE_READY) {\n      i2cHandle->hdmarx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->hdmarx);\n      if (status != HAL_OK) {\n        if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n          dataPtr = i2cHandle->pBuffPtr;\n          i2cHandle->pBuffPtr = dataPtr + 1;\n          *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n        }\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        (*i2cHandle->hdmarx->XferAbortCallback)(i2cHandle->hdmarx);\n      }\n    }\n    else {\n      i2cHandle->hdmatx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->hdmatx);\n      if (status != HAL_OK) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        (*i2cHandle->hdmatx->XferAbortCallback)(i2cHandle->hdmatx);\n      }\n    }\n  }\n  if ((i2cHandle->State == HAL_I2C_STATE_LISTEN) && ((i2cHandle->ErrorCode & 4) != 0)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "reset_i2_c_state_08001ab0",
                "hi2c": "i2cHandle",
                "HVar1": "status",
                "puVar2": "dataPtr",
                "pIVar3": "i2cInstance"
            },
            "calling": [
                "I2C_Slave_STOPF",
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback",
                "HAL_DMA_Abort_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001bfc": {
            "entrypoint": "0x08001bfc",
            "current_name": "process_i2_c_data_08001bfc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef processI2CData_08001bfc(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  I2C_TypeDef *i2cInstance;\n  uint8_t *bufferPtr;\n  uint32_t currentPinState;\n  uint32_t temporaryRegister;\n  \n  currentState = i2cHandle->State;\n  i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) != 0) {\n    if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) || (i2cHandle->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmarx->Instance->NDTR;\n    }\n    else {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmatx->Instance->NDTR;\n    }\n  }\n  if (i2cHandle->XferCount != 0) {\n    if ((i2cInstance->SR1 & 4) != 0) {\n      bufferPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPtr + 1;\n      *bufferPtr = (uint8_t)i2cInstance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n      bufferPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPtr + 1;\n      *bufferPtr = (uint8_t)i2cHandle->Instance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n  }\n  if (i2cHandle->ErrorCode == 0) {\n    if (((currentState == HAL_I2C_STATE_LISTEN) || (currentState == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (currentState == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2cHandle->XferOptions = 0xffff0000;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(i2cHandle);\n    }\n    else if ((i2cHandle->PreviousState == 0x22) || (currentState == HAL_I2C_STATE_BUSY_RX)) {\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  else {\n    I2C_ITError(i2cHandle);\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001bfc": "process_i2_c_data_08001bfc",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "pIVar2": "i2cInstance",
                "puVar3": "bufferPtr",
                "CurrentState": "currentPinState",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveRxCpltCallback",
                "I2C_ITError"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001d00": {
            "entrypoint": "0x08001d00",
            "current_name": "handle_i2_c_interrupt_08001d00",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CInterrupt_08001d00(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2C_TypeDef *i2cInstance;\n  uint32_t currentMode;\n  uint sr1Flags;\n  uint32_t sr1InterruptFlags;\n  uint cr2Flags;\n  uint32_t interruptSources;\n  uint sr2Flags;\n  uint32_t sr2itflags;\n  \n  i2cInstance = i2cHandle->Instance;\n  sr2Flags = i2cInstance->SR2;\n  sr1Flags = i2cInstance->SR1;\n  cr2Flags = i2cInstance->CR2;\n  if ((i2cHandle->Mode == HAL_I2C_MODE_MASTER) || (i2cHandle->Mode == HAL_I2C_MODE_MEM)) {\n    if (((sr1Flags & 0x10001) == 0) || ((cr2Flags & 0x200) == 0)) {\n      if (((sr1Flags & 0x10008) == 0) || ((cr2Flags & 0x200) == 0)) {\n        if (((sr1Flags & 0x10002) != 0) && ((cr2Flags & 0x200) != 0)) {\n          I2C_Master_ADDR(i2cHandle);\n        }\n      }\n      else {\n        I2C_Master_ADD10(i2cHandle);\n      }\n    }\n    else {\n      I2C_Master_SB(i2cHandle);\n    }\n    if ((sr2Flags & 0x100004) == 0) {\n      if ((((sr1Flags & 0x10040) != 0) && ((cr2Flags & 0x400) != 0)) && ((sr1Flags & 0x10004) == 0)) {\n        I2C_MasterReceive_RXNE(i2cHandle);\n        return;\n      }\n      if (((sr1Flags & 0x10004) != 0) && ((cr2Flags & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(i2cHandle);\n        return;\n      }\n    }\n    else {\n      if ((((sr1Flags & 0x10080) != 0) && ((cr2Flags & 0x400) != 0)) && ((sr1Flags & 0x10004) == 0)) {\n        I2C_MasterTransmit_TXE(i2cHandle);\n        return;\n      }\n      if (((sr1Flags & 0x10004) != 0) && ((cr2Flags & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(i2cHandle);\n        return;\n      }\n    }\n  }\n  else {\n    if (((sr1Flags & 0x10002) != 0) && ((cr2Flags & 0x200) != 0)) {\n      I2C_Slave_ADDR(i2cHandle);\n      return;\n    }\n    if (((sr1Flags & 0x10010) != 0) && ((cr2Flags & 0x200) != 0)) {\n      I2C_Slave_STOPF(i2cHandle);\n      return;\n    }\n    if ((sr2Flags & 0x100004) == 0) {\n      if ((((sr1Flags & 0x10040) != 0) && ((cr2Flags & 0x400) != 0)) && ((sr1Flags & 0x10004) == 0)) {\n        I2C_SlaveReceive_RXNE(i2cHandle);\n        return;\n      }\n      if (((sr1Flags & 0x10004) != 0) && ((cr2Flags & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(i2cHandle);\n      }\n    }\n    else {\n      if ((((sr1Flags & 0x10080) != 0) && ((cr2Flags & 0x400) != 0)) && ((sr1Flags & 0x10004) == 0)) {\n        I2C_SlaveTransmit_TXE(i2cHandle);\n        return;\n      }\n      if (((sr1Flags & 0x10004) != 0) && ((cr2Flags & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(i2cHandle);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001d00": "handle_i2_c_interrupt_08001d00",
                "hi2c": "i2cHandle",
                "pIVar1": "i2cInstance",
                "CurrentMode": "currentMode",
                "uVar2": "sr1Flags",
                "sr1itflags": "sr1InterruptFlags",
                "uVar3": "cr2Flags",
                "itsources": "interruptSources",
                "uVar4": "sr2Flags"
            },
            "calling": [
                "I2C2_EV_IRQHandler",
                "I2C1_EV_IRQHandler",
                "I2C3_EV_IRQHandler"
            ],
            "called": [
                "I2C_Slave_STOPF",
                "I2C_MasterReceive_BTF",
                "I2C_SlaveReceive_RXNE",
                "I2C_Master_ADD10",
                "I2C_Master_SB",
                "I2C_MasterTransmit_TXE",
                "I2C_Master_ADDR",
                "I2C_SlaveReceive_BTF",
                "I2C_SlaveTransmit_TXE",
                "I2C_MasterTransmit_BTF",
                "I2C_MasterReceive_RXNE",
                "I2C_Slave_ADDR",
                "I2C_SlaveTransmit_BTF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e68": {
            "entrypoint": "0x08001e68",
            "current_name": "handle_i2_c_events_08001e68",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvents_08001e68(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef i2cState;\n  I2C_TypeDef *i2cInstance;\n  uint32_t statusFlags;\n  uint sr1Value;\n  uint32_t itsources;\n  uint cr2Value;\n  \n  i2cInstance = i2cHandle->Instance;\n  sr1Value = i2cInstance->SR1;\n  cr2Value = i2cInstance->CR2;\n  if (((sr1Value & 0x10100) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 1;\n    i2cInstance->SR1 = 0xfffffeff;\n  }\n  if (((sr1Value & 0x10200) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 2;\n    i2cHandle->Instance->SR1 = 0xfffffdff;\n  }\n  if (((sr1Value & 0x10400) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cState = i2cHandle->State;\n    if (((i2cHandle->Mode == HAL_I2C_MODE_SLAVE) && (i2cHandle->XferCount == 0)) &&\n       (((i2cState == HAL_I2C_STATE_BUSY_TX || (i2cState == HAL_I2C_STATE_BUSY_TX_LISTEN)) ||\n        ((i2cState == HAL_I2C_STATE_LISTEN && (i2cHandle->PreviousState == 0x21)))))) {\n      I2C_Slave_AF(i2cHandle);\n    }\n    else {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n      if (i2cHandle->Mode == HAL_I2C_MODE_MASTER) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      }\n      i2cHandle->Instance->SR1 = 0xfffffbff;\n    }\n  }\n  if (((sr1Value & 0x10800) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 8;\n    i2cHandle->Instance->SR1 = 0xfffff7ff;\n  }\n  if (i2cHandle->ErrorCode != 0) {\n    I2C_ITError(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001e68": "handle_i2_c_events_08001e68",
                "hi2c": "i2cHandle",
                "HVar1": "i2cState",
                "pIVar2": "i2cInstance",
                "sr1itflags": "statusFlags",
                "uVar3": "sr1Value",
                "uVar4": "cr2Value"
            },
            "calling": [
                "I2C3_ER_IRQHandler",
                "I2C2_ER_IRQHandler",
                "I2C1_ER_IRQHandler"
            ],
            "called": [
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f3c": {
            "entrypoint": "0x08001f3c",
            "current_name": "reset_i2_c_state_08001f3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetI2CState_08001f3c(DMA_HandleTypeDef *dmaHandle)\n\n{\n  I2C_HandleTypeDef *i2cHandleParent;\n  I2C_HandleTypeDef *i2cHandle;\n  \n  i2cHandleParent = (I2C_HandleTypeDef *)dmaHandle->Parent;\n  i2cHandleParent->Instance->CR1 = i2cHandleParent->Instance->CR1 & 0xfffffbff;\n  i2cHandleParent->XferCount = 0;\n  i2cHandleParent->txDmaHandle->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  i2cHandleParent->rxDmaHandle->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  if (i2cHandleParent->State != HAL_I2C_STATE_ABORT) {\n    i2cHandleParent->State = HAL_I2C_STATE_READY;\n    i2cHandleParent->Mode = HAL_I2C_MODE_NONE;\n    i2cHandleParent->Instance->CR1 = i2cHandleParent->Instance->CR1 & 0xfffffffe;\n    HAL_I2C_ErrorCallback(i2cHandleParent);\n    return;\n  }\n  i2cHandleParent->State = HAL_I2C_STATE_READY;\n  i2cHandleParent->Mode = HAL_I2C_MODE_NONE;\n  i2cHandleParent->ErrorCode = 0;\n  i2cHandleParent->Instance->CR1 = i2cHandleParent->Instance->CR1 & 0xfffffffe;\n  HAL_I2C_AbortCpltCallback(i2cHandleParent);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001f3c": "reset_i2_c_state_08001f3c",
                "hdma": "dmaHandle",
                "hi2c_00": "i2cHandleParent",
                "hi2c": "i2cHandle",
                "hdmatx": "txDmaHandle",
                "hdmarx": "rxDmaHandle"
            },
            "calling": [],
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f9c": {
            "entrypoint": "0x08001f9c",
            "current_name": "wait_for_bit_change_08001f9c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef waitForBitChange_08001f9c(void)\n\n{\n  uint32_t startTime;\n  uint32_t currentTime;\n  uint32_t status;\n  \n  _DAT_40023840 = _DAT_40023840 | 0x10000000;\n  _DAT_420e0040 = 1;\n  startTime = HAL_GetTick();\n  do {\n    if ((_DAT_40007004 & 0x10000) != 0) {\n      _DAT_420e0044 = 1;\n      startTime = HAL_GetTick();\n      do {\n        if ((_DAT_40007004 & 0x20000) != 0) {\n          return HAL_OK;\n        }\n        currentTime = HAL_GetTick();\n      } while (currentTime - startTime < 0x3e9);\n      return HAL_TIMEOUT;\n    }\n    currentTime = HAL_GetTick();\n  } while (currentTime - startTime < 0x3e9);\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08001f9c": "wait_for_bit_change_08001f9c",
                "uVar1": "startTime",
                "uVar2": "currentTime",
                "tmpreg": "status"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800201c": {
            "entrypoint": "0x0800201c",
            "current_name": "configure_rcc_oscillators_0800201c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureRCCOscillators_0800201c(RCC_OscInitTypeDef_conflict *oscillatorConfig)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTime;\n  uint32_t currentTime;\n  uint32_t tickStart;\n  bool isHserunEnabled;\n  uint32_t temporaryRegister;\n  \n  if (oscillatorConfig == (RCC_OscInitTypeDef_conflict *)0x0) {\n    return HAL_ERROR;\n  }\n  if ((oscillatorConfig->OscillatorType & 1) != 0) {\n    if (((_DAT_40023808 & 0xc) == 4) ||\n       (((_DAT_40023808 & 0xc) == 8 && ((_DAT_40023804 & 0x400000) != 0)))) {\n      if (((_DAT_40023800 & 0x20000) != 0) && (oscillatorConfig->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      if (oscillatorConfig->HSEState == 0x10000) {\n        _DAT_40023800 = _DAT_40023800 | 0x10000;\n      }\n      else if (oscillatorConfig->HSEState == 0x50000) {\n        _DAT_40023800 = _DAT_40023800 | 0x50000;\n      }\n      else {\n        _DAT_40023800 = _DAT_40023800 & 0xfffaffff;\n      }\n      if (oscillatorConfig->HSEState == 0) {\n        startTime = HAL_GetTick();\n        while ((_DAT_40023800 & 0x20000) != 0) {\n          currentTime = HAL_GetTick();\n          if (100 < currentTime - startTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        startTime = HAL_GetTick();\n        while ((_DAT_40023800 & 0x20000) == 0) {\n          currentTime = HAL_GetTick();\n          if (100 < currentTime - startTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 2) != 0) {\n    if (((_DAT_40023808 & 0xc) == 0) ||\n       (((_DAT_40023808 & 0xc) == 8 && ((_DAT_40023804 & 0x400000) == 0)))) {\n      if (((_DAT_40023800 & 2) != 0) && (oscillatorConfig->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      _DAT_40023800 = _DAT_40023800 & 0xffffff07 | oscillatorConfig->HSICalibrationValue << 3;\n    }\n    else if (oscillatorConfig->HSIState == 0) {\n      _DAT_42470000 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023800 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (2 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470000 = 1;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023800 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (2 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40023800 = _DAT_40023800 & 0xffffff07 | oscillatorConfig->HSICalibrationValue << 3;\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 8) != 0) {\n    if (oscillatorConfig->LSIState == 0) {\n      _DAT_42470e80 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023874 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (2 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470e80 = 1;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023874 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (2 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 4) != 0) {\n    isHserunEnabled = (_DAT_40023840 & 0x10000000) == 0;\n    if (isHserunEnabled) {\n      _DAT_40023840 = _DAT_40023840 | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTime = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTime = HAL_GetTick();\n        if (2 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (oscillatorConfig->LSEState == 1) {\n      _DAT_40023870 = _DAT_40023870 | 1;\n    }\n    else if (oscillatorConfig->LSEState == 5) {\n      _DAT_40023870 = _DAT_40023870 | 5;\n    }\n    else {\n      _DAT_40023870 = _DAT_40023870 & 0xfffffffa;\n    }\n    if (oscillatorConfig->LSEState == 0) {\n      startTime = HAL_GetTick();\n      while ((_DAT_40023870 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (5000 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      startTime = HAL_GetTick();\n      while ((_DAT_40023870 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (5000 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (isHserunEnabled) {\n      _DAT_40023840 = _DAT_40023840 & 0xefffffff;\n    }\n  }\n  startTime = (oscillatorConfig->PLL).PLLState;\n  if (startTime == 0) {\n    status = HAL_OK;\n  }\n  else if ((_DAT_40023808 & 0xc) == 8) {\n    status = HAL_ERROR;\n  }\n  else if (startTime == 2) {\n    _DAT_42470060 = 0;\n    startTime = HAL_GetTick();\n    do {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        _DAT_40023804 =\n             (oscillatorConfig->PLL).PLLSource | (oscillatorConfig->PLL).PLLM |\n             (oscillatorConfig->PLL).PLLN << 6 |\n             (((oscillatorConfig->PLL).PLLP >> 1) - 1) * 0x10000 |\n             (oscillatorConfig->PLL).PLLQ << 0x18;\n        _DAT_42470060 = 1;\n        startTime = HAL_GetTick();\n        do {\n          if ((_DAT_40023800 & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          currentTime = HAL_GetTick();\n        } while (currentTime - startTime < 3);\n        return HAL_TIMEOUT;\n      }\n      currentTime = HAL_GetTick();\n    } while (currentTime - startTime < 3);\n    status = HAL_TIMEOUT;\n  }\n  else {\n    _DAT_42470060 = 0;\n    startTime = HAL_GetTick();\n    do {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      currentTime = HAL_GetTick();\n    } while (currentTime - startTime < 3);\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800201c": "configure_rcc_oscillators_0800201c",
                "RCC_OscInitStruct": "oscillatorConfig",
                "HVar1": "status",
                "uVar2": "startTime",
                "uVar3": "currentTime",
                "tickstart": "tickStart",
                "bVar4": "isHserunEnabled",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080023b4": {
            "entrypoint": "0x080023b4",
            "current_name": "calculate_clock_speed_080023b4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateClockSpeed_080023b4(void)\n\n{\n  uint dividend;\n  \n  if ((_DAT_40023808 & 0xc) == 4) {\n    return 8000000;\n  }\n  if ((_DAT_40023808 & 0xc) != 8) {\n    return 16000000;\n  }\n  if ((_DAT_40023804 & 0x400000) == 0) {\n    dividend = (_DAT_40023804 << 0x11) >> 0x17;\n    dividend = __aeabi_uldivmod(dividend * 16000000,\n                             (((uint)(dividend * 0x20 < dividend) * -0x3f -\n                              (uint)(dividend * 0x7c0 < dividend * 0x1f)) * 8 +\n                             (uint)CARRY4(dividend * 0x3d08,dividend)) * 0x400 | dividend * 0x3d09 >> 0x16,\n                             _DAT_40023804 & 0x3f,0);\n  }\n  else {\n    dividend = (_DAT_40023804 << 0x11) >> 0x17;\n    dividend = __aeabi_uldivmod(dividend * 8000000,\n                             (((uint)(dividend * 0x20 < dividend) * -0x3f -\n                              (uint)(dividend * 0x7c0 < dividend * 0x1f)) * 8 +\n                             (uint)CARRY4(dividend * 0x3d08,dividend)) * 0x200,_DAT_40023804 & 0x3f,0);\n  }\n  return dividend / ((((_DAT_40023804 << 0xe) >> 0x1e) + 1) * 2);\n}\n\n",
            "renaming": {
                "FUN_080023b4": "calculate_clock_speed_080023b4",
                "uVar1": "dividend"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "__aeabi_uldivmod"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002488": {
            "entrypoint": "0x08002488",
            "current_name": "initialize_clock_config_08002488",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeClockConfig_08002488(RCC_ClkInitTypeDef_conflict *clkInitStruct,uint32_t flashLatency)\n\n{\n  uint32_t temp1;\n  uint32_t temp2;\n  uint temp3;\n  uint32_t startTick;\n  \n  if (clkInitStruct == (RCC_ClkInitTypeDef_conflict *)0x0) {\n    return HAL_ERROR;\n  }\n  if (((_DAT_40023c00 & 0xf) < flashLatency) &&\n     (_DAT_40023c00 = CONCAT31(DAT_40023c00_1,(char)flashLatency), flashLatency != (flashLatency & 0xf))) {\n    return HAL_ERROR;\n  }\n  if ((clkInitStruct->clockType & 2) != 0) {\n    if ((clkInitStruct->clockType & 4) != 0) {\n      _DAT_40023808 = _DAT_40023808 | 0x1c00;\n    }\n    if ((clkInitStruct->clockType & 8) != 0) {\n      _DAT_40023808 = _DAT_40023808 | 0xe000;\n    }\n    _DAT_40023808 = _DAT_40023808 & 0xffffff0f | clkInitStruct->ahbDivider;\n  }\n  if ((clkInitStruct->clockType & 1) != 0) {\n    temp3 = clkInitStruct->sysclkSource;\n    if (temp3 == 1) {\n      if ((_DAT_40023800 & 0x20000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if (temp3 - 2 < 2) {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((_DAT_40023800 & 2) == 0) {\n      return HAL_ERROR;\n    }\n    _DAT_40023808 = temp3 | _DAT_40023808 & 0xfffffffc;\n    temp1 = HAL_GetTick();\n    while ((_DAT_40023808 & 0xc) != clkInitStruct->sysclkSource * 4) {\n      temp2 = HAL_GetTick();\n      if (5000 < temp2 - temp1) {\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  if ((flashLatency < (_DAT_40023c00 & 0xf)) &&\n     (_DAT_40023c00 = CONCAT31(DAT_40023c00_1,(char)flashLatency), flashLatency != (flashLatency & 0xf))) {\n    return HAL_ERROR;\n  }\n  if ((clkInitStruct->clockType & 4) != 0) {\n    _DAT_40023808 = _DAT_40023808 & 0xffffe3ff | clkInitStruct->apb1Divider;\n  }\n  if ((clkInitStruct->clockType & 8) != 0) {\n    _DAT_40023808 = _DAT_40023808 & 0xffff1fff | clkInitStruct->apb2Divider << 3;\n  }\n  temp1 = HAL_RCC_GetSysClockFreq();\n  sysCoreClock = temp1 >> \"\"[(_DAT_40023808 << 0x18) >> 0x1c];\n  HAL_InitTick(0xf);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002488": "initialize_clock_config_08002488",
                "FLatency": "flashLatency",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "tickstart": "startTick",
                "RCC_ClkInitStruct": "clkInitStruct",
                "ClockType": "clockType",
                "AHBCLKDivider": "ahbDivider",
                "SYSCLKSource": "sysclkSource",
                "APB1CLKDivider": "apb1Divider",
                "APB2CLKDivider": "apb2Divider",
                "SystemCoreClock": "sysCoreClock"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_RCC_GetSysClockFreq",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025e0": {
            "entrypoint": "0x080025e0",
            "current_name": "get_system_core_clock_080025e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_080025e0(void)\n\n{\n  return SystemCoreClock;\n}\n\n",
            "renaming": {
                "FUN_080025e0": "get_system_core_clock_080025e0"
            },
            "calling": [
                "SystemClock_Config",
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025ec": {
            "entrypoint": "0x080025ec",
            "current_name": "get_hclk_frequency_080025ec",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getHCLKFrequency_080025ec(void)\n\n{\n  uint32_t hclkFrequency;\n  \n  hclkFrequency = HAL_RCC_GetHCLKFreq();\n  return hclkFrequency >> \"\"[(uint)(_DAT_40023808 << 0x13) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_080025ec": "get_hclk_frequency_080025ec",
                "uVar1": "hclkFrequency"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800260c": {
            "entrypoint": "0x0800260c",
            "current_name": "get_adjusted_hclk_0800260c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getAdjustedHCLK_0800260c(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = getHCLKFrequency();\n  return uVar1 >> \"\"[(uint)(_DAT_40023808 << 0x10) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_0800260c": "get_adjusted_hclk_0800260c",
                "HAL_RCC_GetHCLKFreq": "getHCLKFrequency"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800262c": {
            "entrypoint": "0x0800262c",
            "current_name": "update_alarm_status_0800262c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid updateAlarmStatus_0800262c(RTC_HandleTypeDef *rtcHandle)\n\n{\n  if (((rtcHandle->Instance->ISR & 0x100) != 0) && ((rtcHandle->Instance->CR & 0x1000) != 0)) {\n    handleAlarmACallback(rtcHandle);\n    rtcHandle->Instance->ISR = rtcHandle->Instance->ISR & 0xff | 0xfffffe7f;\n  }\n  if (((rtcHandle->Instance->ISR & 0x200) != 0) && ((rtcHandle->Instance->CR & 0x2000) != 0)) {\n    handleAlarmBCallback(rtcHandle);\n    rtcHandle->Instance->ISR = rtcHandle->Instance->ISR & 0xff | 0xfffffd7f;\n  }\n  _DAT_40013c14 = 0x20000;\n  rtcHandle->State = HAL_RTC_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800262c": "update_alarm_status_0800262c",
                "hrtc": "rtcHandle",
                "HAL_RTC_AlarmAEventCallback": "handleAlarmACallback",
                "HAL_RTCEx_AlarmBEventCallback": "handleAlarmBCallback"
            },
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "called": [
                "HAL_RTC_AlarmAEventCallback",
                "HAL_RTCEx_AlarmBEventCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800268c": {
            "entrypoint": "0x0800268c",
            "current_name": "FUNC_0800268c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800268c(RTC_HandleTypeDef *hrtc)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800268c": "FUNC_0800268c"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800268e": {
            "entrypoint": "0x0800268e",
            "current_name": "reset_timer_0800268e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef resetTimer_0800268e(TIM_HandleTypeDef *timerHandle)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  timerHandle->State = HAL_TIM_STATE_BUSY;\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  HAL_TIM_PWM_MspDeInit(timerHandle);\n  timerHandle->State = HAL_TIM_STATE_RESET;\n  timerHandle->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800268e": "reset_timer_0800268e",
                "htim": "timerHandle",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080026c8": {
            "entrypoint": "0x080026c8",
            "current_name": "FUNC_080026c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080026c8(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026c8": "FUNC_080026c8"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026ca": {
            "entrypoint": "0x080026ca",
            "current_name": "FUNC_080026ca",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080026ca(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026ca": "FUNC_080026ca"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026cc": {
            "entrypoint": "0x080026cc",
            "current_name": "FUNC_080026cc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080026cc(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026cc": "FUNC_080026cc"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026ce": {
            "entrypoint": "0x080026ce",
            "current_name": "handle_tim_callbacks_080026ce",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimCallbacks_080026ce(timHandle *timHandle)\n\n{\n  timInstance *currentTim;\n  \n  currentTim = timHandle->Instance;\n  if (((currentTim->SR & 2) != 0) && ((currentTim->DIER & 2) != 0)) {\n    currentTim->SR = 0xfffffffd;\n    timHandle->Channel = activeChannel1;\n    if ((timHandle->Instance->CCMR1 & 3) == 0) {\n      ocDelayElapsedCallback(timHandle);\n      pwmPulseFinishedCallback(timHandle);\n    }\n    else {\n      icCaptureCallback(timHandle);\n    }\n    timHandle->Channel = clearedChannel;\n  }\n  currentTim = timHandle->Instance;\n  if (((currentTim->SR & 4) != 0) && ((currentTim->DIER & 4) != 0)) {\n    currentTim->SR = 0xfffffffb;\n    timHandle->Channel = activeChannel2;\n    if ((timHandle->Instance->CCMR1 & 0x300) == 0) {\n      ocDelayElapsedCallback(timHandle);\n      pwmPulseFinishedCallback(timHandle);\n    }\n    else {\n      icCaptureCallback(timHandle);\n    }\n    timHandle->Channel = clearedChannel;\n  }\n  currentTim = timHandle->Instance;\n  if (((currentTim->SR & 8) != 0) && ((currentTim->DIER & 8) != 0)) {\n    currentTim->SR = 0xfffffff7;\n    timHandle->Channel = activeChannel3;\n    if ((timHandle->Instance->CCMR2 & 3) == 0) {\n      ocDelayElapsedCallback(timHandle);\n      pwmPulseFinishedCallback(timHandle);\n    }\n    else {\n      icCaptureCallback(timHandle);\n    }\n    timHandle->Channel = clearedChannel;\n  }\n  currentTim = timHandle->Instance;\n  if (((currentTim->SR & 0x10) != 0) && ((currentTim->DIER & 0x10) != 0)) {\n    currentTim->SR = 0xffffffef;\n    timHandle->Channel = activeChannel4;\n    if ((timHandle->Instance->CCMR2 & 0x300) == 0) {\n      ocDelayElapsedCallback(timHandle);\n      pwmPulseFinishedCallback(timHandle);\n    }\n    else {\n      icCaptureCallback(timHandle);\n    }\n    timHandle->Channel = clearedChannel;\n  }\n  currentTim = timHandle->Instance;\n  if (((currentTim->SR & 1) != 0) && ((currentTim->DIER & 1) != 0)) {\n    currentTim->SR = 0xfffffffe;\n    periodElapsedCallback(timHandle);\n  }\n  currentTim = timHandle->Instance;\n  if (((currentTim->SR & 0x80) != 0) && ((currentTim->DIER & 0x80) != 0)) {\n    currentTim->SR = 0xffffff7f;\n    breakCallback(timHandle);\n  }\n  currentTim = timHandle->Instance;\n  if (((currentTim->SR & 0x40) != 0) && ((currentTim->DIER & 0x40) != 0)) {\n    currentTim->SR = 0xffffffbf;\n    triggerCallback(timHandle);\n  }\n  currentTim = timHandle->Instance;\n  if (((currentTim->SR & 0x20) != 0) && ((currentTim->DIER & 0x20) != 0)) {\n    currentTim->SR = 0xffffffdf;\n    commutationCallback(timHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026ce": "handle_tim_callbacks_080026ce",
                "TIM_HandleTypeDef": "timHandle",
                "TIM_TypeDef": "timInstance",
                "pTVar1": "currentTim",
                "htim": "timHandle",
                "HAL_TIM_ACTIVE_CHANNEL_1": "activeChannel1",
                "HAL_TIM_ACTIVE_CHANNEL_2": "activeChannel2",
                "HAL_TIM_ACTIVE_CHANNEL_3": "activeChannel3",
                "HAL_TIM_ACTIVE_CHANNEL_4": "activeChannel4",
                "HAL_TIM_ACTIVE_CHANNEL_CLEARED": "clearedChannel",
                "HAL_TIM_OC_DelayElapsedCallback": "ocDelayElapsedCallback",
                "HAL_TIM_PWM_PulseFinishedCallback": "pwmPulseFinishedCallback",
                "HAL_TIM_IC_CaptureCallback": "icCaptureCallback",
                "HAL_TIM_PeriodElapsedCallback": "periodElapsedCallback",
                "HAL_TIMEx_BreakCallback": "breakCallback",
                "HAL_TIM_TriggerCallback": "triggerCallback",
                "HAL_TIMEx_CommutationCallback": "commutationCallback"
            },
            "calling": [
                "TIM3_IRQHandler",
                "TIM5_IRQHandler",
                "TIM1_UP_TIM10_IRQHandler",
                "TIM2_IRQHandler",
                "TIM6_DAC_IRQHandler",
                "TIM8_UP_TIM13_IRQHandler",
                "TIM4_IRQHandler",
                "TIM1_BRK_TIM9_IRQHandler",
                "TIM8_BRK_TIM12_IRQHandler",
                "TIM8_TRG_COM_TIM14_IRQHandler",
                "TIM7_IRQHandler",
                "TIM1_TRG_COM_TIM11_IRQHandler"
            ],
            "called": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIMEx_BreakCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002848": {
            "entrypoint": "0x08002848",
            "current_name": "set_timer_channel_state_08002848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setTimerChannelState_08002848(TIM_TypeDef *timer,uint32_t channel,uint32_t channelState)\n\n{\n  timer->CCER = timer->CCER & ~(1 << (channel & 0xff));\n  timer->CCER = timer->CCER | channelState << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002848": "set_timer_channel_state_08002848",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "channelState"
            },
            "calling": [
                "HAL_TIM_PWM_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002864": {
            "entrypoint": "0x08002864",
            "current_name": "disable_tim_channel_08002864",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef disableTIMChannel_08002864(TIM_HandleTypeDef *timerHandler,uint32_t channel)\n\n{\n  bool isTIM2or4;\n  TIM_TypeDef *timerInstance;\n  \n  TIM_CCxchannelCmd(timerHandler->Instance,channel,0);\n  timerInstance = timerHandler->Instance;\n  if (timerInstance == (TIM_TypeDef *)0x40010000) {\n    isTIM2or4 = true;\n  }\n  else if (timerInstance == (TIM_TypeDef *)0x40010400) {\n    isTIM2or4 = true;\n  }\n  else {\n    isTIM2or4 = false;\n  }\n  if (((isTIM2or4) && ((timerInstance->CCER & 0x1111) == 0)) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->BDTR = timerInstance->BDTR & 0xffff7fff;\n  }\n  timerInstance = timerHandler->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  timerHandler->State = HAL_TIM_STATE_READY;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002864": "disable_tim_channel_08002864",
                "htim": "timerHandler",
                "Channel": "channel",
                "bVar1": "isTIM2or4",
                "pTVar2": "timerInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028d4": {
            "entrypoint": "0x080028d4",
            "current_name": "set_channel_state_080028d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setChannelState_080028d4(TIM *TIMx,uint32_t channelNum,uint32_t channelState)\n\n{\n  TIMx->CCER = TIMx->CCER & ~(4 << (channelNum & 0xff));\n  TIMx->CCER = TIMx->CCER | channelState << (channelNum & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080028d4": "set_channel_state_080028d4",
                "TIM_TypeDef": "TIM",
                "Channel": "channelNum",
                "ChannelNState": "channelState"
            },
            "calling": [
                "HAL_TIMEx_PWMN_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028f0": {
            "entrypoint": "0x080028f0",
            "current_name": "disable_tim_channel_080028f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef disableTimChannel_080028f0(TIM_HandleTypeDef *timerHandle,uint32_t channel)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  TIM_CCxNchannelCmd(timerHandle->Instance,channel,0);\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->BDTR = timerInstance->BDTR & 0xffff7fff;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080028f0": "disable_tim_channel_080028f0",
                "htim": "timerHandle",
                "Channel": "channel",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800293c": {
            "entrypoint": "0x0800293c",
            "current_name": "FUNC_0800293c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800293c(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800293c": "FUNC_0800293c"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800293e": {
            "entrypoint": "0x0800293e",
            "current_name": "FUNC_0800293e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800293e(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800293e": "FUNC_0800293e"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002940": {
            "entrypoint": "0x08002940",
            "current_name": "reset_uart_state_08002940",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_uart_state_08002940(UART_HandleTypeDef *uart_handle)\n\n{\n  uart_handle->uart_instance->control_register_1 = uart_handle->uart_instance->control_register_1 & 0xfffffedf;\n  uart_handle->uart_instance->control_register_3 = uart_handle->uart_instance->control_register_3 & 0xfffffffe;\n  uart_handle->receive_state = HAL_UART_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002940": "reset_uart_state_08002940",
                "huart": "uart_handle",
                "Instance": "uart_instance",
                "CR1": "control_register_1",
                "CR3": "control_register_3",
                "RxState": "receive_state"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800295c": {
            "entrypoint": "0x0800295c",
            "current_name": "send_data_0800295c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef sendData_0800295c(UART_HandleTypeDef *uartHandle)\n\n{\n  uint16_t transferCount;\n  byte *buffer;\n  uint16_t *temp;\n  \n  if (uartHandle->gState != UART_STATE_BUSY_TRANSMIT) {\n    return BUSY;\n  }\n  if ((uartHandle->Init).WordLength == 0x1000) {\n    uartHandle->Instance->DR = *(ushort *)uartHandle->pTxBuffPtr & 0x1ff;\n    if ((uartHandle->Init).Parity == 0) {\n      uartHandle->pTxBuffPtr = uartHandle->pTxBuffPtr + 2;\n    }\n    else {\n      uartHandle->pTxBuffPtr = uartHandle->pTxBuffPtr + 1;\n    }\n  }\n  else {\n    buffer = uartHandle->pTxBuffPtr;\n    uartHandle->pTxBuffPtr = buffer + 1;\n    uartHandle->Instance->DR = (uint)*buffer;\n  }\n  transferCount = uartHandle->TxXferCount - 1;\n  uartHandle->TxXferCount = transferCount;\n  if (transferCount == 0) {\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xffffff7f;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x40;\n    return OK;\n  }\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_0800295c": "send_data_0800295c",
                "huart": "uartHandle",
                "uVar1": "transferCount",
                "pbVar2": "buffer",
                "tmp": "temp",
                "HAL_UART_STATE_BUSY_TX": "UART_STATE_BUSY_TRANSMIT",
                "HAL_BUSY": "BUSY",
                "HAL_OK": "OK"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080029c8": {
            "entrypoint": "0x080029c8",
            "current_name": "init_uart_080029c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initUART_080029c8(UARTHandle *uartHandle)\n\n{\n  uint32_t pclkFreq1;\n  uint32_t pclkFreq2;\n  uint32_t pclkFreq3;\n  uint32_t pclkFreq4;\n  uint32_t pclkFreq5;\n  uint32_t baudRate1;\n  uint32_t baudRate2;\n  uint32_t baudRate3;\n  uint32_t baudRate4;\n  USART_TypeDef *uartInstance;\n  \n  uartHandle->Instance->CR2 = uartHandle->Instance->CR2 & 0xffffcfff | (uartHandle->Init).StopBits;\n  uartHandle->Instance->CR1 =\n       uartHandle->Instance->CR1 & 0xffff69f3 |\n       (uartHandle->Init).WordLength | (uartHandle->Init).Parity | (uartHandle->Init).Mode |\n       (uartHandle->Init).OverSampling;\n  uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffcff | (uartHandle->Init).HwFlowCtl;\n  if ((uartHandle->Init).OverSampling == 0x8000) {\n    uartInstance = uartHandle->Instance;\n    if ((uartInstance != (USART_TypeDef *)0x40011000) && (uartInstance != (USART_TypeDef *)0x40011400)) {\n      pclkFreq1 = HAL_RCC_GetPCLK1Freq();\n      baudRate1 = (uartHandle->Init).BaudRate;\n      pclkFreq2 = HAL_RCC_GetPCLK1Freq();\n      baudRate2 = (uartHandle->Init).BaudRate;\n      pclkFreq3 = HAL_RCC_GetPCLK1Freq();\n      baudRate3 = (uartHandle->Init).BaudRate;\n      pclkFreq4 = HAL_RCC_GetPCLK1Freq();\n      baudRate4 = (uartHandle->Init).BaudRate;\n      pclkFreq5 = HAL_RCC_GetPCLK1Freq();\n      uartInstance->BRR = ((uint)((int)((ulonglong)\n                                   (((pclkFreq4 * 0x19) / (baudRate4 << 1) +\n                                    (int)(((ulonglong)(pclkFreq5 * 0x19) /\n                                          (ulonglong)((uartHandle->Init).BaudRate << 1)) / 100) * -100) *\n                                    8 + 0x32) * 0x51eb851f >> 0x20) << 0x18) >> 0x1d) +\n                     ((((pclkFreq2 * 0x19) / (baudRate2 << 1) +\n                       (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(baudRate3 << 1)) / 100) * -100) *\n                       8 + 0x32) / 100 & 0xf8) * 2 +\n                     (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(baudRate1 << 1)) / 100) * 0x10;\n      return;\n    }\n    pclkFreq1 = HAL_RCC_GetPCLK2Freq();\n    baudRate1 = (uartHandle->Init).BaudRate;\n    pclkFreq2 = HAL_RCC_GetPCLK2Freq();\n    baudRate2 = (uartHandle->Init).BaudRate;\n    pclkFreq3 = HAL_RCC_GetPCLK2Freq();\n    baudRate3 = (uartHandle->Init).BaudRate;\n    pclkFreq4 = HAL_RCC_GetPCLK2Freq();\n    baudRate4 = (uartHandle->Init).BaudRate;\n    pclkFreq5 = HAL_RCC_GetPCLK2Freq();\n    uartInstance->BRR = ((uint)((int)((ulonglong)\n                                 (((pclkFreq4 * 0x19) / (baudRate4 << 1) +\n                                  (int)(((ulonglong)(pclkFreq5 * 0x19) /\n                                        (ulonglong)((uartHandle->Init).BaudRate << 1)) / 100) * -100) * 8\n                                 + 0x32) * 0x51eb851f >> 0x20) << 0x18) >> 0x1d) +\n                   ((((pclkFreq2 * 0x19) / (baudRate2 << 1) +\n                     (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(baudRate3 << 1)) / 100) * -100) * 8\n                    + 0x32) / 100 & 0xf8) * 2 +\n                   (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(baudRate1 << 1)) / 100) * 0x10;\n    return;\n  }\n  uartInstance = uartHandle->Instance;\n  if ((uartInstance != (USART_TypeDef *)0x40011000) && (uartInstance != (USART_TypeDef *)0x40011400)) {\n    pclkFreq1 = HAL_RCC_GetPCLK1Freq();\n    baudRate1 = (uartHandle->Init).BaudRate;\n    pclkFreq2 = HAL_RCC_GetPCLK1Freq();\n    baudRate2 = (uartHandle->Init).BaudRate;\n    pclkFreq3 = HAL_RCC_GetPCLK1Freq();\n    baudRate3 = (uartHandle->Init).BaudRate;\n    pclkFreq4 = HAL_RCC_GetPCLK1Freq();\n    baudRate4 = (uartHandle->Init).BaudRate;\n    pclkFreq5 = HAL_RCC_GetPCLK1Freq();\n    uartInstance->BRR = ((uint)((int)((ulonglong)\n                                 (((pclkFreq4 * 0x19) / (baudRate4 << 2) +\n                                  (int)(((ulonglong)(pclkFreq5 * 0x19) /\n                                        (ulonglong)((uartHandle->Init).BaudRate << 2)) / 100) * -100) *\n                                  0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                   ((((pclkFreq2 * 0x19) / (baudRate2 << 2) +\n                     (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(baudRate3 << 2)) / 100) * -100) *\n                     0x10 + 0x32) / 100 & 0xf0) +\n                   (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(baudRate1 << 2)) / 100) * 0x10;\n    return;\n  }\n  pclkFreq1 = HAL_RCC_GetPCLK2Freq();\n  baudRate1 = (uartHandle->Init).BaudRate;\n  pclkFreq2 = HAL_RCC_GetPCLK2Freq();\n  baudRate2 = (uartHandle->Init).BaudRate;\n  pclkFreq3 = HAL_RCC_GetPCLK2Freq();\n  baudRate3 = (uartHandle->Init).BaudRate;\n  pclkFreq4 = HAL_RCC_GetPCLK2Freq();\n  baudRate4 = (uartHandle->Init).BaudRate;\n  pclkFreq5 = HAL_RCC_GetPCLK2Freq();\n  uartInstance->BRR = ((uint)((int)((ulonglong)\n                               (((pclkFreq4 * 0x19) / (baudRate4 << 2) +\n                                (int)(((ulonglong)(pclkFreq5 * 0x19) /\n                                      (ulonglong)((uartHandle->Init).BaudRate << 2)) / 100) * -100) *\n                                0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                 ((((pclkFreq2 * 0x19) / (baudRate2 << 2) +\n                   (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(baudRate3 << 2)) / 100) * -100) * 0x10\n                  + 0x32) / 100 & 0xf0) +\n                 (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(baudRate1 << 2)) / 100) * 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080029c8": "init_uart_080029c8",
                "huart": "uartHandle",
                "UART_HandleTypeDef": "UARTHandle",
                "uVar1": "pclkFreq1",
                "uVar2": "pclkFreq2",
                "uVar3": "pclkFreq3",
                "uVar4": "pclkFreq4",
                "uVar5": "pclkFreq5",
                "uVar6": "baudRate1",
                "uVar7": "baudRate2",
                "uVar8": "baudRate3",
                "uVar9": "baudRate4",
                "pUVar10": "uartInstance"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d0c": {
            "entrypoint": "0x08002d0c",
            "current_name": "check_flag_status_08002d0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_expectedStatusTypeDef\ncheckFlagStatus_08002d0c(UART_HandleTypeDef *uartHandler,uint32_t flag,flagexpectedStatus expectedStatus,uint32_t tickStart,\n            uint32_t timeout)\n\n{\n  uint32_t currentTick;\n  \n  do {\n    if (((flag & ~uartHandler->Instance->statusRegister) == 0) != (bool)expectedStatus) {\n      return HAL_OK;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - tickStart <= timeout))));\n  uartHandler->Instance->CR1 = uartHandler->Instance->CR1 & 0xfffffe5f;\n  uartHandler->Instance->CR3 = uartHandler->Instance->CR3 & 0xfffffffe;\n  uartHandler->gState = HAL_UART_STATE_READY;\n  uartHandler->RxState = HAL_UART_STATE_READY;\n  uartHandler->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08002d0c": "check_flag_status_08002d0c",
                "huart": "uartHandler",
                "Flag": "flag",
                "Status": "expectedStatus",
                "Tickstart": "tickStart",
                "Timeout": "timeout",
                "uVar1": "currentTick",
                "SR": "statusRegister"
            },
            "calling": [
                "HAL_UART_Transmit"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d70": {
            "entrypoint": "0x08002d70",
            "current_name": "FUNC_08002d70",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002d70(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d70": "FUNC_08002d70"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d72": {
            "entrypoint": "0x08002d72",
            "current_name": "initialize_uart_08002d72",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeUART_08002d72(UART_HandleTypeDef *uartHandle)\n\n{\n  if (uartHandle != (UART_HandleTypeDef *)0x0) {\n    if (uartHandle->globalState == HAL_UART_STATE_RESET) {\n      uartHandle->lockState = HAL_UNLOCKED;\n      HAL_UART_MspInit(uartHandle);\n    }\n    uartHandle->globalState = HAL_UART_STATE_BUSY;\n    uartHandle->uartInstance->controlRegister1 = uartHandle->uartInstance->controlRegister1 & 0xffffdfff;\n    UART_SetConfig(uartHandle);\n    uartHandle->uartInstance->controlRegister2 = uartHandle->uartInstance->controlRegister2 & 0xffffb7ff;\n    uartHandle->uartInstance->controlRegister3 = uartHandle->uartInstance->controlRegister3 & 0xffffffd5;\n    uartHandle->uartInstance->controlRegister1 = uartHandle->uartInstance->controlRegister1 | 0x2000;\n    uartHandle->error = 0;\n    uartHandle->globalState = HAL_UART_STATE_READY;\n    uartHandle->receiveState = HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002d72": "initialize_uart_08002d72",
                "huart": "uartHandle",
                "gState": "globalState",
                "Lock": "lockState",
                "Instance": "uartInstance",
                "CR1": "controlRegister1",
                "CR2": "controlRegister2",
                "CR3": "controlRegister3",
                "ErrorCode": "error",
                "RxState": "receiveState"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002dd0": {
            "entrypoint": "0x08002dd0",
            "current_name": "transmit_data_08002dd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\ntransmitData_08002dd0(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t size,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t tickStart;\n  uint16_t *temp;\n  \n  if (uartHandle->gState == HAL_UART_STATE_READY) {\n    if (data == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (uartHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      uartHandle->Lock = HAL_LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n      tickStart = HAL_GetTick();\n      uartHandle->TxXfersize = size;\n      uartHandle->TxXferCount = size;\n      while (uartHandle->TxXferCount != 0) {\n        uartHandle->TxXferCount = uartHandle->TxXferCount - 1;\n        if ((uartHandle->Init).WordLength == 0x1000) {\n          status = UART_WaitOnFlagUntiltimeout(uartHandle,0x80,RESET,tickStart,timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = *(ushort *)data & 0x1ff;\n          if ((uartHandle->Init).Parity == 0) {\n            data = (uint8_t *)((int)data + 2);\n          }\n          else {\n            data = (uint8_t *)((int)data + 1);\n          }\n        }\n        else {\n          status = UART_WaitOnFlagUntiltimeout(uartHandle,0x80,RESET,tickStart,timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = (uint)*data;\n          data = (uint8_t *)((int)data + 1);\n        }\n      }\n      status = UART_WaitOnFlagUntiltimeout(uartHandle,0x40,RESET,tickStart,timeout);\n      if (status == HAL_OK) {\n        uartHandle->gState = HAL_UART_STATE_READY;\n        uartHandle->Lock = HAL_UNLOCKED;\n        status = HAL_OK;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002dd0": "transmit_data_08002dd0",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "tickStart",
                "tmp": "temp"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002eb2": {
            "entrypoint": "0x08002eb2",
            "current_name": "initialize_uart_transfer_08002eb2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeUartTransfer_08002eb2(UART_HandleTypeDef *uartHandle,uint8_t *dataBuffer,uint16_t dataSize)\n\n{\n  if (uartHandle->gState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (dataBuffer == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (dataSize == 0) {\n    return HAL_ERROR;\n  }\n  if (uartHandle->Lock != HAL_LOCKED) {\n    uartHandle->pTxBuffPtr = dataBuffer;\n    uartHandle->TxXferdataSize = dataSize;\n    uartHandle->TxXferCount = dataSize;\n    uartHandle->ErrorCode = 0;\n    uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n    uartHandle->Lock = HAL_UNLOCKED;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x80;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_08002eb2": "initialize_uart_transfer_08002eb2",
                "huart": "uartHandle",
                "pData": "dataBuffer",
                "Size": "dataSize"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "uart_attach_tx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002efa": {
            "entrypoint": "0x08002efa",
            "current_name": "initialize_uart_reception_08002efa",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeUARTReception_08002efa(UART_HandleTypeDef *UARTHandle,uint8_t *dataBuffer,uint16_t bufferSize)\n\n{\n  if (UARTHandle->RxState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (dataBuffer == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (bufferSize == 0) {\n    return HAL_ERROR;\n  }\n  if (UARTHandle->Lock != HAL_LOCKED) {\n    UARTHandle->pRxBuffPtr = dataBuffer;\n    UARTHandle->RxXferbufferSize = bufferSize;\n    UARTHandle->RxXferCount = bufferSize;\n    UARTHandle->ErrorCode = 0;\n    UARTHandle->RxState = HAL_UART_STATE_BUSY_RX;\n    UARTHandle->Lock = HAL_UNLOCKED;\n    UARTHandle->Instance->CR3 = UARTHandle->Instance->CR3 | 1;\n    UARTHandle->Instance->CR1 = UARTHandle->Instance->CR1 | 0x120;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_08002efa": "initialize_uart_reception_08002efa",
                "huart": "UARTHandle",
                "pData": "dataBuffer",
                "Size": "bufferSize"
            },
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f4c": {
            "entrypoint": "0x08002f4c",
            "current_name": "initialize_uart_08002f4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initialize_uart_08002f4c(UART_HandleTypeDef *uart_handle)\n\n{\n  uart_handle->uart_instance->control_register1 = uart_handle->uart_instance->control_register1 & 0xffffffbf;\n  uart_handle->uart_state = HAL_UART_STATE_READY;\n  uart_transmit_complete_callback(uart_handle);\n  return hal_success;\n}\n\n",
            "renaming": {
                "FUN_08002f4c": "initialize_uart_08002f4c",
                "huart": "uart_handle",
                "Instance": "uart_instance",
                "CR1": "control_register1",
                "gState": "uart_state",
                "HAL_UART_TxCpltCallback": "uart_transmit_complete_callback",
                "HAL_OK": "hal_success"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f66": {
            "entrypoint": "0x08002f66",
            "current_name": "process_received_data_08002f66",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef process_received_data_08002f66(UART_HandleTypeDef *uart_handle)\n\n{\n  uint16_t *data_ptr;\n  byte *byte_ptr;\n  uint16_t remaining_count;\n  uint8_t *uint8_ptr;\n  \n  if (uart_handle->RxState != HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  if ((uart_handle->Init).WordLength == 0x1000) {\n    if ((uart_handle->Init).Parity == 0) {\n      *(ushort *)uart_handle->pRxBuffPtr = (ushort)((uart_handle->Instance->DR << 0x17) >> 0x17);\n      uart_handle->pRxBuffPtr = uart_handle->pRxBuffPtr + 2;\n    }\n    else {\n      *(ushort *)uart_handle->pRxBuffPtr = (ushort)uart_handle->Instance->DR & 0xff;\n      uart_handle->pRxBuffPtr = uart_handle->pRxBuffPtr + 1;\n    }\n  }\n  else if ((uart_handle->Init).Parity == 0) {\n    uint8_ptr = uart_handle->pRxBuffPtr;\n    uart_handle->pRxBuffPtr = uint8_ptr + 1;\n    *uint8_ptr = (uint8_t)uart_handle->Instance->DR;\n  }\n  else {\n    byte_ptr = uart_handle->pRxBuffPtr;\n    uart_handle->pRxBuffPtr = byte_ptr + 1;\n    *byte_ptr = (byte)uart_handle->Instance->DR & 0x7f;\n  }\n  remaining_count = uart_handle->RxXferCount - 1;\n  uart_handle->RxXferCount = remaining_count;\n  if (remaining_count != 0) {\n    return HAL_OK;\n  }\n  uart_handle->Instance->CR1 = uart_handle->Instance->CR1 & 0xfffffedf;\n  uart_handle->Instance->CR3 = uart_handle->Instance->CR3 & 0xfffffffe;\n  uart_handle->RxState = HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(uart_handle);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002f66": "process_received_data_08002f66",
                "huart": "uart_handle",
                "tmp": "data_ptr",
                "pbVar1": "byte_ptr",
                "uVar2": "remaining_count",
                "puVar3": "uint8_ptr"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ffc": {
            "entrypoint": "0x08002ffc",
            "current_name": "handle_uart_interrupt_08002ffc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART_interrupt_08002ffc(UART_HandleTypeDef *UART_handle)\n\n{\n  HAL_StatusTypeDef HAL_Status;\n  uint CR1_status;\n  uint32_t cr1_interrupts;\n  USART_TypeDef *USART_instance;\n  uint32_t cr3_interrupts;\n  uint CR3_status;\n  uint SR_status;\n  uint32_t interrupt_flags;\n  \n  USART_instance = UART_handle->Instance;\n  SR_status = USART_instance->SR;\n  CR1_status = USART_instance->CR1;\n  if ((((SR_status & 0xf) == 0) && ((SR_status & 0x20) != 0)) && ((CR1_status & 0x20) != 0)) {\n    UART_Receive_IT(UART_handle);\n    return;\n  }\n  if (((SR_status & 0xf) == 0) || ((CR3_status = USART_instance->CR3 & 1, CR3_status == 0 && ((CR1_status & 0x120) == 0)))) {\n    if (((SR_status & 0x80) != 0) && ((CR1_status & 0x80) != 0)) {\n      UART_Transmit_IT(UART_handle);\n      return;\n    }\n    if (((SR_status & 0x40) != 0) && ((CR1_status & 0x40) != 0)) {\n      UART_EndTransmit_IT(UART_handle);\n    }\n  }\n  else {\n    if (((SR_status & 1) != 0) && ((CR1_status & 0x100) != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 1;\n    }\n    if (((SR_status & 4) != 0) && (CR3_status != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 2;\n    }\n    if (((SR_status & 2) != 0) && (CR3_status != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 4;\n    }\n    if (((SR_status & 8) != 0) && (CR3_status != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 8;\n    }\n    if (UART_handle->ErrorCode != 0) {\n      if (((SR_status & 0x20) != 0) && ((CR1_status & 0x20) != 0)) {\n        UART_Receive_IT(UART_handle);\n      }\n      if (((UART_handle->ErrorCode & 8) == 0) && ((UART_handle->Instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(UART_handle);\n        UART_handle->ErrorCode = 0;\n        return;\n      }\n      UART_EndRxTransfer(UART_handle);\n      USART_instance = UART_handle->Instance;\n      if ((USART_instance->CR3 & 0x40) == 0) {\n        HAL_UART_ErrorCallback(UART_handle);\n        return;\n      }\n      USART_instance->CR3 = USART_instance->CR3 & 0xffffffbf;\n      if (UART_handle->hdmarx == (DMA_HandleTypeDef *)0x0) {\n        HAL_UART_ErrorCallback(UART_handle);\n        return;\n      }\n      UART_handle->hdmarx->XferAbortCallback = UART_DMAAbortOnError + 1;\n      HAL_Status = HAL_DMA_Abort_IT(UART_handle->hdmarx);\n      if (HAL_Status != HAL_OK) {\n        (*UART_handle->hdmarx->XferAbortCallback)(UART_handle->hdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ffc": "handle_uart_interrupt_08002ffc",
                "huart": "UART_handle",
                "HVar1": "HAL_Status",
                "uVar2": "CR1_status",
                "uVar4": "CR3_status",
                "uVar5": "SR_status",
                "cr1its": "cr1_interrupts",
                "cr3its": "cr3_interrupts",
                "isrflags": "interrupt_flags",
                "pUVar3": "USART_instance"
            },
            "calling": [
                "USART3_IRQHandler",
                "USART6_IRQHandler",
                "UART7_IRQHandler",
                "UART4_IRQHandler",
                "UART8_IRQHandler",
                "USART1_IRQHandler",
                "USART2_IRQHandler",
                "UART5_IRQHandler"
            ],
            "called": [
                "UART_Receive_IT",
                "UART_Transmit_IT",
                "UART_EndRxTransfer",
                "UART_EndTransmit_IT",
                "HAL_UART_ErrorCallback",
                "HAL_DMA_Abort_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800311c": {
            "entrypoint": "0x0800311c",
            "current_name": "reset_uart_rx_tx_count_and_callback_0800311c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetUARTRxTxCountAndCallback_0800311c(DMA_HandleTypeDef *dma)\n\n{\n  UART_HandleTypeDef *parentUART;\n  UART_HandleTypeDef *currentUART;\n  \n  parentUART = (UART_HandleTypeDef *)dma->Parent;\n  parentUART->RxXferCount = 0;\n  parentUART->TxXferCount = 0;\n  HAL_UART_ErrorCallback(parentUART);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800311c": "reset_uart_rx_tx_count_and_callback_0800311c",
                "hdma": "dma",
                "huart_00": "parentUART",
                "huart": "currentUART"
            },
            "calling": [],
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800312c": {
            "entrypoint": "0x0800312c",
            "current_name": "get_combined_state_0800312c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_UART_StateTypeDef getCombinedState_0800312c(UART_HandleTypeDef *uart)\n\n{\n  return uart->RxState | uart->gState;\n}\n\n",
            "renaming": {
                "FUN_0800312c": "get_combined_state_0800312c",
                "huart": "uart"
            },
            "calling": [
                "serial_tx_active",
                "serial_rx_active"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003138": {
            "entrypoint": "0x08003138",
            "current_name": "check_pin_08003138",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool checkPin_08003138(PinName_conflict pinName,uint32_t *pinMap)\n\n{\n  uint32_t pinIndex;\n  \n  pinIndex = pinMap[(uint)((int)pinName << 0x18) >> 0x1c];\n  return (_Bool)((byte)(pinIndex >> ((int)pinName & 0xfU)) & 1);\n}\n\n",
            "renaming": {
                "FUN_08003138": "check_pin_08003138",
                "pin": "pinName",
                "map": "pinMap",
                "index": "pinIndex"
            },
            "calling": [
                "pinMode",
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800314e": {
            "entrypoint": "0x0800314e",
            "current_name": "update_pin_map_0800314e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updatePinMap_0800314e(pinName pin,uint32_t *pinMap)\n\n{\n  uint upperNibble;\n  uint32_t lowerNibble;\n  \n  upperNibble = (uint)((int)pin << 0x18) >> 0x1c;\n  pinMap[upperNibble] = pinMap[upperNibble] | 1 << ((int)pin & 0xfU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800314e": "update_pin_map_0800314e",
                "PinName_conflict": "pinName",
                "map": "pinMap",
                "uVar1": "upperNibble",
                "index": "lowerNibble"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800316c": {
            "entrypoint": "0x0800316c",
            "current_name": "clear_pin_map_bit_0800316c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearPinMapBit_0800316c(pin pin,uint32_t *pinMap)\n\n{\n  uint pinIndex;\n  uint32_t index;\n  \n  pinIndex = (uint)((int)pin << 0x18) >> 0x1c;\n  pinMap[pinIndex] = pinMap[pinIndex] & ~(1 << ((int)pin & 0xfU));\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800316c": "clear_pin_map_bit_0800316c",
                "PinName_conflict": "pin",
                "map": "pinMap",
                "uVar1": "pinIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800318c": {
            "entrypoint": "0x0800318c",
            "current_name": "get_gpio_0800318c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nGPIOType * getGPIO_0800318c(uint32_t portIndex)\n\n{\n  switch(portIndex) {\n  case 0:\n    return (GPIOType *)0x40020000;\n  case 1:\n    return (GPIOType *)0x40020400;\n  case 2:\n    return (GPIOType *)0x40020800;\n  case 3:\n    return (GPIOType *)0x40020c00;\n  case 4:\n    return (GPIOType *)0x40021000;\n  case 5:\n    return (GPIOType *)0x40021400;\n  case 6:\n    return (GPIOType *)0x40021800;\n  case 7:\n    return (GPIOType *)0x40021c00;\n  case 8:\n    return (GPIOType *)0x40022000;\n  case 9:\n    return (GPIOType *)0x40022400;\n  case 10:\n    return (GPIOType *)0x40022800;\n  default:\n    return (GPIOType *)0x0;\n  }\n}\n\n",
            "renaming": {
                "FUN_0800318c": "get_gpio_0800318c",
                "port_idx": "portIndex",
                "GPIO_TypeDef": "GPIOType"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080031fc": {
            "entrypoint": "0x080031fc",
            "current_name": "get_gpio_type_from_index_080031fc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * getGPIOTypeFromIndex_080031fc(uint32_t index)\n\n{\n  GPIO_TypeDef *gpioType;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister_1;\n  uint32_t temporaryRegister_2;\n  uint32_t temporaryRegister_3;\n  uint32_t temporaryRegister_4;\n  uint32_t temporaryRegister_5;\n  uint32_t temporaryRegister_6;\n  uint32_t temporaryRegister_7;\n  uint32_t temporaryRegister_8;\n  uint32_t temporaryRegister_9;\n  uint32_t temporaryRegister_10;\n  \n  switch(index) {\n  case 0:\n    _DAT_40023830 = _DAT_40023830 | 1;\n    gpioType = (GPIO_TypeDef *)0x40020000;\n    break;\n  case 1:\n    _DAT_40023830 = _DAT_40023830 | 2;\n    gpioType = (GPIO_TypeDef *)0x40020400;\n    break;\n  case 2:\n    _DAT_40023830 = _DAT_40023830 | 4;\n    gpioType = (GPIO_TypeDef *)0x40020800;\n    break;\n  case 3:\n    _DAT_40023830 = _DAT_40023830 | 8;\n    gpioType = (GPIO_TypeDef *)0x40020c00;\n    break;\n  case 4:\n    _DAT_40023830 = _DAT_40023830 | 0x10;\n    gpioType = (GPIO_TypeDef *)0x40021000;\n    break;\n  case 5:\n    _DAT_40023830 = _DAT_40023830 | 0x20;\n    gpioType = (GPIO_TypeDef *)0x40021400;\n    break;\n  case 6:\n    _DAT_40023830 = _DAT_40023830 | 0x40;\n    gpioType = (GPIO_TypeDef *)0x40021800;\n    break;\n  case 7:\n    _DAT_40023830 = _DAT_40023830 | 0x80;\n    gpioType = (GPIO_TypeDef *)0x40021c00;\n    break;\n  case 8:\n    _DAT_40023830 = _DAT_40023830 | 0x100;\n    gpioType = (GPIO_TypeDef *)0x40022000;\n    break;\n  case 9:\n    _DAT_40023830 = _DAT_40023830 | 0x200;\n    gpioType = (GPIO_TypeDef *)0x40022400;\n    break;\n  case 10:\n    _DAT_40023830 = _DAT_40023830 | 0x400;\n    gpioType = (GPIO_TypeDef *)0x40022800;\n    break;\n  default:\n    gpioType = (GPIO_TypeDef *)0x0;\n  }\n  return gpioType;\n}\n\n",
            "renaming": {
                "FUN_080031fc": "get_gpio_type_from_index_080031fc",
                "port_idx": "index",
                "pGVar1": "gpioType",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister_1",
                "tmpreg_2": "temporaryRegister_2",
                "tmpreg_3": "temporaryRegister_3",
                "tmpreg_4": "temporaryRegister_4",
                "tmpreg_5": "temporaryRegister_5",
                "tmpreg_6": "temporaryRegister_6",
                "tmpreg_7": "temporaryRegister_7",
                "tmpreg_8": "temporaryRegister_8",
                "tmpreg_9": "temporaryRegister_9",
                "tmpreg_10": "temporaryRegister_10"
            },
            "calling": [
                "digital_io_init",
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003380": {
            "entrypoint": "0x08003380",
            "current_name": "check_pin_function_08003380",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t checkPinFunction_08003380(PinName_conflict pinName)\n\n{\n  uint32_t pinFunction;\n  uint32_t shiftedFunction;\n  \n  pinFunction = pinNamemap_shiftedFunction(pinName,(PinMap_conflict *)&PinMap_DAC);\n  shiftedFunction = pinFunction << 0xc;\n  shiftedFunction = shiftedFunction >> 0x1b;\n  if (shiftedFunction != 2) {\n    return 0;\n  }\n  return 0x10;\n}\n\n",
            "renaming": {
                "FUN_08003380": "check_pin_function_08003380",
                "pin": "pinName",
                "uVar1": "pinFunction",
                "function": "shiftedFunction"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800339c": {
            "entrypoint": "0x0800339c",
            "current_name": "get_pin_function_0800339c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getPinFunction_0800339c(PinName_conflict pinName)\n\n{\n  uint32_t pinFunction;\n  uint32_t shiftedFunction;\n  \n  pinFunction = pinNamemap_shiftedFunction(pinName,(PinMap_conflict *)&PinMap_PWM);\n  shiftedFunction = pinFunction << 0xc;\n  shiftedFunction = shiftedFunction >> 0x1b;\n  if (shiftedFunction == 3) {\n    return 8;\n  }\n  if (shiftedFunction != 4) {\n    if (shiftedFunction != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
            "renaming": {
                "FUN_0800339c": "get_pin_function_0800339c",
                "pin": "pinName",
                "uVar1": "pinFunction",
                "function": "shiftedFunction"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033c8": {
            "entrypoint": "0x080033c8",
            "current_name": "clear_dac_interrupt_080033c8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid clear_DAC_interrupt_080033c8(DAC_HandleTypeDef *dac_handle)\n\n{\n  _DAT_40023840 = _DAT_40023840 & 0xdfffffff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033c8": "clear_dac_interrupt_080033c8",
                "hdac": "dac_handle"
            },
            "calling": [
                "HAL_DAC_DeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033d8": {
            "entrypoint": "0x080033d8",
            "current_name": "stop_and_deinit_dac_080033d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopAndDeinitDAC_080033d8(pin pin)\n\n{\n  uint32_t dacChannel;\n  uint32_t dacdacChannel;\n  DACHandle DacHandle;\n  \n  DacHandle.Instance = (DAC_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)&PinMap_DAC);\n  if ((DacHandle.Instance != (DAC_TypeDef *)0x0) &&\n     ((dacChannel = get_dac_channel(pin), dacChannel == 0 || (dacChannel == 0x10)))) {\n    HAL_DAC_Stop(&DacHandle,dacChannel);\n    HAL_DAC_DeInit(&DacHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033d8": "stop_and_deinit_dac_080033d8",
                "PinName_conflict": "pin",
                "Channel": "dacChannel",
                "DAC_HandleTypeDef": "DACHandle"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_DAC_Stop",
                "get_dac_channel",
                "HAL_DAC_DeInit",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800340c": {
            "entrypoint": "0x0800340c",
            "current_name": "disable_timer_clock_0800340c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_timer_clock_0800340c(TIM_HandleTypeDef *timer_handler)\n\n{\n  timer_disable_clock(timer_handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800340c": "disable_timer_clock_0800340c",
                "htim": "timer_handler"
            },
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "called": [
                "timer_disable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003414": {
            "entrypoint": "0x08003414",
            "current_name": "stop_pwm_08003414",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopPWM_08003414(PinName_conflict pinName)\n\n{\n  uint32_t pwmChannel;\n  uint32_t timpwmChannel;\n  uint32_t functionResult;\n  TIM_HandleTypeDef timInstance;\n  \n  timInstance.Instance = (TIM_TypeDef *)pinNamemap_peripheral(pinName,(PinMap_conflict *)&PinMap_PWM);\n  if ((timInstance.Instance != (TIM_TypeDef *)0x0) &&\n     ((((pwmChannel = get_pwm_channel(pinName), pwmChannel == 0 || (pwmChannel == 4)) || (pwmChannel == 8)) ||\n      ((pwmChannel == 0xc || (pwmChannel == 0x18)))))) {\n    functionResult = pinNamemap_function(pinName,(PinMap_conflict *)&PinMap_PWM);\n    if ((functionResult & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(&timInstance,pwmChannel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(&timInstance,pwmChannel);\n    }\n    HAL_TIM_PWM_DeInit(&timInstance);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003414": "stop_pwm_08003414",
                "pin": "pinName",
                "Channel": "pwmChannel",
                "uVar1": "functionResult",
                "timHandle": "timInstance"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "pinmap_function",
                "HAL_TIM_PWM_Stop",
                "get_pwm_channel",
                "HAL_TIM_PWM_DeInit",
                "pinmap_peripheral",
                "HAL_TIMEx_PWMN_Stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800346c": {
            "entrypoint": "0x0800346c",
            "current_name": "get_current_tick_0800346c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_tick_0800346c(void)\n\n{\n  uint32_t current_tick;\n  \n  current_tick = HAL_GetTick();\n  return current_tick;\n}\n\n",
            "renaming": {
                "FUN_0800346c": "get_current_tick_0800346c",
                "uVar1": "current_tick"
            },
            "calling": [
                "millis"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003474": {
            "entrypoint": "0x08003474",
            "current_name": "FUNC_08003474",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003474(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003474": "FUNC_08003474"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003476": {
            "entrypoint": "0x08003476",
            "current_name": "handle_system_tick_08003476",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSystemTick_08003476(void)\n\n{\n  incrementTick();\n  systemTickInterruptHandler();\n  handleNoOsSystick();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003476": "handle_system_tick_08003476",
                "HAL_IncTick": "incrementTick",
                "HAL_SYSTICK_IRQHandler": "systemTickInterruptHandler",
                "noOsSystickHandler": "handleNoOsSystick"
            },
            "calling": [],
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "noOsSystickHandler",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003486": {
            "entrypoint": "0x08003486",
            "current_name": "initialize_gpio_pin_08003486",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeGPIOPin_08003486(pinName pin,uint32_t pinMode,uint32_t pullType)\n\n{\n  GPIO_TypeDef *gpioPort;\n  GPIO_TypeDef *port;\n  GPIO_InitTypeDef gpioInitConfig;\n  \n  gpioPort = set_GPIO_Port_Clock((uint)((int)pin << 0x18) >> 0x1c);\n  gpioInitConfig.Pin = 1 << ((int)pin & 0xfU) & 0xffff;\n  gpioInitConfig.Speed = 2;\n  gpioInitConfig.Mode = pinMode;\n  gpioInitConfig.Pull = pullType;\n  HAL_GPIO_Init(gpioPort,&gpioInitConfig);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003486": "initialize_gpio_pin_08003486",
                "PinName_conflict": "pinName",
                "mode": "pinMode",
                "pull": "pullType",
                "GPIOx": "gpioPort",
                "GPIO_InitStructure": "gpioInitConfig"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034b6": {
            "entrypoint": "0x080034b6",
            "current_name": "write_pin_080034b6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid writePin_080034b6(GPIO_TypeDef *gpioPort,uint32_t pinNumber,uint32_t pinValue)\n\n{\n  if (pinValue == 0) {\n    HAL_GPIO_WritePin(gpioPort,(uint16_t)pinNumber,GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(gpioPort,(uint16_t)pinNumber,GPIO_PIN_SET);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080034b6": "write_pin_080034b6",
                "port": "gpioPort",
                "pin": "pinNumber",
                "val": "pinValue"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034ce": {
            "entrypoint": "0x080034ce",
            "current_name": "initialize_hardware_080034ce",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeHardware_080034ce(void)\n\n{\n  initializeHAL();\n  configureSystemClock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080034ce": "initialize_hardware_080034ce",
                "HAL_Init": "initializeHAL",
                "SystemClock_Config": "configureSystemClock"
            },
            "calling": [
                "init"
            ],
            "called": [
                "SystemClock_Config",
                "HAL_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034da": {
            "entrypoint": "0x080034da",
            "current_name": "find_peripheral_for_pin_080034da",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * findPeripheralForPin_080034da(PinName_conflict targetPin,PinMap_conflict *pinMapping)\n\n{\n  while( true ) {\n    if (pinMapping->targetPin == NotConnected) {\n      return (void *)0x0;\n    }\n    if (pinMapping->targetPin == targetPin) break;\n    pinMapping = pinMapping + 1;\n  }\n  return pinMapping->peripheral;\n}\n\n",
            "renaming": {
                "FUN_080034da": "find_peripheral_for_pin_080034da",
                "pin": "targetPin",
                "map": "pinMapping",
                "NC": "NotConnected"
            },
            "calling": [
                "pinmap_find_peripheral",
                "pinmap_peripheral"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034f4": {
            "entrypoint": "0x080034f4",
            "current_name": "peripheral_locator_080034f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * peripheralLocator_080034f4(pinName pin,pinMap *map)\n\n{\n  void *peripheralAddress;\n  \n  if (pin != NC) {\n    peripheralAddress = pinmap_find_peripheral(pin,map);\n    return peripheralAddress;\n  }\n  return (void *)0x0;\n}\n\n",
            "renaming": {
                "FUN_080034f4": "peripheral_locator_080034f4",
                "PinName_conflict": "pinName",
                "PinMap_conflict": "pinMap",
                "pvVar1": "peripheralAddress"
            },
            "calling": [
                "uart_debug_write",
                "uart_debug_init",
                "dac_stop",
                "uart_init",
                "pwm_stop"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003506": {
            "entrypoint": "0x08003506",
            "current_name": "find_pin_08003506",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName findPin_08003506(void *peripheral,PinMap *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->peripheral == (void *)0x0) {\n      return NotConnected;\n    }\n    if (pinMap->peripheral == peripheral) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->pin;\n}\n\n",
            "renaming": {
                "FUN_08003506": "find_pin_08003506",
                "map": "pinMap",
                "PinName_conflict": "PinName",
                "PinMap_conflict": "PinMap",
                "NC": "NotConnected"
            },
            "calling": [
                "pinmap_find_pin",
                "pinmap_pin"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800351e": {
            "entrypoint": "0x0800351e",
            "current_name": "find_pin_name_0800351e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict findPinName_0800351e(void *device,PinMap_conflict *pinMap)\n\n{\n  PinName_conflict pinName;\n  \n  if (device != (void *)0x0) {\n    pinName = pinpinMap_find_pin(device,pinMap);\n    return pinName;\n  }\n  return NC;\n}\n\n",
            "renaming": {
                "FUN_0800351e": "find_pin_name_0800351e",
                "peripheral": "device",
                "map": "pinMap",
                "PVar1": "pinName"
            },
            "calling": [
                "HardwareSerial",
                "uart_debug_init"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800352e": {
            "entrypoint": "0x0800352e",
            "current_name": "find_pin_function_0800352e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t findPinFunction_0800352e(PinName_conflict targetPin,PinMap_conflict *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->targetPin == NoConnection) {\n      return 0xffffffff;\n    }\n    if (pinMap->targetPin == targetPin) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->pinFunction;\n}\n\n",
            "renaming": {
                "FUN_0800352e": "find_pin_function_0800352e",
                "pin": "targetPin",
                "map": "pinMap",
                "NC": "NoConnection",
                "function": "pinFunction"
            },
            "calling": [
                "pinmap_function",
                "pinmap_find_function"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800354a": {
            "entrypoint": "0x0800354a",
            "current_name": "find_pin_function_0800354a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t findPinFunction_0800354a(PinName_conflict pinName,PinMap_conflict *pinMap)\n\n{\n  uint32_t result;\n  \n  if (pinName == NC) {\n    return 0xffffffff;\n  }\n  result = pinNamepinMap_find_function(pinName,pinMap);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800354a": "find_pin_function_0800354a",
                "pin": "pinName",
                "map": "pinMap",
                "uVar1": "result"
            },
            "calling": [
                "get_dac_channel",
                "get_pwm_channel",
                "uart_init",
                "pwm_stop"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800355e": {
            "entrypoint": "0x0800355e",
            "current_name": "check_if_pin_exists_in_map_0800355e",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool check_if_pin_exists_in_map_0800355e(pin_to_check pin_to_check,pin_map *pin_map)\n\n{\n  if (pin_to_check == not_connected) {\n    return false;\n  }\n  while( true ) {\n    if (pin_map->pin_to_check == not_connected) {\n      return false;\n    }\n    if (pin_to_check == pin_map->pin_to_check) break;\n    pin_map = pin_map + 1;\n  }\n  return true;\n}\n\n",
            "renaming": {
                "FUN_0800355e": "check_if_pin_exists_in_map_0800355e",
                "PinName_conflict": "pin_to_check",
                "PinMap_conflict": "pin_map",
                "pin": "pin_to_check",
                "map": "pin_map",
                "NC": "not_connected"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003582": {
            "entrypoint": "0x08003582",
            "current_name": "merge_pointers_08003582",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * merge_pointers_08003582(void *a,void *b)\n\n{\n  if (a != b) {\n    if (a == (void *)0x0) {\n      return b;\n    }\n    if (b == (void *)0x0) {\n      return a;\n    }\n    a = (void *)0x0;\n  }\n  return a;\n}\n\n",
            "renaming": {
                "FUN_08003582": "merge_pointers_08003582"
            },
            "calling": [
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003594": {
            "entrypoint": "0x08003594",
            "current_name": "execute_rtc_callback_08003594",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid execute_RTC_callback_08003594(RTC_HandleTypeDef *rtc_handle)\n\n{\n  if (user_callback != (callback_function)0x0) {\n    (*user_callback)(callback_data);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003594": "execute_rtc_callback_08003594",
                "hrtc": "rtc_handle",
                "RTCUserCallback": "user_callback",
                "voidCallbackPtr": "callback_function",
                "callbackUserData": "callback_data"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035ac": {
            "entrypoint": "0x080035ac",
            "current_name": "initialize_alarm_irq_handler_080035ac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeAlarmIRQHandler_080035ac(void)\n\n{\n  HAL_RTC_AlarmIRQHandler(&rtcHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035ac": "initialize_alarm_irq_handler_080035ac",
                "&RtcHandle": "&rtcHandle"
            },
            "calling": [],
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035bc": {
            "entrypoint": "0x080035bc",
            "current_name": "initialize_system_080035bc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_080035bc(void)\n\n{\n  _DAT_40023808 = 0;\n  _DAT_40023804 = 0x24003010;\n  _DAT_40023800 = _DAT_40023800 & 0xfef2ffff | 1;\n  _DAT_4002380c = 0;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035bc": "initialize_system_080035bc"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fc": {
            "entrypoint": "0x080035fc",
            "current_name": "clear_tim_instance_flags_080035fc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid clearTimInstanceFlags_080035fc(TIM_HandleTypeDef *timHandle)\n\n{\n  if (timHandle->timInstance == (TIM_TypeDef *)0x40010000) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffffffe;\n  }\n  if (timHandle->timInstance == (TIM_TypeDef *)0x40000000) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffe;\n  }\n  if (timHandle->timInstance == (TIM_TypeDef *)0x40000400) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffd;\n  }\n  if (timHandle->timInstance == (TIM_TypeDef *)0x40000800) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffb;\n  }\n  if (timHandle->timInstance == (TIM_TypeDef *)0x40000c00) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffff7;\n  }\n  if (timHandle->timInstance == (TIM_TypeDef *)0x40001000) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffef;\n  }\n  if (timHandle->timInstance == (TIM_TypeDef *)0x40001400) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffdf;\n  }\n  if (timHandle->timInstance == (TIM_TypeDef *)0x40010400) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffffffd;\n  }\n  if (timHandle->timInstance == (TIM_TypeDef *)0x40014000) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffeffff;\n  }\n  if (timHandle->timInstance == (TIM_TypeDef *)0x40014400) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffdffff;\n  }\n  if (timHandle->timInstance == (TIM_TypeDef *)0x40014800) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffbffff;\n  }\n  if (timHandle->timInstance == (TIM_TypeDef *)0x40001800) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffbf;\n  }\n  if (timHandle->timInstance == (TIM_TypeDef *)0x40001c00) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffff7f;\n  }\n  if (timHandle->timInstance == (TIM_TypeDef *)0x40002000) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffeff;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fc": "clear_tim_instance_flags_080035fc",
                "htim": "timHandle",
                "Instance": "timInstance"
            },
            "calling": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003750": {
            "entrypoint": "0x08003750",
            "current_name": "get_previous_stimer_08003750",
            "code": "\n/* WARNING: Unknown calling convention */\n\nprevious_stimer * get_previous_stimer_08003750(TIM_HandleTypeDef *timer_handle)\n\n{\n  return (previous_stimer *)&previous_timer_lock;\n}\n\n",
            "renaming": {
                "FUN_08003750": "get_previous_stimer_08003750",
                "htim": "timer_handle",
                "stimer_t": "previous_stimer",
                "htim[-1].Lock": "previous_timer_lock"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_OC_DelayElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003754": {
            "entrypoint": "0x08003754",
            "current_name": "handle_tim_event_08003754",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_tim_event_08003754(timer_handle *htim)\n\n{\n  timer_object *timer_obj;\n  timer_object *pointer_obj;\n  \n  timer_obj = get_timer_pointer_obj(htim);\n  if ((timer_obj->irqHandleOC != (_func_void_timer_object_ptr_uint32_t *)0x0) &&\n     (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*timer_obj->irqHandleOC)(timer_obj,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003754": "handle_tim_event_08003754",
                "TIM_HandleTypeDef": "timer_handle",
                "stimer_t": "timer_object",
                "psVar1": "timer_obj",
                "obj": "pointer_obj"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800376e": {
            "entrypoint": "0x0800376e",
            "current_name": "handle_timer_interrupt_0800376e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_timer_interrupt_0800376e(TIM_HandleTypeDef *timer_handle)\n\n{\n  stimer_t *timer_obj;\n  stimer_t *timer_obj;\n  \n  timer_obj = get_timer_timer_obj(timer_handle);\n  if (timer_obj->interrupt_handler != (_func_void_stimer_t_ptr *)0x0) {\n    (*timer_obj->interrupt_handler)(timer_obj);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800376e": "handle_timer_interrupt_0800376e",
                "htim": "timer_handle",
                "psVar1": "timer_obj",
                "obj": "timer_obj",
                "irqHandle": "interrupt_handler"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800377c": {
            "entrypoint": "0x0800377c",
            "current_name": "handle_timers_0800377c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimers_0800377c(void)\n\n{\n  if (timerHandles[0] != (TimerHandle *)0x0) {\n    handleTimerInterrupt(timerHandles[0]);\n  }\n  if (timerHandles[9] != (TimerHandle *)0x0) {\n    handleTimerInterrupt(timerHandles[9]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800377c": "handle_timers_0800377c",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleTimerInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003798": {
            "entrypoint": "0x08003798",
            "current_name": "handle_timer_interrupt_08003798",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_timer_interrupt_08003798(void)\n\n{\n  if (timers[1] != (TimerHandle *)0x0) {\n    handle_timer_irq(timers[1]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003798": "handle_timer_interrupt_08003798",
                "timer_handles": "timers",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handle_timer_irq"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037ac": {
            "entrypoint": "0x080037ac",
            "current_name": "handle_timer_interrupt_080037ac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_080037ac(void)\n\n{\n  if (timerHandles[2] != (TimerHandle *)0x0) {\n    handleTimerIRQ(timerHandles[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037ac": "handle_timer_interrupt_080037ac",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleTimerIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037c0": {
            "entrypoint": "0x080037c0",
            "current_name": "handle_timer_interrupt_080037c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_080037c0(void)\n\n{\n  if (timerHandles[3] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[3]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037c0": "handle_timer_interrupt_080037c0",
                "timer_handles": "timerHandles"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037d4": {
            "entrypoint": "0x080037d4",
            "current_name": "handle_tim_interrupt_080037d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimInterrupt_080037d4(void)\n\n{\n  if (timers[4] != (TimHandle *)0x0) {\n    handleTimIRQ(timers[4]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037d4": "handle_tim_interrupt_080037d4",
                "timer_handles": "timers",
                "TIM_HandleTypeDef": "TimHandle",
                "HAL_TIM_IRQHandler": "handleTimIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037e8": {
            "entrypoint": "0x080037e8",
            "current_name": "handle_fifth_timer_080037e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleFifthTimer_080037e8(void)\n\n{\n  if (timerHandles[5] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[5]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037e8": "handle_fifth_timer_080037e8",
                "timer_handles": "timerHandles",
                "timer_handles[5]": "timerHandles[5]"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037fc": {
            "entrypoint": "0x080037fc",
            "current_name": "handle_timer_interrupt_080037fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_080037fc(void)\n\n{\n  if (timerHandles[6] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[6]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037fc": "handle_timer_interrupt_080037fc",
                "timer_handles": "timerHandles"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003810": {
            "entrypoint": "0x08003810",
            "current_name": "handle_timer_interrupts_08003810",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupts_08003810(void)\n\n{\n  if (timerHandles[7] != (TimHandle *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[7]);\n  }\n  if (timerHandles[12] != (TimHandle *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[12]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003810": "handle_timer_interrupts_08003810",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimHandle"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800382c": {
            "entrypoint": "0x0800382c",
            "current_name": "handle_interrupt_if_timer_available_0800382c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleInterruptIfTimerAvailable_0800382c(void)\n\n{\n  if (timerHandles[8] != (TimerHandleStruct *)0x0) {\n    handleTimerInterrupt(timerHandles[8]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800382c": "handle_interrupt_if_timer_available_0800382c",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandleStruct",
                "HAL_TIM_IRQHandler": "handleTimerInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003840": {
            "entrypoint": "0x08003840",
            "current_name": "handle_timer_interrupt_08003840",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08003840(void)\n\n{\n  if (timerHandlers[10] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerHandlers[10]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003840": "handle_timer_interrupt_08003840",
                "timer_handles": "timerHandlers"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003854": {
            "entrypoint": "0x08003854",
            "current_name": "handle_timer_irq_08003854",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerIRQ_08003854(void)\n\n{\n  if (timerHandles[11] != (Timer_Handle *)0x0) {\n    handleIRQ(timerHandles[11]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003854": "handle_timer_irq_08003854",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "Timer_Handle",
                "HAL_TIM_IRQHandler": "handleIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003868": {
            "entrypoint": "0x08003868",
            "current_name": "handle_timer_interrupt_08003868",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08003868(void)\n\n{\n  if (timerHandles[13] != (TimerHandle *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[13]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003868": "handle_timer_interrupt_08003868",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800387c": {
            "entrypoint": "0x0800387c",
            "current_name": "get_i2_c_struct_0800387c",
            "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_struct * getI2CStruct_0800387c(I2C_HandleTypeDef *i2c_handle)\n\n{\n  return (i2c_struct *)&i2c_handle[-1].event_count;\n}\n\n",
            "renaming": {
                "FUN_0800387c": "get_i2_c_struct_0800387c",
                "hi2c": "i2c_handle",
                "i2c_t": "i2c_struct",
                "EventCount": "event_count"
            },
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003880": {
            "entrypoint": "0x08003880",
            "current_name": "handle_i2_c_data_08003880",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CData_08003880(I2C_HandleTypeDef *i2cHandle,uint8_t direction,uint16_t addressCode)\n\n{\n  i2cStruct *i2cObj;\n  i2cStruct *i2cObject;\n  \n  i2cObj = getI2CObject(i2cHandle);\n  if ((uint)addressCode == (i2cHandle->i2cInit).ownAddress) {\n    if (direction == '\\0') {\n      i2cObj->bufferSize = '\\0';\n      i2cObj->mode = '\\0';\n      if (i2cObj->onSlaveTransmit != (functionVoid *)0x0) {\n        (*i2cObj->onSlaveTransmit)();\n      }\n      slaveTransmitIT\n                (i2cHandle,i2cObj->buffer,(ushort)i2cObj->bufferSize,8);\n      return;\n    }\n    i2cObj->mode = '\\x01';\n    HAL_I2C_Slave_Sequential_Receive_IT(i2cHandle,i2cObj->buffer,0x20,8);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003880": "handle_i2_c_data_08003880",
                "hi2c": "i2cHandle",
                "TransferDirection": "direction",
                "AddrMatchCode": "addressCode",
                "piVar1": "i2cObj",
                "obj": "i2cObject",
                "get_i2c_obj": "getI2CObject",
                "Init": "i2cInit",
                "OwnAddress1": "ownAddress",
                "i2c_t": "i2cStruct",
                "i2cTxRxBufferSize": "bufferSize",
                "slaveMode": "mode",
                "i2c_onSlaveTransmit": "onSlaveTransmit",
                "_func_void": "functionVoid",
                "HAL_I2C_Slave_Sequential_Transmit_IT": "slaveTransmitIT",
                "i2cTxRxBuffer": "buffer"
            },
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "HAL_I2C_Slave_Sequential_Transmit_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080038d0": {
            "entrypoint": "0x080038d0",
            "current_name": "enable_slave_receive_interrupt_080038d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableSlaveReceiveInterrupt_080038d0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2c_t *i2cObj;\n  i2c_t *i2cObj;\n  uint bufferSize;\n  \n  i2cObj = getI2cObject(i2cHandle);\n  if (((i2cObj->onSlaveReceiveHandler != (functionPointer *)0x0) &&\n      (i2cObj->isSlaveMode == '\\x01')) &&\n     (bufferSize = 0x20 - *(byte *)&(i2cObj->i2cHandleVariable).transferSize & 0xff, bufferSize != 0)) {\n    (*i2cObj->onSlaveReceiveHandler)(i2cObj->buffer,bufferSize);\n  }\n  enableListenInterrupt(i2cHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080038d0": "enable_slave_receive_interrupt_080038d0",
                "hi2c": "i2cHandle",
                "piVar1": "i2cObj",
                "obj": "i2cObj",
                "uVar2": "bufferSize",
                "get_i2c_obj": "getI2cObject",
                "_func_void_uint8_t_ptr_int": "functionPointer",
                "HAL_I2C_EnableListen_IT": "enableListenInterrupt",
                "i2c_onSlaveReceive": "onSlaveReceiveHandler",
                "slaveMode": "isSlaveMode",
                "handle": "i2cHandleVariable",
                "XferSize": "transferSize",
                "i2cTxRxBuffer": "buffer"
            },
            "calling": [
                "I2C_Slave_STOPF",
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003900": {
            "entrypoint": "0x08003900",
            "current_name": "enable_listen_interrupts_08003900",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableListenInterrupts_08003900(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2c_t *i2cObj;\n  i2c_t *i2cObj;\n  \n  i2cObj = get_i2c_i2cObj(i2cHandle);\n  if (i2cObj->isMaster == '\\0') {\n    HAL_I2C_EnableListen_IT(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003900": "enable_listen_interrupts_08003900",
                "hi2c": "i2cHandle",
                "piVar1": "i2cObj",
                "obj": "i2cObj"
            },
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003918": {
            "entrypoint": "0x08003918",
            "current_name": "handle_i2_c_event_interrupt_08003918",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEventInterrupt_08003918(void)\n\n{\n  HAL_I2C_EV_IRQHandler(originalI2CHandles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003918": "handle_i2_c_event_interrupt_08003918",
                "i2c_handles": "originalI2CHandles"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003928": {
            "entrypoint": "0x08003928",
            "current_name": "handle_i2_c_error_interrupt_08003928",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CErrorInterrupt_08003928(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c_handles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003928": "handle_i2_c_error_interrupt_08003928"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003938": {
            "entrypoint": "0x08003938",
            "current_name": "handle_i2_c_events_08003938",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_I2C_events_08003938(void)\n\n{\n  handle_i2c_events(i2c_error_handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003938": "handle_i2_c_events_08003938",
                "I2C2_ER_IRQHandler::handle": "i2c_error_handler",
                "HAL_I2C_EV_IRQHandler": "handle_i2c_events"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003948": {
            "entrypoint": "0x08003948",
            "current_name": "handle_i2c_error_08003948",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_i2c_error_08003948(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c_error_handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003948": "handle_i2c_error_08003948",
                "I2C2_ER_IRQHandler::handle": "i2c_error_handler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003958": {
            "entrypoint": "0x08003958",
            "current_name": "handle_i2_c3_event_08003958",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2C3Event_08003958(void)\n\n{\n  handleI2CEvent(eventHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003958": "handle_i2_c3_event_08003958",
                "I2C3_ER_IRQHandler::handle": "eventHandler",
                "HAL_I2C_EV_IRQHandler": "handleI2CEvent"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003968": {
            "entrypoint": "0x08003968",
            "current_name": "handle_i2_c_error_08003968",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CError_08003968(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2cErrorHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003968": "handle_i2_c_error_08003968",
                "I2C3_ER_IRQHandler::handle": "i2cErrorHandler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003978": {
            "entrypoint": "0x08003978",
            "current_name": "initialize_serial_08003978",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_serial_08003978(serial_t *serial_object)\n\n{\n  void *a;\n  USART_TypeDef *tx_uart;\n  void *b;\n  USART_TypeDef *rx_uart;\n  USART_TypeDef *merged_peripheral;\n  GPIO_TypeDef *gpio_port;\n  GPIO_TypeDef *gpio_port;\n  uint32_t pin_function;\n  UART_HandleTypeDef *uart_handle;\n  uint32_t tmp_register;\n  uint32_t tmp_register_1;\n  uint32_t tmp_register_2;\n  uint32_t tmp_register_3;\n  uint32_t tmp_register_4;\n  uint32_t tmp_register_5;\n  uint32_t tmp_register_6;\n  uint32_t tmp_register_7;\n  GPIO_InitTypeDef gpio_init_struct;\n  \n  if (serial_object != (serial_t *)0x0) {\n    a = pinmap_peripheral(serial_object->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n    b = pinmap_peripheral(serial_object->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(\"ERROR: at least one UART pin has no peripheral\\n\");\n    }\n    else {\n      merged_peripheral = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      serial_object->uart = merged_peripheral;\n      if (merged_peripheral == (USART_TypeDef *)0x0) {\n        iprintf(\"ERROR: U(S)ART pins mismatch\\n\");\n      }\n      else {\n        if (merged_peripheral == (USART_TypeDef *)0x40011000) {\n          _DAT_40023824 = _DAT_40023824 & 0xffffffef;\n          _DAT_40023844 = _DAT_40023844 | 0x10;\n          serial_object->index = '\\0';\n          serial_object->irq = USART1_IRQn;\n        }\n        else if (merged_peripheral == (USART_TypeDef *)0x40004400) {\n          _DAT_40023820 = _DAT_40023820 & 0xfffdffff;\n          _DAT_40023840 = _DAT_40023840 | 0x20000;\n          serial_object->index = '\\x01';\n          serial_object->irq = USART2_IRQn;\n        }\n        else if (merged_peripheral == (USART_TypeDef *)0x40004800) {\n          _DAT_40023820 = _DAT_40023820 & 0xfffbffff;\n          _DAT_40023840 = _DAT_40023840 | 0x40000;\n          serial_object->index = '\\x02';\n          serial_object->irq = USART3_IRQn;\n        }\n        else if (merged_peripheral == (USART_TypeDef *)0x40004c00) {\n          _DAT_40023820 = _DAT_40023820 & 0xfff7ffff;\n          _DAT_40023840 = _DAT_40023840 | 0x80000;\n          serial_object->index = '\\x03';\n          serial_object->irq = UART4_IRQn;\n        }\n        else if (merged_peripheral == (USART_TypeDef *)0x40005000) {\n          _DAT_40023820 = _DAT_40023820 & 0xffefffff;\n          _DAT_40023840 = _DAT_40023840 | 0x100000;\n          serial_object->index = '\\x04';\n          serial_object->irq = UART5_IRQn;\n        }\n        else if (merged_peripheral == (USART_TypeDef *)0x40011400) {\n          _DAT_40023824 = _DAT_40023824 & 0xffffffdf;\n          _DAT_40023844 = _DAT_40023844 | 0x20;\n          serial_object->index = '\\x05';\n          serial_object->irq = USART6_IRQn;\n        }\n        else if (merged_peripheral == (USART_TypeDef *)0x40007800) {\n          _DAT_40023820 = _DAT_40023820 & 0xbfffffff;\n          _DAT_40023840 = _DAT_40023840 | 0x40000000;\n          serial_object->index = '\\x06';\n          serial_object->irq = UART7_IRQn;\n        }\n        else if (merged_peripheral == (USART_TypeDef *)0x40007c00) {\n          _DAT_40023820 = _DAT_40023820 & 0x7fffffff;\n          _DAT_40023840 = _DAT_40023840 | 0x80000000;\n          serial_object->index = '\\a';\n          serial_object->irq = UART8_IRQn;\n        }\n        gpio_port = set_GPIO_Port_Clock((uint)((int)serial_object->pin_rx << 0x18) >> 0x1c);\n        pin_function = pinmap_function(serial_object->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n        gpio_init_struct.Pin = 1 << (serial_object->pin_rx & 0xfU) & 0xffff;\n        gpio_init_struct.Mode = (pin_function >> 3 & 1) << 4 | pin_function & 7;\n        gpio_init_struct.Pull = (pin_function << 0x1a) >> 0x1e;\n        gpio_init_struct.Alternate = (pin_function << 0x11) >> 0x19;\n        gpio_init_struct.Speed = 3;\n        HAL_GPIO_Init(gpio_port,&gpio_init_struct);\n        gpio_port = set_GPIO_Port_Clock((uint)((int)serial_object->pin_tx << 0x18) >> 0x1c);\n        pin_function = pinmap_function(serial_object->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n        gpio_init_struct.Pin = 1 << (serial_object->pin_tx & 0xfU) & 0xffff;\n        gpio_init_struct.Mode = (pin_function >> 3 & 1) << 4 | pin_function & 7;\n        gpio_init_struct.Pull = (pin_function << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(gpio_port,&gpio_init_struct);\n        uart_handlers[serial_object->index] = &serial_object->handle;\n        (serial_object->handle).Instance = serial_object->uart;\n        (serial_object->handle).Init.BaudRate = serial_object->baudrate;\n        (serial_object->handle).Init.WordLength = serial_object->databits;\n        (serial_object->handle).Init.StopBits = serial_object->stopbits;\n        (serial_object->handle).Init.Parity = serial_object->parity;\n        (serial_object->handle).Init.Mode = 0xc;\n        (serial_object->handle).Init.HwFlowCtl = 0;\n        (serial_object->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&serial_object->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003978": "initialize_serial_08003978",
                "obj": "serial_object",
                "uart_tx": "tx_uart",
                "uart_rx": "rx_uart",
                "pUVar1": "merged_peripheral",
                "pGVar2": "gpio_port",
                "port": "gpio_port",
                "uVar3": "pin_function",
                "huart": "uart_handle",
                "tmpreg": "tmp_register",
                "tmpreg_1": "tmp_register_1",
                "tmpreg_2": "tmp_register_2",
                "tmpreg_3": "tmp_register_3",
                "tmpreg_4": "tmp_register_4",
                "tmpreg_5": "tmp_register_5",
                "tmpreg_6": "tmp_register_6",
                "tmpreg_7": "tmp_register_7",
                "GPIO_InitStruct": "gpio_init_struct"
            },
            "calling": [
                "begin",
                "uart_debug_init"
            ],
            "called": [
                "pinmap_function",
                "HAL_UART_Init",
                "pinmap_merge_peripheral",
                "HAL_GPIO_Init",
                "iprintf",
                "set_GPIO_Port_Clock",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003cc8": {
            "entrypoint": "0x08003cc8",
            "current_name": "initialize_serial_debug_08003cc8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialDebug_08003cc8(void)\n\n{\n  void *peripheralAddress;\n  \n  peripheralAddress = pinmap_peripheral(pinNumber,(PinMap_conflict *)txPinMap);\n  if (peripheralAddress != (void *)0x0) {\n    peripheralAddress = pinmap_peripheral(pinNumber,(PinMap_conflict *)txPinMap);\n    rxPin = pinmap_pin(peripheralAddress,(PinMap_conflict *)&PinMap_UART_RX);\n    txPin = pinNumber;\n    baudRate = 0x2580;\n    parity = 0;\n    dataBits = 0;\n    stopBits = 0;\n    initializeUart(serialDebugPtr);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003cc8": "initialize_serial_debug_08003cc8",
                "pvVar1": "peripheralAddress",
                "PD_8": "pinNumber",
                "&PinMap_UART_TX": "txPinMap",
                "serial_debug.pin_rx": "rxPin",
                "serial_debug.pin_tx": "txPin",
                "serial_debug.baudrate": "baudRate",
                "serial_debug.parity": "parity",
                "serial_debug.databits": "dataBits",
                "serial_debug.stopbits": "stopBits",
                "&serial_debug": "serialDebugPtr",
                "uart_init": "initializeUart"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "pinmap_pin",
                "uart_init",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d18": {
            "entrypoint": "0x08003d18",
            "current_name": "transmit_data_08003d18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nbufferSize_t transmitData_08003d18(uint8_t *dataBuffer,uint32_t bufferSize)\n\n{\n  HAL_StatusTypeDef transmitStatus;\n  uint32_t startTime;\n  uint32_t tickstart;\n  void *peripheral;\n  USART_TypeDef *peripheralInstance;\n  uint32_t currentTime;\n  uint handlerIndex;\n  \n  startTime = HAL_GetTick();\n  peripheral = pinmap_peripheral(PD_8,(PinMap_conflict *)&PinMap_UART_TX);\n  if (peripheral == (void *)0x0) {\n    return 0;\n  }\n  handlerIndex = 0;\n  while ((handlerIndex < 10 &&\n         ((uart_handlers[handlerIndex] == (UART_HandleTypeDef *)0x0 ||\n          (peripheralInstance = (USART_TypeDef *)pinmap_peripheral(PD_8,(PinMap_conflict *)&PinMap_UART_TX),\n          uart_handlers[handlerIndex]->Instance != peripheralInstance))))) {\n    handlerIndex = handlerIndex + 1 & 0xff;\n  }\n  if (9 < handlerIndex) {\n    if ((9 < serial_debug.index) && (uart_debug_init(), 9 < serial_debug.index)) {\n      return 0;\n    }\n    handlerIndex = (uint)serial_debug.index;\n  }\n  do {\n    transmitStatus = HAL_UART_Transmit(uart_handlers[handlerIndex],dataBuffer,(uint16_t)bufferSize,1000);\n    if (transmitStatus == HAL_OK) {\n      return bufferSize;\n    }\n    currentTime = HAL_GetTick();\n  } while (currentTime - startTime < 1000);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08003d18": "transmit_data_08003d18",
                "data": "dataBuffer",
                "size": "bufferSize",
                "HVar1": "transmitStatus",
                "uVar2": "startTime",
                "pvVar3": "peripheral",
                "pUVar4": "peripheralInstance",
                "uVar5": "currentTime",
                "uVar6": "handlerIndex"
            },
            "calling": [
                "_write"
            ],
            "called": [
                "HAL_GetTick",
                "uart_debug_init",
                "HAL_UART_Transmit",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003dd0": {
            "entrypoint": "0x08003dd0",
            "current_name": "check_uart_state_08003dd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_state_08003dd0(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(handlers[serial_object->index]);\n  return (uart_state & 0x22) == 0x22;\n}\n\n",
            "renaming": {
                "FUN_08003dd0": "check_uart_state_08003dd0",
                "obj": "serial_object",
                "HVar1": "uart_state",
                "uart_handlers": "handlers"
            },
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003df4": {
            "entrypoint": "0x08003df4",
            "current_name": "check_uart_state_08003df4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_state_08003df4(serial_t *serial_obj)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(uart_handlers[serial_obj->index]);\n  return (uart_state & 0x21) == 0x21;\n}\n\n",
            "renaming": {
                "FUN_08003df4": "check_uart_state_08003df4",
                "obj": "serial_obj",
                "HVar1": "uart_state"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e18": {
            "entrypoint": "0x08003e18",
            "current_name": "receive_data_08003e18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint receiveData_08003e18(serial_t *serialObject,uchar *c)\n\n{\n  uint8_t rxActive;\n  \n  if (serialObject == (serial_t *)0x0) {\n    return -1;\n  }\n  rxActive = serial_rx_active(serialObject);\n  if (rxActive == '\\0') {\n    *c = serialObject->recv;\n    HAL_UART_Receive_IT(uart_handlers[serialObject->index],&serialObject->recv,1);\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08003e18": "receive_data_08003e18",
                "obj": "serialObject",
                "uVar1": "rxActive"
            },
            "calling": [
                "_rx_complete_irq"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e54": {
            "entrypoint": "0x08003e54",
            "current_name": "initialize_serial_communication_08003e54",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_08003e54(serial_t *serialObject,_func_void_serial_t_ptr *serialCallback)\n\n{\n  byte index;\n  uint8_t rxActiveStatus;\n  \n  if (serialObject != (serial_t *)0x0) {\n    rxActiveStatus = serial_rx_active(serialObject);\n    if (rxActiveStatus == '\\0') {\n      index = serialObject->index;\n      rx_serialCallback[index] = serialCallback;\n      rx_serialCallback_serialObject[index] = serialObject;\n      HAL_NVIC_SetPriority(serialObject->irq,0,1);\n      HAL_NVIC_EnableIRQ(serialObject->irq);\n      HAL_UART_Receive_IT(uart_handlers[serialObject->index],&serialObject->recv,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e54": "initialize_serial_communication_08003e54",
                "obj": "serialObject",
                "callback": "serialCallback",
                "bVar1": "index",
                "uVar2": "rxActiveStatus"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority",
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003eac": {
            "entrypoint": "0x08003eac",
            "current_name": "initialize_serial_communication_08003eac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_08003eac(serial_t *serialObject,_func_int_serial_t_ptr *callbackFunction)\n\n{\n  byte index;\n  \n  if (serialObject != (serial_t *)0x0) {\n    index = serialObject->index;\n    transmitCallback[index] = callbackFunction;\n    transmitCallbackObject[index] = serialObject;\n    setInterruptPriority(serialObject->irq,0,2);\n    enableInterrupt(serialObject->irq);\n    transmitData(uartHandlers[serialObject->index],serialObject->transmitBuffer + serialObject->transmitTail,1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003eac": "initialize_serial_communication_08003eac",
                "obj": "serialObject",
                "callback": "callbackFunction",
                "bVar1": "index",
                "tx_callback": "transmitCallback",
                "tx_callback_obj": "transmitCallbackObject",
                "HAL_NVIC_SetPriority": "setInterruptPriority",
                "HAL_NVIC_EnableIRQ": "enableInterrupt",
                "HAL_UART_Transmit_IT": "transmitData",
                "uart_handlers": "uartHandlers",
                "tx_buff": "transmitBuffer",
                "tx_tail": "transmitTail"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f00": {
            "entrypoint": "0x08003f00",
            "current_name": "find_uart_handler_index_08003f00",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t find_uart_handler_index_08003f00(UART_HandleTypeDef *uart_handle)\n\n{\n  uint index;\n  \n  if (uart_handle == (UART_HandleTypeDef *)0x0) {\n    index = 10;\n  }\n  else {\n    index = 0;\n    while( true ) {\n      if (9 < index) {\n        return (uint8_t)index;\n      }\n      if (uart_handle == uart_handlers[index]) break;\n      index = index + 1 & 0xff;\n    }\n  }\n  return (uint8_t)index;\n}\n\n",
            "renaming": {
                "FUN_08003f00": "find_uart_handler_index_08003f00",
                "huart": "uart_handle",
                "uVar1": "index"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "HAL_UART_RxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f24": {
            "entrypoint": "0x08003f24",
            "current_name": "process_uart_data_08003f24",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid process_uart_data_08003f24(UART_HandleTypeDef *uart_handle)\n\n{\n  byte index;\n  uint8_t index;\n  uint converted_index;\n  \n  index = uart_index(uart_handle);\n  converted_index = (uint)index;\n  if (converted_index < 10) {\n    (*rx_callback[converted_index])(rx_callback_obj[converted_index]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f24": "process_uart_data_08003f24",
                "huart": "uart_handle",
                "bVar1": "index",
                "uVar2": "converted_index"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f48": {
            "entrypoint": "0x08003f48",
            "current_name": "transmit_data_08003f48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitData_08003f48(UART_HandleTypeDef *uartHandle)\n\n{\n  byte uartIndex;\n  uint8_t serialIndex;\n  int callbackResult;\n  serial_t *transmitObject;\n  serial_t *txCallbackObject;\n  uint callbackIndex;\n  \n  uartIndex = uart_serialIndex(uartHandle);\n  callbackIndex = (uint)uartIndex;\n  txCallbackObject = tx_callback_transmitObject[callbackIndex];\n  if ((callbackIndex < 10) && (callbackResult = (*tx_callback[callbackIndex])(txCallbackObject), callbackResult != -1)) {\n    HAL_UART_Transmit_IT(uart_handlers[txCallbackObject->serialIndex],txCallbackObject->tx_buff + txCallbackObject->tx_tail,1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f48": "transmit_data_08003f48",
                "huart": "uartHandle",
                "bVar1": "uartIndex",
                "index": "serialIndex",
                "iVar3": "callbackResult",
                "obj": "transmitObject",
                "psVar4": "txCallbackObject",
                "uVar2": "callbackIndex"
            },
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f94": {
            "entrypoint": "0x08003f94",
            "current_name": "initialize_uart_08003f94",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_uart_08003f94(UART_HandleTypeDef *uart_handler)\n\n{\n  uint32_t temporary_value;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f94": "initialize_uart_08003f94",
                "huart": "uart_handler",
                "tmpval": "temporary_value"
            },
            "calling": [
                "UART_DMAAbortOnError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fd4": {
            "entrypoint": "0x08003fd4",
            "current_name": "handle_uart_interrupt_08003fd4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_uart_interrupt_08003fd4(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(uart1_interrupt);\n  HAL_UART_IRQHandler(uart_handler_0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fd4": "handle_uart_interrupt_08003fd4",
                "USART1_IRQn": "uart1_interrupt",
                "uart_handlers[0]": "uart_handler_0"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fec": {
            "entrypoint": "0x08003fec",
            "current_name": "handle_usart2_irq_08003fec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_USART2_IRQ_08003fec(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART2_interrupt_number);\n  HAL_UART_IRQHandler(UART_handlers[1]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fec": "handle_usart2_irq_08003fec",
                "USART2_IRQn": "USART2_interrupt_number",
                "uart_handlers": "UART_handlers"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004004": {
            "entrypoint": "0x08004004",
            "current_name": "handle_usart3_irq_08004004",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_USART3_IRQ_08004004(void)\n\n{\n  clear_pending_IRQ(USART3_Interrupt);\n  if (uart_handler_array[2] != (UART_HandleTypeDef *)0x0) {\n    handle_UART_IRQ(uart_handler_array[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004004": "handle_usart3_irq_08004004",
                "uart_handlers": "uart_handler_array",
                "USART3_IRQn": "USART3_Interrupt",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_IRQ",
                "HAL_UART_IRQHandler": "handle_UART_IRQ"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800401c": {
            "entrypoint": "0x0800401c",
            "current_name": "handle_uart4_interrupt_0800401c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleUART4Interrupt_0800401c(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(uart4Interrupt);\n  HAL_UART_IRQHandler(uartHandler3);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800401c": "handle_uart4_interrupt_0800401c",
                "UART4_IRQn": "uart4Interrupt",
                "uart_handlers[3]": "uartHandler3"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004034": {
            "entrypoint": "0x08004034",
            "current_name": "handle_uart5_irq_08004034",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART5_IRQ_08004034(void)\n\n{\n  clear_pending_IRQ(UART5_IRQn);\n  handle_UART_IRQ(uart_handlers[4]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004034": "handle_uart5_irq_08004034",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_IRQ",
                "HAL_UART_IRQHandler": "handle_UART_IRQ"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800404c": {
            "entrypoint": "0x0800404c",
            "current_name": "handle_uart_interrupt_0800404c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_uart_interrupt_0800404c(void)\n\n{\n  clear_pending_interrupt(UART6_Interrupt);\n  handle_uart(handlers[5]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800404c": "handle_uart_interrupt_0800404c",
                "USART6_IRQn": "UART6_Interrupt",
                "uart_handlers": "handlers",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "HAL_UART_IRQHandler": "handle_uart"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004064": {
            "entrypoint": "0x08004064",
            "current_name": "handle_uart_interrupt_08004064",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_uart_interrupt_08004064(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(uart7_interrupt_num);\n  HAL_UART_IRQHandler(uart7_handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004064": "handle_uart_interrupt_08004064",
                "UART7_IRQn": "uart7_interrupt_num",
                "uart_handlers[6]": "uart7_handler"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800407c": {
            "entrypoint": "0x0800407c",
            "current_name": "handle_uart8_irq_0800407c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART8_IRQ_0800407c(void)\n\n{\n  clear_pending_IRQ(irq_type);\n  handle_UART_IRQ(handlers[7]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800407c": "handle_uart8_irq_0800407c",
                "UART8_IRQn": "irq_type",
                "uart_handlers": "handlers",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_IRQ",
                "HAL_UART_IRQHandler": "handle_UART_IRQ"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004094": {
            "entrypoint": "0x08004094",
            "current_name": "allocate_memory_08004094",
            "code": "\nvoid * allocate_memory_08004094(intptr_t size)\n\n{\n  char *current_heap_end;\n  char *previous_heap_end;\n  \n  if (_sbrk::heap_end == (char *)0x0) {\n    _sbrk::heap_end = &_ebss;\n  }\n  current_heap_end = _sbrk::heap_end;\n  if (_sbrk::heap_end + size <= &stack0x00000000) {\n    _sbrk::heap_end = _sbrk::heap_end + size;\n    return current_heap_end;\n  }\n  errno = 0xc;\n  return (void *)0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08004094": "allocate_memory_08004094",
                "__delta": "size",
                "pcVar1": "current_heap_end",
                "prev_heap_end": "previous_heap_end"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040d0": {
            "entrypoint": "0x080040d0",
            "current_name": "check_fd_validity_080040d0",
            "code": "\nint check_fd_validity_080040d0(int file_descriptor)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_080040d0": "check_fd_validity_080040d0",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_close_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040d6": {
            "entrypoint": "0x080040d6",
            "current_name": "set_file_permissions_080040d6",
            "code": "\nint setFilePermissions_080040d6(int fileDescriptor,stat *fileStats)\n\n{\n  *(undefined4 *)((int)&fileStats->device + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040d6": "set_file_permissions_080040d6",
                "__fd": "fileDescriptor",
                "__buf": "fileStats",
                "st_dev": "device"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e0": {
            "entrypoint": "0x080040e0",
            "current_name": "check_connection_080040e0",
            "code": "\nint check_connection_080040e0(int file_descriptor)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080040e0": "check_connection_080040e0",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e4": {
            "entrypoint": "0x080040e4",
            "current_name": "seek_file_080040e4",
            "code": "\n__off_t seekFile_080040e4(int fileDescriptor,__off_t offset,int origin)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040e4": "seek_file_080040e4",
                "__fd": "fileDescriptor",
                "__offset": "offset",
                "__whence": "origin"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e8": {
            "entrypoint": "0x080040e8",
            "current_name": "process_file_080040e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint process_file_080040e8(int file_descriptor,char *data_pointer,int data_length)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040e8": "process_file_080040e8",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "data_pointer",
                "len_UNUSED": "data_length"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040ec": {
            "entrypoint": "0x080040ec",
            "current_name": "write_debug_data_080040ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint write_debug_data_080040ec(int file_descriptor,char *data_ptr,int data_length)\n\n{\n  size_t bytes_written;\n  \n  bytes_written = uart_debug_write((uint8_t *)data_ptr,data_length);\n  return bytes_written;\n}\n\n",
            "renaming": {
                "FUN_080040ec": "write_debug_data_080040ec",
                "file_UNUSED": "file_descriptor",
                "ptr": "data_ptr",
                "len": "data_length",
                "sVar1": "bytes_written"
            },
            "calling": [
                "_write_r"
            ],
            "called": [
                "uart_debug_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040f8": {
            "entrypoint": "0x080040f8",
            "current_name": "loop_forever_080040f8",
            "code": "\nvoid loopForever_080040f8(int status)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080040f8": "loop_forever_080040f8",
                "__status": "status"
            },
            "calling": [
                "abort",
                "_exit"
            ],
            "called": [
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040fc": {
            "entrypoint": "0x080040fc",
            "current_name": "set_errno_080040fc",
            "code": "\nint setErrno_080040fc(processID_t processID,int signal)\n\n{\n  errorNumber = 0x16;\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_080040fc": "set_errno_080040fc",
                "__pid": "processID",
                "__sig": "signal",
                "errno": "errorNumber"
            },
            "calling": [
                "_kill_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800410c": {
            "entrypoint": "0x0800410c",
            "current_name": "get_process_id_0800410c",
            "code": "\n\n\n__pid_t get_process_id_0800410c(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0800410c": "get_process_id_0800410c"
            },
            "calling": [
                "_getpid_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004110": {
            "entrypoint": "0x08004110",
            "current_name": "configure_pin_08004110",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_08004110(uint32_t pinNumber,uint32_t pinMode)\n\n{\n  _Bool isConfigured;\n  PinName pin;\n  \n  if (pinNumber < 0x60) {\n    pin = *(PinName *)(&digitalPin + pinNumber * 2);\n  }\n  else {\n    pin = NotConnected;\n  }\n  if (pin != NotConnected) {\n    isConfigured = LSCNotConnectedEZRFG(pin,outputPinConfigured);\n    if (isConfigured) {\n      isConfigured = pinin_in_pininmapin(pin,(PinMap *)&DACPinMap);\n      if (isConfigured) {\n        stopDAC(pin);\n      }\n      else {\n        isConfigured = pinin_in_pininmapin(pin,(PinMap *)&PWMPinMap);\n        if (isConfigured) {\n          stopPWM(pin);\n        }\n      }\n      resetConfiguredPin(pin,outputPinConfigured);\n    }\n    switch(pinMode) {\n    case 0:\n      initializeDigitalIO(pin,0,0);\n      break;\n    case 1:\n      initializeDigitalIO(pin,1,0);\n      break;\n    case 2:\n      initializeDigitalIO(pin,0,1);\n      break;\n    case 3:\n      initializeDigitalIO(pin,0,2);\n    }\n    setConfiguredPin(pin,digPinConfigured);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004110": "configure_pin_08004110",
                "ulPin": "pinNumber",
                "ulMode": "pinMode",
                "_Var1": "isConfigured",
                "p": "pin",
                "g_anOutputPinConfigured": "outputPinConfigured",
                "PinName_conflict": "PinName",
                "NC": "NotConnected",
                "is_pin_configured": "isPinConfigured",
                "PinMap_conflict": "PinMap",
                "PinMap_DAC": "DACPinMap",
                "dac_stop": "stopDAC",
                "PinMap_PWM": "PWMPinMap",
                "pwm_stop": "stopPWM",
                "reset_pin_configured": "resetConfiguredPin",
                "digital_io_init": "initializeDigitalIO",
                "set_pin_configured": "setConfiguredPin",
                "g_digPinConfigured": "digPinConfigured"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "pin_in_pinmap",
                "reset_pin_configured",
                "digital_io_init",
                "set_pin_configured",
                "dac_stop",
                "is_pin_configured",
                "pwm_stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041bc": {
            "entrypoint": "0x080041bc",
            "current_name": "write_digital_pin_080041bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid writeDigitalPin_080041bc(uint32_t pinNumber,uint32_t pinValue)\n\n{\n  _Bool isPinConfigured;\n  GPIO_TypinConfigeDef *gpioPort;\n  PinName_conflict pinConfig;\n  uint pinIndex;\n  \n  if (pinNumber < 0x60) {\n    pinIndex = (uint)*(short *)(&digitalPin + pinNumber * 2);\n  }\n  else {\n    pinIndex = 0xffffffff;\n  }\n  if ((pinIndex != 0xffffffff) &&\n     (isPinConfigured = is_pinConfigin_configured((PinName_conflict)pinIndex,g_digPinConfigured), isPinConfigured)) {\n    gpioPort = get_GPIO_Port((pinIndex << 0x18) >> 0x1c);\n    digital_io_write(gpioPort,1 << (pinIndex & 0xf) & 0xffff,pinValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041bc": "write_digital_pin_080041bc",
                "ulPin": "pinNumber",
                "ulVal": "pinValue",
                "_Var1": "isPinConfigured",
                "port": "gpioPort",
                "p": "pinConfig",
                "uVar2": "pinIndex"
            },
            "calling": [
                "sendTxBuffer",
                "getRxBuffer",
                "begin"
            ],
            "called": [
                "digital_io_write",
                "get_GPIO_Port",
                "is_pin_configured"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004204": {
            "entrypoint": "0x08004204",
            "current_name": "get_current_milli_time_08004204",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_milli_time_08004204(void)\n\n{\n  uint32_t current_milli_time;\n  \n  current_milli_time = GetCurrentMilli();\n  return current_milli_time;\n}\n\n",
            "renaming": {
                "FUN_08004204": "get_current_milli_time_08004204",
                "uVar1": "current_milli_time"
            },
            "calling": [
                "sendTxBuffer",
                "poll"
            ],
            "called": [
                "GetCurrentMilli"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800420c": {
            "entrypoint": "0x0800420c",
            "current_name": "update_transmit_tail_0800420c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint HardwareSerial::updateTransmitTail_0800420c(serial_t_conflict *transmissionObject)\n\n{\n  ushort unsignedNewTail;\n  uint16_t maskedTail;\n  int newTail;\n  \n  newTail = transmissionObject->tx_tail + 1;\n  unsignedNewTail = (ushort)newTail;\n  maskedTail = unsignedNewTail & 0x7f;\n  if (newTail == 0) {\n    maskedTail = -(-unsignedNewTail & 0x7f);\n  }\n  transmissionObject->tx_tail = maskedTail;\n  if (transmissionObject->tx_head != transmissionObject->tx_tail) {\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "obj": "transmissionObject",
                "iVar3": "newTail",
                "uVar1": "unsignedNewTail",
                "uVar2": "maskedTail",
                "FUN_0800420c": "update_transmit_tail_0800420c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004240": {
            "entrypoint": "0x08004240",
            "current_name": "calculate_available_bytes_08004240",
            "code": "\n/* DWARF original prototype: int  available(HardwareSerial * serialInterface) */\n\nint __serialInterfacecall HardwareSerial::calculateAvailableBytes_08004240(HardwareSerial *serialInterface)\n\n{\n  return ((serialInterface->_serial).headPosition + 0x40) - (uint)(serialInterface->_serial).tailPosition & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_08004240": "calculate_available_bytes_08004240",
                "this": "serialInterface",
                "rx_head": "headPosition",
                "rx_tail": "tailPosition"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004254": {
            "entrypoint": "0x08004254",
            "current_name": "peek_08004254",
            "code": "\n/* DWARF original prototype: int  peek_08004254(HardwareSerial * serial) */\n\nint __serialcall HardwareSerial::peek_08004254(HardwareSerial *serial)\n\n{\n  uint tail;\n  \n  tail = (uint)(serial->_serial).tail;\n  if ((serial->_serial).head != tail) {\n    return (uint)(serial->_serial).buffer[tail];\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08004254": "peek_08004254",
                "this": "serial",
                "uVar1": "tail",
                "rx_tail": "tail",
                "rx_head": "head",
                "rx_buff": "buffer"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004270": {
            "entrypoint": "0x08004270",
            "current_name": "read_byte_08004270",
            "code": "\n/* DWARF original prototype: int  read(HardwareSerial * serialPort) */\n\nssize_t __serialPortcall\nHardwareSerial::readByte_08004270(HardwareSerial *serialPort,int fileDescriptor,void *buffer,size_t numBytes)\n\n{\n  byte byteValue;\n  ushort rxTail;\n  uchar c;\n  \n  rxTail = (serialPort->_serial).rx_tail;\n  if ((uint)(serialPort->_serial).rx_head != (uint)rxTail) {\n    byteValue = (serialPort->_serial).rx_buff[rxTail];\n    (serialPort->_serial).rx_tail = rxTail + 1 & 0x3f;\n    return (uint)byteValue;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "this": "serialPort",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "bVar1": "byteValue",
                "uVar2": "rxTail",
                "FUN_08004270": "read_byte_08004270"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004298": {
            "entrypoint": "0x08004298",
            "current_name": "flush_serial_08004298",
            "code": "\n/* DWARF original prototype: void  flush(HardwareSerial * serialObject) */\n\nvoid __serialObjectcall HardwareSerial::flushSerial_08004298(HardwareSerial *serialObject)\n\n{\n  if (serialObject->_written != false) {\n    do {\n    } while ((serialObject->_serial).tx_head != (serialObject->_serial).tx_tail);\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "serialObject",
                "FUN_08004298": "flush_serial_08004298"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042ac": {
            "entrypoint": "0x080042ac",
            "current_name": "handle_serial_data_080042ac",
            "code": "\n/* WARNING: Unknown callbufferIndexng conventbufferIndexon */\n\nvobufferIndexd HardwareSerbufferIndexal::handleSerialData_080042ac(serbufferIndexal_t_conflbufferIndexct *serialObj)\n\n{\n  bufferIndexnt status;\n  rx_buffer_bufferIndexndex_t bufferIndex;\n  ushort nextHeadIndex;\n  uchar c;\n  \n  status = uart_getc((serbufferIndexal_t *)serialObj,&c);\n  bufferIndexf ((status == 0) && (nextHeadIndex = serialObj->rx_head + 1 & 0x3f, nextHeadIndex != serialObj->rx_tabufferIndexl)) {\n    serialObj->rx_buff[serialObj->rx_head] = c;\n    serialObj->rx_head = nextHeadIndex;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080042ac": "handle_serial_data_080042ac",
                "obj": "serialObj",
                "iVar1": "status",
                "i": "bufferIndex",
                "uVar2": "nextHeadIndex"
            },
            "calling": [],
            "called": [
                "uart_getc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042e8": {
            "entrypoint": "0x080042e8",
            "current_name": "write_to_serial_buffer_080042e8",
            "code": "\n/* DWARF orloop_indexgloop_indexnal prototype: sloop_indexze_t  wrloop_indexte(HardwareSerloop_indexal * serial_port, uloop_indexnt8_t c) */\n\nssloop_indexze_t __serial_portcall\nHardwareSerloop_indexal::write_to_serial_buffer_080042e8(HardwareSerloop_indexal *serial_port,loop_indexnt data,voloop_indexd *buffer,sloop_indexze_t size)\n\n{\n  byte next_index;\n  uloop_indexnt8_t tx_active;\n  byte tail_index;\n  loop_indexnt head_index;\n  uloop_indexnt current_head;\n  tx_buffer_loop_indexndex_t loop_index;\n  \n  serial_port->_wrloop_indextten = true;\n  current_head = (uloop_indexnt)(serial_port->_serloop_indexal).tx_head;\n  head_index = current_head + 1;\n  next_index = (byte)head_index;\n  tail_index = next_index & 0x7f;\n  loop_indexf (head_index == 0) {\n    tail_index = -(-next_index & 0x7f);\n  }\n  do {\n  } whloop_indexle ((serial_port->_serloop_indexal).tx_taloop_indexl == (ushort)tail_index);\n  (serial_port->_serloop_indexal).tx_buff[current_head] = (uloop_indexnt8_t)data;\n  (serial_port->_serloop_indexal).tx_head = (ushort)tail_index;\n  tx_active = serloop_indexal_tx_actloop_indexve((serloop_indexal_t *)&serial_port->_serloop_indexal);\n  loop_indexf (tx_active == '\\0') {\n    uart_attach_tx_callback((serloop_indexal_t *)&serial_port->_serloop_indexal,_tx_complete_loop_indexrq + 1);\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "this": "serial_port",
                "__fd": "data",
                "__buf": "buffer",
                "__n": "size",
                "bVar1": "next_index",
                "uVar2": "tx_active",
                "bVar3": "tail_index",
                "iVar4": "head_index",
                "uVar5": "current_head",
                "i": "loop_index",
                "FUN_080042e8": "write_to_serial_buffer_080042e8"
            },
            "calling": [],
            "called": [
                "uart_attach_tx_callback",
                "serial_tx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004338": {
            "entrypoint": "0x08004338",
            "current_name": "FUNC_08004338",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800433e) */\n/* WARNING: Removing unreachable block (ram,0x08004350) */\n/* WARNING: Removing unreachable block (ram,0x08004346) */\n/* WARNING: Removing unreachable block (ram,0x08004358) */\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004338(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004338": "FUNC_08004338"
            },
            "calling": [
                "main"
            ],
            "called": [
                "available"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004364": {
            "entrypoint": "0x08004364",
            "current_name": "initialize_serial_08004364",
            "code": "\n/* DWARF original prototype: void  init(HardwareSerial * serialObj) */\n\nint __serialObjcall HardwareSerial::initializeSerial_08004364(HardwareSerial *serialObj,EVP_PKEY_CTX *keyContext)\n\n{\n  (serialObj->_serial).rx_buff = serialObj->_rx_buffer;\n  (serialObj->_serial).rx_head = 0;\n  (serialObj->_serial).rx_tail = 0;\n  (serialObj->_serial).tx_buff = serialObj->_tx_buffer;\n  (serialObj->_serial).tx_head = 0;\n  (serialObj->_serial).tx_tail = 0;\n  return (int)serialObj;\n}\n\n",
            "renaming": {
                "FUN_08004364": "initialize_serial_08004364",
                "this": "serialObj",
                "ctx": "keyContext"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004388": {
            "entrypoint": "0x08004388",
            "current_name": "configure_serial_port_08004388",
            "code": "\n/* DWARF original prototype: void  begin(HardwareSerial * serialPort, ulong baudRate, byte configuration) */\n\nvoid __serialPortcall HardwareSerial::configureSerialPort_08004388(HardwareSerial *serialPort,ulong baudRate,byte configuration)\n\n{\n  byte configMask;\n  int configValue;\n  \n  (serialPort->serialDataObject).baudRaterate = baudRate;\n  serialPort->_configuration = configuration;\n  configMask = configuration & 7;\n  if (configMask == 4) {\n    configValue = 7;\n  }\n  else if (configMask == 6) {\n    configValue = 8;\n  }\n  else if (configMask == 2) {\n    configValue = 6;\n  }\n  else {\n    configValue = 0;\n  }\n  if ((configuration & 0x30) == 0x30) {\n    (serialPort->serialDataObject).parity = 0x600;\n    configValue = configValue + 1;\n  }\n  else if ((configuration & 0x20) == 0) {\n    (serialPort->serialDataObject).parity = 0;\n  }\n  else {\n    (serialPort->serialDataObject).parity = 0x400;\n    configValue = configValue + 1;\n  }\n  if ((configuration & 8) == 0) {\n    (serialPort->serialDataObject).stopbits = 0;\n  }\n  else {\n    (serialPort->serialDataObject).stopbits = 0x2000;\n  }\n  if (configValue == 8) {\n    (serialPort->serialDataObject).databits = 0;\n  }\n  else if (configValue == 9) {\n    (serialPort->serialDataObject).databits = 0x1000;\n  }\n  else {\n    configValue = 0;\n  }\n  if (configValue != 0) {\n    initializeUART((serial_t *)&serialPort->serialDataObject);\n    attachRXCallbackToUART((serial_t *)&serialPort->serialDataObject,rxCompleteIRQ + 1);\n    return;\n  }\n                    \n  __assert_func(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/cores/arduino/HardwareSerial.cpp\"\n                ,299,\"void HardwareSerial::begin(long unsigned int, byte)\",\"databits!=0\");\n}\n\n",
            "renaming": {
                "FUN_08004388": "configure_serial_port_08004388",
                "this": "serialPort",
                "baud": "baudRate",
                "config": "configuration",
                "bVar1": "configMask",
                "iVar2": "configValue",
                "uart_init": "initializeUART",
                "uart_attach_rx_callback": "attachRXCallbackToUART",
                "_serial": "serialDataObject",
                "_rx_complete_irq": "rxCompleteIRQ"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "uart_attach_rx_callback",
                "__assert_func",
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004444": {
            "entrypoint": "0x08004444",
            "current_name": "set_rx_08004444",
            "code": "\n/* DWARF original prototype: void  setRx_08004444(HardwareSerial * serial, uint32_t pinIndex) */\n\nvoid __serialcall HardwareSerial::setRx_08004444(HardwareSerial *serial,uint32_t pinIndex)\n\n{\n  PinName pinName;\n  \n  if (pinIndex < 0x60) {\n    pinName = *(PinName *)(&digitalPin + pinIndex * 2);\n  }\n  else {\n    pinName = NC;\n  }\n  (serial->_serial).pinpinIndex = pinName;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004444": "set_rx_08004444",
                "this": "serial",
                "_rx": "pinIndex",
                "PVar1": "pinName"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004460": {
            "entrypoint": "0x08004460",
            "current_name": "set_tx_08004460",
            "code": "\n/* DWARF original prototype: void  setTx_08004460(HardwareSerial * serial, uint32_t pinIndex) */\n\nvoid __serialcall HardwareSerial::setTx_08004460(HardwareSerial *serial,uint32_t pinIndex)\n\n{\n  PinName pinName;\n  \n  if (pinIndex < 0x60) {\n    pinName = *(PinName *)(&digitalPin + pinIndex * 2);\n  }\n  else {\n    pinName = NC;\n  }\n  (serial->_serial).pinpinIndex = pinName;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004460": "set_tx_08004460",
                "this": "serial",
                "_tx": "pinIndex",
                "PVar1": "pinName"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800447c": {
            "entrypoint": "0x0800447c",
            "current_name": "initialize_serial_0800447c",
            "code": "\n/* DWARF original prototype: HardwareSerial *  HardwareSerial(HardwareSerial * serialObject, void *\n   peripheralObject) */\n\nHardwareSerial * __serialObjectcall HardwareSerial::initializeSerial_0800447c(HardwareSerial *serialObject,void *peripheralObject)\n\n{\n  PinName_conflict pinName;\n  EVP_PKEY_CTX *context1;\n  EVP_PKEY_CTX *context2;\n  EVP_PKEY_CTX *context3;\n  \n  (serialObject->super_Stream).super_Print.write_error = 0;\n  (serialObject->super_Stream)._timeout = 1000;\n  (serialObject->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)&PTR_write_1_08005ed4;\n  if (serialObject == &Serial3) {\n    setRx(&Serial3,0x4c);\n    setTx(&Serial3,0x4d);\n    context2 = context3;\n  }\n  else {\n    pinName = pinmap_pin(peripheralObject,(PinMap_conflict *)&PinMap_UART_RX);\n    (serialObject->_serial).pin_rx = pinName;\n    pinName = pinmap_pin(peripheralObject,(PinMap_conflict *)&PinMap_UART_TX);\n    (serialObject->_serial).pin_tx = pinName;\n    context2 = context1;\n  }\n  init(serialObject,context2);\n  return serialObject;\n}\n\n",
            "renaming": {
                "this": "serialObject",
                "peripheral": "peripheralObject",
                "PVar1": "pinName",
                "extraout_r1": "context1",
                "ctx": "context2",
                "extraout_r1_00": "context3",
                "FUN_0800447c": "initialize_serial_0800447c"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "pinmap_pin",
                "init",
                "setTx",
                "setRx"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080044d8": {
            "entrypoint": "0x080044d8",
            "current_name": "initialize_hardware_serial_080044d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeHardwareSerial_080044d8(int isInitialized,int priority)\n\n{\n  if (isInitialized != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    initializeSerial(serialInstance,(void *)0x40004800);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080044d8": "initialize_hardware_serial_080044d8",
                "__initialize_p": "isInitialized",
                "__priority": "priority",
                "HardwareSerial::HardwareSerial": "initializeSerial",
                "&Serial3": "serialInstance"
            },
            "calling": [
                "_GLOBAL__sub_I_Serial3"
            ],
            "called": [
                "HardwareSerial"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080044fc": {
            "entrypoint": "0x080044fc",
            "current_name": "initialize_static_resources_080044fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_resources_080044fc(void)\n\n{\n  initialize_resources(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080044fc": "initialize_static_resources_080044fc",
                "__static_initialization_and_destruction_0": "initialize_resources"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800450a": {
            "entrypoint": "0x0800450a",
            "current_name": "print_ip_address_0800450a",
            "code": "\n/* DWARF original printerrototyprintere: size_t  printerrintTo(IPAddress * ipAddress, Print * printer) */\n\nsize_t __ipAddresscall IPAddress::printIPAddress_0800450a(IPAddress *ipAddress,Print *printer)\n\n{\n  size_t numBytesPrinted;\n  size_t dotPrinted;\n  int byteIndex;\n  int totalBytesPrinted;\n  \n  totalBytesPrinted = 0;\n  for (byteIndex = 0; byteIndex < 3; byteIndex = byteIndex + 1) {\n    numBytesPrinted = Print::printerrint(printer,(ipAddress->_address).bytes[byteIndex],10);\n    dotPrinted = Print::printerrint(printer,'.');\n    totalBytesPrinted = totalBytesPrinted + numBytesPrinted + dotPrinted;\n  }\n  numBytesPrinted = Print::printerrint(printer,(ipAddress->_address).bytes[3],10);\n  return numBytesPrinted + totalBytesPrinted;\n}\n\n",
            "renaming": {
                "FUN_0800450a": "print_ip_address_0800450a",
                "this": "ipAddress",
                "p": "printer",
                "iVar4": "totalBytesPrinted",
                "iVar3": "byteIndex",
                "sVar1": "numBytesPrinted",
                "sVar2": "dotPrinted"
            },
            "calling": [],
            "called": [
                "print",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004544": {
            "entrypoint": "0x08004544",
            "current_name": "set_ip_address_08004544",
            "code": "\n/* DWARF original prototype: IPAddress *  IPAddress(IPAddress * ipAddress, uint8_t octet1, uint8_t\n   octet2, uint8_t octet3, uint8_t octet4) */\n\nIPAddress * __ipAddresscall\nIPAddress::setIPAddress_08004544(IPAddress *ipAddress,uint8_t octet1,uint8_t octet2,uint8_t octet3,\n          uint8_t octet4)\n\n{\n  (ipAddress->super_Printable)._vptr_Printable = (_func_int_varargs **)&DAT_08005f28;\n  (ipAddress->_address).bytes[0] = octet1;\n  (ipAddress->_address).bytes[1] = octet2;\n  (ipAddress->_address).bytes[2] = octet3;\n  (ipAddress->_address).bytes[3] = octet4;\n  return ipAddress;\n}\n\n",
            "renaming": {
                "this": "ipAddress",
                "first_octet": "octet1",
                "second_octet": "octet2",
                "third_octet": "octet3",
                "fourth_octet": "octet4",
                "FUN_08004544": "set_ip_address_08004544"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004560": {
            "entrypoint": "0x08004560",
            "current_name": "initialize_ip_address_08004560",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIPAddress_08004560(int isInitialSetup,int priorityLevel)\n\n{\n  if ((isInitialSetup == 1) && (priorityLevel == 0xffff)) {\n    IP::IP(&invalidAddress,'\\0','\\0','\\0','\\0');\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004560": "initialize_ip_address_08004560",
                "__initialize_p": "isInitialSetup",
                "__priority": "priorityLevel",
                "INADDR_NONE": "invalidAddress",
                "IPAddress": "IP"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "called": [
                "IPAddress"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800458c": {
            "entrypoint": "0x0800458c",
            "current_name": "initialize_static_resources_0800458c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_resources_0800458c(void)\n\n{\n  perform_static_initialization_and_destruction(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800458c": "initialize_static_resources_0800458c",
                "__static_initialization_and_destruction_0": "perform_static_initialization_and_destruction"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800459a": {
            "entrypoint": "0x0800459a",
            "current_name": "write_to_print_0800459a",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080045ae */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * this, uint8_t * buffer, size_t size) */\n\nssize_t this Print::write_to_print_0800459a(Print *this,int file_descriptor,void *buffer,size_t size)\n\n{\n  Print *print_object;\n  int iteration_count;\n  \n  iteration_count = 0;\n  print_object = this;\n  while( true ) {\n    if (buffer == (void *)0x0) {\n      return iteration_count;\n    }\n    print_object = (Print *)(**this->_vptr_Print)(print_object,(uint)*(byte *)file_descriptor,buffer,*this->_vptr_Print,size)\n    ;\n    if (print_object == (Print *)0x0) break;\n    iteration_count = iteration_count + 1;\n    file_descriptor = (int)(file_descriptor + 1);\n    buffer = (void *)((int)buffer + -1);\n  }\n  return iteration_count;\n}\n\n",
            "renaming": {
                "FUN_0800459a": "write_to_print_0800459a",
                "__thiscall": "this",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "size",
                "iVar2": "iteration_count",
                "pPVar1": "print_object"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045be": {
            "entrypoint": "0x080045be",
            "current_name": "print_character_080045be",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080045c4 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * printer, char c) */\n\nsize_t __printercall Print::printCharacter_080045be(Print *printer,char c)\n\n{\n  size_t result;\n  \n  result = (**printer->_vptr_Print)(printer,(int)c);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080045be": "print_character_080045be",
                "this": "printer",
                "sVar1": "result"
            },
            "calling": [
                "printTo"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045c8": {
            "entrypoint": "0x080045c8",
            "current_name": "print_number_080045c8",
            "code": "\n/* WARNING: Heritage AFTER dead redividendoval. Exadividendple locationumber: r0 : 0x08004618 */\n/* WARNING: Restarted to delay deadcode elidividendinumberationumber for space: register */\n/* WARNING: Exceeded dividendaxidividendudividend restarts with dividendore penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbertNudividendber(Prinumbert * printer, ulonumberg number, uinumbert8_t base) */\n\nsize_t __printercall Prinumbert::printNumber_080045c8(Prinumbert *printer,ulonumberg number,uinumbert8_t base)\n\n{\n  char convertedChar;\n  char c;\n  size_t stringLength;\n  size_t result;\n  ulonumberg dividend;\n  uinumbert remainder;\n  uinumbert originalBase;\n  uinumbert quotient;\n  char *buffer;\n  char charBuffer [33];\n  \n  originalBase = (uinumbert)base;\n  charBuffer[32] = '\\0';\n  if (originalBase < 2) {\n    originalBase = 10;\n  }\n  buffer = charBuffer + 0x20;\n  dividend = number;\n  do {\n    quotient = dividend / originalBase;\n    remainder = (dividend & 0xff) - ((inumbert)(short)quotient * (inumbert)(short)originalBase & 0xffU) & 0xff;\n    buffer = buffer + -1;\n    convertedChar = (char)remainder;\n    if (remainder < 10) {\n      convertedChar = convertedChar + '0';\n    }\n    else {\n      convertedChar = convertedChar + '7';\n    }\n    *buffer = convertedChar;\n    dividend = quotient;\n  } while (quotient != 0);\n  if (buffer == (char *)0x0) {\n    result = 0;\n  }\n  else {\n    stringLength = strlenumber(buffer);\n    result = (*printer->_vptr_Prinumbert[1])(stringLength,buffer,stringLength);\n  }\n  returnumber result;\n}\n\n",
            "renaming": {
                "FUN_080045c8": "print_number_080045c8",
                "this": "printer",
                "n": "number",
                "sVar2": "stringLength",
                "sVar3": "result",
                "m": "dividend",
                "uVar4": "remainder",
                "uVar5": "originalBase",
                "uVar6": "quotient",
                "__s": "buffer",
                "buf": "charBuffer",
                "cVar1": "convertedChar"
            },
            "calling": [
                "print"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004622": {
            "entrypoint": "0x08004622",
            "current_name": "print_number_if_base_not_zero_08004622",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example locationumber: r0 : 0x08004634 */\n/* WARNING: Restarted to delay deadcode eliminumberationumber for space: register */\n/* WARNING: Exceeded maximum restarts with more penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbert(PrintClass * self, ulonumberg number, inumbert base) */\n\nsize_t __selfcall PrintClass::printNumberIfBaseNotZero_08004622(PrintClass *self,ulonumberg number,inumbert base)\n\n{\n  size_t sVar1;\n  \n  if (base != 0) {\n    sVar1 = prinumbertNumber(self,number,(uinumbert8_t)base);\n    returnumber sVar1;\n  }\n  sVar1 = (**self->_vptr_PrintClass)(self,number & 0xff);\n  returnumber sVar1;\n}\n\n",
            "renaming": {
                "Print": "PrintClass",
                "this": "self",
                "n": "number",
                "FUN_08004622": "print_number_if_base_not_zero_08004622"
            },
            "calling": [
                "print"
            ],
            "called": [
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004638": {
            "entrypoint": "0x08004638",
            "current_name": "print_byte_08004638",
            "code": "\n/* DWARF original prototype: size_t  print(Printer * this, byte b, int numberBase) */\n\nsize_t __thiscall Printer::printByte_08004638(Printer *this,byte b,int numberBase)\n\n{\n  size_t result;\n  \n  result = print(this,(uint)b,numberBase);\n  return result;\n}\n\n",
            "renaming": {
                "Print": "Printer",
                "uchar": "byte",
                "base": "numberBase",
                "sVar1": "result",
                "FUN_08004638": "print_byte_08004638"
            },
            "calling": [
                "printTo"
            ],
            "called": [
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004640": {
            "entrypoint": "0x08004640",
            "current_name": "concatenate_bytes_08004640",
            "code": "\n/* WARNING: Unknown calow_bytelow_byteing convention */\n\nuint16_t concatenate_bytes_08004640(uint8_t high_byte,uint8_t low_byte)\n\n{\n  return CONCAT11(high_byte,low_byte);\n}\n\n",
            "renaming": {
                "FUN_08004640": "concatenate_bytes_08004640",
                "h": "high_byte",
                "l": "low_byte"
            },
            "calling": [
                "process_FC1",
                "process_FC3",
                "process_FC15",
                "process_FC5",
                "process_FC6",
                "validateRequest",
                "process_FC16"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004646": {
            "entrypoint": "0x08004646",
            "current_name": "FUNC_08004646",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004646(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004646": "FUNC_08004646"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004648": {
            "entrypoint": "0x08004648",
            "current_name": "initialize_pkey_context_08004648",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePKEYContext_08004648(void)\n\n{\n  EVP_PKEY_CTX *context;\n  \n  context = (EVP_PKEY_CTX *)0x3;\n  setPriorityGrouping(3);\n  initialize(context);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004648": "initialize_pkey_context_08004648",
                "ctx": "context",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping",
                "init": "initialize"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004658": {
            "entrypoint": "0x08004658",
            "current_name": "run_loop_08004658",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint runLoop_08004658(void)\n\n{\n  initializeVariant();\n  initializeSetup();\n  do {\n    executeLoop();\n    runSerialEvent();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004658": "run_loop_08004658",
                "initVariant": "initializeVariant",
                "setup": "initializeSetup",
                "loop": "executeLoop",
                "serialEventRun": "runSerialEvent"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "setup",
                "initVariant",
                "loop",
                "serialEventRun"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004678": {
            "entrypoint": "0x08004678",
            "current_name": "count_set_bits_08004678",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t countSetBits_08004678(uint16_t inputPin)\n\n{\n  uint shiftedValue;\n  uint8_t bitCount;\n  \n  bitCount = '\\0';\n  for (shiftedValue = (uint)inputPin; shiftedValue != 1; shiftedValue = shiftedValue >> 1) {\n    bitCount = bitCount + '\\x01';\n  }\n  return bitCount;\n}\n\n",
            "renaming": {
                "FUN_08004678": "count_set_bits_08004678",
                "pin": "inputPin",
                "uVar1": "shiftedValue",
                "uVar2": "bitCount"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800468c": {
            "entrypoint": "0x0800468c",
            "current_name": "deallocate_gpio_irq_conf_0800468c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid deallocate_gpio_irq_conf_0800468c(void *pgVar1)\n\n{\n  gpioConfig *currConfig;\n  _Manager_type manager;\n  gpioConfig *prevConfig;\n  \n  currConfig = (gpioConfig *)&__malloc_free_list;\n  while (prevConfig = currConfig, prevConfig != gpio_irq_conf) {\n    manager = prevConfig[-1].callback.super__Function_base._M_manager;\n    currConfig = prevConfig + -1;\n    if (manager != (_Manager_type)0x0) {\n      (*manager)((_Any_data *)&prevConfig[-1].callback,(_Any_data *)&prevConfig[-1].callback,\n                __destroy_functor);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800468c": "deallocate_gpio_irq_conf_0800468c",
                "param_1": "pgVar1",
                "gpio_irq_conf_str": "gpioConfig",
                "pgVar1": "currConfig",
                "p_Var2": "manager",
                "pgVar3": "prevConfig"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046b4": {
            "entrypoint": "0x080046b4",
            "current_name": "initialize_gpio_irq_configuration_080046b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_gpio_irq_configuration_080046b4(int initialize_flag,int priority)\n\n{\n  if (initialize_flag != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    gpio_irq_configuration[0].irqnb = IRQn_EXTI0;\n    gpio_irq_configuration[0].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[1].irqnb = IRQn_EXTI1;\n    gpio_irq_configuration[1].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[2].irqnb = IRQn_EXTI2;\n    gpio_irq_configuration[2].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[3].irqnb = IRQn_EXTI3;\n    gpio_irq_configuration[3].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[4].irqnb = IRQn_EXTI4;\n    gpio_irq_configuration[4].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[5].irqnb = IRQn_EXTI9_5;\n    gpio_irq_configuration[5].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[6].irqnb = IRQn_EXTI9_5;\n    gpio_irq_configuration[6].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[7].irqnb = IRQn_EXTI9_5;\n    gpio_irq_configuration[7].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[8].irqnb = IRQn_EXTI9_5;\n    gpio_irq_configuration[8].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[9].irqnb = IRQn_EXTI9_5;\n    gpio_irq_configuration[9].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[10].irqnb = IRQn_EXTI15_10;\n    gpio_irq_configuration[10].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[11].irqnb = IRQn_EXTI15_10;\n    gpio_irq_configuration[11].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[12].irqnb = IRQn_EXTI15_10;\n    gpio_irq_configuration[12].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[13].irqnb = IRQn_EXTI15_10;\n    gpio_irq_configuration[13].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[14].irqnb = IRQn_EXTI15_10;\n    gpio_irq_configuration[14].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[15].irqnb = IRQn_EXTI15_10;\n    gpio_irq_configuration[15].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    register_atexit_function(0,0x800468d,0x20000000);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046b4": "initialize_gpio_irq_configuration_080046b4",
                "__initialize_p": "initialize_flag",
                "__priority": "priority",
                "gpio_irq_conf": "gpio_irq_configuration",
                "EXTI0_IRQn": "IRQn_EXTI0",
                "EXTI1_IRQn": "IRQn_EXTI1",
                "EXTI2_IRQn": "IRQn_EXTI2",
                "EXTI3_IRQn": "IRQn_EXTI3",
                "EXTI4_IRQn": "IRQn_EXTI4",
                "EXTI9_5_IRQn": "IRQn_EXTI9_5",
                "EXTI15_10_IRQn": "IRQn_EXTI15_10",
                "__aeabi_atexit": "register_atexit_function"
            },
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "called": [
                "__aeabi_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004760": {
            "entrypoint": "0x08004760",
            "current_name": "handle_gpio_exti_interrupt_08004760",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_EXTI_interrupt_08004760(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004760": "handle_gpio_exti_interrupt_08004760"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800476a": {
            "entrypoint": "0x0800476a",
            "current_name": "handle_external_interrupt_0800476a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_external_interrupt_0800476a(void)\n\n{\n  handle_GPIO_external_interrupt(2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800476a": "handle_external_interrupt_0800476a",
                "HAL_GPIO_EXTI_IRQHandler": "handle_GPIO_external_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004774": {
            "entrypoint": "0x08004774",
            "current_name": "handle_external_interrupt_08004774",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_08004774(void)\n\n{\n  handleGPIOExternalInterrupt(4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004774": "handle_external_interrupt_08004774",
                "HAL_GPIO_EXTI_IRQHandler": "handleGPIOExternalInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800477e": {
            "entrypoint": "0x0800477e",
            "current_name": "handle_external_interrupt_0800477e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_0800477e(void)\n\n{\n  triggerExternalInterrupt(8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800477e": "handle_external_interrupt_0800477e",
                "HAL_GPIO_EXTI_IRQHandler": "triggerExternalInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004788": {
            "entrypoint": "0x08004788",
            "current_name": "handle_gpio_exti_interrupt_08004788",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_gpio_exti_interrupt_08004788(void)\n\n{\n  gpio_exti_irq_handler(0x10);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004788": "handle_gpio_exti_interrupt_08004788",
                "HAL_GPIO_EXTI_IRQHandler": "gpio_exti_irq_handler"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004792": {
            "entrypoint": "0x08004792",
            "current_name": "handle_external_interrupts_08004792",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupts_08004792(void)\n\n{\n  uint loopCount;\n  \n  for (loopCount = 0x20; loopCount < 0x201; loopCount = loopCount << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)loopCount);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004792": "handle_external_interrupts_08004792",
                "uVar1": "loopCount"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047a8": {
            "entrypoint": "0x080047a8",
            "current_name": "handle_gpio_exti_080047a8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_EXTI_080047a8(void)\n\n{\n  uint multiplier;\n  \n  for (multiplier = 0x400; multiplier < 0x8001; multiplier = multiplier << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)multiplier);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047a8": "handle_gpio_exti_080047a8",
                "uVar1": "multiplier"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047c0": {
            "entrypoint": "0x080047c0",
            "current_name": "invoke_function_080047c0",
            "code": "\n/* DWARF original prototype: invokeFunction_080047c0  operator()(function<invokeFunction_080047c0()> * functionPtr) */\n\ninvokeFunction_080047c0 __functionPtrcall std::function<invokeFunction_080047c0()>::invoke_function_080047c0(function<invokeFunction_080047c0()> *functionPtr)\n\n{\n  if ((functionPtr->super__Function_base)._M_manager != (_Manager_type)0x0) {\n    (*functionPtr->_M_invoker)((_Any_data *)functionPtr);\n    return;\n  }\n                    \n  __throw_bad_function_call();\n}\n\n",
            "renaming": {
                "this": "functionPtr",
                "void": "invokeFunction",
                "FUN_080047c0": "invoke_function_080047c0"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [
                "__throw_bad_function_call"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047d0": {
            "entrypoint": "0x080047d0",
            "current_name": "process_gpio_pin_080047d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid process_GPIO_Pin_080047d0(uint16_t pin)\n\n{\n  byte pin_id;\n  uint8_t interrupt_id;\n  \n  pin_id = get_pin_id(pin);\n  if (gpio_irq_conf[pin_id].callback.super__Function_base._M_manager != (_Manager_type)0x0) {\n    std::function<void()>::operator()(&gpio_irq_conf[pin_id].callback);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047d0": "process_gpio_pin_080047d0",
                "GPIO_Pin": "pin",
                "bVar1": "pin_id",
                "irq_id": "interrupt_id"
            },
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "called": [
                "get_pin_id",
                "operator()"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047f0": {
            "entrypoint": "0x080047f0",
            "current_name": "initialize_static_data_080047f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_080047f0(void)\n\n{\n  initialize_destruction(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047f0": "initialize_static_data_080047f0",
                "__static_initialization_and_destruction_0": "initialize_destruction"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047fe": {
            "entrypoint": "0x080047fe",
            "current_name": "register_exit_function_080047fe",
            "code": "\nvoid registerExitFunction_080047fe(undefined4 cleanupFunction,undefined4 cleanupParameter)\n\n{\n  __cxa_atexit(cleanupParameter,cleanupFunction);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047fe": "register_exit_function_080047fe",
                "param_1": "cleanupFunction",
                "param_2": "cleanupParameter"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004808": {
            "entrypoint": "0x08004808",
            "current_name": "print_assertion_failed_08004808",
            "code": "\nvoid printAssertionFailed_08004808(undefined4 file,undefined4 line,char *functionName,undefined4 assertion)\n\n{\n  char *delimiter;\n  \n  if (functionName == (char *)0x0) {\n    functionName = \"\";\n    delimiter = functionName;\n  }\n  else {\n    delimiter = \", function: \";\n  }\n  fiprintf(*(FILE **)(_impure_ptr + 0xc),\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",\n           assertion,file,line,delimiter,functionName,assertion);\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_08004808": "print_assertion_failed_08004808",
                "param_1": "file",
                "param_2": "line",
                "param_3": "functionName",
                "param_4": "assertion",
                "pcVar1": "delimiter"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "abort",
                "fiprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004844": {
            "entrypoint": "0x08004844",
            "current_name": "shift_unsigned_long_long_08004844",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800484c) */\n\nlonglong shiftUnsignedLongLong_08004844(undefined4 param1,uint param2)\n\n{\n  return (ulonglong)param2 << 0x20;\n}\n\n",
            "renaming": {
                "FUN_08004844": "shift_unsigned_long_long_08004844",
                "param_1": "param1",
                "param_2": "param2"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004860": {
            "entrypoint": "0x08004860",
            "current_name": "print_formatted_data_08004860",
            "code": "\nint printFormattedData_08004860(FILE *filePointer,char *formatString,...)\n\n{\n  int returnValue;\n  undefined4 unusedVar1;\n  undefined4 unusedVar2;\n  undefined4 stackVar1;\n  undefined4 stackVar2;\n  \n  stackVar1 = unusedVar1;\n  stackVar2 = unusedVar2;\n  returnValue = _vfiprintf_r(_impure_ptr,filePointer,formatString,&stackVar1,filePointer,&stackVar1);\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08004860": "print_formatted_data_08004860",
                "__stream": "filePointer",
                "__format": "formatString",
                "iVar1": "returnValue",
                "in_r2": "unusedVar1",
                "in_r3": "unusedVar2",
                "uStack_8": "stackVar1",
                "uStack_4": "stackVar2"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004884": {
            "entrypoint": "0x08004884",
            "current_name": "initialize_pre_init_functions_08004884",
            "code": "\nvoid initializePreInitFunctions_08004884(void)\n\n{\n  int index;\n  \n  for (index = 0; index != 0; index = index + 1) {\n    (*(code *)(&__preinit_array_end)[index])();\n  }\n  _init();\n  for (index = 0; index != 10; index = index + 1) {\n    (*(code *)(&__preinit_array_end)[index])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004884": "initialize_pre_init_functions_08004884",
                "iVar1": "index"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "premain",
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080048cc": {
            "entrypoint": "0x080048cc",
            "current_name": "memset_with_value_080048cc",
            "code": "\nvoid * memset_with_value_080048cc(void *dest,int value,size_t num_bytes)\n\n{\n  undefined *current_byte;\n  \n  for (current_byte = (undefined *)dest; current_byte != (undefined *)(num_bytes + (int)dest); current_byte = current_byte + 1) {\n    *current_byte = (char)value;\n  }\n  return dest;\n}\n\n",
            "renaming": {
                "FUN_080048cc": "memset_with_value_080048cc",
                "__s": "dest",
                "__c": "value",
                "__n": "num_bytes",
                "puVar1": "current_byte"
            },
            "calling": [
                "__sfmoreglue",
                "std.isra.0",
                "__sfp"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080048dc": {
            "entrypoint": "0x080048dc",
            "current_name": "allocate_memory_080048dc",
            "code": "\nvoid allocateMemory_080048dc(undefined4 *result,int size,undefined4 arg3,undefined4 arg4)\n\n{\n  int *tempPtr;\n  int **extraResult;\n  int **currentPtr;\n  int **freeListPtr;\n  int **prevPtr;\n  int **newNodePtr;\n  bool isBoundary;\n  \n  if (size == 0) {\n    return;\n  }\n  newNodePtr = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    newNodePtr = (int **)((int)newNodePtr + *(int *)(size + -4));\n  }\n  __malloc_lock();\n  freeListPtr = (int **)&__malloc_free_list;\n  if (__malloc_free_list == (int **)0x0) {\n    newNodePtr[1] = (int *)0x0;\n    currentPtr = extraResult;\n    __malloc_free_list = newNodePtr;\n  }\n  else {\n    freeListPtr = __malloc_free_list;\n    if (newNodePtr < __malloc_free_list) {\n      currentPtr = (int **)*newNodePtr;\n      freeListPtr = (int **)((int)newNodePtr + (int)currentPtr);\n      isBoundary = __malloc_free_list == freeListPtr;\n      if (isBoundary) {\n        freeListPtr = (int **)*__malloc_free_list;\n        __malloc_free_list = (int **)__malloc_free_list[1];\n      }\n      newNodePtr[1] = (int *)__malloc_free_list;\n      __malloc_free_list = newNodePtr;\n      if (isBoundary) {\n        freeListPtr = (int **)((int)freeListPtr + (int)currentPtr);\n        *newNodePtr = (int *)freeListPtr;\n      }\n    }\n    else {\n      do {\n        prevPtr = freeListPtr;\n        freeListPtr = (int **)prevPtr[1];\n        if (freeListPtr == (int **)0x0) break;\n      } while (freeListPtr <= newNodePtr);\n      currentPtr = (int **)*prevPtr;\n      if ((int **)((int)prevPtr + (int)currentPtr) == newNodePtr) {\n        currentPtr = (int **)((int)currentPtr + (int)*newNodePtr);\n        *prevPtr = (int *)currentPtr;\n        if (freeListPtr == (int **)((int)prevPtr + (int)currentPtr)) {\n          tempPtr = *freeListPtr;\n          freeListPtr = (int **)freeListPtr[1];\n          prevPtr[1] = (int *)freeListPtr;\n          currentPtr = (int **)((int)currentPtr + (int)tempPtr);\n          *prevPtr = (int *)currentPtr;\n        }\n      }\n      else if (newNodePtr < (int **)((int)prevPtr + (int)currentPtr)) {\n        *result = 0xc;\n      }\n      else {\n        currentPtr = (int **)((int)newNodePtr + (int)*newNodePtr);\n        isBoundary = freeListPtr == currentPtr;\n        if (isBoundary) {\n          currentPtr = (int **)*freeListPtr;\n          freeListPtr = (int **)freeListPtr[1];\n        }\n        newNodePtr[1] = (int *)freeListPtr;\n        if (isBoundary) {\n          currentPtr = (int **)((int)currentPtr + (int)*newNodePtr);\n          *newNodePtr = (int *)currentPtr;\n        }\n        prevPtr[1] = (int *)newNodePtr;\n      }\n    }\n  }\n  __malloc_unlock(result,currentPtr,freeListPtr,arg4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080048dc": "allocate_memory_080048dc",
                "param_1": "result",
                "param_2": "size",
                "param_3": "arg3",
                "param_4": "arg4",
                "piVar1": "tempPtr",
                "extraout_r1": "extraResult",
                "ppiVar2": "currentPtr",
                "ppiVar3": "freeListPtr",
                "ppiVar4": "prevPtr",
                "ppiVar5": "newNodePtr",
                "bVar6": "isBoundary"
            },
            "calling": [
                "__sflush_r",
                "__swsetup_r"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004978": {
            "entrypoint": "0x08004978",
            "current_name": "allocate_memory_08004978",
            "code": "\nuint allocate_memory_08004978(undefined4 *result,uint size)\n\n{\n  uint *current;\n  int offset;\n  uint *ptr;\n  uint diff;\n  uint *prev;\n  uint allocated_size;\n  \n  allocated_size = (size + 3 & 0xfffffffc) + 8;\n  if (allocated_size < 0xc) {\n    allocated_size = 0xc;\n  }\n  if (((int)allocated_size < 0) || (allocated_size < size)) {\n    *result = 0xc;\n  }\n  else {\n    __malloc_lock();\n    current = __malloc_free_list;\n    prev = __malloc_free_list;\n    while (ptr = current, ptr != (uint *)0x0) {\n      diff = *ptr - allocated_size;\n      if (-1 < (int)diff) {\n        if (diff < 0xc) {\n          if (prev == ptr) {\n            current = (uint *)prev[1];\n          }\n          else {\n            current = (uint *)ptr[1];\n          }\n          if (prev != ptr) {\n            prev[1] = (uint)current;\n            prev = ptr;\n            current = __malloc_free_list;\n          }\n        }\n        else {\n          *ptr = diff;\n          *(uint *)((int)ptr + diff) = allocated_size;\n          prev = (uint *)((int)ptr + diff);\n          current = __malloc_free_list;\n        }\n        goto LAB_080049dc;\n      }\n      prev = ptr;\n      current = (uint *)ptr[1];\n    }\n    if (__malloc_sbrk_start == 0) {\n      __malloc_sbrk_start = _sbrk_r(result);\n    }\n    current = (uint *)_sbrk_r(result,allocated_size);\n    if ((current != (uint *)0xffffffff) &&\n       ((prev = (uint *)((int)current + 3U & 0xfffffffc), current == prev ||\n        (offset = _sbrk_r(result,(int)prev - (int)current), offset != -1)))) {\n      *prev = allocated_size;\n      current = __malloc_free_list;\nLAB_080049dc:\n      __malloc_free_list = current;\n      __malloc_unlock(result);\n      allocated_size = (int)prev + 0xbU & 0xfffffff8;\n      offset = allocated_size - (int)(prev + 1);\n      if (offset != 0) {\n        *(int *)((int)prev + offset) = -offset;\n        return allocated_size;\n      }\n      return allocated_size;\n    }\n    *result = 0xc;\n    __malloc_unlock(result);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004978": "allocate_memory_08004978",
                "param_1": "result",
                "param_2": "size",
                "puVar1": "current",
                "iVar2": "offset",
                "puVar3": "ptr",
                "uVar4": "diff",
                "puVar5": "prev",
                "uVar6": "allocated_size"
            },
            "calling": [
                "__sfmoreglue",
                "__smakebuf_r"
            ],
            "called": [
                "__malloc_lock",
                "_sbrk_r",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a34": {
            "entrypoint": "0x08004a34",
            "current_name": "write_byte_to_file_08004a34",
            "code": "\nuint writeByteToFile_08004a34(undefined4 fileDescriptor,byte byteToWrite,byte **filePointer)\n\n{\n  uint returnValue;\n  byte *newFilePointer;\n  \n  newFilePointer = filePointer[2] + -1;\n  filePointer[2] = newFilePointer;\n  if (((int)newFilePointer < 0) && (((int)newFilePointer < (int)filePointer[6] || (byteToWrite == 10)))) {\n    returnValue = __swbuf_r();\n    return returnValue;\n  }\n  newFilePointer = *filePointer;\n  *filePointer = newFilePointer + 1;\n  *newFilePointer = byteToWrite;\n  return (uint)byteToWrite;\n}\n\n",
            "renaming": {
                "FUN_08004a34": "write_byte_to_file_08004a34",
                "param_1": "fileDescriptor",
                "param_2": "byteToWrite",
                "param_3": "filePointer",
                "uVar1": "returnValue",
                "pbVar2": "newFilePointer"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__swbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a60": {
            "entrypoint": "0x08004a60",
            "current_name": "write_to_file_08004a60",
            "code": "\nint writeToFile_08004a60(undefined4 fileDescriptor,undefined4 bufferSize,undefined *data,int size)\n\n{\n  int bytesWritten;\n  undefined *endOfData;\n  int remainingSize;\n  \n  endOfData = data + size;\n  remainingSize = size;\n  do {\n    if (data == endOfData) {\n      return 0;\n    }\n    bytesWritten = __sfputc_r(fileDescriptor,*data,bufferSize,size,remainingSize);\n    size = bytesWritten + 1;\n    data = data + 1;\n  } while (size != 0);\n  return bytesWritten;\n}\n\n",
            "renaming": {
                "FUN_08004a60": "write_to_file_08004a60",
                "param_1": "fileDescriptor",
                "param_2": "bufferSize",
                "param_3": "data",
                "param_4": "size",
                "iVar1": "bytesWritten",
                "puVar2": "endOfData",
                "iVar3": "remainingSize"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a84": {
            "entrypoint": "0x08004a84",
            "current_name": "formatted_print_08004a84",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08004c58) */\n\nint formattedPrint_08004a84(int stream,undefined4 *format,byte *str,int *args)\n\n{\n  bool foundNumber;\n  int result;\n  void *formatFlag;\n  int *currentArg;\n  byte *currentChar;\n  byte *startIndex;\n  int writeError;\n  int argValue;\n  int *argList;\n  uint flags;\n  int precision;\n  undefined4 unknown;\n  int width;\n  int totalChars;\n  byte conversionSpecifier;\n  undefined spaceFlag;\n  undefined plusFlag;\n  undefined zeroFlag;\n  undefined4 paddingChar;\n  \n  argList = args;\n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (format == &__sf_fake_stdin) {\n    format = *(undefined4 **)(stream + 4);\n  }\n  else if (format == (undefined4 *)&__sf_fake_stdout) {\n    format = *(undefined4 **)(stream + 8);\n  }\n  else if (format == (undefined4 *)&__sf_fake_stderr) {\n    format = *(undefined4 **)(stream + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(format + 3) << 0x1c)) || (format[4] == 0)) &&\n     (argValue = __swsetup_r(stream,format), argValue != 0)) {\n    return -1;\n  }\n  totalChars = 0;\n  spaceFlag = 0x20;\n  plusFlag = 0x30;\n  currentChar = str;\nLAB_08004ac6:\n  startIndex = currentChar;\n  if (*startIndex != 0) goto LAB_08004b7c;\n  goto LAB_08004ad0;\nLAB_08004b7c:\n  currentChar = startIndex + 1;\n  if (*startIndex != 0x25) goto LAB_08004ac6;\nLAB_08004ad0:\n  argValue = (int)startIndex - (int)str;\n  if (argValue != 0) {\n    result = __sfputs_r(stream,format,str,argValue);\n    if (result == -1) {\nLAB_08004c70:\n      if ((int)((uint)*(ushort *)(format + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return totalChars;\n    }\n    totalChars = totalChars + argValue;\n  }\n  if (*startIndex == 0) goto LAB_08004c70;\n  flags = 0;\n  width = 0;\n  precision = -1;\n  unknown = 0;\n  zeroFlag = 0;\n  paddingChar = 0;\n  currentChar = startIndex + 1;\n  while( true ) {\n    formatFlag = memchr(\"#-0+ \",(uint)*currentChar,5);\n    str = currentChar + 1;\n    if (formatFlag == (void *)0x0) break;\n    flags = 1 << ((int)formatFlag + 0xf7ffa094U & 0xff) | flags;\n    currentChar = str;\n  }\n  if ((int)(flags << 0x1b) < 0) {\n    zeroFlag = 0x20;\n  }\n  if ((int)(flags << 0x1c) < 0) {\n    zeroFlag = 0x2b;\n  }\n  if (*currentChar == 0x2a) {\n    currentArg = argList + 1;\n    argValue = *argList;\n    argList = currentArg;\n    if (argValue < 0) {\n      width = -argValue;\n      flags = flags | 2;\n      goto LAB_08004bae;\n    }\n  }\n  else {\n    foundNumber = false;\n    argValue = width;\n    str = currentChar;\n    while( true ) {\n      if (9 < *str - 0x30) break;\n      argValue = argValue * 10 + (*str - 0x30);\n      foundNumber = true;\n      str = str + 1;\n    }\n    if (!foundNumber) goto LAB_08004bae;\n  }\n  width = argValue;\nLAB_08004bae:\n  if (*str == 0x2e) {\n    if (str[1] == 0x2a) {\n      precision = *argList;\n      if (precision < 0) {\n        precision = -1;\n      }\n      str = str + 2;\n      argList = argList + 1;\n    }\n    else {\n      foundNumber = false;\n      precision = 0;\n      argValue = 0;\n      while( true ) {\n        str = str + 1;\n        if (9 < *str - 0x30) break;\n        argValue = argValue * 10 + (*str - 0x30);\n        foundNumber = true;\n      }\n      if (foundNumber) {\n        precision = argValue;\n      }\n    }\n  }\n  formatFlag = memchr(&DAT_08005f72,(uint)*str,3);\n  if (formatFlag != (void *)0x0) {\n    flags = flags | 0x40 << ((int)formatFlag + 0xf7ffa08eU & 0xff);\n    str = str + 1;\n  }\n  conversionSpecifier = *str;\n  str = str + 1;\n  formatFlag = memchr(\"efgEFG\",(uint)conversionSpecifier,6);\n  if (formatFlag == (void *)0x0) {\n    writeError = _printf_i(stream,&flags,format,0x8004a61,&argList);\n    if (writeError == -1) goto LAB_08004c70;\n  }\n  else {\n    argList = (int *)(((int)argList + 7U & 0xfffffff8) + 8);\n  }\n  totalChars = totalChars + writeError;\n  currentChar = str;\n  goto LAB_08004ac6;\n}\n\n",
            "renaming": {
                "FUN_08004a84": "formatted_print_08004a84",
                "param_1": "stream",
                "param_2": "format",
                "param_3": "str",
                "param_4": "args",
                "bVar1": "foundNumber",
                "iVar2": "result",
                "pvVar3": "formatFlag",
                "piVar4": "currentArg",
                "pbVar5": "currentChar",
                "pbVar6": "startIndex",
                "unaff_r9": "writeError",
                "iVar7": "argValue",
                "local_8c": "argList",
                "local_88": "flags",
                "local_84": "precision",
                "local_80": "unknown",
                "local_7c": "width",
                "local_74": "totalChars",
                "local_70": "conversionSpecifier",
                "local_6f": "spaceFlag",
                "local_6e": "plusFlag",
                "local_45": "zeroFlag",
                "local_30": "paddingChar"
            },
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "called": [
                "_printf_i",
                "__sinit",
                "memchr",
                "__swsetup_r",
                "__sfputs_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cb0": {
            "entrypoint": "0x08004cb0",
            "current_name": "process_data_08004cb0",
            "code": "\nundefined4\nprocessData_08004cb0(undefined4 input,uint *array,uint *output,undefined4 arg,code *callback)\n\n{\n  int index1;\n  int index2;\n  uint maxLength;\n  uint count;\n  bool isConditionMet;\n  \n  maxLength = array[4];\n  if ((int)array[4] < (int)array[2]) {\n    maxLength = array[2];\n  }\n  *output = maxLength;\n  if (*(char *)((int)array + 0x43) != '\\0') {\n    *output = maxLength + 1;\n  }\n  if ((int)(*array << 0x1a) < 0) {\n    *output = *output + 2;\n  }\n  if ((*array & 6) == 0) {\n    for (index1 = 0; index1 < (int)(array[3] - *output); index1 = index1 + 1) {\n      index2 = (*callback)(input,arg,(int)array + 0x19,1);\n      if (index2 == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  maxLength = (uint)*(byte *)((int)array + 0x43);\n  if (maxLength != 0) {\n    maxLength = 1;\n  }\n  if ((int)(*array << 0x1a) < 0) {\n    *(undefined *)((int)array + maxLength + 0x43) = 0x30;\n    *(undefined *)((int)array + maxLength + 0x44) = *(undefined *)((int)array + 0x45);\n    maxLength = maxLength + 2;\n  }\n  index1 = (*callback)(input,arg,(int)array + 0x43,maxLength);\n  if (index1 != -1) {\n    maxLength = array[3];\n    isConditionMet = (*array & 6) == 4;\n    if (isConditionMet) {\n      maxLength = maxLength - *output;\n    }\n    if (isConditionMet) {\n      maxLength = maxLength & ~((int)maxLength >> 0x1f);\n    }\n    else {\n      maxLength = 0;\n    }\n    if ((int)array[4] < (int)array[2]) {\n      maxLength = maxLength + (array[2] - array[4]);\n    }\n    count = 0;\n    while( true ) {\n      if (maxLength == count) {\n        return 0;\n      }\n      index1 = (*callback)(input,arg,(int)array + 0x1a,1);\n      if (index1 == -1) break;\n      count = count + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08004cb0": "process_data_08004cb0",
                "param_1": "input",
                "param_2": "array",
                "param_3": "output",
                "param_4": "arg",
                "param_5": "callback",
                "iVar1": "index1",
                "iVar2": "index2",
                "uVar3": "maxLength",
                "uVar4": "count",
                "bVar5": "isConditionMet"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d9c": {
            "entrypoint": "0x08004d9c",
            "current_name": "reverse_and_print_08004d9c",
            "code": "\nuint reverse_and_print_08004d9c(undefined4 input,uint *data,undefined4 format,code *callback,uint **buffer)\n\n{\n  byte byte_val;\n  int result;\n  uint *ptr;\n  void *mem_ptr;\n  int index;\n  char *char_ptr;\n  uint uint_val;\n  uint **ppuVar8;\n  char **ppcVar9;\n  uint num;\n  uint size;\n  char *str;\n  char *input_str;\n  uint local_arr [2];\n  \n  byte_val = *(byte *)(data + 6);\n  input_str = (char *)((int)data + 0x43);\n  if (byte_val != 0x6e) {\n    if (byte_val < 0x6f) {\n      if (byte_val != 99) {\n        if (byte_val < 100) {\n          if (byte_val == 0) goto LAB_08004f56;\n          if (byte_val != 0x58) goto LAB_08004dcc;\n          *(undefined *)((int)data + 0x45) = 0x58;\n          char_ptr = \"0123456789ABCDEF\";\nLAB_08004ee6:\n          uint_val = *data;\n          ptr = *buffer;\n          *buffer = ptr + 1;\n          if (((uint_val & 0x80) == 0) && ((int)(uint_val << 0x19) < 0)) {\n            num = (uint)*(ushort *)ptr;\n          }\n          else {\n            num = *ptr;\n          }\n          if ((int)(uint_val << 0x1f) < 0) {\n            *data = uint_val | 0x20;\n          }\n          if (num == 0) {\n            *data = *data & 0xffffffdf;\n          }\n          uint_val = 0x10;\nLAB_08004e7c:\n          *(undefined *)((int)data + 0x43) = 0;\n        }\n        else {\n          if ((byte_val != 100) && (byte_val != 0x69)) goto LAB_08004dcc;\n          num = *data;\n          ptr = *buffer;\n          if ((num & 0x80) == 0) {\n            *buffer = ptr + 1;\n            if ((num & 0x40) == 0) goto LAB_08004dec;\n            num = (uint)(short)*(ushort *)ptr;\n          }\n          else {\n            *buffer = ptr + 1;\nLAB_08004dec:\n            num = *ptr;\n          }\n          if ((int)num < 0) {\n            num = -num;\n            *(undefined *)((int)data + 0x43) = 0x2d;\n          }\n          char_ptr = \"0123456789ABCDEF\";\n          uint_val = 10;\n        }\n        size = data[1];\n        data[2] = size;\n        str = input_str;\n        if ((int)size < 0) {\n          if (num != 0) goto LAB_08004f1a;\nLAB_08004fc8:\n          *(char *)((int)data + 0x42) = *char_ptr;\n          str = (char *)((int)data + 0x42);\n        }\n        else {\n          *data = *data & 0xfffffffb;\n          if (num == 0) {\n            if (size != 0) goto LAB_08004fc8;\n          }\n          else {\nLAB_08004f1a:\n            do {\n              size = num / uint_val;\n              str = str + -1;\n              *str = char_ptr[num - uint_val * size];\n              num = size;\n            } while (size != 0);\n          }\n        }\n        if (((uint_val == 8) && ((int)(*data << 0x1f) < 0)) && ((int)data[1] <= (int)data[4]))\n        {\n          str[-1] = '0';\n          str = str + -1;\n        }\n        data[4] = (int)input_str - (int)str;\n        input_str = str;\n        goto LAB_08004ec2;\n      }\n      ptr = *buffer;\n      *buffer = ptr + 1;\n      *(char *)((int)data + 0x42) = (char)*ptr;\nLAB_08004e2c:\n      input_str = (char *)((int)data + 0x42);\n      num = 1;\n    }\n    else {\n      if (byte_val != 0x73) {\n        if (byte_val < 0x74) {\n          if (byte_val == 0x6f) {\nLAB_08004e52:\n            num = *data;\n            ptr = *buffer;\n            if ((num & 0x80) == 0) {\n              *buffer = ptr + 1;\n              if ((num & 0x40) == 0) goto LAB_08004e60;\n              num = (uint)*(ushort *)ptr;\n            }\n            else {\n              *buffer = ptr + 1;\nLAB_08004e60:\n              num = *ptr;\n            }\n            char_ptr = \"0123456789ABCDEF\";\n            if (byte_val == 0x6f) {\n              uint_val = 8;\n            }\n            else {\n              uint_val = 10;\n            }\n            goto LAB_08004e7c;\n          }\n          if (byte_val == 0x70) {\n            *data = *data | 0x20;\nLAB_08004e12:\n            *(undefined *)((int)data + 0x45) = 0x78;\n            char_ptr = \"0123456789abcdef\";\n            goto LAB_08004ee6;\n          }\n        }\n        else {\n          if (byte_val == 0x75) goto LAB_08004e52;\n          if (byte_val == 0x78) goto LAB_08004e12;\n        }\nLAB_08004dcc:\n        *(byte *)((int)data + 0x42) = byte_val;\n        goto LAB_08004e2c;\n      }\n      ppcVar9 = (char **)*buffer;\n      *buffer = (uint *)(ppcVar9 + 1);\n      input_str = *ppcVar9;\n      mem_ptr = memchr(input_str,0,data[1]);\n      if (mem_ptr != (void *)0x0) {\n        data[1] = (int)mem_ptr - (int)input_str;\n      }\n      num = data[1];\n    }\n    data[4] = num;\n    *(undefined *)((int)data + 0x43) = 0;\n    goto LAB_08004ec2;\n  }\n  num = *data;\n  ppuVar8 = (uint **)*buffer;\n  uint_val = data[5];\n  if ((num & 0x80) == 0) {\n    *buffer = (uint *)(ppuVar8 + 1);\n    ptr = *ppuVar8;\n    if ((num & 0x40) == 0) goto LAB_08004f42;\n    *(short *)ptr = (short)uint_val;\n  }\n  else {\n    *buffer = (uint *)(ppuVar8 + 1);\n    ptr = *ppuVar8;\nLAB_08004f42:\n    *ptr = uint_val;\n  }\nLAB_08004f56:\n  data[4] = 0;\nLAB_08004ec2:\n  result = _printf_common(input,data,local_arr,format,callback);\n  if ((result == -1) || (result = (*callback)(input,format,input_str,data[4]), result == -1)) {\nLAB_08004ed6:\n    num = 0xffffffff;\n  }\n  else {\n    if ((int)(*data << 0x1e) < 0) {\n      for (result = 0; result < (int)(data[3] - local_arr[0]); result = result + 1) {\n        index = (*callback)(input,format,(int)data + 0x19,1);\n        if (index == -1) goto LAB_08004ed6;\n      }\n    }\n    num = data[3];\n    if ((int)data[3] < (int)local_arr[0]) {\n      num = local_arr[0];\n    }\n  }\n  return num;\n}\n\n",
            "renaming": {
                "FUN_08004d9c": "reverse_and_print_08004d9c",
                "param_1": "input",
                "param_2": "data",
                "param_3": "format",
                "param_4": "callback",
                "param_5": "buffer",
                "bVar1": "byte_val",
                "iVar2": "result",
                "puVar3": "ptr",
                "pvVar4": "mem_ptr",
                "iVar5": "index",
                "pcVar6": "char_ptr",
                "uVar7": "uint_val",
                "uVar10": "num",
                "uVar11": "size",
                "pcVar12": "str",
                "__s": "input_str",
                "local_24": "local_arr"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "_printf_common",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004fdc": {
            "entrypoint": "0x08004fdc",
            "current_name": "print_formatted_string_08004fdc",
            "code": "\nint print_formatted_string_08004fdc(char *format_string,...)\n\n{\n  int impure_ptr;\n  undefined4 param_r1;\n  undefined4 param_r2;\n  undefined4 param_r3;\n  char *format;\n  undefined4 param_c;\n  undefined4 param_8;\n  undefined4 param_4;\n  \n  impure_ptr = _impure_ptr;\n  format = format_string;\n  param_c = param_r1;\n  param_8 = param_r2;\n  param_4 = param_r3;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  impure_ptr = _vfiprintf_r(impure_ptr,*(undefined4 *)(impure_ptr + 8),format_string,&param_c,format,&param_c);\n  return impure_ptr;\n}\n\n",
            "renaming": {
                "FUN_08004fdc": "print_formatted_string_08004fdc",
                "__format": "format_string",
                "iVar1": "impure_ptr",
                "in_r1": "param_r1",
                "in_r2": "param_r2",
                "in_r3": "param_r3",
                "pcVar2": "format",
                "uStack_c": "param_c",
                "uStack_8": "param_8",
                "uStack_4": "param_4"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "__sinit",
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800500c": {
            "entrypoint": "0x0800500c",
            "current_name": "allocate_memory_0800500c",
            "code": "\nvoid allocateMemory_0800500c(int *errorFlag,intptr_t size)\n\n{\n  void *memoryPointer;\n  \n  errno = 0;\n  memoryPointer = _sbrk(size);\n  if ((memoryPointer == (void *)0xffffffff) && (errno != 0)) {\n    *errorFlag = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800500c": "allocate_memory_0800500c",
                "param_1": "errorFlag",
                "param_2": "size",
                "pvVar1": "memoryPointer"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800502c": {
            "entrypoint": "0x0800502c",
            "current_name": "process_input_0800502c",
            "code": "\nuint processInput_0800502c(int inputBuffer,uint inputChar,int *streamBuffer,undefined4 param_4)\n\n{\n  int bufferLength;\n  uint shortValue;\n  undefined *currentChar;\n  \n  if ((inputBuffer != 0) && (*(int *)(inputBuffer + 0x18) == 0)) {\n    __sinit();\n  }\n  if (streamBuffer == &__sf_fake_stdin) {\n    streamBuffer = *(int **)(inputBuffer + 4);\n  }\n  else if (streamBuffer == (int *)&__sf_fake_stdout) {\n    streamBuffer = *(int **)(inputBuffer + 8);\n  }\n  else if (streamBuffer == (int *)&__sf_fake_stderr) {\n    streamBuffer = *(int **)(inputBuffer + 0xc);\n  }\n  streamBuffer[2] = streamBuffer[6];\n  shortValue = (uint)*(ushort *)(streamBuffer + 3);\n  bufferLength = shortValue << 0x1c;\n  if (((bufferLength < 0) && (shortValue = streamBuffer[4], shortValue != 0)) ||\n     (bufferLength = __swsetup_r(inputBuffer,streamBuffer,bufferLength,shortValue,param_4), bufferLength == 0)) {\n    bufferLength = *streamBuffer - streamBuffer[4];\n    inputChar = inputChar & 0xff;\n    if ((bufferLength < streamBuffer[5]) || (bufferLength = _fflush_r(inputBuffer,streamBuffer), bufferLength == 0)) {\n      streamBuffer[2] = streamBuffer[2] + -1;\n      currentChar = (undefined *)*streamBuffer;\n      *streamBuffer = (int)(currentChar + 1);\n      *currentChar = (char)inputChar;\n      if (bufferLength + 1 != streamBuffer[5]) {\n        if (-1 < (int)((uint)*(ushort *)(streamBuffer + 3) << 0x1f)) {\n          return inputChar;\n        }\n        if (inputChar != 10) {\n          return inputChar;\n        }\n      }\n      bufferLength = _fflush_r(inputBuffer,streamBuffer);\n      if (bufferLength == 0) {\n        return inputChar;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800502c": "process_input_0800502c",
                "param_1": "inputBuffer",
                "param_2": "inputChar",
                "param_3": "streamBuffer",
                "iVar1": "bufferLength",
                "uVar2": "shortValue",
                "puVar3": "currentChar"
            },
            "calling": [
                "__sfputc_r"
            ],
            "called": [
                "__sinit",
                "_fflush_r",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080050d0": {
            "entrypoint": "0x080050d0",
            "current_name": "process_io_080050d0",
            "code": "\nuint processIO_080050d0(undefined4 *stdin_buffer,undefined4 *stream)\n\n{\n  int impure_ptr;\n  uint result;\n  ushort stream_flags;\n  \n  impure_ptr = _impure_ptr;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = *(undefined4 **)(impure_ptr + 4);\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stdout) {\n    stream = *(undefined4 **)(impure_ptr + 8);\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stderr) {\n    stream = *(undefined4 **)(impure_ptr + 0xc);\n  }\n  stream_flags = *(ushort *)(stream + 3);\n  result = (uint)stream_flags;\n  if (-1 < (int)(result << 0x1c)) {\n    if (-1 < (int)(result << 0x1b)) {\n      *stdin_buffer = 9;\n      goto LAB_08005100;\n    }\n    if ((int)(result << 0x1d) < 0) {\n      if ((undefined4 *)stream[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)stream[0xd] != stream + 0x11) {\n          _free_r(stdin_buffer);\n        }\n        stream[0xd] = 0;\n      }\n      *(ushort *)(stream + 3) = *(ushort *)(stream + 3) & 0xffdb;\n      stream[1] = 0;\n      *stream = stream[4];\n    }\n    *(ushort *)(stream + 3) = *(ushort *)(stream + 3) | 8;\n  }\n  if ((stream[4] == 0) && ((*(ushort *)(stream + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(stdin_buffer,stream);\n  }\n  stream_flags = *(ushort *)(stream + 3);\n  result = stream_flags & 1;\n  if ((stream_flags & 1) == 0) {\n    if (-1 < (int)((uint)stream_flags << 0x1e)) {\n      result = stream[5];\n    }\n    stream[2] = result;\n  }\n  else {\n    stream[2] = 0;\n    stream[6] = -stream[5];\n  }\n  if (stream[4] == 0) {\n    stream_flags = *(ushort *)(stream + 3);\n    result = (int)(short)stream_flags & 0x80;\n    if (result != 0) {\nLAB_08005100:\n      *(ushort *)(stream + 3) = stream_flags | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080050d0": "process_io_080050d0",
                "param_1": "stdin_buffer",
                "param_2": "stream",
                "iVar1": "impure_ptr",
                "uVar2": "result",
                "uVar3": "stream_flags"
            },
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r"
            ],
            "called": [
                "__sinit",
                "_free_r",
                "__smakebuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080051ac": {
            "entrypoint": "0x080051ac",
            "current_name": "terminate_application_080051ac",
            "code": "\n\n\nvoid terminate_application_080051ac(void)\n\n{\n  raise(6);\n                    \n  _exit(1);\n}\n\n",
            "renaming": {
                "FUN_080051ac": "terminate_application_080051ac"
            },
            "calling": [
                "__throw_bad_function_call",
                "__assert_func"
            ],
            "called": [
                "raise",
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080051bc": {
            "entrypoint": "0x080051bc",
            "current_name": "handle_data_processing_080051bc",
            "code": "\nundefined4 handleDataProcessing_080051bc(uint *dataBuffer,int *infoBuffer)\n\n{\n  int temp1;\n  int *temp2;\n  uint temp3;\n  ushort temp4;\n  int temp5;\n  code *callbackFunc;\n  int temp6;\n  uint temp7;\n  bool isZero;\n  \n  temp4 = *(ushort *)(infoBuffer + 3);\n  temp3 = (uint)temp4;\n  if ((int)(temp3 << 0x1c) < 0) {\n    temp1 = infoBuffer[4];\n    if (temp1 != 0) {\n      temp5 = temp3 << 0x1e;\n      isZero = temp5 == 0;\n      temp6 = *infoBuffer;\n      if (isZero) {\n        temp5 = infoBuffer[5];\n      }\n      *infoBuffer = temp1;\n      if (!isZero) {\n        temp5 = 0;\n      }\n      infoBuffer[2] = temp5;\n      for (temp6 = temp6 - temp1; 0 < temp6; temp6 = temp6 - temp5) {\n        temp5 = (*(code *)infoBuffer[10])(dataBuffer,infoBuffer[8],temp1,temp6);\n        if (temp5 < 1) {\n          temp4 = *(ushort *)(infoBuffer + 3);\n          goto LAB_080052b2;\n        }\n        temp1 = temp1 + temp5;\n      }\n    }\n  }\n  else if (((0 < infoBuffer[1]) || (0 < infoBuffer[0x10])) &&\n          (callbackFunc = (code *)infoBuffer[0xb], callbackFunc != (code *)0x0)) {\n    temp7 = *dataBuffer;\n    *dataBuffer = 0;\n    if ((temp4 & 0x1000) == 0) {\n      temp1 = (*callbackFunc)(dataBuffer,infoBuffer[8],temp3 & 0x1000,1);\n      if ((temp1 == -1) && (temp3 = *dataBuffer, temp3 != 0)) {\n        if ((temp3 != 0x1d) && (temp3 != 0x16)) {\n          *(ushort *)(infoBuffer + 3) = *(ushort *)(infoBuffer + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *dataBuffer = temp7;\n        return 0;\n      }\n    }\n    else {\n      temp1 = infoBuffer[0x15];\n    }\n    if (((int)((uint)*(ushort *)(infoBuffer + 3) << 0x1d) < 0) &&\n       (temp1 = temp1 - infoBuffer[1], infoBuffer[0xd] != 0)) {\n      temp1 = temp1 - infoBuffer[0x10];\n    }\n    temp1 = (*(code *)infoBuffer[0xb])(dataBuffer,infoBuffer[8],temp1,0);\n    temp4 = *(ushort *)(infoBuffer + 3);\n    if ((temp1 == -1) &&\n       ((0x1d < *dataBuffer || (-1 < (int)((0x20400001U >> (*dataBuffer & 0xff)) << 0x1f))))) {\nLAB_080052b2:\n      *(ushort *)(infoBuffer + 3) = temp4 | 0x40;\n      return 0xffffffff;\n    }\n    infoBuffer[1] = 0;\n    *infoBuffer = infoBuffer[4];\n    if (((int)((uint)temp4 << 0x13) < 0) && ((temp1 != -1 || (*dataBuffer == 0)))) {\n      infoBuffer[0x15] = temp1;\n    }\n    temp2 = (int *)infoBuffer[0xd];\n    *dataBuffer = temp7;\n    if (temp2 != (int *)0x0) {\n      if (temp2 != infoBuffer + 0x11) {\n        _free_r(dataBuffer);\n      }\n      infoBuffer[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080051bc": "handle_data_processing_080051bc",
                "param_1": "dataBuffer",
                "param_2": "infoBuffer",
                "iVar1": "temp1",
                "piVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "iVar5": "temp5",
                "pcVar6": "callbackFunc",
                "iVar7": "temp6",
                "uVar8": "temp7",
                "bVar9": "isZero"
            },
            "calling": [
                "_fflush_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052cc": {
            "entrypoint": "0x080052cc",
            "current_name": "check_and_flush_file_stream_080052cc",
            "code": "\nundefined4 checkAndFlushFileStream_080052cc(int fileStream,undefined4 *streamDescriptor,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 returnValue;\n  \n  if (streamDescriptor[4] != 0) {\n    if ((fileStream != 0) && (*(int *)(fileStream + 0x18) == 0)) {\n      __sinit();\n    }\n    if (streamDescriptor == &__sf_fake_stdin) {\n      streamDescriptor = *(undefined4 **)(fileStream + 4);\n    }\n    else if (streamDescriptor == (undefined4 *)&__sf_fake_stdout) {\n      streamDescriptor = *(undefined4 **)(fileStream + 8);\n    }\n    else if (streamDescriptor == (undefined4 *)&__sf_fake_stderr) {\n      streamDescriptor = *(undefined4 **)(fileStream + 0xc);\n    }\n    if (*(short *)(streamDescriptor + 3) != 0) {\n      returnValue = __sflush_r(fileStream,streamDescriptor,param_3,param_4);\n      return returnValue;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080052cc": "check_and_flush_file_stream_080052cc",
                "param_1": "fileStream",
                "param_2": "streamDescriptor",
                "uVar1": "returnValue"
            },
            "calling": [
                "__swbuf_r"
            ],
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005320": {
            "entrypoint": "0x08005320",
            "current_name": "initialize_file_walk_08005320",
            "code": "\nvoid initialize_file_walk_08005320(undefined4 reent_structure)\n\n{\n  file_walk_reentrant(reent_structure,0x80052cd);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005320": "initialize_file_walk_08005320",
                "param_1": "reent_structure",
                "_fwalk_reent": "file_walk_reentrant"
            },
            "calling": [],
            "called": [
                "_fwalk_reent"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800532c": {
            "entrypoint": "0x0800532c",
            "current_name": "initialize_data_structure_0800532c",
            "code": "\nvoid initializeDataStructure_0800532c(undefined4 *dataStructure,undefined2 value1,undefined2 value2)\n\n{\n  *dataStructure = 0;\n  dataStructure[1] = 0;\n  dataStructure[2] = 0;\n  *(undefined2 *)(dataStructure + 3) = value1;\n  dataStructure[0x19] = 0;\n  *(undefined2 *)((int)dataStructure + 0xe) = value2;\n  dataStructure[4] = 0;\n  dataStructure[5] = 0;\n  dataStructure[6] = 0;\n  memset(dataStructure + 0x17,0,8);\n  dataStructure[9] = 0x8005609;\n  dataStructure[10] = 0x800562b;\n  dataStructure[0xb] = 0x8005663;\n  dataStructure[8] = dataStructure;\n  dataStructure[0xc] = 0x8005687;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800532c": "initialize_data_structure_0800532c",
                "param_1": "dataStructure",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005374": {
            "entrypoint": "0x08005374",
            "current_name": "allocate_and_initialize_array_08005374",
            "code": "\nundefined4 * allocateAndInitializeArray_08005374(undefined4 sizeOfElement,int numberOfElements)\n\n{\n  undefined4 *arrayPointer;\n  int totalArraySize;\n  \n  totalArraySize = (numberOfElements + -1) * 0x68;\n  arrayPointer = (undefined4 *)_malloc_r(sizeOfElement,totalArraySize + 0x74);\n  if (arrayPointer != (undefined4 *)0x0) {\n    *arrayPointer = 0;\n    arrayPointer[1] = numberOfElements;\n    arrayPointer[2] = arrayPointer + 3;\n    memset(arrayPointer + 3,0,totalArraySize + 0x68);\n  }\n  return arrayPointer;\n}\n\n",
            "renaming": {
                "FUN_08005374": "allocate_and_initialize_array_08005374",
                "param_1": "sizeOfElement",
                "param_2": "numberOfElements",
                "puVar1": "arrayPointer",
                "iVar2": "totalArraySize"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "_malloc_r",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053a0": {
            "entrypoint": "0x080053a0",
            "current_name": "initialize_data_080053a0",
            "code": "\nvoid initializeData_080053a0(undefined1 *dataPointer)\n\n{\n  undefined4 result;\n  undefined1 *initialValue;\n  \n  if (*(int *)(dataPointer + 0x18) == 0) {\n    *(undefined4 *)(dataPointer + 0x48) = 0;\n    *(undefined4 *)(dataPointer + 0x4c) = 0;\n    *(undefined4 *)(dataPointer + 0x50) = 0;\n    initialValue = &impureData;\n    *(undefined4 *)(dataPointer + 0x28) = 0x8005321;\n    if (dataPointer == &impureData) {\n      initialValue = (undefined1 *)0x1;\n    }\n    if (dataPointer == &impureData) {\n      *(undefined1 **)(dataPointer + 0x18) = initialValue;\n    }\n    result = __sfp();\n    *(undefined4 *)(dataPointer + 4) = result;\n    result = __sfp(dataPointer);\n    *(undefined4 *)(dataPointer + 8) = result;\n    result = __sfp(dataPointer);\n    *(undefined4 *)(dataPointer + 0xc) = result;\n    std_isra_0(*(undefined4 *)(dataPointer + 4),4,0);\n    std_isra_0(*(undefined4 *)(dataPointer + 8),9,1);\n    std_isra_0(*(undefined4 *)(dataPointer + 0xc),0x12,2);\n    *(undefined4 *)(dataPointer + 0x18) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053a0": "initialize_data_080053a0",
                "param_1": "dataPointer",
                "uVar1": "result",
                "puVar2": "initialValue",
                "impure_data": "impureData"
            },
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r",
                "iprintf",
                "_fflush_r",
                "__swsetup_r",
                "__sfp"
            ],
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005400": {
            "entrypoint": "0x08005400",
            "current_name": "initialize_data_structure_08005400",
            "code": "\nint * initializeDataStructure_08005400(undefined4 *errorCode)\n\n{\n  int *currentElement;\n  int *currentArray;\n  int **arrayHead;\n  \n  if (DAT_200000bc == 0) {\n    __sinit(&impure_data);\n  }\n  arrayHead = (int **)&DAT_200000ec;\n  do {\n    currentArray = arrayHead[2];\n    currentElement = arrayHead[1];\n    while (currentElement = (int *)((int)currentElement + -1), -1 < (int)currentElement) {\n      if (*(short *)(currentArray + 3) == 0) {\n        *(undefined2 *)((int)currentArray + 0xe) = 0xffff;\n        *(undefined2 *)(currentArray + 3) = 1;\n        currentArray[0x19] = 0;\n        *currentArray = 0;\n        currentArray[2] = 0;\n        currentArray[1] = 0;\n        currentArray[4] = 0;\n        currentArray[5] = 0;\n        currentArray[6] = 0;\n        memset(currentArray + 0x17,0,8);\n        currentArray[0xd] = 0;\n        currentArray[0xe] = 0;\n        currentArray[0x12] = 0;\n        currentArray[0x13] = 0;\n        return currentArray;\n      }\n      currentArray = currentArray + 0x1a;\n    }\n    if (*arrayHead == (int *)0x0) {\n      currentElement = (int *)__sfmoreglue(errorCode,4);\n      *arrayHead = currentElement;\n      if (currentElement == (int *)0x0) {\n        *errorCode = 0xc;\n        return (int *)0x0;\n      }\n    }\n    arrayHead = (int **)*arrayHead;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005400": "initialize_data_structure_08005400",
                "param_1": "errorCode",
                "piVar1": "currentElement",
                "piVar2": "currentArray",
                "ppiVar3": "arrayHead"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__sfmoreglue",
                "__sinit",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005478": {
            "entrypoint": "0x08005478",
            "current_name": "process_elements_08005478",
            "code": "\nuint processElements_08005478(int startAddress,code *callbackFunction,undefined4 arg1,undefined4 arg2)\n\n{\n  uint returnValue;\n  int increment;\n  int *currentElement;\n  int elementAddress;\n  uint result;\n  int count;\n  \n  result = 0;\n  for (currentElement = (int *)(startAddress + 0x48); currentElement != (int *)0x0; currentElement = (int *)*currentElement) {\n    elementAddress = currentElement[2];\n    count = currentElement[1];\n    while (count = count + -1, -1 < count) {\n      if ((1 < *(ushort *)(elementAddress + 0xc)) && (increment = *(short *)(elementAddress + 0xe) + 1, increment != 0)) {\n        returnValue = (*callbackFunction)(startAddress,elementAddress,arg1,increment,arg2);\n        result = result | returnValue;\n      }\n      elementAddress = elementAddress + 0x68;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005478": "process_elements_08005478",
                "param_1": "startAddress",
                "param_2": "callbackFunction",
                "param_3": "arg1",
                "param_4": "arg2",
                "uVar1": "returnValue",
                "iVar2": "increment",
                "piVar3": "currentElement",
                "iVar4": "elementAddress",
                "uVar5": "result",
                "iVar6": "count"
            },
            "calling": [
                "_cleanup_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054b4": {
            "entrypoint": "0x080054b4",
            "current_name": "check_file_permission_080054b4",
            "code": "\nundefined4 check_file_permission_080054b4(undefined4 file_descriptor,int file_info,undefined4 *permission_flags,uint *file_properties)\n\n{\n  int status;\n  undefined4 flags;\n  undefined stack_buffer [4];\n  uint file_mode;\n  \n  if ((*(short *)(file_info + 0xe) < 0) ||\n     (status = _fstat_r(file_descriptor,(int)*(short *)(file_info + 0xe),stack_buffer), status < 0)) {\n    *file_properties = 0;\n    if ((int)((uint)*(ushort *)(file_info + 0xc) << 0x18) < 0) {\n      flags = 0x40;\n      goto LAB_080054f4;\n    }\n  }\n  else {\n    *file_properties = (uint)((file_mode & 0xf000) == 0x2000);\n  }\n  flags = 0x400;\nLAB_080054f4:\n  *permission_flags = flags;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080054b4": "check_file_permission_080054b4",
                "param_1": "file_descriptor",
                "param_2": "file_info",
                "param_3": "permission_flags",
                "param_4": "file_properties",
                "iVar1": "status",
                "uVar2": "flags",
                "auStack_4c": "stack_buffer",
                "local_48": "file_mode"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054fc": {
            "entrypoint": "0x080054fc",
            "current_name": "parse_and_allocate_memory_080054fc",
            "code": "\nvoid parseAndAllocateMemory_080054fc(int bitOffset,int *data)\n\n{\n  ushort status;\n  int allocatedMemory;\n  int bitOffsetCopy;\n  int *dataCopy;\n  \n  if (-1 < (int)((uint)*(ushort *)(data + 3) << 0x1e)) {\n    bitOffsetCopy = bitOffset;\n    dataCopy = data;\n    status = __swhatbuf_r(bitOffset,data,&bitOffsetCopy,&dataCopy);\n    allocatedMemory = _malloc_r(bitOffset,bitOffsetCopy);\n    if (allocatedMemory != 0) {\n      *(undefined4 *)(bitOffset + 0x28) = 0x8005321;\n      *data = allocatedMemory;\n      *(ushort *)(data + 3) = *(ushort *)(data + 3) | 0x80;\n      data[5] = bitOffsetCopy;\n      data[4] = allocatedMemory;\n      if ((dataCopy != (int *)0x0) &&\n         (allocatedMemory = _isatty_r(bitOffset,(int)*(short *)((int)data + 0xe)), allocatedMemory != 0)) {\n        *(ushort *)(data + 3) = *(ushort *)(data + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(data + 3) = status | *(ushort *)(data + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(data + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(data + 3) = *(ushort *)(data + 3) & 0xfffc | 2;\n  }\n  *data = (int)data + 0x47;\n  data[4] = (int)data + 0x47;\n  data[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080054fc": "parse_and_allocate_memory_080054fc",
                "param_1": "bitOffset",
                "param_2": "data",
                "uVar1": "status",
                "iVar2": "allocatedMemory",
                "local_18": "bitOffsetCopy",
                "local_14": "dataCopy"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "_isatty_r",
                "__swhatbuf_r",
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800557c": {
            "entrypoint": "0x0800557c",
            "current_name": "FUNC_0800557c",
            "code": "\nvoid FUNC_0800557c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800557c": "FUNC_0800557c"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800557e": {
            "entrypoint": "0x0800557e",
            "current_name": "FUNC_0800557e",
            "code": "\nvoid FUNC_0800557e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800557e": "FUNC_0800557e"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005580": {
            "entrypoint": "0x08005580",
            "current_name": "execute_function_08005580",
            "code": "\nundefined4 execute_function_08005580(undefined4 *result,uint index,undefined4 unused1,undefined4 unused2)\n\n{\n  __pid_t process_id;\n  undefined4 kill_result;\n  int function_array;\n  code *function_ptr;\n  \n  if (0x1f < index) {\n    *result = 0x16;\n    return 0xffffffff;\n  }\n  function_array = result[0x11];\n  if ((function_array != 0) && (function_ptr = *(code **)(function_array + index * 4), function_ptr != (code *)0x0)) {\n    if (function_ptr != (code *)0x1) {\n      if (function_ptr == (code *)0xffffffff) {\n        *result = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(function_array + index * 4) = 0;\n      (*function_ptr)(index);\n    }\n    return 0;\n  }\n  process_id = _getpid_r();\n  kill_result = _kill_r(result,process_id,index,unused2);\n  return kill_result;\n}\n\n",
            "renaming": {
                "FUN_08005580": "execute_function_08005580",
                "param_1": "result",
                "param_2": "index",
                "param_3": "unused1",
                "param_4": "unused2",
                "_Var1": "process_id",
                "uVar2": "kill_result",
                "iVar3": "function_array",
                "pcVar4": "function_ptr"
            },
            "calling": [
                "raise"
            ],
            "called": [
                "_getpid_r",
                "_kill_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055d0": {
            "entrypoint": "0x080055d0",
            "current_name": "handle_signal_080055d0",
            "code": "\nint handle_signal_080055d0(int signal_number)\n\n{\n  int result;\n  \n  result = _raise_r(_impure_ptr,signal_number);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080055d0": "handle_signal_080055d0",
                "__sig": "signal_number",
                "iVar1": "result"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "_raise_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055e0": {
            "entrypoint": "0x080055e0",
            "current_name": "kill_process_080055e0",
            "code": "\nvoid kill_process_080055e0(int *error_code,__pid_t process_id,int signal)\n\n{\n  int result;\n  \n  errno = 0;\n  result = _kill(process_id,signal);\n  if ((result == -1) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055e0": "kill_process_080055e0",
                "param_1": "error_code",
                "param_2": "process_id",
                "param_3": "signal",
                "iVar1": "result"
            },
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_kill"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005604": {
            "entrypoint": "0x08005604",
            "current_name": "FUN_08005604",
            "code": "\n\n\n__pid_t _getpid(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {},
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_getpid"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005608": {
            "entrypoint": "0x08005608",
            "current_name": "update_read_count_and_value_08005608",
            "code": "\nvoid updateReadCountAndValue_08005608(undefined4 fileDescriptor,int fileData)\n\n{\n  int readResult;\n  uint updatedValue;\n  bool isReadSuccessful;\n  \n  readResult = _read_r(fileDescriptor,(int)*(short *)(fileData + 0xe));\n  isReadSuccessful = -1 < readResult;\n  if (isReadSuccessful) {\n    updatedValue = *(int *)(fileData + 0x54) + readResult;\n  }\n  else {\n    updatedValue = *(ushort *)(fileData + 0xc) & 0xffffefff;\n  }\n  if (isReadSuccessful) {\n    *(uint *)(fileData + 0x54) = updatedValue;\n  }\n  if (!isReadSuccessful) {\n    *(short *)(fileData + 0xc) = (short)updatedValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005608": "update_read_count_and_value_08005608",
                "param_1": "fileDescriptor",
                "param_2": "fileData",
                "iVar1": "readResult",
                "uVar2": "updatedValue",
                "bVar3": "isReadSuccessful"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800562a": {
            "entrypoint": "0x0800562a",
            "current_name": "write_to_file_0800562a",
            "code": "\nvoid writeToFile_0800562a(undefined4 fileDescriptor,int buffer,undefined4 data,undefined4 size)\n\n{\n  if ((int)((uint)*(unsignedShort *)(buffer + 0xc) << 0x17) < 0) {\n    repositionFilePointer(fileDescriptor,(int)*(short *)(buffer + 0xe),0,2);\n  }\n  *(unsignedShort *)(buffer + 0xc) = *(unsignedShort *)(buffer + 0xc) & 0xefff;\n  writeDataToFile(fileDescriptor,(int)*(short *)(buffer + 0xe),data,size);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800562a": "write_to_file_0800562a",
                "param_1": "fileDescriptor",
                "param_2": "buffer",
                "param_3": "data",
                "param_4": "size",
                "ushort": "unsignedShort",
                "_lseek_r": "repositionFilePointer",
                "_write_r": "writeDataToFile"
            },
            "calling": [],
            "called": [
                "_lseek_r",
                "_write_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005662": {
            "entrypoint": "0x08005662",
            "current_name": "file_seek_08005662",
            "code": "\nvoid file_seek_08005662(undefined4 param_fd,int param_data)\n\n{\n  int seek_result;\n  ushort modified_flags;\n  bool is_seek_error;\n  \n  seek_result = _lseek_r(param_fd,(int)*(short *)(param_data + 0xe));\n  is_seek_error = seek_result == -1;\n  if (is_seek_error) {\n    modified_flags = *(ushort *)(param_data + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(param_data + 0x54) = seek_result;\n    modified_flags = *(ushort *)(param_data + 0xc) | 0x1000;\n  }\n  if (is_seek_error) {\n    *(ushort *)(param_data + 0xc) = modified_flags;\n  }\n  if (!is_seek_error) {\n    *(ushort *)(param_data + 0xc) = modified_flags;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005662": "file_seek_08005662",
                "param_1": "param_fd",
                "param_2": "param_data",
                "iVar1": "seek_result",
                "uVar2": "modified_flags",
                "bVar3": "is_seek_error"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005686": {
            "entrypoint": "0x08005686",
            "current_name": "close_file_08005686",
            "code": "\nvoid closeFile_08005686(undefined4 fileDescriptor,int structPointer)\n\n{\n  _close_r(fileDescriptor,(int)*(short *)(structPointer + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005686": "close_file_08005686",
                "param_1": "fileDescriptor",
                "param_2": "structPointer"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005690": {
            "entrypoint": "0x08005690",
            "current_name": "write_to_file_08005690",
            "code": "\nvoid writeToFile_08005690(int *errorCode,int fileDescriptor,char *buffer,int bufferSize)\n\n{\n  int writeResult;\n  \n  errno = 0;\n  writeResult = _write(fileDescriptor,buffer,bufferSize);\n  if ((writeResult == -1) && (errno != 0)) {\n    *errorCode = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005690": "write_to_file_08005690",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "bufferSize",
                "iVar1": "writeResult"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056b4": {
            "entrypoint": "0x080056b4",
            "current_name": "close_file_080056b4",
            "code": "\nvoid closeFile_080056b4(int *errorPtr,int fileDescriptor)\n\n{\n  int closeResult;\n  \n  errno = 0;\n  closeResult = _close(fileDescriptor);\n  if ((closeResult == -1) && (errno != 0)) {\n    *errorPtr = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056b4": "close_file_080056b4",
                "param_1": "errorPtr",
                "param_2": "fileDescriptor",
                "iVar1": "closeResult"
            },
            "calling": [
                "__sclose"
            ],
            "called": [
                "_close"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056d4": {
            "entrypoint": "0x080056d4",
            "current_name": "get_file_stats_080056d4",
            "code": "\nvoid get_file_stats_080056d4(int *error_code,int file_descriptor,stat *file_stats)\n\n{\n  int status;\n  \n  errno = 0;\n  status = _fstat(file_descriptor,file_stats);\n  if ((status == -1) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056d4": "get_file_stats_080056d4",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "file_stats",
                "iVar1": "status"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056f8": {
            "entrypoint": "0x080056f8",
            "current_name": "check_tty_error_080056f8",
            "code": "\nvoid check_tty_error_080056f8(int *error_code,int file_descriptor)\n\n{\n  int is_tty;\n  \n  error_number = 0;\n  is_tty = _isatty(file_descriptor);\n  if ((is_tty == -1) && (error_number != 0)) {\n    *error_code = error_number;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056f8": "check_tty_error_080056f8",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "iVar1": "is_tty",
                "errno": "error_number"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005718": {
            "entrypoint": "0x08005718",
            "current_name": "set_file_position_08005718",
            "code": "\nvoid setFilePosition_08005718(int *errorCode,int fileDescriptor,__off_t offset,int origin)\n\n{\n  __off_t result;\n  \n  errno = 0;\n  result = _lseek(fileDescriptor,offset,origin);\n  if ((result == -1) && (errno != 0)) {\n    *errorCode = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005718": "set_file_position_08005718",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "param_3": "offset",
                "param_4": "origin",
                "_Var1": "result"
            },
            "calling": [
                "__swrite",
                "__sseek"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800573c": {
            "entrypoint": "0x0800573c",
            "current_name": "read_into_buffer_0800573c",
            "code": "\nvoid readIntoBuffer_0800573c(int *error,int fileDescriptor,char *buffer,int count)\n\n{\n  int readResult;\n  \n  errno = 0;\n  readResult = _read(fileDescriptor,buffer,count);\n  if ((readResult == -1) && (errno != 0)) {\n    *error = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800573c": "read_into_buffer_0800573c",
                "param_1": "error",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "count",
                "iVar1": "readResult"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005760": {
            "entrypoint": "0x08005760",
            "current_name": "abort_and_throw_bad_function_call_08005760",
            "code": "\n\n/* std::__throw_bad_function_call() */\n\nvoid std::abort_and_throw_bad_function_call_08005760(void)\n\n{\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_08005760": "abort_and_throw_bad_function_call_08005760"
            },
            "calling": [
                "operator()"
            ],
            "called": [
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005768": {
            "entrypoint": "0x08005768",
            "current_name": "update_id_values_08005768",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::updateIDValues_08005768(void)\n\n{\n  if (-1 < moneypunct<char,false>::id << 0x1f) {\n    moneypunct<char,false>::id = 1;\n  }\n  if (-1 < moneypunct<char,true>::id << 0x1f) {\n    moneypunct<char,true>::id = 1;\n  }\n  if (-1 < money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < numpunct<char>::id << 0x1f) {\n    numpunct<char>::id = 1;\n  }\n  if (-1 < num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __timepunct<char>::id << 0x1f) {\n    __timepunct<char>::id = 1;\n  }\n  if (-1 < time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < messages<char>::id << 0x1f) {\n    messages<char>::id = 1;\n  }\n  if (-1 < collate<char>::id << 0x1f) {\n    collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005768": "update_id_values_08005768"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800582c": {
            "entrypoint": "0x0800582c",
            "current_name": "initialize_locale_data_0800582c",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeLocaleData_0800582c(void)\n\n{\n  if (-1 < moneypunct<wchar_t,false>::id << 0x1f) {\n    moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < moneypunct<wchar_t,true>::id << 0x1f) {\n    moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < numpunct<wchar_t>::id << 0x1f) {\n    numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __timepunct<wchar_t>::id << 0x1f) {\n    __timepunct<wchar_t>::id = 1;\n  }\n  if (-1 < time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < messages<wchar_t>::id << 0x1f) {\n    messages<wchar_t>::id = 1;\n  }\n  if (-1 < collate<wchar_t>::id << 0x1f) {\n    collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800582c": "initialize_locale_data_0800582c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058f0": {
            "entrypoint": "0x080058f0",
            "current_name": "initialize_localization_080058f0",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeLocalization_080058f0(void)\n\n{\n  if (-1 < __cxx11::moneypunct<wchar_t,false>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<wchar_t,true>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<wchar_t>::id << 0x1f) {\n    __cxx11::numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<wchar_t>::id << 0x1f) {\n    __cxx11::messages<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::collate<wchar_t>::id << 0x1f) {\n    __cxx11::collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080058f0": "initialize_localization_080058f0"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005974": {
            "entrypoint": "0x08005974",
            "current_name": "initialize_character_type_info_08005974",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeCharacterTypeInfo_08005974(void)\n\n{\n  if (-1 < __cxx11::moneypunct<char,false>::id << 0x1f) {\n    __cxx11::moneypunct<char,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<char,true>::id << 0x1f) {\n    __cxx11::moneypunct<char,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<char>::id << 0x1f) {\n    __cxx11::numpunct<char>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f\n     ) {\n    __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<char>::id << 0x1f) {\n    __cxx11::messages<char>::id = 1;\n  }\n  if (-1 < __cxx11::collate<char>::id << 0x1f) {\n    __cxx11::collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005974": "initialize_character_type_info_08005974"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f8": {
            "entrypoint": "0x080059f8",
            "current_name": "FUNC_080059f8",
            "code": "\nvoid FUNC_080059f8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080059f8": "FUNC_080059f8"
            },
            "calling": [
                "__do_global_dtors_aux",
                "__libc_init_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005a04": {
            "entrypoint": "0x08005a04",
            "current_name": "FUNC_08005a04",
            "code": "\nvoid FUNC_08005a04(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a04": "FUNC_08005a04"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 143331,
    "layers": [
        [
            "FUN_080001ac",
            "FUN_08000218",
            "FUN_08000230",
            "FUN_080002d0",
            "FUN_08000300",
            "FUN_080005e0",
            "FUN_080005e4",
            "FUN_08000600",
            "FUN_0800066c",
            "FUN_08000682",
            "FUN_08000690",
            "FUN_080006b4",
            "FUN_08000728",
            "FUN_0800076c",
            "FUN_080007f0",
            "FUN_080008cc",
            "FUN_080008e2",
            "FUN_08000998",
            "FUN_08000a00",
            "FUN_08000a4e",
            "FUN_08000a7a",
            "FUN_08000b04",
            "FUN_08000b54",
            "FUN_08000c4c",
            "FUN_08000c64",
            "FUN_08000c7c",
            "FUN_08000c8c",
            "FUN_08000d3c",
            "FUN_08000d8c",
            "FUN_08000d8e",
            "FUN_08000d98",
            "FUN_08000de4",
            "FUN_08000e18",
            "FUN_08000e30",
            "FUN_08000e3c",
            "FUN_08000e60",
            "FUN_08000ec4",
            "FUN_08000ee0",
            "FUN_08000f0c",
            "FUN_08000f2c",
            "FUN_08000f4e",
            "FUN_08000f56",
            "FUN_08000f72",
            "FUN_08000f8c",
            "FUN_08000fb4",
            "FUN_08001198",
            "FUN_080011a4",
            "FUN_080011c0",
            "FUN_0800124a",
            "FUN_08001256",
            "FUN_08001420",
            "FUN_08001440",
            "FUN_08001460",
            "FUN_080014ec",
            "FUN_08001578",
            "FUN_080015bc",
            "FUN_0800160e",
            "FUN_0800165a",
            "FUN_08001684",
            "FUN_0800171a",
            "FUN_08001864",
            "FUN_08001904",
            "FUN_080019a0",
            "FUN_08001ab0",
            "FUN_08001bfc",
            "FUN_08001d00",
            "FUN_08001e68",
            "FUN_08001f3c",
            "FUN_08001f9c",
            "FUN_0800201c",
            "FUN_080023b4",
            "FUN_08002488",
            "FUN_080025e0",
            "FUN_080025ec",
            "FUN_0800260c",
            "FUN_0800262c",
            "FUN_0800268e",
            "FUN_080026ce",
            "FUN_08002848",
            "FUN_08002864",
            "FUN_080028d4",
            "FUN_080028f0",
            "FUN_08002940",
            "FUN_0800295c",
            "FUN_080029c8",
            "FUN_08002d0c",
            "FUN_08002d72",
            "FUN_08002dd0",
            "FUN_08002eb2",
            "FUN_08002efa",
            "FUN_08002f4c",
            "FUN_08002f66",
            "FUN_08002ffc",
            "FUN_0800311c",
            "FUN_0800312c",
            "FUN_08003138",
            "FUN_0800314e",
            "FUN_0800316c",
            "FUN_0800318c",
            "FUN_080031fc",
            "FUN_08003380",
            "FUN_0800339c",
            "FUN_080033c8",
            "FUN_080033d8",
            "FUN_0800340c",
            "FUN_08003414",
            "FUN_0800346c",
            "FUN_08003476",
            "FUN_08003486",
            "FUN_080034b6",
            "FUN_080034ce",
            "FUN_080034da",
            "FUN_080034f4",
            "FUN_08003506",
            "FUN_0800351e",
            "FUN_0800352e",
            "FUN_0800354a",
            "FUN_0800355e",
            "FUN_08003582",
            "FUN_08003594",
            "FUN_080035ac",
            "FUN_080035bc",
            "FUN_080035fc",
            "FUN_08003750",
            "FUN_08003754",
            "FUN_0800376e",
            "FUN_0800377c",
            "FUN_08003798",
            "FUN_080037ac",
            "FUN_080037c0",
            "FUN_080037d4",
            "FUN_080037e8",
            "FUN_080037fc",
            "FUN_08003810",
            "FUN_0800382c",
            "FUN_08003840",
            "FUN_08003854",
            "FUN_08003868",
            "FUN_0800387c",
            "FUN_08003880",
            "FUN_080038d0",
            "FUN_08003900",
            "FUN_08003918",
            "FUN_08003928",
            "FUN_08003938",
            "FUN_08003948",
            "FUN_08003958",
            "FUN_08003968",
            "FUN_08003978",
            "FUN_08003cc8",
            "FUN_08003d18",
            "FUN_08003dd0",
            "FUN_08003df4",
            "FUN_08003e18",
            "FUN_08003e54",
            "FUN_08003eac",
            "FUN_08003f00",
            "FUN_08003f24",
            "FUN_08003f48",
            "FUN_08003f94",
            "FUN_08003fd4",
            "FUN_08003fec",
            "FUN_08004004",
            "FUN_0800401c",
            "FUN_08004034",
            "FUN_0800404c",
            "FUN_08004064",
            "FUN_0800407c",
            "FUN_08004094",
            "FUN_080040d0",
            "FUN_080040d6",
            "FUN_080040e0",
            "FUN_080040e4",
            "FUN_080040e8",
            "FUN_080040ec",
            "FUN_080040f8",
            "FUN_080040fc",
            "FUN_0800410c",
            "FUN_08004110",
            "FUN_080041bc",
            "FUN_08004204",
            "FUN_0800420c",
            "FUN_08004240",
            "FUN_08004254",
            "FUN_08004270",
            "FUN_08004298",
            "FUN_080042ac",
            "FUN_080042e8",
            "FUN_08004364",
            "FUN_08004388",
            "FUN_08004444",
            "FUN_08004460",
            "FUN_0800447c",
            "FUN_080044d8",
            "FUN_080044fc",
            "FUN_0800450a",
            "FUN_08004544",
            "FUN_08004560",
            "FUN_0800458c",
            "FUN_0800459a",
            "FUN_080045be",
            "FUN_080045c8",
            "FUN_08004622",
            "FUN_08004638",
            "FUN_08004640",
            "FUN_08004648",
            "FUN_08004658",
            "FUN_08004678",
            "FUN_0800468c",
            "FUN_080046b4",
            "FUN_08004760",
            "FUN_0800476a",
            "FUN_08004774",
            "FUN_0800477e",
            "FUN_08004788",
            "FUN_08004792",
            "FUN_080047a8",
            "FUN_080047c0",
            "FUN_080047d0",
            "FUN_080047f0",
            "FUN_080047fe",
            "FUN_08004808",
            "FUN_08004844",
            "FUN_08004860",
            "FUN_08004884",
            "FUN_080048cc",
            "FUN_080048dc",
            "FUN_08004978",
            "FUN_08004a34",
            "FUN_08004a60",
            "FUN_08004a84",
            "FUN_08004cb0",
            "FUN_08004d9c",
            "FUN_08004fdc",
            "FUN_0800500c",
            "FUN_0800502c",
            "FUN_080050d0",
            "FUN_080051ac",
            "FUN_080051bc",
            "FUN_080052cc",
            "FUN_08005320",
            "FUN_0800532c",
            "FUN_08005374",
            "FUN_080053a0",
            "FUN_08005400",
            "FUN_08005478",
            "FUN_080054b4",
            "FUN_080054fc",
            "FUN_08005580",
            "FUN_080055d0",
            "FUN_080055e0",
            "FUN_08005608",
            "FUN_0800562a",
            "FUN_08005662",
            "FUN_08005686",
            "FUN_08005690",
            "FUN_080056b4",
            "FUN_080056d4",
            "FUN_080056f8",
            "FUN_08005718",
            "FUN_0800573c",
            "FUN_08005760",
            "FUN_08005768",
            "FUN_0800582c",
            "FUN_080058f0",
            "FUN_08005974"
        ]
    ],
    "locked_functions": []
}