{
    "functions": {
        "FUN_0800010c": {
            "entrypoint": "0x0800010c",
            "current_name": "set_completed_flag_0800010c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08000118) */\n\nundefined4 setCompletedFlag_0800010c(undefined4 input)\n\n{\n  if ((char)completionStatus == '\\0') {\n    completionStatus._0_1_ = '\\x01';\n  }\n  return input;\n}\n\n",
            "renaming": {
                "FUN_0800010c": "set_completed_flag_0800010c",
                "param_1": "input",
                "completed_8667": "completionStatus"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000130": {
            "entrypoint": "0x08000130",
            "current_name": "FUNC_08000130",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08000134) */\n/* WARNING: Removing unreachable block (ram,0x0800014e) */\n/* WARNING: Removing unreachable block (ram,0x08000144) */\n/* WARNING: Removing unreachable block (ram,0x08000160) */\n/* WARNING: Removing unreachable block (ram,0x08000154) */\n\n\nvoid FUNC_08000130(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000130": "FUNC_08000130"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000178": {
            "entrypoint": "0x08000178",
            "current_name": "calculate_string_length_08000178",
            "code": "\nsize_t calculateStringLength_08000178(char *str)\n\n{\n  char currentChar;\n  char *nextCharPtr;\n  char *currentCharPtr;\n  \n  currentCharPtr = str;\n  do {\n    nextCharPtr = currentCharPtr + 1;\n    currentChar = *currentCharPtr;\n    currentCharPtr = nextCharPtr;\n  } while (currentChar != '\\0');\n  return (size_t)(nextCharPtr + (-1 - (int)str));\n}\n\n",
            "renaming": {
                "FUN_08000178": "calculate_string_length_08000178",
                "__s": "str",
                "cVar1": "currentChar",
                "pcVar2": "nextCharPtr",
                "pcVar3": "currentCharPtr"
            },
            "calling": [
                "print",
                "printNumber"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000188": {
            "entrypoint": "0x08000188",
            "current_name": "add_offset_to_parameter_08000188",
            "code": "\nvoid addOffsetToParameter_08000188(undefined4 target,uint offset)\n\n{\n  addition(target,offset ^ 0x80000000);\n  void;\n}\n\n",
            "renaming": {
                "FUN_08000188": "add_offset_to_parameter_08000188",
                "param_1": "target",
                "param_2": "offset",
                "__aeabi_dadd": "addition",
                "return": "void"
            },
            "calling": [],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000190": {
            "entrypoint": "0x08000190",
            "current_name": "reverse_bits_08000190",
            "code": "\nulonglong reverseBits_08000190(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int bitCount1;\n  byte carry;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint result2;\n  uint result3;\n  int bitCount2;\n  uint result1;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  bool equal;\n  bool carryFlag;\n  bool overflow;\n  \n  result2 = input4 ^ 0x80000000;\n  result1 = input2 << 1;\n  input4 = input4 << 1;\n  equal = ((input2 ^ result2) & 0x7fffffff) == 0;\n  carryFlag = equal && input1 == input3;\n  if (!equal || input1 != input3) {\n    carryFlag = (result1 | input1) == 0;\n  }\n  if (!carryFlag) {\n    carryFlag = (input4 | input3) == 0;\n  }\n  bitCount2 = (int)result1 >> 0x15;\n  if (!carryFlag) {\n    carryFlag = bitCount2 == -1;\n  }\n  bitCount1 = (int)input4 >> 0x15;\n  if (!carryFlag) {\n    carryFlag = bitCount1 == -1;\n  }\n  if (carryFlag) {\n    if (bitCount2 == -1 || bitCount1 == -1) {\n      result1 = result2;\n      temp5 = input3;\n      if (bitCount2 == -1) {\n        result1 = input2;\n        temp5 = input1;\n      }\n      if (bitCount2 != -1 || bitCount1 != -1) {\n        input3 = temp5;\n        result2 = result1;\n      }\n      carryFlag = (temp5 | result1 << 0xc) == 0;\n      if (carryFlag) {\n        carryFlag = (input3 | result2 << 0xc) == 0;\n      }\n      if (carryFlag) {\n        carryFlag = result1 == result2;\n      }\n      if (!carryFlag) {\n        result1 = result1 | 0x80000;\n      }\n      return CONCAT44(result1,temp5);\n    }\n    if (((input2 ^ result2) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((result1 | input1) == 0) {\n        input1 = input3;\n        input2 = result2;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != result2) {\n      return 0;\n    }\n    if (result1 >> 0x15 == 0) {\n      carryFlag = (input1 & 0x80000000) != 0;\n      result2 = input2 * 2 + (uint)carryFlag;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)carryFlag)) {\n        result2 = result2 | 0x80000000;\n      }\n      return CONCAT44(result2,input1 << 1);\n    }\n    if (result1 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  result1 = result1 >> 0x15;\n  input4 = input4 >> 0x15;\n  temp5 = input4 - result1;\n  carryFlag = temp5 != 0;\n  if (input4 < result1) {\n    temp5 = -temp5;\n  }\n  temp4 = input1;\n  result3 = input2;\n  if (carryFlag && result1 <= input4) {\n    result1 = result1 + temp5;\n    temp4 = input3;\n    result3 = result2;\n    input3 = input1;\n    result2 = input2;\n  }\n  if (0x36 < temp5) {\n    return CONCAT44(result3,temp4);\n  }\n  temp2 = result3 & 0xfffff | 0x100000;\n  if ((result3 & 0x80000000) != 0) {\n    carryFlag = temp4 != 0;\n    temp4 = -temp4;\n    temp2 = -temp2 - (uint)carryFlag;\n  }\n  result3 = result2 & 0xfffff | 0x100000;\n  if ((result2 & 0x80000000) != 0) {\n    carryFlag = input3 != 0;\n    input3 = -input3;\n    result3 = -result3 - (uint)carryFlag;\n  }\n  if (result1 == temp5) {\n    result3 = result3 ^ 0x100000;\n    if (result1 == 0) {\n      temp2 = temp2 ^ 0x100000;\n      result1 = 1;\n    }\n    else {\n      temp5 = temp5 - 1;\n    }\n  }\n  result2 = -temp5 + 0x20;\n  if ((int)temp5 < 0x21) {\n    temp6 = input3 << (result2 & 0xff);\n    input3 = input3 >> (temp5 & 0xff);\n    temp1 = temp4 + input3;\n    temp3 = result3 << (result2 & 0xff);\n    result2 = temp1 + temp3;\n    temp2 = temp2 + CARRY4(temp4,input3) + ((int)result3 >> (temp5 & 0xff)) +\n            (uint)CARRY4(temp1,temp3);\n  }\n  else {\n    temp6 = result3 << (-temp5 + 0x40 & 0xff);\n    if (input3 != 0) {\n      temp6 = temp6 | 2;\n    }\n    result3 = (int)result3 >> (temp5 - 0x20 & 0xff);\n    result2 = temp4 + result3;\n    temp2 = temp2 + ((int)result3 >> 0x1f) + (uint)CARRY4(temp4,result3);\n  }\n  input2 = temp2 & 0x80000000;\n  temp5 = temp2;\n  if ((int)temp2 < 0) {\n    carryFlag = temp6 == 0;\n    temp6 = -temp6;\n    temp5 = -result2;\n    result2 = -(uint)!carryFlag - result2;\n    temp5 = -(uint)(carryFlag <= temp5) - temp2;\n  }\n  if (0xfffff < temp5) {\n    temp4 = result1 - 1;\n    if (0x1fffff < temp5) {\n      temp4 = temp5 & 1;\n      temp5 = temp5 >> 1;\n      carry = (byte)result2;\n      result2 = (uint)(temp4 != 0) << 0x1f | result2 >> 1;\n      temp6 = (uint)(carry & 1) << 0x1f | temp6 >> 1;\n      temp4 = result1;\n      if (0xffbfffff < result1 * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    carryFlag = 0x7fffffff < temp6;\n    if (temp6 == 0x80000000) {\n      carryFlag = (result2 & 1) != 0;\n    }\n    return CONCAT44(temp5 + temp4 * 0x100000 + (uint)CARRY4(result2,(uint)carryFlag) | input2,\n                    result2 + carryFlag);\n  }\n  equal = (temp6 & 0x80000000) != 0;\n  temp6 = temp6 << 1;\n  temp4 = result2 * 2;\n  carryFlag = CARRY4(result2,result2);\n  result2 = result2 * 2 + (uint)equal;\n  temp5 = temp5 * 2 + (uint)(carryFlag || CARRY4(temp4,(uint)equal));\n  temp4 = result1 - 2;\n  if ((temp5 & 0x100000) != 0) goto LAB_080002a0;\n  result3 = result2;\n  result1 = temp5;\n  if (temp5 == 0) {\n    result3 = 0;\n    result1 = result2;\n  }\n  bitCount2 = LZCOUNT(result1);\n  if (temp5 == 0) {\n    bitCount2 = bitCount2 + 0x20;\n  }\n  temp5 = bitCount2 - 0xb;\n  overflow = SBORROW4(temp5,0x20);\n  result2 = bitCount2 - 0x2b;\n  carryFlag = (int)result2 < 0;\n  equal = result2 == 0;\n  if ((int)temp5 < 0x20) {\n    overflow = SCARRY4(result2,0xc);\n    bitCount2 = bitCount2 + -0x1f;\n    carryFlag = bitCount2 < 0;\n    equal = bitCount2 == 0;\n    result2 = temp5;\n    if (!equal && carryFlag == overflow) {\n      result3 = result1 << (temp5 & 0xff);\n      result1 = result1 >> (0xcU - bitCount2 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (equal || carryFlag != overflow) {\n    temp6 = 0x20 - result2;\n  }\n  result1 = result1 << (result2 & 0xff);\n  if (equal || carryFlag != overflow) {\n    result1 = result1 | result3 >> (temp6 & 0xff);\n  }\n  if (equal || carryFlag != overflow) {\n    result3 = result3 << (result2 & 0xff);\n  }\nLAB_08000318:\n  if ((int)temp5 <= (int)temp4) {\n    return CONCAT44(result1 + (temp4 - temp5) * 0x100000 | input2,result3);\n  }\n  result2 = ~(temp4 - temp5);\n  if ((int)result2 < 0x1f) {\n    bitCount2 = result2 - 0x13;\n    if (bitCount2 != 0 && bitCount2 < 0 == SCARRY4(result2 - 0x1f,0xc)) {\n      return CONCAT44(temp2,result3 >> (0x20 - (0xcU - bitCount2) & 0xff) | result1 << (0xcU - bitCount2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    result2 = result2 + 1;\n    return CONCAT44(input2 | result1 >> (result2 & 0xff),\n                    result3 >> (result2 & 0xff) | result1 << (0x20 - result2 & 0xff));\n  }\n  return CONCAT44(temp2,result1 >> (result2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000190": "reverse_bits_08000190",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "bitCount1",
                "bVar2": "carry",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "uVar6": "result2",
                "uVar7": "result3",
                "iVar8": "bitCount2",
                "uVar9": "result1",
                "uVar10": "temp4",
                "uVar11": "temp5",
                "uVar12": "temp6",
                "bVar13": "equal",
                "bVar14": "carryFlag",
                "bVar15": "overflow"
            },
            "calling": [
                "SetTunings",
                "Compute",
                "SetControllerDirection",
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000194": {
            "entrypoint": "0x08000194",
            "current_name": "calculate_08000194",
            "code": "\nulonglong calculate_08000194(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int shift1;\n  byte carry1;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int shift2;\n  uint temp4;\n  uint temp5;\n  uint result1;\n  uint result2;\n  uint result3;\n  uint result4;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  \n  temp4 = input2 << 1;\n  result1 = input4 << 1;\n  flag1 = ((input2 ^ input4) & 0x7fffffff) == 0;\n  flag2 = flag1 && input1 == input3;\n  if (!flag1 || input1 != input3) {\n    flag2 = (temp4 | input1) == 0;\n  }\n  if (!flag2) {\n    flag2 = (result1 | input3) == 0;\n  }\n  shift2 = (int)temp4 >> 0x15;\n  if (!flag2) {\n    flag2 = shift2 == -1;\n  }\n  shift1 = (int)result1 >> 0x15;\n  if (!flag2) {\n    flag2 = shift1 == -1;\n  }\n  if (flag2) {\n    if (shift2 == -1 || shift1 == -1) {\n      result1 = input4;\n      temp4 = input3;\n      if (shift2 == -1) {\n        result1 = input2;\n        temp4 = input1;\n      }\n      if (shift2 != -1 || shift1 != -1) {\n        input3 = temp4;\n        input4 = result1;\n      }\n      flag2 = (temp4 | result1 << 0xc) == 0;\n      if (flag2) {\n        flag2 = (input3 | input4 << 0xc) == 0;\n      }\n      if (flag2) {\n        flag2 = result1 == input4;\n      }\n      if (!flag2) {\n        result1 = result1 | 0x80000;\n      }\n      return CONCAT44(result1,temp4);\n    }\n    if (((input2 ^ input4) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((temp4 | input1) == 0) {\n        input1 = input3;\n        input2 = input4;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != input4) {\n      return 0;\n    }\n    if (temp4 >> 0x15 == 0) {\n      flag2 = (input1 & 0x80000000) != 0;\n      result1 = input2 * 2 + (uint)flag2;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)flag2)) {\n        result1 = result1 | 0x80000000;\n      }\n      return CONCAT44(result1,input1 << 1);\n    }\n    if (temp4 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  temp4 = temp4 >> 0x15;\n  result1 = result1 >> 0x15;\n  result2 = result1 - temp4;\n  flag2 = result2 != 0;\n  if (result1 < temp4) {\n    result2 = -result2;\n  }\n  temp5 = input1;\n  temp3 = input2;\n  if (flag2 && temp4 <= result1) {\n    temp4 = temp4 + result2;\n    temp5 = input3;\n    temp3 = input4;\n    input3 = input1;\n    input4 = input2;\n  }\n  if (0x36 < result2) {\n    return CONCAT44(temp3,temp5);\n  }\n  result1 = temp3 & 0xfffff | 0x100000;\n  if ((temp3 & 0x80000000) != 0) {\n    flag2 = temp5 != 0;\n    temp5 = -temp5;\n    result1 = -result1 - (uint)flag2;\n  }\n  temp3 = input4 & 0xfffff | 0x100000;\n  if ((input4 & 0x80000000) != 0) {\n    flag2 = input3 != 0;\n    input3 = -input3;\n    temp3 = -temp3 - (uint)flag2;\n  }\n  if (temp4 == result2) {\n    temp3 = temp3 ^ 0x100000;\n    if (temp4 == 0) {\n      result1 = result1 ^ 0x100000;\n      temp4 = 1;\n    }\n    else {\n      result2 = result2 - 1;\n    }\n  }\n  result4 = -result2 + 0x20;\n  if ((int)result2 < 0x21) {\n    result3 = input3 << (result4 & 0xff);\n    input3 = input3 >> (result2 & 0xff);\n    temp1 = temp5 + input3;\n    temp2 = temp3 << (result4 & 0xff);\n    result4 = temp1 + temp2;\n    result1 = result1 + CARRY4(temp5,input3) + ((int)temp3 >> (result2 & 0xff)) +\n            (uint)CARRY4(temp1,temp2);\n  }\n  else {\n    result3 = temp3 << (-result2 + 0x40 & 0xff);\n    if (input3 != 0) {\n      result3 = result3 | 2;\n    }\n    temp3 = (int)temp3 >> (result2 - 0x20 & 0xff);\n    result4 = temp5 + temp3;\n    result1 = result1 + ((int)temp3 >> 0x1f) + (uint)CARRY4(temp5,temp3);\n  }\n  input2 = result1 & 0x80000000;\n  result2 = result1;\n  if ((int)result1 < 0) {\n    flag2 = result3 == 0;\n    result3 = -result3;\n    result2 = -result4;\n    result4 = -(uint)!flag2 - result4;\n    result2 = -(uint)(flag2 <= result2) - result1;\n  }\n  if (0xfffff < result2) {\n    temp5 = temp4 - 1;\n    if (0x1fffff < result2) {\n      result1 = result2 & 1;\n      result2 = result2 >> 1;\n      carry1 = (byte)result4;\n      result4 = (uint)(result1 != 0) << 0x1f | result4 >> 1;\n      result3 = (uint)(carry1 & 1) << 0x1f | result3 >> 1;\n      temp5 = temp4;\n      if (0xffbfffff < temp4 * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    flag2 = 0x7fffffff < result3;\n    if (result3 == 0x80000000) {\n      flag2 = (result4 & 1) != 0;\n    }\n    return CONCAT44(result2 + temp5 * 0x100000 + (uint)CARRY4(result4,(uint)flag2) | input2,\n                    result4 + flag2);\n  }\n  flag1 = (result3 & 0x80000000) != 0;\n  result3 = result3 << 1;\n  temp5 = result4 * 2;\n  flag2 = CARRY4(result4,result4);\n  result4 = result4 * 2 + (uint)flag1;\n  result2 = result2 * 2 + (uint)(flag2 || CARRY4(temp5,(uint)flag1));\n  temp5 = temp4 - 2;\n  if ((result2 & 0x100000) != 0) goto LAB_080002a0;\n  temp3 = result4;\n  temp4 = result2;\n  if (result2 == 0) {\n    temp3 = 0;\n    temp4 = result4;\n  }\n  shift2 = LZCOUNT(temp4);\n  if (result2 == 0) {\n    shift2 = shift2 + 0x20;\n  }\n  result4 = shift2 - 0xb;\n  flag3 = SBORROW4(result4,0x20);\n  result2 = shift2 - 0x2b;\n  flag2 = (int)result2 < 0;\n  flag1 = result2 == 0;\n  if ((int)result4 < 0x20) {\n    flag3 = SCARRY4(result2,0xc);\n    shift2 = shift2 + -0x1f;\n    flag2 = shift2 < 0;\n    flag1 = shift2 == 0;\n    result2 = result4;\n    if (!flag1 && flag2 == flag3) {\n      temp3 = temp4 << (result4 & 0xff);\n      temp4 = temp4 >> (0xcU - shift2 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (flag1 || flag2 != flag3) {\n    result3 = 0x20 - result2;\n  }\n  temp4 = temp4 << (result2 & 0xff);\n  if (flag1 || flag2 != flag3) {\n    temp4 = temp4 | temp3 >> (result3 & 0xff);\n  }\n  if (flag1 || flag2 != flag3) {\n    temp3 = temp3 << (result2 & 0xff);\n  }\nLAB_08000318:\n  if ((int)result4 <= (int)temp5) {\n    return CONCAT44(temp4 + (temp5 - result4) * 0x100000 | input2,temp3);\n  }\n  result2 = ~(temp5 - result4);\n  if ((int)result2 < 0x1f) {\n    shift2 = result2 - 0x13;\n    if (shift2 != 0 && shift2 < 0 == SCARRY4(result2 - 0x1f,0xc)) {\n      return CONCAT44(result1,temp3 >> (0x20 - (0xcU - shift2) & 0xff) | temp4 << (0xcU - shift2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    result2 = result2 + 1;\n    return CONCAT44(input2 | temp4 >> (result2 & 0xff),\n                    temp3 >> (result2 & 0xff) | temp4 << (0x20 - result2 & 0xff));\n  }\n  return CONCAT44(result1,temp4 >> (result2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000194": "calculate_08000194",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shift1",
                "bVar2": "carry1",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "iVar6": "shift2",
                "uVar7": "temp4",
                "uVar8": "temp5",
                "uVar9": "result1",
                "uVar10": "result2",
                "uVar11": "result3",
                "uVar12": "result4",
                "bVar13": "flag1",
                "bVar14": "flag2",
                "bVar15": "flag3"
            },
            "calling": [
                "loop",
                "Compute",
                "__aeabi_drsub",
                "readThermocouple",
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800040c": {
            "entrypoint": "0x0800040c",
            "current_name": "reverse_and_shift_0800040c",
            "code": "\nulonglong reverseAndShift_0800040c(uint input)\n\n{\n  uint shiftedValue;\n  uint shiftAmount;\n  int bitCount;\n  uint shiftedAmount;\n  uint remainingBits;\n  bool isNegative;\n  bool isZero;\n  bool isCarry;\n  \n  if (input == 0) {\n    return 0;\n  }\n  shiftedValue = 0;\n  bitCount = LZCOUNT(input);\n  shiftedAmount = bitCount + 0x15;\n  isCarry = SBORROW4(shiftedAmount,0x20);\n  shiftAmount = bitCount - 0xb;\n  isNegative = (int)shiftAmount < 0;\n  isZero = shiftAmount == 0;\n  if (shiftedAmount < 0x20) {\n    isCarry = SCARRY4(shiftAmount,0xc);\n    isNegative = false;\n    isZero = bitCount + 1 == 0;\n    shiftAmount = shiftedAmount;\n    if (!isZero && isCarry == false) {\n      shiftedValue = input << shiftedAmount;\n      input = input >> (0xcU - (bitCount + 1) & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (isZero || isNegative != isCarry) {\n    remainingBits = 0x20 - shiftAmount;\n  }\n  input = input << (shiftAmount & 0xff);\n  if (isZero || isNegative != isCarry) {\n    input = input | 0U >> (remainingBits & 0xff);\n  }\n  if (isZero || isNegative != isCarry) {\n    shiftedValue = 0 << (shiftAmount & 0xff);\n  }\nLAB_08000318:\n  if (shiftedAmount < 0x433) {\n    return CONCAT44(input + (0x432 - shiftedAmount) * 0x100000,shiftedValue);\n  }\n  shiftAmount = ~(0x432 - shiftedAmount);\n  if (0x1e < (int)shiftAmount) {\n    return (ulonglong)(input >> (shiftAmount - 0x1f & 0xff));\n  }\n  bitCount = shiftAmount - 0x13;\n  if (bitCount == 0 || bitCount < 0 != SCARRY4(shiftAmount - 0x1f,0xc)) {\n    shiftAmount = shiftAmount + 1;\n    return CONCAT44(input >> (shiftAmount & 0xff),\n                    shiftedValue >> (shiftAmount & 0xff) | input << (0x20 - shiftAmount & 0xff));\n  }\n  return (ulonglong)(shiftedValue >> (0x20 - (0xcU - bitCount) & 0xff) | input << (0xcU - bitCount & 0xff));\n}\n\n",
            "renaming": {
                "FUN_0800040c": "reverse_and_shift_0800040c",
                "param_1": "input",
                "uVar1": "shiftedValue",
                "uVar2": "shiftAmount",
                "iVar3": "bitCount",
                "uVar4": "shiftedAmount",
                "in_r12": "remainingBits",
                "bVar5": "isNegative",
                "bVar6": "isZero",
                "bVar7": "isCarry"
            },
            "calling": [
                "loop",
                "SetTunings",
                "readThermocouple",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800042c": {
            "entrypoint": "0x0800042c",
            "current_name": "bit_shifting_0800042c",
            "code": "\nulonglong bitShifting_0800042c(uint input)\n\n{\n  uint shiftedValue;\n  uint absInput;\n  uint shiftAmount;\n  int leadingZeros;\n  uint finalShiftAmount;\n  uint signBit;\n  uint remainingBits;\n  bool isNegative;\n  bool isZero;\n  bool carryFlag;\n  \n  if (input == 0) {\n    return 0;\n  }\n  signBit = input & 0x80000000;\n  absInput = input;\n  if ((int)signBit < 0) {\n    absInput = -input;\n  }\n  shiftedValue = 0;\n  leadingZeros = LZCOUNT(absInput);\n  finalShiftAmount = leadingZeros + 0x15;\n  carryFlag = SBORROW4(finalShiftAmount,0x20);\n  shiftAmount = leadingZeros - 0xb;\n  isNegative = (int)shiftAmount < 0;\n  isZero = shiftAmount == 0;\n  if (finalShiftAmount < 0x20) {\n    carryFlag = SCARRY4(shiftAmount,0xc);\n    isNegative = false;\n    isZero = leadingZeros + 1 == 0;\n    shiftAmount = finalShiftAmount;\n    if (!isZero && carryFlag == false) {\n      shiftedValue = absInput << finalShiftAmount;\n      absInput = absInput >> (0xcU - (leadingZeros + 1) & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (isZero || isNegative != carryFlag) {\n    remainingBits = 0x20 - shiftAmount;\n  }\n  absInput = absInput << (shiftAmount & 0xff);\n  if (isZero || isNegative != carryFlag) {\n    absInput = absInput | 0U >> (remainingBits & 0xff);\n  }\n  if (isZero || isNegative != carryFlag) {\n    shiftedValue = 0 << (shiftAmount & 0xff);\n  }\nLAB_08000318:\n  if (finalShiftAmount < 0x433) {\n    return CONCAT44(absInput + (0x432 - finalShiftAmount) * 0x100000 | signBit,shiftedValue);\n  }\n  shiftAmount = ~(0x432 - finalShiftAmount);\n  if (0x1e < (int)shiftAmount) {\n    return CONCAT44(input,absInput >> (shiftAmount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leadingZeros = shiftAmount - 0x13;\n  if (leadingZeros == 0 || leadingZeros < 0 != SCARRY4(shiftAmount - 0x1f,0xc)) {\n    shiftAmount = shiftAmount + 1;\n    return CONCAT44(signBit | absInput >> (shiftAmount & 0xff),\n                    shiftedValue >> (shiftAmount & 0xff) | absInput << (0x20 - shiftAmount & 0xff));\n  }\n  return CONCAT44(input,shiftedValue >> (0x20 - (0xcU - leadingZeros) & 0xff) | absInput << (0xcU - leadingZeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800042c": "bit_shifting_0800042c",
                "param_1": "input",
                "uVar1": "shiftedValue",
                "uVar2": "absInput",
                "uVar3": "shiftAmount",
                "iVar4": "leadingZeros",
                "uVar5": "finalShiftAmount",
                "uVar6": "signBit",
                "in_r12": "remainingBits",
                "bVar7": "isNegative",
                "bVar8": "isZero",
                "bVar9": "carryFlag"
            },
            "calling": [
                "loop",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000450": {
            "entrypoint": "0x08000450",
            "current_name": "bitwise_shift_and_concatenate_08000450",
            "code": "\nulonglong bitwiseShiftAndConcatenate_08000450(uint input,undefined4 constant1,undefined4 constant2,uint mask)\n\n{\n  uint shiftedInput1;\n  uint temp1;\n  uint shiftedInput2;\n  uint shiftedInput3;\n  uint shiftedInput4;\n  int shiftCount;\n  uint temp2;\n  uint temp3;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  \n  shiftedInput4 = input << 1;\n  condition2 = shiftedInput4 == 0;\n  shiftedInput1 = (uint)((input & 0x80000000) != 0) << 0x1f;\n  shiftedInput3 = (uint)((int)shiftedInput4 >> 3) >> 1;\n  shiftedInput2 = shiftedInput1 | shiftedInput3;\n  input = input << 0x1d;\n  if (!condition2) {\n    mask = shiftedInput4 & 0xff000000;\n    condition2 = mask == 0;\n  }\n  if (!condition2) {\n    condition2 = mask == 0xff000000;\n  }\n  if (!condition2) {\n    return CONCAT44(shiftedInput2,input) ^ 0x3800000000000000;\n  }\n  if (shiftedInput4 == 0 || mask == 0xff000000) {\n    return CONCAT44(shiftedInput2,input);\n  }\n  temp1 = input;\n  shiftedInput4 = shiftedInput3;\n  if (shiftedInput3 == 0) {\n    temp1 = 0;\n    shiftedInput4 = input;\n  }\n  shiftCount = LZCOUNT(shiftedInput4);\n  if (shiftedInput3 == 0) {\n    shiftCount = shiftCount + 0x20;\n  }\n  temp2 = shiftCount - 0xb;\n  condition3 = SBORROW4(temp2,0x20);\n  shiftedInput3 = shiftCount - 0x2b;\n  condition2 = (int)shiftedInput3 < 0;\n  condition1 = shiftedInput3 == 0;\n  if ((int)temp2 < 0x20) {\n    condition3 = SCARRY4(shiftedInput3,0xc);\n    shiftCount = shiftCount + -0x1f;\n    condition2 = shiftCount < 0;\n    condition1 = shiftCount == 0;\n    shiftedInput3 = temp2;\n    if (!condition1 && condition2 == condition3) {\n      temp1 = shiftedInput4 << (temp2 & 0xff);\n      shiftedInput4 = shiftedInput4 >> (0xcU - shiftCount & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (condition1 || condition2 != condition3) {\n    temp3 = 0x20 - shiftedInput3;\n  }\n  shiftedInput4 = shiftedInput4 << (shiftedInput3 & 0xff);\n  if (condition1 || condition2 != condition3) {\n    shiftedInput4 = shiftedInput4 | temp1 >> (temp3 & 0xff);\n  }\n  if (condition1 || condition2 != condition3) {\n    temp1 = temp1 << (shiftedInput3 & 0xff);\n  }\nLAB_08000318:\n  if ((int)temp2 < 0x381) {\n    return CONCAT44(shiftedInput4 + (0x380 - temp2) * 0x100000 | shiftedInput1,temp1);\n  }\n  shiftedInput3 = ~(0x380 - temp2);\n  if ((int)shiftedInput3 < 0x1f) {\n    shiftCount = shiftedInput3 - 0x13;\n    if (shiftCount != 0 && shiftCount < 0 == SCARRY4(shiftedInput3 - 0x1f,0xc)) {\n      return CONCAT44(shiftedInput2,temp1 >> (0x20 - (0xcU - shiftCount) & 0xff) | shiftedInput4 << (0xcU - shiftCount & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    shiftedInput3 = shiftedInput3 + 1;\n    return CONCAT44(shiftedInput1 | shiftedInput4 >> (shiftedInput3 & 0xff),\n                    temp1 >> (shiftedInput3 & 0xff) | shiftedInput4 << (0x20 - shiftedInput3 & 0xff));\n  }\n  return CONCAT44(shiftedInput2,shiftedInput4 >> (shiftedInput3 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000450": "bitwise_shift_and_concatenate_08000450",
                "param_1": "input",
                "param_2": "constant1",
                "param_3": "constant2",
                "param_4": "mask",
                "uVar1": "shiftedInput1",
                "uVar2": "temp1",
                "uVar3": "shiftedInput2",
                "uVar4": "shiftedInput3",
                "uVar5": "shiftedInput4",
                "iVar6": "shiftCount",
                "uVar7": "temp2",
                "in_r12": "temp3",
                "bVar8": "condition1",
                "bVar9": "condition2",
                "bVar10": "condition3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800048c": {
            "entrypoint": "0x0800048c",
            "current_name": "reverse_function_0800048c",
            "code": "\nulonglong reverseFunction_0800048c(uint input1,uint input2)\n\n{\n  byte byteVal;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int count1;\n  uint count2;\n  int count3;\n  uint shiftVal;\n  bool bool1;\n  bool bool2;\n  bool bool3;\n  \n  if ((input1 | input2) == 0) {\n    return CONCAT44(input2,input1);\n  }\n  count3 = 0x432;\n  shiftVal = input2 >> 0x16;\n  if (shiftVal != 0) {\n    count3 = 3;\n    if (input2 >> 0x19 != 0) {\n      count3 = 6;\n    }\n    if (input2 >> 0x1c != 0) {\n      count3 = count3 + 3;\n    }\n    temp3 = count3 - ((int)input2 >> 0x1f);\n    shiftVal = input1 << (0x20 - temp3 & 0xff);\n    input1 = input1 >> (temp3 & 0xff) | input2 << (0x20 - temp3 & 0xff);\n    input2 = input2 >> (temp3 & 0xff);\n    count3 = temp3 + 0x432;\n  }\n  if (0xfffff < input2) {\n    if (0x1fffff < input2) {\n      temp3 = input2 & 1;\n      input2 = input2 >> 1;\n      byteVal = (byte)input1;\n      input1 = (uint)(temp3 != 0) << 0x1f | input1 >> 1;\n      shiftVal = (uint)(byteVal & 1) << 0x1f | shiftVal >> 1;\n      count3 = count3 + 1;\n      if (0xffbfffff < (uint)(count3 * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_080002a0:\n    bool2 = 0x7fffffff < shiftVal;\n    if (shiftVal == 0x80000000) {\n      bool2 = (input1 & 1) != 0;\n    }\n    return CONCAT44(input2 + count3 * 0x100000 + (uint)CARRY4(input1,(uint)bool2),input1 + bool2\n                   );\n  }\n  bool1 = (shiftVal & 0x80000000) != 0;\n  shiftVal = shiftVal << 1;\n  temp3 = input1 * 2;\n  bool2 = CARRY4(input1,input1);\n  input1 = input1 * 2 + (uint)bool1;\n  input2 = input2 * 2 + (uint)(bool2 || CARRY4(temp3,(uint)bool1));\n  count3 = count3 + -1;\n  if ((input2 & 0x100000) != 0) goto LAB_080002a0;\n  temp1 = input1;\n  temp3 = input2;\n  if (input2 == 0) {\n    temp1 = 0;\n    temp3 = input1;\n  }\n  count1 = LZCOUNT(temp3);\n  if (input2 == 0) {\n    count1 = count1 + 0x20;\n  }\n  count2 = count1 - 0xb;\n  bool3 = SBORROW4(count2,0x20);\n  temp2 = count1 - 0x2b;\n  bool2 = (int)temp2 < 0;\n  bool1 = temp2 == 0;\n  if ((int)count2 < 0x20) {\n    bool3 = SCARRY4(temp2,0xc);\n    count1 = count1 + -0x1f;\n    bool2 = count1 < 0;\n    bool1 = count1 == 0;\n    temp2 = count2;\n    if (!bool1 && bool2 == bool3) {\n      temp1 = temp3 << (count2 & 0xff);\n      temp3 = temp3 >> (0xcU - count1 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (bool1 || bool2 != bool3) {\n    shiftVal = 0x20 - temp2;\n  }\n  temp3 = temp3 << (temp2 & 0xff);\n  if (bool1 || bool2 != bool3) {\n    temp3 = temp3 | temp1 >> (shiftVal & 0xff);\n  }\n  if (bool1 || bool2 != bool3) {\n    temp1 = temp1 << (temp2 & 0xff);\n  }\nLAB_08000318:\n  if ((int)count2 <= count3) {\n    return CONCAT44(temp3 + (count3 - count2) * 0x100000,temp1);\n  }\n  shiftVal = ~(count3 - count2);\n  if (0x1e < (int)shiftVal) {\n    return (ulonglong)(temp3 >> (shiftVal - 0x1f & 0xff));\n  }\n  count3 = shiftVal - 0x13;\n  if (count3 == 0 || count3 < 0 != SCARRY4(shiftVal - 0x1f,0xc)) {\n    shiftVal = shiftVal + 1;\n    return CONCAT44(temp3 >> (shiftVal & 0xff),temp1 >> (shiftVal & 0xff) | temp3 << (0x20 - shiftVal & 0xff)\n                   );\n  }\n  return (ulonglong)(temp1 >> (0x20 - (0xcU - count3) & 0xff) | temp3 << (0xcU - count3 & 0xff));\n}\n\n",
            "renaming": {
                "FUN_0800048c": "reverse_function_0800048c",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "byteVal",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "iVar5": "count1",
                "uVar6": "count2",
                "iVar7": "count3",
                "uVar8": "shiftVal",
                "bVar9": "bool1",
                "bVar10": "bool2",
                "bVar11": "bool3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800049c": {
            "entrypoint": "0x0800049c",
            "current_name": "calculate_float_from_integers_0800049c",
            "code": "\nulonglong calculateFloatFromIntegers_0800049c(uint inputFloat,uint inputInteger)\n\n{\n  byte carryBit;\n  uint resultInteger;\n  uint tempInteger;\n  uint tempBit;\n  int shiftCount;\n  uint tempShiftedInteger;\n  int shiftOffset;\n  uint signBit;\n  uint resultInteger2;\n  bool tempCarryBit;\n  bool tempCondition;\n  bool tempCondition2;\n  \n  if ((inputFloat | inputInteger) == 0) {\n    return CONCAT44(inputInteger,inputFloat);\n  }\n  signBit = inputInteger & 0x80000000;\n  tempInteger = inputInteger;\n  if ((int)signBit < 0) {\n    tempCondition = inputFloat != 0;\n    inputFloat = -inputFloat;\n    tempInteger = -inputInteger - (uint)tempCondition;\n  }\n  shiftOffset = 0x432;\n  resultInteger2 = tempInteger >> 0x16;\n  if (resultInteger2 != 0) {\n    shiftOffset = 3;\n    if (tempInteger >> 0x19 != 0) {\n      shiftOffset = 6;\n    }\n    if (tempInteger >> 0x1c != 0) {\n      shiftOffset = shiftOffset + 3;\n    }\n    tempBit = shiftOffset - ((int)tempInteger >> 0x1f);\n    resultInteger2 = inputFloat << (0x20 - tempBit & 0xff);\n    inputFloat = inputFloat >> (tempBit & 0xff) | tempInteger << (0x20 - tempBit & 0xff);\n    tempInteger = tempInteger >> (tempBit & 0xff);\n    shiftOffset = tempBit + 0x432;\n  }\n  if (0xfffff < tempInteger) {\n    if (0x1fffff < tempInteger) {\n      tempBit = tempInteger & 1;\n      tempInteger = tempInteger >> 1;\n      carryBit = (byte)inputFloat;\n      inputFloat = (uint)(tempBit != 0) << 0x1f | inputFloat >> 1;\n      resultInteger2 = (uint)(carryBit & 1) << 0x1f | resultInteger2 >> 1;\n      shiftOffset = shiftOffset + 1;\n      if (0xffbfffff < (uint)(shiftOffset * 0x200000)) {\n        return (ulonglong)(signBit | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_080002a0:\n    tempCondition = 0x7fffffff < resultInteger2;\n    if (resultInteger2 == 0x80000000) {\n      tempCondition = (inputFloat & 1) != 0;\n    }\n    return CONCAT44(tempInteger + shiftOffset * 0x100000 + (uint)CARRY4(inputFloat,(uint)tempCondition) | signBit,\n                    inputFloat + tempCondition);\n  }\n  tempCarryBit = (resultInteger2 & 0x80000000) != 0;\n  resultInteger2 = resultInteger2 << 1;\n  tempBit = inputFloat * 2;\n  tempCondition = CARRY4(inputFloat,inputFloat);\n  inputFloat = inputFloat * 2 + (uint)tempCarryBit;\n  tempInteger = tempInteger * 2 + (uint)(tempCondition || CARRY4(tempBit,(uint)tempCarryBit));\n  shiftOffset = shiftOffset + -1;\n  if ((tempInteger & 0x100000) != 0) goto LAB_080002a0;\n  resultInteger = inputFloat;\n  tempBit = tempInteger;\n  if (tempInteger == 0) {\n    resultInteger = 0;\n    tempBit = inputFloat;\n  }\n  shiftCount = LZCOUNT(tempBit);\n  if (tempInteger == 0) {\n    shiftCount = shiftCount + 0x20;\n  }\n  tempShiftedInteger = shiftCount - 0xb;\n  tempCondition2 = SBORROW4(tempShiftedInteger,0x20);\n  tempInteger = shiftCount - 0x2b;\n  tempCondition = (int)tempInteger < 0;\n  tempCarryBit = tempInteger == 0;\n  if ((int)tempShiftedInteger < 0x20) {\n    tempCondition2 = SCARRY4(tempInteger,0xc);\n    shiftCount = shiftCount + -0x1f;\n    tempCondition = shiftCount < 0;\n    tempCarryBit = shiftCount == 0;\n    tempInteger = tempShiftedInteger;\n    if (!tempCarryBit && tempCondition == tempCondition2) {\n      resultInteger = tempBit << (tempShiftedInteger & 0xff);\n      tempBit = tempBit >> (0xcU - shiftCount & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (tempCarryBit || tempCondition != tempCondition2) {\n    resultInteger2 = 0x20 - tempInteger;\n  }\n  tempBit = tempBit << (tempInteger & 0xff);\n  if (tempCarryBit || tempCondition != tempCondition2) {\n    tempBit = tempBit | resultInteger >> (resultInteger2 & 0xff);\n  }\n  if (tempCarryBit || tempCondition != tempCondition2) {\n    resultInteger = resultInteger << (tempInteger & 0xff);\n  }\nLAB_08000318:\n  if ((int)tempShiftedInteger <= shiftOffset) {\n    return CONCAT44(tempBit + (shiftOffset - tempShiftedInteger) * 0x100000 | signBit,resultInteger);\n  }\n  tempInteger = ~(shiftOffset - tempShiftedInteger);\n  if (0x1e < (int)tempInteger) {\n    return CONCAT44(inputInteger,tempBit >> (tempInteger - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  shiftOffset = tempInteger - 0x13;\n  if (shiftOffset == 0 || shiftOffset < 0 != SCARRY4(tempInteger - 0x1f,0xc)) {\n    tempInteger = tempInteger + 1;\n    return CONCAT44(signBit | tempBit >> (tempInteger & 0xff),\n                    resultInteger >> (tempInteger & 0xff) | tempBit << (0x20 - tempInteger & 0xff));\n  }\n  return CONCAT44(inputInteger,resultInteger >> (0x20 - (0xcU - shiftOffset) & 0xff) | tempBit << (0xcU - shiftOffset & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800049c": "calculate_float_from_integers_0800049c",
                "param_1": "inputFloat",
                "param_2": "inputInteger",
                "bVar1": "carryBit",
                "uVar2": "resultInteger",
                "uVar3": "tempInteger",
                "uVar4": "tempBit",
                "iVar5": "shiftCount",
                "uVar6": "tempShiftedInteger",
                "iVar7": "shiftOffset",
                "uVar8": "signBit",
                "uVar9": "resultInteger2",
                "bVar10": "tempCarryBit",
                "bVar11": "tempCondition",
                "bVar12": "tempCondition2"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004f8": {
            "entrypoint": "0x080004f8",
            "current_name": "calculate_result_080004f8",
            "code": "\nulonglong calculate_result_080004f8(undefined4 value1,uint value2,uint value3,uint value4)\n\n{\n  ulonglong result1;\n  longlong result2;\n  uint temp1;\n  uint temp2;\n  int temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  ulonglong combined_values;\n  \n  combined_values = CONCAT44(value2,value1);\n  temp6 = 0x7ff;\n  temp2 = value2 >> 0x14 & 0x7ff;\n  flag1 = temp2 == 0;\n  if (!flag1) {\n    temp5 = value4 >> 0x14 & 0x7ff;\n    flag1 = temp5 == 0;\n  }\n  if (!flag1) {\n    flag1 = temp2 == 0x7ff;\n  }\n  if (!flag1) {\n    flag1 = temp5 == 0x7ff;\n  }\n  if (flag1) {\n    combined_values = calculate_bitwise_080006d4();\n  }\n  temp1 = (uint)(combined_values >> 0x20);\n  temp3 = temp2 + temp5;\n  temp2 = temp1 ^ value4;\n  temp1 = temp1 & ~(temp6 << 0x15);\n  value4 = value4 & ~(temp6 << 0x15);\n  flag1 = ((uint)combined_values | temp1 << 0xc) == 0;\n  if (!flag1) {\n    flag1 = (value3 | value4 << 0xc) == 0;\n  }\n  temp1 = temp1 | 0x100000;\n  value4 = value4 | 0x100000;\n  if (flag1) {\n    value3 = (uint)combined_values | value3;\n    value4 = (temp2 & 0x80000000 | temp1) ^ value4;\n    temp2 = temp6 >> 1;\n    flag3 = SBORROW4(temp3,temp2);\n    temp4 = temp3 - temp2;\n    flag1 = temp4 == 0;\n    temp1 = temp4;\n    if (!flag1 && (int)temp2 <= temp3) {\n      flag3 = SBORROW4(temp6,temp4);\n      temp1 = temp6 - temp4;\n      flag1 = temp6 == temp4;\n    }\n    if (!flag1 && (int)temp1 < 0 == flag3) {\n      value4 = value4 | temp4 * 0x100000;\n    }\n    if (!flag1 && (int)temp1 < 0 == flag3) {\n      return CONCAT44(value4,value3);\n    }\n    value4 = value4 | 0x100000;\n    temp6 = 0;\n    flag3 = SBORROW4(temp4,1);\n    temp4 = temp4 - 1;\n    flag1 = temp4 == 0;\n    temp2 = temp4;\n  }\n  else {\n    result1 = (combined_values & 0xffffffff) * (ulonglong)value3;\n    combined_values = (combined_values & 0xffffffff) * (ulonglong)value4 +\n             (ulonglong)temp1 * (ulonglong)value3 + (result1 >> 0x20);\n    temp7 = (uint)combined_values;\n    result2 = (ulonglong)temp1 * (ulonglong)value4 + (combined_values >> 0x20);\n    temp6 = (uint)result2;\n    temp1 = (uint)((ulonglong)result2 >> 0x20);\n    if ((int)result1 != 0) {\n      temp7 = temp7 | 1;\n    }\n    temp4 = (temp3 + -0x3ff) - (uint)(temp1 < 0x200);\n    if (temp1 < 0x200) {\n      flag1 = (temp7 & 0x80000000) != 0;\n      temp7 = temp7 << 1;\n      result2 = CONCAT44(temp1 * 2 + (uint)(CARRY4(temp6,temp6) || CARRY4(temp6 * 2,(uint)flag1)),\n                       temp6 * 2 + (uint)flag1);\n    }\n    value4 = temp2 & 0x80000000 | (int)((ulonglong)result2 >> 0x20) << 0xb | (uint)result2 >> 0x15;\n    value3 = (uint)result2 << 0xb | temp7 >> 0x15;\n    temp6 = temp7 * 0x800;\n    flag2 = 0xfc < temp4;\n    flag3 = SBORROW4(temp4,0xfd);\n    temp1 = temp4 - 0xfd;\n    flag1 = temp1 == 0;\n    temp2 = temp1;\n    if (flag2 && !flag1) {\n      flag2 = 0x6ff < temp1;\n      flag3 = SBORROW4(temp1,0x700);\n      temp2 = temp4 - 0x7fd;\n      flag1 = temp1 == 0x700;\n    }\n    if (!flag2 || flag1) {\n      flag1 = 0x7fffffff < temp6;\n      if (temp6 == 0x80000000) {\n        flag1 = (temp7 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(value4 + temp4 * 0x100000 + (uint)CARRY4(value3,(uint)flag1),value3 + flag1\n                     );\n    }\n  }\n  if (!flag1 && (int)temp2 < 0 == flag3) {\n    return (ulonglong)(value4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag2 = SCARRY4(temp4,0x36);\n  flag1 = (int)(temp4 + 0x36) < 0;\n  flag3 = temp4 == 0xffffffca;\n  if (flag3 || flag1 != flag2) {\n    value3 = 0;\n  }\n  if (flag3 || flag1 != flag2) {\n    value4 = value4 & 0x80000000;\n  }\n  if (flag3 || flag1 != flag2) {\n    return CONCAT44(value4,value3);\n  }\n  temp2 = -temp4;\n  temp1 = temp2 - 0x20;\n  if (0x1f < (int)temp2) {\n    temp4 = value3 >> (temp1 & 0xff) | value4 << (0x20 - temp1 & 0xff);\n    temp2 = (value4 >> (temp1 & 0xff) & ~((value4 & 0x80000000) >> (temp1 & 0xff))) -\n            ((int)temp4 >> 0x1f);\n    if ((temp6 | value3 << (0x20 - temp1 & 0xff) | temp4 << 1) == 0) {\n      temp2 = temp2 & ~(temp4 >> 0x1f);\n    }\n    return CONCAT44(value4,temp2) & 0x80000000ffffffff;\n  }\n  temp3 = temp2 - 0x14;\n  if (temp3 == 0 || temp3 < 0 != SCARRY4(temp1,0xc)) {\n    temp7 = value3 << (temp4 + 0x20 & 0xff);\n    temp1 = value3 >> (temp2 & 0xff) | value4 << (temp4 + 0x20 & 0xff);\n    temp4 = temp1 + -((int)temp7 >> 0x1f);\n    if ((temp6 | temp7 << 1) == 0) {\n      temp4 = temp4 & ~(temp7 >> 0x1f);\n    }\n    return CONCAT44((value4 & 0x80000000) +\n                    ((value4 & 0x7fffffff) >> (temp2 & 0xff)) +\n                    (uint)CARRY4(temp1,-((int)temp7 >> 0x1f)),temp4);\n  }\n  temp2 = 0xc - temp3;\n  temp4 = value3 << (temp2 & 0xff);\n  temp2 = value3 >> (0x20 - temp2 & 0xff) | value4 << (temp2 & 0xff);\n  temp1 = temp2 + -((int)temp4 >> 0x1f);\n  if ((temp6 | temp4 << 1) == 0) {\n    temp1 = temp1 & ~(temp4 >> 0x1f);\n  }\n  return CONCAT44((value4 & 0x80000000) + (uint)CARRY4(temp2,-((int)temp4 >> 0x1f)),temp1);\n}\n\n",
            "renaming": {
                "FUN_080004f8": "calculate_result_080004f8",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result1",
                "lVar2": "result2",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "iVar5": "temp3",
                "uVar6": "temp4",
                "unaff_r5": "temp5",
                "uVar7": "temp6",
                "uVar8": "temp7",
                "bVar9": "flag1",
                "bVar10": "flag2",
                "bVar11": "flag3",
                "uVar12": "combined_values"
            },
            "calling": [
                "SetTunings",
                "Compute",
                "readThermocouple",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [
                "FUN_080006d4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006d4": {
            "entrypoint": "0x080006d4",
            "current_name": "calculate_bitwise_080006d4",
            "code": "\nulonglong calculate_bitwise_080006d4(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint bit1;\n  uint bit2;\n  uint result;\n  uint temp;\n  uint mask;\n  bool is_zero;\n  \n  result = mask & input_4 >> 0x14;\n  if (bit2 != mask && result != mask) {\n    is_zero = (input_1 | input_2 << 1) == 0;\n    if (!is_zero) {\n      is_zero = (input_3 | input_4 << 1) == 0;\n    }\n    if (is_zero) {\n      return (ulonglong)((input_2 ^ input_4) & 0x80000000) << 0x20;\n    }\n    if (bit2 == 0) {\n      temp = input_2 & 0x80000000;\n      do {\n        bit1 = input_1 & 0x80000000;\n        input_1 = input_1 << 1;\n        input_2 = input_2 * 2 + (uint)(bit1 != 0);\n      } while ((input_2 & 0x100000) == 0);\n      input_2 = input_2 | temp;\n      if (result != 0) {\n        return CONCAT44(input_2,input_1);\n      }\n    }\n    do {\n      result = input_3 & 0x80000000;\n      input_3 = input_3 << 1;\n      input_4 = input_4 * 2 + (uint)(result != 0);\n    } while ((input_4 & 0x100000) == 0);\n    return CONCAT44(input_2,input_1);\n  }\n  is_zero = (input_1 | input_2 << 1) == 0;\n  if (is_zero) {\n    input_2 = input_4;\n    input_1 = input_3;\n  }\n  if (!is_zero) {\n    is_zero = (input_3 | input_4 << 1) == 0;\n  }\n  temp = input_2;\n  if (((!is_zero) && ((bit2 != mask || ((input_1 | input_2 << 0xc) == 0)))) &&\n     ((result != mask || (input_1 = input_3, temp = input_4, (input_3 | input_4 << 0xc) == 0)))) {\n    return (ulonglong)((input_2 ^ input_4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(temp,input_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006d4": "calculate_bitwise_080006d4",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "bit1",
                "unaff_r4": "bit2",
                "uVar2": "result",
                "uVar3": "temp",
                "in_r12": "mask",
                "bVar4": "is_zero"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800074c": {
            "entrypoint": "0x0800074c",
            "current_name": "calculate_floating_point_value_0800074c",
            "code": "\nulonglong calculateFloatingPointValue_0800074c(undefined4 flags,uint parts1,uint parts2,uint parts3)\n\n{\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  int difference;\n  uint exponent;\n  uint parts4;\n  uint temp10;\n  uint temp11;\n  uint temp12;\n  uint constant1;\n  bool isZero;\n  bool isEqual;\n  bool isOverflow;\n  undefined8 result;\n  \n  result = CONCAT44(parts1,flags);\n  constant1 = 0x7ff;\n  temp7 = parts1 >> 0x14 & 0x7ff;\n  isZero = temp7 == 0;\n  if (!isZero) {\n    parts4 = parts3 >> 0x14 & 0x7ff;\n    isZero = parts4 == 0;\n  }\n  if (!isZero) {\n    isZero = temp7 == 0x7ff;\n  }\n  if (!isZero) {\n    isZero = parts4 == 0x7ff;\n  }\n  if (isZero) {\n    result = unpack_double_080008ba();\n  }\n  exponent = (uint)((ulonglong)result >> 0x20);\n  temp11 = (uint)result;\n  difference = temp7 - parts4;\n  if ((parts2 | parts3 << 0xc) == 0) {\n    temp7 = (exponent ^ parts3) & 0x80000000 | exponent & 0xfffff;\n    isOverflow = SCARRY4(difference,constant1 >> 1);\n    exponent = difference + (constant1 >> 1);\n    isZero = (int)exponent < 0;\n    isEqual = exponent == 0;\n    if (!isEqual && isZero == isOverflow) {\n      isOverflow = SBORROW4(constant1,exponent);\n      isZero = (int)(constant1 - exponent) < 0;\n      isEqual = constant1 == exponent;\n    }\n    if (!isEqual && isZero == isOverflow) {\n      temp7 = temp7 | exponent * 0x100000;\n    }\n    if (!isEqual && isZero == isOverflow) {\n      return CONCAT44(temp7,temp11);\n    }\n    temp7 = temp7 | 0x100000;\n    constant1 = 0;\n    isEqual = SBORROW4(exponent,1);\n    exponent = exponent - 1;\n    isZero = exponent == 0;\n    temp3 = exponent;\n  }\n  else {\n    temp3 = (parts3 << 0xc) >> 4 | 0x10000000 | parts2 >> 0x18;\n    constant1 = parts2 << 8;\n    temp10 = (exponent << 0xc) >> 4 | 0x10000000 | temp11 >> 0x18;\n    temp11 = temp11 * 0x100;\n    temp7 = (exponent ^ parts3) & 0x80000000;\n    isZero = temp3 <= temp10;\n    if (temp10 == temp3) {\n      isZero = constant1 <= temp11;\n    }\n    difference = difference + (uint)isZero;\n    exponent = difference + 0x3fd;\n    if (isZero == false) {\n      temp3 = temp3 >> 1;\n      constant1 = (uint)((parts2 >> 0x18 & 1) != 0) << 0x1f | constant1 >> 1;\n    }\n    temp12 = temp11 - constant1;\n    temp10 = (temp10 - temp3) - (uint)(temp11 < constant1);\n    temp4 = temp3 >> 1;\n    temp1 = (uint)((temp3 & 1) != 0) << 0x1f | constant1 >> 1;\n    temp11 = 0x100000;\n    temp3 = 0x80000;\n    while( true ) {\n      isZero = temp1 <= temp12;\n      if (temp4 < temp10 || temp10 - temp4 < (uint)isZero) {\n        temp12 = temp12 - temp1;\n        temp11 = temp11 | temp3;\n        temp10 = (temp10 - temp4) - (uint)!isZero;\n      }\n      temp5 = temp4 >> 1;\n      temp1 = (uint)((temp4 & 1) != 0) << 0x1f | temp1 >> 1;\n      isEqual = temp1 <= temp12;\n      isZero = temp10 - temp5 < (uint)isEqual;\n      constant1 = temp10;\n      if (temp5 < temp10 || isZero) {\n        temp12 = temp12 - temp1;\n        constant1 = (temp10 - temp5) - (uint)!isEqual;\n      }\n      if (temp5 < temp10 || isZero) {\n        temp11 = temp11 | temp3 >> 1;\n      }\n      temp10 = temp4 >> 2;\n      temp2 = (uint)((temp5 & 1) != 0) << 0x1f | temp1 >> 1;\n      isEqual = temp2 <= temp12;\n      isZero = constant1 - temp10 < (uint)isEqual;\n      temp5 = constant1;\n      if (temp10 < constant1 || isZero) {\n        temp12 = temp12 - temp2;\n        temp5 = (constant1 - temp10) - (uint)!isEqual;\n      }\n      if (temp10 < constant1 || isZero) {\n        temp11 = temp11 | temp3 >> 2;\n      }\n      temp6 = temp4 >> 3;\n      temp1 = (uint)((temp10 & 1) != 0) << 0x1f | temp2 >> 1;\n      isEqual = temp1 <= temp12;\n      isZero = temp5 - temp6 < (uint)isEqual;\n      temp10 = temp5;\n      if (temp6 < temp5 || isZero) {\n        temp12 = temp12 - temp1;\n        temp10 = (temp5 - temp6) - (uint)!isEqual;\n      }\n      if (temp6 < temp5 || isZero) {\n        temp11 = temp11 | temp3 >> 3;\n      }\n      constant1 = temp10 | temp12;\n      if (constant1 == 0) break;\n      temp10 = temp10 << 4 | temp12 >> 0x1c;\n      temp12 = temp12 << 4;\n      temp4 = temp4 & 0xfffffff8 | temp1 >> 0x1d;\n      temp1 = (temp2 >> 1) << 3;\n      temp3 = temp3 >> 4;\n      if (temp3 == 0) {\n        temp6 = temp4;\n        if ((temp7 & 0x100000) != 0) goto LAB_0800086a;\n        temp7 = temp7 | temp11;\n        temp11 = 0;\n        temp3 = 0x80000000;\n      }\n    }\n    if ((temp7 & 0x100000) == 0) {\n      temp7 = temp7 | temp11;\n      temp11 = 0;\n    }\nLAB_0800086a:\n    isOverflow = 0xfc < exponent;\n    isEqual = SBORROW4(exponent,0xfd);\n    temp4 = difference + 0x300;\n    isZero = temp4 == 0;\n    temp3 = temp4;\n    if (isOverflow && !isZero) {\n      isOverflow = 0x6ff < temp4;\n      isEqual = SBORROW4(temp4,0x700);\n      temp3 = difference - 0x400;\n      isZero = temp4 == 0x700;\n    }\n    if (!isOverflow || isZero) {\n      isZero = temp6 <= temp10;\n      if (temp10 == temp6) {\n        isZero = temp1 <= temp12;\n      }\n      if (temp10 == temp6 && temp12 == temp1) {\n        isZero = (temp11 & 1) != 0;\n      }\n      return CONCAT44(temp7 + exponent * 0x100000 + (uint)CARRY4(temp11,(uint)isZero),temp11 + isZero);\n    }\n  }\n  if (!isZero && (int)temp3 < 0 == isEqual) {\n    return (ulonglong)(temp7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  isOverflow = SCARRY4(exponent,0x36);\n  isZero = (int)(exponent + 0x36) < 0;\n  isEqual = exponent == 0xffffffca;\n  if (isEqual || isZero != isOverflow) {\n    temp11 = 0;\n  }\n  if (isEqual || isZero != isOverflow) {\n    temp7 = temp7 & 0x80000000;\n  }\n  if (isEqual || isZero != isOverflow) {\n    return CONCAT44(temp7,temp11);\n  }\n  temp3 = -exponent;\n  temp10 = temp3 - 0x20;\n  if (0x1f < (int)temp3) {\n    temp3 = temp11 >> (temp10 & 0xff) | temp7 << (0x20 - temp10 & 0xff);\n    exponent = (temp7 >> (temp10 & 0xff) & ~((temp7 & 0x80000000) >> (temp10 & 0xff))) -\n            ((int)temp3 >> 0x1f);\n    if ((constant1 | temp11 << (0x20 - temp10 & 0xff) | temp3 << 1) == 0) {\n      exponent = exponent & ~(temp3 >> 0x1f);\n    }\n    return CONCAT44(temp7,exponent) & 0x80000000ffffffff;\n  }\n  difference = temp3 - 0x14;\n  if (difference != 0 && difference < 0 == SCARRY4(temp10,0xc)) {\n    exponent = 0xc - difference;\n    temp3 = temp11 << (exponent & 0xff);\n    temp11 = temp11 >> (0x20 - exponent & 0xff) | temp7 << (exponent & 0xff);\n    exponent = temp11 + -((int)temp3 >> 0x1f);\n    if ((constant1 | temp3 << 1) == 0) {\n      exponent = exponent & ~(temp3 >> 0x1f);\n    }\n    return CONCAT44((temp7 & 0x80000000) + (uint)CARRY4(temp11,-((int)temp3 >> 0x1f)),exponent);\n  }\n  temp10 = temp11 << (exponent + 0x20 & 0xff);\n  temp11 = temp11 >> (temp3 & 0xff) | temp7 << (exponent + 0x20 & 0xff);\n  exponent = temp11 + -((int)temp10 >> 0x1f);\n  if ((constant1 | temp10 << 1) == 0) {\n    exponent = exponent & ~(temp10 >> 0x1f);\n  }\n  return CONCAT44((temp7 & 0x80000000) +\n                  ((temp7 & 0x7fffffff) >> (temp3 & 0xff)) +\n                  (uint)CARRY4(temp11,-((int)temp10 >> 0x1f)),exponent);\n}\n\n",
            "renaming": {
                "FUN_0800074c": "calculate_floating_point_value_0800074c",
                "param_1": "flags",
                "param_2": "parts1",
                "param_3": "parts2",
                "param_4": "parts3",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "uVar6": "temp6",
                "uVar7": "temp7",
                "iVar8": "difference",
                "uVar9": "exponent",
                "uVar10": "temp10",
                "uVar11": "temp11",
                "uVar12": "temp12",
                "uVar13": "constant1",
                "bVar14": "isZero",
                "bVar15": "isEqual",
                "bVar16": "isOverflow",
                "uVar17": "result",
                "unaff_r5": "parts4"
            },
            "calling": [
                "SetTunings",
                "readThermocouple",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [
                "FUN_080008ba"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008ba": {
            "entrypoint": "0x080008ba",
            "current_name": "unpack_double_080008ba",
            "code": "\nulonglong unpack_double_080008ba(uint packed_low,uint packed_high,uint significand_low,uint significand_high)\n\n{\n  uint bit_low;\n  uint mask;\n  uint shifted_mask;\n  uint temp_low;\n  uint temp_high;\n  bool has_zeros;\n  \n  shifted_mask = temp_high & significand_high >> 0x14;\n  temp_low = packed_high;\n  if (mask != temp_high || shifted_mask != temp_high) {\n    if (mask == temp_high) {\n      if (((packed_low | packed_high << 0xc) == 0) && (packed_low = significand_low, temp_low = significand_high, shifted_mask != temp_high)\n         ) {\nLAB_0800072c:\n        return (ulonglong)((packed_high ^ significand_high) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (shifted_mask == temp_high) {\n      packed_low = significand_low;\n      temp_low = significand_high;\n      if ((significand_low | significand_high << 0xc) == 0) {\nLAB_080006f0:\n        return (ulonglong)((packed_high ^ significand_high) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      has_zeros = (packed_low | packed_high << 1) == 0;\n      if (!has_zeros) {\n        has_zeros = (significand_low | significand_high << 1) == 0;\n      }\n      if (!has_zeros) {\n        if (mask == 0) {\n          temp_low = packed_high & 0x80000000;\n          do {\n            bit_low = packed_low & 0x80000000;\n            packed_low = packed_low << 1;\n            packed_high = packed_high * 2 + (uint)(bit_low != 0);\n          } while ((packed_high & 0x100000) == 0);\n          packed_high = packed_high | temp_low;\n          if (shifted_mask != 0) {\n            return CONCAT44(packed_high,packed_low);\n          }\n        }\n        do {\n          temp_low = significand_low & 0x80000000;\n          significand_low = significand_low << 1;\n          significand_high = significand_high * 2 + (uint)(temp_low != 0);\n        } while ((significand_high & 0x100000) == 0);\n        return CONCAT44(packed_high,packed_low);\n      }\n      if ((packed_low | packed_high << 1) != 0) goto LAB_0800072c;\n      if ((significand_low | significand_high << 1) != 0) goto LAB_080006f0;\n    }\n  }\n  return CONCAT44(temp_low,packed_low) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080008ba": "unpack_double_080008ba",
                "param_1": "packed_low",
                "param_2": "packed_high",
                "param_3": "significand_low",
                "param_4": "significand_high",
                "uVar1": "bit_low",
                "unaff_r4": "mask",
                "uVar2": "shifted_mask",
                "uVar3": "temp_low",
                "in_r12": "temp_high",
                "bVar4": "has_zeros"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800091c": {
            "entrypoint": "0x0800091c",
            "current_name": "check_equality_0800091c",
            "code": "\nuint check_equality_0800091c(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint xor_result;\n  bool is_zero;\n  bool is_less_than_or_equal;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  is_zero = (value1 | value2 << 1) == 0;\n  if (is_zero) {\n    is_zero = (value3 | value4 << 1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = value2 == value4;\n  }\n  if (is_zero) {\n    is_zero = value1 == value3;\n  }\n  if (!is_zero) {\n    xor_result = value2 ^ value4;\n    is_zero = xor_result == 0;\n    if (-1 < (int)xor_result) {\n      is_zero = value2 == value4;\n    }\n    is_less_than_or_equal = -1 < (int)xor_result && value4 <= value2;\n    if (is_zero) {\n      is_less_than_or_equal = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!is_less_than_or_equal) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800091c": "check_equality_0800091c",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "xor_result",
                "bVar2": "is_zero",
                "bVar3": "is_less_than_or_equal"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000924": {
            "entrypoint": "0x08000924",
            "current_name": "check_logic_equality_08000924",
            "code": "\nuint checkLogicEquality_08000924(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint result;\n  bool isZero;\n  bool isNegative;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (value1 | value2 << 1) == 0;\n  if (isZero) {\n    isZero = (value3 | value4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = value2 == value4;\n  }\n  if (isZero) {\n    isZero = value1 == value3;\n  }\n  if (!isZero) {\n    result = value2 ^ value4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = value2 == value4;\n    }\n    isNegative = -1 < (int)result && value4 <= value2;\n    if (isZero) {\n      isNegative = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!isNegative) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08000924": "check_logic_equality_08000924",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isNegative"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800092c": {
            "entrypoint": "0x0800092c",
            "current_name": "check_equality_and_comparison_0800092c",
            "code": "\nuint checkEqualityAndComparison_0800092c(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint result;\n  bool isZero;\n  bool isNegative;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (value1 | value2 << 1) == 0;\n  if (isZero) {\n    isZero = (value3 | value4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = value2 == value4;\n  }\n  if (isZero) {\n    isZero = value1 == value3;\n  }\n  if (!isZero) {\n    result = value2 ^ value4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = value2 == value4;\n    }\n    isNegative = -1 < (int)result && value4 <= value2;\n    if (isZero) {\n      isNegative = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!isNegative) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800092c": "check_equality_and_comparison_0800092c",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isNegative"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009a8": {
            "entrypoint": "0x080009a8",
            "current_name": "compare_floating_point_numbers_080009a8",
            "code": "\nvoid compareFloatingPointNumbers_080009a8(undefined4 result,undefined4 mask,undefined4 value1,undefined4 value2)\n\n{\n  __aeabi_cdcmpeq(value1,value2,result,mask);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080009a8": "compare_floating_point_numbers_080009a8",
                "param_1": "result",
                "param_2": "mask",
                "param_3": "value1",
                "param_4": "value2"
            },
            "calling": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009b8": {
            "entrypoint": "0x080009b8",
            "current_name": "convert_float_to_unsigned_int_080009b8",
            "code": "\nundefined4 convertFloatToUnsignedInt_080009b8(undefined4 inputFloat)\n\n{\n  __eqdf2();\n  return inputFloat;\n}\n\n",
            "renaming": {
                "FUN_080009b8": "convert_float_to_unsigned_int_080009b8",
                "param_1": "inputFloat"
            },
            "calling": [
                "__aeabi_dcmpeq",
                "__aeabi_cdrcmple",
                "__aeabi_dcmplt",
                "__aeabi_dcmple"
            ],
            "called": [
                "__eqdf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c8": {
            "entrypoint": "0x080009c8",
            "current_name": "check_zero_difference_080009c8",
            "code": "\nbool check_zero_difference_080009c8(void)\n\n{\n  char result;\n  \n  __aeabi_cdcmpeq();\n  return result != '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009c8": "check_zero_difference_080009c8",
                "in_ZR": "result"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009dc": {
            "entrypoint": "0x080009dc",
            "current_name": "is_null_character_080009dc",
            "code": "\nbool is_null_character_080009dc(void)\n\n{\n  char input_char;\n  \n  __aeabi_cdcmpeq();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009dc": "is_null_character_080009dc",
                "in_CY": "input_char"
            },
            "calling": [
                "SetOutputLimits",
                "Initialize",
                "loop",
                "SetTunings",
                "Compute",
                "printFloat"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009f0": {
            "entrypoint": "0x080009f0",
            "current_name": "is_zero_or_equal_080009f0",
            "code": "\nbool isZeroOrEqual_080009f0(void)\n\n{\n  undefined isZero;\n  undefined isEqual;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)isEqual || (bool)isZero;\n}\n\n",
            "renaming": {
                "FUN_080009f0": "is_zero_or_equal_080009f0",
                "in_ZR": "isZero",
                "in_CY": "isEqual"
            },
            "calling": [
                "loop",
                "printFloat"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a04": {
            "entrypoint": "0x08000a04",
            "current_name": "is_leq_or_eq_zero_08000a04",
            "code": "\nbool is_leq_or_eq_zero_08000a04(void)\n\n{\n  undefined is_zero;\n  undefined is_leq;\n  \n  __aeabi_cdrcmple();\n  return !(bool)is_leq || (bool)is_zero;\n}\n\n",
            "renaming": {
                "FUN_08000a04": "is_leq_or_eq_zero_08000a04",
                "in_ZR": "is_zero",
                "in_CY": "is_leq"
            },
            "calling": [
                "SetOutputLimits",
                "loop"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a18": {
            "entrypoint": "0x08000a18",
            "current_name": "is_string_empty_08000a18",
            "code": "\nbool isStringEmpty_08000a18(void)\n\n{\n  char inputCharacter;\n  \n  __aeabi_cdrcmple();\n  return inputCharacter == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000a18": "is_string_empty_08000a18",
                "in_CY": "inputCharacter"
            },
            "calling": [
                "SetOutputLimits",
                "Initialize",
                "loop",
                "Compute",
                "printFloat"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a2c": {
            "entrypoint": "0x08000a2c",
            "current_name": "check_parameters_08000a2c",
            "code": "\nundefined4 check_parameters_08000a2c(uint input1,int input2,uint input3,int input4)\n\n{\n  if ((((input2 << 1) >> 0x15 != -1) || ((input1 | input2 << 0xc) == 0)) &&\n     (((input4 << 1) >> 0x15 != -1 || ((input3 | input4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08000a2c": "check_parameters_08000a2c",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4"
            },
            "calling": [
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a58": {
            "entrypoint": "0x08000a58",
            "current_name": "convert_to_twos_complement_08000a58",
            "code": "\nuint convertToTwosComplement_08000a58(uint input1,uint maskedValue)\n\n{\n  uint result;\n  int scaledValue;\n  uint bitShift;\n  \n  scaledValue = maskedValue * 2 + 0x200000;\n  if (maskedValue * 2 < 0xffe00000) {\n    if (-1 < scaledValue) {\n      return 0;\n    }\n    result = scaledValue >> 0x15;\n    bitShift = -result - 0x3e1;\n    if (result < 0xfffffc20 && bitShift != 0) {\n      result = (maskedValue << 0xb | 0x80000000 | input1 >> 0x15) >> (bitShift & 0xff);\n      if ((maskedValue & 0x80000000) != 0) {\n        result = -result;\n      }\n      return result;\n    }\n  }\n  else if ((input1 | maskedValue << 0xc) != 0) {\n    return 0;\n  }\n  maskedValue = maskedValue & 0x80000000;\n  if (maskedValue == 0) {\n    maskedValue = 0x7fffffff;\n  }\n  return maskedValue;\n}\n\n",
            "renaming": {
                "FUN_08000a58": "convert_to_twos_complement_08000a58",
                "param_1": "input1",
                "param_2": "maskedValue",
                "uVar1": "result",
                "iVar2": "scaledValue",
                "uVar3": "bitShift"
            },
            "calling": [
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa8": {
            "entrypoint": "0x08000aa8",
            "current_name": "calculate_shifted_value_08000aa8",
            "code": "\nuint calculate_shifted_value_08000aa8(uint value1,uint value2)\n\n{\n  int temp1;\n  uint temp2;\n  \n  if ((value2 & 0x80000000) != 0) {\n    return 0;\n  }\n  temp1 = value2 * 2 + 0x200000;\n  if (value2 * 2 < 0xffe00000) {\n    if (-1 < temp1) {\n      return 0;\n    }\n    temp2 = -(temp1 >> 0x15) - 0x3e1;\n    if (-1 < (int)temp2) {\n      return (value2 << 0xb | 0x80000000 | value1 >> 0x15) >> (temp2 & 0xff);\n    }\n  }\n  else if ((value1 | value2 << 0xc) != 0) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000aa8": "calculate_shifted_value_08000aa8",
                "param_1": "value1",
                "param_2": "value2",
                "iVar1": "temp1",
                "uVar2": "temp2"
            },
            "calling": [
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ae8": {
            "entrypoint": "0x08000ae8",
            "current_name": "execute_system_call_08000ae8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_system_call_08000ae8(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_08000ae8": "execute_system_call_08000ae8"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aec": {
            "entrypoint": "0x08000aec",
            "current_name": "execute_afl_call_08000aec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint executeAflCall_08000aec(int inputTicks)\n\n{\n  uint32_t aflCallResult;\n  \n  if (isHyperCallDisabled != 0) {\n    return 0;\n  }\n  aflCallResult = aflCall(1,inputTicks,0);\n  return aflCallResult;\n}\n\n",
            "renaming": {
                "FUN_08000aec": "execute_afl_call_08000aec",
                "ticks": "inputTicks",
                "noHyperCall": "isHyperCallDisabled",
                "uVar1": "aflCallResult"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b08": {
            "entrypoint": "0x08000b08",
            "current_name": "initialize_pid_system_08000b08",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePIDSystem_08000b08(int shouldInitialize,int priorityLevel)\n\n{\n  if ((shouldInitialize == 1) && (priorityLevel == 0xffff)) {\n    PID::PID(&ovenPID,&inputValue,&outputValue,&targetTemperature,(double)combineFloats(kpHigh,kpLow),\n             (double)combineFloats(kiHigh,kiLow),(double)combineFloats(kdHigh,kdLow),0);\n    lcdController::lcdController\n              (&lcdObject,(uint8_t)rsPin,(uint8_t)ePin,(uint8_t)d4Pin,(uint8_t)d5Pin,\n               (uint8_t)d6Pin,(uint8_t)d7Pin);\n    thermocoupleSensor::thermocoupleSensor(&thermoCoupleObject,(uchar)soPin,(uchar)csPin,\n                       (uchar)clkPin);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000b08": "initialize_pid_system_08000b08",
                "__initialize_p": "shouldInitialize",
                "__priority": "priorityLevel",
                "reflowOvenPID": "ovenPID",
                "input": "inputValue",
                "output": "outputValue",
                "setpoint": "targetTemperature",
                "CONCAT44": "combineFloats",
                "kp._4_4_": "kpHigh",
                "kp._0_4_": "kpLow",
                "ki._4_4_": "kiHigh",
                "ki._0_4_": "kiLow",
                "kd._4_4_": "kdHigh",
                "kd._0_4_": "kdLow",
                "LiquidCrystal": "lcdController",
                "lcd": "lcdObject",
                "lcdRsPin": "rsPin",
                "lcdEPin": "ePin",
                "lcdD4Pin": "d4Pin",
                "lcdD5Pin": "d5Pin",
                "lcdD6Pin": "d6Pin",
                "lcdD7Pin": "d7Pin",
                "MAX31855": "thermocoupleSensor",
                "thermocouple": "thermoCoupleObject",
                "thermocoupleSOPin": "soPin",
                "thermocoupleCSPin": "csPin",
                "thermocoupleCLKPin": "clkPin"
            },
            "calling": [
                "_GLOBAL__sub_I_lcdMessagesReflowStatus"
            ],
            "called": [
                "MAX31855",
                "LiquidCrystal",
                "PID"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000bcc": {
            "entrypoint": "0x08000bcc",
            "current_name": "initialize_reflow_oven_08000bcc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeReflowOven_08000bcc(void)\n\n{\n  digitalWrite(ssrPin,0);\n  pinMode(ssrPin,1);\n  digitalWrite(buzzerPin,0);\n  pinMode(buzzerPin,1);\n  digitalWrite(ledRedPin,0);\n  pinMode(ledRedPin,1);\n  digitalWrite(buzzerPin,1);\n  LiquidCrystal::begin(&lcd,'\\b','\\x02','\\0');\n  LiquidCrystal::createChar(&lcd,'\\0',degree);\n  LiquidCrystal::clear(&lcd);\n  Print::print(&lcd.super_Print,\"Reflow\");\n  LiquidCrystal::setCursor(&lcd,'\\0','\\x01');\n  Print::print(&lcd.super_Print,\"Oven 1.2\");\n  digitalWrite(buzzerPin,0);\n  delay(0x9c4);\n  LiquidCrystal::clear(&lcd);\n  HardwareSerial::begin(&Serial2,0xe100,'\\x06');\n  digitalWrite(ledRedPin,1);\n  windowSize = 2000;\n  nextCheck = millis();\n  nextRead = millis();\n  startForkserver(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000bcc": "initialize_reflow_oven_08000bcc"
            },
            "calling": [
                "main"
            ],
            "called": [
                "begin",
                "digitalWrite",
                "startForkserver",
                "delay",
                "setCursor",
                "print",
                "begin",
                "millis",
                "createChar",
                "pinMode",
                "clear"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cbc": {
            "entrypoint": "0x08000cbc",
            "current_name": "initialize_and_destroy_08000cbc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_and_destroy_08000cbc(void)\n\n{\n  initialize(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000cbc": "initialize_and_destroy_08000cbc",
                "__static_initialization_and_destruction_0": "initialize"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cd0": {
            "entrypoint": "0x08000cd0",
            "current_name": "run_reflow_oven_08000cd0",
            "code": "\n/* WARNING: UnkcurrentTimen calling convention */\n\nvoid runReflowOven_08000cd0(void)\n\n{\n  double dVar1;\n  uint32_t uVar2;\n  MAX31855 *thermocouplePtr;\n  int ledRedPinState;\n  ulong currentTime;\n  int readResult;\n  size_t readError;\n  int digits1;\n  int digits2;\n  int digits3;\n  size_t messageLength;\n  undefined4 firstParameter;\n  undefined4 secondParameter;\n  undefined8 elapsedTime;\n  undefined4 stackParameter1;\n  undefined4 stackParameter2;\n  undefined4 stackParameter3;\n  \n  uVar2 = millis();\n  if (nextRead < uVar2) {\n    nextRead = nextRead + 1000;\n    thermocouplePtr = &thermocouple;\n    MAX31855::readThermocouple(&thermocouple,CELSIUS);\n    input._0_4_ = thermocouplePtr;\n    input._4_4_ = readError;\n    readResult = __aeabi_dcmpeq();\n    if (((readResult != 0) || (readResult = __aeabi_dcmpeq(thermocouplePtr,readError,0,0x40c38880), readResult != 0)) ||\n       (readResult = __aeabi_dcmpeq(thermocouplePtr,readError,0,0x40c38900), readResult != 0)) {\n      reflowState = REFLOW_STATE_ERROR;\n      reflowStatus = REFLOW_STATUS_OFF;\n    }\n  }\n  uVar2 = millis();\n  readResult = ledRedPin;\n  if (nextCheck < uVar2) {\n    nextCheck = nextCheck + 1000;\n    if (reflowStatus == REFLOW_STATUS_ON) {\n      ledRedPinState = digitalRead(ledRedPin);\n      digitalWrite(readResult,(uint)(ledRedPinState == 0));\n      timerSeconds = timerSeconds + 1;\n      Print::print((Print *)&Serial2,timerSeconds,10);\n      Print::print((Print *)&Serial2,\" \");\n      Print::print((Print *)&Serial2,(double)CONCAT44(stackParameter1,2),digits1);\n      Print::print((Print *)&Serial2,\" \");\n      Print::print((Print *)&Serial2,(double)CONCAT44(stackParameter1,2),digits2);\n      Print::print((Print *)&Serial2,\" \");\n      Print::println((Print *)&Serial2,(double)CONCAT44(stackParameter1,2),digits3);\n    }\n    else {\n      digitalWrite(ledRedPin,1);\n    }\n    LiquidCrystal::clear(&lcd);\n    Print::print(&lcd.super_Print,lcdMessagesReflowStatus[reflowState]);\n    LiquidCrystal::setCursor(&lcd,'\\0','\\x01');\n    if (reflowState == REFLOW_STATE_ERROR) {\n      Print::print(&lcd.super_Print,\"TC Error!\");\n    }\n    else {\n      thermocouplePtr = input._0_4_;\n      messageLength = input._4_4_;\n      Print::print(&lcd.super_Print,(double)CONCAT44(stackParameter1,2),2);\n      LiquidCrystal::write(&lcd,0,thermocouplePtr,messageLength);\n      Print::print(&lcd.super_Print,\"C \");\n    }\n  }\n  messageLength = input._4_4_;\n  thermocouplePtr = input._0_4_;\n  setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n  switch(reflowState) {\n  case REFLOW_STATE_IDLE:\n    readResult = __aeabi_dcmpge(input._0_4_,input._4_4_,0,0x40490000);\n    if (readResult == 0) {\n      if (switchStatus == SWITCH_1) {\n        Print::println((Print *)&Serial2,\"Time Setpoint Input Output\");\n        timerSeconds = 0;\n        windowStartTime = millis();\n        setpoint._0_4_ = 0;\n        setpoint._4_4_ = 0x4062c000;\n        dVar1 = (double)__floatsidf(windowSize);\n        PID::SetOutputLimits\n                  (&reflowOvenPID,dVar1,(double)CONCAT44(stackParameter3,stackParameter2));\n        PID::SetSampleTime(&reflowOvenPID,1000);\n        PID::SetMode(&reflowOvenPID,1);\n        reflowState = REFLOW_STATE_PREHEAT;\n      }\n    }\n    else {\n      reflowState = REFLOW_STATE_TOO_HOT;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_PREHEAT:\n    reflowStatus = REFLOW_STATUS_ON;\n    readResult = __aeabi_dcmpge(input._0_4_,input._4_4_,0,0x4062c000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (readResult != 0) {\n      uVar2 = millis();\n      timerSoak = uVar2 + 9000;\n      PID::SetTunings(&reflowOvenPID,0.05,250.0,(double)CONCAT44(secondParameter,firstParameter));\n      reflowState = REFLOW_STATE_SOAK;\n      setpoint = 155.0;\n    }\n    break;\n  case REFLOW_STATE_SOAK:\n    uVar2 = millis();\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (timerSoak < uVar2) {\n      uVar2 = millis();\n      timerSoak = uVar2 + 9000;\n      setpoint = (double)__aeabi_dadd(setpoint._0_4_,setpoint._4_4_,0,0x40140000);\n      readResult = __aeabi_dcmpgt(SUB84(setpoint,0),(int)((ulonglong)setpoint >> 0x20),0,0x40690000);\n      if (readResult != 0) {\n        PID::SetTunings(&reflowOvenPID,0.05,350.0,(double)CONCAT44(secondParameter,firstParameter));\n        reflowState = REFLOW_STATE_REFLOW;\n        setpoint = 250.0;\n      }\n    }\n    break;\n  case REFLOW_STATE_REFLOW:\n    readResult = __aeabi_dcmpge(input._0_4_,input._4_4_,0,0x406ea000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (readResult != 0) {\n      PID::SetTunings(&reflowOvenPID,0.05,350.0,(double)CONCAT44(secondParameter,firstParameter));\n      reflowState = REFLOW_STATE_COOL;\n      setpoint = 100.0;\n    }\n    break;\n  case REFLOW_STATE_COOL:\n    readResult = __aeabi_dcmple(input._0_4_,input._4_4_,0,0x40590000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (readResult != 0) {\n      uVar2 = millis();\n      buzzerPeriod = uVar2 + 1000;\n      digitalWrite(buzzerPin,1);\n      reflowStatus = REFLOW_STATUS_OFF;\n      reflowState = REFLOW_STATE_COMPLETE;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_COMPLETE:\n    uVar2 = millis();\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (buzzerPeriod < uVar2) {\n      digitalWrite(buzzerPin,0);\n      reflowState = REFLOW_STATE_IDLE;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_TOO_HOT:\n    readResult = __aeabi_dcmplt(input._0_4_,input._4_4_,0,0x40490000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (readResult != 0) {\n      reflowState = REFLOW_STATE_IDLE;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_ERROR:\n    readResult = __aeabi_dcmpeq(input._0_4_,input._4_4_,0,0x40c38800);\n    if ((readResult == 0) && (readResult = __aeabi_dcmpeq(thermocouplePtr,messageLength,0,0x40c38880), readResult == 0)) {\n      readResult = __aeabi_dcmpeq(thermocouplePtr,messageLength,0,0x40c38900);\n      if (readResult == 0) {\n        reflowState = REFLOW_STATE_IDLE;\n        setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n        break;\n      }\n    }\n    reflowState = REFLOW_STATE_ERROR;\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n  }\n  if ((switchStatus == SWITCH_1) && (reflowStatus == REFLOW_STATUS_ON)) {\n    reflowStatus = REFLOW_STATUS_OFF;\n    reflowState = REFLOW_STATE_IDLE;\n  }\n  if (debounceState == DEBOUNCE_STATE_CHECK) {\n    uVar2 = analogRead(switchPin);\n    if (uVar2 == 0) {\n      uVar2 = millis();\n      if (0x32 < uVar2 - lastDebounceTime) {\n        debounceState = DEBOUNCE_STATE_RELEASE;\n      }\n    }\n    else {\n      debounceState = DEBOUNCE_STATE_IDLE;\n    }\n  }\n  else if (debounceState == DEBOUNCE_STATE_IDLE) {\n    switchStatus = SWITCH_NONE;\n    uVar2 = analogRead(switchPin);\n    if (uVar2 == 0) {\n      lastDebounceTime = millis();\n      debounceState = DEBOUNCE_STATE_CHECK;\n    }\n  }\n  else if (debounceState == DEBOUNCE_STATE_RELEASE) {\n    uVar2 = analogRead(switchPin);\n    if (uVar2 != 0) {\n      switchStatus = SWITCH_1;\n      debounceState = DEBOUNCE_STATE_IDLE;\n    }\n  }\n  if (reflowStatus == REFLOW_STATUS_ON) {\n    uVar2 = millis();\n    PID::Compute(&reflowOvenPID);\n    if ((uint)windowSize < uVar2 - windowStartTime) {\n      windowStartTime = windowStartTime + windowSize;\n    }\n    elapsedTime = __floatunsidf(uVar2 - windowStartTime);\n    readResult = __aeabi_dcmplt((int)elapsedTime,(int)((ulonglong)elapsedTime >> 0x20),output._0_4_,output._4_4_);\n    if (readResult == 0) {\n      digitalWrite(ssrPin,0);\n      dVar1 = setpoint;\n    }\n    else {\n      digitalWrite(ssrPin,1);\n      dVar1 = setpoint;\n    }\n  }\n  else {\n    digitalWrite(ssrPin,0);\n    dVar1 = setpoint;\n  }\n  setpoint._4_4_ = (undefined4)((ulonglong)dVar1 >> 0x20);\n  setpoint._0_4_ = SUB84(dVar1,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000cd0": "run_reflow_oven_08000cd0",
                "pMVar3": "thermocouplePtr",
                "iVar4": "ledRedPinState",
                "now": "currentTime",
                "iVar5": "readResult",
                "extraout_r1": "readError",
                "digits": "digits1",
                "digits_00": "digits2",
                "digits_01": "digits3",
                "sVar6": "messageLength",
                "unaff_r4": "firstParameter",
                "unaff_r5": "secondParameter",
                "uVar7": "elapsedTime",
                "in_stack_ffffffe4": "stackParameter1",
                "in_stack_ffffffe8": "stackParameter2",
                "in_stack_ffffffec": "stackParameter3"
            },
            "calling": [
                "main"
            ],
            "called": [
                "SetOutputLimits",
                "write",
                "print",
                "setCursor",
                "analogRead",
                "millis",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "print",
                "__aeabi_dcmpeq",
                "println",
                "digitalRead",
                "__aeabi_dcmpge",
                "clear",
                "__aeabi_dcmple",
                "readThermocouple",
                "digitalWrite",
                "__floatsidf",
                "print",
                "Compute",
                "SetTunings",
                "SetSampleTime",
                "SetMode",
                "__floatunsidf",
                "__aeabi_dcmplt",
                "println"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001294": {
            "entrypoint": "0x08001294",
            "current_name": "set_row_offsets_08001294",
            "code": "\n/* DWARF original prototype: void  setRowOffsets_08001294(LiquidCrystal * lcd, int offset0, int offset1, int offset2,\n   int offset3) */\n\nvoid __lcdcall LiquidCrystal::setRowOffsets_08001294(LiquidCrystal *lcd,int offset0,int offset1,int offset2,int offset3)\n\n{\n  lcd->_row_offsets[0] = (uint8_t)offset0;\n  lcd->_row_offsets[1] = (uint8_t)offset1;\n  lcd->_row_offsets[2] = (uint8_t)offset2;\n  lcd->_row_offsets[3] = (uint8_t)offset3;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001294": "set_row_offsets_08001294",
                "this": "lcd",
                "row0": "offset0",
                "row1": "offset1",
                "row2": "offset2",
                "row3": "offset3"
            },
            "calling": [
                "begin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080012a2": {
            "entrypoint": "0x080012a2",
            "current_name": "pulse_enable_080012a2",
            "code": "\n/* DWARF original prototype: void  pulseEnable_080012a2(LiquidCrystal * lcd) */\n\nvoid __lcdcall LiquidCrystal::pulseEnable_080012a2(LiquidCrystal *lcd)\n\n{\n  digitalWrite((uint)lcd->enablePin,0);\n  digitalWrite((uint)lcd->enablePin,1);\n  digitalWrite((uint)lcd->enablePin,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080012a2": "pulse_enable_080012a2",
                "this": "lcd",
                "_enable_pin": "enablePin"
            },
            "calling": [
                "write4bits",
                "write8bits"
            ],
            "called": [
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080012c0": {
            "entrypoint": "0x080012c0",
            "current_name": "send4_bit_data_080012c0",
            "code": "\n/* DWARF original prototype: void  write4bits(LiquidCrystal * lcdObject, uint8_t dataValue) */\n\nvoid __lcdObjectcall LiquidCrystal::send4BitData_080012c0(LiquidCrystal *lcdObject,uint8_t dataValue)\n\n{\n  uint bitIndex;\n  \n  for (bitIndex = 0; (int)bitIndex < 4; bitIndex = bitIndex + 1) {\n    digitalWrite((uint)lcdObject->_data_pins[bitIndex],(int)(uint)dataValue >> (bitIndex & 0xff) & 1);\n  }\n  pulseEnable(lcdObject);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080012c0": "send4_bit_data_080012c0",
                "this": "lcdObject",
                "value": "dataValue",
                "uVar1": "bitIndex"
            },
            "calling": [
                "send",
                "begin"
            ],
            "called": [
                "digitalWrite",
                "pulseEnable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080012e8": {
            "entrypoint": "0x080012e8",
            "current_name": "write8bits_080012e8",
            "code": "\n/* DWARF original prototype: void  write8bits_080012e8(LiquidCrystal * lcd, uint8_t data) */\n\nvoid __lcdcall LiquidCrystal::write8bits_080012e8(LiquidCrystal *lcd,uint8_t data)\n\n{\n  uint bitIndex;\n  \n  for (bitIndex = 0; (int)bitIndex < 8; bitIndex = bitIndex + 1) {\n    digitalWrite((uint)lcd->_data_pins[bitIndex],(int)(uint)data >> (bitIndex & 0xff) & 1);\n  }\n  pulseEnable(lcd);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080012e8": "write8bits_080012e8",
                "this": "lcd",
                "value": "data",
                "uVar1": "bitIndex"
            },
            "calling": [
                "send"
            ],
            "called": [
                "digitalWrite",
                "pulseEnable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001310": {
            "entrypoint": "0x08001310",
            "current_name": "send_08001310",
            "code": "\n/* DWARF original prototype: void  send_08001310(LiquidCrystal * lcd, uint8_t value, uint8_t mode) */\n\nssize_t __lcdcall\nLiquidCrystal::send_08001310(LiquidCrystal *lcd,int value,void *mode,size_t length,int flags)\n\n{\n  digitalWrite((uint)lcd->rsPin,(uint32_t)mode);\n  if (lcd->rwPin != 0xff) {\n    digitalWrite((uint)lcd->rwPin,0);\n  }\n  if ((lcd->displayFunction & 0x10) == 0) {\n    write4bits(lcd,(uint8_t)((uint)value >> 4));\n    write4bits(lcd,(uint8_t)value);\n    return (ssize_t)lcd;\n  }\n  write8bits(lcd,(uint8_t)value);\n  return (ssize_t)lcd;\n}\n\n",
            "renaming": {
                "this": "lcd",
                "__fd": "value",
                "__buf": "mode",
                "__n": "length",
                "__flags": "flags",
                "_rs_pin": "rsPin",
                "_rw_pin": "rwPin",
                "_displayfunction": "displayFunction",
                "FUN_08001310": "send_08001310"
            },
            "calling": [
                "write",
                "setCursor",
                "begin",
                "display",
                "createChar",
                "clear"
            ],
            "called": [
                "digitalWrite",
                "write4bits",
                "write8bits"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800134e": {
            "entrypoint": "0x0800134e",
            "current_name": "send_data_to_lcd_0800134e",
            "code": "\n/* DWARF original prototype: size_t  write(LiquidCrystal * lcd_instance, uint8_t value) */\n\nssize_t __lcd_instancecall LiquidCrystal::send_data_to_lcd_0800134e(LiquidCrystal *lcd_instance,int _file_descriptor,void *buffer,size_t buffer_size)\n\n{\n  send(lcd_instance,_file_descriptor,(void *)0x1,buffer_size,buffer_size);\n  return 1;\n}\n\n",
            "renaming": {
                "this": "lcd_instance",
                "_fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "buffer_size",
                "FUN_0800134e": "send_data_to_lcd_0800134e"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800135a": {
            "entrypoint": "0x0800135a",
            "current_name": "clear_lcd_0800135a",
            "code": "\n/* DWARF original prototype: void  clear(LiquidCrystal * lcd) */\n\nvoid __lcdcall LiquidCrystal::clearLCD_0800135a(LiquidCrystal *lcd)\n\n{\n  size_t size;\n  \n  sendData(lcd,1,(void *)0x0,size,size);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800135a": "clear_lcd_0800135a",
                "this": "lcd",
                "in_r3": "size",
                "send": "sendData"
            },
            "calling": [
                "setup",
                "begin",
                "loop"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001366": {
            "entrypoint": "0x08001366",
            "current_name": "set_cursor_position_08001366",
            "code": "\n/* DWARF original prototype: void  setCursor(lcd * this, uint8_t column, uint8_t row) */\n\nvoid __thiscall lcd::setCursorPosition_08001366(lcd *this,uint8_t column,uint8_t row)\n\n{\n  uint limitedRow;\n  int unused;\n  \n  limitedRow = (uint)row;\n  if (3 < limitedRow) {\n    limitedRow = 3;\n  }\n  if (this->numLines <= limitedRow) {\n    limitedRow = this->numLines - 1 & 0xff;\n  }\n  transmit(this,(uint)(byte)(column + this->rowOffsets[limitedRow] | 0x80),(void *)0x0,\n       (uint)this->rowOffsets[limitedRow],unused);\n  return;\n}\n\n",
            "renaming": {
                "LiquidCrystal": "lcd",
                "col": "column",
                "uVar1": "limitedRow",
                "in_r3": "unused",
                "send": "transmit",
                "_numlines": "numLines",
                "_row_offsets": "rowOffsets",
                "FUN_08001366": "set_cursor_position_08001366"
            },
            "calling": [
                "setup",
                "loop"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800138e": {
            "entrypoint": "0x0800138e",
            "current_name": "set_display_control_bit_0800138e",
            "code": "\n/* DWARF original prototype: void  display(LiquidCrystal * lcd) */\n\nvoid __lcdcall LiquidCrystal::setDisplayControlBit_0800138e(LiquidCrystal *lcd)\n\n{\n  byte displayControl;\n  size_t size;\n  \n  displayControl = lcd->_displaycontrol;\n  lcd->_displaycontrol = displayControl | 4;\n  sendData(lcd,displayControl | 0xc,(void *)0x0,size,size);\n  return;\n}\n\n",
            "renaming": {
                "this": "lcd",
                "bVar1": "displayControl",
                "send": "sendData",
                "in_r3": "size",
                "FUN_0800138e": "set_display_control_bit_0800138e"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080013a4": {
            "entrypoint": "0x080013a4",
            "current_name": "initialize_lcd_080013a4",
            "code": "\n/* DWARF original prototype: void  begin(LiquidCrystal * lcd, uint8_t numColumns, uint8_t numLines, uint8_t\n   dotSize) */\n\nvoid __lcdcall\nLiquidCrystal::initializeLCD_080013a4(LiquidCrystal *lcd,uint8_t numColumns,uint8_t numLines,uint8_t dotSize)\n\n{\n  int rowOffset;\n  size_t bitCount;\n  int iteration;\n  \n  if (1 < numLines) {\n    lcd->displayFunction = lcd->displayFunction | 8;\n  }\n  lcd->numLines = numLines;\n  rowOffset = numColumns + 0x40;\n  setRowOffsets(lcd,0,0x40,(uint)numColumns,rowOffset);\n  if ((dotSize != '\\0') && (numLines == '\\x01')) {\n    lcd->displayFunction = lcd->displayFunction | 4;\n  }\n  setPinMode((uint)lcd->rsPin,1);\n  if (lcd->rwPin != 0xff) {\n    setPinMode((uint)lcd->rwPin,1);\n  }\n  setPinMode((uint)lcd->enablePin,1);\n  iteration = 0;\n  while( true ) {\n    if ((lcd->displayFunction & 0x10) == 0) {\n      bitCount = 4;\n    }\n    else {\n      bitCount = 8;\n    }\n    if ((int)bitCount <= iteration) break;\n    setPinMode((uint)lcd->dataPins[iteration],1);\n    iteration = iteration + 1;\n  }\n  writeDigital((uint)lcd->rsPin,0);\n  writeDigital((uint)lcd->enablePin,0);\n  if (lcd->rwPin != 0xff) {\n    writeDigital((uint)lcd->rwPin,0);\n  }\n  if ((lcd->displayFunction & 0x10) == 0) {\n    write4bits(lcd,'\\x03');\n    write4bits(lcd,'\\x03');\n    write4bits(lcd,'\\x03');\n    write4bits(lcd,'\\x02');\n  }\n  else {\n    sendData(lcd,lcd->displayFunction | 0x20,(void *)0x0,bitCount,rowOffset);\n    sendData(lcd,lcd->displayFunction | 0x20,(void *)0x0,bitCount,rowOffset);\n    sendData(lcd,lcd->displayFunction | 0x20,(void *)0x0,bitCount,rowOffset);\n  }\n  sendData(lcd,lcd->displayFunction | 0x20,(void *)0x0,bitCount,rowOffset);\n  lcd->displayControl = '\\x04';\n  displayData(lcd);\n  clearDisplay(lcd);\n  lcd->displayMode = '\\x02';\n  sendData(lcd,6,(void *)0x0,2,rowOffset);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080013a4": "initialize_lcd_080013a4",
                "this": "lcd",
                "cols": "numColumns",
                "lines": "numLines",
                "dotsize": "dotSize",
                "row3": "rowOffset",
                "_displayfunction": "displayFunction",
                "_displaycontrol": "displayControl",
                "_displaymode": "displayMode",
                "_numlines": "numLines",
                "_rs_pin": "rsPin",
                "_rw_pin": "rwPin",
                "_enable_pin": "enablePin",
                "_data_pins": "dataPins",
                "__n": "bitCount",
                "iVar1": "iteration",
                "pinMode": "setPinMode",
                "digitalWrite": "writeDigital",
                "send": "sendData",
                "display": "displayData",
                "clear": "clearDisplay"
            },
            "calling": [
                "setup",
                "init"
            ],
            "called": [
                "digitalWrite",
                "send",
                "display",
                "pinMode",
                "clear",
                "setRowOffsets",
                "write4bits"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014ba": {
            "entrypoint": "0x080014ba",
            "current_name": "initialize_lcd_080014ba",
            "code": "\n/* DWARF original prototype: void  init(LiquidCrystal * lcd, uint8_t fourbitmode, uint8_t rs,\n   uint8_t rw, uint8_t enable, uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3, uint8_t d4, uint8_t\n   d5, uint8_t d6, uint8_t d7) */\n\nint __lcdcall LiquidCrystal::initializeLCD_080014ba(LiquidCrystal *lcd,EVPContext *evpContext)\n\n{\n  uint8_t rsPin;\n  uint8_t rwPin;\n  uint8_t enablePin;\n  uint8_t dataPin0;\n  uint8_t dataPin1;\n  uint8_t dataPin2;\n  uint8_t dataPin3;\n  uint8_t dataPin4;\n  uint8_t dataPin5;\n  uint8_t dataPin6;\n  uint8_t dataPin7;\n  \n  lcd->_rs_pin = rsPin;\n  lcd->_rw_pin = rwPin;\n  lcd->_enable_pin = enablePin;\n  lcd->_data_pins[0] = dataPin0;\n  lcd->_data_pins[1] = dataPin1;\n  lcd->_data_pins[2] = dataPin2;\n  lcd->_data_pins[3] = dataPin3;\n  lcd->_data_pins[4] = dataPin4;\n  lcd->_data_pins[5] = dataPin5;\n  lcd->_data_pins[6] = dataPin6;\n  lcd->_data_pins[7] = dataPin7;\n  if (evpContext == (EVPContext *)0x0) {\n    lcd->_displayfunction = '\\x10';\n  }\n  else {\n    lcd->_displayfunction = '\\0';\n  }\n  begin(lcd,'\\x10','\\x01','\\0');\n  return (int)lcd;\n}\n\n",
            "renaming": {
                "this": "lcd",
                "ctx": "evpContext",
                "in_r2": "rsPin",
                "in_r3": "rwPin",
                "in_stack_00000000": "enablePin",
                "in_stack_00000004": "dataPin0",
                "in_stack_00000008": "dataPin1",
                "in_stack_0000000c": "dataPin2",
                "in_stack_00000010": "dataPin3",
                "in_stack_00000014": "dataPin4",
                "in_stack_00000018": "dataPin5",
                "in_stack_0000001c": "dataPin6",
                "in_stack_00000020": "dataPin7",
                "EVP_PKEY_CTX": "EVPContext",
                "FUN_080014ba": "initialize_lcd_080014ba"
            },
            "calling": [
                "LiquidCrystal"
            ],
            "called": [
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001510": {
            "entrypoint": "0x08001510",
            "current_name": "initialize_lcd_08001510",
            "code": "\n/* DWARF original prototype: LiquidCrystal *  LiquidCrystal(LiquidCrystal * lcd, uint8_t registerSelectPin,\n   uint8_t enablePin, uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3) */\n\nLiquidCrystal * __lcdcall\nLiquidCrystal::initializeLCD_08001510(LiquidCrystal *lcd,uint8_t registerSelectPin,uint8_t enablePin,uint8_t d0,uint8_t d1,uint8_t d2,uint8_t d3\n          )\n\n{\n  (lcd->super_Print).write_error = 0;\n  (lcd->super_Print)._vptr_Print = (_func_int_varargs **)&PTR_write_1_080073f8;\n  initialize(lcd,(EVP_PKEY_CTX *)0x1);\n  return lcd;\n}\n\n",
            "renaming": {
                "this": "lcd",
                "rs": "registerSelectPin",
                "enable": "enablePin",
                "init": "initialize",
                "FUN_08001510": "initialize_lcd_08001510"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001550": {
            "entrypoint": "0x08001550",
            "current_name": "create_character_08001550",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example charLocation: r0 : 0x08001574 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  createChar(LiquidCrystal * lcd, uint8_t charLocation, uint8_t *\n   characterMap) */\n\nvoid __lcdcall LiquidCrystal::createCharacter_08001550(LiquidCrystal *lcd,uint8_t charLocation,uint8_t *characterMap)\n\n{\n  size_t size;\n  int unused;\n  int iterationIndex;\n  \n  send(lcd,(charLocation & 7) << 3 | 0x40,(void *)0x0,size,unused);\n  for (iterationIndex = 0; iterationIndex < 8; iterationIndex = iterationIndex + 1) {\n    (**(lcd->super_Print)._vptr_Print)(lcd,(uint)characterMap[iterationIndex]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "lcd",
                "location": "charLocation",
                "charmap": "characterMap",
                "in_r3": "size",
                "unaff_r4": "unused",
                "iVar1": "iterationIndex",
                "FUN_08001550": "create_character_08001550"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800157c": {
            "entrypoint": "0x0800157c",
            "current_name": "initialize_max31855_0800157c",
            "code": "\n/* DWARF original prototype: MAX31855 *  MAX31855(MAX31855 * self, uchar dataOutputPin, uchar chipSelectPin, uchar clockPin) */\n\nMAX31855 * __selfcall MAX31855::initializeMAX31855_0800157c(MAX31855 *self,uchar dataOutputPin,uchar chipSelectPin,uchar clockPin)\n\n{\n  self->so = dataOutputPin;\n  self->cs = chipSelectPin;\n  self->sck = clockPin;\n  pinMode((uint)dataOutputPin,0);\n  pinMode((uint)self->cs,1);\n  pinMode((uint)self->sck,1);\n  digitalWrite((uint)self->cs,1);\n  digitalWrite((uint)self->sck,0);\n  return self;\n}\n\n",
            "renaming": {
                "this": "self",
                "SO": "dataOutputPin",
                "CS": "chipSelectPin",
                "SCK": "clockPin",
                "FUN_0800157c": "initialize_max31855_0800157c"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "digitalWrite",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b2": {
            "entrypoint": "0x080015b2",
            "current_name": "read_data_080015b2",
            "code": "\n/* DWARF original prototype: ulong  readData_080015b2(MAX31855 * sensor) */\n\nulong __sensorcall MAX31855::readData_080015b2(MAX31855 *sensor)\n\n{\n  int readValue;\n  uint bitIndex;\n  uint data;\n  \n  digitalWrite((uint)sensor->chipSelectPin,0);\n  data = 0;\n  for (bitIndex = 0x1f; -1 < (int)bitIndex; bitIndex = bitIndex - 1) {\n    digitalWrite((uint)sensor->clockPin,1);\n    readValue = digitalRead((uint)sensor->dataPin);\n    if (readValue != 0) {\n      data = data | 1 << (bitIndex & 0xff);\n    }\n    digitalWrite((uint)sensor->clockPin,0);\n  }\n  digitalWrite((uint)sensor->chipSelectPin,1);\n  return data;\n}\n\n",
            "renaming": {
                "this": "sensor",
                "cs": "chipSelectPin",
                "sck": "clockPin",
                "so": "dataPin",
                "iVar1": "readValue",
                "uVar2": "bitIndex",
                "uVar3": "data",
                "FUN_080015b2": "read_data_080015b2"
            },
            "calling": [
                "readThermocouple"
            ],
            "called": [
                "digitalWrite",
                "digitalRead"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015f8": {
            "entrypoint": "0x080015f8",
            "current_name": "read_thermocouple_080015f8",
            "code": "\n/* DWARF original prototype: double  readThermocouple_080015f8(MAX31855 * this, unit unit) */\n\ndouble __thiscall MAX31855::readThermocouple_080015f8(MAX31855 *this,unit unit)\n\n{\n  ulong data;\n  ulong data;\n  uint shiftedData;\n  double temperature;\n  double temperature;\n  double result;\n  undefined8 convertedTemperature;\n  \n  data = readData(this);\n  if ((data & 0x10000) == 0) {\n    shiftedData = data >> 0x12;\n    convertedTemperature = __floatunsidf(shiftedData & 0x1fff);\n    if ((shiftedData & 0x2000) != 0) {\n      convertedTemperature = __floatunsidf(~shiftedData & 0x1fff);\n      convertedTemperature = __aeabi_dadd((int)convertedTemperature,(int)((ulonglong)convertedTemperature >> 0x20),0,0x3ff00000);\n      convertedTemperature = CONCAT44((int)((ulonglong)convertedTemperature >> 0x20) + -0x80000000,(int)convertedTemperature);\n    }\n    convertedTemperature = __muldf3((int)convertedTemperature,(int)((ulonglong)convertedTemperature >> 0x20),0,0x3fd00000);\n    result = temperature;\n    if (unit == FAHRENHEIT) {\n      convertedTemperature = __muldf3((int)convertedTemperature,(int)((ulonglong)convertedTemperature >> 0x20),0,0x40220000);\n      convertedTemperature = __divdf3((int)convertedTemperature,(int)((ulonglong)convertedTemperature >> 0x20),0,0x40140000);\n      result = (double)__aeabi_dadd((int)convertedTemperature,(int)((ulonglong)convertedTemperature >> 0x20),0,0x40400000);\n      return result;\n    }\n  }\n  else {\n    shiftedData = data & 7;\n    if (shiftedData == 2) {\n      return temperature;\n    }\n    if (shiftedData == 4) {\n      return temperature;\n    }\n    result = temperature;\n    if (shiftedData != 1) {\n      return temperature;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "unit_t": "unit",
                "uVar1": "data",
                "uVar2": "shiftedData",
                "extraout_d0": "temperature",
                "extraout_d0_00": "temperature",
                "dVar3": "result",
                "uVar4": "convertedTemperature",
                "FUN_080015f8": "read_thermocouple_080015f8"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "__floatunsidf",
                "__divdf3",
                "readData"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016b4": {
            "entrypoint": "0x080016b4",
            "current_name": "compute_pid_080016b4",
            "code": "\n/* DWARF original prototype: bool  Compute(PID * pid) */\n\nbool __pidcall PID::computePID_080016b4(PID *pid)\n\n{\n  bool isAuto;\n  uint32_t currentTime;\n  ulong currentTime;\n  int comparisonResult;\n  undefined4 temp1;\n  undefined4 input1;\n  undefined4 temp2;\n  undefined4 minOutput;\n  ulong timeChange;\n  undefined4 input2;\n  undefined4 maxOutput;\n  undefined4 minOutput;\n  char inAuto;\n  undefined4 maxOutput;\n  undefined4 minOutput;\n  undefined4 temp3;\n  undefined8 outputSum1;\n  undefined8 inputDifference1;\n  undefined8 outputSum2;\n  double outputSum;\n  double computedOutput;\n  double output;\n  \n  inAuto = pid->inAuto;\n  if ((bool)inAuto != false) {\n    currentTime = millis();\n    if (currentTime - pid->lastTime < pid->SampleTime) {\n      inAuto = '\\0';\n    }\n    else {\n      input1 = *(undefined4 *)pid->myInput;\n      input2 = *(undefined4 *)((int)pid->myInput + 4);\n      outputSum1 = __subdf3(*(undefined4 *)pid->mySetpoint,*(undefined4 *)((int)pid->mySetpoint + 4));\n      temp3 = (undefined4)((ulonglong)outputSum1 >> 0x20);\n      inputDifference1 = __subdf3(input1,input2,*(undefined4 *)&pid->lastInput,\n                        *(undefined4 *)((int)&pid->lastInput + 4));\n      temp1 = (undefined4)((ulonglong)inputDifference1 >> 0x20);\n      outputSum2 = __muldf3((int)outputSum1,temp3,*(undefined4 *)&pid->ki,\n                        *(undefined4 *)((int)&pid->ki + 4));\n      outputSum = (double)__aeabi_dadd((int)outputSum2,(int)((ulonglong)outputSum2 >> 0x20),\n                                    *(undefined4 *)&pid->outputSum,\n                                    *(undefined4 *)((int)&pid->outputSum + 4));\n      pid->outputSum = outputSum;\n      isAuto = pid->pOnE;\n      if (isAuto == false) {\n        outputSum2 = __muldf3((int)inputDifference1,temp1,*(undefined4 *)&pid->kp,\n                          *(undefined4 *)((int)&pid->kp + 4));\n        outputSum = (double)__subdf3(SUB84(outputSum,0),(int)((ulonglong)outputSum >> 0x20),(int)outputSum2,\n                                  (int)((ulonglong)outputSum2 >> 0x20));\n        pid->outputSum = outputSum;\n      }\n      temp2 = *(undefined4 *)&pid->outputSum;\n      maxOutput = *(undefined4 *)((int)&pid->outputSum + 4);\n      maxOutput = *(undefined4 *)&pid->outMax;\n      minOutput = *(undefined4 *)((int)&pid->outMax + 4);\n      outputSum = pid->outMax;\n      comparisonResult = __aeabi_dcmpgt(temp2,maxOutput,maxOutput,minOutput);\n      if (comparisonResult == 0) {\n        minOutput = *(undefined4 *)&pid->outMin;\n        minOutput = *(undefined4 *)((int)&pid->outMin + 4);\n        comparisonResult = __aeabi_dcmplt(temp2,maxOutput);\n        if (comparisonResult != 0) {\n          *(undefined4 *)&pid->outputSum = minOutput;\n          *(undefined4 *)((int)&pid->outputSum + 4) = minOutput;\n        }\n      }\n      else {\n        *(undefined4 *)&pid->outputSum = maxOutput;\n        *(undefined4 *)((int)&pid->outputSum + 4) = minOutput;\n      }\n      if (isAuto == false) {\n        outputSum1 = 0;\n      }\n      else {\n        outputSum1 = __muldf3((int)outputSum1,temp3,*(undefined4 *)&pid->kp,\n                          *(undefined4 *)((int)&pid->kp + 4));\n      }\n      output._4_4_ = (undefined4)((ulonglong)outputSum1 >> 0x20);\n      output._0_4_ = (undefined4)outputSum1;\n      temp3 = *(undefined4 *)&pid->outputSum;\n      temp2 = *(undefined4 *)((int)&pid->outputSum + 4);\n      outputSum1 = __muldf3((int)inputDifference1,temp1,*(undefined4 *)&pid->kd,\n                        *(undefined4 *)((int)&pid->kd + 4));\n      outputSum1 = __subdf3(temp3,temp2,(int)outputSum1,(int)((ulonglong)outputSum1 >> 0x20));\n      computedOutput = (double)__aeabi_dadd(output._0_4_,output._4_4_,(int)outputSum1,\n                                    (int)((ulonglong)outputSum1 >> 0x20));\n      temp3 = (undefined4)((ulonglong)computedOutput >> 0x20);\n      comparisonResult = __aeabi_dcmplt(maxOutput,minOutput,SUB84(computedOutput,0),temp3);\n      if (comparisonResult == 0) {\n        outputSum = pid->outMin;\n        comparisonResult = __aeabi_dcmplt(SUB84(computedOutput,0),temp3,*(undefined4 *)&pid->outMin,\n                               *(undefined4 *)((int)&pid->outMin + 4));\n        if (comparisonResult == 0) {\n          outputSum = computedOutput;\n        }\n      }\n      *pid->myOutput = outputSum;\n      *(undefined4 *)&pid->lastInput = input1;\n      *(undefined4 *)((int)&pid->lastInput + 4) = input2;\n      pid->lastTime = currentTime;\n    }\n  }\n  return (bool)inAuto;\n}\n\n",
            "renaming": {
                "FUN_080016b4": "compute_pid_080016b4",
                "this": "pid",
                "bVar1": "isAuto",
                "uVar2": "currentTime",
                "now": "currentTime",
                "iVar3": "comparisonResult",
                "uVar4": "temp1",
                "uVar5": "input1",
                "uVar6": "temp2",
                "uVar7": "minOutput",
                "uVar8": "input2",
                "uVar9": "maxOutput",
                "uVar10": "minOutput",
                "cVar11": "inAuto",
                "uVar12": "maxOutput",
                "uVar13": "minOutput",
                "uVar14": "temp3",
                "uVar15": "outputSum1",
                "uVar16": "inputDifference1",
                "uVar17": "outputSum2",
                "dVar18": "outputSum",
                "dVar19": "computedOutput"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__muldf3",
                "__subdf3",
                "__aeabi_dadd",
                "millis",
                "__aeabi_dcmpgt",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001814": {
            "entrypoint": "0x08001814",
            "current_name": "initialize_pid_controller_08001814",
            "code": "\n/* DWARF original prototype: void  SetTunings(PID * controller, double proportionalGain, double integralGain, double derivativeGain, int processOn)\n    */\n\nvoid __controllercall PID::initializePIDController_08001814(PID *controller,double proportionalGain,double integralGain,double derivativeGain,int processOn)\n\n{\n  int comparisonResult;\n  undefined4 undefinedValue2;\n  undefined4 inputRegister2;\n  undefined4 inputRegister3;\n  undefined undefinedValue3;\n  bool booleanValue;\n  undefined8 floatResult;\n  double multiplicationResult;\n  double divisionResult;\n  double subtractionResult;\n  \n  comparisonResult = __aeabi_dcmplt();\n  if (((comparisonResult == 0) && (comparisonResult = __aeabi_dcmplt(proportionalGain._0_4_,proportionalGain._4_4_,0,0), comparisonResult == 0)) &&\n     (comparisonResult = __aeabi_dcmplt(integralGain._0_4_,integralGain._4_4_,0,0), comparisonResult == 0)) {\n    controller->pOn = derivativeGain._0_4_;\n    booleanValue = derivativeGain._0_4_ != 1;\n    if (booleanValue) {\n      derivativeGain._0_4_ = 0;\n    }\n    undefinedValue3 = (undefined)derivativeGain._0_4_;\n    if (!booleanValue) {\n      undefinedValue3 = true;\n    }\n    controller->pOnE = (bool)undefinedValue3;\n    *(undefined4 *)&controller->dispproportionalGain = inputRegister2;\n    *(undefined4 *)((int)&controller->dispproportionalGain + 4) = inputRegister3;\n    controller->dispintegralGain = proportionalGain;\n    controller->dispderivativeGain = integralGain;\n    floatResult = __floatunsidf(controller->SampleTime);\n    floatResult = __divdf3((int)floatResult,(int)((ulonglong)floatResult >> 0x20),0,0x408f4000);\n    undefinedValue2 = (undefined4)((ulonglong)floatResult >> 0x20);\n    *(undefined4 *)&controller->kp = inputRegister2;\n    *(undefined4 *)((int)&controller->kp + 4) = inputRegister3;\n    multiplicationResult = (double)__muldf3(proportionalGain._0_4_,proportionalGain._4_4_,(int)floatResult,undefinedValue2);\n    controller->ki = multiplicationResult;\n    divisionResult = (double)__divdf3(integralGain._0_4_,integralGain._4_4_,(int)floatResult,undefinedValue2);\n    controller->kd = divisionResult;\n    if (controller->controllerDirection == 1) {\n      subtractionResult = (double)__subdf3(0,0);\n      controller->kp = subtractionResult;\n      multiplicationResult = (double)__subdf3(0,0,SUB84(multiplicationResult,0),(int)((ulonglong)multiplicationResult >> 0x20));\n      controller->ki = multiplicationResult;\n      multiplicationResult = (double)__subdf3(0,0,SUB84(divisionResult,0),(int)((ulonglong)divisionResult >> 0x20));\n      controller->kd = multiplicationResult;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "controller",
                "Kp": "proportionalGain",
                "Ki": "integralGain",
                "Kd": "derivativeGain",
                "POn": "processOn",
                "iVar1": "comparisonResult",
                "uVar2": "undefinedValue2",
                "in_r2": "inputRegister2",
                "in_r3": "inputRegister3",
                "uVar3": "undefinedValue3",
                "bVar4": "booleanValue",
                "uVar5": "floatResult",
                "dVar6": "multiplicationResult",
                "dVar7": "divisionResult",
                "dVar8": "subtractionResult",
                "FUN_08001814": "initialize_pid_controller_08001814"
            },
            "calling": [
                "PID",
                "SetTunings"
            ],
            "called": [
                "__muldf3",
                "__subdf3",
                "__floatunsidf",
                "__divdf3",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080018f8": {
            "entrypoint": "0x080018f8",
            "current_name": "set_pid_tunings_080018f8",
            "code": "\n/* DWARF original prototype: void  SetTunings(PID * pidInstance, double proportionalGain, double integralGain, double derivativeGain) */\n\nvoid __pidInstancecall PID::setPIDTunings_080018f8(PID *pidInstance,double proportionalGain,double integralGain,double derivativeGain)\n\n{\n  undefined4 tempVariable;\n  \n  SetTunings(pidInstance,proportionalGain,integralGain,(double)CONCAT44(tempVariable,pidInstance->pOn),pidInstance->pOn);\n  return;\n}\n\n",
            "renaming": {
                "this": "pidInstance",
                "Kp": "proportionalGain",
                "Ki": "integralGain",
                "Kd": "derivativeGain",
                "in_stack_ffffffec": "tempVariable",
                "FUN_080018f8": "set_pid_tunings_080018f8"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "SetTunings"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001918": {
            "entrypoint": "0x08001918",
            "current_name": "set_sample_time_08001918",
            "code": "\n/* DWARF original prototype: void  SetSampleTime(PID * pid, int new_sample_time) */\n\nvoid __pidcall PID::set_sample_time_08001918(PID *pid,int new_sample_time)\n\n{\n  undefined4 div_result;\n  undefined8 float_new_sample;\n  undefined8 float_sample_time;\n  double temp;\n  \n  if (0 < new_sample_time) {\n    float_new_sample = __floatsidf(new_sample_time);\n    float_sample_time = __floatunsidf(pid->SampleTime);\n    float_new_sample = __divdf3((int)float_new_sample,(int)((ulonglong)float_new_sample >> 0x20),(int)float_sample_time,\n                     (int)((ulonglong)float_sample_time >> 0x20));\n    div_result = (undefined4)((ulonglong)float_new_sample >> 0x20);\n    temp = (double)__muldf3((int)float_new_sample,div_result,*(undefined4 *)&pid->integral_gain,\n                             *(undefined4 *)((int)&pid->integral_gain + 4));\n    pid->integral_gain = temp;\n    temp = (double)__divdf3(*(undefined4 *)&pid->derivative_gain,*(undefined4 *)((int)&pid->derivative_gain + 4),(int)float_new_sample\n                             ,div_result);\n    pid->derivative_gain = temp;\n    pid->SampleTime = new_sample_time;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001918": "set_sample_time_08001918",
                "this": "pid",
                "NewSampleTime": "new_sample_time",
                "uVar1": "div_result",
                "uVar2": "float_new_sample",
                "uVar3": "float_sample_time",
                "dVar4": "temp",
                "ki": "integral_gain",
                "kd": "derivative_gain"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__muldf3",
                "__floatsidf",
                "__floatunsidf",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001960": {
            "entrypoint": "0x08001960",
            "current_name": "set_output_limits_08001960",
            "code": "\n/* DWARF original prototype: void  SetOutputLimits(PID * this, double min_limit, double max_limit) */\n\nvoid __thiscall PID::set_output_limits_08001960(PID *this,double min_limit,double max_limit)\n\n{\n  int comparison_result;\n  undefined4 new_min_0;\n  undefined4 new_min_1;\n  double *output_ptr;\n  undefined4 output_sum_0;\n  undefined4 output_sum_1;\n  undefined4 new_max_0;\n  undefined4 new_max_1;\n  \n  comparison_result = __aeabi_dcmpge();\n  if (comparison_result == 0) {\n    *(undefined4 *)&this->outmin_limit = new_min_0;\n    *(undefined4 *)((int)&this->outmin_limit + 4) = new_min_1;\n    this->outmax_limit = min_limit;\n    if (this->inAuto != false) {\n      output_ptr = this->myOutput;\n      comparison_result = __aeabi_dcmplt(min_limit._0_4_,min_limit._4_4_,*(undefined4 *)output_ptr,\n                             *(undefined4 *)((int)output_ptr + 4));\n      if (comparison_result == 0) {\n        comparison_result = __aeabi_dcmpgt();\n        if (comparison_result != 0) {\n          *(undefined4 *)output_ptr = new_min_0;\n          *(undefined4 *)((int)output_ptr + 4) = new_min_1;\n        }\n      }\n      else {\n        *output_ptr = min_limit;\n      }\n      output_sum_0 = *(undefined4 *)&this->outputSum;\n      output_sum_1 = *(undefined4 *)((int)&this->outputSum + 4);\n      new_max_0 = *(undefined4 *)&this->outmax_limit;\n      new_max_1 = *(undefined4 *)((int)&this->outmax_limit + 4);\n      comparison_result = __aeabi_dcmpgt(output_sum_0,output_sum_1,new_max_0,new_max_1);\n      if (comparison_result != 0) {\n        *(undefined4 *)&this->outputSum = new_max_0;\n        *(undefined4 *)((int)&this->outputSum + 4) = new_max_1;\n        return;\n      }\n      new_max_0 = *(undefined4 *)&this->outmin_limit;\n      new_max_1 = *(undefined4 *)((int)&this->outmin_limit + 4);\n      comparison_result = __aeabi_dcmplt(output_sum_0,output_sum_1,new_max_0,new_max_1);\n      if (comparison_result != 0) {\n        *(undefined4 *)&this->outputSum = new_max_0;\n        *(undefined4 *)((int)&this->outputSum + 4) = new_max_1;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001960": "set_output_limits_08001960",
                "Min": "min_limit",
                "Max": "max_limit",
                "iVar1": "comparison_result",
                "in_r2": "new_min_0",
                "in_r3": "new_min_1",
                "pdVar2": "output_ptr",
                "uVar3": "output_sum_0",
                "uVar4": "output_sum_1",
                "uVar5": "new_max_0",
                "uVar6": "new_max_1"
            },
            "calling": [
                "PID",
                "loop"
            ],
            "called": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080019f6": {
            "entrypoint": "0x080019f6",
            "current_name": "initialize_pid_080019f6",
            "code": "\n/* DWARF original prototype: void  Initialize(PID * pidInstance) */\n\nvoid __pidInstancecall PID::initializePID_080019f6(PID *pidInstance)\n\n{\n  int comparisonResult;\n  undefined4 outMinVar1;\n  undefined4 myOutputVar1;\n  undefined4 myOutputVar2;\n  undefined4 outMinVar2;\n  \n  myOutputVar1 = *(undefined4 *)pidInstance->myOutput;\n  myOutputVar2 = *(undefined4 *)((int)pidInstance->myOutput + 4);\n  *(undefined4 *)&pidInstance->outputSum = myOutputVar1;\n  *(undefined4 *)((int)&pidInstance->outputSum + 4) = myOutputVar2;\n  outMinVar1 = *(undefined4 *)((int)pidInstance->myInput + 4);\n  *(undefined4 *)&pidInstance->lastInput = *(undefined4 *)pidInstance->myInput;\n  *(undefined4 *)((int)&pidInstance->lastInput + 4) = outMinVar1;\n  outMinVar1 = *(undefined4 *)&pidInstance->outMax;\n  outMinVar2 = *(undefined4 *)((int)&pidInstance->outMax + 4);\n  comparisonResult = __aeabi_dcmpgt(myOutputVar1,myOutputVar2,outMinVar1,outMinVar2);\n  if (comparisonResult == 0) {\n    outMinVar1 = *(undefined4 *)&pidInstance->outMin;\n    outMinVar2 = *(undefined4 *)((int)&pidInstance->outMin + 4);\n    comparisonResult = __aeabi_dcmplt(myOutputVar1,myOutputVar2,outMinVar1,outMinVar2);\n    if (comparisonResult != 0) {\n      *(undefined4 *)&pidInstance->outputSum = outMinVar1;\n      *(undefined4 *)((int)&pidInstance->outputSum + 4) = outMinVar2;\n    }\n    return;\n  }\n  *(undefined4 *)&pidInstance->outputSum = outMinVar1;\n  *(undefined4 *)((int)&pidInstance->outputSum + 4) = outMinVar2;\n  return;\n}\n\n",
            "renaming": {
                "this": "pidInstance",
                "uVar2": "outMinVar1",
                "uVar3": "myOutputVar1",
                "uVar4": "myOutputVar2",
                "uVar5": "outMinVar2",
                "iVar1": "comparisonResult",
                "FUN_080019f6": "initialize_pid_080019f6"
            },
            "calling": [
                "SetMode"
            ],
            "called": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a44": {
            "entrypoint": "0x08001a44",
            "current_name": "set_mode_08001a44",
            "code": "\n/* DWARF original prototype: void  SetnewMode(PID * pidObject, int newMode) */\n\nvoid __pidObjectcall PID::setMode_08001a44(PID *pidObject,int newMode)\n\n{\n  bool isAuto;\n  bool shouldInitialize;\n  \n  if (newMode == 1) {\n    shouldInitialize = true;\n    if (pidObject->inAuto == false) {\n      Initialize(pidObject);\n    }\n  }\n  else {\n    shouldInitialize = false;\n  }\n  pidObject->inAuto = shouldInitialize;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a44": "set_mode_08001a44",
                "this": "pidObject",
                "Mode": "newMode",
                "newAuto": "isAuto",
                "bVar1": "shouldInitialize"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "Initialize"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a66": {
            "entrypoint": "0x08001a66",
            "current_name": "set_controller_direction_08001a66",
            "code": "\n/* DWARF original prototype: void  SetControllerdirection(PID * pid, int direction) */\n\nvoid __pidcall PID::set_controller_direction_08001a66(PID *pid,int direction)\n\n{\n  double subtracted_value;\n  \n  if ((pid->inAuto != false) && (pid->controllerdirection != direction)) {\n    subtracted_value = (double)__subdf3(0,0,*(undefined4 *)&pid->kp,*(undefined4 *)((int)&pid->kp + 4));\n    pid->kp = subtracted_value;\n    subtracted_value = (double)__subdf3(0,0,*(undefined4 *)&pid->ki,*(undefined4 *)((int)&pid->ki + 4));\n    pid->ki = subtracted_value;\n    subtracted_value = (double)__subdf3(0,0,*(undefined4 *)&pid->kd,*(undefined4 *)((int)&pid->kd + 4));\n    pid->kd = subtracted_value;\n  }\n  pid->controllerdirection = direction;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a66": "set_controller_direction_08001a66",
                "this": "pid",
                "Direction": "direction",
                "dVar1": "subtracted_value"
            },
            "calling": [
                "PID"
            ],
            "called": [
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "initialize_pid_08001ab0",
            "code": "\n/* DWARF original prototype: PID *  PID(PID * pid, double * input, double * output, double *\n   setpoint, double kp, double ki, double kd, int pon, int controllerDirection) */\n\nPID * __pidcall\nPID::initializePID_08001ab0(PID *pid,double *input,double *output,double *setpoint,double kp,double ki,\n                 double kd,int pon,int controllerDirection)\n\n{\n  uint32_t currentTime;\n  int scaledPOn;\n  undefined4 limitMin;\n  undefined4 limitMax;\n  undefined4 scaledPOn_Kd;\n  \n  pid->myoutput = output;\n  pid->myinput = input;\n  pid->mysetpoint = setpoint;\n  pid->inAuto = false;\n  SetoutputLimits(pid,255.0,(double)CONCAT44(limitMax,limitMin));\n  pid->SampleTime = 100;\n  SetcontrollerDirection(pid,controllerDirection);\n  SetTunings(pid,ki,kd,(double)CONCAT44(scaledPOn_Kd,pon),scaledPOn);\n  currentTime = millis();\n  pid->lastTime = currentTime - pid->SampleTime;\n  return pid;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "initialize_pid_08001ab0",
                "this": "pid",
                "Input": "input",
                "Output": "output",
                "Setpoint": "setpoint",
                "Kp": "kp",
                "Ki": "ki",
                "Kd": "kd",
                "POn": "pon",
                "ControllerDirection": "controllerDirection",
                "uVar1": "currentTime",
                "POn_00": "scaledPOn",
                "in_stack_ffffffe8": "limitMin",
                "in_stack_ffffffec": "limitMax",
                "in_stack_fffffff4": "scaledPOn_Kd"
            },
            "calling": [
                "PID"
            ],
            "called": [
                "SetOutputLimits",
                "millis",
                "SetTunings",
                "SetControllerDirection"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b18": {
            "entrypoint": "0x08001b18",
            "current_name": "initialize_pid_08001b18",
            "code": "\n/* DWARF original prototype: PID *  PID(PID * pidObject, double * input, double * output, double *\n   setpoint, double proportionalGain, double integralGain, double derivativeGain, int controllerDirection) */\n\nPID * __pidObjectcall\nPID::initializePID_08001b18(PID *pidObject,double *input,double *output,double *setpoint,double proportionalGain,double integralGain,\n                 double derivativeGain,int controllerDirection)\n\n{\n  PID(pidObject,input,output,setpoint,proportionalGain,integralGain,derivativeGain,1,controllerDirection);\n  return pidObject;\n}\n\n",
            "renaming": {
                "FUN_08001b18": "initialize_pid_08001b18",
                "this": "pidObject",
                "Input": "input",
                "Output": "output",
                "Setpoint": "setpoint",
                "Kp": "proportionalGain",
                "Ki": "integralGain",
                "Kd": "derivativeGain",
                "ControllerDirection": "controllerDirection"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "PID"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b48": {
            "entrypoint": "0x08001b48",
            "current_name": "initialize_clocks_08001b48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeClocks_08001b48(void)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t hclkFreq;\n  RCC_PeriphCLKInitTypeDef PeriphClkInit;\n  RCC_ClkInitTypeDef RCC_ClkInitStruct;\n  RCC_OscInitTypeDef RCC_OscInitStruct;\n  \n  RCC_OscInitStruct.OscillatorType = 2;\n  RCC_OscInitStruct.HSIState = 1;\n  RCC_OscInitStruct.HSICalibrationValue = 0x10;\n  RCC_OscInitStruct.PLL.PLLState = 2;\n  RCC_OscInitStruct.PLL.PLLSource = 0;\n  RCC_OscInitStruct.PLL.PLLMUL = 0x380000;\n  HVar1 = HAL_RCC_OscConfig((RCC_OscInitTypeDef_conflict *)&RCC_OscInitStruct);\n  if (HVar1 != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x88);\n  }\n  RCC_ClkInitStruct.ClockType = 0xf;\n  RCC_ClkInitStruct.SYSCLKSource = 2;\n  RCC_ClkInitStruct.AHBCLKDivider = 0;\n  RCC_ClkInitStruct.APB1CLKDivider = 0x400;\n  RCC_ClkInitStruct.APB2CLKDivider = 0;\n  HVar1 = HAL_RCC_ClockConfig((RCC_ClkInitTypeDef_conflict *)&RCC_ClkInitStruct,2);\n  if (HVar1 != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x95);\n  }\n  PeriphClkInit.PeriphClockSelection = 2;\n  PeriphClkInit.AdcClockSelection = 0x8000;\n  HVar1 = HAL_RCCEx_PeriphCLKConfig((RCC_PeriphCLKInitTypeDef_conflict *)&PeriphClkInit);\n  if (HVar1 != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x9c);\n  }\n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFreq / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001b48": "initialize_clocks_08001b48",
                "uVar2": "hclkFreq"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_RCCEx_PeriphCLKConfig",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_ClockConfig",
                "HAL_SYSTICK_Config",
                "_Error_Handler",
                "HAL_RCC_OscConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001be8": {
            "entrypoint": "0x08001be8",
            "current_name": "initialize_system_08001be8",
            "code": "\nvoid initializeSystem_08001be8(void)\n\n{\n  int index;\n  undefined4 *ptr;\n  code *jumpTable;\n  \n  for (index = 0; (undefined *)(index + 0x20000000) < &_edata; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&_sidata + index);\n  }\n  for (ptr = &completed_8667; ptr < &_ebss; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x8001c1a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08001c1a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001be8": "initialize_system_08001be8",
                "iVar1": "index",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c30": {
            "entrypoint": "0x08001c30",
            "current_name": "keep_looping_08001c30",
            "code": "\nvoid keep_looping_08001c30(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08001c30": "keep_looping_08001c30"
            },
            "calling": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "called": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c32": {
            "entrypoint": "0x08001c32",
            "current_name": "initialize_context_08001c32",
            "code": "\nint initialize_context_08001c32(EVP_PKEY_CTX *context)\n\n{\n  hw_config_init();\n  return (int)context;\n}\n\n",
            "renaming": {
                "FUN_08001c32": "initialize_context_08001c32",
                "ctx": "context"
            },
            "calling": [
                "premain"
            ],
            "called": [
                "hw_config_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c3a": {
            "entrypoint": "0x08001c3a",
            "current_name": "FUNC_08001c3a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001c3a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001c3a": "FUNC_08001c3a"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001c3c": {
            "entrypoint": "0x08001c3c",
            "current_name": "configure_sys_tick_08001c3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureSysTick_08001c3c(uint32_t priority)\n\n{\n  uint32_t configStatus;\n  \n  configStatus = HAL_SYSTICK_Config((uint32_t)((ulonglong)SystemCoreClock / (1000 / (ulonglong)uwTickFreq))\n                            );\n  if (configStatus != 0) {\n    return HAL_ERROR;\n  }\n  if (0xf < priority) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn,priority,0);\n  uwTickPrio = priority;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001c3c": "configure_sys_tick_08001c3c",
                "TickPriority": "priority",
                "uVar1": "configStatus"
            },
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c88": {
            "entrypoint": "0x08001c88",
            "current_name": "initialize_hardware_08001c88",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeHardware_08001c88(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  setPriorityGrouping(3);\n  initializeTick(0xf);\n  initializeMSP();\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001c88": "initialize_hardware_08001c88",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializeMSP"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cac": {
            "entrypoint": "0x08001cac",
            "current_name": "update_tick_value_08001cac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateTickValue_08001cac(void)\n\n{\n  currentTickValue = tickFrequency + currentTickValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cac": "update_tick_value_08001cac",
                "uwTick": "currentTickValue",
                "uwTickFreq": "tickFrequency"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cc4": {
            "entrypoint": "0x08001cc4",
            "current_name": "get_system_tick_08001cc4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemTick_08001cc4(void)\n\n{\n  return systemTick;\n}\n\n",
            "renaming": {
                "FUN_08001cc4": "get_system_tick_08001cc4",
                "uwTick": "systemTick"
            },
            "calling": [
                "HAL_RCCEx_PeriphCLKConfig",
                "ADC_ConversionStop_Disable",
                "HAL_ADC_PollForConversion",
                "GetCurrentMilli",
                "HAL_RCC_ClockConfig",
                "HAL_ADCEx_Calibration_Start",
                "UART_WaitOnFlagUntilTimeout",
                "HAL_UART_Transmit",
                "ADC_Enable",
                "HAL_RCC_OscConfig",
                "uart_debug_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cd0": {
            "entrypoint": "0x08001cd0",
            "current_name": "perform_adc_conversion_08001cd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict performADCConversion_08001cd0(ADC_HandleTypeDef *adcHandle,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t startTick;\n  uint32_t periphCLKFreq;\n  int sampleDelay;\n  uint32_t sysClock;\n  ADC_TypeDef *adcInstance;\n  uint cpuCycles;\n  uint32_t conversionTimeoutCycles;\n  \n  conversionTimeoutCycles = 0;\n  startTick = HAL_GetTick();\n  sysClock = SystemCoreClock;\n  adcInstance = adcHandle->Instance;\n  if ((adcInstance->CR2 & 0x100) == 0) {\n    if (((adcInstance->CR1 & 0x100) == 0) && ((adcInstance->SQR1 & 0xf00000) == 0)) {\n      do {\n        if ((adcHandle->Instance->SR & 2) != 0) goto LAB_08001de2;\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (sysClock = HAL_GetTick(), sysClock - startTick <= timeout))));\n      adcHandle->State = adcHandle->State | 4;\n      adcHandle->Lock = HAL_UNLOCKED;\n      status = HAL_TIMEOUT;\n    }\n    else {\n      periphCLKFreq = HAL_RCCEx_GetPeriphCLKFreq(2);\n      adcInstance = adcHandle->Instance;\n      if (((adcInstance->SMPR2 & 0x24924924) == 0) && ((adcInstance->SMPR1 & 0x924924) == 0)) {\n        if ((adcInstance->SMPR2 & 0x12492492) == 0) {\n          if ((adcInstance->SMPR1 & 0x492492) == 0) {\n            sampleDelay = 0x14;\n          }\n          else {\n            sampleDelay = 0x29;\n          }\n        }\n        else {\n          sampleDelay = 0x29;\n        }\n      }\n      else if (((adcInstance->SMPR2 & 0x12492492) == 0) && ((adcInstance->SMPR1 & 0x492492) == 0)) {\n        sampleDelay = 0x54;\n      }\n      else if ((adcInstance->SMPR2 & 0x249249) == 0) {\n        if ((adcInstance->SMPR1 & 0x249249) == 0) {\n          sampleDelay = 0x54;\n        }\n        else {\n          sampleDelay = 0xfc;\n        }\n      }\n      else {\n        sampleDelay = 0xfc;\n      }\n      cpuCycles = (sysClock / periphCLKFreq) * sampleDelay;\n      for (; conversionTimeoutCycles <= cpuCycles && cpuCycles - conversionTimeoutCycles != 0;\n          conversionTimeoutCycles = conversionTimeoutCycles + 1) {\n        if ((timeout != 0xffffffff) &&\n           ((timeout == 0 || (sysClock = HAL_GetTick(), timeout < sysClock - startTick)))) {\n          adcHandle->State = adcHandle->State | 4;\n          adcHandle->Lock = HAL_UNLOCKED;\n          return HAL_TIMEOUT;\n        }\n      }\nLAB_08001de2:\n      adcHandle->Instance->SR = 0xffffffed;\n      adcHandle->State = adcHandle->State | 0x200;\n      if ((adcHandle->Instance->CR2 & 0xe0000) == 0xe0000) {\n        if ((adcHandle->Init).ContinuousConvMode == 0) {\n          adcHandle->State = adcHandle->State & 0xfffffeff;\n          if ((adcHandle->State & 0x1000) == 0) {\n            adcHandle->State = adcHandle->State | 1;\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        status = HAL_OK;\n      }\n    }\n  }\n  else {\n    adcHandle->State = adcHandle->State | 0x20;\n    adcHandle->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001cd0": "perform_adc_conversion_08001cd0",
                "hadc": "adcHandle",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "startTick",
                "uVar3": "periphCLKFreq",
                "iVar4": "sampleDelay",
                "uVar5": "sysClock",
                "pAVar6": "adcInstance",
                "uVar7": "cpuCycles",
                "Conversion_Timeout_CPU_cycles": "conversionTimeoutCycles"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e40": {
            "entrypoint": "0x08001e40",
            "current_name": "get_adc_data_08001e40",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_ADC_data_08001e40(ADC_HandleTypeDef *adc_handle)\n\n{\n  return adc_handle->adc_instance->data_register;\n}\n\n",
            "renaming": {
                "FUN_08001e40": "get_adc_data_08001e40",
                "hadc": "adc_handle",
                "Instance": "adc_instance",
                "DR": "data_register"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e48": {
            "entrypoint": "0x08001e48",
            "current_name": "configure_adc_channel_08001e48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureADCChannel_08001e48(ADC_HandleTypeDef *adcHandle,ADC_ChannelConfTypeDef *channelConfig)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint rankOffset;\n  uint32_t loopIndex;\n  \n  if (adcHandle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    adcHandle->Lock = HAL_LOCKED;\n    rankOffset = channelConfig->Rank;\n    if (rankOffset < 7) {\n      rankOffset = rankOffset * 5 - 5;\n      adcHandle->Instance->SQR3 =\n           channelConfig->Channel << (rankOffset & 0xff) | adcHandle->Instance->SQR3 & ~(0x1f << (rankOffset & 0xff));\n    }\n    else if (rankOffset < 0xd) {\n      rankOffset = rankOffset * 5 - 0x23;\n      adcHandle->Instance->SQR2 =\n           channelConfig->Channel << (rankOffset & 0xff) | adcHandle->Instance->SQR2 & ~(0x1f << (rankOffset & 0xff));\n    }\n    else {\n      rankOffset = rankOffset * 5 - 0x41;\n      adcHandle->Instance->SQR1 =\n           channelConfig->Channel << (rankOffset & 0xff) | adcHandle->Instance->SQR1 & ~(0x1f << (rankOffset & 0xff));\n    }\n    rankOffset = channelConfig->Channel;\n    if (rankOffset < 10) {\n      adcHandle->Instance->SMPR2 =\n           channelConfig->SamplingTime << (rankOffset * 3 & 0xff) |\n           adcHandle->Instance->SMPR2 & ~(7 << (rankOffset * 3 & 0xff));\n    }\n    else {\n      rankOffset = rankOffset * 3 - 0x1e;\n      adcHandle->Instance->SMPR1 =\n           channelConfig->SamplingTime << (rankOffset & 0xff) | adcHandle->Instance->SMPR1 & ~(7 << (rankOffset & 0xff));\n    }\n    if (channelConfig->Channel - 0x10 < 2) {\n      if (adcHandle->Instance == (ADC_TypeDef *)0x40012400) {\n        if ((uRam40012408 & 0x800000) == 0) {\n          uRam40012408 = uRam40012408 | 0x800000;\n          if (channelConfig->Channel == 0x10) {\n            for (loopIndex = (SystemCoreClock / 1000000) * 10; loopIndex != 0;\n                loopIndex = loopIndex - 1) {\n            }\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        adcHandle->State = adcHandle->State | 0x20;\n        status = HAL_ERROR;\n      }\n    }\n    else {\n      status = HAL_OK;\n    }\n    adcHandle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001e48": "configure_adc_channel_08001e48",
                "hadc": "adcHandle",
                "sConfig": "channelConfig",
                "HVar1": "status",
                "uVar2": "rankOffset",
                "wait_loop_index": "loopIndex"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f80": {
            "entrypoint": "0x08001f80",
            "current_name": "get_state_of_adc_08001f80",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getStateOfADC_08001f80(ADC_HandleTypeDef *adcHandle)\n\n{\n  return adcHandle->State;\n}\n\n",
            "renaming": {
                "FUN_08001f80": "get_state_of_adc_08001f80",
                "hadc": "adcHandle"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f84": {
            "entrypoint": "0x08001f84",
            "current_name": "initialize_adc_08001f84",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeADC_08001f84(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t startTime;\n  uint32_t currentTime;\n  ADC_TypeDef *adcInstance;\n  uint32_t loopIndex;\n  \n  adcInstance = adcHandle->Instance;\n  if ((adcInstance->CR2 & 1) == 0) {\n    adcInstance->CR2 = adcInstance->CR2 | 1;\n    for (loopIndex = SystemCoreClock / 1000000; loopIndex != 0;\n        loopIndex = loopIndex - 1) {\n    }\n    startTime = HAL_GetTick();\n    do {\n      if ((adcHandle->Instance->CR2 & 1) != 0) {\n        return HAL_OK;\n      }\n      currentTime = HAL_GetTick();\n    } while (currentTime - startTime < 3);\n    adcHandle->State = adcHandle->State | 0x10;\n    adcHandle->ErrorCode = adcHandle->ErrorCode | 1;\n    adcHandle->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  else {\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001f84": "initialize_adc_08001f84",
                "hadc": "adcHandle",
                "HVar1": "status",
                "uVar2": "startTime",
                "uVar3": "currentTime",
                "pAVar4": "adcInstance",
                "wait_loop_index": "loopIndex"
            },
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Start"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002004": {
            "entrypoint": "0x08002004",
            "current_name": "initialize_adc_08002004",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeADC_08002004(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  ADC_TypeDef *adcInstance;\n  \n  if (adcHandle->Lock != HAL_LOCKED) {\n    adcHandle->Lock = HAL_LOCKED;\n    status = ADC_Enable(adcHandle);\n    if (status == HAL_OK) {\n      adcHandle->State = adcHandle->State & 0xfffffcfe | 0x100;\n      adcInstance = adcHandle->Instance;\n      if ((adcInstance == (ADC_TypeDef *)0x40012800) && ((_DAT_40012404 & 0xf0000) != 0)) {\n        adcHandle->State = adcHandle->State | 0x100000;\n        if ((_DAT_40012404 & 0x400) != 0) {\n          adcHandle->State = adcHandle->State & 0xffffcfff | 0x1000;\n        }\n      }\n      else {\n        adcHandle->State = adcHandle->State & 0xffefffff;\n        if ((adcInstance->CR1 & 0x400) != 0) {\n          adcHandle->State = adcHandle->State & 0xffffcfff | 0x1000;\n        }\n      }\n      if ((adcHandle->State & 0x1000) == 0) {\n        adcHandle->ErrorCode = 0;\n      }\n      else {\n        adcHandle->ErrorCode = adcHandle->ErrorCode & 0xfffffff9;\n      }\n      adcHandle->Lock = HAL_UNLOCKED;\n      adcInstance->SR = 0xfffffffd;\n      adcInstance = adcHandle->Instance;\n      if (((adcInstance->CR2 & 0xe0000) == 0xe0000) &&\n         ((adcInstance != (ADC_TypeDef *)0x40012800 || ((_DAT_40012404 & 0xf0000) == 0)))) {\n        adcInstance->CR2 = adcInstance->CR2 | 0x500000;\n      }\n      else {\n        adcInstance->CR2 = adcInstance->CR2 | 0x100000;\n      }\n    }\n    else {\n      adcHandle->Lock = HAL_UNLOCKED;\n    }\n    return status;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_08002004": "initialize_adc_08002004",
                "hadc": "adcHandle",
                "HVar1": "status",
                "pAVar2": "adcInstance"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_Enable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080020f0": {
            "entrypoint": "0x080020f0",
            "current_name": "check_adc_status_080020f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict checkADCStatus_080020f0(ADC_HandleTypeDef *adcHandle)\n\n{\n  uint32_t startTime;\n  uint32_t currentTime;\n  ADC_TypeDef *adcInstance;\n  \n  adcInstance = adcHandle->Instance;\n  if ((adcInstance->CR2 & 1) == 0) {\n    return HAL_OK;\n  }\n  adcInstance->CR2 = adcInstance->CR2 & 0xfffffffe;\n  startTime = HAL_GetTick();\n  do {\n    if ((adcHandle->Instance->CR2 & 1) == 0) {\n      return HAL_OK;\n    }\n    currentTime = HAL_GetTick();\n  } while (currentTime - startTime < 3);\n  adcHandle->State = adcHandle->State | 0x10;\n  adcHandle->ErrorCode = adcHandle->ErrorCode | 1;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_080020f0": "check_adc_status_080020f0",
                "hadc": "adcHandle",
                "uVar1": "startTime",
                "uVar2": "currentTime",
                "pAVar3": "adcInstance"
            },
            "calling": [
                "HAL_ADC_DeInit",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Stop",
                "HAL_ADC_Init"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800213c": {
            "entrypoint": "0x0800213c",
            "current_name": "initialize_adc_0800213c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeADC_0800213c(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t tempVar1;\n  uint tempVar2;\n  uint tempVar3;\n  uint32_t tempVar4;\n  \n  if (adcHandle == (ADC_HandleTypeDef *)0x0) {\n    return HAL_ERROR;\n  }\n  if (adcHandle->State == 0) {\n    adcHandle->ErrorCode = 0;\n    adcHandle->Lock = HAL_UNLOCKED;\n    HAL_ADC_MspInit(adcHandle);\n  }\n  status = ADC_ConversionStop_Disable(adcHandle);\n  if (((adcHandle->State & 0x10) == 0) && (status == HAL_OK)) {\n    adcHandle->State = adcHandle->State & 0xffffeefd | 2;\n    tempVar4 = (adcHandle->Init).ContinuousConvMode;\n    tempVar2 = (adcHandle->Init).DataAlign | (adcHandle->Init).ExternalTrigConv | tempVar4 << 1;\n    tempVar1 = (adcHandle->Init).ScanConvMode;\n    if (tempVar1 == 0x100) {\n      tempVar3 = 0x100;\n    }\n    else {\n      tempVar3 = 0;\n      if (tempVar1 == 1) {\n        tempVar3 = 0x100;\n      }\n    }\n    if ((adcHandle->Init).DiscontinuousConvMode == 1) {\n      if (tempVar4 == 0) {\n        tempVar3 = tempVar3 | ((adcHandle->Init).NbrOfDiscConversion - 1) * 0x2000 | 0x800;\n      }\n      else {\n        adcHandle->State = adcHandle->State | 0x20;\n        adcHandle->ErrorCode = adcHandle->ErrorCode | 1;\n      }\n    }\n    adcHandle->Instance->CR1 = tempVar3 | adcHandle->Instance->CR1 & 0xffff16ff;\n    adcHandle->Instance->CR2 = adcHandle->Instance->CR2 & 0xffe1f7fd | tempVar2;\n    tempVar1 = (adcHandle->Init).ScanConvMode;\n    if ((tempVar1 == 0x100) || (tempVar1 == 1)) {\n      tempVar3 = ((adcHandle->Init).NbrOfConversion - 1) * 0x100000;\n    }\n    else {\n      tempVar3 = 0;\n    }\n    adcHandle->Instance->SQR1 = tempVar3 | adcHandle->Instance->SQR1 & 0xff0fffff;\n    if (tempVar2 != (adcHandle->Instance->CR2 & 0xff1f0efe)) {\n      adcHandle->State = adcHandle->State & 0xffffffed | 0x10;\n      adcHandle->ErrorCode = adcHandle->ErrorCode | 1;\n      return HAL_ERROR;\n    }\n    adcHandle->ErrorCode = 0;\n    adcHandle->State = adcHandle->State & 0xfffffffc | 1;\n    return HAL_OK;\n  }\n  adcHandle->State = adcHandle->State | 0x10;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_0800213c": "initialize_adc_0800213c",
                "hadc": "adcHandle",
                "HVar1": "status",
                "uVar2": "tempVar1",
                "uVar3": "tempVar2",
                "uVar4": "tempVar3",
                "uVar5": "tempVar4"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800224c": {
            "entrypoint": "0x0800224c",
            "current_name": "disable_adc_conversion_0800224c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict disableADCConversion_0800224c(ADCHandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  \n  if (adcHandle == (ADCHandleTypeDef *)0x0) {\n    status = HAL_ERROR;\n  }\n  else {\n    adcHandle->state = adcHandle->state | 2;\n    status = disableADCConversion_0800224cStop(adcHandle);\n    if (status == HAL_OK) {\n      adcHandle->adcInstance->statusRegister = 0xffffffe0;\n      adcHandle->adcInstance->controlRegister1 = adcHandle->adcInstance->controlRegister1 & 0xff3f0000;\n      adcHandle->adcInstance->controlRegister2 = adcHandle->adcInstance->controlRegister2 & 0xff0106f0;\n      adcHandle->adcInstance->sampleRateRegister1 = adcHandle->adcInstance->sampleRateRegister1 & 0xff000000;\n      adcHandle->adcInstance->sampleRateRegister2 = adcHandle->adcInstance->sampleRateRegister2 & 0xc0000000;\n      adcHandle->adcInstance->jofr1 = adcHandle->adcInstance->jofr1 & 0xfffff000;\n      adcHandle->adcInstance->jofr2 = adcHandle->adcInstance->jofr2 & 0xfffff000;\n      adcHandle->adcInstance->jofr3 = adcHandle->adcInstance->jofr3 & 0xfffff000;\n      adcHandle->adcInstance->jofr4 = adcHandle->adcInstance->jofr4 & 0xfffff000;\n      adcHandle->adcInstance->highThreshold = adcHandle->adcInstance->highThreshold & 0xfffff000;\n      adcHandle->adcInstance->lowThreshold = adcHandle->adcInstance->lowThreshold & 0xfffff000;\n      adcHandle->adcInstance->sequenceRegister1 = adcHandle->adcInstance->sequenceRegister1 & 0xff000000;\n      adcHandle->adcInstance->sequenceRegister1 = adcHandle->adcInstance->sequenceRegister1 & 0xff000000;\n      adcHandle->adcInstance->sequenceRegister2 = adcHandle->adcInstance->sequenceRegister2 & 0xc0000000;\n      adcHandle->adcInstance->sequenceRegister3 = adcHandle->adcInstance->sequenceRegister3 & 0xc0000000;\n      adcHandle->adcInstance->jsequenceRegister = adcHandle->adcInstance->jsequenceRegister & 0xffc00000;\n      adcHandle->adcInstance->jsequenceRegister = adcHandle->adcInstance->jsequenceRegister & 0xffc00000;\n      HAL_ADC_MspDeInit(adcHandle);\n      adcHandle->errorCode = 0;\n      adcHandle->state = 0;\n    }\n    adcHandle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800224c": "disable_adc_conversion_0800224c",
                "hadc": "adcHandle",
                "HVar1": "status",
                "ADC_HandleTypeDef": "ADCHandleTypeDef",
                "State": "state",
                "ADC_ConversionStop_Disable": "disableADCConversionStop",
                "Instance": "adcInstance",
                "SR": "statusRegister",
                "CR1": "controlRegister1",
                "CR2": "controlRegister2",
                "SMPR1": "sampleRateRegister1",
                "SMPR2": "sampleRateRegister2",
                "JOFR1": "jofr1",
                "JOFR2": "jofr2",
                "JOFR3": "jofr3",
                "JOFR4": "jofr4",
                "HTR": "highThreshold",
                "LTR": "lowThreshold",
                "SQR1": "sequenceRegister1",
                "SQR2": "sequenceRegister2",
                "SQR3": "sequenceRegister3",
                "JSQR": "jsequenceRegister",
                "ErrorCode": "errorCode"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002348": {
            "entrypoint": "0x08002348",
            "current_name": "stop_adc_conversion_08002348",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict stopADCConversion_08002348(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  \n  if (adcHandle->Lock == locked) {\n    return busy;\n  }\n  adcHandle->Lock = locked;\n  status = disableADCConversionStop(adcHandle);\n  if (status == ok) {\n    adcHandle->state = adcHandle->state & 0xffffeefe | 1;\n  }\n  adcHandle->Lock = unlocked;\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002348": "stop_adc_conversion_08002348",
                "hadc": "adcHandle",
                "HVar1": "status",
                "HAL_LOCKED": "locked",
                "HAL_BUSY": "busy",
                "HAL_OK": "ok",
                "ADC_ConversionStop_Disable": "disableADCConversionStop",
                "State": "state",
                "HAL_UNLOCKED": "unlocked"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002384": {
            "entrypoint": "0x08002384",
            "current_name": "convert_and_enable_adc_08002384",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict convertAndEnableADC_08002384(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t clockFreq;\n  uint32_t coreClock;\n  ADC_TypeDef *adcType;\n  uint32_t startTick;\n  uint32_t loopIndex;\n  \n  if (adcHandle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  adcHandle->Lock = HAL_LOCKED;\n  status = ADC_ConversionStop_Disable(adcHandle);\n  if (status == HAL_OK) {\n    adcHandle->State = adcHandle->State & 0xffffeefd | 2;\n    coreClock = SystemCoreClock;\n    clockFreq = HAL_RCCEx_GetPeriphCLKFreq(2);\n    for (loopIndex = coreClock / clockFreq << 1; loopIndex != 0;\n        loopIndex = loopIndex - 1) {\n    }\n    ADC_Enable(adcHandle);\n    adcHandle->Instance->CR2 = adcHandle->Instance->CR2 | 8;\n    coreClock = HAL_GetTick();\n    while (adcType = adcHandle->Instance, (adcType->CR2 & 8) != 0) {\n      clockFreq = HAL_GetTick();\n      if (10 < clockFreq - coreClock) {\n        adcHandle->State = adcHandle->State & 0xffffffed | 0x10;\n        adcHandle->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adcType->CR2 = adcType->CR2 | 4;\n    coreClock = HAL_GetTick();\n    while ((adcHandle->Instance->CR2 & 4) != 0) {\n      clockFreq = HAL_GetTick();\n      if (10 < clockFreq - coreClock) {\n        adcHandle->State = adcHandle->State & 0xffffffed | 0x10;\n        adcHandle->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adcHandle->State = adcHandle->State & 0xfffffffc | 1;\n  }\n  adcHandle->Lock = HAL_UNLOCKED;\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002384": "convert_and_enable_adc_08002384",
                "hadc": "adcHandle",
                "HVar1": "status",
                "uVar2": "clockFreq",
                "uVar3": "coreClock",
                "pAVar4": "adcType",
                "tickstart": "startTick",
                "wait_loop_index": "loopIndex"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_GetTick",
                "ADC_ConversionStop_Disable",
                "HAL_RCCEx_GetPeriphCLKFreq",
                "ADC_Enable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002470": {
            "entrypoint": "0x08002470",
            "current_name": "configure_priority_group_08002470",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configurePriorityGroup_08002470(uint32_t newPriorityGroup)\n\n{\n  uint32_t registerValue;\n  \n  _DAT_e000ed0c = (newPriorityGroup & 7) << 8 | _DAT_e000ed0c & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002470": "configure_priority_group_08002470",
                "PriorityGroup": "newPriorityGroup",
                "reg_value": "registerValue"
            },
            "calling": [
                "premain",
                "HAL_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002494": {
            "entrypoint": "0x08002494",
            "current_name": "set_interrupt_priority_08002494",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setInterruptPriority_08002494(interrupt_Type_conflict interrupt,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint irqNumber;\n  uint priorityGroup;\n  uint32_t priorityGroupTmp;\n  uint32_t subPriorityBits;\n  uint32_t preemptPriorityBits;\n  \n  irqNumber = (uint)interrupt;\n  priorityGroup = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  preemptPriorityBits = 7 - priorityGroup;\n  if (3 < preemptPriorityBits) {\n    preemptPriorityBits = 4;\n  }\n  if (priorityGroup + 4 < 7) {\n    subPriorityBits = 0;\n  }\n  else {\n    subPriorityBits = priorityGroup - 3;\n  }\n  priorityGroup = (preemptPriority & (1 << (preemptPriorityBits & 0xff)) - 1U) << (subPriorityBits & 0xff) |\n          (1 << (subPriorityBits & 0xff)) - 1U & subPriority;\n  if ((int)irqNumber < 0) {\n    *(char *)((irqNumber & 0xf) + 0xe000ed14) = (char)(priorityGroup << 4);\n  }\n  else {\n    *(char *)(irqNumber + 0xe000e400) = (char)(priorityGroup << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002494": "set_interrupt_priority_08002494",
                "IRQn": "interrupt",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "uVar1": "irqNumber",
                "uVar2": "priorityGroup",
                "PriorityGroupTmp": "priorityGroupTmp",
                "SubPriorityBits": "subPriorityBits",
                "PreemptPriorityBits": "preemptPriorityBits"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback",
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080024f8": {
            "entrypoint": "0x080024f8",
            "current_name": "set_interrupt_flag_080024f8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setInterruptFlag_080024f8(interruptNumber_Type_conflict interruptNumber)\n\n{\n  uint convertedNumber;\n  \n  convertedNumber = (uint)interruptNumber;\n  if (-1 < (int)convertedNumber) {\n    *(int *)((convertedNumber >> 5) * 4 + -0x1fff1f00) = 1 << (convertedNumber & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080024f8": "set_interrupt_flag_080024f8",
                "IRQn": "interruptNumber",
                "uVar1": "convertedNumber"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002514": {
            "entrypoint": "0x08002514",
            "current_name": "initialize_timer_08002514",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t initializeTimer_08002514(uint32_t tickCount)\n\n{\n  if (tickCount - 1 < 0x1000000) {\n    _DAT_e000e014 = tickCount - 1;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002514": "initialize_timer_08002514",
                "TicksNumb": "tickCount"
            },
            "calling": [
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002540": {
            "entrypoint": "0x08002540",
            "current_name": "set_interrupt_enable_bit_08002540",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setInterruptEnableBit_08002540(interruptNumber IRQn)\n\n{\n  uint interruptIndex;\n  \n  interruptIndex = (uint)IRQn;\n  if (-1 < (int)interruptIndex) {\n    *(int *)(((interruptIndex >> 5) + 0x60) * 4 + -0x1fff1f00) = 1 << (interruptIndex & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002540": "set_interrupt_enable_bit_08002540",
                "IRQn_Type_conflict": "interruptNumber",
                "uVar1": "interruptIndex"
            },
            "calling": [
                "USART2_IRQHandler",
                "USART3_IRQHandler",
                "USART1_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002560": {
            "entrypoint": "0x08002560",
            "current_name": "set_clock_source_08002560",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setClockSource_08002560(uint32_t source)\n\n{\n  if (source != 4) {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n    return;\n  }\n  _DAT_e000e010 = _DAT_e000e010 | 4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002560": "set_clock_source_08002560",
                "CLKSource": "source"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002580": {
            "entrypoint": "0x08002580",
            "current_name": "FUNC_08002580",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002580(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002580": "FUNC_08002580"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002582": {
            "entrypoint": "0x08002582",
            "current_name": "handle_sys_tick_interrupt_08002582",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickInterrupt_08002582(void)\n\n{\n  handleSysTickCallback();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002582": "handle_sys_tick_interrupt_08002582",
                "HAL_SYSTICK_Callback": "handleSysTickCallback"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800258c": {
            "entrypoint": "0x0800258c",
            "current_name": "set_dma_channel_priority_0800258c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict set_dma_channel_priority_0800258c(DMA_HandleTypeDef *dma_handle)\n\n{\n  DMA_Channel_TypeDef *dma_instance;\n  \n  if (dma_handle->dma_state != DMA_STATE_BUSY) {\n    dma_handle->error_code = 4;\n    return HAL_ERROR;\n  }\n  dma_handle->dma_channel_instance->dma_channel_ctrl_reg = dma_handle->dma_channel_instance->dma_channel_ctrl_reg & 0xfffffff1;\n  dma_handle->dma_channel_instance->dma_channel_ctrl_reg = dma_handle->dma_channel_instance->dma_channel_ctrl_reg & 0xfffffffe;\n  dma_instance = dma_handle->dma_channel_instance;\n  if (dma_instance == (DMA_Channel_TypeDef *)0x40020008) {\n    _DAT_40020004 = 1;\n  }\n  else if (dma_instance == (DMA_Channel_TypeDef *)0x4002001c) {\n    _DAT_40020004 = 0x10;\n  }\n  else if (dma_instance == (DMA_Channel_TypeDef *)0x40020030) {\n    _DAT_40020004 = 0x100;\n  }\n  else if (dma_instance == (DMA_Channel_TypeDef *)0x40020044) {\n    _DAT_40020004 = 0x1000;\n  }\n  else if (dma_instance == (DMA_Channel_TypeDef *)0x40020058) {\n    _DAT_40020004 = 0x10000;\n  }\n  else if (dma_instance == (DMA_Channel_TypeDef *)0x4002006c) {\n    _DAT_40020004 = 0x100000;\n  }\n  else {\n    _DAT_40020004 = 0x1000000;\n  }\n  dma_handle->dma_state = DMA_STATE_READY;\n  dma_handle->Lock = HAL_UNLOCKED;\n  if (dma_handle->transfer_abort_callback != (callback_function *)0x0) {\n    (*dma_handle->transfer_abort_callback)(dma_handle);\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800258c": "set_dma_channel_priority_0800258c",
                "hdma": "dma_handle",
                "pDVar1": "dma_instance",
                "State": "dma_state",
                "ErrorCode": "error_code",
                "Instance": "dma_channel_instance",
                "CCR": "dma_channel_ctrl_reg",
                "XferAbortCallback": "transfer_abort_callback",
                "HAL_DMA_STATE_BUSY": "DMA_STATE_BUSY",
                "HAL_DMA_STATE_READY": "DMA_STATE_READY",
                "_func_void___DMA_HandleTypeDef_ptr": "callback_function"
            },
            "calling": [
                "I2C_ITError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002624": {
            "entrypoint": "0x08002624",
            "current_name": "configure_gpio_08002624",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureGPIO_08002624(GPIOStructure *GPIOx,GPIOInitializer *GPIO_Init)\n\n{\n  GPIOStructure *configuredGPIO;\n  uint pinMask;\n  uint pinVal;\n  uint i;\n  uint mode;\n  uint32_t speed;\n  int bitShift;\n  uint32_t *configRegister;\n  int portIndex;\n  uint32_t tempReg;\n  \n  speed = 0;\n  i = 0;\n  do {\n    if (0xf < i) {\n      return;\n    }\n    pinMask = 1 << (i & 0xff);\n    pinVal = GPIO_Init->Pin & pinMask;\n    if (pinMask == pinVal) {\n      mode = GPIO_Init->Mode;\n      if (mode == 0x12) {\n        speed = GPIO_Init->Speed + 0xc;\n      }\n      else if (mode < 0x13) {\n        if (mode == 2) {\n          speed = GPIO_Init->Speed + 8;\n        }\n        else if (mode < 3) {\n          if (mode == 0) goto LAB_08002776;\n          if (mode == 1) {\n            speed = GPIO_Init->Speed;\n          }\n        }\n        else if (mode == 3) {\n          speed = 0;\n        }\n        else if (mode == 0x11) {\n          speed = GPIO_Init->Speed + 4;\n        }\n      }\n      else if (mode == 0x10210000) {\nLAB_08002776:\n        if (GPIO_Init->Pull == 0) {\n          speed = 4;\n        }\n        else if (GPIO_Init->Pull == 1) {\n          GPIOx->BSRR = pinMask;\n          speed = 8;\n        }\n        else {\n          GPIOx->BRR = pinMask;\n          speed = 8;\n        }\n      }\n      else if (mode < 0x10210001) {\n        if ((mode == 0x10110000) || (mode == 0x10120000)) goto LAB_08002776;\n      }\n      else if ((mode == 0x10310000) || ((mode == 0x10320000 || (mode == 0x10220000))))\n      goto LAB_08002776;\n      pinMask = i;\n      configuredGPIO = GPIOx;\n      if (0xff < pinVal) {\n        pinMask = i - 8;\n        configuredGPIO = (GPIOStructure *)&GPIOx->CRH;\n      }\n      configuredGPIO->CRL = configuredGPIO->CRL & ~(0xf << (pinMask << 2 & 0xff)) | speed << (pinMask << 2 & 0xff);\n      if ((GPIO_Init->Mode & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        bitShift = (i & 3) << 2;\n        if (GPIOx == (GPIOStructure *)0x40010800) {\n          portIndex = 0;\n        }\n        else if (GPIOx == (GPIOStructure *)0x40010c00) {\n          portIndex = 1;\n        }\n        else if (GPIOx == (GPIOStructure *)0x40011000) {\n          portIndex = 2;\n        }\n        else if (GPIOx == (GPIOStructure *)0x40011400) {\n          portIndex = 3;\n        }\n        else {\n          portIndex = 4;\n        }\n        *(uint *)(((i >> 2) + 2) * 4 + 0x40010000) =\n             *(uint *)(((i >> 2) + 2) * 4 + 0x40010000) & ~(0xf << bitShift) | portIndex << bitShift;\n        if ((GPIO_Init->Mode & 0x10000) == 0) {\n          _DAT_40010400 = _DAT_40010400 & ~pinVal;\n        }\n        else {\n          _DAT_40010400 = _DAT_40010400 | pinVal;\n        }\n        if ((GPIO_Init->Mode & 0x20000) == 0) {\n          _DAT_40010404 = _DAT_40010404 & ~pinVal;\n        }\n        else {\n          _DAT_40010404 = _DAT_40010404 | pinVal;\n        }\n        if ((GPIO_Init->Mode & 0x100000) == 0) {\n          _DAT_40010408 = _DAT_40010408 & ~pinVal;\n        }\n        else {\n          _DAT_40010408 = _DAT_40010408 | pinVal;\n        }\n        if ((GPIO_Init->Mode & 0x200000) == 0) {\n          _DAT_4001040c = _DAT_4001040c & ~pinVal;\n        }\n        else {\n          _DAT_4001040c = pinVal | _DAT_4001040c;\n        }\n      }\n    }\n    i = i + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08002624": "configure_gpio_08002624",
                "GPIO_TypeDef": "GPIOStructure",
                "GPIO_InitTypeDef": "GPIOInitializer",
                "pGVar1": "configuredGPIO",
                "uVar2": "pinMask",
                "uVar3": "pinVal",
                "uVar4": "i",
                "uVar5": "mode",
                "uVar6": "speed",
                "configregister": "configRegister",
                "iVar7": "bitShift",
                "iVar8": "portIndex",
                "tmpreg": "tempReg"
            },
            "calling": [
                "digital_io_init",
                "uart_init",
                "HAL_ADC_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002810": {
            "entrypoint": "0x08002810",
            "current_name": "check_pin_state_08002810",
            "code": "\n/* WARNING: Unknown calling convention */\n\npinState checkPinState_08002810(GPIO_TypeDef *port,uint16_t pin)\n\n{\n  pinState state;\n  \n  if (((uint)pin & port->IDR) == 0) {\n    state = GPIO_PIN_RESET;\n    return state;\n  }\n  return GPIO_PIN_SET;\n}\n\n",
            "renaming": {
                "FUN_08002810": "check_pin_state_08002810",
                "GPIOx": "port",
                "GPIO_Pin": "pin",
                "bitstatus": "state"
            },
            "calling": [
                "digital_io_read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800281e": {
            "entrypoint": "0x0800281e",
            "current_name": "set_gpio_state_0800281e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setGPIOState_0800281e(GPIO_TypeDef *port,uint16_t pin,pinState state)\n\n{\n  if (state == GPIO_PIN_RESET) {\n    port->BSRR = (uint)pin << 0x10;\n    return;\n  }\n  port->BSRR = (uint)pin;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800281e": "set_gpio_state_0800281e",
                "GPIOx": "port",
                "GPIO_Pin": "pin",
                "PinState": "state"
            },
            "calling": [
                "digital_io_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800282c": {
            "entrypoint": "0x0800282c",
            "current_name": "handle_gpio_pin_0800282c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_Pin_0800282c(uint16_t pin)\n\n{\n  if ((_DAT_40010414 & pin) != 0) {\n    _DAT_40010414 = (uint)pin;\n    handle_pin_interrupt(pin);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800282c": "handle_gpio_pin_0800282c",
                "GPIO_Pin": "pin",
                "HAL_GPIO_EXTI_Callback": "handle_pin_interrupt"
            },
            "calling": [
                "EXTI4_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI15_10_IRQHandler",
                "EXTI2_IRQHandler",
                "EXTI9_5_IRQHandler",
                "EXTI0_IRQHandler",
                "EXTI1_IRQHandler"
            ],
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002848": {
            "entrypoint": "0x08002848",
            "current_name": "initialize_i2_c_08002848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeI2C_08002848(I2C_HandleTypeDef *i2cHandle)\n\n{\n  if (i2cHandle->operatingMode == memoryMode) {\n    if (i2cHandle->eventCount == 0) {\n      i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xfe;\n    }\n    else {\n      i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xff | 1;\n    }\n  }\n  else if ((i2cHandle->i2cInit).addressingMode == 0x4000) {\n    if (i2cHandle->i2cState == transmitState) {\n      i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xfe;\n    }\n    else {\n      i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xff | 1;\n    }\n  }\n  else if (i2cHandle->eventCount == 0) {\n    i2cHandle->i2cInstance->dataRegister = (i2cHandle->deviceAddress << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (i2cHandle->eventCount == 1) {\n    i2cHandle->i2cInstance->dataRegister = (i2cHandle->deviceAddress << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return HAL_StatusTypeDef_conflict;\n}\n\n",
            "renaming": {
                "FUN_08002848": "initialize_i2_c_08002848",
                "hi2c": "i2cHandle",
                "Mode": "operatingMode",
                "EventCount": "eventCount",
                "Instance": "i2cInstance",
                "DR": "dataRegister",
                "Devaddress": "deviceAddress",
                "Init": "i2cInit",
                "AddressingMode": "addressingMode",
                "State": "i2cState",
                "HAL_I2C_MODE_MEM": "memoryMode",
                "HAL_I2C_STATE_BUSY_TX": "transmitState",
                "HAL_OK": "HAL_StatusTypeDef_conflict"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028d2": {
            "entrypoint": "0x080028d2",
            "current_name": "set_i2_c_device_address_080028d2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict setI2CDeviceAddress_080028d2(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xff;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080028d2": "set_i2_c_device_address_080028d2",
                "hi2c": "i2cHandle",
                "Instance": "i2cInstance",
                "DR": "dataRegister",
                "Devaddress": "deviceAddress"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028de": {
            "entrypoint": "0x080028de",
            "current_name": "process_i2_c_state_080028de",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict processI2CState_080028de(I2C_HandleTypeDef *i2cHandler)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t transferOptions;\n  I2C_TypeDef *i2cInstance;\n  uint32_t previousState;\n  uint32_t tempRegister;\n  uint32_t tempRegister1;\n  uint32_t tempRegister2;\n  uint32_t tempRegister3;\n  uint32_t tempRegister4;\n  uint32_t tempRegister5;\n  uint32_t tempRegister6;\n  uint32_t tempRegister7;\n  uint32_t tempRegister8;\n  uint32_t tempRegister9;\n  uint32_t tempRegister10;\n  \n  transferOptions = i2cHandler->XferOptions;\n  if ((i2cHandler->State == HAL_I2C_STATE_BUSY_RX) &&\n     ((i2cHandler->EventCount != 0 || (i2cHandler->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((i2cHandler->EventCount == 0) && ((i2cHandler->Init).AddressingMode == 0xc000)) {\n      i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 | 0x100;\n      i2cHandler->EventCount = i2cHandler->EventCount + 1;\n    }\n    else {\n      if (i2cHandler->XferCount == 0) {\n        i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 | 0x200;\n      }\n      else if (i2cHandler->XferCount == 1) {\n        if (transferOptions == 0xffff0000) {\n          i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 & 0xfffffbff;\n          i2cInstance = i2cHandler->Instance;\n          if ((i2cInstance->CR2 & 0x800) == 0) {\n            i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n          }\n          else {\n            i2cInstance->CR1 = i2cInstance->CR1 & 0xfffffbff;\n          }\n        }\n        else if (((transferOptions == 4) || (transferOptions == 8)) || (i2cHandler->PreviousState == 0x12)) {\n          i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 & 0xfffffbff;\n          i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 | 0x200;\n        }\n        else if (i2cHandler->XferOptions == 2) {\n          i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 & 0xfffffbff;\n        }\n      }\n      else if (i2cHandler->XferCount == 2) {\n        if (i2cHandler->XferOptions == 2) {\n          i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 | 0x800;\n          i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 & 0xfffffbff;\n        }\n        i2cInstance = i2cHandler->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      else {\n        i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 | 0x400;\n        i2cInstance = i2cHandler->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      i2cHandler->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080028de": "process_i2_c_state_080028de",
                "hi2c": "i2cHandler",
                "CurrentXferOptions": "currentTransferOptions",
                "uVar1": "transferOptions",
                "pIVar2": "i2cInstance",
                "Prev_State": "previousState",
                "tmpreg": "tempRegister",
                "tmpreg_1": "tempRegister1",
                "tmpreg_2": "tempRegister2",
                "tmpreg_3": "tempRegister3",
                "tmpreg_4": "tempRegister4",
                "tmpreg_5": "tempRegister5",
                "tmpreg_6": "tempRegister6",
                "tmpreg_7": "tempRegister7",
                "tmpreg_8": "tempRegister8",
                "tmpreg_9": "tempRegister9",
                "tmpreg_10": "tempRegister10"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ab8": {
            "entrypoint": "0x08002ab8",
            "current_name": "send_byte_08002ab8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict sendByte_08002ab8(I2C_HandleTypeDef *i2cHandler)\n\n{\n  byte *pbVar1;\n  \n  if (i2cHandler->transferCount != 0) {\n    pbVar1 = i2cHandler->bufferPointer;\n    i2cHandler->bufferPointer = pbVar1 + 1;\n    i2cHandler->i2cInstance->dataRegister = (uint)*pbVar1;\n    i2cHandler->transferCount = i2cHandler->transferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002ab8": "send_byte_08002ab8",
                "hi2c": "i2cHandler",
                "XferCount": "transferCount",
                "pBuffPtr": "bufferPointer",
                "Instance": "i2cInstance",
                "DR": "dataRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad8": {
            "entrypoint": "0x08002ad8",
            "current_name": "process_i2_c_data_08002ad8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict processI2CData_08002ad8(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint8_t *bufferPtr;\n  \n  if (i2cHandle->transferCount != 0) {\n    bufferPtr = i2cHandle->bufferPtr;\n    i2cHandle->bufferPtr = bufferPtr + 1;\n    *bufferPtr = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002ad8": "process_i2_c_data_08002ad8",
                "hi2c": "i2cHandle",
                "puVar1": "bufferPtr",
                "XferCount": "transferCount",
                "pBuffPtr": "bufferPtr",
                "Instance": "i2cInstance",
                "DR": "dataRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002af8": {
            "entrypoint": "0x08002af8",
            "current_name": "configure_i2_c_08002af8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nconfigureI2C_08002af8(I2C_HandleTypeDef *i2cHandle,uint8_t *dataBuffer,uint16_t bufferSize,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef *i2cInstance;\n  uint32_t temporaryRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (dataBuffer == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (bufferSize == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = dataBuffer;\n      i2cHandle->XferCount = bufferSize;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->XferbufferSize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002af8": "configure_i2_c_08002af8",
                "hi2c": "i2cHandle",
                "pData": "dataBuffer",
                "Size": "bufferSize",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002b84": {
            "entrypoint": "0x08002b84",
            "current_name": "configure_i2_c_in_listen_mode_08002b84",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nconfigureI2CInListenMode_08002b84(I2C_HandleTypeDef *i2cHandle,uint8_t *dataBuffer,uint16_t dataSize,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef *i2cInstance;\n  uint32_t temporaryRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (dataBuffer == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (dataSize == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = dataBuffer;\n      i2cHandle->XferCount = dataSize;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->XferdataSize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002b84": "configure_i2_c_in_listen_mode_08002b84",
                "hi2c": "i2cHandle",
                "pData": "dataBuffer",
                "Size": "dataSize",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c10": {
            "entrypoint": "0x08002c10",
            "current_name": "initialize_i2_c_08002c10",
            "code": "\n/* WARNING: Unknown calling convention */\n\nI2CStatus initializeI2C_08002c10(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2C_TypeDef *i2cInstance;\n  \n  if (i2cHandle->State != I2C_STATE_READY) {\n    return I2C_BUSY;\n  }\n  i2cHandle->State = I2C_STATE_LISTEN;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR1 & 1) == 0) {\n    i2cInstance->CR1 = i2cInstance->CR1 | 1;\n  }\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n  i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x300;\n  return I2C_OK;\n}\n\n",
            "renaming": {
                "FUN_08002c10": "initialize_i2_c_08002c10",
                "hi2c": "i2cHandle",
                "pIVar1": "i2cInstance",
                "HAL_StatusTypeDef_conflict": "I2CStatus",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_BUSY": "I2C_BUSY",
                "HAL_I2C_STATE_LISTEN": "I2C_STATE_LISTEN",
                "HAL_OK": "I2C_OK"
            },
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c4e": {
            "entrypoint": "0x08002c4e",
            "current_name": "FUNC_08002c4e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002c4e(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c4e": "FUNC_08002c4e"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002c50": {
            "entrypoint": "0x08002c50",
            "current_name": "FUNC_08002c50",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002c50(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c50": "FUNC_08002c50"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002c52": {
            "entrypoint": "0x08002c52",
            "current_name": "FUNC_08002c52",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002c52(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c52": "FUNC_08002c52"
            },
            "calling": [
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_AF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002c54": {
            "entrypoint": "0x08002c54",
            "current_name": "transfer_data_08002c54",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict transferData_08002c54(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  byte *dataPointer;\n  \n  currentState = i2cHandle->State;\n  if (i2cHandle->XferCount != 0) {\n    dataPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = dataPointer + 1;\n    i2cHandle->Instance->DR = (uint)*dataPointer;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    if ((i2cHandle->XferCount == 0) && (currentState == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      i2cHandle->PreviousState = 0x21;\n      i2cHandle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(i2cHandle);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002c54": "transfer_data_08002c54",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "pbVar2": "dataPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca4": {
            "entrypoint": "0x08002ca4",
            "current_name": "FUNC_08002ca4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002ca4(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ca4": "FUNC_08002ca4"
            },
            "calling": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca6": {
            "entrypoint": "0x08002ca6",
            "current_name": "handle_i2_c_data_08002ca6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CData_08002ca6(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_State i2cState;\n  uint8_t *dataPtr;\n  \n  i2cState = hi2c->State;\n  if (hi2c->XferCount != 0) {\n    dataPtr = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = dataPtr + 1;\n    *dataPtr = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n    if ((hi2c->XferCount == 0) && (i2cState == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffbff;\n      hi2c->PreviousState = 0x22;\n      hi2c->State = HAL_I2C_STATE_LISTEN;\n      handleSlaveRxCplt(hi2c);\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002ca6": "handle_i2_c_data_08002ca6",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_I2C_StateTypeDef": "HAL_I2C_State",
                "HVar1": "i2cState",
                "puVar2": "dataPtr",
                "HAL_I2C_SlaveRxCpltCallback": "handleSlaveRxCplt"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002cf2": {
            "entrypoint": "0x08002cf2",
            "current_name": "handle_i2_c_addr_match_08002cf2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CAddrMatch_08002cf2(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint16_t addressMatchCode;\n  \n  if ((i2cHandle->Instance->SR2 & 0x80) == 0) {\n    addressMatchCode = *(uint16_t *)&(i2cHandle->Init).OwnAddress1;\n  }\n  else {\n    addressMatchCode = *(uint16_t *)&(i2cHandle->Init).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(i2cHandle,(i2cHandle->Instance->SR2 & 4) == 0,addressMatchCode);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002cf2": "handle_i2_c_addr_match_08002cf2",
                "hi2c": "i2cHandle",
                "AddrMatchCode": "addressMatchCode"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d1c": {
            "entrypoint": "0x08002d1c",
            "current_name": "handle_i2_c_messages_08002d1c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CMessages_08002d1c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t currentState;\n  \n  if (((i2cHandle->XferOptions == 4) || (i2cHandle->XferOptions == 8)) &&\n     (i2cHandle->State == HAL_I2C_STATE_LISTEN)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandle);\n  }\n  else if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->PreviousState = 0x21;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback(i2cHandle);\n  }\n  else {\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002d1c": "handle_i2_c_messages_08002d1c",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "CurrentState": "currentState"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002db0": {
            "entrypoint": "0x08002db0",
            "current_name": "FUNC_08002db0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002db0(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002db0": "FUNC_08002db0"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002db2": {
            "entrypoint": "0x08002db2",
            "current_name": "handle_i2_c_transfer_08002db2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CTransfer_08002db2(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  uint32_t currentI2CState;\n  byte *bufferPtr;\n  uint32_t currentTransferOptions;\n  uint32_t transferOptions;\n  \n  currentState = i2cHandle->State;\n  transferOptions = i2cHandle->XferOptions;\n  if ((i2cHandle->XferSize == 0) && (currentState == I2C_STATE_BUSY_TRANSMIT)) {\n    if ((transferOptions == 4) || ((transferOptions == 8 || (transferOptions == 0xffff0000)))) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = I2C_STATE_READY;\n      if (i2cHandle->Mode == I2C_MODE_MEMORY) {\n        i2cHandle->Mode = I2C_MODE_NONE;\n        handleI2CMemoryTransmitCompleteCallback(i2cHandle);\n      }\n      else {\n        i2cHandle->Mode = I2C_MODE_NONE;\n        handleI2CMasterTransmitCompleteCallback(i2cHandle);\n      }\n    }\n    else {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n      i2cHandle->PreviousState = 0x11;\n      i2cHandle->Mode = I2C_MODE_NONE;\n      i2cHandle->State = I2C_STATE_READY;\n      handleI2CMasterTransmitCompleteCallback(i2cHandle);\n    }\n  }\n  else if ((currentState == I2C_STATE_BUSY_TRANSMIT) ||\n          ((i2cHandle->Mode == I2C_MODE_MEMORY && (currentState == I2C_STATE_BUSY_RECEIVE)))) {\n    if (i2cHandle->XferCount == 0) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n    }\n    else if (i2cHandle->Mode == I2C_MODE_MEMORY) {\n      if (i2cHandle->EventCount == 0) {\n        if (i2cHandle->MemaddSize == 1) {\n          i2cHandle->Instance->DR = i2cHandle->Memaddress & 0xff;\n          i2cHandle->EventCount = i2cHandle->EventCount + 2;\n        }\n        else {\n          i2cHandle->Instance->DR = (i2cHandle->Memaddress << 0x10) >> 0x18;\n          i2cHandle->EventCount = i2cHandle->EventCount + 1;\n        }\n      }\n      else if (i2cHandle->EventCount == 1) {\n        i2cHandle->Instance->DR = i2cHandle->Memaddress & 0xff;\n        i2cHandle->EventCount = i2cHandle->EventCount + 1;\n      }\n      else if (i2cHandle->EventCount == 2) {\n        if (i2cHandle->State == I2C_STATE_BUSY_RECEIVE) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n        }\n        else if (i2cHandle->State == I2C_STATE_BUSY_TRANSMIT) {\n          bufferPtr = i2cHandle->pBuffPtr;\n          i2cHandle->pBuffPtr = bufferPtr + 1;\n          i2cHandle->Instance->DR = (uint)*bufferPtr;\n          i2cHandle->XferCount = i2cHandle->XferCount - 1;\n        }\n      }\n    }\n    else {\n      bufferPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPtr + 1;\n      i2cHandle->Instance->DR = (uint)*bufferPtr;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OPERATION_OK;\n}\n\n",
            "renaming": {
                "FUN_08002db2": "handle_i2_c_transfer_08002db2",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "CurrentState": "currentI2CState",
                "pbVar2": "bufferPtr",
                "CurrentXferOptions": "currentTransferOptions",
                "uVar3": "transferOptions",
                "HAL_I2C_STATE_BUSY_TX": "I2C_STATE_BUSY_TRANSMIT",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_I2C_MODE_MEM": "I2C_MODE_MEMORY",
                "HAL_I2C_MODE_NONE": "I2C_MODE_NONE",
                "HAL_OK": "HAL_OPERATION_OK",
                "HAL_I2C_MemTxCpltCallback": "handleI2CMemoryTransmitCompleteCallback",
                "HAL_I2C_MasterTxCpltCallback": "handleI2CMasterTransmitCompleteCallback",
                "HAL_I2C_STATE_BUSY_RX": "I2C_STATE_BUSY_RECEIVE"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002efc": {
            "entrypoint": "0x08002efc",
            "current_name": "transfer_complete_handler_08002efc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict transferCompleteHandler_08002efc(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t transferOptions;\n  uint32_t currentTransferOptions;\n  byte *bufferPointer;\n  \n  transferOptions = i2cHandle->XferOptions;\n  if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    if (i2cHandle->XferCount == 0) {\n      if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        i2cHandle->PreviousState = 0;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(i2cHandle);\n        }\n        else {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(i2cHandle);\n        }\n      }\n      else {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->PreviousState = 0x11;\n        i2cHandle->Mode = HAL_I2C_MODE_NONE;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      bufferPointer = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPointer + 1;\n      i2cHandle->Instance->DR = (uint)*bufferPointer;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002efc": "transfer_complete_handler_08002efc",
                "hi2c": "i2cHandle",
                "uVar1": "transferOptions",
                "CurrentXferOptions": "currentTransferOptions",
                "pbVar2": "bufferPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f9a": {
            "entrypoint": "0x08002f9a",
            "current_name": "FUNC_08002f9a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002f9a(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f9a": "FUNC_08002f9a"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002f9c": {
            "entrypoint": "0x08002f9c",
            "current_name": "handle_i2_c_rx_transfer_08002f9c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CRxTransfer_08002f9c(I2C_HandleTypeDef *hi2c)\n\n{\n  uint8_t *bufferPtr;\n  \n  if (hi2c->currentState == HAL_I2C_STATE_RECEIVING) {\n    if (hi2c->transferCount < 4) {\n      if (hi2c->transferCount - 2 < 2) {\n        if (hi2c->transferOptions == 2) {\n          hi2c->i2cInstance->controlRegister1 = hi2c->i2cInstance->controlRegister1 | 0x400;\n        }\n        else {\n          hi2c->i2cInstance->controlRegister1 = hi2c->i2cInstance->controlRegister1 & 0xfffffbff;\n          hi2c->i2cInstance->controlRegister1 = hi2c->i2cInstance->controlRegister1 | 0x800;\n        }\n        hi2c->i2cInstance->controlRegister2 = hi2c->i2cInstance->controlRegister2 & 0xfffffbff;\n      }\n      else {\n        if (hi2c->transferOptions == 2) {\n          hi2c->i2cInstance->controlRegister1 = hi2c->i2cInstance->controlRegister1 | 0x400;\n        }\n        else {\n          hi2c->i2cInstance->controlRegister1 = hi2c->i2cInstance->controlRegister1 & 0xfffffbff;\n        }\n        hi2c->i2cInstance->controlRegister2 = hi2c->i2cInstance->controlRegister2 & 0xfffff8ff;\n        bufferPtr = hi2c->dataBufferPtr;\n        hi2c->dataBufferPtr = bufferPtr + 1;\n        *bufferPtr = (uint8_t)hi2c->i2cInstance->dataRegister;\n        hi2c->transferCount = hi2c->transferCount - 1;\n        hi2c->currentState = HAL_I2C_STATE_IDLE;\n        hi2c->previousState = 0;\n        if (hi2c->i2cMode == HAL_I2C_MODE_MEMORY) {\n          hi2c->i2cMode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemRxCpltCallback(hi2c);\n        }\n        else {\n          hi2c->i2cMode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterRxCpltCallback(hi2c);\n        }\n      }\n    }\n    else {\n      bufferPtr = hi2c->dataBufferPtr;\n      hi2c->dataBufferPtr = bufferPtr + 1;\n      *bufferPtr = (uint8_t)hi2c->i2cInstance->dataRegister;\n      hi2c->transferCount = hi2c->transferCount - 1;\n    }\n  }\n  return HAL_SUCCESS;\n}\n\n",
            "renaming": {
                "FUN_08002f9c": "handle_i2_c_rx_transfer_08002f9c",
                "puVar1": "bufferPtr",
                "State": "currentState",
                "XferCount": "transferCount",
                "XferOptions": "transferOptions",
                "Instance": "i2cInstance",
                "CR1": "controlRegister1",
                "CR2": "controlRegister2",
                "pBuffPtr": "dataBufferPtr",
                "DR": "dataRegister",
                "Mode": "i2cMode",
                "PreviousState": "previousState",
                "HAL_I2C_STATE_BUSY_RX": "HAL_I2C_STATE_RECEIVING",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_IDLE",
                "HAL_I2C_MODE_MEM": "HAL_I2C_MODE_MEMORY",
                "HAL_OK": "HAL_SUCCESS"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800306c": {
            "entrypoint": "0x0800306c",
            "current_name": "transfer_i2_c_data_0800306c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict transferI2CData_0800306c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t transferOptions;\n  uint32_t currentTransferOptions;\n  uint8_t *dataBufferPtr;\n  \n  transferOptions = i2cHandle->XferOptions;\n  if (i2cHandle->XferCount == 3) {\n    if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    }\n    dataBufferPtr = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = dataBufferPtr + 1;\n    *dataBufferPtr = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n  }\n  else if (i2cHandle->XferCount == 2) {\n    if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffcff;\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n    }\n    else {\n      if (transferOptions == 2) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n      }\n      else {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n      }\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffcff;\n    }\n    dataBufferPtr = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = dataBufferPtr + 1;\n    *dataBufferPtr = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    dataBufferPtr = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = dataBufferPtr + 1;\n    *dataBufferPtr = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->PreviousState = 0;\n    if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MemRxCpltCallback(i2cHandle);\n    }\n    else {\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MasterRxCpltCallback(i2cHandle);\n    }\n  }\n  else {\n    dataBufferPtr = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = dataBufferPtr + 1;\n    *dataBufferPtr = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800306c": "transfer_i2_c_data_0800306c",
                "hi2c": "i2cHandle",
                "uVar1": "transferOptions",
                "CurrentXferOptions": "currentTransferOptions",
                "puVar2": "dataBufferPtr"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800316a": {
            "entrypoint": "0x0800316a",
            "current_name": "FUNC_0800316a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800316a(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800316a": "FUNC_0800316a"
            },
            "calling": [
                "I2C_DMAAbort",
                "I2C_ITError"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800316c": {
            "entrypoint": "0x0800316c",
            "current_name": "update_i2_c_state_0800316c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateI2CState_0800316c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t *puVar2;\n  I2C_TypeDef *pIVar3;\n  \n  if (i2cHandle->currentState - 0x29 < 2) {\n    i2cHandle->previousState = 0;\n    i2cHandle->currentState = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((i2cHandle->currentState != HAL_I2C_STATE_ABORT) && ((i2cHandle->i2cInstance->i2cControlRegister2 & 0x800) == 0)) {\n      i2cHandle->currentState = HAL_I2C_STATE_READY;\n    }\n    i2cHandle->previousState = 0;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  }\n  i2cHandle->i2cInstance->i2cControlRegister1 = i2cHandle->i2cInstance->i2cControlRegister1 & 0xfffff7ff;\n  pIVar3 = i2cHandle->i2cInstance;\n  if ((pIVar3->i2cControlRegister2 & 0x800) == 0) {\n    if (i2cHandle->currentState == HAL_I2C_STATE_ABORT) {\n      i2cHandle->currentState = HAL_I2C_STATE_READY;\n      i2cHandle->errorFlag = 0;\n      if ((pIVar3->statusRegister1 & 0x40) != 0) {\n        puVar2 = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = puVar2 + 1;\n        *puVar2 = (uint8_t)pIVar3->dataRegister;\n      }\n      i2cHandle->i2cInstance->i2cControlRegister1 = i2cHandle->i2cInstance->i2cControlRegister1 & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(i2cHandle);\n    }\n    else {\n      if ((pIVar3->statusRegister1 & 0x40) != 0) {\n        puVar2 = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = puVar2 + 1;\n        *puVar2 = (uint8_t)pIVar3->dataRegister;\n      }\n      HAL_I2C_ErrorCallback(i2cHandle);\n    }\n  }\n  else {\n    pIVar3->i2cControlRegister2 = pIVar3->i2cControlRegister2 & 0xfffff7ff;\n    if (i2cHandle->dmaTransmitHandle->currentState == HAL_DMA_STATE_READY) {\n      i2cHandle->dmaReceiveHandle->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->dmaReceiveHandle);\n      if (status != HAL_OK) {\n        if ((i2cHandle->i2cInstance->statusRegister1 & 0x40) != 0) {\n          puVar2 = i2cHandle->pBuffPtr;\n          i2cHandle->pBuffPtr = puVar2 + 1;\n          *puVar2 = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n        }\n        i2cHandle->i2cInstance->i2cControlRegister1 = i2cHandle->i2cInstance->i2cControlRegister1 & 0xfffffffe;\n        i2cHandle->currentState = HAL_I2C_STATE_READY;\n        (*i2cHandle->dmaReceiveHandle->XferAbortCallback)(i2cHandle->dmaReceiveHandle);\n      }\n    }\n    else {\n      i2cHandle->dmaTransmitHandle->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->dmaTransmitHandle);\n      if (status != HAL_OK) {\n        i2cHandle->i2cInstance->i2cControlRegister1 = i2cHandle->i2cInstance->i2cControlRegister1 & 0xfffffffe;\n        i2cHandle->currentState = HAL_I2C_STATE_READY;\n        (*i2cHandle->dmaTransmitHandle->XferAbortCallback)(i2cHandle->dmaTransmitHandle);\n      }\n    }\n  }\n  if ((i2cHandle->currentState == HAL_I2C_STATE_LISTEN) && ((i2cHandle->errorFlag & 4) != 0)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->previousState = 0;\n    i2cHandle->currentState = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800316c": "update_i2_c_state_0800316c",
                "hi2c": "i2cHandle",
                "PreviousState": "previousState",
                "State": "currentState",
                "Instance": "i2cInstance",
                "CR1": "i2cControlRegister1",
                "CR2": "i2cControlRegister2",
                "ErrorCode": "errorFlag",
                "SR1": "statusRegister1",
                "DR": "dataRegister",
                "hdmatx": "dmaTransmitHandle",
                "hdmarx": "dmaReceiveHandle",
                "HVar1": "status",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "HAL_DMA_Abort_IT",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080032b4": {
            "entrypoint": "0x080032b4",
            "current_name": "process_i2_c_080032b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict processI2C_080032b4(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  I2C_TypeDef *i2cInstance;\n  uint8_t *dataPtr;\n  uint32_t currentStatus;\n  uint32_t temporaryRegister;\n  \n  currentState = i2cHandle->State;\n  i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) != 0) {\n    if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) || (i2cHandle->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmarx->Instance->CNDTR;\n    }\n    else {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmatx->Instance->CNDTR;\n    }\n  }\n  if (i2cHandle->XferCount != 0) {\n    if ((i2cInstance->SR1 & 4) != 0) {\n      dataPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPtr + 1;\n      *dataPtr = (uint8_t)i2cInstance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n      dataPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPtr + 1;\n      *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n  }\n  if (i2cHandle->ErrorCode == 0) {\n    if (((currentState == HAL_I2C_STATE_LISTEN) || (currentState == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (currentState == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2cHandle->XferOptions = 0xffff0000;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(i2cHandle);\n    }\n    else if ((i2cHandle->PreviousState == 0x22) || (currentState == HAL_I2C_STATE_BUSY_RX)) {\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  else {\n    I2C_ITError(i2cHandle);\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080032b4": "process_i2_c_080032b4",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "pIVar2": "i2cInstance",
                "puVar3": "dataPtr",
                "CurrentState": "currentStatus",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback",
                "I2C_ITError",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033b8": {
            "entrypoint": "0x080033b8",
            "current_name": "process_interrupt_080033b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processInterrupt_080033b8(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2C_TypeDef *i2cInstance;\n  uint32_t currentMode;\n  uint statusReg1;\n  uint32_t statusReg1ITFlags;\n  uint controlReg2;\n  uint32_t interruptSources;\n  uint statusReg2;\n  uint32_t sr2itflags;\n  \n  i2cInstance = i2cHandle->Instance;\n  statusReg2 = i2cInstance->SR2;\n  statusReg1 = i2cInstance->SR1;\n  controlReg2 = i2cInstance->CR2;\n  if ((i2cHandle->Mode == HAL_I2C_MODE_MASTER) || (i2cHandle->Mode == HAL_I2C_MODE_MEM)) {\n    if (((statusReg1 & 0x10001) == 0) || ((controlReg2 & 0x200) == 0)) {\n      if (((statusReg1 & 0x10008) == 0) || ((controlReg2 & 0x200) == 0)) {\n        if (((statusReg1 & 0x10002) != 0) && ((controlReg2 & 0x200) != 0)) {\n          I2C_Master_ADDR(i2cHandle);\n        }\n      }\n      else {\n        I2C_Master_ADD10(i2cHandle);\n      }\n    }\n    else {\n      I2C_Master_SB(i2cHandle);\n    }\n    if ((statusReg2 & 0x100004) == 0) {\n      if ((((statusReg1 & 0x10040) != 0) && ((controlReg2 & 0x400) != 0)) && ((statusReg1 & 0x10004) == 0)) {\n        I2C_MasterReceive_RXNE(i2cHandle);\n        return;\n      }\n      if (((statusReg1 & 0x10004) != 0) && ((controlReg2 & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(i2cHandle);\n        return;\n      }\n    }\n    else {\n      if ((((statusReg1 & 0x10080) != 0) && ((controlReg2 & 0x400) != 0)) && ((statusReg1 & 0x10004) == 0)) {\n        I2C_MasterTransmit_TXE(i2cHandle);\n        return;\n      }\n      if (((statusReg1 & 0x10004) != 0) && ((controlReg2 & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(i2cHandle);\n        return;\n      }\n    }\n  }\n  else {\n    if (((statusReg1 & 0x10002) != 0) && ((controlReg2 & 0x200) != 0)) {\n      I2C_Slave_ADDR(i2cHandle);\n      return;\n    }\n    if (((statusReg1 & 0x10010) != 0) && ((controlReg2 & 0x200) != 0)) {\n      I2C_Slave_STOPF(i2cHandle);\n      return;\n    }\n    if ((statusReg2 & 0x100004) == 0) {\n      if ((((statusReg1 & 0x10040) != 0) && ((controlReg2 & 0x400) != 0)) && ((statusReg1 & 0x10004) == 0)) {\n        I2C_SlaveReceive_RXNE(i2cHandle);\n        return;\n      }\n      if (((statusReg1 & 0x10004) != 0) && ((controlReg2 & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(i2cHandle);\n      }\n    }\n    else {\n      if ((((statusReg1 & 0x10080) != 0) && ((controlReg2 & 0x400) != 0)) && ((statusReg1 & 0x10004) == 0)) {\n        I2C_SlaveTransmit_TXE(i2cHandle);\n        return;\n      }\n      if (((statusReg1 & 0x10004) != 0) && ((controlReg2 & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(i2cHandle);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033b8": "process_interrupt_080033b8",
                "hi2c": "i2cHandle",
                "pIVar1": "i2cInstance",
                "CurrentMode": "currentMode",
                "uVar2": "statusReg1",
                "sr1itflags": "statusReg1ITFlags",
                "uVar3": "controlReg2",
                "itsources": "interruptSources",
                "uVar4": "statusReg2"
            },
            "calling": [
                "I2C1_EV_IRQHandler",
                "I2C2_EV_IRQHandler"
            ],
            "called": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterReceive_BTF",
                "I2C_Master_ADD10",
                "I2C_Slave_ADDR",
                "I2C_SlaveTransmit_BTF",
                "I2C_MasterReceive_RXNE",
                "I2C_SlaveTransmit_TXE",
                "I2C_Master_SB",
                "I2C_SlaveReceive_BTF",
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF",
                "I2C_Master_ADDR",
                "I2C_MasterTransmit_TXE"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003520": {
            "entrypoint": "0x08003520",
            "current_name": "handle_i2_c_interrupt_08003520",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CInterrupt_08003520(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef i2cState;\n  I2C_TypeDef *i2cInstance;\n  uint32_t sr1InterruptFlags;\n  uint sr1Value;\n  uint32_t itsources;\n  uint cr2Value;\n  \n  i2cInstance = i2cHandle->Instance;\n  sr1Value = i2cInstance->SR1;\n  cr2Value = i2cInstance->CR2;\n  if (((sr1Value & 0x10100) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 1;\n    i2cInstance->SR1 = 0xfffffeff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x8000;\n  }\n  if (((sr1Value & 0x10200) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 2;\n    i2cHandle->Instance->SR1 = 0xfffffdff;\n  }\n  if (((sr1Value & 0x10400) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cState = i2cHandle->State;\n    if (((i2cHandle->Mode == HAL_I2C_MODE_SLAVE) && (i2cHandle->XferCount == 0)) &&\n       (((i2cState == HAL_I2C_STATE_BUSY_TX || (i2cState == HAL_I2C_STATE_BUSY_TX_LISTEN)) ||\n        ((i2cState == HAL_I2C_STATE_LISTEN && (i2cHandle->PreviousState == 0x21)))))) {\n      I2C_Slave_AF(i2cHandle);\n    }\n    else {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n      if (i2cHandle->Mode == HAL_I2C_MODE_MASTER) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      }\n      i2cHandle->Instance->SR1 = 0xfffffbff;\n    }\n  }\n  if (((sr1Value & 0x10800) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 8;\n    i2cHandle->Instance->SR1 = 0xfffff7ff;\n  }\n  if (i2cHandle->ErrorCode != 0) {\n    I2C_ITError(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003520": "handle_i2_c_interrupt_08003520",
                "hi2c": "i2cHandle",
                "HVar1": "i2cState",
                "pIVar2": "i2cInstance",
                "sr1itflags": "sr1InterruptFlags",
                "uVar3": "sr1Value",
                "uVar4": "cr2Value"
            },
            "calling": [
                "I2C1_ER_IRQHandler",
                "I2C2_ER_IRQHandler"
            ],
            "called": [
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fc": {
            "entrypoint": "0x080035fc",
            "current_name": "reset_i2_c_080035fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetI2C_080035fc(DMA_HandleTypeDef *dmaHandle)\n\n{\n  I2C_HandleTypeDef *i2cHandleParent;\n  I2C_HandleTypeDef *i2cHandle;\n  \n  i2cHandleParent = (I2C_HandleTypeDef *)dmaHandle->Parent;\n  i2cHandleParent->Instance->CR1 = i2cHandleParent->Instance->CR1 & 0xfffffbff;\n  i2cHandleParent->XferCount = 0;\n  i2cHandleParent->dmaHandletx->XferAbortCallback = (voidCallback *)0x0;\n  i2cHandleParent->dmaHandlerx->XferAbortCallback = (voidCallback *)0x0;\n  if (i2cHandleParent->State != STATE_ABORT) {\n    i2cHandleParent->State = STATE_READY;\n    i2cHandleParent->Mode = MODE_NONE;\n    i2cHandleParent->Instance->CR1 = i2cHandleParent->Instance->CR1 & 0xfffffffe;\n    errorCallback(i2cHandleParent);\n    return;\n  }\n  i2cHandleParent->State = STATE_READY;\n  i2cHandleParent->Mode = MODE_NONE;\n  i2cHandleParent->ErrorCode = 0;\n  i2cHandleParent->Instance->CR1 = i2cHandleParent->Instance->CR1 & 0xfffffffe;\n  abortCompleteCallback(i2cHandleParent);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fc": "reset_i2_c_080035fc",
                "hdma": "dmaHandle",
                "hi2c_00": "i2cHandleParent",
                "hi2c": "i2cHandle",
                "_func_void___DMA_HandleTypeDef_ptr": "voidCallback",
                "HAL_I2C_STATE_ABORT": "STATE_ABORT",
                "HAL_I2C_STATE_READY": "STATE_READY",
                "HAL_I2C_MODE_NONE": "MODE_NONE",
                "HAL_I2C_ErrorCallback": "errorCallback",
                "HAL_I2C_AbortCpltCallback": "abortCompleteCallback"
            },
            "calling": [],
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800365c": {
            "entrypoint": "0x0800365c",
            "current_name": "delay_loop_0800365c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid delayLoop_0800365c(uint32_t milliseconds)\n\n{\n  bool isNotZero;\n  uint32_t cycles;\n  \n  cycles = milliseconds * (SystemCoreClock / 8000);\n  do {\n    isNotZero = cycles != 0;\n    cycles = cycles - 1;\n  } while (isNotZero);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800365c": "delay_loop_0800365c",
                "mdelay": "milliseconds",
                "Delay": "cycles",
                "bVar1": "isNotZero"
            },
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003688": {
            "entrypoint": "0x08003688",
            "current_name": "initialize_clocks_08003688",
            "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_result initializeClocks_08003688(RCC_OscInitTypeDef_conflict *clockInit)\n\n{\n  HAL_StatusTypeDef_result result;\n  uint32_t currentTime;\n  uint32_t startTime;\n  bool isHSEDisabled;\n  uint32_t temporaryRegister;\n  \n  if ((clockInit->OscillatorType & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) != 0)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (clockInit->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      startTime = clockInit->HSEState;\n      if (startTime == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (startTime == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (startTime == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (clockInit->HSEState == 0) {\n        startTime = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          currentTime = HAL_GetTick();\n          if (100 < currentTime - startTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        startTime = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          currentTime = HAL_GetTick();\n          if (100 < currentTime - startTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((clockInit->OscillatorType & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (clockInit->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      _DAT_40021000 = _DAT_40021000 & 0xffffff07 | clockInit->HSICalibrationValue << 3;\n    }\n    else if (clockInit->HSIState == 0) {\n      _DAT_42420000 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021000 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (2 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021000 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (2 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40021000 = _DAT_40021000 & 0xffffff07 | clockInit->HSICalibrationValue << 3;\n    }\n  }\n  if ((clockInit->OscillatorType & 8) != 0) {\n    if (clockInit->LSIState == 0) {\n      _DAT_42420480 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021024 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (2 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021024 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (2 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((clockInit->OscillatorType & 4) != 0) {\n    isHSEDisabled = (_DAT_4002101c & 0x10000000) == 0;\n    if (isHSEDisabled) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTime = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTime = HAL_GetTick();\n        if (100 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    startTime = clockInit->LSEState;\n    if (startTime == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (startTime == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (startTime == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (clockInit->LSEState == 0) {\n      startTime = HAL_GetTick();\n      while ((_DAT_40021020 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (5000 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      startTime = HAL_GetTick();\n      while ((_DAT_40021020 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (5000 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (isHSEDisabled) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  startTime = (clockInit->PLL).PLLState;\n  if (startTime == 0) {\n    result = HAL_OK;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    result = HAL_ERROR;\n  }\n  else if (startTime == 2) {\n    _DAT_42420060 = 0;\n    startTime = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if ((clockInit->PLL).PLLSource == 0x10000) {\n          _DAT_40021004 = _DAT_40021004 & 0xfffdffff | clockInit->HSEPredivValue;\n        }\n        _DAT_40021004 =\n             _DAT_40021004 & 0xffc2ffff |\n             (clockInit->PLL).PLLSource | (clockInit->PLL).PLLMUL;\n        _DAT_42420060 = 1;\n        startTime = HAL_GetTick();\n        do {\n          if ((_DAT_40021000 & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          currentTime = HAL_GetTick();\n        } while (currentTime - startTime < 3);\n        return HAL_TIMEOUT;\n      }\n      currentTime = HAL_GetTick();\n    } while (currentTime - startTime < 3);\n    result = HAL_TIMEOUT;\n  }\n  else {\n    _DAT_42420060 = 0;\n    startTime = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      currentTime = HAL_GetTick();\n    } while (currentTime - startTime < 3);\n    result = HAL_TIMEOUT;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003688": "initialize_clocks_08003688",
                "RCC_OscInitStruct": "clockInit",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef_result",
                "HVar1": "result",
                "uVar2": "currentTime",
                "uVar3": "startTime",
                "bVar4": "isHSEDisabled",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a68": {
            "entrypoint": "0x08003a68",
            "current_name": "calculate_clock_frequency_08003a68",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateClockFrequency_08003a68(void)\n\n{\n  uint32_t clockFrequency;\n  uint8_t predivFactors [2];\n  uint8_t pllMulFactors [16];\n  \n  pllMulFactors[12] = '\\x0e';\n  pllMulFactors[13] = '\\x0f';\n  pllMulFactors[14] = '\\x10';\n  pllMulFactors[15] = '\\x10';\n  pllMulFactors[8] = '\\n';\n  pllMulFactors[9] = '\\v';\n  pllMulFactors[10] = '\\f';\n  pllMulFactors[11] = '\\r';\n  pllMulFactors[4] = '\\x06';\n  pllMulFactors[5] = '\\a';\n  pllMulFactors[6] = '\\b';\n  pllMulFactors[7] = '\\t';\n  pllMulFactors[0] = '\\x02';\n  pllMulFactors[1] = '\\x03';\n  pllMulFactors[2] = '\\x04';\n  pllMulFactors[3] = '\\x05';\n  predivFactors[0] = '\\x01';\n  predivFactors[1] = '\\x02';\n  if ((_DAT_40021004 & 0xc) == 8) {\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      clockFrequency = (uint)pllMulFactors[(_DAT_40021004 << 10) >> 0x1c] * 4000000;\n    }\n    else {\n      clockFrequency = ((uint)pllMulFactors[(_DAT_40021004 << 10) >> 0x1c] * 8000000) /\n              (uint)predivFactors[-((int)(_DAT_40021004 << 0xe) >> 0x1f)];\n    }\n  }\n  else {\n    clockFrequency = 8000000;\n  }\n  return clockFrequency;\n}\n\n",
            "renaming": {
                "FUN_08003a68": "calculate_clock_frequency_08003a68",
                "aPredivFactorTable": "predivFactors",
                "aPLLMULFactorTable": "pllMulFactors",
                "uVar1": "clockFrequency"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ad4": {
            "entrypoint": "0x08003ad4",
            "current_name": "configure_clocks_08003ad4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nconfigureClocks_08003ad4(RCC_ClkInitTypeDef_conflict *RCC_ClkInitStruct,uint32_t flashLatency)\n\n{\n  uint32_t tempVar1;\n  uint32_t tempVar2;\n  uint tempVar3;\n  \n  if ((_DAT_40022000 & 7) < flashLatency) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | flashLatency;\n    if (flashLatency != (flashLatency & 7)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((RCC_ClkInitStruct->ClockType & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffff0f | RCC_ClkInitStruct->AHBCLKDivider;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 1) != 0) {\n    tempVar3 = RCC_ClkInitStruct->SYSCLKSource;\n    if (tempVar3 == 1) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((tempVar3 != 2) && ((_DAT_40021000 & 2) == 0)) {\n      return HAL_ERROR;\n    }\n    _DAT_40021004 = tempVar3 | _DAT_40021004 & 0xfffffffc;\n    tempVar1 = HAL_GetTick();\n    if (RCC_ClkInitStruct->SYSCLKSource == 1) {\n      while ((_DAT_40021004 & 0xc) != 4) {\n        tempVar2 = HAL_GetTick();\n        if (5000 < tempVar2 - tempVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else if (RCC_ClkInitStruct->SYSCLKSource == 2) {\n      while ((_DAT_40021004 & 0xc) != 8) {\n        tempVar2 = HAL_GetTick();\n        if (5000 < tempVar2 - tempVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      while ((_DAT_40021004 & 0xc) != 0) {\n        tempVar2 = HAL_GetTick();\n        if (5000 < tempVar2 - tempVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if (flashLatency < (_DAT_40022000 & 7)) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | flashLatency;\n    if (flashLatency != (flashLatency & 7)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((RCC_ClkInitStruct->ClockType & 4) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xfffff8ff | RCC_ClkInitStruct->APB1CLKDivider;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 8) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffc7ff | RCC_ClkInitStruct->APB2CLKDivider << 3;\n  }\n  tempVar1 = HAL_RCC_GetSysClockFreq();\n  SystemCoreClock = tempVar1 >> \"\"[(_DAT_40021004 << 0x18) >> 0x1c];\n  HAL_InitTick(0xf);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08003ad4": "configure_clocks_08003ad4",
                "FLatency": "flashLatency",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "uVar3": "tempVar3"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_RCC_GetSysClockFreq",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c44": {
            "entrypoint": "0x08003c44",
            "current_name": "get_system_core_clock_08003c44",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_08003c44(void)\n\n{\n  return coreClock;\n}\n\n",
            "renaming": {
                "FUN_08003c44": "get_system_core_clock_08003c44",
                "SystemCoreClock": "coreClock"
            },
            "calling": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c50": {
            "entrypoint": "0x08003c50",
            "current_name": "get_adjusted_hclk_freq_08003c50",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getAdjustedHCLKFreq_08003c50(void)\n\n{\n  uint32_t hclkFreq;\n  \n  hclkFreq = getHCLKFreq();\n  return hclkFreq >> \"\"[(uint)(_DAT_40021004 << 0x15) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_08003c50": "get_adjusted_hclk_freq_08003c50",
                "uVar1": "hclkFreq",
                "HAL_RCC_GetHCLKFreq": "getHCLKFreq"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c70": {
            "entrypoint": "0x08003c70",
            "current_name": "calculate_hclk_divide_factor_08003c70",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateHCLKDivideFactor_08003c70(void)\n\n{\n  uint32_t HCLKFrequency;\n  \n  HCLKFrequency = HAL_RCC_GetHCLKFreq();\n  return HCLKFrequency >> \"\"[(uint)(_DAT_40021004 << 0x12) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_08003c70": "calculate_hclk_divide_factor_08003c70",
                "uVar1": "HCLKFrequency"
            },
            "calling": [
                "UART_SetConfig",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c90": {
            "entrypoint": "0x08003c90",
            "current_name": "configure_periph_clock_init_08003c90",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configurePeriphClockInit_08003c90(RCC_PeriphCLKInitTypeDef_conflict *peripheralClockInit)\n\n{\n  uint tempVar1;\n  uint tempVar2;\n  uint32_t tempVar3;\n  uint32_t tempVar4;\n  bool isBitSet;\n  uint32_t temporaryRegister;\n  \n  if ((peripheralClockInit->PeriphClockSelection & 1) != 0) {\n    isBitSet = (_DAT_4002101c & 0x10000000) == 0;\n    if (isBitSet) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      tempVar3 = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        tempVar4 = HAL_GetTick();\n        if (100 < tempVar4 - tempVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (((_DAT_40021020 & 0x300) != 0) &&\n       ((_DAT_40021020 & 0x300) != (peripheralClockInit->RTCClockSelection & 0x300))) {\n      tempVar2 = _DAT_40021020 & 0xfffffcff;\n      _DAT_42420440 = 0;\n      tempVar1 = _DAT_40021020 & 1;\n      _DAT_40021020 = tempVar2;\n      if (tempVar1 != 0) {\n        tempVar3 = HAL_GetTick();\n        while ((_DAT_40021020 & 2) == 0) {\n          tempVar4 = HAL_GetTick();\n          if (5000 < tempVar4 - tempVar3) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    _DAT_40021020 = _DAT_40021020 & 0xfffffcff | peripheralClockInit->RTCClockSelection;\n    if (isBitSet) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if ((peripheralClockInit->PeriphClockSelection & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffff3fff | peripheralClockInit->AdcClockSelection;\n  }\n  if ((peripheralClockInit->PeriphClockSelection & 0x10) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffbfffff | peripheralClockInit->UsbClockSelection;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08003c90": "configure_periph_clock_init_08003c90",
                "PeriphClkInit": "peripheralClockInit",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "uVar3": "tempVar3",
                "uVar4": "tempVar4",
                "bVar5": "isBitSet",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003da4": {
            "entrypoint": "0x08003da4",
            "current_name": "calculate_clock_frequency_08003da4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateClockFrequency_08003da4(uint32_t peripheralClock)\n\n{\n  uint32_t clockFrequency;\n  uint divider;\n  uint8_t predivFactorTable [2];\n  uint8_t pllMulFactorTable [16];\n  \n  pllMulFactorTable[12] = '\\x0e';\n  pllMulFactorTable[13] = '\\x0f';\n  pllMulFactorTable[14] = '\\x10';\n  pllMulFactorTable[15] = '\\x10';\n  pllMulFactorTable[8] = '\\n';\n  pllMulFactorTable[9] = '\\v';\n  pllMulFactorTable[10] = '\\f';\n  pllMulFactorTable[11] = '\\r';\n  pllMulFactorTable[4] = '\\x06';\n  pllMulFactorTable[5] = '\\a';\n  pllMulFactorTable[6] = '\\b';\n  pllMulFactorTable[7] = '\\t';\n  pllMulFactorTable[0] = '\\x02';\n  pllMulFactorTable[1] = '\\x03';\n  pllMulFactorTable[2] = '\\x04';\n  pllMulFactorTable[3] = '\\x05';\n  predivFactorTable[0] = '\\x01';\n  predivFactorTable[1] = '\\x02';\n  if (peripheralClock == 2) {\n    clockFrequency = HAL_RCC_GetPCLK2Freq();\n    clockFrequency = clockFrequency / ((((_DAT_40021004 << 0x10) >> 0x1e) + 1) * 2);\n  }\n  else if (peripheralClock == 0x10) {\n    if ((_DAT_40021000 & 0x1000000) == 0) {\n      clockFrequency = 0;\n    }\n    else {\n      if ((_DAT_40021004 & 0x10000) == 0) {\n        divider = 4000000;\n      }\n      else {\n        divider = 8000000 / predivFactorTable[-((int)(_DAT_40021004 << 0xe) >> 0x1f)];\n      }\n      clockFrequency = divider * pllMulFactorTable[(_DAT_40021004 << 10) >> 0x1c];\n      if ((_DAT_40021004 & 0x400000) == 0) {\n        clockFrequency = (clockFrequency * 2) / 3;\n      }\n    }\n  }\n  else if (peripheralClock == 1) {\n    if ((_DAT_40021020 & 0x302) == 0x102) {\n      clockFrequency = 0x8000;\n    }\n    else if (((_DAT_40021020 & 0x300) == 0x200) && ((_DAT_40021024 & 2) != 0)) {\n      clockFrequency = 32000;\n    }\n    else if ((_DAT_40021020 & 0x300) == 0x300) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        clockFrequency = 0;\n      }\n      else {\n        clockFrequency = 0xf424;\n      }\n    }\n    else {\n      clockFrequency = 0;\n    }\n  }\n  else {\n    clockFrequency = 0;\n  }\n  return clockFrequency;\n}\n\n",
            "renaming": {
                "FUN_08003da4": "calculate_clock_frequency_08003da4",
                "PeriphClk": "peripheralClock",
                "uVar1": "clockFrequency",
                "uVar2": "divider",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllMulFactorTable"
            },
            "calling": [
                "HAL_ADC_PollForConversion",
                "HAL_ADCEx_Calibration_Start"
            ],
            "called": [
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ea0": {
            "entrypoint": "0x08003ea0",
            "current_name": "handle_rtc_alarm_08003ea0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_RTC_alarm_08003ea0(RTC_HandleTypeDef *rtc_handle)\n\n{\n  if (((rtc_handle->Instance->CRH & 2) != 0) && ((rtc_handle->Instance->CRL & 2) != 0)) {\n    handle_RTC_alarm_08003ea0_event(rtc_handle);\n    rtc_handle->Instance->CRL = 0xfffffffd;\n  }\n  _DAT_40010414 = 0x20000;\n  rtc_handle->State = HAL_RTC_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ea0": "handle_rtc_alarm_08003ea0",
                "hrtc": "rtc_handle",
                "HAL_RTC_AlarmAEventCallback": "handle_RTC_alarm_event"
            },
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "called": [
                "HAL_RTC_AlarmAEventCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ed8": {
            "entrypoint": "0x08003ed8",
            "current_name": "reset_tim_08003ed8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict resetTim_08003ed8(TIM_HandleTypeDef *timer)\n\n{\n  TimerType *timerInstance;\n  \n  timer->State = busyState;\n  timerInstance = timer->Instance;\n  if (((timerInstance->captureCompareEnableRegister & 0x1111) == 0) && ((timerInstance->captureCompareEnableRegister & 0x444) == 0)) {\n    timerInstance->controlRegister1 = timerInstance->controlRegister1 & 0xfffffffe;\n  }\n  deinitializePWM(timer);\n  timer->State = resetState;\n  timer->Lock = unlockedState;\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_08003ed8": "reset_tim_08003ed8",
                "htim": "timer",
                "HAL_TIM_STATE_BUSY": "busyState",
                "TIM_TypeDef": "TimerType",
                "pTVar1": "timerInstance",
                "CCER": "captureCompareEnableRegister",
                "CR1": "controlRegister1",
                "HAL_TIM_PWM_MspDeInit": "deinitializePWM",
                "HAL_TIM_STATE_RESET": "resetState",
                "HAL_UNLOCKED": "unlockedState",
                "HAL_OK": "OK"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f12": {
            "entrypoint": "0x08003f12",
            "current_name": "FUNC_08003f12",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003f12(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f12": "FUNC_08003f12"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003f14": {
            "entrypoint": "0x08003f14",
            "current_name": "FUNC_08003f14",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003f14(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f14": "FUNC_08003f14"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003f16": {
            "entrypoint": "0x08003f16",
            "current_name": "FUNC_08003f16",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003f16(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f16": "FUNC_08003f16"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003f18": {
            "entrypoint": "0x08003f18",
            "current_name": "handle_tim_interrupts_08003f18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimInterrupts_08003f18(TIM_HandleTypeDef *timHandle)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  timerInstance = timHandle->Instance;\n  if (((timerInstance->SR & 2) != 0) && ((timerInstance->DIER & 2) != 0)) {\n    timerInstance->SR = 0xfffffffd;\n    timHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n    if ((timHandle->Instance->CCMR1 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timHandle);\n    }\n    timHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timHandle->Instance;\n  if (((timerInstance->SR & 4) != 0) && ((timerInstance->DIER & 4) != 0)) {\n    timerInstance->SR = 0xfffffffb;\n    timHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n    if ((timHandle->Instance->CCMR1 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timHandle);\n    }\n    timHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timHandle->Instance;\n  if (((timerInstance->SR & 8) != 0) && ((timerInstance->DIER & 8) != 0)) {\n    timerInstance->SR = 0xfffffff7;\n    timHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n    if ((timHandle->Instance->CCMR2 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timHandle);\n    }\n    timHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timHandle->Instance;\n  if (((timerInstance->SR & 0x10) != 0) && ((timerInstance->DIER & 0x10) != 0)) {\n    timerInstance->SR = 0xffffffef;\n    timHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n    if ((timHandle->Instance->CCMR2 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timHandle);\n    }\n    timHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timHandle->Instance;\n  if (((timerInstance->SR & 1) != 0) && ((timerInstance->DIER & 1) != 0)) {\n    timerInstance->SR = 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(timHandle);\n  }\n  timerInstance = timHandle->Instance;\n  if (((timerInstance->SR & 0x80) != 0) && ((timerInstance->DIER & 0x80) != 0)) {\n    timerInstance->SR = 0xffffff7f;\n    HAL_TIMEx_BreakCallback(timHandle);\n  }\n  timerInstance = timHandle->Instance;\n  if (((timerInstance->SR & 0x40) != 0) && ((timerInstance->DIER & 0x40) != 0)) {\n    timerInstance->SR = 0xffffffbf;\n    HAL_TIM_TriggerCallback(timHandle);\n  }\n  timerInstance = timHandle->Instance;\n  if (((timerInstance->SR & 0x20) != 0) && ((timerInstance->DIER & 0x20) != 0)) {\n    timerInstance->SR = 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(timHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f18": "handle_tim_interrupts_08003f18",
                "htim": "timHandle",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "TIM1_UP_IRQHandler",
                "TIM3_IRQHandler",
                "TIM4_IRQHandler",
                "TIM2_IRQHandler"
            ],
            "called": [
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIMEx_BreakCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_PWM_PulseFinishedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004092": {
            "entrypoint": "0x08004092",
            "current_name": "update_channel_state_08004092",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateChannelState_08004092(TIM_TypeDef *timer,uint32_t channel,uint32_t state)\n\n{\n  timer->CCER = timer->CCER & ~(1 << (channel & 0xff));\n  timer->CCER = timer->CCER | state << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004092": "update_channel_state_08004092",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "state"
            },
            "calling": [
                "HAL_TIM_PWM_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040b0": {
            "entrypoint": "0x080040b0",
            "current_name": "disable_timer_channel_080040b0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict disableTimerChannel_080040b0(TIM_HandleTypeDef *timerHandle,uint32_t channel)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  TIM_CCxchannelCmd(timerHandle->Instance,channel,0);\n  if (((timerHandle->Instance == (TIM_TypeDef *)0x40012c00) && ((memoryValue1 & 0x1111) == 0)) &&\n     ((memoryValue1 & 0x444) == 0)) {\n    memoryValue2 = memoryValue2 & 0xffff7fff;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  timerHandle->State = HAL_TIM_STATE_READY;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080040b0": "disable_timer_channel_080040b0",
                "htim": "timerHandle",
                "Channel": "channel",
                "pTVar1": "timerInstance",
                "uRam40012c20": "memoryValue1",
                "uRam40012c44": "memoryValue2"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004110": {
            "entrypoint": "0x08004110",
            "current_name": "configure_channel_state_08004110",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureChannelState_08004110(TIM_TypeDef *timer,uint32_t channel,uint32_t newChannelState)\n\n{\n  timer->CCER = timer->CCER & ~(4 << (channel & 0xff));\n  timer->CCER = timer->CCER | newChannelState << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004110": "configure_channel_state_08004110",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelNState": "newChannelState"
            },
            "calling": [
                "HAL_TIMEx_PWMN_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800412c": {
            "entrypoint": "0x0800412c",
            "current_name": "disable_tim_channel_0800412c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict disableTimChannel_0800412c(TIM_HandleTypeDef *timerHandle,uint32_t channel)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  TIM_CCxNchannelCmd(timerHandle->Instance,channel,0);\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->BDTR = timerInstance->BDTR & 0xffff7fff;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800412c": "disable_tim_channel_0800412c",
                "htim": "timerHandle",
                "Channel": "channel",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004178": {
            "entrypoint": "0x08004178",
            "current_name": "FUNC_08004178",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004178(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004178": "FUNC_08004178"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800417a": {
            "entrypoint": "0x0800417a",
            "current_name": "FUNC_0800417a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800417a(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800417a": "FUNC_0800417a"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800417c": {
            "entrypoint": "0x0800417c",
            "current_name": "reset_uart_instance_0800417c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_uart_instance_0800417c(UART_HandleTypeDef *uart_handle)\n\n{\n  uart_handle->uart_instance->control_register_1 = uart_handle->uart_instance->control_register_1 & 0xfffffedf;\n  uart_handle->uart_instance->control_register_3 = uart_handle->uart_instance->control_register_3 & 0xfffffffe;\n  uart_handle->receive_state = HAL_UART_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800417c": "reset_uart_instance_0800417c",
                "huart": "uart_handle",
                "Instance": "uart_instance",
                "CR1": "control_register_1",
                "CR3": "control_register_3",
                "RxState": "receive_state"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004198": {
            "entrypoint": "0x08004198",
            "current_name": "transmit_data_08004198",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict transmitData_08004198(UART_HandleTypeDef *uartHandle)\n\n{\n  uint16_t remainingCount;\n  byte *dataPtr;\n  uint16_t *tempVar;\n  \n  if (uartHandle->gState != HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  if ((uartHandle->Init).WordLength == 0x1000) {\n    uartHandle->Instance->DR = *(ushort *)uartHandle->pTxBuffPtr & 0x1ff;\n    if ((uartHandle->Init).Parity == 0) {\n      uartHandle->pTxBuffPtr = uartHandle->pTxBuffPtr + 2;\n    }\n    else {\n      uartHandle->pTxBuffPtr = uartHandle->pTxBuffPtr + 1;\n    }\n  }\n  else {\n    dataPtr = uartHandle->pTxBuffPtr;\n    uartHandle->pTxBuffPtr = dataPtr + 1;\n    uartHandle->Instance->DR = (uint)*dataPtr;\n  }\n  remainingCount = uartHandle->TxXferCount - 1;\n  uartHandle->TxXferCount = remainingCount;\n  if (remainingCount == 0) {\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xffffff7f;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x40;\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004198": "transmit_data_08004198",
                "huart": "uartHandle",
                "uVar1": "remainingCount",
                "pbVar2": "dataPtr",
                "tmp": "tempVar"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004204": {
            "entrypoint": "0x08004204",
            "current_name": "configure_uart_08004204",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureUART_08004204(UART_Config *huart)\n\n{\n  uint32_t pclk1Freq;\n  uint32_t pclk1Freq2;\n  uint32_t pclk1Freq3;\n  uint32_t pclk1Freq4;\n  uint32_t pclk1Freq5;\n  uint32_t baudRate;\n  uint32_t baudRate2;\n  uint32_t baudRate3;\n  uint32_t baudRate4;\n  USART_TypeDef *uartInstance;\n  \n  huart->Instance->CR2 = huart->Instance->CR2 & 0xffffcfff | (huart->Init).StopBits;\n  huart->Instance->CR1 =\n       (huart->Init).WordLength | (huart->Init).Parity | (huart->Init).Mode |\n       huart->Instance->CR1 & 0xffffe9f3;\n  huart->Instance->CR3 = huart->Instance->CR3 & 0xfffffcff | (huart->Init).HwFlowCtl;\n  uartInstance = huart->Instance;\n  if (uartInstance != (USART_TypeDef *)0x40013800) {\n    pclk1Freq = HAL_RCC_GetPCLK1Freq();\n    baudRate = (huart->Init).BaudRate;\n    pclk1Freq2 = HAL_RCC_GetPCLK1Freq();\n    baudRate2 = (huart->Init).BaudRate;\n    pclk1Freq3 = HAL_RCC_GetPCLK1Freq();\n    baudRate3 = (huart->Init).BaudRate;\n    pclk1Freq4 = HAL_RCC_GetPCLK1Freq();\n    baudRate4 = (huart->Init).BaudRate;\n    pclk1Freq5 = HAL_RCC_GetPCLK1Freq();\n    uartInstance->BRR = ((uint)((int)((ulonglong)\n                                 (((pclk1Freq4 * 0x19) / (baudRate4 << 2) +\n                                  (int)(((ulonglong)(pclk1Freq5 * 0x19) /\n                                        (ulonglong)((huart->Init).BaudRate << 2)) / 100) * -100) *\n                                  0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                   ((((pclk1Freq2 * 0x19) / (baudRate2 << 2) +\n                     (int)(((ulonglong)(pclk1Freq3 * 0x19) / (ulonglong)(baudRate3 << 2)) / 100) * -100) *\n                     0x10 + 0x32) / 100 & 0xf0) +\n                   (int)(((ulonglong)(pclk1Freq * 0x19) / (ulonglong)(baudRate << 2)) / 100) * 0x10;\n    return;\n  }\n  pclk1Freq = HAL_RCC_GetPCLK2Freq();\n  baudRate = (huart->Init).BaudRate;\n  pclk1Freq2 = HAL_RCC_GetPCLK2Freq();\n  baudRate2 = (huart->Init).BaudRate;\n  pclk1Freq3 = HAL_RCC_GetPCLK2Freq();\n  baudRate3 = (huart->Init).BaudRate;\n  pclk1Freq4 = HAL_RCC_GetPCLK2Freq();\n  baudRate4 = (huart->Init).BaudRate;\n  pclk1Freq5 = HAL_RCC_GetPCLK2Freq();\n  iRam40013808 = ((uint)((int)((ulonglong)\n                               (((pclk1Freq4 * 0x19) / (baudRate4 << 2) +\n                                (int)(((ulonglong)(pclk1Freq5 * 0x19) /\n                                      (ulonglong)((huart->Init).BaudRate << 2)) / 100) * -100) *\n                                0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                 ((((pclk1Freq2 * 0x19) / (baudRate2 << 2) +\n                   (int)(((ulonglong)(pclk1Freq3 * 0x19) / (ulonglong)(baudRate3 << 2)) / 100) * -100) * 0x10\n                  + 0x32) / 100 & 0xf0) +\n                 (int)(((ulonglong)(pclk1Freq * 0x19) / (ulonglong)(baudRate << 2)) / 100) * 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004204": "configure_uart_08004204",
                "UART_HandleTypeDef": "UART_Config",
                "uVar1": "pclk1Freq",
                "uVar2": "pclk1Freq2",
                "uVar3": "pclk1Freq3",
                "uVar4": "pclk1Freq4",
                "uVar5": "pclk1Freq5",
                "uVar6": "baudRate",
                "uVar7": "baudRate2",
                "uVar8": "baudRate3",
                "uVar9": "baudRate4",
                "pUVar10": "uartInstance"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080043b4": {
            "entrypoint": "0x080043b4",
            "current_name": "check_flag_status_080043b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatusTypeDef\ncheckFlagStatus_080043b4(UART_HandleTypeDef *uartHandle,uint32_t flagMask,flagMaskexpectedStatus expectedStatus,uint32_t tickStart,\n            uint32_t timeout)\n\n{\n  uint32_t currentTick;\n  \n  do {\n    if (((flagMask & ~uartHandle->uartInstance->statusRegister) == 0) != (bool)expectedStatus) {\n      return OK;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTick = getTick(), currentTick - tickStart <= timeout))));\n  uartHandle->uartInstance->controlRegister1 = uartHandle->uartInstance->controlRegister1 & 0xfffffe5f;\n  uartHandle->uartInstance->controlRegister3 = uartHandle->uartInstance->controlRegister3 & 0xfffffffe;\n  uartHandle->globalState = HAL_UART_STATE_READY;\n  uartHandle->receiveState = HAL_UART_STATE_READY;\n  uartHandle->lockState = UNLOCKED;\n  return TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_080043b4": "check_flag_status_080043b4",
                "huart": "uartHandle",
                "Flag": "flagMask",
                "Status": "expectedStatus",
                "Tickstart": "tickStart",
                "Timeout": "timeout",
                "uVar1": "currentTick",
                "HAL_StatusTypeDef_conflict": "StatusTypeDef",
                "Instance": "uartInstance",
                "SR": "statusRegister",
                "CR1": "controlRegister1",
                "CR3": "controlRegister3",
                "gState": "globalState",
                "RxState": "receiveState",
                "Lock": "lockState",
                "HAL_UNLOCKED": "UNLOCKED",
                "HAL_OK": "OK",
                "HAL_TIMEOUT": "TIMEOUT",
                "HAL_GetTick": "getTick"
            },
            "calling": [
                "HAL_UART_Transmit"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004418": {
            "entrypoint": "0x08004418",
            "current_name": "FUNC_08004418",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004418(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004418": "FUNC_08004418"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800441a": {
            "entrypoint": "0x0800441a",
            "current_name": "initialize_uart_0800441a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nUART_Status initialize_UART_0800441a(UART_HandleTypeDef *UART_handle)\n\n{\n  if (UART_handle != (UART_HandleTypeDef *)0x0) {\n    if (UART_handle->general_state == HAL_UART_STATE_RESET) {\n      UART_handle->lock = HAL_UNLOCKED;\n      HAL_UART_MspInit(UART_handle);\n    }\n    UART_handle->general_state = HAL_UART_STATE_BUSY;\n    UART_handle->UART_instance->control_register_1 = UART_handle->UART_instance->control_register_1 & 0xffffdfff;\n    UART_SetConfig(UART_handle);\n    UART_handle->UART_instance->control_register_2 = UART_handle->UART_instance->control_register_2 & 0xffffb7ff;\n    UART_handle->UART_instance->control_register_3 = UART_handle->UART_instance->control_register_3 & 0xffffffd5;\n    UART_handle->UART_instance->control_register_1 = UART_handle->UART_instance->control_register_1 | 0x2000;\n    UART_handle->error_code = 0;\n    UART_handle->general_state = HAL_UART_STATE_READY;\n    UART_handle->receive_state = HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_0800441a": "initialize_uart_0800441a",
                "huart": "UART_handle",
                "gState": "general_state",
                "Lock": "lock",
                "Instance": "UART_instance",
                "CR1": "control_register_1",
                "CR2": "control_register_2",
                "CR3": "control_register_3",
                "ErrorCode": "error_code",
                "RxState": "receive_state",
                "HAL_StatusTypeDef_conflict": "UART_Status"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004478": {
            "entrypoint": "0x08004478",
            "current_name": "send_data_08004478",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nsendData_08004478(UART_HandleTypeDef *uartHandle,uint8_t *dataBuffer,uint16_t dataSize,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t tickStart;\n  uint16_t *tmp;\n  \n  if (uartHandle->gState == UART_STATE_READY) {\n    if (dataBuffer == (uint8_t *)0x0) {\n      status = ERROR;\n    }\n    else if (dataSize == 0) {\n      status = ERROR;\n    }\n    else if (uartHandle->Lock == LOCKED) {\n      status = BUSY;\n    }\n    else {\n      uartHandle->Lock = LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->gState = UART_STATE_BUSY_TX;\n      tickStart = getTick();\n      uartHandle->transferSize = dataSize;\n      uartHandle->transferCount = dataSize;\n      while (uartHandle->transferCount != 0) {\n        uartHandle->transferCount = uartHandle->transferCount - 1;\n        if ((uartHandle->Init).wordLength == 0x1000) {\n          status = waitOnFlagUntilTimeout(uartHandle,0x80,RESET,tickStart,timeout);\n          if (status != OK) {\n            return TIMEOUT;\n          }\n          uartHandle->instance->dataRegister = *(ushort *)dataBuffer & 0x1ff;\n          if ((uartHandle->Init).parity == 0) {\n            dataBuffer = (uint8_t *)((int)dataBuffer + 2);\n          }\n          else {\n            dataBuffer = (uint8_t *)((int)dataBuffer + 1);\n          }\n        }\n        else {\n          status = waitOnFlagUntilTimeout(uartHandle,0x80,RESET,tickStart,timeout);\n          if (status != OK) {\n            return TIMEOUT;\n          }\n          uartHandle->instance->dataRegister = (uint)*dataBuffer;\n          dataBuffer = (uint8_t *)((int)dataBuffer + 1);\n        }\n      }\n      status = waitOnFlagUntilTimeout(uartHandle,0x40,RESET,tickStart,timeout);\n      if (status == OK) {\n        uartHandle->gState = UART_STATE_READY;\n        uartHandle->Lock = UNLOCKED;\n        status = OK;\n      }\n      else {\n        status = TIMEOUT;\n      }\n    }\n  }\n  else {\n    status = BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08004478": "send_data_08004478",
                "huart": "uartHandle",
                "pData": "dataBuffer",
                "Size": "dataSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "tickStart",
                "HAL_UART_STATE_READY": "UART_STATE_READY",
                "HAL_ERROR": "ERROR",
                "HAL_LOCKED": "LOCKED",
                "HAL_BUSY": "BUSY",
                "HAL_UART_STATE_BUSY_TX": "UART_STATE_BUSY_TX",
                "HAL_GetTick": "getTick",
                "TxXferSize": "transferSize",
                "TxXferCount": "transferCount",
                "UART_WaitOnFlagUntilTimeout": "waitOnFlagUntilTimeout",
                "HAL_OK": "OK",
                "HAL_TIMEOUT": "TIMEOUT",
                "HAL_UNLOCKED": "UNLOCKED",
                "DR": "dataRegister",
                "Instance": "instance",
                "WordLength": "wordLength",
                "Parity": "parity"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800455a": {
            "entrypoint": "0x0800455a",
            "current_name": "initialize_uart_transmission_0800455a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeUartTransmission_0800455a(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t size)\n\n{\n  if (uartHandle->gState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (data == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (size == 0) {\n    return HAL_ERROR;\n  }\n  if (uartHandle->Lock != HAL_LOCKED) {\n    uartHandle->pTxBuffPtr = data;\n    uartHandle->TxXfersize = size;\n    uartHandle->TxXferCount = size;\n    uartHandle->ErrorCode = 0;\n    uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n    uartHandle->Lock = HAL_UNLOCKED;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x80;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_0800455a": "initialize_uart_transmission_0800455a",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "size"
            },
            "calling": [
                "uart_attach_tx_callback",
                "HAL_UART_TxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045a2": {
            "entrypoint": "0x080045a2",
            "current_name": "configure_uart_receive_080045a2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureUartReceive_080045a2(UART_HandleTypeDef *uartHandle,uint8_t *receiveData,uint16_t dataSize)\n\n{\n  if (uartHandle->RxState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (receiveData == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (dataSize == 0) {\n    return HAL_ERROR;\n  }\n  if (uartHandle->Lock != HAL_LOCKED) {\n    uartHandle->pRxBuffPtr = receiveData;\n    uartHandle->RxXferdataSize = dataSize;\n    uartHandle->RxXferCount = dataSize;\n    uartHandle->ErrorCode = 0;\n    uartHandle->RxState = HAL_UART_STATE_BUSY_RX;\n    uartHandle->Lock = HAL_UNLOCKED;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x100;\n    uartHandle->Instance->CR3 = uartHandle->Instance->CR3 | 1;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x20;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_080045a2": "configure_uart_receive_080045a2",
                "huart": "uartHandle",
                "pData": "receiveData",
                "Size": "dataSize"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045fe": {
            "entrypoint": "0x080045fe",
            "current_name": "reset_uart_state_080045fe",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict resetUARTState_080045fe(UART_HandleTypeDef *uartHandle)\n\n{\n  uartHandle->uartInstance->controlRegister1 = uartHandle->uartInstance->controlRegister1 & 0xffffffbf;\n  uartHandle->globalState = HAL_UART_STATE_READY;\n  HAL_UART_TxCpltCallback(uartHandle);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080045fe": "reset_uart_state_080045fe",
                "huart": "uartHandle",
                "Instance": "uartInstance",
                "CR1": "controlRegister1",
                "gState": "globalState"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004618": {
            "entrypoint": "0x08004618",
            "current_name": "handle_received_data_08004618",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleReceivedData_08004618(UART_HandleTypeDef *uartHandle)\n\n{\n  uint16_t *dataPointer;\n  byte *bytePointer;\n  uint16_t count;\n  uint8_t *uint8Pointer;\n  \n  if (uartHandle->RxState != HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  if ((uartHandle->Init).WordLength == 0x1000) {\n    if ((uartHandle->Init).Parity == 0) {\n      *(ushort *)uartHandle->pRxBuffPtr = (ushort)((uartHandle->Instance->DR << 0x17) >> 0x17);\n      uartHandle->pRxBuffPtr = uartHandle->pRxBuffPtr + 2;\n    }\n    else {\n      *(ushort *)uartHandle->pRxBuffPtr = (ushort)uartHandle->Instance->DR & 0xff;\n      uartHandle->pRxBuffPtr = uartHandle->pRxBuffPtr + 1;\n    }\n  }\n  else if ((uartHandle->Init).Parity == 0) {\n    uint8Pointer = uartHandle->pRxBuffPtr;\n    uartHandle->pRxBuffPtr = uint8Pointer + 1;\n    *uint8Pointer = (uint8_t)uartHandle->Instance->DR;\n  }\n  else {\n    bytePointer = uartHandle->pRxBuffPtr;\n    uartHandle->pRxBuffPtr = bytePointer + 1;\n    *bytePointer = (byte)uartHandle->Instance->DR & 0x7f;\n  }\n  count = uartHandle->RxXferCount - 1;\n  uartHandle->RxXferCount = count;\n  if (count != 0) {\n    return HAL_OK;\n  }\n  uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xffffffdf;\n  uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffeff;\n  uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n  uartHandle->RxState = HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(uartHandle);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004618": "handle_received_data_08004618",
                "huart": "uartHandle",
                "tmp": "dataPointer",
                "pbVar1": "bytePointer",
                "uVar2": "count",
                "puVar3": "uint8Pointer"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046b8": {
            "entrypoint": "0x080046b8",
            "current_name": "handle_uart_interrupt_080046b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART_interrupt_080046b8(UART_HandleTypeDef *UART_handle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint CR1;\n  uint32_t CR1_its;\n  USART_TypeDef *UART_instance;\n  uint32_t CR3_its;\n  uint CR3_bit;\n  uint SR;\n  uint32_t isr_flags;\n  \n  UART_instance = UART_handle->Instance;\n  SR = UART_instance->SR;\n  CR1 = UART_instance->CR1;\n  if ((((SR & 0xf) == 0) && ((SR & 0x20) != 0)) && ((CR1 & 0x20) != 0)) {\n    UART_Receive_IT(UART_handle);\n    return;\n  }\n  if (((SR & 0xf) == 0) || ((CR3_bit = UART_instance->CR3 & 1, CR3_bit == 0 && ((CR1 & 0x120) == 0)))) {\n    if (((SR & 0x80) != 0) && ((CR1 & 0x80) != 0)) {\n      UART_Transmit_IT(UART_handle);\n      return;\n    }\n    if (((SR & 0x40) != 0) && ((CR1 & 0x40) != 0)) {\n      UART_EndTransmit_IT(UART_handle);\n    }\n  }\n  else {\n    if (((SR & 1) != 0) && ((CR1 & 0x100) != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 1;\n    }\n    if (((SR & 4) != 0) && (CR3_bit != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 2;\n    }\n    if (((SR & 2) != 0) && (CR3_bit != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 4;\n    }\n    if (((SR & 8) != 0) && (CR3_bit != 0)) {\n      UART_handle->ErrorCode = UART_handle->ErrorCode | 8;\n    }\n    if (UART_handle->ErrorCode != 0) {\n      if (((SR & 0x20) != 0) && ((CR1 & 0x20) != 0)) {\n        UART_Receive_IT(UART_handle);\n      }\n      if (((UART_handle->ErrorCode & 8) == 0) && ((UART_handle->Instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(UART_handle);\n        UART_handle->ErrorCode = 0;\n        return;\n      }\n      UART_EndRxTransfer(UART_handle);\n      UART_instance = UART_handle->Instance;\n      if ((UART_instance->CR3 & 0x40) == 0) {\n        HAL_UART_ErrorCallback(UART_handle);\n        return;\n      }\n      UART_instance->CR3 = UART_instance->CR3 & 0xffffffbf;\n      if (UART_handle->hdmarx == (DMA_HandleTypeDef *)0x0) {\n        HAL_UART_ErrorCallback(UART_handle);\n        return;\n      }\n      UART_handle->hdmarx->XferAbortCallback = UART_DMAAbortOnError + 1;\n      status = HAL_DMA_Abort_IT(UART_handle->hdmarx);\n      if (status != HAL_OK) {\n        (*UART_handle->hdmarx->XferAbortCallback)(UART_handle->hdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046b8": "handle_uart_interrupt_080046b8",
                "huart": "UART_handle",
                "HVar1": "status",
                "uVar2": "CR1",
                "uVar4": "CR3_bit",
                "uVar5": "SR",
                "cr1its": "CR1_its",
                "cr3its": "CR3_its",
                "isrflags": "isr_flags",
                "pUVar3": "UART_instance"
            },
            "calling": [
                "USART2_IRQHandler",
                "USART3_IRQHandler",
                "USART1_IRQHandler"
            ],
            "called": [
                "HAL_DMA_Abort_IT",
                "HAL_UART_ErrorCallback",
                "UART_EndRxTransfer",
                "UART_EndTransmit_IT",
                "UART_Transmit_IT",
                "UART_Receive_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047d8": {
            "entrypoint": "0x080047d8",
            "current_name": "handle_dma_interrupt_080047d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_DMA_interrupt_080047d8(DMA_HandleTypeDef *dma_handle)\n\n{\n  UART_HandleTypeDef *uart_handle;\n  UART_HandleTypeDef *uart_handle;\n  \n  uart_handle = (UART_HandleTypeDef *)dma_handle->Parent;\n  uart_handle->RxXferCount = 0;\n  uart_handle->TxXferCount = 0;\n  HAL_UART_ErrorCallback(uart_handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047d8": "handle_dma_interrupt_080047d8",
                "hdma": "dma_handle",
                "huart_00": "uart_handle",
                "huart": "uart_handle"
            },
            "calling": [],
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047e8": {
            "entrypoint": "0x080047e8",
            "current_name": "get_uart_state_080047e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_UART_StateTypeDef get_uart_state_080047e8(UART_HandleTypeDef *uart_handle)\n\n{\n  return uart_handle->RxState | uart_handle->gState;\n}\n\n",
            "renaming": {
                "FUN_080047e8": "get_uart_state_080047e8",
                "huart": "uart_handle"
            },
            "calling": [
                "serial_tx_active",
                "serial_rx_active"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047f4": {
            "entrypoint": "0x080047f4",
            "current_name": "check_pin_value_080047f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool checkPinValue_080047f4(PinName_conflict pinName,uint32_t *pinMap)\n\n{\n  uint32_t pinIndex;\n  \n  pinIndex = pinMap[(uint)((int)pinName << 0x18) >> 0x1c];\n  return (_Bool)((byte)(pinIndex >> ((int)pinName & 0xfU)) & 1);\n}\n\n",
            "renaming": {
                "FUN_080047f4": "check_pin_value_080047f4",
                "pin": "pinName",
                "map": "pinMap",
                "index": "pinIndex"
            },
            "calling": [
                "digitalWrite",
                "digitalRead",
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800480a": {
            "entrypoint": "0x0800480a",
            "current_name": "update_pin_map_0800480a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updatePinMap_0800480a(PinName_conflict selectedPin,uint32_t *pinMap)\n\n{\n  uint shiftedIndex;\n  uint32_t originalIndex;\n  \n  shiftedIndex = (uint)((int)selectedPin << 0x18) >> 0x1c;\n  pinMap[shiftedIndex] = pinMap[shiftedIndex] | 1 << ((int)selectedPin & 0xfU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800480a": "update_pin_map_0800480a",
                "pin": "selectedPin",
                "map": "pinMap",
                "uVar1": "shiftedIndex",
                "index": "originalIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004828": {
            "entrypoint": "0x08004828",
            "current_name": "clear_pin_from_map_08004828",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearPinFromMap_08004828(PinName_conflict pinName,uint32_t *pinMap)\n\n{\n  uint shiftedIndex;\n  uint32_t index;\n  \n  shiftedIndex = (uint)((int)pinName << 0x18) >> 0x1c;\n  pinMap[shiftedIndex] = pinMap[shiftedIndex] & ~(1 << ((int)pinName & 0xfU));\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004828": "clear_pin_from_map_08004828",
                "pin": "pinName",
                "map": "pinMap",
                "uVar1": "shiftedIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004848": {
            "entrypoint": "0x08004848",
            "current_name": "get_gpio_by_port_index_08004848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nGPIOType * getGPIOByPortIndex_08004848(uint32_t portIndex)\n\n{\n  switch(portIndex) {\n  case 0:\n    return (GPIOType *)0x40010800;\n  case 1:\n    return (GPIOType *)0x40010c00;\n  case 2:\n    return (GPIOType *)0x40011000;\n  case 3:\n    return (GPIOType *)0x40011400;\n  case 4:\n    return (GPIOType *)0x40011800;\n  default:\n    return (GPIOType *)0x0;\n  }\n}\n\n",
            "renaming": {
                "FUN_08004848": "get_gpio_by_port_index_08004848",
                "port_idx": "portIndex",
                "GPIO_TypeDef": "GPIOType"
            },
            "calling": [
                "digitalWrite",
                "digitalRead"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004884": {
            "entrypoint": "0x08004884",
            "current_name": "get_gpio_08004884",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * getGPIO_08004884(uint32_t portIndex)\n\n{\n  GPIO_TypeDef *gpioPointer;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister_1;\n  uint32_t temporaryRegister_2;\n  uint32_t temporaryRegister_3;\n  uint32_t temporaryRegister_4;\n  \n  switch(portIndex) {\n  case 0:\n    _DAT_40021018 = _DAT_40021018 | 4;\n    gpioPointer = (GPIO_TypeDef *)0x40010800;\n    break;\n  case 1:\n    _DAT_40021018 = _DAT_40021018 | 8;\n    gpioPointer = (GPIO_TypeDef *)0x40010c00;\n    break;\n  case 2:\n    _DAT_40021018 = _DAT_40021018 | 0x10;\n    gpioPointer = (GPIO_TypeDef *)0x40011000;\n    break;\n  case 3:\n    _DAT_40021018 = _DAT_40021018 | 0x20;\n    gpioPointer = (GPIO_TypeDef *)0x40011400;\n    break;\n  case 4:\n    _DAT_40021018 = _DAT_40021018 | 0x40;\n    gpioPointer = (GPIO_TypeDef *)0x40011800;\n    break;\n  default:\n    gpioPointer = (GPIO_TypeDef *)0x0;\n  }\n  return gpioPointer;\n}\n\n",
            "renaming": {
                "FUN_08004884": "get_gpio_08004884",
                "port_idx": "portIndex",
                "pGVar1": "gpioPointer",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister_1",
                "tmpreg_2": "temporaryRegister_2",
                "tmpreg_3": "temporaryRegister_3",
                "tmpreg_4": "temporaryRegister_4"
            },
            "calling": [
                "digital_io_init",
                "uart_init",
                "HAL_ADC_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800492c": {
            "entrypoint": "0x0800492c",
            "current_name": "get_adc_function_0800492c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getADCFunction_0800492c(PinName_conflict pin)\n\n{\n  uint32_t functionResult;\n  uint32_t shiftedFunction;\n  \n  functionResult = pinmap_shiftedFunction(pin,(PinMap_conflict *)&PinMap_ADC);\n  shiftedFunction = functionResult << 0xc;\n  shiftedFunction = shiftedFunction >> 0x1b;\n  if (0x10 < shiftedFunction - 1) {\n    shiftedFunction = 0;\n  }\n  return shiftedFunction;\n}\n\n",
            "renaming": {
                "FUN_0800492c": "get_adc_function_0800492c",
                "uVar1": "functionResult",
                "function": "shiftedFunction"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004948": {
            "entrypoint": "0x08004948",
            "current_name": "pin_to_function_08004948",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t pin_to_function_08004948(pin pin)\n\n{\n  uint32_t function_mapping;\n  uint32_t mapped_function;\n  \n  function_mapping = pinmap_mapped_function(pin,(PinMap_conflict *)&PinMap_PWM);\n  mapped_function = function_mapping << 0xc;\n  mapped_function = mapped_function >> 0x1b;\n  if (mapped_function == 3) {\n    return 8;\n  }\n  if (mapped_function != 4) {\n    if (mapped_function != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
            "renaming": {
                "FUN_08004948": "pin_to_function_08004948",
                "PinName_conflict": "pin",
                "uVar1": "function_mapping",
                "function": "mapped_function"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004974": {
            "entrypoint": "0x08004974",
            "current_name": "configure_adc_gpio_pin_08004974",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureADC_GPIO_Pin_08004974(ADC_HandleTypeDef *adc_handle)\n\n{\n  GPIO_TypeDef *gpio_port;\n  GPIO_TypeDef *gpio_port;\n  uint32_t temporary_register;\n  uint32_t temporary_register_1;\n  GPIO_InitTypeDef gpio_init_struct;\n  \n  if (adc_handle->Instance == (ADC_TypeDef *)0x40012400) {\n    _DAT_40021018 = _DAT_40021018 | 0x200;\n  }\n  else if (adc_handle->Instance == (ADC_TypeDef *)0x40012800) {\n    _DAT_40021018 = _DAT_40021018 | 0x400;\n  }\n  gpio_port = set_GPIO_Port_Clock((uint)((int)g_current_pin << 0x18) >> 0x1c);\n  gpio_init_struct.Pin = 1 << (g_current_pin & 0xfU) & 0xffff;\n  gpio_init_struct.Mode = 3;\n  gpio_init_struct.Pull = 0;\n  HAL_GPIO_Init(gpio_port,&gpio_init_struct);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004974": "configure_adc_gpio_pin_08004974",
                "hadc": "adc_handle",
                "GPIOx": "gpio_port",
                "port": "gpio_port",
                "tmpreg": "temporary_register",
                "tmpreg_1": "temporary_register_1",
                "GPIO_InitStruct": "gpio_init_struct"
            },
            "calling": [
                "HAL_ADC_Init"
            ],
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049f0": {
            "entrypoint": "0x080049f0",
            "current_name": "update_adc_instance_080049f0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid update_ADC_Instance_080049f0(ADC_HandleTypeDef *adc_handle)\n\n{\n  if (adc_handle->Instance != (ADC_TypeDef *)0x40012400) {\n    if (adc_handle->Instance == (ADC_TypeDef *)0x40012800) {\n      _DAT_4002100c = _DAT_4002100c & 0xfffffbff;\n      _DAT_40021018 = _DAT_40021018 & 0xfffffbff;\n    }\n    return;\n  }\n  _DAT_4002100c = _DAT_4002100c & 0xfffffdff;\n  _DAT_40021018 = _DAT_40021018 & 0xfffffdff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080049f0": "update_adc_instance_080049f0",
                "hadc": "adc_handle"
            },
            "calling": [
                "HAL_ADC_DeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a4c": {
            "entrypoint": "0x08004a4c",
            "current_name": "read_adc_value_08004a4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint16_t readADCValue_08004a4c(pinConfig pin)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t convertedValue;\n  uint16_t finalConvertedValue;\n  ADC_ChannelConfTypeDef adcChannelConfig;\n  ADC_HandleTypeDef adcHandle;\n  \n  memset(&adcHandle,0,0x30);\n  adcChannelConfig.Channel = 0;\n  adcChannelConfig.Rank = 0;\n  adcChannelConfig.SamplingTime = 0;\n  finalConvertedValue = 0;\n  adcHandle.Instance = (ADC_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)&PinMap_ADC);\n  if (adcHandle.Instance == (ADC_TypeDef *)0x0) {\n    finalConvertedValue = 0;\n  }\n  else {\n    adcHandle.Init.DataAlign = 0;\n    adcHandle.Init.ScanConvMode = 0;\n    adcHandle.Init.ContinuousConvMode = 0;\n    adcHandle.Init.DiscontinuousConvMode = 0;\n    adcHandle.Init.ExternalTrigConv = 0xe0000;\n    adcHandle.State = 0;\n    adcHandle.Init.NbrOfConversion = 1;\n    adcHandle.Init.NbrOfDiscConversion = 0;\n    g_current_pin = pin;\n    status = HAL_ADC_Init(&adcHandle);\n    if (status == HAL_OK) {\n      adcChannelConfig.Channel = get_adc_channel(pin);\n      if (adcChannelConfig.Channel < 0x12) {\n        adcChannelConfig.Rank = 1;\n        adcChannelConfig.SamplingTime = 2;\n        status = HAL_ADC_ConfigChannel(&adcHandle,&adcChannelConfig);\n        if (status == HAL_OK) {\n          status = HAL_ADCEx_Calibration_Start(&adcHandle);\n          if (status == HAL_OK) {\n            status = HAL_ADC_Start(&adcHandle);\n            if (status == HAL_OK) {\n              status = HAL_ADC_PollForConversion(&adcHandle,10);\n              if (status == HAL_OK) {\n                convertedValue = HAL_ADC_GetState(&adcHandle);\n                if ((convertedValue & 0x200) != 0) {\n                  convertedValue = HAL_ADC_GetValue(&adcHandle);\n                  finalConvertedValue = (uint16_t)convertedValue;\n                }\n                status = HAL_ADC_Stop(&adcHandle);\n                if (status == HAL_OK) {\n                  status = HAL_ADC_DeInit(&adcHandle);\n                  if (status != HAL_OK) {\n                    finalConvertedValue = 0;\n                  }\n                }\n                else {\n                  finalConvertedValue = 0;\n                }\n              }\n              else {\n                finalConvertedValue = 0;\n              }\n            }\n            else {\n              finalConvertedValue = 0;\n            }\n          }\n          else {\n            finalConvertedValue = 0;\n          }\n        }\n        else {\n          finalConvertedValue = 0;\n        }\n      }\n      else {\n        finalConvertedValue = 0;\n      }\n    }\n    else {\n      finalConvertedValue = 0;\n    }\n  }\n  return finalConvertedValue;\n}\n\n",
            "renaming": {
                "FUN_08004a4c": "read_adc_value_08004a4c",
                "PinName_conflict": "pinConfig",
                "HVar1": "status",
                "uVar2": "convertedValue",
                "uhADCxConvertedValue": "finalConvertedValue",
                "AdcChannelConf": "adcChannelConfig",
                "AdcHandle": "adcHandle"
            },
            "calling": [
                "analogRead"
            ],
            "called": [
                "HAL_ADC_DeInit",
                "HAL_ADC_GetState",
                "get_adc_channel",
                "HAL_ADC_PollForConversion",
                "HAL_ADC_ConfigChannel",
                "HAL_ADC_GetValue",
                "memset",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Stop",
                "pinmap_peripheral",
                "HAL_ADC_Init",
                "HAL_ADC_Start"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b34": {
            "entrypoint": "0x08004b34",
            "current_name": "disable_timer_clock_08004b34",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_timer_clock_08004b34(TIM_HandleTypeDef *timer_handle)\n\n{\n  disable_clock(timer_handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b34": "disable_timer_clock_08004b34",
                "htim": "timer_handle",
                "timer_disable_clock": "disable_clock"
            },
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "called": [
                "timer_disable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b3c": {
            "entrypoint": "0x08004b3c",
            "current_name": "stop_pwm_channel_08004b3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopPwmChannel_08004b3c(pin pin)\n\n{\n  uint32_t channel;\n  uint32_t timchannel;\n  uint32_t functionResult;\n  TIM_HandleTypeDef timHandle;\n  \n  timHandle.Instance = (TIM_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)&PinMap_PWM);\n  if ((timHandle.Instance != (TIM_TypeDef *)0x0) &&\n     ((((channel = get_pwm_channel(pin), channel == 0 || (channel == 4)) || (channel == 8)) ||\n      ((channel == 0xc || (channel == 0x18)))))) {\n    functionResult = pinmap_function(pin,(PinMap_conflict *)&PinMap_PWM);\n    if ((functionResult & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(&timHandle,channel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(&timHandle,channel);\n    }\n    HAL_TIM_PWM_DeInit(&timHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b3c": "stop_pwm_channel_08004b3c",
                "PinName_conflict": "pin",
                "Channel": "channel",
                "uVar1": "functionResult"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_TIM_PWM_DeInit",
                "HAL_TIM_PWM_Stop",
                "get_pwm_channel",
                "pinmap_peripheral",
                "HAL_TIMEx_PWMN_Stop",
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b94": {
            "entrypoint": "0x08004b94",
            "current_name": "get_current_tick_08004b94",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_tick_08004b94(void)\n\n{\n  uint32_t current_tick;\n  \n  current_tick = HAL_GetTick();\n  return current_tick;\n}\n\n",
            "renaming": {
                "FUN_08004b94": "get_current_tick_08004b94",
                "uVar1": "current_tick"
            },
            "calling": [
                "millis"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b9c": {
            "entrypoint": "0x08004b9c",
            "current_name": "FUNC_08004b9c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004b9c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b9c": "FUNC_08004b9c"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004b9e": {
            "entrypoint": "0x08004b9e",
            "current_name": "handle_sys_tick_interrupt_08004b9e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickInterrupt_08004b9e(void)\n\n{\n  incrementSystemTick();\n  handleSysTickIRQ();\n  handleSystickWithoutOs();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b9e": "handle_sys_tick_interrupt_08004b9e",
                "HAL_IncTick": "incrementSystemTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTickIRQ",
                "noOsSystickHandler": "handleSystickWithoutOs"
            },
            "calling": [],
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "noOsSystickHandler",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bb0": {
            "entrypoint": "0x08004bb0",
            "current_name": "configure_pin_08004bb0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configure_pin_08004bb0(pin_name pin,uint32_t pin_mode,uint32_t pull_mode)\n\n{\n  uint pin_value;\n  GPIO_TypeDef *gpio_port;\n  GPIO_TypeDef *gpio_port_2;\n  uint32_t temp_register_2;\n  uint32_t temp_register_1;\n  uint32_t temp_register;\n  GPIO_InitTypeDef gpio_init_structure;\n  \n  pin_value = (uint)pin;\n  gpio_port = set_GPIO_Port_Clock((pin_value << 0x18) >> 0x1c);\n  gpio_init_structure.Pin = 1 << (pin_value & 0xf) & 0xffff;\n  gpio_init_structure.Speed = 3;\n  _DAT_40021018 = _DAT_40021018 | 1;\n  if ((pin_value - 0xd & 0xff) < 2) {\n    _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x4000000;\n  }\n  if (((pin_value == 0xf) || (pin_value == 0x13)) || (pin_value == 0x14)) {\n    temp_register_1 = _DAT_40010004 & 0xf8ffffff;\n    _DAT_40010004 = temp_register_1 | 0x2000000;\n  }\n  gpio_init_structure.Mode = pin_mode;\n  gpio_init_structure.Pull = pull_mode;\n  HAL_GPIO_Init(gpio_port,&gpio_init_structure);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bb0": "configure_pin_08004bb0",
                "PinName_conflict": "pin_name",
                "mode": "pin_mode",
                "pull": "pull_mode",
                "uVar1": "pin_value",
                "GPIOx": "gpio_port",
                "port": "gpio_port_2",
                "tmpreg_2": "temp_register_2",
                "tmpreg_1": "temp_register_1",
                "tmpreg": "temp_register",
                "GPIO_InitStructure": "gpio_init_structure"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c30": {
            "entrypoint": "0x08004c30",
            "current_name": "set_pin_state_08004c30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinState_08004c30(GPIO_TypeDef *gpioPort,uint32_t pinNumber,uint32_t state)\n\n{\n  if (state == 0) {\n    HAL_GPIO_WritePin(gpioPort,(uint16_t)pinNumber,GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(gpioPort,(uint16_t)pinNumber,GPIO_PIN_SET);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c30": "set_pin_state_08004c30",
                "port": "gpioPort",
                "pin": "pinNumber",
                "val": "state"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c48": {
            "entrypoint": "0x08004c48",
            "current_name": "read_gpio_pin_08004c48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t read_gpio_pin_08004c48(GPIO_TypeDef *gpio_port,uint32_t gpio_pin)\n\n{\n  GPIO_PinState pin_state;\n  \n  pin_state = HAL_GPIO_ReadPin(gpio_port,(uint16_t)gpio_pin);\n  return (uint)pin_state;\n}\n\n",
            "renaming": {
                "FUN_08004c48": "read_gpio_pin_08004c48",
                "port": "gpio_port",
                "pin": "gpio_pin",
                "GVar1": "pin_state"
            },
            "calling": [
                "digitalRead"
            ],
            "called": [
                "HAL_GPIO_ReadPin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c52": {
            "entrypoint": "0x08004c52",
            "current_name": "initialize_system_08004c52",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_system_08004c52(void)\n\n{\n  initialize_HAL();\n  configure_system_clock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c52": "initialize_system_08004c52",
                "HAL_Init": "initialize_HAL",
                "SystemClock_Config": "configure_system_clock"
            },
            "calling": [
                "init"
            ],
            "called": [
                "HAL_Init",
                "SystemClock_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c5e": {
            "entrypoint": "0x08004c5e",
            "current_name": "find_peripheral_08004c5e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * findPeripheral_08004c5e(pin pin,pinMap *currentPinMap)\n\n{\n  while( true ) {\n    if (currentPinMap->pin == NC) {\n      return (void *)0x0;\n    }\n    if (currentPinMap->pin == pin) break;\n    currentPinMap = currentPinMap + 1;\n  }\n  return currentPinMap->peripheral;\n}\n\n",
            "renaming": {
                "FUN_08004c5e": "find_peripheral_08004c5e",
                "PinName_conflict": "pin",
                "PinMap_conflict": "pinMap",
                "map": "currentPinMap"
            },
            "calling": [
                "pinmap_find_peripheral",
                "pinmap_peripheral"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c78": {
            "entrypoint": "0x08004c78",
            "current_name": "find_peripheral_08004c78",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * find_peripheral_08004c78(pin pin,map *map)\n\n{\n  void *peripheral;\n  \n  if (pin != NC) {\n    peripheral = pinmap_find_peripheral_08004c78(pin,map);\n    return peripheral;\n  }\n  return (void *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08004c78": "find_peripheral_08004c78",
                "PinName_conflict": "pin",
                "PinMap_conflict": "map",
                "pvVar1": "peripheral"
            },
            "calling": [
                "uart_debug_init",
                "adc_read_value",
                "pwm_stop",
                "uart_init",
                "uart_debug_write"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c8a": {
            "entrypoint": "0x08004c8a",
            "current_name": "find_pin_08004c8a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName findPin_08004c8a(void *targetPeripheral,PinMap *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->targetPeripheral == (void *)0x0) {\n      return NoConnection;\n    }\n    if (pinMap->targetPeripheral == targetPeripheral) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->pin;\n}\n\n",
            "renaming": {
                "FUN_08004c8a": "find_pin_08004c8a",
                "peripheral": "targetPeripheral",
                "PinMap_conflict": "PinMap",
                "map": "pinMap",
                "NC": "NoConnection",
                "PinName_conflict": "PinName"
            },
            "calling": [
                "pinmap_pin",
                "pinmap_find_pin"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ca2": {
            "entrypoint": "0x08004ca2",
            "current_name": "find_pin_for_peripheral_08004ca2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict find_pin_for_peripheral_08004ca2(void *peripheral_ptr,PinMap_conflict_ptr *map)\n\n{\n  PinName_conflict found_pin;\n  \n  if (peripheral_ptr != (void *)0x0) {\n    found_pin = pinmap_find_pin(peripheral_ptr,map);\n    return found_pin;\n  }\n  return NotConnected;\n}\n\n",
            "renaming": {
                "FUN_08004ca2": "find_pin_for_peripheral_08004ca2",
                "peripheral": "peripheral_ptr",
                "PinMap_conflict": "PinMap_conflict_ptr",
                "PVar1": "found_pin",
                "NC": "NotConnected"
            },
            "calling": [
                "uart_debug_init",
                "HardwareSerial"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cb2": {
            "entrypoint": "0x08004cb2",
            "current_name": "find_pin_function_08004cb2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t findPinFunction_08004cb2(PinName_conflict targetPin,PinMap_conflict *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->targetPin == NoConnection) {\n      return 0xffffffff;\n    }\n    if (pinMap->targetPin == targetPin) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->function;\n}\n\n",
            "renaming": {
                "FUN_08004cb2": "find_pin_function_08004cb2",
                "pin": "targetPin",
                "map": "pinMap",
                "NC": "NoConnection"
            },
            "calling": [
                "pinmap_find_function",
                "pinmap_function"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cce": {
            "entrypoint": "0x08004cce",
            "current_name": "pinmap_find_mapped_function_08004cce",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t pinmap_find_mapped_function_08004cce(PinName_conflict pin_name,PinMap_conflict *pin_map)\n\n{\n  uint32_t result;\n  \n  if (pin_name == NC) {\n    return 0xffffffff;\n  }\n  result = pin_namepin_map_find_function(pin_name,pin_map);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004cce": "pinmap_find_mapped_function_08004cce",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "result"
            },
            "calling": [
                "get_adc_channel",
                "pwm_stop",
                "get_pwm_channel",
                "uart_init"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ce2": {
            "entrypoint": "0x08004ce2",
            "current_name": "pin_exists_08004ce2",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool pin_exists_08004ce2(pin pin,pin_map *current_pin_map)\n\n{\n  if (pin == not_connected) {\n    return false;\n  }\n  while( true ) {\n    if (current_pin_map->pin == not_connected) {\n      return false;\n    }\n    if (pin == current_pin_map->pin) break;\n    current_pin_map = current_pin_map + 1;\n  }\n  return true;\n}\n\n",
            "renaming": {
                "FUN_08004ce2": "pin_exists_08004ce2",
                "PinName_conflict": "pin",
                "PinMap_conflict": "pin_map",
                "NC": "not_connected",
                "map": "current_pin_map"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d06": {
            "entrypoint": "0x08004d06",
            "current_name": "merge_pointers_08004d06",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * merge_pointers_08004d06(void *a,void *b)\n\n{\n  if (a != b) {\n    if (a == (void *)0x0) {\n      return b;\n    }\n    if (b == (void *)0x0) {\n      return a;\n    }\n    a = (void *)0x0;\n  }\n  return a;\n}\n\n",
            "renaming": {
                "FUN_08004d06": "merge_pointers_08004d06"
            },
            "calling": [
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d18": {
            "entrypoint": "0x08004d18",
            "current_name": "execute_rtc_user_callback_08004d18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid executeRTCUserCallback_08004d18(RTC_HandleTypeDef *rtcHandler)\n\n{\n  if (userCallback != (callbackFunctionPtr)0x0) {\n    (*userCallback)(userData);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d18": "execute_rtc_user_callback_08004d18",
                "hrtc": "rtcHandler",
                "RTCUserCallback": "userCallback",
                "voidCallbackPtr": "callbackFunctionPtr",
                "callbackUserData": "userData"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d30": {
            "entrypoint": "0x08004d30",
            "current_name": "handle_alarm_interrupt_08004d30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleAlarmInterrupt_08004d30(void)\n\n{\n  HAL_RTC_AlarmIRQHandler(&RtcHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d30": "handle_alarm_interrupt_08004d30"
            },
            "calling": [],
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d40": {
            "entrypoint": "0x08004d40",
            "current_name": "infinite_loop_08004d40",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08004d40(char *message,int value)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004d40": "infinite_loop_08004d40",
                "msg": "message",
                "val": "value"
            },
            "calling": [
                "_Error_Handler",
                "SystemClock_Config"
            ],
            "called": [
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d44": {
            "entrypoint": "0x08004d44",
            "current_name": "initialize_system_08004d44",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_08004d44(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d44": "initialize_system_08004d44"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d90": {
            "entrypoint": "0x08004d90",
            "current_name": "update_timers_08004d90",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid updateTimers_08004d90(TIM_HandleTypeDef *htim)\n\n{\n  if (htim->Instance == (TimerStruct *)0x40012c00) {\n    _DAT_40021018 = _DAT_40021018 & 0xfffff7ff;\n  }\n  if (htim->Instance == (TimerStruct *)0x40000000) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffe;\n  }\n  if (htim->Instance == (TimerStruct *)0x40000400) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffd;\n  }\n  if (htim->Instance == (TimerStruct *)0x40000800) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d90": "update_timers_08004d90",
                "TIM_TypeDef": "TimerStruct"
            },
            "calling": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004df4": {
            "entrypoint": "0x08004df4",
            "current_name": "get_stimer_from_htim_08004df4",
            "code": "\n/* WARNING: Unknown calling convention */\n\ntimer_struct * get_stimer_from_htim_08004df4(TIM_HandleTypeDef *timer_handle)\n\n{\n  return (timer_struct *)&timer_handle[-1].lock_variable;\n}\n\n",
            "renaming": {
                "FUN_08004df4": "get_stimer_from_htim_08004df4",
                "htim": "timer_handle",
                "stimer_t": "timer_struct",
                "Lock": "lock_variable"
            },
            "calling": [
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004df8": {
            "entrypoint": "0x08004df8",
            "current_name": "handle_timer_interrupt_08004df8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08004df8(TIM_HandleTypeDef *timerHandle)\n\n{\n  stimer_t *timerObject;\n  stimer_t *timerObject;\n  \n  timerObject = get_timer_timerObject(timerHandle);\n  if ((timerObject->interruptHandlerOC != (_func_void_stimer_t_ptr_uint32_t *)0x0) &&\n     (timerHandle->Channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*timerObject->interruptHandlerOC)(timerObject,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004df8": "handle_timer_interrupt_08004df8",
                "htim": "timerHandle",
                "psVar1": "timerObject",
                "obj": "timerObject",
                "irqHandleOC": "interruptHandlerOC"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e12": {
            "entrypoint": "0x08004e12",
            "current_name": "handle_timer_interrupt_08004e12",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_timer_interrupt_08004e12(TIM_HandleTypeDef *timer_handle)\n\n{\n  stimer_t *timer_object;\n  stimer_t *timer_object_2;\n  \n  timer_object = get_timer_timer_object_2(timer_handle);\n  if (timer_object->irqHandle != (_func_void_stimer_t_ptr *)0x0) {\n    (*timer_object->irqHandle)(timer_object);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e12": "handle_timer_interrupt_08004e12",
                "htim": "timer_handle",
                "psVar1": "timer_object",
                "obj": "timer_object_2"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e20": {
            "entrypoint": "0x08004e20",
            "current_name": "handle_timer_interrupt_08004e20",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08004e20(void)\n\n{\n  if (timerHandle != (TimerHandleType *)0x0) {\n    HAL_TIM_IRQHandler(timerHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e20": "handle_timer_interrupt_08004e20",
                "timer_handles[0]": "timerHandle",
                "TIM_HandleTypeDef": "TimerHandleType"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e34": {
            "entrypoint": "0x08004e34",
            "current_name": "handle_timer_interrupt_08004e34",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08004e34(void)\n\n{\n  if (timerHandles[1] != (TimerHandle *)0x0) {\n    handleTimerIRQ(timerHandles[1]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e34": "handle_timer_interrupt_08004e34",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleTimerIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e48": {
            "entrypoint": "0x08004e48",
            "current_name": "handle_timer_interrupt_08004e48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08004e48(void)\n\n{\n  if (timerHandles[2] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e48": "handle_timer_interrupt_08004e48",
                "timer_handles": "timerHandles"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e5c": {
            "entrypoint": "0x08004e5c",
            "current_name": "handle_timer_interrupt_08004e5c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08004e5c(void)\n\n{\n  if (timerHandles[3] != (TimerHandle *)0x0) {\n    handleTimerInterrupt_08004e5cRequest(timerHandles[3]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e5c": "handle_timer_interrupt_08004e5c",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleTimerInterruptRequest"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e70": {
            "entrypoint": "0x08004e70",
            "current_name": "extract_i2c_t_from_hi2c_08004e70",
            "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_t * extract_i2c_t_from_hi2c_08004e70(I2C_HandleTypeDef *i2c_handle)\n\n{\n  return (i2c_t *)&i2c_handle[-1].event_count;\n}\n\n",
            "renaming": {
                "FUN_08004e70": "extract_i2c_t_from_hi2c_08004e70",
                "hi2c": "i2c_handle",
                "EventCount": "event_count"
            },
            "calling": [
                "HAL_I2C_AddrCallback",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e74": {
            "entrypoint": "0x08004e74",
            "current_name": "handle_i2_c_data_transfer_08004e74",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CDataTransfer_08004e74(I2C_HandleTypeDef *i2cHandle,uint8_t direction,uint16_t addressCode)\n\n{\n  I2C_Struct *i2cObjPtr;\n  I2C_Struct *i2cObj;\n  \n  i2cObjPtr = get_i2c_i2cObj(i2cHandle);\n  if ((uint)addressCode == (i2cHandle->Init).OwnAddress1) {\n    if (direction == '\\0') {\n      i2cObjPtr->bufferSize = '\\0';\n      i2cObjPtr->isSlaveMode = '\\0';\n      if (i2cObjPtr->slaveTransmitCallback != (_func_void *)0x0) {\n        (*i2cObjPtr->slaveTransmitCallback)();\n      }\n      HAL_I2C_Slave_Sequential_Transmit_IT\n                (i2cHandle,i2cObjPtr->buffer,(uint16_t)i2cObjPtr->bufferSize,8);\n      return;\n    }\n    i2cObjPtr->isSlaveMode = '\\x01';\n    HAL_I2C_Slave_Sequential_Receive_IT(i2cHandle,i2cObjPtr->buffer,0x20,8);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e74": "handle_i2_c_data_transfer_08004e74",
                "hi2c": "i2cHandle",
                "TransferDirection": "direction",
                "AddrMatchCode": "addressCode",
                "piVar1": "i2cObjPtr",
                "obj": "i2cObj",
                "i2c_t": "I2C_Struct",
                "i2c_onSlaveTransmit": "slaveTransmitCallback",
                "i2cTxRxBufferSize": "bufferSize",
                "slaveMode": "isSlaveMode",
                "i2cTxRxBuffer": "buffer",
                "ushort": "uint16_t"
            },
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "called": [
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "HAL_I2C_Slave_Sequential_Transmit_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ec4": {
            "entrypoint": "0x08004ec4",
            "current_name": "handle_i2c_slave_receive_08004ec4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_i2c_slave_receive_08004ec4(I2C_HandleTypeDef *i2c_handle)\n\n{\n  i2c_t *current_i2c_obj;\n  i2c_t *i2c_object;\n  uint bytes_remaining;\n  \n  current_i2c_obj = get_i2c_i2c_object(i2c_handle);\n  if (((current_i2c_obj->i2c_onSlaveReceive != (_func_void_uint8_t_ptr_int *)0x0) &&\n      (current_i2c_obj->slaveMode == '\\x01')) &&\n     (bytes_remaining = 0x20 - *(byte *)&(current_i2c_obj->handle).XferSize & 0xff, bytes_remaining != 0)) {\n    (*current_i2c_obj->i2c_onSlaveReceive)(current_i2c_obj->i2cTxRxBuffer,bytes_remaining);\n  }\n  HAL_I2C_EnableListen_IT(i2c_handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ec4": "handle_i2c_slave_receive_08004ec4",
                "hi2c": "i2c_handle",
                "piVar1": "current_i2c_obj",
                "obj": "i2c_object",
                "uVar2": "bytes_remaining"
            },
            "calling": [
                "I2C_ITError",
                "I2C_Slave_AF",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef4": {
            "entrypoint": "0x08004ef4",
            "current_name": "enable_listen_interrupt_08004ef4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableListenInterrupt_08004ef4(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2c_t *currentI2CObject;\n  i2c_t *temporaryObject;\n  \n  currentI2CObject = get_i2c_temporaryObject(i2cHandle);\n  if (currentI2CObject->isMaster == '\\0') {\n    HAL_I2C_EnableListen_IT(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef4": "enable_listen_interrupt_08004ef4",
                "hi2c": "i2cHandle",
                "piVar1": "currentI2CObject",
                "obj": "temporaryObject"
            },
            "calling": [
                "I2C_DMAAbort",
                "I2C_ITError"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f0c": {
            "entrypoint": "0x08004f0c",
            "current_name": "handle_i2_c_event_08004f0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvent_08004f0c(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2c_handles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f0c": "handle_i2_c_event_08004f0c"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f1c": {
            "entrypoint": "0x08004f1c",
            "current_name": "handle_i2_c_error_interrupt_08004f1c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CErrorInterrupt_08004f1c(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c_handles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f1c": "handle_i2_c_error_interrupt_08004f1c"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f2c": {
            "entrypoint": "0x08004f2c",
            "current_name": "handle_i2c_event_08004f2c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2cEvent_08004f2c(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2cErrorHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f2c": "handle_i2c_event_08004f2c",
                "I2C2_ER_IRQHandler::handle": "i2cErrorHandler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "handle_i2c_error_08004f3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_i2c_error_08004f3c(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c2_error_handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "handle_i2c_error_08004f3c",
                "I2C2_ER_IRQHandler::handle": "i2c2_error_handler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f4c": {
            "entrypoint": "0x08004f4c",
            "current_name": "initialize_serial_communication_08004f4c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_serial_communication_08004f4c(serial_t *serial_object)\n\n{\n  void *a;\n  USART_TypeDef *uart_transmitter;\n  void *b;\n  USART_TypeDef *uart_receiver;\n  USART_TypeDef *merged_peripheral;\n  GPIO_TypeDef *gpio_port;\n  GPIO_TypeDef *gpio_port;\n  uint32_t function_result;\n  uint32_t temp_register_4;\n  uint32_t temp_register_5;\n  uint32_t temp_register_6;\n  uint32_t temp_register_7;\n  uint32_t temp_register_8;\n  uint32_t temp_register_9;\n  uint32_t temp_register_10;\n  uint32_t temp_register_11;\n  uint32_t temp_register_12;\n  uint32_t temp_register_13;\n  uint32_t temp_register_14;\n  uint32_t temp_register_15;\n  uint32_t temp_register_16;\n  UART_HandleTypeDef *uart_handle;\n  uint32_t temp_register;\n  uint32_t temp_register_1;\n  uint32_t temp_register_2;\n  uint32_t temp_register_3;\n  GPIO_InitTypeDef gpio_init_struct;\n  \n  if (serial_object != (serial_t *)0x0) {\n    a = pinmap_peripheral(serial_object->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n    b = pinmap_peripheral(serial_object->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(\"ERROR: at least one UART pin has no peripheral\\n\");\n    }\n    else {\n      merged_peripheral = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      serial_object->uart = merged_peripheral;\n      if (merged_peripheral == (USART_TypeDef *)0x0) {\n        iprintf(\"ERROR: U(S)ART pins mismatch\\n\");\n      }\n      else {\n        if (merged_peripheral == (USART_TypeDef *)0x40013800) {\n          _DAT_4002100c = _DAT_4002100c & 0xffffbfff;\n          _DAT_40021018 = _DAT_40021018 | 0x4000;\n          serial_object->index = '\\0';\n          serial_object->irq = USART1_IRQn;\n        }\n        else if (merged_peripheral == (USART_TypeDef *)0x40004400) {\n          _DAT_40021010 = _DAT_40021010 & 0xfffdffff;\n          _DAT_4002101c = _DAT_4002101c | 0x20000;\n          serial_object->index = '\\x01';\n          serial_object->irq = USART2_IRQn;\n        }\n        else if (merged_peripheral == (USART_TypeDef *)0x40004800) {\n          _DAT_40021010 = _DAT_40021010 & 0xfffbffff;\n          _DAT_4002101c = _DAT_4002101c | 0x40000;\n          serial_object->index = '\\x02';\n          serial_object->irq = USART3_IRQn;\n        }\n        gpio_port = set_GPIO_Port_Clock((uint)((int)serial_object->pin_rx << 0x18) >> 0x1c);\n        function_result = pinmap_function(serial_object->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n        gpio_init_struct.Pin = 1 << (serial_object->pin_rx & 0xfU) & 0xffff;\n        gpio_init_struct.Mode = (function_result >> 3 & 1) << 4 | function_result & 7;\n        gpio_init_struct.Pull = (function_result << 0x1a) >> 0x1e;\n        _DAT_40021018 = _DAT_40021018 | 1;\n        switch((function_result << 0x11) >> 0x19) {\n        case 1:\n          temp_register_13 = temp_register_13 | 0x7000001;\n          break;\n        case 2:\n          temp_register_13 = temp_register_13 & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          temp_register_13 = temp_register_13 | 0x7000002;\n          break;\n        case 4:\n          temp_register_13 = temp_register_13 & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          temp_register_13 = temp_register_13 | 0x7000004;\n          break;\n        case 6:\n          temp_register_13 = temp_register_13 & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          temp_register_13 = temp_register_13 | 0x7000008;\n          break;\n        case 8:\n          temp_register_13 = temp_register_13 & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          temp_register_13 = temp_register_13 | 0x7000030;\n          break;\n        case 10:\n          temp_register_4 = temp_register_13 & 0xffffffcf;\n          temp_register_13 = temp_register_4 | 0x7000010;\n          break;\n        case 0xb:\n          temp_register_5 = temp_register_13 & 0xffffffcf;\n          temp_register_13 = temp_register_5 | 0x7000000;\n          break;\n        case 0xc:\n          temp_register_13 = temp_register_13 | 0x70000c0;\n          break;\n        case 0xd:\n          temp_register_6 = temp_register_13 & 0xffffff3f;\n          temp_register_13 = temp_register_6 | 0x7000040;\n          break;\n        case 0xe:\n          temp_register_7 = temp_register_13 & 0xffffff3f;\n          temp_register_13 = temp_register_7 | 0x7000000;\n          break;\n        case 0xf:\n          temp_register_13 = temp_register_13 | 0x7000300;\n          break;\n        case 0x10:\n          temp_register_8 = temp_register_13 & 0xfffffcff;\n          temp_register_13 = temp_register_8 | 0x7000200;\n          break;\n        case 0x11:\n          temp_register_9 = temp_register_13 & 0xfffffcff;\n          temp_register_13 = temp_register_9 | 0x7000100;\n          break;\n        case 0x12:\n          temp_register_10 = temp_register_13 & 0xfffffcff;\n          temp_register_13 = temp_register_10 | 0x7000000;\n          break;\n        case 0x13:\n          temp_register_13 = temp_register_13 | 0x7000c00;\n          break;\n        case 0x14:\n          temp_register_11 = temp_register_13 & 0xfffff3ff;\n          temp_register_13 = temp_register_11 | 0x7000800;\n          break;\n        case 0x15:\n          temp_register_12 = temp_register_13 & 0xfffff3ff;\n          temp_register_13 = temp_register_12 | 0x7000000;\n          break;\n        case 0x16:\n          temp_register_13 = temp_register_13 | 0x7001000;\n          break;\n        case 0x17:\n          temp_register_13 = temp_register_13 & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          temp_register_13 = temp_register_13 | 0x7008000;\n          break;\n        case 0x1c:\n          temp_register_13 = temp_register_13 & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          temp_register_13 = temp_register_13 & 0xf8ffffff;\n          break;\n        case 0x22:\n          temp_register_14 = temp_register_13 & 0xf8ffffff;\n          temp_register_13 = temp_register_14 | 0x1000000;\n          break;\n        case 0x23:\n          temp_register_15 = temp_register_13 & 0xf8ffffff;\n          temp_register_13 = temp_register_15 | 0x2000000;\n          break;\n        case 0x24:\n          temp_register_16 = temp_register_13 & 0xf8ffffff;\n          temp_register_13 = temp_register_16 | 0x4000000;\n        }\n        gpio_init_struct.Speed = 3;\n        HAL_GPIO_Init(gpio_port,&gpio_init_struct);\n        gpio_port = set_GPIO_Port_Clock((uint)((int)serial_object->pin_tx << 0x18) >> 0x1c);\n        function_result = pinmap_function(serial_object->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n        gpio_init_struct.Pin = 1 << (serial_object->pin_tx & 0xfU) & 0xffff;\n        gpio_init_struct.Mode = (function_result >> 3 & 1) << 4 | function_result & 7;\n        gpio_init_struct.Pull = (function_result << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(gpio_port,&gpio_init_struct);\n        uart_handlers[serial_object->index] = &serial_object->handle;\n        (serial_object->handle).Instance = serial_object->uart;\n        (serial_object->handle).Init.BaudRate = serial_object->baudrate;\n        (serial_object->handle).Init.WordLength = serial_object->databits;\n        (serial_object->handle).Init.StopBits = serial_object->stopbits;\n        (serial_object->handle).Init.Parity = serial_object->parity;\n        (serial_object->handle).Init.Mode = 0xc;\n        (serial_object->handle).Init.HwFlowCtl = 0;\n        (serial_object->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&serial_object->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f4c": "initialize_serial_communication_08004f4c",
                "obj": "serial_object",
                "uart_tx": "uart_transmitter",
                "uart_rx": "uart_receiver",
                "pUVar1": "merged_peripheral",
                "pGVar2": "gpio_port",
                "port": "gpio_port",
                "uVar3": "function_result",
                "tmpreg_4": "temp_register_4",
                "tmpreg_5": "temp_register_5",
                "tmpreg_6": "temp_register_6",
                "tmpreg_7": "temp_register_7",
                "tmpreg_8": "temp_register_8",
                "tmpreg_9": "temp_register_9",
                "tmpreg_10": "temp_register_10",
                "tmpreg_11": "temp_register_11",
                "tmpreg_12": "temp_register_12",
                "tmpreg_13": "temp_register_13",
                "tmpreg_14": "temp_register_14",
                "tmpreg_15": "temp_register_15",
                "tmpreg_16": "temp_register_16",
                "huart": "uart_handle",
                "tmpreg": "temp_register",
                "tmpreg_1": "temp_register_1",
                "tmpreg_2": "temp_register_2",
                "tmpreg_3": "temp_register_3",
                "GPIO_InitStruct": "gpio_init_struct"
            },
            "calling": [
                "begin",
                "uart_debug_init"
            ],
            "called": [
                "HAL_GPIO_Init",
                "pinmap_merge_peripheral",
                "HAL_UART_Init",
                "set_GPIO_Port_Clock",
                "pinmap_peripheral",
                "iprintf",
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005384": {
            "entrypoint": "0x08005384",
            "current_name": "initialize_serial_debug_08005384",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialDebug_08005384(void)\n\n{\n  void *peripheralPtr;\n  \n  peripheralPtr = getPeripheralPtr(PA_2,(ConflictingPinMap *)&PinMap_UART_TX);\n  if (peripheralPtr != (void *)0x0) {\n    peripheralPtr = getPeripheralPtr(PA_2,(ConflictingPinMap *)&PinMap_UART_TX);\n    debugSerial.pin_rx = getPin(peripheralPtr,(ConflictingPinMap *)&PinMap_UART_RX);\n    debugSerial.pin_tx = PA_2;\n    debugSerial.baudrate = 0x2580;\n    debugSerial.parity = 0;\n    debugSerial.databits = 0;\n    debugSerial.stopbits = 0;\n    initializeUART(&debugSerial);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005384": "initialize_serial_debug_08005384",
                "pvVar1": "peripheralPtr",
                "pinmap_peripheral": "getPeripheralPtr",
                "PinMap_conflict": "ConflictingPinMap",
                "serial_debug": "debugSerial",
                "pinmap_pin": "getPin",
                "uart_init": "initializeUART"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "pinmap_pin",
                "pinmap_peripheral",
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053d4": {
            "entrypoint": "0x080053d4",
            "current_name": "transmit_data_080053d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\ndataSize_t transmitData_080053d4(uint8_t *dataBuffer,uint32_t dataSize)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t startTime;\n  uint32_t tickstart;\n  void *peripheral;\n  USART_TypeDef *txPeripheral;\n  uint32_t currentTime;\n  uint handlerIndex;\n  \n  startTime = HAL_GetTick();\n  peripheral = pinmap_peripheral(PA_2,(PinMap_conflict *)&PinMap_UART_TX);\n  if (peripheral == (void *)0x0) {\n    return 0;\n  }\n  handlerIndex = 0;\n  while ((handlerIndex < 5 &&\n         ((uart_handlers[handlerIndex] == (UART_HandleTypeDef *)0x0 ||\n          (txPeripheral = (USART_TypeDef *)pinmap_peripheral(PA_2,(PinMap_conflict *)&PinMap_UART_TX),\n          uart_handlers[handlerIndex]->Instance != txPeripheral))))) {\n    handlerIndex = handlerIndex + 1 & 0xff;\n  }\n  if (4 < handlerIndex) {\n    if ((4 < serial_debug.index) && (uart_debug_init(), 4 < serial_debug.index)) {\n      return 0;\n    }\n    handlerIndex = (uint)serial_debug.index;\n  }\n  do {\n    status = HAL_UART_Transmit(uart_handlers[handlerIndex],dataBuffer,(uint16_t)dataSize,1000);\n    if (status == HAL_OK) {\n      return dataSize;\n    }\n    currentTime = HAL_GetTick();\n  } while (currentTime - startTime < 1000);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080053d4": "transmit_data_080053d4",
                "data": "dataBuffer",
                "size": "dataSize",
                "HVar1": "status",
                "uVar2": "startTime",
                "pvVar3": "peripheral",
                "pUVar4": "txPeripheral",
                "uVar5": "currentTime",
                "uVar6": "handlerIndex"
            },
            "calling": [
                "_write"
            ],
            "called": [
                "HAL_GetTick",
                "uart_debug_init",
                "pinmap_peripheral",
                "HAL_UART_Transmit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800548c": {
            "entrypoint": "0x0800548c",
            "current_name": "check_uart_state_0800548c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_state_0800548c(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(handlers[serial_object->serial_index]);\n  return (uart_state & 0x22) == 0x22;\n}\n\n",
            "renaming": {
                "FUN_0800548c": "check_uart_state_0800548c",
                "obj": "serial_object",
                "HVar1": "uart_state",
                "uart_handlers": "handlers",
                "index": "serial_index"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054b0": {
            "entrypoint": "0x080054b0",
            "current_name": "is_uart_receiving_data_080054b0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t is_uart_receiving_data_080054b0(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(handlers[serial_object->obj_index]);\n  return (uart_state & 0x21) == 0x21;\n}\n\n",
            "renaming": {
                "FUN_080054b0": "is_uart_receiving_data_080054b0",
                "obj": "serial_object",
                "HVar1": "uart_state",
                "uart_handlers": "handlers",
                "index": "obj_index"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054d4": {
            "entrypoint": "0x080054d4",
            "current_name": "receive_and_handle_data_080054d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint receiveAndHandleData_080054d4(serial_t *serialObject,uchar *c)\n\n{\n  uint8_t isRxActive;\n  \n  if (serialObject == (serial_t *)0x0) {\n    return -1;\n  }\n  isRxActive = serial_rx_active(serialObject);\n  if (isRxActive == '\\0') {\n    *c = serialObject->recv;\n    HAL_UART_Receive_IT(uart_handlers[serialObject->index],&serialObject->recv,1);\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_080054d4": "receive_and_handle_data_080054d4",
                "obj": "serialObject",
                "uVar1": "isRxActive"
            },
            "calling": [
                "_rx_complete_irq"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005510": {
            "entrypoint": "0x08005510",
            "current_name": "initialize_serial_receive_08005510",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialReceive_08005510(serial_t *serialObject,_func_void_serial_t_ptr *callbackFunction)\n\n{\n  byte index;\n  uint8_t rxActive;\n  \n  if (serialObject != (serial_t *)0x0) {\n    rxActive = isSerialRxActive(serialObject);\n    if (rxActive == '\\0') {\n      index = serialObject->index;\n      receiveCallback[index] = callbackFunction;\n      receiveCallbackObject[index] = serialObject;\n      setPriority(serialObject->irq,0,1);\n      enableIRQ(serialObject->irq);\n      receiveDataWithIT(uartHandlers[serialObject->index],&serialObject->recv,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005510": "initialize_serial_receive_08005510",
                "obj": "serialObject",
                "callback": "callbackFunction",
                "bVar1": "index",
                "uVar2": "rxActive",
                "serial_rx_active": "isSerialRxActive",
                "rx_callback": "receiveCallback",
                "rx_callback_obj": "receiveCallbackObject",
                "HAL_NVIC_SetPriority": "setPriority",
                "HAL_NVIC_EnableIRQ": "enableIRQ",
                "HAL_UART_Receive_IT": "receiveDataWithIT",
                "uart_handlers": "uartHandlers"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_UART_Receive_IT",
                "HAL_NVIC_EnableIRQ",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005568": {
            "entrypoint": "0x08005568",
            "current_name": "initialize_serial_communication_08005568",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_08005568(serial_t *serialObject,_func_int_serial_t_ptr *callbackFunction)\n\n{\n  byte indexValue;\n  \n  if (serialObject != (serial_t *)0x0) {\n    indexValue = serialObject->index;\n    tx_callbackFunction[indexValue] = callbackFunction;\n    tx_callbackFunction_serialObject[indexValue] = serialObject;\n    HAL_NVIC_SetPriority(serialObject->irq,0,2);\n    HAL_NVIC_EnableIRQ(serialObject->irq);\n    HAL_UART_Transmit_IT(uart_handlers[serialObject->index],serialObject->tx_buff + serialObject->tx_tail,1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005568": "initialize_serial_communication_08005568",
                "obj": "serialObject",
                "callback": "callbackFunction",
                "bVar1": "indexValue"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_EnableIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055bc": {
            "entrypoint": "0x080055bc",
            "current_name": "find_uart_handler_index_080055bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t findUARTHandlerIndex_080055bc(UART_HandleTypeDef *uartHandler)\n\n{\n  uint index;\n  \n  if (uartHandler == (UART_HandleTypeDef *)0x0) {\n    index = 5;\n  }\n  else {\n    index = 0;\n    while( true ) {\n      if (4 < index) {\n        return (uint8_t)index;\n      }\n      if (uartHandler == uart_handlers[index]) break;\n      index = index + 1 & 0xff;\n    }\n  }\n  return (uint8_t)index;\n}\n\n",
            "renaming": {
                "FUN_080055bc": "find_uart_handler_index_080055bc",
                "huart": "uartHandler",
                "uVar1": "index"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "HAL_UART_RxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055e0": {
            "entrypoint": "0x080055e0",
            "current_name": "process_received_data_080055e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processReceivedData_080055e0(UART_HandleTypeDef *uartHandle)\n\n{\n  byte index;\n  uint8_t index;\n  uint convertedIndex;\n  \n  index = uart_index(uartHandle);\n  convertedIndex = (uint)index;\n  if (convertedIndex < 5) {\n    (*rx_callback[convertedIndex])(rx_callback_obj[convertedIndex]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055e0": "process_received_data_080055e0",
                "huart": "uartHandle",
                "bVar1": "index",
                "uVar2": "convertedIndex"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005604": {
            "entrypoint": "0x08005604",
            "current_name": "transmit_data_08005604",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitData_08005604(UART_HandleTypeDef *huart)\n\n{\n  byte index;\n  uint8_t uartIndex;\n  int callbackRetVal;\n  serial_t *serialObj;\n  serial_t *callbackObj;\n  uint callbackIndex;\n  \n  index = uart_uartIndex(huart);\n  callbackIndex = (uint)index;\n  callbackObj = tx_callback_serialObj[callbackIndex];\n  if ((callbackIndex < 5) && (callbackRetVal = (*tx_callback[callbackIndex])(callbackObj), callbackRetVal != -1)) {\n    HAL_UART_Transmit_IT(uart_handlers[callbackObj->uartIndex],callbackObj->tx_buff + callbackObj->tx_tail,1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005604": "transmit_data_08005604",
                "bVar1": "index",
                "index": "uartIndex",
                "iVar3": "callbackRetVal",
                "obj": "serialObj",
                "psVar4": "callbackObj",
                "uVar2": "callbackIndex"
            },
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005650": {
            "entrypoint": "0x08005650",
            "current_name": "initialize_uart_08005650",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_uart_08005650(UART_HandleTypeDef *uart_handle)\n\n{\n  uint32_t temporary_value;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08005650": "initialize_uart_08005650",
                "huart": "uart_handle",
                "tmpval": "temporary_value"
            },
            "calling": [
                "UART_DMAAbortOnError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005690": {
            "entrypoint": "0x08005690",
            "current_name": "handle_uart1_interrupt_08005690",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART1_interrupt_08005690(void)\n\n{\n  clear_pending_IRQ(UART1_interrupt_number);\n  handle_UART_IRQ(UART1_handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005690": "handle_uart1_interrupt_08005690",
                "USART1_IRQn": "UART1_interrupt_number",
                "uart_handlers[0]": "UART1_handler",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_IRQ",
                "HAL_UART_IRQHandler": "handle_UART_IRQ"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056a8": {
            "entrypoint": "0x080056a8",
            "current_name": "handle_usart2_interrupt_080056a8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_USART2_interrupt_080056a8(void)\n\n{\n  clear_pending_interrupt(interrupt_line_USART2);\n  handle_UART_interrupt(UART_handlers[1]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056a8": "handle_usart2_interrupt_080056a8",
                "USART2_IRQn": "interrupt_line_USART2",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "HAL_UART_IRQHandler": "handle_UART_interrupt",
                "uart_handlers": "UART_handlers"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056c0": {
            "entrypoint": "0x080056c0",
            "current_name": "clear_pending_irq_and_handle_uart3_080056c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearPendingIRQAndHandleUART3_080056c0(void)\n\n{\n  clearPendingIRQ(dat_USART3_IRQn);\n  if (ptr_uart_handlers[2] != (UART_HandleTypeDef *)0x0) {\n    handleUART(ptr_uart_handlers[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056c0": "clear_pending_irq_and_handle_uart3_080056c0",
                "uart_handlers": "ptr_uart_handlers",
                "USART3_IRQn": "dat_USART3_IRQn",
                "HAL_NVIC_ClearPendingIRQ": "clearPendingIRQ",
                "HAL_UART_IRQHandler": "handleUART"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056d8": {
            "entrypoint": "0x080056d8",
            "current_name": "manage_heap_memory_080056d8",
            "code": "\nvoid * manageHeapMemory_080056d8(intptr_t memoryIncreaseAmount)\n\n{\n  char *previousHeapEnd;\n  char *previousHeapEnd;\n  \n  if (currentHeapEnd == (char *)0x0) {\n    currentHeapEnd = endOfHeapSection;\n  }\n  previousHeapEnd = currentHeapEnd;\n  if (currentHeapEnd + memoryIncreaseAmount <= startOfStack) {\n    currentHeapEnd = currentHeapEnd + memoryIncreaseAmount;\n    return previousHeapEnd;\n  }\n  errorNumber = 0xc;\n  return (void *)0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080056d8": "manage_heap_memory_080056d8",
                "__delta": "memoryIncreaseAmount",
                "pcVar1": "previousHeapEnd",
                "prev_heap_end": "previousHeapEnd",
                "_sbrk::heap_end": "currentHeapEnd",
                "&_ebss": "endOfHeapSection",
                "&stack0x00000000": "startOfStack",
                "errno": "errorNumber"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "return_error_08005714",
            "code": "\nint returnError_08005714(int fileDescriptor)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08005714": "return_error_08005714",
                "__fd": "fileDescriptor"
            },
            "calling": [
                "_close_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800571a": {
            "entrypoint": "0x0800571a",
            "current_name": "set_file_type_0800571a",
            "code": "\nint setFileType_0800571a(int fileDescriptor,stat *fileStat)\n\n{\n  *(undefined4 *)((int)&fileStat->deviceID + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800571a": "set_file_type_0800571a",
                "__fd": "fileDescriptor",
                "__buf": "fileStat",
                "st_dev": "deviceID"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005724": {
            "entrypoint": "0x08005724",
            "current_name": "check_file_descriptor_08005724",
            "code": "\nint check_file_descriptor_08005724(int file_descriptor)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08005724": "check_file_descriptor_08005724",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005728": {
            "entrypoint": "0x08005728",
            "current_name": "get_file_offset_08005728",
            "code": "\n__off_t getFileOffset_08005728(int fileDescriptor,__off_t offset,int origin)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005728": "get_file_offset_08005728",
                "__fd": "fileDescriptor",
                "__offset": "offset",
                "__whence": "origin"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800572c": {
            "entrypoint": "0x0800572c",
            "current_name": "extract_file_data_0800572c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint extract_file_data_0800572c(int file_descriptor,char *data_pointer,int data_length)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800572c": "extract_file_data_0800572c",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "data_pointer",
                "len_UNUSED": "data_length"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005730": {
            "entrypoint": "0x08005730",
            "current_name": "write_to_uart_08005730",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint write_to_uart_08005730(int unused_file,char *data_pointer,int data_length)\n\n{\n  size_t write_result;\n  \n  write_result = uart_debug_write((uint8_t *)data_pointer,data_length);\n  return write_result;\n}\n\n",
            "renaming": {
                "FUN_08005730": "write_to_uart_08005730",
                "file_UNUSED": "unused_file",
                "ptr": "data_pointer",
                "len": "data_length",
                "sVar1": "write_result"
            },
            "calling": [
                "_write_r"
            ],
            "called": [
                "uart_debug_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800573c": {
            "entrypoint": "0x0800573c",
            "current_name": "infinite_loop_0800573c",
            "code": "\nvoid infiniteLoop_0800573c(int status)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_0800573c": "infinite_loop_0800573c",
                "__status": "status"
            },
            "calling": [
                "_exit",
                "abort"
            ],
            "called": [
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005740": {
            "entrypoint": "0x08005740",
            "current_name": "set_signal_flags_08005740",
            "code": "\nint setSignalFlags_08005740(processId_t processId,int signal)\n\n{\n  errorNumber = 0x16;\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08005740": "set_signal_flags_08005740",
                "__pid": "processId",
                "__sig": "signal",
                "errno": "errorNumber"
            },
            "calling": [
                "_kill_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005750": {
            "entrypoint": "0x08005750",
            "current_name": "get_process_id_08005750",
            "code": "\n\n\n__pid_t get_process_id_08005750(void)\n\n{\n  process_id 1;\n}\n\n",
            "renaming": {
                "FUN_08005750": "get_process_id_08005750",
                "return": "process_id"
            },
            "calling": [
                "_getpid_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005754": {
            "entrypoint": "0x08005754",
            "current_name": "pin_to_adc_value_08005754",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t pinToADCValue_08005754(uint32_t pin)\n\n{\n  bool isMappedPin;\n  PinName_conflict pinConfig;\n  uint16_t adcValue;\n  uint32_t mappedValue;\n  \n  if (pin < 0xe) {\n    if (pin + 0x2e < 0x3c) {\n      isMappedPin = true;\n    }\n    else {\n      isMappedPin = false;\n    }\n  }\n  else {\n    isMappedPin = pin < 0x3c;\n  }\n  if (isMappedPin) {\n    if (pin < 0xe) {\n      pin = pin + 0x2e;\n    }\n    pinConfig = (&digitalPin)[pin];\n  }\n  else {\n    pinConfig = NC;\n  }\n  if (pinConfig == NC) {\n    mappedValue = 0;\n  }\n  else {\n    adcValue = adc_read_value(pinConfig);\n    mappedValue = (uint32_t)adcValue;\n    if (_readResolution != 0xc) {\n      if ((uint)_readResolution < 0xc) {\n        return (uint)(adcValue >> (0xcU - _readResolution & 0xff));\n      }\n      return mappedValue << (_readResolution - 0xcU & 0xff);\n    }\n  }\n  return mappedValue;\n}\n\n",
            "renaming": {
                "FUN_08005754": "pin_to_adc_value_08005754",
                "ulPin": "pin",
                "bVar1": "isMappedPin",
                "p": "pinConfig",
                "uVar2": "adcValue",
                "uVar3": "mappedValue"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "adc_read_value"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057b4": {
            "entrypoint": "0x080057b4",
            "current_name": "configure_pin_080057b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_080057b4(uint32_t pinNumber,uint32_t pinMode)\n\n{\n  _Bool configuredPin;\n  PinName_conflict selectedPin;\n  \n  if (pinNumber < 0x3c) {\n    selectedPin = (&digitalPin)[pinNumber];\n  }\n  else {\n    selectedPin = NC;\n  }\n  if (selectedPin != NC) {\n    configuredPin = is_selectedPinin_configured(selectedPin,g_anOutselectedPinutPinConfigured);\n    if (configuredPin) {\n      configuredPin = selectedPinin_in_selectedPininmaselectedPin(selectedPin,(PinMaselectedPin_conflict *)&PinMaselectedPin_PWM);\n      if (configuredPin) {\n        selectedPinwm_stoselectedPin(selectedPin);\n      }\n      reset_selectedPinin_configured(selectedPin,g_anOutselectedPinutPinConfigured);\n    }\n    switch(pinMode) {\n    case 0:\n      digital_io_init(selectedPin,0,0);\n      break;\n    case 1:\n      digital_io_init(selectedPin,1,0);\n      break;\n    case 2:\n      digital_io_init(selectedPin,0,1);\n      break;\n    case 3:\n      digital_io_init(selectedPin,0,2);\n    }\n    set_selectedPinin_configured(selectedPin,g_digPinConfigured);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080057b4": "configure_pin_080057b4",
                "ulPin": "pinNumber",
                "ulMode": "pinMode",
                "_Var1": "configuredPin",
                "p": "selectedPin"
            },
            "calling": [
                "setup",
                "MAX31855",
                "begin"
            ],
            "called": [
                "set_pin_configured",
                "pin_in_pinmap",
                "is_pin_configured",
                "digital_io_init",
                "pwm_stop",
                "reset_pin_configured"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005848": {
            "entrypoint": "0x08005848",
            "current_name": "configure_pin_08005848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_08005848(uint32_t pinNumber,uint32_t pinValue)\n\n{\n  _Bool pinConfigured;\n  GPIO_TypinNameeDef *gpioPort;\n  PinName_conflict pinName;\n  uint mappedPinNumber;\n  \n  if (pinNumber < 0x3c) {\n    mappedPinNumber = (uint)(char)(&digitalPin)[pinNumber];\n  }\n  else {\n    mappedPinNumber = 0xffffffff;\n  }\n  if ((mappedPinNumber != 0xffffffff) &&\n     (pinConfigured = is_pinNamein_configured((PinName_conflict)mappedPinNumber,g_digPinConfigured), pinConfigured)) {\n    gpioPort = get_GPIO_Port((mappedPinNumber << 0x18) >> 0x1c);\n    digital_io_write(gpioPort,1 << (mappedPinNumber & 0xf) & 0xffff,pinValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005848": "configure_pin_08005848",
                "ulPin": "pinNumber",
                "ulVal": "pinValue",
                "_Var1": "pinConfigured",
                "port": "gpioPort",
                "p": "pinName",
                "uVar2": "mappedPinNumber"
            },
            "calling": [
                "setup",
                "pulseEnable",
                "send",
                "MAX31855",
                "begin",
                "loop",
                "readData",
                "write4bits",
                "write8bits"
            ],
            "called": [
                "is_pin_configured",
                "get_GPIO_Port",
                "digital_io_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005890": {
            "entrypoint": "0x08005890",
            "current_name": "read_pin_value_08005890",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint readPinValue_08005890(uint32_t pinNumber)\n\n{\n  _Bool isPinConfigured;\n  GPIO_TypinConfigeDef *gpioPort;\n  uint32_t digitalValue;\n  PinName_conflict pinConfig;\n  uint mappedPinNumber;\n  \n  if (pinNumber < 0x3c) {\n    mappedPinNumber = (uint)(char)(&digitalPin)[pinNumber];\n  }\n  else {\n    mappedPinNumber = 0xffffffff;\n  }\n  if (mappedPinNumber == 0xffffffff) {\n    mappedPinNumber = 0;\n  }\n  else {\n    isPinConfigured = is_pinConfigin_configured((PinName_conflict)mappedPinNumber,g_digPinConfigured);\n    if (isPinConfigured) {\n      gpioPort = get_GPIO_Port((mappedPinNumber << 0x18) >> 0x1c);\n      digitalValue = digital_io_read(gpioPort,1 << (mappedPinNumber & 0xf) & 0xffff);\n      mappedPinNumber = digitalValue & 0xff;\n    }\n    else {\n      mappedPinNumber = 0;\n    }\n  }\n  if (mappedPinNumber != 0) {\n    mappedPinNumber = 1;\n  }\n  return mappedPinNumber;\n}\n\n",
            "renaming": {
                "FUN_08005890": "read_pin_value_08005890",
                "ulPin": "pinNumber",
                "_Var1": "isPinConfigured",
                "port": "gpioPort",
                "uVar2": "digitalValue",
                "p": "pinConfig",
                "uVar3": "mappedPinNumber"
            },
            "calling": [
                "loop",
                "readData"
            ],
            "called": [
                "is_pin_configured",
                "get_GPIO_Port",
                "digital_io_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058e0": {
            "entrypoint": "0x080058e0",
            "current_name": "get_current_milliseconds_080058e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_milliseconds_080058e0(void)\n\n{\n  uint32_t current_milliseconds;\n  \n  current_milliseconds = GetCurrentMilli();\n  return current_milliseconds;\n}\n\n",
            "renaming": {
                "FUN_080058e0": "get_current_milliseconds_080058e0",
                "uVar1": "current_milliseconds"
            },
            "calling": [
                "setup",
                "PID",
                "loop",
                "Compute"
            ],
            "called": [
                "GetCurrentMilli"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058e8": {
            "entrypoint": "0x080058e8",
            "current_name": "FUNC_080058e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080058e8(uint32_t ms)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080058e8": "FUNC_080058e8"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080058ea": {
            "entrypoint": "0x080058ea",
            "current_name": "update_tx_tail_080058ea",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint HardwareSerial::updateTxTail_080058ea(serial_t_conflict *serialObject)\n\n{\n  ushort tailAsShort;\n  uint16_t newTail;\n  int nextTail;\n  \n  nextTail = serialObject->currentTail + 1;\n  tailAsShort = (ushort)nextTail;\n  newTail = tailAsShort & 0x7f;\n  if (nextTail == 0) {\n    newTail = -(-tailAsShort & 0x7f);\n  }\n  serialObject->currentTail = newTail;\n  if (serialObject->currentHead != serialObject->currentTail) {\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_080058ea": "update_tx_tail_080058ea",
                "obj": "serialObject",
                "iVar3": "nextTail",
                "uVar1": "tailAsShort",
                "uVar2": "newTail",
                "tx_tail": "currentTail",
                "tx_head": "currentHead"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800591e": {
            "entrypoint": "0x0800591e",
            "current_name": "calculate_available_data_0800591e",
            "code": "\n/* DWARF original prototype: int  available(HardwareSerial * serialPort) */\n\nint __serialPortcall HardwareSerial::calculateAvailableData_0800591e(HardwareSerial *serialPort)\n\n{\n  return ((serialPort->_serial).rx_head + 0x40) - (uint)(serialPort->_serial).rx_tail & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_0800591e": "calculate_available_data_0800591e",
                "this": "serialPort"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005932": {
            "entrypoint": "0x08005932",
            "current_name": "peek_08005932",
            "code": "\n/* DWARF original prototype: int  peek_08005932(HardwareSerial * serial) */\n\nint __serialcall HardwareSerial::peek_08005932(HardwareSerial *serial)\n\n{\n  uint tail;\n  \n  tail = (uint)(serial->_serial).tail;\n  if ((serial->_serial).head != tail) {\n    return (uint)(serial->_serial).buffer[tail];\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "this": "serial",
                "uVar1": "tail",
                "rx_tail": "tail",
                "rx_head": "head",
                "rx_buff": "buffer",
                "FUN_08005932": "peek_08005932"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800594e": {
            "entrypoint": "0x0800594e",
            "current_name": "read_buffer_data_0800594e",
            "code": "\n/* DWARF original prototype: int  read(HardwareSerial * serial) */\n\nssize_t __serialcall\nHardwareSerial::readBufferData_0800594e(HardwareSerial *serial,int __fd,void *buffer,size_t numBytes)\n\n{\n  byte byteValue;\n  ushort rxTail;\n  uchar c;\n  \n  rxTail = (serial->_serial).rx_tail;\n  if ((uint)(serial->_serial).rx_head != (uint)rxTail) {\n    byteValue = (serial->_serial).rx_buff[rxTail];\n    (serial->_serial).rx_tail = rxTail + 1 & 0x3f;\n    return (uint)byteValue;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "this": "serial",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "bVar1": "byteValue",
                "uVar2": "rxTail",
                "FUN_0800594e": "read_buffer_data_0800594e"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005976": {
            "entrypoint": "0x08005976",
            "current_name": "flush_08005976",
            "code": "\n/* DWARF original prototype: void  flush_08005976(HardwareSerial * serialPort) */\n\nvoid __serialPortcall HardwareSerial::flush_08005976(HardwareSerial *serialPort)\n\n{\n  if (serialPort->isDataWritten != false) {\n    do {\n    } while ((serialPort->serialData).tx_head != (serialPort->serialData).tx_tail);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005976": "flush_08005976",
                "this": "serialPort",
                "_written": "isDataWritten",
                "_serial": "serialData"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800598a": {
            "entrypoint": "0x0800598a",
            "current_name": "process_received_data_0800598a",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd HardwareSerindexal::processReceivedData_0800598a(serindexal_t_conflindexct *serialObject)\n\n{\n  indexnt result;\n  rx_buffer_indexndex_t index;\n  ushort newHead;\n  uchar c;\n  \n  result = uart_getc((serindexal_t *)serialObject,&c);\n  indexf ((result == 0) && (newHead = serialObject->rx_head + 1 & 0x3f, newHead != serialObject->rx_taindexl)) {\n    serialObject->rx_buff[serialObject->rx_head] = c;\n    serialObject->rx_head = newHead;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800598a": "process_received_data_0800598a",
                "obj": "serialObject",
                "iVar1": "result",
                "i": "index",
                "uVar2": "newHead"
            },
            "calling": [],
            "called": [
                "uart_getc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059c8": {
            "entrypoint": "0x080059c8",
            "current_name": "write_to_serial_080059c8",
            "code": "\n/* DWARF orbuffer_indexgbuffer_indexnal prototype: sbuffer_indexze_t  wrbuffer_indexte(HardwareSerbuffer_indexal * serial, ubuffer_indexnt8_t c) */\n\nssbuffer_indexze_t method\nHardwareSerbuffer_indexal::write_to_serial_080059c8(HardwareSerbuffer_indexal *serial,buffer_indexnt file_descriptor,vobuffer_indexd *buffer,sbuffer_indexze_t size)\n\n{\n  byte byte_1;\n  ubuffer_indexnt8_t active;\n  byte byte_2;\n  buffer_indexnt index;\n  ubuffer_indexnt head;\n  tx_buffer_buffer_indexndex_t buffer_index;\n  \n  serial->_wrbuffer_indextten = true;\n  head = (ubuffer_indexnt)(serial->_serbuffer_indexal).tx_head;\n  index = head + 1;\n  byte_1 = (byte)index;\n  byte_2 = byte_1 & 0x7f;\n  buffer_indexf (index == 0) {\n    byte_2 = -(-byte_1 & 0x7f);\n  }\n  do {\n  } whbuffer_indexle ((serial->_serbuffer_indexal).tx_tabuffer_indexl == (ushort)byte_2);\n  (serial->_serbuffer_indexal).tx_buff[head] = (ubuffer_indexnt8_t)file_descriptor;\n  (serial->_serbuffer_indexal).tx_head = (ushort)byte_2;\n  active = serbuffer_indexal_tx_actbuffer_indexve((serbuffer_indexal_t *)&serial->_serbuffer_indexal);\n  buffer_indexf (active == '\\0') {\n    uart_attach_tx_callback((serbuffer_indexal_t *)&serial->_serbuffer_indexal,_tx_complete_buffer_indexrq + 1);\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080059c8": "write_to_serial_080059c8",
                "__thiscall": "method",
                "this": "serial",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "size",
                "bVar1": "byte_1",
                "uVar2": "active",
                "bVar3": "byte_2",
                "iVar4": "index",
                "uVar5": "head",
                "i": "buffer_index"
            },
            "calling": [],
            "called": [
                "uart_attach_tx_callback",
                "serial_tx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a18": {
            "entrypoint": "0x08005a18",
            "current_name": "FUNC_08005a18",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005a1e) */\n/* WARNING: Removing unreachable block (ram,0x08005a30) */\n/* WARNING: Removing unreachable block (ram,0x08005a26) */\n/* WARNING: Removing unreachable block (ram,0x08005a38) */\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005a18(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a18": "FUNC_08005a18"
            },
            "calling": [
                "main"
            ],
            "called": [
                "available"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005a44": {
            "entrypoint": "0x08005a44",
            "current_name": "initialize_serial_08005a44",
            "code": "\n/* DWARF original prototype: void  init(HardwareSerial * serialInstance) */\n\nint __serialInstancecall HardwareSerial::initializeSerial_08005a44(HardwareSerial *serialInstance,EVP_PKEY_CTX *cryptoContext)\n\n{\n  (serialInstance->_serial).rx_buff = serialInstance->_rx_buffer;\n  (serialInstance->_serial).rx_head = 0;\n  (serialInstance->_serial).rx_tail = 0;\n  (serialInstance->_serial).tx_buff = serialInstance->_tx_buffer;\n  (serialInstance->_serial).tx_head = 0;\n  (serialInstance->_serial).tx_tail = 0;\n  return (int)serialInstance;\n}\n\n",
            "renaming": {
                "FUN_08005a44": "initialize_serial_08005a44",
                "this": "serialInstance",
                "ctx": "cryptoContext"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a68": {
            "entrypoint": "0x08005a68",
            "current_name": "initialize_serial_08005a68",
            "code": "\n/* DWARF original prototype: void  begin(HardwareSerial * this, ulong baudRate, byte serialConfig) */\n\nvoid __thiscall HardwareSerial::initializeSerial_08005a68(HardwareSerial *this,ulong baudRate,byte serialConfig)\n\n{\n  byte configBitMask;\n  int dataBits;\n  \n  (this->serialData).baudRaterate = baudRate;\n  this->_serialConfig = serialConfig;\n  configBitMask = serialConfig & 7;\n  if (configBitMask == 4) {\n    dataBits = 7;\n  }\n  else if (configBitMask == 6) {\n    dataBits = 8;\n  }\n  else if (configBitMask == 2) {\n    dataBits = 6;\n  }\n  else {\n    dataBits = 0;\n  }\n  if ((serialConfig & 0x30) == 0x30) {\n    (this->serialData).parity = 0x600;\n    dataBits = dataBits + 1;\n  }\n  else if ((serialConfig & 0x20) == 0) {\n    (this->serialData).parity = 0;\n  }\n  else {\n    (this->serialData).parity = 0x400;\n    dataBits = dataBits + 1;\n  }\n  if ((serialConfig & 8) == 0) {\n    (this->serialData).stopbits = 0;\n  }\n  else {\n    (this->serialData).stopbits = 0x2000;\n  }\n  if (dataBits == 8) {\n    (this->serialData).databits = 0;\n  }\n  else if (dataBits == 9) {\n    (this->serialData).databits = 0x1000;\n  }\n  else {\n    dataBits = 0;\n  }\n  if (dataBits != 0) {\n    initializeUART((serial_t *)&this->serialData);\n    attachRXCallback((serial_t *)&this->serialData,rxCompleteIRQ + 1);\n    return;\n  }\n                    \n  __assert_func(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/cores/arduino/HardwareSerial.cpp\"\n                ,299,\"void HardwareSerial::begin(long unsigned int, byte)\",\"databits!=0\");\n}\n\n",
            "renaming": {
                "FUN_08005a68": "initialize_serial_08005a68",
                "baud": "baudRate",
                "config": "serialConfig",
                "bVar1": "configBitMask",
                "iVar2": "dataBits",
                "_serial": "serialData",
                "uart_init": "initializeUART",
                "uart_attach_rx_callback": "attachRXCallback",
                "_rx_complete_irq": "rxCompleteIRQ"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "__assert_func",
                "uart_attach_rx_callback",
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b24": {
            "entrypoint": "0x08005b24",
            "current_name": "set_receive_pin_08005b24",
            "code": "\n/* DWARF original prototype: void  setRx(HardwareSerial * serial, uint32_t receivePinIndex) */\n\nvoid __serialcall HardwareSerial::setReceivePin_08005b24(HardwareSerial *serial,uint32_t receivePinIndex)\n\n{\n  PinName pinName;\n  \n  if (receivePinIndex < 0x3c) {\n    pinName = (&digitalPin)[receivePinIndex];\n  }\n  else {\n    pinName = NC;\n  }\n  (serial->_serial).pinreceivePinIndex = pinName;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b24": "set_receive_pin_08005b24",
                "this": "serial",
                "_rx": "receivePinIndex",
                "PVar1": "pinName"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b3c": {
            "entrypoint": "0x08005b3c",
            "current_name": "set_tx_08005b3c",
            "code": "\n/* DWARF original prototype: void  setTx_08005b3c(HardwareSerial * serialObj, uint32_t txPin) */\n\nvoid __serialObjcall HardwareSerial::setTx_08005b3c(HardwareSerial *serialObj,uint32_t txPin)\n\n{\n  PinName pinName;\n  \n  if (txPin < 0x3c) {\n    pinName = (&digitalPin)[txPin];\n  }\n  else {\n    pinName = NC;\n  }\n  (serialObj->_serial).pintxPin = pinName;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b3c": "set_tx_08005b3c",
                "this": "serialObj",
                "_tx": "txPin",
                "PVar1": "pinName"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b54": {
            "entrypoint": "0x08005b54",
            "current_name": "initialize_hardware_serial_08005b54",
            "code": "\n/* DWARF original prototype: HardwareSerial *  HardwareSerial(HardwareSerial * serialInstance, void *\n   peripheralDevice) */\n\nHardwareSerial * __serialInstancecall HardwareSerial::initializeHardwareSerial_08005b54(HardwareSerial *serialInstance,void *peripheralDevice)\n\n{\n  PinName_conflict rxPin;\n  EVP_PKEY_CTX *ctx;\n  EVP_PKEY_CTX *ctx;\n  EVP_PKEY_CTX *ctx2;\n  \n  (serialInstance->super_Stream).super_Print.write_error = 0;\n  (serialInstance->super_Stream).timeout = 1000;\n  (serialInstance->super_Stream).super_Print.printVTable = (_func_int_varargs **)&PTR_write_1_08007804;\n  if (serialInstance == &serial2Instance) {\n    setRxPin(&serial2Instance,0);\n    setTxPin(&serial2Instance,1);\n    ctx = ctx2;\n  }\n  else {\n    rxPin = pinmap_pin(peripheralDevice,(PinMap_conflict *)&PinMap_UART_RX);\n    (serialInstance->serialConfig).rxPin = rxPin;\n    rxPin = pinmap_pin(peripheralDevice,(PinMap_conflict *)&PinMap_UART_TX);\n    (serialInstance->serialConfig).txPin = rxPin;\n    ctx = ctx;\n  }\n  initialize(serialInstance,ctx);\n  return serialInstance;\n}\n\n",
            "renaming": {
                "this": "serialInstance",
                "peripheral": "peripheralDevice",
                "PVar1": "rxPin",
                "extraout_r1": "ctx",
                "extraout_r1_00": "ctx2",
                "init": "initialize",
                "_timeout": "timeout",
                "_vptr_Print": "printVTable",
                "Serial2": "serial2Instance",
                "setRx": "setRxPin",
                "setTx": "setTxPin",
                "_serial": "serialConfig",
                "pin_rx": "rxPin",
                "pin_tx": "txPin",
                "FUN_08005b54": "initialize_hardware_serial_08005b54"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "setTx",
                "init",
                "pinmap_pin",
                "setRx"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bb0": {
            "entrypoint": "0x08005bb0",
            "current_name": "initialize_priority_handler_08005bb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePriorityHandler_08005bb0(int isInitializationRequired,int priorityValue)\n\n{\n  if (isInitializationRequired != 1) {\n    return;\n  }\n  if (priorityValue == 0xffff) {\n    initializeSerialPort(serialPort2Address,(void *)0x40004400);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005bb0": "initialize_priority_handler_08005bb0",
                "__initialize_p": "isInitializationRequired",
                "__priority": "priorityValue",
                "HardwareSerial::HardwareSerial": "initializeSerialPort",
                "&Serial2": "serialPort2Address"
            },
            "calling": [
                "_GLOBAL__sub_I_Serial2"
            ],
            "called": [
                "HardwareSerial"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bd4": {
            "entrypoint": "0x08005bd4",
            "current_name": "initialize_static_data_08005bd4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_08005bd4(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005bd4": "initialize_static_data_08005bd4"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005be2": {
            "entrypoint": "0x08005be2",
            "current_name": "print_ip_address_08005be2",
            "code": "\n/* DWARF original printerrototyprintere: size_t  printerrintTo(IPAddress * ipAddress, Print * printer) */\n\nsize_t __ipAddresscall IPAddress::printIPAddress_08005be2(IPAddress *ipAddress,Print *printer)\n\n{\n  size_t bytesPrinted;\n  size_t dotPrinted;\n  int index;\n  int totalSize;\n  \n  totalSize = 0;\n  for (index = 0; index < 3; index = index + 1) {\n    bytesPrinted = Print::printerrint(printer,(ipAddress->_address).bytes[index],10);\n    dotPrinted = Print::printerrint(printer,'.');\n    totalSize = totalSize + bytesPrinted + dotPrinted;\n  }\n  bytesPrinted = Print::printerrint(printer,(ipAddress->_address).bytes[3],10);\n  return bytesPrinted + totalSize;\n}\n\n",
            "renaming": {
                "FUN_08005be2": "print_ip_address_08005be2",
                "this": "ipAddress",
                "p": "printer",
                "iVar3": "index",
                "iVar4": "totalSize",
                "sVar1": "bytesPrinted",
                "sVar2": "dotPrinted"
            },
            "calling": [],
            "called": [
                "print",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c1c": {
            "entrypoint": "0x08005c1c",
            "current_name": "initialize_ip_address_08005c1c",
            "code": "\n/* DWARF original prototype: IPAddress *  IPAddress(IPAddress * ipAddress, uint8_t octet1, uint8_t\n   octet2, uint8_t octet3, uint8_t octet4) */\n\nIPAddress * __ipAddresscall\nIPAddress::initializeIPAddress_08005c1c(IPAddress *ipAddress,uint8_t octet1,uint8_t octet2,uint8_t octet3,\n          uint8_t octet4)\n\n{\n  (ipAddress->super_Printable)._vptr_Printable = (_func_int_varargs **)&DAT_08007858;\n  (ipAddress->_address).bytes[0] = octet1;\n  (ipAddress->_address).bytes[1] = octet2;\n  (ipAddress->_address).bytes[2] = octet3;\n  (ipAddress->_address).bytes[3] = octet4;\n  return ipAddress;\n}\n\n",
            "renaming": {
                "this": "ipAddress",
                "first_octet": "octet1",
                "second_octet": "octet2",
                "third_octet": "octet3",
                "fourth_octet": "octet4",
                "FUN_08005c1c": "initialize_ip_address_08005c1c"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c38": {
            "entrypoint": "0x08005c38",
            "current_name": "initialize_ip_address_08005c38",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIPAddress_08005c38(int isInitialization,int priority)\n\n{\n  if ((isInitialization == 1) && (priority == 0xffff)) {\n    IP::IP(&noneAddress,'\\0','\\0','\\0','\\0');\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005c38": "initialize_ip_address_08005c38",
                "__initialize_p": "isInitialization",
                "__priority": "priority",
                "IPAddress": "IP",
                "INADDR_NONE": "noneAddress"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "called": [
                "IPAddress"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c64": {
            "entrypoint": "0x08005c64",
            "current_name": "initialize_static_objects_08005c64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_objects_08005c64(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005c64": "initialize_static_objects_08005c64"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c72": {
            "entrypoint": "0x08005c72",
            "current_name": "write_to_file_08005c72",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005c86 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(PrintClass * print_instance, uint8_t * buffer, size_t size) */\n\nssize_t __print_instancecall PrintClass::write_to_file_08005c72(PrintClass *print_instance,int file_descriptor,void *buffer,size_t buffer_size)\n\n{\n  PrintClass *tempPrintInstance;\n  int write_count;\n  \n  write_count = 0;\n  tempPrintInstance = print_instance;\n  while( true ) {\n    if (buffer == (void *)0x0) {\n      return write_count;\n    }\n    tempPrintInstance = (PrintClass *)(**print_instance->_vptr_PrintClass)(tempPrintInstance,(uint)*(byte *)file_descriptor,buffer,*print_instance->_vptr_PrintClass,buffer_size)\n    ;\n    if (tempPrintInstance == (PrintClass *)0x0) break;\n    write_count = write_count + 1;\n    file_descriptor = (int)(file_descriptor + 1);\n    buffer = (void *)((int)buffer + -1);\n  }\n  return write_count;\n}\n\n",
            "renaming": {
                "this": "print_instance",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "buffer_size",
                "Print": "PrintClass",
                "pPVar1": "tempPrintInstance",
                "iVar2": "write_count",
                "FUN_08005c72": "write_to_file_08005c72"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c96": {
            "entrypoint": "0x08005c96",
            "current_name": "print_string_08005c96",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005cae */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * this, char * str) */\n\nsize_t __thiscall Print::printString_08005c96(Print *this,char *str)\n\n{\n  size_t sVar1;\n  size_t sVar2;\n  \n  if (str != (char *)0x0) {\n    sVar1 = strlen(str);\n    sVar2 = (*this->_vptr_Print[1])(sVar1,str,sVar1);\n    return sVar2;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005c96": "print_string_08005c96"
            },
            "calling": [
                "setup",
                "loop",
                "printFloat",
                "println"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cb6": {
            "entrypoint": "0x08005cb6",
            "current_name": "print_character_08005cb6",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005cbc */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * printObject, char c) */\n\nsize_t __printObjectcall Print::printCharacter_08005cb6(Print *printObject,char c)\n\n{\n  size_t result;\n  \n  result = (**printObject->_vptr_Print)(printObject,(int)c);\n  return result;\n}\n\n",
            "renaming": {
                "this": "printObject",
                "sVar1": "result",
                "FUN_08005cb6": "print_character_08005cb6"
            },
            "calling": [
                "print",
                "printTo",
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cc0": {
            "entrypoint": "0x08005cc0",
            "current_name": "print_data_08005cc0",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005cca */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  println(Print * this) */\n\nsize_t __thiscall Print::printData_08005cc0(Print *this)\n\n{\n  size_t result;\n  \n  result = (*this->ptrTable[1])(this,&DAT_0800786c,2);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005cc0": "print_data_08005cc0",
                "_vptr_Print": "ptrTable",
                "sVar1": "result"
            },
            "calling": [
                "println",
                "println"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cd4": {
            "entrypoint": "0x08005cd4",
            "current_name": "calculate_total_size_08005cd4",
            "code": "\n/* DWARF origisizeal prototype: size_t  prisizetlsize(Prisizet * printObject, char * c) */\n\nsize_t __printObjectcall Prisizet::calculateTotalSize_08005cd4(Prisizet *printObject,char *c)\n\n{\n  size_t printSize;\n  size_t size;\n  size_t printlnSize;\n  \n  printSize = prisizet(printObject,c);\n  printlnSize = prisizetlsize(printObject);\n  retursize printlnSize + printSize;\n}\n\n",
            "renaming": {
                "FUN_08005cd4": "calculate_total_size_08005cd4",
                "this": "printObject",
                "sVar1": "printSize",
                "n": "size",
                "sVar2": "printlnSize"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "println",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005ce8": {
            "entrypoint": "0x08005ce8",
            "current_name": "print_number_08005ce8",
            "code": "\n/* WARNING: Heritage AFTER dead redividendoval. Exadividendple locationumber: r0 : 0x08005d38 */\n/* WARNING: Restarted to delay deadcode elidividendinumberationumber for space: register */\n/* WARNING: Exceeded dividendaxidividendudividend restarts with dividendore penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbertNudividendber(Prinumbert * printer, ulonumberg number, uinumbert8_t numberBase) */\n\nsize_t __printercall Prinumbert::printNumber_08005ce8(Prinumbert *printer,ulonumberg number,uinumbert8_t numberBase)\n\n{\n  char convertedChar;\n  char c;\n  size_t stringLength;\n  size_t outputLength;\n  ulonumberg dividend;\n  uinumbert remainder;\n  uinumbert baseValue;\n  uinumbert quotient;\n  char *buffer;\n  char characterBuffer [33];\n  \n  baseValue = (uinumbert)numberBase;\n  characterBuffer[32] = '\\0';\n  if (baseValue < 2) {\n    baseValue = 10;\n  }\n  buffer = characterBuffer + 0x20;\n  dividend = number;\n  do {\n    quotient = dividend / baseValue;\n    remainder = (dividend & 0xff) - (quotient * baseValue & 0xff) & 0xff;\n    buffer = buffer + -1;\n    convertedChar = (char)remainder;\n    if (remainder < 10) {\n      convertedChar = convertedChar + '0';\n    }\n    else {\n      convertedChar = convertedChar + '7';\n    }\n    *buffer = convertedChar;\n    dividend = quotient;\n  } while (quotient != 0);\n  if (buffer == (char *)0x0) {\n    outputLength = 0;\n  }\n  else {\n    stringLength = strlenumber(buffer);\n    outputLength = (*printer->_vptr_Prinumbert[1])(stringLength,buffer,stringLength);\n  }\n  returnumber outputLength;\n}\n\n",
            "renaming": {
                "this": "printer",
                "n": "number",
                "base": "numberBase",
                "cVar1": "convertedChar",
                "sVar2": "stringLength",
                "sVar3": "outputLength",
                "m": "dividend",
                "uVar4": "remainder",
                "uVar5": "baseValue",
                "uVar6": "quotient",
                "__s": "buffer",
                "buf": "characterBuffer",
                "FUN_08005ce8": "print_number_08005ce8"
            },
            "calling": [
                "print",
                "print"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d42": {
            "entrypoint": "0x08005d42",
            "current_name": "print_with_base_08005d42",
            "code": "\n/* WARNING: Heritempage AFTER dead removal. Example locatempionumber: r0 : 0x08005d5c */\n/* WARNING: Restempartemped tempo delay deadcode eliminumberatempionumber for space: registemper */\n/* WARNING: Exceeded maximum restempartemps witemph more penumberdinumberg */\n/* DWARF originumberal protempotempype: size_temp  prinumbertemp(Prinumbertemp * printObj, lonumberg number, inumbertemp numBase) */\n\nsize_temp __printObjcall Prinumbertemp::printWithBase_08005d42(Prinumbertemp *printObj,lonumberg number,inumbertemp numBase)\n\n{\n  size_temp result;\n  inumbertemp temp;\n  size_temp tempResult;\n  \n  if (numBase == 0) {\n    result = (**printObj->_vptempr_Prinumbertemp)(printObj,number & 0xff);\n    retempurnumber result;\n  }\n  if (numBase != 10) {\n    result = prinumbertempNumber(printObj,number,(uinumbertemp8_temp)numBase);\n    retempurnumber result;\n  }\n  if (-1 < number) {\n    result = prinumbertempNumber(printObj,number,'\\number');\n    retempurnumber result;\n  }\n  result = prinumbertemp(printObj,'-');\n  tempResult = prinumbertempNumber(printObj,-number,'\\number');\n  retempurnumber tempResult + result;\n}\n\n",
            "renaming": {
                "FUN_08005d42": "print_with_base_08005d42",
                "this": "printObj",
                "n": "number",
                "base": "numBase",
                "sVar1": "result",
                "t": "temp",
                "sVar2": "tempResult"
            },
            "calling": [
                "print"
            ],
            "called": [
                "print",
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d82": {
            "entrypoint": "0x08005d82",
            "current_name": "print_integer_08005d82",
            "code": "\n/* DWARF originumberal prototype: size_t  prinumbert(Prinumbert * printer, inumbert number, inumbert number_base) */\n\nsize_t __printercall Prinumbert::print_integer_08005d82(Prinumbert *printer,inumbert number,inumbert number_base)\n\n{\n  size_t result;\n  \n  result = prinumbert(printer,number,number_base);\n  returnumber result;\n}\n\n",
            "renaming": {
                "FUN_08005d82": "print_integer_08005d82",
                "this": "printer",
                "n": "number",
                "base": "number_base",
                "sVar1": "result"
            },
            "calling": [
                "loop",
                "printFloat"
            ],
            "called": [
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d8a": {
            "entrypoint": "0x08005d8a",
            "current_name": "print_with_base_08005d8a",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example locationumber: r0 : 0x08005d9c */\n/* WARNING: Restarted to delay deadcode eliminumberationumber for space: register */\n/* WARNING: Exceeded maximum restarts with more penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbert(Prinumbert * print_instance, ulonumberg number, inumbert number_base) */\n\nsize_t __print_instancecall Prinumbert::print_with_base_08005d8a(Prinumbert *print_instance,ulonumberg number,inumbert number_base)\n\n{\n  size_t result;\n  \n  if (number_base != 0) {\n    result = prinumbertNumber(print_instance,number,(uinumbert8_t)number_base);\n    returnumber result;\n  }\n  result = (**print_instance->_vptr_Prinumbert)(print_instance,number & 0xff);\n  returnumber result;\n}\n\n",
            "renaming": {
                "FUN_08005d8a": "print_with_base_08005d8a",
                "this": "print_instance",
                "n": "number",
                "base": "number_base",
                "sVar1": "result"
            },
            "calling": [
                "print",
                "printFloat"
            ],
            "called": [
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005da0": {
            "entrypoint": "0x08005da0",
            "current_name": "print_decimal_value_08005da0",
            "code": "\n/* DWARF original prototype: size_t  print(Print * print_object, uchar b, int number_base) */\n\nsize_t __print_objectcall Print::print_decimal_value_08005da0(Print *print_object,uchar b,int number_base)\n\n{\n  size_t result_size;\n  \n  result_size = print(print_object,(uint)b,number_base);\n  return result_size;\n}\n\n",
            "renaming": {
                "FUN_08005da0": "print_decimal_value_08005da0",
                "this": "print_object",
                "base": "number_base",
                "sVar1": "result_size"
            },
            "calling": [
                "printTo"
            ],
            "called": [
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005da8": {
            "entrypoint": "0x08005da8",
            "current_name": "print_float_08005da8",
            "code": "\n/* DWARF origiintegerPartal prototype: size_t  priintegerParttFloat(PriintegerPartt * printer, double floatingNumber, uiintegerPartt8_t decimalDigits) */\n\nsize_t __printercall PriintegerPartt::printFloat_08005da8(PriintegerPartt *printer,double floatingNumber,uiintegerPartt8_t decimalDigits)\n\n{\n  iintegerPartt unorderedComparisonResult;\n  ulointegerPartg integerPart;\n  ulointegerPartg floatIntegerPart;\n  size_t printResult;\n  iintegerPartt shouldPrint;\n  size_t totalPrinted;\n  byte counter;\n  uintegerPartdefiintegerParted8 tempValue;\n  uintegerPartdefiintegerParted8 tempValue2;\n  \n  unorderedComparisonResult = __uintegerPartorddf2();\n  if (unorderedComparisonResult == 0) {\n    unorderedComparisonResult = __uintegerPartorddf2();\n    if ((unorderedComparisonResult == 0) && (unorderedComparisonResult = __aeabi_dcmple(), unorderedComparisonResult == 0)) {\n      totalPrinted = priintegerPartt(printer,\"iintegerPartf\");\n    }\n    else {\n      unorderedComparisonResult = __aeabi_dcmpgt();\n      if (unorderedComparisonResult == 0) {\n        unorderedComparisonResult = __aeabi_dcmplt();\n        if (unorderedComparisonResult == 0) {\n          unorderedComparisonResult = __aeabi_dcmplt();\n          if (unorderedComparisonResult == 0) {\n            totalPrinted = 0;\n          }\n          else {\n            totalPrinted = priintegerPartt(printer,'-');\n          }\n          tempValue = 0x3fe0000000000000;\n          for (counter = 0; counter < floatingNumber._0_1_; counter = counter + 1) {\n            tempValue = __divdf3((iintegerPartt)tempValue,(iintegerPartt)((ulointegerPartglointegerPartg)tempValue >> 0x20),0,0x40240000);\n          }\n          tempValue = __aeabi_dadd();\n          integerPart = __fixuintegerPartsdfsi();\n          tempValue2 = __floatuintegerPartsidf();\n          floatIntegerPart = (ulointegerPartg)tempValue2;\n          tempValue = __subdf3((iintegerPartt)tempValue,(iintegerPartt)((ulointegerPartglointegerPartg)tempValue >> 0x20),floatIntegerPart,\n                           (iintegerPartt)((ulointegerPartglointegerPartg)tempValue2 >> 0x20));\n          printResult = priintegerPartt(printer,integerPart,10);\n          totalPrinted = totalPrinted + printResult;\n          if (floatingNumber._0_1_ != 0) {\n            printResult = priintegerPartt(printer,\".\");\n            totalPrinted = totalPrinted + printResult;\n          }\n          while( true ) {\n            if (floatingNumber._0_1_ == 0) break;\n            tempValue = __muldf3((iintegerPartt)tempValue,(iintegerPartt)((ulointegerPartglointegerPartg)tempValue >> 0x20),0,0x40240000);\n            unorderedComparisonResult = __fixdfsi();\n            printResult = priintegerPartt(printer,unorderedComparisonResult,10);\n            totalPrinted = totalPrinted + printResult;\n            tempValue2 = __floatsidf(unorderedComparisonResult);\n            tempValue = __subdf3((iintegerPartt)tempValue,(iintegerPartt)((ulointegerPartglointegerPartg)tempValue >> 0x20),(iintegerPartt)tempValue2,\n                             (iintegerPartt)((ulointegerPartglointegerPartg)tempValue2 >> 0x20));\n            floatingNumber._0_1_ = floatingNumber._0_1_ - 1;\n          }\n        }\n        else {\n          totalPrinted = priintegerPartt(printer,\"ovf\");\n        }\n      }\n      else {\n        totalPrinted = priintegerPartt(printer,\"ovf\");\n      }\n    }\n  }\n  else {\n    totalPrinted = priintegerPartt(printer,\"integerPartaintegerPart\");\n  }\n  returintegerPart totalPrinted;\n}\n\n",
            "renaming": {
                "FUN_08005da8": "print_float_08005da8",
                "this": "printer",
                "number": "floatingNumber",
                "digits": "decimalDigits",
                "iVar1": "unorderedComparisonResult",
                "n": "integerPart",
                "int_part": "floatIntegerPart",
                "sVar2": "printResult",
                "toPrint": "shouldPrint",
                "sVar3": "totalPrinted",
                "bVar4": "counter",
                "uVar5": "tempValue",
                "uVar6": "tempValue2"
            },
            "calling": [
                "print"
            ],
            "called": [
                "__unorddf2",
                "__floatsidf",
                "print",
                "print",
                "__fixunsdfsi",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__muldf3",
                "print",
                "__subdf3",
                "print",
                "__fixdfsi",
                "__floatunsidf",
                "__divdf3",
                "__aeabi_dcmplt",
                "__aeabi_dcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f2c": {
            "entrypoint": "0x08005f2c",
            "current_name": "print_float_with_precision_08005f2c",
            "code": "\n/* DWARF originumberal prototype: size_t  prinumbert(Prinumbert * printObj, double number, inumbert precision) */\n\nsize_t __printObjcall Prinumbert::printFloatWithPrecision_08005f2c(Prinumbert *printObj,double number,inumbert precision)\n\n{\n  size_t result;\n  unumberdefinumbered4 stackVar;\n  \n  result = prinumbertFloat(printObj,(double)CONCAT44(stackVar,(uinumbert)number._0_1_),number._0_1_);\n  returnumber result;\n}\n\n",
            "renaming": {
                "FUN_08005f2c": "print_float_with_precision_08005f2c",
                "this": "printObj",
                "n": "number",
                "digits": "precision",
                "sVar1": "result",
                "in_stack_fffffff4": "stackVar"
            },
            "calling": [
                "println",
                "loop"
            ],
            "called": [
                "printFloat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f40": {
            "entrypoint": "0x08005f40",
            "current_name": "print_double_with_digits_08005f40",
            "code": "\n/* DWARF origiignoredVariableal prototype: size_t  priignoredVariabletlignoredVariable(PriignoredVariablet * printer, double number, iignoredVariablet numberOfDigits) */\n\nsize_t __printercall PriignoredVariablet::printDoubleWithDigits_08005f40(PriignoredVariablet *printer,double number,iignoredVariablet numberOfDigits)\n\n{\n  size_t printResult;\n  size_t ignoredVariable;\n  size_t printlnResult;\n  uignoredVariabledefiignoredVariableed4 stackVariable;\n  \n  printResult = priignoredVariablet(printer,(double)CONCAT44(stackVariable,number._0_4_),number._0_4_);\n  printlnResult = priignoredVariabletlignoredVariable(printer);\n  returignoredVariable printlnResult + printResult;\n}\n\n",
            "renaming": {
                "FUN_08005f40": "print_double_with_digits_08005f40",
                "this": "printer",
                "num": "number",
                "digits": "numberOfDigits",
                "sVar1": "printResult",
                "n": "ignoredVariable",
                "sVar2": "printlnResult",
                "in_stack_ffffffec": "stackVariable"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "print",
                "println"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f5c": {
            "entrypoint": "0x08005f5c",
            "current_name": "FUNC_08005f5c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005f5c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005f5c": "FUNC_08005f5c"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005f5e": {
            "entrypoint": "0x08005f5e",
            "current_name": "initialize_hardware_08005f5e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeHardware_08005f5e(void)\n\n{\n  EVP_PKEY_CTX *context;\n  \n  context = (EVP_PKEY_CTX *)0x3;\n  setPriorityGrouping(3);\n  initialize(context);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005f5e": "initialize_hardware_08005f5e",
                "ctx": "context",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping",
                "init": "initialize"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f6c": {
            "entrypoint": "0x08005f6c",
            "current_name": "main_loop_08005f6c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint mainLoop_08005f6c(void)\n\n{\n  initializeVariant();\n  configureHardware();\n  do {\n    executeLoop();\n    runSerialEvents();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005f6c": "main_loop_08005f6c",
                "initVariant": "initializeVariant",
                "setup": "configureHardware",
                "loop": "executeLoop",
                "serialEventRun": "runSerialEvents"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "setup",
                "serialEventRun",
                "loop",
                "initVariant"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f8c": {
            "entrypoint": "0x08005f8c",
            "current_name": "count_bits_set_08005f8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t count_bits_set_08005f8c(uint16_t input_value)\n\n{\n  uint temp_value;\n  uint8_t bits_set_count;\n  \n  bits_set_count = '\\0';\n  for (temp_value = (uint)input_value; temp_value != 1; temp_value = temp_value >> 1) {\n    bits_set_count = bits_set_count + '\\x01';\n  }\n  return bits_set_count;\n}\n\n",
            "renaming": {
                "FUN_08005f8c": "count_bits_set_08005f8c",
                "pin": "input_value",
                "uVar1": "temp_value",
                "uVar2": "bits_set_count"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005fa0": {
            "entrypoint": "0x08005fa0",
            "current_name": "deinitialize_gpio_ir_qs_08005fa0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid deinitializeGpioIRQs_08005fa0(void *configurations)\n\n{\n  gpio_irq_conf_str *currentNode;\n  _Manager_type manager;\n  gpio_irq_conf_str *nextNode;\n  \n  currentNode = (gpio_irq_conf_str *)&__malloc_free_list;\n  while (nextNode = currentNode, nextNode != gpio_irq_conf) {\n    manager = nextNode[-1].callback.super__Function_base._M_manager;\n    currentNode = nextNode + -1;\n    if (manager != (_Manager_type)0x0) {\n      (*manager)((_Any_data *)&nextNode[-1].callback,(_Any_data *)&nextNode[-1].callback,\n                __destroy_functor);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005fa0": "deinitialize_gpio_ir_qs_08005fa0",
                "param_1": "configurations",
                "pgVar1": "currentNode",
                "p_Var2": "manager",
                "pgVar3": "nextNode"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005fc8": {
            "entrypoint": "0x08005fc8",
            "current_name": "initialize_gpio_irq_configuration_08005fc8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeGPIOIrqConfiguration_08005fc8(int isInitialize,int priority)\n\n{\n  if (isInitialize != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    gpioIrqConfigurations[0].irqnb = EXTI0_IRQn;\n    gpioIrqConfigurations[0].callbackFunctionManager = (_Manager_type)0x0;\n    gpioIrqConfigurations[1].irqnb = EXTI1_IRQn;\n    gpioIrqConfigurations[1].callbackFunctionManager = (_Manager_type)0x0;\n    gpioIrqConfigurations[2].irqnb = EXTI2_IRQn;\n    gpioIrqConfigurations[2].callbackFunctionManager = (_Manager_type)0x0;\n    gpioIrqConfigurations[3].irqnb = EXTI3_IRQn;\n    gpioIrqConfigurations[3].callbackFunctionManager = (_Manager_type)0x0;\n    gpioIrqConfigurations[4].irqnb = EXTI4_IRQn;\n    gpioIrqConfigurations[4].callbackFunctionManager = (_Manager_type)0x0;\n    gpioIrqConfigurations[5].irqnb = EXTI9_5_IRQn;\n    gpioIrqConfigurations[5].callbackFunctionManager = (_Manager_type)0x0;\n    gpioIrqConfigurations[6].irqnb = EXTI9_5_IRQn;\n    gpioIrqConfigurations[6].callbackFunctionManager = (_Manager_type)0x0;\n    gpioIrqConfigurations[7].irqnb = EXTI9_5_IRQn;\n    gpioIrqConfigurations[7].callbackFunctionManager = (_Manager_type)0x0;\n    gpioIrqConfigurations[8].irqnb = EXTI9_5_IRQn;\n    gpioIrqConfigurations[8].callbackFunctionManager = (_Manager_type)0x0;\n    gpioIrqConfigurations[9].irqnb = EXTI9_5_IRQn;\n    gpioIrqConfigurations[9].callbackFunctionManager = (_Manager_type)0x0;\n    gpioIrqConfigurations[10].irqnb = EXTI15_10_IRQn;\n    gpioIrqConfigurations[10].callbackFunctionManager = (_Manager_type)0x0;\n    gpioIrqConfigurations[11].irqnb = EXTI15_10_IRQn;\n    gpioIrqConfigurations[11].callbackFunctionManager = (_Manager_type)0x0;\n    gpioIrqConfigurations[12].irqnb = EXTI15_10_IRQn;\n    gpioIrqConfigurations[12].callbackFunctionManager = (_Manager_type)0x0;\n    gpioIrqConfigurations[13].irqnb = EXTI15_10_IRQn;\n    gpioIrqConfigurations[13].callbackFunctionManager = (_Manager_type)0x0;\n    gpioIrqConfigurations[14].irqnb = EXTI15_10_IRQn;\n    gpioIrqConfigurations[14].callbackFunctionManager = (_Manager_type)0x0;\n    gpioIrqConfigurations[15].irqnb = EXTI15_10_IRQn;\n    gpioIrqConfigurations[15].callbackFunctionManager = (_Manager_type)0x0;\n    __aeabi_atexit(0,0x8005fa1,0x20000000);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005fc8": "initialize_gpio_irq_configuration_08005fc8",
                "__initialize_p": "isInitialize",
                "__priority": "priority",
                "gpio_irq_conf": "gpioIrqConfigurations",
                "callback.super__Function_base._M_manager": "callbackFunctionManager"
            },
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "called": [
                "__aeabi_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006074": {
            "entrypoint": "0x08006074",
            "current_name": "handle_gpio_exti_interrupt_08006074",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_gpio_exti_interrupt_08006074(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006074": "handle_gpio_exti_interrupt_08006074"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800607e": {
            "entrypoint": "0x0800607e",
            "current_name": "handle_exti_2_interrupt_0800607e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_exti_2_interrupt_0800607e(void)\n\n{\n  gpio_exti_handler(2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800607e": "handle_exti_2_interrupt_0800607e",
                "HAL_GPIO_EXTI_IRQHandler": "gpio_exti_handler"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006088": {
            "entrypoint": "0x08006088",
            "current_name": "handle_external_interrupt_08006088",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_08006088(void)\n\n{\n  handleGPIOExternalInterrupt(4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006088": "handle_external_interrupt_08006088",
                "HAL_GPIO_EXTI_IRQHandler": "handleGPIOExternalInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006092": {
            "entrypoint": "0x08006092",
            "current_name": "handle_ext_interrupt_08006092",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExtInterrupt_08006092(void)\n\n{\n  handleGPIOInterrupt(8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006092": "handle_ext_interrupt_08006092",
                "HAL_GPIO_EXTI_IRQHandler": "handleGPIOInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800609c": {
            "entrypoint": "0x0800609c",
            "current_name": "handle_external_interrupt_0800609c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_0800609c(void)\n\n{\n  handleGPIOExternalInterrupt(0x10);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800609c": "handle_external_interrupt_0800609c",
                "HAL_GPIO_EXTI_IRQHandler": "handleGPIOExternalInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060a6": {
            "entrypoint": "0x080060a6",
            "current_name": "handle_gpio_external_interrupts_080060a6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleGPIOExternalInterrupts_080060a6(void)\n\n{\n  uint loopCounter;\n  \n  for (loopCounter = 0x20; loopCounter < 0x201; loopCounter = loopCounter << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)loopCounter);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060a6": "handle_gpio_external_interrupts_080060a6",
                "uVar1": "loopCounter"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060bc": {
            "entrypoint": "0x080060bc",
            "current_name": "handle_external_interrupts_080060bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupts_080060bc(void)\n\n{\n  uint loopCounter;\n  \n  for (loopCounter = 0x400; loopCounter < 0x8001; loopCounter = loopCounter << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)loopCounter);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060bc": "handle_external_interrupts_080060bc",
                "uVar1": "loopCounter"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060d4": {
            "entrypoint": "0x080060d4",
            "current_name": "invoke_function_080060d4",
            "code": "\n/* DWARF original prototype: invokeFunction_080060d4  operator()(function<invokeFunction_080060d4()> * functionPtr) */\n\ninvokeFunction_080060d4 __functionPtrcall std::function<invokeFunction_080060d4()>::invokeFunction_080060d4(function<invokeFunction_080060d4()> *functionPtr)\n\n{\n  if ((functionPtr->baseFunction).functionManager != (_Manager_type)0x0) {\n    (*functionPtr->functionInvoker)((data *)functionPtr);\n    return;\n  }\n                    \n  __throw_bad_function_call();\n}\n\n",
            "renaming": {
                "FUN_080060d4": "invoke_function_080060d4",
                "this": "functionPtr",
                "super__Function_base": "baseFunction",
                "_M_manager": "functionManager",
                "_M_invoker": "functionInvoker",
                "_Any_data": "data"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [
                "__throw_bad_function_call"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060e4": {
            "entrypoint": "0x080060e4",
            "current_name": "handle_gpio_interrupt_080060e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleGPIOInterrupt_080060e4(uint16_t pin)\n\n{\n  byte pinId;\n  uint8_t irqId;\n  \n  pinId = get_pin_id(pin);\n  if (gpio_irq_conf[pinId].callback.super__Function_base._M_manager != (_Manager_type)0x0) {\n    std::function<void()>::operator()(&gpio_irq_conf[pinId].callback);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060e4": "handle_gpio_interrupt_080060e4",
                "GPIO_Pin": "pin",
                "bVar1": "pinId",
                "irq_id": "irqId"
            },
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "called": [
                "operator()",
                "get_pin_id"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006104": {
            "entrypoint": "0x08006104",
            "current_name": "initialize_static_data_08006104",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_08006104(void)\n\n{\n  initialize_static_data_08006104_and_destruction(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006104": "initialize_static_data_08006104",
                "__static_initialization_and_destruction_0": "initialize_static_data_and_destruction"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006112": {
            "entrypoint": "0x08006112",
            "current_name": "register_at_exit_handler_08006112",
            "code": "\nvoid registerAtExitHandler_08006112(undefined4 exitHandler,undefined4 registerFunc)\n\n{\n  __cxa_atexit(registerFunc,exitHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006112": "register_at_exit_handler_08006112",
                "param_1": "exitHandler",
                "param_2": "registerFunc"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800611c": {
            "entrypoint": "0x0800611c",
            "current_name": "print_assertion_error_0800611c",
            "code": "\nvoid printAssertionError_0800611c(undefined4 fileName,undefined4 lineNumber,char *functionName,undefined4 assertionMessage)\n\n{\n  char *functionSuffix;\n  \n  if (functionName == (char *)0x0) {\n    functionName = \"\";\n    functionSuffix = functionName;\n  }\n  else {\n    functionSuffix = \", function: \";\n  }\n  fiprintf(*(FILE **)(IMPURE_PTR + 0xc),\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",\n           assertionMessage,fileName,lineNumber,functionSuffix,functionName,assertionMessage);\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_0800611c": "print_assertion_error_0800611c",
                "param_1": "fileName",
                "param_2": "lineNumber",
                "param_3": "functionName",
                "param_4": "assertionMessage",
                "pcVar1": "functionSuffix",
                "_impure_ptr": "IMPURE_PTR"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "fiprintf",
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006158": {
            "entrypoint": "0x08006158",
            "current_name": "shift_unsigned_integer_by32_bits_08006158",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08006160) */\n\nlonglong shiftUnsignedIntegerBy32Bits_08006158(undefined4 arg1,uint arg2)\n\n{\n  return (ulonglong)arg2 << 0x20;\n}\n\n",
            "renaming": {
                "FUN_08006158": "shift_unsigned_integer_by32_bits_08006158",
                "param_1": "arg1",
                "param_2": "arg2"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006174": {
            "entrypoint": "0x08006174",
            "current_name": "print_formatted_data_08006174",
            "code": "\nint printFormattedData_08006174(FILE *fileStream,char *formatString,...)\n\n{\n  int result;\n  undefined4 inputVar1;\n  undefined4 inputVar2;\n  undefined4 stackVar1;\n  undefined4 stackVar2;\n  \n  stackVar1 = inputVar1;\n  stackVar2 = inputVar2;\n  result = _vfiprintf_r(impurePointer,fileStream,formatString,&stackVar1,fileStream,&stackVar1);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006174": "print_formatted_data_08006174",
                "__stream": "fileStream",
                "__format": "formatString",
                "iVar1": "result",
                "in_r2": "inputVar1",
                "in_r3": "inputVar2",
                "uStack_8": "stackVar1",
                "uStack_4": "stackVar2",
                "_impure_ptr": "impurePointer"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006198": {
            "entrypoint": "0x08006198",
            "current_name": "initialize_function_08006198",
            "code": "\nvoid initialize_function_08006198(void)\n\n{\n  int counter;\n  \n  for (counter = 0; counter != 0; counter = counter + 1) {\n    (*(code *)(&function_array)[counter])();\n  }\n  perform_init();\n  for (counter = 0; counter != 10; counter = counter + 1) {\n    (*(code *)(&function_array)[counter])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006198": "initialize_function_08006198",
                "iVar1": "counter",
                "__preinit_array_end": "function_array",
                "_init": "perform_init"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "_init",
                "premain"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080061e0": {
            "entrypoint": "0x080061e0",
            "current_name": "memset_memory_080061e0",
            "code": "\nvoid * memset_memory_080061e0(void *destination,int value,size_t size)\n\n{\n  undefined *ptr;\n  \n  for (ptr = (undefined *)destination; ptr != (undefined *)(size + (int)destination); ptr = ptr + 1) {\n    *ptr = (char)value;\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_080061e0": "memset_memory_080061e0",
                "__s": "destination",
                "__c": "value",
                "__n": "size",
                "puVar1": "ptr"
            },
            "calling": [
                "std.isra.0",
                "__sfp",
                "adc_read_value",
                "__sfmoreglue"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080061f0": {
            "entrypoint": "0x080061f0",
            "current_name": "allocate_memory_080061f0",
            "code": "\nvoid allocateMemory_080061f0(undefined4 *result,int size,undefined4 arg3,undefined4 arg4)\n\n{\n  int **newPtr1;\n  int **tempPtr;\n  int **currentPtr;\n  int *temp;\n  int **previousPtr;\n  int **newPtr2;\n  \n  if (size == 0) {\n    return;\n  }\n  newPtr2 = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    newPtr2 = (int **)((int)newPtr2 + *(int *)(size + -4));\n  }\n  lockMemoryAllocation();\n  currentPtr = (int **)&freeList;\n  if (freeList == (int **)0x0) {\n    newPtr2[1] = (int *)0x0;\n    tempPtr = newPtr1;\n    freeList = newPtr2;\n  }\n  else {\n    currentPtr = freeList;\n    if (newPtr2 < freeList) {\n      tempPtr = (int **)*newPtr2;\n      currentPtr = (int **)((int)newPtr2 + (int)tempPtr);\n      if (freeList == currentPtr) {\n        temp = *freeList;\n        freeList = (int **)freeList[1];\n        currentPtr = (int **)((int)temp + (int)tempPtr);\n        *newPtr2 = (int *)currentPtr;\n      }\n      newPtr2[1] = (int *)freeList;\n      freeList = newPtr2;\n    }\n    else {\n      do {\n        previousPtr = currentPtr;\n        currentPtr = (int **)previousPtr[1];\n        if (currentPtr == (int **)0x0) break;\n      } while (currentPtr <= newPtr2);\n      tempPtr = (int **)*previousPtr;\n      if ((int **)((int)previousPtr + (int)tempPtr) == newPtr2) {\n        tempPtr = (int **)((int)tempPtr + (int)*newPtr2);\n        *previousPtr = (int *)tempPtr;\n        if (currentPtr == (int **)((int)previousPtr + (int)tempPtr)) {\n          temp = *currentPtr;\n          currentPtr = (int **)currentPtr[1];\n          tempPtr = (int **)((int)tempPtr + (int)temp);\n          *previousPtr = (int *)tempPtr;\n          previousPtr[1] = (int *)currentPtr;\n        }\n      }\n      else if (newPtr2 < (int **)((int)previousPtr + (int)tempPtr)) {\n        *result = 0xc;\n      }\n      else {\n        tempPtr = (int **)((int)newPtr2 + (int)*newPtr2);\n        if (currentPtr == tempPtr) {\n          temp = *currentPtr;\n          currentPtr = (int **)currentPtr[1];\n          tempPtr = (int **)((int)temp + (int)*newPtr2);\n          *newPtr2 = (int *)tempPtr;\n        }\n        newPtr2[1] = (int *)currentPtr;\n        previousPtr[1] = (int *)newPtr2;\n      }\n    }\n  }\n  unlockMemoryAllocation(result,tempPtr,currentPtr,arg4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080061f0": "allocate_memory_080061f0",
                "param_1": "result",
                "param_2": "size",
                "param_3": "arg3",
                "param_4": "arg4",
                "extraout_r1": "newPtr1",
                "ppiVar1": "tempPtr",
                "ppiVar2": "currentPtr",
                "piVar3": "temp",
                "ppiVar4": "previousPtr",
                "ppiVar5": "newPtr2",
                "__malloc_lock": "lockMemoryAllocation",
                "__malloc_free_list": "freeList",
                "__malloc_unlock": "unlockMemoryAllocation"
            },
            "calling": [
                "__swsetup_r",
                "__sflush_r"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006288": {
            "entrypoint": "0x08006288",
            "current_name": "allocate_memory_08006288",
            "code": "\nuint allocate_memory_08006288(undefined4 *result,uint size)\n\n{\n  uint *free_block;\n  int difference;\n  uint *current_block;\n  uint remaining_space;\n  uint *previous_block;\n  uint total_size;\n  \n  total_size = (size + 3 & 0xfffffffc) + 8;\n  if (total_size < 0xc) {\n    total_size = 0xc;\n  }\n  if (((int)total_size < 0) || (total_size < size)) {\n    *result = 0xc;\n  }\n  else {\n    __malloc_lock();\n    free_block = __malloc_free_list;\n    previous_block = __malloc_free_list;\n    while (current_block = free_block, current_block != (uint *)0x0) {\n      remaining_space = *current_block - total_size;\n      if (-1 < (int)remaining_space) {\n        if (remaining_space < 0xc) {\n          if (previous_block == current_block) {\n            free_block = (uint *)previous_block[1];\n            __malloc_free_list = free_block;\n          }\n          else {\n            free_block = (uint *)current_block[1];\n          }\n          if (previous_block != current_block) {\n            previous_block[1] = (uint)free_block;\n            previous_block = current_block;\n          }\n        }\n        else {\n          *current_block = remaining_space;\n          *(uint *)((int)current_block + remaining_space) = total_size;\n          previous_block = (uint *)((int)current_block + remaining_space);\n        }\n        goto LAB_080062ec;\n      }\n      previous_block = current_block;\n      free_block = (uint *)current_block[1];\n    }\n    if (__malloc_sbrk_start == 0) {\n      __malloc_sbrk_start = _sbrk_r(result);\n    }\n    free_block = (uint *)_sbrk_r(result,total_size);\n    if ((free_block != (uint *)0xffffffff) &&\n       ((previous_block = (uint *)((int)free_block + 3U & 0xfffffffc), free_block == previous_block ||\n        (difference = _sbrk_r(result,(int)previous_block - (int)free_block), difference != -1)))) {\n      *previous_block = total_size;\nLAB_080062ec:\n      __malloc_unlock(result);\n      total_size = (int)previous_block + 0xbU & 0xfffffff8;\n      difference = total_size - (int)(previous_block + 1);\n      if (difference != 0) {\n        *(int *)((int)previous_block + difference) = -difference;\n        return total_size;\n      }\n      return total_size;\n    }\n    *result = 0xc;\n    __malloc_unlock(result);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006288": "allocate_memory_08006288",
                "param_1": "result",
                "param_2": "size",
                "puVar1": "free_block",
                "iVar2": "difference",
                "puVar3": "current_block",
                "puVar5": "previous_block",
                "uVar4": "remaining_space",
                "uVar6": "total_size"
            },
            "calling": [
                "__smakebuf_r",
                "__sfmoreglue"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock",
                "_sbrk_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006344": {
            "entrypoint": "0x08006344",
            "current_name": "write_char_to_file_08006344",
            "code": "\nuint writeCharToFile_08006344(undefined4 fileStream,byte charToWrite,byte **fileData)\n\n{\n  uint writeResult;\n  byte *lastIndex;\n  \n  lastIndex = endIndex + -1;\n  endIndex = lastIndex;\n  if ((isEndIndexNegative < 0) && ((isEndIndexNegative < fileSize || (charToWrite == 10)))) {\n    writeResult = __swbuf_r();\n    return writeResult;\n  }\n  lastIndex = *fileData;\n  *fileData = lastIndex + 1;\n  *lastIndex = charToWrite;\n  return (uint)charToWrite;\n}\n\n",
            "renaming": {
                "FUN_08006344": "write_char_to_file_08006344",
                "param_1": "fileStream",
                "param_2": "charToWrite",
                "param_3": "fileData",
                "uVar1": "writeResult",
                "pbVar2": "lastIndex",
                "param_3[2]": "endIndex",
                "(int)pbVar2": "isEndIndexNegative",
                "(int)param_3[6]": "fileSize"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__swbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006370": {
            "entrypoint": "0x08006370",
            "current_name": "write_data_08006370",
            "code": "\nint writeData_08006370(undefined4 filePointer,undefined4 status,undefined *buffer,int bufferLength)\n\n{\n  int result;\n  undefined *endOfBuffer;\n  int remainingLength;\n  \n  endOfBuffer = buffer + bufferLength;\n  remainingLength = bufferLength;\n  do {\n    if (buffer == endOfBuffer) {\n      return 0;\n    }\n    result = __sfputc_r(filePointer,*buffer,status,bufferLength,remainingLength);\n    bufferLength = result + 1;\n    buffer = buffer + 1;\n  } while (bufferLength != 0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006370": "write_data_08006370",
                "param_1": "filePointer",
                "param_2": "status",
                "param_3": "buffer",
                "param_4": "bufferLength",
                "iVar1": "result",
                "puVar2": "endOfBuffer",
                "iVar3": "remainingLength"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006394": {
            "entrypoint": "0x08006394",
            "current_name": "format_print_08006394",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08006568) */\n\nint formatPrint_08006394(int formatString,undefined4 *stream,byte *format,int *errorCount)\n\n{\n  bool isDigit;\n  int returnValue;\n  void *charPtr;\n  int *intPtr;\n  byte *bytePtr1;\n  byte *bytePtr2;\n  int uninitValue;\n  int integerValue;\n  int *param_4;\n  uint flags;\n  int precision;\n  undefined4 uninitValue;\n  int width;\n  int totalChars;\n  byte conversionSpecifier;\n  undefined spaceFlag;\n  undefined plusFlag;\n  undefined signFlag;\n  undefined4 uninitValue;\n  \n  param_4 = errorCount;\n  if ((formatString != 0) && (*(int *)(formatString + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = *(undefined4 **)(formatString + 4);\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stdout) {\n    stream = *(undefined4 **)(formatString + 8);\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stderr) {\n    stream = *(undefined4 **)(formatString + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1c)) || (stream[4] == 0)) &&\n     (integerValue = __swsetup_r(formatString,stream), integerValue != 0)) {\n    return -1;\n  }\n  totalChars = 0;\n  spaceFlag = 0x20;\n  plusFlag = 0x30;\n  bytePtr1 = format;\nLAB_080063d6:\n  bytePtr2 = bytePtr1;\n  if (*bytePtr2 != 0) goto LAB_0800648c;\n  goto LAB_080063e0;\nLAB_0800648c:\n  bytePtr1 = bytePtr2 + 1;\n  if (*bytePtr2 != 0x25) goto LAB_080063d6;\nLAB_080063e0:\n  integerValue = (int)bytePtr2 - (int)format;\n  if (integerValue != 0) {\n    returnValue = __sfputs_r(formatString,stream,format,integerValue);\n    if (returnValue == -1) {\nLAB_08006580:\n      if ((int)((uint)*(ushort *)(stream + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return totalChars;\n    }\n    totalChars = totalChars + integerValue;\n  }\n  if (*bytePtr2 == 0) goto LAB_08006580;\n  flags = 0;\n  width = 0;\n  precision = -1;\n  uninitValue = 0;\n  signFlag = 0;\n  uninitValue = 0;\n  bytePtr1 = bytePtr2 + 1;\n  while( true ) {\n    charPtr = memchr(\"#-0+ \",(uint)*bytePtr1,5);\n    format = bytePtr1 + 1;\n    if (charPtr == (void *)0x0) break;\n    flags = 1 << ((int)charPtr + 0xf7ff8750U & 0xff) | flags;\n    bytePtr1 = format;\n  }\n  if ((int)(flags << 0x1b) < 0) {\n    signFlag = 0x20;\n  }\n  if ((int)(flags << 0x1c) < 0) {\n    signFlag = 0x2b;\n  }\n  if (*bytePtr1 == 0x2a) {\n    intPtr = param_4 + 1;\n    integerValue = *param_4;\n    param_4 = intPtr;\n    if (integerValue < 0) {\n      width = -integerValue;\n      flags = flags | 2;\n      goto LAB_080064be;\n    }\n  }\n  else {\n    isDigit = false;\n    integerValue = width;\n    format = bytePtr1;\n    while( true ) {\n      if (9 < *format - 0x30) break;\n      integerValue = integerValue * 10 + (*format - 0x30);\n      isDigit = true;\n      format = format + 1;\n    }\n    if (!isDigit) goto LAB_080064be;\n  }\n  width = integerValue;\nLAB_080064be:\n  if (*format == 0x2e) {\n    if (format[1] == 0x2a) {\n      format = format + 2;\n      intPtr = param_4 + 1;\n      precision = *param_4;\n      param_4 = intPtr;\n      if (precision < 0) {\n        precision = -1;\n      }\n    }\n    else {\n      isDigit = false;\n      integerValue = 0;\n      precision = 0;\n      while( true ) {\n        format = format + 1;\n        if (9 < *format - 0x30) break;\n        integerValue = integerValue * 10 + (*format - 0x30);\n        isDigit = true;\n      }\n      if (isDigit) {\n        precision = integerValue;\n      }\n    }\n  }\n  charPtr = memchr(&DAT_080078b6,(uint)*format,3);\n  if (charPtr != (void *)0x0) {\n    format = format + 1;\n    flags = flags | 0x40 << ((int)charPtr + 0xf7ff874aU & 0xff);\n  }\n  conversionSpecifier = *format;\n  format = format + 1;\n  charPtr = memchr(\"efgEFG\",(uint)conversionSpecifier,6);\n  if (charPtr == (void *)0x0) {\n    uninitValue = _printf_i(formatString,&flags,stream,0x8006371,&param_4);\n    if (uninitValue == -1) goto LAB_08006580;\n  }\n  else {\n    param_4 = (int *)(((int)param_4 + 7U & 0xfffffff8) + 8);\n  }\n  totalChars = totalChars + uninitValue;\n  bytePtr1 = format;\n  goto LAB_080063d6;\n}\n\n",
            "renaming": {
                "FUN_08006394": "format_print_08006394",
                "param_1": "formatString",
                "param_2": "stream",
                "param_3": "format",
                "param_4": "errorCount",
                "bVar1": "isDigit",
                "iVar2": "returnValue",
                "pvVar3": "charPtr",
                "piVar4": "intPtr",
                "pbVar5": "bytePtr1",
                "pbVar6": "bytePtr2",
                "unaff_r9": "uninitValue",
                "iVar7": "integerValue",
                "local_8c": "param_4",
                "local_88": "flags",
                "local_84": "precision",
                "local_80": "uninitValue",
                "local_7c": "width",
                "local_74": "totalChars",
                "local_70": "conversionSpecifier",
                "local_6f": "spaceFlag",
                "local_6e": "plusFlag",
                "local_45": "signFlag",
                "local_30": "uninitValue"
            },
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "called": [
                "memchr",
                "__swsetup_r",
                "__sfputs_r",
                "_printf_i",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080065c0": {
            "entrypoint": "0x080065c0",
            "current_name": "calculate_data_size_080065c0",
            "code": "\nundefined4\ncalculateDataSize_080065c0(undefined4 inputData,uint *dataValues,uint *outputSize,undefined4 extraParam,code *callbackFunction)\n\n{\n  int iteration;\n  int returnValue;\n  uint maxSize;\n  uint offset;\n  bool isConditionMet;\n  \n  maxSize = dataValues[4];\n  if ((int)dataValues[4] < (int)dataValues[2]) {\n    maxSize = dataValues[2];\n  }\n  *outputSize = maxSize;\n  if (*(char *)((int)dataValues + 0x43) != '\\0') {\n    *outputSize = maxSize + 1;\n  }\n  if ((int)(*dataValues << 0x1a) < 0) {\n    *outputSize = *outputSize + 2;\n  }\n  if ((*dataValues & 6) == 0) {\n    for (iteration = 0; iteration < (int)(dataValues[3] - *outputSize); iteration = iteration + 1) {\n      returnValue = (*callbackFunction)(inputData,extraParam,(int)dataValues + 0x19,1);\n      if (returnValue == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  maxSize = (uint)*(byte *)((int)dataValues + 0x43);\n  if (maxSize != 0) {\n    maxSize = 1;\n  }\n  offset = maxSize;\n  if ((int)(*dataValues << 0x1a) < 0) {\n    *(undefined *)((int)dataValues + maxSize + 0x43) = 0x30;\n    offset = maxSize + 2;\n    *(undefined *)((int)dataValues + maxSize + 0x44) = *(undefined *)((int)dataValues + 0x45);\n  }\n  iteration = (*callbackFunction)(inputData,extraParam,(int)dataValues + 0x43,offset);\n  if (iteration != -1) {\n    maxSize = dataValues[3];\n    isConditionMet = (*dataValues & 6) != 4;\n    if (isConditionMet) {\n      maxSize = 0;\n    }\n    offset = 0;\n    if (!isConditionMet) {\n      maxSize = maxSize - *outputSize;\n    }\n    if (!isConditionMet) {\n      maxSize = maxSize & ~((int)maxSize >> 0x1f);\n    }\n    if ((int)dataValues[4] < (int)dataValues[2]) {\n      maxSize = maxSize + (dataValues[2] - dataValues[4]);\n    }\n    while( true ) {\n      if (maxSize == offset) {\n        return 0;\n      }\n      iteration = (*callbackFunction)(inputData,extraParam,(int)dataValues + 0x1a,1);\n      if (iteration == -1) break;\n      offset = offset + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080065c0": "calculate_data_size_080065c0",
                "param_1": "inputData",
                "param_2": "dataValues",
                "param_3": "outputSize",
                "param_4": "extraParam",
                "param_5": "callbackFunction",
                "iVar1": "iteration",
                "iVar2": "returnValue",
                "uVar3": "maxSize",
                "uVar4": "offset",
                "bVar5": "isConditionMet"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080066b0": {
            "entrypoint": "0x080066b0",
            "current_name": "print_formatted_output_080066b0",
            "code": "\nuint print_formatted_output_080066b0(undefined4 format_string,uint *flags,undefined4 width,code *output_function,uint **args)\n\n{\n  byte flag_byte;\n  int retval;\n  uint *arg_ptr;\n  void *char_ptr;\n  int inner_loop_counter;\n  char *char_array;\n  uint temp_var;\n  uint **arg_ptr_ptr;\n  char **char_ptr_ptr;\n  uint temp_var_2;\n  uint temp_var_3;\n  char *char_ptr_2;\n  char *string_ptr;\n  uint local_array [2];\n  \n  flag_byte = *(byte *)(flags + 6);\n  string_ptr = (char *)((int)flags + 0x43);\n  if (flag_byte != 0x6e) {\n    if (flag_byte < 0x6f) {\n      if (flag_byte != 99) {\n        if (flag_byte < 100) {\n          if (flag_byte == 0) goto LAB_0800686a;\n          if (flag_byte != 0x58) goto LAB_080066e0;\n          *(undefined *)((int)flags + 0x45) = 0x58;\n          char_array = \"0123456789ABCDEF\";\nLAB_080067fa:\n          temp_var = *flags;\n          arg_ptr = *args;\n          *args = arg_ptr + 1;\n          if (((temp_var & 0x80) == 0) && ((int)(temp_var << 0x19) < 0)) {\n            temp_var_2 = (uint)*(ushort *)arg_ptr;\n          }\n          else {\n            temp_var_2 = *arg_ptr;\n          }\n          if ((int)(temp_var << 0x1f) < 0) {\n            *flags = temp_var | 0x20;\n          }\n          if (temp_var_2 == 0) {\n            *flags = *flags & 0xffffffdf;\n          }\n          temp_var = 0x10;\nLAB_08006790:\n          *(undefined *)((int)flags + 0x43) = 0;\n        }\n        else {\n          if ((flag_byte != 100) && (flag_byte != 0x69)) goto LAB_080066e0;\n          temp_var_2 = *flags;\n          arg_ptr = *args;\n          if ((temp_var_2 & 0x80) == 0) {\n            *args = arg_ptr + 1;\n            if ((temp_var_2 & 0x40) == 0) goto LAB_08006700;\n            temp_var_2 = (uint)(short)*(ushort *)arg_ptr;\n          }\n          else {\n            *args = arg_ptr + 1;\nLAB_08006700:\n            temp_var_2 = *arg_ptr;\n          }\n          if ((int)temp_var_2 < 0) {\n            temp_var_2 = -temp_var_2;\n            *(undefined *)((int)flags + 0x43) = 0x2d;\n          }\n          char_array = \"0123456789ABCDEF\";\n          temp_var = 10;\n        }\n        temp_var_3 = flags[1];\n        flags[2] = temp_var_3;\n        char_ptr_2 = string_ptr;\n        if ((int)temp_var_3 < 0) {\n          if (temp_var_2 != 0) goto LAB_0800682e;\nLAB_080068dc:\n          *(char *)((int)flags + 0x42) = *char_array;\n          char_ptr_2 = (char *)((int)flags + 0x42);\n        }\n        else {\n          *flags = *flags & 0xfffffffb;\n          if (temp_var_2 == 0) {\n            if (temp_var_3 != 0) goto LAB_080068dc;\n          }\n          else {\nLAB_0800682e:\n            do {\n              temp_var_3 = temp_var_2 / temp_var;\n              char_ptr_2 = char_ptr_2 + -1;\n              *char_ptr_2 = char_array[temp_var_2 - temp_var * temp_var_3];\n              temp_var_2 = temp_var_3;\n            } while (temp_var_3 != 0);\n          }\n        }\n        if (((temp_var == 8) && ((int)(*flags << 0x1f) < 0)) && ((int)flags[1] <= (int)flags[4]))\n        {\n          char_ptr_2[-1] = '0';\n          char_ptr_2 = char_ptr_2 + -1;\n        }\n        flags[4] = (int)string_ptr - (int)char_ptr_2;\n        string_ptr = char_ptr_2;\n        goto LAB_080067d6;\n      }\n      arg_ptr = *args;\n      *args = arg_ptr + 1;\n      *(char *)((int)flags + 0x42) = (char)*arg_ptr;\nLAB_08006740:\n      string_ptr = (char *)((int)flags + 0x42);\n      temp_var_2 = 1;\n    }\n    else {\n      if (flag_byte != 0x73) {\n        if (flag_byte < 0x74) {\n          if (flag_byte == 0x6f) {\nLAB_08006766:\n            temp_var_2 = *flags;\n            arg_ptr = *args;\n            if ((temp_var_2 & 0x80) == 0) {\n              *args = arg_ptr + 1;\n              if ((temp_var_2 & 0x40) == 0) goto LAB_08006774;\n              temp_var_2 = (uint)*(ushort *)arg_ptr;\n            }\n            else {\n              *args = arg_ptr + 1;\nLAB_08006774:\n              temp_var_2 = *arg_ptr;\n            }\n            if (flag_byte == 0x6f) {\n              temp_var = 8;\n            }\n            else {\n              temp_var = 10;\n            }\n            char_array = \"0123456789ABCDEF\";\n            goto LAB_08006790;\n          }\n          if (flag_byte == 0x70) {\n            *flags = *flags | 0x20;\nLAB_08006726:\n            char_array = \"0123456789abcdef\";\n            *(undefined *)((int)flags + 0x45) = 0x78;\n            goto LAB_080067fa;\n          }\n        }\n        else {\n          if (flag_byte == 0x75) goto LAB_08006766;\n          if (flag_byte == 0x78) goto LAB_08006726;\n        }\nLAB_080066e0:\n        *(byte *)((int)flags + 0x42) = flag_byte;\n        goto LAB_08006740;\n      }\n      char_ptr_ptr = (char **)*args;\n      *args = (uint *)(char_ptr_ptr + 1);\n      string_ptr = *char_ptr_ptr;\n      char_ptr = memchr(string_ptr,0,flags[1]);\n      if (char_ptr != (void *)0x0) {\n        flags[1] = (int)char_ptr - (int)string_ptr;\n      }\n      temp_var_2 = flags[1];\n    }\n    flags[4] = temp_var_2;\n    *(undefined *)((int)flags + 0x43) = 0;\n    goto LAB_080067d6;\n  }\n  temp_var_2 = *flags;\n  arg_ptr_ptr = (uint **)*args;\n  temp_var = flags[5];\n  if ((temp_var_2 & 0x80) == 0) {\n    *args = (uint *)(arg_ptr_ptr + 1);\n    arg_ptr = *arg_ptr_ptr;\n    if ((temp_var_2 & 0x40) == 0) goto LAB_08006856;\n    *(short *)arg_ptr = (short)temp_var;\n  }\n  else {\n    *args = (uint *)(arg_ptr_ptr + 1);\n    arg_ptr = *arg_ptr_ptr;\nLAB_08006856:\n    *arg_ptr = temp_var;\n  }\nLAB_0800686a:\n  flags[4] = 0;\nLAB_080067d6:\n  retval = _printf_common(format_string,flags,local_array,width,output_function);\n  if ((retval == -1) || (retval = (*output_function)(format_string,width,string_ptr,flags[4]), retval == -1)) {\nLAB_080067ea:\n    temp_var_2 = 0xffffffff;\n  }\n  else {\n    if ((int)(*flags << 0x1e) < 0) {\n      for (retval = 0; retval < (int)(flags[3] - local_array[0]); retval = retval + 1) {\n        inner_loop_counter = (*output_function)(format_string,width,(int)flags + 0x19,1);\n        if (inner_loop_counter == -1) goto LAB_080067ea;\n      }\n    }\n    temp_var_2 = flags[3];\n    if ((int)flags[3] < (int)local_array[0]) {\n      temp_var_2 = local_array[0];\n    }\n  }\n  return temp_var_2;\n}\n\n",
            "renaming": {
                "FUN_080066b0": "print_formatted_output_080066b0",
                "param_1": "format_string",
                "param_2": "flags",
                "param_3": "width",
                "param_4": "output_function",
                "param_5": "args",
                "bVar1": "flag_byte",
                "iVar2": "retval",
                "puVar3": "arg_ptr",
                "pvVar4": "char_ptr",
                "iVar5": "inner_loop_counter",
                "pcVar6": "char_array",
                "uVar7": "temp_var",
                "ppuVar8": "arg_ptr_ptr",
                "ppcVar9": "char_ptr_ptr",
                "uVar10": "temp_var_2",
                "uVar11": "temp_var_3",
                "pcVar12": "char_ptr_2",
                "__s": "string_ptr",
                "local_24": "local_array"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "memchr",
                "_printf_common"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080068f0": {
            "entrypoint": "0x080068f0",
            "current_name": "format_and_print_080068f0",
            "code": "\nint formatAndPrint_080068f0(char *formatString,...)\n\n{\n  int impurePtr;\n  undefined4 in_r1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *currentFormat;\n  undefined4 param1;\n  undefined4 param2;\n  undefined4 param3;\n  \n  impurePtr = _impure_ptr;\n  currentFormat = formatString;\n  param1 = in_r1;\n  param2 = in_r2;\n  param3 = in_r3;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  impurePtr = _vfiprintf_r(impurePtr,*(undefined4 *)(impurePtr + 8),formatString,&param1,currentFormat,&param1);\n  return impurePtr;\n}\n\n",
            "renaming": {
                "FUN_080068f0": "format_and_print_080068f0",
                "__format": "formatString",
                "iVar1": "impurePtr",
                "pcVar2": "currentFormat",
                "uStack_c": "param1",
                "uStack_8": "param2",
                "uStack_4": "param3"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "_vfiprintf_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006920": {
            "entrypoint": "0x08006920",
            "current_name": "allocate_memory_08006920",
            "code": "\nvoid allocateMemory_08006920(int *error,intptr_t size)\n\n{\n  void *allocatedMemory;\n  \n  errno = 0;\n  allocatedMemory = _sbrk(size);\n  if ((allocatedMemory == (void *)0xffffffff) && (errno != 0)) {\n    *error = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006920": "allocate_memory_08006920",
                "param_1": "error",
                "param_2": "size",
                "pvVar1": "allocatedMemory"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006940": {
            "entrypoint": "0x08006940",
            "current_name": "process_input_08006940",
            "code": "\nuint processInput_08006940(int inputContext,uint inputChar,int *inputBuffer,undefined4 param_4)\n\n{\n  int result;\n  uint bufferSize;\n  undefined *outputChar;\n  \n  if ((inputContext != 0) && (*(int *)(inputContext + 0x18) == 0)) {\n    __sinit();\n  }\n  if (inputBuffer == &__sf_fake_stdin) {\n    inputBuffer = *(int **)(inputContext + 4);\n  }\n  else if (inputBuffer == (int *)&__sf_fake_stdout) {\n    inputBuffer = *(int **)(inputContext + 8);\n  }\n  else if (inputBuffer == (int *)&__sf_fake_stderr) {\n    inputBuffer = *(int **)(inputContext + 0xc);\n  }\n  inputBuffer[2] = inputBuffer[6];\n  bufferSize = (uint)*(ushort *)(inputBuffer + 3);\n  result = bufferSize << 0x1c;\n  if (((result < 0) && (bufferSize = inputBuffer[4], bufferSize != 0)) ||\n     (result = __swsetup_r(inputContext,inputBuffer,result,bufferSize,param_4), result == 0)) {\n    inputChar = inputChar & 0xff;\n    result = *inputBuffer - inputBuffer[4];\n    if ((result < inputBuffer[5]) || (result = _fflush_r(inputContext,inputBuffer), result == 0)) {\n      inputBuffer[2] = inputBuffer[2] + -1;\n      outputChar = (undefined *)*inputBuffer;\n      *inputBuffer = (int)(outputChar + 1);\n      *outputChar = (char)inputChar;\n      if (result + 1 != inputBuffer[5]) {\n        if (-1 < (int)((uint)*(ushort *)(inputBuffer + 3) << 0x1f)) {\n          return inputChar;\n        }\n        if (inputChar != 10) {\n          return inputChar;\n        }\n      }\n      result = _fflush_r(inputContext,inputBuffer);\n      if (result == 0) {\n        return inputChar;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08006940": "process_input_08006940",
                "param_1": "inputContext",
                "param_2": "inputChar",
                "param_3": "inputBuffer",
                "iVar1": "result",
                "uVar2": "bufferSize",
                "puVar3": "outputChar"
            },
            "calling": [
                "__sfputc_r"
            ],
            "called": [
                "_fflush_r",
                "__swsetup_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080069e4": {
            "entrypoint": "0x080069e4",
            "current_name": "update_stream_properties_080069e4",
            "code": "\nuint update_stream_properties_080069e4(undefined4 *input_stream,undefined4 *output_stream)\n\n{\n  int impure_ptr;\n  uint result;\n  ushort stream_properties;\n  \n  impure_ptr = _impure_ptr;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  if (output_stream == &__sf_fake_stdin) {\n    output_stream = *(undefined4 **)(impure_ptr + 4);\n  }\n  else if (output_stream == (undefined4 *)&__sf_fake_stdout) {\n    output_stream = *(undefined4 **)(impure_ptr + 8);\n  }\n  else if (output_stream == (undefined4 *)&__sf_fake_stderr) {\n    output_stream = *(undefined4 **)(impure_ptr + 0xc);\n  }\n  stream_properties = *(ushort *)(output_stream + 3);\n  result = (uint)stream_properties;\n  if (-1 < (int)(result << 0x1c)) {\n    if (-1 < (int)(result << 0x1b)) {\n      *input_stream = 9;\n      goto LAB_08006a14;\n    }\n    if ((int)(result << 0x1d) < 0) {\n      if ((undefined4 *)output_stream[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)output_stream[0xd] != output_stream + 0x11) {\n          _free_r(input_stream);\n        }\n        output_stream[0xd] = 0;\n      }\n      *(ushort *)(output_stream + 3) = *(ushort *)(output_stream + 3) & 0xffdb;\n      output_stream[1] = 0;\n      *output_stream = output_stream[4];\n    }\n    *(ushort *)(output_stream + 3) = *(ushort *)(output_stream + 3) | 8;\n  }\n  if ((output_stream[4] == 0) && ((*(ushort *)(output_stream + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(input_stream,output_stream);\n  }\n  stream_properties = *(ushort *)(output_stream + 3);\n  result = stream_properties & 1;\n  if ((stream_properties & 1) == 0) {\n    if (-1 < (int)((uint)stream_properties << 0x1e)) {\n      result = output_stream[5];\n    }\n    output_stream[2] = result;\n  }\n  else {\n    output_stream[2] = 0;\n    output_stream[6] = -output_stream[5];\n  }\n  if (output_stream[4] == 0) {\n    stream_properties = *(ushort *)(output_stream + 3);\n    result = (int)(short)stream_properties & 0x80;\n    if (result != 0) {\nLAB_08006a14:\n      *(ushort *)(output_stream + 3) = stream_properties | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080069e4": "update_stream_properties_080069e4",
                "param_1": "input_stream",
                "param_2": "output_stream",
                "iVar1": "impure_ptr",
                "uVar2": "result",
                "uVar3": "stream_properties"
            },
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r"
            ],
            "called": [
                "__smakebuf_r",
                "_free_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ac0": {
            "entrypoint": "0x08006ac0",
            "current_name": "trigger_critical_error_08006ac0",
            "code": "\n\n\nvoid trigger_critical_error_08006ac0(void)\n\n{\n  send_signal(6);\n                    \n  exit_program(1);\n}\n\n",
            "renaming": {
                "FUN_08006ac0": "trigger_critical_error_08006ac0",
                "raise": "send_signal",
                "_exit": "exit_program"
            },
            "calling": [
                "__assert_func",
                "__throw_bad_function_call"
            ],
            "called": [
                "_exit",
                "raise"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ad0": {
            "entrypoint": "0x08006ad0",
            "current_name": "process_data_08006ad0",
            "code": "\nundefined4 processData_08006ad0(uint *data,int *config)\n\n{\n  int tempVar1;\n  int *tempVar2;\n  uint configValue;\n  ushort configFlag;\n  int tempVar3;\n  code *functionPtr;\n  int tempVar4;\n  uint tempVar5;\n  bool conditionFlag;\n  \n  configFlag = *(ushort *)(config + 3);\n  configValue = (uint)configFlag;\n  if ((int)(configValue << 0x1c) < 0) {\n    tempVar1 = config[4];\n    if (tempVar1 != 0) {\n      tempVar3 = configValue << 0x1e;\n      conditionFlag = tempVar3 != 0;\n      if (conditionFlag) {\n        tempVar3 = 0;\n      }\n      tempVar4 = *config;\n      if (!conditionFlag) {\n        tempVar3 = config[5];\n      }\n      *config = tempVar1;\n      config[2] = tempVar3;\n      for (tempVar4 = tempVar4 - tempVar1; 0 < tempVar4; tempVar4 = tempVar4 - tempVar3) {\n        tempVar3 = (*(code *)config[10])(data,config[8],tempVar1,tempVar4);\n        if (tempVar3 < 1) {\n          configFlag = *(ushort *)(config + 3);\n          goto LAB_08006bc6;\n        }\n        tempVar1 = tempVar1 + tempVar3;\n      }\n    }\n  }\n  else if (((0 < config[1]) || (0 < config[0x10])) &&\n          (functionPtr = (code *)config[0xb], functionPtr != (code *)0x0)) {\n    tempVar5 = *data;\n    *data = 0;\n    if ((configFlag & 0x1000) == 0) {\n      tempVar1 = (*functionPtr)(data,config[8],configValue & 0x1000,1);\n      if ((tempVar1 == -1) && (configValue = *data, configValue != 0)) {\n        if ((configValue != 0x1d) && (configValue != 0x16)) {\n          *(ushort *)(config + 3) = *(ushort *)(config + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *data = tempVar5;\n        return 0;\n      }\n    }\n    else {\n      tempVar1 = config[0x15];\n    }\n    if (((int)((uint)*(ushort *)(config + 3) << 0x1d) < 0) &&\n       (tempVar1 = tempVar1 - config[1], config[0xd] != 0)) {\n      tempVar1 = tempVar1 - config[0x10];\n    }\n    tempVar1 = (*(code *)config[0xb])(data,config[8],tempVar1,0);\n    configFlag = *(ushort *)(config + 3);\n    if ((tempVar1 == -1) &&\n       ((0x1d < *data || (-1 < (int)((0x20400001U >> (*data & 0xff)) << 0x1f))))) {\nLAB_08006bc6:\n      *(ushort *)(config + 3) = configFlag | 0x40;\n      return 0xffffffff;\n    }\n    config[1] = 0;\n    *config = config[4];\n    if (((int)((uint)configFlag << 0x13) < 0) && ((tempVar1 != -1 || (*data == 0)))) {\n      config[0x15] = tempVar1;\n    }\n    tempVar2 = (int *)config[0xd];\n    *data = tempVar5;\n    if (tempVar2 != (int *)0x0) {\n      if (tempVar2 != config + 0x11) {\n        _free_r(data);\n      }\n      config[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006ad0": "process_data_08006ad0",
                "param_1": "data",
                "param_2": "config",
                "iVar1": "tempVar1",
                "piVar2": "tempVar2",
                "uVar3": "configValue",
                "uVar4": "configFlag",
                "iVar5": "tempVar3",
                "iVar7": "tempVar4",
                "pcVar6": "functionPtr",
                "uVar8": "tempVar5",
                "bVar9": "conditionFlag"
            },
            "calling": [
                "_fflush_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006be0": {
            "entrypoint": "0x08006be0",
            "current_name": "sanitize_streams_08006be0",
            "code": "\nundefined4 sanitizeStreams_08006be0(int streamPointer,undefined4 *stream,undefined4 param3,undefined4 param4)\n\n{\n  undefined4 result;\n  \n  if (stream[4] != 0) {\n    if ((streamPointer != 0) && (*(int *)(streamPointer + 0x18) == 0)) {\n      __sinit();\n    }\n    if (stream == &__sf_fake_stdin) {\n      stream = *(undefined4 **)(streamPointer + 4);\n    }\n    else if (stream == (undefined4 *)&__sf_fake_stdout) {\n      stream = *(undefined4 **)(streamPointer + 8);\n    }\n    else if (stream == (undefined4 *)&__sf_fake_stderr) {\n      stream = *(undefined4 **)(streamPointer + 0xc);\n    }\n    if (*(short *)(stream + 3) != 0) {\n      result = __sflush_r(streamPointer,stream,param3,param4);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006be0": "sanitize_streams_08006be0",
                "param_1": "streamPointer",
                "param_2": "stream",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "result"
            },
            "calling": [
                "__swbuf_r"
            ],
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c34": {
            "entrypoint": "0x08006c34",
            "current_name": "execute_fwalk_reent_08006c34",
            "code": "\nvoid execute_fwalk_reent_08006c34(undefined4 reent_ptr)\n\n{\n  call_fwalk_reent(reent_ptr,0x8006be1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006c34": "execute_fwalk_reent_08006c34",
                "param_1": "reent_ptr",
                "_fwalk_reent": "call_fwalk_reent"
            },
            "calling": [],
            "called": [
                "_fwalk_reent"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c40": {
            "entrypoint": "0x08006c40",
            "current_name": "initialize_data_structure_08006c40",
            "code": "\nvoid initializeDataStructure_08006c40(undefined4 *dataStructure,undefined2 value1,undefined2 value2)\n\n{\n  *dataStructure = 0;\n  dataStructure[1] = 0;\n  dataStructure[2] = 0;\n  *(undefined2 *)(dataStructure + 3) = value1;\n  dataStructure[25] = 0;\n  *(undefined2 *)((int)dataStructure + 0xe) = value2;\n  dataStructure[4] = 0;\n  dataStructure[5] = 0;\n  dataStructure[6] = 0;\n  memset(dataStructure + 0x17,0,8);\n  dataStructure[8] = dataStructure;\n  dataStructure[9] = 0x8006f39;\n  dataStructure[10] = 0x8006f5b;\n  dataStructure[11] = 0x8006f93;\n  dataStructure[12] = 0x8006fb7;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006c40": "initialize_data_structure_08006c40",
                "param_1": "dataStructure",
                "param_2": "value1",
                "param_3": "value2",
                "param_1[1]": "dataStructure[1]",
                "param_1[2]": "dataStructure[2]",
                "param_1[0x19]": "dataStructure[25]",
                "param_1[4]": "dataStructure[4]",
                "param_1[5]": "dataStructure[5]",
                "param_1[6]": "dataStructure[6]",
                "param_1[8]": "dataStructure[8]",
                "param_1[9]": "dataStructure[9]",
                "param_1[10]": "dataStructure[10]",
                "param_1[0xb]": "dataStructure[11]",
                "param_1[0xc]": "dataStructure[12]"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c88": {
            "entrypoint": "0x08006c88",
            "current_name": "allocate_memory_08006c88",
            "code": "\nundefined4 * allocateMemory_08006c88(undefined4 size,int count)\n\n{\n  undefined4 *allocatedMemory;\n  int totalSize;\n  \n  totalSize = (count + -1) * 0x68;\n  allocatedMemory = (undefined4 *)_malloc_r(size,totalSize + 0x74);\n  if (allocatedMemory != (undefined4 *)0x0) {\n    *allocatedMemory = 0;\n    allocatedMemory[1] = count;\n    allocatedMemory[2] = allocatedMemory + 3;\n    memset(allocatedMemory + 3,0,totalSize + 0x68);\n  }\n  return allocatedMemory;\n}\n\n",
            "renaming": {
                "FUN_08006c88": "allocate_memory_08006c88",
                "param_1": "size",
                "param_2": "count",
                "puVar1": "allocatedMemory",
                "iVar2": "totalSize"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "_malloc_r",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006cb4": {
            "entrypoint": "0x08006cb4",
            "current_name": "initialize_data_08006cb4",
            "code": "\nvoid initializeData_08006cb4(undefined1 *dataPointer)\n\n{\n  undefined4 resultVar;\n  undefined1 *auxPointer;\n  \n  if (*(int *)(dataPointer + 0x18) == 0) {\n    *(undefined4 *)(dataPointer + 0x48) = 0;\n    *(undefined4 *)(dataPointer + 0x4c) = 0;\n    *(undefined4 *)(dataPointer + 0x50) = 0;\n    auxPointer = &impure_data;\n    *(undefined4 *)(dataPointer + 0x28) = 0x8006c35;\n    if (dataPointer == &impure_data) {\n      auxPointer = (undefined1 *)0x1;\n    }\n    if (dataPointer == &impure_data) {\n      *(undefined1 **)(dataPointer + 0x18) = auxPointer;\n    }\n    resultVar = __sfp();\n    *(undefined4 *)(dataPointer + 4) = resultVar;\n    resultVar = __sfp(dataPointer);\n    *(undefined4 *)(dataPointer + 8) = resultVar;\n    resultVar = __sfp(dataPointer);\n    *(undefined4 *)(dataPointer + 0xc) = resultVar;\n    std_isra_0(*(undefined4 *)(dataPointer + 4),4,0);\n    std_isra_0(*(undefined4 *)(dataPointer + 8),9,1);\n    std_isra_0(*(undefined4 *)(dataPointer + 0xc),0x12,2);\n    *(undefined4 *)(dataPointer + 0x18) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006cb4": "initialize_data_08006cb4",
                "param_1": "dataPointer",
                "uVar1": "resultVar",
                "puVar2": "auxPointer"
            },
            "calling": [
                "_fflush_r",
                "__swbuf_r",
                "__sfp",
                "__swsetup_r",
                "iprintf",
                "_vfiprintf_r"
            ],
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d14": {
            "entrypoint": "0x08006d14",
            "current_name": "allocate_and_initialize_struct_08006d14",
            "code": "\nint * allocate_and_initialize_struct_08006d14(undefined4 *param)\n\n{\n  int *current_element;\n  int *current_struct;\n  int **struct_list;\n  \n  if (DAT_20000114 == 0) {\n    __sinit(&impure_data);\n  }\n  struct_list = (int **)&DAT_20000144;\n  do {\n    current_struct = struct_list[2];\n    current_element = struct_list[1];\n    while (current_element = (int *)((int)current_element + -1), -1 < (int)current_element) {\n      if (*(short *)(current_struct + 3) == 0) {\n        *(undefined2 *)((int)current_struct + 0xe) = 0xffff;\n        current_struct[0x19] = 0;\n        *(undefined2 *)(current_struct + 3) = 1;\n        *current_struct = 0;\n        current_struct[2] = 0;\n        current_struct[1] = 0;\n        current_struct[4] = 0;\n        current_struct[5] = 0;\n        current_struct[6] = 0;\n        memset(current_struct + 0x17,0,8);\n        current_struct[0xd] = 0;\n        current_struct[0xe] = 0;\n        current_struct[0x12] = 0;\n        current_struct[0x13] = 0;\n        return current_struct;\n      }\n      current_struct = current_struct + 0x1a;\n    }\n    if (*struct_list == (int *)0x0) {\n      current_element = (int *)__sfmoreglue(param,4);\n      *struct_list = current_element;\n      if (current_element == (int *)0x0) {\n        *param = 0xc;\n        return (int *)0x0;\n      }\n    }\n    struct_list = (int **)*struct_list;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08006d14": "allocate_and_initialize_struct_08006d14",
                "param_1": "param",
                "piVar1": "current_element",
                "piVar2": "current_struct",
                "ppiVar3": "struct_list"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset",
                "__sfmoreglue",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d8c": {
            "entrypoint": "0x08006d8c",
            "current_name": "find_and_execute_callback_08006d8c",
            "code": "\nuint find_and_execute_callback_08006d8c(int input,code *callback,undefined4 param1,undefined4 param2)\n\n{\n  uint result;\n  int increment;\n  int *current_element;\n  int var1;\n  uint combined_results;\n  int var2;\n  \n  combined_results = 0;\n  for (current_element = (int *)(input + 0x48); current_element != (int *)0x0; current_element = (int *)*current_element) {\n    var1 = current_element[2];\n    var2 = current_element[1];\n    while (var2 = var2 + -1, -1 < var2) {\n      if ((1 < *(ushort *)(var1 + 0xc)) && (increment = *(short *)(var1 + 0xe) + 1, increment != 0)) {\n        result = (*callback)(input,var1,param1,increment,param2);\n        combined_results = combined_results | result;\n      }\n      var1 = var1 + 0x68;\n    }\n  }\n  return combined_results;\n}\n\n",
            "renaming": {
                "FUN_08006d8c": "find_and_execute_callback_08006d8c",
                "param_1": "input",
                "param_2": "callback",
                "param_3": "param1",
                "param_4": "param2",
                "uVar1": "result",
                "iVar2": "increment",
                "piVar3": "current_element",
                "iVar4": "var1",
                "uVar5": "combined_results",
                "iVar6": "var2"
            },
            "calling": [
                "_cleanup_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006dc8": {
            "entrypoint": "0x08006dc8",
            "current_name": "get_file_permission_08006dc8",
            "code": "\nundefined4 getFilePermission_08006dc8(undefined4 fileDescriptor,int fileInfo,undefined4 *permissionFlag,uint *isExecutable)\n\n{\n  int fileStatus;\n  undefined4 permission;\n  undefined tempArray [4];\n  uint fileMode;\n  \n  if ((*(short *)(fileInfo + 0xe) < 0) ||\n     (fileStatus = _fstat_r(fileDescriptor,(int)*(short *)(fileInfo + 0xe),tempArray), fileStatus < 0)) {\n    *isExecutable = 0;\n    if ((int)((uint)*(ushort *)(fileInfo + 0xc) << 0x18) < 0) {\n      permission = 0x40;\n      goto LAB_08006e08;\n    }\n  }\n  else {\n    *isExecutable = (uint)((fileMode & 0xf000) == 0x2000);\n  }\n  permission = 0x400;\nLAB_08006e08:\n  *permissionFlag = permission;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006dc8": "get_file_permission_08006dc8",
                "param_1": "fileDescriptor",
                "param_2": "fileInfo",
                "param_3": "permissionFlag",
                "param_4": "isExecutable",
                "iVar1": "fileStatus",
                "uVar2": "permission",
                "auStack_4c": "tempArray",
                "local_48": "fileMode"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e10": {
            "entrypoint": "0x08006e10",
            "current_name": "process_data_08006e10",
            "code": "\nvoid processData_08006e10(int data,int *inputArray)\n\n{\n  ushort result;\n  int allocatedMemory;\n  int dataLength;\n  int *tempArray;\n  \n  if (-1 < (int)((uint)*(ushort *)(inputArray + 3) << 0x1e)) {\n    dataLength = data;\n    tempArray = inputArray;\n    result = __swhatbuf_r(data,inputArray,&dataLength,&tempArray);\n    allocatedMemory = _malloc_r(data,dataLength);\n    if (allocatedMemory != 0) {\n      *(undefined4 *)(data + 0x28) = 0x8006c35;\n      *inputArray = allocatedMemory;\n      *(ushort *)(inputArray + 3) = *(ushort *)(inputArray + 3) | 0x80;\n      inputArray[4] = allocatedMemory;\n      inputArray[5] = dataLength;\n      if ((tempArray != (int *)0x0) &&\n         (allocatedMemory = _isatty_r(data,(int)*(short *)((int)inputArray + 0xe)), allocatedMemory != 0)) {\n        *(ushort *)(inputArray + 3) = *(ushort *)(inputArray + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(inputArray + 3) = result | *(ushort *)(inputArray + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(inputArray + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(inputArray + 3) = *(ushort *)(inputArray + 3) & 0xfffc | 2;\n  }\n  *inputArray = (int)inputArray + 0x47;\n  inputArray[4] = (int)inputArray + 0x47;\n  inputArray[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006e10": "process_data_08006e10",
                "param_1": "data",
                "param_2": "inputArray",
                "uVar1": "result",
                "iVar2": "allocatedMemory",
                "local_18": "dataLength",
                "local_14": "tempArray"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "_malloc_r",
                "_isatty_r",
                "__swhatbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e90": {
            "entrypoint": "0x08006e90",
            "current_name": "find_byte_in_memory_08006e90",
            "code": "\nvoid * find_byte_in_memory_08006e90(void *memory,int byte_to_find,size_t memory_size)\n\n{\n  byte *current_byte;\n  byte *next_byte;\n  \n  current_byte = (byte *)memory;\n  do {\n    next_byte = current_byte;\n    if (next_byte == (byte *)(memory_size + (int)memory)) {\n      return (void *)0x0;\n    }\n    current_byte = next_byte + 1;\n  } while ((uint)*next_byte != (byte_to_find & 0xffU));\n  return next_byte;\n}\n\n",
            "renaming": {
                "FUN_08006e90": "find_byte_in_memory_08006e90",
                "__s": "memory",
                "__c": "byte_to_find",
                "__n": "memory_size",
                "pbVar1": "current_byte",
                "pbVar2": "next_byte"
            },
            "calling": [
                "_vfiprintf_r",
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006eac": {
            "entrypoint": "0x08006eac",
            "current_name": "FUNC_08006eac",
            "code": "\nvoid FUNC_08006eac(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006eac": "FUNC_08006eac"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08006eae": {
            "entrypoint": "0x08006eae",
            "current_name": "FUNC_08006eae",
            "code": "\nvoid FUNC_08006eae(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006eae": "FUNC_08006eae"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08006eb0": {
            "entrypoint": "0x08006eb0",
            "current_name": "execute_function_08006eb0",
            "code": "\nundefined4 executeFunction_08006eb0(undefined4 *result,uint index,undefined4 param3,undefined4 param4)\n\n{\n  __pid_t pid;\n  undefined4 returnVal;\n  int var3;\n  code *functionPtr;\n  \n  if (0x1f < index) {\n    *result = 0x16;\n    return 0xffffffff;\n  }\n  var3 = result[0x11];\n  if ((var3 != 0) && (functionPtr = *(code **)(var3 + index * 4), functionPtr != (code *)0x0)) {\n    if (functionPtr != (code *)0x1) {\n      if (functionPtr == (code *)0xffffffff) {\n        *result = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(var3 + index * 4) = 0;\n      (*functionPtr)(index);\n    }\n    return 0;\n  }\n  pid = _getpid_r();\n  returnVal = _kill_r(result,pid,index,param4);\n  return returnVal;\n}\n\n",
            "renaming": {
                "FUN_08006eb0": "execute_function_08006eb0",
                "param_1": "result",
                "param_2": "index",
                "param_3": "param3",
                "param_4": "param4",
                "_Var1": "pid",
                "uVar2": "returnVal",
                "iVar3": "var3",
                "pcVar4": "functionPtr"
            },
            "calling": [
                "raise"
            ],
            "called": [
                "_kill_r",
                "_getpid_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f00": {
            "entrypoint": "0x08006f00",
            "current_name": "execute_signal_handler_08006f00",
            "code": "\nint executeSignalHandler_08006f00(int signalNumber)\n\n{\n  int returnValue;\n  \n  returnValue = _raise_r(_impure_ptr,signalNumber);\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08006f00": "execute_signal_handler_08006f00",
                "__sig": "signalNumber",
                "iVar1": "returnValue"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "_raise_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f10": {
            "entrypoint": "0x08006f10",
            "current_name": "kill_process_with_signal_08006f10",
            "code": "\nvoid kill_process_with_signal_08006f10(int *error_code,__pid_t process_id,int signal)\n\n{\n  int result;\n  \n  errno = 0;\n  result = _kill(process_id,signal);\n  if ((result == -1) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f10": "kill_process_with_signal_08006f10",
                "param_1": "error_code",
                "param_2": "process_id",
                "param_3": "signal",
                "iVar1": "result"
            },
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_kill"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f34": {
            "entrypoint": "0x08006f34",
            "current_name": "FUN_08006f34",
            "code": "\n\n\n__pid_t _getpid(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {},
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_getpid"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f38": {
            "entrypoint": "0x08006f38",
            "current_name": "update_data_08006f38",
            "code": "\nvoid updateData_08006f38(undefined4 inputBuffer,int dataStruct)\n\n{\n  int readResult;\n  uint newData;\n  bool isSuccess;\n  \n  readResult = _read_r(inputBuffer,(int)*(short *)(dataStruct + 0xe));\n  isSuccess = -1 < readResult;\n  if (isSuccess) {\n    newData = *(int *)(dataStruct + 0x54) + readResult;\n  }\n  else {\n    newData = *(ushort *)(dataStruct + 0xc) & 0xffffefff;\n  }\n  if (isSuccess) {\n    *(uint *)(dataStruct + 0x54) = newData;\n  }\n  if (!isSuccess) {\n    *(short *)(dataStruct + 0xc) = (short)newData;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f38": "update_data_08006f38",
                "param_1": "inputBuffer",
                "param_2": "dataStruct",
                "iVar1": "readResult",
                "uVar2": "newData",
                "bVar3": "isSuccess"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f5a": {
            "entrypoint": "0x08006f5a",
            "current_name": "write_data_with_seek_08006f5a",
            "code": "\nvoid writeDataWithSeek_08006f5a(undefined4 fileDescriptor,int buffer,undefined4 data,undefined4 size)\n\n{\n  if ((int)((uint)*(unsignedShort *)(buffer + 0xc) << 0x17) < 0) {\n    _lseek_r(fileDescriptor,(int)*(short *)(buffer + 0xe),0,2);\n  }\n  *(unsignedShort *)(buffer + 0xc) = *(unsignedShort *)(buffer + 0xc) & 0xefff;\n  _write_r(fileDescriptor,(int)*(short *)(buffer + 0xe),data,size);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f5a": "write_data_with_seek_08006f5a",
                "param_1": "fileDescriptor",
                "param_2": "buffer",
                "param_3": "data",
                "param_4": "size",
                "ushort": "unsignedShort"
            },
            "calling": [],
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f92": {
            "entrypoint": "0x08006f92",
            "current_name": "update_seek_position_08006f92",
            "code": "\nvoid updateSeekPosition_08006f92(undefined4 fileDescriptor,int dataStruct)\n\n{\n  int seekResult;\n  ushort modifiedFlag;\n  bool isError;\n  \n  seekResult = _lseek_r(fileDescriptor,(int)*(short *)(dataStruct + 0xe));\n  isError = seekResult == -1;\n  if (isError) {\n    modifiedFlag = *(ushort *)(dataStruct + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(dataStruct + 0x54) = seekResult;\n    modifiedFlag = *(ushort *)(dataStruct + 0xc) | 0x1000;\n  }\n  if (isError) {\n    *(ushort *)(dataStruct + 0xc) = modifiedFlag;\n  }\n  if (!isError) {\n    *(ushort *)(dataStruct + 0xc) = modifiedFlag;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f92": "update_seek_position_08006f92",
                "param_1": "fileDescriptor",
                "param_2": "dataStruct",
                "iVar1": "seekResult",
                "uVar2": "modifiedFlag",
                "bVar3": "isError"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006fb6": {
            "entrypoint": "0x08006fb6",
            "current_name": "close_file_descriptor_08006fb6",
            "code": "\nvoid closeFileDescriptor_08006fb6(undefined4 fileDescriptor,int memoryAddress)\n\n{\n  _close_r(fileDescriptor,(int)*(short *)(memoryAddress + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006fb6": "close_file_descriptor_08006fb6",
                "param_1": "fileDescriptor",
                "param_2": "memoryAddress"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006fc0": {
            "entrypoint": "0x08006fc0",
            "current_name": "write_with_error_code_08006fc0",
            "code": "\nvoid writeWithErrorCode_08006fc0(int *errorPointer,int fileDescriptor,char *data,int length)\n\n{\n  int writeResult;\n  \n  errno = 0;\n  writeResult = _write(fileDescriptor,data,length);\n  if ((writeResult == -1) && (errno != 0)) {\n    *errorPointer = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006fc0": "write_with_error_code_08006fc0",
                "param_1": "errorPointer",
                "param_2": "fileDescriptor",
                "param_3": "data",
                "param_4": "length",
                "iVar1": "writeResult"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006fe4": {
            "entrypoint": "0x08006fe4",
            "current_name": "close_file_08006fe4",
            "code": "\nvoid closeFile_08006fe4(int *errorCode,int fileDescriptor)\n\n{\n  int result;\n  \n  errorNumber = 0;\n  result = _close(fileDescriptor);\n  if ((result == -1) && (errorNumber != 0)) {\n    *errorCode = errorNumber;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006fe4": "close_file_08006fe4",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "errno": "errorNumber",
                "iVar1": "result"
            },
            "calling": [
                "__sclose"
            ],
            "called": [
                "_close"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007004": {
            "entrypoint": "0x08007004",
            "current_name": "get_file_info_08007004",
            "code": "\nvoid get_file_info_08007004(int *error_code,int file_descriptor,stat *file_stat)\n\n{\n  int result;\n  \n  error_number = 0;\n  result = _fstat(file_descriptor,file_stat);\n  if ((result == -1) && (error_number != 0)) {\n    *error_code = error_number;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007004": "get_file_info_08007004",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "file_stat",
                "errno": "error_number",
                "iVar1": "result"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007028": {
            "entrypoint": "0x08007028",
            "current_name": "check_if_terminal_is_interactive_08007028",
            "code": "\nvoid checkIfTerminalIsInteractive_08007028(int *errorCode,int fileDescriptor)\n\n{\n  int isTerminal;\n  \n  errno = 0;\n  isTerminal = _isatty(fileDescriptor);\n  if ((isTerminal == -1) && (errno != 0)) {\n    *errorCode = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007028": "check_if_terminal_is_interactive_08007028",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "iVar1": "isTerminal"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007048": {
            "entrypoint": "0x08007048",
            "current_name": "set_file_pointer_08007048",
            "code": "\nvoid setFilePointer_08007048(int *errorFlag,int fileDescriptor,__off_t offset,int origin)\n\n{\n  __off_t newFilePointer;\n  \n  errno = 0;\n  newFilePointer = _lseek(fileDescriptor,offset,origin);\n  if ((newFilePointer == -1) && (errno != 0)) {\n    *errorFlag = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007048": "set_file_pointer_08007048",
                "param_1": "errorFlag",
                "param_2": "fileDescriptor",
                "param_3": "offset",
                "param_4": "origin",
                "_Var1": "newFilePointer"
            },
            "calling": [
                "__swrite",
                "__sseek"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800706c": {
            "entrypoint": "0x0800706c",
            "current_name": "read_data_0800706c",
            "code": "\nvoid readData_0800706c(int *error,int fileDescriptor,char *buffer,int bufferSize)\n\n{\n  int readResult;\n  \n  errno = 0;\n  readResult = _read(fileDescriptor,buffer,bufferSize);\n  if ((readResult == -1) && (errno != 0)) {\n    *error = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800706c": "read_data_0800706c",
                "param_1": "error",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "bufferSize",
                "iVar1": "readResult"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007090": {
            "entrypoint": "0x08007090",
            "current_name": "abort_function_08007090",
            "code": "\n\n/* std::__throw_bad_function_call() */\n\nvoid std::abort_function_08007090(void)\n\n{\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_08007090": "abort_function_08007090"
            },
            "calling": [
                "operator()"
            ],
            "called": [
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007098": {
            "entrypoint": "0x08007098",
            "current_name": "initialize_monetary_and_numeric_facets_08007098",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeMonetaryAndNumericFacets_08007098(void)\n\n{\n  if (-1 < moneypunct<char,false>::id << 0x1f) {\n    moneypunct<char,false>::id = 1;\n  }\n  if (-1 < moneypunct<char,true>::id << 0x1f) {\n    moneypunct<char,true>::id = 1;\n  }\n  if (-1 < money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < numpunct<char>::id << 0x1f) {\n    numpunct<char>::id = 1;\n  }\n  if (-1 < num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __timepunct<char>::id << 0x1f) {\n    __timepunct<char>::id = 1;\n  }\n  if (-1 < time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < messages<char>::id << 0x1f) {\n    messages<char>::id = 1;\n  }\n  if (-1 < collate<char>::id << 0x1f) {\n    collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007098": "initialize_monetary_and_numeric_facets_08007098"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800715c": {
            "entrypoint": "0x0800715c",
            "current_name": "update_ctype_name_ids_0800715c",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::updateCtypeNameIds_0800715c(void)\n\n{\n  if (-1 < moneypunct<wchar_t,false>::id << 0x1f) {\n    moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < moneypunct<wchar_t,true>::id << 0x1f) {\n    moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < numpunct<wchar_t>::id << 0x1f) {\n    numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __timepunct<wchar_t>::id << 0x1f) {\n    __timepunct<wchar_t>::id = 1;\n  }\n  if (-1 < time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < messages<wchar_t>::id << 0x1f) {\n    messages<wchar_t>::id = 1;\n  }\n  if (-1 < collate<wchar_t>::id << 0x1f) {\n    collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800715c": "update_ctype_name_ids_0800715c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007220": {
            "entrypoint": "0x08007220",
            "current_name": "initialize_locale_ids_08007220",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeLocaleIds_08007220(void)\n\n{\n  if (-1 < __cxx11::moneypunct<wchar_t,false>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<wchar_t,true>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<wchar_t>::id << 0x1f) {\n    __cxx11::numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<wchar_t>::id << 0x1f) {\n    __cxx11::messages<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::collate<wchar_t>::id << 0x1f) {\n    __cxx11::collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007220": "initialize_locale_ids_08007220"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072a4": {
            "entrypoint": "0x080072a4",
            "current_name": "initialize_locale_information_080072a4",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeLocaleInformation_080072a4(void)\n\n{\n  if (-1 < __cxx11::moneypunct<char,false>::id << 0x1f) {\n    __cxx11::moneypunct<char,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<char,true>::id << 0x1f) {\n    __cxx11::moneypunct<char,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<char>::id << 0x1f) {\n    __cxx11::numpunct<char>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f\n     ) {\n    __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<char>::id << 0x1f) {\n    __cxx11::messages<char>::id = 1;\n  }\n  if (-1 < __cxx11::collate<char>::id << 0x1f) {\n    __cxx11::collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080072a4": "initialize_locale_information_080072a4"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007328": {
            "entrypoint": "0x08007328",
            "current_name": "FUNC_08007328",
            "code": "\nvoid FUNC_08007328(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007328": "FUNC_08007328"
            },
            "calling": [
                "__libc_init_array",
                "__do_global_dtors_aux"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08007334": {
            "entrypoint": "0x08007334",
            "current_name": "FUNC_08007334",
            "code": "\nvoid FUNC_08007334(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007334": "FUNC_08007334"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 195389,
    "layers": [
        [
            "FUN_0800010c",
            "FUN_08000178",
            "FUN_08000188",
            "FUN_08000190",
            "FUN_08000194",
            "FUN_0800040c",
            "FUN_0800042c",
            "FUN_08000450",
            "FUN_0800048c",
            "FUN_0800049c",
            "FUN_080006d4",
            "FUN_080008ba",
            "FUN_0800091c",
            "FUN_08000924",
            "FUN_0800092c",
            "FUN_080009a8",
            "FUN_080009b8",
            "FUN_080009c8",
            "FUN_080009dc",
            "FUN_080009f0",
            "FUN_08000a04",
            "FUN_08000a18",
            "FUN_08000a2c",
            "FUN_08000a58",
            "FUN_08000aa8",
            "FUN_08000ae8",
            "FUN_08000aec",
            "FUN_08000b08",
            "FUN_08000bcc",
            "FUN_08000cbc",
            "FUN_08000cd0",
            "FUN_08001294",
            "FUN_080012a2",
            "FUN_080012c0",
            "FUN_080012e8",
            "FUN_08001310",
            "FUN_0800134e",
            "FUN_0800135a",
            "FUN_08001366",
            "FUN_0800138e",
            "FUN_080013a4",
            "FUN_080014ba",
            "FUN_08001510",
            "FUN_08001550",
            "FUN_0800157c",
            "FUN_080015b2",
            "FUN_080015f8",
            "FUN_080016b4",
            "FUN_08001814",
            "FUN_080018f8",
            "FUN_08001918",
            "FUN_08001960",
            "FUN_080019f6",
            "FUN_08001a44",
            "FUN_08001a66",
            "FUN_08001ab0",
            "FUN_08001b18",
            "FUN_08001b48",
            "FUN_08001be8",
            "FUN_08001c30",
            "FUN_08001c32",
            "FUN_08001c3c",
            "FUN_08001c88",
            "FUN_08001cac",
            "FUN_08001cc4",
            "FUN_08001cd0",
            "FUN_08001e40",
            "FUN_08001e48",
            "FUN_08001f80",
            "FUN_08001f84",
            "FUN_08002004",
            "FUN_080020f0",
            "FUN_0800213c",
            "FUN_0800224c",
            "FUN_08002348",
            "FUN_08002384",
            "FUN_08002470",
            "FUN_08002494",
            "FUN_080024f8",
            "FUN_08002514",
            "FUN_08002540",
            "FUN_08002560",
            "FUN_08002582",
            "FUN_0800258c",
            "FUN_08002624",
            "FUN_08002810",
            "FUN_0800281e",
            "FUN_0800282c",
            "FUN_08002848",
            "FUN_080028d2",
            "FUN_080028de",
            "FUN_08002ab8",
            "FUN_08002ad8",
            "FUN_08002af8",
            "FUN_08002b84",
            "FUN_08002c10",
            "FUN_08002c54",
            "FUN_08002ca6",
            "FUN_08002cf2",
            "FUN_08002d1c",
            "FUN_08002db2",
            "FUN_08002efc",
            "FUN_08002f9c",
            "FUN_0800306c",
            "FUN_0800316c",
            "FUN_080032b4",
            "FUN_080033b8",
            "FUN_08003520",
            "FUN_080035fc",
            "FUN_0800365c",
            "FUN_08003688",
            "FUN_08003a68",
            "FUN_08003ad4",
            "FUN_08003c44",
            "FUN_08003c50",
            "FUN_08003c70",
            "FUN_08003c90",
            "FUN_08003da4",
            "FUN_08003ea0",
            "FUN_08003ed8",
            "FUN_08003f18",
            "FUN_08004092",
            "FUN_080040b0",
            "FUN_08004110",
            "FUN_0800412c",
            "FUN_0800417c",
            "FUN_08004198",
            "FUN_08004204",
            "FUN_080043b4",
            "FUN_0800441a",
            "FUN_08004478",
            "FUN_0800455a",
            "FUN_080045a2",
            "FUN_080045fe",
            "FUN_08004618",
            "FUN_080046b8",
            "FUN_080047d8",
            "FUN_080047e8",
            "FUN_080047f4",
            "FUN_0800480a",
            "FUN_08004828",
            "FUN_08004848",
            "FUN_08004884",
            "FUN_0800492c",
            "FUN_08004948",
            "FUN_08004974",
            "FUN_080049f0",
            "FUN_08004a4c",
            "FUN_08004b34",
            "FUN_08004b3c",
            "FUN_08004b94",
            "FUN_08004b9e",
            "FUN_08004bb0",
            "FUN_08004c30",
            "FUN_08004c48",
            "FUN_08004c52",
            "FUN_08004c5e",
            "FUN_08004c78",
            "FUN_08004c8a",
            "FUN_08004ca2",
            "FUN_08004cb2",
            "FUN_08004cce",
            "FUN_08004ce2",
            "FUN_08004d06",
            "FUN_08004d18",
            "FUN_08004d30",
            "FUN_08004d40",
            "FUN_08004d44",
            "FUN_08004d90",
            "FUN_08004df4",
            "FUN_08004df8",
            "FUN_08004e12",
            "FUN_08004e20",
            "FUN_08004e34",
            "FUN_08004e48",
            "FUN_08004e5c",
            "FUN_08004e70",
            "FUN_08004e74",
            "FUN_08004ec4",
            "FUN_08004ef4",
            "FUN_08004f0c",
            "FUN_08004f1c",
            "FUN_08004f2c",
            "FUN_08004f3c",
            "FUN_08004f4c",
            "FUN_08005384",
            "FUN_080053d4",
            "FUN_0800548c",
            "FUN_080054b0",
            "FUN_080054d4",
            "FUN_08005510",
            "FUN_08005568",
            "FUN_080055bc",
            "FUN_080055e0",
            "FUN_08005604",
            "FUN_08005650",
            "FUN_08005690",
            "FUN_080056a8",
            "FUN_080056c0",
            "FUN_080056d8",
            "FUN_08005714",
            "FUN_0800571a",
            "FUN_08005724",
            "FUN_08005728",
            "FUN_0800572c",
            "FUN_08005730",
            "FUN_0800573c",
            "FUN_08005740",
            "FUN_08005750",
            "FUN_08005754",
            "FUN_080057b4",
            "FUN_08005848",
            "FUN_08005890",
            "FUN_080058e0",
            "FUN_080058ea",
            "FUN_0800591e",
            "FUN_08005932",
            "FUN_0800594e",
            "FUN_08005976",
            "FUN_0800598a",
            "FUN_080059c8",
            "FUN_08005a44",
            "FUN_08005a68",
            "FUN_08005b24",
            "FUN_08005b3c",
            "FUN_08005b54",
            "FUN_08005bb0",
            "FUN_08005bd4",
            "FUN_08005be2",
            "FUN_08005c1c",
            "FUN_08005c38",
            "FUN_08005c64",
            "FUN_08005c72",
            "FUN_08005c96",
            "FUN_08005cb6",
            "FUN_08005cc0",
            "FUN_08005cd4",
            "FUN_08005ce8",
            "FUN_08005d42",
            "FUN_08005d82",
            "FUN_08005d8a",
            "FUN_08005da0",
            "FUN_08005da8",
            "FUN_08005f2c",
            "FUN_08005f40",
            "FUN_08005f5e",
            "FUN_08005f6c",
            "FUN_08005f8c",
            "FUN_08005fa0",
            "FUN_08005fc8",
            "FUN_08006074",
            "FUN_0800607e",
            "FUN_08006088",
            "FUN_08006092",
            "FUN_0800609c",
            "FUN_080060a6",
            "FUN_080060bc",
            "FUN_080060d4",
            "FUN_080060e4",
            "FUN_08006104",
            "FUN_08006112",
            "FUN_0800611c",
            "FUN_08006158",
            "FUN_08006174",
            "FUN_08006198",
            "FUN_080061e0",
            "FUN_080061f0",
            "FUN_08006288",
            "FUN_08006344",
            "FUN_08006370",
            "FUN_08006394",
            "FUN_080065c0",
            "FUN_080066b0",
            "FUN_080068f0",
            "FUN_08006920",
            "FUN_08006940",
            "FUN_080069e4",
            "FUN_08006ac0",
            "FUN_08006ad0",
            "FUN_08006be0",
            "FUN_08006c34",
            "FUN_08006c40",
            "FUN_08006c88",
            "FUN_08006cb4",
            "FUN_08006d14",
            "FUN_08006d8c",
            "FUN_08006dc8",
            "FUN_08006e10",
            "FUN_08006e90",
            "FUN_08006eb0",
            "FUN_08006f00",
            "FUN_08006f10",
            "FUN_08006f38",
            "FUN_08006f5a",
            "FUN_08006f92",
            "FUN_08006fb6",
            "FUN_08006fc0",
            "FUN_08006fe4",
            "FUN_08007004",
            "FUN_08007028",
            "FUN_08007048",
            "FUN_0800706c",
            "FUN_08007090",
            "FUN_08007098",
            "FUN_0800715c",
            "FUN_08007220",
            "FUN_080072a4"
        ],
        [
            "FUN_080004f8",
            "FUN_0800074c"
        ]
    ],
    "locked_functions": []
}