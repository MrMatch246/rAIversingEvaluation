{
    "functions": {
        "FUN_08007246": {
            "renaming": {
                "FUN_08007246": "handleSystickInterrupt_08007246",
                "noOsSystickHandler": "handleNoOsSystick"
            },
            "code": "void handleSystickInterrupt_08007246(void)\n{\n  HAL_IncTick();\n  HAL_SYSTICK_IRQHandler();\n  handleNoOsSystick();\n  return;\n}",
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "HAL_IncTick",
                "noOsSystickHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007246",
            "calling": [],
            "imported": false,
            "current_name": "handleSystickInterrupt_08007246"
        },
        "FUN_0800a042": {
            "renaming": {
                "FUN_0800a042": "write_data_to_file_0800a042",
                "param_1": "file_descriptor",
                "param_2": "data_offset",
                "param_3": "data",
                "param_4": "data_size",
                "is_negative": "is_data_offset_negative"
            },
            "code": "void write_data_to_file_0800a042(int file_descriptor, int data_offset, void* data, int data_size) {\n  int is_negative = (int)((uint)*(ushort *)(data_offset + 0xc) << 0x17) < 0;\n  if (is_negative) {\n    _lseek_r(file_descriptor,(int)*(short *)(data_offset + 0xe),0,2);\n  }\n  *(ushort *)(data_offset + 0xc) = *(ushort *)(data_offset + 0xc) & 0xefff;\n  _write_r(file_descriptor,(int)*(short *)(data_offset + 0xe),data,data_size);\n  return;\n}",
            "called": [
                "_lseek_r",
                "_write_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a042",
            "calling": [],
            "imported": false,
            "current_name": "write_data_to_file_0800a042"
        },
        "FUN_08008e4e": {
            "renaming": {
                "FUN_08008e4e": "printBuffer_08008e4e",
                "this": "print_instance",
                "buffer": "buffer",
                "size": "size",
                "pPVar1": "current_print_instance",
                "sVar2": "bytes_printed"
            },
            "code": "size_t __thiscall printBuffer_08008e4e(Print *print_instance, uint8_t *buffer, size_t size) {\n  Print *current_print_instance;\n  size_t bytes_printed = 0;\n  current_print_instance = print_instance;\n  while( true ) {\n    if (size == 0) {\n      return bytes_printed;\n    }\n    current_print_instance = (Print *)(**print_instance->_vptr_Print)(current_print_instance,(uint)*buffer);\n    if (current_print_instance == (Print *)0x0) break;\n    bytes_printed = bytes_printed + 1;\n    buffer = buffer + 1;\n    size = size - 1;\n  }\n  return bytes_printed;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e4e",
            "calling": [],
            "imported": false,
            "current_name": "printBuffer_08008e4e"
        },
        "FUN_08008694": {
            "renaming": {
                "FUN_08008694": "transmit_data_08008694",
                "obj": "serial_obj",
                "callback": "callback_fn",
                "bVar1": "index",
                "PTR_tx_callback_080086dc": "tx_callback",
                "PTR_tx_callback_obj_080086e0": "tx_callback_obj",
                "PTR_uart_handlers_080086e4": "uart_handlers"
            },
            "code": "void transmit_data_08008694(serial_t *serial_obj, _func_int_serial_t_ptr *callback_fn) {\n  if (serial_obj != NULL) {\n    uint8_t index = serial_obj->index;\n    _func_int_serial_t_ptr **PTR_tx_callback_080086dc = (_func_int_serial_t_ptr **)(PTR_PTR_tx_callback_080086dc_080086dc + index * 4);\n    *PTR_tx_callback_080086dc = callback_fn;\n    serial_t **PTR_PTR_tx_callback_080086dc_obj_080086e0 = (serial_t **)(PTR_PTR_PTR_tx_callback_080086dc_obj_080086e0_080086e0 + index * 4);\n    *PTR_PTR_tx_callback_080086dc_obj_080086e0 = serial_obj;\n    HAL_NVIC_SetPriority(serial_obj->irq, 0, 2);\n    HAL_NVIC_EnableIRQ(serial_obj->irq);\n    UART_HandleTypeDef **PTR_uart_handlers_080086e4 = (UART_HandleTypeDef **)(PTR_PTR_uart_handlers_080086e4_080086e4 + index * 4);\n    HAL_UART_Transmit_IT(*PTR_uart_handlers_080086e4, serial_obj->tx_buff + serial_obj->tx_tail, 1);\n  }\n}",
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008694",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "transmit_data_08008694"
        },
        "FUN_08002ce0": {
            "renaming": {
                "FUN_08002ce0": "createFirmataParser_08002ce0",
                "this": "parser",
                "this_00": "parser",
                "marshaller": "marshaller",
                "parserBuffer": "parserBuffer",
                "firmwareVersionCount": "firmwareVersionCount",
                "firmwareVersionVector": "firmwareVersionVector",
                "blinkVersionDisabled": "blinkVersionDisabled",
                "attach": "attach",
                "0xe0": "0xe0",
                "0x90": "0x90",
                "0xc0": "0xc0",
                "0xd0": "0xd0",
                "0xf4": "0xf4",
                "0xf5": "0xf5",
                "'q'": "'q'",
                "0xf0": "0xf0",
                "'y'": "'y'",
                "0xf9": "0xf9",
                "0xff": "0xff",
                "DAT_08002d90": "handleE0",
                "DAT_08002d94": "handle90",
                "DAT_08002d98": "handleC0",
                "DAT_08002d9c": "handleD0",
                "DAT_08002da0": "handleF4",
                "DAT_08002da4": "handleF5",
                "DAT_08002da8": "handleQ",
                "DAT_08002dac": "handleF0",
                "DAT_08002db0": "handleY",
                "DAT_08002db4": "handleF9",
                "DAT_08002db8": "handleFF"
            },
            "code": "FirmataParser* createFirmataParser_08002ce0(FirmataParser* parser) {\n  FirmataMarshaller marshaller;\n  FirmataMarshaller::FirmataMarshaller(&marshaller);\n  FirmataParser::FirmataParser(parser, parserBuffer, 0x40);\n  parser->firmwareVersionCount = 0;\n  parser->firmwareVersionVector = nullptr;\n  parser->blinkVersionDisabled = false;\n  FirmataParser::attach(parser, 0xe0, DAT_08002d90, nullptr);\n  FirmataParser::attach(parser, 0x90, DAT_08002d94, nullptr);\n  FirmataParser::attach(parser, 0xc0, DAT_08002d98, nullptr);\n  FirmataParser::attach(parser, 0xd0, DAT_08002d9c, nullptr);\n  FirmataParser::attach(parser, 0xf4, DAT_08002da0, nullptr);\n  FirmataParser::attach(parser, 0xf5, DAT_08002da4, nullptr);\n  FirmataParser::attach(parser, 'q', DAT_08002da8, nullptr);\n  FirmataParser::attach(parser, 0xf0, DAT_08002dac, nullptr);\n  FirmataParser::attach(parser, 'y', DAT_08002db0, parser);\n  FirmataParser::attach(parser, 0xf9, DAT_08002db4, parser);\n  FirmataParser::attach(parser, 0xff, DAT_08002db8, nullptr);\n  return parser;\n}",
            "called": [
                "attach",
                "attach",
                "attach",
                "attach",
                "attach",
                "FirmataMarshaller",
                "FirmataParser"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ce0",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "createFirmataParser_08002ce0"
        },
        "FUN_08005188": {
            "renaming": {
                "FUN_08005188": "handle_I2C_events_08005188",
                "hi2c": "i2c_handle",
                "pIVar1": "i2c_instance",
                "uVar2": "status_register_1",
                "uVar3": "control_register_2",
                "uVar4": "status_register_2"
            },
            "code": "void handle_I2C_events_08005188(I2C_HandleTypeDef_conflict *hi2c)\n{\n  I2C_TypeDef_conflict *i2c_instance;\n  uint32_t status_register_2;\n  uint32_t status_register_1;\n  uint32_t control_register_2;\n  \n  i2c_instance = hi2c->Instance;\n  status_register_2 = i2c_instance->SR2;\n  status_register_1 = i2c_instance->SR1;\n  control_register_2 = i2c_instance->CR2;\n  \n  if ((hi2c->Mode == HAL_I2C_MODE_MASTER) || (hi2c->Mode == HAL_I2C_MODE_MEM)) {\n    if (((status_register_1 & 0x10001) == 0) || ((control_register_2 & 0x200) == 0)) {\n      if (((status_register_1 & 0x08) == 0) || ((control_register_2 & 0x200) == 0)) {\n        if (((status_register_1 & 0x02) != 0) && ((control_register_2 & 0x200) != 0)) {\n          I2C_Master_ADDR(hi2c);\n        }\n      }\n      else {\n        I2C_Master_ADD10(hi2c);\n      }\n    }\n    else {\n      I2C_Master_SB(hi2c);\n    }\n    if ((status_register_2 & 0x04) == 0) {\n      if ((((status_register_1 & 0x40) != 0) && ((control_register_2 & 0x400) != 0)) && ((status_register_1 & 0x04) == 0)) {\n        I2C_MasterReceive_RXNE(hi2c);\n        return;\n      }\n      if (((status_register_1 & 0x04) != 0) && ((control_register_2 & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(hi2c);\n        return;\n      }\n    }\n    else {\n      if ((((status_register_1 & 0x40) != 0) && ((control_register_2 & 0x400) != 0)) && ((status_register_1 & 0x04) == 0)) {\n        I2C_MasterTransmit_TXE(hi2c);\n        return;\n      }\n      if (((status_register_1 & 0x04) != 0) && ((control_register_2 & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(hi2c);\n        return;\n      }\n    }\n  }\n  else {\n    if (((status_register_1 & 0x02) != 0) && ((control_register_2 & 0x200) != 0)) {\n      I2C_Slave_ADDR(hi2c);\n      return;\n    }\n    if (((status_register_1 & 0x10) != 0) && ((control_register_2 & 0x200) != 0)) {\n      I2C_Slave_STOPF(hi2c);\n      return;\n    }\n    if ((status_register_2 & 0x04) == 0) {\n      if ((((status_register_1 & 0x40) != 0) && ((control_register_2 & 0x400) != 0)) && ((status_register_1 & 0x04) == 0)) {\n        I2C_SlaveReceive_RXNE(hi2c);\n        return;\n      }\n      if (((status_register_1 & 0x04) != 0) && ((control_register_2 & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(hi2c);\n      }\n    }\n    else {\n      if ((((status_register_1 & 0x40) != 0) && ((control_register_2 & 0x400) != 0)) && ((status_register_1 & 0x04) == 0)) {\n        I2C_SlaveTransmit_TXE(hi2c);\n        return;\n      }\n      if (((status_register_1 & 0x04) != 0) && ((control_register_2 & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(hi2c);\n        return;\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "I2C_SlaveTransmit_BTF",
                "I2C_SlaveReceive_RXNE",
                "I2C_MasterTransmit_TXE",
                "I2C_SlaveReceive_BTF",
                "I2C_Master_ADDR",
                "I2C_MasterReceive_RXNE",
                "I2C_Master_SB",
                "I2C_Slave_ADDR",
                "I2C_Slave_STOPF",
                "I2C_MasterReceive_BTF",
                "I2C_SlaveTransmit_TXE",
                "I2C_MasterTransmit_BTF",
                "I2C_Master_ADD10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005188",
            "calling": [
                "I2C1_EV_IRQHandler",
                "I2C2_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_I2C_events_08005188"
        },
        "FUN_08007244": {
            "renaming": {
                "FUN_08007244": "do_nothing_08007244"
            },
            "code": "\nvoid do_nothing_08007244(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007244",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "do_nothing_08007244"
        },
        "FUN_08001bf8": {
            "renaming": {
                "FUN_08001bf8": "writeDataToWire_08001bf8",
                "data": "data",
                "PTR_Wire_08001c04": "wire"
            },
            "code": "void writeDataToWire_08001bf8(byte data) {\n  TwoWire::write(&PTR_Wire_08001c04, data);\n  return;\n}",
            "called": [
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001bf8",
            "calling": [
                "sysexCallback",
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "writeDataToWire_08001bf8"
        },
        "FUN_080069ec": {
            "renaming": {
                "FUN_080069ec": "uart_handler_080069ec",
                "huart": "uart",
                "HVar1": "status",
                "uVar2": "cr1",
                "pUVar3": "instance",
                "uVar4": "cr3_value",
                "uVar5": "sr",
                "UART_Receive_IT": "uart_receive",
                "UART_Transmit_IT": "uart_transmit",
                "UART_EndTransmit_IT": "uart_end_transmit",
                "HAL_UART_ErrorCallback": "uart_error_callback",
                "huart->ErrorCode": "error_code",
                "huart->Instance": "instance",
                "huart->hdmarx": "hdmarx",
                "HAL_DMA_Abort_IT": "dma_abort",
                "DAT_08006b08": "uart_dma_abort"
            },
            "code": "void uart_handler_080069ec(UART_HandleTypeDef *uart)\n{\n  HAL_StatusTypeDef status;\n  uint32_t sr;\n  uint32_t cr1;\n  USART_TypeDef *instance;\n  uint32_t cr3;\n  uint32_t error_code;\n  DMA_HandleTypeDef *hdmarx;\n  instance = uart->Instance;\n  sr = instance->SR;\n  cr1 = instance->CR1;\n  if ((sr & USART_SR_RXNE) && (cr1 & USART_CR1_RXNEIE)) {\n    UART_Receive_IT(uart);\n    return;\n  }\n  if ((sr & USART_SR_TXE) && (cr1 & USART_CR1_TXEIE)) {\n    UART_Transmit_IT(uart);\n    return;\n  }\n  if ((sr & USART_SR_TC) && (cr1 & USART_CR1_TCIE)) {\n    UART_EndTransmit_IT(uart);\n    return;\n  }\n  cr3 = instance->CR3;\n  error_code = 0;\n  if ((sr & USART_SR_PE) && (cr1 & USART_CR1_PEIE)) {\n    error_code |= HAL_UART_ERROR_PE;\n  }\n  if ((sr & USART_SR_FE) && (cr3 & USART_CR3_EIE)) {\n    error_code |= HAL_UART_ERROR_FE;\n  }\n  if ((sr & USART_SR_NE) && (cr3 & USART_CR3_EIE)) {\n    error_code |= HAL_UART_ERROR_NE;\n  }\n  if ((sr & USART_SR_ORE) && (cr3 & USART_CR3_EIE)) {\n    error_code |= HAL_UART_ERROR_ORE;\n  }\n  if (error_code != 0) {\n    if ((sr & USART_SR_RXNE) && (cr1 & USART_CR1_RXNEIE)) {\n      UART_Receive_IT(uart);\n    }\n    if ((error_code & HAL_UART_ERROR_ORE) == 0 && (instance->CR3 & USART_CR3_HDSEL) == 0) {\n      HAL_UART_ErrorCallback(uart);\n      uart->ErrorCode = 0;\n      return;\n    }\n    UART_EndRxTransfer(uart);\n    if ((instance->CR3 & USART_CR3_HDSEL) == 0) {\n      HAL_UART_ErrorCallback(uart);\n      return;\n    }\n    instance->CR3 &= ~USART_CR3_HDSEL;\n    hdmarx = uart->hdmarx;\n    if (hdmarx == NULL) {\n      HAL_UART_ErrorCallback(uart);\n      return;\n    }\n    hdmarx->XferAbortCallback = DAT_08006b08;\n    status = HAL_DMA_Abort_IT(hdmarx);\n    if (status != HAL_OK) {\n      hdmarx->XferAbortCallback(hdmarx);\n      return;\n    }\n  }\n}\n",
            "called": [
                "UART_EndRxTransfer",
                "UART_EndTransmit_IT",
                "UART_Transmit_IT",
                "HAL_DMA_Abort_IT",
                "HAL_UART_ErrorCallback",
                "UART_Receive_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080069ec",
            "calling": [
                "USART3_IRQHandler",
                "USART2_IRQHandler",
                "USART1_IRQHandler"
            ],
            "imported": false,
            "current_name": "uart_handler_080069ec"
        },
        "FUN_0800a168": {
            "renaming": {
                "FUN_0800a168": "read_file_0800a168",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "puVar1": "errno_ptr",
                "iVar2": "read_result"
            },
            "code": "void read_file_0800a168(int *error_code, int file_descriptor, char *buffer, int buffer_size) {\n  int *errno_ptr;\n  int read_result;\n  errno_ptr = PTR_errno_0800a188;\n  *(int *)PTR_errno_0800a188 = 0;\n  read_result = _read(file_descriptor, buffer, buffer_size);\n  if ((read_result == -1) && (*(int *)errno_ptr != 0)) {\n    *error_code = *(int *)errno_ptr;\n  }\n  return;\n}",
            "called": [
                "_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a168",
            "calling": [
                "__sread"
            ],
            "imported": false,
            "current_name": "read_file_0800a168"
        },
        "FUN_080067ac": {
            "renaming": {
                "FUN_080067ac": "transmitData_080067ac",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "dataSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "startTime"
            },
            "code": "HAL_StatusTypeDef transmitData_080067ac(UART_HandleTypeDef *uartHandle, uint8_t *data, uint16_t dataSize, uint32_t timeout)\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTime;\n\n  if (uartHandle->gState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n\n  if (data == NULL || dataSize == 0) {\n    return HAL_ERROR;\n  }\n\n  if (uartHandle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n\n  uartHandle->Lock = HAL_LOCKED;\n  uartHandle->ErrorCode = 0;\n  uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n  startTime = HAL_GetTick();\n\n  uartHandle->TxXferSize = dataSize;\n  uartHandle->TxXferCount = dataSize;\n\n  while (uartHandle->TxXferCount != 0) {\n    uartHandle->TxXferCount--;\n\n    if (uartHandle->Init.WordLength == UART_WORDLENGTH_9B) {\n      status = UART_WaitOnFlagUntilTimeout(uartHandle, UART_FLAG_TXE, RESET, startTime, timeout);\n      if (status != HAL_OK) {\n        uartHandle->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n\n      uartHandle->Instance->DR = *(uint16_t *)data & 0x1FF;\n      if (uartHandle->Init.Parity == UART_PARITY_NONE) {\n        data += 2;\n      }\n      else {\n        data++;\n      }\n    }\n    else {\n      status = UART_WaitOnFlagUntilTimeout(uartHandle, UART_FLAG_TXE, RESET, startTime, timeout);\n      if (status != HAL_OK) {\n        uartHandle->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n\n      uartHandle->Instance->DR = *data;\n      data++;\n    }\n  }\n\n  status = UART_WaitOnFlagUntilTimeout(uartHandle, UART_FLAG_TC, RESET, startTime, timeout);\n  if (status == HAL_OK) {\n    uartHandle->gState = HAL_UART_STATE_READY;\n    uartHandle->Lock = HAL_UNLOCKED;\n  }\n  else {\n    status = HAL_TIMEOUT;\n  }\n\n  return status;\n}",
            "called": [
                "UART_WaitOnFlagUntilTimeout",
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080067ac",
            "calling": [
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "transmitData_080067ac"
        },
        "FUN_0800735a": {
            "renaming": {
                "FUN_0800735a": "find_pin_function_0800735a",
                "pin": "target_pin",
                "map": "pin_map"
            },
            "code": "uint32_t find_pin_function_0800735a(PinName_conflict target_pin, PinMap_conflict *pin_map)\n{\n  while (true) {\n    if (pin_map->pin == NC) {\n      return 0xffffffff;\n    }\n    if (pin_map->pin == target_pin) {\n      break;\n    }\n    pin_map++;\n  }\n  return pin_map->function;\n}",
            "called": [
                "pinmap_find_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800735a",
            "calling": [
                "pinmap_find_function",
                "pinmap_function"
            ],
            "imported": false,
            "current_name": "find_pin_function_0800735a"
        },
        "FUN_08008c20": {
            "renaming": {
                "FUN_08008c20": "initializeSerialBuffers_08008c20",
                "this": "serial",
                "ctx": "ctx",
                "_serial": "serial",
                "rx_buff": "rx_buffer",
                "_rx_buffer": "_rx_buffer",
                "rx_head": "rx_head",
                "rx_tail": "rx_tail",
                "tx_buff": "tx_buffer",
                "_tx_buffer": "_tx_buffer",
                "tx_head": "tx_head",
                "tx_tail": "tx_tail"
            },
            "code": "int __thiscall initializeSerialBuffers_08008c20(HardwareSerial *serial,EVP_PKEY_CTX *ctx)\n{\n  serial->rx_buffer = serial->_rx_buffer;\n  serial->rx_head = 0;\n  serial->rx_tail = 0;\n  serial->tx_buffer = serial->_tx_buffer;\n  serial->tx_head = 0;\n  serial->tx_tail = 0;\n  return (int)serial;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008c20",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "initializeSerialBuffers_08008c20"
        },
        "FUN_0800723c": {
            "renaming": {
                "FUN_0800723c": "get_current_tick_0800723c",
                "uVar1": "current_tick"
            },
            "code": "uint32_t get_current_tick_0800723c(void)\n{\n  uint32_t current_tick = HAL_GetTick();\n  return current_tick;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800723c",
            "calling": [
                "millis"
            ],
            "imported": false,
            "current_name": "get_current_tick_0800723c"
        },
        "FUN_080043a2": {
            "renaming": {
                "FUN_080043a2": "i2c_handle_transfer_080043a2",
                "hi2c": "handle",
                "uVar1": "transfer_options",
                "pIVar2": "i2c_instance",
                "tmpreg": "tmpreg"
            },
            "code": "HAL_StatusTypeDef i2c_handle_transfer_080043a2(I2C_HandleTypeDef *handle)\n{\n  uint32_t transfer_options = handle->XferOptions;\n  I2C_TypeDef *i2c_instance = handle->Instance;\n  uint32_t tmpreg;\n\n  if ((handle->State == HAL_I2C_STATE_BUSY_RX) && ((handle->EventCount != 0 || (handle->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((handle->EventCount == 0) && ((handle->Init).AddressingMode == I2C_ADDRESSINGMODE_10BIT)) {\n      i2c_instance->CR1 |= I2C_CR1_ACK;\n      handle->EventCount++;\n    }\n    else {\n      if (handle->XferCount == 0) {\n        i2c_instance->CR1 |= I2C_CR1_STOP;\n      }\n      else if (handle->XferCount == 1) {\n        if (transfer_options == I2C_FIRST_AND_LAST_FRAME_NO_PEC) {\n          i2c_instance->CR1 &= ~(I2C_CR1_POS);\n          if ((i2c_instance->CR2 & I2C_CR2_LAST) == 0) {\n            i2c_instance->CR1 |= I2C_CR1_START;\n          }\n          else {\n            i2c_instance->CR1 &= ~(I2C_CR1_START);\n          }\n        }\n        else if (((transfer_options == I2C_FIRST_FRAME_WITH_PEC) || (transfer_options == I2C_LAST_FRAME_WITH_PEC)) || (handle->PreviousState == HAL_I2C_STATE_ADDR)) {\n          i2c_instance->CR1 &= ~(I2C_CR1_POS);\n          i2c_instance->CR1 |= I2C_CR1_START;\n        }\n        else if (handle->XferOptions == I2C_OTHER_FRAME_NO_PEC) {\n          i2c_instance->CR1 |= I2C_CR1_ACK;\n        }\n        else {\n          i2c_instance->CR1 &= ~(I2C_CR1_POS);\n        }\n      }\n      else if (handle->XferCount == 2) {\n        if (handle->XferOptions == I2C_LAST_FRAME_NO_PEC) {\n          i2c_instance->CR1 |= I2C_CR1_ACK;\n        }\n        else {\n          i2c_instance->CR1 |= I2C_CR1_POS;\n          i2c_instance->CR1 &= ~(I2C_CR1_ACK);\n        }\n        if ((i2c_instance->CR2 & I2C_CR2_LAST) != 0) {\n          i2c_instance->CR2 |= I2C_CR2_RD_WRN;\n        }\n      }\n      else {\n        i2c_instance->CR1 |= I2C_CR1_ACK;\n        if ((i2c_instance->CR2 & I2C_CR2_LAST) != 0) {\n          i2c_instance->CR2 |= I2C_CR2_RD_WRN;\n        }\n      }\n      handle->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080043a2",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handle_transfer_080043a2"
        },
        "FUN_08006280": {
            "renaming": {
                "FUN_08006280": "set_timer_interrupt_08006280",
                "htim": "timer_handle",
                "Channel": "channel",
                "pTVar1": "timer_instance",
                "DAT_080062f0": "TIM1"
            },
            "code": "HAL_StatusTypeDef set_timer_interrupt_08006280(TIM_HandleTypeDef *timer_handle, uint32_t channel) {\n  TIM_TypeDef *timer_instance = timer_handle->Instance;\n  switch(channel) {\n    case 0:\n      timer_instance->DIER |= TIM_DIER_UIE;\n      break;\n    case 4:\n      timer_instance->DIER |= TIM_DIER_CC4IE;\n      break;\n    case 8:\n      timer_instance->DIER |= TIM_DIER_CC3IE;\n      break;\n    case 0xc:\n      timer_instance->DIER |= TIM_DIER_CC2IE;\n  }\n  TIM_CCxChannelCmd(timer_instance, channel, TIM_CCx_ENABLE);\n  if (timer_instance == DAT_080062f0) {\n    timer_instance->BDTR |= TIM_BDTR_MOE;\n  }\n  timer_instance->CR1 |= TIM_CR1_CEN;\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006280",
            "calling": [
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "set_timer_interrupt_08006280"
        },
        "FUN_08007258": {
            "renaming": {
                "FUN_08007258": "configure_gpio_pin_08007258",
                "pin": "pin",
                "mode": "mode",
                "pull": "pull",
                "uVar1": "pin_number",
                "GPIOx": "gpio_port",
                "tmpreg": "N/A",
                "GPIO_InitStructure": "gpio_init_structure"
            },
            "code": "void configure_gpio_pin_08007258(PinName_conflict pin, uint32_t mode, uint32_t pull) {\n  uint32_t pin_number = (uint32_t) pin;\n  GPIO_TypeDef *gpio_port = set_GPIO_Port_Clock((pin_number << 0x18) >> 0x1c);\n  GPIO_InitTypeDef gpio_init_structure;\n  gpio_init_structure.Pin = 1 << (pin_number & 0xf) & 0xffff;\n  gpio_init_structure.Mode = mode;\n  gpio_init_structure.Pull = pull;\n  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;\n  HAL_GPIO_Init(gpio_port, &gpio_init_structure);\n  return;\n}",
            "called": [
                "set_GPIO_Port_Clock",
                "HAL_GPIO_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007258",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "configure_gpio_pin_08007258"
        },
        "FUN_08009f4c": {
            "renaming": {
                "FUN_08009f4c": "allocate_memory_08009f4c",
                "param_1": "size",
                "param_2": "ptr",
                "param_3": "new_ptr",
                "param_4": "new_size",
                "pvVar1": "result",
                "pvVar2": "old_size"
            },
            "code": "void * allocate_memory_08009f4c(size_t size, void *ptr, void *new_ptr, size_t new_size)\n{\n  void *result;\n  if (ptr != NULL) {\n    if (new_ptr == NULL) {\n      free(ptr);\n      result = new_ptr;\n    }\n    else {\n      size_t old_size = malloc_usable_size(ptr);\n      result = ptr;\n      if ((old_size < new_size) && (result = malloc(size, new_size), result != NULL)) {\n        memcpy(result, ptr, old_size);\n        free(ptr);\n      }\n    }\n    return result;\n  }\n  result = malloc(size, new_size);\n  return result;\n}",
            "called": [
                "_malloc_r",
                "_malloc_usable_size_r",
                "memcpy",
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f4c",
            "calling": [
                "realloc"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009f4c"
        },
        "FUN_08009f4a": {
            "renaming": {
                "FUN_08009f4a": "do_nothing_08009f4a"
            },
            "code": "\nvoid do_nothing_08009f4a(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f4a",
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "imported": false,
            "current_name": "do_nothing_08009f4a"
        },
        "FUN_08006c7c": {
            "renaming": {
                "FUN_08006c7c": "map_PWM_function_to_pin_08006c7c",
                "pin": "pin_name",
                "uVar1": "function_map_result",
                "uVar2": "function_index"
            },
            "code": "uint32_t map_PWM_function_to_pin_08006c7c(PinName_conflict pin)\n{\n  uint32_t function_map_result;\n  uint32_t function_index;\n  \n  function_map_result = pinmap_function(pin,(PinMap_conflict *)PTR_PinMap_PWM_08006ca4);\n  function_index = (function_map_result << 0xc) >> 0x1b;\n  if (function_index == 3) {\n    return 8;\n  }\n  if (function_index != 4) {\n    if (function_index != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}",
            "called": [
                "pinmap_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c7c",
            "calling": [
                "pwm_stop",
                "pwm_start"
            ],
            "imported": false,
            "current_name": "map_PWM_function_to_pin_08006c7c"
        },
        "FUN_08006b5c": {
            "renaming": {
                "FUN_08006b5c": "updateMap_08006b5c",
                "pin": "pinName",
                "map": "mapPtr",
                "uVar1": "pinIndex"
            },
            "code": "void updateMap_08006b5c(PinName_conflict pin, uint32_t *map) {\n  uint32_t pinIndex = (uint32_t)pin >> 4;\n  uint32_t pinMask = 1 << ((uint32_t)pin & 0xF);\n  map[pinIndex] &= ~pinMask;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b5c",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "updateMap_08006b5c"
        },
        "FUN_08007376": {
            "renaming": {
                "FUN_08007376": "find_pin_function_08007376",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "function_id"
            },
            "code": "uint32_t find_pin_function_08007376(PinName_conflict pin, PinMap_conflict *pin_map){\n  uint32_t function_id;\n  if (pin == NC) {\n    return 0xffffffff;\n  }\n  function_id = pinmap_find_function(pin, pin_map);\n  return function_id;\n}",
            "called": [
                "pinmap_find_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007376",
            "calling": [
                "pwm_stop",
                "i2c_custom_init",
                "get_pwm_channel",
                "pwm_start",
                "get_adc_channel",
                "uart_init",
                "HAL_TIM_PWM_MspInit"
            ],
            "imported": false,
            "current_name": "find_pin_function_08007376"
        },
        "FUN_080033cc": {
            "renaming": {
                "FUN_080033cc": "parseSysexMessage_080033cc",
                "this": "parser",
                "uVar1": "messageType",
                "sVar2": "stringLength/firmwareVersionLength",
                "puVar3": "firmwareVersionData",
                "bufferDataAtPosition": "bufferDataAtPosition",
                "currentStringCallback": "currentStringCallback",
                "stringCallbackFunction": "stringCallbackFunction",
                "currentStringCallbackContext": "currentStringCallbackContext",
                "currentReportFirmwareCallback": "currentReportFirmwareCallback",
                "versionCallbackFunction": "versionCallbackFunction",
                "sysexBytesRead": "sysexBytesRead",
                "decodeByteStream": "decodeByteStream",
                "currentReportFirmwareCallbackContext": "currentReportFirmwareCallbackContext",
                "currentSysexCallback": "currentSysexCallback",
                "sysexCallbackFunction": "sysexCallbackFunction"
            },
            "code": "void __thiscall parseSysexMessage_080033cc(FirmataParser *parser) {\n  uint8_t messageType = *parser->dataBuffer;\n  if (messageType == 'q') {\n    if (parser->currentStringCallback != (stringCallbackFunction)0x0) {\n      size_t stringLength = decodeByteStream(parser, parser->sysexBytesRead - 1, parser->dataBuffer + 1);\n      bufferDataAtPosition(parser, '\\0', stringLength + 1);\n      (*parser->currentStringCallback)(parser->currentStringCallbackContext, (char *)(parser->dataBuffer + 1));\n      return;\n    }\n  }\n  else if (messageType == 'y') {\n    if (parser->currentReportFirmwareCallback != (versionCallbackFunction)0x0) {\n      if (parser->sysexBytesRead < 3) {\n        (*parser->currentReportFirmwareCallback)(parser->currentReportFirmwareCallbackContext, 0, 0, (char *)0x0);\n        return;\n      }\n      size_t firmwareVersionLength = decodeByteStream(parser, parser->sysexBytesRead - 3, parser->dataBuffer + 3);\n      bufferDataAtPosition(parser, '\\0', firmwareVersionLength + 3);\n      uint8_t *firmwareVersionData = parser->dataBuffer;\n      (*parser->currentReportFirmwareCallback)(parser->currentReportFirmwareCallbackContext, (uint)firmwareVersionData[1], (uint)firmwareVersionData[2], (char *)(firmwareVersionData + 3));\n      return;\n    }\n  }\n  else if (parser->currentSysexCallback != (sysexCallbackFunction)0x0) {\n    (*parser->currentSysexCallback)(parser->currentSysexCallbackContext, messageType, parser->sysexBytesRead - 1, parser->dataBuffer + 1);\n  }\n  return;\n}",
            "called": [
                "decodeByteStream",
                "bufferDataAtPosition"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080033cc",
            "calling": [
                "parse"
            ],
            "imported": false,
            "current_name": "parseSysexMessage_080033cc"
        },
        "FUN_08003de4": {
            "renaming": {
                "FUN_08003de4": "stop_adc_conversion_08003de4",
                "hadc": "adc_handle",
                "HVar1": "status",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "ADC_ConversionStop_Disable": "ADC_stop_conversion",
                "Lock": "lock",
                "HAL_LOCKED": "HAL_ADC_LOCKED",
                "HAL_UNLOCKED": "HAL_ADC_UNLOCKED",
                "State": "state"
            },
            "code": "HAL_StatusTypeDef_conflict stop_adc_conversion_08003de4(ADC_HandleTypeDef *adc_handle)\n{\n  HAL_StatusTypeDef_conflict status;\n  if (adc_handle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  adc_handle->Lock = HAL_LOCKED;\n  status = ADC_ConversionStop_Disable(adc_handle);\n  if (status == HAL_OK) {\n    adc_handle->State = adc_handle->State & 0xffffeefe | 1;\n  }\n  adc_handle->Lock = HAL_UNLOCKED;\n  return status;\n}",
            "called": [
                "ADC_ConversionStop_Disable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003de4",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "stop_adc_conversion_08003de4"
        },
        "FUN_08000500": {
            "renaming": {
                "FUN_08000500": "attachServo_08000500",
                "pin": "servoPin",
                "minPulse": "minPulse",
                "maxPulse": "maxPulse",
                "pin_00": "servoPin_00",
                "bVar1": "servoCount",
                "PTR_servoCount_0800056c": "servoCountPtr",
                "firmata::FirmataClass::sendString": "sendString",
                "FirmataClass": "firmataPtr",
                "PTR_Firmata_08000584": "firmataPtr",
                "PTR_s_Max_servos_attached_08000580": "maxServosAttachedMsg",
                "bVar2": "detachedServoCount",
                "PTR_detachedServoCount_08000570": "detachedServoCountPtr",
                "PTR_servoPinMap_08000578": "servoPinMap",
                "PTR_detachedServos_08000574": "detachedServos",
                "Servo::attach": "Servo::attach",
                "PTR_servos_0800057c": "servosPtr"
            },
            "code": "void attachServo_08000500(byte servoPin, int minPulse, int maxPulse) {\n  byte servoCount = *PTR_servoCount_0800056c;\n  if (servoCount > 11) {\n    firmata::FirmataClass::sendString((FirmataClass *)PTR_Firmata_08000584, PTR_s_Max_servos_attached_08000580);\n    return;\n  }\n  byte detachedServoCount = *PTR_detachedServoCount_08000570;\n  if (detachedServoCount == 0) {\n    PTR_servoPinMap_08000578[servoPin] = servoCount;\n    *PTR_servoCount_0800056c = servoCount + 1;\n  }\n  else {\n    PTR_servoPinMap_08000578[servoPin] = PTR_detachedServos_08000574[detachedServoCount - 1];\n    *PTR_detachedServoCount_08000570 = detachedServoCount - 1;\n  }\n  if ((minPulse > 0) && (maxPulse > 0)) {\n    Servo::attach((Servo *)(PTR_servos_0800057c + (uint)(byte)PTR_servoPinMap_08000578[servoPin] * 3), servoPin, minPulse, maxPulse);\n    return;\n  }\n  Servo::attach((Servo *)(PTR_servos_0800057c + (uint)(byte)PTR_servoPinMap_08000578[servoPin] * 3), servoPin);\n  return;\n}",
            "called": [
                "attach",
                "sendString",
                "attach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000500",
            "calling": [
                "sysexCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "attachServo_08000500"
        },
        "FUN_08009d24": {
            "renaming": {
                "FUN_08009d24": "allocate_memory_block_08009d24",
                "param_1": "num_blocks",
                "param_2": "block_size",
                "puVar1": "memory_block",
                "iVar2": "total_size"
            },
            "code": "undefined4* allocate_memory_block_08009d24(int num_blocks, int block_size)\n{\n  undefined4* memory_block;\n  int total_size = (num_blocks - 1) * 0x68 + 0x74;\n  memory_block = (undefined4*) _malloc_r(num_blocks, total_size);\n  if (memory_block != (undefined4*)0x0) {\n    *memory_block = 0;\n    memory_block[1] = num_blocks;\n    memory_block[2] = memory_block + 3;\n    memset(memory_block + 3, 0, total_size - 0x74);\n  }\n  return memory_block;\n}",
            "called": [
                "_malloc_r",
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009d24",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_08009d24"
        },
        "FUN_08008e72": {
            "renaming": {
                "__thiscall Print::FUN_08008e72": "size_t Print::printChar",
                "this": "this",
                "c": "character",
                "sVar1": "size",
                "FUN_08008e72": "Print::printChar_08008e72"
            },
            "code": "size_t Print::printChar_08008e72(char character) {\n  size_t size = (**this->_vptr_Print)(this,(int)character);\n  return size;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e72",
            "calling": [
                "printTo"
            ],
            "imported": false,
            "current_name": "Print::printChar_08008e72"
        },
        "FUN_080022f8": {
            "renaming": {
                "FUN_080022f8": "readAndProcessInputs_080022f8",
                "bVar1": "is_digital_input",
                "PVar2": "pin_conflict",
                "bVar3": "pin_mode",
                "iVar4": "available_bytes",
                "uVar5": "current_millis",
                "uVar6": "pin_num",
                "ulPin": "digital_pin_num"
            },
            "code": "void readAndProcessInputs_080022f8()\n{\n  bool is_digital_input;\n  PinName_conflict pin_conflict;\n  byte pin_mode;\n  int available_bytes;\n  uint32_t current_millis;\n  uint sampling_interval;\n  uint previous_millis;\n  uint pin_num;\n  checkDigitalInputs();\n  while (available_bytes = firmata::FirmataClass::available((FirmataClass *)PTR_Firmata_080023e0), available_bytes != 0)\n  {\n    firmata::FirmataClass::processInput((FirmataClass *)PTR_Firmata_080023e0);\n  }\n  current_millis = millis();\n  *(uint32_t *)PTR_currentMillis_080023e4 = current_millis;\n  if (*(uint *)PTR_samplingInterval_080023ec < current_millis - *(int *)PTR_previousMillis_080023e8) {\n    *(uint *)PTR_previousMillis_080023e8 = *(int *)PTR_previousMillis_080023e8 + *(uint *)PTR_samplingInterval_080023ec;\n    for (pin_num = 0; pin_num < 0x3c; pin_num = pin_num + 1 & 0xff) {\n      uint digital_pin_num = pin_num - 0x2e & 0xff;\n      if (digital_pin_num < 0xe) {\n        if (pin_num < 0x3c) {\n          pin_conflict = PTR_digitalPin_080023f4[pin_num];\n        }\n        else {\n          pin_conflict = NC;\n        }\n        uint digital_pin = pinNametoDigitalPin(pin_conflict);\n        if (digital_pin == 0) {\n          is_digital_input = false;\n        }\n        else {\n          if (pin_num < 0x3c) {\n            pin_conflict = PTR_digitalPin_080023f4[pin_num];\n          }\n          else {\n            pin_conflict = NC;\n          }\n          uint digital_pin = pinNametoDigitalPin(pin_conflict);\n          if (digital_pin == 1) {\n            is_digital_input = false;\n          }\n          else {\n            pin_mode = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_080023e0,(byte)pin_num);\n            if (pin_mode == '\\x02') {\n              is_digital_input = true;\n            }\n            else {\n              is_digital_input = false;\n            }\n          }\n        }\n      }\n      else {\n        is_digital_input = false;\n      }\n      if ((is_digital_input) && ((*(int *)PTR_analogInputsToReport_080023f0 >> digital_pin_num & 1U) != 0)) {\n        uint analog_input = analogRead(digital_pin_num);\n        firmata::FirmataClass::sendAnalog((FirmataClass *)PTR_Firmata_080023e0,(byte)digital_pin_num,analog_input);\n      }\n    }\n    if (-1 < (char)*PTR_queryIndex_080023f8) {\n      for (pin_num = 0; (int)pin_num < (char)*PTR_queryIndex_080023f8 + 1; pin_num = pin_num + 1 & 0xff) {\n        int query_offset = pin_num * 0xc;\n        readAndReportData(PTR_query_080023fc[query_offset],*(int *)(PTR_query_080023fc + query_offset + 4),PTR_query_080023fc[query_offset + 8],PTR_query_080023fc[query_offset + 9]);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "pinNametoDigitalPin",
                "sendAnalog",
                "analogRead",
                "getPinMode",
                "checkDigitalInputs",
                "readAndReportData",
                "processInput",
                "millis",
                "available"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080022f8",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "readAndProcessInputs_080022f8"
        },
        "FUN_08005084": {
            "renaming": {
                "FUN_08005084": "i2c_handle_transfer_08005084",
                "hi2c": "handle",
                "HVar1": "state",
                "pIVar2": "instance",
                "puVar3": "buffer",
                "tmpreg": "control_reg"
            },
            "code": "HAL_StatusTypeDef i2c_handle_transfer_08005084(I2C_HandleTypeDef *handle)\n{\n  HAL_I2C_StateTypeDef state = handle->State;\n  I2C_TypeDef *instance = handle->Instance;\n  uint8_t *buffer = handle->pBuffPtr;\n  uint32_t control_reg;\n\n  control_reg = instance->CR2 & 0xfffff8ff;\n  instance->CR2 = control_reg;\n  instance->CR1 |= 1;\n  instance->CR1 &= 0xfffffbff;\n\n  if ((instance->CR2 & 0x800) != 0) {\n    if ((state == HAL_I2C_STATE_BUSY_RX) || (state == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      handle->XferCount = (uint16_t)handle->hdmarx->Instance->CNDTR;\n    }\n    else {\n      handle->XferCount = (uint16_t)handle->hdmatx->Instance->CNDTR;\n    }\n  }\n\n  if (handle->XferCount != 0) {\n    if ((instance->SR1 & 4) != 0) {\n      *buffer++ = (uint8_t)instance->DR;\n      handle->XferCount--;\n    }\n    if ((instance->SR1 & 0x40) != 0) {\n      *buffer++ = (uint8_t)instance->DR;\n      handle->XferCount--;\n    }\n    handle->ErrorCode |= 4;\n  }\n\n  if (handle->ErrorCode == 0) {\n    if (((state == HAL_I2C_STATE_LISTEN) || (state == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (state == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      handle->XferOptions = DAT_08005184;\n      handle->PreviousState = 0;\n      handle->State = HAL_I2C_STATE_READY;\n      handle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(handle);\n    }\n    else if ((handle->PreviousState == 0x22) || (state == HAL_I2C_STATE_BUSY_RX)) {\n      handle->PreviousState = 0;\n      handle->State = HAL_I2C_STATE_READY;\n      handle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(handle);\n    }\n  }\n  else {\n    I2C_ITError(handle);\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "I2C_ITError",
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005084",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handle_transfer_08005084"
        },
        "FUN_08008b0e": {
            "renaming": {
                "FUN_08008b0e": "readNextByte_08008b0e",
                "this": "serial",
                "_serial": "_serial",
                "rx_tail": "rxTail",
                "rx_head": "rxHead",
                "rx_buff": "rxBuffer"
            },
            "code": "int __thiscall readNextByte_08008b0e(HardwareSerial *serial) {\n  uint rxTail = (uint)(serial->_serial).rx_tail;\n  if ((serial->_serial).rx_head != rxTail) {\n    return (uint)(serial->_serial).rx_buff[rxTail];\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b0e",
            "calling": [],
            "imported": false,
            "current_name": "readNextByte_08008b0e"
        },
        "FUN_0800291c": {
            "renaming": {
                "FUN_0800291c::FUN_0800291c": "initialize_i2c",
                "this": "self",
                "puVar1": "digital_pin",
                "(this->super_Stream)": "stream",
                "(this->super_Stream).super_Print": "print",
                "(this->super_Stream).super_Print.write_error": "print->write_error",
                "(this->super_Stream).super_Print._vptr_Print": "print->_vptr_Print",
                "(this->super_Stream)._timeout": "stream->_timeout",
                "PTR_digitalPin_08002944": "digital_pin",
                "(this->_i2c).sda": "self->_i2c.sda",
                "(this->_i2c).scl": "self->_i2c.scl",
                "FUN_0800291c": "initialize_i2c_0800291c"
            },
            "code": "initialize_i2c_0800291c* __thiscall initialize_i2c_0800291c(initialize_i2c_0800291c* this) {\n\tundefined* PTR_digitalPin_08002944;\n\tStream* stream = &(this->super_Stream);\n\tPrint* print = &(stream->super_Print);\n\tprint->write_error = 0;\n\tprint->_vptr_Print = (_func_int_varargs**)PTR_PTR_write_1_08002940;\n\tstream->_timeout = 1000;\n\tPTR_digitalPin_08002944 = PTR_digitalPin_08002944;\n\t(this->_i2c).sda = PTR_digitalPin_08002944[0xe];\n\t(this->_i2c).scl = PTR_digitalPin_08002944[0xf];\n\treturn this;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800291c",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_i2c_0800291c"
        },
        "FUN_08002ac0": {
            "renaming": {
                "FUN_08002ac0": "readRegister_08002ac0",
                "this": "wire",
                "uVar1": "registerValue"
            },
            "code": "uint8_t __thiscall readRegister_08002ac0(TwoWire *this)\n{\n  uint8_t registerValue;\n  registerValue = readRegister_08002ac0(this, '\\x01');\n  return registerValue;\n}",
            "called": [
                "endTransmission"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ac0",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "readRegister_08002ac0"
        },
        "FUN_080032bc": {
            "renaming": {
                "FUN_080032bc::FUN_080032bc": "FirmataCommandHandler::FirmataCommandHandler",
                "this": "this",
                "dataBuffer": "dataBuffer_",
                "dataBufferSize": "dataBufferSize_",
                "executeMultiByteCommand": "executeMultiByteCommand_",
                "multiByteChannel": "multiByteChannel_",
                "waitForData": "waitForData_",
                "parsingSysex": "parsingSysex_",
                "sysexBytesRead": "sysexBytesRead_",
                "currentAnalogCallbackContext": "currentAnalogCallbackContext_",
                "currentDigitalCallbackContext": "currentDigitalCallbackContext_",
                "currentReportAnalogCallbackContext": "currentReportAnalogCallbackContext_",
                "currentReportDigitalCallbackContext": "currentReportDigitalCallbackContext_",
                "currentPinModeCallbackContext": "currentPinModeCallbackContext_",
                "currentPinValueCallbackContext": "currentPinValueCallbackContext_",
                "currentReportFirmwareCallbackContext": "currentReportFirmwareCallbackContext_",
                "currentReportVersionCallbackContext": "currentReportVersionCallbackContext_",
                "currentDataBufferOverflowCallbackContext": "currentDataBufferOverflowCallbackContext_",
                "currentStringCallbackContext": "currentStringCallbackContext_",
                "currentSysexCallbackContext": "currentSysexCallbackContext_",
                "currentSystemResetCallbackContext": "currentSystemResetCallbackContext_",
                "currentAnalogCallback": "currentAnalogCallback_",
                "currentDigitalCallback": "currentDigitalCallback_",
                "currentReportAnalogCallback": "currentReportAnalogCallback_",
                "currentReportDigitalCallback": "currentReportDigitalCallback_",
                "currentPinModeCallback": "currentPinModeCallback_",
                "currentPinValueCallback": "currentPinValueCallback_",
                "currentDataBufferOverflowCallback": "currentDataBufferOverflowCallback_",
                "currentStringCallback": "currentStringCallback_",
                "currentSysexCallback": "currentSysexCallback_",
                "currentReportFirmwareCallback": "currentReportFirmwareCallback_",
                "currentReportVersionCallback": "currentReportVersionCallback_",
                "currentSystemResetCallback": "currentSystemResetCallback_",
                "count_leading_zeroes": "count_leading_zeroes",
                "uint8_t": "uint8_t",
                "size_t": "size_t",
                "bool": "bool",
                "void": "void",
                "callbackFunction": "callbackFunction",
                "dataBufferOverflowCallbackFunction": "dataBufferOverflowCallbackFunction",
                "stringCallbackFunction": "stringCallbackFunction",
                "sysexCallbackFunction": "sysexCallbackFunction",
                "versionCallbackFunction": "versionCallbackFunction",
                "systemCallbackFunction": "systemCallbackFunction",
                "allowBufferUpdate": "allowBufferUpdate_",
                "FUN_080032bc": "FirmataCommandHandler_080032bc"
            },
            "code": "class FirmataCommandHandler_080032bc {\npublic:\n    FirmataCommandHandler_080032bc(uint8_t *dataBuffer, size_t dataBufferSize) :\n        dataBuffer_(dataBuffer),\n        dataBufferSize_(dataBufferSize),\n        executeMultiByteCommand_(false),\n        multiByteChannel_(0),\n        waitForData_(0),\n        parsingSysex_(false),\n        sysexBytesRead_(0),\n        currentAnalogCallbackContext_(nullptr),\n        currentDigitalCallbackContext_(nullptr),\n        currentReportAnalogCallbackContext_(nullptr),\n        currentReportDigitalCallbackContext_(nullptr),\n        currentPinModeCallbackContext_(nullptr),\n        currentPinValueCallbackContext_(nullptr),\n        currentReportFirmwareCallbackContext_(nullptr),\n        currentReportVersionCallbackContext_(nullptr),\n        currentDataBufferOverflowCallbackContext_(nullptr),\n        currentStringCallbackContext_(nullptr),\n        currentSysexCallbackContext_(nullptr),\n        currentSystemResetCallbackContext_(nullptr),\n        currentAnalogCallback_(nullptr),\n        currentDigitalCallback_(nullptr),\n        currentReportAnalogCallback_(nullptr),\n        currentReportDigitalCallback_(nullptr),\n        currentPinModeCallback_(nullptr),\n        currentPinValueCallback_(nullptr),\n        currentDataBufferOverflowCallback_(nullptr),\n        currentStringCallback_(nullptr),\n        currentSysexCallback_(nullptr),\n        currentReportFirmwareCallback_(nullptr),\n        currentReportVersionCallback_(nullptr),\n        currentSystemResetCallback_(nullptr),\n        allowBufferUpdate_(count_leading_zeroes(dataBuffer) >> 5)\n    {}\n\nprivate:\n    uint8_t *dataBuffer_;\n    size_t dataBufferSize_;\n    bool executeMultiByteCommand_;\n    uint8_t multiByteChannel_;\n    uint8_t waitForData_;\n    bool parsingSysex_;\n    uint16_t sysexBytesRead_;\n    void *currentAnalogCallbackContext_;\n    void *currentDigitalCallbackContext_;\n    void *currentReportAnalogCallbackContext_;\n    void *currentReportDigitalCallbackContext_;\n    void *currentPinModeCallbackContext_;\n    void *currentPinValueCallbackContext_;\n    void *currentReportFirmwareCallbackContext_;\n    void *currentReportVersionCallbackContext_;\n    void *currentDataBufferOverflowCallbackContext_;\n    void *currentStringCallbackContext_;\n    void *currentSysexCallbackContext_;\n    void *currentSystemResetCallbackContext_;\n    callbackFunction currentAnalogCallback_;\n    callbackFunction currentDigitalCallback_;\n    callbackFunction currentReportAnalogCallback_;\n    callbackFunction currentReportDigitalCallback_;\n    callbackFunction currentPinModeCallback_;\n    callbackFunction currentPinValueCallback_;\n    dataBufferOverflowCallbackFunction currentDataBufferOverflowCallback_;\n    stringCallbackFunction currentStringCallback_;\n    sysexCallbackFunction currentSysexCallback_;\n    versionCallbackFunction currentReportFirmwareCallback_;\n    systemCallbackFunction currentReportVersionCallback_;\n    systemCallbackFunction currentSystemResetCallback_;\n    bool allowBufferUpdate_;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080032bc",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "FirmataCommandHandler_080032bc"
        },
        "FUN_080077b0": {
            "renaming": {
                "FUN_080077b0": "FUNC_080077b0"
            },
            "code": "\nvoid FUNC_080077b0(i2c_t_conflict *obj,i2c_timing_e_conflict timing,uint32_t addressingMode,\n                    uint32_t ownAddress,uint8_t master)\n\n{\n  undefined *puVar1;\n  I2C_TypeDef_conflict *pIVar2;\n  void *a;\n  void *b;\n  I2C_TypeDef_conflict *pIVar3;\n  GPIO_TypeDef *pGVar4;\n  uint32_t uVar5;\n  uint32_t uVar6;\n  I2C_HandleTypeDef_conflict *hi2c;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_2;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (obj != (i2c_t_conflict *)0x0) {\n    hi2c = &obj->handle;\n    a = pinmap_peripheral(obj->sda,(PinMap_conflict *)PTR_PinMap_I2C_SDA_08007a74);\n    b = pinmap_peripheral(obj->scl,(PinMap_conflict *)PTR_PinMap_I2C_SCL_08007a78);\n    if ((a == (void *)0x0) || (b == (void *)0x0)) {\n      iprintf(PTR_s_ERROR__at_least_one_I2C_pin_has_n_08007a88);\n    }\n    else {\n      pIVar3 = (I2C_TypeDef_conflict *)pinmap_merge_peripheral(a,b);\n      obj->i2c = pIVar3;\n      pIVar2 = DAT_08007a7c;\n      if (pIVar3 == (I2C_TypeDef_conflict *)0x0) {\n        iprintf(PTR_s_ERROR__I2C_pins_mismatch_08007a8c);\n      }\n      else {\n        if (pIVar3 == DAT_08007a7c) {\n          DAT_08007a7c[0xc56].CR2 = DAT_08007a7c[0xc56].CR2 | 0x200000;\n          pIVar2[0xc55].CCR = pIVar2[0xc55].CCR | 0x200000;\n          pIVar2[0xc55].CCR = pIVar2[0xc55].CCR & 0xffdfffff;\n          obj->irq = I2C1_EV_IRQn;\n          obj->irqER = I2C1_ER_IRQn;\n          *(I2C_HandleTypeDef_conflict **)PTR_i2c_handles_08007a90 = hi2c;\n        }\n        pIVar2 = DAT_08007a80;\n        if (obj->i2c == DAT_08007a80) {\n          DAT_08007a80[0xc39].SR2 = DAT_08007a80[0xc39].SR2 | 0x400000;\n          pIVar2[0xc39].OAR2 = pIVar2[0xc39].OAR2 | 0x400000;\n          pIVar2[0xc39].OAR2 = pIVar2[0xc39].OAR2 & 0xffbfffff;\n          obj->irq = I2C2_EV_IRQn;\n          obj->irqER = I2C2_ER_IRQn;\n          *(I2C_HandleTypeDef_conflict **)(PTR_i2c_handles_08007a90 + 4) = hi2c;\n        }\n        pGVar4 = set_GPIO_Port_Clock((uint)((int)obj->scl << 0x18) >> 0x1c);\n        puVar1 = PTR_PinMap_I2C_SCL_08007a78;\n        GPIO_InitStruct.Pin = 1 << ((int)obj->scl & 0xfU) & 0xffff;\n        uVar5 = pinmap_function(obj->scl,(PinMap_conflict *)PTR_PinMap_I2C_SCL_08007a78);\n        uVar6 = pinmap_function(obj->scl,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Mode = (uVar5 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Speed = 3;\n        uVar5 = pinmap_function(obj->scl,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Pull = (uVar5 << 0x1a) >> 0x1e;\n        uVar5 = pinmap_function(obj->scl,(PinMap_conflict *)puVar1);\n        *(uint *)(DAT_08007a84 + 0x18) = *(uint *)(DAT_08007a84 + 0x18) | 1;\n        switch((uVar5 << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x4000000;\n        }\n        HAL_GPIO_Init(pGVar4,&GPIO_InitStruct);\n        pGVar4 = set_GPIO_Port_Clock((uint)((int)obj->sda << 0x18) >> 0x1c);\n        puVar1 = PTR_PinMap_I2C_SDA_08007a74;\n        GPIO_InitStruct.Pin = 1 << ((int)obj->sda & 0xfU) & 0xffff;\n        uVar5 = pinmap_function(obj->sda,(PinMap_conflict *)PTR_PinMap_I2C_SDA_08007a74);\n        uVar6 = pinmap_function(obj->sda,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Mode = (uVar5 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Speed = 3;\n        uVar5 = pinmap_function(obj->sda,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Pull = (uVar5 << 0x1a) >> 0x1e;\n        uVar5 = pinmap_function(obj->sda,(PinMap_conflict *)puVar1);\n        *(uint *)(DAT_08007a84 + 0x18) = *(uint *)(DAT_08007a84 + 0x18) | 1;\n        switch((uVar5 << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x4000000;\n        }\n        HAL_GPIO_Init(pGVar4,&GPIO_InitStruct);\n        (obj->handle).Instance = obj->i2c;\n        (obj->handle).Init.ClockSpeed = timing;\n        (obj->handle).Init.DutyCycle = 0;\n        (obj->handle).Init.OwnAddress1 = ownAddress;\n        (obj->handle).Init.OwnAddress2 = 0xff;\n        (obj->handle).Init.AddressingMode = addressingMode;\n        (obj->handle).Init.DualAddressMode = 0;\n        (obj->handle).Init.GeneralCallMode = 0;\n        (obj->handle).Init.NoStretchMode = 0;\n        (obj->handle).State = HAL_I2C_STATE_RESET;\n        HAL_NVIC_SetPriority(obj->irq,0,1);\n        HAL_NVIC_EnableIRQ(obj->irq);\n        HAL_NVIC_SetPriority(obj->irqER,0,1);\n        HAL_NVIC_EnableIRQ(obj->irqER);\n        HAL_I2C_Init(hi2c);\n        obj->isMaster = master;\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority",
                "iprintf",
                "set_GPIO_Port_Clock",
                "pinmap_merge_peripheral",
                "HAL_GPIO_Init",
                "pinmap_function",
                "HAL_I2C_Init",
                "pinmap_peripheral"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080077b0",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "FUNC_080077b0"
        },
        "FUN_08008c44": {
            "renaming": {
                "FUN_08008c44": "setSerialConfiguration_08008c44",
                "this": "serial",
                "baud": "baudrate",
                "config": "config",
                "bVar1": "configMask",
                "iVar2": "databits",
                "_serial": "_serial",
                "PTR_s__home_bo__arduino15_packages_STM_08008cfc": "PTR_s__home_bo__arduino15_packages_STM_08008cfc",
                "DAT_08008cf0": "receiveData"
            },
            "code": "void __thiscall setSerialConfiguration_08008c44(HardwareSerial *serial, ulong baudrate, byte config) {\n  byte configMask = config & 7;\n  int databits = 0;\n  int parity = 0;\n  int stopbits = 0;\n  if (configMask == 4) {\n    databits = 7;\n  }\n  else if (configMask == 6) {\n    databits = 8;\n  }\n  else if (configMask == 2) {\n    databits = 6;\n  }\n  if ((config & 0x30) == 0x30) {\n    parity = 0x600;\n    databits++;\n  }\n  else if ((config & 0x20) == 0) {\n    parity = 0;\n  }\n  else {\n    parity = 0x400;\n    databits++;\n  }\n  if ((config & 8) == 0) {\n    stopbits = 0;\n  }\n  else {\n    stopbits = 0x2000;\n  }\n  if (databits != 0) {\n    (serial->_serial).baudrate = baudrate;\n    (serial->_serial).databits = databits == 8 ? 0 : (databits == 9 ? 0x1000 : 0);\n    (serial->_serial).parity = parity;\n    (serial->_serial).stopbits = stopbits;\n    uart_init((serial_t *)&serial->_serial);\n    uart_attach_rx_callback((serial_t *)&serial->_serial, DAT_08008cf0);\n    return;\n  }\n  __assert_func(PTR_s__home_bo__arduino15_packages_STM_08008cfc,299,PTR___PRETTY_FUNCTION___08008cf8, PTR_s_databits__0_08008cf4);\n}",
            "called": [
                "uart_attach_rx_callback",
                "uart_init",
                "__assert_func"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008c44",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "setSerialConfiguration_08008c44"
        },
        "FUN_08006060": {
            "renaming": {
                "FUN_08006060": "configureTimer_08006060",
                "htim": "timer",
                "State": "state",
                "Lock": "lock",
                "HAL_TIM_OC_MspInit": "HAL_TIM_OC_MspInit",
                "Instance": "instance",
                "Init": "init",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_TIM_STATE_RESET": "HAL_TIM_STATE_RESET",
                "HAL_TIM_STATE_BUSY": "HAL_TIM_STATE_BUSY",
                "HAL_TIM_STATE_READY": "HAL_TIM_STATE_READY",
                "HAL_OK": "HAL_OK",
                "HAL_ERROR": "HAL_ERROR"
            },
            "code": "HAL_StatusTypeDef configureTimer_08006060(TIM_HandleTypeDef *timer)\n{\n  if (timer != NULL) {\n    if (timer->state == HAL_TIM_STATE_RESET) {\n      timer->lock = HAL_UNLOCKED;\n      HAL_TIM_OC_MspInit(timer);\n    }\n    timer->state = HAL_TIM_STATE_BUSY;\n    TIM_Base_SetConfig(timer->instance, &timer->init);\n    timer->state = HAL_TIM_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}",
            "called": [
                "HAL_TIM_OC_MspInit",
                "TIM_Base_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006060",
            "calling": [
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "configureTimer_08006060"
        },
        "FUN_08009698": {
            "renaming": {
                "FUN_08009698": "FUNC_08009698"
            },
            "code": "\nuint FUNC_08009698(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  byte bVar1;\n  int iVar2;\n  uint *puVar3;\n  void *pvVar4;\n  int iVar5;\n  undefined *puVar6;\n  uint uVar7;\n  uint **ppuVar8;\n  uint uVar9;\n  uint uVar10;\n  undefined *puVar11;\n  undefined *__s;\n  uint local_24 [2];\n  \n  bVar1 = *(byte *)(param_2 + 6);\n  __s = (undefined *)((int)param_2 + 0x43);\n  if (bVar1 != 0x6e) {\n    if (bVar1 < 0x6f) {\n      if (bVar1 != 99) {\n        if (bVar1 < 100) {\n          if (bVar1 == 0) goto LAB_08009852;\n          if (bVar1 != 0x58) goto LAB_080096c8;\n          *(undefined *)((int)param_2 + 0x45) = 0x58;\n          puVar6 = PTR_s_0123456789ABCDEF_080098d4;\nLAB_080097e2:\n          uVar7 = *param_2;\n          puVar3 = *param_5;\n          *param_5 = puVar3 + 1;\n          if (((uVar7 & 0x80) == 0) && ((int)(uVar7 << 0x19) < 0)) {\n            uVar9 = (uint)*(ushort *)puVar3;\n          }\n          else {\n            uVar9 = *puVar3;\n          }\n          if ((int)(uVar7 << 0x1f) < 0) {\n            *param_2 = uVar7 | 0x20;\n          }\n          if (uVar9 == 0) {\n            *param_2 = *param_2 & 0xffffffdf;\n          }\n          uVar7 = 0x10;\nLAB_08009778:\n          *(undefined *)((int)param_2 + 0x43) = 0;\n        }\n        else {\n          if ((bVar1 != 100) && (bVar1 != 0x69)) goto LAB_080096c8;\n          uVar9 = *param_2;\n          puVar3 = *param_5;\n          if ((uVar9 & 0x80) == 0) {\n            *param_5 = puVar3 + 1;\n            if ((uVar9 & 0x40) == 0) goto LAB_080096e8;\n            uVar9 = (uint)(short)*(ushort *)puVar3;\n          }\n          else {\n            *param_5 = puVar3 + 1;\nLAB_080096e8:\n            uVar9 = *puVar3;\n          }\n          if ((int)uVar9 < 0) {\n            uVar9 = -uVar9;\n            *(undefined *)((int)param_2 + 0x43) = 0x2d;\n          }\n          uVar7 = 10;\n          puVar6 = PTR_s_0123456789ABCDEF_080098d4;\n        }\n        uVar10 = param_2[1];\n        param_2[2] = uVar10;\n        puVar11 = __s;\n        if ((int)uVar10 < 0) {\n          if (uVar9 != 0) goto LAB_08009816;\nLAB_080098c4:\n          *(undefined *)((int)param_2 + 0x42) = *puVar6;\n          puVar11 = (undefined *)((int)param_2 + 0x42);\n        }\n        else {\n          *param_2 = *param_2 & 0xfffffffb;\n          if (uVar9 == 0) {\n            if (uVar10 != 0) goto LAB_080098c4;\n          }\n          else {\nLAB_08009816:\n            do {\n              uVar10 = uVar9 / uVar7;\n              puVar11 = puVar11 + -1;\n              *puVar11 = puVar6[uVar9 - uVar7 * uVar10];\n              uVar9 = uVar10;\n            } while (uVar10 != 0);\n          }\n        }\n        if (((uVar7 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4]))\n        {\n          puVar11[-1] = 0x30;\n          puVar11 = puVar11 + -1;\n        }\n        param_2[4] = (int)__s - (int)puVar11;\n        __s = puVar11;\n        goto LAB_080097be;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      *(char *)((int)param_2 + 0x42) = (char)*puVar3;\nLAB_08009728:\n      __s = (undefined *)((int)param_2 + 0x42);\n      uVar9 = 1;\n    }\n    else {\n      if (bVar1 != 0x73) {\n        if (bVar1 < 0x74) {\n          if (bVar1 == 0x6f) {\nLAB_0800974e:\n            uVar9 = *param_2;\n            puVar3 = *param_5;\n            if ((uVar9 & 0x80) == 0) {\n              *param_5 = puVar3 + 1;\n              if ((uVar9 & 0x40) == 0) goto LAB_0800975c;\n              uVar9 = (uint)*(ushort *)puVar3;\n            }\n            else {\n              *param_5 = puVar3 + 1;\nLAB_0800975c:\n              uVar9 = *puVar3;\n            }\n            puVar6 = PTR_s_0123456789ABCDEF_080098d4;\n            if (bVar1 == 0x6f) {\n              uVar7 = 8;\n            }\n            else {\n              uVar7 = 10;\n            }\n            goto LAB_08009778;\n          }\n          if (bVar1 == 0x70) {\n            *param_2 = *param_2 | 0x20;\nLAB_0800970e:\n            puVar6 = PTR_s_0123456789abcdef_080098d0;\n            *(undefined *)((int)param_2 + 0x45) = 0x78;\n            goto LAB_080097e2;\n          }\n        }\n        else {\n          if (bVar1 == 0x75) goto LAB_0800974e;\n          if (bVar1 == 0x78) goto LAB_0800970e;\n        }\nLAB_080096c8:\n        *(byte *)((int)param_2 + 0x42) = bVar1;\n        goto LAB_08009728;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      __s = (undefined *)*puVar3;\n      pvVar4 = memchr(__s,0,param_2[1]);\n      if (pvVar4 != (void *)0x0) {\n        param_2[1] = (int)pvVar4 - (int)__s;\n      }\n      uVar9 = param_2[1];\n    }\n    param_2[4] = uVar9;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_080097be;\n  }\n  uVar9 = *param_2;\n  ppuVar8 = (uint **)*param_5;\n  uVar7 = param_2[5];\n  if ((uVar9 & 0x80) == 0) {\n    *param_5 = (uint *)(ppuVar8 + 1);\n    puVar3 = *ppuVar8;\n    if ((uVar9 & 0x40) == 0) goto LAB_0800983e;\n    *(short *)puVar3 = (short)uVar7;\n  }\n  else {\n    *param_5 = (uint *)(ppuVar8 + 1);\n    puVar3 = *ppuVar8;\nLAB_0800983e:\n    *puVar3 = uVar7;\n  }\nLAB_08009852:\n  param_2[4] = 0;\nLAB_080097be:\n  iVar2 = _printf_common(param_1,param_2,local_24,param_3,param_4);\n  if ((iVar2 == -1) || (iVar2 = (*param_4)(param_1,param_3,__s,param_2[4]), iVar2 == -1)) {\nLAB_080097d2:\n    uVar9 = 0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar2 = 0; iVar2 < (int)(param_2[3] - local_24[0]); iVar2 = iVar2 + 1) {\n        iVar5 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar5 == -1) goto LAB_080097d2;\n      }\n    }\n    uVar9 = param_2[3];\n    if ((int)param_2[3] < (int)local_24[0]) {\n      uVar9 = local_24[0];\n    }\n  }\n  return uVar9;\n}\n\n",
            "called": [
                "memchr",
                "_printf_common"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08009698",
            "calling": [
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "FUNC_08009698"
        },
        "FUN_08006186": {
            "renaming": {
                "FUN_08006186": "set_timer_output_compare_08006186",
                "htim": "timer_handle",
                "sConfig": "output_config",
                "Channel": "channel",
                "Lock": "lock_status",
                "State": "state",
                "CCMR1": "capture_compare_mode_register_1",
                "Instance": "timer_instance",
                "OCFastMode": "output_compare_fast_mode"
            },
            "code": "HAL_StatusTypeDef set_timer_output_compare_08006186(TIM_HandleTypeDef *timer_handle, TIM_OC_InitTypeDef *output_config, uint32_t channel) {\n  if (timer_handle->lock_status != HAL_LOCKED) {\n    timer_handle->lock_status = HAL_LOCKED;\n    timer_handle->state = HAL_TIM_STATE_BUSY;\n    switch(channel) {\n      case 0:\n        TIM_OC1_SetConfig(timer_handle->Instance, output_config);\n        timer_handle->Instance->CCMR1 |= 8;\n        timer_handle->Instance->CCMR1 &= 0xfffffffb;\n        timer_handle->Instance->CCMR1 |= output_config->OCFastMode;\n        break;\n      case 4:\n        TIM_OC2_SetConfig(timer_handle->Instance, output_config);\n        timer_handle->Instance->CCMR1 |= 0x800;\n        timer_handle->Instance->CCMR1 &= 0xfffffbff;\n        timer_handle->Instance->CCMR1 |= output_config->OCFastMode << 8;\n        break;\n      case 8:\n        TIM_OC3_SetConfig(timer_handle->Instance, output_config);\n        timer_handle->Instance->CCMR2 |= 8;\n        timer_handle->Instance->CCMR2 &= 0xfffffffb;\n        timer_handle->Instance->CCMR2 |= output_config->OCFastMode;\n        break;\n      case 0xc:\n        TIM_OC4_SetConfig(timer_handle->Instance, output_config);\n        timer_handle->Instance->CCMR2 |= 0x800;\n        timer_handle->Instance->CCMR2 &= 0xfffffbff;\n        timer_handle->Instance->CCMR2 |= output_config->OCFastMode << 8;\n    }\n    timer_handle->state = HAL_TIM_STATE_READY;\n    timer_handle->lock_status = HAL_UNLOCKED;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}",
            "called": [
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC2_SetConfig",
                "TIM_OC4_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006186",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "set_timer_output_compare_08006186"
        },
        "FUN_08006b7c": {
            "renaming": {
                "FUN_08006b7c": "get_gpio_type_def_08006b7c",
                "port_idx": "port_index",
                "DAT_08006ba4": "gpio_type_def_0",
                "DAT_08006bb4": "gpio_type_def_1",
                "DAT_08006ba8": "gpio_type_def_2",
                "DAT_08006bac": "gpio_type_def_3",
                "DAT_08006bb0": "gpio_type_def_4"
            },
            "code": "GPIO_TypeDef* get_gpio_type_def_08006b7c(uint32_t port_index) {\n    switch(port_index) {\n        case 0:\n            return DAT_08006ba4;\n        case 1:\n            return DAT_08006bb4;\n        case 2:\n            return DAT_08006ba8;\n        case 3:\n            return DAT_08006bac;\n        case 4:\n            return DAT_08006bb0;\n        default:\n            return (GPIO_TypeDef*)0x0;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b7c",
            "calling": [
                "digitalWrite",
                "digitalRead"
            ],
            "imported": false,
            "current_name": "get_gpio_type_def_08006b7c"
        },
        "FUN_08008e7c": {
            "renaming": {
                "__thiscall Print::FUN_08008e7c": "printUnsigned",
                "this": "print",
                "n": "number",
                "base": "base",
                "cVar1": "digit",
                "sVar2": "length",
                "sVar3": "result",
                "uVar4": "remainder",
                "uVar5": "baseNumber",
                "uVar6": "quotient",
                "__s": "currentDigit",
                "buf": "buffer",
                "FUN_08008e7c": "Print::printUnsigned_08008e7c"
            },
            "code": "size_t Print::printUnsigned_08008e7c(Print *print, ulong number, uint8_t base) {\n  char digit;\n  size_t length = 0;\n  char buffer[33];\n  uint baseNumber = (uint)base;\n  buffer[32] = '\\0';\n  if (baseNumber < 2) {\n    baseNumber = 10;\n  }\n  char *currentDigit = buffer + 0x20;\n  do {\n    uint quotient = number / baseNumber;\n    uint remainder = (number & 0xff) - (quotient * baseNumber & 0xff) & 0xff;\n    currentDigit--;\n    digit = (char)remainder;\n    if (remainder < 10) {\n      digit += '0';\n    }\n    else {\n      digit += '7';\n    }\n    *currentDigit = digit;\n    number = quotient;\n    length++;\n  } while (quotient != 0);\n  if (currentDigit == (char *)0x0) {\n    return 0;\n  }\n  else {\n    size_t result = (*this->_vptr_Print[1])(length, currentDigit, length);\n    return result;\n  }\n}",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e7c",
            "calling": [
                "print"
            ],
            "imported": false,
            "current_name": "Print::printUnsigned_08008e7c"
        },
        "FUN_0800a194": {
            "renaming": {
                "std::ctype_byname<char>::FUN_0800a194": "set_pointers_to_one",
                "PTR_id_0800a228": "id_one",
                "PTR_id_0800a22c": "id_two",
                "PTR_id_0800a230": "id_three",
                "PTR_id_0800a234": "id_four",
                "PTR_id_0800a238": "id_five",
                "PTR_id_0800a23c": "id_six",
                "PTR_id_0800a240": "id_seven",
                "PTR_id_0800a244": "id_eight",
                "PTR_id_0800a248": "id_nine",
                "PTR_id_0800a24c": "id_ten",
                "PTR_id_0800a250": "id_eleven",
                "PTR_id_0800a254": "id_twelve",
                "FUN_0800a194": "set_pointers_to_one_0800a194"
            },
            "code": "void set_pointers_to_one_0800a194(void)\n{\n  if (*(int *)PTR_id_0800a228 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a228 = 1;\n  }\n  if (*(int *)PTR_id_0800a22c << 0x1f) {\n    *(undefined4 *)PTR_id_0800a22c = 1;\n  }\n  if (*(int *)PTR_id_0800a230 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a230 = 1;\n  }\n  if (*(int *)PTR_id_0800a234 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a234 = 1;\n  }\n  if (*(int *)PTR_id_0800a238 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a238 = 1;\n  }\n  if (*(int *)PTR_id_0800a23c << 0x1f) {\n    *(undefined4 *)PTR_id_0800a23c = 1;\n  }\n  if (*(int *)PTR_id_0800a240 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a240 = 1;\n  }\n  if (*(int *)PTR_id_0800a244 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a244 = 1;\n  }\n  if (*(int *)PTR_id_0800a248 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a248 = 1;\n  }\n  if (*(int *)PTR_id_0800a24c << 0x1f) {\n    *(undefined4 *)PTR_id_0800a24c = 1;\n  }\n  if (*(int *)PTR_id_0800a250 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a250 = 1;\n  }\n  if (*(int *)PTR_id_0800a254 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a254 = 1;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a194",
            "calling": [],
            "imported": false,
            "current_name": "set_pointers_to_one_0800a194"
        },
        "FUN_08003aa0": {
            "renaming": {
                "FUN_08003aa0": "enable_ADC_08003aa0",
                "hadc": "adc",
                "HVar1": "status",
                "pAVar2": "instance"
            },
            "code": "HAL_StatusTypeDef_conflict enable_ADC_08003aa0(ADC_HandleTypeDef *adc)\n{\n  HAL_StatusTypeDef_conflict status;\n  ADC_TypeDef *instance;\n  \n  if (adc->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  adc->Lock = HAL_LOCKED;\n  status = ADC_Enable(adc);\n  if (status == HAL_OK) {\n    adc->State = (adc->State & 0xfffffcfe) | 0x100;\n    instance = adc->Instance;\n    if ((instance == PTR_08003b84) && ((PTR_08003b84[-0xd].JOFR1 & 0xf0000) != 0)) {\n      adc->State |= 0x100000;\n      if ((*(uint *)(PTR_08003b88 + 4) & 0x400) != 0) {\n        adc->State = (adc->State & 0xffffcfff) | 0x1000;\n      }\n    }\n    else {\n      adc->State &= 0xffefffff;\n      if ((instance->CR1 & 0x400) != 0) {\n        adc->State = (adc->State & 0xffffcfff) | 0x1000;\n      }\n    }\n    if ((adc->State & 0x1000) == 0) {\n      adc->ErrorCode = 0;\n    }\n    else {\n      adc->ErrorCode &= 0xfffffff9;\n    }\n    adc->Lock = HAL_UNLOCKED;\n    instance->SR = 0xfffffffd;\n    instance = adc->Instance;\n    if (((instance->CR2 & 0xe0000) == 0xe0000) && ((instance != PTR_08003b84) || ((PTR_08003b84[-0xd].JOFR1 & 0xf0000) == 0))) {\n      instance->CR2 |= 0x500000;\n    }\n    else {\n      instance->CR2 |= 0x100000;\n    }\n  }\n  else {\n    adc->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}",
            "called": [
                "ADC_Enable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003aa0",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "enable_ADC_08003aa0"
        },
        "FUN_08005fe8": {
            "renaming": {
                "FUN_08005fe8": "configureTimer_08005fe8",
                "TIMx": "timer",
                "Structure": "config",
                "uVar1": "cr1",
                "DAT_0800605c": "timer1",
                "TIM_TypeDef_conflict": "TIM_TypeDef",
                "TIM_Base_InitTypeDef_conflict": "TIM_Base_InitTypeDef"
            },
            "code": "void configureTimer_08005fe8(TIM_TypeDef_conflict *timer, TIM_Base_InitTypeDef_conflict *config) {\n  uint32_t cr1 = timer->CR1;\n  if (timer == DAT_0800605c || timer == timer2 || timer == timer3 || timer == timer4) {\n    cr1 = (cr1 & 0xffffff8f) | config->CounterMode;\n  }\n  if (timer == DAT_0800605c || timer == timer2 || timer == timer3 || timer == timer4) {\n    cr1 = (cr1 & 0xfffffcff) | config->ClockDivision;\n  }\n  timer->CR1 = (cr1 & 0xffffff7f) | config->AutoReloadPreload;\n  timer->ARR = config->Period;\n  timer->PSC = config->Prescaler;\n  if (timer == DAT_0800605c) {\n    timer->RCR = config->RepetitionCounter;\n  }\n  timer->EGR = 1;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005fe8",
            "calling": [
                "HAL_TIM_OC_Init",
                "HAL_TIM_PWM_Init"
            ],
            "imported": false,
            "current_name": "configureTimer_08005fe8"
        },
        "FUN_08003ce8": {
            "renaming": {
                "FUN_08003ce8": "stop_and_disable_conversion_08003ce8",
                "hadc": "adc",
                "HVar1": "status",
                "HAL_ERROR": "HAL_ERROR",
                "ADC_STATE_READY": "ADC_STATE_READY",
                "ADC_CR1_RESET_VALUE": "ADC_CR1_RESET_VALUE",
                "ADC_CR2_RESET_VALUE": "ADC_CR2_RESET_VALUE",
                "ADC_StateTypeDef": "ADC_StateTypeDef",
                "ADC_HandleTypeDef": "ADC_HandleTypeDef",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef_conflict"
            },
            "code": "HAL_StatusTypeDef_conflict stop_and_disable_conversion_08003ce8(ADC_HandleTypeDef *adc)\n{\n  HAL_StatusTypeDef_conflict status;\n  if (adc == NULL) {\n    status = HAL_ERROR;\n  }\n  else {\n    adc->State |= ADC_STATE_READY;\n    status = ADC_ConversionStop_Disable(adc);\n    if (status == HAL_OK) {\n      adc->Instance->SR = 0xffffffe0;\n      adc->Instance->CR1 = ADC_CR1_RESET_VALUE & adc->Instance->CR1;\n      adc->Instance->CR2 = ADC_CR2_RESET_VALUE & adc->Instance->CR2;\n      adc->Instance->SMPR1 &= 0xff000000;\n      adc->Instance->SMPR2 &= 0xc0000000;\n      adc->Instance->JOFR1 &= 0xfffff000;\n      adc->Instance->JOFR2 &= 0xfffff000;\n      adc->Instance->JOFR3 &= 0xfffff000;\n      adc->Instance->JOFR4 &= 0xfffff000;\n      adc->Instance->HTR &= 0xfffff000;\n      adc->Instance->LTR &= 0xfffff000;\n      adc->Instance->SQR1 &= 0xff000000;\n      adc->Instance->SQR2 &= 0xc0000000;\n      adc->Instance->SQR3 &= 0xc0000000;\n      adc->Instance->JSQR &= 0xffc00000;\n      HAL_ADC_MspDeInit(adc);\n      adc->ErrorCode = 0;\n      adc->State = ADC_STATE_RESET;\n    }\n    adc->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}",
            "called": [
                "HAL_ADC_MspDeInit",
                "ADC_ConversionStop_Disable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003ce8",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "stop_and_disable_conversion_08003ce8"
        },
        "FUN_0800738a": {
            "renaming": {
                "FUN_0800738a": "check_pin_validity_0800738a",
                "pin": "pin_name",
                "map": "pin_map",
                "NC": "not_connected",
                "true": "VALID",
                "false": "INVALID"
            },
            "code": "_Bool check_pin_validity_0800738a(PinName_conflict pin, PinMap_conflict *pin_map) {\n  if (pin == NC) {\n    return false;\n  }\n  while(pin_map->pin != NC) {\n    if (pin == pin_map->pin) {\n      return true;\n    }\n    pin_map++;\n  }\n  return false;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800738a",
            "calling": [
                "analogWrite",
                "pinMode",
                "sysexCallback",
                "enableI2CPins",
                "analogWriteCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "check_pin_validity_0800738a"
        },
        "FUN_08002948": {
            "renaming": {
                "FUN_08002948": "initializeWire_08002948",
                "__initialize_p": "shouldInitialize",
                "__priority": "priorityLevel"
            },
            "code": "void initializeWire_08002948(int shouldInitialize, int priorityLevel) {\n  if (shouldInitialize != 1) {\n    return;\n  }\n  if (priorityLevel == 0xffff) {\n    TwoWire::TwoWire((TwoWire *)PTR_Wire_08002964);\n  }\n  return;\n}",
            "called": [
                "TwoWire"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002948",
            "calling": [
                "_GLOBAL__sub_I__ZN7TwoWire8rxBufferE"
            ],
            "imported": false,
            "current_name": "initializeWire_08002948"
        },
        "FUN_08009e64": {
            "renaming": {
                "FUN_08009e64": "check_file_permissions_08009e64",
                "param_1": "file_descriptor",
                "param_2": "file_info_offset",
                "param_3": "permission_result",
                "param_4": "error_code",
                "iVar1": "status",
                "uVar2": "is_executable",
                "auStack_4c": "file_mode",
                "local_48": "local_48"
            },
            "code": "int check_file_permissions_08009e64(int file_descriptor, int file_info_offset, int* permission_result, uint* error_code)\n{\n  int status;\n  int file_mode;\n  uint is_executable;\n  \n  if ((*(short *)(file_info_offset + 0xe) < 0) ||\n     (status = _fstat_r(file_descriptor, (int)*(short *)(file_info_offset + 0xe), &file_mode), status < 0)) {\n    *error_code = 0;\n    if ((int)((uint)*(ushort *)(file_info_offset + 0xc) << 0x18) < 0) {\n      is_executable = 0x40;\n      goto LAB_08009ea4;\n    }\n  }\n  else {\n    is_executable = (uint)((file_mode & 0xf000) == 0x2000);\n  }\n  \n  is_executable = 0x400;\nLAB_08009ea4:\n  *permission_result = is_executable;\n  return 0;\n}",
            "called": [
                "_fstat_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009e64",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_file_permissions_08009e64"
        },
        "FUN_08002acc": {
            "renaming": {
                "TwoWire::FUN_08002acc": "allocate_rx_buffer",
                "length": "buffer_length",
                "puVar1": "rx_buffer_ptr",
                "pvVar2": "new_buffer_ptr",
                "uVar3": "buffer_length_byte",
                "PTR_rxBuffer_08002afc": "rx_buffer_allocated_ptr",
                "*PTR_rxBuffer_08002afc": "*(void **)rx_buffer_allocated_ptr",
                "PTR_rxBufferAllocated_08002af8": "rx_buffer_length_ptr",
                "*PTR_rxBufferAllocated_08002af8": "*(byte *)rx_buffer_length_ptr",
                "FUN_08002acc": "allocate_rx_buffer_08002acc"
            },
            "code": "void allocate_rx_buffer_08002acc(size_t buffer_length)\n{\n  undefined *rx_buffer_ptr;\n  void *new_buffer_ptr;\n  undefined buffer_length_byte;\n  rx_buffer_ptr = PTR_rxBuffer_08002afc;\n  if ((byte)*PTR_rxBufferAllocated_08002af8 < buffer_length) {\n    if (buffer_length < 0x20) {\n      buffer_length = 0x20;\n    }\n    new_buffer_ptr = realloc(*(void **)rx_buffer_ptr, buffer_length);\n    *(void **)rx_buffer_ptr = new_buffer_ptr;\n    if (new_buffer_ptr == (void *)0x0) {\n      buffer_length_byte = 0;\n    }\n    else {\n      buffer_length_byte = (undefined)buffer_length;\n    }\n    *PTR_rxBufferAllocated_08002af8 = buffer_length_byte;\n  }\n  return;\n}",
            "called": [
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002acc",
            "calling": [
                "requestFrom",
                "onReceiveService"
            ],
            "imported": false,
            "current_name": "allocate_rx_buffer_08002acc"
        },
        "FUN_0800932c": {
            "renaming": {
                "FUN_0800932c": "write_byte_to_buffer_0800932c",
                "param_1": "buffer_start",
                "param_2": "byte_to_write",
                "param_3": "buffer_ptr",
                "uVar1": "result",
                "pbVar2": "current_buffer_ptr"
            },
            "code": "uint write_byte_to_buffer_0800932c(uint buffer_start, byte byte_to_write, byte **buffer_ptr)\n{\n  uint result;\n  byte *current_buffer_ptr;\n  current_buffer_ptr = *buffer_ptr;\n  *buffer_ptr = current_buffer_ptr + 1;\n  *current_buffer_ptr = byte_to_write;\n  if (((int)(*buffer_ptr)[2] + -1 < 0) && (((int)(*buffer_ptr)[2] + -1 < (int)(*buffer_ptr)[6] || (byte_to_write == 10)))) {\n    result = __swbuf_r();\n    return result;\n  }\n  result = (uint)byte_to_write;\n  return result;\n}",
            "called": [
                "__swbuf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800932c",
            "calling": [
                "__sfputs_r"
            ],
            "imported": false,
            "current_name": "write_byte_to_buffer_0800932c"
        },
        "FUN_080099a4": {
            "renaming": {
                "FUN_080099a4": "find_substring_080099a4",
                "__haystack": "haystack",
                "__needle": "needle",
                "pcVar1": "current_haystack",
                "pcVar2": "current_needle",
                "pcVar3": "temp_needle"
            },
            "code": "char* find_substring_080099a4(char* haystack, char* needle)\n{\n  char* current_haystack = haystack;\n  char* current_needle;\n  if (*current_haystack == '\\0') {\n    if (*needle != '\\0') {\n      current_haystack = NULL;\n    }\n    return current_haystack;\n  }\n  while (true) {\n    current_needle = needle;\n    while (*current_haystack != '\\0' && *current_needle != '\\0' && *current_haystack == *current_needle) {\n      current_haystack++;\n      current_needle++;\n    }\n    if (*current_needle == '\\0') {\n      return current_haystack - (current_needle - needle);\n    }\n    if (*current_haystack == '\\0') {\n      return NULL;\n    }\n    current_haystack++;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080099a4",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "find_substring_080099a4"
        },
        "FUN_08005a1c": {
            "renaming": {
                "FUN_08005a1c": "getSystemCoreClock_08005a1c",
                "*PTR_SystemCoreClock_08005a24": "*systemCoreClockPtr"
            },
            "code": "uint32_t getSystemCoreClock_08005a1c(void)\n{\n  uint32_t *PTR_SystemCoreClock_08005a24 = PTR_SystemCoreClock_08005a24;\n  return *PTR_SystemCoreClock_08005a24;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a1c",
            "calling": [
                "HAL_RCC_GetPCLK2Freq",
                "SystemClock_Config",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "imported": false,
            "current_name": "getSystemCoreClock_08005a1c"
        },
        "FUN_08006b0c": {
            "renaming": {
                "FUN_08006b0c": "reset_uart_transfer_counts_08006b0c",
                "hdma": "dma_handle",
                "huart": "uart_handle",
                "RxXferCount": "rx_transfer_count",
                "TxXferCount": "tx_transfer_count",
                "HAL_UART_ErrorCallback": "error_callback"
            },
            "code": "void reset_uart_transfer_counts_08006b0c(DMA_HandleTypeDef_conflict *dma_handle)\n{\n  UART_HandleTypeDef *uart_handle;\n  uart_handle = (UART_HandleTypeDef *)dma_handle->Parent;\n  uart_handle->RxXferCount = 0;\n  uart_handle->TxXferCount = 0;\n  HAL_UART_ErrorCallback(uart_handle);\n  return;\n}",
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b0c",
            "calling": [],
            "imported": false,
            "current_name": "reset_uart_transfer_counts_08006b0c"
        },
        "FUN_08001cd0": {
            "renaming": {
                "FUN_08001cd0": "FUNC_08001cd0"
            },
            "code": "\nvoid FUNC_08001cd0(byte command,byte argc,byte *argv)\n\n{\n  byte bVar1;\n  uint8_t address;\n  byte bVar2;\n  byte bVar3;\n  byte bVar4;\n  byte bVar5;\n  char cVar6;\n  undefined *puVar7;\n  undefined *this;\n  PinName_conflict PVar8;\n  _Bool _Var9;\n  byte bVar10;\n  uint32_t uVar11;\n  uint uVar12;\n  int iVar13;\n  int iVar14;\n  char cVar15;\n  uint uVar16;\n  int iVar17;\n  bool bVar18;\n  \n  this = PTR_Firmata_080022e8;\n  puVar7 = PTR_Firmata_08002044;\n  uVar16 = (uint)argc;\n  switch(command) {\n  case 'i':\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf0);\n    firmata::FirmataClass::write((FirmataClass *)this,'j');\n    for (uVar16 = 0; uVar16 < 0x3c; uVar16 = uVar16 + 1 & 0xff) {\n      uVar12 = uVar16 - 0x2e & 0xff;\n      bVar10 = (byte)uVar12;\n      if (uVar12 < 0xe) {\n        if (uVar16 < 0x3c) {\n          PVar8 = PTR_digitalPin_080022e4[uVar16];\n        }\n        else {\n          PVar8 = NC;\n        }\n        uVar11 = pinNametoDigitalPin(PVar8);\n        if (uVar11 == 0) {\n          bVar10 = '\\x7f';\n        }\n        else {\n          if (uVar16 < 0x3c) {\n            PVar8 = PTR_digitalPin_080022e4[uVar16];\n          }\n          else {\n            PVar8 = NC;\n          }\n          uVar11 = pinNametoDigitalPin(PVar8);\n          if (uVar11 == 1) {\n            bVar10 = '\\x7f';\n          }\n        }\n      }\n      else {\n        bVar10 = '\\x7f';\n      }\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,bVar10);\n    }\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf7);\n    break;\n  case 'k':\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_08002044,0xf0);\n    firmata::FirmataClass::write((FirmataClass *)puVar7,'l');\n    for (uVar16 = 0; uVar16 < 0x3c; uVar16 = uVar16 + 1 & 0xff) {\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          bVar18 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            bVar18 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_08002060[uVar16]);\n            if (uVar11 == 1) {\n              bVar18 = false;\n            }\n            else {\n              bVar18 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      puVar7 = PTR_Firmata_08002044;\n      if (bVar18) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_08002044,'\\0');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\v');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n      }\n      if ((uVar16 - 0x2e & 0xff) < 0xe) {\n        if (uVar16 < 0x3c) {\n          PVar8 = PTR_digitalPin_08002060[uVar16];\n        }\n        else {\n          PVar8 = NC;\n        }\n        uVar11 = pinNametoDigitalPin(PVar8);\n        if (uVar11 == 0) {\n          bVar18 = false;\n        }\n        else {\n          if (uVar16 < 0x3c) {\n            PVar8 = PTR_digitalPin_08002060[uVar16];\n          }\n          else {\n            PVar8 = NC;\n          }\n          uVar11 = pinNametoDigitalPin(PVar8);\n          if (uVar11 == 1) {\n            bVar18 = false;\n          }\n          else {\n            bVar18 = true;\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (bVar18) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x02');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\n');\n      }\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          _Var9 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            _Var9 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n            if (uVar11 == 1) {\n              _Var9 = false;\n            }\n            else {\n              _Var9 = pin_in_pinmap(PTR_digitalPin_080022e4[uVar16],\n                                    (PinMap_conflict *)PTR_PinMap_PWM_080022ec);\n            }\n          }\n        }\n      }\n      else {\n        _Var9 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (_Var9 != false) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x03');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\b');\n      }\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          bVar18 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            bVar18 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n            if (uVar11 == 1) {\n              bVar18 = false;\n            }\n            else {\n              bVar18 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (bVar18) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x04');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x0e');\n      }\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          _Var9 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            _Var9 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n            if (uVar11 == 1) {\n              _Var9 = false;\n            }\n            else {\n              _Var9 = pin_in_pinmap(PTR_digitalPin_080022e4[uVar16],\n                                    (PinMap_conflict *)PTR_PinMap_I2C_SDA_080022f0);\n              if (!_Var9) {\n                _Var9 = pin_in_pinmap(PTR_digitalPin_080022e4[uVar16],\n                                      (PinMap_conflict *)PTR_PinMap_I2C_SCL_080022f4);\n              }\n            }\n          }\n        }\n      }\n      else {\n        _Var9 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (_Var9 != false) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x06');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n      }\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x7f');\n    }\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf7);\n    return;\n  case 'm':\n    if (uVar16 != 0) {\n      bVar1 = *argv;\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf0);\n      firmata::FirmataClass::write((FirmataClass *)this,'n');\n      firmata::FirmataClass::write((FirmataClass *)this,bVar1);\n      if (bVar1 < 0x3c) {\n        bVar10 = firmata::FirmataClass::getPinMode((FirmataClass *)this,bVar1);\n        firmata::FirmataClass::write((FirmataClass *)this,bVar10);\n        iVar13 = firmata::FirmataClass::getPinState((FirmataClass *)this,bVar1);\n        firmata::FirmataClass::write((FirmataClass *)this,(byte)iVar13 & 0x7f);\n        uVar16 = firmata::FirmataClass::getPinState((FirmataClass *)this,bVar1);\n        if ((uVar16 & 0xff80) != 0) {\n          iVar13 = firmata::FirmataClass::getPinState((FirmataClass *)this,bVar1);\n          firmata::FirmataClass::write((FirmataClass *)this,(byte)((uint)(iVar13 << 0x12) >> 0x19));\n        }\n        uVar16 = firmata::FirmataClass::getPinState((FirmataClass *)PTR_Firmata_080022e8,bVar1);\n        puVar7 = PTR_Firmata_080022e8;\n        if ((uVar16 & 0xc000) != 0) {\n          iVar13 = firmata::FirmataClass::getPinState((FirmataClass *)PTR_Firmata_080022e8,bVar1);\n          firmata::FirmataClass::write((FirmataClass *)puVar7,(byte)((uint)(iVar13 << 0xb) >> 0x19))\n          ;\n        }\n      }\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf7);\n      return;\n    }\n    break;\n  case 'o':\n    if (1 < uVar16) {\n      uVar12 = (uint)argv[1];\n      if (2 < uVar16) {\n        uVar12 = uVar12 | (uint)argv[2] << 7;\n      }\n      if (3 < uVar16) {\n        uVar12 = uVar12 | (uint)argv[3] << 0xe;\n      }\n      analogWriteCallback(*argv,uVar12);\n      return;\n    }\n    break;\n  case 'p':\n    if (4 < uVar16) {\n      bVar1 = *argv;\n      uVar16 = (uint)bVar1;\n      bVar2 = argv[1];\n      bVar3 = argv[2];\n      bVar4 = argv[3];\n      bVar5 = argv[4];\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_08002060[uVar16] == NC) {\n          bVar18 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_08002060[uVar16]);\n          if (uVar11 == 0) {\n            bVar18 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_08002060[uVar16]);\n            if (uVar11 == 1) {\n              bVar18 = false;\n            }\n            else {\n              bVar18 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      if (bVar18) {\n        if ((byte)PTR_servoPinMap_08002064[uVar16] < 0xc) {\n          bVar18 = Servo::attached((Servo *)(PTR_servos_08002068 +\n                                            (uint)(byte)PTR_servoPinMap_08002064[uVar16] * 3));\n        }\n        else {\n          bVar18 = false;\n        }\n        if (bVar18 != false) {\n          detachServo(bVar1);\n        }\n        attachServo(bVar1,(uint)bVar2 + (uint)bVar3 * 0x80,(uint)bVar4 + (uint)bVar5 * 0x80);\n        setPinModeCallback(bVar1,4);\n        return;\n      }\n    }\n    break;\n  case 'v':\n    bVar1 = argv[1];\n    if ((bVar1 & 0x20) != 0) {\n      firmata::FirmataClass::sendString\n                ((FirmataClass *)PTR_Firmata_08002044,PTR_s_10_bit_addressing_not_supported_08002040\n                );\n      return;\n    }\n    address = *argv;\n    bVar18 = (bVar1 & 0x40) == 0;\n    if ((bVar1 & 0x18) < 0x19) {\n      switch(bVar1 & 0x18) {\n      case 0:\n        TwoWire::beginTransmission((TwoWire *)PTR_Wire_08002048,address);\n        for (uVar12 = 2; uVar12 < uVar16; uVar12 = uVar12 + 2 & 0xff) {\n          wireWrite(argv[uVar12 + 1] * -0x80 + argv[uVar12]);\n        }\n        TwoWire::endTransmission((TwoWire *)PTR_Wire_08002048);\n        return;\n      case 8:\n        if (uVar16 == 6) {\n          iVar13 = (uint)argv[2] + (uint)argv[3] * 0x80;\n          bVar10 = argv[4] + argv[5] * -0x80;\n        }\n        else {\n          bVar10 = argv[2] + argv[3] * -0x80;\n          iVar13 = -1;\n        }\n        readAndReportData(address,iVar13,bVar10,bVar18);\n        return;\n      case 0x10:\n        if ((char)*PTR_queryIndex_0800204c + 1 < 8) {\n          if (uVar16 == 6) {\n            iVar13 = (uint)argv[2] + (uint)argv[3] * 0x80;\n            cVar15 = argv[4] + argv[5] * -0x80;\n          }\n          else {\n            cVar15 = argv[2] + argv[3] * -0x80;\n            iVar13 = -1;\n          }\n          cVar6 = *PTR_queryIndex_0800204c + '\\x01';\n          *PTR_queryIndex_0800204c = cVar6;\n          puVar7 = PTR_query_08002050;\n          iVar14 = cVar6 * 0xc;\n          PTR_query_08002050[iVar14] = address;\n          *(int *)(puVar7 + iVar14 + 4) = iVar13;\n          puVar7[iVar14 + 8] = cVar15;\n          puVar7[iVar14 + 9] = bVar18;\n          return;\n        }\n        firmata::FirmataClass::sendString\n                  ((FirmataClass *)PTR_Firmata_08002044,PTR_s_too_many_queries_08002054);\n        return;\n      case 0x18:\n        cVar15 = *PTR_queryIndex_0800204c;\n        if (cVar15 < 1) {\n          *PTR_queryIndex_0800204c = 0xff;\n          return;\n        }\n      }\n      for (uVar16 = 0; iVar13 = cVar15 + 1, (int)uVar16 < iVar13; uVar16 = uVar16 + 1 & 0xff) {\n        if (address == PTR_query_08002050[uVar16 * 0xc]) goto LAB_08001e66;\n      }\n      uVar16 = 0;\nLAB_08001e66:\n      for (; puVar7 = PTR_query_08002050, (int)uVar16 < iVar13; uVar16 = uVar16 + 1 & 0xff) {\n        if (uVar16 < 8) {\n          iVar14 = (uVar16 + 1) * 0xc;\n          iVar17 = uVar16 * 0xc;\n          PTR_query_08002050[iVar17] = PTR_query_08002050[iVar14];\n          *(undefined4 *)(puVar7 + iVar17 + 4) = *(undefined4 *)(puVar7 + iVar14 + 4);\n          puVar7[iVar17 + 8] = puVar7[iVar14 + 8];\n          puVar7[iVar17 + 9] = puVar7[iVar14 + 9];\n        }\n      }\n      *PTR_queryIndex_0800204c = cVar15 + -1;\n      return;\n    }\n    break;\n  case 'x':\n    iVar13 = (uint)*argv + (uint)argv[1] * 0x80;\n    if ((1 < uVar16) && (iVar13 != 0)) {\n      *(int *)PTR_i2cReadDelayTime_08002058 = iVar13;\n    }\n    if (*PTR_isI2CEnabled_0800205c == '\\0') {\n      enableI2CPins();\n      return;\n    }\n    break;\n  case 'z':\n    if ((1 < uVar16) &&\n       (iVar13 = (uint)*argv + (uint)argv[1] * 0x80, *(int *)PTR_samplingInterval_0800206c = iVar13,\n       iVar13 == 0)) {\n      *(undefined4 *)PTR_samplingInterval_0800206c = 1;\n      return;\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "detachServo",
                "endTransmission",
                "attachServo",
                "readAndReportData",
                "beginTransmission",
                "analogWriteCallback",
                "setPinModeCallback",
                "write",
                "pinNametoDigitalPin",
                "attached",
                "wireWrite",
                "sendString",
                "getPinMode",
                "enableI2CPins",
                "getPinState",
                "pin_in_pinmap"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08001cd0",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_08001cd0"
        },
        "FUN_08007320": {
            "renaming": {
                "FUN_08007320": "find_peripheral_08007320",
                "pin": "pin_name",
                "map": "pin_map",
                "pvVar1": "peripheral",
                "NC": "NOT_CONNECTED"
            },
            "code": "void* find_peripheral_08007320(PinName_conflict pin, PinMap_conflict* map) {\n  void* peripheral = NULL;\n  if (pin != NC) {\n    peripheral = pinmap_find_peripheral_08007320(pin, map);\n  }\n  return peripheral;\n}",
            "called": [
                "pinmap_find_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007320",
            "calling": [
                "pwm_stop",
                "i2c_custom_init",
                "pwm_start",
                "uart_init",
                "adc_read_value",
                "uart_debug_init",
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "find_peripheral_08007320"
        },
        "FUN_080002ec": {
            "renaming": {
                "FUN_080002ec": "setPins_080002ec",
                "port": "portNumber",
                "value": "pinValues",
                "bVar1": "isPinValid",
                "bVar2": "pinMode",
                "uVar3": "portIndex",
                "uVar4": "digitalPin",
                "iVar5": "pinState",
                "pin": "pinIndex",
                "ulPin": "pinOffset",
                "ulPin_00": "portOffset",
                "uVar6": "maskBit",
                "uVar7": "pinOffsetMax",
                "uVar8": "pinMaskEnabled"
            },
            "code": "void setPins_080002ec(byte port, int value) {\n  bool isPinValid;\n  byte pinIndex;\n  uint32_t pinMask;\n  int pinState;\n  byte pin;\n  uint32_t pinOffset;\n  uint32_t pinOffsetMax;\n  uint32_t pinMaskEnabled = 0;\n  uint32_t maskBit = 1;\n  uint32_t portOffset = (uint32_t)port * 8;\n  if (port < 5) {\n    pinOffsetMax = (portOffset + 8) > 60 ? 60 : (portOffset + 8);\n    for (pinOffset = portOffset; pinOffset < pinOffsetMax; pinOffset++) {\n      if (PTR_digitalPin_08000480[pinOffset] == NC) {\n        isPinValid = false;\n      } else {\n        pin = pinNametoDigitalPin(PTR_digitalPin_08000480[pinOffset]);\n        if (pin == 0 || pin == 1) {\n          isPinValid = false;\n        } else {\n          isPinValid = true;\n        }\n      }\n      if (isPinValid) {\n        pinIndex = (byte)pinOffset;\n        byte pinMode = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000484, pinIndex);\n        if (pinMode == OUTPUT || pinMode == INPUT_PULLUP) {\n          if (maskBit & value) {\n            pinMaskEnabled |= maskBit;\n            if (pinMode == OUTPUT) {\n              pinMode(pinOffset, OUTPUT);\n            }\n            pinState = maskBit;\n          } else if (pinMode == INPUT_PULLUP && firmata::FirmataClass::getPinState((FirmataClass *)PTR_Firmata_08000484, pinIndex) == 1) {\n            pinState = 1;\n          } else {\n            pinState = 0;\n          }\n          firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_08000484, pinIndex, pinState);\n        }\n      }\n      maskBit <<= 1;\n    }\n    for (pinOffset = portOffset; pinOffset < pinOffsetMax; pinOffset++) {\n      if (pinMaskEnabled & maskBit) {\n        digitalWrite(pinOffset, value & maskBit);\n      }\n      maskBit <<= 1;\n    }\n  }\n}",
            "called": [
                "pinNametoDigitalPin",
                "digitalWrite",
                "pinMode",
                "getPinMode",
                "getPinState",
                "setPinState"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080002ec",
            "calling": [],
            "imported": false,
            "current_name": "setPins_080002ec"
        },
        "FUN_08000be8": {
            "renaming": {
                "FUN_08000be8": "sendDigitalPortIfChanged_08000be8",
                "portNumber": "portNumber",
                "portValue": "portValue",
                "forceSend": "forceSend",
                "PTR_portConfigInputs_08000c0c": "portConfigInputs",
                "bVar1": "maskedPortValue",
                "PTR_previousPINs_08000c10": "previousPINs",
                "PTR_Firmata_08000c14": "Firmata"
            },
            "code": "void sendDigitalPortIfChanged_08000be8(byte portNumber, byte portValue, byte forceSend){\n  byte portConfigInput = PTR_portConfigInputs_08000c0c[portNumber];\n  byte maskedPortValue = portConfigInput & portValue;\n  if (forceSend || (maskedPortValue != PTR_previousPINs_08000c10[portNumber])) {\n    PTR_Firmata_08000c14.sendDigitalPort(portNumber, maskedPortValue);\n    PTR_previousPINs_08000c10[portNumber] = maskedPortValue;\n  }\n  return;\n}",
            "called": [
                "sendDigitalPort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000be8",
            "calling": [
                "checkDigitalInputs",
                "reportDigitalCallback"
            ],
            "imported": false,
            "current_name": "sendDigitalPortIfChanged_08000be8"
        },
        "FUN_08003fd8": {
            "renaming": {
                "FUN_08003fd8": "calculate_ticks_difference_08003fd8",
                "TicksNumb": "ticks_number",
                "puVar1": "ticks_pointer",
                "DAT_08003ffc": "ticks_array",
                "DAT_08004000": "memory_address"
            },
            "code": "uint32_t calculate_ticks_difference_08003fd8(uint32_t ticks_number) {\n  undefined4 *ticks_pointer;\n  ticks_pointer = DAT_08003ffc;\n  if (ticks_number - 1 < 0x1000000) {\n    DAT_08003ffc[1] = ticks_number - 1;\n    *(undefined *)(DAT_08004000 + 0x23) = 0xf0;\n    ticks_pointer[2] = 0;\n    *ticks_pointer = 7;\n    return 0;\n  }\n  return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fd8",
            "calling": [
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "imported": false,
            "current_name": "calculate_ticks_difference_08003fd8"
        },
        "FUN_0800307a": {
            "renaming": {
                "FUN_0800307a": "encodeAndSend_0800307a",
                "this": "marshaller",
                "bytec": "byte_count",
                "bytev": "bytes",
                "max_bytes": "max_bytes",
                "uVar1": "current_byte",
                "uVar2": "current_bit",
                "uVar3": "encoded_byte_count",
                "uVar4": "i"
            },
            "code": "void __thiscall encodeAndSend_0800307a(FirmataMarshaller *marshaller, size_t byte_count, uint8_t *bytes, size_t max_bytes) {\n  uint8_t current_byte = *bytes;\n  if (max_bytes == 0) {\n    max_bytes = SIZE_MAX;\n  }\n  uint8_t current_bit = 0;\n  uint32_t encoded_byte = 0;\n  uint32_t encoded_byte_count = 0;\n  for (size_t i = 0; i < byte_count && encoded_byte_count < max_bytes; i++) {\n    encoded_byte |= ((uint32_t)bytes[i] << current_bit) | current_byte;\n    current_byte = (uint8_t)(bytes[i] >> (7 - current_bit));\n    current_bit++;\n    while (current_bit > 6 && encoded_byte_count < max_bytes) {\n      marshaller->FirmataStream->write(encoded_byte & 0x7F);\n      encoded_byte >>= 7;\n      current_bit -= 7;\n      encoded_byte_count++;\n    }\n  }\n  if (current_bit != 0 && encoded_byte_count < max_bytes) {\n    marshaller->FirmataStream->write((1 << current_bit) - 1U & encoded_byte);\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800307a",
            "calling": [
                "sendDigitalPort",
                "sendSysex",
                "sendExtendedAnalog",
                "sendFirmwareVersion",
                "sendAnalog"
            ],
            "imported": false,
            "current_name": "encodeAndSend_0800307a"
        },
        "FUN_08004b80": {
            "renaming": {
                "FUN_08004b80": "do_nothing_08004b80"
            },
            "code": "\nvoid do_nothing_08004b80(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004b80",
            "calling": [
                "I2C_MasterTransmit_TXE",
                "I2C_MasterTransmit_BTF"
            ],
            "imported": false,
            "current_name": "do_nothing_08004b80"
        },
        "FUN_08002ca4": {
            "renaming": {
                "FUN_08002ca4": "sendStringCallback_08002ca4",
                "param_1": "callback",
                "c_str": "stringToSend",
                "PTR_currentStringCallback_08002cb4": "currentStringCallback"
            },
            "code": "void sendStringCallback_08002ca4(void *callback,char *stringToSend)\n{\n  if (*(code **)PTR_currentStringCallback_08002cb4 != (code *)0x0) {\n    (**(code **)PTR_currentStringCallback_08002cb4)(stringToSend);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ca4",
            "calling": [],
            "imported": false,
            "current_name": "sendStringCallback_08002ca4"
        },
        "FUN_0800319e": {
            "renaming": {
                "FUN_0800319e": "sendPortData_0800319e",
                "portNumber": "portNumber",
                "portData": "portData",
                "local_a": "localPortData",
                "this->FirmataStream": "this->stream",
                "(Stream *)0x0": "nullptr",
                "(this->FirmataStream->super_Print)._vptr_Print": "this->stream->print",
                "encodeByteStream": "encodeByteStream"
            },
            "code": "void __thiscall sendPortData_0800319e(FirmataMarshaller *this, uint8_t portNumber, uint16_t portData)\n{\n  uint16_t localPortData;\n  if (this->FirmataStream != nullptr) {\n    localPortData = portData;\n    (**(this->FirmataStream->super_Print)._vptr_Print)(this, portNumber & 0xf | 0x90);\n    encodeByteStream(this, 2, (uint8_t *)&localPortData, 2);\n  }\n  return;\n}",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800319e",
            "calling": [
                "sendDigitalPort"
            ],
            "imported": false,
            "current_name": "sendPortData_0800319e"
        },
        "FUN_08008d00": {
            "renaming": {
                "FUN_08008d00": "setRxPin_08008d00",
                "_rx": "rxPin",
                "PVar1": "pin",
                "PTR_digitalPin_08008d14": "digitalPinNames"
            },
            "code": "void __thiscall setRxPin_08008d00(HardwareSerial *this,uint32_t rxPin)\n{\n  PinName pin;\n  if (rxPin < 0x3c) {\n    pin = PTR_digitalPin_08008d14[rxPin];\n  }\n  else {\n    pin = NC;\n  }\n  (this->_serial).pin_rx = pin;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d00",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "setRxPin_08008d00"
        },
        "FUN_08004b82": {
            "renaming": {
                "FUN_08004b82": "i2c_transfer_08004b82",
                "hi2c": "handle",
                "HVar1": "state",
                "pbVar2": "buffer",
                "uVar3": "options"
            },
            "code": "HAL_StatusTypeDef i2c_transfer_08004b82(I2C_HandleTypeDef *handle)\n{\n  HAL_I2C_StateTypeDef state = handle->State;\n  uint32_t options = handle->XferOptions;\n  \n  if ((handle->XferSize == 0) && (state == HAL_I2C_STATE_BUSY_TX)) {\n    if ((options == 4) || ((options == 8 || (options == 0xffff0000)))) {\n      handle->Instance->CR2 = handle->Instance->CR2 & 0xfffff8ff;\n      handle->Instance->CR1 = handle->Instance->CR1 | 0x200;\n      handle->PreviousState = 0;\n      handle->State = HAL_I2C_STATE_READY;\n      if (handle->Mode == HAL_I2C_MODE_MEM) {\n        handle->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(handle);\n      }\n      else {\n        handle->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(handle);\n      }\n    }\n    else {\n      handle->Instance->CR2 = handle->Instance->CR2 & 0xfffff8ff;\n      handle->PreviousState = 0x11;\n      handle->Mode = HAL_I2C_MODE_NONE;\n      handle->State = HAL_I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(handle);\n    }\n  }\n  else if ((state == HAL_I2C_STATE_BUSY_TX) || ((handle->Mode == HAL_I2C_MODE_MEM && (state == HAL_I2C_STATE_BUSY_RX)))) {\n    if (handle->XferCount == 0) {\n      handle->Instance->CR2 = handle->Instance->CR2 & 0xfffffbff;\n    }\n    else if (handle->Mode == HAL_I2C_MODE_MEM) {\n      if (handle->EventCount == 0) {\n        if (handle->MemaddSize == 1) {\n          handle->Instance->DR = handle->Memaddress & 0xff;\n          handle->EventCount = handle->EventCount + 2;\n        }\n        else {\n          handle->Instance->DR = (handle->Memaddress << 0x10) >> 0x18;\n          handle->EventCount = handle->EventCount + 1;\n        }\n      }\n      else if (handle->EventCount == 1) {\n        handle->Instance->DR = handle->Memaddress & 0xff;\n        handle->EventCount = handle->EventCount + 1;\n      }\n      else if (handle->EventCount == 2) {\n        if (state == HAL_I2C_STATE_BUSY_RX) {\n          handle->Instance->CR1 = handle->Instance->CR1 | 0x100;\n        }\n        else if (state == HAL_I2C_STATE_BUSY_TX) {\n          uint8_t *buffer = handle->pBuffPtr;\n          handle->pBuffPtr = buffer + 1;\n          handle->Instance->DR = (uint)*buffer;\n          handle->XferCount = handle->XferCount - 1;\n        }\n      }\n    }\n    else {\n      uint8_t *buffer = handle->pBuffPtr;\n      handle->pBuffPtr = buffer + 1;\n      handle->Instance->DR = (uint)*buffer;\n      handle->XferCount = handle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MasterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004b82",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_transfer_08004b82"
        },
        "FUN_0800997e": {
            "renaming": {
                "FUN_0800997e": "find_last_occurrence_of_char_0800997e",
                "__s": "str",
                "__c": "c",
                "pcVar1": "occurrence",
                "pcVar2": "last_occurrence"
            },
            "code": "char* find_last_occurrence_of_char_0800997e(char* str, int c) {\n  char* last_occurrence = NULL;\n  if (c != 0) {\n    while (char* occurrence = strchr(str, c)) {\n      last_occurrence = occurrence;\n      str = occurrence + 1;\n    }\n    return last_occurrence;\n  }\n  return strchr(str, 0);\n}",
            "called": [
                "strchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800997e",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "find_last_occurrence_of_char_0800997e"
        },
        "FUN_0800779c": {
            "renaming": {
                "FUN_0800779c": "handle_timer_interrupt_0800779c",
                "PTR_timer_handles_080077ac": "PTR_timer_handles",
                "TIM_HandleTypeDef_conflict": "Timer_HandleTypeDef"
            },
            "code": "void handle_timer_interrupt_0800779c(void)\n{\n  TIM_HandleTypeDef_conflict *timer_handle = *(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_080077ac_080077ac + 0xc);\n  if (timer_handle != NULL) {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800779c",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_0800779c"
        },
        "FUN_08002dbc": {
            "renaming": {
                "FUN_08002dbc": "initializeFirmata_08002dbc",
                "__initialize_p": "shouldInitialize",
                "__priority": "priorityLevel"
            },
            "code": "void initializeFirmata_08002dbc(int shouldInitialize, int priorityLevel) {\n  if (shouldInitialize != 1) {\n    return;\n  }\n  if (priorityLevel == 0xffff) {\n    firmata::FirmataClass::FirmataClass((FirmataClass *)PTR_Firmata_08002dd8);\n  }\n  return;\n}",
            "called": [
                "FirmataClass"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002dbc",
            "calling": [
                "_GLOBAL__sub_I_Firmata"
            ],
            "imported": false,
            "current_name": "initializeFirmata_08002dbc"
        },
        "FUN_08007f78": {
            "renaming": {
                "FUN_08007f78": "get_i2c_statistics_08007f78",
                "hi2c": "hi2c_handle",
                "i2c_t_conflict": "i2c_stats_t",
                "EventCount": "event_count",
                "ErrorCount": "error_count"
            },
            "code": "typedef struct {\n  uint32_t EventCount;\n  uint32_t ErrorCount;\n} i2c_stats_t;\ni2c_stats_t * get_i2c_statistics_08007f78(I2C_HandleTypeDef * hi2c) {\n  return (i2c_stats_t *)&hi2c[-1].Instance->ISR;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f78",
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_AddrCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "imported": false,
            "current_name": "get_i2c_statistics_08007f78"
        },
        "FUN_08006b28": {
            "renaming": {
                "FUN_08006b28": "is_pin_high_08006b28",
                "pin": "pin_name",
                "map": "pin_map"
            },
            "code": "_Bool is_pin_high_08006b28(PinName_conflict pin, uint32_t *pin_map) {\n    uint32_t pin_value = map[(uint32_t)pin << 24 >> 28];\n    uint32_t pin_mask = (uint32_t)1 << (pin & 0xf);\n    return (_Bool)(pin_value & pin_mask);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b28",
            "calling": [
                "digitalWrite",
                "analogWrite",
                "pinMode",
                "digitalRead"
            ],
            "imported": false,
            "current_name": "is_pin_high_08006b28"
        },
        "FUN_08006b1c": {
            "renaming": {
                "FUN_08006b1c": "get_uart_rx_and_global_state_08006b1c",
                "*huart": "*uart_handler",
                "RxState": "rx_state",
                "gState": "global_state"
            },
            "code": "HAL_UART_StateTypeDef get_uart_rx_and_global_state_08006b1c(UART_HandleTypeDef *huart) {\n  HAL_UART_StateTypeDef rx_state = huart->RxState;\n  HAL_UART_StateTypeDef global_state = huart->gState;\n  return rx_state | global_state;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b1c",
            "calling": [
                "serial_rx_active",
                "serial_tx_active"
            ],
            "imported": false,
            "current_name": "get_uart_rx_and_global_state_08006b1c"
        },
        "FUN_0800a130": {
            "renaming": {
                "FUN_0800a130": "seek_file_and_set_error_0800a130",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "offset",
                "param_4": "whence",
                "puVar1": "error_ptr",
                "iVar2": "seek_result"
            },
            "code": "void seek_file_and_set_error_0800a130(int *error_code, int file_descriptor, int offset, int whence)\n{\n  int seek_result;\n  int *error_ptr;\n  error_ptr = PTR_errno_0800a150;\n  *(int *)PTR_errno_0800a150 = 0;\n  seek_result = _lseek(file_descriptor, offset, whence);\n  if ((seek_result == -1) && (*error_ptr != 0)) {\n    *error_code = *error_ptr;\n  }\n  return;\n}",
            "called": [
                "_lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a130",
            "calling": [
                "__swrite",
                "__sseek"
            ],
            "imported": false,
            "current_name": "seek_file_and_set_error_0800a130"
        },
        "FUN_08008f3c": {
            "renaming": {
                "FUN_08008f3c": "count_bits_set_in_binary_representation_08008f3c",
                "pin": "num",
                "uVar1": "temp",
                "uVar2": "count"
            },
            "code": "uint8_t count_bits_set_in_binary_representation_08008f3c(uint16_t num) {\n  uint16_t temp = num;\n  uint8_t count = 0;\n  while(temp != 0) {\n    if(temp & 1) {\n      count++;\n    }\n    temp = temp >> 1;\n  }\n  return count;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f3c",
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "imported": false,
            "current_name": "count_bits_set_in_binary_representation_08008f3c"
        },
        "FUN_08002ef2": {
            "renaming": {
                "FUN_08002ef2": "sendPinValue_08002ef2",
                "this": "self",
                "pin": "pin_number",
                "value": "pin_value",
                "FirmataMarshaller::FUN_08002ef2": "sendPinValue",
                "&this->marshaller": "&marshaller"
            },
            "code": "void __thiscall sendPinValue_08002ef2(byte pin, int value)\n{\n  FirmataMarshaller::sendPinValue_08002ef2(&marshaller, pin, (uint16_t)value);\n  return;\n}",
            "called": [
                "sendAnalog"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ef2",
            "calling": [
                "reportAnalogCallback",
                "loop"
            ],
            "imported": false,
            "current_name": "sendPinValue_08002ef2"
        },
        "FUN_08007332": {
            "renaming": {
                "FUN_08007332": "find_pin_name_08007332",
                "PinName_conflict": "PinName",
                "peripheral": "device",
                "PinMap_conflict": "PinMap",
                "map": "map"
            },
            "code": "PinName find_pin_name_08007332(void *device, PinMap *map) {\n    while (true) {\n        if (map->device == (void *)0x0) {\n            return NC;\n        }\n        if (map->device == device) {\n            break;\n        }\n        map = map + 1;\n    }\n    return map->pin;\n}",
            "called": [
                "pinmap_find_pin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007332",
            "calling": [
                "pinmap_pin",
                "pinmap_find_pin"
            ],
            "imported": false,
            "current_name": "find_pin_name_08007332"
        },
        "FUN_08006128": {
            "renaming": {
                "FUN_08006128": "set_timer_output_compare_08006128",
                "TIM_HandleTypeDef_conflict": "TIM_HandleTypeDef",
                "htim": "timer_handle",
                "sConfig": "output_config",
                "Channel": "channel",
                "Lock": "lock",
                "State": "state",
                "HAL_LOCKED": "HAL_LOCKED",
                "HAL_TIM_STATE_BUSY": "HAL_TIM_STATE_BUSY",
                "HAL_TIM_STATE_READY": "HAL_TIM_STATE_READY",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "TIM_OC1_SetConfig": "TIM_OC1_SetConfig",
                "TIM_OC2_SetConfig": "TIM_OC2_SetConfig",
                "TIM_OC3_SetConfig": "TIM_OC3_SetConfig",
                "TIM_OC4_SetConfig": "TIM_OC4_SetConfig",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "htim->Lock": "timer_handle->lock",
                "htim->State": "timer_handle->state"
            },
            "code": "HAL_StatusTypeDef set_timer_output_compare_08006128(TIM_HandleTypeDef *timer_handle, TIM_OC_InitTypeDef *output_config, uint32_t channel) {\n  if (timer_handle->lock != HAL_LOCKED) {\n    timer_handle->lock = HAL_LOCKED;\n    timer_handle->state = HAL_TIM_STATE_BUSY;\n    switch (channel) {\n      case 0:\n        TIM_OC1_SetConfig(timer_handle->instance, output_config);\n        break;\n      case 4:\n        TIM_OC2_SetConfig(timer_handle->instance, output_config);\n        break;\n      case 8:\n        TIM_OC3_SetConfig(timer_handle->instance, output_config);\n        break;\n      case 0xc:\n        TIM_OC4_SetConfig(timer_handle->instance, output_config);\n    }\n    timer_handle->state = HAL_TIM_STATE_READY;\n    timer_handle->lock = HAL_UNLOCKED;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}",
            "called": [
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC2_SetConfig",
                "TIM_OC4_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006128",
            "calling": [
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "set_timer_output_compare_08006128"
        },
        "FUN_0800a258": {
            "renaming": {
                "std::ctype_byname<wchar_t>::FUN_0800a258": "set_ctype_flags",
                "PTR_id_0800a2ec": "&id_1",
                "PTR_id_0800a2f0": "&id_2",
                "PTR_id_0800a2f4": "&id_3",
                "PTR_id_0800a2f8": "&id_4",
                "PTR_id_0800a2fc": "&id_5",
                "PTR_id_0800a300": "&id_6",
                "PTR_id_0800a304": "&id_7",
                "PTR_id_0800a308": "&id_8",
                "PTR_id_0800a30c": "&id_9",
                "PTR_id_0800a310": "&id_10",
                "PTR_id_0800a314": "&id_11",
                "PTR_id_0800a318": "&id_12",
                "FUN_0800a258": "set_ctype_flags_0800a258"
            },
            "code": "void set_ctype_flags_0800a258() {\n  if (is_flag_set(PTR_id_0800a2ec)) {\n    set_flag(PTR_id_0800a2ec);\n  }\n  if (is_flag_set(PTR_id_0800a2f0)) {\n    set_flag(PTR_id_0800a2f0);\n  }\n  if (is_flag_set(PTR_id_0800a2f4)) {\n    set_flag(PTR_id_0800a2f4);\n  }\n  if (is_flag_set(PTR_id_0800a2f8)) {\n    set_flag(PTR_id_0800a2f8);\n  }\n  if (is_flag_set(PTR_id_0800a2fc)) {\n    set_flag(PTR_id_0800a2fc);\n  }\n  if (is_flag_set(PTR_id_0800a300)) {\n    set_flag(PTR_id_0800a300);\n  }\n  if (is_flag_set(PTR_id_0800a304)) {\n    set_flag(PTR_id_0800a304);\n  }\n  if (is_flag_set(PTR_id_0800a308)) {\n    set_flag(PTR_id_0800a308);\n  }\n  if (is_flag_set(PTR_id_0800a30c)) {\n    set_flag(PTR_id_0800a30c);\n  }\n  if (is_flag_set(PTR_id_0800a310)) {\n    set_flag(PTR_id_0800a310);\n  }\n  if (is_flag_set(PTR_id_0800a314)) {\n    set_flag(PTR_id_0800a314);\n  }\n  if (is_flag_set(PTR_id_0800a318)) {\n    set_flag(PTR_id_0800a318);\n  }\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a258",
            "calling": [],
            "imported": false,
            "current_name": "set_ctype_flags_0800a258"
        },
        "FUN_08002cb8": {
            "renaming": {
                "FUN_08002cb8": "handleSysex_08002cb8",
                "param_1": "sysexCallback",
                "PTR_currentSysexCallback_08002ccc": "sysexCallback",
                "command": "command",
                "argc": "argc",
                "argv": "argv"
            },
            "code": "void handleSysex_08002cb8(void *PTR_currentSysexCallback_08002ccc, uint8_t command, size_t argc, uint8_t *argv) {\n  if (*(code **)PTR_currentSysexCallback_08002ccc != (code *)0x0) {\n    (**(code **)PTR_currentSysexCallback_08002ccc)(command, argc & 0xff, argv, argv, argv);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002cb8",
            "calling": [],
            "imported": false,
            "current_name": "handleSysex_08002cb8"
        },
        "FUN_08004a74": {
            "renaming": {
                "FUN_08004a74": "do_nothing_08004a74"
            },
            "code": "\nvoid do_nothing_08004a74(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a74",
            "calling": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a74"
        },
        "FUN_08008f50": {
            "renaming": {
                "FUN_08008f50": "free_gpio_irq_configurations_08008f50",
                "param_1": "list_start",
                "puVar1": "list_end",
                "puVar2": "current_node",
                "PTR___malloc_free_list_08008f70": "list_start",
                "PTR_gpio_irq_conf_08008f74": "list_end"
            },
            "code": "void free_gpio_irq_configurations_08008f50(void *PTR___malloc_free_list_08008f70)\n{\n  void *current_node = PTR___malloc_free_list_08008f70;\n  while (current_node != PTR_gpio_irq_conf_08008f74) {\n    void *previous_node = current_node - 0x14;\n    if (*(code **)(current_node - 8) != (code *)0x0) {\n      (**(code **)(current_node - 8))(current_node - 0x10, current_node - 0x10, 3);\n    }\n    current_node = previous_node;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f50",
            "calling": [],
            "imported": false,
            "current_name": "free_gpio_irq_configurations_08008f50"
        },
        "FUN_08004a76": {
            "renaming": {
                "FUN_08004a76": "transfer_data_08004a76",
                "hi2c": "i2c_handle",
                "HVar1": "current_state",
                "puVar2": "data_ptr"
            },
            "code": "HAL_StatusTypeDef_conflict transfer_data_08004a76(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  HAL_I2C_StateTypeDef_conflict current_state = i2c_handle->State;\n  if (i2c_handle->XferCount != 0) {\n    uint8_t *data_ptr = i2c_handle->pBuffPtr;\n    i2c_handle->pBuffPtr = data_ptr + 1;\n    *data_ptr = (uint8_t)i2c_handle->Instance->DR;\n    i2c_handle->XferCount--;\n    if ((i2c_handle->XferCount == 0) && (current_state == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2c_handle->Instance->CR2 &= 0xfffffbff;\n      i2c_handle->PreviousState = 0x22;\n      i2c_handle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveRxCpltCallback(i2c_handle);\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a76",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "transfer_data_08004a76"
        },
        "FUN_0800877c": {
            "renaming": {
                "FUN_0800877c": "initialize_uart_0800877c",
                "huart": "uart_handle",
                "tmpval": "register_value"
            },
            "code": "void initialize_uart_0800877c(UART_HandleTypeDef *uart_handle)\n{\n  uint32_t register_value;\n\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800877c",
            "calling": [
                "UART_DMAAbortOnError",
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "initialize_uart_0800877c"
        },
        "FUN_080047f4": {
            "renaming": {
                "FUN_080047f4": "i2c_transfer_080047f4",
                "hi2c": "handle",
                "DevAddress": "device_address",
                "pData": "data",
                "Size": "size",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "I2C_TypeDef_conflict": "I2C_TypeDef",
                "count": "count",
                "PTR_SystemCoreClock_080048bc": "SYS_CLK_PTR",
                "DAT_080048c0": "PRESCALER",
                "DAT_080048c4": "OPTIONS",
                "HVar1": "status",
                "pIVar2": "instance"
            },
            "code": "HAL_StatusTypeDef i2c_transfer_080047f4(I2C_HandleTypeDef *handle, uint16_t device_address, uint8_t *data, uint16_t size)\n{\n  HAL_StatusTypeDef status;\n  I2C_TypeDef *instance;\n  uint32_t count;\n  \n  if (handle->State == HAL_I2C_STATE_READY) {\n    count = (uint32_t)((uint64_t)DAT_080048c0 * (uint64_t)(*(uint32_t *)PTR_SystemCoreClock_080048bc >> 3) >> 0x28) * 0x19;\n    do {\n      if (count == 0) {\n        handle->PreviousState = 0;\n        handle->State = HAL_I2C_STATE_READY;\n        handle->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      instance = handle->Instance;\n      count--;\n    } while ((instance->SR2 & 2) != 0);\n    if (handle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      handle->Lock = HAL_LOCKED;\n      if ((instance->CR1 & 1) == 0) {\n        instance->CR1 |= 1;\n      }\n      handle->Instance->CR1 &= 0xfffff7ff;\n      handle->State = HAL_I2C_STATE_BUSY_RX;\n      handle->Mode = HAL_I2C_MODE_MASTER;\n      status = HAL_OK;\n      handle->ErrorCode = 0;\n      handle->pBuffPtr = data;\n      handle->XferCount = size;\n      handle->XferOptions = DAT_080048c4;\n      handle->XferSize = handle->XferCount;\n      handle->Devaddress = (uint16_t)device_address;\n      handle->Instance->CR1 |= 0x400;\n      handle->Instance->CR1 |= 0x100;\n      handle->Lock = HAL_UNLOCKED;\n      handle->Instance->CR2 |= 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080047f4",
            "calling": [
                "i2c_master_read"
            ],
            "imported": false,
            "current_name": "i2c_transfer_080047f4"
        },
        "FUN_08005a48": {
            "renaming": {
                "FUN_08005a48": "get_HCLK_frequency_divider_08005a48",
                "uVar1": "HCLK_frequency",
                "PTR_APBPrescTable_08005a64": "HCLK_frequency_divider_table",
                "DAT_08005a60": "APB_prescaler_register_address",
                "APB_prescaler_index": "APB_prescaler_index"
            },
            "code": "uint32_t get_HCLK_frequency_divider_08005a48(void)\n{\n  uint32_t HCLK_frequency = HAL_RCC_GetHCLKFreq();\n  uint32_t APB_prescaler_index = (uint)(*(int *)(DAT_08005a60 + 4) << 0x12) >> 0x1d;\n  uint32_t HCLK_frequency_divider = PTR_APBPrescTable_08005a64[APB_prescaler_index];\n  return HCLK_frequency / HCLK_frequency_divider;\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a48",
            "calling": [
                "getTimerClkFreq",
                "HAL_RCCEx_GetPeriphCLKFreq",
                "UART_SetConfig"
            ],
            "imported": false,
            "current_name": "get_HCLK_frequency_divider_08005a48"
        },
        "FUN_080033a8": {
            "renaming": {
                "FUN_080033a8": "decode_and_combine_bytes_080033a8",
                "this": "this",
                "bytec": "byte_count",
                "bytev": "byte_array",
                "bVar1": "current_byte",
                "sVar2": "combined_byte_count",
                "uVar3": "i"
            },
            "code": "size_t __thiscall decode_and_combine_bytes_080033a8(FirmataParser *this,size_t byte_count,uint8_t *byte_array)\n{\n  byte current_byte;\n  size_t combined_byte_count = 0;\n  for (uint i = 0; i < byte_count; i = i + 2) {\n    current_byte = byte_array[i];\n    byte_array[combined_byte_count] = current_byte;\n    byte_array[combined_byte_count] = byte_array[i + 1] << 7 | current_byte;\n    combined_byte_count = combined_byte_count + 1;\n  }\n  return combined_byte_count;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080033a8",
            "calling": [
                "processSysexMessage"
            ],
            "imported": false,
            "current_name": "decode_and_combine_bytes_080033a8"
        },
        "FUN_08008d18": {
            "renaming": {
                "FUN_08008d18": "set_tx_pin_08008d18",
                "_tx": "tx_pin",
                "PVar1": "pin",
                "PTR_digitalPin_08008d2c": "digitalPin"
            },
            "code": "void set_tx_pin_08008d18(HardwareSerial *serial, uint32_t tx_pin) {\n  PinName pin;\n  if (tx_pin < 0x3c) {\n    pin = PTR_digitalPin_08008d2c[tx_pin];\n  }\n  else {\n    pin = NC;\n  }\n  (serial->_serial).pin_tx = pin;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d18",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "set_tx_pin_08008d18"
        },
        "FUN_0800a020": {
            "renaming": {
                "FUN_0800a020": "read_and_update_data_0800a020",
                "param_1": "file_descriptor",
                "param_2": "data_address",
                "iVar1": "bytes_read",
                "uVar2": "updated_value",
                "bVar3": "read_successful"
            },
            "code": "void read_and_update_data_0800a020(int file_descriptor, int data_address){\n  int bytes_read;\n  uint updated_value;\n  bool read_successful;\n  \n  bytes_read = _read_r(file_descriptor, (int)*(short *)(data_address + 0xe));\n  read_successful = bytes_read >= 0;\n  if (read_successful) {\n    updated_value = *(int *)(data_address + 0x54) + bytes_read;\n  }\n  else {\n    updated_value = *(ushort *)(data_address + 0xc) & 0xffffefff;\n  }\n  if (read_successful) {\n    *(uint *)(data_address + 0x54) = updated_value;\n  }\n  if (!read_successful) {\n    *(short *)(data_address + 0xc) = (short)updated_value;\n  }\n  return;\n}",
            "called": [
                "_read_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a020",
            "calling": [],
            "imported": false,
            "current_name": "read_and_update_data_0800a020"
        },
        "FUN_08007f7c": {
            "renaming": {
                "FUN_08007f7c": "set_i2c_slave_receive_callback_08007f7c",
                "obj": "i2c_conflict_obj",
                "function": "callback_function",
                "i2c_onSlaveReceive": "i2c_slave_receive_callback",
                "HAL_I2C_EnableListen_IT": "enable_i2c_listen_interrupt",
                "handle": "i2c_handle"
            },
            "code": "void set_i2c_slave_receive_callback_08007f7c(i2c_t_conflict *i2c_conflict_obj, _func_void_uint8_t_ptr_int *callback_function) {\n  if (i2c_conflict_obj != NULL) {\n    if (callback_function != NULL) {\n      i2c_conflict_obj->i2c_onSlaveReceive = callback_function;\n      HAL_I2C_EnableListen_IT(&(i2c_conflict_obj->handle));\n    }\n  }\n}",
            "called": [
                "HAL_I2C_EnableListen_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f7c",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "set_i2c_slave_receive_callback_08007f7c"
        },
        "FUN_08006d80": {
            "renaming": {
                "FUN_08006d80": "read_analog_pin_08006d80",
                "pin": "pin",
                "HVar1": "hal_status",
                "uVar2": "adc_value",
                "uhADCxConvertedValue": "converted_value",
                "AdcChannelConf": "adc_channel_conf",
                "AdcHandle": "adc_handle"
            },
            "code": "uint16_t read_analog_pin_08006d80(PinName_conflict pin)\n{\n  HAL_StatusTypeDef_conflict hal_status;\n  uint32_t adc_value;\n  uint16_t converted_value = 0;\n  ADC_ChannelConfTypeDef adc_channel_conf;\n  ADC_HandleTypeDef adc_handle;\n  memset(&adc_handle, 0, sizeof(ADC_HandleTypeDef));\n  adc_channel_conf.Channel = 0;\n  adc_channel_conf.Rank = 0;\n  adc_channel_conf.SamplingTime = 0;\n  adc_handle.Instance = (ADC_TypeDef *)pinmap_peripheral(pin, (PinMap_conflict *)PTR_PinMap_ADC_08006e60);\n  if (adc_handle.Instance != (ADC_TypeDef *)0x0) {\n    adc_handle.Init.DataAlign = ADC_DATAALIGN_RIGHT;\n    adc_handle.Init.ScanConvMode = DISABLE;\n    adc_handle.Init.ContinuousConvMode = DISABLE;\n    adc_handle.Init.DiscontinuousConvMode = DISABLE;\n    adc_handle.Init.ExternalTrigConv = ADC_SOFTWARE_START;\n    adc_handle.Init.NbrOfConversion = 1;\n    adc_handle.Init.NbrOfDiscConversion = 0;\n    *PTR_g_current_pin_08006e64 = pin;\n    hal_status = HAL_ADC_Init(&adc_handle);\n    if (hal_status == HAL_OK) {\n      adc_channel_conf.Channel = get_adc_channel(pin);\n      if (adc_channel_conf.Channel < 0x12) {\n        adc_channel_conf.Rank = 1;\n        adc_channel_conf.SamplingTime = ADC_SAMPLETIME_3CYCLES;\n        hal_status = HAL_ADC_ConfigChannel(&adc_handle, &adc_channel_conf);\n        if (hal_status == HAL_OK) {\n          hal_status = HAL_ADCEx_Calibration_Start(&adc_handle);\n          if (hal_status == HAL_OK) {\n            hal_status = HAL_ADC_Start(&adc_handle);\n            if (hal_status == HAL_OK) {\n              hal_status = HAL_ADC_PollForConversion(&adc_handle, 10);\n              if (hal_status == HAL_OK) {\n                uint32_t adc_state = HAL_ADC_GetState(&adc_handle);\n                if ((adc_state & ADC_FLAG_EOC) != 0) {\n                  adc_value = HAL_ADC_GetValue(&adc_handle);\n                  converted_value = (uint16_t)adc_value;\n                }\n                hal_status = HAL_ADC_Stop(&adc_handle);\n                if (hal_status != HAL_OK) {\n                  converted_value = 0;\n                }\n              }\n              else {\n                converted_value = 0;\n              }\n            }\n            else {\n              converted_value = 0;\n            }\n          }\n          else {\n            converted_value = 0;\n          }\n        }\n        else {\n          converted_value = 0;\n        }\n      }\n      else {\n        converted_value = 0;\n      }\n      hal_status = HAL_ADC_DeInit(&adc_handle);\n      if (hal_status != HAL_OK) {\n        converted_value = 0;\n      }\n    }\n  }\n  return converted_value;\n}",
            "called": [
                "HAL_ADC_GetState",
                "HAL_ADC_ConfigChannel",
                "memset",
                "HAL_ADC_GetValue",
                "HAL_ADC_Stop",
                "get_adc_channel",
                "HAL_ADC_DeInit",
                "HAL_ADC_PollForConversion",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Start",
                "pinmap_peripheral",
                "HAL_ADC_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d80",
            "calling": [
                "analogRead"
            ],
            "imported": false,
            "current_name": "read_analog_pin_08006d80"
        },
        "FUN_08006c60": {
            "renaming": {
                "FUN_08006c60": "get_adc_channel_08006c60",
                "pin": "pin",
                "uVar1": "adc_function",
                "PTR_PinMap_ADC_08006c78": "PTR_PinMap_ADC_08006c78",
                "PinMap_conflict": "PinMap_conflict",
                "0xc": "ADC_FUNCTION_SHIFT",
                "0x1b": "ADC_CHANNEL_MASK",
                "0x10": "MAX_ADC_CHANNEL"
            },
            "code": "uint32_t get_adc_channel_08006c60(PinName_conflict pin)\n{\n  uint32_t adc_function = pinmap_function(pin, (PinMap_conflict*)PTR_PinMap_ADC_08006c78);\n  uint32_t adc_channel = (adc_function << 12) >> 27;\n  if (adc_channel > 15) {\n    adc_channel = 0;\n  }\n  return adc_channel;\n}",
            "called": [
                "pinmap_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c60",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "get_adc_channel_08006c60"
        },
        "FUN_08008e40": {
            "renaming": {
                "FUN_08008e40": "initialize_static_variables_08008e40"
            },
            "code": "void initialize_static_variables_08008e40(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e40",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_08008e40"
        },
        "FUN_080045c0": {
            "renaming": {
                "FUN_080045c0": "configureI2C_080045c0",
                "hi2c": "i2c",
                "bVar1": "isPCLK1Valid",
                "uVar2": "pclk1Freq",
                "uVar3": "riseTime",
                "uVar4": "leadingZeroes",
                "uVar5": "dutyCycleValue",
                "clockSpeed": "clockSpeed",
                "HAL_I2C_STATE_RESET": "HAL_I2C_STATE_RESET",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_I2C_STATE_BUSY": "HAL_I2C_STATE_BUSY",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_OK": "HAL_OK",
                "count_leading_zeroes": "count_leading_zeroes",
                "DAT_08004714": "DAT_08004714",
                "DAT_08004720": "DAT_08004720",
                "DAT_08004718": "DAT_08004718",
                "i2c->State": "i2c->State",
                "i2c->Lock": "i2c->Lock",
                "HAL_I2C_MspInit": "HAL_I2C_MspInit",
                "i2c->Instance->CR1": "i2c->Instance->CR1",
                "i2c->Init.ClockSpeed": "i2c->Init.ClockSpeed",
                "i2c->Instance->CR2": "i2c->Instance->CR2",
                "i2c->Init.DutyCycle": "i2c->Init.DutyCycle",
                "i2c->Instance->CCR": "i2c->Instance->CCR",
                "i2c->Init.GeneralCallMode": "i2c->Init.GeneralCallMode",
                "i2c->Init.NoStretchMode": "i2c->Init.NoStretchMode",
                "i2c->Init.AddressingMode": "i2c->Init.AddressingMode",
                "i2c->Init.OwnAddress1": "i2c->Init.OwnAddress1",
                "i2c->Init.DualAddressMode": "i2c->Init.DualAddressMode",
                "i2c->Init.OwnAddress2": "i2c->Init.OwnAddress2",
                "i2c->ErrorCode": "i2c->ErrorCode",
                "i2c->PreviousState": "i2c->PreviousState",
                "i2c->Mode": "i2c->Mode"
            },
            "code": "HAL_StatusTypeDef configureI2C_080045c0(I2C_HandleTypeDef *i2c)\n{\n  bool isPCLK1Valid;\n  uint32_t pclk1Freq, riseTime, ccrValue, leadingZeroes, dutyCycleValue, divValue;\n  uint clockSpeed = i2c->Init.ClockSpeed;\n  \n  if (i2c == NULL) {\n    return HAL_ERROR;\n  }\n  if (i2c->State == HAL_I2C_STATE_RESET) {\n    i2c->Lock = HAL_UNLOCKED;\n    HAL_I2C_MspInit(i2c);\n  }\n  i2c->State = HAL_I2C_STATE_BUSY;\n  i2c->Instance->CR1 &= ~(1);\n  pclk1Freq = HAL_RCC_GetPCLK1Freq();\n  if (DAT_08004714 < clockSpeed) {\n    isPCLK1Valid = pclk1Freq <= DAT_08004720;\n  }\n  else if (DAT_08004718 < pclk1Freq) {\n    isPCLK1Valid = false;\n  }\n  else {\n    isPCLK1Valid = true;\n  }\n  if (isPCLK1Valid) {\n    return HAL_ERROR;\n  }\n  divValue = (uint)((ulonglong)DAT_0800471c * (ulonglong)pclk1Freq >> 0x32);\n  i2c->Instance->CR2 = divValue;\n  if (DAT_08004714 < clockSpeed) {\n    dutyCycleValue = i2c->Init.DutyCycle;\n    leadingZeroes = count_leading_zeroes((pclk1Freq - 1) / (clockSpeed * ((dutyCycleValue == 0) ? 3 : 0x19)) + 1 & 0xfff);\n    if (leadingZeroes >> 5 == 0) {\n      ccrValue = ((pclk1Freq - 1) / (clockSpeed * ((dutyCycleValue == 0) ? 3 : 0x19))) + 1 & 0xfff | ((dutyCycleValue == 0) ? 0x8000 : 0xc000);\n    }\n    else {\n      ccrValue = 1;\n    }\n  }\n  else {\n    ccrValue = ((pclk1Freq - 1) / (clockSpeed << 1)) + 1 & 0xfff;\n    if (ccrValue < 4) {\n      ccrValue = 4;\n    }\n  }\n  riseTime = ccrValue + 1;\n  i2c->Instance->TRISE = riseTime;\n  i2c->Instance->CR1 = i2c->Init.GeneralCallMode | i2c->Init.NoStretchMode;\n  i2c->Instance->OAR1 = i2c->Init.AddressingMode | i2c->Init.OwnAddress1;\n  i2c->Instance->OAR2 = i2c->Init.DualAddressMode | i2c->Init.OwnAddress2;\n  i2c->Instance->CR1 |= 1;\n  i2c->ErrorCode = 0;\n  i2c->State = HAL_I2C_STATE_READY;\n  i2c->PreviousState = 0;\n  i2c->Mode = HAL_I2C_MODE_NONE;\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MspInit",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080045c0",
            "calling": [
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "configureI2C_080045c0"
        },
        "FUN_08007e74": {
            "renaming": {
                "FUN_08007e74": "i2c_transmit_data_08007e74",
                "obj": "handle",
                "dev_address": "device_address",
                "data": "data",
                "size": "data_size",
                "HVar1": "i2c_state",
                "HVar2": "i2c_status",
                "uVar3": "start_time",
                "uVar4": "error",
                "uVar5": "elapsed_time",
                "iVar6": "status",
                "hi2c": "handle"
            },
            "code": "i2c_status_e_transmit i2c_transmit_data_08007e74(I2C_HandleTypeDef* handle, uint8_t device_address, uint8_t* data, uint16_t data_size) {\n  HAL_I2C_StateTypeDef i2c_state;\n  HAL_StatusTypeDef i2c_status;\n  uint32_t start_time = HAL_GetTick();\n  uint32_t elapsed_time = 0;\n  i2c_status_e_transmit status = I2C_ERROR;\n  do {\n    i2c_status = HAL_I2C_Master_Transmit_IT(handle, (uint16_t)device_address, data, data_size);\n    if (i2c_status == HAL_OK) {\n      status = I2C_OK;\n      while ((i2c_state = HAL_I2C_GetState(handle)) != HAL_I2C_STATE_READY && status == I2C_OK) {\n        elapsed_time = HAL_GetTick() - start_time;\n        if (elapsed_time < 0x65) {\n          uint32_t error = HAL_I2C_GetError(handle);\n          if (error != 0) {\n            status = I2C_ERROR;\n          }\n        }\n        else {\n          status = I2C_TIMEOUT;\n        }\n      }\n    }\n    uint32_t error = HAL_I2C_GetError(handle);\n  } while (error == 4 && elapsed_time < 100);\n  return status;\n}",
            "called": [
                "HAL_I2C_GetState",
                "HAL_I2C_Master_Transmit_IT",
                "HAL_GetTick",
                "HAL_I2C_GetError"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e74",
            "calling": [
                "endTransmission"
            ],
            "imported": false,
            "current_name": "i2c_transmit_data_08007e74"
        },
        "FUN_08002efe": {
            "renaming": {
                "FUN_08002efe": "sendPortData_08002efe",
                "portNumber": "portNumber",
                "portData": "portData",
                "FirmataMarshaller::FUN_08002efe": "FirmataMarshaller::sendPortData",
                "this": "this",
                "&this->marshaller": "&this->marshaller"
            },
            "code": "void __thiscall sendPortData_08002efe(FirmataClass *this, byte portNumber, int portData)\n{\n  FirmataMarshaller::sendPortData_08002efe(&this->marshaller, portNumber, (uint16_t)portData);\n  return;\n}",
            "called": [
                "sendDigitalPort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002efe",
            "calling": [
                "outputPort"
            ],
            "imported": false,
            "current_name": "sendPortData_08002efe"
        },
        "FUN_08002ddc": {
            "renaming": {
                "FUN_08002ddc": "sendFirmwareVersion_08002ddc",
                "&this": "*firmataClass",
                "&this->marshaller": "*firmataMarshaller"
            },
            "code": "void __thiscall sendFirmwareVersion_08002ddc(FirmataClass *this)\n{\n  FirmataMarshaller::sendVersion(&this->marshaller, 2, 5);\n  return;\n}",
            "called": [
                "sendVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ddc",
            "calling": [
                "begin",
                "staticReportVersionCallback"
            ],
            "imported": false,
            "current_name": "sendFirmwareVersion_08002ddc"
        },
        "FUN_08009f2c": {
            "renaming": {
                "FUN_08009f2c": "find_byte_08009f2c",
                "__s": "buffer",
                "__c": "byte_to_find",
                "__n": "buffer_size",
                "pbVar1": "current_byte",
                "pbVar2": "current_byte"
            },
            "code": "void* find_byte_08009f2c(void* buffer, int byte_to_find, size_t buffer_size) {\n  unsigned char* current_byte = (unsigned char*) buffer;\n  while (current_byte != (unsigned char*) buffer + buffer_size) {\n    if (*current_byte == (unsigned char) byte_to_find) {\n      return (void*) current_byte;\n    }\n    current_byte++;\n  }\n  return NULL;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f2c",
            "calling": [
                "_vfiprintf_r",
                "_printf_i"
            ],
            "imported": false,
            "current_name": "find_byte_08009f2c"
        },
        "FUN_0800a154": {
            "renaming": {
                "FUN_0800a154": "calculate_result_0800a154",
                "param_1": "value",
                "param_2": "array_ptr",
                "iVar1": "array_index"
            },
            "code": "int calculate_result_0800a154(int value, int* array_ptr) {\n  int array_index = *(array_ptr - 1) - 4;\n  if (*(array_ptr - 1) < 0) {\n    array_index += *(array_ptr + array_index);\n  }\n  return array_index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a154",
            "calling": [
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "calculate_result_0800a154"
        },
        "FUN_08007f8e": {
            "renaming": {
                "FUN_08007f8e": "set_i2c_slave_transmit_callback_08007f8e",
                "obj": "i2c_conflict_obj",
                "function": "transmit_callback_func",
                "i2c_onSlaveTransmit": "transmit_callback",
                "HAL_I2C_EnableListen_IT(&obj->handle)": "enable_i2c_listen_interrupt(&i2c_conflict_obj->handle)"
            },
            "code": "void set_i2c_slave_transmit_callback_08007f8e(i2c_t_conflict *i2c_conflict_obj, _func_void *transmit_callback_func) {\n  if (i2c_conflict_obj != NULL) {\n    if (transmit_callback_func != NULL) {\n      i2c_conflict_obj->i2c_onSlaveTransmit = transmit_callback_func;\n      HAL_I2C_EnableListen_IT(&i2c_conflict_obj->handle);\n    }\n  }\n}",
            "called": [
                "HAL_I2C_EnableListen_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f8e",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "set_i2c_slave_transmit_callback_08007f8e"
        },
        "FUN_08006b3e": {
            "renaming": {
                "FUN_08006b3e": "set_pin_state_08006b3e",
                "pin": "pin_name",
                "map": "state_map",
                "uVar1": "pin_index"
            },
            "code": "void set_pin_state_08006b3e(PinName_conflict pin, uint32_t *state_map) {\n  uint32_t pin_index = (uint32_t)((int)pin << 0x18) >> 0x1c;\n  state_map[pin_index] |= 1 << ((int)pin & 0xfU);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b3e",
            "calling": [
                "analogWrite",
                "pinMode"
            ],
            "imported": false,
            "current_name": "set_pin_state_08006b3e"
        },
        "FUN_08006262": {
            "renaming": {
                "FUN_08006262": "setChannelStateOfTimer_08006262",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "channelState",
                "CCER": "channelControlRegister",
                "channelMask": "channelMask"
            },
            "code": "void setChannelStateOfTimer_08006262(TIM_TypeDef_conflict *timer, uint32_t channel, uint32_t channelState) {\n  uint32_t channelMask = 1 << (channel & 0xff);\n  timer->CCER = (timer->CCER & ~channelMask) | (channelState << (channel & 0xff));\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006262",
            "calling": [
                "HAL_TIM_OC_Start_IT",
                "HAL_TIM_OC_Stop_IT",
                "HAL_TIM_PWM_Start",
                "HAL_TIM_PWM_Stop"
            ],
            "imported": false,
            "current_name": "setChannelStateOfTimer_08006262"
        },
        "FUN_08007110": {
            "renaming": {
                "FUN_08007110": "disable_timer_clock_08007110",
                "htim": "timer_handle"
            },
            "code": "void disable_timer_clock_08007110(TIM_HandleTypeDef_conflict *timer_handle)\n{\n  timer_disable_clock(timer_handle);\n  return;\n}",
            "called": [
                "timer_disable_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007110",
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "imported": false,
            "current_name": "disable_timer_clock_08007110"
        },
        "FUN_08007594": {
            "renaming": {
                "FUN_08007594": "determineTimerInstanceType_08007594",
                "tim": "timer",
                "DAT_080075d0": "timerInstance1",
                "DAT_080075d4": "timerInstance2",
                "PTR_s_TIM__Unknown_timer_instance_080075d8": "errorMessage"
            },
            "code": "uint8_t determineTimerInstanceType_08007594(TIM_TypeDef_conflict *timer) {\\n  if (timer == (TIM_TypeDef_conflict *)0xffffffff) {\\n    return \"\\0\";\\n  }\\n  if (timer == DAT_080075d0) {\\n    return \"\\x01\";\\n  }\\n  if (DAT_080075d0 < timer) {\\n    if (timer == DAT_080075d4) {\\n      return \"\\x01\";\\n    }\\n    if (timer == (TIM_TypeDef_conflict *)&DAT_080075d4[0x379].DMAR) {\\n      return \"\\x02\";\\n    }\\n  }\\n  else if (timer == (TIM_TypeDef_conflict *)0x40000000) {\\n    return \"\\x01\";\\n  }\\n  iprintf(PTR_s_TIM__Unknown_timer_instance_080075d8);\\n  return \"\\0\";\\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007594",
            "calling": [
                "getTimerClkFreq"
            ],
            "imported": false,
            "current_name": "determineTimerInstanceType_08007594"
        },
        "FUN_08002cd0": {
            "renaming": {
                "FUN_08002cd0": "executeSystemResetCallback_08002cd0",
                "param_1": "callbackFunctionPointer",
                "PTR_currentSystemResetCallback_08002cdc": "currentSystemResetCallback"
            },
            "code": "void executeSystemResetCallback_08002cd0(void *callbackFunctionPointer)\n{\n  if (*(code **)PTR_currentSystemResetCallback_08002cdc != (code *)0x0) {\n    (**(code **)PTR_currentSystemResetCallback_08002cdc)();\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002cd0",
            "calling": [],
            "imported": false,
            "current_name": "executeSystemResetCallback_08002cd0"
        },
        "FUN_08002df6": {
            "renaming": {
                "FUN_08002df6": "sendFirmwareVersionIfAvailable_08002df6",
                "this": "firmataInstance",
                "puVar1": "firmwareVersionVectorPtr",
                "firmwareVersionCount": "firmwareVersionCount",
                "firmwareVersionVector": "firmwareVersionVectorPtr",
                "FirmataMarshaller::sendFirmwareVersion": "FirmataMarshaller::sendFirmwareVersion",
                "&this->marshaller": "&firmataInstance->marshaller"
            },
            "code": "void __thiscall sendFirmwareVersionIfAvailable_08002df6(FirmataClass *firmataInstance)\n{\n  uint8_t *firmwareVersionVectorPtr;\n  int firmwareVersionCount = firmataInstance->firmwareVersionCount;\n  if (firmwareVersionCount == 0) {\n    return;\n  }\n  firmwareVersionVectorPtr = firmataInstance->firmwareVersionVector;\n  FirmataMarshaller::sendFirmwareVersion(&firmataInstance->marshaller, *firmwareVersionVectorPtr, firmwareVersionVectorPtr[1], firmwareVersionCount - 2, firmwareVersionVectorPtr + 2);\n  return;\n}",
            "called": [
                "sendFirmwareVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002df6",
            "calling": [
                "begin",
                "staticReportFirmwareCallback"
            ],
            "imported": false,
            "current_name": "sendFirmwareVersionIfAvailable_08002df6"
        },
        "FUN_080045bc": {
            "renaming": {
                "FUN_080045bc": "do_nothing_080045bc"
            },
            "code": "\nvoid do_nothing_080045bc(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080045bc",
            "calling": [
                "HAL_I2C_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_080045bc"
        },
        "FUN_08007118": {
            "renaming": {
                "FUN_08007118": "set_pwm_output_08007118",
                "PinName_conflict": "PinName",
                "clock_freq": "clock_frequency",
                "period": "period",
                "value": "duty_cycle",
                "do_init": "initialize",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HVar1": "status",
                "uVar2": "timer_clk_freq",
                "uVar3": "function",
                "timConfig": "timer_config",
                "timHandle": "timer_handle",
                "TIM_OC_InitTypeDef": "TIM_OC_InitTypeDef",
                "TIM_HandleTypeDef_conflict": "TIM_HandleTypeDef",
                "TIM_TypeDef_conflict": "TIM_TypeDef",
                "PTR_PinMap_PWM_080071dc": "PinMap_PWM",
                "PTR_g_current_pin_080071e0": "current_pin",
                "getTimerClkFreq": "get_timer_clk_freq",
                "get_pwm_channel": "get_channel_number",
                "HAL_TIM_PWM_Init": "HAL_TIM_PWM_Init",
                "HAL_TIM_PWM_ConfigChannel": "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_PWM_Start": "HAL_TIM_PWM_Start",
                "HAL_TIMEx_PWMN_Start": "HAL_TIMEx_PWMN_Start"
            },
            "code": "void set_pwm_output_08007118(PinName pin, uint32_t clock_frequency, uint32_t period, uint32_t duty_cycle, uint8_t initialize){\n  HAL_StatusTypeDef status;\n  uint32_t timer_clk_freq;\n  uint32_t channel_number;\n  TIM_OC_InitTypeDef timer_config;\n  TIM_HandleTypeDef timer_handle;\n  memset(&timer_handle, 0, sizeof(TIM_HandleTypeDef));\n  timer_config.OCMode = TIM_OCMODE_PWM1;\n  timer_config.Pulse = 0;\n  timer_config.OCPolarity = TIM_OCPOLARITY_HIGH;\n  timer_config.OCNPolarity = TIM_OCNPOLARITY_HIGH;\n  timer_config.OCFastMode = TIM_OCFAST_DISABLE;\n  timer_config.OCIdleState = TIM_OCIDLESTATE_RESET;\n  timer_config.OCNIdleState = TIM_OCNIDLESTATE_RESET;\n  timer_handle.Instance = (TIM_TypeDef*)pinmap_peripheral(pin, (PinMap*)PTR_PinMap_PWM_080071dc);\n  if(timer_handle.Instance != NULL){\n    timer_clk_freq = getTimerClkFreq(timer_handle.Instance);\n    timer_handle.Init.Prescaler = timer_clk_freq / clock_frequency - 1;\n    timer_handle.Init.Period = period - 1;\n    timer_handle.Init.ClockDivision = 0;\n    timer_handle.Init.CounterMode = TIM_COUNTERMODE_UP;\n    timer_handle.Init.RepetitionCounter = 0;\n    timer_handle.State = HAL_TIM_STATE_RESET;\n    if(initialize == 1){\n      PTR_g_current_pin_080071e0 = pin;\n      status = HAL_TIM_PWM_Init(&timer_handle);\n      if(status != HAL_OK){\n        return;\n      }\n    }\n    channel_number = get_pwm_channel(pin);\n    if(channel_number == 0 || channel_number == 4 || channel_number == 8 || channel_number == 12 || channel_number == 18){\n      timer_config.OCMode = TIM_OCMODE_PWM1;\n      timer_config.OCPolarity = TIM_OCPOLARITY_HIGH;\n      timer_config.OCFastMode = TIM_OCFAST_DISABLE;\n      timer_config.OCNPolarity = TIM_OCNPOLARITY_HIGH;\n      timer_config.OCNIdleState = TIM_OCNIDLESTATE_RESET;\n      timer_config.OCIdleState = TIM_OCIDLESTATE_RESET;\n      timer_config.Pulse = duty_cycle;\n      status = HAL_TIM_PWM_ConfigChannel(&timer_handle, &timer_config, channel_number);\n      if(status == HAL_OK){\n        uint32_t function = pinmap_function(pin, (PinMap*)PTR_PinMap_PWM_080071dc);\n        if((function & 0x100000) == 0){\n          HAL_TIM_PWM_Start(&timer_handle, channel_number);\n        }\n        else{\n          HAL_TIMEx_PWMN_Start(&timer_handle, channel_number);\n        }\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "HAL_TIMEx_PWMN_Start",
                "HAL_TIM_PWM_ConfigChannel",
                "getTimerClkFreq",
                "get_pwm_channel",
                "memset",
                "HAL_TIM_PWM_Start",
                "pinmap_function",
                "pinmap_peripheral",
                "HAL_TIM_PWM_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007118",
            "calling": [
                "analogWrite"
            ],
            "imported": false,
            "current_name": "set_pwm_output_08007118"
        },
        "FUN_08001be8": {
            "renaming": {
                "FUN_08001be8": "initialize_static_data_08001be8"
            },
            "code": "void initialize_static_data_08001be8(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001be8",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_data_08001be8"
        },
        "FUN_08005a68": {
            "renaming": {
                "FUN_08005a68": "configure_RCC_clocks_08005a68",
                "RCC_ClkInitStruct": "clock_init_struct",
                "pFLatency": "flash_latency",
                "DAT_08005a9c": "data_address",
                "RCC_ClkInitStruct->ClockType": "clock_init_struct->ClockType",
                "*(uint *)(DAT_08005a9c + 4) & 3": "*(uint *)(data_address + 4) & RCC_SYSCLKSOURCE_STATUS_PLLCLK",
                "RCC_ClkInitStruct->SYSCLKSource": "clock_init_struct->SYSCLKSource",
                "*(uint *)(iVar1 + 4) & 0xf0": "*(uint *)(data_address + 4) & RCC_SYSCLK_DIVIDER_1",
                "RCC_ClkInitStruct->AHBCLKDivider": "clock_init_struct->AHBCLKDivider",
                "*(uint *)(iVar1 + 4) & 0x700": "*(uint *)(data_address + 4) & RCC_HCLK_DIVIDER_2",
                "RCC_ClkInitStruct->APB1CLKDivider": "clock_init_struct->APB1CLKDivider",
                "*(uint *)(iVar1 + 4) >> 3 & 0x700": "*(uint *)(data_address + 4) >> 3 & RCC_HCLK_DIVIDER_1",
                "RCC_ClkInitStruct->APB2CLKDivider": "clock_init_struct->APB2CLKDivider",
                "*pFLatency": "*flash_latency",
                "*DAT_08005aa0 & 7": "*DAT_08005aa0 & FLASH_LATENCY_MASK"
            },
            "code": "void configure_RCC_clocks_08005a68(RCC_ClkInitTypeDef_conflict *clock_init_struct, uint32_t *flash_latency) {\n  int DAT_08005a9c = DAT_08005a9c;\n  clock_init_struct->ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;\n  clock_init_struct->SYSCLKSource = *(uint *)(DAT_08005a9c + 4) & 3;\n  clock_init_struct->AHBCLKDivider = *(uint *)(DAT_08005a9c + 4) & RCC_SYSCLK_DIVIDER_1;\n  clock_init_struct->APB1CLKDivider = *(uint *)(DAT_08005a9c + 4) & RCC_HCLK_DIVIDER_2;\n  clock_init_struct->APB2CLKDivider = *(uint *)(DAT_08005a9c + 4) >> 3 & RCC_HCLK_DIVIDER_1;\n  *flash_latency = *DAT_08005aa0 & 7;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a68",
            "calling": [
                "getTimerClkFreq"
            ],
            "imported": false,
            "current_name": "configure_RCC_clocks_08005a68"
        },
        "FUN_08008f78": {
            "renaming": {
                "FUN_08008f78": "initialize_gpio_irq_config_08008f78",
                "__initialize_p": "should_initialize",
                "__priority": "priority",
                "PTR_gpio_irq_conf_08009018": "gpio_irq_config_ptr",
                "DAT_08009020": "DAT_08009020",
                "PTR___dso_handle_0800901c": "PTR___dso_handle_0800901c",
                "puVar1": "gpio_irq_config_ptr"
            },
            "code": "void initialize_gpio_irq_config_08008f78(int should_initialize, int priority) {\n  undefined *PTR_gpio_irq_conf_08009018;\n  PTR_gpio_irq_conf_08009018 = PTR_gpio_irq_conf_08009018;\n  if (should_initialize == 1 && priority == 0xffff) {\n    int offsets[] = {0, 12, 20, 40, 56, 84, 92, 116, 124, 148, 156, 180, 188, 212, 220, 244, 252, 276, 284, 308, 316, 340, 348, 372, 380, 404, 412, 436, 444, 468, 476, 500, 508, 532, 540, 564, 572, 596, 604, 628, 636, 660, 668, 692, 700, 724, 732, 756, 764, 788, 796, 820, 828, 852, 860};\n    int i;\n    for (i = 0; i < 54; i++) {\n      PTR_gpio_irq_conf_08009018[offsets[i]] = (i % 6 == 0) ? 6 : 0x17;\n      *(undefined4 *)(PTR_gpio_irq_conf_08009018 + offsets[i] + 0xc) = 0;\n    }\n    for (i = 54; i < 60; i++) {\n      PTR_gpio_irq_conf_08009018[offsets[i]] = 0x28;\n      *(undefined4 *)(PTR_gpio_irq_conf_08009018 + offsets[i] + 0xc) = 0;\n    }\n    __aeabi_atexit(0, DAT_08009020, PTR___dso_handle_0800901c);\n  }\n}",
            "called": [
                "__aeabi_atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f78",
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "imported": false,
            "current_name": "initialize_gpio_irq_config_08008f78"
        },
        "FUN_08002dea": {
            "renaming": {
                "FUN_08002dea": "printFirmataVersionIfContextIsNotNull_08002dea",
                "context": "context",
                "FirmataClass": "FirmataClass",
                "printVersion": "printVersion",
                "nullptr": "nullptr",
                "static_cast": "static_cast"
            },
            "code": "void printFirmataVersionIfContextIsNotNull_08002dea(void *context) {\n  if (context != nullptr) {\n    printVersion(static_cast<FirmataClass *>(context));\n    return;\n  }\n  return;\n}",
            "called": [
                "printVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002dea",
            "calling": [],
            "imported": false,
            "current_name": "printFirmataVersionIfContextIsNotNull_08002dea"
        },
        "FUN_08008d30": {
            "renaming": {
                "FUN_08008d30": "initialize_serial_08008d30",
                "this": "serial",
                "peripheral": "peripheral",
                "PVar1": "pin",
                "extraout_r1": "ctx",
                "extraout_r1_00": "ctx",
                "PTR_Ptr_write_1_08008d7c": "write_1_08008d7c",
                "PTR_Serial2_08008d80": "Serial2_08008d80",
                "_serial": "_serial",
                "pin_rx": "rx_pin",
                "pin_tx": "tx_pin",
                "PTR_PinMap_UART_RX_08008d84": "PinMap_UART_RX_08008d84",
                "PTR_PinMap_UART_TX_08008d88": "PinMap_UART_TX_08008d88",
                "init": "init_serial"
            },
            "code": "typedef struct {\n  Stream super_Stream;\n  serial_t _serial;\n} Serial;\n\nvoid initialize_serial_08008d30(Serial *serial, void *peripheral) {\n  PinName rx_pin;\n  PinName tx_pin;\n  EVP_PKEY_CTX *ctx;\n  serial->super_Stream.super_Print.write_error = 0;\n  serial->super_Stream._timeout = 1000;\n  serial->super_Stream.super_Print._vptr_Print = (_func_int_varargs **)PTR_Ptr_write_1_08008d7c;\n  if (serial == (Serial *)PTR_Serial2_08008d80) {\n    setRx(serial, 0);\n    setTx(serial, 1);\n    ctx = NULL;\n  }\n  else {\n    rx_pin = pinmap_pin(peripheral, (PinMap *)PTR_PinMap_UART_RX_08008d84);\n    serial->_serial.pin_rx = rx_pin;\n    tx_pin = pinmap_pin(peripheral, (PinMap *)PTR_PinMap_UART_TX_08008d88);\n    serial->_serial.pin_tx = tx_pin;\n    ctx = NULL;\n  }\n  init_serial(serial, ctx);\n}\n",
            "called": [
                "setTx",
                "pinmap_pin",
                "setRx",
                "init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d30",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_serial_08008d30"
        },
        "FUN_0800734a": {
            "renaming": {
                "FUN_0800734a": "find_pin_for_peripheral_0800734a",
                "PinName_conflict": "PinName",
                "PinMap_conflict": "PinMap",
                "PVar1": "pin",
                "pinmap_find_pin": "find_pin_for_peripheral_in_map"
            },
            "code": "PinName find_pin_for_peripheral_0800734a(void *peripheral, PinMap *map)\n{\n  PinName pin;\n  if (peripheral != NULL) {\n    pin = find_pin_for_peripheral_0800734a_in_map(peripheral, map);\n    return pin;\n  }\n  return NC;\n}",
            "called": [
                "pinmap_find_pin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800734a",
            "calling": [
                "HardwareSerial",
                "uart_debug_init"
            ],
            "imported": false,
            "current_name": "find_pin_for_peripheral_0800734a"
        },
        "FUN_08000aec": {
            "renaming": {
                "FUN_08000aec": "initializePinsAndVariables_08000aec",
                "PTR_isResetting_08000bc0": "isResetting",
                "PTR_isI2CEnabled_08000bc4": "isI2CEnabled",
                "disableI2CPins": "disableI2CPins",
                "PTR_reportPINs_08000bc8": "reportPINs",
                "PTR_portConfigInputs_08000bcc": "portConfigInputs",
                "PTR_previousPINs_08000bd0": "previousPINs",
                "PTR_digitalPin_08000bd4": "digitalPin",
                "NC": "NC",
                "pinNametoDigitalPin": "pinNametoDigitalPin",
                "PTR_servoPinMap_08000bd8": "servoPinMap",
                "PTR_analogInputsToReport_08000bdc": "analogInputsToReport",
                "PTR_detachedServoCount_08000be0": "detachedServoCount",
                "PTR_servoCount_08000be4": "servoCount"
            },
            "code": "void initializePinsAndVariables_08000aec(void) {\n  bool isPinServo;\n  PinName_conflict pinName;\n  uint32_t PTR_digitalPin_08000bd4;\n  uint PTR_analogInputsToReport_08000bdc = 0;\n  *PTR_isResetting_08000bc0 = true;\n  if (*PTR_isI2CEnabled_08000bc4 != 0) {\n    disableI2CPins();\n  }\n  for (uint i = 0; i < 5; i++) {\n    PTR_reportPINs_08000bc8[i] = 0;\n    PTR_portConfigInputs_08000bcc[i] = 0;\n    PTR_previousPINs_08000bd0[i] = 0;\n  }\n  for (uint i = 0; i < 0x3c; i++) {\n    if ((i - 0x2e & 0xff) < 0xe) {\n      if (i < 0x3c) {\n        pinName = PTR_digitalPin_08000bd4[i];\n      }\n      else {\n        pinName = NC;\n      }\n      PTR_digitalPin_08000bd4 = pinNametoDigitalPin(pinName);\n      if (PTR_digitalPin_08000bd4 == 0) {\n        isPinServo = false;\n      }\n      else {\n        if (i < 0x3c) {\n          pinName = PTR_digitalPin_08000bd4[i];\n        }\n        else {\n          pinName = NC;\n        }\n        PTR_digitalPin_08000bd4 = pinNametoDigitalPin(pinName);\n        if (PTR_digitalPin_08000bd4 == 1) {\n          isPinServo = false;\n        }\n        else {\n          isPinServo = true;\n        }\n      }\n    }\n    else {\n      isPinServo = false;\n    }\n    if (isPinServo) {\n      setPinModeCallback((byte)i, 2);\n    }\n    else {\n      if ((i < 0x3c) && (PTR_digitalPin_08000bd4[i] != NC) && (PTR_digitalPin_08000bd4 = pinNametoDigitalPin(PTR_digitalPin_08000bd4[i]), PTR_digitalPin_08000bd4 != 0) && (PTR_digitalPin_08000bd4 = pinNametoDigitalPin(PTR_digitalPin_08000bd4[i]), PTR_digitalPin_08000bd4 != 1)) {\n        isPinServo = true;\n      }\n      if (isPinServo) {\n        setPinModeCallback((byte)i, 1);\n      }\n    }\n    PTR_servoPinMap_08000bd8[i] = 0xff;\n  }\n  *PTR_analogInputsToReport_08000bdc = PTR_analogInputsToReport_08000bdc;\n  *PTR_detachedServoCount_08000be0 = 0;\n  *PTR_servoCount_08000be4 = 0;\n  *PTR_isResetting_08000bc0 = false;\n  return;\n}",
            "called": [
                "pinNametoDigitalPin",
                "disableI2CPins",
                "setPinModeCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000aec",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "initializePinsAndVariables_08000aec"
        },
        "FUN_080068d6": {
            "renaming": {
                "FUN_080068d6": "receive_data_080068d6",
                "huart": "uart_handle",
                "pData": "data",
                "Size": "size",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "HAL_BUSY": "HAL_BUSY",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_LOCKED": "HAL_LOCKED",
                "pRxBuffPtr": "p_rx_buff_ptr",
                "RxXferSize": "rx_xfer_size",
                "RxXferCount": "rx_xfer_count",
                "ErrorCode": "error_code",
                "HAL_UART_STATE_BUSY_RX": "HAL_UART_STATE_BUSY_RX",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "Instance": "instance",
                "CR1": "cr1",
                "CR3": "cr3",
                "USART_CR1_RXNEIE": "USART_CR1_RXNEIE",
                "USART_CR3_EIE": "USART_CR3_EIE",
                "USART_CR1_RE": "USART_CR1_RE"
            },
            "code": "HAL_StatusTypeDef receive_data_080068d6(UART_HandleTypeDef *uart_handle, uint8_t *data, uint16_t size) {\n  if (uart_handle->RxState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (data == NULL) {\n    return HAL_ERROR;\n  }\n  if (size == 0) {\n    return HAL_ERROR;\n  }\n  if (uart_handle->Lock != HAL_LOCKED) {\n    uart_handle->pRxBuffPtr = data;\n    uart_handle->RxXferSize = size;\n    uart_handle->RxXferCount = size;\n    uart_handle->ErrorCode = 0;\n    uart_handle->RxState = HAL_UART_STATE_BUSY_RX;\n    uart_handle->Lock = HAL_UNLOCKED;\n    uart_handle->Instance->CR1 |= USART_CR1_RXNEIE;\n    uart_handle->Instance->CR3 |= USART_CR3_EIE;\n    uart_handle->Instance->CR1 |= USART_CR1_RE;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080068d6",
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "imported": false,
            "current_name": "receive_data_080068d6"
        },
        "FUN_080032a2": {
            "renaming": {
                "FUN_080032a2": "sendSysexMessage_080032a2",
                "this": "marshaller",
                "string": "message",
                "bytec": "message_length"
            },
            "code": "void __thiscall sendSysexMessage_080032a2(FirmataMarshaller *marshaller, char *message) {\n  size_t message_length;\n  message_length = strlen(message);\n  sendSysex(marshaller, 'q', message_length, (uint8_t *)message);\n  return;\n}",
            "called": [
                "strlen",
                "sendSysex"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080032a2",
            "calling": [
                "sendString"
            ],
            "imported": false,
            "current_name": "sendSysexMessage_080032a2"
        },
        "FUN_08009e28": {
            "renaming": {
                "FUN_08009e28": "process_data_08009e28",
                "param_1": "data",
                "param_2": "callback",
                "param_3": "arg1",
                "param_4": "arg2",
                "piVar3": "ptr",
                "iVar4": "ptr2",
                "iVar6": "count",
                "uVar1": "callback_result",
                "uVar5": "result"
            },
            "code": "uint process_data_08009e28(int data, code *callback, undefined4 arg1, undefined4 arg2) {\n  uint result = 0;\n  for (int *ptr = (int *)(data + 0x48); ptr != (int *)0x0; ptr = (int *)*ptr) {\n    int ptr2 = ptr[2];\n    int count = ptr[1];\n    while (count > 0) {\n      if ((*(ushort *)(ptr2 + 0xc) > 1) && (*(short *)(ptr2 + 0xe) + 1 != 0)) {\n        uint callback_result = (*callback)(data, ptr2, arg1, *(short *)(ptr2 + 0xe) + 1, arg2);\n        result |= callback_result;\n      }\n      ptr2 += 0x68;\n      count--;\n    }\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009e28",
            "calling": [
                "_cleanup_r"
            ],
            "imported": false,
            "current_name": "process_data_08009e28"
        },
        "FUN_0800a01c": {
            "renaming": {
                "FUN_0800a01c": "get_process_id_0800a01c"
            },
            "code": "__pid_t get_process_id_0800a01c(void)\n{\n  __pid_t process_id = 1;\n  return process_id;\n}",
            "called": [
                "_getpid"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a01c",
            "calling": [
                "_raise_r"
            ],
            "imported": false,
            "current_name": "get_process_id_0800a01c"
        },
        "FUN_08006390": {
            "renaming": {
                "FUN_08006390": "configure_timer_08006390",
                "htim": "timer_handle",
                "Channel": "channel",
                "pTVar1": "timer_instance",
                "DAT_080063bc": "PTR_TIM1"
            },
            "code": "HAL_StatusTypeDef_conflict configure_timer_08006390(TIM_HandleTypeDef_conflict *timer_handle, uint32_t channel) {\n  TIM_TypeDef_conflict *timer_instance;\n  TIM_CCxChannelCmd(timer_handle->Instance, channel, 1);\n  timer_instance = timer_handle->Instance;\n  if (timer_instance == DAT_080063bc) {\n    timer_instance->BDTR |= 0x8000;\n  }\n  timer_handle->Instance->CR1 |= TIM_CR1_CEN;\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006390",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "configure_timer_08006390"
        },
        "FUN_08009f48": {
            "renaming": {
                "FUN_08009f48": "do_nothing_08009f48"
            },
            "code": "\nvoid do_nothing_08009f48(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f48",
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "imported": false,
            "current_name": "do_nothing_08009f48"
        },
        "FUN_08004d6a": {
            "renaming": {
                "FUN_08004d6a": "do_nothing_08004d6a"
            },
            "code": "\nvoid do_nothing_08004d6a(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d6a",
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004d6a"
        },
        "FUN_08008730": {
            "renaming": {
                "FUN_08008730": "transmit_data_08008730",
                "huart": "uart_handler",
                "bVar1": "uart_index_num",
                "uVar2": "uart_handler_index",
                "iVar3": "callback_return_val",
                "iVar4": "callback_obj_index",
                "PTR_tx_callback_obj_08008770": "callback_obj_pointer",
                "PTR_tx_callback_08008774": "callback_func_pointer",
                "PTR_uart_handlers_08008778": "uart_handler_pointer"
            },
            "code": "void transmit_data_08008730(UART_HandleTypeDef *uart_handler)\n{\n  uint8_t uart_index_num;\n  int callback_obj_index;\n  int callback_return_val;\n  uint8_t uart_handler_index;\n  uint8_t uart_handler_address_index;\n\n  uart_index_num = get_uart_index(uart_handler);\n  uart_handler_index = (uint8_t)uart_index_num;\n  callback_obj_index = *(int *)(PTR_tx_callback_obj_08008770 + uart_handler_index * 4);\n  if ((uart_handler_index < 5) &&\n     (callback_return_val = (**(code **)(PTR_tx_callback_08008774 + uart_handler_index * 4))(callback_obj_index), callback_return_val != -1)) {\n    uart_handler_address_index = *(uint8_t *)(callback_obj_index + 0x44);\n    HAL_UART_Transmit_IT\n              (*(UART_HandleTypeDef **)\n                (PTR_uart_handlers_08008778 + (uint)uart_handler_address_index * 4),\n               (uint8_t *)(*(int *)(callback_obj_index + 100) + (uint)*(ushort *)(callback_obj_index + 0x6a)),1);\n  }\n  return;\n}",
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008730",
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "imported": false,
            "current_name": "transmit_data_08008730"
        },
        "FUN_08005460": {
            "renaming": {
                "FUN_08005460": "FUNC_08005460"
            },
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nHAL_StatusTypeDef_conflict FUNC_08005460(RCC_OscInitTypeDef_conflict *RCC_OscInitStruct)\n\n{\n  uint *puVar1;\n  uint *puVar2;\n  HAL_StatusTypeDef_conflict HVar3;\n  uint32_t uVar4;\n  uint32_t uVar5;\n  bool bVar6;\n  uint32_t tmpreg;\n  \n  puVar1 = DAT_08005720;\n  if ((RCC_OscInitStruct->OscillatorType & 1) != 0) {\n    if (((DAT_08005720[1] & 0xc) == 4) ||\n       (((DAT_08005720[1] & 0xc) == 8 && ((DAT_08005720[1] & 0x10000) != 0)))) {\n      if (((*DAT_08005720 & 0x20000) != 0) && (RCC_OscInitStruct->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      uVar5 = RCC_OscInitStruct->HSEState;\n      if (uVar5 == 0x10000) {\n        *DAT_08005720 = *DAT_08005720 | 0x10000;\n      }\n      else if (uVar5 == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (uVar5 == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        *DAT_08005720 = *DAT_08005720 & 0xfffeffff;\n        *puVar1 = *puVar1 & 0xfffbffff;\n      }\n      if (RCC_OscInitStruct->HSEState == 0) {\n        uVar5 = HAL_GetTick();\n        while ((*DAT_08005720 & 0x20000) != 0) {\n          uVar4 = HAL_GetTick();\n          if (100 < uVar4 - uVar5) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        uVar5 = HAL_GetTick();\n        while ((*DAT_08005720 & 0x20000) == 0) {\n          uVar4 = HAL_GetTick();\n          if (100 < uVar4 - uVar5) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 2) != 0) {\n    if (((DAT_08005720[1] & 0xc) == 0) ||\n       (((DAT_08005720[1] & 0xc) == 8 && ((DAT_08005720[1] & 0x10000) == 0)))) {\n      if (((*DAT_08005720 & 2) != 0) && (RCC_OscInitStruct->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      *DAT_08005720 = *DAT_08005720 & 0xffffff07 | RCC_OscInitStruct->HSICalibrationValue << 3;\n    }\n    else if (RCC_OscInitStruct->HSIState == 0) {\n      *DAT_08005724 = 0;\n      uVar5 = HAL_GetTick();\n      while ((*DAT_08005720 & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005724 = 1;\n      uVar5 = HAL_GetTick();\n      while ((*DAT_08005720 & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n      *DAT_08005720 = *DAT_08005720 & 0xffffff07 | RCC_OscInitStruct->HSICalibrationValue << 3;\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 8) != 0) {\n    if (RCC_OscInitStruct->LSIState == 0) {\n      *DAT_08005728 = 0;\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005720[9] & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005728 = 1;\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005720[9] & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 4) != 0) {\n    bVar6 = (DAT_08005720[7] & 0x10000000) == 0;\n    if (bVar6) {\n      DAT_08005720[7] = DAT_08005720[7] | 0x10000000;\n    }\n    if ((*DAT_0800572c & 0x100) == 0) {\n      *DAT_0800572c = *DAT_0800572c | 0x100;\n      uVar5 = HAL_GetTick();\n      while ((*DAT_0800572c & 0x100) == 0) {\n        uVar4 = HAL_GetTick();\n        if (100 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    puVar2 = DAT_08005838;\n    puVar1 = DAT_08005720;\n    uVar5 = RCC_OscInitStruct->LSEState;\n    if (uVar5 == 1) {\n      DAT_08005720[8] = DAT_08005720[8] | 1;\n    }\n    else if (uVar5 == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (uVar5 == 5) {\n      DAT_08005838[8] = DAT_08005838[8] | 4;\n      puVar2[8] = puVar2[8] | 1;\n    }\n    else {\n      DAT_08005720[8] = DAT_08005720[8] & 0xfffffffe;\n      puVar1[8] = puVar1[8] & 0xfffffffb;\n    }\n    if (RCC_OscInitStruct->LSEState == 0) {\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005838[8] & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (5000 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005720[8] & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (5000 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (bVar6) {\n      DAT_08005838[7] = DAT_08005838[7] & 0xefffffff;\n    }\n  }\n  uVar5 = (RCC_OscInitStruct->PLL).PLLState;\n  if (uVar5 == 0) {\n    HVar3 = HAL_OK;\n  }\n  else if ((DAT_08005838[1] & 0xc) == 8) {\n    HVar3 = HAL_ERROR;\n  }\n  else if (uVar5 == 2) {\n    *DAT_0800583c = 0;\n    uVar5 = HAL_GetTick();\n    do {\n      if ((*DAT_08005838 & 0x2000000) == 0) {\n        if ((RCC_OscInitStruct->PLL).PLLSource == 0x10000) {\n          DAT_08005838[1] = DAT_08005838[1] & 0xfffdffff | RCC_OscInitStruct->HSEPredivValue;\n        }\n        DAT_08005838[1] =\n             DAT_08005838[1] & 0xffc2ffff |\n             (RCC_OscInitStruct->PLL).PLLSource | (RCC_OscInitStruct->PLL).PLLMUL;\n        *DAT_0800583c = 1;\n        uVar5 = HAL_GetTick();\n        do {\n          if ((*DAT_08005838 & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          uVar4 = HAL_GetTick();\n        } while (uVar4 - uVar5 < 3);\n        return HAL_TIMEOUT;\n      }\n      uVar4 = HAL_GetTick();\n    } while (uVar4 - uVar5 < 3);\n    HVar3 = HAL_TIMEOUT;\n  }\n  else {\n    *DAT_0800583c = 0;\n    uVar5 = HAL_GetTick();\n    do {\n      if ((*DAT_08005838 & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      uVar4 = HAL_GetTick();\n    } while (uVar4 - uVar5 < 3);\n    HVar3 = HAL_TIMEOUT;\n  }\n  return HVar3;\n}\n\n",
            "called": [
                "RCC_Delay",
                "HAL_GetTick"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08005460",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "FUNC_08005460"
        },
        "FUN_08008854": {
            "renaming": {
                "FUN_08008854": "calculate_file_size_08008854",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "pointer",
                "dir_UNUSED": "directory"
            },
            "code": "int calculate_file_size_08008854(int file_descriptor, int pointer, int directory) {\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008854",
            "calling": [
                "_lseek_r"
            ],
            "imported": false,
            "current_name": "calculate_file_size_08008854"
        },
        "FUN_08004d6c": {
            "renaming": {
                "FUN_08004d6c": "i2c_transfer_08004d6c",
                "hi2c": "handle",
                "State": "state",
                "XferCount": "xfer_count",
                "XferOptions": "xfer_options",
                "Instance": "instance",
                "CR1": "CR1",
                "CR2": "CR2",
                "pBuffPtr": "buffer_ptr",
                "Mode": "mode",
                "PreviousState": "previous_state",
                "HAL_I2C_STATE_BUSY_RX": "HAL_I2C_STATE_BUSY_RX",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "HAL_I2C_MODE_MEM": "HAL_I2C_MODE_MEM",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NONE",
                "HAL_I2C_MasterRxCpltCallback": "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback": "HAL_I2C_MemRxCpltCallback",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef i2c_transfer_08004d6c(I2C_HandleTypeDef *handle)\n{\n  uint8_t *buffer_ptr;\n  if (handle->state == HAL_I2C_STATE_BUSY_RX) {\n    if (handle->xfer_count < 4) {\n      if (handle->xfer_count - 2 < 2) {\n        if (handle->xfer_options == 2) {\n          handle->instance->CR1 |= 0x400;\n        }\n        else {\n          handle->instance->CR1 &= 0xfffffbff;\n          handle->instance->CR1 |= 0x800;\n        }\n        handle->instance->CR2 &= 0xfffffbff;\n      }\n      else {\n        if (handle->xfer_options == 2) {\n          handle->instance->CR1 |= 0x400;\n        }\n        else {\n          handle->instance->CR1 &= 0xfffffbff;\n        }\n        handle->instance->CR2 &= 0xfffff8ff;\n        buffer_ptr = handle->buffer_ptr;\n        handle->buffer_ptr = buffer_ptr + 1;\n        *buffer_ptr = (uint8_t)handle->instance->DR;\n        handle->xfer_count--;\n        handle->state = HAL_I2C_STATE_READY;\n        handle->previous_state = 0;\n        if (handle->mode == HAL_I2C_MODE_MEM) {\n          handle->mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemRxCpltCallback(handle);\n        }\n        else {\n          handle->mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterRxCpltCallback(handle);\n        }\n      }\n    }\n    else {\n      buffer_ptr = handle->buffer_ptr;\n      handle->buffer_ptr = buffer_ptr + 1;\n      *buffer_ptr = (uint8_t)handle->instance->DR;\n      handle->xfer_count--;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d6c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_transfer_08004d6c"
        },
        "FUN_08007760": {
            "renaming": {
                "FUN_08007760": "handle_timer_interrupt_08007760",
                "PTR_timer_handles_08007770": "PTR_timer_handles",
                "TIM_HandleTypeDef_conflict": "TimerHandleConflict"
            },
            "code": "void handle_timer_interrupt_08007760(void)\n{\n  TIM_HandleTypeDef_conflict** timer_handles = *(TIM_HandleTypeDef_conflict***)PTR_timer_handles_08007770_08007770;\n  if (*timer_handles != NULL) {\n    HAL_TIM_IRQHandler(*timer_handles);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007760",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08007760"
        },
        "FUN_08008850": {
            "renaming": {
                "FUN_08008850": "returnOne_08008850",
                "file_UNUSED": "fileUnused",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int returnOne_08008850() {\n  int result = 1;\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008850",
            "calling": [
                "_isatty_r"
            ],
            "imported": false,
            "current_name": "returnOne_08008850"
        },
        "FUN_08002fc2": {
            "renaming": {
                "FUN_08002fc2": "setPinState_08002fc2",
                "pin": "pinNumber",
                "state": "pinState",
                "this": "firmataClassInstance"
            },
            "code": "void __thiscall setPinState_08002fc2(FirmataClass *this, byte pin, int state)\n{\n  this->pinState[pin] = state;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fc2",
            "calling": [
                "setPinValueCallback",
                "digitalWriteCallback",
                "analogWriteCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "setPinState_08002fc2"
        },
        "FUN_08008afa": {
            "renaming": {
                "FUN_08008afa": "getReceivedDataSize_08008afa",
                "this": "serialInstance",
                "_serial": "serialData",
                "rx_head": "head",
                "rx_tail": "tail"
            },
            "code": "int __thiscall getReceivedDataSize_08008afa(HardwareSerial *this)\n{\n  int head = (this->_serial).rx_head;\n  int tail = (this->_serial).rx_tail;\n  int size = (head + 0x40) - tail & 0x3f;\n  return size;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008afa",
            "calling": [
                "serialEventRun"
            ],
            "imported": false,
            "current_name": "getReceivedDataSize_08008afa"
        },
        "FUN_08003048": {
            "renaming": {
                "FUN_08003048": "begin_08003048",
                "this": "firmataInstance",
                "speed": "baudRate",
                "s": "serialPtr",
                "PTR_Serial2_08003068": "serial2Ptr",
                "HardwareSerial::FUN_08003048": "HardwareSerial::begin",
                "'\\x06'": "SERIAL_8N1"
            },
            "code": "void __thiscall begin_08003048(FirmataClass *firmataInstance,long speed)\n{\n  undefined *serialPtr;\n  serialPtr = PTR_Serial2_08003068;\n  HardwareSerial::begin_08003048((HardwareSerial *)PTR_Serial2_08003068,speed,'\\x06');\n  blinkVersion(firmataInstance);\n  begin_08003048(firmataInstance,(Stream *)serialPtr);\n  return;\n}",
            "called": [
                "begin",
                "blinkVersion",
                "begin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003048",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "begin_08003048"
        },
        "FUN_080038dc": {
            "renaming": {
                "FUN_080038dc": "get_ADC_data_080038dc",
                "hadc": "adc_handler"
            },
            "code": "uint32_t get_ADC_data_080038dc(ADC_HandleTypeDef *adc_handler)\n{\n  return adc_handler->Instance->DR;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080038dc",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "get_ADC_data_080038dc"
        },
        "FUN_080025ac": {
            "renaming": {
                "FUN_080025ac": "setServoLimits_080025ac",
                "this": "servo",
                "pin": "pin",
                "min": "min_angle",
                "max": "max_angle",
                "obj": "servoTimerISR",
                "bVar1": "isTimerActive",
                "iVar2": "min_pulse_width, max_pulse_width",
                "timer": "timer",
                "PTR_servos_08002628": "servoPins",
                "DAT_0800262c": "servoTimers",
                "PTR__timer_08002630": "servoTimers"
            },
            "code": "uint8_t __thiscall setServoLimits_080025ac(Servo *servo,int pin,int min_angle,int max_angle)\n{\n  boolean isTimerActive;\n  int min_pulse_width;\n  int max_pulse_width;\n  timer16_Sequence_t timer;\n  if (servo->servoIndex < 0xc) {\n    pinMode(pin, OUTPUT);\n    PTR_servos_08002628[(uint)servo->servoIndex * 8] = PTR_servos_08002628[(uint)servo->servoIndex * 8] & 0xc0 | (byte)pin & 0x3f;\n    min_pulse_width = -min_angle + 0x220;\n    if (min_pulse_width < 0) {\n      min_pulse_width = -min_angle + 0x223;\n    }\n    servo->min_angle = (int8_t)((uint)(min_pulse_width << 0x16) >> 0x18);\n    max_pulse_width = -max_angle + 0x960;\n    if (max_pulse_width < 0) {\n      max_pulse_width = -max_angle + 0x963;\n    }\n    servo->max_angle = (int8_t)((uint)(max_pulse_width << 0x16) >> 0x18);\n    timer = (timer16_Sequence_t)\n            (uint)((ulonglong)DAT_0800262c * (ulonglong)servo->servoIndex >> 0x23);\n    isTimerActive = isTimerActive(timer);\n    if (!isTimerActive) {\n      DAT_0800262c[0x44] = timer;\n      initISR((stimer_t *)servoTimerISR);\n    }\n    PTR_servos_08002628[(uint)servo->servoIndex * 8] = PTR_servos_08002628[(uint)servo->servoIndex * 8] | 0x40;\n  }\n  return servo->servoIndex;\n}",
            "called": [
                "pinMode",
                "isTimerActive",
                "initISR"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080025ac",
            "calling": [
                "attachServo",
                "attach"
            ],
            "imported": false,
            "current_name": "setServoLimits_080025ac"
        },
        "FUN_08007648": {
            "renaming": {
                "FUN_08007648": "initializeTimer_08007648",
                "obj": "timer",
                "period": "period",
                "pulseWidth": "pulseWidth",
                "irqHandle": "irqHandle",
                "HVar1": "status",
                "uVar2": "timerFrequency",
                "htim": "timerHandle",
                "sConfig": "timerConfig",
                "OCMode": "TIM_OCMODE_PWM1",
                "Pulse": "pulseWidth",
                "OCPolarity": "TIM_OCPOLARITY_HIGH",
                "OCNPolarity": "TIM_OCNPOLARITY_HIGH",
                "OCFastMode": "TIM_OCFAST_DISABLE",
                "OCIdleState": "TIM_OCIDLESTATE_RESET",
                "OCNIdleState": "TIM_OCNIDLESTATE_RESET",
                "Instance": "Instance",
                "Prescaler": "Init.Prescaler",
                "ClockDivision": "Init.ClockDivision",
                "CounterMode": "Init.CounterMode",
                "RepetitionCounter": "Init.RepetitionCounter",
                "irqHandleOC": "irqHandleOC",
                "getTimerClkFreq": "getTimerClockFrequency",
                "getTimerIrq": "getTimerIRQ"
            },
            "code": "void initializeTimer_08007648(stimer_t_conflict *timer, uint16_t period, uint16_t pulseWidth, _func_void_stimer_t_ptr_uint32_t_conflict *irqHandle) {\n  HAL_StatusTypeDef_conflict status;\n  uint32_t timerFrequency;\n  TIM_HandleTypeDef_conflict *timerHandle;\n  TIM_OC_InitTypeDef timerConfig;\n  timerConfig.OCMode = TIM_OCMODE_PWM1;\n  timerConfig.Pulse = pulseWidth;\n  timerConfig.OCPolarity = TIM_OCPOLARITY_HIGH;\n  timerConfig.OCNPolarity = TIM_OCNPOLARITY_HIGH;\n  timerConfig.OCFastMode = TIM_OCFAST_DISABLE;\n  timerConfig.OCIdleState = TIM_OCIDLESTATE_RESET;\n  timerConfig.OCNIdleState = TIM_OCNIDLESTATE_RESET;\n  timerHandle = &timer->handle;\n  timer->timer = TIM1;\n  timerHandle->Instance = TIM1;\n  timerHandle->Init.Period = period;\n  timerFrequency = getTimerClkFreq(TIM1);\n  timerHandle->Init.Prescaler = (uint32_t)(((uint64_t)timerFrequency * (uint64_t)TIMER_PRESCALER) >> 32) - 1;\n  timerHandle->Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;\n  timerHandle->Init.CounterMode = TIM_COUNTERMODE_UP;\n  timerHandle->Init.RepetitionCounter = 0;\n  timer->irqHandleOC = irqHandle;\n  status = HAL_TIM_OC_Init(timerHandle);\n  if ((status == HAL_OK) && (status = HAL_TIM_OC_ConfigChannel(timerHandle, &timerConfig, TIM_CHANNEL_1), status == HAL_OK)) {\n    HAL_TIM_OC_Start_IT(timerHandle, TIM_CHANNEL_1);\n  }\n  uint32_t timerIrq = getTimerIrq(timer->timer);\n  HAL_NVIC_SetPriority((IRQn_Type_conflict)timerIrq, 0xE, 0);\n  HAL_NVIC_EnableIRQ((IRQn_Type_conflict)timerIrq);\n}\n",
            "called": [
                "getTimerIrq",
                "HAL_NVIC_EnableIRQ",
                "HAL_TIM_OC_Start_IT",
                "getTimerClkFreq",
                "HAL_NVIC_SetPriority",
                "HAL_TIM_OC_ConfigChannel",
                "HAL_TIM_OC_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007648",
            "calling": [
                "initISR"
            ],
            "imported": false,
            "current_name": "initializeTimer_08007648"
        },
        "FUN_08008858": {
            "renaming": {
                "FUN_08008858": "calculate_checksum_08008858",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "data_buffer",
                "len_UNUSED": "buffer_length"
            },
            "code": "int calculate_checksum_08008858(int file_descriptor, char *data_buffer, int buffer_length) {\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008858",
            "calling": [
                "_read_r"
            ],
            "imported": false,
            "current_name": "calculate_checksum_08008858"
        },
        "FUN_08004a20": {
            "renaming": {
                "FUN_08004a20": "do_nothing_08004a20"
            },
            "code": "\nvoid do_nothing_08004a20(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a20",
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a20"
        },
        "FUN_08004a24": {
            "renaming": {
                "FUN_08004a24": "i2c_transfer_08004a24",
                "hi2c": "i2c_handle",
                "pbVar2": "data_ptr",
                "HVar1": "current_state"
            },
            "code": "HAL_StatusTypeDef i2c_transfer_08004a24(I2C_HandleTypeDef *i2c_handle)\n{\n  HAL_I2C_StateTypeDef current_state = i2c_handle->State;\n  if (i2c_handle->XferCount != 0) {\n    uint8_t *data_ptr = i2c_handle->pBuffPtr;\n    i2c_handle->pBuffPtr = data_ptr + 1;\n    i2c_handle->Instance->DR = (uint)*data_ptr;\n    i2c_handle->XferCount--;\n    if ((i2c_handle->XferCount == 0) && (current_state == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2c_handle->Instance->CR2 &= 0xfffffbff;\n      i2c_handle->PreviousState = 0x21;\n      i2c_handle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(i2c_handle);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a24",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_transfer_08004a24"
        },
        "FUN_08004a22": {
            "renaming": {
                "FUN_08004a22": "do_nothing_08004a22"
            },
            "code": "\nvoid do_nothing_08004a22(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a22",
            "calling": [
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_AF"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a22"
        },
        "FUN_08002fba": {
            "renaming": {
                "FUN_08002fba": "getPinState_08002fba",
                "pin": "pin",
                "this": "this",
                "pinState": "pinState"
            },
            "code": "int __thiscall getPinState_08002fba(FirmataClass *this, byte pin) {\n  return this->pinState[pin];\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fba",
            "calling": [
                "sysexCallback",
                "digitalWriteCallback"
            ],
            "imported": false,
            "current_name": "getPinState_08002fba"
        },
        "FUN_080090cc": {
            "renaming": {
                "FUN_080090cc": "print_assertion_failed_080090cc",
                "param_1": "stream",
                "param_2": "file",
                "param_3": "assertion",
                "param_4": "line",
                "puVar1": "assertion_string",
                "puVar2": "message_string",
                "PTR_s__08009104": "assertion_string_constant",
                "PTR_s___function__080090fc": "message_string_constant",
                "PTR_s_assertion___s__failed__file___s__08009100": "assertion_failed_format_string",
                "PTR__impure_ptr_080090f8": "impure_ptr_address"
            },
            "code": "void print_assertion_failed_080090cc(FILE* stream, const char* file, int line, const char* function, const char* assertion, const char* message)\n{\n  const char* assertion_string = assertion ? assertion : \"\";\n  const char* message_string = message ? message : \"\";\n  fprintf(stream, \"Assertion '%s' failed in function %s() [%s:%d]\\n%s\\n\", assertion_string, function, file, line, message_string);\n  abort();\n}",
            "called": [
                "abort",
                "fiprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090cc",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "print_assertion_failed_080090cc"
        },
        "FUN_080049e0": {
            "renaming": {
                "FUN_080049e0": "listen_mode_080049e0",
                "hi2c": "i2c_handle",
                "pIVar1": "i2c_instance",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "I2C_TypeDef_conflict": "I2C_TypeDef",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "HAL_StatusTypeDef listen_mode_080049e0(I2C_HandleTypeDef *i2c_handle)\n{\n  I2C_TypeDef *i2c_instance;\n  \n  if (i2c_handle->State != HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  i2c_handle->State = HAL_I2C_STATE_LISTEN;\n  i2c_instance = i2c_handle->Instance;\n  if ((i2c_instance->CR1 & 1) == 0) {\n    i2c_instance->CR1 |= 1;\n  }\n  i2c_instance->CR1 |= 0x400;\n  i2c_instance->CR2 |= 0x300;\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080049e0",
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "i2c_attachSlaveTxEvent",
                "HAL_I2C_ErrorCallback",
                "i2c_attachSlaveRxEvent"
            ],
            "imported": false,
            "current_name": "listen_mode_080049e0"
        },
        "FUN_08006d24": {
            "renaming": {
                "FUN_08006d24": "update_ADC_status_08006d24",
                "hadc": "adc_handle",
                "DAT_08006d7c": "data_pointer",
                "DAT_08006d74": "ADC_INSTANCE_1",
                "DAT_08006d78": "ADC_INSTANCE_2",
                "iVar1": "data_pointer",
                "register_pointer": "register_pointer"
            },
            "code": "void update_ADC_status_08006d24(ADC_HandleTypeDef *adc_handle)\n{\n  int DAT_08006d7c = DAT_08006d7c;\n  if (adc_handle->Instance != DAT_08006d74) {\n    if (adc_handle->Instance == DAT_08006d78) {\n      uint* register_pointer = (uint*)(DAT_08006d7c + 0xc);\n      *register_pointer |= 0x400;\n      register_pointer = (uint*)(DAT_08006d7c + 0xc);\n      *register_pointer &= 0xfffffbff;\n      register_pointer = (uint*)(DAT_08006d7c + 0x18);\n      *register_pointer &= 0xfffffbff;\n      *register_pointer &= 0xfffffbff;\n    }\n    return;\n  }\n  uint* register_pointer = (uint*)(DAT_08006d7c + 0xc);\n  *register_pointer |= 0x200;\n  register_pointer = (uint*)(DAT_08006d7c + 0xc);\n  *register_pointer &= 0xfffffdff;\n  register_pointer = (uint*)(DAT_08006d7c + 0x18);\n  *register_pointer &= 0xfffffdff;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d24",
            "calling": [
                "HAL_ADC_DeInit"
            ],
            "imported": false,
            "current_name": "update_ADC_status_08006d24"
        },
        "FUN_08008500": {
            "renaming": {
                "FUN_08008500": "transmit_data_via_uart_08008500",
                "data": "data_buffer",
                "size": "data_size",
                "pin": "pin_name",
                "HVar1": "hal_status",
                "uVar2": "start_time_ms",
                "pvVar3": "peripheral_ptr",
                "uVar4": "current_time_ms",
                "uVar5": "uart_handler_index",
                "current_handler_index": "current_uart_handler_index"
            },
            "code": "size_t transmit_data_via_uart_08008500(uint8_t *data, uint32_t size)\n{\n  PinName_conflict pin_name;\n  HAL_StatusTypeDef_conflict hal_status;\n  uint32_t start_time_ms;\n  void *peripheral_ptr;\n  uint32_t uart_handler_index;\n  uint8_t current_handler_index = 0;\n\n  start_time_ms = HAL_GetTick();\n  pin_name = PTR_digitalPin_080085a8[1];\n  peripheral_ptr = pinmap_peripheral(pin_name, (PinMap_conflict *)PTR_PinMap_UART_TX_080085ac);\n  if (peripheral_ptr == (void *)0x0) {\n    return 0;\n  }\n  while ((current_handler_index < 5 && ((*(int *)(PTR_uart_handlers_080085b0 + current_handler_index * 4) == 0 || (peripheral_ptr = pinmap_peripheral(pin_name, (PinMap_conflict *)PTR_PinMap_UART_TX_080085ac), **(void ***)(PTR_uart_handlers_080085b0 + current_handler_index * 4) != peripheral_ptr))))) {\n    current_handler_index++;\n  }\n  if (4 < current_handler_index) {\n    if ((4 < (byte)PTR_serial_debug_080085b4[0x44]) && (uart_debug_init(), 4 < (byte)PTR_serial_debug_080085b4[0x44])) {\n      return 0;\n    }\n    current_handler_index = (uint)(byte)PTR_serial_debug_080085b4[0x44];\n  }\n  do {\n    hal_status = HAL_UART_Transmit(*(UART_HandleTypeDef **)(PTR_uart_handlers_080085b0 + current_handler_index * 4), data, (uint16_t)size, 1000);\n    if (hal_status == HAL_OK) {\n      return size;\n    }\n  } while (HAL_GetTick() - start_time_ms < 1000);\n  return 0;\n}",
            "called": [
                "HAL_UART_Transmit",
                "HAL_GetTick",
                "uart_debug_init",
                "pinmap_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008500",
            "calling": [
                "_write"
            ],
            "imported": false,
            "current_name": "transmit_data_via_uart_08008500"
        },
        "FUN_08007774": {
            "renaming": {
                "FUN_08007774": "handle_timer_interrupt_08007774",
                "PTR_timer_handles_08007784": "PTR_timer_handles",
                "TIM_HandleTypeDef_conflict": "TimerHandle",
                "timer_handle": "timer_handle",
                "HAL_TIM_IRQHandler": "handle_timer_interrupt_request"
            },
            "code": "void handle_timer_interrupt_08007774(void)\n{\n  TIM_HandleTypeDef_conflict* timer_handle = *(TIM_HandleTypeDef_conflict**)(PTR_timer_handles_08007784_08007784 + 4);\n  if (timer_handle != NULL) {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007774",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08007774"
        },
        "FUN_08005e6c": {
            "renaming": {
                "FUN_08005e6c": "do_nothing_08005e6c"
            },
            "code": "\nvoid do_nothing_08005e6c(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e6c",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08005e6c"
        },
        "FUN_080001a8": {
            "renaming": {
                "FUN_080001a8": "check_and_set_pin_state_080001a8",
                "pin": "pin_number",
                "value": "pin_value",
                "ulPin": "pin_index",
                "bVar1": "is_valid_pin",
                "bVar2": "pin_mode",
                "uVar3": "digital_pin_number"
            },
            "code": "void check_and_set_pin_state_080001a8(byte pin, int value)\n{\n  bool is_valid_pin = false;\n  byte pin_mode;\n  uint32_t digital_pin_number;\n  uint32_t analog_pin_number = (uint)pin - 14;\n  uint32_t pin_index = (uint)pin;\n\n  if (pin_index < 0x3c) {\n    if (PTR_digitalPin_0800020c[pin_index] != NC) {\n      digital_pin_number = pinNametoDigitalPin(PTR_digitalPin_0800020c[pin_index]);\n      if (digital_pin_number > 1) {\n        is_valid_pin = true;\n      }\n    }\n  }\n\n  if (is_valid_pin) {\n    pin_mode = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000210, pin);\n    if (pin_mode == OUTPUT) {\n      firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_08000210, pin, value);\n      digitalWrite(digital_pin_number, value);\n    }\n    else if (pin_mode == INPUT) {\n      analogWrite(analog_pin_number, value);\n    }\n  }\n}\n",
            "called": [
                "pinNametoDigitalPin",
                "digitalWrite",
                "getPinMode",
                "setPinState"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001a8",
            "calling": [],
            "imported": false,
            "current_name": "check_and_set_pin_state_080001a8"
        },
        "FUN_080048c8": {
            "renaming": {
                "FUN_080048c8": "i2c_listen_080048c8",
                "hi2c": "handle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "options",
                "HVar1": "status",
                "I2C_TypeDef_conflict": "I2C_TypeDef",
                "pIVar2": "instance",
                "tmpreg": "tmpreg"
            },
            "code": "HAL_StatusTypeDef i2c_listen_080048c8(I2C_HandleTypeDef *handle, uint8_t *data, uint16_t size, uint32_t options)\n{\n  HAL_StatusTypeDef status;\n  I2C_TypeDef *instance;\n  uint32_t tmpreg;\n  \n  if (handle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == NULL || size == 0 || handle->Lock == HAL_LOCKED) {\n      status = HAL_ERROR;\n    }\n    else {\n      handle->Lock = HAL_LOCKED;\n      instance = handle->Instance;\n      if ((instance->CR1 & 1) == 0) {\n        instance->CR1 |= 1;\n      }\n      instance->CR1 &= 0xfffff7ff;\n      handle->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      handle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      handle->ErrorCode = 0;\n      handle->pBuffPtr = data;\n      handle->XferCount = size;\n      handle->XferOptions = options;\n      handle->XferSize = handle->XferCount;\n      handle->Lock = HAL_UNLOCKED;\n      instance->CR2 |= 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080048c8",
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "imported": false,
            "current_name": "i2c_listen_080048c8"
        },
        "FUN_08009954": {
            "renaming": {
                "FUN_08009954": "copy_string_08009954",
                "__dest": "destination",
                "__src": "source",
                "__n": "num",
                "cVar1": "current_char",
                "sVar2": "remaining_chars",
                "pcVar3": "dest_ptr",
                "pcVar4": "dest_ptr_prev"
            },
            "code": "char* copy_string_08009954(char* destination, const char* source, size_t num)\n{\n  char current_char;\n  size_t remaining_chars;\n  char* dest_ptr = destination;\n  const char* src_ptr = source;\n  do {\n    remaining_chars = num;\n    if (remaining_chars == 0) {\n      return destination;\n    }\n    current_char = *src_ptr;\n    dest_ptr++;\n    *dest_ptr = current_char;\n    src_ptr++;\n    num = remaining_chars - 1;\n  } while (current_char != '\\0');\n  for (; dest_ptr != destination + remaining_chars; dest_ptr++) {\n    *dest_ptr = '\\0';\n  }\n  return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009954",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "copy_string_08009954"
        },
        "FUN_08005e6e": {
            "renaming": {
                "FUN_08005e6e": "handle_TIM_interrupt_08005e6e",
                "htim": "TIM_handle",
                "pTVar1": "tim_instance",
                "SR": "Status_Register",
                "DIER": "DMA_Interrupt_Enable_Register",
                "Channel": "Active_Channel"
            },
            "code": "void handle_TIM_interrupt_08005e6e(TIM_HandleTypeDef_conflict *htim)\n{\n  TIM_TypeDef_conflict *tim_instance;\n  tim_instance = htim->Instance;\n  if (((tim_instance->SR & TIM_FLAG_CC1) != 0) && ((tim_instance->DIER & TIM_IT_CC1) != 0)) {\n    tim_instance->SR = ~TIM_FLAG_CC1;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n    if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  tim_instance = htim->Instance;\n  if (((tim_instance->SR & TIM_FLAG_CC2) != 0) && ((tim_instance->DIER & TIM_IT_CC2) != 0)) {\n    tim_instance->SR = ~TIM_FLAG_CC2;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n    if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  tim_instance = htim->Instance;\n  if (((tim_instance->SR & TIM_FLAG_CC3) != 0) && ((tim_instance->DIER & TIM_IT_CC3) != 0)) {\n    tim_instance->SR = ~TIM_FLAG_CC3;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n    if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  tim_instance = htim->Instance;\n  if (((tim_instance->SR & TIM_FLAG_CC4) != 0) && ((tim_instance->DIER & TIM_IT_CC4) != 0)) {\n    tim_instance->SR = ~TIM_FLAG_CC4;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n    if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  tim_instance = htim->Instance;\n  if (((tim_instance->SR & TIM_FLAG_UPDATE) != 0) && ((tim_instance->DIER & TIM_IT_UPDATE) != 0)) {\n    tim_instance->SR = ~TIM_FLAG_UPDATE;\n    HAL_TIM_PeriodElapsedCallback(htim);\n  }\n  tim_instance = htim->Instance;\n  if (((tim_instance->SR & TIM_FLAG_BREAK) != 0) && ((tim_instance->DIER & TIM_IT_BREAK) != 0)) {\n    tim_instance->SR = ~TIM_FLAG_BREAK;\n    HAL_TIMEx_BreakCallback(htim);\n  }\n  tim_instance = htim->Instance;\n  if (((tim_instance->SR & TIM_FLAG_TRIGGER) != 0) && ((tim_instance->DIER & TIM_IT_TRIGGER) != 0)) {\n    tim_instance->SR = ~TIM_FLAG_TRIGGER;\n    HAL_TIM_TriggerCallback(htim);\n  }\n  tim_instance = htim->Instance;\n  if (((tim_instance->SR & TIM_FLAG_COM) != 0) && ((tim_instance->DIER & TIM_IT_COM) != 0)) {\n    tim_instance->SR = ~TIM_FLAG_COM;\n    HAL_TIMEx_CommutationCallback(htim);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIMEx_BreakCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_PWM_PulseFinishedCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e6e",
            "calling": [
                "TIM2_IRQHandler",
                "TIM3_IRQHandler",
                "TIM4_IRQHandler",
                "TIM1_UP_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_TIM_interrupt_08005e6e"
        },
        "FUN_08004024": {
            "renaming": {
                "FUN_08004024": "set_clock_source_08004024",
                "CLKSource": "source",
                "DAT_08004040": "clock_register"
            },
            "code": "void set_clock_source_08004024(uint32_t source) {\n  if (source != 4) {\n    *DAT_08004040 = *DAT_08004040 & 0xfffffffb;\n    return;\n  }\n  *DAT_08004040 = *DAT_08004040 | 4;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004024",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "set_clock_source_08004024"
        },
        "FUN_08005e6a": {
            "renaming": {
                "FUN_08005e6a": "do_nothing_08005e6a"
            },
            "code": "\nvoid do_nothing_08005e6a(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e6a",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08005e6a"
        },
        "FUN_08004a1e": {
            "renaming": {
                "FUN_08004a1e": "do_nothing_08004a1e"
            },
            "code": "\nvoid do_nothing_08004a1e(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a1e",
            "calling": [
                "I2C_MasterTransmit_TXE",
                "I2C_MasterTransmit_BTF"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a1e"
        },
        "FUN_08008868": {
            "renaming": {
                "FUN_08008868": "wait_for_status_08008868",
                "status_UNUSED": "status"
            },
            "code": "void wait_for_status_08008868(int status)\n{\n  while(true) {\n    // Do nothing block with infinite loop\n  }\n}",
            "called": [
                "_exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008868",
            "calling": [
                "abort",
                "_exit"
            ],
            "imported": false,
            "current_name": "wait_for_status_08008868"
        },
        "FUN_080036ac": {
            "renaming": {
                "FUN_080036ac": "find_digital_pin_index_080036ac",
                "p": "pin",
                "uVar1": "index"
            },
            "code": "uint32_t find_digital_pin_index_080036ac(PinName_conflict pin) {\n  uint32_t index = 0;\n  if ((uint)((int)pin << 0x18) >> 0x1c < 5) {\n    while (index < 0x3c && ((int)pin != (int)(char)PTR_digitalPin_080036d0[index])) {\n      index++;\n    }\n  }\n  else {\n    index = 0xffffffff;\n  }\n  return index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036ac",
            "calling": [
                "setPinValueCallback",
                "sysexCallback",
                "systemResetCallback",
                "digitalWriteCallback",
                "checkDigitalInputs",
                "reportDigitalCallback",
                "enableI2CPins",
                "analogWriteCallback",
                "loop",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "find_digital_pin_index_080036ac"
        },
        "FUN_0800885c": {
            "renaming": {
                "FUN_0800885c": "send_debug_info_0800885c",
                "file_UNUSED": "file_unused",
                "ptr": "data_ptr",
                "len": "data_len",
                "sVar1": "data_size"
            },
            "code": "int send_debug_info_0800885c(int file_unused, char *data_ptr, int data_len)\n{\n  size_t data_size;\n  data_size = uart_send_debug_info_0800885c((uint8_t *)data_ptr, data_len);\n  return data_size;\n}",
            "called": [
                "uart_debug_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800885c",
            "calling": [
                "_write_r"
            ],
            "imported": false,
            "current_name": "send_debug_info_0800885c"
        },
        "FUN_0800643c": {
            "renaming": {
                "FUN_0800643c": "configure_timer_0800643c",
                "*htim": "*timer_handle",
                "Channel": "channel",
                "BDTR": "TIM_BDTR_MOE",
                "CR1": "TIM_CR1_CEN"
            },
            "code": "HAL_StatusTypeDef configure_timer_0800643c(TIM_HandleTypeDef *timer_handle, uint32_t channel)\n{\n  TIM_CCxNChannelCmd(timer_handle->Instance, channel, TIM_CCxN_ENABLE);\n  timer_handle->Instance->BDTR |= TIM_BDTR_MOE;\n  timer_handle->Instance->CR1 |= TIM_CR1_CEN;\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800643c",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "configure_timer_0800643c"
        },
        "FUN_08002fca": {
            "renaming": {
                "FUN_08002fca": "blinkPin_08002fca",
                "pin": "pinNumber",
                "count": "blinkCount",
                "onInterval": "onDuration",
                "offInterval": "offDuration",
                "uVar1": "counter"
            },
            "code": "void __thiscall blinkPin_08002fca(FirmataClass *this, byte pin, int blinkCount, int onDuration, int offDuration)\n{\n  uint8_t counter;\n  for (counter = 0; counter < blinkCount; counter++) {\n    delay(offDuration);\n    digitalWrite((uint8_t)pin, HIGH);\n    delay(onDuration);\n    digitalWrite((uint8_t)pin, LOW);\n  }\n  return;\n}",
            "called": [
                "digitalWrite",
                "delay"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fca",
            "calling": [
                "blinkVersion"
            ],
            "imported": false,
            "current_name": "blinkPin_08002fca"
        },
        "FUN_0800a31c": {
            "renaming": {
                "std::ctype_byname<wchar_t>::FUN_0800a31c": "set_flags",
                "FUN_0800a31c": "set_flags_0800a31c"
            },
            "code": "void set_flags_0800a31c(void)\n{\n  if (*(int *)PTR_id_0800a380 < 0) {\n    *(undefined4 *)PTR_id_0800a380 = 1;\n  }\n  if (*(int *)PTR_id_0800a384 < 0) {\n    *(undefined4 *)PTR_id_0800a384 = 1;\n  }\n  if (*(int *)PTR_id_0800a388 < 0) {\n    *(undefined4 *)PTR_id_0800a388 = 1;\n  }\n  if (*(int *)PTR_id_0800a38c < 0) {\n    *(undefined4 *)PTR_id_0800a38c = 1;\n  }\n  if (*(int *)PTR_id_0800a390 < 0) {\n    *(undefined4 *)PTR_id_0800a390 = 1;\n  }\n  if (*(int *)PTR_id_0800a394 < 0) {\n    *(undefined4 *)PTR_id_0800a394 = 1;\n  }\n  if (*(int *)PTR_id_0800a398 < 0) {\n    *(undefined4 *)PTR_id_0800a398 = 1;\n  }\n  if (*(int *)PTR_id_0800a39c < 0) {\n    *(undefined4 *)PTR_id_0800a39c = 1;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a31c",
            "calling": [],
            "imported": false,
            "current_name": "set_flags_0800a31c"
        },
        "FUN_080026f8": {
            "renaming": {
                "FUN_080026f8": "is_servo_enabled_080026f8",
                "this": "servo",
                "servoIndex": "servo_index",
                "PTR_servos_08002708": "ptr_servos",
                "byte": "servo_byte",
                "uint": "uint32_t",
                "SUB41": "masked_byte"
            },
            "code": "bool is_servo_enabled_080026f8(Servo* servo)\n{\n    uint32_t servo_index = servo->servoIndex;\n    uint32_t PTR_servos_08002708 = (uint32_t)PTR_servos_08002708;\n    uint32_t servo_byte = *(PTR_servos_08002708 + servo_index * 8);\n    uint32_t shifted_byte = servo_byte << 0x19;\n    uint32_t masked_byte = shifted_byte >> 0x1f;\n    return masked_byte == 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080026f8",
            "calling": [
                "sysexCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "is_servo_enabled_080026f8"
        },
        "FUN_08007544": {
            "renaming": {
                "FUN_08007544": "find_timer_index_08007544",
                "tim": "timer",
                "DAT_08007588": "original_timer",
                "DAT_0800758c": "second_timer",
                "PTR_s_TIM__Unknown_timer_IRQn_08007590": "timer_unknown_message"
            },
            "code": "uint32_t find_timer_index_08007544(TIM_TypeDef_conflict *timer)\n{\n  if (timer == (TIM_TypeDef_conflict *)0xffffffff) {\n    return 0;\n  }\n  if (timer == DAT_08007588) {\n    return 0x1d;\n  }\n  if (DAT_08007588 < timer) {\n    if (timer == DAT_0800758c) {\n      return 0x1e;\n    }\n    if (timer == (TIM_TypeDef_conflict *)&DAT_0800758c[0x379].DMAR) {\n      return 0x19;\n    }\n  }\n  else if (timer == (TIM_TypeDef_conflict *)0x40000000) {\n    return 0x1c;\n  }\n  iprintf(PTR_s_TIM__Unknown_timer_IRQn_08007590);\n  return 0;\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007544",
            "calling": [
                "TimerPulseInit",
                "TimerPulseDeinit"
            ],
            "imported": false,
            "current_name": "find_timer_index_08007544"
        },
        "FUN_08008990": {
            "renaming": {
                "FUN_08008990": "configure_pin_08008990",
                "ulPin": "pin_number",
                "ulMode": "mode",
                "_Var1": "is_pin_output",
                "PinName_conflict": "PinName",
                "PTR_digitalPin_08008a14": "digitalPin",
                "NC": "NC",
                "is_pin_configured": "is_pin_configured",
                "PTR_g_anOutputPinConfigured_08008a18": "output_pin_configured",
                "pin_in_pinmap": "pin_in_pinmap",
                "PinMap_conflict": "PinMap",
                "PTR_PinMap_PWM_08008a1c": "PinMap_PWM",
                "pwm_stop": "pwm_stop",
                "reset_pin_configured": "reset_pin_configured",
                "switch": "switch",
                "digital_io_init": "digital_io_init",
                "set_pin_configured": "set_pin_configured",
                "PTR_g_digPinConfigured_08008a20": "digital_pin_configured"
            },
            "code": "void configure_pin_08008990(uint32_t pin_number, uint32_t mode)\n{\n  _Bool is_pin_output;\n  PinName_conflict pin_name;\n  if (pin_number < 0x3c) {\n    pin_name = PTR_digitalPin_08008a14[pin_number];\n  }\n  else {\n    pin_name = NC;\n  }\n  if (pin_name != NC) {\n    is_pin_output = is_pin_configured(pin_name, (uint32_t *)PTR_g_anOutputPinConfigured_08008a18);\n    if (is_pin_output) {\n      is_pin_output = pin_in_pinmap(pin_name, (PinMap_conflict *)PTR_PinMap_PWM_08008a1c);\n      if (is_pin_output) {\n        pwm_stop(pin_name);\n      }\n      reset_pin_configured(pin_name, (uint32_t *)PTR_g_anOutputPinConfigured_08008a18);\n    }\n    switch(mode) {\n    case 0:\n      digital_io_init(pin_name, 0, 0);\n      break;\n    case 1:\n      digital_io_init(pin_name, 1, 0);\n      break;\n    case 2:\n      digital_io_init(pin_name, 0, 1);\n      break;\n    case 3:\n      digital_io_init(pin_name, 0, 2);\n    }\n    set_pin_configured(pin_name, (uint32_t *)PTR_g_digPinConfigured_08008a20);\n  }\n  return;\n}",
            "called": [
                "pwm_stop",
                "set_pin_configured",
                "is_pin_configured",
                "reset_pin_configured",
                "digital_io_init",
                "pin_in_pinmap"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008990",
            "calling": [
                "analogWrite",
                "blinkVersion",
                "attach",
                "digitalWriteCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "configure_pin_08008990"
        },
        "FUN_08004396": {
            "renaming": {
                "FUN_08004396": "set_i2c_device_address_08004396",
                "hi2c": "i2c_handle",
                "Instance": "i2c_instance",
                "DR": "data_register",
                "Devaddress": "device_address"
            },
            "code": "HAL_StatusTypeDef set_i2c_device_address_08004396(I2C_HandleTypeDef *i2c_handle, uint8_t device_address)\n{\n  i2c_handle->Instance->DR = device_address & 0xff;\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004396",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "set_i2c_device_address_08004396"
        },
        "FUN_08003fb0": {
            "renaming": {
                "FUN_08003fb0": "set_interrupt_handler_08003fb0",
                "IRQn": "IRQn",
                "uVar1": "irq_num",
                "DAT_08003fd4": "DAT_08003fd4"
            },
            "code": "void set_interrupt_handler_08003fb0(IRQn_Type_conflict IRQn)\n{\n  uint32_t irq_num = (uint32_t)IRQn;\n  if (irq_num >= 0)\n  {\n    uint32_t word_offset = (irq_num >> 5) + 0x20;\n    uint32_t bit_offset = irq_num & 0x1f;\n    *(int *)(DAT_08003fd4 + word_offset * 4) = 1 << bit_offset;\n    DataSynchronizationBarrier(0xf);\n    InstructionSynchronizationBarrier(0xf);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fb0",
            "calling": [
                "TimerPulseDeinit"
            ],
            "imported": false,
            "current_name": "set_interrupt_handler_08003fb0"
        },
        "FUN_08007788": {
            "renaming": {
                "FUN_08007788": "handle_timer_interrupt_08007788",
                "PTR_timer_handles_08007798": "PTR_timer_handles",
                "TIM_HandleTypeDef_conflict": "Timer_HandleTypeDef",
                "timer_handle": "current_timer_handle"
            },
            "code": "void handle_timer_interrupt_08007788(void)\n{\n  TIM_HandleTypeDef_conflict *timer_handle = *(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_08007798_08007798 + 8);\n  if (timer_handle != NULL) {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007788",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08007788"
        },
        "FUN_08008f0c": {
            "renaming": {
                "FUN_08008f0c": "do_nothing_08008f0c"
            },
            "code": "\nvoid do_nothing_08008f0c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f0c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "do_nothing_08008f0c"
        },
        "FUN_08002ec4": {
            "renaming": {
                "FUN_08002ec4": "getPrintVptrIndex_08002ec4",
                "this": "firmataInstance",
                "iVar1": "printVptrIndex"
            },
            "code": "int __thiscall getPrintVptrIndex_08002ec4(FirmataClass *firmataInstance) {\n  int printVptrIndex = (*(firmataInstance->FirmataStream->super_Print)._vptr_Print[2])();\n  return printVptrIndex;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ec4",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "getPrintVptrIndex_08002ec4"
        },
        "FUN_08007306": {
            "renaming": {
                "FUN_08007306": "find_peripheral_from_pin_08007306",
                "pin": "target_pin",
                "map": "pin_map"
            },
            "code": "void* find_peripheral_from_pin_08007306(PinName_conflict target_pin, PinMap_conflict* pin_map) {\n  while(true) {\n    if(pin_map->pin == NC) {\n      return (void*)0x0;\n    }\n    if(pin_map->pin == target_pin) {\n      break;\n    }\n    pin_map++;\n  }\n  return pin_map->peripheral;\n}",
            "called": [
                "pinmap_find_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007306",
            "calling": [
                "pinmap_find_peripheral",
                "pinmap_peripheral"
            ],
            "imported": false,
            "current_name": "find_peripheral_from_pin_08007306"
        },
        "FUN_08008f0e": {
            "renaming": {
                "FUN_08008f0e": "initialize_EVP_PKEY_CTX_08008f0e",
                "ctx": "context"
            },
            "code": "void initialize_EVP_PKEY_CTX_08008f0e(void)\n{\n  EVP_PKEY_CTX *context;\n  context = (EVP_PKEY_CTX *)0x3;\n  HAL_NVIC_SetPriorityGrouping(3);\n  init(context);\n  return;\n}",
            "called": [
                "init",
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f0e",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "initialize_EVP_PKEY_CTX_08008f0e"
        },
        "FUN_0800886c": {
            "renaming": {
                "FUN_0800886c": "set_errno_to_22_0800886c",
                "pid_UNUSED": "pid_unused",
                "sig_UNUSED": "sig_unused",
                "PTR_errno_08008878": "PTR_errno_08008878"
            },
            "code": "int set_errno_to_22_0800886c(int pid_unused, int sig_unused)\n{\n  *(unsigned int *)PTR_errno_08008878 = 22;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800886c",
            "calling": [
                "_kill_r"
            ],
            "imported": false,
            "current_name": "set_errno_to_22_0800886c"
        },
        "FUN_080036d4": {
            "renaming": {
                "FUN_080036d4": "do_nothing_080036d4"
            },
            "code": "\nvoid do_nothing_080036d4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036d4",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_080036d4"
        },
        "FUN_08006e68": {
            "renaming": {
                "FUN_08006e68": "FUNC_08006e68"
            },
            "code": "\nvoid FUNC_08006e68(TIM_HandleTypeDef_conflict *htim)\n\n{\n  undefined *puVar1;\n  uint32_t uVar2;\n  GPIO_TypeDef *GPIOx;\n  uint32_t tmpreg;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  puVar1 = PTR_g_current_pin_08007100;\n  uVar2 = pinmap_function(*PTR_g_current_pin_08007100,(PinMap_conflict *)PTR_PinMap_PWM_08007104);\n  timer_enable_clock(htim);\n  GPIOx = set_GPIO_Port_Clock((uint)((int)(char)*puVar1 << 0x18) >> 0x1c);\n  GPIO_InitStruct.Mode = 2;\n  GPIO_InitStruct.Pull = 0;\n  GPIO_InitStruct.Speed = 3;\n  *(uint *)(DAT_08007108 + 0x18) = *(uint *)(DAT_08007108 + 0x18) | 1;\n  switch((uVar2 << 0x11) >> 0x19) {\n  case 1:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000001;\n    break;\n  case 2:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffe | 0x7000000;\n    break;\n  case 3:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000002;\n    break;\n  case 4:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffd | 0x7000000;\n    break;\n  case 5:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000004;\n    break;\n  case 6:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffb | 0x7000000;\n    break;\n  case 7:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000008;\n    break;\n  case 8:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffff7 | 0x7000000;\n    break;\n  case 9:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000030;\n    break;\n  case 10:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffffcf | 0x7000010;\n    break;\n  case 0xb:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffffcf | 0x7000000;\n    break;\n  case 0xc:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x70000c0;\n    break;\n  case 0xd:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffff3f | 0x7000040;\n    break;\n  case 0xe:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffff3f | 0x7000000;\n    break;\n  case 0xf:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000300;\n    break;\n  case 0x10:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000200;\n    break;\n  case 0x11:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000100;\n    break;\n  case 0x12:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000000;\n    break;\n  case 0x13:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000c00;\n    break;\n  case 0x14:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffff3ff | 0x7000800;\n    break;\n  case 0x15:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffff3ff | 0x7000000;\n    break;\n  case 0x16:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7001000;\n    break;\n  case 0x17:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffefff | 0x7000000;\n    break;\n  case 0x1b:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7008000;\n    break;\n  case 0x1c:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffff7fff | 0x7000000;\n    break;\n  case 0x21:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff;\n    break;\n  case 0x22:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x1000000;\n    break;\n  case 0x23:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x2000000;\n    break;\n  case 0x24:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x4000000;\n  }\n  GPIO_InitStruct.Pin = 1 << (*PTR_g_current_pin_08007100 & 0xf) & 0xffff;\n  HAL_GPIO_Init(GPIOx,&GPIO_InitStruct);\n  return;\n}\n\n",
            "called": [
                "timer_enable_clock",
                "set_GPIO_Port_Clock",
                "HAL_GPIO_Init",
                "pinmap_function"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08006e68",
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "imported": false,
            "current_name": "FUNC_08006e68"
        },
        "FUN_080036d8": {
            "renaming": {
                "FUN_080036d8": "configureSysTick_080036d8",
                "TickPriority": "tickPriority",
                "uVar1": "clockSpeed",
                "PTR_SystemCoreClock_0800371c": "PTR_SystemCoreClock_0800371c",
                "PTR_uwTickFreq_08003718": "PTR_uwTickFreq_08003718",
                "HAL_SYSTICK_Config": "HAL_SYSTICK_Config",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_NVIC_SetPriority": "HAL_NVIC_SetPriority",
                "SysTick_IRQn": "SysTick_IRQn",
                "PTR_uwTickPrio_08003720": "PTR_uwTickPrio_08003720",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef configureSysTick_080036d8(uint32_t tickPriority)\n{\n  uint32_t clockSpeed = *(uint *)PTR_SystemCoreClock_0800371c;\n  uint32_t tickFreq = (uint32_t)((uint64_t)clockSpeed / (1000 / (uint64_t)(byte)*PTR_uwTickFreq_08003718));\n  uint32_t systickConfig = HAL_SYSTICK_Config(tickFreq);\n  if (systickConfig != HAL_OK) {\n    return HAL_ERROR;\n  }\n  if (tickPriority > 0xf) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn, tickPriority, 0);\n  *(uint32_t *)PTR_uwTickPrio_08003720 = tickPriority;\n  return HAL_OK;\n}",
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036d8",
            "calling": [
                "HAL_Init",
                "HAL_RCC_ClockConfig"
            ],
            "imported": false,
            "current_name": "configureSysTick_080036d8"
        },
        "FUN_0800a110": {
            "renaming": {
                "FUN_0800a110": "checkInputIsTerminal_0800a110",
                "param_1": "errorNumber",
                "param_2": "fileDescriptor",
                "puVar1": "errorNumberPtr",
                "iVar2": "isTerminal"
            },
            "code": "void checkInputIsTerminal_0800a110(int *errorNumber, int fileDescriptor)\n{\n  undefined *errorNumberPtr;\n  int isTerminal;\n  errorNumberPtr = PTR_errno_0800a12c;\n  *(undefined4 *)PTR_errno_0800a12c = 0;\n  isTerminal = _isatty(fileDescriptor);\n  if ((isTerminal == -1) && (*(int *)errorNumberPtr != 0)) {\n    *errorNumber = *(int *)errorNumberPtr;\n  }\n  return;\n}",
            "called": [
                "_isatty"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a110",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "checkInputIsTerminal_0800a110"
        },
        "FUN_08003b8c": {
            "renaming": {
                "FUN_08003b8c": "check_ADC_conversion_ready_08003b8c",
                "hadc": "adc_handle",
                "uVar1": "start_time",
                "uVar2": "current_time",
                "pAVar3": "adc_instance",
                "PTR_xxx": "no_change",
                "DAT_xxx": "no_change"
            },
            "code": "HAL_StatusTypeDef check_ADC_conversion_ready_08003b8c(ADC_HandleTypeDef *adc_handle)\n{\n  uint32_t start_time = HAL_GetTick();\n  ADC_TypeDef *adc_instance = adc_handle->Instance;\n  if ((adc_instance->CR2 & ADC_CR2_ADON) == 0)\n  {\n    return HAL_OK;\n  }\n  adc_instance->CR2 = adc_instance->CR2 & ~ADC_CR2_ADON;\n  while ((adc_handle->Instance->CR2 & ADC_CR2_ADON) != 0)\n  {\n    if (HAL_GetTick() - start_time >= 3)\n    {\n      adc_handle->State |= HAL_ADC_STATE_ERROR_INTERNAL;\n      adc_handle->ErrorCode |= HAL_ADC_ERROR_INTERNAL;\n      return HAL_ERROR;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003b8c",
            "calling": [
                "HAL_ADC_DeInit",
                "HAL_ADC_Stop",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Init"
            ],
            "imported": false,
            "current_name": "check_ADC_conversion_ready_08003b8c"
        },
        "FUN_080035b8": {
            "renaming": {
                "FUN_080035b8": "initializeSystemClock_080035b8",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HVar1": "status",
                "uVar2": "hclkFrequency",
                "PeriphClkInit": "periphClockInit",
                "RCC_ClkInitStruct": "clkInit",
                "RCC_OscInitStruct": "oscInit"
            },
            "code": "void initializeSystemClock_080035b8(void)\n{\n  HAL_StatusTypeDef status;\n  uint32_t hclkFrequency;\n  RCC_PeriphCLKInitTypeDef periphClockInit;\n  RCC_ClkInitTypeDef clkInit;\n  RCC_OscInitTypeDef oscInit;\n\n  oscInit.OscillatorType = RCC_OSCILLATORTYPE_HSI;\n  oscInit.HSIState = RCC_HSI_ON;\n  oscInit.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;\n  oscInit.PLL.PLLState = RCC_PLL_ON;\n  oscInit.PLL.PLLSource = RCC_PLLSOURCE_HSI;\n  oscInit.PLL.PLLMUL = RCC_PLL_MUL16;\n  status = HAL_RCC_OscConfig(&oscInit);\n  if (status != HAL_OK) {\n    _Error_Handler(__FILE__, __LINE__);\n  }\n  clkInit.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK\n                  |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;\n  clkInit.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\n  clkInit.AHBCLKDivider = RCC_SYSCLK_DIV1;\n  clkInit.APB1CLKDivider = RCC_HCLK_DIV2;\n  clkInit.APB2CLKDivider = RCC_HCLK_DIV1;\n  status = HAL_RCC_ClockConfig(&clkInit, FLASH_LATENCY_2);\n  if (status != HAL_OK) {\n    _Error_Handler(__FILE__, __LINE__);\n  }\n  periphClockInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;\n  periphClockInit.AdcClockSelection = RCC_ADCPCLK2_DIV8;\n  status = HAL_RCCEx_PeriphCLKConfig(&periphClockInit);\n  if (status != HAL_OK) {\n    _Error_Handler(__FILE__, __LINE__);\n  }\n  hclkFrequency = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config((uint32_t)(SYSTICK_CLOCK_SOURCE_HCLK_DIV8 / (1000U / SYSTICK_INTERRUPT_FREQUENCY)));\n  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK_DIV8);\n  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);\n  return;\n}",
            "called": [
                "_Error_Handler",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_ClockConfig",
                "HAL_RCCEx_PeriphCLKConfig",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_OscConfig",
                "HAL_SYSTICK_Config",
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035b8",
            "calling": [
                "hw_config_init"
            ],
            "imported": false,
            "current_name": "initializeSystemClock_080035b8"
        },
        "FUN_08006460": {
            "renaming": {
                "FUN_08006460": "disable_tim_channel_08006460",
                "htim": "timer_handle",
                "Channel": "channel",
                "pTVar1": "timer_instance"
            },
            "code": "HAL_StatusTypeDef_conflict disable_tim_channel_08006460(TIM_HandleTypeDef_conflict *timer_handle,uint32_t channel){\n  TIM_TypeDef_conflict *timer_instance = timer_handle->Instance;\n  \n  TIM_CCxNChannelCmd(timer_instance, channel, 0);\n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->BDTR &= 0xffff7fff;\n  }\n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->CR1 &= 0xfffffffe;\n  }\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006460",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "disable_tim_channel_08006460"
        },
        "FUN_08004046": {
            "renaming": {
                "FUN_08004046": "execute_systick_callback_08004046"
            },
            "code": "void execute_systick_callback_08004046(void)\n{\n  HAL_SYSTICK_Callback();\n  return;\n}",
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004046",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "execute_systick_callback_08004046"
        },
        "FUN_08008880": {
            "renaming": {
                "FUN_08008880": "read_adc_value_08008880",
                "ulPin": "pin_number",
                "bVar1": "is_valid_pin",
                "pin": "pin_name",
                "uVar2": "adc_value",
                "uVar3": "read_value",
                "uVar4": "resolution"
            },
            "code": "uint32_t read_adc_value_08008880(uint32_t pin_number) {\n  bool is_valid_pin;\n  PinName_conflict pin_name;\n  uint16_t adc_value;\n  uint32_t read_value;\n  uint resolution;\n  \n  if (pin_number < 14) {\n    is_valid_pin = (pin_number + 46) < 60;\n  }\n  else {\n    is_valid_pin = pin_number < 60;\n  }\n  \n  if (is_valid_pin) {\n    if (pin_number < 14) {\n      pin_number += 46;\n    }\n    pin_name = PTR_digitalPin_080088d8[pin_number];\n  }\n  else {\n    pin_name = NC;\n  }\n  \n  if (pin_name == NC) {\n    read_value = 0;\n  }\n  else {\n    adc_value = adc_read_value(pin_name);\n    read_value = (uint32_t)adc_value;\n    resolution = *(uint *)PTR__readResolution_080088dc;\n    if (resolution != 12) {\n      if (resolution < 12) {\n        return (uint)(adc_value >> (12 - resolution & 0xff));\n      }\n      return read_value << (resolution - 12 & 0xff);\n    }\n  }\n  return read_value;\n}",
            "called": [
                "adc_read_value"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008880",
            "calling": [
                "reportAnalogCallback",
                "loop"
            ],
            "imported": false,
            "current_name": "read_adc_value_08008880"
        },
        "FUN_08004044": {
            "renaming": {
                "FUN_08004044": "do_nothing_08004044"
            },
            "code": "\nvoid do_nothing_08004044(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004044",
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08004044"
        },
        "FUN_08002ed2": {
            "renaming": {
                "FUN_08002ed2": "parseInput_08002ed2",
                "iVar1": "inputByte",
                "FirmataParser": "FirmataParser",
                "this": "this",
                "FirmataStream": "FirmataStream",
                "super_Print": "super_Print",
                "_vptr_Print": "_vptr_Print",
                "parse": "parse",
                "parser": "parser",
                "uint8_t": "uint8_t"
            },
            "code": "void __thiscall parseInput_08002ed2(FirmataClass *this)\n{\n  int inputByte;\n  inputByte = (*(this->FirmataStream->super_Print)._vptr_Print[3])();\n  if (inputByte != -1) {\n    FirmataParser::parse(&this->parser,(uint8_t)inputByte);\n  }\n  return;\n}",
            "called": [
                "parse"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ed2",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "parseInput_08002ed2"
        },
        "FUN_08008f1c": {
            "renaming": {
                "FUN_08008f1c": "main_loop_08008f1c",
                "initVariant": "init_variant",
                "setup": "setup",
                "loop": "run_loop",
                "DAT_08008f38": "data_flag",
                "serialEventRun": "run_serial_event"
            },
            "code": "int main_loop_08008f1c(void)\n{\n  init_variant();\n  setup();\n  do {\n    do {\n      run_loop();\n    } while (DAT_08008f38 == 0);\n    run_serial_event();\n  } while( true );\n}",
            "called": [
                "setup",
                "loop",
                "serialEventRun",
                "initVariant"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f1c",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "main_loop_08008f1c"
        },
        "FUN_080058ac": {
            "renaming": {
                "FUN_080058ac": "set_clock_config_080058ac",
                "RCC_ClkInitTypeDef_conflict": "RCC_ClkInitTypeDef",
                "RCC_ClkInitStruct": "clock_init_struct",
                "FLatency": "latency",
                "puVar1": "flash_latency",
                "uVar2": "sysclk_source",
                "uVar3": "timeout_start",
                "uVar4": "sysclk_source"
            },
            "code": "HAL_StatusTypeDef set_clock_config_080058ac(RCC_ClkInitTypeDef *clock_init_struct, uint32_t latency) {\n  uint32_t *flash_latency = DAT_08005a0c;\n  uint32_t sysclk_source;\n  uint32_t timeout_start;\n\n  if (((*flash_latency & 7) < latency) && (*flash_latency = *flash_latency & 0xfffffff8 | latency, latency != (*flash_latency & 7))) {\n    return HAL_ERROR;\n  }\n\n  if ((clock_init_struct->ClockType & RCC_CLOCKTYPE_HCLK) != 0) {\n    DAT_08005a10[1] = DAT_08005a10[1] & 0xffffff0f | clock_init_struct->AHBCLKDivider;\n  }\n\n  if ((clock_init_struct->ClockType & RCC_CLOCKTYPE_SYSCLK) != 0) {\n    sysclk_source = clock_init_struct->SYSCLKSource;\n    if (sysclk_source == RCC_SYSCLKSOURCE_PLLCLK) {\n      if ((*DAT_08005a10 & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((sysclk_source != RCC_SYSCLKSOURCE_HSI) && ((*DAT_08005a10 & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSE)) {\n      return HAL_ERROR;\n    }\n    DAT_08005a10[1] = sysclk_source | DAT_08005a10[1] & 0xfffffffc;\n    timeout_start = HAL_GetTick();\n    if (sysclk_source == RCC_SYSCLKSOURCE_PLLCLK) {\n      while ((DAT_08005a10[1] & RCC_FLAG_PLLRDY) == RESET) {\n        if (HAL_GetTick() - timeout_start > 5000) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else if (sysclk_source == RCC_SYSCLKSOURCE_HSE) {\n      while ((DAT_08005a10[1] & RCC_FLAG_HSERDY) == RESET) {\n        if (HAL_GetTick() - timeout_start > 5000) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      while ((DAT_08005a10[1] & RCC_FLAG_HSIRDY) == RESET) {\n        if (HAL_GetTick() - timeout_start > 5000) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n\n  flash_latency = DAT_08005a0c;\n  if ((latency < (*DAT_08005a0c & 7)) && (*DAT_08005a0c = *DAT_08005a0c & 0xfffffff8 | latency, latency != (*flash_latency & 7))) {\n    return HAL_ERROR;\n  }\n\n  if ((clock_init_struct->ClockType & RCC_CLOCKTYPE_PCLK1) != 0) {\n    DAT_08005a10[1] = DAT_08005a10[1] & 0xfffff8ff | clock_init_struct->APB1CLKDivider;\n  }\n\n  if ((clock_init_struct->ClockType & RCC_CLOCKTYPE_PCLK2) != 0) {\n    DAT_08005a10[1] = DAT_08005a10[1] & 0xffffc7ff | clock_init_struct->APB2CLKDivider << 3;\n  }\n\n  uint32_t sysclk_freq = HAL_RCC_GetSysClockFreq();\n  *(uint32_t *)PTR_SystemCoreClock_08005a18 = sysclk_freq >> PTR_AHBPrescTable_08005a14[(DAT_08005a10[1] << 0x18) >> 0x1c];\n  HAL_InitTick(0xf);\n  return HAL_OK;\n}",
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_GetTick",
                "HAL_InitTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080058ac",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "set_clock_config_080058ac"
        },
        "FUN_08007438": {
            "renaming": {
                "FUN_08007438": "configure_timer_08007438",
                "htim": "timer_handle",
                "tmpreg": "dier_val",
                "tmpreg_1": "ccmr1_val",
                "tmpreg_2": "smcr_val",
                "_": "",
                "DAT_080074d0": "TIM2",
                "PTR_timer_handles_080074dc": "timer_handles",
                "TIM_HandleTypeDef_conflict": "",
                "TIM_TypeDef_conflict": "",
                "DAT_080074d4": "TIM3",
                "DAT_080074d8": "TIM4"
            },
            "code": "void configure_timer_08007438(TIM_HandleTypeDef_conflict *timer_handle) {\n  uint32_t dier_val;\n  uint32_t ccmr1_val;\n  uint32_t smcr_val;\n  \n  if (timer_handle->Instance == DAT_080074d0) {\n    dier_val = timer_handle->Instance->DIER | 0x800;\n    PTR_timer_handles_080074dc[0] = timer_handle;\n  }\n  if (timer_handle->Instance == DAT_080074d4) {\n    ccmr1_val = timer_handle->Instance->CCMR1 | 2;\n    PTR_timer_handles_080074dc[1] = timer_handle;\n  }\n  if (timer_handle->Instance == DAT_080074d8) {\n    smcr_val = timer_handle->Instance->SMCR | 4;\n    PTR_timer_handles_080074dc[2] = timer_handle;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef_conflict *)0x40000000) {\n    _DAT_4002101c |= 1;\n    PTR_timer_handles_080074dc[3] = timer_handle;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007438",
            "calling": [
                "HAL_TIM_OC_MspInit",
                "HAL_TIM_PWM_MspInit"
            ],
            "imported": false,
            "current_name": "configure_timer_08007438"
        },
        "FUN_0800306c": {
            "renaming": {
                "FUN_0800306c": "initialize_static_data_0800306c"
            },
            "code": "void initialize_static_data_0800306c(void)\n{\n  __static_initialization_and_destruction_0(1, 0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800306c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_data_0800306c"
        },
        "FUN_0800887c": {
            "renaming": {
                "FUN_0800887c": "get_process_id_0800887c"
            },
            "code": "__pid_t get_process_id_0800887c(void)\n{\n  __pid_t process_id = 1;\n  return process_id;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800887c",
            "calling": [
                "_getpid_r"
            ],
            "imported": false,
            "current_name": "get_process_id_0800887c"
        },
        "FUN_0800863c": {
            "renaming": {
                "FUN_0800863c": "activate_serial_rx_0800863c",
                "obj": "serial_obj",
                "callback": "rx_callback_function_ptr",
                "bVar1": "index_byte",
                "uVar2": "rx_active_flag"
            },
            "code": "void activate_serial_rx_0800863c(serial_t *serial_obj, _func_void_serial_t_ptr *rx_callback_function_ptr)\n{\n  byte index_byte;\n  uint8_t rx_active_flag;\n  \n  if (serial_obj != NULL)\n  {\n    rx_active_flag = serial_rx_active(serial_obj);\n    if (rx_active_flag == 0)\n    {\n      index_byte = serial_obj->index;\n      *( _func_void_serial_t_ptr **)(PTR_rx_callback_08008688 + (uint)index_byte * 4) = rx_callback_function_ptr;\n      *(serial_t **)(PTR_rx_callback_obj_0800868c + (uint)index_byte * 4) = serial_obj;\n      HAL_NVIC_SetPriority(serial_obj->irq, 0, 1);\n      HAL_NVIC_EnableIRQ(serial_obj->irq);\n      HAL_UART_Receive_IT(*(UART_HandleTypeDef **)(PTR_uart_handlers_08008690 + (uint)serial_obj->index * 4), &serial_obj->recv, 1);\n    }\n  }\n}",
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority",
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800863c",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "activate_serial_rx_0800863c"
        },
        "FUN_08004050": {
            "renaming": {
                "FUN_08004050": "set_DMA_channel_to_ready_state_08004050",
                "hdma": "dma_handle",
                "hdma->State": "dma_handle->State",
                "hdma->ErrorCode": "dma_handle->ErrorCode",
                "hdma->Instance": "dma_handle->Instance",
                "DMA_Channel_TypeDef_conflict": "DMA_Channel_TypeDef",
                "DMA_HandleTypeDef_conflict": "DMA_HandleTypeDef",
                "pDVar2": "channel_instance",
                "DAT_080040e0": "PTR_DAT_080040e0"
            },
            "code": "HAL_StatusTypeDef set_DMA_channel_to_ready_state_08004050(DMA_HandleTypeDef *dma_handle)\n{\n  uint32_t channel_id;\n  DMA_Channel_TypeDef *channel_instance;\n  if (dma_handle->State != HAL_DMA_STATE_BUSY) {\n    dma_handle->ErrorCode = 4;\n    return HAL_ERROR;\n  }\n  channel_instance = dma_handle->Instance;\n  channel_instance->CCR &= ~(DMA_CCR_EN | DMA_CCR_DIR);\n  if (channel_instance == DAT_080040e0) {\n    channel_id = 1;\n  }\n  else if (channel_instance == (DMA_Channel_TypeDef *)&DAT_080040e0[1].CNDTR) {\n    channel_id = 0x10;\n  }\n  else if (channel_instance == (DMA_Channel_TypeDef *)&DAT_080040e0[2].CPAR) {\n    channel_id = 0x100;\n  }\n  else if (channel_instance == (DMA_Channel_TypeDef *)&DAT_080040e0[3].CMAR) {\n    channel_id = 0x1000;\n  }\n  else if (channel_instance == DAT_080040e0 + 5) {\n    channel_id = 0x10000;\n  }\n  else if (channel_instance == (DMA_Channel_TypeDef *)&DAT_080040e0[6].CNDTR) {\n    channel_id = 0x100000;\n  }\n  else {\n    channel_id = 0x1000000;\n  }\n  *(uint32_t *)(PTR_DAT_080040e4 + 4) = channel_id;\n  dma_handle->State = HAL_DMA_STATE_READY;\n  dma_handle->Lock = HAL_UNLOCKED;\n  if (dma_handle->XferAbortCallback != (void (*) (DMA_HandleTypeDef *))0x0) {\n    (*dma_handle->XferAbortCallback)(dma_handle);\n    return HAL_OK;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004050",
            "calling": [
                "I2C_ITError",
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "set_DMA_channel_to_ready_state_08004050"
        },
        "FUN_08008e14": {
            "renaming": {
                "FUN_08008e14": "initializeIPAddress_08008e14",
                "__initialize_p": "should_initialize",
                "__priority": "priority_level"
            },
            "code": "void initializeIPAddress_08008e14(int should_initialize, int priority_level) {\n  if (should_initialize == 1 && priority_level == 0xffff) {\n    IPAddress::IPAddress((IPAddress *)PTR_INADDR_NONE_08008e3c, '\\0', '\\0', '\\0', '\\0');\n    return;\n  }\n  return;\n}",
            "called": [
                "IPAddress"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e14",
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "imported": false,
            "current_name": "initializeIPAddress_08008e14"
        },
        "FUN_08005a28": {
            "renaming": {
                "FUN_08005a28": "get_HCLK_frequency_divider_08005a28",
                "DAT_08005a40": "data_08005a40",
                "PTR_APBPrescTable_08005a44": "prescaler_table_08005a44"
            },
            "code": "uint32_t get_HCLK_frequency_divider_08005a28(void)\n{\n  uint32_t HCLK_frequency = HAL_RCC_GetHCLKFreq();\n  uint32_t prescaler_index = (uint)(*(int *)(DAT_08005a40 + 4) << 0x15) >> 0x1d;\n  uint32_t prescaler_value = PTR_APBPrescTable_08005a44[prescaler_index];\n  return HCLK_frequency >> prescaler_value;\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a28",
            "calling": [
                "getTimerClkFreq",
                "HAL_I2C_Init",
                "UART_SetConfig"
            ],
            "imported": false,
            "current_name": "get_HCLK_frequency_divider_08005a28"
        },
        "FUN_08008ac6": {
            "renaming": {
                "FUN_08008ac6": "update_tx_tail_08008ac6",
                "obj": "serial_obj",
                "iVar3": "next_tail",
                "uVar1": "new_tail",
                "uVar2": "updated_tail"
            },
            "code": "int update_tx_tail_08008ac6(serial_t_conflict *serial_obj)\n{\n  int next_tail = serial_obj->tx_tail + 1;\n  ushort new_tail = (ushort)next_tail & 0x7f;\n  if (next_tail == 0) {\n    new_tail = -(-next_tail & 0x7f);\n  }\n  serial_obj->tx_tail = new_tail;\n  if (serial_obj->tx_head != serial_obj->tx_tail) {\n    return 0;\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ac6",
            "calling": [],
            "imported": false,
            "current_name": "update_tx_tail_08008ac6"
        },
        "FUN_08003002": {
            "renaming": {
                "FUN_08003002": "initializePins_08003002",
                "FUN_08003002Disabled": "disabled",
                "0xd": "13",
                "'\r'": "'\\r'",
                "0x28": "40",
                "0xd2": "210",
                "0xfa": "250",
                "0x7d": "125"
            },
            "code": "void __thiscall initializePins_08003002(FirmataClass *this)\n{\n  if (this->disabled != false) {\n    return;\n  }\n  pinMode(13, OUTPUT);\n  strobeBlinkPin(this, '\\r', 2, 40, 210);\n  delay(250);\n  strobeBlinkPin(this, '\\r', 5, 40, 210);\n  delay(125);\n  return;\n}",
            "called": [
                "pinMode",
                "strobeBlinkPin",
                "delay"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003002",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "initializePins_08003002"
        },
        "FUN_08008ac4": {
            "renaming": {
                "FUN_08008ac4": "do_nothing_08008ac4"
            },
            "code": "\nvoid do_nothing_08008ac4(uint32_t ms)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ac4",
            "calling": [
                "blinkVersion",
                "strobeBlinkPin"
            ],
            "imported": false,
            "current_name": "do_nothing_08008ac4"
        },
        "FUN_08003366": {
            "renaming": {
                "FUN_08003366": "setStringCallback_08003366",
                "command": "cmd",
                "newFunction": "callback",
                "context": "ctx",
                "currentStringCallback": "current_callback",
                "currentStringCallbackContext": "current_callback_ctx"
            },
            "code": "void __thiscall setStringCallback_08003366(FirmataParser *this, uint8_t command, stringCallbackFunction newFunction, void *context) {\n  if (command == 'q') {\n    this->currentStringCallback = newFunction;\n    this->currentStringCallbackContext = context;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003366",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "setStringCallback_08003366"
        },
        "FUN_080091b0": {
            "renaming": {
                "FUN_080091b0": "copy_memory_080091b0",
                "__dest": "destination",
                "__src": "source",
                "__n": "num_bytes",
                "puVar1": "src_ptr",
                "puVar2": "dest_ptr"
            },
            "code": "void * copy_memory_080091b0(void *destination, const void *source, size_t num_bytes) {\n  unsigned char *dest_ptr = (unsigned char *)destination - 1;\n  const unsigned char *src_ptr = (const unsigned char *)source + num_bytes;\n  for (; source != src_ptr; source = (void *)((int)source + 1)) {\n    dest_ptr++;\n    *dest_ptr = *(unsigned char *)source;\n  }\n  return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091b0",
            "calling": [
                "write",
                "_realloc_r",
                "onReceiveService"
            ],
            "imported": false,
            "current_name": "copy_memory_080091b0"
        },
        "FUN_08009908": {
            "renaming": {
                "FUN_08009908": "allocate_memory_08009908",
                "__ptr": "ptr",
                "__size": "size",
                "pvVar1": "allocated_memory"
            },
            "code": "void * allocate_memory_08009908(void *ptr, size_t size) {\n  void *allocated_memory;\n  allocated_memory = (void *)_allocate_memory_08009908_r(*(undefined4 *)PTR__impure_ptr_08009914, ptr, size);\n  return allocated_memory;\n}",
            "called": [
                "_realloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009908",
            "calling": [
                "write",
                "write",
                "allocateRxBuffer"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009908"
        },
        "FUN_08008abc": {
            "renaming": {
                "FUN_08008abc": "get_current_milli_seconds_08008abc",
                "uVar1": "current_milli_seconds"
            },
            "code": "uint32_t get_current_milli_seconds_08008abc(void)\n{\n  uint32_t current_milli_seconds = GetCurrentMilli();\n  return current_milli_seconds;\n}",
            "called": [
                "GetCurrentMilli"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008abc",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "get_current_milli_seconds_08008abc"
        },
        "FUN_08002b68": {
            "renaming": {
                "FUN_08002b68": "readFromAddress_08002b68",
                "this": "wire",
                "address": "address",
                "quantity": "quantity",
                "iaddress": "internal_address",
                "isize": "internal_address_size",
                "sendStop": "send_stop",
                "iVar1": "status",
                "uVar2": "size"
            },
            "code": "uint8_t __thiscall readFromAddress_08002b68(TwoWire *wire,uint8_t address,uint8_t quantity,uint32_t internal_address,uint8_t internal_address_size,uint8_t send_stop)\n{\n  i2c_status_e_conflict status;\n  uint8_t size = (uint8_t)internal_address_size;\n  if (wire->master == false) {\n    return 0;\n  }\n  wire->allocateRxBuffer((uint8_t)quantity);\n  if (*(int *)wire->rxBuffer != 0) {\n    if (size != 0) {\n      wire->beginTransmission(address);\n      if (3 < size) {\n        size = 3;\n      }\n      while( true ) {\n        if (size == 0) break;\n        (**(wire->super_Stream).super_Print._vptr_Print)\n                  (wire,internal_address >> ((size - 1 & 0x1f) << 3) & 0xff);\n        size = size - 1 & 0xff;\n      }\n      wire->endTransmission(send_stop);\n    }\n    status = wire->i2c_master_read((i2c_t_conflict *)&wire->_i2c,address << 1,\n                            *(uint8_t **)wire->rxBuffer,(ushort)quantity);\n    if (status != I2C_OK) {\n      quantity = 0;\n    }\n    *wire->rxBufferIndex = 0;\n    *wire->rxBufferLength = quantity;\n    return quantity;\n  }\n  (wire->super_Stream).super_Print.write_error = 1;\n  return 0;\n}",
            "called": [
                "i2c_master_read",
                "beginTransmission",
                "endTransmission",
                "allocateRxBuffer"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002b68",
            "calling": [
                "requestFrom"
            ],
            "imported": false,
            "current_name": "readFromAddress_08002b68"
        },
        "FUN_080005e0": {
            "renaming": {
                "FUN_080005e0": "disableI2C_080005e0",
                "PTR_isI2CEnabled_080005f0": "is_I2C_Enabled",
                "PTR_queryIndex_080005f4": "query_Index"
            },
            "code": "void disableI2C_080005e0(void)\n{\n  *PTR_isI2CEnabled_080005f0 = 0;\n  *PTR_queryIndex_080005f4 = 0xff;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080005e0",
            "calling": [
                "systemResetCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "disableI2C_080005e0"
        },
        "FUN_0800674c": {
            "renaming": {
                "FUN_0800674c": "do_nothing_0800674c"
            },
            "code": "\nvoid do_nothing_0800674c(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800674c",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_0800674c"
        },
        "FUN_0800674e": {
            "renaming": {
                "FUN_0800674e": "initialize_uart_0800674e",
                "huart": "uart_handle",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "PTR_": "",
                "DAT_": "",
                "gState": "global_state",
                "Lock": "lock",
                "Instance": "instance",
                "CR1": "control_register1",
                "CR2": "control_register2",
                "CR3": "control_register3",
                "ErrorCode": "error_code",
                "RxState": "receive_state"
            },
            "code": "DAT_PDAT_TDAT_RDAT__DAT_HDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_LDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_SDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_sDAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT_yDAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_DDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_ initialize_uart_0800674e(DAT_PDAT_TDAT_RDAT__DAT_UDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_HDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT_yDAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_DDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_hDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_{DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_hDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_!DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_NDAT_PDAT_TDAT_RDAT__DAT_UDAT_PDAT_TDAT_RDAT__DAT_LDAT_PDAT_TDAT_RDAT__DAT_LDAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_{DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_hDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_-DAT_PDAT_TDAT_RDAT__DAT_>DAT_PDAT_TDAT_RDAT__DAT_gDAT_PDAT_TDAT_RDAT__DAT_SDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_HDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_LDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_UDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_SDAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT_EDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_EDAT_PDAT_TDAT_RDAT__DAT_SDAT_PDAT_TDAT_RDAT__DAT_EDAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_{DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_hDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_-DAT_PDAT_TDAT_RDAT__DAT_>DAT_PDAT_TDAT_RDAT__DAT_LDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_cDAT_PDAT_TDAT_RDAT__DAT_kDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_HDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_LDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_UDAT_PDAT_TDAT_RDAT__DAT_NDAT_PDAT_TDAT_RDAT__DAT_LDAT_PDAT_TDAT_RDAT__DAT_ODAT_PDAT_TDAT_RDAT__DAT_CDAT_PDAT_TDAT_RDAT__DAT_KDAT_PDAT_TDAT_RDAT__DAT_EDAT_PDAT_TDAT_RDAT__DAT_DDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_HDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_LDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_UDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_MDAT_PDAT_TDAT_RDAT__DAT_sDAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_hDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_}DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_hDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_-DAT_PDAT_TDAT_RDAT__DAT_>DAT_PDAT_TDAT_RDAT__DAT_gDAT_PDAT_TDAT_RDAT__DAT_SDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_HDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_LDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_UDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_SDAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT_EDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_BDAT_PDAT_TDAT_RDAT__DAT_UDAT_PDAT_TDAT_RDAT__DAT_SDAT_PDAT_TDAT_RDAT__DAT_YDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_hDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_-DAT_PDAT_TDAT_RDAT__DAT_>DAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_sDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_cDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_-DAT_PDAT_TDAT_RDAT__DAT_>DAT_PDAT_TDAT_RDAT__DAT_CDAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_1DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_&DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_xDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_UDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_SDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_CDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_gDAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_hDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_hDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_-DAT_PDAT_TDAT_RDAT__DAT_>DAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_sDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_cDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_-DAT_PDAT_TDAT_RDAT__DAT_>DAT_PDAT_TDAT_RDAT__DAT_CDAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_2DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_&DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_xDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_bDAT_PDAT_TDAT_RDAT__DAT_7DAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_hDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_-DAT_PDAT_TDAT_RDAT__DAT_>DAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_sDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_cDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_-DAT_PDAT_TDAT_RDAT__DAT_>DAT_PDAT_TDAT_RDAT__DAT_CDAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_3DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_&DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_xDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_5DAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_hDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_-DAT_PDAT_TDAT_RDAT__DAT_>DAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_sDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_cDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_-DAT_PDAT_TDAT_RDAT__DAT_>DAT_PDAT_TDAT_RDAT__DAT_CDAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_1DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_|DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_xDAT_PDAT_TDAT_RDAT__DAT_2DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_hDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_-DAT_PDAT_TDAT_RDAT__DAT_>DAT_PDAT_TDAT_RDAT__DAT_EDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_CDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_hDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_-DAT_PDAT_TDAT_RDAT__DAT_>DAT_PDAT_TDAT_RDAT__DAT_gDAT_PDAT_TDAT_RDAT__DAT_SDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_HDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_LDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_UDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_SDAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT_EDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_EDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_DDAT_PDAT_TDAT_RDAT__DAT_YDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_hDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_-DAT_PDAT_TDAT_RDAT__DAT_>DAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_xDAT_PDAT_TDAT_RDAT__DAT_SDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_HDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_LDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_UDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_SDAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT_EDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_EDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_DDAT_PDAT_TDAT_RDAT__DAT_YDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_HDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_LDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_ODAT_PDAT_TDAT_RDAT__DAT_KDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_}DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_HDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_LDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_EDAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_ODAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_}DAT_PDAT_TDAT_RDAT__DAT_",
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800674e",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_0800674e"
        },
        "FUN_0800771c": {
            "renaming": {
                "FUN_0800771c": "handle_timer_interrupt_0800771c",
                "htim": "timer_handle",
                "psVar1": "timer_obj",
                "irqHandleOC": "interrupt_handler"
            },
            "code": "void handle_timer_interrupt_0800771c(TIM_HandleTypeDef_conflict *timer_handle) {\n  stimer_t_conflict *timer_obj;\n  timer_obj = get_timer_object(timer_handle);\n  if ((timer_obj->interrupt_handler != (_func_void_stimer_t_ptr_uint32_t_conflict *)0x0) && (timer_handle->Channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*timer_obj->interrupt_handler)(timer_obj, 0);\n  }\n  return;\n}",
            "called": [
                "get_timer_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800771c",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_timer_interrupt_0800771c"
        },
        "FUN_08003370": {
            "renaming": {
                "FUN_08003370": "setSysexCallback_08003370",
                "this": "thisPointer",
                "command": "commandByte",
                "newFunction": "callbackFunction",
                "context": "callbackContext"
            },
            "code": "void __thiscall setSysexCallback_08003370(FirmataParser *thisPointer, uint8_t command, sysexCallbackFunction newFunction, void *context) {\n  thisPointer->currentSysexCallback = newFunction;\n  thisPointer->currentSysexCallbackContext = context;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003370",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "setSysexCallback_08003370"
        },
        "FUN_08003376": {
            "renaming": {
                "FUN_08003376": "handleDataBufferOverflow_08003376",
                "this": "parser",
                "data": "data",
                "pos": "position",
                "bVar1": "bufferOverflowed",
                "dataBufferSize": "dataBufferSize",
                "currentDataBufferOverflowCallback": "currentDataBufferOverflowCallback",
                "allowBufferUpdate": "allowBufferUpdate",
                "currentDataBufferOverflowCallbackContext": "currentDataBufferOverflowCallbackContext",
                "dataBuffer": "dataBuffer"
            },
            "code": "bool __thiscall handleDataBufferOverflow_08003376(FirmataParser *parser, uint8_t data, size_t position) {\n  bool bufferOverflowed;\n  if (position >= parser->dataBufferSize) {\n    bufferOverflowed = true;\n    if (parser->currentDataBufferOverflowCallback != (dataBufferOverflowCallbackFunction)0x0) {\n      parser->allowBufferUpdate = true;\n      (*parser->currentDataBufferOverflowCallback)(parser->currentDataBufferOverflowCallbackContext);\n      bufferOverflowed = position >= parser->dataBufferSize;\n    }\n  } else {\n    bufferOverflowed = false;\n    parser->dataBuffer[position] = data;\n  }\n  return bufferOverflowed;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003376",
            "calling": [
                "parse",
                "processSysexMessage"
            ],
            "imported": false,
            "current_name": "handleDataBufferOverflow_08003376"
        },
        "FUN_08008bf4": {
            "renaming": {
                "FUN_08008bf4": "checkSerial2Availability_08008bf4",
                "DAT_08008c18": "serial2Enabled",
                "PTR_Serial2_08008c1c": "serial2"
            },
            "code": "void checkSerial2Availability_08008bf4(void)\n{\n    if (DAT_08008c18)\n    {\n        HardwareSerial::available(PTR_Serial2_08008c1c);\n    }\n    return;\n}",
            "called": [
                "available"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008bf4",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "checkSerial2Availability_08008bf4"
        },
        "FUN_08002c7c": {
            "renaming": {
                "FUN_08002c7c": "reportAnalogRead_08002c7c",
                "param_1": "callback",
                "command": "pin",
                "value": "value",
                "PTR_currentReportAnalogCallback_08002c8c": "currentReportAnalogCallback"
            },
            "code": "void reportAnalogRead_08002c7c(void *callback, uint8_t pin, uint16_t value) {\n  if (*(code **)PTR_currentReportAnalogCallback_08002c8c != (code *)0x0) {\n    (**(code **)PTR_currentReportAnalogCallback_08002c8c)(pin, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c7c",
            "calling": [],
            "imported": false,
            "current_name": "reportAnalogRead_08002c7c"
        },
        "FUN_08005430": {
            "renaming": {
                "FUN_08005430": "getI2CErrorCode_08005430",
                "hi2c": "i2cHandle"
            },
            "code": "uint32_t getI2CErrorCode_08005430(I2C_HandleTypeDef_conflict *i2cHandle) {\n  return i2cHandle->ErrorCode;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005430",
            "calling": [
                "i2c_master_read",
                "i2c_master_write"
            ],
            "imported": false,
            "current_name": "getI2CErrorCode_08005430"
        },
        "FUN_08009918": {
            "renaming": {
                "FUN_08009918": "allocate_memory_08009918",
                "param_1": "memory_address",
                "param_2": "memory_size",
                "puVar1": "errno_ptr",
                "pcVar2": "sbrk_result"
            },
            "code": "void allocate_memory_08009918(int *memory_address, int memory_size) {\n  undefined *errno_ptr;\n  caddr_t sbrk_result;\n  \n  errno_ptr = PTR_errno_08009934;\n  *(undefined4 *)PTR_errno_08009934 = 0;\n  sbrk_result = _sbrk(memory_size);\n  if ((sbrk_result == (caddr_t)0xffffffff) && (*(int *)errno_ptr != 0)) {\n    *memory_address = *(int *)errno_ptr;\n  }\n  return;\n}",
            "called": [
                "_sbrk"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009918",
            "calling": [
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009918"
        },
        "FUN_08005434": {
            "renaming": {
                "FUN_08005434": "delay_in_milliseconds_08005434",
                "mdelay": "milliseconds",
                "Delay": "delay_cycles",
                "bVar1": "delay_finished",
                "DAT_0800545c": "system_core_clock_frequency",
                "PTR_SystemCoreClock_08005458": "SystemCoreClockPointer"
            },
            "code": "void delay_in_milliseconds_08005434(uint32_t milliseconds)\n{\n  bool delay_finished;\n  uint32_t delay_cycles = milliseconds * (uint)((ulonglong)DAT_0800545c * (ulonglong)*PTR_SystemCoreClock_08005458 >> 0x29);\n  do {\n    delay_finished = delay_cycles != 0;\n    delay_cycles--;\n  } while (delay_finished);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005434",
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "imported": false,
            "current_name": "delay_in_milliseconds_08005434"
        },
        "FUN_08005e2e": {
            "renaming": {
                "FUN_08005e2e": "check_pwm_output_state_08005e2e",
                "htim": "timer_handle",
                "HAL_TIM_STATE_BUSY": "TIM_BUSY",
                "TIM_TypeDef_conflict": "timer_instance",
                "pTVar1": "timer_instance",
                "CCER": "capture_compare_enable_register",
                "CR1": "control_register_1",
                "HAL_TIM_PWM_MspDeInit": "deinitialize_pwm_gpio",
                "HAL_TIM_STATE_RESET": "TIM_RESET",
                "HAL_UNLOCKED": "TIM_UNLOCKED",
                "HAL_OK": "TIM_OK"
            },
            "code": "HAL_StatusTypeDef_conflict check_pwm_output_state_08005e2e(TIM_HandleTypeDef_conflict *timer_handle)\n{\n  TIM_TypeDef_conflict *timer_instance;\n  \n  timer_handle->State = HAL_TIM_STATE_BUSY;\n  timer_instance = timer_handle->Instance;\n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->CR1 = timer_instance->CR1 & 0xfffffffe;\n  }\n  HAL_TIM_PWM_MspDeInit(timer_handle);\n  timer_handle->State = HAL_TIM_STATE_RESET;\n  timer_handle->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}",
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e2e",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "check_pwm_output_state_08005e2e"
        },
        "FUN_08007736": {
            "renaming": {
                "FUN_08007736": "handle_timer_interrupt_08007736",
                "htim": "timer_handle",
                "psVar1": "timer_obj",
                "get_timer_obj": "get_timer_object",
                "irqHandle": "interrupt_handler"
            },
            "code": "void handle_timer_interrupt_08007736(TIM_HandleTypeDef_conflict *timer_handle) {\n  stimer_t_conflict *timer_obj;\n  timer_obj = get_timer_object(timer_handle);\n  if (timer_obj->interrupt_handler != (_func_void_stimer_t_ptr_conflict *)0x0) {\n    (*timer_obj->interrupt_handler)(timer_obj);\n  }\n  return;\n}",
            "called": [
                "get_timer_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007736",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_timer_interrupt_08007736"
        },
        "FUN_08002c90": {
            "renaming": {
                "FUN_08002c90": "reportDigitalCallback_08002c90",
                "param_1": "callbackFunction",
                "command": "command",
                "value": "value",
                "PTR_currentReportDigitalCallback_08002ca0": "currentReportDigitalCallback"
            },
            "code": "void reportDigitalCallback_08002c90(void *callbackFunction, uint8_t command, uint16_t value) {\n  if (*(code **)PTR_currentReportDigitalCallback_08002ca0 != (code *)0x0) {\n    (**(code **)PTR_currentReportDigitalCallback_08002ca0)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c90",
            "calling": [],
            "imported": false,
            "current_name": "reportDigitalCallback_08002c90"
        },
        "FUN_0800542a": {
            "renaming": {
                "FUN_0800542a": "get_i2c_state_0800542a",
                "hi2c": "i2c_handle",
                "HAL_I2C_StateTypeDef_conflict": "HAL_I2C_StateTypeDef"
            },
            "code": "HAL_I2C_StateTypeDef get_i2c_state_0800542a(I2C_HandleTypeDef *i2c_handle)\n{\n  return i2c_handle->State;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800542a",
            "calling": [
                "i2c_master_read",
                "i2c_master_write"
            ],
            "imported": false,
            "current_name": "get_i2c_state_0800542a"
        },
        "FUN_0800457c": {
            "renaming": {
                "FUN_0800457c": "write_byte_to_i2c_0800457c",
                "hi2c": "i2c_handle",
                "pbVar1": "data_ptr",
                "XferCount": "transfer_count",
                "pBuffPtr": "data_buffer_ptr",
                "Instance": "i2c_instance"
            },
            "code": "HAL_StatusTypeDef write_byte_to_i2c_0800457c(I2C_HandleTypeDef *i2c_handle)\n{\n  uint8_t *data_ptr;\n  if (i2c_handle->XferCount != 0) {\n    data_ptr = i2c_handle->pBuffPtr;\n    i2c_handle->pBuffPtr = data_ptr + 1;\n    i2c_handle->Instance->DR = (uint8_t)*data_ptr;\n    i2c_handle->XferCount--;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800457c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "write_byte_to_i2c_0800457c"
        },
        "FUN_080091c6": {
            "renaming": {
                "FUN_080091c6": "set_memory_080091c6",
                "__s": "destination",
                "__c": "value",
                "__n": "num_bytes",
                "puVar1": "byte_pointer"
            },
            "code": "void * set_memory_080091c6(void *destination, int value, size_t num_bytes) {\n  unsigned char *byte_pointer;\n  for (byte_pointer = (unsigned char *)destination; byte_pointer != (unsigned char *)(num_bytes + (int)destination); byte_pointer++) {\n    *byte_pointer = (unsigned char)value;\n  }\n  return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091c6",
            "calling": [
                "flush",
                "pwm_start",
                "__sfmoreglue",
                "adc_read_value",
                "__sfp",
                "begin",
                "endTransmission",
                "std.isra.0"
            ],
            "imported": false,
            "current_name": "set_memory_080091c6"
        },
        "FUN_08003a20": {
            "renaming": {
                "FUN_08003a20": "configure_ADC_08003a20",
                "hadc": "adc_handle",
                "HVar1": "status",
                "uVar2": "start_time",
                "uVar3": "current_time",
                "pAVar4": "adc_instance",
                "wait_loop_index": "wait_loop_index",
                "PTR_SystemCoreClock_08003a98": "SystemCoreClock_address",
                "DAT_08003a9c": "clock_speed"
            },
            "code": "HAL_StatusTypeDef_conflict configure_ADC_08003a20(ADC_HandleTypeDef *adc_handle)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t wait_loop_index;\n  uint32_t start_time = HAL_GetTick();\n  ADC_TypeDef *adc_instance = adc_handle->Instance;\n  \n  if ((adc_instance->CR2 & 1) == 0) {\n    adc_instance->CR2 |= 1;\n    for (wait_loop_index = ((uint32_t)((ulonglong)DAT_08003a9c * (ulonglong)*(uint *)PTR_SystemCoreClock_08003a98 >> 0x32)); wait_loop_index != 0; wait_loop_index--) {\n    }\n    while ((adc_handle->Instance->CR2 & 1) == 0) {\n      if (HAL_GetTick() - start_time >= 3) {\n        adc_handle->State |= 0x10;\n        adc_handle->ErrorCode |= 1;\n        adc_handle->Lock = HAL_UNLOCKED;\n        status = HAL_ERROR;\n        return status;\n      }\n    }\n    status = HAL_OK;\n  }\n  else {\n    status = HAL_OK;\n  }\n  return status;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a20",
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Start"
            ],
            "imported": false,
            "current_name": "configure_ADC_08003a20"
        },
        "FUN_08009cdc": {
            "renaming": {
                "std_isra_0": "initialize_data_structures",
                "param_1": "data_structure",
                "param_2": "value_1",
                "param_3": "value_2",
                "uVar1": "unused_variable",
                "DAT_08009d14": "constant_1",
                "DAT_08009d18": "constant_2",
                "DAT_08009d1c": "constant_3",
                "DAT_08009d20": "constant_4",
                "FUN_08009cdc": "initialize_data_structures_08009cdc"
            },
            "code": "void initialize_data_structures_08009cdc(undefined4 *data_structure, undefined2 value_1, undefined2 value_2) {\n  data_structure[0] = 0;\n  data_structure[1] = 0;\n  data_structure[2] = 0;\n  *(undefined2 *)(data_structure + 3) = value_1;\n  data_structure[0x19] = 0;\n  *(undefined2 *)((int)data_structure + 0xe) = value_2;\n  data_structure[4] = 0;\n  data_structure[5] = 0;\n  data_structure[6] = 0;\n  memset(data_structure + 0x17, 0, 8);\n  data_structure[8] = data_structure;\n  data_structure[9] = DAT_08009d14;\n  data_structure[10] = DAT_08009d18;\n  data_structure[0xb] = DAT_08009d1c;\n  data_structure[0xc] = DAT_08009d20;\n  return;\n}",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009cdc",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "initialize_data_structures_08009cdc"
        },
        "FUN_080026b0": {
            "renaming": {
                "FUN_080026b0": "mapValueToMicroseconds_080026b0",
                "this": "servo",
                "value": "inputValue",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void __thiscall mapValueToMicroseconds_080026b0(Servo *servo,int value)\n{\n  int minValue = (0x88 - servo->min) * 4;\n  int maxValue = (600 - servo->max) * 4;\n  if (value < 0x220) {\n    if (value < 0) {\n      value = 0;\n    }\n    else if (0xb4 < value) {\n      value = 0xb4;\n    }\n    value = map(value, 0, 0xb4, minValue, maxValue);\n  }\n  mapValueToMicroseconds_080026b0Microseconds(servo, value);\n  return;\n}",
            "called": [
                "writeMicroseconds",
                "map"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080026b0",
            "calling": [
                "analogWriteCallback"
            ],
            "imported": false,
            "current_name": "mapValueToMicroseconds_080026b0"
        },
        "FUN_08002a58": {
            "renaming": {
                "FUN_08002a58": "transmitData_08002a58",
                "this": "wire",
                "sendStop": "sendStop",
                "i2c_status_e_conflict": "i2c_status",
                "iVar1": "status",
                "uVar2": "result",
                "master": "isMaster",
                "i2c_t_conflict": "i2c_t",
                "_i2c": "i2c",
                "PTR_txAddress_08002ab0": "txAddress",
                "PTR_txBuffer_08002aac": "txBuffer",
                "PTR_txBufferLength_08002aa8": "txBufferLength",
                "byte": "byteSize",
                "PTR_txBufferAllocated_08002ab4": "txBufferAllocated",
                "PTR_txBufferIndex_08002ab8": "txBufferIndex",
                "PTR_transmitting_08002abc": "transmitting"
            },
            "code": "uint8_t __thiscall transmitData_08002a58(TwoWire *wire, uint8_t sendStop){\\n  i2c_status_e_conflict status;\\n  uint8_t result;\\n  if (wire->master == false) {\\n    result = \"\\x04\";\\n  }\\n  else {\\n    status = i2c_master_write((i2c_t_conflict *)&wire->_i2c, *PTR_txAddress_08002ab0, *(uint8_t **)PTR_txBuffer_08002aac, (ushort)(byte)*PTR_PTR_txBuffer_08002aacLength_08002aa8);\\n    if (status == I2C_OK) {\\n      result = \"\\0\";\\n    }\\n    else if (status == I2C_TIMEOUT) {\\n      result = \"\\x01\";\\n    }\\n    else {\\n      result = \"\\x04\";\\n    }\\n    if (*(void **)PTR_txBuffer_08002aac != (void *)0x0) {\\n      memset(*(void **)PTR_txBuffer_08002aac,0,(uint)(byte)*PTR_PTR_txBuffer_08002aacAllocated_08002ab4);\\n    }\\n    *PTR_PTR_txBuffer_08002aacIndex_08002ab8 = 0;\\n    *PTR_PTR_txBuffer_08002aacLength_08002aa8 = 0;\\n    *PTR_transmitting_08002abc = 0;\\n  }\\n  return result;\\n}",
            "called": [
                "memset",
                "i2c_master_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a58",
            "calling": [
                "requestFrom",
                "endTransmission",
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "transmitData_08002a58"
        },
        "FUN_080004d4": {
            "renaming": {
                "FUN_080004d4": "initialize_servos_080004d4",
                "__initialize_p": "should_initialize",
                "__priority": "priority_level",
                "iVar1": "servo_index",
                "this": "current_servo",
                "PTR_servos_080004fc": "servo_array_ptr"
            },
            "code": "void initialize_servos_080004d4(int should_initialize, int priority_level)\n{\n  int servo_index;\n  Servo *current_servo;\n  \n  if (should_initialize != 1) {\n    return;\n  }\n  if (priority_level == 0xffff) {\n    current_servo = (Servo *)PTR_servos_080004fc;\n    for (servo_index = 0xb; -1 < servo_index; servo_index--) {\n      Servo::Servo(current_servo);\n      current_servo++;\n    }\n  }\n  return;\n}",
            "called": [
                "Servo"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080004d4",
            "calling": [
                "_GLOBAL__sub_I_analogInputsToReport"
            ],
            "imported": false,
            "current_name": "initialize_servos_080004d4"
        },
        "FUN_080005f8": {
            "renaming": {
                "FUN_080005f8": "FUNC_080005f8"
            },
            "code": "\nvoid FUNC_080005f8(byte pin,int mode)\n\n{\n  undefined *this;\n  byte bVar1;\n  PinName_conflict PVar2;\n  bool bVar3;\n  bool bVar4;\n  _Bool _Var5;\n  uint ulPin;\n  uint32_t uVar6;\n  char cVar7;\n  uint uVar8;\n  \n  ulPin = (uint)pin;\n  bVar1 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000874,pin);\n  if (bVar1 != '\\x7f') {\n    bVar1 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000874,pin);\n    if (bVar1 == '\\x06') {\n      cVar7 = *PTR_isI2CEnabled_0800087c;\n      if (cVar7 == '\\0') {\n        cVar7 = '\\0';\n      }\n      else if (mode == 6) {\n        cVar7 = '\\0';\n      }\n    }\n    else {\n      cVar7 = '\\0';\n    }\n    if (cVar7 != '\\0') {\n      disableI2CPins();\n    }\n    if (ulPin < 0x3c) {\n      if (PTR_digitalPin_08000878[ulPin] == NC) {\n        bVar3 = false;\n      }\n      else {\n        uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n        if (uVar6 == 0) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 1) {\n            bVar3 = false;\n          }\n          else if (mode == 4) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    else {\n      bVar3 = false;\n    }\n    if (bVar3) {\n      if ((byte)PTR_servoPinMap_08000880[ulPin] < 0xc) {\n        bVar3 = Servo::attached((Servo *)(PTR_servos_08000884 +\n                                         (uint)(byte)PTR_servoPinMap_08000880[ulPin] * 3));\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3 != false) {\n        detachServo(pin);\n      }\n    }\n    uVar8 = ulPin - 0x2e & 0xff;\n    if (uVar8 < 0xe) {\n      if (ulPin < 0x3c) {\n        PVar2 = PTR_digitalPin_08000878[ulPin];\n      }\n      else {\n        PVar2 = NC;\n      }\n      uVar6 = pinNametoDigitalPin(PVar2);\n      if (uVar6 == 0) {\n        bVar3 = false;\n      }\n      else {\n        if (ulPin < 0x3c) {\n          PVar2 = PTR_digitalPin_08000878[ulPin];\n        }\n        else {\n          PVar2 = NC;\n        }\n        uVar6 = pinNametoDigitalPin(PVar2);\n        if (uVar6 == 1) {\n          bVar3 = false;\n        }\n        else {\n          bVar3 = true;\n        }\n      }\n    }\n    else {\n      bVar3 = false;\n    }\n    if (bVar3) {\n      reportAnalogCallback((byte)uVar8,(uint)(mode == 2));\n    }\n    if (ulPin < 0x3c) {\n      if (PTR_digitalPin_08000878[ulPin] == NC) {\n        bVar3 = false;\n      }\n      else {\n        uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n        if (uVar6 == 0) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 1) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    else {\n      bVar3 = false;\n    }\n    if (bVar3) {\n      if ((mode == 0) || (mode == 0xb)) {\n        PTR_portConfigInputs_08000888[pin >> 3] =\n             PTR_portConfigInputs_08000888[pin >> 3] | (byte)(1 << (ulPin & 7));\n      }\n      else {\n        PTR_portConfigInputs_08000888[pin >> 3] =\n             PTR_portConfigInputs_08000888[pin >> 3] & ~(byte)(1 << (ulPin & 7));\n      }\n    }\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_08000874,pin,0);\n    switch(mode) {\n    case 0:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000878[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        pinMode(ulPin,0);\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000874,pin,'\\0');\n        return;\n      }\n      break;\n    case 1:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        bVar1 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000a44,pin);\n        if (bVar1 == '\\x03') {\n          digitalWrite(ulPin,0);\n        }\n        pinMode(ulPin,1);\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x01');\n        return;\n      }\n      break;\n    case 2:\n      if (uVar8 < 0xe) {\n        if (ulPin < 0x3c) {\n          PVar2 = PTR_digitalPin_08000878[ulPin];\n        }\n        else {\n          PVar2 = NC;\n        }\n        uVar6 = pinNametoDigitalPin(PVar2);\n        if (uVar6 == 0) {\n          bVar3 = false;\n        }\n        else {\n          if (ulPin < 0x3c) {\n            PVar2 = PTR_digitalPin_08000878[ulPin];\n          }\n          else {\n            PVar2 = NC;\n          }\n          uVar6 = pinNametoDigitalPin(PVar2);\n          if (uVar6 == 1) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        if (ulPin < 0x3c) {\n          if (PTR_digitalPin_08000878[ulPin] == NC) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n            if (uVar6 == 0) {\n              bVar3 = false;\n            }\n            else {\n              uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n              if (uVar6 == 1) {\n                bVar3 = false;\n              }\n            }\n          }\n        }\n        else {\n          bVar3 = false;\n        }\n        if (bVar3) {\n          pinMode(ulPin,0);\n        }\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000874,pin,'\\x02');\n        return;\n      }\n      break;\n    case 3:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          _Var5 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            _Var5 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              _Var5 = false;\n            }\n            else {\n              _Var5 = pin_in_pinmap(PTR_digitalPin_08000a48[ulPin],\n                                    (PinMap_conflict *)PTR_PinMap_PWM_08000a4c);\n            }\n          }\n        }\n      }\n      else {\n        _Var5 = false;\n      }\n      if (_Var5 != false) {\n        pinMode(ulPin,1);\n        analogWrite(ulPin,0);\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x03');\n        return;\n      }\n      break;\n    case 4:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x04');\n        if (((byte)PTR_servoPinMap_08000a50[ulPin] != 0xff) &&\n           (bVar4 = Servo::attached((Servo *)(PTR_servos_08000a54 +\n                                             (uint)(byte)PTR_servoPinMap_08000a50[ulPin] * 3)),\n           bVar4)) {\n          bVar3 = false;\n        }\n        if (bVar3) {\n          attachServo(pin,-1,-1);\n          return;\n        }\n      }\n      break;\n    default:\n      firmata::FirmataClass::sendString\n                ((FirmataClass *)PTR_Firmata_08000a44,PTR_s_Unknown_pin_mode_08000a60);\n      break;\n    case 6:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          _Var5 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            _Var5 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              _Var5 = false;\n            }\n            else {\n              _Var5 = pin_in_pinmap(PTR_digitalPin_08000a48[ulPin],\n                                    (PinMap_conflict *)PTR_PinMap_I2C_SDA_08000a58);\n              if (!_Var5) {\n                _Var5 = pin_in_pinmap(PTR_digitalPin_08000a48[ulPin],\n                                      (PinMap_conflict *)PTR_PinMap_I2C_SCL_08000a5c);\n              }\n            }\n          }\n        }\n      }\n      else {\n        _Var5 = false;\n      }\n      if (_Var5 != false) {\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x06');\n        return;\n      }\n      break;\n    case 10:\n      break;\n    case 0xb:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000878[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        pinMode(ulPin,2);\n        this = PTR_Firmata_08000a44;\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\v');\n        firmata::FirmataClass::setPinState((FirmataClass *)this,pin,1);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "detachServo",
                "digitalWrite",
                "setPinMode",
                "attachServo",
                "disableI2CPins",
                "setPinState",
                "pinNametoDigitalPin",
                "reportAnalogCallback",
                "analogWrite",
                "attached",
                "pinMode",
                "getPinMode",
                "sendString",
                "pin_in_pinmap"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080005f8",
            "calling": [
                "sysexCallback",
                "systemResetCallback",
                "enableI2CPins"
            ],
            "imported": false,
            "current_name": "FUNC_080005f8"
        },
        "FUN_08002fa0": {
            "renaming": {
                "FUN_08002fa0": "getPinConfiguration_08002fa0",
                "pin": "pinNumber",
                "this": "firmataObject",
                "pinConfig": "pinConfiguration"
            },
            "code": "byte __thiscall getPinConfiguration_08002fa0(FirmataClass *this, byte pin) {\n  return this->pinConfig[pin];\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fa0",
            "calling": [
                "setPinValueCallback",
                "sysexCallback",
                "digitalWriteCallback",
                "analogWriteCallback",
                "loop",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "getPinConfiguration_08002fa0"
        },
        "FUN_0800a424": {
            "renaming": {
                "FUN_0800a424": "do_nothing_0800a424"
            },
            "code": "\nvoid do_nothing_0800a424(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a424",
            "calling": [
                "__libc_init_array",
                "__do_global_dtors_aux"
            ],
            "imported": false,
            "current_name": "do_nothing_0800a424"
        },
        "FUN_08003a1c": {
            "renaming": {
                "FUN_08003a1c": "get_adc_state_08003a1c",
                "hadc": "ADC_HandleTypeDef_pointer"
            },
            "code": "uint32_t get_adc_state_08003a1c(ADC_HandleTypeDef* hadc) {\n  return hadc->State;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a1c",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "get_adc_state_08003a1c"
        },
        "FUN_08007744": {
            "renaming": {
                "FUN_08007744": "get_stimer_counter_08007744",
                "obj": "timer_conf",
                "(obj->handle).Instance": "timer_handle->Instance",
                "((obj->handle).Instance)->CNT": "timer_handle->Instance->CNT"
            },
            "code": "uint32_t get_stimer_counter_08007744(stimer_t_conflict *timer_conf) {\n  TIM_HandleTypeDef* timer_handle = &(timer_conf->handle);\n  uint32_t counter_value = timer_handle->Instance->CNT;\n  return counter_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007744",
            "calling": [
                "ServoIrqHandle"
            ],
            "imported": false,
            "current_name": "get_stimer_counter_08007744"
        },
        "FUN_08006538": {
            "renaming": {
                "FUN_08006538": "set_uart_config_08006538",
                "huart": "uart",
                "uVar1": "baud_rate",
                "uVar2": "int_div",
                "uVar3": "pclk_freq",
                "uVar4": "pclk_freq",
                "uVar5": "pclk_freq",
                "uVar6": "pclk_freq",
                "uVar7": "pclk_freq",
                "uVar8": "baud_rate",
                "uVar9": "baud_rate",
                "uVar10": "baud_rate",
                "uVar11": "baud_rate",
                "pUVar12": "uart_instance",
                "DAT_080066e0": "USART1",
                "DAT_080066e4": "25"
            },
            "code": "void set_uart_config_08006538(UART_HandleTypeDef *uart)\n{\n  uint32_t pclk_freq;\n  uint32_t baud_rate = uart->Init.BaudRate;\n  uint32_t stop_bits = uart->Init.StopBits;\n  uint32_t word_length = uart->Init.WordLength;\n  uint32_t parity = uart->Init.Parity;\n  uint32_t mode = uart->Init.Mode;\n  uint32_t hw_flow_ctl = uart->Init.HwFlowCtl;\n  USART_TypeDef *uart_instance = uart->Instance;\n  \n  uart_instance->CR2 = (uart_instance->CR2 & 0xffffcfff) | stop_bits;\n  uart_instance->CR1 = word_length | parity | mode | (uart_instance->CR1 & 0xffffe9f3);\n  uart_instance->CR3 = (uart_instance->CR3 & 0xfffffcff) | hw_flow_ctl;\n  \n  if (uart_instance != DAT_080066e0) {\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n  } else {\n    pclk_freq = HAL_RCC_GetPCLK2Freq();\n  }\n  \n  uint32_t int_div = ((DAT_080066e4 * pclk_freq) / (4 * baud_rate));\n  uint32_t fractional_div = (((int_div % 100) * 16) + 50) / 100;\n  int_div /= 100;\n  \n  uart_instance->BRR = (int_div << 4) | fractional_div;\n}",
            "called": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006538",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "set_uart_config_08006538"
        },
        "FUN_08002fa8": {
            "renaming": {
                "FUN_08002fa8": "setPinConfig_08002fa8",
                "pin": "pinNum",
                "config": "configVal",
                "pinConfig": "pinConfigs"
            },
            "code": "void __thiscall setPinConfig_08002fa8(FirmataClass *this, byte pin, byte config) {\n  if (this->pinConfig[pin] != '\\x7f') {\n    this->pinConfig[pin] = config;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fa8",
            "calling": [
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "setPinConfig_08002fa8"
        },
        "FUN_0800325a": {
            "renaming": {
                "FUN_0800325a": "sendFirmataMessage_0800325a",
                "this": "marshaller",
                "command": "command",
                "bytec": "numBytes",
                "bytev": "byteArray",
                "uVar1": "index",
                "encodeByteStream": "encodeByteStream"
            },
            "code": "void __thiscall sendFirmataMessage_0800325a(FirmataMarshaller *marshaller, uint8_t command, size_t numBytes, uint8_t *byteArray) {\n  uint8_t index = 0;\n  if (marshaller->FirmataStream != (Stream *)0x0) {\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller,0xf0);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,(uint)command);\n    for (index = 0; index < numBytes; index = index + 1) {\n      encodeByteStream(marshaller, 1, byteArray + index, 0);\n    }\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,0xf7);\n  }\n  return;\n}",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800325a",
            "calling": [
                "sendString",
                "sendSysex"
            ],
            "imported": false,
            "current_name": "sendFirmataMessage_0800325a"
        },
        "FUN_080091d8": {
            "renaming": {
                "FUN_080091d8": "allocate_memory_block_080091d8",
                "param_1": "free_list",
                "param_2": "block_size",
                "param_3": "new_block",
                "param_4": "previous_block",
                "puVar1": "free_list_ptr",
                "extraout_r1": "next_block",
                "ppiVar2": "next_block",
                "ppiVar3": "next_block_end",
                "piVar4": "next_block_size",
                "ppiVar5": "current_free_block",
                "ppiVar6": "previous_block",
                "ppiVar7": "current_block"
            },
            "code": "void allocate_memory_block_080091d8(int** free_list, int block_size, int** new_block, int** previous_block) {\n  if (block_size == 0) {\n    return;\n  }\n  int** current_block = (int**)(block_size - 4);\n  if (*(int*)(block_size - 4) < 0) {\n    current_block = (int**)((int)current_block + *(int*)(block_size - 4));\n  }\n  __malloc_lock();\n  void* free_list_ptr = PTR___malloc_free_list_0800926c;\n  int** current_free_block = *(int***)(PTR___malloc_free_list_0800926c);\n  if (current_free_block == NULL) {\n    current_block[1] = NULL;\n    *(int***)free_list_ptr = current_block;\n    *new_block = current_block;\n    *previous_block = NULL;\n  }\n  else if (current_block < current_free_block) {\n    int** next_block = (int**)*current_block;\n    int** next_block_end = (int**)((int)current_block + (int)next_block);\n    if (current_free_block == next_block_end) {\n      int* next_block_size = *current_free_block;\n      current_free_block = (int**)current_free_block[1];\n      next_block_end = (int**)((int)next_block_size + (int)next_block);\n      *current_block = (int*)next_block_end;\n    }\n    current_block[1] = (int*)current_free_block;\n    *(int***)free_list_ptr = current_block;\n    *new_block = current_block;\n    *previous_block = NULL;\n  }\n  else {\n    while (current_free_block != NULL && current_free_block <= current_block) {\n      *previous_block = current_free_block;\n      current_free_block = (int**)current_free_block[1];\n    }\n    if (current_free_block == NULL) {\n      int** current_block_end = (int**)((int)current_block + (int)*current_block);\n      current_block[1] = NULL;\n      (*previous_block)[1] = current_block;\n      *new_block = current_block;\n    }\n    else if (current_block < (int**)((int)*previous_block + (int)*previous_block[0])) {\n      *new_block = NULL;\n    }\n    else {\n      int** current_block_end = (int**)((int)current_block + (int)*current_block);\n      if (current_free_block == current_block_end) {\n        int* next_block_size = *current_free_block;\n        current_free_block = (int**)current_free_block[1];\n        next_block_end = (int**)((int)next_block_size + (int)*current_block);\n        *current_block = (int*)next_block_end;\n      }\n      current_block[1] = (int*)current_free_block;\n      (*previous_block)[1] = current_block;\n      *(int***)free_list_ptr = *previous_block;\n      *new_block = current_block;\n    }\n  }\n  __malloc_unlock();\n  return;\n}",
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091d8",
            "calling": [
                "__sflush_r",
                "free",
                "__swsetup_r",
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_080091d8"
        },
        "FUN_0800688e": {
            "renaming": {
                "FUN_0800688e": "transmit_0800688e",
                "huart": "uart_handle",
                "pData": "data",
                "Size": "size",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_BUSY": "HAL_BUSY",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_LOCKED": "HAL_LOCKED",
                "pTxBuffPtr": "p_tx_buff_ptr",
                "TxXferSize": "tx_xfer_size",
                "TxXferCount": "tx_xfer_count",
                "ErrorCode": "error_code",
                "gState": "g_state",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "HAL_UART_STATE_BUSY_TX": "HAL_UART_STATE_BUSY_TX",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "Instance": "instance",
                "CR1": "CR1"
            },
            "code": "HAL_StatusTypeDef transmit_0800688e(UART_HandleTypeDef *uart_handle, uint8_t *data, uint16_t size)\n{\n  if (uart_handle->gState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (data == NULL) {\n    return HAL_ERROR;\n  }\n  if (size == 0) {\n    return HAL_ERROR;\n  }\n  if (uart_handle->Lock != HAL_LOCKED) {\n    uart_handle->pTxBuffPtr = data;\n    uart_handle->TxXferSize = size;\n    uart_handle->TxXferCount = size;\n    uart_handle->ErrorCode = 0;\n    uart_handle->gState = HAL_UART_STATE_BUSY_TX;\n    uart_handle->Lock = HAL_UNLOCKED;\n    uart_handle->Instance->CR1 |= 0x80;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800688e",
            "calling": [
                "HAL_UART_TxCpltCallback",
                "uart_attach_tx_callback"
            ],
            "imported": false,
            "current_name": "transmit_0800688e"
        },
        "FUN_080090b4": {
            "renaming": {
                "FUN_080090b4": "initialize_static_data_080090b4"
            },
            "code": "void initialize_static_data_080090b4()\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090b4",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_data_080090b4"
        },
        "FUN_0800870c": {
            "renaming": {
                "FUN_0800870c": "process_uart_data_0800870c",
                "huart": "uart_handle",
                "bVar1": "uart_index",
                "uVar2": "callback_index",
                "PTR_rx_callback_08008728": "rx_callback_ptr",
                "PTR_rx_callback_obj_0800872c": "rx_callback_obj_ptr"
            },
            "code": "void process_uart_data_0800870c(UART_HandleTypeDef *uart_handle)\n{\n  uint8_t uart_index = get_uart_index(uart_handle);\n  uint8_t callback_index = (uint8_t)uart_index;\n  if (callback_index < 5) {\n    (**(code **)(PTR_rx_callback_08008728 + callback_index * 4))\n              (*(undefined4 *)(PTR_rx_callback_obj_0800872c + callback_index * 4));\n  }\n  return;\n}",
            "called": [
                "uart_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800870c",
            "calling": [
                "UART_Receive_IT"
            ],
            "imported": false,
            "current_name": "process_uart_data_0800870c"
        },
        "FUN_08008840": {
            "renaming": {
                "FUN_08008840": "return_error_status_08008840",
                "file_UNUSED": "file_not_used"
            },
            "code": "int return_error_status_08008840(int file_not_used)\n{\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008840",
            "calling": [
                "_close_r"
            ],
            "imported": false,
            "current_name": "return_error_status_08008840"
        },
        "FUN_08008600": {
            "renaming": {
                "FUN_08008600": "receive_data_from_serial_08008600",
                "obj": "serial_obj",
                "c": "received_data",
                "uVar1": "is_rx_active"
            },
            "code": "int receive_data_from_serial_08008600(serial_t *serial_obj, uchar *received_data) {\n  uint8_t is_rx_active;\n  \n  if (serial_obj == NULL) {\n    return -1;\n  }\n  is_rx_active = serial_rx_active(serial_obj);\n  if (is_rx_active == 0) {\n    *received_data = serial_obj->recv;\n    HAL_UART_Receive_IT(*(UART_HandleTypeDef **)(PTR_uart_handlers_08008638 + (uint)serial_obj->index * 4), &serial_obj->recv, 1);\n    return 0;\n  }\n  return -1;\n}",
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008600",
            "calling": [
                "_rx_complete_irq"
            ],
            "imported": false,
            "current_name": "receive_data_from_serial_08008600"
        },
        "FUN_08003154": {
            "renaming": {
                "FUN_08003154": "setFirmataStream_08003154",
                "this": "marshaller",
                "s": "stream",
                "FirmataStream": "FirmataStream"
            },
            "code": "void __thiscall setFirmataStream_08003154(FirmataMarshaller *marshaller, Stream *stream)\n{\n  marshaller->FirmataStream = stream;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003154",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "setFirmataStream_08003154"
        },
        "FUN_08006420": {
            "renaming": {
                "FUN_08006420": "setChannelState_08006420",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelNState": "channelState",
                "CCER": "ccer"
            },
            "code": "void setChannelState_08006420(TIM_TypeDef_conflict *timer, uint32_t channel, uint32_t channelState) {\n  uint32_t ccerMask = ~(4 << (channel & 0xff));\n  uint32_t ccerValue = channelState << (channel & 0xff);\n  timer->CCER = (timer->CCER & ccerMask) | ccerValue;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006420",
            "calling": [
                "HAL_TIMEx_PWMN_Stop",
                "HAL_TIMEx_PWMN_Start"
            ],
            "imported": false,
            "current_name": "setChannelState_08006420"
        },
        "FUN_08007750": {
            "renaming": {
                "FUN_08007750": "set_timer_channel_value_08007750",
                "obj": "timer_obj",
                "channel": "channel_num",
                "value": "value",
                "&((obj->handle).Instance)->CCR1": "channel_reg",
                "[]": "[]"
            },
            "code": "void set_timer_channel_value_08007750(stimer_t_conflict *timer_obj, uint32_t channel_num, uint32_t value) {\n    uint32_t *channel_reg = &((timer_obj->handle).Instance)->CCR1;\n    channel_reg[channel_num] = value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007750",
            "calling": [
                "ServoIrqHandle"
            ],
            "imported": false,
            "current_name": "set_timer_channel_value_08007750"
        },
        "FUN_08009938": {
            "renaming": {
                "FUN_08009938": "find_char_08009938",
                "__s": "str",
                "__c": "c",
                "pbVar1": "current_char"
            },
            "code": "char* find_char_08009938(char* str, int c) {\n  byte* current_char;\n  do {\n    current_char = (byte*)str;\n    if (*current_char == 0) {\n      if ((c & 0xffU) != 0) {\n        current_char = (byte*)0x0;\n      }\n      return (char*)current_char;\n    }\n    str = (char*)(current_char + 1);\n  } while ((c & 0xffU) != (uint)*current_char);\n  return (char*)current_char;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009938",
            "calling": [
                "strrchr"
            ],
            "imported": false,
            "current_name": "find_char_08009938"
        },
        "FUN_08007f0e": {
            "renaming": {
                "FUN_08007f0e": "receive_i2c_data_08007f0e",
                "obj": "handle",
                "dev_address": "device_address",
                "data": "data",
                "size": "size",
                "HVar1": "state",
                "HVar2": "status",
                "uVar3": "start_time",
                "uVar4": "error",
                "uVar5": "elapsed_time",
                "iVar6": "status_code",
                "hi2c": "handle"
            },
            "code": "i2c_status_e receive_i2c_data_08007f0e(I2C_HandleTypeDef* handle, uint8_t device_address, uint8_t* data, uint16_t size)\n{\n  HAL_I2C_StateTypeDef state;\n  HAL_StatusTypeDef status;\n  uint32_t start_time = HAL_GetTick();\n  uint32_t elapsed_time = 0;\n  i2c_status_e status_code = I2C_ERROR;\n  do {\n    status = HAL_I2C_Master_Receive_IT(handle, device_address, data, size);\n    if (status == HAL_OK) {\n      status_code = I2C_OK;\n      while (((state = HAL_I2C_GetState(handle)) != HAL_I2C_STATE_READY) && (status_code == I2C_OK)) {\n        elapsed_time = HAL_GetTick() - start_time;\n        if (elapsed_time < 0x65) {\n          uint32_t error = HAL_I2C_GetError(handle);\n          if (error != 0) {\n            status_code = I2C_ERROR;\n          }\n        }\n        else {\n          status_code = I2C_TIMEOUT;\n        }\n      }\n    }\n    uint32_t error = HAL_I2C_GetError(handle);\n  } while ((error == 4) && (elapsed_time < 100));\n  return status_code;\n}",
            "called": [
                "HAL_I2C_Master_Receive_IT",
                "HAL_I2C_GetState",
                "HAL_GetTick",
                "HAL_I2C_GetError"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f0e",
            "calling": [
                "requestFrom"
            ],
            "imported": false,
            "current_name": "receive_i2c_data_08007f0e"
        },
        "FUN_08004004": {
            "renaming": {
                "FUN_08004004": "set_interrupt_flag_08004004",
                "IRQn": "irq",
                "uVar1": "irq_num",
                "DAT_08004020": "flag_base_address"
            },
            "code": "void set_interrupt_flag_08004004(IRQn_Type_conflict irq)\n{\n  uint irq_num;\n  irq_num = (uint)irq;\n  if (irq_num >= 0)\n  {\n    uint* flag_address = (uint*)(DAT_08004020 + ((irq_num >> 5) + 0x60) * 4);\n    *flag_address = 1 << (irq_num & 0x1f);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004004",
            "calling": [
                "USART3_IRQHandler",
                "USART2_IRQHandler",
                "USART1_IRQHandler"
            ],
            "imported": false,
            "current_name": "set_interrupt_flag_08004004"
        },
        "FUN_08003158": {
            "renaming": {
                "FUN_08003158": "sendPinValue_08003158",
                "pin": "pin_number",
                "value": "pin_value",
                "local_a": "encoded_value",
                "FirmataStream": "firmata_stream"
            },
            "code": "void __thiscall sendPinValue_08003158(FirmataMarshaller *this, uint8_t pin, uint16_t value)\n{\n  uint16_t encoded_value;\n  if (this->FirmataStream != nullptr) {\n    encoded_value = value;\n    if ((pin < 16) && (value < 16384)) {\n      (**(this->FirmataStream->super_Print)._vptr_Print)(this, pin | 0xe0);\n      encodeByteStream(this, 2, (uint8_t *)&encoded_value, 2);\n    }\n    else {\n      sendExtendedAnalog(this, pin, 2, (uint8_t *)&encoded_value);\n    }\n  }\n  return;\n}",
            "called": [
                "sendExtendedAnalog",
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003158",
            "calling": [
                "sendAnalog"
            ],
            "imported": false,
            "current_name": "sendPinValue_08003158"
        },
        "FUN_080090c2": {
            "renaming": {
                "FUN_080090c2": "register_exit_handler_080090c2",
                "param_1": "handler",
                "param_2": "arg"
            },
            "code": "void register_exit_handler_080090c2(void (*handler)(void), void *arg)\n{\n  __cxa_atexit(handler, arg);\n  return;\n}",
            "called": [
                "__cxa_atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090c2",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "register_exit_handler_080090c2"
        },
        "FUN_08000ef8": {
            "renaming": {
                "FUN_08000ef8": "FUNC_08000ef8"
            },
            "code": "\nvoid FUNC_08000ef8(void)\n\n{\n  byte bVar1;\n  bool bVar2;\n  uint32_t uVar3;\n  int iVar4;\n  byte bVar5;\n  \n  if (*PTR_reportPINs_08001188 != '\\0') {\n    bVar1 = *PTR_portConfigInputs_0800118c;\n    if (*PTR_digitalPin_08001190 == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(*PTR_digitalPin_08001190);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(*PTR_digitalPin_08001190);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_08001190[1] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[1]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[1]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(1);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001190[2] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[2]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[2]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(2);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001190[3] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[3]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[3]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(3);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001190[4] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[4]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[4]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(4);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001190[5] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[5]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[5]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(5);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001190[6] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[6]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[6]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(6);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001190[7] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[7]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[7]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(7);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\0',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_08001188[1] != '\\0') {\n    bVar1 = PTR_portConfigInputs_0800118c[1];\n    if (PTR_digitalPin_08001190[8] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[8]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[8]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(8);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_08001424[9] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[9]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[9]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(9);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001424[10] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[10]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[10]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(10);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001424[0xb] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xb]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xb]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xb);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001424[0xc] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xc]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xc]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xc);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001424[0xd] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xd]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xd]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xd);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001424[0xe] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xe]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xe]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xe);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001424[0xf] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xf]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xf]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xf);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x01',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_08001428[2] != '\\0') {\n    bVar1 = PTR_portConfigInputs_0800142c[2];\n    if (PTR_digitalPin_08001424[0x10] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0x10]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0x10]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0x10);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_080016c4[0x11] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x11]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x11]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x11);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_080016c4[0x12] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x12]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x12]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x12);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_080016c4[0x13] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x13]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x13]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x13);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_080016c4[0x14] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x14]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x14]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x14);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_080016c4[0x15] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x15]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x15]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x15);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_080016c4[0x16] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x16]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x16]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x16);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_080016c4[0x17] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x17]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x17]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x17);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x02',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_080016c8[3] != '\\0') {\n    bVar1 = PTR_portConfigInputs_080016cc[3];\n    if (PTR_digitalPin_080016c4[0x18] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x18]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x18]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0x18);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_080016c4[0x19] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x19]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x19]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x19);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001960[0x1a] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1a]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1a]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1a);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001960[0x1b] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1b]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1b]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1b);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001960[0x1c] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1c]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1c]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1c);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001960[0x1d] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1d]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1d]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1d);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001960[0x1e] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1e]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1e]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1e);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001960[0x1f] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1f]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1f]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1f);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x03',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_08001964[4] != '\\0') {\n    bVar1 = PTR_portConfigInputs_08001968[4];\n    if (PTR_digitalPin_08001960[0x20] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x20]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x20]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0x20);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_08001960[0x21] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x21]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x21]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x21);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001b44[0x22] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x22]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x22]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x22);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001b44[0x23] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x23]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x23]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x23);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001b44[0x24] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x24]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x24]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x24);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001b44[0x25] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x25]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x25]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x25);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001b44[0x26] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x26]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x26]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x26);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001b44[0x27] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x27]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x27]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x27);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x04',bVar5,'\\0');\n  }\n  return;\n}\n\n",
            "called": [
                "pinNametoDigitalPin",
                "outputPort",
                "digitalRead"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08000ef8",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "FUNC_08000ef8"
        },
        "FUN_08008846": {
            "renaming": {
                "FUN_08008846": "set_file_mode_to_directory_08008846",
                "file_UNUSED": "file_stats",
                "st": "file_stats"
            },
            "code": "int set_file_mode_to_directory_08008846(stat *file_stats){\n  file_stats->st_mode = 0x2000;\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008846",
            "calling": [
                "_fstat_r"
            ],
            "imported": false,
            "current_name": "set_file_mode_to_directory_08008846"
        },
        "FUN_0800a430": {
            "renaming": {
                "FUN_0800a430": "do_nothing_0800a430"
            },
            "code": "\nvoid do_nothing_0800a430(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a430",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0800a430"
        },
        "FUN_0800459c": {
            "renaming": {
                "FUN_0800459c": "transfer_byte_0800459c",
                "hi2c": "i2c_handle",
                "XferCount": "TransferCount",
                "pBuffPtr": "pBuffer",
                "puVar1": "buffer_pointer",
                "Instance": "Instance"
            },
            "code": "HAL_StatusTypeDef transfer_byte_0800459c(I2C_HandleTypeDef *i2c_handle)\n{\n  uint8_t *buffer_pointer;\n  \n  if (i2c_handle->TransferCount != 0) {\n    buffer_pointer = i2c_handle->pBuffer;\n    i2c_handle->pBuffer = buffer_pointer + 1;\n    *buffer_pointer = (uint8_t)i2c_handle->Instance->DR;\n    i2c_handle->TransferCount--;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800459c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "transfer_byte_0800459c"
        },
        "FUN_0800774a": {
            "renaming": {
                "FUN_0800774a": "set_timer_value_0800774a",
                "obj": "timer_object",
                "value": "timer_value",
                "(obj->handle).Instance": "timer_instance",
                "((obj->handle).Instance)->CNT": "timer_instance->CNT"
            },
            "code": "void set_timer_value_0800774a(stimer_t_conflict *timer_object, uint32_t timer_value)\n{\n  TIM_TypeDef *timer_instance = (timer_object->handle).Instance;\n  timer_instance->CNT = timer_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800774a",
            "calling": [
                "ServoIrqHandle"
            ],
            "imported": false,
            "current_name": "set_timer_value_0800774a"
        },
        "FUN_080027f0": {
            "renaming": {
                "TwoWire::FUN_080027f0": "sendData",
                "this": "wire",
                "data": "data",
                "quantity": "quantity",
                "cVar1": "current_byte",
                "puVar2": "tx_buffer_ptr",
                "iVar3": "i2c_status",
                "pvVar4": "realloc_result",
                "uVar5": "size",
                "__size": "size",
                "PTR_txBuffer_08002884": "tx_buffer",
                "*PTR_transmitting_08002878": "transmitting",
                "i2c_slave_FUN_080027f0_IT": "i2c_slave_send",
                "(i2c_t_conflict *)&this->_i2c": "(i2c_t_conflict *)&wire->_i2c",
                "I2C_OK": "I2C_SUCCESS",
                "*PTR_txBufferLength_0800287c": "tx_buffer_length",
                "*PTR_txBufferAllocated_08002880": "tx_buffer_allocated",
                "realloc": "realloc",
                "*(void **)PTR_txBuffer_08002884": "*(void **)tx_buffer",
                "memcpy": "memcpy",
                "*(int *)PTR_txBuffer_08002884": "*(int *)tx_buffer",
                "(void *)((uint)(byte)*PTR_txBufferIndex_08002888 + *(int *)PTR_txBuffer_08002884)": "(void *)((uint)(byte)*tx_buffer_index + *(int *)tx_buffer)",
                "*PTR_txBufferIndex_08002888": "tx_buffer_index",
                "(this->super_Stream).super_Print.FUN_080027f0_error": "(wire->super_Stream).super_Print.send_error",
                "FUN_080027f0": "sendData_080027f0"
            },
            "code": "size_t __thiscall sendData_080027f0(TwoWire *wire, uint8_t *data, size_t quantity) {\\n  char current_byte;\\n  undefined *PTR_txBuffer_08002884_ptr;\\n  i2c_status_e_conflict i2c_status;\\n  void *realloc_result;\\n  undefined size;\\n  \\n  PTR_txBuffer_08002884_ptr = PTR_txBuffer_08002884;\\n  if (*PTR_*PTR_transmitting_08002878_08002878 == \"\\0\") {\\n    i2c_status = i2c_slave_send((i2c_t_conflict *)&wire->_i2c, data, (uint16_t)quantity);\\n    if (i2c_status != I2C_OK) {\\n      return 0;\\n    }\\n    return quantity;\\n  }\\n  size = (byte)*PTR_txBufferLength_0800287c + quantity;\\n  if ((byte)*PTR_txBufferAllocated_08002880 < size) {\\n    if (size < 0x20) {\\n      size = 0x20;\\n    }\\n    realloc_result = realloc(*(void **)PTR_txBuffer_08002884, size);\\n    *(void **)PTR_txBuffer_08002884_ptr = realloc_result;\\n    if (realloc_result == (void *)0x0) {\\n      size = 0;\\n    }\\n    else {\\n      size = (undefined)size;\\n    }\\n    *PTR_txBufferAllocated_08002880 = size;\\n  }\\n  PTR_txBuffer_08002884_ptr = PTR_txBufferIndex_08002888;\\n  if (*(int *)PTR_txBuffer_08002884 != 0) {\\n    memcpy((void *)((uint)(byte)*PTR_txBufferIndex_08002888 + *(int *)PTR_txBuffer_08002884), data, quantity);\\n    current_byte = *PTR_txBuffer_08002884_ptr + (char)quantity;\\n    *PTR_txBuffer_08002884_ptr = current_byte;\\n    *PTR_txBufferLength_0800287c = current_byte;\\n    return quantity;\\n  }\\n  (wire->super_Stream).super_Print.sendData_080027f0_error = 1;\\n  return 0;\\n}",
            "called": [
                "memcpy",
                "realloc",
                "i2c_slave_write_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080027f0",
            "calling": [],
            "imported": false,
            "current_name": "sendData_080027f0"
        },
        "FUN_0800314e": {
            "renaming": {
                "FUN_0800314e::FUN_0800314e": "firmata::FirmataConstructor::FirmataConstructor",
                "this": "this_ptr",
                "FirmataStream": "serial_stream",
                "FUN_0800314e": "firmata::FirmataConstructor::FirmataConstructor_0800314e"
            },
            "code": "firmata::FirmataConstructor::FirmataConstructor_0800314e* __thiscall firmata::FirmataConstructor::FirmataConstructor_0800314e(firmata::FirmataConstructor::FirmataConstructor_0800314e* this_ptr)\n{\n  this_ptr->serial_stream = (Stream *)0x0;\n  return this_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800314e",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "firmata::FirmataConstructor::FirmataConstructor_0800314e"
        },
        "FUN_080036a0": {
            "renaming": {
                "FUN_080036a0": "wait_forever_080036a0"
            },
            "code": "void wait_forever_080036a0(void)\n{\n  while(true) {\n    // Do nothing\n  }\n}",
            "called": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036a0",
            "calling": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "imported": false,
            "current_name": "wait_forever_080036a0"
        },
        "FUN_080036a2": {
            "renaming": {
                "FUN_080036a2": "initialize_EVP_PKEY_CTX_080036a2",
                "ctx": "key_ctx",
                "hw_config_FUN_080036a2": "initialize_hardware_configuration"
            },
            "code": "int initialize_EVP_PKEY_CTX_080036a2(EVP_PKEY_CTX *key_ctx)\n{\n  initialize_hardware_configuration();\n  return (int)key_ctx;\n}",
            "called": [
                "hw_config_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036a2",
            "calling": [
                "premain"
            ],
            "imported": false,
            "current_name": "initialize_EVP_PKEY_CTX_080036a2"
        },
        "FUN_080038e4": {
            "renaming": {
                "FUN_080038e4": "set_adc_channel_080038e4",
                "*hadc": "*adc_handle",
                "*sConfig": "*channel_config",
                "HVar1": "status",
                "uVar2": "rank",
                "*pAVar3": "*adc_instance",
                "wait_loop_index": "wait_loop_index",
                "PTR_SystemCoreClock_08003a14": "SystemCoreClock",
                "DAT_08003a10": "ADC1",
                "DAT_08003a18": "ADC_MAX_CLOCK_CYCLE"
            },
            "code": "HAL_StatusTypeDef set_adc_channel_080038e4(ADC_HandleTypeDef *adc_handle, ADC_ChannelConfTypeDef *channel_config)\n{\n  HAL_StatusTypeDef status;\n  uint32_t rank = channel_config->Rank;\n  uint32_t channel = channel_config->Channel;\n  uint32_t sampling_time = channel_config->SamplingTime;\n  ADC_TypeDef *adc_instance = adc_handle->Instance;\n\n  if (adc_handle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    adc_handle->Lock = HAL_LOCKED;\n    if (rank < 7) {\n      uint32_t shift = (rank * 5) - 5;\n      adc_instance->SQR3 = (channel << shift) | (adc_instance->SQR3 & ~(0x1f << shift));\n    }\n    else if (rank < 0xd) {\n      uint32_t shift = (rank * 5) - 0x23;\n      adc_instance->SQR2 = (channel << shift) | (adc_instance->SQR2 & ~(0x1f << shift));\n    }\n    else {\n      uint32_t shift = (rank * 5) - 0x41;\n      adc_instance->SQR1 = (channel << shift) | (adc_instance->SQR1 & ~(0x1f << shift));\n    }\n    if (channel < 10) {\n      adc_instance->SMPR2 = (sampling_time << (channel * 3)) | (adc_instance->SMPR2 & ~(7 << (channel * 3)));\n    }\n    else {\n      uint32_t shift = (channel * 3) - 0x1e;\n      adc_instance->SMPR1 = (sampling_time << shift) | (adc_instance->SMPR1 & ~(7 << shift));\n    }\n    if (channel >= 0x10 && channel <= 0x12 && adc_instance == DAT_08003a10) {\n      if ((adc_instance->CR2 & 0x800000) == 0) {\n        adc_instance->CR2 |= 0x800000;\n        if (channel == 0x10) {\n          uint32_t wait_loop_index = (uint32_t)((uint64_t)DAT_08003a18 * (uint64_t)*((uint32_t *)PTR_SystemCoreClock_08003a14) >> 0x32) * 10;\n          while (wait_loop_index--);\n          status = HAL_OK;\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        status = HAL_OK;\n      }\n    }\n    else {\n      adc_handle->State |= 0x20;\n      status = HAL_ERROR;\n    }\n    adc_handle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080038e4",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "set_adc_channel_080038e4"
        },
        "FUN_08005e68": {
            "renaming": {
                "FUN_08005e68": "do_nothing_08005e68"
            },
            "code": "\nvoid do_nothing_08005e68(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e68",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08005e68"
        },
        "FUN_08005d48": {
            "renaming": {
                "FUN_08005d48": "configure_timer_08005d48",
                "TIMx": "timer",
                "OC_Config": "output_compare_config",
                "uVar1": "cc_enable_value",
                "uVar2": "cr2_value",
                "uVar3": "oc_mode",
                "cc_enable_mask": "cc_enable_mask",
                "DAT_08005da8": "PTR_08005da8"
            },
            "code": "void configure_timer_08005d48(TIM_TypeDef_conflict *timer, TIM_OC_InitTypeDef *output_compare_config)\n{\n  uint32_t cc_enable_mask = 0xfffffeff;\n  uint32_t cr2_value = timer->CR2;\n  uint oc_mode = output_compare_config->OCMode;\n  uint32_t cc_enable_value = (timer->CCER & 0xfffffdff) | (output_compare_config->OCPolarity << 8);\n  if (timer == DAT_08005da8) {\n    cc_enable_value = (cc_enable_value & 0xfffff7ff) | (output_compare_config->OCNPolarity << 8);\n    cr2_value = (cr2_value & 0xffffcfff) | (output_compare_config->OCIdleState << 4) | (output_compare_config->OCNIdleState << 4);\n  }\n  timer->CR2 = cr2_value;\n  timer->CCMR2 = (timer->CCMR2 & 0xffffff8c) | oc_mode;\n  timer->CCR3 = output_compare_config->Pulse;\n  timer->CCER = cc_enable_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005d48",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_08005d48"
        },
        "FUN_08008ba4": {
            "renaming": {
                "FUN_08008ba4": "write_08008ba4",
                "this": "serial_object",
                "c": "data",
                "_written": "is_written",
                "uVar2": "tx_tail_index",
                "bVar1": "next_head_index",
                "uVar5": "tx_head_index",
                "bVar3": "wrapped_head_index",
                "iVar4": "next_head_index_int"
            },
            "code": "size_t __thiscall write_08008ba4(HardwareSerial *serial_object,uint8_t c)\\n{\\n  bool is_written;\\n  byte next_head_index;\\n  byte wrapped_head_index;\\n  int next_head_index_int;\\n  uint tx_head_index;\\n  uint tx_tail_index;\\n  \\n  is_written = true;\\n  tx_head_index = (uint)(serial_object->_serial).tx_head;\\n  next_head_index_int = tx_head_index + 1;\\n  next_head_index = (byte)next_head_index_int;\\n  wrapped_head_index = next_head_index & 0x7f;\\n  if (next_head_index_int == 0) {\\n    wrapped_head_index = -(-next_head_index & 0x7f);\\n  }\\n  do {\\n  } while ((serial_object->_serial).tx_tail == (ushort)wrapped_head_index);\\n  (serial_object->_serial).tx_buff[tx_head_index] = c;\\n  (serial_object->_serial).tx_head = (ushort)wrapped_head_index;\\n  tx_tail_index = serial_tx_active((serial_t *)&serial_object->_serial);\\n  if (tx_tail_index == \"\\0\") {\\n    uart_attach_tx_callback((serial_t *)&serial_object->_serial,DAT_08008bf0);\\n  }\\n  return 1;\\n}",
            "called": [
                "serial_tx_active",
                "uart_attach_tx_callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ba4",
            "calling": [],
            "imported": false,
            "current_name": "write_08008ba4"
        },
        "FUN_08009ff8": {
            "renaming": {
                "FUN_08009ff8": "kill_process_if_alive_08009ff8",
                "param_1": "error_code",
                "param_2": "process_id",
                "param_3": "signal",
                "puVar1": "error_ptr",
                "iVar2": "result"
            },
            "code": "void kill_process_if_alive_08009ff8(int *error_code, int process_id, int signal) {\n  undefined *error_ptr = PTR_errno_0800a018;\n  *(undefined4 *)PTR_errno_0800a018 = 0;\n  int result = _kill(process_id, signal);\n  if ((result == -1) && (*(int *)error_ptr != 0)) {\n    *error_code = *(int *)error_ptr;\n  }\n  return;\n}",
            "called": [
                "_kill"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009ff8",
            "calling": [
                "_raise_r"
            ],
            "imported": false,
            "current_name": "kill_process_if_alive_08009ff8"
        },
        "FUN_08009db0": {
            "renaming": {
                "FUN_08009db0": "find_unused_int_array_08009db0",
                "param_1": "error_code",
                "piVar1": "current_array",
                "piVar2": "current_element",
                "iVar3": "global_impure_ptr",
                "ppiVar4": "array_list"
            },
            "code": "int find_unused_int_array_08009db0(undefined4 *error_code) {\n  int *current_array;\n  int *current_element;\n  int global_impure_ptr = *(int *)PTR__global_impure_ptr_08009e24;\n  if (*(int *)(global_impure_ptr + 0x18) == 0) {\n    __sinit(global_impure_ptr);\n  }\n  int **array_list = (int **)(global_impure_ptr + 0x48);\n  do {\n    current_element = array_list[2];\n    current_array = array_list[1];\n    while (current_array = (int *)((int)current_array + -1), -1 < (int)current_array) {\n      if (*(short *)(current_element + 3) == 0) {\n        *(undefined2 *)((int)current_element + 0xe) = 0xffff;\n        current_element[0x19] = 0;\n        *(undefined2 *)(current_element + 3) = 1;\n        *current_element = 0;\n        current_element[2] = 0;\n        current_element[1] = 0;\n        current_element[4] = 0;\n        current_element[5] = 0;\n        current_element[6] = 0;\n        memset(current_element + 0x17, 0, 8);\n        current_element[0xd] = 0;\n        current_element[0xe] = 0;\n        current_element[0x12] = 0;\n        current_element[0x13] = 0;\n        return current_element;\n      }\n      current_element = current_element + 0x1a;\n    }\n    if (*array_list == (int *)0x0) {\n      current_array = (int *)__sfmoreglue(error_code, 4);\n      *array_list = current_array;\n      if (current_array == (int *)0x0) {\n        *error_code = 0xc;\n        return (int *)0x0;\n      }\n    }\n    array_list = (int **)*array_list;\n  } while( true );\n}",
            "called": [
                "__sinit",
                "memset",
                "__sfmoreglue"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009db0",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "find_unused_int_array_08009db0"
        },
        "FUN_08002c2c": {
            "renaming": {
                "FUN_08002c2c": "executeAnalogCallback_08002c2c",
                "param_1": "analogCallbackFunction",
                "command": "command",
                "value": "value",
                "PTR_currentAnalogCallback_08002c3c": "currentAnalogCallback"
            },
            "code": "void executeAnalogCallback_08002c2c(void *analogCallbackFunction, uint8_t command, uint16_t value)\n{\n  if (*(code **)PTR_currentAnalogCallback_08002c3c != (code *)0x0) {\n    (**(code **)PTR_currentAnalogCallback_08002c3c)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c2c",
            "calling": [],
            "imported": false,
            "current_name": "executeAnalogCallback_08002c2c"
        },
        "FUN_080072f0": {
            "renaming": {
                "FUN_080072f0": "read_gpio_pin_state_080072f0",
                "port": "gpio_port",
                "pin": "gpio_pin",
                "GVar1": "pin_state"
            },
            "code": "uint32_t read_gpio_pin_state_080072f0(GPIO_TypeDef *gpio_port, uint32_t gpio_pin)\n{\n  GPIO_PinState pin_state;\n  pin_state = HAL_GPIO_ReadPin(gpio_port, (uint16_t)gpio_pin);\n  return (uint32_t)pin_state;\n}",
            "called": [
                "HAL_GPIO_ReadPin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072f0",
            "calling": [
                "digitalRead"
            ],
            "imported": false,
            "current_name": "read_gpio_pin_state_080072f0"
        },
        "FUN_08000178": {
            "renaming": {
                "FUN_08000178": "string_length_08000178",
                "__s": "str",
                "pcVar3": "current_ptr",
                "pcVar2": "next_ptr",
                "cVar1": "current_char"
            },
            "code": "size_t string_length_08000178(char* str) {\n  char current_char;\n  char *current_ptr;\n  current_ptr = str;\n  do {\n    current_ptr++;\n    current_char = *current_ptr;\n  } while (current_char != '\\0');\n  return (size_t)(current_ptr + (-1 - (int)str));\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000178",
            "calling": [
                "sendString",
                "printNumber",
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "string_length_08000178"
        },
        "FUN_08000a64": {
            "renaming": {
                "FUN_08000a64": "checkI2CPinsAndEnable_08000a64",
                "_Var1": "isPinValid",
                "uVar2": "digitalPin",
                "uVar3": "pinIndex",
                "PTR_digitalPin_08000ad8": "digitalPin_08000ad8",
                "NC": "NC",
                "pinNametoDigitalPin": "pinNametoDigitalPin",
                "PinMap_conflict": "PinMap_conflict",
                "PTR_PinMap_I2C_SDA_08000adc": "PinMap_I2C_SDA_08000adc",
                "PTR_PinMap_I2C_SCL_08000ae0": "PinMap_I2C_SCL_08000ae0",
                "pin_in_pinmap": "pin_in_pinmap",
                "setPinModeCallback": "setPinModeCallback",
                "byte": "byte",
                "*PTR_isI2CEnabled_08000ae4": "isI2CEnabled_08000ae4",
                "TwoWire": "Wire",
                "*PTR_Wire_08000ae8": "Wire_08000ae8"
            },
            "code": "void checkI2CPinsAndEnable_08000a64()\n{\n  bool isPinValid;\n  uint32_t digitalPin;\n  uint pinIndex;\n  for (pinIndex = 0; pinIndex < 0x3c; pinIndex = (pinIndex + 1) & 0xff) {\n    if (pinIndex < 0x3c) {\n      if (PTR_digitalPin_08000ad8[pinIndex] == NC) {\n        isPinValid = false;\n      }\n      else {\n        digitalPin = pinNametoDigitalPin(PTR_digitalPin_08000ad8[pinIndex]);\n        if (digitalPin == 0) {\n          isPinValid = false;\n        }\n        else {\n          digitalPin = pinNametoDigitalPin(PTR_digitalPin_08000ad8[pinIndex]);\n          if (digitalPin == 1) {\n            isPinValid = false;\n          }\n          else {\n            isPinValid = pin_in_pinmap(PTR_digitalPin_08000ad8[pinIndex], (PinMap_conflict *)PTR_PinMap_I2C_SDA_08000adc);\n            if (!isPinValid) {\n              isPinValid = pin_in_pinmap(PTR_digitalPin_08000ad8[pinIndex], (PinMap_conflict *)PTR_PinMap_I2C_SCL_08000ae0);\n            }\n          }\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid) {\n      setPinModeCallback((byte)pinIndex, 6);\n    }\n  }\n  **PTR_isI2CEnabled_08000ae4 = 1;\n  Wire::begin((TwoWire *)*PTR_Wire_08000ae8);\n  return;\n}",
            "called": [
                "pinNametoDigitalPin",
                "begin",
                "pin_in_pinmap",
                "setPinModeCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a64",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "checkI2CPinsAndEnable_08000a64"
        },
        "FUN_08002c40": {
            "renaming": {
                "FUN_08002c40": "digitalCallbackHandler_08002c40",
                "param_1": "callback",
                "command": "command",
                "value": "value",
                "PTR_currentDigitalCallback_08002c50": "current_digital_callback"
            },
            "code": "void digitalCallbackHandler_08002c40(void *callback, uint8_t command, uint16_t value)\n{\n  if (*(code **)PTR_currentDigitalCallback_08002c50 != (code *)0x0) {\n    (**(code **)PTR_currentDigitalCallback_08002c50)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c40",
            "calling": [],
            "imported": false,
            "current_name": "digitalCallbackHandler_08002c40"
        },
        "FUN_0800694c": {
            "renaming": {
                "FUN_0800694c": "handle_uart_receive_0800694c",
                "huart": "uart_handle",
                "pbVar1": "rx_byte_ptr",
                "uVar2": "rx_count",
                "puVar3": "rx_byte_ptr",
                "data_register": "data_reg_ptr",
                "data_byte": "data_byte",
                "data_word": "data_word",
                "word_length": "word_length",
                "rx_buffer_ptr": "rx_buffer_ptr"
            },
            "code": "HAL_StatusTypeDef handle_uart_receive_0800694c(UART_HandleTypeDef *uart_handle)\n{\n  uint16_t word_length = uart_handle->Init.WordLength;\n  uint8_t *rx_buffer_ptr = uart_handle->pRxBuffPtr;\n  uint8_t *data_register = (uint8_t *)&uart_handle->Instance->DR;\n  uint8_t data_byte = *data_register;\n  uint16_t data_word = (uint16_t)(*data_register) | ((uint16_t)(*(data_register + 1)) << 8);\n  if (uart_handle->RxState != HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  if (word_length == 0x1000) {\n    if (uart_handle->Init.Parity == 0) {\n      *(uint16_t *)rx_buffer_ptr = data_word;\n      rx_buffer_ptr += 2;\n    }\n    else {\n      *(uint8_t *)rx_buffer_ptr = data_byte;\n      rx_buffer_ptr += 1;\n    }\n  }\n  else if (uart_handle->Init.Parity == 0) {\n    *rx_buffer_ptr = data_byte;\n    rx_buffer_ptr += 1;\n  }\n  else {\n    *rx_buffer_ptr = data_byte & 0x7f;\n    rx_buffer_ptr += 1;\n  }\n  uart_handle->RxXferCount -= 1;\n  if (uart_handle->RxXferCount != 0) {\n    return HAL_OK;\n  }\n  uart_handle->Instance->CR1 &= 0xffffffdf;\n  uart_handle->Instance->CR1 &= 0xfffffeff;\n  uart_handle->Instance->CR3 &= 0xfffffffe;\n  uart_handle->RxState = HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(uart_handle);\n  return HAL_OK;\n}",
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800694c",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_uart_receive_0800694c"
        },
        "FUN_0800a0ec": {
            "renaming": {
                "FUN_0800a0ec": "get_file_status_0800a0ec",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "file_stats",
                "puVar1": "err_ptr",
                "iVar2": "status"
            },
            "code": "void get_file_status_0800a0ec(int *error_code, int file_descriptor, stat *file_stats)\n{\n  undefined *err_ptr;\n  int status;\n\n  err_ptr = PTR_errno_0800a10c;\n  *(undefined4 *)PTR_errno_0800a10c = 0;\n  status = _fstat(file_descriptor, file_stats);\n  if ((status == -1) && (*(int *)err_ptr != 0)) {\n    *error_code = *(int *)err_ptr;\n  }\n  return;\n}",
            "called": [
                "_fstat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a0ec",
            "calling": [
                "__swhatbuf_r"
            ],
            "imported": false,
            "current_name": "get_file_status_0800a0ec"
        },
        "FUN_08008df8": {
            "renaming": {
                "FUN_08008df8::FUN_08008df8": "IPAddress::IPAddress",
                "this": "this",
                "first_octet": "first_octet",
                "second_octet": "second_octet",
                "third_octet": "third_octet",
                "fourth_octet": "fourth_octet",
                "super_Printable": "_address",
                "_vptr_Printable": "_vptr_Printable",
                "_address": "_address",
                "bytes": "bytes",
                "FUN_08008df8": "IPAddress_08008df8"
            },
            "code": "class IPAddress_08008df8 { \n public: \n IPAddress_08008df8(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet) { \n _address.bytes[0] = first_octet; \n _address.bytes[1] = second_octet; \n _address.bytes[2] = third_octet; \n _address.bytes[3] = fourth_octet; \n } \n private: \n union { \n uint8_t bytes[4]; \n uint32_t dword; \n } _address; \n};",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008df8",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "IPAddress_08008df8"
        },
        "FUN_08000188": {
            "renaming": {
                "FUN_08000188": "software_interrupt_handler_08000188",
                "a0": "interrupt_number",
                "a1": "parameter",
                "a2": "flag"
            },
            "code": "uint32_t software_interrupt_handler_08000188(uint32_t interrupt_number, uint32_t parameter, int32_t flag)\n{\n  software_interrupt(0x3f);\n  return interrupt_number;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000188",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "software_interrupt_handler_08000188"
        },
        "FUN_08004f3c": {
            "renaming": {
                "FUN_08004f3c": "i2c_handle_08004f3c",
                "hi2c": "handle",
                "HVar1": "status",
                "puVar2": "buffer",
                "pIVar3": "instance",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "I2C_TypeDef_conflict": "I2C_TypeDef",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_STATE_LISTEN",
                "HAL_I2C_STATE_ABORT": "HAL_I2C_STATE_ABORT",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NONE",
                "hdmatx": "handle_tx_dma",
                "hdmarx": "handle_rx_dma",
                "HAL_DMA_STATE_READY": "HAL_DMA_STATE_READY",
                "DAT_0800507c": "i2c_abort_transfer",
                "I2C_XFER_OPTIONS": "I2C_XFER_OPTIONS",
                "ErrorCode": "error_code",
                "Instance": "instance",
                "State": "state",
                "PreviousState": "previous_state",
                "Mode": "mode",
                "XferOptions": "xfer_options",
                "pBuffPtr": "buffer_ptr",
                "DR": "data_register",
                "SR1": "status_register_1",
                "CR1": "control_register_1",
                "CR2": "control_register_2"
            },
            "code": "void i2c_handle_08004f3c(I2C_HandleTypeDef *handle)\n{\n  HAL_StatusTypeDef status;\n  uint8_t *buffer;\n  I2C_TypeDef *instance;\n  if ((uint8_t)handle->State - 0x29 < 2) {\n    handle->PreviousState = 0;\n    handle->State = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((handle->State != HAL_I2C_STATE_ABORT) && ((handle->Instance->CR2 & 0x800) == 0)) {\n      handle->State = HAL_I2C_STATE_READY;\n    }\n    handle->PreviousState = 0;\n    handle->Mode = HAL_I2C_MODE_NONE;\n  }\n  handle->Instance->CR1 &= 0xfffff7ff;\n  instance = handle->Instance;\n  if ((instance->CR2 & 0x800) == 0) {\n    if (handle->State == HAL_I2C_STATE_ABORT) {\n      handle->State = HAL_I2C_STATE_READY;\n      handle->ErrorCode = 0;\n      if ((instance->SR1 & 0x40) != 0) {\n        buffer = handle->pBuffPtr;\n        handle->pBuffPtr = buffer + 1;\n        *buffer = (uint8_t)instance->DR;\n      }\n      handle->Instance->CR1 &= 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(handle);\n    }\n    else {\n      if ((instance->SR1 & 0x40) != 0) {\n        buffer = handle->pBuffPtr;\n        handle->pBuffPtr = buffer + 1;\n        *buffer = (uint8_t)instance->DR;\n      }\n      HAL_I2C_ErrorCallback(handle);\n    }\n  }\n  else {\n    instance->CR2 &= 0xfffff7ff;\n    if (handle->hdmatx->State == HAL_DMA_STATE_READY) {\n      handle->hdmarx->XferAbortCallback = DAT_0800507c;\n      status = HAL_DMA_Abort_IT(handle->hdmarx);\n      if (status != HAL_OK) {\n        if ((instance->SR1 & 0x40) != 0) {\n          buffer = handle->pBuffPtr;\n          handle->pBuffPtr = buffer + 1;\n          *buffer = (uint8_t)instance->DR;\n        }\n        instance->CR1 &= 0xfffffffe;\n        handle->State = HAL_I2C_STATE_READY;\n        (*handle->hdmarx->XferAbortCallback)(handle->hdmarx);\n      }\n    }\n    else {\n      handle->hdmatx->XferAbortCallback = DAT_0800507c;\n      status = HAL_DMA_Abort_IT(handle->hdmatx);\n      if (status != HAL_OK) {\n        instance->CR1 &= 0xfffffffe;\n        handle->State = HAL_I2C_STATE_READY;\n        (*handle->hdmatx->XferAbortCallback)(handle->hdmatx);\n      }\n    }\n  }\n  if ((handle->State == HAL_I2C_STATE_LISTEN) && ((handle->ErrorCode & 4) != 0)) {\n    handle->XferOptions = I2C_XFER_OPTIONS;\n    handle->PreviousState = 0;\n    handle->State = HAL_I2C_STATE_READY;\n    handle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(handle);\n  }\n  return;\n}",
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback",
                "HAL_DMA_Abort_IT",
                "HAL_I2C_AbortCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f3c",
            "calling": [
                "I2C_Slave_STOPF",
                "HAL_I2C_ER_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handle_08004f3c"
        },
        "FUN_08004f3a": {
            "renaming": {
                "FUN_08004f3a": "do_nothing_08004f3a"
            },
            "code": "\nvoid do_nothing_08004f3a(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f3a",
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "imported": false,
            "current_name": "do_nothing_08004f3a"
        },
        "FUN_0800344a": {
            "renaming": {
                "FUN_0800344a": "resetParserState_0800344a",
                "this": "parser",
                "uVar1": "i",
                "dataBuffer": "dataBuffer",
                "dataBufferSize": "dataBufferSize",
                "waitForData": "waitForData",
                "executeMultiByteCommand": "executeMultiByteCommand",
                "multiByteChannel": "multiByteChannel",
                "parsingSysex": "parsingSysex",
                "sysexBytesRead": "sysexBytesRead",
                "currentSystemResetCallback": "currentSystemResetCallback",
                "currentSystemResetCallbackContext": "currentSystemResetCallbackContext"
            },
            "code": "void __thiscall resetParserState_0800344a(FirmataParser *parser)\n{\n  parser->waitForData = false;\n  parser->executeMultiByteCommand = 0;\n  parser->multiByteChannel = 0;\n  \n  for (uint i = 0; i < parser->dataBufferSize; i++) {\n    parser->dataBuffer[i] = 0;\n  }\n  \n  parser->parsingSysex = false;\n  parser->sysexBytesRead = 0;\n  \n  if (parser->currentSystemResetCallback != (systemCallbackFunction)0x0) {\n    (*parser->currentSystemResetCallback)(parser->currentSystemResetCallbackContext);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800344a",
            "calling": [
                "parse"
            ],
            "imported": false,
            "current_name": "resetParserState_0800344a"
        },
        "FUN_080071e4": {
            "renaming": {
                "FUN_080071e4": "stop_pwm_signal_080071e4",
                "pin": "pin_name",
                "Channel": "channel_num",
                "uVar1": "function_map",
                "timHandle": "tim_handle"
            },
            "code": "void stop_pwm_signal_080071e4(PinName_conflict pin)\n{\n  uint32_t channel_num;\n  uint32_t function_map;\n  TIM_HandleTypeDef_conflict tim_handle;\n  tim_handle.Instance = (TIM_TypeDef_conflict *)pinmap_peripheral(pin, (PinMap_conflict *)PTR_PinMap_PWM_08007238);\n  if ((tim_handle.Instance != (TIM_TypeDef_conflict *)0x0) && (((channel_num = get_pwm_channel(pin), channel_num == 0 || (channel_num == 4)) || (channel_num == 8)) || ((channel_num == 0xc || (channel_num == 0x18))))))\n  {\n    function_map = pinmap_function(pin, (PinMap_conflict *)PTR_PinMap_PWM_08007238);\n    if ((function_map & 0x100000) == 0)\n    {\n      HAL_TIM_PWM_Stop(&tim_handle, channel_num);\n    }\n    else\n    {\n      HAL_TIMEx_PWMN_Stop(&tim_handle, channel_num);\n    }\n    HAL_TIM_PWM_DeInit(&tim_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_PWM_DeInit",
                "HAL_TIMEx_PWMN_Stop",
                "get_pwm_channel",
                "HAL_TIM_PWM_Stop",
                "pinmap_function",
                "pinmap_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080071e4",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "stop_pwm_signal_080071e4"
        },
        "FUN_08002c54": {
            "renaming": {
                "FUN_08002c54": "handleCurrentPinModeCallback_08002c54",
                "param_1": "callback",
                "command": "command",
                "value": "value",
                "PTR_currentPinModeCallback_08002c64": "currentPinModeCallback"
            },
            "code": "void handleCurrentPinModeCallback_08002c54(void *callback, uint8_t command, uint16_t value)\n{\n  if (*(code **)PTR_currentPinModeCallback_08002c64 != (code *)0x0) {\n    (**(code **)PTR_currentPinModeCallback_08002c64)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c54",
            "calling": [],
            "imported": false,
            "current_name": "handleCurrentPinModeCallback_08002c54"
        },
        "FUN_080072fa": {
            "renaming": {
                "FUN_080072fa": "initialize_system_080072fa",
                "HAL_Init": "initialize_HAL",
                "SystemClock_Config": "configure_system_clock"
            },
            "code": "void initialize_system_080072fa(void)\n{\n  initialize_HAL();\n  configure_system_clock();\n  return;\n}",
            "called": [
                "HAL_Init",
                "SystemClock_Config"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072fa",
            "calling": [
                "init"
            ],
            "imported": false,
            "current_name": "initialize_system_080072fa"
        },
        "FUN_08003346": {
            "renaming": {
                "FUN_08003346": "setReportFirmwareCallback_08003346",
                "command": "firmwareCommand",
                "newFunction": "newCallbackFunction",
                "context": "callbackContext",
                "currentReportFirmwareCallback": "currentCallbackFunction",
                "currentReportFirmwareCallbackContext": "currentCallbackContext"
            },
            "code": "void __thiscall setReportFirmwareCallback_08003346(FirmataParser *this, uint8_t command, versionCallbackFunction newCallbackFunction, void *context) {\n  if (command == 'y') {\n    this->currentReportFirmwareCallback = newCallbackFunction;\n    this->currentReportFirmwareCallbackContext = context;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003346",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "setReportFirmwareCallback_08003346"
        },
        "FUN_08003106": {
            "renaming": {
                "FUN_08003106": "sendPinState_08003106",
                "this": "self",
                "pin": "pin",
                "bytec": "byteCount",
                "bytev": "byteValues",
                "FirmataStream": "FirmataStream",
                "super_Print": "superPrint",
                "_vptr_Print": "virtualPrint",
                "encodeByteStream": "encodeByteStream"
            },
            "code": "void __thiscall sendPinState_08003106(FirmataMarshaller *self, uint8_t pin, size_t byteCount, uint8_t *byteValues) {\n  if (self->FirmataStream != nullptr) {\n    (**(self->FirmataStream->super_Print)._vptr_Print)(self, 0xf0);\n    (**(self->FirmataStream->super_Print)._vptr_Print)(self->FirmataStream, 0x6f);\n    (**(self->FirmataStream->super_Print)._vptr_Print)(self->FirmataStream, (uint)pin);\n    encodeByteStream(self, byteCount, byteValues, byteCount);\n    (**(self->FirmataStream->super_Print)._vptr_Print)(self->FirmataStream, 0xf7);\n  }\n  return;\n}",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003106",
            "calling": [
                "sendAnalog"
            ],
            "imported": false,
            "current_name": "sendPinState_08003106"
        },
        "FUN_08007708": {
            "renaming": {
                "FUN_08007708": "enable_timer_clock_08007708",
                "htim": "timer_handle"
            },
            "code": "void enable_timer_clock_08007708(TIM_HandleTypeDef_conflict *timer_handle) {\n  timer_enable_clock(timer_handle);\n  return;\n}",
            "called": [
                "timer_enable_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007708",
            "calling": [
                "HAL_TIM_OC_Init"
            ],
            "imported": false,
            "current_name": "enable_timer_clock_08007708"
        },
        "FUN_0800018c": {
            "renaming": {
                "FUN_0800018c": "getTicksAndCallAFL_0800018c",
                "ticks": "ticksToWait",
                "uVar1": "aflResult",
                "PTR_noHyperCall_080001a4": "noHyperCallPtr"
            },
            "code": "int getTicksAndCallAFL_0800018c(uint32_t ticksToWait)\n{\n  const uint32_t *PTR_noHyperCall_080001a4 = PTR_noHyperCall_080001a4;\n  if (*PTR_noHyperCall_080001a4 != 0) {\n    return 0;\n  }\n  uint32_t aflResult = aflCall(1, ticksToWait, 0);\n  return aflResult;\n}",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800018c",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "getTicksAndCallAFL_0800018c"
        },
        "FUN_08003f94": {
            "renaming": {
                "FUN_08003f94": "set_interrupt_enable_bit_08003f94",
                "IRQn": "IRQn",
                "uVar1": "irq_num",
                "DAT_08003fac": "interrupt_enable_reg"
            },
            "code": "void set_interrupt_enable_bit_08003f94(IRQn_Type_conflict IRQn)\n{\n  uint32_t irq_num = (uint32_t)IRQn;\n  if (irq_num >= 0) {\n    uint32_t word_offset = irq_num >> 5;\n    uint32_t bit_offset = irq_num & 0x1f;\n    uint32_t* DAT_08003fac = (uint32_t*)(DAT_08003fac + word_offset * 4);\n    *DAT_08003fac = 1 << bit_offset;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f94",
            "calling": [
                "TimerPulseInit",
                "i2c_custom_init",
                "uart_attach_rx_callback",
                "uart_attach_tx_callback"
            ],
            "imported": false,
            "current_name": "set_interrupt_enable_bit_08003f94"
        },
        "FUN_08002c68": {
            "renaming": {
                "FUN_08002c68": "pinValueCallback_08002c68",
                "param_1": "callback",
                "command": "command",
                "value": "value",
                "PTR_currentPinValueCallback_08002c78": "currentPinValueCallback"
            },
            "code": "void pinValueCallback_08002c68(void *callback, uint8_t command, uint16_t value)\n{\n  if (*(code **)PTR_currentPinValueCallback_08002c78 != (code *)0x0) {\n    (**(code **)PTR_currentPinValueCallback_08002c78)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c68",
            "calling": [],
            "imported": false,
            "current_name": "pinValueCallback_08002c68"
        },
        "FUN_08002a26": {
            "renaming": {
                "TwoWire::FUN_08002a26": "initializeWire",
                "this": "wire",
                "FUN_08002a26": "sendStartCondition_08002a26",
                "DAT_08003000": "0x33",
                "sendByte": "sendByte",
                "sendStopCondition": "sendStopCondition"
            },
            "code": "void __thiscall sendStartCondition_08002a26(TwoWire *wire)\n{\n  sendStartCondition_08002a26(wire);\n  sendByte(wire,DAT_08003000);\n  sendStopCondition(wire);\n  return;\n}",
            "called": [
                "begin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a26",
            "calling": [
                "enableI2CPins"
            ],
            "imported": false,
            "current_name": "sendStartCondition_08002a26"
        },
        "FUN_0800430c": {
            "renaming": {
                "FUN_0800430c": "i2c_handle_mem_mode_0800430c",
                "hi2c": "i2c_handle",
                "Mode": "mode",
                "EventCount": "event_count",
                "Init": "init",
                "AddressingMode": "addressing_mode",
                "State": "state",
                "Instance": "instance",
                "Devaddress": "dev_address"
            },
            "code": "HAL_StatusTypeDef i2c_handle_mem_mode_0800430c(I2C_HandleTypeDef *i2c_handle) {\n  uint8_t dev_address = i2c_handle->Devaddress;\n  uint8_t mode = i2c_handle->Mode;\n  uint16_t event_count = i2c_handle->EventCount;\n  uint16_t addressing_mode = i2c_handle->Init.AddressingMode;\n  I2C_TypeDef *instance = i2c_handle->Instance;\n  if (mode == HAL_I2C_MODE_MEM) {\n    if (event_count == 0) {\n      instance->DR = dev_address & 0xFE;\n    }\n    else {\n      instance->DR = dev_address & 0xFF | 1;\n    }\n  }\n  else if (addressing_mode == 0x4000) {\n    if (i2c_handle->State == HAL_I2C_STATE_BUSY_TX) {\n      instance->DR = dev_address & 0xFE;\n    }\n    else {\n      instance->DR = dev_address & 0xFF | 1;\n    }\n  }\n  else if (event_count == 0) {\n    instance->DR = (dev_address << 16) >> 23 & 6 | 0xF0;\n  }\n  else if (event_count == 1) {\n    instance->DR = (dev_address << 16) >> 23 & 6 | 0xF1;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800430c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handle_mem_mode_0800430c"
        },
        "FUN_08003350": {
            "renaming": {
                "FUN_08003350": "setCallbackFunction_08003350",
                "command": "callbackCommand",
                "newFunction": "callbackFunction",
                "context": "callbackContext",
                "currentReportVersionCallback": "reportVersionCallback",
                "currentReportVersionCallbackContext": "reportVersionCallbackContext",
                "currentSystemResetCallback": "systemResetCallback",
                "currentSystemResetCallbackContext": "systemResetCallbackContext"
            },
            "code": "void __thiscall setCallbackFunction_08003350(FirmataParser *this, uint8_t command, systemCallbackFunction newFunction, void *context) {\n  if (command == 0xf9) {\n    this->currentReportVersionCallback = newFunction;\n    this->currentReportVersionCallbackContext = context;\n    return;\n  }\n  if (command != 0xff) {\n    return;\n  }\n  this->currentSystemResetCallback = newFunction;\n  this->currentSystemResetCallbackContext = context;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003350",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "setCallbackFunction_08003350"
        },
        "FUN_08007710": {
            "renaming": {
                "FUN_08007710": "disable_timer_clock_08007710",
                "htim": "timer_handle"
            },
            "code": "void disable_timer_clock_08007710(TIM_HandleTypeDef_conflict *timer_handle)\n{\n  timer_disable_clock(timer_handle);\n  return;\n}",
            "called": [
                "timer_disable_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007710",
            "calling": [
                "HAL_TIM_OC_DeInit"
            ],
            "imported": false,
            "current_name": "disable_timer_clock_08007710"
        },
        "FUN_08003474": {
            "renaming": {
                "FUN_08003474": "parseInput_08003474",
                "inputData": "inputValue",
                "byte": "byteValue",
                "uint": "uint",
                "pos": "position",
                "parsingSysex": "parsingSysex",
                "bufferDataAtPosition": "bufferDataAtPosition",
                "sysexBytesRead": "sysexBytesRead",
                "false": "false",
                "processSysexMessage": "processSysexMessage",
                "waitForData": "waitForData",
                "multiByteChannel": "multiByteChannel",
                "currentReportVersionCallback": "currentReportVersionCallback",
                "currentReportVersionCallbackContext": "currentReportVersionCallbackContext",
                "systemCallbackFunction": "systemCallbackFunction",
                "currentReportDigitalCallback": "currentReportDigitalCallback",
                "callbackFunction": "callbackFunction",
                "currentReportDigitalCallbackContext": "currentReportDigitalCallbackContext",
                "dataBuffer": "dataBuffer",
                "currentDigitalCallback": "currentDigitalCallback",
                "currentDigitalCallbackContext": "currentDigitalCallbackContext",
                "currentReportAnalogCallback": "currentReportAnalogCallback",
                "currentReportAnalogCallbackContext": "currentReportAnalogCallbackContext",
                "currentPinModeCallback": "currentPinModeCallback",
                "currentPinModeCallbackContext": "currentPinModeCallbackContext",
                "currentPinValueCallback": "currentPinValueCallback",
                "currentPinValueCallbackContext": "currentPinValueCallbackContext",
                "currentAnalogCallback": "currentAnalogCallback",
                "currentAnalogCallbackContext": "currentAnalogCallbackContext",
                "executeMultiByteCommand": "executeMultiByteCommand",
                "LAB_0800359c": "LAB_0800359c"
            },
            "code": "void __thiscall parseInput_08003474(uint8_t inputData) {\\n  byte byteValue;\\n  uint inputValue;\\n  size_t position;\\n  inputValue = (uint)inputData;\\n  if (parsingSysex) {\\n    if (inputValue != 0xf7) {\\n      bufferDataAtPosition(this, inputData, sysexBytesRead);\\n      sysexBytesRead = sysexBytesRead + 1;\\n      return;\\n    }\\n    parsingSysex = false;\\n    processSysexMessage(this);\\n    return;\\n  }\\n  if ((waitForData == 0) || (0x7f < inputValue)) {\\n    if (inputValue < 0xf0) {\\n      multiByteChannel = inputData & 0xf;\\n      inputValue = inputValue & 0xf0;\\n    }\\n    if (inputValue == 0xf0) {\\n      parsingSysex = true;\\n      sysexBytesRead = 0;\\n      return;\\n    }\\n    if (inputValue < 0xf1) {\\n      if (inputValue != 0xc0) {\\n        if (inputValue < 0xc1) {\\n          if (inputValue != 0x90) {\\n            return;\\n          }\\n        }\\n        else {\\n          if (inputValue == 0xd0) goto LAB_0800359c;\\n          if (inputValue != 0xe0) {\\n            return;\\n          }\\n        }\\nLAB_08003586:\\n        waitForData = 2;\\n        executeMultiByteCommand = (uint8_t)inputValue;\\n        return;\\n      }\\nLAB_0800359c:\\n      waitForData = 1;\\n      executeMultiByteCommand = (uint8_t)inputValue;\\n      return;\\n    }\\n    if (inputValue != 0xf9) {\\n      if (0xf9 < inputValue) {\\n        if (inputValue == 0xff) {\\n          systemReset(this);\\n          return;\\n        }\\n        return;\\n      }\\n      if (1 < inputValue - 0xf4) {\\n        return;\\n      }\\n      goto LAB_08003586;\\n    }\\n    if (currentReportVersionCallback != (systemCallbackFunction)0x0) {\\n      (*currentReportVersionCallback)(currentReportVersionCallbackContext);\\n    }\\n  }\\n  else {\\n    position = waitForData - 1;\\n    waitForData = position;\\n    bufferDataAtPosition(this, inputData, position);\\n    if ((waitForData == 0) && (byteValue = executeMultiByteCommand, byteValue != 0)) {\\n      if (byteValue == 0xd0) {\\n        if (currentReportDigitalCallback != (callbackFunction)0x0) {\\n          (*currentReportDigitalCallback)(currentReportDigitalCallbackContext, multiByteChannel, (uint16_t)*dataBuffer);\\n        }\\n      }\\n      else if (byteValue < 0xd1) {\\n        if (byteValue == 0x90) {\\n          if (currentDigitalCallback != (callbackFunction)0x0) {\\n            (*currentDigitalCallback)(currentDigitalCallbackContext, multiByteChannel, (ushort)dataBuffer[1] + (ushort)*dataBuffer * 0x80);\\n          }\\n        }\\n        else if ((byteValue == 0xc0) && (currentReportAnalogCallback != (callbackFunction)0x0)) {\\n          (*currentReportAnalogCallback)(currentReportAnalogCallbackContext, multiByteChannel, (uint16_t)*dataBuffer);\\n        }\\n      }\\n      else if (byteValue == 0xf4) {\\n        if (currentPinModeCallback != (callbackFunction)0x0) {\\n          (*currentPinModeCallback)(currentPinModeCallbackContext, dataBuffer[1], (uint16_t)*dataBuffer);\\n        }\\n      }\\n      else if (byteValue == 0xf5) {\\n        if (currentPinValueCallback != (callbackFunction)0x0) {\\n          (*currentPinValueCallback)(currentPinValueCallbackContext, dataBuffer[1], (uint16_t)*dataBuffer);\\n        }\\n      }\\n      else if ((byteValue == 0xe0) && (currentAnalogCallback != (callbackFunction)0x0)) {\\n        (*currentAnalogCallback)(currentAnalogCallbackContext, multiByteChannel, (ushort)dataBuffer[1] + (ushort)*dataBuffer * 0x80);\\n      }\\n      executeMultiByteCommand = \"\\0\";\\n      return;\\n    }\\n  }\\n  return;\\n}",
            "called": [
                "processSysexMessage",
                "bufferDataAtPosition",
                "systemReset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003474",
            "calling": [
                "processInput"
            ],
            "imported": false,
            "current_name": "parseInput_08003474"
        },
        "FUN_08008804": {
            "renaming": {
                "FUN_08008804": "allocate_memory_08008804",
                "incr": "size",
                "pcVar1": "start_address",
                "pcVar2": "end_address"
            },
            "code": "caddr_t allocate_memory_08008804(int size)\n{\n  caddr_t start_address;\n  caddr_t end_address;\n  \n  if (*(int *)PTR_heap_end_08008834 == 0) {\n    *(undefined **)PTR_heap_end_08008834 = PTR__ebss_08008838;\n  }\n  start_address = *(caddr_t *)PTR_heap_end_08008834;\n  end_address = start_address + size;\n  if (end_address <= &stack0x00000000) {\n    *(caddr_t *)PTR_heap_end_08008834 = end_address;\n    return start_address;\n  }\n  *(undefined4 *)PTR_errno_0800883c = 0xc;\n  return (caddr_t)0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008804",
            "calling": [
                "_sbrk_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_08008804"
        },
        "FUN_08004e3c": {
            "renaming": {
                "FUN_08004e3c": "transfer_data_08004e3c",
                "hi2c": "handle",
                "uVar1": "transfer_options",
                "puVar2": "data_ptr",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "XferOptions": "transfer_options",
                "XferCount": "transfer_count",
                "Instance": "peripheral_instance",
                "CR1": "control_register_1",
                "CR2": "control_register_2",
                "pBuffPtr": "data_buffer_pointer",
                "State": "current_state",
                "PreviousState": "previous_state",
                "Mode": "current_mode",
                "HAL_I2C_MODE_MEM": "HAL_I2C_MODE_MEMORY",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NO_TRANSFER",
                "I2C_FIRST_FRAME": "I2C_TRANSFER_FIRST_FRAME",
                "I2C_FIRST_AND_NEXT_FRAME": "I2C_TRANSFER_FIRST_AND_NEXT_FRAME",
                "I2C_NEXT_FRAME": "I2C_TRANSFER_NEXT_FRAME",
                "I2C_NO_OPTION_FRAME": "I2C_TRANSFER_NO_OPTION_FRAME",
                "CLEAR_ACK_BIT": "0xfffffbff",
                "CLEAR_LAST_2BITS": "0xfffffcff",
                "SET_POS_BIT": "0x200",
                "SET_ACK_BIT": "0x400",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "HAL_OK": "HAL_OK",
                "HAL_I2C_MasterRxCpltCallback": "HAL_I2C_MasterReceiveCompleteCallback",
                "HAL_I2C_MemRxCpltCallback": "HAL_I2C_MemoryReceiveCompleteCallback"
            },
            "code": "HAL_StatusTypeDef transfer_data_08004e3c(I2C_HandleTypeDef *handle)\n{\n  uint32_t transfer_options = handle->XferOptions;\n  uint8_t *data_ptr;\n  \n  if (handle->XferCount == 3) {\n    if (((transfer_options == I2C_FIRST_FRAME) || (transfer_options == I2C_FIRST_AND_NEXT_FRAME)) || (transfer_options == I2C_NO_OPTION_FRAME)) {\n      handle->Instance->CR1 = handle->Instance->CR1 & CLEAR_ACK_BIT;\n    }\n    data_ptr = handle->pBuffPtr;\n    handle->pBuffPtr = data_ptr + 1;\n    *data_ptr = (uint8_t)handle->Instance->DR;\n    handle->XferCount = handle->XferCount - 1;\n  }\n  else if (handle->XferCount == 2) {\n    if (((transfer_options == I2C_FIRST_FRAME) || (transfer_options == I2C_FIRST_AND_NEXT_FRAME)) || (transfer_options == I2C_NO_OPTION_FRAME)) {\n      handle->Instance->CR2 = handle->Instance->CR2 & CLEAR_LAST_2BITS;\n      handle->Instance->CR1 = handle->Instance->CR1 | SET_POS_BIT;\n    }\n    else {\n      if (transfer_options == I2C_NEXT_FRAME) {\n        handle->Instance->CR1 = handle->Instance->CR1 | SET_ACK_BIT;\n      }\n      else {\n        handle->Instance->CR1 = handle->Instance->CR1 & CLEAR_ACK_BIT;\n      }\n      handle->Instance->CR2 = handle->Instance->CR2 & CLEAR_LAST_2BITS;\n    }\n    data_ptr = handle->pBuffPtr;\n    handle->pBuffPtr = data_ptr + 1;\n    *data_ptr = (uint8_t)handle->Instance->DR;\n    handle->XferCount = handle->XferCount - 1;\n    data_ptr = handle->pBuffPtr;\n    handle->pBuffPtr = data_ptr + 1;\n    *data_ptr = (uint8_t)handle->Instance->DR;\n    handle->XferCount = handle->XferCount - 1;\n    handle->State = HAL_I2C_STATE_READY;\n    handle->PreviousState = 0;\n    if (handle->Mode == HAL_I2C_MODE_MEM) {\n      handle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MemRxCpltCallback(handle);\n    }\n    else {\n      handle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MasterRxCpltCallback(handle);\n    }\n  }\n  else {\n    data_ptr = handle->pBuffPtr;\n    handle->pBuffPtr = data_ptr + 1;\n    *data_ptr = (uint8_t)handle->Instance->DR;\n    handle->XferCount = handle->XferCount - 1;\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e3c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "transfer_data_08004e3c"
        },
        "FUN_080091a0": {
            "renaming": {
                "FUN_080091a0": "execute_function_080091a0",
                "__ptr": "ptr",
                "_FUN_080091a0_r": "execute_function_recursive"
            },
            "code": "void execute_function_080091a0(void *__ptr)\n{\n  execute_function_080091a0_recursive(*(undefined4 *)PTR__impure_ptr_080091ac,__ptr);\n  return;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091a0",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "execute_function_080091a0"
        },
        "FUN_08002a1c": {
            "renaming": {
                "FUN_08002a1c": "setI2CAddress_08002a1c",
                "this": "wire",
                "address": "newAddress",
                "uint8_t": "unsigned char"
            },
            "code": "void __thiscall setI2CAddress_08002a1c(TwoWire *wire, int newAddress)\n{\n  setI2CAddress_08002a1c(wire, (uint8_t)newAddress);\n  return;\n}",
            "called": [
                "begin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a1c",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "setI2CAddress_08002a1c"
        },
        "FUN_08007718": {
            "renaming": {
                "FUN_08007718": "get_stimer_from_htim_08007718",
                "htim": "htim_conflict",
                "prev_htim": "prev_htim_conflict"
            },
            "code": "stimer_t_conflict* get_stimer_from_htim_08007718(TIM_HandleTypeDef_conflict* htim)\n{\n    TIM_HandleTypeDef_conflict* prev_htim = htim - 1;\n    return (stimer_t_conflict*)&prev_htim->Lock;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007718",
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_OC_DelayElapsedCallback"
            ],
            "imported": false,
            "current_name": "get_stimer_from_htim_08007718"
        },
        "FUN_08002a30": {
            "renaming": {
                "FUN_08002a30": "initializeTransmission_08002a30",
                "this": "wire",
                "address": "address",
                "PTR_transmitting_08002a48": "isTransmitting",
                "PTR_txAddress_08002a4c": "txAddress",
                "PTR_txBufferIndex_08002a50": "txBufferIndex",
                "PTR_txBufferLength_08002a54": "txBufferLength"
            },
            "code": "void __thiscall initializeTransmission_08002a30(TwoWire *wire, uint8_t address)\n{\n  bool PTR_transmitting_08002a48 = true;\n  uint8_t PTR_txAddress_08002a4c = address << 1;\n  uint8_t PTR_txBufferIndex_08002a50 = 0;\n  uint8_t PTR_txBufferLength_08002a54 = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a30",
            "calling": [
                "requestFrom",
                "sysexCallback",
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "initializeTransmission_08002a30"
        },
        "FUN_08009cd0": {
            "renaming": {
                "FUN_08009cd0": "walk_reentrant_functions_08009cd0",
                "param_1": "reent_struct",
                "DAT_08009cd8": "global_reentrancy_guard"
            },
            "code": "void walk_reentrant_functions_08009cd0(void *reent_struct)\n{\n  _fwalk_reent(reent_struct, DAT_08009cd8);\n  return;\n}",
            "called": [
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009cd0",
            "calling": [],
            "imported": false,
            "current_name": "walk_reentrant_functions_08009cd0"
        },
        "FUN_0800322c": {
            "renaming": {
                "FUN_0800322c": "sendFirmwareVersion_0800322c",
                "this": "marshaller",
                "major": "firmwareMajor",
                "minor": "firmwareMinor",
                "FirmataStream": "firmataStream",
                "Stream": "stream",
                "super_Print": "superPrint",
                "_vptr_Print": "virtualPrint"
            },
            "code": "void __thiscall sendFirmwareVersion_0800322c(FirmataMarshaller *marshaller, uint8_t major, uint8_t minor)\n{\n  if (marshaller->FirmataStream != nullptr) {\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller, 0xf9);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream, (uint)major);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream, (uint)minor);\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800322c",
            "calling": [
                "printVersion"
            ],
            "imported": false,
            "current_name": "sendFirmwareVersion_0800322c"
        },
        "FUN_08003760": {
            "renaming": {
                "FUN_08003760": "get_uwTick_value_08003760"
            },
            "code": "uint32_t get_uwTick_value_08003760(void)\n{\n  return *(uint32_t *)PTR_uwTick_08003768;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003760",
            "calling": [
                "GetCurrentMilli",
                "i2c_master_read",
                "HAL_RCC_ClockConfig",
                "HAL_RCCEx_PeriphCLKConfig",
                "HAL_RCC_OscConfig",
                "HAL_ADC_PollForConversion",
                "ADC_Enable",
                "HAL_ADCEx_Calibration_Start",
                "uart_debug_write",
                "ADC_ConversionStop_Disable",
                "HAL_UART_Transmit",
                "UART_WaitOnFlagUntilTimeout",
                "i2c_master_write"
            ],
            "imported": false,
            "current_name": "get_uwTick_value_08003760"
        },
        "FUN_08000130": {
            "renaming": {
                "FUN_08000130": "execute_if_completed_08000130",
                "PTR_completed_8667_08000170": "completed",
                "DAT_08000174": "function",
                "PTR_object_8672_0800016c": "object"
            },
            "code": "void execute_if_completed_08000130(void)\n{\n  int* PTR_completed_8667_08000170 = (int*)PTR_PTR_completed_8667_08000170_8667_08000170;\n  code* DAT_08000174 = DAT_08000174;\n  if (DAT_08000164 == 0) {\n    if (*PTR_completed_8667_08000170 != 0 && DAT_08000174 != (code*)0x0) {\n      (*DAT_08000174)();\n      return;\n    }\n    return;\n  }\n  if (*PTR_completed_8667_08000170 != 0 && DAT_08000174 != (code*)0x0) {\n    (*DAT_08000174)(PTR_PTR_completed_8667_08000170_8667_08000170, PTR_PTR_object_8672_0800016c_8672_0800016c);\n    return;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000130",
            "calling": [],
            "imported": false,
            "current_name": "execute_if_completed_08000130"
        },
        "FUN_08002798": {
            "renaming": {
                "FUN_08002798": "resetWireBuffers_08002798",
                "this": "wireInstance",
                "PTR_rxBufferIndex_080027d0": "rxBufferIndex",
                "PTR_rxBufferLength_080027d4": "rxBufferLength",
                "PTR_rxBuffer_080027d8": "rxBuffer",
                "PTR_rxBufferAllocated_080027dc": "rxBufferAllocated",
                "PTR_txBufferIndex_080027e0": "txBufferIndex",
                "PTR_txBufferLength_080027e4": "txBufferLength",
                "PTR_txBuffer_080027e8": "txBuffer",
                "PTR_txBufferAllocated_080027ec": "txBufferAllocated"
            },
            "code": "void __thiscall resetWireBuffers_08002798(TwoWire *wireInstance)\n{\n  uint8_t* PTR_PTR_rxBuffer_080027d8Index_080027d0 = wireInstance->PTR_PTR_rxBuffer_080027d8Index_080027d0;\n  uint8_t* PTR_PTR_rxBuffer_080027d8Length_080027d4 = wireInstance->PTR_PTR_rxBuffer_080027d8Length_080027d4;\n  uint8_t** PTR_rxBuffer_080027d8 = wireInstance->PTR_rxBuffer_080027d8;\n  uint8_t* PTR_PTR_rxBuffer_080027d8Allocated_080027dc = wireInstance->PTR_PTR_rxBuffer_080027d8Allocated_080027dc;\n  uint8_t* PTR_PTR_txBuffer_080027e8Index_080027e0 = wireInstance->PTR_PTR_txBuffer_080027e8Index_080027e0;\n  uint8_t* PTR_PTR_txBuffer_080027e8Length_080027e4 = wireInstance->PTR_PTR_txBuffer_080027e8Length_080027e4;\n  uint8_t** PTR_txBuffer_080027e8 = wireInstance->PTR_txBuffer_080027e8;\n  uint8_t* PTR_PTR_txBuffer_080027e8Allocated_080027ec = wireInstance->PTR_PTR_txBuffer_080027e8Allocated_080027ec;\n  *PTR_PTR_rxBuffer_080027d8Index_080027d0 = 0;\n  *PTR_PTR_rxBuffer_080027d8Length_080027d4 = 0;\n  if (*PTR_rxBuffer_080027d8 != NULL) {\n    memset(*PTR_rxBuffer_080027d8, 0, (uint)(byte)*PTR_PTR_rxBuffer_080027d8Allocated_080027dc);\n  }\n  *PTR_PTR_txBuffer_080027e8Index_080027e0 = 0;\n  *PTR_PTR_txBuffer_080027e8Length_080027e4 = 0;\n  if (*PTR_txBuffer_080027e8 != NULL) {\n    memset(*PTR_txBuffer_080027e8, 0, (uint)(byte)*PTR_PTR_txBuffer_080027e8Allocated_080027ec);\n  }\n  return;\n}",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002798",
            "calling": [],
            "imported": false,
            "current_name": "resetWireBuffers_08002798"
        },
        "FUN_08009190": {
            "renaming": {
                "FUN_08009190": "allocate_memory_08009190",
                "__size": "size",
                "pvVar1": "memory_pointer",
                "_FUN_08009190_r": "_allocate_memory_r"
            },
            "code": "void * allocate_memory_08009190(size_t size){\n  void *memory_pointer;\n  memory_pointer = (void *)_allocate_memory_08009190_r(*(undefined4 *)PTR__impure_ptr_0800919c,size);\n  return memory_pointer;\n}",
            "called": [
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009190",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009190"
        },
        "FUN_0800242c": {
            "renaming": {
                "FUN_0800242c": "initialize_timer_0800242c",
                "obj": "timer_obj",
                "60000": "timer_duration",
                "0x5dc": "timer_pulse_value",
                "DAT_08002440": "timer_callback"
            },
            "code": "void initialize_timer_0800242c(stimer_t *timer_obj)\n{\n  int timer_duration = 60000;\n  int timer_pulse_value = 0x5dc;\n  TimerPulseInit((stimer_t_conflict *)timer_obj, timer_duration, timer_pulse_value, DAT_08002440);\n  return;\n}",
            "called": [
                "TimerPulseInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800242c",
            "calling": [
                "attach"
            ],
            "imported": false,
            "current_name": "initialize_timer_0800242c"
        },
        "FUN_08002e44": {
            "renaming": {
                "FUN_08002e44": "parseFirmwareVersion_08002e44",
                "name": "versionName",
                "major": "majorVersion",
                "minor": "minorVersion",
                "bVar1": "versionNameLength",
                "pcVar2": "versionNameStart",
                "pcVar3": "versionNameEnd",
                "pbVar4": "versionVector",
                "sVar5": "versionVectorSize",
                "firmwareVersionCount": "versionNameLength",
                "firmwareVersionVector": "versionVector",
                "PTR_s__cpp_08002ec0": "versionNameStartString"
            },
            "code": "void __thiscall parseFirmwareVersion_08002e44(char *versionName, byte majorVersion, byte minorVersion)\n{\n  byte versionNameLength;\n  char *versionNameStart;\n  char *versionNameEnd;\n  byte *versionVector;\n  size_t versionVectorSize;\n  \n  versionNameStart = strstr(versionName, PTR_s__cpp_08002ec0);\n  versionNameEnd = strrchr(versionName, 0x2f);\n  if (versionNameEnd == NULL) {\n    versionNameEnd = strrchr(versionName, 0x5c);\n  }\n  if (versionNameEnd != NULL) {\n    versionName = versionNameEnd + 1;\n  }\n  if (versionNameStart == NULL) {\n    versionNameLength = strlen(versionName) + 2;\n  }\n  else {\n    versionNameLength = versionNameStart - versionName + 2;\n  }\n  free(firmwareVersionVector);\n  versionVectorSize = versionNameLength + 1;\n  versionVector = (byte *)malloc(versionVectorSize);\n  firmwareVersionVector = versionVector;\n  versionVector[versionNameLength] = 0;\n  *versionVector = majorVersion;\n  versionVector[1] = minorVersion;\n  strncpy((char *)(versionVector + 2), versionName, versionNameLength - 2);\n  return;\n}",
            "called": [
                "strlen",
                "free",
                "malloc",
                "strrchr",
                "strstr",
                "strncpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002e44",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "parseFirmwareVersion_08002e44"
        },
        "FUN_0800a0a8": {
            "renaming": {
                "FUN_0800a0a8": "write_to_file_with_error_handling_0800a0a8",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_length",
                "puVar1": "errno_pointer",
                "iVar2": "write_result"
            },
            "code": "void write_to_file_with_error_handling_0800a0a8(int *error_code, int file_descriptor, char *buffer, int buffer_length)\n{\n  int write_result;\n  int *errno_pointer = PTR_errno_0800a0c8;\n  *errno_pointer = 0;\n  write_result = _write(file_descriptor, buffer, buffer_length);\n  if ((write_result == -1) && (*errno_pointer != 0)) {\n    *error_code = *errno_pointer;\n  }\n  return;\n}",
            "called": [
                "_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a0a8",
            "calling": [
                "__swrite"
            ],
            "imported": false,
            "current_name": "write_to_file_with_error_handling_0800a0a8"
        },
        "FUN_08002c00": {
            "renaming": {
                "FUN_08002c00": "readFromAddress_08002c00",
                "this": "wire",
                "address": "address",
                "quantity": "quantity",
                "sendStop": "sendStop",
                "uVar1": "result"
            },
            "code": "uint8_t __thiscall readFromAddress_08002c00(TwoWire *wire, uint8_t address, uint8_t quantity, uint8_t sendStop)\n{\n  uint8_t result;\n  result = readFromAddress_08002c00(wire, address, quantity, 0, '\\0', sendStop);\n  return result;\n}",
            "called": [
                "requestFrom"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c00",
            "calling": [
                "requestFrom"
            ],
            "imported": false,
            "current_name": "readFromAddress_08002c00"
        },
        "FUN_08003f30": {
            "renaming": {
                "FUN_08003f30": "set_interrupt_priority_08003f30",
                "IRQn": "irq",
                "PreemptPriority": "preempt_priority",
                "SubPriority": "sub_priority",
                "uVar1": "irq_num",
                "uVar2": "priority_group_bits",
                "uVar3": "priority_group",
                "priority": "priority",
                "DAT_08003f8c": "ptr_dat_08003f8c",
                "DAT_08003f90": "ptr_dat_08003f90"
            },
            "code": "void set_interrupt_priority_08003f30(IRQn_Type_conflict irq, uint32_t preempt_priority, uint32_t sub_priority)\n{\n  uint8_t priority_group_bits = (*(int *)(DAT_08003f8c + 0xc) << 0x15) >> 0x1d;\n  uint8_t priority_group = 7 - priority_group_bits;\n  if (priority_group > 3) {\n    priority_group = 4;\n  }\n  uint8_t sub_priority_bits = priority_group_bits + 4 < 7 ? 0 : priority_group_bits - 3;\n  uint32_t priority = ((preempt_priority & ((1 << priority_group) - 1)) << sub_priority_bits) | ((1 << sub_priority_bits) - 1 & sub_priority);\n  if ((int)irq < 0) {\n    *(char *)(DAT_08003f90 + (irq & 0xf)) = (char)(priority << 4);\n  }\n  else {\n    *(char *)(irq + 0xe000e400) = (char)(priority << 4);\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f30",
            "calling": [
                "TimerPulseInit",
                "i2c_custom_init",
                "uart_attach_rx_callback",
                "SystemClock_Config",
                "uart_attach_tx_callback",
                "HAL_InitTick"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_08003f30"
        },
        "FUN_080073d8": {
            "renaming": {
                "FUN_080073d8": "handle_rtc_alarm_interrupt_080073d8",
                "PTR_RtcHandle_080073e4": "rtc_handle"
            },
            "code": "void handle_rtc_alarm_interrupt_080073d8(void)\n{\n  RTC_HandleTypeDef* PTR_RtcHandle_080073e4 = (RTC_HandleTypeDef*)PTR_RtcHandle_080073e4;\n  HAL_RTC_AlarmIRQHandler(PTR_RtcHandle_080073e4);\n  return;\n}",
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073d8",
            "calling": [],
            "imported": false,
            "current_name": "handle_rtc_alarm_interrupt_080073d8"
        },
        "FUN_080085dc": {
            "renaming": {
                "FUN_080085dc": "is_uart_state_ready_080085dc",
                "obj": "serial_obj",
                "HVar1": "uart_state",
                "PTR_uart_handlers_080085fc": "PTR_uart_handlers_080085fc",
                "uint": "uint"
            },
            "code": "bool is_uart_state_ready_080085dc(serial_t *serial_obj) {\n  UART_HandleTypeDef *uart_handler = *(UART_HandleTypeDef **)(PTR_uart_handlers_080085fc + (uint)serial_obj->index * 4);\n  HAL_UART_StateTypeDef uart_state = HAL_UART_GetState(uart_handler);\n  bool is_ready = (uart_state & 0x21U) == 0x21;\n  return is_ready;\n}",
            "called": [
                "HAL_UART_GetState"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080085dc",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "is_uart_state_ready_080085dc"
        },
        "FUN_08008ed6": {
            "renaming": {
                "__thiscall Print::FUN_08008ed6": "printNumber",
                "this": "printer",
                "n": "number",
                "base": "base",
                "sVar1": "size",
                "FUN_08008ed6": "printNumber_08008ed6"
            },
            "code": "size_t printNumber_08008ed6(Print *printer, ulong number, int base) {\n  size_t size;\n  if (base != 0) {\n    size = printNumber_08008ed6(printer, number, (uint8_t)base);\n  } else {\n    size = (**printer->_vptr_Print)(printer, number & 0xff);\n  }\n  return size;\n}",
            "called": [
                "printNumber"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ed6",
            "calling": [
                "print"
            ],
            "imported": false,
            "current_name": "printNumber_08008ed6"
        },
        "FUN_08008db0": {
            "renaming": {
                "FUN_08008db0": "initialize_static_variables_08008db0"
            },
            "code": "void initialize_static_variables_08008db0(void)\n{\n  __static_initialization_and_destruction_0(1, 0xFFFF);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008db0",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_08008db0"
        },
        "FUN_08002444": {
            "renaming": {
                "FUN_08002444": "checkServo_08002444",
                "obj": "servoTimer",
                "channel": "channel",
                "bVar1": "isServoEnabled",
                "puVar2": "timerChannelPtr",
                "uVar3": "timerCounter",
                "iVar4": "servoOffset",
                "uVar5": "servoIdx"
            },
            "code": "void checkServo_08002444(stimer_t *servoTimer, uint32_t channel){\n  bool isServoEnabled;\n  undefined *timerChannelPtr;\n  uint32_t servoIdx;\n  int servoOffset;\n  uint32_t timerCounter;\n  uint32_t servoCount = (uint32_t)*ServoCount;\n\n  servoIdx = (uint32_t)servoTimer->idx;\n  timerChannelPtr = &timerChannel[servoIdx];\n  if ((timerChannelPtr[0] & 0x80) == 0) {\n    servoOffset = servoIdx * 0xc;\n    if ((char)timerChannelPtr[0] + servoOffset < (int)servoCount){\n      if ((servos[(char)timerChannelPtr[0] + servoOffset * 8] & 0x40) == 0) {\n        isServoEnabled = false;\n      }\n      else {\n        isServoEnabled = true;\n      }\n    }\n    else {\n      isServoEnabled = false;\n    }\n    if (isServoEnabled) {\n      digitalWrite((byte)servos[(servoOffset + (char)timerChannelPtr[0]) * 8] & 0x3f, 0);\n    }\n  }\n  else {\n    setTimerCounter((stimer_t_conflict *)servoTimer, 0);\n  }\n  timerChannelPtr[0]++;\n  servoOffset = servoIdx * 0xc;\n  if ((char)timerChannelPtr[0] + servoOffset < (int)servoCount) {\n    if ((char)timerChannelPtr[0] < '\f') {\n      isServoEnabled = true;\n    }\n    else {\n      isServoEnabled = false;\n    }\n  }\n  else {\n    isServoEnabled = false;\n  }\n  if (isServoEnabled) {\n    if ((servos[(char)timerChannelPtr[0] + servoOffset * 8] & 0x40) != 0) {\n      digitalWrite((byte)servos[((char)timerChannelPtr[0] + servoOffset) * 8] & 0x3f, 1);\n    }\n    timerCounter = getTimerCounter((stimer_t_conflict *)servoTimer);\n    setCCRRegister((stimer_t_conflict *)servoTimer, channel, *(int *)(servos + (servoOffset + (char)timerChannelPtr[0]) * 8 + 4) + timerCounter);\n    return;\n  }\n  timerCounter = getTimerCounter((stimer_t_conflict *)servoTimer);\n  if (timerCounter + 4 < 20000) {\n    setCCRRegister((stimer_t_conflict *)servoTimer, channel, 20000);\n  }\n  else {\n    timerCounter = getTimerCounter((stimer_t_conflict *)servoTimer);\n    setCCRRegister((stimer_t_conflict *)servoTimer, channel, timerCounter + 4);\n  }\n  timerChannelPtr[0] = 0xff;\n}",
            "called": [
                "digitalWrite",
                "getTimerCounter",
                "setCCRRegister",
                "setTimerCounter"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002444",
            "calling": [],
            "imported": false,
            "current_name": "checkServo_08002444"
        },
        "FUN_0800906c": {
            "renaming": {
                "FUN_0800906c": "handle_gpio_interrupts_0800906c",
                "uVar1": "gpio_pin"
            },
            "code": "void handle_gpio_interrupts_0800906c(void)\n{\n  uint16_t gpio_pin;\n  for (gpio_pin = 0x400; gpio_pin < 0x8001; gpio_pin <<= 1) {\n    HAL_GPIO_EXTI_IRQHandler(gpio_pin);\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800906c",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_interrupts_0800906c"
        },
        "FUN_08003658": {
            "renaming": {
                "FUN_08003658": "initialize_system_08003658",
                "iVar1": "index",
                "puVar2": "completed_ptr",
                "UNRECOVERED_JUMPTABLE": "jump_table_ptr"
            },
            "code": "void initialize_system_08003658(void)\n{\n  int index;\n  undefined4 *completed_ptr = (undefined4 *)PTR_completed_8667_08003698;\n  undefined4 *dso_handle_ptr = (undefined4 *)PTR___dso_handle_08003690;\n  code *jump_table_ptr = (code *)0x800368a;\n  \n  for (index = 0; dso_handle_ptr + index < (undefined4 *)PTR_completed_8667_08003694; index += 4) {\n    *(undefined4 *)(dso_handle_ptr + index) = *(undefined4 *)(PTR__sidata_0800368c + index);\n  }\n  for (; completed_ptr < (undefined4 *)PTR__ebss_0800369c; completed_ptr++) {\n    *completed_ptr = 0;\n  }\n  \n  SystemInit();\n  __libc_init_array();\n  \n  // Jump to main function\n  (*jump_table_ptr)();\n  return;\n}",
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003658",
            "calling": [],
            "imported": false,
            "current_name": "initialize_system_08003658"
        },
        "FUN_08009a80": {
            "renaming": {
                "FUN_08009a80": "process_input_output_08009a80",
                "param_1": "output_error",
                "param_2": "stream",
                "uVar1": "status",
                "uVar2": "flags",
                "iVar3": "impure_ptr"
            },
            "code": "uint process_input_output_08009a80(undefined4 *output_error, undefined4 *stream) {\n  uint status;\n  ushort flags;\n  int impure_ptr = *(int *)PTR__impure_ptr_08009b4c;\n  if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n    __sinit(impure_ptr);\n  }\n  if (stream == (undefined4 *)PTR___sf_fake_stdin_08009b50) {\n    stream = *(undefined4 **)(impure_ptr + 4);\n  }\n  else if (stream == (undefined4 *)PTR___sf_fake_stdout_08009b54) {\n    stream = *(undefined4 **)(impure_ptr + 8);\n  }\n  else if (stream == (undefined4 *)PTR___sf_fake_stderr_08009b58) {\n    stream = *(undefined4 **)(impure_ptr + 0xc);\n  }\n  flags = *(ushort *)(stream + 3);\n  status = (uint)flags;\n  if (-1 < (int)(status << 0x1c)) {\n    if (-1 < (int)(status << 0x1b)) {\n      *output_error = 9;\n      goto LAB_08009ab0;\n    }\n    if ((int)(status << 0x1d) < 0) {\n      if ((undefined4 *)stream[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)stream[0xd] != stream + 0x11) {\n          _free_r(output_error);\n        }\n        stream[0xd] = 0;\n      }\n      *(ushort *)(stream + 3) = *(ushort *)(stream + 3) & 0xffdb;\n      stream[1] = 0;\n      *stream = stream[4];\n    }\n    *(ushort *)(stream + 3) = *(ushort *)(stream + 3) | 8;\n  }\n  if ((stream[4] == 0) && ((*(ushort *)(stream + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(output_error, stream);\n  }\n  flags = *(ushort *)(stream + 3);\n  status = flags & 1;\n  if ((flags & 1) == 0) {\n    if (-1 < (int)((uint)flags << 0x1e)) {\n      status = stream[5];\n    }\n    stream[2] = status;\n  }\n  else {\n    stream[2] = 0;\n    stream[6] = -stream[5];\n  }\n  if (stream[4] == 0) {\n    flags = *(ushort *)(stream + 3);\n    status = (int)(short)flags & 0x80;\n    if (status != 0) {\n      *(ushort *)(stream + 3) = flags | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    status = 0;\n  }\n  return status;\n}",
            "called": [
                "__smakebuf_r",
                "_free_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009a80",
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "process_input_output_08009a80"
        },
        "FUN_080062f4": {
            "renaming": {
                "FUN_080062f4": "set_timer_channel_disabled_080062f4",
                "htim": "timer_handle",
                "Channel": "channel",
                "TIM_TypeDef_conflict": "TIM_TypeDef",
                "pTVar1": "timer_instance",
                "DAT_0800638c": "PTR_0800638c"
            },
            "code": "HAL_StatusTypeDef set_timer_channel_disabled_080062f4(TIM_HandleTypeDef *timer_handle, uint32_t channel) {\n  TIM_TypeDef *timer_instance = timer_handle->Instance;\n  switch(channel) {\n    case 0:\n      timer_instance->DIER &= 0xfffffffd;\n      break;\n    case 4:\n      timer_instance->DIER &= 0xfffffffb;\n      break;\n    case 8:\n      timer_instance->DIER &= 0xfffffff7;\n      break;\n    case 0xc:\n      timer_instance->DIER &= 0xffffffef;\n  }\n  TIM_CCxChannelCmd(timer_instance, channel, DISABLE);\n  if (((timer_instance == DAT_0800638c) && ((timer_instance->CCER & 0x1111) == 0)) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->BDTR &= 0xffff7fff;\n  }\n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->CR1 &= 0xfffffffe;\n  }\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080062f4",
            "calling": [
                "TimerPulseDeinit"
            ],
            "imported": false,
            "current_name": "set_timer_channel_disabled_080062f4"
        },
        "FUN_080073e8": {
            "renaming": {
                "FUN_080073e8": "wait_for_input_080073e8",
                "msg": "message",
                "val": "value"
            },
            "code": "void wait_for_input_080073e8(char *message, int value)\n{\n  do {\n    // do nothing, wait for user input\n  } while(true);\n}",
            "called": [
                "_Error_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073e8",
            "calling": [
                "_Error_Handler",
                "SystemClock_Config",
                "onReceiveService"
            ],
            "imported": false,
            "current_name": "wait_for_input_080073e8"
        },
        "FUN_0800267c": {
            "renaming": {
                "FUN_0800267c": "updateServo_0800267c",
                "this": "servo",
                "value": "value",
                "iVar1": "minPos",
                "iVar2": "maxPos"
            },
            "code": "void __thiscall updateServo_0800267c(Servo *servo, int value) {\n  int minPos = (0x88 - servo->minAngle) * 4;\n  int maxPos = (600 - servo->maxAngle) * 4;\n  if (servo->servoIndex < 0xc) {\n    if ((minPos - value == 0 || minPos < value) &&\n        (value == maxPos || value + maxPos * -4 < 0 != SBORROW4(value,maxPos))) {\n      *(int *)(PTR_servos_080026ac + (uint)servo->servoIndex * 8 + 4) = value;\n    }\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800267c",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "updateServo_0800267c"
        },
        "FUN_0800376c": {
            "renaming": {
                "FUN_0800376c": "check_adc_conversion_status_0800376c",
                "hadc": "adc_handle",
                "HVar1": "status",
                "uVar2": "tick_start",
                "pAVar5": "adc_instance",
                "uVar3": "adc_clock_freq",
                "Conversion_Timeout_CPU_cycles": "conversion_timeout_cpu_cycles",
                "Timeout": "timeout",
                "uVar6": "system_core_clock",
                "PTR_SystemCoreClock_080038c8": "PTR_SystemCoreClock",
                "sample_time": "sample_time",
                "DAT_080038cc": "ADC_SMPR2_SMP",
                "DAT_080038d0": "ADC_SMPR1_SMP17",
                "DAT_080038d4": "ADC_SMPR1_SMP16",
                "DAT_080038d8": "ADC_SMPR1_SMP15",
                "adc_clock_cycles_per_sample": "adc_clock_cycles_per_sample"
            },
            "code": "HAL_StatusTypeDef_conflict check_adc_conversion_status_0800376c(ADC_HandleTypeDef *adc_handle, uint32_t timeout)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t tick_start = HAL_GetTick();\n  ADC_TypeDef *adc_instance = adc_handle->Instance;\n  uint32_t conversion_timeout_cpu_cycles = 0;\n  \n  if ((adc_instance->CR2 & ADC_CR2_ADON) == 0) {\n    if (((adc_instance->CR1 & ADC_CR1_EOCIE) == 0) && ((adc_instance->SQR1 & ADC_SQR1_L) == 0)) {\n      do {\n        if ((adc_handle->Instance->SR & ADC_SR_EOC) != 0) goto conversion_complete;\n      } while ((timeout == 0xffffffff) || ((timeout != 0 && (HAL_GetTick() - tick_start <= timeout))));\n      adc_handle->State = adc_handle->State | ADC_STATE_TIMEOUT;\n      adc_handle->Lock = HAL_UNLOCKED;\n      status = HAL_TIMEOUT;\n    }\n    else {\n      uint32_t system_core_clock = *(uint *)PTR_SystemCoreClock_080038c8_080038c8;\n      uint32_t adc_clock_freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC);\n      adc_instance = adc_handle->Instance;\n      uint32_t sample_time;\n      if (((adc_instance->SMPR2 & DAT_080038cc) == 0) && ((adc_instance->SMPR1 & (ADC_SMPR1_SMP10 | ADC_SMPR1_SMP11 | ADC_SMPR1_SMP12 | ADC_SMPR1_SMP13 | ADC_SMPR1_SMP14 | DAT_080038d8 | DAT_080038d4 | DAT_080038d0)) == 0)) {\n        sample_time = 14;\n      }\n      else if (((adc_instance->SMPR2 & DAT_080038cc) == 0) && ((adc_instance->SMPR1 & (ADC_SMPR1_SMP10 | ADC_SMPR1_SMP11 | ADC_SMPR1_SMP12 | ADC_SMPR1_SMP13 | ADC_SMPR1_SMP14 | DAT_080038d8 | DAT_080038d4 | DAT_080038d0)) == (ADC_SMPR1_SMP10 | ADC_SMPR1_SMP11 | ADC_SMPR1_SMP12 | ADC_SMPR1_SMP13 | ADC_SMPR1_SMP14 | DAT_080038d8 | DAT_080038d4 | DAT_080038d0))) {\n        sample_time = 54;\n      }\n      else if ((DAT_080038cc0 & adc_instance->SMPR2) == 0) {\n        if ((ADC_SMPR1_SMP0 & adc_instance->SMPR1) == 0) {\n          sample_time = 54;\n        }\n        else {\n          sample_time = 252;\n        }\n      }\n      else {\n        sample_time = 252;\n      }\n      uint32_t adc_clock_cycles_per_sample = (system_core_clock / adc_clock_freq) * sample_time;\n      for (; conversion_timeout_cpu_cycles <= adc_clock_cycles_per_sample && adc_clock_cycles_per_sample - conversion_timeout_cpu_cycles != 0; conversion_timeout_cpu_cycles = conversion_timeout_cpu_cycles + 1) {\n        if ((timeout != 0xffffffff) && ((timeout == 0 || (HAL_GetTick() - tick_start > timeout)))) {\n          adc_handle->State = adc_handle->State | ADC_STATE_TIMEOUT;\n          adc_handle->Lock = HAL_UNLOCKED;\n          return HAL_TIMEOUT;\n        }\n      }\nconversion_complete:\n      adc_handle->Instance->SR = 0xffffffed;\n      adc_handle->State = adc_handle->State | ADC_STATE_EOC;\n      if ((adc_handle->Instance->CR2 & ADC_CR2_CONT) == ADC_CR2_CONT) {\n        if (!(adc_handle->Init).ContinuousConvMode) {\n          adc_handle->State = adc_handle->State & ~ADC_STATE_CONTINUOUS;\n          if ((adc_handle->State & ADC_STATE_INJ_BUSY) == 0) {\n            adc_handle->State = adc_handle->State | ADC_STATE_READY;\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        status = HAL_OK;\n      }\n    }\n  }\n  else {\n    adc_handle->State = adc_handle->State | ADC_STATE_ERROR_INTERNAL;\n    adc_handle->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  return status;\n}",
            "called": [
                "HAL_RCCEx_GetPeriphCLKFreq",
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800376c",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "check_adc_conversion_status_0800376c"
        },
        "FUN_08003e20": {
            "renaming": {
                "FUN_08003e20": "perform_ADC_conversion_08003e20",
                "hadc": "ADC_handle",
                "HVar1": "status",
                "uVar2": "clock_freq",
                "uVar3": "current_time",
                "pAVar4": "adc_instance",
                "uVar5": "sys_clock_freq",
                "wait_loop_index": "wait_loop_index",
                "PTR_SystemCoreClock_08003f08": "N/A",
                "DAT_08003f00": "N/A"
            },
            "code": "HAL_StatusTypeDef_conflict perform_ADC_conversion_08003e20(ADC_HandleTypeDef *hadc)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t clock_freq, wait_loop_index, start_time;\n  ADC_TypeDef *adc_instance;\n  if (hadc->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  hadc->Lock = HAL_LOCKED;\n  status = ADC_ConversionStop_Disable(hadc);\n  if (status == HAL_OK) {\n    hadc->State &= ~0x1202;\n    clock_freq = HAL_RCCEx_GetPeriphCLKFreq(2);\n    wait_loop_index = (HAL_RCC_GetHCLKFreq() / clock_freq) << 1;\n    while (wait_loop_index != 0) {\n        wait_loop_index--;\n    }\n    ADC_Enable(hadc);\n    hadc->Instance->CR2 |= 8;\n    start_time = HAL_GetTick();\n    while ((hadc->Instance->CR2 & 8) != 0) {\n      if (HAL_GetTick() - start_time > 10) {\n        hadc->State = (hadc->State & ~0x12) | 0x10;\n        hadc->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adc_instance = hadc->Instance;\n    adc_instance->CR2 |= 4;\n    start_time = HAL_GetTick();\n    while ((hadc->Instance->CR2 & 4) != 0) {\n      if (HAL_GetTick() - start_time > 10) {\n        hadc->State = (hadc->State & ~0x12) | 0x10;\n        hadc->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    hadc->State = (hadc->State & ~0x3) | 0x1;\n  }\n  hadc->Lock = HAL_UNLOCKED;\n  return status;\n}",
            "called": [
                "HAL_RCCEx_GetPeriphCLKFreq",
                "HAL_GetTick",
                "ADC_Enable",
                "ADC_ConversionStop_Disable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003e20",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "perform_ADC_conversion_08003e20"
        },
        "FUN_08002c14": {
            "renaming": {
                "FUN_08002c14": "readFromAddress_08002c14",
                "this": "wire",
                "address": "address",
                "quantity": "quantity",
                "uVar1": "result"
            },
            "code": "uint8_t __thiscall readFromAddress_08002c14(TwoWire *wire, uint8_t address, uint8_t quantity)\n{\n  uint8_t result;\n  result = readFromAddress_08002c14(wire, address, quantity, '\\x01');\n  return result;\n}",
            "called": [
                "requestFrom"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c14",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "readFromAddress_08002c14"
        },
        "FUN_08009084": {
            "renaming": {
                "std::function<void()>::operator__": "improved_function<void()>::execute",
                "this": "function_ptr",
                "super__Function_base": "function_base",
                "_M_manager": "_manager",
                "_M_invoker": "invoker",
                "FUN_08009084": "improved_function<void_08009084"
            },
            "code": "void __thiscall improved_function<void_08009084()>::execute(function_void___ *function_ptr)\n{\n  if ((function_ptr->function_base)._M_manager != (_Manager_type)0x0) {\n    (*function_ptr->invoker)((_Any_data *)function_ptr);\n    return;\n  }\n  __throw_bad_function_call();\n}",
            "called": [
                "__throw_bad_function_call"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009084",
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "imported": false,
            "current_name": "improved_function<void_08009084"
        },
        "FUN_08005840": {
            "renaming": {
                "FUN_08005840": "calculate_value_08005840",
                "uVar1": "value",
                "uVar2": "flags",
                "local_1c": "extra_data",
                "abStack_18": "data_array",
                "uStack_14": "constant_1",
                "uStack_10": "constant_2",
                "uStack_c": "constant_3"
            },
            "code": "uint calculate_value_08005840(void)\n{\n  uint value;\n  uint flags;\n  undefined2 extra_data;\n  byte data_array[4];\n  undefined4 constant_1;\n  undefined4 constant_2;\n  undefined4 constant_3;\n  \n  constant_3 = *(undefined4 *)(PTR__etext_0800589c + 8);\n  constant_2 = *(undefined4 *)(PTR__etext_0800589c + 4);\n  constant_1 = *(undefined4 *)PTR__etext_0800589c;\n  extra_data = *(undefined2 *)(PTR__etext_0800589c + 0x10);\n  flags = *(uint *)(DAT_080058a0 + 4);\n  value = DAT_080058a8;\n  if ((flags & 0xc) == 8) {\n    if ((flags & 0x10000) == 0) {\n      value = DAT_080058a4 * (uint)data_array[(flags << 10) >> 0x1c];\n    }\n    else {\n      value = (DAT_080058a8 * data_array[(flags << 10) >> 0x1c]) / (uint)*(byte *)((int)&extra_data - ((*(int *)(DAT_080058a0 + 4) << 0xe) >> 0x1f));\n    }\n  }\n  return value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005840",
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "imported": false,
            "current_name": "calculate_value_08005840"
        },
        "FUN_08003306": {
            "renaming": {
                "FUN_08003306": "parseCommand_08003306",
                "command": "commandByte",
                "newFunction": "callback",
                "context": "callbackContext",
                "currentReportDigitalCallback": "reportDigitalCallback",
                "currentReportDigitalCallbackContext": "reportDigitalCallbackContext",
                "currentPinModeCallback": "pinModeCallback",
                "currentPinModeCallbackContext": "pinModeCallbackContext",
                "currentPinValueCallback": "pinValueCallback",
                "currentPinValueCallbackContext": "pinValueCallbackContext",
                "currentReportAnalogCallback": "reportAnalogCallback",
                "currentReportAnalogCallbackContext": "reportAnalogCallbackContext",
                "currentDigitalCallback": "digitalCallback",
                "currentDigitalCallbackContext": "digitalCallbackContext",
                "currentAnalogCallback": "analogCallback",
                "currentAnalogCallbackContext": "analogCallbackContext",
                "0xd0": "REPORT_DIGITAL",
                "0xf4": "PIN_MODE_QUERY",
                "0xf5": "PIN_STATE_QUERY",
                "0xe0": "REPORT_ANALOG",
                "0x90": "DIGITAL_MESSAGE",
                "0xc0": "REPORT_ANALOG"
            },
            "code": "void __thiscall parseCommand_08003306(FirmataParser *this, uint8_t command, callbackFunction newFunction, void *context) {\n  if (command == REPORT_DIGITAL) {\n    this->currentReportDigitalCallback = newFunction;\n    this->currentReportDigitalCallbackContext = context;\n    return;\n  }\n  if (command > REPORT_DIGITAL) {\n    if (command == PIN_MODE_QUERY) {\n      this->currentPinModeCallback = newFunction;\n      this->currentPinModeCallbackContext = context;\n      return;\n    }\n    if (command == PIN_STATE_QUERY) {\n      this->currentPinValueCallback = newFunction;\n      this->currentPinValueCallbackContext = context;\n      return;\n    }\n    if (command == REPORT_ANALOG) {\n      this->currentReportAnalogCallback = newFunction;\n      this->currentReportAnalogCallbackContext = context;\n      return;\n    }\n    return;\n  }\n  if (command == DIGITAL_MESSAGE) {\n    this->currentDigitalCallback = newFunction;\n    this->currentDigitalCallbackContext = context;\n    return;\n  }\n  if (command == REPORT_ANALOG) {\n    this->currentAnalogCallback = newFunction;\n    this->currentAnalogCallbackContext = context;\n    return;\n  }\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003306",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "parseCommand_08003306"
        },
        "FUN_08002578": {
            "renaming": {
                "FUN_08002578": "stopTimer_08002578",
                "obj": "timerObj"
            },
            "code": "void stopTimer_08002578(stimer_t *timerObj)\n{\n  TimerPulseDeinit((stimer_t_conflict *)timerObj);\n  return;\n}",
            "called": [
                "TimerPulseDeinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002578",
            "calling": [
                "detach"
            ],
            "imported": false,
            "current_name": "stopTimer_08002578"
        },
        "FUN_08006932": {
            "renaming": {
                "FUN_08006932": "configure_uart_08006932",
                "huart": "uart_handle",
                "Instance": "instance",
                "CR1": "cr1",
                "gState": "global_state",
                "HAL_UART_TxCpltCallback": "tx_complete_callback",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "code": "HAL_StatusTypeDef configure_uart_08006932(UART_HandleTypeDef *uart_handle)\n{\n  uint32_t cr1_mask = 0xffffffbf;\n  uart_handle->Instance->CR1 &= cr1_mask;\n  uart_handle->gState = HAL_UART_STATE_READY;\n  HAL_UART_TxCpltCallback(uart_handle);\n  return HAL_OK;\n}",
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006932",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "configure_uart_08006932"
        },
        "FUN_080060c4": {
            "renaming": {
                "FUN_080060c4": "configure_timer_080060c4",
                "TIMx": "timer",
                "OC_Config": "output_compare_config",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "DAT_08006124": "PTR_08006124"
            },
            "code": "void configure_timer_080060c4(TIM_TypeDef_conflict *timer, TIM_OC_InitTypeDef *output_compare_config)\n{\n  uint32_t temp1;\n  uint32_t temp2;\n  uint32_t temp3;\n  \n  timer->CCER = timer->CCER & 0xffffffef;\n  temp2 = timer->CR2;\n  temp3 = output_compare_config->OCMode;\n  temp1 = timer->CCER & 0xffffffdf | output_compare_config->OCPolarity << 4;\n  if (timer == DAT_08006124) {\n    temp1 = (temp1 & 0xffffff7f | output_compare_config->OCNPolarity << 4) & 0xffffffbf;\n    temp2 = temp2 & 0xfffff3ff | output_compare_config->OCIdleState << 2 | output_compare_config->OCNIdleState << 2;\n  }\n  timer->CR2 = temp2;\n  timer->CCMR1 = timer->CCMR1 & 0xffff8cff | temp3 << 8;\n  timer->CCR2 = output_compare_config->Pulse;\n  timer->CCER = temp1;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080060c4",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_080060c4"
        },
        "FUN_08009eac": {
            "renaming": {
                "FUN_08009eac": "initialize_file_descriptor_08009eac",
                "param_1": "file_descriptor",
                "param_2": "file_descriptor_pointer",
                "uVar1": "status_code",
                "iVar2": "temp_variable",
                "local_18": "file_size",
                "local_14": "local_pointer"
            },
            "code": "void initialize_file_descriptor_08009eac(int file_descriptor, int *file_descriptor_pointer)\n{\n  ushort status_code;\n  int temp_variable;\n  int file_size;\n  int *local_pointer;\n\n  if (-1 < (int)((uint)*(ushort *)(file_descriptor_pointer + 3) << 0x1e)) {\n    file_size = file_descriptor;\n    local_pointer = file_descriptor_pointer;\n    status_code = __swhatbuf_r(file_descriptor,file_descriptor_pointer,&file_size,&local_pointer);\n    temp_variable = _malloc_r(file_descriptor,file_size);\n    if (temp_variable != 0) {\n      *(undefined4 *)(file_descriptor + 0x28) = DAT_08009f28;\n      *file_descriptor_pointer = temp_variable;\n      *(ushort *)(file_descriptor_pointer + 3) = *(ushort *)(file_descriptor_pointer + 3) | 0x80;\n      file_descriptor_pointer[4] = temp_variable;\n      file_descriptor_pointer[5] = file_size;\n      if ((local_pointer != (int *)0x0) &&\n         (temp_variable = _isatty_r(file_descriptor,(int)*(short *)((int)file_descriptor_pointer + 0xe)), temp_variable != 0)) {\n        *(ushort *)(file_descriptor_pointer + 3) = *(ushort *)(file_descriptor_pointer + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(file_descriptor_pointer + 3) = status_code | *(ushort *)(file_descriptor_pointer + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(file_descriptor_pointer + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(file_descriptor_pointer + 3) = *(ushort *)(file_descriptor_pointer + 3) & 0xfffc | 2;\n  }\n  *file_descriptor_pointer = (int)file_descriptor_pointer + 0x47;\n  file_descriptor_pointer[4] = (int)file_descriptor_pointer + 0x47;\n  file_descriptor_pointer[5] = 1;\n  return;\n}",
            "called": [
                "_malloc_r",
                "__swhatbuf_r",
                "_isatty_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009eac",
            "calling": [
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "initialize_file_descriptor_08009eac"
        },
        "FUN_08008dbe": {
            "renaming": {
                "FUN_08008dbe": "printIPAddress_08008dbe",
                "this": "ipAddress",
                "p": "printer",
                "iVar3": "i",
                "iVar4": "totalPrinted",
                "sVar1": "bytesPrinted",
                "sVar2": "dotPrinted"
            },
            "code": "size_t __thiscall printIPAddress_08008dbe(IPAddress *ipAddress, Print *printer)\n{\n  size_t totalPrinted = 0;\n  for (int i = 0; i < 3; i++) {\n    size_t bytesPrinted = Print::print(printer, (ipAddress->_address).bytes[i], 10);\n    size_t dotPrinted = Print::print(printer, '.');\n    totalPrinted += bytesPrinted + dotPrinted;\n  }\n  totalPrinted += Print::print(printer, (ipAddress->_address).bytes[3], 10);\n  return totalPrinted;\n}",
            "called": [
                "print",
                "print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008dbe",
            "calling": [],
            "imported": false,
            "current_name": "printIPAddress_08008dbe"
        },
        "FUN_080072d8": {
            "renaming": {
                "FUN_080072d8": "set_gpio_pin_state_080072d8",
                "port": "gpio_port",
                "pin": "pin_number",
                "val": "state",
                "GPIO_PIN_RESET": "GPIO_PIN_STATE_RESET",
                "GPIO_PIN_SET": "GPIO_PIN_STATE_SET"
            },
            "code": "void set_gpio_pin_state_080072d8(GPIO_TypeDef *gpio_port, uint32_t pin_number, uint32_t state) {\n  if (state == 0) {\n    HAL_GPIO_WritePin(gpio_port, (uint16_t)pin_number, GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(gpio_port, (uint16_t)pin_number, GPIO_PIN_SET);\n  return;\n}",
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072d8",
            "calling": [
                "digitalWrite"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_state_080072d8"
        },
        "FUN_08002b00": {
            "renaming": {
                "TwoWire::FUN_08002b00": "receiveData",
                "inBytes": "receivedBytes",
                "numBytes": "numBytes",
                "PTR_user_onReceive_08002b54": "userOnReceive",
                "byte": "byte",
                "PTR_rxBufferLength_08002b5c": "rxBufferLength",
                "PTR_rxBufferIndex_08002b58": "rxBufferIndex",
                "allocateRxBuffer": "allocateRxBuffer",
                "PTR_rxBuffer_08002b60": "rxBuffer",
                "_Error_Handler": "_Error_Handler",
                "PTR_s__home_bo__arduino15_packages_STM_08002b64": "s__home_bo__arduino15_packages_STM",
                "memcpy": "memcpy",
                "code": "code",
                "FUN_08002b00": "receiveData_08002b00"
            },
            "code": "void receiveData_08002b00(uint8_t *receivedBytes, int numBytes) {\n  if (*(int *)PTR_user_onReceive_08002b54 != 0 && PTR_PTR_rxBuffer_08002b60Length_08002b5c <= PTR_PTR_rxBuffer_08002b60Index_08002b58) {\n    allocateRxBuffer(numBytes);\n    if (*(int *)PTR_rxBuffer_08002b60 == 0) {\n      _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08002b64,0x183);\n    }\n    memcpy(*(void **)PTR_rxBuffer_08002b60,receivedBytes,numBytes);\n    *PTR_PTR_rxBuffer_08002b60Index_08002b58 = 0;\n    *PTR_PTR_rxBuffer_08002b60Length_08002b5c = (char)numBytes;\n    (**(code **)PTR_user_onReceive_08002b54)(numBytes);\n  }\n  return;\n}",
            "called": [
                "memcpy",
                "_Error_Handler",
                "allocateRxBuffer"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002b00",
            "calling": [],
            "imported": false,
            "current_name": "receiveData_08002b00"
        },
        "FUN_08002f84": {
            "renaming": {
                "FUN_08002f84": "setSystemResetCallback_08002f84",
                "command": "command",
                "newFunction": "newFunction",
                "PTR_currentSystemResetCallback_08002f90": "systemResetCallback",
                "uint8_t": "uint8_t",
                "systemCallbackFunction": "systemCallbackFunction",
                "return": "return"
            },
            "code": "void __thiscall setSystemResetCallback_08002f84(FirmataClass *this, uint8_t command, systemCallbackFunction newFunction)\n{\n  if (command == SYSTEM_RESET_COMMAND) {\n    PTR_currentSystemResetCallback_08002f90 = newFunction;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f84",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "setSystemResetCallback_08002f84"
        },
        "FUN_08009094": {
            "renaming": {
                "FUN_08009094": "handle_gpio_interrupt_08009094",
                "GPIO_Pin": "pin_number",
                "bVar1": "pin_id"
            },
            "code": "void handle_gpio_interrupt_08009094(uint16_t pin_number)\n{\n  uint8_t pin_id = get_pin_id(pin_number);\n  if (*(int *)(PTR_gpio_irq_conf_080090b0 + (uint)pin_id * 0x14 + 0xc) != 0) {\n    std::function<void()>::operator__ ((function_void___ *)(PTR_gpio_irq_conf_080090b0 + (uint)pin_id * 0x14 + 4));\n  }\n  return;\n}",
            "called": [
                "get_pin_id",
                "operator()"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009094",
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_gpio_interrupt_08009094"
        },
        "FUN_0800a0cc": {
            "renaming": {
                "FUN_0800a0cc": "close_file_and_return_errno_0800a0cc",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "puVar1": "errno_ptr",
                "iVar2": "close_result"
            },
            "code": "void close_file_and_return_errno_0800a0cc(int *error_code, int file_descriptor) {\n  undefined *errno_ptr = PTR_errno_0800a0e8;\n  *(undefined4 *)PTR_errno_0800a0e8 = 0;\n  int close_result = _close(file_descriptor);\n  if ((close_result == -1) && (*(int *)errno_ptr != 0)) {\n    *error_code = *(int *)errno_ptr;\n  }\n  return;\n}",
            "called": [
                "_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a0cc",
            "calling": [
                "__sclose"
            ],
            "imported": false,
            "current_name": "close_file_and_return_errno_0800a0cc"
        },
        "FUN_08002580": {
            "renaming": {
                "FUN_08002580": "initializeServo_08002580",
                "this": "servoInstance",
                "bVar1": "servoCount"
            },
            "code": "initializeServo_08002580* initializeServo_08002580(initializeServo_08002580* servoInstance) {\n  byte servoCount = *PTR_initializeServo_08002580Count_080025a4;\n  if (servoCount > 11) {\n    servoInstance->servoIndex = 0xff;\n    return servoInstance;\n  }\n  *PTR_initializeServo_08002580Count_080025a4 = servoCount + 1;\n  servoInstance->servoIndex = servoCount;\n  *(undefined4 *)(PTR_servos_080025a8 + (uint)servoCount * 8 + 4) = 0x5dc;\n  return servoInstance;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002580",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initializeServo_08002580"
        },
        "FUN_080073ec": {
            "renaming": {
                "FUN_080073ec": "set_flags_080073ec",
                "puVar1": "flags"
            },
            "code": "void set_flags_080073ec(void)\n{\n  uint *flags = DAT_0800742c;\n  *flags |= 1;\n  flags[1] &= DAT_08007430;\n  *flags &= 0xfef6ffff;\n  *flags &= 0xfffbffff;\n  flags[1] &= 0xff80ffff;\n  flags[2] = 0x9f0000;\n  *(undefined4 *)(DAT_08007434 + 8) = 0x8000000;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073ec",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "set_flags_080073ec"
        },
        "FUN_08008ef4": {
            "renaming": {
                "FUN_08008ef4": "map_08008ef4",
                "x": "value",
                "in_min": "in_min",
                "in_max": "in_max",
                "out_min": "out_min",
                "out_max": "out_max",
                "uint": "long",
                "out_max - out_min": "range_out",
                "x - in_min": "value_shifted",
                "in_max - in_min": "range_in",
                "(out_max - out_min) * (x - in_min)) / (in_max - in_min) + out_min": "mapped_value"
            },
            "code": "long map_08008ef4(long value, long in_min, long in_max, long out_min, long out_max)\n{\n  long range_in = in_max - in_min;\n  long range_out = out_max - out_min;\n  long map_08008ef4ped_value = (range_out * (value - in_min)) / range_in + out_min;\n  return map_08008ef4ped_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ef4",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "map_08008ef4"
        },
        "FUN_08009fe8": {
            "renaming": {
                "FUN_08009fe8": "execute_signal_handler_08009fe8",
                "__sig": "signal_number",
                "iVar1": "return_value",
                "_FUN_08009fe8_r": "execute_signal_handler_recursive"
            },
            "code": "int execute_signal_handler_08009fe8(int signal_number)\n{\n  int return_value;\n  return_value = execute_signal_handler_08009fe8_recursive(*(undefined4 *)PTR__impure_ptr_08009ff4, signal_number);\n  return return_value;\n}",
            "called": [
                "_raise_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009fe8",
            "calling": [
                "abort"
            ],
            "imported": false,
            "current_name": "execute_signal_handler_08009fe8"
        },
        "FUN_08002c1e": {
            "renaming": {
                "FUN_08002c1e": "initialize_static_variables_08002c1e"
            },
            "code": "void initialize_static_variables_08002c1e(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c1e",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_08002c1e"
        },
        "FUN_08002f94": {
            "renaming": {
                "FUN_08002f94": "setSysexCallback_08002f94",
                "command": "command",
                "newFunction": "sysexCallback",
                "PTR_currentSysexCallback_08002f9c": "currentSysexCallback"
            },
            "code": "void __thiscall setSysexCallback_08002f94(FirmataClass *this, uint8_t command, sysexCallbackFunction newFunction) {\n  *(sysexCallbackFunction *)PTR_currentSysexCallback_08002f9c = newFunction;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f94",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "setSysexCallback_08002f94"
        },
        "FUN_08008eec": {
            "renaming": {
                "FUN_08008eec": "print_08008eec",
                "this": "print_obj",
                "b": "character",
                "base": "base",
                "sVar1": "size"
            },
            "code": "size_t __thiscall print_08008eec(Print *print_08008eec_obj, uchar character, int base) {\n  size_t size;\n  size = print_08008eec(print_08008eec_obj, (uint)character, base);\n  return size;\n}",
            "called": [
                "print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008eec",
            "calling": [
                "printTo"
            ],
            "imported": false,
            "current_name": "print_08008eec"
        },
        "FUN_08001b48": {
            "renaming": {
                "FUN_08001b48": "initializeFirmata_08001b48",
                "this": "firmata"
            },
            "code": "void initializeFirmata_08001b48(void)\n{\n  FirmataClass* firmata = (FirmataClass*) PTR_Firmata_08001bc0;\n  firmata->setFirmwareNameAndVersion(PTR_Firmata_08001bc0, PTR_s__home_bo_p2im_p2im_real_firmware_08001bc4, 2, 5);\n  firmata->attach(firmata, 0xe0, DAT_08001bc8);\n  firmata->attach(firmata, 0x90, DAT_08001bcc);\n  firmata->attach(firmata, 0xc0, DAT_08001bd0);\n  firmata->attach(firmata, 0xd0, DAT_08001bd4);\n  firmata->attach(firmata, 0xf4, DAT_08001bd8);\n  firmata->attach(firmata, 0xf5, DAT_08001bdc);\n  firmata->attach(firmata, 0xf0, DAT_08001be0);\n  firmata->attach(firmata, 0xff, DAT_08001be4);\n  firmata->begin(0xe100);\n  systemResetCallback();\n  startForkserver(0);\n  return;\n}",
            "called": [
                "attach",
                "begin",
                "setFirmwareNameAndVersion",
                "systemResetCallback",
                "attach",
                "attach",
                "startForkserver"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001b48",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initializeFirmata_08001b48"
        },
        "FUN_08005df4": {
            "renaming": {
                "FUN_08005df4": "reset_timer_08005df4",
                "htim": "timer",
                "TIM_HandleTypeDef_conflict": "TIM_HandleTypeDef",
                "TIM_TypeDef_conflict": "TIM_TypeDef"
            },
            "code": "HAL_StatusTypeDef reset_timer_08005df4(TIM_HandleTypeDef *timer)\n{\n  TIM_TypeDef *timer_instance;\n  timer->State = HAL_TIM_STATE_BUSY;\n  timer_instance = timer->Instance;\n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->CR1 = timer_instance->CR1 & 0xfffffffe;\n  }\n  HAL_TIM_OC_MspDeInit(timer);\n  timer->State = HAL_TIM_STATE_RESET;\n  timer->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}",
            "called": [
                "HAL_TIM_OC_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005df4",
            "calling": [
                "TimerPulseDeinit"
            ],
            "imported": false,
            "current_name": "reset_timer_08005df4"
        },
        "FUN_08009148": {
            "renaming": {
                "FUN_08009148": "execute_global_constructors_08009148",
                "puVar1": "constructor_array_start",
                "iVar2": "constructor_array_size",
                "iVar3": "i",
                "_init": "_init",
                "PTR___preinit_array_end_08009188": "destructor_array_start",
                "PTR___do_global_dtors_aux_fini_array_entry_0800918c": "destructor_array_end"
            },
            "code": "void execute_global_constructors_08009148(void)\n{\n    void **constructor_array_start = PTR___preinit_array_end_08009180;\n    int constructor_array_size = (int)PTR___preinit_array_end_08009184 - (int)PTR___preinit_array_end_08009180;\n    for (int i = 0; i < constructor_array_size >> 2; i++) {\n        (**(void (**)(void))(constructor_array_start + i * 4))();\n    }\n    _init();\n    void **PTR___preinit_array_end_08009188 = PTR___preinit_array_end_08009188;\n    int destructor_array_size = (int)PTR___do_global_dtors_aux_fini_array_entry_0800918c - (int)PTR___preinit_array_end_08009188;\n    for (int i = 0; i < destructor_array_size >> 2; i++) {\n        (**(void (**)(void))(PTR___preinit_array_end_08009188 + i * 4))();\n    }\n    return;\n}",
            "called": [
                "_init",
                "premain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009148",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "execute_global_constructors_08009148"
        },
        "FUN_080099dc": {
            "renaming": {
                "FUN_080099dc": "send_char_080099dc",
                "param_1": "fd",
                "param_2": "c",
                "param_3": "stream",
                "param_4": "flags",
                "iVar1": "status",
                "uVar2": "num_chars",
                "puVar3": "buf_ptr"
            },
            "code": "uint send_char_080099dc(int fd, uint c, int *stream, undefined4 flags)\n{\n  int status;\n  uint num_chars;\n  undefined *buf_ptr;\n  if ((fd != 0) && (*(int *)(fd + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == (int *)PTR___sf_fake_stdin_08009a74) {\n    stream = *(int **)(fd + 4);\n  }\n  else if (stream == (int *)PTR___sf_fake_stdout_08009a78) {\n    stream = *(int **)(fd + 8);\n  }\n  else if (stream == (int *)PTR___sf_fake_stderr_08009a7c) {\n    stream = *(int **)(fd + 0xc);\n  }\n  stream[2] = stream[6];\n  num_chars = (uint)*(ushort *)(stream + 3);\n  status = num_chars << 0x1c;\n  if (((status < 0) && (num_chars = stream[4], num_chars != 0)) ||\n     (status = __swsetup_r(fd, stream, status, num_chars, flags), status == 0)) {\n    c = c & 0xff;\n    status = *stream - stream[4];\n    if ((status < stream[5]) || (status = _fflush_r(fd, stream), status == 0)) {\n      stream[2] = stream[2] + -1;\n      buf_ptr = (undefined *)*stream;\n      *stream = (int)(buf_ptr + 1);\n      *buf_ptr = (char)c;\n      if (status + 1 != stream[5]) {\n        if (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1f)) {\n          return c;\n        }\n        if (c != 10) {\n          return c;\n        }\n      }\n      status = _fflush_r(fd, stream);\n      if (status == 0) {\n        return c;\n      }\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "__sinit",
                "__swsetup_r",
                "_fflush_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080099dc",
            "calling": [
                "__sfputc_r"
            ],
            "imported": false,
            "current_name": "send_char_080099dc"
        },
        "FUN_08000c18": {
            "renaming": {
                "FUN_08000c18": "FUNC_08000c18"
            },
            "code": "\nvoid FUNC_08000c18(byte port,int value)\n\n{\n  byte bVar1;\n  bool bVar2;\n  uint32_t uVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  byte portValue;\n  \n  uVar6 = (uint)port;\n  if ((uVar6 < 5) && (PTR_reportPINs_08000ebc[uVar6] = (char)value, value != 0)) {\n    bVar1 = PTR_portConfigInputs_08000ec0[uVar6];\n    uVar6 = (uVar6 & 0x1f) * 8;\n    if (uVar6 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar6] == NC) {\n        portValue = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n        if (uVar3 == 0) {\n          portValue = 0;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n          if (uVar3 == 1) {\n            portValue = 0;\n          }\n          else if ((bVar1 & 1) == 0) {\n            portValue = 0;\n          }\n          else {\n            iVar4 = digitalRead(uVar6);\n            if (iVar4 == 0) {\n              portValue = 0;\n            }\n            else {\n              portValue = 1;\n            }\n          }\n        }\n      }\n    }\n    else {\n      portValue = 0;\n    }\n    uVar5 = uVar6 + 1;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 2) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 2;\n    }\n    uVar5 = uVar6 + 2;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 4) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 4;\n    }\n    uVar5 = uVar6 + 3;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 8) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 8;\n    }\n    uVar5 = uVar6 + 4;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x10) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x10;\n    }\n    uVar5 = uVar6 + 5;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x20) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x20;\n    }\n    uVar5 = uVar6 + 6;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x40) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x40;\n    }\n    uVar6 = uVar6 + 7;\n    if (uVar6 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar6] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x80) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar6);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x80;\n    }\n    outputPort(port,portValue,'\\x01');\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "pinNametoDigitalPin",
                "outputPort",
                "digitalRead"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08000c18",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_08000c18"
        },
        "FUN_08009024": {
            "renaming": {
                "FUN_08009024": "handle_gpio_exti_interrupt_08009024",
                "PTR_": "",
                "DAT_": "",
                "HAL_GPIO_EXTI_IRQHandler": "HAL_GPIO_EXTI_IRQHandler",
                "1": "GPIO_PIN_1"
            },
            "code": "DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_ handle_gpio_exti_interrupt_08009024(DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_{DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_HDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_LDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_GDAT_PDAT_TDAT_RDAT__DAT_PDAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT_ODAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_EDAT_PDAT_TDAT_RDAT__DAT_XDAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_QDAT_PDAT_TDAT_RDAT__DAT_HDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_GDAT_PDAT_TDAT_RDAT__DAT_PDAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT_ODAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_PDAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT_NDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_1DAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_}DAT_PDAT_TDAT_RDAT__DAT_",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009024",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_exti_interrupt_08009024"
        },
        "FUN_080064cc": {
            "renaming": {
                "FUN_080064cc": "send_data_080064cc",
                "huart": "uart",
                "uVar1": "count",
                "pbVar2": "data"
            },
            "code": "HAL_StatusTypeDef send_data_080064cc(UART_HandleTypeDef *uart)\n{\n  uint16_t count;\n  uint8_t *data;\n  if (uart->gState != HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  if ((uart->Init).WordLength == UART_WORDLENGTH_9B) {\n    data = (uint8_t*)uart->pTxBuffPtr;\n    uart->pTxBuffPtr += 2;\n    uart->Instance->DR = (*data & 0x1FF);\n  }\n  else {\n    data = (uint8_t*)uart->pTxBuffPtr;\n    uart->pTxBuffPtr++;\n    uart->Instance->DR = (*data);\n  }\n  count = uart->TxXferCount - 1;\n  uart->TxXferCount = count;\n  if (count == 0) {\n    uart->Instance->CR1 &= ~USART_CR1_TXEIE;\n    uart->Instance->CR1 |= USART_CR1_TCIE;\n    return HAL_OK;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064cc",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "send_data_080064cc"
        },
        "FUN_08008058": {
            "renaming": {
                "FUN_08008058": "handle_i2c_event_interrupt_08008058",
                "PTR_i2c_handles_08008064": "i2c_handles_ptr"
            },
            "code": "void handle_i2c_event_interrupt_08008058(I2C_HandleTypeDef_conflict **PTR_i2c_handles_08008064) {\n  HAL_I2C_EV_IRQHandler(*PTR_i2c_handles_08008064);\n  return;\n}",
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008058",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_event_interrupt_08008058"
        },
        "FUN_08004ac2": {
            "renaming": {
                "FUN_08004ac2": "handle_i2c_address_match_08004ac2",
                "hi2c": "i2c_handle",
                "AddrMatchCode": "address_match_code",
                "hi2c->Instance->SR2": "i2c_handle->Instance->SR2",
                "hi2c->Init": "i2c_handle->Init",
                "(hi2c->Instance->SR2 & 0x80) == 0": "(i2c_handle->Instance->SR2 & 0x80) == 0",
                "*(uint16_t *)&(hi2c->Init).OwnAddress1": "*(uint16_t *)&(i2c_handle->Init).OwnAddress1",
                "*(uint16_t *)&(hi2c->Init).OwnAddress2": "*(uint16_t *)&(i2c_handle->Init).OwnAddress2",
                "HAL_I2C_AddrCallback": "HAL_I2C_AddrCallback",
                "(hi2c->Instance->SR2 & 4) == 0": "(i2c_handle->Instance->SR2 & 4) == 0",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef handle_i2c_address_match_08004ac2(I2C_HandleTypeDef *i2c_handle)\n{\n  uint16_t address_match_code;\n  if ((i2c_handle->Instance->SR2 & 0x80) == 0) {\n    address_match_code = *(uint16_t *)&(i2c_handle->Init).OwnAddress1;\n  }\n  else {\n    address_match_code = *(uint16_t *)&(i2c_handle->Init).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(i2c_handle, (i2c_handle->Instance->SR2 & 4) == 0, address_match_code);\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ac2",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_i2c_address_match_08004ac2"
        },
        "FUN_08006ca8": {
            "renaming": {
                "FUN_08006ca8": "init_ADC_GPIO_pin_08006ca8",
                "hadc": "adc_handle",
                "GPIOx": "GPIOx",
                "tmpreg": "tmp_reg",
                "tmpreg_1": "tmp_reg_1",
                "GPIO_InitStruct": "GPIO_init_struct",
                "DAT_08006d14": "ADC1",
                "DAT_08006d18": "ADC2",
                "puVar1": "current_pin"
            },
            "code": "void init_ADC_GPIO_pin_08006ca8(ADC_HandleTypeDef *adc_handle)\n{\n  uint32_t tmp_reg;\n  GPIO_InitTypeDef GPIO_init_struct;\n  if (adc_handle->Instance == DAT_08006d14) {\n    *(uint *)(g_current_pin + 0x18) = *(uint *)(g_current_pin + 0x18) | 0x200;\n  }\n  else if (adc_handle->Instance == DAT_08006d18) {\n    *(uint *)(g_current_pin + 0x18) = *(uint *)(g_current_pin + 0x18) | 0x400;\n  }\n  uint8_t* current_pin = g_current_pin;\n  GPIO_TypeDef *GPIOx = set_GPIO_Port_Clock((uint)((int)(char)*current_pin << 0x18) >> 0x1c);\n  GPIO_init_struct.Pin = 1 << (*current_pin & 0xf) & 0xffff;\n  GPIO_init_struct.Mode = GPIO_MODE_ANALOG;\n  GPIO_init_struct.Pull = GPIO_NOPULL;\n  HAL_GPIO_Init(GPIOx,&GPIO_init_struct);\n  return;\n}",
            "called": [
                "set_GPIO_Port_Clock",
                "HAL_GPIO_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006ca8",
            "calling": [
                "HAL_ADC_Init"
            ],
            "imported": false,
            "current_name": "init_ADC_GPIO_pin_08006ca8"
        },
        "FUN_0800937c": {
            "renaming": {
                "FUN_0800937c": "FUNC_0800937c"
            },
            "code": "\nint FUNC_0800937c(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  bool bVar1;\n  undefined *puVar2;\n  int iVar3;\n  void *pvVar4;\n  int *piVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  int unaff_r9;\n  int iVar8;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 local_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  local_8c = param_4;\n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_2 == PTR___sf_fake_stdin_08009588) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR___sf_fake_stdout_08009590) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR___sf_fake_stderr_08009594) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar8 = __swsetup_r(param_1,param_2), iVar8 != 0)) {\n    return -1;\n  }\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar6 = param_3;\nLAB_080093be:\n  pbVar7 = pbVar6;\n  if (*pbVar7 != 0) goto LAB_08009474;\n  goto LAB_080093c8;\nLAB_08009474:\n  pbVar6 = pbVar7 + 1;\n  if (*pbVar7 != 0x25) goto LAB_080093be;\nLAB_080093c8:\n  iVar8 = (int)pbVar7 - (int)param_3;\n  if (iVar8 != 0) {\n    iVar3 = __sfputs_r(param_1,param_2,param_3,iVar8);\n    if (iVar3 == -1) {\nLAB_08009568:\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar8;\n  }\n  if (*pbVar7 == 0) goto LAB_08009568;\n  local_88 = 0;\n  local_7c = 0;\n  local_84 = -1;\n  local_80 = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar6 = pbVar7 + 1;\n  while( true ) {\n    pvVar4 = memchr(PTR_s___0__0800958c,(uint)*pbVar6,5);\n    puVar2 = PTR_DAT_08009598;\n    param_3 = pbVar6 + 1;\n    if (pvVar4 == (void *)0x0) break;\n    local_88 = 1 << ((int)pvVar4 - (int)PTR_s___0__0800958c & 0xffU) | local_88;\n    pbVar6 = param_3;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar6 == 0x2a) {\n    piVar5 = local_8c + 1;\n    iVar8 = *local_8c;\n    local_8c = piVar5;\n    if (-1 < iVar8) goto LAB_08009498;\n    local_7c = -iVar8;\n    local_88 = local_88 | 2;\n  }\n  else {\n    bVar1 = false;\n    iVar8 = local_7c;\n    param_3 = pbVar6;\n    while( true ) {\n      if (9 < *param_3 - 0x30) break;\n      iVar8 = iVar8 * 10 + (*param_3 - 0x30);\n      bVar1 = true;\n      param_3 = param_3 + 1;\n    }\n    if (bVar1) {\nLAB_08009498:\n      local_7c = iVar8;\n    }\n  }\n  if (*param_3 == 0x2e) {\n    if (param_3[1] == 0x2a) {\n      param_3 = param_3 + 2;\n      piVar5 = local_8c + 1;\n      local_84 = *local_8c;\n      local_8c = piVar5;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n    }\n    else {\n      bVar1 = false;\n      iVar8 = 0;\n      local_84 = 0;\n      while( true ) {\n        param_3 = param_3 + 1;\n        if (9 < *param_3 - 0x30) break;\n        iVar8 = iVar8 * 10 + (*param_3 - 0x30);\n        bVar1 = true;\n      }\n      if (bVar1) {\n        local_84 = iVar8;\n      }\n    }\n  }\n  pvVar4 = memchr(PTR_DAT_08009598,(uint)*param_3,3);\n  if (pvVar4 != (void *)0x0) {\n    param_3 = param_3 + 1;\n    local_88 = local_88 | 0x40 << ((int)pvVar4 - (int)puVar2 & 0xffU);\n  }\n  local_70 = *param_3;\n  param_3 = param_3 + 1;\n  pvVar4 = memchr(PTR_s_efgEFG_0800959c,(uint)local_70,6);\n  if (pvVar4 == (void *)0x0) {\n    iVar8 = _printf_i(param_1,&local_88,param_2,DAT_080095a4,&local_8c);\n  }\n  else {\n    iVar8 = param_1;\n    if (DAT_080095a0 == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar8 = unaff_r9;\n      goto LAB_0800951a;\n    }\n  }\n  if (iVar8 == -1) goto LAB_08009568;\nLAB_0800951a:\n  local_74 = local_74 + iVar8;\n  pbVar6 = param_3;\n  unaff_r9 = iVar8;\n  goto LAB_080093be;\n}\n\n",
            "called": [
                "__sinit",
                "memchr",
                "__swsetup_r",
                "_printf_i",
                "__sfputs_r"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0800937c",
            "calling": [
                "iprintf",
                "fiprintf"
            ],
            "imported": false,
            "current_name": "FUNC_0800937c"
        },
        "FUN_08000214": {
            "renaming": {
                "FUN_08000214": "set_pin_state_08000214",
                "pin": "pin_number",
                "value": "pin_value",
                "bVar1": "is_pin_in_servo_map",
                "bVar2": "pin_mode",
                "_Var3": "is_pin_in_pwm_map",
                "ulPin": "pin_number",
                "uVar4": "digital_pin_number"
            },
            "code": "void set_pin_state_08000214(byte pin, int value)\n{\n  bool is_pin_in_pwm_map;\n  byte pin_mode;\n  uint pin_number;\n  uint32_t digital_pin_number;\n  \n  pin_number = (uint)pin;\n  if (pin_number > 59) {\n    return;\n  }\n  pin_mode = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_080002d8, pin);\n  if (pin_mode == PIN_MODE_ANALOG_OUTPUT) {\n    if (pin_number < 60) {\n      if (PTR_digitalPin_080002dc[pin_number] == NC) {\n        is_pin_in_pwm_map = false;\n      }\n      else {\n        digital_pin_number = pinNametoDigitalPin(PTR_digitalPin_080002dc[pin_number]);\n        if (digital_pin_number == 0 || digital_pin_number == 1) {\n          is_pin_in_pwm_map = false;\n        }\n        else {\n          is_pin_in_pwm_map = pin_in_pinmap(PTR_digitalPin_080002dc[pin_number], (PinMap_conflict *)PTR_PinMap_PWM_080002e8);\n        }\n      }\n    }\n    else {\n      is_pin_in_pwm_map = false;\n    }\n    if (is_pin_in_pwm_map) {\n      analogWrite(pin_number, value);\n    }\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_080002d8, pin, value);\n  }\n  else if (pin_mode == PIN_MODE_SERVO) {\n    if (pin_number < 60) {\n      if (PTR_digitalPin_080002dc[pin_number] == NC) {\n        is_pin_in_pwm_map = false;\n      }\n      else {\n        digital_pin_number = pinNametoDigitalPin(PTR_digitalPin_080002dc[pin_number]);\n        if (digital_pin_number == 0 || digital_pin_number == 1) {\n          is_pin_in_pwm_map = false;\n        }\n        else {\n          is_pin_in_pwm_map = true;\n        }\n      }\n    }\n    else {\n      is_pin_in_pwm_map = false;\n    }\n    if (is_pin_in_pwm_map) {\n      Servo::write((Servo *)(PTR_servos_080002e4 + (uint)PTR_servoPinMap_080002e0[pin_number] * 3), value);\n    }\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_080002d8, pin, value);\n    return;\n  }\n  return;\n}",
            "called": [
                "pinNametoDigitalPin",
                "analogWrite",
                "getPinMode",
                "write",
                "setPinState",
                "pin_in_pinmap"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000214",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "set_pin_state_08000214"
        },
        "FUN_08003724": {
            "renaming": {
                "FUN_08003724": "initializeHardware_08003724",
                "FUN_08003724Tick": "initializeTimer",
                "DAT_08003744": "data_register_1"
            },
            "code": "HAL_StatusTypeDef_conflict initializeHardware_08003724(void)\n{\n  *DAT_08003744 |= 0x10;\n  HAL_NVIC_SetPriorityGrouping(3);\n  initializeTimer(0xf);\n  HAL_MspInit();\n  return HAL_OK;\n}",
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003724",
            "calling": [
                "hw_config_init"
            ],
            "imported": false,
            "current_name": "initializeHardware_08003724"
        },
        "FUN_08005bb8": {
            "renaming": {
                "FUN_08005bb8": "getPeriphClockFrequency_08005bb8",
                "PeriphClk": "periphClock",
                "uVar1": "frequency",
                "uVar2": "uVar2",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllMulFactorTable"
            },
            "code": "uint32_t getPeriphClockFrequency_08005bb8(uint32_t periphClock)\n{\n  uint32_t frequency = 0;\n  uint8_t predivFactorTable[2];\n  uint8_t pllMulFactorTable[16];\n  pllMulFactorTable[0] = *(uint32_t *)(PTR_DAT_08005ca0);\n  pllMulFactorTable[1] = *(uint32_t *)(PTR_DAT_08005ca0 + 4);\n  pllMulFactorTable[2] = *(uint32_t *)(PTR_DAT_08005ca0 + 8);\n  predivFactorTable[0] = *(uint8_t *)(PTR_DAT_08005ca0 + 0x10);\n  predivFactorTable[1] = *(uint8_t *)(PTR_DAT_08005ca0 + 0x11);\n  if (periphClock == 2) {\n    uint32_t pclk2Frequency = HAL_RCC_GetPCLK2Freq();\n    frequency = pclk2Frequency / ((((DAT_08005ca4[1] << 0x10) >> 0x1e) + 1) * 2);\n  }\n  else if (periphClock == 0x10) {\n    if ((*DAT_08005ca4 & 0x1000000) == 0) {\n      frequency = 0;\n    }\n    else {\n      uint32_t mulFactor = pllMulFactorTable[(DAT_08005ca4[1] << 10) >> 0x1c];\n      uint32_t divFactor = predivFactorTable[-((int)(DAT_08005ca4[1] << 0xe) >> 0x1f)];\n      uint32_t pllmul = DAT_08005ca8 / divFactor;\n      frequency = pllmul * mulFactor;\n      if ((DAT_08005ca4[1] & 0x400000) == 0) {\n        frequency = (uint32_t)((uint64_t)DAT_08005cac * (uint64_t)(frequency * 2) >> 0x21);\n      }\n    }\n  }\n  else if (periphClock == 1) {\n    if ((DAT_08005ca4[8] & 0x302) == 0x102) {\n      frequency = 0x8000;\n    }\n    else {\n      uint32_t uVar2 = DAT_08005ca4[8] & 0x300;\n      if ((uVar2 == 0x200) && ((DAT_08005ca4[9] & 2) != 0)) {\n        frequency = 32000;\n      }\n      else if (uVar2 == 0x300) {\n        if ((*DAT_08005ca4 & 0x20000) == 0) {\n          frequency = 0;\n        }\n        else {\n          frequency = 0xf424;\n        }\n      }\n    }\n  }\n  return frequency;\n}",
            "called": [
                "HAL_RCC_GetPCLK2Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005bb8",
            "calling": [
                "HAL_ADC_PollForConversion",
                "HAL_ADCEx_Calibration_Start"
            ],
            "imported": false,
            "current_name": "getPeriphClockFrequency_08005bb8"
        },
        "FUN_08002f0a": {
            "renaming": {
                "FUN_08002f0a": "sendCommand_08002f0a",
                "bytec": "numBytes",
                "bytev": "byteArray"
            },
            "code": "void __thiscall sendCommand_08002f0a(FirmataClass *this, byte command, byte numBytes, byte *byteArray) {\n  FirmataMarshaller::sendCommand_08002f0a(&this->marshaller, command, (uint)numBytes, byteArray);\n  return;\n}",
            "called": [
                "sendSysex"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f0a",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "sendCommand_08002f0a"
        },
        "FUN_08002634": {
            "renaming": {
                "FUN_08002634": "setPin_08002634",
                "this": "servo",
                "pin": "pin",
                "uVar1": "result"
            },
            "code": "uint8_t __thiscall setPin_08002634(int pin)\n{\n  uint8_t result = setPin_08002634(this, pin, 0x220, 0x960);\n  return result;\n}",
            "called": [
                "attach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002634",
            "calling": [
                "attachServo"
            ],
            "imported": false,
            "current_name": "setPin_08002634"
        },
        "FUN_080063c0": {
            "renaming": {
                "FUN_080063c0": "disableTimerChannel_080063c0",
                "htim": "timerHandle",
                "Channel": "channel",
                "pTVar1": "timerInstance",
                "DAT_0800641c": "instancePointer"
            },
            "code": "HAL_StatusTypeDef_conflict disableTimerChannel_080063c0(TIM_HandleTypeDef_conflict *timerHandle,uint32_t channel)\n{\n  TIM_TypeDef_conflict *timerInstance;\n  \n  TIM_CCxChannelCmd(timerHandle->Instance,channel,0);\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance == DAT_0800641c) && ((timerInstance->CCER & 0x1111) == 0)) && ((timerInstance->CCER & 0x444) == 0))\n  {\n    timerInstance->BDTR = timerInstance->BDTR & 0xffff7fff;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  timerHandle->State = HAL_TIM_STATE_READY;\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080063c0",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "disableTimerChannel_080063c0"
        },
        "FUN_0800274c": {
            "renaming": {
                "FUN_0800274c": "getNextByteFromRxBuffer_0800274c",
                "this": "wire",
                "PTR_rxBufferIndex_08002768": "wire->rxBufferIndex",
                "PTR_rxBufferLength_0800276c": "wire->rxBufferLength",
                "PTR_rxBuffer_08002770": "wire->rxBuffer"
            },
            "code": "int getNextByteFromRxBuffer_0800274c(TwoWire *wire) {\n  int bufferIndex = *(PTR_rxBufferIndex_08002768);\n  int bufferLength = *(PTR_rxBufferLength_0800276c);\n  if (bufferIndex < bufferLength) {\n    int nextByte = *(PTR_rxBuffer_08002770 + bufferIndex);\n    *(PTR_rxBufferIndex_08002768) = bufferIndex + 1;\n    return nextByte;\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800274c",
            "calling": [],
            "imported": false,
            "current_name": "getNextByteFromRxBuffer_0800274c"
        },
        "FUN_080098d8": {
            "renaming": {
                "FUN_080098d8": "format_string_080098d8",
                "__format": "format",
                "PTR__impure_ptr_08009904": "impure_ptr",
                "pcVar2": "arg_list",
                "in_r1": "arg1",
                "in_r2": "arg2",
                "in_r3": "arg3",
                "uStack_c": "arg1",
                "uStack_8": "arg2",
                "uStack_4": "arg3",
                "iVar1": "result"
            },
            "code": "int format_string_080098d8(char *format, ...)\n{\n  int PTR__impure_ptr_08009904 = *(int *)PTR__PTR__impure_ptr_08009904_08009904;\n  char *arg_list = format;\n  undefined4 arg1 = 0;\n  undefined4 arg2 = 0;\n  undefined4 arg3 = 0;\n  if ((PTR__impure_ptr_08009904 != 0) && (*(int *)(PTR__impure_ptr_08009904 + 0x18) == 0)) {\n    __sinit(PTR__impure_ptr_08009904);\n  }\n  int result = _vfformat_string_080098d8_r(PTR__impure_ptr_08009904,*(undefined4 *)(PTR__impure_ptr_08009904 + 8),format,&arg1,arg_list,&arg2);\n  return result;\n}",
            "called": [
                "__sinit",
                "_vfiprintf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080098d8",
            "calling": [
                "getTimerIrq",
                "i2c_custom_init",
                "getTimerClkFreq",
                "uart_init",
                "getTimerClkSrc"
            ],
            "imported": false,
            "current_name": "format_string_080098d8"
        },
        "FUN_08009270": {
            "renaming": {
                "FUN_08009270": "allocate_memory_block_08009270",
                "param_1": "allocation_result",
                "param_2": "block_size",
                "puVar1": "current_sbrk_start",
                "uVar2": "sbrk_result",
                "puVar3": "current_free_list",
                "iVar4": "sbrk_error",
                "puVar5": "previous_free_list",
                "uVar6": "remaining_block_size",
                "puVar7": "last_fitting_block"
            },
            "code": "uint allocate_memory_block_08009270(undefined4 *allocation_result, uint block_size)\n{\n  uint adjusted_block_size = (block_size + 3 & 0xfffffffc) + 8;\n  if (adjusted_block_size < 0xc) {\n    adjusted_block_size = 0xc;\n  }\n  if (((int)adjusted_block_size < 0) || (adjusted_block_size < block_size)) {\n    *allocation_result = 0xc;\n  }\n  else {\n    __malloc_lock();\n    void* current_sbrk_start = PTR___malloc_sbrk_start_08009328;\n    uint* current_free_list = *(uint **)PTR___malloc_free_list_08009324;\n    uint* previous_free_list = *(uint **)PTR___malloc_free_list_08009324;\n    while (current_free_list != (uint *)0x0) {\n      uint remaining_block_size = *current_free_list - adjusted_block_size;\n      if (-1 < (int)remaining_block_size) {\n        if (remaining_block_size < 0xc) {\n          if (previous_free_list == current_free_list) {\n            adjusted_block_size = previous_free_list[1];\n            *(uint *)PTR___malloc_free_list_08009324 = adjusted_block_size;\n          }\n          else {\n            adjusted_block_size = current_free_list[1];\n          }\n          if (previous_free_list != current_free_list) {\n            previous_free_list[1] = adjusted_block_size;\n            previous_free_list = current_free_list;\n          }\n        }\n        else {\n          *current_free_list = remaining_block_size;\n          *(uint *)((int)current_free_list + remaining_block_size) = adjusted_block_size;\n          previous_free_list = (uint *)((int)current_free_list + remaining_block_size);\n        }\n        goto END_ALLOC;\n      }\n      previous_free_list = current_free_list;\n      current_free_list = (uint *)current_free_list[1];\n    }\n    if (*(int *)PTR___malloc_sbrk_start_08009328 == 0) {\n      uVar2 = _sbrk_r(allocation_result);\n      *(undefined4 *)current_sbrk_start = uVar2;\n    }\n    current_free_list = (uint *)_sbrk_r(allocation_result,adjusted_block_size);\n    if ((current_free_list != (uint *)0xffffffff) &&\n       ((previous_free_list = (uint *)((int)current_free_list + 3U & 0xfffffffc), current_free_list == previous_free_list ||\n        (iVar4 = _sbrk_r(allocation_result,(int)previous_free_list - (int)current_free_list), iVar4 != -1)))) {\n      *previous_free_list = adjusted_block_size;\nEND_ALLOC:\n      __malloc_unlock(allocation_result);\n      adjusted_block_size = (int)previous_free_list + 0xbU & 0xfffffff8;\n      int padding_size = adjusted_block_size - (int)(previous_free_list + 1);\n      if (padding_size != 0) {\n        *(int *)((int)previous_free_list + padding_size) = -padding_size;\n        return adjusted_block_size;\n      }\n      return adjusted_block_size;\n    }\n    *allocation_result = 0xc;\n    __malloc_unlock(allocation_result);\n  }\n  return 0;\n}",
            "called": [
                "__malloc_unlock",
                "_sbrk_r",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009270",
            "calling": [
                "__smakebuf_r",
                "malloc",
                "__sfmoreglue",
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_08009270"
        },
        "FUN_08009038": {
            "renaming": {
                "FUN_08009038": "handle_external_interrupt_08009038"
            },
            "code": "void handle_external_interrupt_08009038(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(gpio_pin_num);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009038",
            "calling": [],
            "imported": false,
            "current_name": "handle_external_interrupt_08009038"
        },
        "FUN_08005aa4": {
            "renaming": {
                "FUN_08005aa4": "configurePeriphClocks_08005aa4",
                "PeriphClkInit": "periphClkInit",
                "iVar1": "regBackup",
                "puVar2": "rtcClockAlreadyEnabled",
                "uVar3": "startTick",
                "uVar4": "currentTick",
                "uVar5": "rtcClockSource",
                "bVar6": "enableRtcClock",
                "tmpreg": "tempRegister",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "RCC_PeriphCLKInitTypeDef_conflict": "RCC_PeriphCLKInitTypeDef",
                "DAT_08005bac": "RCC_BDCR",
                "DAT_08005bb0": "PWR_CR",
                "DAT_08005bb4": "RTC_ISR",
                "PeriphClockSelection": "PeriphClockSelection",
                "RTCClockSelection": "RTCClockSelection",
                "ADCclockSelection": "AdcClockSelection",
                "USBclockSelection": "UsbClockSelection"
            },
            "code": "HAL_StatusTypeDef configurePeriphClocks_08005aa4(RCC_PeriphCLKInitTypeDef* periphClkInit)\n{\n  bool enableRtcClock = (periphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) != 0;\n  if (enableRtcClock) {\n    bool rtcClockAlreadyEnabled = (*DAT_08005bac & DAT_08005bac_RTCEN) != 0;\n    if (!rtcClockAlreadyEnabled) {\n      *DAT_08005bac |= DAT_08005bac_RTCEN;\n      uint32_t startTick = HAL_GetTick();\n      while (!rtcClockAlreadyEnabled) {\n        uint32_t currentTick = HAL_GetTick();\n        if (currentTick - startTick > 100) {\n          return HAL_TIMEOUT;\n        }\n        rtcClockAlreadyEnabled = (*DAT_08005bac & DAT_08005bac_RTCEN) != 0;\n      }\n    }\n    uint32_t rtcClockSource = (*DAT_08005bac & DAT_08005bac_RTCSEL) & DAT_08005bac_RTCSEL;\n    uint32_t requestedRtcClockSource = periphClkInit->RTCClockSelection & RCC_RTCCLKSOURCE_HSE_DIV32;\n    if (rtcClockSource != requestedRtcClockSource) {\n      uint32_t regBackup = *DAT_08005bac & ~DAT_08005bac_RTCSEL;\n      *DAT_08005bac = regBackup | requestedRtcClockSource;\n      if (requestedRtcClockSource == RCC_RTCCLKSOURCE_HSE_DIV32) {\n        uint32_t startTick = HAL_GetTick();\n        while ((*DAT_08005bac & DAT_08005bac_RTCSEL) != DAT_08005bac_RTCSEL_0) {\n          uint32_t currentTick = HAL_GetTick();\n          if (currentTick - startTick > 5000) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    if (!rtcClockAlreadyEnabled) {\n      *DAT_08005bac &= ~DAT_08005bac_RTCEN;\n    }\n  }\n  if ((periphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) != 0) {\n    *RCC_CFGR &= RCC_CFGR_ADCPRE;\n    *RCC_CFGR |= periphClkInit->AdcClockSelection;\n  }\n  if ((periphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USB) != 0) {\n    *RCC_CFGR &= RCC_CFGR_USBPRE;\n    *RCC_CFGR |= periphClkInit->UsbClockSelection;\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005aa4",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configurePeriphClocks_08005aa4"
        },
        "FUN_08008068": {
            "renaming": {
                "FUN_08008068": "handle_i2c_error_interrupt_08008068",
                "PTR_i2c_handles_08008074": "i2c_handles_ptr"
            },
            "code": "void handle_i2c_error_interrupt_08008068(I2C_HandleTypeDef_conflict **PTR_i2c_handles_08008074)\n{\n  HAL_I2C_ER_IRQHandler(*PTR_i2c_handles_08008074);\n  return;\n}",
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008068",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_error_interrupt_08008068"
        },
        "FUN_08002400": {
            "renaming": {
                "FUN_08002400": "has_timer_sequence_reached_end_08002400",
                "timer": "timer_sequence",
                "uVar1": "index"
            },
            "code": "bool has_timer_sequence_reached_end_08002400(timer16_Sequence_t timer) {\n  uint8_t index = 0;\n  while (true) {\n    if (index > 11) {\n      return false;\n    }\n    if ((PTR_servos_08002428[((uint)timer * 0xc + index) * 8] & 0x40) != 0) {\n      break;\n    }\n    index = (index + 1) % 256;\n  }\n  return true;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002400",
            "calling": [
                "detach",
                "attach"
            ],
            "imported": false,
            "current_name": "has_timer_sequence_reached_end_08002400"
        },
        "FUN_08000588": {
            "renaming": {
                "FUN_08000588": "detachServo_08000588",
                "pin": "pin",
                "puVar3": "servoPinMapPtr",
                "PTR_servoPinMap_080005cc": "PTR_servoPinMap_080005cc",
                "Servo::detach": "Servo::detach",
                "PTR_servos_080005d0": "PTR_servos_080005d0",
                "PTR_servoCount_080005d4": "PTR_servoCount_080005d4",
                "cVar1": "servoCount",
                "cVar2": "servoIndex",
                "PTR_detachedServoCount_080005d8": "PTR_detachedServoCount_080005d8",
                "detachedServoCount": "detachedServoCount",
                "PTR_detachedServos_080005dc": "PTR_detachedServos_080005dc"
            },
            "code": "void detachServo_08000588(byte pin)\\n{\\n  char servoIndex;\\n  char servoCount;\\n  undefined *servoPinMapPtr;\\n  servoPinMapPtr = PTR_servoPinMap_080005cc;\\n  Servo::detach((Servo *)(PTR_servos_080005d0 + (uint)(byte)PTR_servoPinMap_080005cc[pin] * 3));\\n  servoIndex = servoPinMapPtr[pin];\\n  servoCount = *PTR_servoCount_080005d4;\\n  if ((servoIndex == servoCount) && (servoCount != \"\\0\")) {\\n    *PTR_servoCount_080005d4 = servoCount + -1;\\n  }\\n  else if (servoCount != \"\\0\") {\\n    char detachedServoCount = *PTR_detachedServoCount_080005d8;\\n    *PTR_detachedServoCount_080005d8 = detachedServoCount + 1U;\\n    PTR_detachedServos_080005dc[(byte)(detachedServoCount + 1U) - 1] = servoIndex;\\n  }\\n  servoPinMapPtr[pin] = 0xff;\\n  return;\\n}",
            "called": [
                "detach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000588",
            "calling": [
                "sysexCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "detachServo_08000588"
        },
        "FUN_08002644": {
            "renaming": {
                "FUN_08002644": "updateServo_08002644",
                "this": "servo",
                "bVar1": "isActive",
                "uVar2": "servoIndex"
            },
            "code": "void __thiscall updateServo_08002644(Servo *servo) {\n  boolean isActive;\n  uint servoIndex = (uint)servo->servoIndex;\n  PTR_servos_08002670[servoIndex * 8] = PTR_servos_08002670[servoIndex * 8] & 0xbf;\n  isActive = isTimerActive((timer16_Sequence_t)\n                        (uint)((ulonglong)DAT_08002674 * (ulonglong)servoIndex >> 0x23));\n  if (!isActive) {\n    finISR((stimer_t *)PTR__timer_08002678);\n  }\n  return;\n}",
            "called": [
                "isTimerActive",
                "finISR"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002644",
            "calling": [
                "detachServo"
            ],
            "imported": false,
            "current_name": "updateServo_08002644"
        },
        "FUN_08002f1e": {
            "renaming": {
                "FUN_08002f1e": "printByteToStream_08002f1e",
                "c": "byteToPrint"
            },
            "code": "void __thiscall printByteToStream_08002f1e(FirmataClass *this, byte byteToPrint)\n{\n  (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream,(uint)byteToPrint);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f1e",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "printByteToStream_08002f1e"
        },
        "FUN_0800902e": {
            "renaming": {
                "FUN_0800902e": "handle_GPIO_interrupt_0800902e",
                "PTR_": "",
                "DAT_": ""
            },
            "code": "DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_ handle_GPIO_interrupt_0800902e(DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_{DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_HDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_LDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_GDAT_PDAT_TDAT_RDAT__DAT_PDAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT_ODAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_EDAT_PDAT_TDAT_RDAT__DAT_XDAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_QDAT_PDAT_TDAT_RDAT__DAT_HDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_GDAT_PDAT_TDAT_RDAT__DAT_PDAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT_ODAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_PDAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT_NDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_2DAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_}DAT_PDAT_TDAT_RDAT__DAT_",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800902e",
            "calling": [],
            "imported": false,
            "current_name": "handle_GPIO_interrupt_0800902e"
        },
        "FUN_08009042": {
            "renaming": {
                "FUN_08009042": "handleExternalInterrupt_08009042"
            },
            "code": "void handleExternalInterrupt_08009042(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(8);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009042",
            "calling": [],
            "imported": false,
            "current_name": "handleExternalInterrupt_08009042"
        },
        "FUN_08009c7c": {
            "renaming": {
                "FUN_08009c7c": "flush_if_not_fake_08009c7c",
                "param_1": "file_descriptor",
                "param_2": "stream",
                "param_3": "arg3",
                "param_4": "arg4",
                "uVar1": "result"
            },
            "code": "int flush_if_not_fake_08009c7c(int file_descriptor, void *stream, int arg3, int arg4) {\n  int result;\n  if (*(int *)(stream + 0x10) != 0) {\n    if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n      __sinit();\n    }\n    if (stream == PTR___sf_fake_stdin_08009cc4) {\n      stream = *(void **)(file_descriptor + 4);\n    }\n    else if (stream == PTR___sf_fake_stdout_08009cc8) {\n      stream = *(void **)(file_descriptor + 8);\n    }\n    else if (stream == PTR___sf_fake_stderr_08009ccc) {\n      stream = *(void **)(file_descriptor + 0xc);\n    }\n    if (*(short *)(stream + 0xc) != 0) {\n      result = __sflush_r(file_descriptor, stream, arg3, arg4);\n      return result;\n    }\n  }\n  return 0;\n}",
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009c7c",
            "calling": [
                "__swbuf_r"
            ],
            "imported": false,
            "current_name": "flush_if_not_fake_08009c7c"
        },
        "FUN_08009b5c": {
            "renaming": {
                "FUN_08009b5c": "raise_signal_and_exit_on_failure_08009b5c"
            },
            "code": "void raise_signal_and_exit_on_failure_08009b5c(void)\n{\n  raise(SIGABRT);\n  _exit(EXIT_FAILURE);\n}",
            "called": [
                "raise",
                "_exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009b5c",
            "calling": [
                "__throw_bad_function_call",
                "__assert_func"
            ],
            "imported": false,
            "current_name": "raise_signal_and_exit_on_failure_08009b5c"
        },
        "FUN_08008a6c": {
            "renaming": {
                "FUN_08008a6c": "read_digital_pin_08008a6c",
                "ulPin": "pin_number",
                "_Var1": "is_pin_configured",
                "port": "gpio_port",
                "uVar2": "digital_io_value",
                "uVar3": "digital_pin_index"
            },
            "code": "int read_digital_pin_08008a6c(uint32_t pin_number) {\n  _Bool is_pin_configured;\n  GPIO_TypeDef *gpio_port;\n  uint32_t digital_io_value;\n  uint32_t digital_pin_index;\n\n  if (pin_number < 0x3c) {\n    digital_pin_index = (uint32_t)(char)PTR_digitalPin_08008ab4[pin_number];\n  }\n  else {\n    digital_pin_index = 0xffffffff;\n  }\n\n  if (digital_pin_index == 0xffffffff) {\n    digital_pin_index = 0;\n  }\n  else {\n    is_pin_configured = is_pin_configured((PinName_conflict)digital_pin_index, (uint32_t *)PTR_g_digPinConfigured_08008ab8);\n    if (is_pin_configured) {\n      gpio_port = get_GPIO_Port((digital_pin_index << 0x18) >> 0x1c);\n      digital_io_value = digital_io_read(gpio_port, 1 << (digital_pin_index & 0xf) & 0xffff);\n      digital_pin_index = digital_io_value & 0xff;\n    }\n    else {\n      digital_pin_index = 0;\n    }\n  }\n\n  if (digital_pin_index != 0) {\n    digital_pin_index = 1;\n  }\n  return digital_pin_index;\n}",
            "called": [
                "digital_io_read",
                "is_pin_configured",
                "get_GPIO_Port"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a6c",
            "calling": [
                "checkDigitalInputs",
                "reportDigitalCallback"
            ],
            "imported": false,
            "current_name": "read_digital_pin_08008a6c"
        },
        "FUN_080085b8": {
            "renaming": {
                "FUN_080085b8": "is_uart_state_error_080085b8",
                "obj": "serial",
                "HVar1": "uart_state",
                "PTR_uart_handlers_080085d8": "uart_handlers_ptr"
            },
            "code": "bool is_uart_state_error_080085b8(serial_t *serial) {\n  UART_HandleTypeDef *uart_handler = *(UART_HandleTypeDef **)(PTR_uart_handlers_080085d8 + (uint)serial->index * 4);\n  HAL_UART_StateTypeDef uart_state = HAL_UART_GetState(uart_handler);\n  return (uart_state & (HAL_UART_STATE_BUSY_TX | HAL_UART_STATE_BUSY_RX)) == (HAL_UART_STATE_BUSY_TX | HAL_UART_STATE_BUSY_RX);\n}",
            "called": [
                "HAL_UART_GetState"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080085b8",
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "imported": false,
            "current_name": "is_uart_state_error_080085b8"
        },
        "FUN_08001c08": {
            "renaming": {
                "FUN_08001c08": "readDataFromWire_08001c08",
                "in_r1": "address",
                "in_r2": "buffer",
                "in_r3": "length",
                "sVar1": "bytesRead"
            },
            "code": "byte readDataFromWire_08001c08(void)\n{\n  ssize_t bytesRead;\n  int address;\n  void *buffer;\n  size_t length;\n  bytesRead = TwoWire::read((TwoWire *)PTR_Wire_08001c14, address, buffer, length);\n  return (byte)bytesRead;\n}",
            "called": [
                "read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001c08",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "readDataFromWire_08001c08"
        },
        "FUN_080075dc": {
            "renaming": {
                "FUN_080075dc": "getTimerFrequency_080075dc",
                "tim": "timer",
                "uVar1": "frequency",
                "uVar2": "timerClkSrc",
                "uVar3": "apb1Freq",
                "uVar4": "apb2Freq",
                "pFLatency": "flashLatency",
                "clkconfig": "clockConfig"
            },
            "code": "uint32_t getTimerFrequency_080075dc(TIM_TypeDef_conflict *timer)\n{\n  uint32_t frequency;\n  uint8_t timerClkSrc;\n  uint32_t apb1ClkDiv;\n  uint32_t apb2ClkDiv;\n  uint32_t flashLatency;\n  RCC_ClkInitTypeDef_conflict clockConfig;\n  \n  clockConfig.ClockType = 0;\n  clockConfig.SYSCLKSource = 0;\n  clockConfig.AHBCLKDivider = 0;\n  clockConfig.APB1CLKDivider = 0;\n  clockConfig.APB2CLKDivider = 0;\n  flashLatency = 0;\n  HAL_RCC_GetClockConfig(&clockConfig,&flashLatency);\n  timerClkSrc = getTimerClkSrc(timer);\n  apb2ClkDiv = clockConfig.APB2CLKDivider;\n  apb1ClkDiv = clockConfig.APB1CLKDivider;\n  if (timerClkSrc == TIMER_CLK_SRC_APB1)\n  {\n    frequency = HAL_RCC_GetPCLK1Freq();\n  }\n  else if (timerClkSrc == TIMER_CLK_SRC_APB2)\n  {\n    frequency = HAL_RCC_GetPCLK2Freq();\n    apb1ClkDiv = apb2ClkDiv;\n  }\n  else\n  {\n    iprintf(PTR_s_TIM__Unknown_clock_source_08007644);\n    frequency = 0;\n    apb1ClkDiv = 0;\n  }\n  if (apb1ClkDiv != APB1_CLK_DIV_2)\n  {\n    if (apb1ClkDiv < APB1_CLK_DIV_4)\n    {\n      if (apb1ClkDiv != APB1_CLK_DIV_1)\n      {\n        return frequency;\n      }\n    }\n    else if ((apb1ClkDiv != APB1_CLK_DIV_8) && (apb1ClkDiv != APB1_CLK_DIV_16))\n    {\n      return frequency;\n    }\n  }\n  return frequency << 1;\n}",
            "called": [
                "iprintf",
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq",
                "getTimerClkSrc",
                "HAL_RCC_GetClockConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080075dc",
            "calling": [
                "TimerPulseInit",
                "pwm_start"
            ],
            "imported": false,
            "current_name": "getTimerFrequency_080075dc"
        },
        "FUN_080087ec": {
            "renaming": {
                "FUN_080087ec": "handle_USART3_interrupt_080087ec",
                "USART3_IRQn": "USART3_interrupt_number",
                "PTR_uart_handlers_08008800": "uart_handlers_pointer",
                "active_uart_handler": "active_uart_handler"
            },
            "code": "void handle_USART3_interrupt_080087ec(void)\n{\n  HAL_NVIC_ClearPendingIRQ(USART3_IRQn);\n  if (active_uart_handler != NULL) {\n    HAL_UART_IRQHandler(active_uart_handler);\n  }\n  return;\n}",
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080087ec",
            "calling": [],
            "imported": false,
            "current_name": "handle_USART3_interrupt_080087ec"
        },
        "FUN_08007ff0": {
            "renaming": {
                "FUN_08007ff0": "handle_i2c_receive_08007ff0",
                "hi2c": "i2c_handle",
                "piVar1": "i2c_obj",
                "uVar2": "remaining_bytes",
                "get_i2c_obj": "get_i2c_object",
                "i2c_onSlaveReceive": "on_slave_receive",
                "i2cTxRxBuffer": "tx_rx_buffer",
                "slaveMode": "slave_mode"
            },
            "code": "void handle_i2c_receive_08007ff0(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  i2c_t_conflict *i2c_obj;\n  uint8_t remaining_bytes;\n\n  i2c_obj = get_i2c_object(i2c_handle);\n  if (((i2c_obj->on_slave_receive != (_func_void_uint8_t_ptr_int *)0x0) &&\n      (i2c_obj->slave_mode == '\\x01')) &&\n     (remaining_bytes = 0x20 - *(uint8_t *)&(i2c_obj->handle).XferSize & 0xff, remaining_bytes != 0)) {\n    (*i2c_obj->on_slave_receive)(i2c_obj->tx_rx_buffer, remaining_bytes);\n  }\n  HAL_I2C_EnableListen_IT(i2c_handle);\n  return;\n}",
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007ff0",
            "calling": [
                "I2C_ITError",
                "I2C_Slave_STOPF",
                "I2C_Slave_AF"
            ],
            "imported": false,
            "current_name": "handle_i2c_receive_08007ff0"
        },
        "FUN_08008078": {
            "renaming": {
                "FUN_08008078": "FUNC_08008078"
            },
            "code": "\nvoid FUNC_08008078(serial_t *obj)\n\n{\n  USART_TypeDef *pUVar1;\n  USART_TypeDef *pUVar2;\n  USART_TypeDef *pUVar3;\n  void *a;\n  void *b;\n  USART_TypeDef *pUVar4;\n  GPIO_TypeDef *pGVar5;\n  uint32_t uVar6;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (obj != (serial_t *)0x0) {\n    a = pinmap_peripheral(obj->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08008330);\n    b = pinmap_peripheral(obj->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08008334);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(PTR_s_ERROR__at_least_one_UART_pin_has_08008348);\n    }\n    else {\n      pUVar4 = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      obj->uart = pUVar4;\n      pUVar3 = DAT_08008340;\n      pUVar2 = DAT_0800833c;\n      pUVar1 = DAT_08008338;\n      if (pUVar4 == (USART_TypeDef *)0x0) {\n        iprintf(PTR_s_ERROR__U_S_ART_pins_mismatch_0800834c);\n      }\n      else {\n        if (pUVar4 == DAT_08008338) {\n          DAT_08008338[0x7b7].BRR = DAT_08008338[0x7b7].BRR | 0x4000;\n          pUVar1[0x7b7].BRR = pUVar1[0x7b7].BRR & 0xffffbfff;\n          pUVar1[0x7b7].CR3 = pUVar1[0x7b7].CR3 | 0x4000;\n          obj->index = '\\0';\n          obj->irq = USART1_IRQn;\n        }\n        else if (pUVar4 == DAT_0800833c) {\n          DAT_0800833c[0x106e].BRR = DAT_0800833c[0x106e].BRR | 0x20000;\n          pUVar2[0x106e].BRR = pUVar2[0x106e].BRR & 0xfffdffff;\n          pUVar2[0x106e].CR3 = pUVar2[0x106e].CR3 | 0x20000;\n          obj->index = '\\x01';\n          obj->irq = USART2_IRQn;\n        }\n        else if (pUVar4 == DAT_08008340) {\n          DAT_08008340[0x1049].CR3 = DAT_08008340[0x1049].CR3 | 0x40000;\n          pUVar3[0x1049].CR3 = pUVar3[0x1049].CR3 & 0xfffbffff;\n          pUVar3[0x104a].DR = pUVar3[0x104a].DR | 0x40000;\n          obj->index = '\\x02';\n          obj->irq = USART3_IRQn;\n        }\n        pGVar5 = set_GPIO_Port_Clock((uint)((int)obj->pin_rx << 0x18) >> 0x1c);\n        uVar6 = pinmap_function(obj->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08008334);\n        GPIO_InitStruct.Pin = 1 << (obj->pin_rx & 0xfU) & 0xffff;\n        GPIO_InitStruct.Mode = (uVar6 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Pull = (uVar6 << 0x1a) >> 0x1e;\n        *(uint *)(DAT_08008344 + 0x18) = *(uint *)(DAT_08008344 + 0x18) | 1;\n        switch((uVar6 << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x4000000;\n        }\n        GPIO_InitStruct.Speed = 3;\n        HAL_GPIO_Init(pGVar5,&GPIO_InitStruct);\n        pGVar5 = set_GPIO_Port_Clock((uint)((int)obj->pin_tx << 0x18) >> 0x1c);\n        uVar6 = pinmap_function(obj->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08008330);\n        GPIO_InitStruct.Pin = 1 << (obj->pin_tx & 0xfU) & 0xffff;\n        GPIO_InitStruct.Mode = (uVar6 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Pull = (uVar6 << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(pGVar5,&GPIO_InitStruct);\n        *(UART_HandleTypeDef **)(PTR_uart_handlers_08008354 + (uint)obj->index * 4) = &obj->handle;\n        (obj->handle).Instance = obj->uart;\n        (obj->handle).Init.BaudRate = obj->baudrate;\n        (obj->handle).Init.WordLength = obj->databits;\n        (obj->handle).Init.StopBits = obj->stopbits;\n        (obj->handle).Init.Parity = obj->parity;\n        (obj->handle).Init.Mode = 0xc;\n        (obj->handle).Init.HwFlowCtl = 0;\n        (obj->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&obj->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "iprintf",
                "set_GPIO_Port_Clock",
                "pinmap_merge_peripheral",
                "HAL_GPIO_Init",
                "pinmap_function",
                "pinmap_peripheral",
                "HAL_UART_Init"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08008078",
            "calling": [
                "begin",
                "uart_debug_init"
            ],
            "imported": false,
            "current_name": "FUNC_08008078"
        },
        "FUN_08002774": {
            "renaming": {
                "FUN_08002774": "executeUserRequest_08002774",
                "pcVar1": "user_request_handler",
                "PTR_user_onRequest_0800278c": "user_request_ptr",
                "PTR_txBufferIndex_08002790": "tx_buffer_index",
                "PTR_txBufferLength_08002794": "tx_buffer_length"
            },
            "code": "void executeUserRequest_08002774(void)\n{\n  code *user_request_handler;\n  user_request_handler = *(code **)PTR_user_onRequest_0800278c;\n  if (user_request_handler != (code *)0x0) {\n    *PTR_txBufferIndex_08002790 = 0;\n    *PTR_txBufferLength_08002794 = 0;\n    (*user_request_handler)();\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002774",
            "calling": [],
            "imported": false,
            "current_name": "executeUserRequest_08002774"
        },
        "FUN_080052f0": {
            "renaming": {
                "FUN_080052f0": "i2c_handle_errors_080052f0",
                "hi2c": "handle",
                "HVar1": "state",
                "pIVar2": "instance",
                "uVar3": "sr1",
                "uVar4": "cr2"
            },
            "code": "void i2c_handle_errors_080052f0(I2C_HandleTypeDef *handle)\n{\n  HAL_I2C_StateTypeDef state;\n  I2C_TypeDef *instance;\n  uint16_t sr1;\n  uint16_t cr2;\n  instance = handle->Instance;\n  sr1 = instance->SR1;\n  cr2 = instance->CR2;\n  if (((sr1 & I2C_SR1_ARLO) != 0) && ((cr2 & I2C_CR2_ITEVTEN) != 0)) {\n    handle->ErrorCode |= HAL_I2C_ERROR_ARLO;\n    instance->SR1 = ~(I2C_SR1_ARLO);\n    instance->CR1 |= I2C_CR1_PE;\n  }\n  if (((sr1 & (I2C_SR1_ADDR | I2C_SR1_BTF)) != 0) && ((cr2 & I2C_CR2_ITEVTEN) != 0)) {\n    handle->ErrorCode |= HAL_I2C_ERROR_BERR;\n    instance->SR1 = ~(I2C_SR1_BERR);\n  }\n  if (((sr1 & I2C_SR1_AF) != 0) && ((cr2 & I2C_CR2_ITEVTEN) != 0)) {\n    state = handle->State;\n    if (((handle->Mode == HAL_I2C_MODE_SLAVE) && (handle->XferCount == 0)) && (((state == HAL_I2C_STATE_BUSY_TX) || (state == HAL_I2C_STATE_BUSY_TX_LISTEN)) || ((state == HAL_I2C_STATE_LISTEN) && (handle->PreviousState == I2C_STATE_ADDR)))) {\n      i2c_slave_af(handle);\n    }\n    else {\n      handle->ErrorCode |= HAL_I2C_ERROR_AF;\n      if (handle->Mode == HAL_I2C_MODE_MASTER) {\n        instance->CR1 |= I2C_CR1_STOP;\n      }\n      instance->SR1 = ~(I2C_SR1_AF);\n    }\n  }\n  if (((sr1 & I2C_SR1_OVR) != 0) && ((cr2 & I2C_CR2_ITEVTEN) != 0)) {\n    handle->ErrorCode |= HAL_I2C_ERROR_OVR;\n    instance->SR1 = ~(I2C_SR1_OVR);\n  }\n  if (handle->ErrorCode != HAL_I2C_ERROR_NONE) {\n    i2c_it_error(handle);\n  }\n  return;\n}",
            "called": [
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052f0",
            "calling": [
                "I2C2_ER_IRQHandler",
                "I2C1_ER_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handle_errors_080052f0"
        },
        "FUN_08002f2c": {
            "renaming": {
                "FUN_08002f2c": "updateCallback_08002f2c",
                "PTR_currentReportDigitalCallback_08002f78": "currentReportDigitalCallback",
                "PTR_currentPinModeCallback_08002f7c": "currentPinModeCallback",
                "PTR_currentPinValueCallback_08002f80": "currentDigitalCallback",
                "PTR_currentAnalogCallback_08002f6c": "currentAnalogCallback",
                "PTR_currentDigitalCallback_08002f74": "currentDigitalCallback",
                "PTR_currentReportAnalogCallback_08002f70": "currentReportAnalogCallback",
                "command": "command",
                "newFunction": "newFunction"
            },
            "code": "void __thiscall updateCallback_08002f2c(FirmataClass *this,uint8_t command,callbackFunction newFunction) {\n  if (command == DIGITAL_MESSAGE) {\n    *(callbackFunction *)PTR_currentReportDigitalCallback_08002f78 = newFunction;\n    return;\n  }\n  if (command >= START_SYSEX) {\n    if (command == SET_PIN_MODE) {\n      *(callbackFunction *)PTR_currentPinModeCallback_08002f7c = newFunction;\n      return;\n    }\n    if (command == REPORT_DIGITAL) {\n      *(callbackFunction *)PTR_currentPinValueCallback_08002f80 = newFunction;\n      return;\n    }\n    if (command == REPORT_ANALOG) {\n      *(callbackFunction *)PTR_currentReportAnalogCallback_08002f70 = newFunction;\n      return;\n    }\n    if (command == ANALOG_MESSAGE) {\n      *(callbackFunction *)PTR_currentAnalogCallback_08002f6c = newFunction;\n      return;\n    }\n  }\n  if (command == REPORT_ANALOG) {\n    *(callbackFunction *)PTR_currentReportAnalogCallback_08002f70 = newFunction;\n    return;\n  }\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f2c",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "updateCallback_08002f2c"
        },
        "FUN_08004954": {
            "renaming": {
                "FUN_08004954": "listen_state_handler_08004954",
                "hi2c": "i2c_handle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "transfer_options",
                "HVar1": "status",
                "pIVar2": "i2c_instance",
                "tmpreg": "control_register"
            },
            "code": "HAL_StatusTypeDef listen_state_handler_08004954(I2C_HandleTypeDef *i2c_handle, uint8_t *data, uint16_t size, uint32_t transfer_options) {\n  HAL_StatusTypeDef status;\n  I2C_TypeDef *i2c_instance;\n  uint32_t control_register;\n  if (i2c_handle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == NULL || size == 0 || i2c_handle->Lock == HAL_LOCKED) {\n      status = (data == NULL || size == 0) ? HAL_ERROR : HAL_BUSY;\n    }\n    else {\n      i2c_handle->Lock = HAL_LOCKED;\n      i2c_instance = i2c_handle->Instance;\n      control_register = i2c_instance->CR1;\n      if ((control_register & 1) == 0) {\n        i2c_instance->CR1 = control_register | 1;\n      }\n      i2c_instance->CR1 &= ~(1 << 11);\n      i2c_handle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      i2c_handle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2c_handle->ErrorCode = 0;\n      i2c_handle->pBuffPtr = data;\n      i2c_handle->XferCount = size;\n      i2c_handle->XferOptions = transfer_options;\n      i2c_handle->XferSize = i2c_handle->XferCount;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      i2c_instance->CR2 |= 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004954",
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "imported": false,
            "current_name": "listen_state_handler_08004954"
        },
        "FUN_08005cec": {
            "renaming": {
                "FUN_08005cec": "configure_timer_08005cec",
                "TIMx": "timer",
                "OC_Config": "output_compare_config",
                "uVar1": "cc_enable_value",
                "uVar2": "cr2_register_value",
                "uVar3": "output_compare_mode",
                "cc_enable_mask": "cc_enable_mask",
                "PTR_08005d44": "PTR_08005d44"
            },
            "code": "void configure_timer_08005cec(TIM_TypeDef_conflict *timer, TIM_OC_InitTypeDef *output_compare_config) {\n  uint32_t cc_enable_mask = 0xfffffffe;\n  uint32_t cr2_register_value = timer->CR2;\n  uint output_compare_mode = output_compare_config->OCMode;\n  uint32_t cc_enable_value = (timer->CCER & 0xfffffffd) | output_compare_config->OCPolarity;\n  if (timer == PTR_08005d44) {\n    cc_enable_value = (cc_enable_value & 0xfffffff7 | output_compare_config->OCNPolarity) & 0xfffffffb;\n    cr2_register_value = (cr2_register_value & 0xfffffcff) | output_compare_config->OCIdleState | output_compare_config->OCNIdleState;\n  }\n  timer->CR2 = cr2_register_value;\n  timer->CCMR1 = (timer->CCMR1 & 0xffffff8c) | output_compare_mode;\n  timer->CCR1 = output_compare_config->Pulse;\n  timer->CCER = cc_enable_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005cec",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_08005cec"
        },
        "FUN_08003748": {
            "renaming": {
                "FUN_08003748": "updateTickValue_08003748",
                "PTR_uwTick_08003758": "tickValue",
                "PTR_uwTickFreq_0800375c": "tickFreq"
            },
            "code": "void updateTickValue_08003748(void)\n{\n  uint8_t PTR_uwTickFreq_0800375c = *(uint8_t*)PTR_uwTickFreq_0800375c;\n  uint32_t* PTR_uwTick_08003758 = (uint32_t*)PTR_uwTick_08003758;\n  *PTR_uwTick_08003758 = PTR_uwTickFreq_0800375c + *PTR_uwTick_08003758;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003748",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "updateTickValue_08003748"
        },
        "FUN_080040e8": {
            "renaming": {
                "FUN_080040e8": "configure_GPIO_pins_080040e8",
                "GPIOx": "GPIO_port",
                "GPIO_Init": "GPIO_config",
                "pGVar1": "GPIO_reg",
                "uVar2": "alternate_function_bits",
                "uVar3": "pin_mask",
                "uVar4": "pin_masked",
                "uVar5": "pin_index",
                "uVar6": "mode_bits",
                "uVar7": "speed_bits",
                "iVar8": "shift_amount",
                "uVar9": "alternate_function_mask",
                "iVar10": "alternate_function_index",
                "tmpreg": "temporary_register",
                "DAT_080042bc": "AFIO_BASE",
                "DAT_080042c0": "GPIO_AFRL_AFRH_BASE",
                "DAT_080042c4": "GPIO_ODR_BSRR_BRR_BASE",
                "DAT_080042c8": "GPIO_MODE_ANALOG",
                "DAT_080042cc": "GPIO_MODE_IT_FALLING",
                "DAT_080042d0": "GPIOA_BASE"
            },
            "code": "void configure_GPIO_pins_080040e8(GPIO_TypeDef *GPIO_port, GPIO_InitTypeDef *GPIO_config)\n{\n  uint32_t pin_mask, speed_bits;\n  uint8_t pin_index;\n  GPIO_TypeDef *GPIO_reg;\n  uint8_t mode_bits;\n  uint32_t *AFRH_reg, *AFRL_reg;\n\n  for (pin_index = 0; pin_index <= 15; pin_index++) {\n    pin_mask = 1U << pin_index;\n    if (GPIO_config->Pin & pin_mask) {\n      mode_bits = GPIO_config->Mode;\n      if (mode_bits == GPIO_MODE_AF_OD || mode_bits == GPIO_MODE_AF_PP) {\n        AFRH_reg = (pin_index >= 8) ? &GPIO_port->AFRH : &GPIO_port->AFRL;\n        *AFRH_reg &= ~(0xFU << ((pin_index & 0x7U) * 4U));\n        *AFRH_reg |= ((GPIO_config->Alternate) & 0xFU) << ((pin_index & 0x7U) * 4U);\n      }\n      else {\n        speed_bits = GPIO_config->Speed;\n        if (mode_bits == GPIO_MODE_OUTPUT_OD || mode_bits == GPIO_MODE_OUTPUT_PP) {\n          speed_bits += 0x8U;\n        }\n        else if (mode_bits == GPIO_MODE_INPUT) {\n          speed_bits = 0U;\n        }\n        else if (mode_bits == GPIO_MODE_IT_RISING || mode_bits == GPIO_MODE_EVT_RISING) {\n          speed_bits += 0x4U;\n        }\n        GPIO_reg = (pin_index >= 8) ? (GPIO_TypeDef *)&GPIO_port->CRH : GPIO_port;\n        GPIO_reg->CRL &= ~(0xFU << (pin_index * 4U));\n        GPIO_reg->CRL |= speed_bits << (pin_index * 4U);\n        if ((GPIO_config->Mode & GPIO_MODE_INPUT) && (GPIO_config->Pull == GPIO_PULLUP)) {\n          GPIO_port->BSRR = pin_mask;\n        }\n        else if ((GPIO_config->Mode & GPIO_MODE_INPUT) && (GPIO_config->Pull == GPIO_PULLDOWN)) {\n          GPIO_port->BRR = pin_mask;\n        }\n      }\n    }\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040e8",
            "calling": [
                "i2c_custom_init",
                "HAL_ADC_MspInit",
                "digital_io_init",
                "uart_init",
                "HAL_TIM_PWM_MspInit"
            ],
            "imported": false,
            "current_name": "configure_GPIO_pins_080040e8"
        },
        "FUN_08009b6c": {
            "renaming": {
                "FUN_08009b6c": "decode_and_process_08009b6c",
                "param_1": "data",
                "param_2": "params",
                "iVar1": "start_offset",
                "piVar2": "decoder_params",
                "uVar3": "flags",
                "uVar4": "original_flags",
                "iVar5": "block_size",
                "pcVar6": "decoder",
                "iVar7": "result",
                "uVar8": "original_data",
                "bVar9": "is_block"
            },
            "code": "uint32_t decode_and_process_08009b6c(uint32_t *data, int *params) {\n  int start_offset;\n  int block_size;\n  code *decoder;\n  int result;\n  uint16_t flags;\n  uint32_t original_data;\n  bool is_block;\n  \n  flags = *(uint16_t *)(params + 6);\n  is_block = (flags & 0x8000) != 0;\n  if ((flags & 0x4000) != 0 && (decoder = (code *)params[11]) != NULL) {\n    original_data = *data;\n    *data = 0;\n    if ((flags & 0x1000) == 0) {\n      result = decoder(data, params[8], flags & 0x1000, 1);\n      if (result == -1 && *data != 0) {\n        if (*data != 0x1d && *data != 0x16) {\n          *(uint16_t *)(params + 6) = flags | 0x40;\n          return 0xffffffff;\n        }\n        *data = original_data;\n        return 0;\n      }\n    } else {\n      result = params[21];\n    }\n    if (((flags << 0x13) & 0x80000000) != 0 && result != -1 && *data == 0) {\n      params[21] = result;\n    }\n    if (((flags << 0x1d) & 0x80000000) != 0 && params[13] != 0) {\n      start_offset = result - params[1];\n      block_size = params[13] != 0 ? start_offset - params[16] : start_offset;\n      result = decoder(data, params[8], block_size, 0);\n      if (result == -1 && (*data > 0x1d || (DAT_08009c78 >> (*data & 0xff)) < 0)) {\n        *(uint16_t *)(params + 6) = flags | 0x40;\n        return 0xffffffff;\n      }\n    }\n    params[1] = 0;\n    *params = params[4];\n    if (((flags << 0x13) & 0x80000000) != 0 && (result != -1 || *data == 0)) {\n      params[21] = result;\n    }\n    decoder = (code *)params[13];\n    *data = original_data;\n    if (decoder != NULL) {\n      if (decoder != (code *)(params + 17)) {\n        free(data);\n      }\n      params[13] = 0;\n    }\n    return 0;\n  }\n  flags = *(uint16_t *)(params + 8);\n  if ((int)(flags << 0x1c) >= 0) {\n    return 0;\n  }\n  decoder = (code *)params[4];\n  if (decoder == NULL) {\n    return 0;\n  }\n  start_offset = params[5];\n  if (start_offset == 0) {\n    return 0;\n  }\n  params[5] = 0;\n  params[3] = start_offset << 0x1e;\n  params[2] = 0;\n  params[0] = params[4];\n  original_data = *data;\n  for (start_offset = params[2] - params[0]; start_offset > 0; start_offset -= params[2]) {\n    result = decoder(data, params[8], params[4], start_offset);\n    if (result < 1) {\n      *(uint16_t *)(params + 6) = flags | 0x40;\n      return 0xffffffff;\n    }\n    params[0] += result;\n  }\n  *data = original_data;\n  return 0;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009b6c",
            "calling": [
                "_fflush_r"
            ],
            "imported": false,
            "current_name": "decode_and_process_08009b6c"
        },
        "FUN_0800288c": {
            "renaming": {
                "TwoWire::FUN_0800288c": "transmitData",
                "this": "wire",
                "data": "data",
                "puVar1": "bufferPtr",
                "iVar2": "i2cStatus",
                "pvVar3": "reallocPtr",
                "sVar4": "result",
                "cVar5": "bufferIndex",
                "uVar6": "bufferAllocated",
                "__size": "resultSize",
                "local_11": "localData",
                "PTR_txBuffer_08002914": "wire->txBuffer",
                "PTR_transmitting_08002908": "*wire->transmitting",
                "PTR_txBufferLength_0800290c": "wire->txBufferLength",
                "PTR_txBufferAllocated_08002910": "wire->txBufferAllocated",
                "PTR_txBufferIndex_08002918": "wire->txBufferIndex",
                "i2c_t_conflict": "i2c_t",
                "undefined": "unsigned char",
                "uint8_t": "unsigned char",
                "size_t": "unsigned int",
                "realloc": "realloc",
                "i2c_slave_FUN_0800288c_IT": "i2c_slave_transmit_IT",
                "FUN_0800288c": "transmitData_0800288c"
            },
            "code": "size_t __thiscall transmitData_0800288c(TwoWire *wire, uint8_t data) {\n  undefined *bufferPtr;\n  i2c_status_e_conflict i2cStatus;\n  void *reallocPtr;\n  size_t result;\n  char bufferIndex;\n  undefined bufferAllocated;\n  undefined transmitting;\n  uint8_t localData;\n  \n  bufferPtr = PTR_txBuffer_08002914;\n  localData = data;\n  transmitting = PTR_transmitting_08002908 == 0;\n  if (transmitting) {\n    i2cStatus = i2c_slave_transmit_IT((i2c_t_conflict *)&wire->_i2c, &localData, 1);\n    result = i2cStatus == I2C_OK ? 1 : 0;\n  }\n  else {\n    result = (byte)*PTR_txBufferLength_0800290c + 1;\n    bufferAllocated = (byte)*PTR_txBufferAllocated_08002910;\n    if (bufferAllocated < result) {\n      if (result < 0x20) {\n        result = 0x20;\n      }\n      reallocPtr = realloc(*(void **)PTR_txBuffer_08002914, result);\n      *(void **)bufferPtr = reallocPtr;\n      bufferAllocated = reallocPtr == (void *)0x0 ? 0 : (undefined)result;\n      *PTR_txBufferAllocated_08002910 = bufferAllocated;\n    }\n    bufferPtr = PTR_txBufferIndex_08002918;\n    if (*(int *)PTR_txBuffer_08002914 == 0) {\n      wire->super_Stream.super_Print.transmitData_0800288c_error = 1;\n      result = 0;\n    }\n    else {\n      *(uint8_t *)(*(int *)PTR_txBuffer_08002914 + (uint)(byte)*bufferPtr) = localData;\n      bufferIndex = *bufferPtr + '\\x01';\n      *bufferPtr = bufferIndex;\n      *PTR_txBufferLength_0800290c = bufferIndex;\n      result = 1;\n    }\n  }\n  return result;\n}",
            "called": [
                "realloc",
                "i2c_slave_write_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800288c",
            "calling": [
                "wireWrite"
            ],
            "imported": false,
            "current_name": "transmitData_0800288c"
        },
        "FUN_08002e26": {
            "renaming": {
                "FUN_08002e26": "initialize_08002e26",
                "s": "stream_instance",
                "this": "firmata_instance",
                "FirmataStream": "stream_instance",
                "marshaller": "firmata_marshaller",
                "printVersion": "print_version",
                "printFirmwareVersion": "print_firmware_version"
            },
            "code": "void __thiscall initialize_08002e26(FirmataClass *firmata_instance, Stream *stream_instance)\n{\n  firmata_instance->FirmataStream = stream_instance;\n  FirmataMarshaller::initialize_08002e26(&firmata_instance->marshaller,stream_instance);\n  printVersion(firmata_instance);\n  printFirmwareVersion(firmata_instance);\n  return;\n}",
            "called": [
                "printFirmwareVersion",
                "printVersion",
                "begin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002e26",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "initialize_08002e26"
        },
        "FUN_0800010c": {
            "renaming": {
                "FUN_0800010c": "isInitializationCompleted_0800010c",
                "param_1": "initializationPointer",
                "PTR_completed_8667_08000124": "isCompleted",
                "DAT_08000128": "initializationValue",
                "PTR__init_0800012c": "initPointer"
            },
            "code": "bool isInitializationCompleted_0800010c(bool* PTR_completed_8667_08000124, int* DAT_08000128, bool* initializationPointer) {\n  if (*PTR_completed_8667_08000124 == false) {\n    if (*DAT_08000128 != 0) {\n      initializationPointer = &PTR__init_0800012c;\n    }\n    *PTR_completed_8667_08000124 = true;\n  }\n  return *initializationPointer;\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800010c",
            "calling": [],
            "imported": false,
            "current_name": "isInitializationCompleted_0800010c"
        },
        "FUN_080086e8": {
            "renaming": {
                "FUN_080086e8": "get_uart_handler_index_080086e8",
                "huart": "uart_handler",
                "uVar1": "index"
            },
            "code": "uint8_t get_uart_handler_index_080086e8(UART_HandleTypeDef *uart_handler) {\n  uint8_t index = 0;\n  if (uart_handler == NULL) {\n    index = 5;\n  }\n  else {\n    while (index < 5) {\n      if (uart_handler == *(UART_HandleTypeDef **)(PTR_uart_handlers_08008708 + index * 4)) {\n        break;\n      }\n      index++;\n    }\n  }\n  return index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080086e8",
            "calling": [
                "HAL_UART_TxCpltCallback",
                "HAL_UART_RxCpltCallback"
            ],
            "imported": false,
            "current_name": "get_uart_handler_index_080086e8"
        },
        "FUN_08001c18": {
            "renaming": {
                "FUN_08001c18": "readI2CDataFromAddress_08001c18",
                "address": "deviceAddress",
                "theRegister": "registerAddress",
                "numBytes": "numBytesToRead",
                "stopTX": "stopTransmission",
                "bVar1": "isAvailable",
                "puVar2": "wirePtr",
                "bVar3": "receivedByte",
                "iVar4": "bytesAvailable",
                "iVar5": "i",
                "uVar6": "numBytes"
            },
            "code": "void readI2CDataFromAddress_08001c18(byte deviceAddress, int registerAddress, byte numBytesToRead, byte stopTransmission) {\n  bool isAvailable;\n  undefined *wirePtr;\n  byte receivedByte;\n  int bytesAvailable;\n  int i;\n  uint numBytes = (uint)numBytesToRead;\n  if (registerAddress == -1) {\n    registerAddress = 0;\n  }\n  else {\n    TwoWire::beginTransmission((TwoWire *)PTR_Wire_08001cbc, deviceAddress);\n    wireWrite((byte)registerAddress);\n    TwoWire::endTransmission((TwoWire *)PTR_Wire_08001cbc, stopTransmission);\n  }\n  wirePtr = PTR_Wire_08001cbc;\n  TwoWire::requestFrom((TwoWire *)PTR_Wire_08001cbc, deviceAddress, numBytesToRead);\n  bytesAvailable = TwoWire::available((TwoWire *)wirePtr);\n  if ((int)numBytes < bytesAvailable) {\n    firmata::FirmataClass::sendString((FirmataClass *)PTR_Firmata_08001cc4, PTR_s_I2C__Too_many_bytes_received_08001cc0);\n  }\n  else {\n    bytesAvailable = TwoWire::available((TwoWire *)PTR_Wire_08001cbc);\n    if (bytesAvailable < (int)numBytes) {\n      firmata::FirmataClass::sendString((FirmataClass *)PTR_Firmata_08001cc4, PTR_s_I2C__Too_few_bytes_received_08001ccc);\n    }\n  }\n  wirePtr = PTR_i2cRxData_08001cc8;\n  *PTR_i2cRxData_08001cc8 = deviceAddress;\n  wirePtr[1] = (char)registerAddress;\n  i = 0;\n  while (true) {\n    if (i < (int)numBytes) {\n      bytesAvailable = TwoWire::available((TwoWire *)PTR_Wire_08001cbc);\n      if (bytesAvailable == 0) {\n        isAvailable = false;\n      }\n      else {\n        isAvailable = true;\n      }\n    }\n    else {\n      isAvailable = false;\n    }\n    if (!isAvailable) break;\n    receivedByte = wireRead();\n    PTR_i2cRxData_08001cc8[i + 2] = receivedByte;\n    i++;\n  }\n  firmata::FirmataClass::sendSysex((FirmataClass *)PTR_Firmata_08001cc4, 'w', numBytesToRead + '\\x02', PTR_i2cRxData_08001cc8);\n}",
            "called": [
                "wireRead",
                "wireWrite",
                "requestFrom",
                "sendString",
                "beginTransmission",
                "endTransmission",
                "available",
                "sendSysex"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001c18",
            "calling": [
                "sysexCallback",
                "loop"
            ],
            "imported": false,
            "current_name": "readI2CDataFromAddress_08001c18"
        },
        "FUN_08009056": {
            "renaming": {
                "FUN_08009056": "handle_gpio_interrupts_08009056",
                "uVar1": "i",
                "HAL_GPIO_EXTI_IRQHandler": "handle_exti_interrupt",
                "uint16_t": "uint",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void handle_gpio_interrupts_08009056(void)\n{\n  uint16_t gpio_pin;\n\n  for (uint16_t i = 0x20; i < 0x201; i <<= 1) {\n    gpio_pin = (uint16_t)i;\n    HAL_GPIO_EXTI_IRQHandler(gpio_pin);\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009056",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_interrupts_08009056"
        },
        "FUN_08002e1a": {
            "renaming": {
                "FUN_08002e1a": "printFirmwareVersionIfContextIsNotNull_08002e1a",
                "param_2": "sizeOfParam2",
                "param_3": "sizeOfParam3",
                "param_4": "firmwareVersion",
                "context": "context"
            },
            "code": "void printFirmwareVersionIfContextIsNotNull_08002e1a(void *context, size_t sizeOfParam2, size_t sizeOfParam3, char *firmwareVersion) {\n  if (context != nullptr) {\n    printFirmwareVersion((FirmataClass *)context);\n    return;\n  }\n  return;\n}",
            "called": [
                "printFirmwareVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002e1a",
            "calling": [],
            "imported": false,
            "current_name": "printFirmwareVersionIfContextIsNotNull_08002e1a"
        },
        "FUN_0800904c": {
            "renaming": {
                "FUN_0800904c": "handle_GPIO_EXTI_interrupt_0800904c",
                "PTR_": "",
                "DAT_": "",
                "HAL_GPIO_EXTI_IRQHandler": "",
                "0x10": "GPIO_PIN_4"
            },
            "code": "DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_ handle_GPIO_EXTI_interrupt_0800904c(DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_{DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_HDAT_PDAT_TDAT_RDAT__DAT_ADAT_PDAT_TDAT_RDAT__DAT_LDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_GDAT_PDAT_TDAT_RDAT__DAT_PDAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT_ODAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_EDAT_PDAT_TDAT_RDAT__DAT_XDAT_PDAT_TDAT_RDAT__DAT_TDAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT_RDAT_PDAT_TDAT_RDAT__DAT_QDAT_PDAT_TDAT_RDAT__DAT_HDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_GDAT_PDAT_TDAT_RDAT__DAT_PDAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT_ODAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_PDAT_PDAT_TDAT_RDAT__DAT_IDAT_PDAT_TDAT_RDAT__DAT_NDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_4DAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_}DAT_PDAT_TDAT_RDAT__DAT_",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800904c",
            "calling": [],
            "imported": false,
            "current_name": "handle_GPIO_EXTI_interrupt_0800904c"
        },
        "FUN_080073ae": {
            "renaming": {
                "FUN_080073ae": "compare_pointers_080073ae",
                "a": "ptr1",
                "b": "ptr2"
            },
            "code": "void * compare_pointers_080073ae(void *ptr1, void *ptr2)\n{\n  if (ptr1 != ptr2) {\n    if (ptr1 == NULL) {\n      return ptr2;\n    }\n    if (ptr2 == NULL) {\n      return ptr1;\n    }\n    ptr1 = NULL;\n  }\n  return ptr1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073ae",
            "calling": [
                "i2c_custom_init",
                "uart_init"
            ],
            "imported": false,
            "current_name": "compare_pointers_080073ae"
        },
        "FUN_08003f0c": {
            "renaming": {
                "FUN_08003f0c": "setPriorityGroup_08003f0c",
                "PriorityGroup": "priorityGroup",
                "DAT_08003f2c": "priorityRegisterBase",
                "priorityMask": "priorityMask",
                "priorityValue": "priorityValue",
                "*PTR_DAT_08003f2c": "*priorityRegister"
            },
            "code": "void setPriorityGroup_08003f0c(uint32_t priorityGroup)\n{\n  uint32_t* priorityRegister = (uint32_t*)(DAT_08003f2c + 0xc);\n  uint32_t priorityMask = *(uint32_t*)(DAT_08003f2c + 0xc) & 0xf8ff;\n  uint32_t priorityValue = (priorityGroup & 7) << 8 | priorityMask | 0x5fa0000;\n  *PTR_DAT_08003f2c = priorityValue;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f0c",
            "calling": [
                "HAL_Init",
                "premain"
            ],
            "imported": false,
            "current_name": "setPriorityGroup_08003f0c"
        },
        "FUN_08000488": {
            "renaming": {
                "FUN_08000488": "reportAnalogInput_08000488",
                "analogPin": "pin",
                "value": "value",
                "ulPin": "mappedPin",
                "PTR_analogInputsToReport_080004c8": "analogInputsToReportPtr",
                "value_00": "analogValue",
                "PTR_isResetting_080004cc": "isResettingPtr",
                "PTR_Firmata_080004d0": "FirmataPtr"
            },
            "code": "void reportAnalogInput_08000488(uint8_t pin, int value) {\n  uint8_t mappedPin = (uint8_t)pin;\n  if (mappedPin < 14) {\n    if (value == 0) {\n      *(uint32_t *)PTR_analogInputsToReport_080004c8 &= ~(1 << mappedPin);\n      return;\n    }\n    *(uint32_t *)PTR_analogInputsToReport_080004c8 |= (1 << mappedPin);\n    if (!isResetting) {\n      uint32_t analogValue = analogRead(mappedPin);\n      Firmata.sendAnalog(pin, analogValue);\n      return;\n    }\n  }\n  return;\n}",
            "called": [
                "sendAnalog",
                "analogRead"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000488",
            "calling": [
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "reportAnalogInput_08000488"
        },
        "FUN_08006bb8": {
            "renaming": {
                "FUN_08006bb8": "get_GPIO_08006bb8",
                "port_idx": "port_index",
                "pGVar1": "gpio",
                "tmpreg": "unused_tmpreg_1",
                "tmpreg_1": "unused_tmpreg_2",
                "tmpreg_2": "unused_tmpreg_3",
                "tmpreg_3": "unused_tmpreg_4",
                "tmpreg_4": "unused_tmpreg_5",
                "DAT_08006c48": "GPIO_BASE_ADDRESS",
                "DAT_08006c4c": "GPIOA_BASE_ADDRESS",
                "DAT_08006c50": "GPIOB_BASE_ADDRESS",
                "DAT_08006c54": "GPIOC_BASE_ADDRESS",
                "DAT_08006c58": "GPIOD_BASE_ADDRESS",
                "DAT_08006c5c": "GPIOE_BASE_ADDRESS"
            },
            "code": "GPIO_TypeDef* get_GPIO_08006bb8(uint32_t port_idx)\n{\n  GPIO_TypeDef* gpio;\n  uint32_t GPIO_CR_OFFSET = 0x18;\n  uint32_t GPIO_CR_MASK = 0x3C;\n  uint32_t GPIO_CR_SET = (1 << port_idx) << 2;\n  uint32_t* GPIO_CR = (uint32_t*)(DAT_08006c48 + GPIO_CR_OFFSET);\n  *GPIO_CR |= GPIO_CR_SET;\n  switch(port_idx) {\n    case 0:\n      gpio = DAT_08006c4c;\n      break;\n    case 1:\n      gpio = DAT_08006c50;\n      break;\n    case 2:\n      gpio = DAT_08006c54;\n      break;\n    case 3:\n      gpio = DAT_08006c58;\n      break;\n    case 4:\n      gpio = DAT_08006c5c;\n      break;\n    default:\n      gpio = (GPIO_TypeDef*)0x0;\n  }\n  return gpio;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006bb8",
            "calling": [
                "i2c_custom_init",
                "HAL_ADC_MspInit",
                "digital_io_init",
                "uart_init",
                "HAL_TIM_PWM_MspInit"
            ],
            "imported": false,
            "current_name": "get_GPIO_08006bb8"
        },
        "FUN_08004aec": {
            "renaming": {
                "FUN_08004aec": "handle_i2c_conflict_08004aec",
                "hi2c": "i2c_handle",
                "XferOptions": "transfer_options",
                "State": "state",
                "PreviousState": "previous_state",
                "Instance": "instance",
                "CR2": "control_register_2",
                "SR1": "status_register_1",
                "CR1": "control_register_1",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_STATE_LISTEN",
                "HAL_I2C_STATE_BUSY_TX": "HAL_I2C_STATE_BUSY_TX",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NONE",
                "I2C_TRANSFER_OPTIONS_SLAVE_RECEIVER": "I2C_TRANSFER_OPTIONS_SLAVE_RECEIVER",
                "I2C_TRANSFER_OPTIONS_SLAVE_TRANSMITTER": "I2C_TRANSFER_OPTIONS_SLAVE_TRANSMITTER",
                "HAL_I2C_ListenCpltCallback": "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveTxCpltCallback": "HAL_I2C_SlaveTxCpltCallback"
            },
            "code": "HAL_StatusTypeDef handle_i2c_conflict_08004aec(I2C_HandleTypeDef *i2c_handle) {\n  if (((i2c_handle->transfer_options == I2C_TRANSFER_OPTIONS_SLAVE_RECEIVER) || (i2c_handle->transfer_options == I2C_TRANSFER_OPTIONS_SLAVE_TRANSMITTER)) && (i2c_handle->state == HAL_I2C_STATE_LISTEN)) {\n    i2c_handle->transfer_options = DAT_08004b7c;\n    i2c_handle->instance->CR2 = i2c_handle->instance->CR2 & 0xfffff8ff;\n    i2c_handle->instance->SR1 = 0xfffffbff;\n    i2c_handle->instance->CR1 = i2c_handle->instance->CR1 & 0xfffffbff;\n    i2c_handle->previous_state = 0;\n    i2c_handle->state = HAL_I2C_STATE_READY;\n    i2c_handle->mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2c_handle);\n  }\n  else if (i2c_handle->state == HAL_I2C_STATE_BUSY_TX) {\n    i2c_handle->transfer_options = DAT_08004b7c;\n    i2c_handle->previous_state = 0x21;\n    i2c_handle->state = HAL_I2C_STATE_READY;\n    i2c_handle->mode = HAL_I2C_MODE_NONE;\n    i2c_handle->instance->CR2 = i2c_handle->instance->CR2 & 0xfffff8ff;\n    i2c_handle->instance->SR1 = 0xfffffbff;\n    i2c_handle->instance->CR1 = i2c_handle->instance->CR1 & 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback(i2c_handle);\n  }\n  else {\n    i2c_handle->instance->SR1 = 0xfffffbff;\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_SlaveTxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004aec",
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_i2c_conflict_08004aec"
        },
        "FUN_08007ede": {
            "renaming": {
                "FUN_08007ede": "transferData_08007ede",
                "obj": "i2c_object",
                "data": "data_buffer",
                "size": "data_size",
                "uVar1": "index"
            },
            "code": "i2c_status_e transferData_08007ede(i2c_t_conflict *i2c_object, uint8_t *data_buffer, uint16_t data_size) {\n  uint16_t index;\n  if (data_size > 32) {\n    return I2C_ERROR;\n  }\n  for (index = 0; index < data_size; index++) {\n    i2c_object->i2cTxRxBuffer[index] = data_buffer[index];\n    i2c_object->i2cTxRxBufferSize++;\n  }\n  return I2C_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007ede",
            "calling": [
                "write",
                "write"
            ],
            "imported": false,
            "current_name": "transferData_08007ede"
        },
        "FUN_08004728": {
            "renaming": {
                "FUN_08004728": "i2c_transfer_08004728",
                "hi2c": "handle",
                "DevAddress": "address",
                "pData": "data",
                "Size": "size",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "I2C_TypeDef_conflict": "I2C_TypeDef",
                "HVar1": "status",
                "pIVar2": "instance",
                "count": "count",
                "transfer_timeout_cycles": "transfer_timeout_cycles",
                "PTR_SystemCoreClock_080047e8": "SystemCoreClock_ptr",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_TIMEOUT": "HAL_TIMEOUT",
                "HAL_LOCKED": "HAL_LOCKED",
                "HAL_I2C_STATE_BUSY_TX": "HAL_I2C_STATE_BUSY_TX",
                "HAL_I2C_MODE_MASTER": "HAL_I2C_MODE_MASTER",
                "HAL_OK": "HAL_OK",
                "transfer_options": "transfer_options",
                "handle->PreviousState": "handle->PreviousState",
                "handle->Instance": "handle->Instance",
                "instance->SR2": "instance->SR2",
                "handle->Lock": "handle->Lock",
                "instance->CR1": "instance->CR1",
                "handle->State": "handle->State",
                "handle->ErrorCode": "handle->ErrorCode",
                "handle->pBuffPtr": "handle->pBuffPtr",
                "handle->XferCount": "handle->XferCount",
                "handle->XferOptions": "handle->XferOptions",
                "handle->XferSize": "handle->XferSize",
                "handle->Devaddress": "handle->Devaddress",
                "instance->CR2": "instance->CR2"
            },
            "code": "HAL_StatusTypeDef i2c_transfer_08004728(I2C_HandleTypeDef *handle, uint16_t address, uint8_t *data, uint16_t size)\n{\n  HAL_StatusTypeDef status;\n  I2C_TypeDef *instance;\n  uint32_t count;\n  \n  if (handle->State == HAL_I2C_STATE_READY) {\n    count = (uint)((ulonglong)transfer_timeout_cycles * (ulonglong)(*(uint *)PTR_SystemCoreClock_080047e8 >> 3)\n                  >> 0x28) * 0x19;\n    do {\n      if (count == 0) {\n        handle->PreviousState = 0;\n        handle->State = HAL_I2C_STATE_READY;\n        handle->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      instance = handle->Instance;\n      count = count - 1;\n    } while ((instance->SR2 & 2) != 0);\n    if (handle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      handle->Lock = HAL_LOCKED;\n      if ((instance->CR1 & 1) == 0) {\n        instance->CR1 = instance->CR1 | 1;\n      }\n      handle->Instance->CR1 = handle->Instance->CR1 & 0xfffff7ff;\n      handle->State = HAL_I2C_STATE_BUSY_TX;\n      handle->Mode = HAL_I2C_MODE_MASTER;\n      status = HAL_OK;\n      handle->ErrorCode = 0;\n      handle->pBuffPtr = data;\n      handle->XferCount = size;\n      handle->XferOptions = transfer_options;\n      handle->XferSize = handle->XferCount;\n      handle->Devaddress = (uint)address;\n      handle->Instance->CR1 = handle->Instance->CR1 | 0x100;\n      handle->Lock = HAL_UNLOCKED;\n      handle->Instance->CR2 = handle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004728",
            "calling": [
                "i2c_master_write"
            ],
            "imported": false,
            "current_name": "i2c_transfer_08004728"
        },
        "FUN_080074e0": {
            "renaming": {
                "FUN_080074e0": "set_timer_interrupts_080074e0",
                "htim": "timer_handle",
                "Instance": "timer_instance",
                "DAT_08007534": "timer1",
                "DAT_08007538": "timer3",
                "DAT_0800753c": "timer4",
                "(TIM_TypeDef_conflict *)0x40000000": "timer2",
                "*(uint *)(DAT_08007540 + 0x18)": "*(uint32_t *)(interrupt_base_address + 0x18)",
                "*(uint *)(DAT_08007540 + 0x1c)": "*(uint32_t *)(interrupt_base_address + 0x1c)"
            },
            "code": "void set_timer_interrupts_080074e0(TIM_HandleTypeDef_conflict *timer_handle) {\n  if (timer_handle->Instance == DAT_08007534) {\n    uint32_t *interrupt_register = (uint32_t *)(interrupt_base_address + 0x18);\n    *interrupt_register &= ~(1 << 11);\n  }\n  if (timer_handle->Instance == timer2) {\n    uint32_t *interrupt_register = (uint32_t *)(interrupt_base_address + 0x1c);\n    *interrupt_register &= ~(1 << 0);\n  }\n  if (timer_handle->Instance == DAT_08007538) {\n    uint32_t *interrupt_register = (uint32_t *)(interrupt_base_address + 0x1c);\n    *interrupt_register &= ~(1 << 1);\n  }\n  if (timer_handle->Instance == DAT_0800753c) {\n    uint32_t *interrupt_register = (uint32_t *)(interrupt_base_address + 0x1c);\n    *interrupt_register &= ~(1 << 2);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080074e0",
            "calling": [
                "HAL_TIM_PWM_MspDeInit",
                "HAL_TIM_OC_MspDeInit"
            ],
            "imported": false,
            "current_name": "set_timer_interrupts_080074e0"
        },
        "FUN_080073c0": {
            "renaming": {
                "FUN_080073c0": "execute_RTC_user_callback_080073c0",
                "hrtc": "rtc_handle",
                "PTR_RTCUserCallback_080073d0": "RTC_user_callback_ptr",
                "PTR_callbackUserData_080073d4": "RTC_callback_user_data_ptr"
            },
            "code": "void execute_RTC_user_callback_080073c0(RTC_HandleTypeDef *rtc_handle)\n{\n  code *user_callback = *(code **)PTR_RTCUserCallback_080073d0;\n  if (user_callback != NULL) {\n    (*user_callback)(*(uint32_t *)PTR_callbackUserData_080073d4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073c0",
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "imported": false,
            "current_name": "execute_RTC_user_callback_080073c0"
        },
        "FUN_080084b0": {
            "renaming": {
                "FUN_080084b0": "initialize_uart_debug_080084b0",
                "pin": "pin_name",
                "obj": "serial_debug",
                "PVar1": "uart_rx_pin",
                "pvVar2": "peripheral"
            },
            "code": "void initialize_uart_debug_080084b0(void)\n{\n  PinName_conflict pin_name = PTR_digitalPin_080084f0[1];\n  void *peripheral = pinmap_peripheral(pin_name, (PinMap_conflict *)PTR_PinMap_UART_TX_080084f4);\n  if (peripheral != (void *)0x0) {\n    void *uart_tx_pin = pinmap_peripheral(pin_name, (PinMap_conflict *)PTR_PinMap_UART_TX_080084f4);\n    PinName_conflict uart_rx_pin = pinmap_pin(uart_tx_pin, (PinMap_conflict *)PTR_PinMap_UART_RX_080084f8);\n    undefined *serial_debug = PTR_serial_debug_080084fc;\n    serial_debug[0x59] = uart_rx_pin;\n    serial_debug[0x58] = pin_name;\n    *(undefined4 *)(serial_debug + 0x48) = 0x2580;\n    *(undefined4 *)(serial_debug + 0x54) = 0;\n    *(undefined4 *)(serial_debug + 0x4c) = 0;\n    *(undefined4 *)(serial_debug + 0x50) = 0;\n    uart_init((serial_t *)serial_debug);\n  }\n  return;\n}",
            "called": [
                "pinmap_pin",
                "uart_init",
                "pinmap_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080084b0",
            "calling": [
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "initialize_uart_debug_080084b0"
        },
        "FUN_080095a8": {
            "renaming": {
                "FUN_080095a8": "decode_and_print_string_080095a8",
                "param_1": "input",
                "param_2": "string_info",
                "param_3": "output_length",
                "param_4": "param_4",
                "param_5": "output_function",
                "uVar2": "max_length",
                "uVar3": "padding_length",
                "bVar4": "has_no_padding",
                "iVar1": "i",
                "padding": "padding_offset",
                "has_padding": "has_padding"
            },
            "code": "undefined4 decode_and_print_string_080095a8(undefined4 input, uint *string_info, uint *output_length, undefined4 param_4, code *output_function)\n{\n  int i;\n  uint max_length = string_info[4];\n  if ((int)string_info[4] < (int)string_info[2]) {\n    max_length = string_info[2];\n  }\n  *output_length = max_length;\n  if (*(char *)((int)string_info + 0x43) != '\\0') {\n    *output_length = max_length + 1;\n  }\n  if ((int)(*string_info << 0x1a) < 0) {\n    *output_length += 2;\n  }\n  uint padding = *string_info & 6;\n  if (padding == 0) {\n    for (; (int)padding < (int)(string_info[3] - *output_length); padding++) {\n      i = (*output_function)(input, param_4, (int)string_info + 0x19, 1);\n      if (i == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  uint has_padding = (uint)*(byte *)((int)string_info + 0x43);\n  if (has_padding != 0) {\n    has_padding = 1;\n  }\n  uint padding_length = has_padding;\n  if ((int)(*string_info << 0x1a) < 0) {\n    *(undefined *)((int)string_info + has_padding + 0x43) = 0x30;\n    padding_length = has_padding + 2;\n    *(undefined *)((int)string_info + has_padding + 0x44) = *(undefined *)((int)string_info + 0x45);\n  }\n  i = (*output_function)(input, param_4, (int)string_info + 0x43, padding_length);\n  if (i != -1) {\n    uint remaining_length = string_info[3];\n    bool has_no_padding = (*string_info & 6) != 4;\n    if (has_no_padding) {\n      remaining_length = 0;\n    }\n    uint padding_offset = 0;\n    if (!has_no_padding) {\n      remaining_length = remaining_length - *output_length;\n    }\n    if (!has_no_padding) {\n      remaining_length = remaining_length & ~((int)remaining_length >> 0x1f);\n    }\n    if ((int)string_info[4] < (int)string_info[2]) {\n      remaining_length = remaining_length + (string_info[2] - string_info[4]);\n    }\n    while (true) {\n      if (remaining_length == padding_offset) {\n        return 0;\n      }\n      i = (*output_function)(input, param_4, (int)string_info + 0x1a, 1);\n      if (i == -1) {\n        break;\n      }\n      padding_offset++;\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080095a8",
            "calling": [
                "_printf_i"
            ],
            "imported": false,
            "current_name": "decode_and_print_string_080095a8"
        },
        "FUN_08008b2a": {
            "renaming": {
                "FUN_08008b2a": "readByte_08008b2a",
                "this": "serial",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "bVar1": "byteRead",
                "uVar2": "tailIndex"
            },
            "code": "ssize_t __thiscall readByte_08008b2a(HardwareSerial *serial, int fileDescriptor, void *buffer, size_t numBytes) {\n  byte byteRead;\n  ushort tailIndex;\n  tailIndex = (serial->_serial).rx_tail;\n  if ((uint)(serial->_serial).rx_head != (uint)tailIndex) {\n    byteRead = (serial->_serial).rx_buff[tailIndex];\n    (serial->_serial).rx_tail = tailIndex + 1 & 0x3f;\n    return (uint)byteRead;\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b2a",
            "calling": [],
            "imported": false,
            "current_name": "readByte_08008b2a"
        },
        "FUN_08003bd8": {
            "renaming": {
                "FUN_08003bd8": "configure_ADC_08003bd8",
                "hadc": "adc",
                "HVar1": "status",
                "uVar2": "scan_conv_mode",
                "uVar3": "data_align_external_trig_conv_continuous_conv_mode",
                "uVar4": "state_flags",
                "uVar5": "continuous_conv_mode",
                "DAT_08003ce0": "cr2_flags_mask",
                "DAT_08003ce4": "cr2_flags_mask2"
            },
            "code": "HAL_StatusTypeDef_conflict configure_ADC_08003bd8(ADC_HandleTypeDef *adc)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t state_flags;\n  uint32_t cr1_flags;\n  uint32_t cr2_flags;\n  uint32_t sqr1_flags;\n  uint32_t continuous_conv_mode;\n  uint32_t data_align;\n  uint32_t external_trig_conv;\n  uint32_t scan_conv_mode;\n  uint32_t nbr_of_disc_conversion;\n  uint32_t nbr_of_conversion;\n\n  if (adc == NULL) {\n    return HAL_ERROR;\n  }\n\n  if (adc->State == 0) {\n    adc->ErrorCode = 0;\n    adc->Lock = HAL_UNLOCKED;\n    HAL_ADC_MspInit(adc);\n  }\n\n  status = ADC_ConversionStop_Disable(adc);\n  state_flags = adc->State & 0x10;\n\n  if ((state_flags == 0) && (status == HAL_OK)) {\n    adc->State = adc->State & 0xffffeefd | 2;\n    continuous_conv_mode = (adc->Init).ContinuousConvMode;\n    data_align = (adc->Init).DataAlign;\n    external_trig_conv = (adc->Init).ExternalTrigConv;\n    scan_conv_mode = (adc->Init).ScanConvMode;\n    nbr_of_disc_conversion = (adc->Init).NbrOfDiscConversion;\n    nbr_of_conversion = (adc->Init).NbrOfConversion;\n\n    if (scan_conv_mode == 0x100 || scan_conv_mode == 1) {\n      cr2_flags = 0x100;\n    }\n    else {\n      cr2_flags = 0;\n    }\n\n    if ((adc->Init).DiscontinuousConvMode == 1) {\n      if (continuous_conv_mode == 0) {\n        cr2_flags |= (nbr_of_disc_conversion - 1) * 0x2000 | 0x800;\n      }\n      else {\n        adc->State |= 0x20;\n        adc->ErrorCode |= 1;\n      }\n    }\n\n    cr1_flags = cr2_flags | (adc->Instance->CR1 & 0xffff16ff);\n    cr2_flags = (data_align | external_trig_conv | continuous_conv_mode << 1) & DAT_08003ce0 | (adc->Instance->CR2 & ~DAT_08003ce0);\n    sqr1_flags = ((nbr_of_conversion - 1) * 0x100000) | (adc->Instance->SQR1 & 0xff0fffff);\n\n    if (cr2_flags != (DAT_08003ce4 & adc->Instance->CR2)) {\n      adc->State = adc->State & 0xffffffed | 0x10;\n      adc->ErrorCode |= 1;\n      return HAL_ERROR;\n    }\n\n    adc->ErrorCode = 0;\n    adc->State = adc->State & 0xfffffffc | 1;\n    adc->Instance->CR1 = cr1_flags;\n    adc->Instance->CR2 = cr2_flags;\n    adc->Instance->SQR1 = sqr1_flags;\n    return HAL_OK;\n  }\n\n  adc->State |= 0x10;\n  return HAL_ERROR;\n}",
            "called": [
                "HAL_ADC_MspInit",
                "ADC_ConversionStop_Disable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003bd8",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "configure_ADC_08003bd8"
        },
        "FUN_08009d50": {
            "renaming": {
                "FUN_08009d50": "initialize_08009d50",
                "param_1": "param",
                "uVar1": "float1",
                "iVar2": "global_impure_ptr",
                "bVar3": "is_global_impure_ptr"
            },
            "code": "void initialize_08009d50(int param){\n    undefined4 float1;\n    int global_impure_ptr = *(int *)PTR__global_impure_ptr_08009da8;\n    bool is_global_impure_ptr = param == global_impure_ptr;\n\n    if (*(int *)(param + 0x18) == 0) {\n        *(undefined4 *)(param + 0x48) = 0;\n        *(undefined4 *)(param + 0x4c) = 0;\n        *(undefined4 *)(param + 0x50) = 0;\n        \n        *(undefined4 *)(param + 0x28) = DAT_08009dac;\n        \n        if (is_global_impure_ptr) {\n            global_impure_ptr = 1;\n        }\n        \n        if (is_global_impure_ptr) {\n            *(int *)(param + 0x18) = global_impure_ptr;\n        }\n        \n        float1 = __sfp();\n        *(undefined4 *)(param + 4) = float1;\n        float1 = __sfp(param);\n        *(undefined4 *)(param + 8) = float1;\n        float1 = __sfp(param);\n        *(undefined4 *)(param + 0xc) = float1;\n        \n        std_isra_0(*(undefined4 *)(param + 4), 4, 0);\n        std_isra_0(*(undefined4 *)(param + 8), 9, 1);\n        std_isra_0(*(undefined4 *)(param + 0xc), 0x12, 2);\n        \n        *(undefined4 *)(param + 0x18) = 1;\n    }\n}",
            "called": [
                "__sfp",
                "std.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009d50",
            "calling": [
                "iprintf",
                "__swsetup_r",
                "__swbuf_r",
                "__sfp",
                "_vfiprintf_r",
                "_fflush_r"
            ],
            "imported": false,
            "current_name": "initialize_08009d50"
        },
        "FUN_08009108": {
            "renaming": {
                "FUN_08009108": "get_result_if_not_initialized_08009108",
                "param_1": "value",
                "param_2": "initialized_value",
                "DAT_08009120": "initialized_value_check"
            },
            "code": "unsigned long long get_result_if_not_initialized_08009108(uint32_t value, uint64_t initialized_value)\n{\n  if (initialized_value != 0) {\n    return ((uint64_t) value << 32) | value;\n  }\n  return ((uint64_t) 2 << 32) | 2;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009108",
            "calling": [
                "__aeabi_atexit"
            ],
            "imported": false,
            "current_name": "get_result_if_not_initialized_08009108"
        },
        "FUN_08009f98": {
            "renaming": {
                "FUN_08009f98": "process_handler_08009f98",
                "param_1": "status",
                "param_2": "signal",
                "param_3": "pid",
                "param_4": "param_4",
                "_Var1": "process_id",
                "uVar2": "result",
                "iVar3": "handler_ptr",
                "pcVar4": "handler_function"
            },
            "code": "int process_handler_08009f98(int *status, uint32_t signal, int pid, uint32_t param_4)\n{\n  __pid_t process_id;\n  int result;\n  code *handler_function;\n  \n  if (signal > 31) {\n    *status = 22;\n    return -1;\n  }\n  handler_function = (code *)(status[17] + signal * 4);\n  if ((handler_function != (code *)0) && (handler_function != (code *)1)) {\n    if (handler_function == (code *)(-1)) {\n      *status = 22;\n      return 1;\n    }\n    *(undefined4 *)(status[17] + signal * 4) = 0;\n    (*handler_function)(signal);\n  }\n  process_id = _getpid_r();\n  result = _kill_r(status, process_id, signal, param_4);\n  return result;\n}",
            "called": [
                "_getpid_r",
                "_kill_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f98",
            "calling": [
                "raise"
            ],
            "imported": false,
            "current_name": "process_handler_08009f98"
        },
        "FUN_0800a18c": {
            "renaming": {
                "std::FUN_0800a18c": "abort_program",
                "FUN_0800a18c": "abort_program_0800a18c"
            },
            "code": "/* This function aborts the program */\nvoid abort_program_0800a18c(void)\n{\n    abort();\n}",
            "called": [
                "abort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a18c",
            "calling": [
                "operator()"
            ],
            "imported": false,
            "current_name": "abort_program_0800a18c"
        },
        "FUN_08008a24": {
            "renaming": {
                "FUN_08008a24": "write_to_digital_pin_08008a24",
                "ulPin": "pin_number",
                "ulVal": "pin_value",
                "_Var1": "is_pin_configured_flag",
                "port": "gpio_port",
                "uVar2": "pin_index",
                "PTR_digitalPin_08008a64": "digital_pin_lookup_table",
                "PTR_g_digPinConfigured_08008a68": "digital_pin_configured_flag_array"
            },
            "code": "void write_to_digital_pin_08008a24(uint32_t pin_number, uint32_t pin_value) {\n  bool is_pin_configured_flag;\n  GPIO_TypeDef *gpio_port;\n  uint32_t pin_index;\n  if (pin_number < 60) {\n    pin_index = PTR_digitalPin_08008a64[pin_number];\n  }\n  else {\n    pin_index = 0xffffffff;\n  }\n  if ((pin_index != 0xffffffff) && (is_pin_configured_flag = is_pin_configured((PinName_conflict)pin_index, (uint32_t *)PTR_g_digPinConfigured_08008a68), is_pin_configured_flag)) {\n    gpio_port = get_gpio_port((pin_index << 0x18) >> 0x1c);\n    digital_io_write(gpio_port, 1 << (pin_index & 0xf) & 0xffff, pin_value);\n  }\n  return;\n}",
            "called": [
                "is_pin_configured",
                "get_GPIO_Port",
                "digital_io_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a24",
            "calling": [
                "analogWrite",
                "setPinValueCallback",
                "digitalWriteCallback",
                "strobeBlinkPin",
                "ServoIrqHandle",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "write_to_digital_pin_08008a24"
        },
        "FUN_08008020": {
            "renaming": {
                "FUN_08008020": "enable_i2c_listen_interrupt_08008020",
                "hi2c": "i2c_handle",
                "piVar1": "i2c_obj",
                "isMaster": "is_master"
            },
            "code": "void enable_i2c_listen_interrupt_08008020(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  i2c_t_conflict *i2c_obj = get_i2c_object(i2c_handle);\n  if (i2c_obj->is_master == false) {\n    HAL_I2C_EnableListen_IT(i2c_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008020",
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "imported": false,
            "current_name": "enable_i2c_listen_interrupt_08008020"
        },
        "FUN_08005dac": {
            "renaming": {
                "FUN_08005dac": "configure_timer_08005dac",
                "TIMx": "timer",
                "OC_Config": "output_channel_config",
                "uVar1": "control_register_1",
                "uVar2": "output_mode",
                "uVar3": "output_polarity"
            },
            "code": "void configure_timer_08005dac(TIM_TypeDef_conflict *timer, TIM_OC_InitTypeDef *output_channel_config)\n{\n  uint32_t control_register_1;\n  uint32_t output_mode;\n  uint32_t output_polarity;\n  \n  timer->CCER = timer->CCER & 0xffffefff;\n  control_register_1 = timer->CR2;\n  output_mode = output_channel_config->OCMode;\n  output_polarity = output_channel_config->OCPolarity;\n  if (timer == PTR_08005df0) {\n    control_register_1 = control_register_1 & 0xffffbfff | output_channel_config->OCIdleState << 6;\n  }\n  timer->CR2 = control_register_1;\n  timer->CCMR2 = timer->CCMR2 & 0xffff8cff | output_mode << 8;\n  timer->CCR4 = output_channel_config->Pulse;\n  timer->CCER = timer->CCER & 0xffffdfff | output_polarity << 0xc;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005dac",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_08005dac"
        },
        "FUN_080066e8": {
            "renaming": {
                "FUN_080066e8": "check_flag_status_080066e8",
                "huart": "uart",
                "Flag": "flag",
                "Status": "status",
                "Tickstart": "tickstart",
                "Timeout": "timeout",
                "uVar1": "current_tick"
            },
            "code": "HAL_StatusTypeDef check_flag_status_080066e8(UART_HandleTypeDef *uart, uint32_t flag, FlagStatus status, uint32_t tickstart, uint32_t timeout)\n{\n  uint32_t current_tick;\n  do {\n    bool flag_condition = ((flag & ~uart->Instance->SR) == 0);\n    bool status_condition = (status == SET);\n    if (flag_condition != status_condition) {\n      return HAL_OK;\n    }\n  } while ((timeout == HAL_MAX_DELAY) || ((timeout != 0) && ((current_tick = HAL_GetTick()) - tickstart <= timeout)));\n  uart->Instance->CR1 &= 0xfffffe5f;\n  uart->Instance->CR3 &= 0xfffffffe;\n  uart->gState = HAL_UART_STATE_READY;\n  uart->RxState = HAL_UART_STATE_READY;\n  uart->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080066e8",
            "calling": [
                "HAL_UART_Transmit"
            ],
            "imported": false,
            "current_name": "check_flag_status_080066e8"
        },
        "FUN_08009358": {
            "renaming": {
                "FUN_08009358": "write_to_stream_08009358",
                "param_1": "file_descriptor",
                "param_2": "flags",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "puVar2": "buffer_end",
                "iVar1": "write_result",
                "iVar3": "bytes_written"
            },
            "code": "int write_to_stream_08009358(int file_descriptor, int flags, char *buffer, int buffer_size)\n{\n  int bytes_written = 0;\n  char *buffer_end = buffer + buffer_size;\n  while (bytes_written != buffer_size) {\n    if (buffer == buffer_end) {\n      return 0;\n    }\n    int write_result = __sfputc_r(file_descriptor, *buffer, flags, buffer_size, bytes_written);\n    bytes_written = write_result + 1;\n    buffer++;\n  }\n  return write_result;\n}",
            "called": [
                "__sfputc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009358",
            "calling": [
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "write_to_stream_08009358"
        },
        "FUN_0800270c": {
            "renaming": {
                "FUN_0800270c": "calculateBufferLengthDifference_0800270c",
                "this": "wire",
                "PTR_rxBufferLength_08002718": "rxBufferLength",
                "PTR_rxBufferIndex_0800271c": "rxBufferIndex"
            },
            "code": "int calculateBufferLengthDifference_0800270c(TwoWire *wire) {\n  int PTR_rxBufferLength_08002718 = *PTR_PTR_rxBufferLength_08002718_08002718;\n  int PTR_rxBufferIndex_0800271c = *PTR_PTR_rxBufferIndex_0800271c_0800271c;\n  return (uint)(byte)PTR_rxBufferLength_08002718 - (uint)(byte)PTR_rxBufferIndex_0800271c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800270c",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "calculateBufferLengthDifference_0800270c"
        },
        "FUN_08007fa0": {
            "renaming": {
                "FUN_08007fa0": "i2c_transfer_08007fa0",
                "hi2c": "handle",
                "TransferDirection": "direction",
                "AddrMatchCode": "address",
                "piVar1": "i2c",
                "get_i2c_obj": "get_i2c_object",
                "i2cTxRxBufferSize": "buffer_size",
                "slaveMode": "slave_mode",
                "i2c_onSlaveTransmit": "on_slave_transmit",
                "i2cTxRxBuffer": "buffer",
                "HAL_I2C_Slave_Sequential_Transmit_IT": "HAL_I2C_Slave_Sequential_Transmit_IT",
                "(ushort)": "(ushort)",
                "HAL_I2C_Slave_Sequential_Receive_IT": "HAL_I2C_Slave_Sequential_Receive_IT"
            },
            "code": "void i2c_transfer_08007fa0(I2C_HandleTypeDef_conflict *handle, uint8_t direction, uint16_t address) {\\n  i2c_t_conflict *i2c = get_i2c_object(handle);\\n  if ((uint)address == (handle->Init).OwnAddress1) {\\n    if (direction == \"\\0\") {\\n      i2c->buffer_size = \"\\0\";\\n      i2c->slave_mode = \"\\0\";\\n      if (i2c->on_slave_transmit != (_func_void *)0x0) {\\n        (*i2c->on_slave_transmit)();\\n      }\\n      HAL_I2C_Slave_Sequential_Transmit_IT\\n                (handle,i2c->buffer,(ushort)i2c->buffer_size,8);\\n      return;\\n    }\\n    i2c->slave_mode = \"\\x01\";\\n    HAL_I2C_Slave_Sequential_Receive_IT(handle,i2c->buffer,0x20,8);\\n  }\\n  return;\\n}",
            "called": [
                "HAL_I2C_Slave_Sequential_Transmit_IT",
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "get_i2c_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007fa0",
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "imported": false,
            "current_name": "i2c_transfer_08007fa0"
        },
        "FUN_08002720": {
            "renaming": {
                "FUN_08002720": "read_08002720",
                "this": "wire",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "bVar1": "rxBufferIndex",
                "bVar2": "data",
                "PTR_rxBufferIndex_08002740": "rxBufferIndexPtr",
                "PTR_rxBufferLength_08002744": "rxBufferLengthPtr",
                "*(byte *)(*(int *)PTR_rxBuffer_08002748 + (uint)bVar1)": "*(byte *)(*(int *)rxBufferPtr + (uint)rxBufferIndex)"
            },
            "code": "ssize_t __thiscall read_08002720(TwoWire *wire,int fileDescriptor,void *buffer,size_t numBytes)\n{\n  byte rxBufferIndex = *PTR_rxBufferIndex_08002740;\n  if ((uint)rxBufferIndex < (uint)(byte)*PTR_rxBufferLength_08002744) {\n    byte data = *(byte *)(*(int *)PTR_rxBuffer_08002748 + (uint)bVar1);\n    *PTR_rxBufferIndex_08002740 = rxBufferIndex + 1;\n    return (uint)data;\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002720",
            "calling": [
                "wireRead"
            ],
            "imported": false,
            "current_name": "read_08002720"
        },
        "FUN_080031ce": {
            "renaming": {
                "FUN_080031ce": "sendFirmwareVersion_080031ce",
                "this": "marshaller",
                "major": "majorVersion",
                "minor": "minorVersion",
                "bytec": "byteCount",
                "bytev": "byteStream",
                "p_Var1": "printFunction",
                "uVar2": "index"
            },
            "code": "void __thiscall sendFirmwareVersion_080031ce(FirmataMarshaller *marshaller, uint8_t major, uint8_t minor, size_t byteCount, uint8_t *byteStream)\n{\n  _func_int_varargs *printFunction;\n  uint index;\n  if (marshaller->firmataStream != (Stream *)0x0) {\n    printFunction = *(marshaller->firmataStream->super_Print)._vptr_Print;\n    (*printFunction)(marshaller, 0xf0, (uint)minor, printFunction, byteCount);\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller->firmataStream, 0x79);\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller->firmataStream, (uint)major);\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller->firmataStream, (uint)minor);\n    for (index = 0; index < byteCount; index = index + 1) {\n      encodeByteStream(marshaller, 1, byteStream + index, 0);\n    }\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller->firmataStream, 0xf7);\n  }\n  return;\n}",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080031ce",
            "calling": [
                "printFirmwareVersion"
            ],
            "imported": false,
            "current_name": "sendFirmwareVersion_080031ce"
        },
        "FUN_08008b52": {
            "renaming": {
                "FUN_08008b52": "waitForTransmissionCompletion_08008b52",
                "this": "serialInstance",
                "_written": "isDataWritten",
                "_serial": "serialBuffer",
                "tx_head": "head",
                "tx_tail": "tail"
            },
            "code": "void __thiscall waitForTransmissionCompletion_08008b52(HardwareSerial *serialInstance)\n{\n  if (serialInstance->isDataWritten != false) {\n    do {\n    } while ((serialInstance->serialBuffer).head != (serialInstance->serialBuffer).tail);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b52",
            "calling": [],
            "imported": false,
            "current_name": "waitForTransmissionCompletion_08008b52"
        },
        "FUN_08002968": {
            "renaming": {
                "FUN_08002968": "initializeI2C_08002968",
                "this": "wire",
                "address": "address",
                "ownAddress": "ownAddress",
                "obj": "i2c"
            },
            "code": "void __thiscall initializeI2C_08002968(TwoWire *wire, uint8_t address) {\n  uint32_t ownAddress;\n  i2c_t *i2c;\n  wire->rxBufferIndex = 0;\n  wire->rxBufferLength = 0;\n  if (*(void **)wire->rxBuffer != (void *)0x0) {\n    memset(*(void **)wire->rxBuffer, 0, (uint)(byte)*wire->rxBufferAllocated);\n  }\n  wire->txBufferIndex = 0;\n  wire->txBufferLength = 0;\n  if (*(void **)wire->txBuffer != (void *)0x0) {\n    memset(*(void **)wire->txBuffer, 0, (uint)(byte)*wire->txBufferAllocated);\n  }\n  wire->transmitting = 0;\n  ownAddress = (address & 0x7f) << 1;\n  wire->ownAddress = (uint8_t)ownAddress;\n  if (address == 0x33) {\n    wire->master = true;\n  }\n  else {\n    wire->master = false;\n  }\n  i2c = &wire->_i2c;\n  i2c_custom_init((i2c_t_conflict *)i2c, wire->rxBuffer, wire->txBuffer, ownAddress, wire->master);\n  if (wire->master == false) {\n    i2c_attachSlaveTxEvent((i2c_t_conflict *)i2c, wire->onSlaveTransmit);\n    i2c_attachSlaveRxEvent((i2c_t_conflict *)i2c, wire->onSlaveReceive);\n  }\n  return;\n}",
            "called": [
                "i2c_custom_init",
                "i2c_attachSlaveTxEvent",
                "memset",
                "i2c_attachSlaveRxEvent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002968",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "initializeI2C_08002968"
        },
        "FUN_08004ccc": {
            "renaming": {
                "FUN_08004ccc": "i2cTransfer_08004ccc",
                "hi2c": "handle",
                "uVar1": "transferOptions",
                "pbVar2": "bufferPointer"
            },
            "code": "HAL_StatusTypeDef i2cTransfer_08004ccc(I2C_HandleTypeDef *handle)\n{\n  uint32_t transferOptions = handle->XferOptions;\n  if (handle->State == HAL_I2C_STATE_BUSY_TX) {\n    if (handle->XferCount == 0) {\n      if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n        handle->Instance->CR2 = handle->Instance->CR2 & 0xfffff8ff;\n        handle->Instance->CR1 = handle->Instance->CR1 | 0x200;\n        handle->PreviousState = 0;\n        handle->State = HAL_I2C_STATE_READY;\n        if (handle->Mode == HAL_I2C_MODE_MEM) {\n          handle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(handle);\n        }\n        else {\n          handle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(handle);\n        }\n      }\n      else {\n        handle->Instance->CR2 = handle->Instance->CR2 & 0xfffff8ff;\n        handle->PreviousState = 0x11;\n        handle->Mode = HAL_I2C_MODE_NONE;\n        handle->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(handle);\n      }\n    }\n    else {\n      uint8_t *bufferPointer = handle->pBuffPtr;\n      handle->pBuffPtr = bufferPointer + 1;\n      handle->Instance->DR = (uint32_t)*bufferPointer;\n      handle->XferCount = handle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MasterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ccc",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2cTransfer_08004ccc"
        },
        "FUN_080042d4": {
            "renaming": {
                "FUN_080042d4": "get_gpio_pin_state_080042d4",
                "GPIOx": "gpio_port",
                "GPIO_Pin": "gpio_pin",
                "GPIO_PIN_RESET": "GPIO_PIN_RESET",
                "GPIO_PIN_SET": "GPIO_PIN_SET"
            },
            "code": "GPIO_PinState get_gpio_pin_state_080042d4(GPIO_TypeDef *gpio_port, uint16_t gpio_pin) {\n  if ((gpio_pin & gpio_port->IDR) == 0) {\n    return GPIO_PIN_RESET;\n  }\n  return GPIO_PIN_SET;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042d4",
            "calling": [
                "digital_io_read"
            ],
            "imported": false,
            "current_name": "get_gpio_pin_state_080042d4"
        },
        "FUN_0800a07a": {
            "renaming": {
                "FUN_0800a07a": "seek_and_update_0800a07a",
                "param_1": "file_descriptor",
                "param_2": "buffer_address",
                "iVar1": "seek_result",
                "uVar2": "flags",
                "bVar3": "seek_failed"
            },
            "code": "void seek_and_update_0800a07a(int file_descriptor, int buffer_address) {\n  int seek_result;\n  ushort flags;\n  bool seek_failed;\n  seek_result = _lseek_r(file_descriptor, (int)*(short *)(buffer_address + 0xe));\n  seek_failed = seek_result == -1;\n  if (seek_failed) {\n    flags = *(ushort *)(buffer_address + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(buffer_address + 0x54) = seek_result;\n    flags = *(ushort *)(buffer_address + 0xc) | 0x1000;\n  }\n  if (seek_failed) {\n    *(ushort *)(buffer_address + 0xc) = flags;\n  }\n  else {\n    *(ushort *)(buffer_address + 0xc) = flags;\n  }\n  return;\n}",
            "called": [
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a07a",
            "calling": [],
            "imported": false,
            "current_name": "seek_and_update_0800a07a"
        },
        "FUN_080064b0": {
            "renaming": {
                "FUN_080064b0": "reset_uart_080064b0",
                "huart": "uart_handle",
                "Instance": "uart_instance",
                "CR1": "control_register_1",
                "CR3": "control_register_3",
                "RxState": "receive_state",
                "HAL_UART_STATE_READY": "UART_READY"
            },
            "code": "void reset_uart_080064b0(UART_HandleTypeDef *uart_handle)\n{\n  uart_handle->Instance->CR1 &= ~(1 << 13);\n  uart_handle->Instance->CR3 &= ~(1);\n  uart_handle->RxState = HAL_UART_STATE_READY;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064b0",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "reset_uart_080064b0"
        },
        "FUN_08006092": {
            "renaming": {
                "FUN_08006092": "configureTimer_08006092",
                "htim": "timer",
                "State": "state",
                "Lock": "lock",
                "HAL_TIM_STATE_RESET": "HAL_TIM_STATE_RESET",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_TIM_PWM_MspInit": "HAL_TIM_PWM_MspInit",
                "HAL_TIM_STATE_BUSY": "HAL_TIM_STATE_BUSY",
                "HAL_TIM_STATE_READY": "HAL_TIM_STATE_READY",
                "TIM_Base_SetConfig": "TIM_Base_SetConfig",
                "Instance": "instance",
                "Init": "init",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "code": "HAL_StatusTypeDef configureTimer_08006092(TIM_HandleTypeDef *timer)\n{\n  if (timer != NULL) {\n    if (timer->state == HAL_TIM_STATE_RESET) {\n      timer->lock = HAL_UNLOCKED;\n      HAL_TIM_PWM_MspInit(timer);\n    }\n    timer->state = HAL_TIM_STATE_BUSY;\n    TIM_Base_SetConfig(timer->instance, &(timer->init));\n    timer->state = HAL_TIM_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}",
            "called": [
                "TIM_Base_SetConfig",
                "HAL_TIM_PWM_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006092",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "configureTimer_08006092"
        },
        "FUN_08008d8c": {
            "renaming": {
                "FUN_08008d8c": "initializeSerial_08008d8c",
                "__initialize_p": "should_initialize",
                "__priority": "priority_level",
                "PTR_Serial2_08008dac": "PTR_Serial2_08008dac",
                "DAT_08008da8": "DAT_08008da8"
            },
            "code": "void initializeSerial_08008d8c(int should_initialize, int priority_level) {\n  if (should_initialize != 1) {\n    return;\n  }\n  if (priority_level == 0xffff) {\n    HardwareSerial::HardwareSerial((HardwareSerial *)PTR_Serial2_08008dac,DAT_08008da8);\n  }\n  return;\n}",
            "called": [
                "HardwareSerial"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d8c",
            "calling": [
                "_GLOBAL__sub_I_Serial2"
            ],
            "imported": false,
            "current_name": "initializeSerial_08008d8c"
        },
        "FUN_08008038": {
            "renaming": {
                "FUN_08008038": "handle_I2C_event_08008038",
                "PTR_i2c_handles_08008044": "i2c_handles_ptr"
            },
            "code": "void handle_I2C_event_08008038(I2C_HandleTypeDef_conflict **PTR_i2c_handles_08008044)\n{\n  HAL_I2C_EV_IRQHandler(*PTR_i2c_handles_08008044);\n  return;\n}",
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008038",
            "calling": [],
            "imported": false,
            "current_name": "handle_I2C_event_08008038"
        },
        "FUN_08009124": {
            "renaming": {
                "FUN_08009124": "read_formatted_data_08009124",
                "__stream": "file_stream",
                "__format": "format_string",
                "uStack_8": "stack_arg1",
                "uStack_4": "stack_arg2",
                "in_r2": "arg2",
                "in_r3": "arg3",
                "iVar1": "return_value"
            },
            "code": "int read_formatted_data_08009124(FILE* file_stream, char* format_string, ...)\n{\n  int return_value;\n  undefined4 arg2;\n  undefined4 arg3;\n  undefined4 stack_arg1;\n  undefined4 stack_arg2;\n  \n  stack_arg1 = arg2;\n  stack_arg2 = arg3;\n  return_value = _vread_formatted_data_08009124_r(*(undefined4 *)PTR__impure_ptr_08009144, file_stream, format_string, &stack_arg1, file_stream, &stack_arg1);\n  return return_value;\n}",
            "called": [
                "_vfiprintf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009124",
            "calling": [
                "__assert_func"
            ],
            "imported": false,
            "current_name": "read_formatted_data_08009124"
        },
        "FUN_080064ae": {
            "renaming": {
                "FUN_080064ae": "do_nothing_080064ae"
            },
            "code": "\nvoid do_nothing_080064ae(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064ae",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_080064ae"
        },
        "FUN_080064ac": {
            "renaming": {
                "FUN_080064ac": "do_nothing_080064ac"
            },
            "code": "\nvoid do_nothing_080064ac(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064ac",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_080064ac"
        },
        "FUN_08005cb4": {
            "renaming": {
                "FUN_08005cb4": "check_alarm_and_set_state_08005cb4",
                "hrtc": "rtc_handle",
                "RTC_CRH_ALRIE": "2",
                "RTC_CRL_ALRF": "2"
            },
            "code": "void check_alarm_and_set_state_08005cb4(RTC_HandleTypeDef *rtc_handle)\n{\n  if (((rtc_handle->Instance->CRH & RTC_CRH_ALRIE) != 0) && ((rtc_handle->Instance->CRL & RTC_CRL_ALRF) != 0)) {\n    HAL_RTC_AlarmAEventCallback(rtc_handle);\n    rtc_handle->Instance->CRL = ~(RTC_CRL_ALRF);\n  }\n  *(uint32_t *)(DAT_08005ce8 + 0x14) = 0x20000;\n  rtc_handle->State = HAL_RTC_STATE_READY;\n  return;\n}",
            "called": [
                "HAL_RTC_AlarmAEventCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005cb4",
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "imported": false,
            "current_name": "check_alarm_and_set_state_08005cb4"
        },
        "FUN_080042e2": {
            "renaming": {
                "FUN_080042e2": "set_gpio_pin_state_080042e2",
                "GPIOx": "gpio",
                "GPIO_Pin": "pin",
                "PinState": "state",
                "BSRR": "bit_set_reset_register",
                "uint": "uint32_t"
            },
            "code": "void set_gpio_pin_state_080042e2(GPIO_TypeDef *gpio, uint16_t pin, GPIO_PinState state)\n{\n  if (state == GPIO_PIN_RESET) {\n    gpio->BSRR = (uint32_t)pin << 16;\n    return;\n  }\n  gpio->BSRR = (uint32_t)pin;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042e2",
            "calling": [
                "digital_io_write"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_state_080042e2"
        },
        "FUN_080088e0": {
            "renaming": {
                "FUN_080088e0": "set_pwm_output_080088e0",
                "ulPin": "pin_number",
                "ulValue": "output_value",
                "_Var1": "is_pwm_pin",
                "uVar2": "write_resolution",
                "pin": "pin_name",
                "PTR_digitalPin_0800897c": "digitalPin_0800897c",
                "NC": "NC",
                "pin_in_pinmap": "pin_in_pinmap",
                "PinMap_conflict": "PinMap_PWM_08008980",
                "is_pin_configured": "is_pin_configured",
                "set_pin_configured": "set_pin_configured",
                "g_anOutputPinConfigured_08008984": "g_anOutputPinConfigured_08008984",
                "writeResolution_08008988": "writeResolution_08008988",
                "pwm_start": "pwm_start",
                "DAT_0800898c": "DAT_0800898c",
                "digitalWrite": "digitalWrite",
                "OUTPUT": "OUTPUT",
                "LOW": "LOW",
                "HIGH": "HIGH"
            },
            "code": "void set_pwm_output_080088e0(uint32_t pin_number, uint32_t output_value)\n{\n  bool is_pwm_pin;\n  uint8_t write_resolution;\n  PinName_conflict pin_name;\n  uint8_t duty_cycle;\n  uint32_t* output_pin_configured;\n\n  if (pin_number < 0x3c) {\n    pin_name = PTR_digitalPin_0800897c[pin_number];\n  }\n  else {\n    pin_name = NC;\n  }\n  if (pin_name != NC) {\n    is_pwm_pin = pin_in_pinmap(pin_name, (PinMap_conflict *)PinMap_PWM_08008980);\n    if (is_pwm_pin) {\n      output_pin_configured = (uint32_t *)g_anOutputPinConfigured_08008984;\n      if (!is_pin_configured(pin_name, output_pin_configured)) {\n        set_pin_configured(pin_name, output_pin_configured);\n      }\n      write_resolution = *(uint8_t *)writeResolution_08008988;\n      if (write_resolution != 8) {\n        if (write_resolution < 9) {\n          output_value = output_value << (8 - write_resolution & 0xff);\n        }\n        else {\n          output_value = output_value >> (write_resolution - 8 & 0xff);\n        }\n      }\n      duty_cycle = 0xff;\n      pwm_start(pin_name, DAT_0800898c, duty_cycle, output_value, !is_pin_configured);\n    }\n    else {\n      pinMode(pin_number, OUTPUT);\n      write_resolution = *(uint8_t *)writeResolution_08008988;\n      if (write_resolution != 8) {\n        if (write_resolution < 9) {\n          output_value = output_value << (8 - write_resolution & 0xff);\n        }\n        else {\n          output_value = output_value >> (write_resolution - 8 & 0xff);\n        }\n      }\n      if (output_value < 0x80) {\n        digitalWrite(pin_number, LOW);\n      }\n      else {\n        digitalWrite(pin_number, HIGH);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "digitalWrite",
                "pinMode",
                "is_pin_configured",
                "set_pin_configured",
                "pwm_start",
                "pin_in_pinmap"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080088e0",
            "calling": [
                "analogWriteCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "set_pwm_output_080088e0"
        },
        "FUN_08008b66": {
            "renaming": {
                "FUN_08008b66": "receiveSerialData_08008b66",
                "obj": "serialObj",
                "iVar1": "errorCode",
                "uVar2": "nextHeadIndex",
                "c": "receivedChar"
            },
            "code": "void receiveSerialData_08008b66(serial_t_conflict *serialObj) {\n  int errorCode;\n  ushort nextHeadIndex;\n  uchar receivedChar;\n  \n  errorCode = uart_getc((serial_t *)serialObj, &receivedChar);\n  if ((errorCode == 0) && (nextHeadIndex = serialObj->rx_head + 1 & 0x3f, nextHeadIndex != serialObj->rx_tail)) {\n    serialObj->rx_buff[serialObj->rx_head] = receivedChar;\n    serialObj->rx_head = nextHeadIndex;\n  }\n  return;\n}",
            "called": [
                "uart_getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b66",
            "calling": [],
            "imported": false,
            "current_name": "receiveSerialData_08008b66"
        },
        "FUN_0800a3a0": {
            "renaming": {
                "std::ctype_byname<char>::FUN_0800a3a0": "set_flags",
                "PTR_id_0800a404": "flag_1",
                "PTR_id_0800a408": "flag_2",
                "PTR_id_0800a40c": "flag_3",
                "PTR_id_0800a410": "flag_4",
                "PTR_id_0800a414": "flag_5",
                "PTR_id_0800a418": "flag_6",
                "PTR_id_0800a41c": "flag_7",
                "PTR_id_0800a420": "flag_8",
                "is_negative": "check_if_negative",
                "set_flag": "set_flag",
                "FUN_0800a3a0": "set_flags_0800a3a0"
            },
            "code": "void set_flags_0800a3a0() {\n  if (is_negative(PTR_id_0800a404)) {\n    set_flag(PTR_id_0800a404);\n  }\n  if (is_negative(PTR_id_0800a408)) {\n    set_flag(PTR_id_0800a408);\n  }\n  if (is_negative(PTR_id_0800a40c)) {\n    set_flag(PTR_id_0800a40c);\n  }\n  if (is_negative(PTR_id_0800a410)) {\n    set_flag(PTR_id_0800a410);\n  }\n  if (is_negative(PTR_id_0800a414)) {\n    set_flag(PTR_id_0800a414);\n  }\n  if (is_negative(PTR_id_0800a418)) {\n    set_flag(PTR_id_0800a418);\n  }\n  if (is_negative(PTR_id_0800a41c)) {\n    set_flag(PTR_id_0800a41c);\n  }\n  if (is_negative(PTR_id_0800a420)) {\n    set_flag(PTR_id_0800a420);\n  }\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a3a0",
            "calling": [],
            "imported": false,
            "current_name": "set_flags_0800a3a0"
        },
        "FUN_08008048": {
            "renaming": {
                "FUN_08008048": "handle_i2c_error_interrupt_08008048",
                "PTR_i2c_handles_08008054": "i2c_handles_ptr"
            },
            "code": "void handle_i2c_error_interrupt_08008048(I2C_HandleTypeDef_conflict **PTR_i2c_handles_08008054)\n{\n  HAL_I2C_ER_IRQHandler(*PTR_i2c_handles_08008054);\n  return;\n}",
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008048",
            "calling": [],
            "imported": false,
            "current_name": "handle_i2c_error_interrupt_08008048"
        },
        "FUN_080053cc": {
            "renaming": {
                "FUN_080053cc": "reset_i2c_dma_080053cc",
                "hdma": "dma_handle",
                "hi2c": "i2c_handle"
            },
            "code": "void reset_i2c_dma_080053cc(I2C_HandleTypeDef *i2c_handle)\n{\n  DMA_HandleTypeDef *dma_handle = (DMA_HandleTypeDef *)i2c_handle->hdmatx->Parent;\n  i2c_handle->Instance->CR1 &= 0xfffffbff;\n  i2c_handle->XferCount = 0;\n  i2c_handle->hdmatx->XferAbortCallback = NULL;\n  i2c_handle->hdmarx->XferAbortCallback = NULL;\n  if (i2c_handle->State != HAL_I2C_STATE_ABORT) {\n    i2c_handle->State = HAL_I2C_STATE_READY;\n    i2c_handle->Mode = HAL_I2C_MODE_NONE;\n    i2c_handle->Instance->CR1 &= 0xfffffffe;\n    HAL_I2C_ErrorCallback(i2c_handle);\n    return;\n  }\n  i2c_handle->State = HAL_I2C_STATE_READY;\n  i2c_handle->Mode = HAL_I2C_MODE_NONE;\n  i2c_handle->ErrorCode = 0;\n  i2c_handle->Instance->CR1 &= 0xfffffffe;\n  HAL_I2C_AbortCpltCallback(i2c_handle);\n  return;\n}",
            "called": [
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_AbortCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080053cc",
            "calling": [],
            "imported": false,
            "current_name": "reset_i2c_dma_080053cc"
        },
        "FUN_080087bc": {
            "renaming": {
                "FUN_080087bc": "handle_uart_interrupt_080087bc",
                "PTR_uart_handlers_080087d0": "uart_handlers_ptr",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_irq",
                "USART1_IRQn": "usart1_irqn",
                "HAL_UART_IRQHandler": "uart_irq_handler"
            },
            "code": "void handle_uart_interrupt_080087bc(UART_HandleTypeDef** PTR_uart_handlers_080087d0)\n{\n  HAL_NVIC_ClearPendingIRQ(USART1_IRQn);\n  HAL_UART_IRQHandler(*PTR_uart_handlers_080087d0);\n  return;\n}",
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080087bc",
            "calling": [],
            "imported": false,
            "current_name": "handle_uart_interrupt_080087bc"
        },
        "FUN_080042f0": {
            "renaming": {
                "FUN_080042f0": "check_and_trigger_gpio_interrupt_080042f0",
                "GPIO_Pin": "pin",
                "DAT_08004308": "pin_register_base_address",
                "PTR_uint_14": "pin_register_offset",
                "uint": "uint32_t",
                "HAL_GPIO_EXTI_Callback": "trigger_gpio_interrupt_callback"
            },
            "code": "void check_and_trigger_gpio_interrupt_080042f0(uint16_t pin) {\n  uint* pin_register = (uint*)(DAT_08004308 + 0x14);\n  uint pin_mask = (uint)pin;\n  if ((*pin_register & pin_mask) != 0) {\n    *pin_register = pin_mask;\n    HAL_GPIO_EXTI_Callback(pin);\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042f0",
            "calling": [
                "EXTI4_IRQHandler",
                "EXTI2_IRQHandler",
                "EXTI15_10_IRQHandler",
                "EXTI9_5_IRQHandler",
                "EXTI1_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI0_IRQHandler"
            ],
            "imported": false,
            "current_name": "check_and_trigger_gpio_interrupt_080042f0"
        },
        "FUN_080087d4": {
            "renaming": {
                "FUN_080087d4": "handle_USART2_IRQ_080087d4",
                "USART2_IRQn": "USART2_Interrupt",
                "PTR_uart_handlers_080087e8": "PTR_uart_handlers",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_IRQ",
                "UART_HandleTypeDef": "UART_handler",
                "HAL_UART_IRQHandler": "handle_UART_IRQ"
            },
            "code": "void handle_USART2_IRQ_080087d4(void)\n{\n  HAL_NVIC_ClearPendingIRQ(USART2_IRQn);\n  UART_HandleTypeDef* uart_handler = *(UART_HandleTypeDef **)(PTR_uart_handlers_080087e8_080087e8 + 4);\n  HAL_UART_IRQHandler(uart_handler);\n  return;\n}",
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080087d4",
            "calling": [],
            "imported": false,
            "current_name": "handle_USART2_IRQ_080087d4"
        },
        "FUN_0800a09e": {
            "renaming": {
                "FUN_0800a09e": "close_file_descriptor_0800a09e",
                "param_1": "file_descriptor",
                "param_2": "file_descriptor_offset"
            },
            "code": "void close_file_descriptor_0800a09e(void* file_descriptor, int file_descriptor_offset) {\n  _close_r(file_descriptor, (int)*(short *)(file_descriptor_offset + 0xe));\n  return;\n}",
            "called": [
                "_close_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a09e",
            "calling": [],
            "imported": false,
            "current_name": "close_file_descriptor_0800a09e"
        },
        "FUN_080076e0": {
            "renaming": {
                "FUN_080076e0": "stop_timer_080076e0",
                "obj": "timer_obj",
                "HVar1": "hal_status",
                "uVar2": "timer_irq_num"
            },
            "code": "void stop_timer_080076e0(stimer_t_conflict *timer_obj)\n{\n  HAL_StatusTypeDef_conflict hal_status;\n  uint32_t timer_irq_num;\n  \n  timer_obj->irqHandleOC = (_func_void_stimer_t_ptr_uint32_t_conflict *)0x0;\n  timer_irq_num = getTimerIrq(timer_obj->timer);\n  HAL_NVIC_DisableIRQ((IRQn_Type_conflict)timer_irq_num);\n  hal_status = HAL_TIM_OC_DeInit(&timer_obj->handle);\n  if (hal_status == HAL_OK) {\n    HAL_TIM_OC_Stop_IT(&timer_obj->handle, 0);\n  }\n  return;\n}",
            "called": [
                "getTimerIrq",
                "HAL_NVIC_DisableIRQ",
                "HAL_TIM_OC_Stop_IT",
                "HAL_TIM_OC_DeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080076e0",
            "calling": [
                "finISR"
            ],
            "imported": false,
            "current_name": "stop_timer_080076e0"
        },
        "FUN_08002f14": {
            "renaming": {
                "FUN_08002f14": "sendStringToMarshaller_08002f14",
                "this": "firmataInstance",
                "string": "stringToSend",
                "FirmataMarshaller::FUN_08002f14": "sendString",
                "&this->marshaller": "&firmataInstance->marshaller"
            },
            "code": "void __thiscall sendStringToMarshaller_08002f14(FirmataClass *firmataInstance, char *stringToSend)\n{\n  FirmataMarshaller::sendString(&firmataInstance->marshaller, stringToSend);\n  return;\n}",
            "called": [
                "sendString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f14",
            "calling": [
                "sysexCallback",
                "attachServo",
                "readAndReportData",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "sendStringToMarshaller_08002f14"
        }
    },
    "used_tokens": 301968,
    "layers": [
        [
            "FUN_08007246",
            "FUN_0800a042",
            "FUN_08008e4e",
            "FUN_08008694",
            "FUN_08005188",
            "FUN_08001bf8",
            "FUN_080069ec",
            "FUN_0800a168",
            "FUN_080067ac",
            "FUN_0800735a",
            "FUN_08008c20",
            "FUN_0800723c",
            "FUN_080043a2",
            "FUN_08006280",
            "FUN_08007258",
            "FUN_08009f4c",
            "FUN_08006c7c",
            "FUN_08006b5c",
            "FUN_08007376",
            "FUN_080033cc",
            "FUN_08003de4",
            "FUN_08000500",
            "FUN_08009d24",
            "FUN_08008e72",
            "FUN_080022f8",
            "FUN_08005084",
            "FUN_08008b0e",
            "FUN_0800291c",
            "FUN_080032bc",
            "FUN_08008c44",
            "FUN_08006060",
            "FUN_08006186",
            "FUN_08006b7c",
            "FUN_08008e7c",
            "FUN_0800a194",
            "FUN_08003aa0",
            "FUN_08005fe8",
            "FUN_08003ce8",
            "FUN_0800738a",
            "FUN_08002948",
            "FUN_08009e64",
            "FUN_08002acc",
            "FUN_0800932c",
            "FUN_080099a4",
            "FUN_08005a1c",
            "FUN_08006b0c",
            "FUN_08007320",
            "FUN_080002ec",
            "FUN_08000be8",
            "FUN_08003fd8",
            "FUN_0800307a",
            "FUN_08002ca4",
            "FUN_0800319e",
            "FUN_08008d00",
            "FUN_08004b82",
            "FUN_0800997e",
            "FUN_0800779c",
            "FUN_08002dbc",
            "FUN_08007f78",
            "FUN_08006b28",
            "FUN_08006b1c",
            "FUN_0800a130",
            "FUN_08008f3c",
            "FUN_08007332",
            "FUN_08006128",
            "FUN_0800a258",
            "FUN_08002cb8",
            "FUN_08008f50",
            "FUN_08004a76",
            "FUN_0800877c",
            "FUN_080047f4",
            "FUN_08005a48",
            "FUN_080033a8",
            "FUN_08008d18",
            "FUN_0800a020",
            "FUN_08007f7c",
            "FUN_08006d80",
            "FUN_08006c60",
            "FUN_08008e40",
            "FUN_080045c0",
            "FUN_08007e74",
            "FUN_08002ddc",
            "FUN_08009f2c",
            "FUN_0800a154",
            "FUN_08007f8e",
            "FUN_08006b3e",
            "FUN_08006262",
            "FUN_08007110",
            "FUN_08007594",
            "FUN_08002cd0",
            "FUN_08002df6",
            "FUN_08007118",
            "FUN_08001be8",
            "FUN_08005a68",
            "FUN_08008f78",
            "FUN_08002dea",
            "FUN_0800734a",
            "FUN_08000aec",
            "FUN_080068d6",
            "FUN_080032a2",
            "FUN_08009e28",
            "FUN_0800a01c",
            "FUN_08006390",
            "FUN_08008730",
            "FUN_08008854",
            "FUN_08004d6c",
            "FUN_08007760",
            "FUN_08008850",
            "FUN_08002fc2",
            "FUN_08008afa",
            "FUN_080038dc",
            "FUN_080025ac",
            "FUN_08007648",
            "FUN_08008858",
            "FUN_08004a24",
            "FUN_08002fba",
            "FUN_080090cc",
            "FUN_080049e0",
            "FUN_08006d24",
            "FUN_08008500",
            "FUN_08007774",
            "FUN_080001a8",
            "FUN_080048c8",
            "FUN_08009954",
            "FUN_08005e6e",
            "FUN_08004024",
            "FUN_08008868",
            "FUN_080036ac",
            "FUN_0800643c",
            "FUN_08002fca",
            "FUN_0800a31c",
            "FUN_080026f8",
            "FUN_08007544",
            "FUN_08008990",
            "FUN_08004396",
            "FUN_08003fb0",
            "FUN_08007788",
            "FUN_08002ec4",
            "FUN_08007306",
            "FUN_08008f0e",
            "FUN_0800886c",
            "FUN_080036d8",
            "FUN_0800a110",
            "FUN_08003b8c",
            "FUN_080035b8",
            "FUN_08006460",
            "FUN_08004046",
            "FUN_08008880",
            "FUN_08002ed2",
            "FUN_08008f1c",
            "FUN_080058ac",
            "FUN_08007438",
            "FUN_0800306c",
            "FUN_0800887c",
            "FUN_0800863c",
            "FUN_08004050",
            "FUN_08008e14",
            "FUN_08005a28",
            "FUN_08008ac6",
            "FUN_08003366",
            "FUN_080091b0",
            "FUN_08008abc",
            "FUN_08002b68",
            "FUN_080005e0",
            "FUN_0800674e",
            "FUN_0800771c",
            "FUN_08003370",
            "FUN_08003376",
            "FUN_08008bf4",
            "FUN_08002c7c",
            "FUN_08005430",
            "FUN_08009918",
            "FUN_08005434",
            "FUN_08005e2e",
            "FUN_08007736",
            "FUN_08002c90",
            "FUN_0800542a",
            "FUN_0800457c",
            "FUN_080091c6",
            "FUN_08003a20",
            "FUN_08002a58",
            "FUN_080004d4",
            "FUN_08002fa0",
            "FUN_08003a1c",
            "FUN_08007744",
            "FUN_08006538",
            "FUN_08002fa8",
            "FUN_0800325a",
            "FUN_080091d8",
            "FUN_0800688e",
            "FUN_080090b4",
            "FUN_0800870c",
            "FUN_08008840",
            "FUN_08008600",
            "FUN_08003154",
            "FUN_08006420",
            "FUN_08007750",
            "FUN_08009938",
            "FUN_08007f0e",
            "FUN_08004004",
            "FUN_08003158",
            "FUN_080090c2",
            "FUN_08008846",
            "FUN_0800459c",
            "FUN_0800774a",
            "FUN_0800314e",
            "FUN_080036a0",
            "FUN_080038e4",
            "FUN_08005d48",
            "FUN_08008ba4",
            "FUN_08009ff8",
            "FUN_08009db0",
            "FUN_08002c2c",
            "FUN_080072f0",
            "FUN_08000178",
            "FUN_08000a64",
            "FUN_08002c40",
            "FUN_0800694c",
            "FUN_0800a0ec",
            "FUN_08008df8",
            "FUN_08000188",
            "FUN_08004f3c",
            "FUN_0800344a",
            "FUN_080071e4",
            "FUN_08002c54",
            "FUN_080072fa",
            "FUN_08003346",
            "FUN_08003106",
            "FUN_08007708",
            "FUN_0800018c",
            "FUN_08003f94",
            "FUN_08002c68",
            "FUN_0800430c",
            "FUN_08003350",
            "FUN_08007710",
            "FUN_08003474",
            "FUN_08008804",
            "FUN_08004e3c",
            "FUN_08007718",
            "FUN_08002a30",
            "FUN_08009cd0",
            "FUN_0800322c",
            "FUN_08003760",
            "FUN_08000130",
            "FUN_08002798",
            "FUN_0800242c",
            "FUN_08002e44",
            "FUN_0800a0a8",
            "FUN_08003f30",
            "FUN_080073d8",
            "FUN_080085dc",
            "FUN_08008db0",
            "FUN_08002444",
            "FUN_0800906c",
            "FUN_08003658",
            "FUN_08009a80",
            "FUN_080062f4",
            "FUN_080073e8",
            "FUN_0800267c",
            "FUN_0800376c",
            "FUN_08003e20",
            "FUN_08005840",
            "FUN_08003306",
            "FUN_08002578",
            "FUN_08006932",
            "FUN_080060c4",
            "FUN_08009eac",
            "FUN_08008dbe",
            "FUN_080072d8",
            "FUN_08002b00",
            "FUN_08002f84",
            "FUN_08009094",
            "FUN_0800a0cc",
            "FUN_08002580",
            "FUN_080073ec",
            "FUN_08008ef4",
            "FUN_08002c1e",
            "FUN_08002f94",
            "FUN_08001b48",
            "FUN_08005df4",
            "FUN_08009148",
            "FUN_080099dc",
            "FUN_08009024",
            "FUN_080064cc",
            "FUN_08008058",
            "FUN_08004ac2",
            "FUN_08006ca8",
            "FUN_08000214",
            "FUN_08005bb8",
            "FUN_080063c0",
            "FUN_0800274c",
            "FUN_08009270",
            "FUN_08009038",
            "FUN_08005aa4",
            "FUN_08008068",
            "FUN_08002400",
            "FUN_08000588",
            "FUN_08002644",
            "FUN_08002f1e",
            "FUN_0800902e",
            "FUN_08009042",
            "FUN_08009c7c",
            "FUN_08009b5c",
            "FUN_08008a6c",
            "FUN_080085b8",
            "FUN_08001c08",
            "FUN_080075dc",
            "FUN_080087ec",
            "FUN_08007ff0",
            "FUN_08002774",
            "FUN_080052f0",
            "FUN_08002f2c",
            "FUN_08004954",
            "FUN_08005cec",
            "FUN_08003748",
            "FUN_080040e8",
            "FUN_08009b6c",
            "FUN_0800010c",
            "FUN_080086e8",
            "FUN_08001c18",
            "FUN_08009056",
            "FUN_08002e1a",
            "FUN_0800904c",
            "FUN_080073ae",
            "FUN_08003f0c",
            "FUN_08000488",
            "FUN_08006bb8",
            "FUN_08004aec",
            "FUN_08007ede",
            "FUN_08004728",
            "FUN_080074e0",
            "FUN_080073c0",
            "FUN_080084b0",
            "FUN_080095a8",
            "FUN_08008b2a",
            "FUN_08003bd8",
            "FUN_08009d50",
            "FUN_08009108",
            "FUN_08009f98",
            "FUN_08008a24",
            "FUN_08008020",
            "FUN_08005dac",
            "FUN_080066e8",
            "FUN_08009358",
            "FUN_0800270c",
            "FUN_08007fa0",
            "FUN_08002720",
            "FUN_080031ce",
            "FUN_08008b52",
            "FUN_08002968",
            "FUN_08004ccc",
            "FUN_080042d4",
            "FUN_0800a07a",
            "FUN_080064b0",
            "FUN_08006092",
            "FUN_08008d8c",
            "FUN_08008038",
            "FUN_08005cb4",
            "FUN_080042e2",
            "FUN_080088e0",
            "FUN_08008b66",
            "FUN_0800a3a0",
            "FUN_08008048",
            "FUN_080053cc",
            "FUN_080087bc",
            "FUN_080042f0",
            "FUN_080087d4",
            "FUN_0800a09e",
            "FUN_080076e0"
        ],
        [
            "FUN_08002ce0",
            "FUN_08002ac0",
            "FUN_08002ef2",
            "FUN_08002efe",
            "FUN_08008d30",
            "FUN_08003048",
            "FUN_0800885c",
            "FUN_08003002",
            "FUN_08009908",
            "FUN_08009cdc",
            "FUN_080026b0",
            "FUN_080027f0",
            "FUN_080036a2",
            "FUN_08002a26",
            "FUN_080091a0",
            "FUN_08002a1c",
            "FUN_08009190",
            "FUN_08002c00",
            "FUN_08008ed6",
            "FUN_08002c14",
            "FUN_08009084",
            "FUN_08009fe8",
            "FUN_08008eec",
            "FUN_08003724",
            "FUN_08002f0a",
            "FUN_08002634",
            "FUN_080098d8",
            "FUN_0800288c",
            "FUN_08002e26",
            "FUN_0800a18c",
            "FUN_08009124",
            "FUN_08002f14"
        ]
    ],
    "locked_functions": []
}