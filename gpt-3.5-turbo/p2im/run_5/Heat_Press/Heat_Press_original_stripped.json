{
    "functions": {
        "FUN_000800f4": {
            "entrypoint": "0x000800f4",
            "current_name": "set_completed_flag_000800f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080100) */\n\nundefined4 setCompletedFlag_000800f4(undefined4 input)\n\n{\n  if ((char)completionFlag == '\\0') {\n    completionFlag._0_1_ = '\\x01';\n  }\n  return input;\n}\n\n",
            "renaming": {
                "FUN_000800f4": "set_completed_flag_000800f4",
                "param_1": "input",
                "completed_7857": "completionFlag"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080118": {
            "entrypoint": "0x00080118",
            "current_name": "FUNC_00080118",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0008011e) */\n/* WARNING: Removing unreachable block (ram,0x00080130) */\n\n\nvoid FUNC_00080118(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080118": "FUNC_00080118"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080148": {
            "entrypoint": "0x00080148",
            "current_name": "execute_software_interrupt_00080148",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t executeSoftwareInterrupt_00080148(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_00080148": "execute_software_interrupt_00080148"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008014c": {
            "entrypoint": "0x0008014c",
            "current_name": "execute_hypercall_0008014c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint executeHypercall_0008014c(int numTicks)\n\n{\n  uint32_t returnVal;\n  \n  if (noHyperCall == 0) {\n    returnVal = aflCall(1,numTicks,0);\n    return returnVal;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0008014c": "execute_hypercall_0008014c",
                "ticks": "numTicks",
                "uVar1": "returnVal"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080164": {
            "entrypoint": "0x00080164",
            "current_name": "initialize_modbus_00080164",
            "code": "\n/* DWARF original prototype: void  begin(Modbus * modbusInstance, long speed) */\n\nvoid __modbusInstancecall Modbus::initializeModbus_00080164(Modbus *modbusInstance,long speed)\n\n{\n  int iVar1;\n  \n  modbusInstance->serialPort = &SerialBaseClass;\n  (**(code **)(pointerToSerial + 0x18))(&Serial);\n  if (1 < modbusInstance->txEnablePin) {\n    setPinMode((uint)modbusInstance->txEnablePin,1);\n    writeToPin((uint)modbusInstance->txEnablePin,0);\n  }\n  do {\n    iVar1 = (**(code **)(*(int *)modbusInstance->serialPort + 0xc))();\n  } while (-1 < iVar1);\n  modbusInstance->bufferSize = '\\0';\n  modbusInstance->lastReceivedByte = '\\0';\n  modbusInstance->errorCount = 0;\n  modbusInstance->outgoingCount = 0;\n  modbusInstance->incomingCount = 0;\n  return;\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "u32speed": "speed",
                "port": "serialPort",
                "Serial.super_HardwareSerial": "SerialBaseClass",
                "Serial._0_4_": "pointerToSerial",
                "u8txenpin": "txEnablePin",
                "u8BufferSize": "bufferSize",
                "u8lastRec": "lastReceivedByte",
                "u16errCnt": "errorCount",
                "u16OutCnt": "outgoingCount",
                "u16InCnt": "incomingCount",
                "pinMode": "setPinMode",
                "digitalWrite": "writeToPin",
                "FUN_00080164": "initialize_modbus_00080164"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "pinMode",
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000801b0": {
            "entrypoint": "0x000801b0",
            "current_name": "get_rx_buffer_000801b0",
            "code": "\n/* DWARF original prototype: int8_t  getRxBuffer_000801b0(Modbus * modbusInstance) */\n\nint8_t __modbusInstancecall Modbus::getRxBuffer_000801b0(Modbus *modbusInstance)\n\n{\n  bool isBufferFull;\n  uchar receivedByte;\n  uint8_t bufferSize;\n  int readResult;\n  byte bufferIndex;\n  \n  if (1 < modbusInstance->u8txenpin) {\n    digitalWrite((uint)modbusInstance->u8txenpin,0);\n  }\n  isBufferFull = false;\n  modbusInstance->u8BufferSize = '\\0';\n  if (modbusInstance->u8serno < 4) {\n    while (readResult = (**(code **)(*(int *)modbusInstance->port + 8))(), readResult != 0) {\n      bufferIndex = modbusInstance->u8BufferSize;\n      receivedByte = (**(code **)(*(int *)modbusInstance->port + 0xc))();\n      bufferSize = modbusInstance->u8BufferSize;\n      modbusInstance->au8Buffer[bufferIndex] = receivedByte;\n      bufferIndex = bufferSize + 1;\n      modbusInstance->u8BufferSize = bufferIndex;\n      if (0x3f < bufferIndex) {\n        isBufferFull = true;\n      }\n    }\n  }\n  modbusInstance->u16InCnt = modbusInstance->u16InCnt + 1;\n  if (isBufferFull) {\n    bufferSize = 0xfd;\n    modbusInstance->u16errCnt = modbusInstance->u16errCnt + 1;\n  }\n  else {\n    bufferSize = modbusInstance->u8BufferSize;\n  }\n  return bufferSize;\n}\n\n",
            "renaming": {
                "FUN_000801b0": "get_rx_buffer_000801b0",
                "this": "modbusInstance",
                "bVar1": "isBufferFull",
                "uVar2": "receivedByte",
                "uVar3": "bufferSize",
                "iVar4": "readResult",
                "bVar5": "bufferIndex"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008021c": {
            "entrypoint": "0x0008021c",
            "current_name": "calculate_crc_0008021c",
            "code": "\n/* DWARF original prototype: uint16_t  calcCRC(Modbus * modbus, uint8_t dataLength) */\n\nuint16_t __modbuscall Modbus::calculateCRC_0008021c(Modbus *modbus,uint8_t dataLength)\n\n{\n  Modbus *currentModbus;\n  uint crc;\n  char bitCount;\n  uint lsb;\n  uint flag;\n  \n  crc = 0xffff;\n  for (currentModbus = modbus; ((int)currentModbus - (int)modbus & 0xffU) < (uint)dataLength;\n      currentModbus = (Modbus *)((int)&currentModbus->port + 1)) {\n    crc = crc ^ currentModbus->au8Buffer[0];\n    bitCount = '\\b';\n    do {\n      lsb = crc & 1;\n      crc = crc >> 1;\n      if (lsb != 0) {\n        crc = crc ^ 0xa001;\n      }\n      bitCount = bitCount + -1;\n    } while (bitCount != '\\0');\n  }\n  return (ushort)(crc << 8) | (ushort)(crc >> 8);\n}\n\n",
            "renaming": {
                "FUN_0008021c": "calculate_crc_0008021c",
                "this": "modbus",
                "u8length": "dataLength",
                "pMVar1": "currentModbus",
                "uVar2": "crc",
                "cVar3": "bitCount",
                "uVar4": "lsb"
            },
            "calling": [
                "sendTxBuffer"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080258": {
            "entrypoint": "0x00080258",
            "current_name": "send_transmit_buffer_00080258",
            "code": "\n/* DWARF original prototype: void  sendTxBuffer(Transmitter * transmitter) */\n\nvoid __transmittercall Transmitter::sendTransmitBuffer_00080258(Transmitter *transmitter)\n\n{\n  byte bufferLength;\n  uint16_t crcResult;\n  uint16_t calculatedCRC;\n  uint32_t millisResult;\n  int loopVariable;\n  \n  bufferLength = transmitter->u8BufferSize;\n  crcResult = calcCRC(transmitter,bufferLength);\n  transmitter->au8Buffer[bufferLength] = (uchar)(crcResult >> 8);\n  transmitter->au8Buffer[bufferLength + 1 & 0xff] = (uchar)crcResult;\n  transmitter->u8BufferSize = bufferLength + 2;\n  if (1 < transmitter->u8txenpin) {\n    digitalWrite((uint)transmitter->u8txenpin,1);\n  }\n  if (transmitter->u8serno < 4) {\n    (**(code **)(*(int *)transmitter->port + 4))(transmitter->port,transmitter->au8Buffer,transmitter->u8BufferSize);\n  }\n  if (1 < transmitter->u8txenpin) {\n    digitalWrite((uint)transmitter->u8txenpin,0);\n  }\n  if (transmitter->u8serno < 4) {\n    do {\n      loopVariable = (**(code **)(*(int *)transmitter->port + 0xc))();\n    } while (-1 < loopVariable);\n  }\n  transmitter->u8BufferSize = '\\0';\n  millisResult = millis();\n  transmitter->u32timeOut = millisResult + transmitter->u16timeOut;\n  transmitter->u16OutCnt = transmitter->u16OutCnt + 1;\n  return;\n}\n\n",
            "renaming": {
                "Modbus": "Transmitter",
                "this": "transmitter",
                "u8length": "bufferLength",
                "uVar1": "crcResult",
                "u16crc": "calculatedCRC",
                "uVar2": "millisResult",
                "iVar3": "loopVariable",
                "FUN_00080258": "send_transmit_buffer_00080258"
            },
            "calling": [
                "query"
            ],
            "called": [
                "millis",
                "digitalWrite",
                "calcCRC"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000802da": {
            "entrypoint": "0x000802da",
            "current_name": "process_modbus_telegram_000802da",
            "code": "\n/* DWARF original prototype: int8_t  query(Modbus * this, modbus_t telegram) */\n\nint8_t __thiscall Modbus::processModbusTelegram_000802da(Modbus *this,modbus_t telegram)\n\n{\n  uchar uVar1;\n  uint in_r1;\n  uint8_t u8bytesno;\n  byte bVar3;\n  ushort in_r2;\n  ushort *puVar4;\n  uint8_t uVar5;\n  ushort uVar6;\n  ushort *in_r3;\n  uint uVar7;\n  ushort *puVar8;\n  uchar local_1c;\n  uchar local_1b;\n  uchar uVar2;\n  \n  local_1c = (uchar)in_r1;\n  local_1b = (uchar)(in_r1 >> 8);\n  uVar7 = (uint)in_r2;\n  if (this->u8id != '\\0') {\n    return -2;\n  }\n  if (this->u8state != '\\0') {\n    return -1;\n  }\n  if (0xf6 < ((in_r1 & 0xff) - 1 & 0xff)) {\n    return -3;\n  }\n  this->au8Buffer[0] = local_1c;\n  this->au8Buffer[1] = local_1b;\n  this->au16regs = in_r3;\n  this->au8Buffer[2] = (uchar)(in_r1 >> 0x18);\n  this->au8Buffer[3] = (uchar)(in_r1 >> 0x10);\n  uVar1 = (uchar)in_r2;\n  uVar2 = (uchar)(in_r2 >> 8);\n  switch(local_1b) {\n  case '\\x01':\n  case '\\x02':\n  case '\\x03':\n  case '\\x04':\n    this->au8Buffer[4] = uVar2;\n    break;\n  case '\\x05':\n    uVar6 = *in_r3;\n    if (uVar6 != 0) {\n      uVar6 = 1;\n    }\n    this->au8Buffer[4] = -(char)uVar6;\n    uVar7 = 0;\n    break;\n  case '\\x06':\n    this->au8Buffer[4] = (uchar)(*in_r3 >> 8);\n    uVar7 = (uint)*in_r3;\n    break;\n  default:\n    goto switchD_0008031e_caseD_7;\n  case '\\x0f':\n    bVar3 = (byte)(in_r2 >> 3) & 0xfe;\n    if ((in_r2 & 0xf) != 0) {\n      bVar3 = bVar3 + 1;\n    }\n    this->au8Buffer[5] = uVar1;\n    this->au8Buffer[4] = uVar2;\n    this->au8Buffer[6] = bVar3;\n    uVar5 = '\\a';\n    goto LAB_0008034a;\n  case '\\x10':\n    this->au8Buffer[4] = uVar2;\n    this->au8Buffer[5] = uVar1;\n    puVar4 = in_r3 + -1;\n    this->au8Buffer[6] = uVar1 * '\\x02';\n    this->u8BufferSize = '\\a';\n    puVar8 = puVar4 + uVar7;\n    while (puVar4 != puVar8) {\n      bVar3 = this->u8BufferSize;\n      this->au8Buffer[bVar3] = (uchar)(puVar4[1] >> 8);\n      uVar7 = bVar3 + 1 & 0xff;\n      this->u8BufferSize = (uint8_t)uVar7;\n      puVar4 = puVar4 + 1;\n      this->au8Buffer[uVar7] = (uchar)*puVar4;\n      this->u8BufferSize = bVar3 + 2;\n    }\n    goto switchD_0008031e_caseD_7;\n  }\n  this->au8Buffer[5] = (uchar)uVar7;\n  uVar5 = '\\x06';\nLAB_0008034a:\n  this->u8BufferSize = uVar5;\nswitchD_0008031e_caseD_7:\n  sendTxBuffer(this);\n  this->u8state = '\\x01';\n  return '\\0';\n}\n\n",
            "renaming": {
                "FUN_000802da": "process_modbus_telegram_000802da"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "sendTxBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000803d4": {
            "entrypoint": "0x000803d4",
            "current_name": "validate_answer_000803d4",
            "code": "\n/* DWARF orindexgindexnal prototype: uindexnt8_t  valindexdateAnswer(Modbus * modbus) */\n\nuindexnt8_t __modbuscall Modbus::validateAnswer_000803d4(Modbus *modbus)\n\n{\n  uindexnt8_t index;\n  indexnt iterator;\n  \n  indexf ((indexnt)((uindexnt)modbus->au8Buffer[1] << 0x18) < 0) {\n    modbus->u16errCnt = modbus->u16errCnt + 1;\n    return 0xfb;\n  }\n  iterator = 0;\n  do {\n    indexf (\"\\x01\\x02\\x03\\x04\\x05\\x06\\x0f\\x10\"[iterator] == modbus->au8Buffer[1]) {\n      return '\\0';\n    }\n    iterator = iterator + 1;\n  } whindexle (iterator != 8);\n  modbus->u16errCnt = modbus->u16errCnt + 1;\n  return '\\x01';\n}\n\n",
            "renaming": {
                "FUN_000803d4": "validate_answer_000803d4",
                "this": "modbus",
                "i": "index",
                "iVar1": "iterator"
            },
            "calling": [
                "poll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080410": {
            "entrypoint": "0x00080410",
            "current_name": "extract_modbus_registers_00080410",
            "code": "\n/* DWARF original prototype: void  get_FC3(Modbus * this) */\n\nvoid __thiscall Modbus::extractModbusRegisters_00080410(Modbus *this)\n\n{\n  uint16_t registerValue;\n  uint adjustedIndex;\n  byte counter;\n  uint index;\n  uint16_t *registersArray;\n  \n  counter = 0;\n  while( true ) {\n    index = (uint)counter;\n    counter = counter + 1;\n    adjustedIndex = index * 2 + 3 & 0xff;\n    if (this->au8Buffer[2] >> 1 <= index) break;\n    registersArray = this->au16regs;\n    registerValue = makeWord(this->au8Buffer[adjustedIndex],this->au8Buffer[adjustedIndex + 1]);\n    registersArray[index] = registerValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080410": "extract_modbus_registers_00080410",
                "bVar3": "counter",
                "uVar4": "index",
                "uVar2": "adjustedIndex",
                "uVar1": "registerValue",
                "puVar5": "registersArray"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008043e": {
            "entrypoint": "0x0008043e",
            "current_name": "poll_modbus_0008043e",
            "code": "\n/* DWARF original prototype: int8_t  poll(Modbus * modbusObject) */\n\nint __modbusObjectcall Modbus::pollModbus_0008043e(Modbus *modbusObject,pollfd *fileDescriptors,nfds_t numFileDescriptors,int timeout)\n\n{\n  byte byteValue;\n  uint8_t errorCode;\n  uint8_t exceptionCode;\n  uint32_t currentMillis;\n  uint8_t currentValue;\n  uint receivedValue;\n  \n  if (modbusObject->serialNumber < 4) {\n    byteValue = (**(code **)(*(int *)modbusObject->port + 8))();\n    receivedValue = (uint)byteValue;\n  }\n  currentMillis = millis();\n  if (modbusObject->timeoutValue < currentMillis) {\n    modbusObject->lastErrorCode = 0xff;\n    modbusObject->stateValue = '\\0';\n    modbusObject->errorCount = modbusObject->errorCount + 1;\n  }\n  else if (7 < receivedValue) {\n    getRxBuffer(modbusObject);\n    errorCode = validateAnswer(modbusObject);\n    if (errorCode == '\\0') {\n      if (modbusObject->receiveBuffer[1] - 3 < 2) {\n        get_FC3(modbusObject);\n      }\n      modbusObject->stateValue = '\\0';\n      errorCode = modbusObject->bufferSize;\n    }\n    else {\n      modbusObject->stateValue = '\\0';\n    }\n    goto LAB_000804a2;\n  }\n  errorCode = '\\0';\nLAB_000804a2:\n  return (int)(char)errorCode;\n}\n\n",
            "renaming": {
                "__fds": "fileDescriptors",
                "__nfds": "numFileDescriptors",
                "__timeout": "timeout",
                "bVar1": "byteValue",
                "uVar2": "errorCode",
                "u8exception": "exceptionCode",
                "uVar3": "currentMillis",
                "u8current": "currentValue",
                "unaff_r6": "receivedValue",
                "u8serno": "serialNumber",
                "this": "modbusObject",
                "u32timeOut": "timeoutValue",
                "u8lastError": "lastErrorCode",
                "u8state": "stateValue",
                "u16errCnt": "errorCount",
                "u8BufferSize": "bufferSize",
                "au8Buffer": "receiveBuffer",
                "FUN_0008043e": "poll_modbus_0008043e"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "getRxBuffer",
                "get_FC3",
                "validateAnswer",
                "millis"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000804a8": {
            "entrypoint": "0x000804a8",
            "current_name": "initialize_modbus_communication_000804a8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeModbusCommunication_000804a8(void)\n\n{\n  uint32_t currentMillis;\n  \n  pinMode(1,0);\n  pinMode(6,1);\n  pinMode(0,1);\n  pinMode(1,1);\n  digitalWrite(0,0);\n  digitalWrite(1,0);\n  modbusMessages[1].registerAddress = 0x13;\n  modbusMessages[1].coilsNumber = 10;\n  modbusMessages[1].modbusData = au16data + 0x13;\n  modbusMessages[0].functionCode = '\\x03';\n  modbusMessages[2].functionCode = '\\x03';\n  modbusMessages[2].registerAddress = 0x14;\n  modbusMessages[3].coilsNumber = 3;\n  modbusMessages[0].coilsNumber = 0x10;\n  modbusMessages[0].modbusData = au16data;\n  modbusMessages[1].functionCode = '\\x10';\n  modbusMessages[2].coilsNumber = 0xc;\n  modbusMessages[3].functionCode = '\\x10';\n  modbusMessages[4].coilsNumber = 8;\n  modbusMessages[3].registerAddress = 0x1c;\n  modbusMessages[3].modbusData = au16data + 0x1c;\n  modbusMessages[4].deviceID = '\\x02';\n  modbusMessages[4].functionCode = '\\x02';\n  modbusMessages[4].modbusData = data8024;\n  modbusMessages[5].deviceID = '\\x02';\n  modbusMessages[0].deviceID = '\\x01';\n  modbusMessages[1].deviceID = '\\x01';\n  modbusMessages[2].deviceID = '\\x01';\n  modbusMessages[3].deviceID = '\\x01';\n  modbusMessages[5].registerAddress = 1;\n  modbusMessages[5].coilsNumber = 1;\n  modbusMessages[0].registerAddress = 0;\n  modbusMessages[2].modbusData = au16data + 0x14;\n  modbusMessages[4].registerAddress = 0;\n  modbusMessages[5].functionCode = '\\x05';\n  modbusMessages[5].modbusData = data8024 + 1;\n  initializeModbus(&modbusMaster,0x4b00);\n  modbusMaster.u16timeOut = 2000;\n  startTime = millis();\n  currentMillis = millis();\n  pid1Time = currentMillis + 1000;\n  currentMillis = millis();\n  dutyHigh1 = currentMillis + 1000;\n  currentMillis = millis();\n  dutyLow1 = currentMillis + 1000;\n  currentMillis = millis();\n  clockTime = currentMillis + 1000;\n  state = '\\0';\n  startForkserver(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000804a8": "initialize_modbus_communication_000804a8",
                "uVar1": "currentMillis",
                "u32wait": "startTime",
                "tiempopid1": "pid1Time",
                "dutyalto1": "dutyHigh1",
                "dutybajo1": "dutyLow1",
                "reloj": "clockTime",
                "u8state": "state",
                "telegram": "modbusMessages",
                "u16RegAdd": "registerAddress",
                "u16CoilsNo": "coilsNumber",
                "au16reg": "modbusData",
                "u8fct": "functionCode",
                "u8id": "deviceID",
                "Modbus::begin": "initializeModbus",
                "master": "modbusMaster"
            },
            "calling": [
                "main"
            ],
            "called": [
                "pinMode",
                "millis",
                "startForkserver",
                "digitalWrite",
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000805d0": {
            "entrypoint": "0x000805d0",
            "current_name": "process_modbus_data_000805d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processModbusData_000805d0(void)\n\n{\n  modbus_t telegram;\n  modbus_t telegram_00;\n  modbus_t telegram_01;\n  modbus_t telegram_02;\n  uint32_t uVar1;\n  undefined4 uVar2;\n  float fVar3;\n  float fVar4;\n  float fVar5;\n  int iVar6;\n  pollfd *pollFds;\n  nfds_t numFds;\n  int *ptrEsperaPlancha;\n  uint timeout;\n  undefined4 data_0;\n  undefined4 data_1;\n  float *ptrE1;\n  undefined4 data_2;\n  ulong *ptrReloj;\n  float *ptrKdp1;\n  \n  timeout = (uint)currentState;\n  switch(timeout) {\n  case 0:\n    uVar1 = millis();\n    if (waitTimestamp < uVar1) goto LAB_000806ca;\n    break;\n  case 1:\n    Modbus::poll(&modbusMaster,pollFds,numFds,timeout);\n    if (modbusMaster.currentState == '\\0') {\n      telegram._4_4_ = data_1;\n      telegram.u8id = (char)data_0;\n      telegram.u8fct = (char)((uint)data_0 >> 8);\n      telegram.u16RegAdd = (short)((uint)data_0 >> 0x10);\n      telegram.au16reg = (uint16_t *)data_2;\n      Modbus::query(&modbusMaster,telegram);\n      currentState = currentState + '\\x01';\n      waitTimestamp = millis();\n      temperature1 = (int)dataArray[1];\n      temperature2 = (int)dataArray[2];\n      kp1 = (float)__floatunsisf(dataArray[6]);\n      ki1 = (float)__floatsisf(dataArray[7] / 10);\n      kd1 = (float)__floatunsisf(dataArray[8]);\n      dutyCycle2 = (int)dataArray[12];\n      dutyCycle1 = (int)dataArray[9];\n      minutes = (int)dataArray[14];\n      seconds = (int)dataArray[15];\n    }\n    break;\n  case 2:\n  case 4:\n  case 6:\n  case 8:\n    Modbus::poll(&modbusMaster,pollFds,numFds,timeout);\n    if (modbusMaster.currentState == '\\0') {\n      currentState = currentState + '\\x01';\n      waitTimestamp = millis();\n    }\n    break;\n  case 3:\n    Modbus::poll(&modbusMaster,pollFds,numFds,timeout);\n    if (modbusMaster.currentState == '\\0') {\n      telegram_00._4_4_ = data_1;\n      telegram_00.u8id = (char)data_0;\n      telegram_00.u8fct = (char)((uint)data_0 >> 8);\n      telegram_00.u16RegAdd = (short)((uint)data_0 >> 0x10);\n      telegram_00.au16reg = (uint16_t *)data_2;\n      Modbus::query(&modbusMaster,telegram_00);\n      currentState = currentState + '\\x01';\n      waitTimestamp = millis();\n      waitingTime = (int)dataArray[30];\n      state = (int)dataArray[29];\n    }\n    break;\n  case 5:\n    Modbus::poll(&modbusMaster,pollFds,numFds,timeout);\n    if (modbusMaster.currentState == '\\0') {\nLAB_000806c4:\n      telegram_01._4_4_ = data_1;\n      telegram_01.u8id = (char)data_0;\n      telegram_01.u8fct = (char)((uint)data_0 >> 8);\n      telegram_01.u16RegAdd = (short)((uint)data_0 >> 0x10);\n      telegram_01.au16reg = (uint16_t *)data_2;\n      Modbus::query(&modbusMaster,telegram_01);\n      goto LAB_000806ca;\n    }\n    break;\n  case 7:\n    Modbus::poll(&modbusMaster,pollFds,numFds,timeout);\n    if ((endCycle == 1) && (modbusMaster.currentState == '\\0')) {\n      dataArray[29] = 0;\n      endCycle = 0;\n      goto LAB_000806c4;\n    }\nLAB_000806ca:\n    currentState = currentState + '\\x01';\n    break;\n  case 9:\n    Modbus::poll(&modbusMaster,pollFds,numFds,timeout);\n    if (modbusMaster.currentState == '\\0') {\n      telegram_02._4_4_ = data_1;\n      telegram_02.u8id = (char)data_0;\n      telegram_02.u8fct = (char)((uint)data_0 >> 8);\n      telegram_02.u16RegAdd = (short)((uint)data_0 >> 0x10);\n      telegram_02.au16reg = (uint16_t *)data_2;\n      Modbus::query(&modbusMaster,telegram_02);\n      waitTimestamp = millis();\n    }\n    currentState = '\\0';\n  }\n  mmTemp = minutes - mmResult;\n  if (mmTemp < 0) {\n    mmTemp = mmTemp + 0x3c;\n  }\n  ssTemp = seconds - ssResult;\n  if (ssTemp < 0) {\n    mmTemp = mmTemp + -1;\n    ssTemp = ssTemp + 0x3c;\n  }\n  dataArray[27] = (ushort)mmTemp;\n  dataArray[28] = (ushort)ssTemp;\n  if ((mmTemp == 0) && (ssTemp == 0)) {\n    endCycle = 1;\n    mmResult = ssTemp;\n    ssResult = ssTemp;\n  }\n  if (minutesp == minutes) {\n    secondsp = 1 - seconds;\n    if (1 < (uint)seconds) {\n      secondsp = 0;\n    }\n    if (secondsp != 0) goto LAB_00080a08;\n  }\n  else {\nLAB_00080a08:\n    secondsp = seconds;\n    mmResult = 0;\n    ssResult = 0;\n    espera_plancha = 0;\n    minutesp = minutes;\n  }\n  if (state == 0) {\n    mmResult = state;\n    ssResult = state;\n    ptrEsperaPlancha = &espera_plancha;\nLAB_000808f2:\n    *ptrEsperaPlancha = ssResult;\n  }\n  else {\n    if (state != 1) goto LAB_000808f4;\n    if ((espera_plancha < waitingTime) && (uVar1 = millis(), clock < uVar1)) {\n      espera_plancha = espera_plancha + 1;\n      ptrReloj = &clock;\n      uVar1 = millis();\n      *ptrReloj = uVar1 + 1000;\n    }\n    if (espera_plancha < waitingTime) goto LAB_000808f4;\n    espera_plancha = waitingTime + 1;\n    if (mmResult < minutes) {\n      uVar1 = millis();\n      if (clock < uVar1) {\n        ssResult = ssResult + 1;\n        uVar1 = millis();\n        clock = uVar1 + 1000;\n      }\n    }\n    else {\n      if (mmResult != minutes) goto LAB_000808f4;\n      if (seconds < ssResult) {\n        ptrEsperaPlancha = &mmResult;\n        ssResult = 0;\n        goto LAB_000808f2;\n      }\n      uVar1 = millis();\n      if (clock < uVar1) {\n        ssResult = ssResult + 1;\n        uVar1 = millis();\n        clock = uVar1 + 1000;\n      }\n    }\n    if (0x3b < ssResult) {\n      ssResult = 0;\n      mmResult = mmResult + 1;\n    }\n  }\nLAB_000808f4:\n  uVar1 = millis();\n  if (pid1Time < uVar1) {\n    uVar2 = __floatsisf(temperature1);\n    fVar3 = (float)__aeabi_fsub(uVar2,temperatura1);\n    ptrE1 = &ep1;\n    e1 = fVar3;\n    fVar5 = ep1;\n    uVar2 = __addsf3(fVar3,ep1);\n    uVar2 = __aeabi_fmul(uVar2,ki1);\n    fVar4 = (float)__addsf3(uVar2,kip1);\n    ki1 = fVar4;\n    uVar2 = __aeabi_fsub(fVar3,fVar5);\n    uVar2 = __aeabi_fmul(uVar2,kd1);\n    ptrKdp1 = &kdp1;\n    fVar5 = (float)__aeabi_fsub(uVar2,kdp1);\n    kd1 = fVar5;\n    uVar2 = __aeabi_fmul(fVar3,kp1);\n    uVar2 = __addsf3(uVar2,fVar4);\n    __addsf3(uVar2,fVar5);\n    pid1 = __aeabi_f2iz();\n    YN = (float)__floatsisf();\n    *ptrE1 = fVar3;\n    increment = 0;\n    kip1 = fVar4;\n    *ptrKdp1 = fVar5;\n    uVar1 = millis();\n    pid1Time = uVar1 + dutyCycle1;\n  }\n  fVar5 = (float)__floatsisf(dutyCycle1);\n  iVar6 = __aeabi_fcmpge(YN,fVar5);\n  if (iVar6 != 0) {\n    YN = fVar5;\n  }\n  iVar6 = __aeabi_fcmple(YN,0);\n  if (iVar6 != 0) {\n    YN = 0.0;\n  }\n  dataArray[21] = __fixunssfsi(YN);\n  increment = increment + 1;\n  input1 = data8024[0] & 1 ^ 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000805d0": "process_modbus_data_000805d0",
                "u8state": "currentState",
                "u32wait": "waitTimestamp",
                "master": "modbusMaster",
                "in_r1": "pollFds",
                "in_r2": "numFds",
                "piVar7": "ptrEsperaPlancha",
                "__timeout": "timeout",
                "in_stack_ffffffc8": "data_0",
                "in_stack_ffffffcc": "data_1",
                "pfVar8": "ptrE1",
                "in_stack_ffffffd0": "data_2",
                "puVar9": "ptrReloj",
                "pfVar10": "ptrKdp1",
                "tempe_z1": "temperature1",
                "tempe_z2": "temperature2",
                "kpa1": "kp1",
                "kia1": "ki1",
                "kda1": "kd1",
                "duty2": "dutyCycle2",
                "duty1": "dutyCycle1",
                "minutos": "minutes",
                "segundos": "seconds",
                "au16data": "dataArray",
                "mmt": "mmTemp",
                "sst": "ssTemp",
                "terminar_ciclo": "endCycle",
                "mmres": "mmResult",
                "ssres": "ssResult",
                "tiempo_espera": "waitingTime",
                "estado": "state",
                "reloj": "clock",
                "tiempopid1": "pid1Time",
                "incre": "increment",
                "in1": "input1"
            },
            "calling": [
                "main"
            ],
            "called": [
                "__floatunsisf",
                "__aeabi_fmul",
                "__aeabi_fcmple",
                "__addsf3",
                "__floatsisf",
                "query",
                "__aeabi_fsub",
                "__aeabi_fcmpge",
                "poll",
                "millis",
                "__fixunssfsi",
                "__aeabi_f2iz"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a68": {
            "entrypoint": "0x00080a68",
            "current_name": "initialize_master_00080a68",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeMaster_00080a68(void)\n\n{\n  String::String(&emptyString,\"\");\n  __aeabi_atexit(&emptyString,0x815ff,&__dso_handle);\n  device.deviceId = '\\0';\n  device.serialNumber = '\\0';\n  device.transmitEnablePin = '\\x06';\n  device.timeout = 1000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080a68": "initialize_master_00080a68",
                "RxString": "emptyString",
                "master": "device",
                "u8id": "deviceId",
                "u8serno": "serialNumber",
                "u8txenpin": "transmitEnablePin",
                "u16timeOut": "timeout"
            },
            "calling": [],
            "called": [
                "__aeabi_atexit",
                "String"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080aa8": {
            "entrypoint": "0x00080aa8",
            "current_name": "FUNC_00080aa8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080aa8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080aa8": "FUNC_00080aa8"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080aac": {
            "entrypoint": "0x00080aac",
            "current_name": "handle_serial_interrupt_00080aac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSerialInterrupt_00080aac(void)\n\n{\n  UARTClass::IrqHandler(&serialObject);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080aac": "handle_serial_interrupt_00080aac",
                "Serial": "serialObject"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ab8": {
            "entrypoint": "0x00080ab8",
            "current_name": "FUNC_00080ab8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080ab8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080ab8": "FUNC_00080ab8"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080aba": {
            "entrypoint": "0x00080aba",
            "current_name": "FUNC_00080aba",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080aba(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080aba": "FUNC_00080aba"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080abc": {
            "entrypoint": "0x00080abc",
            "current_name": "FUNC_00080abc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080abc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080abc": "FUNC_00080abc"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080ac0": {
            "entrypoint": "0x00080ac0",
            "current_name": "handle_serial_irq_00080ac0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSerialIrq_00080ac0(void)\n\n{\n  handleUartInterrupt(&serial1UartClassObject);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080ac0": "handle_serial_irq_00080ac0",
                "UARTClass::IrqHandler": "handleUartInterrupt",
                "&Serial1.super_UARTClass": "&serial1UartClassObject"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080acc": {
            "entrypoint": "0x00080acc",
            "current_name": "handle_serial_interrupt_00080acc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSerialInterrupt_00080acc(void)\n\n{\n  UARTClass::IrqHandler(&Serial2.super_UARTClass);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080acc": "handle_serial_interrupt_00080acc"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ad8": {
            "entrypoint": "0x00080ad8",
            "current_name": "handle_serial3_irq_00080ad8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSerial3Irq_00080ad8(void)\n\n{\n  handleIrq(serial3);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080ad8": "handle_serial3_irq_00080ad8",
                "&Serial3.super_UARTClass": "serial3",
                "UARTClass::IrqHandler": "handleIrq"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ae4": {
            "entrypoint": "0x00080ae4",
            "current_name": "initialize_device_00080ae4",
            "code": "\n\n\nint initializeDevice_00080ae4(EVP_PKEY_CTX *context)\n\n{\n  int returnValue;\n  uint32_t pinIndex;\n  uint32_t nextPinIndex;\n  \n  SystemInit();\n  _DAT_e000e014 = SystemCoreClock / 1000 - 1;\n  DAT_e000ed23 = 0xf0;\n  _DAT_e000e018 = 0;\n  _DAT_e000e010 = 7;\n  __libc_init_array();\n  pinIndex = 0;\n  do {\n    nextPinIndex = pinIndex + 1;\n    digitalWrite(pinIndex,0);\n    pinIndex = nextPinIndex;\n  } while (nextPinIndex != 0x4f);\n  _DAT_400e0ea0 = 0xffffffff;\n  _DAT_400e10a0 = 0xffffffff;\n  _DAT_400e12a0 = 0xffffffff;\n  _DAT_400e14a0 = 0xffffffff;\n  PIO_Configure(&DAT_400e0e00,1,0x300,0);\n  digitalWrite(0,1);\n  PIO_Configure(&DAT_400e0e00,1,0xc00,0);\n  PIO_Configure(&DAT_400e0e00,1,0x3000,0);\n  PIO_Configure(&DAT_400e1400,2,0x30,0);\n  PIO_Configure(&DAT_400e1000,1,0xc00,0);\n  PIO_Configure(&DAT_400e0e00,1,3,0);\n  PIO_Configure(&DAT_400e1000,1,0xc000,0);\n  pmc_enable_periph_clk(0x25);\n  adc_init(0x400c0000,SystemCoreClock,20000000,0xc);\n  adc_configure_timing(0x400c0000,0,0x300000,1);\n  adc_configure_trigger(0x400c0000,0,0);\n  adc_disable_interrupt(0x400c0000,0xffffffff);\n  returnValue = adc_disable_all_channel(0x400c0000);\n  analogOutputInit();\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00080ae4": "initialize_device_00080ae4",
                "ctx": "context",
                "iVar1": "returnValue",
                "ulPin": "pinIndex",
                "uVar2": "nextPinIndex"
            },
            "calling": [
                "main"
            ],
            "called": [
                "PIO_Configure",
                "SystemInit",
                "adc_configure_trigger",
                "adc_disable_interrupt",
                "analogOutputInit",
                "adc_configure_timing",
                "digitalWrite",
                "__libc_init_array",
                "pmc_enable_periph_clk",
                "adc_disable_all_channel",
                "adc_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080c0c": {
            "entrypoint": "0x00080c0c",
            "current_name": "initialize_serial_communication_00080c0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_00080c0c(void)\n\n{\n  RingBuffer::RingBuffer(&receiveBuffer1);\n  RingBuffer::RingBuffer(&transmitBuffer1);\n  UARTClass::UARTClass(&serialPort,(Uart *)0x400e0800,UART_IRQn,8,&receiveBuffer1,&transmitBuffer1);\n  RingBuffer::RingBuffer(&receiveBuffer2);\n  RingBuffer::RingBuffer(&receiveBuffer3);\n  RingBuffer::RingBuffer(&receiveBuffer4);\n  RingBuffer::RingBuffer(&transmitBuffer2);\n  RingBuffer::RingBuffer(&transmitBuffer3);\n  RingBuffer::RingBuffer(&transmitBuffer4);\n  USARTClass::USARTClass(&serialPort1,(Usart *)0x40098000,USART0_IRQn,0x11,&receiveBuffer2,&transmitBuffer2);\n  USARTClass::USARTClass(&serialPort2,(Usart *)0x4009c000,USART1_IRQn,0x12,&receiveBuffer3,&transmitBuffer3);\n  USARTClass::USARTClass(&serialPort3,(Usart *)0x400a4000,USART3_IRQn,0x14,&receiveBuffer4,&transmitBuffer4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080c0c": "initialize_serial_communication_00080c0c",
                "rx_buffer1": "receiveBuffer1",
                "tx_buffer1": "transmitBuffer1",
                "Serial": "serialPort",
                "Serial1": "serialPort1",
                "Serial2": "serialPort2",
                "Serial3": "serialPort3",
                "rx_buffer2": "receiveBuffer2",
                "rx_buffer3": "receiveBuffer3",
                "rx_buffer4": "receiveBuffer4",
                "tx_buffer2": "transmitBuffer2",
                "tx_buffer3": "transmitBuffer3",
                "tx_buffer4": "transmitBuffer4"
            },
            "calling": [],
            "called": [
                "UARTClass",
                "RingBuffer",
                "USARTClass"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ce0": {
            "entrypoint": "0x00080ce0",
            "current_name": "process_serial_events_00080ce0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processSerialEvents_00080ce0(void)\n\n{\n  int availableCount;\n  \n  availableCount = UARTClass::available(&Serial);\n  if (availableCount != 0) {\n    serialEvent();\n  }\n  availableCount = UARTClass::available(&Serial1);\n  if (availableCount != 0) {\n    serialEvent1();\n  }\n  availableCount = UARTClass::available(&Serial2);\n  if (availableCount != 0) {\n    serialEvent2();\n  }\n  availableCount = UARTClass::available(&Serial3);\n  if (availableCount != 0) {\n    serialEvent3();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080ce0": "process_serial_events_00080ce0",
                "iVar1": "availableCount",
                "&Serial1.super_UARTClass": "&Serial1",
                "&Serial2.super_UARTClass": "&Serial2",
                "&Serial3.super_UARTClass": "&Serial3"
            },
            "calling": [
                "main"
            ],
            "called": [
                "serialEvent2",
                "serialEvent3",
                "serialEvent1",
                "serialEvent",
                "available"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d24": {
            "entrypoint": "0x00080d24",
            "current_name": "set_param_value_00080d24",
            "code": "\nvoid setParamValue_00080d24(int objectAddress,undefined4 newValue,int flag)\n\n{\n  if (flag != 0) {\n    *(undefined4 *)(objectAddress + 100) = newValue;\n    return;\n  }\n  *(undefined4 *)(objectAddress + 0x60) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d24": "set_param_value_00080d24",
                "param_1": "objectAddress",
                "param_2": "newValue",
                "param_3": "flag"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d2e": {
            "entrypoint": "0x00080d2e",
            "current_name": "update_parameter_00080d2e",
            "code": "\nvoid updateParameter_00080d2e(int baseAddress,undefined4 operation,uint value)\n\n{\n  uint result;\n  \n  *(uint *)(baseAddress + 0x44) = value;\n  switch(operation) {\n  case 0:\n  case 3:\n  case 4:\n  case 5:\n    return;\n  case 1:\n    result = *(uint *)(baseAddress + 0x70) & *(uint *)(baseAddress + 0x70) & ~value;\n    break;\n  case 2:\n    result = *(uint *)(baseAddress + 0x70) | value;\n    break;\n  default:\n    goto switchD_00080d34_caseD_6;\n  }\n  *(uint *)(baseAddress + 0x70) = result;\nswitchD_00080d34_caseD_6:\n  *(uint *)(baseAddress + 4) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d2e": "update_parameter_00080d2e",
                "param_1": "baseAddress",
                "param_2": "operation",
                "param_3": "value",
                "uVar1": "result"
            },
            "calling": [
                "PIO_Configure"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d54": {
            "entrypoint": "0x00080d54",
            "current_name": "update_parameters_00080d54",
            "code": "\nvoid updateParameters_00080d54(undefined4 *params,undefined4 value,uint flags)\n\n{\n  bool isNegative;\n  \n  isNegative = (int)(flags << 0x1f) < 0;\n  params[17] = value;\n  if (isNegative) {\n    params[25] = value;\n  }\n  if (!isNegative) {\n    params[24] = value;\n  }\n  isNegative = (flags & 10) != 0;\n  if (isNegative) {\n    params[8] = value;\n  }\n  if (!isNegative) {\n    params[9] = value;\n  }\n  if (((int)(flags << 0x1e) < 0) || ((int)(flags << 0x1c) < 0)) {\n    params[32] = value;\n  }\n  params[5] = value;\n  *params = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d54": "update_parameters_00080d54",
                "param_1": "params",
                "param_2": "value",
                "param_3": "flags",
                "bVar1": "isNegative",
                "param_1[0x11]": "params[17]",
                "param_1[0x19]": "params[25]",
                "param_1[0x18]": "params[24]",
                "param_1[8]": "params[8]",
                "param_1[9]": "params[9]",
                "param_1[0x20]": "params[32]",
                "param_1[5]": "params[5]"
            },
            "calling": [
                "PIO_Configure"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d7a": {
            "entrypoint": "0x00080d7a",
            "current_name": "update_params_00080d7a",
            "code": "\nvoid updateParams_00080d7a(undefined4 *output,undefined4 input,int condition1,int condition2,int condition3)\n\n{\n  output[0x11] = input;\n  if (condition3 == 0) {\n    output[0x18] = input;\n  }\n  else {\n    output[0x19] = input;\n  }\n  if (condition2 == 0) {\n    output[0x15] = input;\n  }\n  else {\n    output[0x14] = input;\n  }\n  if (condition1 == 0) {\n    output[0xd] = input;\n  }\n  else {\n    output[0xc] = input;\n  }\n  output[4] = input;\n  *output = input;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d7a": "update_params_00080d7a",
                "param_1": "output",
                "param_2": "input",
                "param_3": "condition1",
                "param_4": "condition2",
                "param_5": "condition3"
            },
            "calling": [
                "PIO_Configure",
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080da0": {
            "entrypoint": "0x00080da0",
            "current_name": "set_peripheral_00080da0",
            "code": "\nundefined4 setPeripheral_00080da0(int peripheral,int type,undefined4 value,uint flag)\n\n{\n  bool isNegative;\n  \n  switch(type) {\n  case 1:\n  case 2:\n    setPeripheral_00080da0Type(peripheral,type,value);\n    isNegative = (int)(flag << 0x1f) < 0;\n    *(undefined4 *)(peripheral + 0x44) = value;\n    if (isNegative) {\n      *(undefined4 *)(peripheral + 100) = value;\n    }\n    if (!isNegative) {\n      *(undefined4 *)(peripheral + 0x60) = value;\n    }\n    break;\n  case 3:\n    setInput(peripheral,value,flag,0x80d55,peripheral);\n    break;\n  case 4:\n  case 5:\n    setOutput(peripheral,value,type == 5,(flag << 0x1d) >> 0x1f,flag & 1,type,value\n                 );\n    break;\n  default:\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080da0": "set_peripheral_00080da0",
                "param_1": "peripheral",
                "param_2": "type",
                "param_3": "value",
                "param_4": "flag",
                "bVar1": "isNegative",
                "PIO_SetPeripheral": "setPeripheralType",
                "PIO_SetInput": "setInput",
                "PIO_SetOutput": "setOutput"
            },
            "calling": [
                "pinMode",
                "init"
            ],
            "called": [
                "PIO_SetOutput",
                "PIO_SetInput",
                "PIO_SetPeripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e04": {
            "entrypoint": "0x00080e04",
            "current_name": "check_intersection_00080e04",
            "code": "\nuint check_intersection_00080e04(int pointer1,uint value)\n\n{\n  uint result;\n  \n  result = *(uint *)(pointer1 + 8) & value;\n  if (result != 0) {\n    if ((value & *(uint *)(pointer1 + 0x18)) == 0) {\n      result = 0;\n    }\n    else {\n      result = 1;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00080e04": "check_intersection_00080e04",
                "param_1": "pointer1",
                "param_2": "value",
                "uVar1": "result"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e18": {
            "entrypoint": "0x00080e18",
            "current_name": "check_and_update_bit_00080e18",
            "code": "\n\n\nundefined4 check_and_update_bit_00080e18(uint input_value)\n\n{\n  uint bit_mask;\n  \n  if (input_value < 0x2d) {\n    if (input_value < 0x20) {\n      bit_mask = 1 << (input_value & 0xff);\n      if ((bit_mask & _DAT_400e0618) != bit_mask) {\n        _DAT_400e0610 = bit_mask;\n      }\n    }\n    else {\n      bit_mask = 1 << (input_value - 0x20 & 0xff);\n      if ((bit_mask & _DAT_400e0708) != bit_mask) {\n        _DAT_400e0700 = bit_mask;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080e18": "check_and_update_bit_00080e18",
                "param_1": "input_value",
                "uVar1": "bit_mask"
            },
            "calling": [
                "pinMode",
                "init",
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e5c": {
            "entrypoint": "0x00080e5c",
            "current_name": "check_and_set_bitmask_00080e5c",
            "code": "\n\n\nundefined4 checkAndSetBitmask_00080e5c(uint inputValue)\n\n{\n  uint bitmask;\n  uint result;\n  \n  if (inputValue < 0x2d) {\n    if (inputValue < 0x20) {\n      bitmask = 1 << (inputValue & 0xff);\n      result = _DAT_400e0618 & bitmask;\n      if (result == bitmask) {\n        _DAT_400e0614 = result;\n      }\n    }\n    else {\n      bitmask = 1 << (inputValue - 0x20 & 0xff);\n      result = _DAT_400e0708 & bitmask;\n      if (result == bitmask) {\n        _DAT_400e0704 = result;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080e5c": "check_and_set_bitmask_00080e5c",
                "param_1": "inputValue",
                "uVar1": "bitmask",
                "uVar2": "result"
            },
            "calling": [
                "pinMode",
                "end"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e9c": {
            "entrypoint": "0x00080e9c",
            "current_name": "initialize_system_00080e9c",
            "code": "\n\n\nvoid initializeSystem_00080e9c(void)\n\n{\n  _DAT_400e0a00 = 0x400;\n  _DAT_400e0c00 = 0x400;\n  _DAT_400e0620 = _DAT_400e0620 << 7;\n  while (-1 < _DAT_400e0620) {\n    _DAT_400e0620 = _DAT_400e0668 << 0x1f;\n  }\n  _DAT_400e0620 = 0x1370809;\n  do {\n  } while (-1 < _DAT_400e0668 << 0xf);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0628 = 0x200d3f01;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1e);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0630 = 0x12;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  clockFreq = 84000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080e9c": "initialize_system_00080e9c",
                "SystemCoreClock": "clockFreq"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080f24": {
            "entrypoint": "0x00080f24",
            "current_name": "copy_data_00080f24",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080f6e) */\n\n\nvoid copyData_00080f24(void)\n\n{\n  int offset;\n  undefined4 *ptr;\n  \n  for (offset = 0; source + offset < destination_end; offset = offset + 4) {\n    *(undefined4 *)(source + offset) = *(undefined4 *)(&source_end + offset);\n  }\n  for (ptr = destination_end; ptr < destination; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  _DAT_e000ed08 = 0x80000;\n  main();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080f24": "copy_data_00080f24",
                "iVar1": "offset",
                "puVar2": "ptr",
                "banzai": "source",
                "&completed_7857": "destination_end",
                "_etext": "source_end",
                "&_ebss": "destination"
            },
            "calling": [],
            "called": [
                "banzai",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080f9c": {
            "entrypoint": "0x00080f9c",
            "current_name": "calculate_descriptive_value_00080f9c",
            "code": "\nundefined4 calculateDescriptiveValue_00080f9c(undefined4 *output,uint inputSize,int calculationFactor,int threshold)\n\n{\n  uint quotient;\n  uint index;\n  uint thresholdValues [16];\n  \n  thresholdValues[0] = 0;\n  thresholdValues[1] = 8;\n  thresholdValues[2] = 0x10;\n  thresholdValues[3] = 0x18;\n  thresholdValues[4] = 0x40;\n  thresholdValues[5] = 0x50;\n  thresholdValues[6] = 0x60;\n  thresholdValues[7] = 0x70;\n  thresholdValues[8] = 0x200;\n  thresholdValues[9] = 0x240;\n  thresholdValues[10] = 0x280;\n  thresholdValues[11] = 0x2c0;\n  thresholdValues[12] = 0x300;\n  thresholdValues[13] = 0x340;\n  thresholdValues[14] = 0x380;\n  thresholdValues[15] = 0x3c0;\n  *output = 1;\n  output[1] = 0;\n  output[0x48] = 0x202;\n  output[0x41] = 0;\n  output[0x45] = 0;\n  quotient = inputSize / (uint)(calculationFactor * 2);\n  if (inputSize == calculationFactor * 2 * quotient) {\n    quotient = quotient - 1;\n  }\n  index = 0;\n  do {\n    if ((uint)(threshold * (int)(((ulonglong)inputSize / (ulonglong)((quotient + 1) * 2)) / 1000000)) <=\n        thresholdValues[index]) {\n      output[1] = (index & 0xf) << 0x10 | (quotient & 0xff) << 8 | output[1];\n      return 0;\n    }\n    index = index + 1;\n  } while (index != 0x10);\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080f9c": "calculate_descriptive_value_00080f9c",
                "param_1": "output",
                "param_2": "inputSize",
                "param_3": "calculationFactor",
                "param_4": "threshold",
                "uVar1": "quotient",
                "uVar2": "index",
                "local_58": "thresholdValues"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081034": {
            "entrypoint": "0x00081034",
            "current_name": "update_param_with_flag_00081034",
            "code": "\nvoid updateParamWithFlag_00081034(int ptr,uint value,uint flag)\n\n{\n  *(uint *)(ptr + 4) = value | *(uint *)(ptr + 4) | (flag & 1) << 7;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081034": "update_param_with_flag_00081034",
                "param_1": "ptr",
                "param_2": "value",
                "param_3": "flag"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081042": {
            "entrypoint": "0x00081042",
            "current_name": "update_config_values_00081042",
            "code": "\nvoid updateConfigValues_00081042(int configAddress,uint paramA,uint paramB,uint paramC)\n\n{\n  *(uint *)(configAddress + 4) =\n       paramB | *(uint *)(configAddress + 4) | (paramA & 0xf) << 0x18 | (paramC & 3) << 0x1c;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081042": "update_config_values_00081042",
                "param_1": "configAddress",
                "param_2": "paramA",
                "param_3": "paramB",
                "param_4": "paramC"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008105c": {
            "entrypoint": "0x0008105c",
            "current_name": "set_bit_at_position_0008105c",
            "code": "\nvoid setBitAtPosition_0008105c(int baseAddress,uint position)\n\n{\n  *(int *)(baseAddress + 0x14) = 1 << (position & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008105c": "set_bit_at_position_0008105c",
                "param_1": "baseAddress",
                "param_2": "position"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081066": {
            "entrypoint": "0x00081066",
            "current_name": "initialize_value_00081066",
            "code": "\nvoid initializeValue_00081066(int baseAddress)\n\n{\n  *(undefined4 *)(baseAddress + 0x14) = 0xffff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081066": "initialize_value_00081066",
                "param_1": "baseAddress"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008106e": {
            "entrypoint": "0x0008106e",
            "current_name": "set_param_value_0008106e",
            "code": "\nvoid setParamValue_0008106e(int objectAddress,undefined4 newValue)\n\n{\n  *(undefined4 *)(objectAddress + 0x28) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008106e": "set_param_value_0008106e",
                "param_1": "objectAddress",
                "param_2": "newValue"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081074": {
            "entrypoint": "0x00081074",
            "current_name": "execute_isr_00081074",
            "code": "\nvoid execute_isr_00081074(void)\n\n{\n  if (isr_function != (code *)0x0) {\n    (*isr_function)();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081074": "execute_isr_00081074",
                "gpf_isr": "isr_function"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081084": {
            "entrypoint": "0x00081084",
            "current_name": "execute_callbacks_00081084",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid executeCallbacks_00081084(void)\n\n{\n  uint8_t numLeadingZeros;\n  uint32_t interruptStatusReg;\n  uint bitIndex;\n  \n  for (interruptStatusReg = _DAT_400e0e4c; (uint)LZCOUNT(interruptStatusReg) < 0x20; interruptStatusReg = interruptStatusReg & ~(1 << bitIndex)) {\n    bitIndex = 0x1fU - LZCOUNT(interruptStatusReg) & 0xff;\n    if (callbacksPioA[bitIndex] != (interruptCB)0x0) {\n      (*callbacksPioA[bitIndex])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081084": "execute_callbacks_00081084",
                "leading_zeros": "numLeadingZeros",
                "isr": "interruptStatusReg",
                "uVar1": "bitIndex"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810bc": {
            "entrypoint": "0x000810bc",
            "current_name": "process_interrupts_000810bc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid processInterrupts_000810bc(void)\n\n{\n  uint8_t countLeadingZeros;\n  uint32_t interruptStatus;\n  uint shiftAmount;\n  \n  for (interruptStatus = _DAT_400e104c; (uint)LZCOUNT(interruptStatus) < 0x20; interruptStatus = interruptStatus & ~(1 << shiftAmount)) {\n    shiftAmount = 0x1fU - LZCOUNT(interruptStatus) & 0xff;\n    if (callbacksPioB[shiftAmount] != (interruptCB)0x0) {\n      (*callbacksPioB[shiftAmount])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810bc": "process_interrupts_000810bc",
                "isr": "interruptStatus",
                "leading_zeros": "countLeadingZeros",
                "uVar1": "shiftAmount"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810f4": {
            "entrypoint": "0x000810f4",
            "current_name": "process_interrupts_000810f4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid processInterrupts_000810f4(void)\n\n{\n  uint8_t leadingZeros;\n  uint32_t interruptStatus;\n  uint index;\n  \n  for (interruptStatus = _DAT_400e124c; (uint)LZCOUNT(interruptStatus) < 0x20; interruptStatus = interruptStatus & ~(1 << index)) {\n    index = 0x1fU - LZCOUNT(interruptStatus) & 0xff;\n    if (pioCallbacks[index] != (interruptCB)0x0) {\n      (*pioCallbacks[index])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810f4": "process_interrupts_000810f4",
                "isr": "interruptStatus",
                "leading_zeros": "leadingZeros",
                "uVar1": "index",
                "callbacksPioC": "pioCallbacks"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008112c": {
            "entrypoint": "0x0008112c",
            "current_name": "execute_interrupt_callbacks_0008112c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid executeInterruptCallbacks_0008112c(void)\n\n{\n  uint8_t numLeadingZeros;\n  uint32_t interruptStatus;\n  uint shiftAmount;\n  \n  for (interruptStatus = _DAT_400e144c; (uint)LZCOUNT(interruptStatus) < 0x20; interruptStatus = interruptStatus & ~(1 << shiftAmount)) {\n    shiftAmount = 0x1fU - LZCOUNT(interruptStatus) & 0xff;\n    if (callbacksPioD[shiftAmount] != (interruptCB)0x0) {\n      (*callbacksPioD[shiftAmount])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008112c": "execute_interrupt_callbacks_0008112c",
                "leading_zeros": "numLeadingZeros",
                "isr": "interruptStatus",
                "uVar1": "shiftAmount"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081164": {
            "entrypoint": "0x00081164",
            "current_name": "endless_loop_00081164",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid endlessLoop_00081164(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00081164": "endless_loop_00081164"
            },
            "calling": [
                "__halt"
            ],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081166": {
            "entrypoint": "0x00081166",
            "current_name": "infinite_loop_00081166",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_00081166(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00081166": "infinite_loop_00081166"
            },
            "calling": [],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008116a": {
            "entrypoint": "0x0008116a",
            "current_name": "infinite_loop_0008116a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_0008116a(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_0008116a": "infinite_loop_0008116a"
            },
            "calling": [],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008116e": {
            "entrypoint": "0x0008116e",
            "current_name": "initialize_tick_0008116e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeTick_0008116e(void)\n\n{\n  int isFalse;\n  \n  isFalse = __false();\n  if (isFalse == 0) {\n    resetTick();\n    incrementTimeTick();\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008116e": "initialize_tick_0008116e",
                "iVar1": "isFalse",
                "tickReset": "resetTick",
                "TimeTick_Increment": "incrementTimeTick"
            },
            "calling": [],
            "called": [
                "TimeTick_Increment",
                "__false",
                "tickReset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081184": {
            "entrypoint": "0x00081184",
            "current_name": "initialize_00081184",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint initialize_00081184(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00081184": "initialize_00081184"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081188": {
            "entrypoint": "0x00081188",
            "current_name": "infinite_loop_00081188",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_00081188(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00081188": "infinite_loop_00081188"
            },
            "calling": [
                "__halt",
                "SVC_Handler",
                "PendSV_Handler"
            ],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008118c": {
            "entrypoint": "0x0008118c",
            "current_name": "expand_heap_0008118c",
            "code": "\nvoid * expandHeap_0008118c(intptr_t heapExpansionSize)\n\n{\n  uchar *previousHeap;\n  uchar *previousHeap;\n  \n  if (currentHeap == (uchar *)0x0) {\n    currentHeap = &endOfDataSection;\n  }\n  previousHeap = currentHeap;\n  currentHeap = currentHeap + heapExpansionSize;\n  return previousHeap;\n}\n\n",
            "renaming": {
                "FUN_0008118c": "expand_heap_0008118c",
                "__delta": "heapExpansionSize",
                "puVar1": "previousHeap",
                "prev_heap": "previousHeap",
                "_sbrk::heap": "currentHeap",
                "_ebss": "endOfDataSection"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811a8": {
            "entrypoint": "0x000811a8",
            "current_name": "copy_string_000811a8",
            "code": "\nint copyString_000811a8(char *source,char *destination)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_000811a8": "copy_string_000811a8",
                "__from": "source",
                "__to": "destination"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811ae": {
            "entrypoint": "0x000811ae",
            "current_name": "check_file_status_000811ae",
            "code": "\nint checkFileStatus_000811ae(int fileDescriptor)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_000811ae": "check_file_status_000811ae",
                "__fd": "fileDescriptor"
            },
            "calling": [
                "_close_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811b4": {
            "entrypoint": "0x000811b4",
            "current_name": "set_file_device_permission_000811b4",
            "code": "\nint setFileDevicePermission_000811b4(int fileDescriptor,stat *fileStat)\n\n{\n  *(undefined4 *)((int)&fileStat->device + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000811b4": "set_file_device_permission_000811b4",
                "__fd": "fileDescriptor",
                "__buf": "fileStat",
                "st_dev": "device"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811be": {
            "entrypoint": "0x000811be",
            "current_name": "check_file_descriptor_000811be",
            "code": "\nint checkFileDescriptor_000811be(int fileDescriptor)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000811be": "check_file_descriptor_000811be",
                "__fd": "fileDescriptor"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811c2": {
            "entrypoint": "0x000811c2",
            "current_name": "get_file_offset_000811c2",
            "code": "\n__off_t get_file_offset_000811c2(int file_descriptor,__off_t offset,int origin)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000811c2": "get_file_offset_000811c2",
                "__fd": "file_descriptor",
                "__offset": "offset",
                "__whence": "origin"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811c6": {
            "entrypoint": "0x000811c6",
            "current_name": "file_processing_function_000811c6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint file_processing_function_000811c6(int unused_file_parameter,char *unused_pointer_parameter,int unused_length_parameter)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000811c6": "file_processing_function_000811c6",
                "file_UNUSED": "unused_file_parameter",
                "ptr_UNUSED": "unused_pointer_parameter",
                "len_UNUSED": "unused_length_parameter"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811cc": {
            "entrypoint": "0x000811cc",
            "current_name": "copy_bytes_000811cc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nint copyBytes_000811cc(int fileDescriptor,char *source,int length)\n\n{\n  int index;\n  \n  for (index = 0; index < length; index = index + 1) {\n    do {\n    } while (-1 < _DAT_400e0814 << 0x1e);\n    _DAT_400e081c = (uint)(byte)source[index];\n  }\n  return length & ~(length >> 0x1f);\n}\n\n",
            "renaming": {
                "FUN_000811cc": "copy_bytes_000811cc",
                "file_UNUSED": "fileDescriptor",
                "ptr": "source",
                "len": "length",
                "iVar1": "index"
            },
            "calling": [
                "_write_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811f0": {
            "entrypoint": "0x000811f0",
            "current_name": "exit_with_status_000811f0",
            "code": "\nvoid exitWithStatus_000811f0(int status)\n\n{\n  printStatusMessage(\"Exiting with status %d.\\n\",status);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000811f0": "exit_with_status_000811f0",
                "__status": "status",
                "iprintf": "printStatusMessage"
            },
            "calling": [],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081200": {
            "entrypoint": "0x00081200",
            "current_name": "FUNC_00081200",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00081200(int pid_UNUSED,int sig_UNUSED)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081200": "FUNC_00081200"
            },
            "calling": [
                "_kill_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081202": {
            "entrypoint": "0x00081202",
            "current_name": "get_current_process_id_00081202",
            "code": "\n\n\nprocess_id get_current_process_id_00081202(void)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_00081202": "get_current_process_id_00081202",
                "__pid_t": "process_id"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081208": {
            "entrypoint": "0x00081208",
            "current_name": "get_tick_count_00081208",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTickCount_00081208(void)\n\n{\n  return tickCounter;\n}\n\n",
            "renaming": {
                "FUN_00081208": "get_tick_count_00081208",
                "_dwTickCount": "tickCounter"
            },
            "calling": [
                "sendTxBuffer",
                "setup",
                "poll",
                "loop"
            ],
            "called": [
                "GetTickCount"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008120c": {
            "entrypoint": "0x0008120c",
            "current_name": "FUNC_0008120c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0008120c(uint32_t ms)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008120c": "FUNC_0008120c"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008120e": {
            "entrypoint": "0x0008120e",
            "current_name": "FUNC_0008120e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0008120e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008120e": "FUNC_0008120e"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081210": {
            "entrypoint": "0x00081210",
            "current_name": "configure_pin_00081210",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_00081210(uint32_t pinNumber,uint32_t mode)\n\n{\n  undefined4 configurationValue;\n  byte pinStatusLowerNibble;\n  byte pinStatusFull;\n  Pio_conflict *portVariable;\n  \n  if (pinDescription[pinNumber].pinType != NOT_A_PIN) {\n    if ((pinStatus[pinNumber] & 0xf) == 4) {\n      disableADCChannel(0x400c0000,pinDescription[pinNumber].ADCChannelNumber);\n    }\n    pinStatusFull = pinStatus[pinNumber];\n    pinStatusLowerNibble = pinStatusFull & 0xf;\n    if ((pinStatusLowerNibble < 3) && (pinStatusFull != 0)) {\n      if (pinStatusLowerNibble == 2) {\n        if (mode == 0) {\n          return;\n        }\n      }\n      else if (pinStatusLowerNibble == 1) {\n        if (mode == 2) {\n          return;\n        }\n      }\n      else if (pinStatusLowerNibble == 3) {\n        if (mode == 1) {\n          return;\n        }\n        goto skipPinConfigurationLabel;\n      }\n    }\n    if (mode != 1) {\nskipPinConfigurationLabel:\n      if (mode == 0) {\n        enablePeripheralClock(pinDescription[pinNumber].peripheralId);\n        configurePIO(pinDescription[pinNumber].port,3,pinDescription[pinNumber].pinNumber,0);\n        pinStatusFull = pinStatus[pinNumber] & 0xf0 | 2;\n      }\n      else {\n        if (mode != 2) {\n          return;\n        }\n        enablePeripheralClock(pinDescription[pinNumber].peripheralId);\n        configurePIO(pinDescription[pinNumber].port,3,pinDescription[pinNumber].pinNumber,1);\n        pinStatusFull = pinStatus[pinNumber] & 0xf0 | 1;\n      }\n      pinStatus[pinNumber] = pinStatusFull;\n      return;\n    }\n    portVariable = pinDescription[pinNumber].port;\n    if (pinStatusFull >> 4 == 0) {\n      configurationValue = 4;\n    }\n    else {\n      configurationValue = 5;\n    }\n    configurePIO(portVariable,configurationValue,pinDescription[pinNumber].pinNumber,\n                  pinDescription[pinNumber].pinNumberConfiguration);\n    pinStatus[pinNumber] = pinStatus[pinNumber] & 0xf0 | 3;\n    if (portVariable->OSR == 0xffffffff) {\n      pmc_disable_periph_clk(pinDescription[pinNumber].peripheralId);\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081210": "configure_pin_00081210",
                "ulPin": "pinNumber",
                "ulMode": "mode",
                "ulPinType": "pinType",
                "g_APinDescription": "pinDescription",
                "PIO_NOT_A_PIN": "NOT_A_PIN",
                "g_pinStatus": "pinStatus",
                "adc_disable_channel": "disableADCChannel",
                "ulADCChannelNumber": "ADCChannelNumber",
                "bVar2": "pinStatusLowerNibble",
                "LAB_0008126c": "skipPinConfigurationLabel",
                "pmc_enable_periph_clk": "enablePeripheralClock",
                "PIO_Configure": "configurePIO",
                "pPort": "port",
                "ulPeripheralId": "peripheralId",
                "bVar3": "pinStatusFull",
                "pPVar4": "portVariable",
                "uVar1": "configurationValue",
                "PIO_OSR": "OSR"
            },
            "calling": [
                "setup",
                "begin",
                "digitalWrite"
            ],
            "called": [
                "PIO_Configure",
                "pmc_disable_periph_clk",
                "adc_disable_channel",
                "pmc_enable_periph_clk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081318": {
            "entrypoint": "0x00081318",
            "current_name": "configure_pin_00081318",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_00081318(uint32_t pinNumber,uint32_t pinValue)\n\n{\n  int outputStatus;\n  uint32_t pin;\n  Pio_conflict *pinPort;\n  uint32_t updatedValue;\n  \n  if (g_APinDescription[pinNumber].pinNumberType != PIO_NOT_A_PIN) {\n    updatedValue = pinValue;\n    if ((g_pinStatus[pinNumber] & 0xf) == 5) {\n      pinMode(pinNumber,1);\n    }\n    g_pinStatus[pinNumber] = g_pinStatus[pinNumber] & 0xf | (byte)(pinValue << 4);\n    pinPort = g_APinDescription[pinNumber].pPort;\n    pin = g_APinDescription[pinNumber].pinNumber;\n    outputStatus = PIO_GetOutputDataStatus(pinPort,pin);\n    if (outputStatus == 0) {\n      PIO_PullUp(pinPort,pin,pinValue);\n      return;\n    }\n    PIO_SetOutput(pinPort,pin,pinValue,0,1,updatedValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081318": "configure_pin_00081318",
                "ulPin": "pinNumber",
                "ulVal": "pinValue",
                "iVar1": "outputStatus",
                "uVar2": "pin",
                "pPVar3": "pinPort",
                "uVar4": "updatedValue"
            },
            "calling": [
                "getRxBuffer",
                "sendTxBuffer",
                "setup",
                "init",
                "begin"
            ],
            "called": [
                "pinMode",
                "PIO_SetOutput",
                "PIO_PullUp",
                "PIO_GetOutputDataStatus"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081388": {
            "entrypoint": "0x00081388",
            "current_name": "check_ticks_and_call_banzai_00081388",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid checkTicksAndCallBanzai_00081388(void)\n\n{\n  if ((ticksCount != -1) && (ticksCount = ticksCount + -1, ticksCount == 0)) {\n    banzai();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081388": "check_ticks_and_call_banzai_00081388",
                "ticks": "ticksCount"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "banzai"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813a8": {
            "entrypoint": "0x000813a8",
            "current_name": "initialize_ring_buffer_000813a8",
            "code": "\n/* DWARF original prototype: RingBuffer *  RingBuffer(RingBuffer * ringBuffer) */\n\nRingBuffer * __ringBuffercall RingBuffer::initializeRingBuffer_000813a8(RingBuffer *ringBuffer)\n\n{\n  memset(ringBuffer,0,0x80);\n  ringBuffer->_iHead = 0;\n  ringBuffer->_iTail = 0;\n  return ringBuffer;\n}\n\n",
            "renaming": {
                "FUN_000813a8": "initialize_ring_buffer_000813a8",
                "this": "ringBuffer"
            },
            "calling": [
                "_GLOBAL__sub_I_g_APinDescription"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813c2": {
            "entrypoint": "0x000813c2",
            "current_name": "store_char_000813c2",
            "code": "\n/* DWARF orcurrentIndexgcurrentIndexnal prototype: vocurrentIndexd  store_char(RcurrentIndexngBuffer * ringBuffer, ucurrentIndexnt8_t c) */\n\nvocurrentIndexd __ringBuffercall RcurrentIndexngBuffer::storeChar_000813c2(RcurrentIndexngBuffer *ringBuffer,ucurrentIndexnt8_t c)\n\n{\n  currentIndexnt currentIndex;\n  ucurrentIndexnt newIndex;\n  \n  currentIndex = ringBuffer->_currentIndexHead;\n  newIndex = currentIndex + 1U & 0x7f;\n  currentIndexf (newIndex != ringBuffer->_currentIndexTacurrentIndexl) {\n    ringBuffer->_aucBuffer[ringBuffer->_currentIndexHead] = c;\n    ringBuffer->_currentIndexHead = newIndex;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000813c2": "store_char_000813c2",
                "this": "ringBuffer",
                "i": "currentIndex",
                "uVar1": "newIndex"
            },
            "calling": [
                "IrqHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813e0": {
            "entrypoint": "0x000813e0",
            "current_name": "is_uart_class_valid_000813e0",
            "code": "\n/* DWARF original name: operator bool\n   DWARF original prototype: bool  operator_bool(UARTClass * uart_instance) */\n\nbool __uart_instancecall UARTClass::is_UARTClassValid_000813e0(UARTClass *uart_instance)\n\n{\n  return true;\n}\n\n",
            "renaming": {
                "FUN_000813e0": "is_uart_class_valid_000813e0",
                "this": "uart_instance"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813e4": {
            "entrypoint": "0x000813e4",
            "current_name": "get_available_data_000813e4",
            "code": "\n/* DWARF original prototype: int  available(UARTClass * uartInstance) */\n\nint __uartInstancecall UARTClass::getAvailableData_000813e4(UARTClass *uartInstance)\n\n{\n  return uartInstance->rxBuffer->bufferHeadIndex - uartInstance->rxBuffer->bufferTailIndex & 0x7f;\n}\n\n",
            "renaming": {
                "FUN_000813e4": "get_available_data_000813e4",
                "this": "uartInstance",
                "_rx_buffer": "rxBuffer",
                "_iHead": "bufferHeadIndex",
                "_iTail": "bufferTailIndex"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813f6": {
            "entrypoint": "0x000813f6",
            "current_name": "peek_000813f6",
            "code": "\n/* DWARF original prototype: int  peek_000813f6(UARTClass * uart) */\n\nint __uartcall UARTClass::peek_000813f6(UARTClass *uart)\n\n{\n  uint result;\n  RingBuffer *ringBuffer;\n  \n  ringBuffer = uart->rxBuffer;\n  if (ringBuffer->headIndex == ringBuffer->tailIndex) {\n    result = 0xffffffff;\n  }\n  else {\n    result = (uint)ringBuffer->buffer[ringBuffer->tailIndex];\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000813f6": "peek_000813f6",
                "this": "uart",
                "pRVar2": "ringBuffer",
                "_rx_buffer": "rxBuffer",
                "_iHead": "headIndex",
                "_iTail": "tailIndex",
                "_aucBuffer": "buffer",
                "uVar1": "result"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081412": {
            "entrypoint": "0x00081412",
            "current_name": "read_from_uart_00081412",
            "code": "\n/* DWARF original prototype: int  read(UARTClass * this) */\n\nssize_t UARTClass UARTClass::read_from_uart_00081412(UARTClass *this,int file_descriptor,void *buffer,size_t num_bytes)\n\n{\n  byte_t bVar1;\n  unsigned_int8_t uc;\n  RingBuffer *ring_buffer;\n  \n  ring_buffer = this->receive_buffer;\n  if (ring_buffer->head_index != ring_buffer->tail_index) {\n    bVar1 = ring_buffer->buffer_array[ring_buffer->tail_index];\n    ring_buffer->tail_index = ring_buffer->tail_index + 1U & 0x7f;\n    return (uint)bVar1;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_00081412": "read_from_uart_00081412",
                "__thiscall": "UARTClass",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__nbytes": "num_bytes",
                "byte": "byte_t",
                "uint8_t": "unsigned_int8_t",
                "pRVar2": "ring_buffer",
                "_rx_buffer": "receive_buffer",
                "_iHead": "head_index",
                "_iTail": "tail_index",
                "_aucBuffer": "buffer_array"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008143c": {
            "entrypoint": "0x0008143c",
            "current_name": "wait_until_transmit_complete_0008143c",
            "code": "\n/* DWARF original prototype: void  flush(UARTClass * uartInstance) */\n\nvoid __uartInstancecall UARTClass::waitUntilTransmitComplete_0008143c(UARTClass *uartInstance)\n\n{\n  do {\n  } while (uartInstance->transmitBuffer->headIndex != uartInstance->transmitBuffer->tailIndex);\n  do {\n  } while (-1 < (int)(uartInstance->uartPeripherals->statusRegister << 0x16));\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008143c": "wait_until_transmit_complete_0008143c",
                "this": "uartInstance",
                "_tx_buffer": "transmitBuffer",
                "_iHead": "headIndex",
                "_iTail": "tailIndex",
                "_pUart": "uartPeripherals",
                "UART_SR": "statusRegister"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081454": {
            "entrypoint": "0x00081454",
            "current_name": "write_uart_data_00081454",
            "code": "\n/* DWARF original prototype: size_t  write(UARTClass * uart_instance, uint8_t uc_data) */\n\nssize_t UARTClass UARTClass::write_uart_data_00081454(UARTClass *uart_instance,int file_descriptor,void *buffer,size_t buffer_size)\n\n{\n  RingBuffer *ring_buffer;\n  uint head_increment;\n  \n  ring_buffer = uart_instance->_tx_buffer;\n  if (((int)(uart_instance->_pUart->UART_SR << 0x1e) < 0) && (ring_buffer->_iTail == ring_buffer->_iHead)) {\n    uart_instance->_pUart->UART_THR = file_descriptor;\n  }\n  else {\n    head_increment = ring_buffer->_iHead + 1U & 0x8000007f;\n    if ((int)head_increment < 0) {\n      head_increment = (head_increment - 1 | 0xffffff80) + 1;\n    }\n    do {\n    } while (ring_buffer->_iTail == head_increment);\n    ring_buffer->_aucBuffer[ring_buffer->_iHead] = (uchar)file_descriptor;\n    uart_instance->_tx_buffer->_iHead = head_increment;\n    uart_instance->_pUart->UART_IER = 2;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00081454": "write_uart_data_00081454",
                "__thiscall": "UARTClass",
                "this": "uart_instance",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "buffer_size",
                "pRVar1": "ring_buffer",
                "uVar2": "head_increment"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814a8": {
            "entrypoint": "0x000814a8",
            "current_name": "end_uart_000814a8",
            "code": "\n/* DWARF original prototype: void  end(UARTClass * uartInstance) */\n\nvoid __uartInstancecall UARTClass::endUART_000814a8(UARTClass *uartInstance)\n\n{\n  uartInstance->rxBuffer->headIndex = uartInstance->rxBuffer->tailIndex;\n  (**(code **)(*(int *)uartInstance + 0x14))();\n  *(int *)((((uint)(int)uartInstance->irq >> 5) + 0x20) * 4 + -0x1fff1f00) =\n       1 << (uint)(byte)(uartInstance->irq & 0x1f);\n  pmc_disable_periph_clk(uartInstance->id);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000814a8": "end_uart_000814a8",
                "this": "uartInstance",
                "_rx_buffer": "rxBuffer",
                "_iHead": "headIndex",
                "_iTail": "tailIndex",
                "_dwIrq": "irq",
                "_dwId": "id"
            },
            "calling": [],
            "called": [
                "pmc_disable_periph_clk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814e4": {
            "entrypoint": "0x000814e4",
            "current_name": "initialize_uart_000814e4",
            "code": "\n/* DWARF original prototype: UARTClass *  UARTClass(UARTClass * uartInstance, Uart * uartPointer, IRQn_Type interruptNumber,\n   uint32_t deviceId, RingBuffer * rxBuffer, RingBuffer * txBuffer) */\n\nUARTClass * __uartInstancecall\nUARTClass::initializeUART_000814e4(UARTClass *uartInstance,Uart *uartPointer,IRQn_Type interruptNumber,uint32_t deviceId,RingBuffer *rxBuffer,\n          RingBuffer *txBuffer)\n\n{\n  *(undefined4 *)&uartInstance->fieldA = 0;\n  *(undefined4 *)&uartInstance->fieldB = 1000;\n  uartInstance->uartInstancePointer = uartPointer;\n  *(undefined ***)uartInstance = &PTR_write_1_000857a8;\n  uartInstance->interruptNumber = interruptNumber;\n  uartInstance->rxBuffer = rxBuffer;\n  uartInstance->deviceId = deviceId;\n  uartInstance->txBuffer = txBuffer;\n  return uartInstance;\n}\n\n",
            "renaming": {
                "this": "uartInstance",
                "pUart": "uartPointer",
                "dwIrq": "interruptNumber",
                "dwId": "deviceId",
                "pRx_buffer": "rxBuffer",
                "pTx_buffer": "txBuffer",
                "field_0x4": "fieldA",
                "field_0x8": "fieldB",
                "_pUart": "uartInstancePointer",
                "_dwIrq": "interruptNumber",
                "_rx_buffer": "rxBuffer",
                "_dwId": "deviceId",
                "_tx_buffer": "txBuffer",
                "FUN_000814e4": "initialize_uart_000814e4"
            },
            "calling": [
                "_GLOBAL__sub_I_g_APinDescription",
                "USARTClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081508": {
            "entrypoint": "0x00081508",
            "current_name": "initialize_uart_00081508",
            "code": "\n/* DWARF original prototype: void  init(UARTClass * uartObject, uint32_t dwBaudRate, uint32_t modeReg) */\n\nint __uartObjectcall UARTClass::initializeUART_00081508(UARTClass *uartObject,EVP_PKEY_CTX *cryptoContext)\n\n{\n  uint uVar1;\n  RingBuffer *ringBuffer;\n  RwReg modeRegisterValue;\n  Uart *uartPeripheral;\n  \n  enablePeripheralClock(uartObject->id);\n  uartPeripheral = uartObject->_pUart;\n  uartPeripheral->ptcrRegister = 0x202;\n  uartPeripheral->crRegister = 0xac;\n  uartPeripheral->mrRegister = modeRegisterValue;\n  uartPeripheral->brgrRegister = systemClock / (uint)cryptoContext >> 4;\n  uartPeripheral->idrRegister = 0xffffffff;\n  uartPeripheral->ierRegister = 0x61;\n  uVar1 = (uint)(int)uartObject->irq >> 5;\n  *(int *)(uVar1 * 4 + -0x1fff1f00) = 1 << (uint)(byte)(uartObject->irq & 0x1f);\n  ringBuffer = uartObject->rxBuffer;\n  ringBuffer->tailIndex = 0;\n  ringBuffer->headIndex = 0;\n  ringBuffer = uartObject->txBuffer;\n  ringBuffer->tailIndex = 0;\n  ringBuffer->headIndex = 0;\n  uartPeripheral->crRegister = 0x50;\n  return uVar1;\n}\n\n",
            "renaming": {
                "FUN_00081508": "initialize_uart_00081508",
                "this": "uartObject",
                "ctx": "cryptoContext",
                "pmc_enable_periph_clk": "enablePeripheralClock",
                "pUVar3": "uartPeripheral",
                "in_r2": "modeRegisterValue",
                "SystemCoreClock": "systemClock",
                "pRVar2": "ringBuffer",
                "_dwId": "id",
                "UART_PTCR": "ptcrRegister",
                "UART_CR": "crRegister",
                "UART_MR": "mrRegister",
                "UART_BRGR": "brgrRegister",
                "UART_IDR": "idrRegister",
                "UART_IER": "ierRegister",
                "_dwIrq": "irq",
                "_rx_buffer": "rxBuffer",
                "_tx_buffer": "txBuffer",
                "_iTail": "tailIndex",
                "_iHead": "headIndex"
            },
            "calling": [
                "begin",
                "begin"
            ],
            "called": [
                "pmc_enable_periph_clk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081578": {
            "entrypoint": "0x00081578",
            "current_name": "initialize_uart_00081578",
            "code": "\n/* DWARF original prototype: void  begin(UARTClass * uartInstance, uint32_t baudRate) */\n\nvoid __uartInstancecall UARTClass::initializeUART_00081578(UARTClass *uartInstance,uint32_t baudRate)\n\n{\n  init(uartInstance,(EVP_PKEY_CTX *)baudRate);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081578": "initialize_uart_00081578",
                "this": "uartInstance",
                "dwBaudRate": "baudRate"
            },
            "calling": [],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081580": {
            "entrypoint": "0x00081580",
            "current_name": "handle_serial_interrupt_00081580",
            "code": "\n/* DWARF original prototype: void  IrqHandler(UARTClass * serial) */\n\nvoid __serialcall UARTClass::handleSerialInterrupt_00081580(UARTClass *serial)\n\n{\n  buffer *txBuffer;\n  uint32_t uartStatus;\n  RoReg uartStatusReg;\n  \n  uartStatusReg = serial->_pUart->UART_SR;\n  if ((int)(uartStatusReg << 0x1f) < 0) {\n    buffer::store_char(serial->_rx_buffer,(uint8_t)serial->_pUart->UART_RHR);\n  }\n  if ((int)(uartStatusReg << 0x1e) < 0) {\n    txBuffer = serial->_tx_buffer;\n    if (txBuffer->_iTail != txBuffer->_iHead) {\n      serial->_pUart->UART_THR = (uint)txBuffer->_aucBuffer[txBuffer->_iTail];\n      txBuffer->_iTail = txBuffer->_iTail + 1U & 0x7f;\n      return;\n    }\n    serial->_pUart->UART_IDR = 2;\n  }\n  return;\n}\n\n",
            "renaming": {
                "this": "serial",
                "RingBuffer": "buffer",
                "status": "uartStatus",
                "RVar2": "uartStatusReg",
                "pRVar1": "txBuffer",
                "FUN_00081580": "handle_serial_interrupt_00081580"
            },
            "calling": [
                "USART1_Handler",
                "UART_Handler",
                "USART3_Handler",
                "USART0_Handler"
            ],
            "called": [
                "store_char"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815ca": {
            "entrypoint": "0x000815ca",
            "current_name": "initialize_uart_000815ca",
            "code": "\n/* DWARF original prototype: void  begin(USARTClass * uartInstance, uint32_t baudRate) */\n\nvoid __uartInstancecall USARTClass::initializeUART_000815ca(USARTClass *uartInstance,uint32_t baudRate)\n\n{\n  UARTClass::init(&uartInstance->super_UARTClass,(EVP_PKEY_CTX *)baudRate);\n  return;\n}\n\n",
            "renaming": {
                "this": "uartInstance",
                "dwBaudRate": "baudRate",
                "FUN_000815ca": "initialize_uart_000815ca"
            },
            "calling": [],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815d4": {
            "entrypoint": "0x000815d4",
            "current_name": "usart_class_init_000815d4",
            "code": "\n/* DWARF original prototype: USARTClass *  USARTClass(USARTClass * usartObj, Usart * usart, IRQn_Type\n   interruptNum, uint32_t deviceId, RingBuffer * rxBuffer, RingBuffer * txBuffer) */\n\nUSARTClass * __usartObjcall\nUSARTClass::USARTClassInit_000815d4(USARTClass *usartObj,Usart *usart,IRQn_Type interruptNum,uint32_t deviceId,RingBuffer *rxBuffer,\n          RingBuffer *txBuffer)\n\n{\n  SerialPort::SerialPort(&usartObj->super_SerialPort,(Uart *)usart,interruptNum,deviceId,rxBuffer,txBuffer);\n  *(undefined ***)&usartObj->super_SerialPort = &PTR_write_1_000857d8;\n  usartObj->_usart = usart;\n  return usartObj;\n}\n\n",
            "renaming": {
                "this": "usartObj",
                "pUsart": "usart",
                "dwIrq": "interruptNum",
                "dwId": "deviceId",
                "pRx_buffer": "rxBuffer",
                "pTx_buffer": "txBuffer",
                "UARTClass": "SerialPort",
                "FUN_000815d4": "usart_class_init_000815d4"
            },
            "calling": [
                "_GLOBAL__sub_I_g_APinDescription"
            ],
            "called": [
                "UARTClass"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815f8": {
            "entrypoint": "0x000815f8",
            "current_name": "combine_bytes_000815f8",
            "code": "\n/* WARNING: Unknown calowBytelowByteing convention */\n\nuint16_t combineBytes_000815f8(uint8_t highByte,uint8_t lowByte)\n\n{\n  return CONCAT11(highByte,lowByte);\n}\n\n",
            "renaming": {
                "FUN_000815f8": "combine_bytes_000815f8",
                "h": "highByte",
                "l": "lowByte"
            },
            "calling": [
                "get_FC3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815fe": {
            "entrypoint": "0x000815fe",
            "current_name": "cleanup_string_000815fe",
            "code": "\n/* DWARF original prototype: void *  ~String(String * str, int chargeFlag) */\n\nvoid * __strcall String::cleanupString_000815fe(String *str,int chargeFlag)\n\n{\n  free(str->buffer);\n  return str;\n}\n\n",
            "renaming": {
                "this": "str",
                "__in_chrg": "chargeFlag",
                "FUN_000815fe": "cleanup_string_000815fe"
            },
            "calling": [],
            "called": [
                "free"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008160c": {
            "entrypoint": "0x0008160c",
            "current_name": "clear_string_0008160c",
            "code": "\n/* DWARF original prototype: void  invalidate(String * str) */\n\nvoid __strcall String::clearString_0008160c(String *str)\n\n{\n  if (str->strBuffer != (char *)0x0) {\n    free(str->strBuffer);\n  }\n  str->strBuffer = (char *)0x0;\n  str->strLen = 0;\n  str->strCapacity = 0;\n  return;\n}\n\n",
            "renaming": {
                "this": "str",
                "buffer": "strBuffer",
                "len": "strLen",
                "capacity": "strCapacity",
                "FUN_0008160c": "clear_string_0008160c"
            },
            "calling": [
                "copy"
            ],
            "called": [
                "free"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081622": {
            "entrypoint": "0x00081622",
            "current_name": "resize_string_buffer_00081622",
            "code": "\n/* DWARF original prototype: uchar  changeBuffer(String * str, uint newSize) */\n\nuchar __strcall String::resizeStringBuffer_00081622(String *str,uint newSize)\n\n{\n  char *newBuffer;\n  char *newBuffer;\n  \n  newBuffer = (char *)realloc(str->buffer,newSize + 1);\n  if (newBuffer != (char *)0x0) {\n    str->buffer = newBuffer;\n    str->capacity = newSize;\n    newBuffer = (char *)0x1;\n  }\n  return (uchar)newBuffer;\n}\n\n",
            "renaming": {
                "this": "str",
                "maxStrLen": "newSize",
                "pcVar1": "newBuffer",
                "newbuffer": "newBuffer",
                "FUN_00081622": "resize_string_buffer_00081622"
            },
            "calling": [
                "reserve"
            ],
            "called": [
                "realloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008163a": {
            "entrypoint": "0x0008163a",
            "current_name": "reserve_memory_0008163a",
            "code": "\n/* DWARF original prototype: uchar  reserve(String * stringObject, uint newSize) */\n\nuchar __stringObjectcall String::reserveMemory_0008163a(String *stringObject,uint newSize)\n\n{\n  uchar bufferChangeResult;\n  \n  if ((stringObject->buffer == (char *)0x0) || (stringObject->capacity < newSize)) {\n    bufferChangeResult = changeBuffer(stringObject,newSize);\n    if (bufferChangeResult == '\\0') {\n      return '\\0';\n    }\n    if (stringObject->len == 0) {\n      *stringObject->buffer = '\\0';\n    }\n  }\n  return '\\x01';\n}\n\n",
            "renaming": {
                "this": "stringObject",
                "size": "newSize",
                "uVar1": "bufferChangeResult",
                "FUN_0008163a": "reserve_memory_0008163a"
            },
            "calling": [
                "copy"
            ],
            "called": [
                "changeBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008165c": {
            "entrypoint": "0x0008165c",
            "current_name": "copy_string_buffer_0008165c",
            "code": "\n/* DWARF original prototype: String *  copy(String * strObj, char * cstr, uint length) */\n\nint __strObjcall String::copyStringBuffer_0008165c(String *strObj,EVP_PKEY_CTX *srcBuffer,EVP_PKEY_CTX *srcLength)\n\n{\n  uchar reserveSuccess;\n  \n  reserveSuccess = reserve(strObj,(uint)srcLength);\n  if (reserveSuccess == '\\0') {\n    invalidate(strObj);\n  }\n  else {\n    strObj->len = (uint)srcLength;\n    strcpy(strObj->buffer,(char *)srcBuffer);\n  }\n  return (int)strObj;\n}\n\n",
            "renaming": {
                "this": "strObj",
                "dst": "srcBuffer",
                "src": "srcLength",
                "uVar1": "reserveSuccess",
                "FUN_0008165c": "copy_string_buffer_0008165c"
            },
            "calling": [
                "String"
            ],
            "called": [
                "reserve",
                "invalidate",
                "strcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081682": {
            "entrypoint": "0x00081682",
            "current_name": "initialize_string_00081682",
            "code": "\n/* DWARF original prototype: String *  String(String * stringObject, char * cstring) */\n\nString * __stringObjectcall String::initializeString_00081682(String *stringObject,char *cstring)\n\n{\n  EVP_PKEY_CTX *stringLength;\n  \n  stringObject->buffer = (char *)0x0;\n  stringObject->capacity = 0;\n  stringObject->len = 0;\n  if (cstring != (char *)0x0) {\n    stringLength = (EVP_PKEY_CTX *)strlen(cstring);\n    copy(stringObject,(EVP_PKEY_CTX *)cstring,stringLength);\n  }\n  return stringObject;\n}\n\n",
            "renaming": {
                "this": "stringObject",
                "cstr": "cstring",
                "src": "stringLength",
                "FUN_00081682": "initialize_string_00081682"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN6ModbusC2Ev"
            ],
            "called": [
                "strlen",
                "copy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816a6": {
            "entrypoint": "0x000816a6",
            "current_name": "FUNC_000816a6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_000816a6(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000816a6": "FUNC_000816a6"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000816a8": {
            "entrypoint": "0x000816a8",
            "current_name": "main_loop_000816a8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint mainLoop_000816a8(void)\n\n{\n  EVP_PKEY_CTX *ctx;\n  \n  setupWatchdog();\n  initialize(ctx);\n  initializeVariant();\n  delayExecution(1);\n  setupSystem();\n  do {\n    executeLoop();\n    runSerialEvent();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000816a8": "main_loop_000816a8",
                "in_r0": "ctx",
                "_watchdogDefaultSetup": "setupWatchdog",
                "init": "initialize",
                "initVariant": "initializeVariant",
                "delay": "delayExecution",
                "setup": "setupSystem",
                "loop": "executeLoop",
                "serialEventRun": "runSerialEvent"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "initVariant",
                "_watchdogDefaultSetup",
                "serialEventRun",
                "setup",
                "loop",
                "init",
                "delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816d4": {
            "entrypoint": "0x000816d4",
            "current_name": "disable_watchdog_timer_000816d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disableWatchdogTimer_000816d4(void)\n\n{\n  WDT_Disable(0x400e1a50);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000816d4": "disable_watchdog_timer_000816d4"
            },
            "calling": [
                "main"
            ],
            "called": [
                "WDT_Disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816e0": {
            "entrypoint": "0x000816e0",
            "current_name": "print_write_000816e0",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x000816f6 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * this, uint8_t * buffer, size_t size) */\n\nssize_t __thiscall Print::printWrite_000816e0(Print *this,int fileDescriptor,void *buffer,size_t size)\n\n{\n  Print *printObject;\n  void *pointer;\n  \n  pointer = (void *)0x0;\n  printObject = this;\n  while ((pointer != buffer &&\n         (printObject = (Print *)(**this->_vptr_Print)(printObject,(uint)*(byte *)(fileDescriptor + (int)pointer)),\n         printObject != (Print *)0x0))) {\n    pointer = (void *)((int)pointer + 1);\n  }\n  return (ssize_t)pointer;\n}\n\n",
            "renaming": {
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__n": "size",
                "pvVar2": "pointer",
                "pPVar1": "printObject",
                "FUN_000816e0": "print_write_000816e0"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081704": {
            "entrypoint": "0x00081704",
            "current_name": "increment_tick_count_00081704",
            "code": "\nvoid incrementTickCount_00081704(void)\n\n{\n  tickCount = tickCount + 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081704": "increment_tick_count_00081704",
                "_dwTickCount": "tickCount"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081714": {
            "entrypoint": "0x00081714",
            "current_name": "get_tick_count_00081714",
            "code": "\nundefined4 getTickCount_00081714(void)\n\n{\n  return tickCount;\n}\n\n",
            "renaming": {
                "FUN_00081714": "get_tick_count_00081714",
                "_dwTickCount": "tickCount"
            },
            "calling": [
                "millis"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081720": {
            "entrypoint": "0x00081720",
            "current_name": "initialize_memory_00081720",
            "code": "\nvoid initializeMemory_00081720(int baseAddress)\n\n{\n  *(undefined4 *)(baseAddress + 4) = 0x8000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081720": "initialize_memory_00081720",
                "param_1": "baseAddress"
            },
            "calling": [
                "_watchdogDefaultSetup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081728": {
            "entrypoint": "0x00081728",
            "current_name": "convert_and_add_sign_bit_00081728",
            "code": "\nvoid convertAndAddSignBit_00081728(uint inputNumber)\n\n{\n  __addsf3(inputNumber ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081728": "convert_and_add_sign_bit_00081728",
                "param_1": "inputNumber"
            },
            "calling": [],
            "called": [
                "__addsf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081730": {
            "entrypoint": "0x00081730",
            "current_name": "calculate_modified_float_00081730",
            "code": "\nuint calculate_modified_float_00081730(uint input_float,uint input_value,undefined4 param_3,uint param_4)\n\n{\n  int shifted_input_float_high;\n  int shifted_value_high;\n  uint modified_value;\n  uint uVar4;\n  uint shifted_input_float;\n  uint modified_shift;\n  uint difference;\n  bool is_equal;\n  \n  modified_value = input_value ^ 0x80000000;\n  shifted_input_float = input_float << 1;\n  is_equal = shifted_input_float == 0;\n  if (!is_equal) {\n    param_4 = input_value << 1;\n    is_equal = param_4 == 0;\n  }\n  if (!is_equal) {\n    is_equal = shifted_input_float == param_4;\n  }\n  shifted_input_float_high = (int)shifted_input_float >> 0x18;\n  if (!is_equal) {\n    is_equal = shifted_input_float_high == -1;\n  }\n  if (!is_equal) {\n    is_equal = (int)param_4 >> 0x18 == -1;\n  }\n  if (is_equal) {\n    shifted_value_high = (int)(input_value << 1) >> 0x18;\n    if (shifted_input_float_high == -1 || shifted_value_high == -1) {\n      shifted_input_float = modified_value;\n      if (shifted_input_float_high == -1) {\n        shifted_input_float = input_float;\n      }\n      if (shifted_input_float_high != -1 || shifted_value_high != -1) {\n        modified_value = shifted_input_float;\n      }\n      is_equal = (shifted_input_float & 0x7fffff) == 0;\n      if (is_equal) {\n        is_equal = (modified_value & 0x7fffff) == 0;\n      }\n      if (is_equal) {\n        is_equal = shifted_input_float == modified_value;\n      }\n      if (!is_equal) {\n        shifted_input_float = shifted_input_float | 0x400000;\n      }\n      return shifted_input_float;\n    }\n    if (((input_float ^ modified_value) & 0x7fffffff) != 0) {\n      if (shifted_input_float == 0) {\n        input_float = modified_value;\n      }\n      return input_float;\n    }\n    if (input_float != modified_value) {\n      return 0;\n    }\n    if ((shifted_input_float & 0xff000000) == 0) {\n      modified_value = input_float << 1;\n      if ((input_float & 0x80000000) != 0) {\n        modified_value = modified_value | 0x80000000;\n      }\n      return modified_value;\n    }\n    if (shifted_input_float < 0xfe000000) {\n      return input_float + 0x800000;\n    }\n    input_float = input_float & 0x80000000;\nLAB_0008186a:\n    return input_float | 0x7f800000;\n  }\n  shifted_input_float = shifted_input_float >> 0x18;\n  param_4 = param_4 >> 0x18;\n  difference = param_4 - shifted_input_float;\n  is_equal = difference != 0;\n  modified_shift = shifted_input_float;\n  if (is_equal && shifted_input_float <= param_4) {\n    modified_shift = shifted_input_float + difference;\n  }\n  if (is_equal && shifted_input_float <= param_4) {\n    modified_value = modified_value ^ input_float;\n  }\n  if (is_equal && shifted_input_float <= param_4) {\n    input_float = input_float ^ modified_value;\n  }\n  if (is_equal && shifted_input_float <= param_4) {\n    modified_value = modified_value ^ input_float;\n  }\n  if (param_4 < shifted_input_float) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return input_float;\n  }\n  shifted_input_float = input_float & 0xffffff | 0x800000;\n  if ((input_float & 0x80000000) != 0) {\n    shifted_input_float = -shifted_input_float;\n  }\n  uVar4 = modified_value & 0xffffff | 0x800000;\n  if ((modified_value & 0x80000000) != 0) {\n    uVar4 = -uVar4;\n  }\n  if (modified_shift == difference) {\n    uVar4 = uVar4 ^ 0x800000;\n    if (modified_shift == 0) {\n      shifted_input_float = shifted_input_float ^ 0x800000;\n      modified_shift = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  shifted_input_float = shifted_input_float + ((int)uVar4 >> (difference & 0xff));\n  uVar4 = uVar4 << (0x20 - difference & 0xff);\n  input_float = shifted_input_float & 0x80000000;\n  if ((int)shifted_input_float < 0) {\n    is_equal = uVar4 != 0;\n    uVar4 = -uVar4;\n    shifted_input_float = -shifted_input_float - (uint)is_equal;\n  }\n  if (shifted_input_float < 0x800000) {\n    modified_value = uVar4 & 0x80000000;\n    uVar4 = uVar4 << 1;\n    shifted_input_float = shifted_input_float * 2 + (uint)(modified_value != 0);\n    modified_value = modified_shift - 2;\n    if ((shifted_input_float & 0x800000) == 0) {\n      difference = LZCOUNT(shifted_input_float) - 8;\n      shifted_input_float = shifted_input_float << (difference & 0xff);\n      if ((int)modified_value < (int)difference) {\n        shifted_input_float = shifted_input_float >> (-(modified_value - difference) & 0xff);\n      }\n      else {\n        shifted_input_float = shifted_input_float + (modified_value - difference) * 0x800000;\n      }\n      return shifted_input_float | input_float;\n    }\n  }\n  else {\n    modified_value = modified_shift - 1;\n    if (0xffffff < shifted_input_float) {\n      modified_value = shifted_input_float & 1;\n      shifted_input_float = shifted_input_float >> 1;\n      uVar4 = (uint)(modified_value != 0) << 0x1f | uVar4 >> 1;\n      modified_value = modified_shift;\n      if (0xfd < modified_shift) goto LAB_0008186a;\n    }\n  }\n  shifted_input_float = shifted_input_float + modified_value * 0x800000 + (uint)(0x7fffffff < uVar4);\n  if (uVar4 == 0x80000000) {\n    shifted_input_float = shifted_input_float & 0xfffffffe;\n  }\n  return shifted_input_float | input_float;\n}\n\n",
            "renaming": {
                "FUN_00081730": "calculate_modified_float_00081730",
                "param_1": "input_float",
                "param_2": "input_value",
                "uVar3": "modified_value",
                "uVar5": "shifted_input_float",
                "uVar6": "modified_shift",
                "uVar7": "difference",
                "bVar8": "is_equal",
                "iVar1": "shifted_input_float_high",
                "iVar2": "shifted_value_high"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081734": {
            "entrypoint": "0x00081734",
            "current_name": "calculate_floating_point_00081734",
            "code": "\nuint calculateFloatingPoint_00081734(uint input1,uint input2,undefined4 input3,uint input4)\n\n{\n  int shiftedInput1;\n  int shiftedInput2;\n  uint absMaskedInput1;\n  uint absMaskedInput2;\n  uint shiftCount;\n  uint difference;\n  bool isEqualZero;\n  \n  absMaskedInput2 = input1 << 1;\n  isEqualZero = absMaskedInput2 == 0;\n  if (!isEqualZero) {\n    input4 = input2 << 1;\n    isEqualZero = input4 == 0;\n  }\n  if (!isEqualZero) {\n    isEqualZero = absMaskedInput2 == input4;\n  }\n  shiftedInput1 = (int)absMaskedInput2 >> 0x18;\n  if (!isEqualZero) {\n    isEqualZero = shiftedInput1 == -1;\n  }\n  if (!isEqualZero) {\n    isEqualZero = (int)input4 >> 0x18 == -1;\n  }\n  if (isEqualZero) {\n    shiftedInput2 = (int)(input2 << 1) >> 0x18;\n    if (shiftedInput1 == -1 || shiftedInput2 == -1) {\n      absMaskedInput2 = input2;\n      if (shiftedInput1 == -1) {\n        absMaskedInput2 = input1;\n      }\n      if (shiftedInput1 != -1 || shiftedInput2 != -1) {\n        input2 = absMaskedInput2;\n      }\n      isEqualZero = (absMaskedInput2 & 0x7fffff) == 0;\n      if (isEqualZero) {\n        isEqualZero = (input2 & 0x7fffff) == 0;\n      }\n      if (isEqualZero) {\n        isEqualZero = absMaskedInput2 == input2;\n      }\n      if (!isEqualZero) {\n        absMaskedInput2 = absMaskedInput2 | 0x400000;\n      }\n      return absMaskedInput2;\n    }\n    if (((input1 ^ input2) & 0x7fffffff) != 0) {\n      if (absMaskedInput2 == 0) {\n        input1 = input2;\n      }\n      return input1;\n    }\n    if (input1 != input2) {\n      return 0;\n    }\n    if ((absMaskedInput2 & 0xff000000) == 0) {\n      absMaskedInput2 = input1 << 1;\n      if ((input1 & 0x80000000) != 0) {\n        absMaskedInput2 = absMaskedInput2 | 0x80000000;\n      }\n      return absMaskedInput2;\n    }\n    if (absMaskedInput2 < 0xfe000000) {\n      return input1 + 0x800000;\n    }\n    input1 = input1 & 0x80000000;\nLAB_0008186a:\n    return input1 | 0x7f800000;\n  }\n  absMaskedInput2 = absMaskedInput2 >> 0x18;\n  input4 = input4 >> 0x18;\n  difference = input4 - absMaskedInput2;\n  isEqualZero = difference != 0;\n  shiftCount = absMaskedInput2;\n  if (isEqualZero && absMaskedInput2 <= input4) {\n    shiftCount = absMaskedInput2 + difference;\n  }\n  if (isEqualZero && absMaskedInput2 <= input4) {\n    input2 = input2 ^ input1;\n  }\n  if (isEqualZero && absMaskedInput2 <= input4) {\n    input1 = input1 ^ input2;\n  }\n  if (isEqualZero && absMaskedInput2 <= input4) {\n    input2 = input2 ^ input1;\n  }\n  if (input4 < absMaskedInput2) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return input1;\n  }\n  absMaskedInput2 = input1 & 0xffffff | 0x800000;\n  if ((input1 & 0x80000000) != 0) {\n    absMaskedInput2 = -absMaskedInput2;\n  }\n  absMaskedInput1 = input2 & 0xffffff | 0x800000;\n  if ((input2 & 0x80000000) != 0) {\n    absMaskedInput1 = -absMaskedInput1;\n  }\n  if (shiftCount == difference) {\n    absMaskedInput1 = absMaskedInput1 ^ 0x800000;\n    if (shiftCount == 0) {\n      absMaskedInput2 = absMaskedInput2 ^ 0x800000;\n      shiftCount = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  absMaskedInput2 = absMaskedInput2 + ((int)absMaskedInput1 >> (difference & 0xff));\n  absMaskedInput1 = absMaskedInput1 << (0x20 - difference & 0xff);\n  input1 = absMaskedInput2 & 0x80000000;\n  if ((int)absMaskedInput2 < 0) {\n    isEqualZero = absMaskedInput1 != 0;\n    absMaskedInput1 = -absMaskedInput1;\n    absMaskedInput2 = -absMaskedInput2 - (uint)isEqualZero;\n  }\n  if (absMaskedInput2 < 0x800000) {\n    difference = absMaskedInput1 & 0x80000000;\n    absMaskedInput1 = absMaskedInput1 << 1;\n    absMaskedInput2 = absMaskedInput2 * 2 + (uint)(difference != 0);\n    difference = shiftCount - 2;\n    if ((absMaskedInput2 & 0x800000) == 0) {\n      shiftCount = LZCOUNT(absMaskedInput2) - 8;\n      absMaskedInput2 = absMaskedInput2 << (shiftCount & 0xff);\n      if ((int)difference < (int)shiftCount) {\n        absMaskedInput2 = absMaskedInput2 >> (-(difference - shiftCount) & 0xff);\n      }\n      else {\n        absMaskedInput2 = absMaskedInput2 + (difference - shiftCount) * 0x800000;\n      }\n      return absMaskedInput2 | input1;\n    }\n  }\n  else {\n    difference = shiftCount - 1;\n    if (0xffffff < absMaskedInput2) {\n      difference = absMaskedInput2 & 1;\n      absMaskedInput2 = absMaskedInput2 >> 1;\n      absMaskedInput1 = (uint)(difference != 0) << 0x1f | absMaskedInput1 >> 1;\n      difference = shiftCount;\n      if (0xfd < shiftCount) goto LAB_0008186a;\n    }\n  }\n  absMaskedInput2 = absMaskedInput2 + difference * 0x800000 + (uint)(0x7fffffff < absMaskedInput1);\n  if (absMaskedInput1 == 0x80000000) {\n    absMaskedInput2 = absMaskedInput2 & 0xfffffffe;\n  }\n  return absMaskedInput2 | input1;\n}\n\n",
            "renaming": {
                "FUN_00081734": "calculate_floating_point_00081734",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shiftedInput1",
                "iVar2": "shiftedInput2",
                "uVar3": "absMaskedInput1",
                "uVar4": "absMaskedInput2",
                "uVar5": "shiftCount",
                "uVar6": "difference",
                "bVar7": "isEqualZero"
            },
            "calling": [
                "loop",
                "__aeabi_frsub"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081894": {
            "entrypoint": "0x00081894",
            "current_name": "calculate_checksum_00081894",
            "code": "\nuint calculateChecksum_00081894(uint input)\n\n{\n  uint finalResult;\n  uint shiftedInput;\n  int constantValue;\n  uint tempValue;\n  \n  if (input == 0) {\n    return 0;\n  }\n  finalResult = LZCOUNT(input);\n  shiftedInput = finalResult - 8;\n  constantValue = shiftedInput * -0x800000 + 0x4a800000;\n  if (7 < finalResult) {\n    tempValue = 0 << (shiftedInput & 0xff);\n    finalResult = constantValue + (input << (shiftedInput & 0xff)) +\n            (0U >> (0x20 - shiftedInput & 0xff)) + (uint)(0x7fffffff < tempValue);\n    if (tempValue == 0x80000000) {\n      finalResult = finalResult & 0xfffffffe;\n    }\n    return finalResult;\n  }\n  shiftedInput = input << finalResult + 0x18;\n  finalResult = constantValue + ((input >> (0x20 - (finalResult + 0x18) & 0xff)) - ((int)shiftedInput >> 0x1f));\n  if ((shiftedInput & 0x7fffffff) == 0) {\n    finalResult = finalResult & ~(shiftedInput >> 0x1f);\n  }\n  return finalResult;\n}\n\n",
            "renaming": {
                "FUN_00081894": "calculate_checksum_00081894",
                "param_1": "input",
                "uVar1": "finalResult",
                "uVar2": "shiftedInput",
                "iVar3": "constantValue",
                "uVar4": "tempValue"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008189c": {
            "entrypoint": "0x0008189c",
            "current_name": "decode_unsigned_integer_0008189c",
            "code": "\nuint decode_unsigned_integer_0008189c(uint input_value)\n\n{\n  uint leading_zeroes;\n  uint shift_amount;\n  uint sign_bit;\n  int result;\n  \n  sign_bit = input_value & 0x80000000;\n  if ((int)sign_bit < 0) {\n    input_value = -input_value;\n  }\n  if (input_value == 0) {\n    return 0;\n  }\n  leading_zeroes = count_leading_zeroes(input_value);\n  shift_amount = leading_zeroes - 8;\n  result = ((sign_bit | 0x4b000000) - 0x800000) + shift_amount * -0x800000;\n  if (7 < leading_zeroes) {\n    leading_zeroes = 0 << (shift_amount & 0xff);\n    sign_bit = result + (input_value << (shift_amount & 0xff)) +\n            (0U >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < leading_zeroes);\n    if (leading_zeroes == 0x80000000) {\n      sign_bit = sign_bit & 0xfffffffe;\n    }\n    return sign_bit;\n  }\n  shift_amount = input_value << leading_zeroes + 0x18;\n  sign_bit = result + ((input_value >> (0x20 - (leading_zeroes + 0x18) & 0xff)) - ((int)shift_amount >> 0x1f));\n  if ((shift_amount & 0x7fffffff) == 0) {\n    sign_bit = sign_bit & ~(shift_amount >> 0x1f);\n  }\n  return sign_bit;\n}\n\n",
            "renaming": {
                "FUN_0008189c": "decode_unsigned_integer_0008189c",
                "param_1": "input_value",
                "uVar1": "leading_zeroes",
                "uVar2": "shift_amount",
                "uVar3": "sign_bit",
                "iVar4": "result",
                "LZCOUNT": "count_leading_zeroes"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000818b8": {
            "entrypoint": "0x000818b8",
            "current_name": "bitwise_operation_000818b8",
            "code": "\nuint bitwiseOperation_000818b8(uint input1,uint input2)\n\n{\n  uint temp1;\n  uint temp2;\n  uint shiftCount;\n  uint shiftedValue;\n  int constant;\n  \n  if ((input1 | input2) == 0) {\n    return input1;\n  }\n  temp1 = input1;\n  temp2 = input2;\n  if (input2 == 0) {\n    temp1 = 0;\n    temp2 = input1;\n  }\n  constant = 0x5b000000;\n  if (input2 == 0) {\n    constant = 0x4b000000;\n  }\n  shiftCount = LZCOUNT(temp2);\n  shiftedValue = shiftCount - 8;\n  constant = constant + -0x800000 + shiftedValue * -0x800000;\n  if (shiftCount < 8) {\n    shiftedValue = temp2 << shiftCount + 0x18;\n    temp2 = constant + ((temp2 >> (0x20 - (shiftCount + 0x18) & 0xff)) - ((int)shiftedValue >> 0x1f));\n    if ((temp1 | shiftedValue << 1) == 0) {\n      temp2 = temp2 & ~(shiftedValue >> 0x1f);\n    }\n    return temp2;\n  }\n  shiftCount = temp1 << (shiftedValue & 0xff);\n  temp2 = constant + (temp2 << (shiftedValue & 0xff)) +\n          (temp1 >> (0x20 - shiftedValue & 0xff)) + (uint)(0x7fffffff < shiftCount);\n  if (shiftCount == 0x80000000) {\n    temp2 = temp2 & 0xfffffffe;\n  }\n  return temp2;\n}\n\n",
            "renaming": {
                "FUN_000818b8": "bitwise_operation_000818b8",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "shiftCount",
                "uVar4": "shiftedValue",
                "iVar5": "constant"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000818c8": {
            "entrypoint": "0x000818c8",
            "current_name": "calculate_modified_value_000818c8",
            "code": "\nuint calculateModifiedValue_000818c8(uint originalValue,uint modifier)\n\n{\n  uint modValue1;\n  uint modValue2;\n  uint count;\n  uint shiftAmount;\n  uint flag;\n  int newValue;\n  bool isOriginalValueNonzero;\n  \n  if ((originalValue | modifier) == 0) {\n    return originalValue;\n  }\n  flag = modifier & 0x80000000;\n  if ((int)flag < 0) {\n    isOriginalValueNonzero = originalValue != 0;\n    originalValue = -originalValue;\n    modifier = -modifier - (uint)isOriginalValueNonzero;\n  }\n  modValue2 = originalValue;\n  modValue1 = modifier;\n  if (modifier == 0) {\n    modValue2 = 0;\n    modValue1 = originalValue;\n  }\n  flag = flag | 0x5b000000;\n  if (modifier == 0) {\n    flag = flag + 0xf0000000;\n  }\n  count = LZCOUNT(modValue1);\n  shiftAmount = count - 8;\n  newValue = (flag - 0x800000) + shiftAmount * -0x800000;\n  if (count < 8) {\n    shiftAmount = modValue1 << count + 0x18;\n    flag = newValue + ((modValue1 >> (0x20 - (count + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n    if ((modValue2 | shiftAmount << 1) == 0) {\n      flag = flag & ~(shiftAmount >> 0x1f);\n    }\n    return flag;\n  }\n  count = modValue2 << (shiftAmount & 0xff);\n  flag = newValue + (modValue1 << (shiftAmount & 0xff)) +\n          (modValue2 >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < count);\n  if (count == 0x80000000) {\n    flag = flag & 0xfffffffe;\n  }\n  return flag;\n}\n\n",
            "renaming": {
                "FUN_000818c8": "calculate_modified_value_000818c8",
                "param_1": "originalValue",
                "param_2": "modifier",
                "uVar1": "modValue1",
                "uVar2": "modValue2",
                "uVar3": "count",
                "uVar4": "shiftAmount",
                "uVar5": "flag",
                "iVar6": "newValue",
                "bVar7": "isOriginalValueNonzero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081944": {
            "entrypoint": "0x00081944",
            "current_name": "calculate_floating_point_00081944",
            "code": "\nuint calculateFloatingPoint_00081944(uint input1,uint input2,undefined4 param3,uint param4)\n\n{\n  longlong tempResult;\n  uint result;\n  uint normalizedExp1;\n  int expSum;\n  int normalizedExpDiff;\n  uint significand2;\n  int normalizedExpDiffAbs;\n  uint normalizedExpSum;\n  bool isNormalizedExpZero;\n  bool isCarry;\n  \n  normalizedExp1 = input1 >> 0x17 & 0xff;\n  isNormalizedExpZero = normalizedExp1 == 0;\n  if (!isNormalizedExpZero) {\n    param4 = input2 >> 0x17 & 0xff;\n    isNormalizedExpZero = param4 == 0;\n  }\n  if (!isNormalizedExpZero) {\n    isNormalizedExpZero = normalizedExp1 == 0xff;\n  }\n  if (!isNormalizedExpZero) {\n    isNormalizedExpZero = param4 == 0xff;\n  }\n  if (isNormalizedExpZero) {\n    param4 = input2 >> 0x17 & 0xff;\n    if (normalizedExp1 == 0xff || param4 == 0xff) {\n      isNormalizedExpZero = input1 == 0 || input1 == 0x80000000;\n      result = input2;\n      if (input1 != 0 && input1 != 0x80000000) {\n        isNormalizedExpZero = input2 == 0;\n        result = input1;\n      }\n      if (!isNormalizedExpZero) {\n        isNormalizedExpZero = input2 == 0x80000000;\n      }\n      normalizedExpSum = result;\n      if (((isNormalizedExpZero) || ((normalizedExp1 == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((param4 == 0xff && (normalizedExpSum = input2, (input2 & 0x7fffff) != 0)))) {\n        return normalizedExpSum | 0x7fc00000;\n      }\n      result = result ^ input2;\n      goto LAB_00081a94;\n    }\n    isNormalizedExpZero = (input1 & 0x7fffffff) == 0;\n    if (!isNormalizedExpZero) {\n      isNormalizedExpZero = (input2 & 0x7fffffff) == 0;\n    }\n    if (isNormalizedExpZero) {\n      return (input1 ^ input2) & 0x80000000;\n    }\n    isNormalizedExpZero = normalizedExp1 == 0;\n    result = input1 & 0x80000000;\n    while( true ) {\n      if (isNormalizedExpZero) {\n        input1 = input1 << 1;\n        isNormalizedExpZero = (input1 & 0x800000) == 0;\n      }\n      if (!isNormalizedExpZero) break;\n      normalizedExp1 = normalizedExp1 - 1;\n    }\n    input1 = input1 | result;\n    isNormalizedExpZero = param4 == 0;\n    result = input2 & 0x80000000;\n    while( true ) {\n      if (isNormalizedExpZero) {\n        input2 = input2 << 1;\n        isNormalizedExpZero = (input2 & 0x800000) == 0;\n      }\n      if (!isNormalizedExpZero) break;\n      param4 = param4 - 1;\n    }\n    input2 = input2 | result;\n  }\n  expSum = normalizedExp1 + param4;\n  normalizedExpSum = input1 ^ input2;\n  normalizedExp1 = input1 << 9;\n  isNormalizedExpZero = normalizedExp1 == 0;\n  if (!isNormalizedExpZero) {\n    input2 = input2 << 9;\n    isNormalizedExpZero = input2 == 0;\n  }\n  if (isNormalizedExpZero) {\n    if (normalizedExp1 == 0) {\n      input2 = input2 << 9;\n    }\n    result = normalizedExpSum & 0x80000000 | input1 & 0x7fffff | input2 >> 9;\n    isCarry = SBORROW4(expSum,0x7f);\n    normalizedExpDiff = expSum + -0x7f;\n    isNormalizedExpZero = normalizedExpDiff == 0;\n    normalizedExpDiffAbs = normalizedExpDiff;\n    if (!isNormalizedExpZero && 0x7e < expSum) {\n      isCarry = SBORROW4(0xff,normalizedExpDiff);\n      normalizedExpDiffAbs = 0xff - normalizedExpDiff;\n      isNormalizedExpZero = normalizedExpDiff == 0xff;\n    }\n    if (!isNormalizedExpZero && normalizedExpDiffAbs < 0 == isCarry) {\n      result = result | normalizedExpDiff * 0x800000;\n    }\n    if (!isNormalizedExpZero && normalizedExpDiffAbs < 0 == isCarry) {\n      return result;\n    }\n    result = result | 0x800000;\n    significand2 = 0;\n    isCarry = SBORROW4(normalizedExpDiff,1);\n    normalizedExpSum = expSum - 0x80;\n    isNormalizedExpZero = normalizedExpSum == 0;\n    normalizedExp1 = normalizedExpSum;\n  }\n  else {\n    tempResult = (ulonglong)(normalizedExp1 >> 5 | 0x8000000) * (ulonglong)(input2 >> 5 | 0x8000000);\n    significand2 = (uint)tempResult;\n    result = (uint)((ulonglong)tempResult >> 0x20);\n    isNormalizedExpZero = result < 0x800000;\n    if (isNormalizedExpZero) {\n      result = result << 1;\n    }\n    if (isNormalizedExpZero) {\n      result = result | significand2 >> 0x1f;\n      significand2 = significand2 << 1;\n    }\n    result = normalizedExpSum & 0x80000000 | result;\n    normalizedExpSum = (expSum + -0x7f) - (uint)isNormalizedExpZero;\n    isCarry = SBORROW4(normalizedExpSum,0xfd);\n    isNormalizedExpZero = normalizedExpSum == 0xfd;\n    normalizedExp1 = normalizedExpSum - 0xfd;\n    if (normalizedExpSum < 0xfe) {\n      result = result + normalizedExpSum * 0x800000 + (uint)(0x7fffffff < significand2);\n      if (significand2 == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (isNormalizedExpZero || (int)normalizedExp1 < 0 != isCarry) {\n    isNormalizedExpZero = (int)(normalizedExpSum + 0x19) < 0;\n    if (normalizedExpSum == 0xffffffe7 || isNormalizedExpZero != SCARRY4(normalizedExpSum,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (normalizedExpSum != 0xffffffe7 && isNormalizedExpZero == SCARRY4(normalizedExpSum,0x19)) {\n      normalizedExp1 = (result << 1) >> (-normalizedExpSum & 0xff);\n      normalizedExpSum = result << (normalizedExpSum + 0x20 & 0xff);\n      normalizedExp1 = ((uint)((result & 0x80000000) != 0) << 0x1f | normalizedExp1 >> 1) + (uint)((byte)normalizedExp1 & 1);\n      if ((significand2 | normalizedExpSum << 1) == 0) {\n        normalizedExp1 = normalizedExp1 & ~(normalizedExpSum >> 0x1f);\n      }\n      return normalizedExp1;\n    }\n    return result;\n  }\nLAB_00081a94:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_00081944": "calculate_floating_point_00081944",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar2": "result",
                "uVar3": "normalizedExp1",
                "iVar4": "expSum",
                "iVar5": "normalizedExpDiff",
                "uVar6": "significand2",
                "iVar7": "normalizedExpDiffAbs",
                "uVar8": "normalizedExpSum",
                "bVar9": "isNormalizedExpZero",
                "bVar10": "isCarry",
                "lVar1": "tempResult"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081aac": {
            "entrypoint": "0x00081aac",
            "current_name": "floating_point_multiply_00081aac",
            "code": "\nuint floatingPointMultiply_00081aac(uint operand1,uint operand2,undefined4 param3,uint param4)\n\n{\n  uint quotient;\n  uint normalizedOperand1;\n  int difference;\n  uint normalizedOperand2;\n  int sum;\n  uint result;\n  bool isZero;\n  bool isCarry;\n  bool isBorrow;\n  \n  normalizedOperand1 = operand1 >> 0x17 & 0xff;\n  isZero = normalizedOperand1 == 0;\n  if (!isZero) {\n    param4 = operand2 >> 0x17 & 0xff;\n    isZero = param4 == 0;\n  }\n  if (!isZero) {\n    isZero = normalizedOperand1 == 0xff;\n  }\n  if (!isZero) {\n    isZero = param4 == 0xff;\n  }\n  if (isZero) {\n    param4 = operand2 >> 0x17 & 0xff;\n    result = operand1;\n    if (normalizedOperand1 == 0xff) {\n      if (((operand1 & 0x7fffff) != 0) || (result = operand2, param4 == 0xff)) {\nLAB_00081aa2:\n        return result | 0x7fc00000;\n      }\n    }\n    else {\n      if (param4 == 0xff) {\n        result = operand2;\n        if ((operand2 & 0x7fffff) == 0) {\nLAB_00081a58:\n          return (operand1 ^ operand2) & 0x80000000;\n        }\n        goto LAB_00081aa2;\n      }\n      isZero = (operand1 & 0x7fffffff) == 0;\n      if (!isZero) {\n        isZero = (operand2 & 0x7fffffff) == 0;\n      }\n      if (!isZero) {\n        isZero = normalizedOperand1 == 0;\n        result = operand1 & 0x80000000;\n        while( true ) {\n          if (isZero) {\n            operand1 = operand1 << 1;\n            isZero = (operand1 & 0x800000) == 0;\n          }\n          if (!isZero) break;\n          normalizedOperand1 = normalizedOperand1 - 1;\n        }\n        operand1 = operand1 | result;\n        isZero = param4 == 0;\n        result = operand2 & 0x80000000;\n        while( true ) {\n          if (isZero) {\n            operand2 = operand2 << 1;\n            isZero = (operand2 & 0x800000) == 0;\n          }\n          if (!isZero) break;\n          param4 = param4 - 1;\n        }\n        operand2 = operand2 | result;\n        goto LAB_00081ac4;\n      }\n      if ((operand1 & 0x7fffffff) == 0) {\n        if ((operand2 & 0x7fffffff) != 0) goto LAB_00081a58;\n        goto LAB_00081aa2;\n      }\n    }\n    operand1 = operand1 ^ operand2;\n  }\n  else {\nLAB_00081ac4:\n    difference = normalizedOperand1 - param4;\n    if (operand2 << 9 == 0) {\n      operand1 = (operand1 ^ operand2) & 0x80000000 | operand1 & 0x7fffff;\n      isBorrow = SCARRY4(difference,0x7f);\n      sum = difference + 0x7f;\n      isZero = sum < 0;\n      isCarry = sum == 0;\n      if (!isCarry && isZero == isBorrow) {\n        isBorrow = SBORROW4(0xff,sum);\n        isZero = 0xff - sum < 0;\n        isCarry = sum == 0xff;\n      }\n      if (!isCarry && isZero == isBorrow) {\n        operand1 = operand1 | sum * 0x800000;\n      }\n      if (!isCarry && isZero == isBorrow) {\n        return operand1;\n      }\n      operand1 = operand1 | 0x800000;\n      normalizedOperand1 = 0;\n      isCarry = SBORROW4(sum,1);\n      normalizedOperand2 = difference + 0x7e;\n      isZero = normalizedOperand2 == 0;\n      result = normalizedOperand2;\n    }\n    else {\n      quotient = (operand2 << 9) >> 4 | 0x10000000;\n      normalizedOperand1 = (operand1 << 9) >> 4 | 0x10000000;\n      operand1 = (operand1 ^ operand2) & 0x80000000;\n      isZero = quotient <= normalizedOperand1;\n      if (!isZero) {\n        normalizedOperand1 = normalizedOperand1 << 1;\n      }\n      normalizedOperand2 = difference + 0x7d + (uint)isZero;\n      result = 0x800000;\n      do {\n        if (quotient <= normalizedOperand1) {\n          normalizedOperand1 = normalizedOperand1 - quotient;\n          operand1 = operand1 | result;\n        }\n        isZero = quotient >> 1 <= normalizedOperand1;\n        if (isZero) {\n          normalizedOperand1 = normalizedOperand1 - (quotient >> 1);\n        }\n        if (isZero) {\n          operand1 = operand1 | result >> 1;\n        }\n        isZero = quotient >> 2 <= normalizedOperand1;\n        if (isZero) {\n          normalizedOperand1 = normalizedOperand1 - (quotient >> 2);\n        }\n        if (isZero) {\n          operand1 = operand1 | result >> 2;\n        }\n        isZero = quotient >> 3 <= normalizedOperand1;\n        if (isZero) {\n          normalizedOperand1 = normalizedOperand1 - (quotient >> 3);\n        }\n        if (isZero) {\n          operand1 = operand1 | result >> 3;\n        }\n        normalizedOperand1 = normalizedOperand1 * 0x10;\n        isZero = normalizedOperand1 == 0;\n        if (!isZero) {\n          result = result >> 4;\n          isZero = result == 0;\n        }\n      } while (!isZero);\n      isCarry = SBORROW4(normalizedOperand2,0xfd);\n      isZero = normalizedOperand2 == 0xfd;\n      result = normalizedOperand2 - 0xfd;\n      if (normalizedOperand2 < 0xfe) {\n        operand1 = operand1 + normalizedOperand2 * 0x800000 + (uint)(quotient <= normalizedOperand1);\n        if (normalizedOperand1 - quotient == 0) {\n          operand1 = operand1 & 0xfffffffe;\n        }\n        return operand1;\n      }\n    }\n    if (isZero || (int)result < 0 != isCarry) {\n      isZero = (int)(normalizedOperand2 + 0x19) < 0;\n      if (normalizedOperand2 == 0xffffffe7 || isZero != SCARRY4(normalizedOperand2,0x19)) {\n        operand1 = operand1 & 0x80000000;\n      }\n      if (normalizedOperand2 == 0xffffffe7 || isZero != SCARRY4(normalizedOperand2,0x19)) {\n        return operand1;\n      }\n      result = (operand1 << 1) >> (-normalizedOperand2 & 0xff);\n      normalizedOperand2 = operand1 << (normalizedOperand2 + 0x20 & 0xff);\n      result = ((uint)((operand1 & 0x80000000) != 0) << 0x1f | result >> 1) + (uint)((byte)result & 1);\n      if ((normalizedOperand1 | normalizedOperand2 << 1) == 0) {\n        result = result & ~(normalizedOperand2 >> 0x1f);\n      }\n      return result;\n    }\n  }\n  return operand1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_00081aac": "floating_point_multiply_00081aac",
                "param_1": "operand1",
                "param_2": "operand2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "quotient",
                "uVar2": "normalizedOperand1",
                "iVar3": "difference",
                "uVar4": "normalizedOperand2",
                "iVar5": "sum",
                "uVar6": "result",
                "bVar7": "isZero",
                "bVar8": "isCarry",
                "bVar9": "isBorrow"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081be4": {
            "entrypoint": "0x00081be4",
            "current_name": "calculate_result_00081be4",
            "code": "\nuint calculate_result_00081be4(uint final_result,uint input_2)\n\n{\n  bool is_negative;\n  uint doubled_input_1;\n  uint doubled_input_2;\n  uint combined_result;\n  bool is_zero;\n  \n  doubled_input_1 = final_result * 2;\n  doubled_input_2 = input_2 * 2;\n  if (((int)doubled_input_1 >> 0x18 == -1 || (int)doubled_input_2 >> 0x18 == -1) &&\n     ((((int)doubled_input_1 >> 0x18 == -1 && ((final_result & 0x7fffff) != 0)) ||\n      (((int)doubled_input_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 0xffffffff;\n  }\n  combined_result = doubled_input_1 | input_2 & 0x7fffffff;\n  is_zero = combined_result == 0;\n  if (!is_zero) {\n    combined_result = final_result ^ input_2;\n    is_zero = combined_result == 0;\n  }\n  is_negative = -1 < (int)combined_result;\n  if (is_negative) {\n    final_result = doubled_input_1 + input_2 * -2;\n    is_zero = final_result == 0;\n  }\n  if ((is_negative && doubled_input_2 <= doubled_input_1) && !is_zero) {\n    final_result = (int)input_2 >> 0x1f;\n  }\n  if (!is_negative || doubled_input_2 > doubled_input_1) {\n    final_result = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    final_result = final_result | 1;\n  }\n  return final_result;\n}\n\n",
            "renaming": {
                "FUN_00081be4": "calculate_result_00081be4",
                "param_1": "final_result",
                "param_2": "input_2",
                "bVar1": "is_negative",
                "uVar2": "doubled_input_1",
                "uVar3": "doubled_input_2",
                "uVar4": "combined_result",
                "bVar5": "is_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081bec": {
            "entrypoint": "0x00081bec",
            "current_name": "calculate_checksum_00081bec",
            "code": "\nuint calculateChecksum_00081bec(uint input1,uint input2)\n\n{\n  bool isCombinedNegative;\n  uint doubleInput1;\n  uint doubleInput2;\n  uint combinedInputs;\n  bool isCombinedZero;\n  \n  doubleInput1 = input1 * 2;\n  doubleInput2 = input2 * 2;\n  if (((int)doubleInput1 >> 0x18 == -1 || (int)doubleInput2 >> 0x18 == -1) &&\n     ((((int)doubleInput1 >> 0x18 == -1 && ((input1 & 0x7fffff) != 0)) ||\n      (((int)doubleInput2 >> 0x18 == -1 && ((input2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combinedInputs = doubleInput1 | input2 & 0x7fffffff;\n  isCombinedZero = combinedInputs == 0;\n  if (!isCombinedZero) {\n    combinedInputs = input1 ^ input2;\n    isCombinedZero = combinedInputs == 0;\n  }\n  isCombinedNegative = -1 < (int)combinedInputs;\n  if (isCombinedNegative) {\n    input1 = doubleInput1 + input2 * -2;\n    isCombinedZero = input1 == 0;\n  }\n  if ((isCombinedNegative && doubleInput2 <= doubleInput1) && !isCombinedZero) {\n    input1 = (int)input2 >> 0x1f;\n  }\n  if (!isCombinedNegative || doubleInput2 > doubleInput1) {\n    input1 = ~((int)input2 >> 0x1f);\n  }\n  if (!isCombinedZero) {\n    input1 = input1 | 1;\n  }\n  return input1;\n}\n\n",
            "renaming": {
                "FUN_00081bec": "calculate_checksum_00081bec",
                "param_1": "input1",
                "param_2": "input2",
                "uVar2": "doubleInput1",
                "uVar3": "doubleInput2",
                "uVar4": "combinedInputs",
                "bVar5": "isCombinedZero",
                "bVar1": "isCombinedNegative"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081bf4": {
            "entrypoint": "0x00081bf4",
            "current_name": "check_overflow_00081bf4",
            "code": "\nuint check_overflow_00081bf4(uint result,uint operand2)\n\n{\n  bool is_negative;\n  uint double_operand1;\n  uint double_operand2;\n  uint combined_operands;\n  bool is_zero;\n  \n  double_operand1 = result * 2;\n  double_operand2 = operand2 * 2;\n  if (((int)double_operand1 >> 0x18 == -1 || (int)double_operand2 >> 0x18 == -1) &&\n     ((((int)double_operand1 >> 0x18 == -1 && ((result & 0x7fffff) != 0)) ||\n      (((int)double_operand2 >> 0x18 == -1 && ((operand2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined_operands = double_operand1 | operand2 & 0x7fffffff;\n  is_zero = combined_operands == 0;\n  if (!is_zero) {\n    combined_operands = result ^ operand2;\n    is_zero = combined_operands == 0;\n  }\n  is_negative = -1 < (int)combined_operands;\n  if (is_negative) {\n    result = double_operand1 + operand2 * -2;\n    is_zero = result == 0;\n  }\n  if ((is_negative && double_operand2 <= double_operand1) && !is_zero) {\n    result = (int)operand2 >> 0x1f;\n  }\n  if (!is_negative || double_operand2 > double_operand1) {\n    result = ~((int)operand2 >> 0x1f);\n  }\n  if (!is_zero) {\n    result = result | 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00081bf4": "check_overflow_00081bf4",
                "param_1": "result",
                "param_2": "operand2",
                "uVar2": "double_operand1",
                "uVar3": "double_operand2",
                "uVar4": "combined_operands",
                "bVar1": "is_negative",
                "bVar5": "is_zero"
            },
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081c54": {
            "entrypoint": "0x00081c54",
            "current_name": "compare_floats_00081c54",
            "code": "\nvoid compareFloats_00081c54(undefined4 float1,undefined4 float2)\n\n{\n  __aeabi_cfcmpeq(float2,float1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081c54": "compare_floats_00081c54",
                "param_1": "float1",
                "param_2": "float2"
            },
            "calling": [
                "__aeabi_fcmpgt",
                "__aeabi_fcmpge"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081c5c": {
            "entrypoint": "0x00081c5c",
            "current_name": "concatenate_and_convert_to64_bits_00081c5c",
            "code": "\nundefined8 concatenateAndConvertTo64Bits_00081c5c(undefined4 lowerHalf,undefined4 upperHalf)\n\n{\n  __cmpsf2();\n  return CONCAT44(upperHalf,lowerHalf);\n}\n\n",
            "renaming": {
                "FUN_00081c5c": "concatenate_and_convert_to64_bits_00081c5c",
                "param_1": "lowerHalf",
                "param_2": "upperHalf"
            },
            "calling": [
                "__aeabi_fcmpeq",
                "__aeabi_cfrcmple",
                "__aeabi_fcmple",
                "__aeabi_fcmplt"
            ],
            "called": [
                "__cmpsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081c6c": {
            "entrypoint": "0x00081c6c",
            "current_name": "is_not_zero_00081c6c",
            "code": "\nbool isNotZero_00081c6c(void)\n\n{\n  char inputChar;\n  \n  __aeabi_cfcmpeq();\n  return inputChar != '\\0';\n}\n\n",
            "renaming": {
                "FUN_00081c6c": "is_not_zero_00081c6c",
                "in_ZR": "inputChar"
            },
            "calling": [],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081c80": {
            "entrypoint": "0x00081c80",
            "current_name": "is_null_character_00081c80",
            "code": "\nbool is_null_character_00081c80(void)\n\n{\n  char input_char;\n  \n  __aeabi_cfcmpeq();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_00081c80": "is_null_character_00081c80",
                "in_CY": "input_char"
            },
            "calling": [],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081c94": {
            "entrypoint": "0x00081c94",
            "current_name": "compare_flags_and_return_result_00081c94",
            "code": "\nbool compareFlagsAndReturnResult_00081c94(void)\n\n{\n  undefined zeroFlag;\n  undefined carryFlag;\n  \n  __aeabi_cfcmpeq();\n  return !(bool)carryFlag || (bool)zeroFlag;\n}\n\n",
            "renaming": {
                "FUN_00081c94": "compare_flags_and_return_result_00081c94",
                "in_ZR": "zeroFlag",
                "in_CY": "carryFlag"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081ca8": {
            "entrypoint": "0x00081ca8",
            "current_name": "check_if_compare_result_less_or_equal_00081ca8",
            "code": "\nbool check_if_compare_result_less_or_equal_00081ca8(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_set;\n  \n  __aeabi_cfrcmple();\n  return !(bool)is_carry_set || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_00081ca8": "check_if_compare_result_less_or_equal_00081ca8",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_set"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081cbc": {
            "entrypoint": "0x00081cbc",
            "current_name": "is_input_empty_00081cbc",
            "code": "\nbool isInputEmpty_00081cbc(void)\n\n{\n  char inputCharacter;\n  \n  __aeabi_cfrcmple();\n  return inputCharacter == '\\0';\n}\n\n",
            "renaming": {
                "FUN_00081cbc": "is_input_empty_00081cbc",
                "in_CY": "inputCharacter"
            },
            "calling": [],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081cd0": {
            "entrypoint": "0x00081cd0",
            "current_name": "convert_to_signed_int_00081cd0",
            "code": "\nuint convertToSignedInt_00081cd0(uint inputValue)\n\n{\n  uint shiftedValue;\n  uint difference;\n  \n  if (inputValue << 1 < 0x7f000000) {\n    return 0;\n  }\n  shiftedValue = (inputValue << 1) >> 0x18;\n  difference = 0x9e - shiftedValue;\n  if (shiftedValue < 0x9f && difference != 0) {\n    shiftedValue = (inputValue << 8 | 0x80000000) >> (difference & 0xff);\n    if ((inputValue & 0x80000000) != 0) {\n      shiftedValue = -shiftedValue;\n    }\n    return shiftedValue;\n  }\n  if ((difference == 0xffffff9f) && ((inputValue & 0x7fffff) != 0)) {\n    return 0;\n  }\n  inputValue = inputValue & 0x80000000;\n  if (inputValue == 0) {\n    inputValue = 0x7fffffff;\n  }\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_00081cd0": "convert_to_signed_int_00081cd0",
                "param_1": "inputValue",
                "uVar1": "shiftedValue",
                "uVar2": "difference"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081d1c": {
            "entrypoint": "0x00081d1c",
            "current_name": "convert_to_float_00081d1c",
            "code": "\nuint convertToFloat_00081d1c(uint input)\n\n{\n  uint shiftCount;\n  \n  if (((input & 0x80000000) != 0) || (input << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shiftCount = 0x9e - ((input << 1) >> 0x18);\n  if (-1 < (int)shiftCount) {\n    return (input << 8 | 0x80000000) >> (shiftCount & 0xff);\n  }\n  if ((shiftCount == 0xffffff9f) && ((input & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00081d1c": "convert_to_float_00081d1c",
                "param_1": "input",
                "uVar1": "shiftCount"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081d5c": {
            "entrypoint": "0x00081d5c",
            "current_name": "register_cleanup_function_00081d5c",
            "code": "\nvoid registerCleanupFunction_00081d5c(undefined4 cleanupFunction,undefined4 cleanupParameter)\n\n{\n  __cxa_atexit(cleanupParameter,cleanupFunction);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081d5c": "register_cleanup_function_00081d5c",
                "param_1": "cleanupFunction",
                "param_2": "cleanupParameter"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN6ModbusC2Ev"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081d68": {
            "entrypoint": "0x00081d68",
            "current_name": "register_exit_procedure_00081d68",
            "code": "\nvoid registerExitProcedure_00081d68(undefined4 exitProcFunc,undefined4 param1,undefined4 param2)\n\n{\n  __register_exitproc(2,exitProcFunc,param1,param2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081d68": "register_exit_procedure_00081d68",
                "param_1": "exitProcFunc",
                "param_2": "param1",
                "param_3": "param2"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081d7c": {
            "entrypoint": "0x00081d7c",
            "current_name": "execute_initialization_00081d7c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00081d88) */\n/* WARNING: Removing unreachable block (ram,0x00081d8c) */\n/* WARNING: Removing unreachable block (ram,0x00081db8) */\n\nvoid executeInitialization_00081d7c(void)\n\n{\n  int iterationCount;\n  code **functionPointers;\n  \n  _init();\n  functionPointers = (code **)0x85860;\n  iterationCount = 0;\n  do {\n    iterationCount = iterationCount + 1;\n    functionPointers = functionPointers + 1;\n    (**functionPointers)();\n  } while (iterationCount != 4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081d7c": "execute_initialization_00081d7c",
                "iVar1": "iterationCount",
                "ppcVar2": "functionPointers"
            },
            "calling": [
                "init"
            ],
            "called": [
                "register_fini",
                "_init",
                "frame_dummy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081dcc": {
            "entrypoint": "0x00081dcc",
            "current_name": "print_formatted_value_00081dcc",
            "code": "\nvoid printFormattedValue_00081dcc(undefined4 formatString,undefined4 arg1,undefined4 arg2,undefined4 arg3)\n\n{\n  undefined4 arg1_copy;\n  undefined4 arg2_copy;\n  undefined4 arg3_copy;\n  \n  arg1_copy = arg1;\n  arg2_copy = arg2;\n  arg3_copy = arg3;\n  _vfiprintf_r(_impure_ptr,*(undefined4 *)(_impure_ptr + 8),formatString,&arg1_copy);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081dcc": "print_formatted_value_00081dcc",
                "param_1": "formatString",
                "param_2": "arg1",
                "param_3": "arg2",
                "param_4": "arg3",
                "uStack_c": "arg1_copy",
                "uStack_8": "arg2_copy",
                "uStack_4": "arg3_copy"
            },
            "calling": [
                "_exit"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081df4": {
            "entrypoint": "0x00081df4",
            "current_name": "allocate_memory_00081df4",
            "code": "\nvoid * allocateMemory_00081df4(size_t size)\n\n{\n  void *allocatedMemory;\n  \n  allocatedMemory = (void *)_malloc_r(_impure_ptr,size);\n  return allocatedMemory;\n}\n\n",
            "renaming": {
                "FUN_00081df4": "allocate_memory_00081df4",
                "__size": "size",
                "pvVar1": "allocatedMemory"
            },
            "calling": [
                "__register_exitproc"
            ],
            "called": [
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081e04": {
            "entrypoint": "0x00081e04",
            "current_name": "deallocate_memory_00081e04",
            "code": "\nvoid deallocateMemory_00081e04(void *memoryPointer)\n\n{\n  _free_r(_impure_ptr,memoryPointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081e04": "deallocate_memory_00081e04",
                "__ptr": "memoryPointer"
            },
            "calling": [
                "~String",
                "invalidate"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081e14": {
            "entrypoint": "0x00081e14",
            "current_name": "allocate_memory_00081e14",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocateMemory_00081e14(undefined4 *param,uint size)\n\n{\n  undefined1 *pointer1;\n  int index1;\n  uint index2;\n  uint temp1;\n  int temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  undefined4 *pointer2;\n  undefined1 *pointer3;\n  undefined1 *pointer4;\n  undefined1 *pointer5;\n  uint temp6;\n  undefined4 *pointer6;\n  undefined4 *pointer7;\n  undefined1 *pointer8;\n  \n  if (size + 0xb < 0x17) {\n    temp6 = 0x10;\n    if (0x10 < size) goto LAB_00081e7a;\n  }\n  else {\n    temp6 = size + 0xb & 0xfffffff8;\n    if (((int)temp6 < 0) || (temp6 < size)) {\nLAB_00081e7a:\n      *param = 0xc;\n      return (int *)0x0;\n    }\n  }\n  __malloc_lock(param);\n  pointer6 = DAT_20070474;\n  if (temp6 < 0x1f8) {\n    pointer5 = *(undefined1 **)((int)&DAT_20070470 + temp6);\n    if ((pointer5 != &__malloc_av_ + temp6) ||\n       (pointer4 = pointer5 + 8, pointer5 = *(undefined1 **)(pointer5 + 0x14), pointer4 != pointer5)) {\n      temp5 = *(uint *)(pointer5 + 4);\n      temp2 = *(int *)(pointer5 + 0xc);\n      temp6 = *(uint *)(pointer5 + (temp5 & 0xfffffffc) + 4);\n      index1 = *(int *)(pointer5 + 8);\n      *(int *)(index1 + 0xc) = temp2;\n      *(int *)(temp2 + 8) = index1;\n      *(uint *)(pointer5 + (temp5 & 0xfffffffc) + 4) = temp6 | 1;\n      __malloc_unlock(param);\n      return (int *)(pointer5 + 8);\n    }\n    temp5 = (temp6 >> 3) + 2;\n  }\n  else {\n    temp5 = temp6 >> 9;\n    if (temp5 == 0) {\n      temp2 = 0x7e;\n      index1 = 0x3f;\n    }\n    else if (temp5 < 5) {\n      index1 = (temp6 >> 6) + 0x38;\n      temp2 = index1 * 2;\n    }\n    else if (temp5 < 0x15) {\n      index1 = temp5 + 0x5b;\n      temp2 = index1 * 2;\n    }\n    else if (temp5 < 0x55) {\n      index1 = (temp6 >> 0xc) + 0x6e;\n      temp2 = index1 * 2;\n    }\n    else if (temp5 < 0x155) {\n      index1 = (temp6 >> 0xf) + 0x77;\n      temp2 = index1 * 2;\n    }\n    else if (temp5 < 0x555) {\n      index1 = (temp6 >> 0x12) + 0x7c;\n      temp2 = index1 * 2;\n    }\n    else {\n      temp2 = 0xfc;\n      index1 = 0x7e;\n    }\n    for (pointer5 = (undefined1 *)(&DAT_20070470)[temp2]; &__malloc_av_ + temp2 * 4 != pointer5;\n        pointer5 = *(undefined1 **)(pointer5 + 0xc)) {\n      temp5 = *(uint *)(pointer5 + 4) & 0xfffffffc;\n      if (0xf < (int)(temp5 - temp6)) {\n        index1 = index1 + -1;\n        break;\n      }\n      if (-1 < (int)(temp5 - temp6)) {\n        temp6 = *(uint *)(pointer5 + temp5 + 4);\n        temp2 = *(int *)(pointer5 + 0xc);\n        index1 = *(int *)(pointer5 + 8);\n        *(int *)(index1 + 0xc) = temp2;\n        *(int *)(temp2 + 8) = index1;\n        *(uint *)(pointer5 + temp5 + 4) = temp6 | 1;\n        __malloc_unlock(param);\n        return (int *)(pointer5 + 8);\n      }\n    }\n    temp5 = index1 + 1;\n  }\n  index2 = DAT_20070468;\n  if ((undefined1 **)DAT_20070474 != &DAT_2007046c) {\n    index2 = DAT_20070474[1];\n    temp1 = index2 & 0xfffffffc;\n    temp3 = temp1 - temp6;\n    if (0xf < (int)temp3) {\n      pointer7 = (undefined4 *)(temp6 + (int)DAT_20070474);\n      DAT_20070474[1] = temp6 | 1;\n      DAT_20070474 = pointer7;\n      DAT_20070478 = pointer7;\n      pointer7[3] = &DAT_2007046c;\n      pointer7[2] = &DAT_2007046c;\n      pointer7[1] = temp3 | 1;\n      *(uint *)((int)pointer7 + temp3) = temp3;\n      __malloc_unlock(param);\n      return pointer6 + 2;\n    }\n    DAT_20070478 = &DAT_2007046c;\n    DAT_20070474 = &DAT_2007046c;\n    if (-1 < (int)temp3) {\n      *(uint *)((int)pointer6 + temp1 + 4) = *(uint *)((int)pointer6 + temp1 + 4) | 1;\n      __malloc_unlock(param);\n      return pointer6 + 2;\n    }\n    if (temp1 < 0x200) {\n      temp1 = index2 & 0xfffffff8;\n      index1 = *(int *)((int)&DAT_2007046c + temp1);\n      index2 = 1 << ((int)(index2 >> 3) >> 2 & 0xffU) | DAT_20070468;\n      pointer6[2] = index1;\n      pointer6[3] = &__malloc_av_ + temp1;\n      DAT_20070468 = index2;\n      *(undefined4 **)((int)&DAT_2007046c + temp1) = pointer6;\n      *(undefined4 **)(index1 + 0xc) = pointer6;\n    }\n    else {\n      temp3 = index2 >> 9;\n      if (temp3 < 5) {\n        temp2 = (index2 >> 6) + 0x38;\n        index1 = temp2 * 2;\n      }\n      else if (temp3 < 0x15) {\n        temp2 = temp3 + 0x5b;\n        index1 = temp2 * 2;\n      }\n      else if (temp3 < 0x55) {\n        temp2 = (index2 >> 0xc) + 0x6e;\n        index1 = temp2 * 2;\n      }\n      else if (temp3 < 0x155) {\n        temp2 = (index2 >> 0xf) + 0x77;\n        index1 = temp2 * 2;\n      }\n      else if (temp3 < 0x555) {\n        temp2 = (index2 >> 0x12) + 0x7c;\n        index1 = temp2 * 2;\n      }\n      else {\n        index1 = 0xfc;\n        temp2 = 0x7e;\n      }\n      pointer5 = (&DAT_2007046c)[index1];\n      if (pointer5 == &__malloc_av_ + index1 * 4) {\n        DAT_20070468 = DAT_20070468 | 1 << (temp2 >> 2 & 0xffU);\n        pointer4 = pointer5;\n      }\n      else {\n        do {\n          pointer4 = pointer5;\n          if ((*(uint *)(pointer5 + 4) & 0xfffffffc) <= temp1) break;\n          pointer5 = *(undefined1 **)(pointer5 + 8);\n          pointer4 = pointer5;\n        } while (&__malloc_av_ + index1 * 4 != pointer5);\n        pointer5 = *(undefined1 **)(pointer4 + 0xc);\n      }\n      index2 = DAT_20070468;\n      pointer6[3] = pointer5;\n      pointer6[2] = pointer4;\n      *(undefined4 **)(pointer5 + 8) = pointer6;\n      *(undefined4 **)(pointer4 + 0xc) = pointer6;\n    }\n  }\n  pointer5 = DAT_2007046c;\n  temp1 = 1 << ((int)temp5 >> 2 & 0xffU);\n  if (temp1 <= index2) {\n    if ((index2 & temp1) == 0) {\n      temp5 = temp5 & 0xfffffffc;\n      do {\n        temp1 = temp1 << 1;\n        temp5 = temp5 + 4;\n      } while ((index2 & temp1) == 0);\n    }\n    do {\n      pointer7 = (undefined4 *)(&__malloc_av_ + temp5 * 8);\n      pointer6 = pointer7;\n      index2 = temp5;\n      do {\n        for (pointer2 = (undefined4 *)pointer6[3]; pointer6 != pointer2; pointer2 = (undefined4 *)pointer2[3])\n        {\n          temp3 = pointer2[1] & 0xfffffffc;\n          temp4 = temp3 - temp6;\n          if (0xf < (int)temp4) {\n            temp2 = pointer2[2];\n            index1 = pointer2[3];\n            pointer6 = (undefined4 *)(temp6 + (int)pointer2);\n            pointer2[1] = temp6 | 1;\n            *(int *)(temp2 + 0xc) = index1;\n            *(int *)(index1 + 8) = temp2;\n            DAT_20070474 = pointer6;\n            DAT_20070478 = pointer6;\n            pointer6[3] = &DAT_2007046c;\n            pointer6[2] = &DAT_2007046c;\n            pointer6[1] = temp4 | 1;\n            *(uint *)((int)pointer6 + temp4) = temp4;\n            __malloc_unlock(param);\n            return pointer2 + 2;\n          }\n          if (-1 < (int)temp4) {\n            index1 = pointer2[2];\n            temp2 = pointer2[3];\n            *(uint *)((int)pointer2 + temp3 + 4) = *(uint *)((int)pointer2 + temp3 + 4) | 1;\n            *(int *)(index1 + 0xc) = temp2;\n            *(int *)(temp2 + 8) = index1;\n            __malloc_unlock(param);\n            return pointer2 + 2;\n          }\n        }\n        index2 = index2 + 1;\n        pointer6 = pointer6 + 2;\n      } while ((index2 & 3) != 0);\n      do {\n        temp3 = temp5 & 3;\n        pointer6 = pointer7 + -2;\n        temp5 = temp5 - 1;\n        if (temp3 == 0) {\n          DAT_20070468 = DAT_20070468 & ~temp1;\n          break;\n        }\n        pointer7 = (undefined4 *)*pointer7;\n      } while (pointer7 == pointer6);\n      temp1 = temp1 * 2;\n      if ((DAT_20070468 <= temp1 && temp1 - DAT_20070468 != 0) || (temp5 = index2, temp1 == 0))\n      break;\n      for (; (DAT_20070468 & temp1) == 0; temp1 = temp1 << 1) {\n        temp5 = temp5 + 4;\n      }\n    } while( true );\n  }\n  temp5 = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n  if ((temp6 <= temp5) && (index2 = temp5 - temp6, pointer4 = DAT_2007046c, 0xf < (int)index2))\n  goto LAB_0008211e;\n  pointer8 = DAT_2007046c + temp5;\n  if (__malloc_sbrk_base == (undefined1 *)0xffffffff) {\n    index2 = temp6 + __malloc_top_pad + 0x10;\n  }\n  else {\n    index2 = temp6 + __malloc_top_pad + 0x100f & 0xfffff000;\n  }\n  pointer4 = (undefined1 *)_sbrk_r(param,index2);\n  if ((pointer4 == (undefined1 *)0xffffffff) || ((pointer4 < pointer8 && (pointer5 != &__malloc_av_))))\n  {\n    temp5 = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n    pointer4 = DAT_2007046c;\n  }\n  else {\n    pointer3 = __malloc_current_mallinfo + index2;\n    __malloc_current_mallinfo = pointer3;\n    if ((pointer8 == pointer4) && (((uint)pointer8 & 0xfff) == 0)) {\n      *(uint *)(DAT_2007046c + 4) = index2 + temp5 | 1;\n    }\n    else {\n      pointer1 = pointer4;\n      if (__malloc_sbrk_base != (undefined1 *)0xffffffff) {\n        pointer1 = __malloc_sbrk_base;\n        __malloc_current_mallinfo = pointer3 + ((int)pointer4 - (int)pointer8);\n      }\n      __malloc_sbrk_base = pointer1;\n      temp1 = (uint)pointer4 & 7;\n      if (temp1 == 0) {\n        index1 = 0x1000;\n      }\n      else {\n        pointer4 = pointer4 + (8 - temp1);\n        index1 = 0x1008 - temp1;\n      }\n      index1 = index1 - ((uint)(pointer4 + index2) & 0xfff);\n      temp2 = _sbrk_r(param,index1);\n      if (temp2 == -1) {\n        index2 = 1;\n        index1 = 0;\n      }\n      else {\n        index2 = (temp2 - (int)pointer4) + index1 | 1;\n      }\n      pointer3 = __malloc_current_mallinfo + index1;\n      DAT_2007046c = pointer4;\n      __malloc_current_mallinfo = pointer3;\n      *(uint *)(pointer4 + 4) = index2;\n      if (pointer5 != &__malloc_av_) {\n        if (temp5 < 0x10) {\n          *(undefined4 *)(pointer4 + 4) = 1;\n          temp5 = 0;\n          goto LAB_00082108;\n        }\n        temp5 = temp5 - 0xc & 0xfffffff8;\n        *(uint *)(pointer5 + 4) = temp5 | *(uint *)(pointer5 + 4) & 1;\n        *(undefined4 *)(pointer5 + temp5 + 4) = 5;\n        *(undefined4 *)(pointer5 + temp5 + 8) = 5;\n        if (0xf < temp5) {\n          _free_r(param,pointer5 + 8);\n          pointer3 = __malloc_current_mallinfo;\n        }\n      }\n    }\n    if (__malloc_max_sbrked_mem < pointer3) {\n      __malloc_max_sbrked_mem = pointer3;\n    }\n    if (__malloc_max_total_mem < pointer3) {\n      __malloc_max_total_mem = pointer3;\n    }\n    temp5 = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n    pointer4 = DAT_2007046c;\n  }\nLAB_00082108:\n  index2 = temp5 - temp6;\n  if ((temp5 < temp6) || ((int)index2 < 0x10)) {\n    __malloc_unlock(param);\n    return (int *)0x0;\n  }\nLAB_0008211e:\n  DAT_2007046c = pointer4 + temp6;\n  *(uint *)(pointer4 + 4) = temp6 | 1;\n  *(uint *)(DAT_2007046c + 4) = index2 | 1;\n  __malloc_unlock(param);\n  return (int *)(pointer4 + 8);\n}\n\n",
            "renaming": {
                "FUN_00081e14": "allocate_memory_00081e14",
                "param_1": "param",
                "param_2": "size",
                "puVar1": "pointer1",
                "iVar2": "index1",
                "uVar3": "index2",
                "uVar4": "temp1",
                "iVar5": "temp2",
                "uVar6": "temp3",
                "uVar7": "temp4",
                "uVar8": "temp5",
                "puVar9": "pointer2",
                "puVar10": "pointer3",
                "puVar11": "pointer4",
                "puVar12": "pointer5",
                "uVar13": "temp6",
                "puVar14": "pointer6",
                "puVar15": "pointer7",
                "puVar16": "pointer8"
            },
            "calling": [
                "malloc",
                "__sfvwrite_r",
                "_realloc_r",
                "__smakebuf_r"
            ],
            "called": [
                "__malloc_unlock",
                "_sbrk_r",
                "__malloc_lock",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008234c": {
            "entrypoint": "0x0008234c",
            "current_name": "copy_memory_0008234c",
            "code": "\nvoid * copyMemory_0008234c(void *destination,void *source,size_t size)\n\n{\n  undefined *destPointer;\n  undefined4 *destPointer4;\n  undefined4 *destPointer32;\n  undefined *copyPointer;\n  undefined4 *srcPointer4;\n  undefined *srcPointer32;\n  uint remainingSize;\n  uint alignmentSize;\n  bool isRemainingSizePositive;\n  \n  destPointer32 = (undefined4 *)destination;\n  if ((((uint)source | (uint)destination) & 3) != 0) {\n    if (size < 8) {\n      alignmentSize = size - 4;\n      destPointer = (undefined *)destination;\n      if (3 < size) {\n        do {\n          srcPointer32 = (undefined *)source;\n          copyPointer = destPointer;\n          isRemainingSizePositive = alignmentSize != 0;\n          alignmentSize = alignmentSize - 1;\n          *copyPointer = *srcPointer32;\n          destPointer = copyPointer + 1;\n          source = srcPointer32 + 1;\n        } while (isRemainingSizePositive);\n        copyPointer[1] = srcPointer32[1];\n        copyPointer[2] = srcPointer32[2];\n        copyPointer[3] = srcPointer32[3];\n        return destination;\n      }\n      goto LAB_000823d0;\n    }\n    if ((((uint)source & 3) != 0) && (((uint)destination & 3) != 0)) {\n      alignmentSize = 4 - ((uint)destination & 3);\n      size = size - alignmentSize;\n      destPointer4 = (undefined4 *)destination;\n      srcPointer4 = (undefined4 *)source;\n                    /* WARNING: Load size is inaccurate */\n      if (((uint)destination & 1) != 0) {\n        srcPointer4 = (undefined4 *)((int)source + 1);\n        destPointer4 = (undefined4 *)((int)destination + 1);\n        *(undefined *)destination = *source;\n      }\n      destPointer32 = destPointer4;\n      source = srcPointer4;\n      if ((alignmentSize & 2) != 0) {\n        source = (void *)((int)srcPointer4 + 2);\n        destPointer32 = (undefined4 *)((int)destPointer4 + 2);\n        *(undefined2 *)destPointer4 = *(undefined2 *)srcPointer4;\n      }\n    }\n  }\n  while (0x3f < size) {\n                    /* WARNING: Load size is inaccurate */\n    *destPointer32 = *source;\n    destPointer32[1] = *(undefined4 *)((int)source + 4);\n    destPointer32[2] = *(undefined4 *)((int)source + 8);\n    destPointer32[3] = *(undefined4 *)((int)source + 0xc);\n    destPointer32[4] = *(undefined4 *)((int)source + 0x10);\n    destPointer32[5] = *(undefined4 *)((int)source + 0x14);\n    destPointer32[6] = *(undefined4 *)((int)source + 0x18);\n    destPointer32[7] = *(undefined4 *)((int)source + 0x1c);\n    destPointer32[8] = *(undefined4 *)((int)source + 0x20);\n    destPointer32[9] = *(undefined4 *)((int)source + 0x24);\n    destPointer32[10] = *(undefined4 *)((int)source + 0x28);\n    destPointer32[0xb] = *(undefined4 *)((int)source + 0x2c);\n    destPointer32[0xc] = *(undefined4 *)((int)source + 0x30);\n    destPointer32[0xd] = *(undefined4 *)((int)source + 0x34);\n    destPointer32[0xe] = *(undefined4 *)((int)source + 0x38);\n    destPointer32[0xf] = *(undefined4 *)((int)source + 0x3c);\n    destPointer32 = destPointer32 + 0x10;\n    source = (undefined4 *)((int)source + 0x40);\n    size = size - 0x40;\n  }\n  remainingSize = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n                    /* WARNING: Load size is inaccurate */\n      *destPointer32 = *source;\n      destPointer32[1] = *(undefined4 *)((int)source + 4);\n      destPointer32[2] = *(undefined4 *)((int)source + 8);\n      destPointer32[3] = *(undefined4 *)((int)source + 0xc);\n      destPointer32 = destPointer32 + 4;\n      source = (void *)((int)source + 0x10);\n      isRemainingSizePositive = 0xf < remainingSize;\n      remainingSize = remainingSize - 0x10;\n    } while (isRemainingSizePositive);\n  }\n  alignmentSize = remainingSize + 0xc;\n  srcPointer4 = destPointer32;\n  destPointer4 = (undefined4 *)source;\n  if (0xfffffff3 < remainingSize) {\n    do {\n      source = destPointer4 + 1;\n      *srcPointer4 = *destPointer4;\n      isRemainingSizePositive = 3 < alignmentSize;\n      alignmentSize = alignmentSize - 4;\n      destPointer32 = srcPointer4 + 1;\n      srcPointer4 = srcPointer4 + 1;\n      destPointer4 = (undefined4 *)source;\n    } while (isRemainingSizePositive);\n  }\nLAB_000823d0:\n  if (alignmentSize + 4 != 0) {\n    destPointer4 = destPointer32;\n    srcPointer4 = (undefined4 *)source;\n                    /* WARNING: Load size is inaccurate */\n    if ((alignmentSize & 1) != 0) {\n      srcPointer4 = (undefined4 *)((int)source + 1);\n      destPointer4 = (undefined4 *)((int)destPointer32 + 1);\n      *(undefined *)destPointer32 = *source;\n    }\n    if ((alignmentSize + 4 & 2) != 0) {\n      *(undefined2 *)destPointer4 = *(undefined2 *)srcPointer4;\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_0008234c": "copy_memory_0008234c",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "puVar1": "destPointer",
                "puVar2": "destPointer4",
                "puVar3": "destPointer32",
                "puVar4": "copyPointer",
                "puVar5": "srcPointer4",
                "puVar6": "srcPointer32",
                "uVar7": "remainingSize",
                "uVar8": "alignmentSize",
                "bVar9": "isRemainingSizePositive"
            },
            "calling": [
                "__sfvwrite_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082438": {
            "entrypoint": "0x00082438",
            "current_name": "reverse_copy_memory_00082438",
            "code": "\nvoid * reverse_copy_memory_00082438(void *destination,void *source,size_t length)\n\n{\n  int index;\n  undefined4 *dest_ptr;\n  undefined4 *src_ptr;\n  undefined4 *temp_ptr;\n  undefined *end_ptr;\n  uint remaining_length;\n  undefined *end_dest_ptr;\n  uint remaining_bytes;\n  \n  if ((source < destination) && (end_ptr = (undefined *)((int)source + length), destination < end_ptr)) {\n    end_dest_ptr = (undefined *)((int)destination + length);\n    index = length - 1;\n    if (length != 0) {\n      do {\n        end_ptr = end_ptr + -1;\n        index = index + -1;\n        end_dest_ptr = end_dest_ptr + -1;\n        *end_dest_ptr = *end_ptr;\n      } while (index != -1);\n    }\n    return destination;\n  }\n  dest_ptr = (undefined4 *)destination;\n  if (length < 0x10) {\n    if (length == 0) {\n      return destination;\n    }\n  }\n  else if ((((uint)destination | (uint)source) & 3) == 0) {\n    src_ptr = (undefined4 *)source;\n    do {\n      temp_ptr = dest_ptr + 4;\n      *dest_ptr = *src_ptr;\n      dest_ptr[1] = src_ptr[1];\n      dest_ptr[2] = src_ptr[2];\n      dest_ptr[3] = src_ptr[3];\n      dest_ptr = temp_ptr;\n      src_ptr = src_ptr + 4;\n    } while (temp_ptr != (undefined4 *)((int)destination + (length - 0x10 & 0xfffffff0) + 0x10));\n    remaining_bytes = length & 0xf;\n    index = ((length - 0x10 >> 4) + 1) * 0x10;\n    source = (void *)((int)source + index);\n    dest_ptr = (undefined4 *)(index + (int)destination);\n    remaining_length = remaining_bytes;\n    src_ptr = dest_ptr;\n    temp_ptr = (undefined4 *)source;\n    if (3 < remaining_bytes) {\n      do {\n        remaining_length = remaining_length - 4;\n        *src_ptr = *temp_ptr;\n        src_ptr = src_ptr + 1;\n        temp_ptr = temp_ptr + 1;\n      } while (3 < remaining_length);\n      index = (remaining_bytes - 4 & 0xfffffffc) + 4;\n      dest_ptr = (undefined4 *)((int)dest_ptr + index);\n      source = (void *)((int)source + index);\n      remaining_bytes = length & 3;\n    }\n    length = remaining_bytes;\n    if (length == 0) {\n      return destination;\n    }\n  }\n  src_ptr = dest_ptr;\n  do {\n                    /* WARNING: Load size is inaccurate */\n    temp_ptr = (undefined4 *)((int)src_ptr + 1);\n    *(undefined *)src_ptr = *source;\n    source = (undefined4 *)((int)source + 1);\n    src_ptr = temp_ptr;\n  } while (temp_ptr != (undefined4 *)(length + (int)dest_ptr));\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_00082438": "reverse_copy_memory_00082438",
                "__dest": "destination",
                "__src": "source",
                "__n": "length",
                "iVar1": "index",
                "puVar2": "dest_ptr",
                "puVar3": "src_ptr",
                "puVar4": "temp_ptr",
                "puVar5": "end_ptr",
                "puVar7": "end_dest_ptr",
                "uVar6": "remaining_length",
                "uVar8": "remaining_bytes"
            },
            "calling": [
                "__sfvwrite_r",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082504": {
            "entrypoint": "0x00082504",
            "current_name": "memset_with_value_00082504",
            "code": "\nvoid * memset_with_value_00082504(void *dest,int value,size_t num_bytes)\n\n{\n  uint *dest_ptr;\n  uint *cur_ptr;\n  uint *next_ptr;\n  uint value_32;\n  uint remaining_bytes;\n  bool is_empty;\n  \n  cur_ptr = (uint *)dest;\n  if (((uint)dest & 3) != 0) {\n    is_empty = num_bytes == 0;\n    dest_ptr = (uint *)dest;\n    num_bytes = num_bytes - 1;\n    if (is_empty) {\n      return dest;\n    }\n    while( true ) {\n      cur_ptr = (uint *)((int)dest_ptr + 1);\n      *(char *)dest_ptr = (char)value;\n      if (((uint)cur_ptr & 3) == 0) break;\n      is_empty = num_bytes == 0;\n      dest_ptr = cur_ptr;\n      num_bytes = num_bytes - 1;\n      if (is_empty) {\n        return dest;\n      }\n    }\n  }\n  if (3 < num_bytes) {\n    value_32 = value & 0xffU | (value & 0xffU) << 8;\n    value_32 = value_32 | value_32 << 0x10;\n    remaining_bytes = num_bytes;\n    dest_ptr = cur_ptr;\n    if (0xf < num_bytes) {\n      remaining_bytes = num_bytes - 0x10;\n      do {\n        *dest_ptr = value_32;\n        dest_ptr[1] = value_32;\n        dest_ptr[2] = value_32;\n        dest_ptr[3] = value_32;\n        dest_ptr = dest_ptr + 4;\n      } while (dest_ptr != (uint *)((int)cur_ptr + (remaining_bytes & 0xfffffff0) + 0x10));\n      num_bytes = num_bytes & 0xf;\n      cur_ptr = cur_ptr + ((remaining_bytes >> 4) + 1) * 4;\n      remaining_bytes = num_bytes;\n      dest_ptr = cur_ptr;\n      if (num_bytes < 4) goto LAB_00082580;\n    }\n    do {\n      num_bytes = num_bytes - 4;\n      *cur_ptr = value_32;\n      cur_ptr = cur_ptr + 1;\n    } while (3 < num_bytes);\n    cur_ptr = (uint *)((int)dest_ptr + (remaining_bytes - 4 & 0xfffffffc) + 4);\n    num_bytes = remaining_bytes & 3;\n  }\nLAB_00082580:\n  if (num_bytes != 0) {\n    dest_ptr = cur_ptr;\n    do {\n      next_ptr = (uint *)((int)dest_ptr + 1);\n      *(char *)dest_ptr = (char)value;\n      dest_ptr = next_ptr;\n    } while (next_ptr != (uint *)(num_bytes + (int)cur_ptr));\n  }\n  return dest;\n}\n\n",
            "renaming": {
                "FUN_00082504": "memset_with_value_00082504",
                "__s": "dest",
                "__c": "value",
                "__n": "num_bytes",
                "puVar1": "dest_ptr",
                "puVar2": "cur_ptr",
                "puVar3": "next_ptr",
                "uVar4": "value_32",
                "uVar5": "remaining_bytes",
                "bVar6": "is_empty"
            },
            "calling": [
                "RingBuffer",
                "__sinit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082598": {
            "entrypoint": "0x00082598",
            "current_name": "FUNC_00082598",
            "code": "\nvoid FUNC_00082598(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00082598": "FUNC_00082598"
            },
            "calling": [
                "_malloc_r",
                "_realloc_r",
                "_malloc_trim_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008259c": {
            "entrypoint": "0x0008259c",
            "current_name": "FUNC_0008259c",
            "code": "\nvoid FUNC_0008259c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008259c": "FUNC_0008259c"
            },
            "calling": [
                "_malloc_r",
                "_realloc_r",
                "_malloc_trim_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000825a0": {
            "entrypoint": "0x000825a0",
            "current_name": "reallocated_memory_000825a0",
            "code": "\nvoid * reallocatedMemory_000825a0(void *originalPointer,size_t newSize)\n\n{\n  void *reallocatedPointer;\n  \n  reallocatedPointer = (void *)_realloc_r(_impure_ptr,originalPointer,newSize);\n  return reallocatedPointer;\n}\n\n",
            "renaming": {
                "FUN_000825a0": "reallocated_memory_000825a0",
                "__ptr": "originalPointer",
                "__size": "newSize",
                "pvVar1": "reallocatedPointer"
            },
            "calling": [
                "changeBuffer"
            ],
            "called": [
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000825b0": {
            "entrypoint": "0x000825b0",
            "current_name": "allocate_memory_000825b0",
            "code": "\nint * allocateMemory_000825b0(undefined4 *param,int *buffer,uint size)\n\n{\n  int currentBlock;\n  int *newBlock;\n  uint headerSize;\n  size_t moveSize;\n  uint prevBlockSize;\n  int temp;\n  int *dest;\n  uint blockSize;\n  uint alignedSize;\n  int *result;\n  \n  if (buffer == (int *)0x0) {\n    newBlock = (int *)_malloc_r(param,size);\n    return newBlock;\n  }\n  __malloc_lock();\n  prevBlockSize = buffer[-1];\n  blockSize = prevBlockSize & 0xfffffffc;\n  newBlock = buffer + -2;\n  if (size + 0xb < 0x17) {\n    alignedSize = 0x10;\n  }\n  else {\n    alignedSize = size + 0xb & 0xfffffff8;\n    if ((int)alignedSize < 0) goto LAB_0008267c;\n  }\n  if (alignedSize < size) {\nLAB_0008267c:\n    *param = 0xc;\n    return (int *)0x0;\n  }\n  if ((int)blockSize < (int)alignedSize) {\n    currentBlock = (int)newBlock + blockSize;\n    if (DAT_2007046c == currentBlock) {\n      headerSize = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n      currentBlock = DAT_2007046c;\n      if ((int)(alignedSize + 0x10) <= (int)(headerSize + blockSize)) {\n        DAT_2007046c = (int)newBlock + alignedSize;\n        *(uint *)(DAT_2007046c + 4) = (headerSize + blockSize) - alignedSize | 1;\n        buffer[-1] = alignedSize | buffer[-1] & 1U;\n        __malloc_unlock(param);\n        return buffer;\n      }\n    }\n    else if ((*(uint *)((*(uint *)(currentBlock + 4) & 0xfffffffe) + currentBlock + 4) & 1) == 0) {\n      headerSize = *(uint *)(currentBlock + 4) & 0xfffffffc;\n      if ((int)alignedSize <= (int)(headerSize + blockSize)) {\n        temp = *(int *)(currentBlock + 0xc);\n        currentBlock = *(int *)(currentBlock + 8);\n        *(int *)(currentBlock + 0xc) = temp;\n        *(int *)(temp + 8) = currentBlock;\n        blockSize = headerSize + blockSize;\n        goto LAB_0008268c;\n      }\n    }\n    else {\n      headerSize = 0;\n      currentBlock = 0;\n    }\n    if (-1 < (int)(prevBlockSize << 0x1f)) {\n      result = (int *)((int)newBlock - buffer[-2]);\n      prevBlockSize = (result[1] & 0xfffffffcU) + blockSize;\n      if (currentBlock != 0) {\n        if (currentBlock == DAT_2007046c) {\n          if ((int)(alignedSize + 0x10) <= (int)(headerSize + prevBlockSize)) {\n            newBlock = result + 2;\n            currentBlock = *newBlock;\n            temp = result[3];\n            moveSize = blockSize - 4;\n            *(int *)(currentBlock + 0xc) = temp;\n            *(int *)(temp + 8) = currentBlock;\n            if (moveSize < 0x25) {\n              dest = newBlock;\n              if (0x13 < moveSize) {\n                result[2] = *buffer;\n                result[3] = buffer[1];\n                if (moveSize < 0x1c) {\n                  buffer = buffer + 2;\n                  dest = result + 4;\n                }\n                else {\n                  result[4] = buffer[2];\n                  result[5] = buffer[3];\n                  if (moveSize == 0x24) {\n                    result[6] = buffer[4];\n                    dest = buffer + 5;\n                    buffer = buffer + 6;\n                    result[7] = *dest;\n                    dest = result + 8;\n                  }\n                  else {\n                    buffer = buffer + 4;\n                    dest = result + 6;\n                  }\n                }\n              }\n              *dest = *buffer;\n              dest[1] = buffer[1];\n              dest[2] = buffer[2];\n            }\n            else {\n              memmove(newBlock,buffer,moveSize);\n            }\n            DAT_2007046c = (int)result + alignedSize;\n            *(uint *)(DAT_2007046c + 4) = (headerSize + prevBlockSize) - alignedSize | 1;\n            result[1] = alignedSize | result[1] & 1U;\n            __malloc_unlock(param);\n            return newBlock;\n          }\n        }\n        else {\n          headerSize = headerSize + prevBlockSize;\n          if ((int)alignedSize <= (int)headerSize) {\n            temp = *(int *)(currentBlock + 0xc);\n            currentBlock = *(int *)(currentBlock + 8);\n            *(int *)(currentBlock + 0xc) = temp;\n            *(int *)(temp + 8) = currentBlock;\n            dest = result + 2;\n            currentBlock = *dest;\n            temp = result[3];\n            moveSize = blockSize - 4;\n            *(int *)(currentBlock + 0xc) = temp;\n            *(int *)(temp + 8) = currentBlock;\n            blockSize = headerSize;\n            if (moveSize < 0x25) {\n              newBlock = dest;\n              if (0x13 < moveSize) {\n                result[2] = *buffer;\n                result[3] = buffer[1];\n                if (moveSize < 0x1c) {\n                  buffer = buffer + 2;\n                  newBlock = result + 4;\n                }\n                else {\n                  result[4] = buffer[2];\n                  result[5] = buffer[3];\n                  if (moveSize == 0x24) {\n                    result[6] = buffer[4];\n                    newBlock = buffer + 5;\n                    buffer = buffer + 6;\n                    result[7] = *newBlock;\n                    newBlock = result + 8;\n                  }\n                  else {\n                    buffer = buffer + 4;\n                    newBlock = result + 6;\n                  }\n                }\n              }\n              *newBlock = *buffer;\n              newBlock[1] = buffer[1];\n              newBlock[2] = buffer[2];\n              prevBlockSize = result[1];\n              newBlock = result;\n              buffer = dest;\n            }\n            else {\n              memmove(dest,buffer,moveSize);\n              prevBlockSize = result[1];\n              newBlock = result;\n              buffer = dest;\n            }\n            goto LAB_0008268c;\n          }\n        }\n      }\n      if ((int)alignedSize <= (int)prevBlockSize) {\n        dest = result + 2;\n        currentBlock = *dest;\n        temp = result[3];\n        moveSize = blockSize - 4;\n        *(int *)(currentBlock + 0xc) = temp;\n        *(int *)(temp + 8) = currentBlock;\n        blockSize = prevBlockSize;\n        if (moveSize < 0x25) {\n          newBlock = dest;\n          if (0x13 < moveSize) {\n            result[2] = *buffer;\n            result[3] = buffer[1];\n            if (moveSize < 0x1c) {\n              buffer = buffer + 2;\n              newBlock = result + 4;\n            }\n            else {\n              result[4] = buffer[2];\n              result[5] = buffer[3];\n              if (moveSize == 0x24) {\n                result[6] = buffer[4];\n                newBlock = buffer + 5;\n                buffer = buffer + 6;\n                result[7] = *newBlock;\n                newBlock = result + 8;\n              }\n              else {\n                buffer = buffer + 4;\n                newBlock = result + 6;\n              }\n            }\n          }\n          *newBlock = *buffer;\n          newBlock[1] = buffer[1];\n          newBlock[2] = buffer[2];\n          prevBlockSize = result[1];\n          newBlock = result;\n          buffer = dest;\n        }\n        else {\n          memmove(dest,buffer,moveSize);\n          prevBlockSize = result[1];\n          newBlock = result;\n          buffer = dest;\n        }\n        goto LAB_0008268c;\n      }\n    }\n    result = (int *)_malloc_r(param,size);\n    if (result == (int *)0x0) goto LAB_000826a4;\n    prevBlockSize = buffer[-1];\n    if (result + -2 != (int *)((prevBlockSize & 0xfffffffe) + (int)newBlock)) {\n      moveSize = blockSize - 4;\n      if (moveSize < 0x25) {\n        newBlock = buffer;\n        dest = result;\n        if (0x13 < moveSize) {\n          *result = *buffer;\n          result[1] = buffer[1];\n          if (moveSize < 0x1c) {\n            newBlock = buffer + 2;\n            dest = result + 2;\n          }\n          else {\n            result[2] = buffer[2];\n            result[3] = buffer[3];\n            if (moveSize == 0x24) {\n              result[4] = buffer[4];\n              result[5] = buffer[5];\n              newBlock = buffer + 6;\n              dest = result + 6;\n            }\n            else {\n              newBlock = buffer + 4;\n              dest = result + 4;\n            }\n          }\n        }\n        *dest = *newBlock;\n        dest[1] = newBlock[1];\n        dest[2] = newBlock[2];\n      }\n      else {\n        memmove(result,buffer,moveSize);\n      }\n      _free_r(param,buffer);\n      goto LAB_000826a4;\n    }\n    blockSize = blockSize + (result[-1] & 0xfffffffcU);\n  }\nLAB_0008268c:\n  headerSize = blockSize - alignedSize;\n  result = buffer;\n  if (headerSize < 0x10) {\n    newBlock[1] = prevBlockSize & 1 | blockSize;\n    *(uint *)((int)newBlock + blockSize + 4) = *(uint *)((int)newBlock + blockSize + 4) | 1;\n  }\n  else {\n    newBlock[1] = prevBlockSize & 1 | alignedSize;\n    *(uint *)((int)newBlock + alignedSize + 4) = headerSize | 1;\n    *(uint *)((int)newBlock + headerSize + alignedSize + 4) = *(uint *)((int)newBlock + headerSize + alignedSize + 4) | 1;\n    _free_r(param,(int)newBlock + alignedSize + 8);\n  }\nLAB_000826a4:\n  __malloc_unlock(param);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000825b0": "allocate_memory_000825b0",
                "param_1": "param",
                "param_2": "buffer",
                "param_3": "size",
                "iVar1": "currentBlock",
                "piVar2": "newBlock",
                "uVar3": "headerSize",
                "sVar4": "moveSize",
                "uVar5": "prevBlockSize",
                "iVar6": "temp",
                "piVar7": "dest",
                "uVar8": "blockSize",
                "uVar9": "alignedSize",
                "piVar10": "result"
            },
            "calling": [
                "__sfvwrite_r",
                "realloc"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock",
                "_malloc_r",
                "_free_r",
                "memmove"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082970": {
            "entrypoint": "0x00082970",
            "current_name": "allocate_memory_00082970",
            "code": "\nvoid allocateMemory_00082970(int *error,intptr_t size)\n\n{\n  void *allocatedPtr;\n  \n  errno = 0;\n  allocatedPtr = _sbrk(size);\n  if ((allocatedPtr == (void *)0xffffffff) && (errno != 0)) {\n    *error = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00082970": "allocate_memory_00082970",
                "param_1": "error",
                "param_2": "size",
                "pvVar1": "allocatedPtr"
            },
            "calling": [
                "_malloc_r",
                "_malloc_trim_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082994": {
            "entrypoint": "0x00082994",
            "current_name": "copy_string_00082994",
            "code": "\nchar * copyString_00082994(char *destination,char *source)\n\n{\n  char currentChar;\n  ushort currentShort;\n  uint *pointer1;\n  uint *pointer2;\n  uint currentUint;\n  uint tempUint;\n  uint *destinationPointer;\n  uint *sourcePointer;\n  char *destinationCharPointer;\n  bool isZero;\n  \n  destinationCharPointer = destination;\n  if ((((uint)destination ^ (uint)source) & 3) != 0) {\n    do {\n      currentChar = *source;\n      *destinationCharPointer = currentChar;\n      source = source + 1;\n      destinationCharPointer = destinationCharPointer + 1;\n    } while (currentChar != '\\0');\n    return destination;\n  }\n  sourcePointer = (uint *)destination;\n  if (((uint)source & 3) != 0) {\n    pointer2 = (uint *)source;\n    if (((uint)source & 1) != 0) {\n      pointer2 = (uint *)(source + 1);\n      currentChar = *source;\n      sourcePointer = (uint *)(destination + 1);\n      *destination = currentChar;\n      if (currentChar == '\\0') {\n        return destination;\n      }\n    }\n    source = (char *)pointer2;\n    if (((uint)pointer2 & 2) != 0) {\n      source = (char *)((int)pointer2 + 2);\n      currentShort = *(ushort *)pointer2;\n      isZero = (currentShort & 0xff) == 0;\n      if (isZero) {\n        *(char *)sourcePointer = (char)currentShort;\n      }\n      else {\n        *(ushort *)sourcePointer = currentShort;\n        isZero = (currentShort & 0xff00) == 0;\n        sourcePointer = (uint *)((int)sourcePointer + 2);\n      }\n      if (isZero) {\n        return destination;\n      }\n    }\n  }\n  currentUint = *(uint *)source;\n  pointer2 = (uint *)((int)source + 4);\n  destinationPointer = sourcePointer;\n  if (((uint)source & 4) != 0) {\n    if ((currentUint + 0xfefefeff & ~currentUint & 0x80808080) != 0) goto LAB_000829f8;\n    destinationPointer = sourcePointer + 1;\n    *sourcePointer = currentUint;\n    pointer2 = (uint *)((int)source + 8);\n    currentUint = *(uint *)((int)source + 4);\n  }\n  while( true ) {\n    pointer1 = pointer2 + 1;\n    tempUint = *pointer2;\n    sourcePointer = destinationPointer;\n    if ((currentUint + 0xfefefeff & ~currentUint & 0x80808080) != 0) break;\n    sourcePointer = destinationPointer + 1;\n    *destinationPointer = currentUint;\n    currentUint = tempUint;\n    if ((tempUint + 0xfefefeff & ~tempUint & 0x80808080) != 0) break;\n    pointer2 = pointer2 + 2;\n    currentUint = *pointer1;\n    destinationPointer = destinationPointer + 2;\n    *sourcePointer = tempUint;\n  }\nLAB_000829f8:\n  do {\n    *(char *)sourcePointer = (char)currentUint;\n    tempUint = currentUint & 0xff;\n    currentUint = currentUint >> 8 | currentUint << 0x18;\n    sourcePointer = (uint *)((int)sourcePointer + 1);\n  } while (tempUint != 0);\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_00082994": "copy_string_00082994",
                "__dest": "destination",
                "__src": "source",
                "cVar1": "currentChar",
                "uVar2": "currentShort",
                "puVar3": "pointer1",
                "puVar4": "pointer2",
                "uVar5": "currentUint",
                "uVar6": "tempUint",
                "puVar7": "destinationPointer",
                "puVar8": "sourcePointer",
                "pcVar9": "destinationCharPointer",
                "bVar10": "isZero"
            },
            "calling": [
                "copy"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082a50": {
            "entrypoint": "0x00082a50",
            "current_name": "calculate_string_length_00082a50",
            "code": "\nsize_t calculateStringLength_00082a50(char *inputString)\n\n{\n  size_t offsetBytes;\n  uint *alignedPointer;\n  uint currentWord;\n  bool isWordZero;\n  \n  alignedPointer = (uint *)((uint)inputString & 0xfffffffc);\n  offsetBytes = -((uint)inputString & 3);\n  currentWord = *alignedPointer;\n  if (((uint)inputString & 3) != 0) {\n    currentWord = currentWord | 0xffffffffU >> ((offsetBytes + 4 & 0x1f) << 3);\n  }\n  while (alignedPointer = alignedPointer + 1, (currentWord + 0xfefefeff & ~currentWord & 0x80808080) == 0) {\n    offsetBytes = offsetBytes + 4;\n    currentWord = *alignedPointer;\n  }\n  isWordZero = (currentWord & 0xff) == 0;\n  if (!isWordZero) {\n    offsetBytes = offsetBytes + 1;\n    isWordZero = (currentWord & 0xff00) == 0;\n  }\n  if (!isWordZero) {\n    offsetBytes = offsetBytes + 1;\n    isWordZero = (currentWord & 0xff0000) == 0;\n  }\n  if (!isWordZero) {\n    offsetBytes = offsetBytes + 1;\n  }\n  return offsetBytes;\n}\n\n",
            "renaming": {
                "FUN_00082a50": "calculate_string_length_00082a50",
                "__s": "inputString",
                "sVar1": "offsetBytes",
                "puVar2": "alignedPointer",
                "uVar3": "currentWord",
                "bVar4": "isWordZero"
            },
            "calling": [
                "String",
                "_vfiprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082ab0": {
            "entrypoint": "0x00082ab0",
            "current_name": "send_signal_00082ab0",
            "code": "\nint sendSignal_00082ab0(processId_t processId,int signalNumber)\n\n{\n  int result;\n  \n  result = _kill_r(_impure_ptr,processId,signalNumber);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00082ab0": "send_signal_00082ab0",
                "__pid": "processId",
                "__sig": "signalNumber",
                "iVar1": "result"
            },
            "calling": [],
            "called": [
                "_kill_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082ac0": {
            "entrypoint": "0x00082ac0",
            "current_name": "write_to_file_00082ac0",
            "code": "\nint writeToFile_00082ac0(undefined4 file,int bufferSize,int **data)\n\n{\n  int *pData;\n  int result;\n  int *pCurrentData;\n  uint iteration;\n  undefined4 *pWord;\n  uint wordSize;\n  uint numWords;\n  \n  if (-1 < *(int *)(bufferSize + 100) << 0x12) {\n    result = __sfvwrite_r();\n    data[2] = (int *)0x0;\n    data[1] = (int *)0x0;\n    return result;\n  }\n  pCurrentData = data[2];\n  pData = *data;\n  while (pCurrentData != (int *)0x0) {\n    wordSize = pData[1];\n    numWords = wordSize >> 2;\n    if (numWords != 0) {\n      pWord = (undefined4 *)(*pData + -4);\n      iteration = 0;\n      do {\n        pWord = pWord + 1;\n        result = _fputwc_r(file,*pWord,bufferSize);\n        iteration = iteration + 1;\n        if (result == -1) goto LAB_00082b00;\n      } while (numWords != iteration);\n      pCurrentData = data[2];\n    }\n    pCurrentData = (int *)((int)pCurrentData - (wordSize & 0xfffffffc));\n    data[2] = pCurrentData;\n    pData = pData + 2;\n  }\n  result = 0;\nLAB_00082b00:\n  data[2] = (int *)0x0;\n  data[1] = (int *)0x0;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00082ac0": "write_to_file_00082ac0",
                "param_1": "file",
                "param_2": "bufferSize",
                "param_3": "data",
                "piVar1": "pData",
                "iVar2": "result",
                "piVar3": "pCurrentData",
                "uVar4": "iteration",
                "puVar5": "pWord",
                "uVar6": "wordSize",
                "uVar7": "numWords"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "_fputwc_r",
                "__sfvwrite_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082b38": {
            "entrypoint": "0x00082b38",
            "current_name": "print_formatted_string_00082b38",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nint print_formatted_string_00082b38(int buffer,int format,int *******format_ptr,int **arguments)\n\n{\n  bool flag_minus;\n  bool flag_plus;\n  bool flag_zero;\n  char specifier;\n  bool flag_hash;\n  void *ptr;\n  int ********ptr_array;\n  int *value_ptr;\n  int result;\n  char character;\n  int *******format_start_ptr;\n  uint digit;\n  int **arg_ptr;\n  uint flags;\n  uint ch;\n  int counter;\n  int ********pptr_array_temp;\n  int counter2;\n  int *******remaining_format_ptr;\n  int *value;\n  int *******ppppppptemp;\n  uint temp2;\n  int *sign;\n  int *******tmp_ptr;\n  undefined4 temp3;\n  int ********formatted_string;\n  bool flag_long;\n  longlong combined_value;\n  int *******minimum_width_ptr;\n  int *******precision_ptr;\n  int **arg_current_ptr;\n  int total_length;\n  char *digits;\n  char prefix_char;\n  undefined fill_char;\n  undefined conversion_size;\n  int ********format_start_ptr_temp;\n  int arg_count;\n  int *******args_ptr;\n  undefined buffer_temp;\n  char zeroes_6718;\n  undefined digit_temp;\n  undefined formatted_string_temp [4];\n  int *******ptr_array_temp2 [16];\n  \n  if ((buffer != 0) && (*(int *)(buffer + 0x38) == 0)) {\n    formatted_stringinit();\n  }\n  flags = (uint)*(ushort *)(format + 0xc);\n  if (-1 < (int)((uint)*(ushort *)(format + 0xc) << 0x12)) {\n    flags = flags | 0x2000;\n    *(short *)(format + 0xc) = (short)flags;\n    *(uint *)(format + 100) = *(uint *)(format + 100) & 0xffffdfff;\n  }\n  if (((int)(flags << 0x1c) < 0) && (*(int *)(format + 0x10) != 0)) {\n    if ((flags & 0x1a) != 10) goto LAB_00082b8a;\n  }\n  else {\n    result = formatted_stringwsetup_r(buffer,format);\n    if (result != 0) {\n      return -1;\n    }\n    if ((*(ushort *)(format + 0xc) & 0x1a) != 10) goto LAB_00082b8a;\n  }\n  if (-1 < *(short *)(format + 0xe)) {\n    result = formatted_stringbprintf(buffer,format,format_ptr,arguments);\n    return result;\n  }\nLAB_00082b8a:\n  digits = (char *)0x0;\n  args_ptr = (int *******)0x0;\n  arg_count = 0;\n  total_length = 0;\n  ptr_array = (int ********)formatted_string_temp;\n  arg_current_ptr = arguments;\n  format_start_ptr_temp = (int ********)formatted_string_temp;\nLAB_00082b9e:\n  format_start_ptr = format_ptr;\n  if ((*(char *)format_ptr != '\\0') && (*(char *)format_ptr != '%')) {\n    do {\n      format_start_ptr = (int *******)((int)format_start_ptr + 1);\n      if (*(char *)format_start_ptr == '\\0') break;\n    } while (*(char *)format_start_ptr != '%');\n    ppppppptemp = (int *******)((int)format_start_ptr - (int)format_ptr);\n    if (ppppppptemp != (int *******)0x0) {\n      arg_count = arg_count + 1;\n      args_ptr = (int *******)((int)args_ptr + (int)ppppppptemp);\n      *ptr_array = format_ptr;\n      ptr_array[1] = ppppppptemp;\n      if (arg_count < 8) {\n        ptr_array = ptr_array + 2;\n      }\n      else {\n        if (args_ptr == (int *******)0x0) {\n          total_length = total_length + (int)ppppppptemp;\n          arg_count = 0;\n          ptr_array = (int ********)formatted_string_temp;\n          goto LAB_00082bee;\n        }\n        result = formatted_stringprint_r_part_0(buffer,format,&format_start_ptr_temp);\n        ptr_array = (int ********)formatted_string_temp;\n        if (result != 0) goto LAB_000833de;\n      }\n      total_length = total_length + (int)ppppppptemp;\n    }\n  }\nLAB_00082bee:\n  if (*(char *)format_start_ptr != '\\0') {\n    prefix_char = '\\0';\n    ch = (uint)*(byte *)((int)format_start_ptr + 1);\n    flags = 0;\n    flag_hash = false;\n    flag_plus = false;\n    flag_minus = false;\n    flag_zero = false;\n    flag_long = false;\n    ppppppptemp = (int *******)0x0;\n    precision_ptr = (int *******)0xffffffff;\n    format_ptr = (int *******)((int)format_start_ptr + 1);\nLAB_00082c12:\n    format_ptr = (int *******)((int)format_ptr + 1);\nLAB_00082c16:\n    switch(ch) {\n    case 0x20:\n      goto switchD_00082c20_caseD_20;\n    default:\n      if (ch != 0) {\n        minimum_width_ptr = (int *******)0x1;\n        precision_ptr = (int *******)0x1;\n        formatted_string = (int ********)&buffer_temp;\n        buffer_temp = (char)ch;\n        goto LAB_00083012;\n      }\n      goto LAB_000833d0;\n    case 0x23:\n      flag_zero = true;\n      ch = (uint)*(byte *)format_ptr;\n      goto LAB_00082c12;\n    case 0x2a:\n      ppppppptemp = (int *******)*arg_current_ptr;\n      arg_current_ptr = arg_current_ptr + 1;\n      if ((int)ppppppptemp < 0) {\n        ppppppptemp = (int *******)-(int)ppppppptemp;\n        goto switchD_00082c20_caseD_2d;\n      }\n      ch = (uint)*(byte *)format_ptr;\n      goto LAB_00082c12;\n    case 0x2b:\n      ch = (uint)*(byte *)format_ptr;\n      prefix_char = '+';\n      goto LAB_00082c12;\n    case 0x2d:\nswitchD_00082c20_caseD_2d:\n      flags = flags | 4;\n      ch = (uint)*(byte *)format_ptr;\n      goto LAB_00082c12;\n    case 0x2e:\n      ch = (uint)*(byte *)format_ptr;\n      format_start_ptr = (int *******)((int)format_ptr + 1);\n      if (ch == 0x2a) {\n        ch = (uint)*(byte *)((int)format_ptr + 1);\n        precision_ptr = (int *******)*arg_current_ptr;\n        arg_current_ptr = arg_current_ptr + 1;\n        format_ptr = format_start_ptr;\n        if ((int)precision_ptr < 0) {\n          precision_ptr = (int *******)0xffffffff;\n        }\n        goto LAB_00082c12;\n      }\n      digit = ch - 0x30;\n      if (digit < 10) {\n        temp2 = 0;\n        do {\n          format_ptr = (int *******)((int)format_start_ptr + 1);\n          ch = (uint)*(byte *)format_start_ptr;\n          temp2 = digit + temp2 * 10;\n          digit = ch - 0x30;\n          format_start_ptr = format_ptr;\n        } while (digit < 10);\n        precision_ptr = (int *******)(temp2 | (int)temp2 >> 0x1f);\n      }\n      else {\n        precision_ptr = (int *******)0x0;\n        format_ptr = format_start_ptr;\n      }\n      goto LAB_00082c16;\n    case 0x30:\n      flags = flags | 0x80;\n      ch = (uint)*(byte *)format_ptr;\n      goto LAB_00082c12;\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n      goto switchD_00082c20_caseD_31;\n    case 0x44:\n      flag_plus = true;\n      if (flag_minus == false) goto LAB_00083028;\nLAB_00082e98:\n      arg_current_ptr = (int **)((int)arg_current_ptr + 7U & 0xfffffff8);\n      value = *arg_current_ptr;\n      sign = arg_current_ptr[1];\n      arg_current_ptr = arg_current_ptr + 2;\n      goto LAB_00082eac;\n    case 0x4f:\n      flag_plus = true;\n      if (flag_minus != false) goto LAB_00082d42;\nLAB_00082f2a:\n      result = (uint)flag_plus << 4;\n      counter = (uint)flag_minus << 5;\n      if ((flag_plus == 0) && (counter = (uint)flag_long << 6, flag_long != 0)) {\n        value = (int *)(uint)*(ushort *)arg_current_ptr;\n        arg_current_ptr = arg_current_ptr + 1;\n        sign = (int *)0x0;\n      }\n      else {\n        result = counter;\n        value = *arg_current_ptr;\n        arg_current_ptr = arg_current_ptr + 1;\n        sign = (int *)0x0;\n      }\n      break;\n    case 0x55:\n      flag_plus = true;\n      if (flag_minus != false) goto LAB_00082e62;\nLAB_00082f7c:\n      if ((flag_plus) || (flag_long == false)) {\n        result = 1;\n        value = *arg_current_ptr;\n        arg_current_ptr = arg_current_ptr + 1;\n        sign = (int *)0x0;\n      }\n      else {\n        sign = (int *)0x0;\n        value = (int *)(uint)*(ushort *)arg_current_ptr;\n        arg_current_ptr = arg_current_ptr + 1;\n        result = 1;\n      }\n      break;\n    case 0x58:\n      digits = \"0123456789ABCDEF\";\n      if (flag_minus == false) goto LAB_00083196;\nLAB_00082fb6:\n      arg_ptr = (int **)((int)arg_current_ptr + 7U & 0xfffffff8);\n      arg_current_ptr = arg_ptr + 2;\n      value = *arg_ptr;\n      sign = arg_ptr[1];\n      goto LAB_00082fca;\n    case 99:\n      value = *arg_current_ptr;\n      arg_current_ptr = arg_current_ptr + 1;\n      minimum_width_ptr = (int *******)0x1;\n      buffer_temp = SUB41(value,0);\n      precision_ptr = (int *******)0x1;\n      formatted_string = (int ********)&buffer_temp;\n      goto LAB_00083012;\n    case 100:\n    case 0x69:\n      if (flag_minus != false) goto LAB_00082e98;\nLAB_00083028:\n      if ((flag_plus == false) && (flag_long != false)) {\n        value = (int *)(int)*(short *)arg_current_ptr;\n        arg_current_ptr = arg_current_ptr + 1;\n        sign = (int *)((int)value >> 0x1f);\n      }\n      else {\n        value = *arg_current_ptr;\n        arg_current_ptr = arg_current_ptr + 1;\n        sign = (int *)((int)value >> 0x1f);\n      }\nLAB_00082eac:\n      if ((int)sign < 0) {\n        flag_long = value != (int *)0x0;\n        value = (int *)-(int)value;\n        sign = (int *)(-(int)sign - (uint)flag_long);\n        prefix_char = '-';\n        specifier = '-';\n        result = 1;\n        goto LAB_00082d6a;\n      }\n      if (-1 < (int)precision_ptr) {\n        flags = flags & 0xffffff7f;\n      }\n      flag_hash = false;\n      ch = (uint)value | (uint)sign;\n      result = 1;\n      specifier = prefix_char;\n      goto joined_r0x00082d78;\n    case 0x68:\n      flag_long = true;\n      ch = (uint)*(byte *)format_ptr;\n      goto LAB_00082c12;\n    case 0x6c:\n      ch = (uint)*(byte *)format_ptr;\n      if (ch == 0x6c) {\n        flag_minus = true;\n        ch = (uint)*(byte *)((int)format_ptr + 1);\n        format_ptr = (int *******)((int)format_ptr + 1);\n      }\n      else {\n        flag_plus = true;\n      }\n      goto LAB_00082c12;\n    case 0x6e:\n      if (flag_minus == false) {\n        if (flag_plus == false) {\n          if (flag_long) {\n            value = *arg_current_ptr;\n            arg_current_ptr = arg_current_ptr + 1;\n            *(short *)value = (short)total_length;\n          }\n          else {\n            value = *arg_current_ptr;\n            arg_current_ptr = arg_current_ptr + 1;\n            *value = total_length;\n          }\n        }\n        else {\n          value = *arg_current_ptr;\n          arg_current_ptr = arg_current_ptr + 1;\n          *value = total_length;\n        }\n      }\n      else {\n        value = *arg_current_ptr;\n        arg_current_ptr = arg_current_ptr + 1;\n        *value = total_length;\n        value[1] = total_length >> 0x1f;\n      }\n      goto LAB_00082b9e;\n    case 0x6f:\n      if (flag_minus == false) goto LAB_00082f2a;\nLAB_00082d42:\n      arg_ptr = (int **)((int)arg_current_ptr + 7U & 0xfffffff8);\n      arg_current_ptr = arg_ptr + 2;\n      value = *arg_ptr;\n      sign = arg_ptr[1];\n      result = 0;\n      break;\n    case 0x70:\n      value = *arg_current_ptr;\n      arg_current_ptr = arg_current_ptr + 1;\n      conversion_size = 0x78;\n      flag_hash = true;\n      sign = (int *)0x0;\n      fill_char = 0x30;\n      digits = \"0123456789abcdef\";\n      result = 2;\n      break;\n    case 0x71:\n      flag_minus = true;\n      ch = (uint)*(byte *)format_ptr;\n      goto LAB_00082c12;\n    case 0x73:\n      formatted_string = (int ********)*arg_current_ptr;\n      prefix_char = '\\0';\n      arg_current_ptr = arg_current_ptr + 1;\n      if (formatted_string != (int ********)0x0) {\n        if ((int)precision_ptr < 0) {\n          precision_ptr = (int *******)strlen((char *)formatted_string);\n          format_start_ptr = (int *******)0x0;\n          specifier = prefix_char;\n        }\n        else {\n          ptr = memchr(formatted_string,0,(size_t)precision_ptr);\n          specifier = prefix_char;\n          if (ptr == (void *)0x0) {\n            format_start_ptr = (int *******)0x0;\n          }\n          else {\n            remaining_format_ptr = (int *******)((int)ptr - (int)formatted_string);\n            if ((int)precision_ptr <= (int)(int *******)((int)ptr - (int)formatted_string)) {\n              remaining_format_ptr = precision_ptr;\n            }\n            format_start_ptr = (int *******)0x0;\n            precision_ptr = remaining_format_ptr;\n          }\n        }\n        goto LAB_00082da0;\n      }\n      if ((int *******)0x5 < precision_ptr) {\n        precision_ptr = (int *******)0x6;\n      }\n      minimum_width_ptr = (int *******)((uint)precision_ptr & ~((int)precision_ptr >> 0x1f));\n      formatted_string = (int ********)&UNK_00085840;\nLAB_00083012:\n      prefix_char = '\\0';\n      format_start_ptr = (int *******)0x0;\n      goto LAB_00082dba;\n    case 0x75:\n      if (!flag_minus) goto LAB_00082f7c;\nLAB_00082e62:\n      arg_ptr = (int **)((int)arg_current_ptr + 7U & 0xfffffff8);\n      arg_current_ptr = arg_ptr + 2;\n      value = *arg_ptr;\n      sign = arg_ptr[1];\n      result = 1;\n      break;\n    case 0x78:\n      digits = \"0123456789abcdef\";\n      if (flag_minus != false) goto LAB_00082fb6;\nLAB_00083196:\n      if ((flag_plus == false) && (flag_long != false)) {\n        sign = (int *)0x0;\n        value = (int *)(uint)*(ushort *)arg_current_ptr;\n        arg_current_ptr = arg_current_ptr + 1;\n      }\n      else {\n        value = *arg_current_ptr;\n        arg_current_ptr = arg_current_ptr + 1;\n        sign = (int *)0x0;\n      }\nLAB_00082fca:\n      if ((flag_zero) && (((uint)value | (uint)sign) != 0)) {\n        flag_hash = true;\n        fill_char = 0x30;\n        result = 2;\n        conversion_size = (char)ch;\n      }\n      else {\n        result = 2;\n      }\n    }\n    prefix_char = '\\0';\n    specifier = '\\0';\nLAB_00082d6a:\n    if (-1 < (int)precision_ptr) {\n      flags = flags & 0xffffff7f;\n    }\n    ch = (uint)value | (uint)sign;\njoined_r0x00082d78:\n    combined_value = CONCAT44(sign,value);\n    format_start_ptr = precision_ptr;\n    if ((ch == 0) && (precision_ptr == (int *******)0x0)) {\n      formatted_string = (int ********)formatted_string_temp;\n      if ((result != 0) || (!flag_zero)) goto LAB_00082da0;\n      formatted_string = (int ********)(&zeroes_6718 + 1);\n      digit_temp = '0';\n      goto LAB_00082d9a;\n    }\n    if (result == 1) {\n      if (sign != (int *)0x0 || (int *)0x9 < value) {\n        pptr_array_temp = (int ********)(&zeroes_6718 + 1);\n        do {\n          formatted_string = pptr_array_temp;\n          temp3 = (undefined4)((ulonglong)combined_value >> 0x20);\n          character = '\\n';\n          __aeabi_uldivmod((int)combined_value,temp3,10,0);\n          *(char *)formatted_string = character + '0';\n          combined_value = __aeabi_uldivmod((int)combined_value,temp3,10,0);\n          pptr_array_temp = (int ********)((int)formatted_string + -1);\n        } while (combined_value != 0);\n        precision_ptr = (int *******)((int)formatted_string_temp - (int)formatted_string);\n        goto LAB_00082da0;\n      }\n      digit_temp = (char)value + '0';\n      formatted_string = (int ********)(&zeroes_6718 + 1);\n      goto LAB_0008351e;\n    }\n    pptr_array_temp = (int ********)(&zeroes_6718 + 1);\n    if (result != 2) goto LAB_0008337e;\n    do {\n      formatted_string = pptr_array_temp;\n      ch = (uint)value & 0xf;\n      value = (int *)((uint)value >> 4 | (int)sign << 0x1c);\n      sign = (int *)((uint)sign >> 4);\n      *(char *)formatted_string = digits[ch];\n      pptr_array_temp = (int ********)((int)formatted_string + -1);\n    } while (((uint)value | (uint)sign) != 0);\n    precision_ptr = (int *******)((int)formatted_string_temp - (int)formatted_string);\n    goto LAB_00082da0;\n  }\nLAB_000833d0:\n  if (args_ptr != (int *******)0x0) {\n    formatted_stringprint_r_part_0(buffer,format,&format_start_ptr_temp);\n  }\nLAB_000833de:\n  if ((int)((uint)*(ushort *)(format + 0xc) << 0x19) < 0) {\n    return -1;\n  }\n  return total_length;\nLAB_0008337e:\n  do {\n    formatted_string = pptr_array_temp;\n    value_ptr = (int *)((uint)value >> 3 | (int)sign << 0x1d);\n    sign = (int *)((uint)sign >> 3);\n    result = ((uint)value & 7) + 0x30;\n    *(char *)formatted_string = (char)result;\n    pptr_array_temp = (int ********)((int)formatted_string + -1);\n    value = value_ptr;\n  } while (((uint)value_ptr | (uint)sign) != 0);\n  if (flag_zero) {\n    if (result == 0x30) {\nLAB_00082d9a:\n      precision_ptr = (int *******)((int)formatted_string_temp - (int)formatted_string);\n    }\n    else {\n      *(undefined *)((int)formatted_string + -1) = 0x30;\n      formatted_string = pptr_array_temp;\n      precision_ptr = (int *******)((int)formatted_string_temp - (int)pptr_array_temp);\n    }\n  }\n  else {\nLAB_0008351e:\n    precision_ptr = (int *******)((int)formatted_string_temp - (int)formatted_string);\n  }\nLAB_00082da0:\n  minimum_width_ptr = precision_ptr;\n  if ((int)precision_ptr < (int)format_start_ptr) {\n    minimum_width_ptr = format_start_ptr;\n  }\n  if (specifier != '\\0') {\n    minimum_width_ptr = (int *******)((int)minimum_width_ptr + 1);\n  }\nLAB_00082dba:\n  if (flag_hash) {\n    minimum_width_ptr = (int *******)((int)minimum_width_ptr + 2);\n  }\n  if ((flags == 0) &&\n     (remaining_format_ptr = (int *******)((int)ppppppptemp - (int)minimum_width_ptr), 0 < (int)remaining_format_ptr)) {\n    if ((int)remaining_format_ptr < 0x11) {\n      arg_count = arg_count + 1;\n    }\n    else {\n      do {\n        tmp_ptr = remaining_format_ptr;\n        result = arg_count + 1;\n        args_ptr = args_ptr + 4;\n        *ptr_array = (int *******)0x85808;\n        ptr_array[1] = (int *******)0x10;\n        if (result < 8) {\n          counter = arg_count + 2;\n          ptr_array = ptr_array + 2;\n          arg_count = result;\n        }\n        else if (args_ptr == (int *******)0x0) {\n          counter = 1;\n          ptr_array = (int ********)formatted_string_temp;\n          arg_count = 0;\n        }\n        else {\n          arg_count = result;\n          result = formatted_stringprint_r_part_0(buffer,format,&format_start_ptr_temp);\n          if (result != 0) goto LAB_000833de;\n          counter = arg_count + 1;\n          ptr_array = (int ********)formatted_string_temp;\n        }\n        remaining_format_ptr = tmp_ptr + -4;\n      } while (0x10 < (int)remaining_format_ptr);\n      remaining_format_ptr = tmp_ptr + -4;\n      arg_count = counter;\n    }\n    args_ptr = (int *******)((int)args_ptr + (int)remaining_format_ptr);\n    *ptr_array = (int *******)0x85808;\n    ptr_array[1] = remaining_format_ptr;\n    if (arg_count < 8) {\n      result = arg_count + 1;\n      ptr_array = ptr_array + 2;\n    }\n    else if (args_ptr == (int *******)0x0) {\n      result = 1;\n      arg_count = 0;\n      ptr_array = (int ********)formatted_string_temp;\n    }\n    else {\n      result = formatted_stringprint_r_part_0(buffer,format,&format_start_ptr_temp);\n      if (result != 0) goto LAB_000833de;\n      result = arg_count + 1;\n      ptr_array = (int ********)formatted_string_temp;\n    }\n  }\n  else {\n    result = arg_count + 1;\n  }\n  counter = result;\n  if (prefix_char != '\\0') {\n    args_ptr = (int *******)((int)args_ptr + 1);\n    counter = 1;\n    *ptr_array = (int *******)&prefix_char;\n    ptr_array[1] = (int *******)0x1;\n    arg_count = result;\n    if (result < 8) {\n      counter = result + 1;\n      ptr_array = ptr_array + 2;\n    }\n    else if (args_ptr == (int *******)0x0) {\n      arg_count = 0;\n      ptr_array = (int ********)formatted_string_temp;\n    }\n    else {\n      result = formatted_stringprint_r_part_0(buffer,format,&format_start_ptr_temp);\n      if (result != 0) goto LAB_000833de;\n      counter = arg_count + 1;\n      ptr_array = (int ********)formatted_string_temp;\n    }\n  }\n  result = counter;\n  counter2 = arg_count;\n  if (flag_hash) {\n    args_ptr = (int *******)((int)args_ptr + 2);\n    *ptr_array = (int *******)&fill_char;\n    ptr_array[1] = (int *******)0x2;\n    if (counter < 8) {\n      result = counter + 1;\n      counter2 = counter;\n      ptr_array = ptr_array + 2;\n    }\n    else if (args_ptr == (int *******)0x0) {\n      result = 1;\n      counter2 = 0;\n      ptr_array = (int ********)formatted_string_temp;\n    }\n    else {\n      arg_count = counter;\n      result = formatted_stringprint_r_part_0(buffer,format,&format_start_ptr_temp);\n      if (result != 0) goto LAB_000833de;\n      result = arg_count + 1;\n      counter2 = arg_count;\n      ptr_array = (int ********)formatted_string_temp;\n    }\n  }\n  arg_count = counter2;\n  if ((flags == 0x80) &&\n     (remaining_format_ptr = (int *******)((int)ppppppptemp - (int)minimum_width_ptr), 0 < (int)remaining_format_ptr)) {\n    if (0x10 < (int)remaining_format_ptr) {\n      do {\n        while( true ) {\n          tmp_ptr = remaining_format_ptr;\n          arg_count = counter2 + 1;\n          args_ptr = args_ptr + 4;\n          *ptr_array = (int *******)&zeroes_6718;\n          ptr_array[1] = (int *******)0x10;\n          if (7 < arg_count) break;\n          result = counter2 + 2;\n          ptr_array = ptr_array + 2;\nLAB_0008348e:\n          counter2 = arg_count;\n          remaining_format_ptr = tmp_ptr + -4;\n          if ((int)(tmp_ptr + -4) < 0x11) goto LAB_000834b4;\n        }\n        if (args_ptr != (int *******)0x0) {\n          result = formatted_stringprint_r_part_0(buffer,format,&format_start_ptr_temp);\n          if (result == 0) {\n            result = arg_count + 1;\n            ptr_array = (int ********)formatted_string_temp;\n            goto LAB_0008348e;\n          }\n          goto LAB_000833de;\n        }\n        result = 1;\n        counter2 = 0;\n        remaining_format_ptr = tmp_ptr + -4;\n        ptr_array = (int ********)formatted_string_temp;\n      } while (0x10 < (int)(tmp_ptr + -4));\nLAB_000834b4:\n      remaining_format_ptr = tmp_ptr + -4;\n    }\n    args_ptr = (int *******)((int)args_ptr + (int)remaining_format_ptr);\n    *ptr_array = (int *******)&zeroes_6718;\n    ptr_array[1] = remaining_format_ptr;\n    arg_count = result;\n    if (result < 8) {\n      result = result + 1;\n      ptr_array = ptr_array + 2;\n    }\n    else if (args_ptr == (int *******)0x0) {\n      result = 1;\n      arg_count = 0;\n      ptr_array = (int ********)formatted_string_temp;\n    }\n    else {\n      result = formatted_stringprint_r_part_0(buffer,format,&format_start_ptr_temp);\n      if (result != 0) goto LAB_000833de;\n      result = arg_count + 1;\n      ptr_array = (int ********)formatted_string_temp;\n    }\n  }\n  format_start_ptr = (int *******)((int)format_start_ptr - (int)precision_ptr);\n  pptr_array_temp = (int ********)formatted_string_temp;\n  if ((int)format_start_ptr < 1) {\nLAB_000832c6:\n    args_ptr = (int *******)((int)args_ptr + (int)precision_ptr);\n    *ptr_array = (int *******)formatted_string;\n    ptr_array[1] = precision_ptr;\n    precision_ptr = args_ptr;\n    arg_count = result;\n    if (result < 8) goto LAB_0008345a;\n    if (args_ptr == (int *******)0x0) {\n      arg_count = 0;\n    }\n    else {\n      result = formatted_stringprint_r_part_0(buffer,format,&format_start_ptr_temp);\n      if (result != 0) goto LAB_000833de;\n    }\n  }\n  else {\n    counter = arg_count;\n    if (0x10 < (int)format_start_ptr) {\n      do {\n        while( true ) {\n          remaining_format_ptr = format_start_ptr;\n          arg_count = counter + 1;\n          args_ptr = args_ptr + 4;\n          *ptr_array = (int *******)&zeroes_6718;\n          ptr_array[1] = (int *******)0x10;\n          if (7 < arg_count) break;\n          result = counter + 2;\n          ptr_array = ptr_array + 2;\nLAB_00083282:\n          counter = arg_count;\n          format_start_ptr = remaining_format_ptr + -4;\n          if ((int)(remaining_format_ptr + -4) < 0x11) goto LAB_000832aa;\n        }\n        if (args_ptr != (int *******)0x0) {\n          result = formatted_stringprint_r_part_0(buffer,format,&format_start_ptr_temp);\n          if (result == 0) {\n            result = arg_count + 1;\n            ptr_array = (int ********)formatted_string_temp;\n            goto LAB_00083282;\n          }\n          goto LAB_000833de;\n        }\n        result = 1;\n        ptr_array = (int ********)formatted_string_temp;\n        counter = 0;\n        format_start_ptr = remaining_format_ptr + -4;\n      } while (0x10 < (int)(remaining_format_ptr + -4));\nLAB_000832aa:\n      format_start_ptr = remaining_format_ptr + -4;\n    }\n    args_ptr = (int *******)((int)args_ptr + (int)format_start_ptr);\n    *ptr_array = (int *******)&zeroes_6718;\n    ptr_array[1] = format_start_ptr;\n    if (result < 8) {\n      result = result + 1;\n      ptr_array = ptr_array + 2;\n      goto LAB_000832c6;\n    }\n    if (args_ptr != (int *******)0x0) {\n      arg_count = result;\n      result = formatted_stringprint_r_part_0(buffer,format,&format_start_ptr_temp);\n      if (result != 0) goto LAB_000833de;\n      result = arg_count + 1;\n      ptr_array = (int ********)formatted_string_temp;\n      goto LAB_000832c6;\n    }\n    ptr_array_temp2[0] = precision_ptr;\n    arg_count = 1;\n    ptr_array = (int ********)formatted_string_temp;\n    formatted_string_temp = (undefined  [4])formatted_string;\nLAB_0008345a:\n    pptr_array_temp = ptr_array + 2;\n    args_ptr = precision_ptr;\n  }\n  if (((flags & 4) != 0) &&\n     (format_start_ptr = (int *******)((int)ppppppptemp - (int)minimum_width_ptr), 0 < (int)format_start_ptr)) {\n    result = arg_count;\n    if ((int)format_start_ptr < 0x11) {\n      counter = arg_count + 1;\n    }\n    else {\n      do {\n        while( true ) {\n          arg_count = result + 1;\n          args_ptr = args_ptr + 4;\n          *pptr_array_temp = (int *******)0x85808;\n          pptr_array_temp[1] = (int *******)0x10;\n          if (7 < arg_count) break;\n          counter = result + 2;\n          pptr_array_temp = pptr_array_temp + 2;\nLAB_00083316:\n          format_start_ptr = format_start_ptr + -4;\n          result = arg_count;\n          if ((int)format_start_ptr < 0x11) goto LAB_0008333e;\n        }\n        if (args_ptr != (int *******)0x0) {\n          result = formatted_stringprint_r_part_0(buffer,format,&format_start_ptr_temp);\n          if (result == 0) {\n            counter = arg_count + 1;\n            pptr_array_temp = (int ********)formatted_string_temp;\n            goto LAB_00083316;\n          }\n          goto LAB_000833de;\n        }\n        format_start_ptr = format_start_ptr + -4;\n        counter = 1;\n        result = 0;\n        pptr_array_temp = (int ********)formatted_string_temp;\n      } while (0x10 < (int)format_start_ptr);\n    }\nLAB_0008333e:\n    args_ptr = (int *******)((int)args_ptr + (int)format_start_ptr);\n    *pptr_array_temp = (int *******)0x85808;\n    pptr_array_temp[1] = format_start_ptr;\n    arg_count = counter;\n    if (7 < counter) {\n      if (args_ptr == (int *******)0x0) {\n        if ((int)minimum_width_ptr < (int)ppppppptemp) {\n          minimum_width_ptr = ppppppptemp;\n        }\n        total_length = total_length + (int)minimum_width_ptr;\n        goto LAB_00083422;\n      }\n      result = formatted_stringprint_r_part_0(buffer,format,&format_start_ptr_temp);\n      if (result != 0) goto LAB_000833de;\n    }\n  }\n  if ((int)minimum_width_ptr < (int)ppppppptemp) {\n    minimum_width_ptr = ppppppptemp;\n  }\n  total_length = total_length + (int)minimum_width_ptr;\n  if ((args_ptr != (int *******)0x0) &&\n     (result = formatted_stringprint_r_part_0(buffer,format,&format_start_ptr_temp), result != 0)) goto LAB_000833de;\nLAB_00083422:\n  arg_count = 0;\n  ptr_array = (int ********)formatted_string_temp;\n  goto LAB_00082b9e;\nswitchD_00082c20_caseD_31:\n  digit = ch - 0x30;\n  ppppppptemp = (int *******)0x0;\n  format_start_ptr = format_ptr;\n  do {\n    format_ptr = (int *******)((int)format_start_ptr + 1);\n    ch = (uint)*(byte *)format_start_ptr;\n    ppppppptemp = (int *******)(digit + (int)ppppppptemp * 10);\n    digit = ch - 0x30;\n    format_start_ptr = format_ptr;\n  } while (digit < 10);\n  goto LAB_00082c16;\nswitchD_00082c20_caseD_20:\n  ch = (uint)*(byte *)format_ptr;\n  if (prefix_char == '\\0') {\n    prefix_char = ' ';\n  }\n  goto LAB_00082c12;\n}\n\n",
            "renaming": {
                "FUN_00082b38": "print_formatted_string_00082b38",
                "param_1": "buffer",
                "param_2": "format",
                "param_3": "format_ptr",
                "param_4": "arguments",
                "bVar1": "flag_minus",
                "bVar2": "flag_plus",
                "bVar3": "flag_zero",
                "cVar4": "specifier",
                "bVar5": "flag_hash",
                "pvVar6": "ptr",
                "ppppppppiVar7": "ptr_array",
                "piVar8": "value_ptr",
                "iVar9": "result",
                "cVar10": "character",
                "pppppppiVar11": "format_start_ptr",
                "uVar12": "digit",
                "ppiVar13": "arg_ptr",
                "uVar14": "flags",
                "uVar15": "ch",
                "iVar16": "counter",
                "pppppppiVar17": "ptr_array_temp",
                "iVar18": "counter2",
                "pppppppiVar19": "remaining_format_ptr",
                "piVar20": "value",
                "iVar21": "temp",
                "uVar22": "temp2",
                "piVar23": "sign",
                "pppppppiVar24": "tmp_ptr",
                "uVar25": "temp3",
                "__s": "formatted_string",
                "bVar26": "flag_long",
                "lVar27": "combined_value",
                "local_dc": "minimum_width_ptr",
                "local_d4": "precision_ptr",
                "local_c8": "arg_current_ptr",
                "local_c4": "total_length",
                "local_c0": "digits",
                "local_a1": "prefix_char",
                "local_a0": "fill_char",
                "local_9f": "conversion_size",
                "local_9c": "format_start_ptr_temp",
                "local_98": "arg_count",
                "local_94": "args_ptr",
                "local_90": "buffer_temp",
                "cStack_6a": "zeroes_6718",
                "local_69": "digit_temp",
                "local_68": "formatted_string_temp",
                "local_64": "ptr_array_temp2"
            },
            "calling": [
                "__sbprintf",
                "iprintf"
            ],
            "called": [
                "memchr",
                "__sbprintf",
                "__swsetup_r",
                "__sprint_r.part.0",
                "strlen",
                "__sinit",
                "__aeabi_uldivmod"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008378c": {
            "entrypoint": "0x0008378c",
            "current_name": "print_formatted_output_0008378c",
            "code": "\nint print_formatted_output_0008378c(undefined4 output_stream,int binary_data)\n\n{\n  int result;\n  int flush_result;\n  undefined *buffer_array [2];\n  undefined4 buffer_size;\n  ushort masked_short;\n  undefined2 short_value;\n  undefined *buffer_pointer;\n  undefined4 buffer_length;\n  undefined4 zero_value;\n  undefined4 field_46c;\n  undefined4 field_464;\n  undefined4 field_424;\n  undefined stack_buffer [1024];\n  \n  field_424 = *(undefined4 *)(binary_data + 100);\n  field_46c = *(undefined4 *)(binary_data + 0x1c);\n  short_value = *(undefined2 *)(binary_data + 0xe);\n  field_464 = *(undefined4 *)(binary_data + 0x24);\n  buffer_array[0] = stack_buffer;\n  masked_short = *(ushort *)(binary_data + 0xc) & 0xfffd;\n  buffer_size = 0x400;\n  buffer_length = 0x400;\n  zero_value = 0;\n  buffer_pointer = buffer_array[0];\n  result = _vfiprintf_r(output_stream,buffer_array);\n  if ((-1 < result) && (flush_result = _fflush_r(output_stream,buffer_array), flush_result != 0)) {\n    result = -1;\n  }\n  if ((int)((uint)masked_short << 0x19) < 0) {\n    *(ushort *)(binary_data + 0xc) = *(ushort *)(binary_data + 0xc) | 0x40;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0008378c": "print_formatted_output_0008378c",
                "param_1": "output_stream",
                "param_2": "binary_data",
                "iVar1": "result",
                "iVar2": "flush_result",
                "local_488": "buffer_array",
                "local_480": "buffer_size",
                "local_47c": "masked_short",
                "local_47a": "short_value",
                "local_478": "buffer_pointer",
                "local_474": "buffer_length",
                "local_470": "zero_value",
                "local_46c": "field_46c",
                "local_464": "field_464",
                "local_424": "field_424",
                "auStack_420": "stack_buffer"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "_vfiprintf_r",
                "_fflush_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083808": {
            "entrypoint": "0x00083808",
            "current_name": "process_data_00083808",
            "code": "\nundefined4 processData_00083808(undefined4 *output,int *input)\n\n{\n  int tempVar1;\n  int tempVar2;\n  uint shiftedValue;\n  ushort ushortValue;\n  \n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x38) == 0)) {\n    __sinit();\n  }\n  ushortValue = *(ushort *)(input + 3);\n  shiftedValue = (uint)ushortValue;\n  if ((int)(shiftedValue << 0x1c) < 0) {\n    tempVar2 = input[4];\n  }\n  else {\n    if (-1 < (int)(shiftedValue << 0x1b)) {\n      *output = 9;\n      *(ushort *)(input + 3) = ushortValue | 0x40;\n      return 0xffffffff;\n    }\n    if ((int)(shiftedValue << 0x1d) < 0) {\n      if ((int *)input[0xc] != (int *)0x0) {\n        if ((int *)input[0xc] != input + 0x10) {\n          _free_r(output);\n          ushortValue = *(ushort *)(input + 3);\n        }\n        input[0xc] = 0;\n      }\n      tempVar2 = input[4];\n      ushortValue = ushortValue & 0xffdb;\n      *input = tempVar2;\n      input[1] = 0;\n    }\n    else {\n      tempVar2 = input[4];\n    }\n    *(ushort *)(input + 3) = ushortValue | 8;\n    shiftedValue = (uint)(ushortValue | 8);\n  }\n  if ((tempVar2 == 0) && ((shiftedValue & 0x280) != 0x200)) {\n    __smakebuf_r(output,input);\n    shiftedValue = (uint)*(ushort *)(input + 3);\n    tempVar2 = input[4];\n  }\n  if ((shiftedValue & 1) == 0) {\n    tempVar1 = 0;\n    if (-1 < (int)(shiftedValue << 0x1e)) {\n      tempVar1 = input[5];\n    }\n    input[2] = tempVar1;\n  }\n  else {\n    input[6] = -input[5];\n    input[2] = 0;\n  }\n  if ((tempVar2 == 0) && ((int)((uint)*(ushort *)(input + 3) << 0x18) < 0)) {\n    *(ushort *)(input + 3) = *(ushort *)(input + 3) | 0x40;\n    return 0xffffffff;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083808": "process_data_00083808",
                "param_1": "output",
                "param_2": "input",
                "iVar1": "tempVar1",
                "iVar2": "tempVar2",
                "uVar3": "shiftedValue",
                "uVar4": "ushortValue"
            },
            "calling": [
                "__swbuf_r",
                "__sfvwrite_r",
                "_vfiprintf_r"
            ],
            "called": [
                "_free_r",
                "__sinit",
                "__smakebuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000838cc": {
            "entrypoint": "0x000838cc",
            "current_name": "update_data_000838cc",
            "code": "\nundefined4 updateData_000838cc(int dataFlag,undefined4 newValue,undefined4 newValue2,undefined4 newValue3)\n\n{\n  undefined4 *dataPointer;\n  uint index;\n  uint bitMask;\n  \n  if (DAT_20070180 == (undefined4 *)0x0) {\n    DAT_20070180 = (undefined4 *)&DAT_20070184;\n  }\n  index = DAT_20070180[1];\n  dataPointer = DAT_20070180;\n  if (0x1f < (int)index) {\n    dataPointer = (undefined4 *)malloc(400);\n    if (dataPointer == (undefined4 *)0x0) {\n      return 0xffffffff;\n    }\n    *dataPointer = DAT_20070180;\n    dataPointer[1] = 0;\n    index = 0;\n    DAT_20070180 = dataPointer;\n    dataPointer[0x62] = 0;\n    dataPointer[99] = 0;\n  }\n  if (dataFlag != 0) {\n    bitMask = 1 << (index & 0xff);\n    dataPointer[index + 0x22] = newValue2;\n    dataPointer[0x62] = dataPointer[0x62] | bitMask;\n    dataPointer[index + 0x42] = newValue3;\n    if (dataFlag == 2) {\n      dataPointer[99] = bitMask | dataPointer[99];\n    }\n  }\n  dataPointer[1] = index + 1;\n  dataPointer[index + 2] = newValue;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000838cc": "update_data_000838cc",
                "param_1": "dataFlag",
                "param_2": "newValue",
                "param_3": "newValue2",
                "param_4": "newValue3",
                "puVar1": "dataPointer",
                "uVar2": "index",
                "uVar3": "bitMask"
            },
            "calling": [
                "atexit",
                "__cxa_atexit"
            ],
            "called": [
                "malloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083974": {
            "entrypoint": "0x00083974",
            "current_name": "FUNC_00083974",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00083978) */\n\nvoid FUNC_00083974(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083974": "FUNC_00083974"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "atexit"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00083988": {
            "entrypoint": "0x00083988",
            "current_name": "register_exit_proc_00083988",
            "code": "\nint registerExitProc_00083988(function *function)\n\n{\n  int result;\n  \n  result = __register_exitproc(0,function,0,0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00083988": "register_exit_proc_00083988",
                "__func": "function",
                "iVar1": "result"
            },
            "calling": [
                "register_fini"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083994": {
            "entrypoint": "0x00083994",
            "current_name": "process_data_00083994",
            "code": "\nundefined4 processData_00083994(int *inputArray,int *outputArray)\n\n{\n  int *tempPointer;\n  int var1;\n  ushort var2;\n  uint var3;\n  int var4;\n  code *functionPointer;\n  int var5;\n  \n  var2 = *(ushort *)(outputArray + 3);\n  if ((int)((uint)var2 << 0x1c) < 0) {\n    var5 = outputArray[4];\n    if (var5 == 0) {\n      return 0;\n    }\n    var1 = *outputArray;\n    if ((var2 & 3) == 0) {\n      var4 = outputArray[5];\n    }\n    else {\n      var4 = 0;\n    }\n    *outputArray = var5;\n    var1 = var1 - var5;\n    outputArray[2] = var4;\n    do {\n      if (var1 < 1) {\n        return 0;\n      }\n      var4 = (*(code *)outputArray[9])(inputArray,outputArray[7],var5,var1);\n      var1 = var1 - var4;\n      var5 = var5 + var4;\n    } while (0 < var4);\nLAB_00083a54:\n    *(ushort *)(outputArray + 3) = *(ushort *)(outputArray + 3) | 0x40;\n    return 0xffffffff;\n  }\n  *(ushort *)(outputArray + 3) = var2 | 0x800;\n  if ((outputArray[1] < 1) && (outputArray[0xf] < 1)) {\n    return 0;\n  }\n  functionPointer = (code *)outputArray[10];\n  if (functionPointer == (code *)0x0) {\n    return 0;\n  }\n  var3 = (uint)(var2 | 0x800);\n  var5 = *inputArray;\n  *inputArray = 0;\n  if ((var2 & 0x1000) == 0) {\n    var1 = (*functionPointer)(inputArray,outputArray[7],var3 & 0x1000,1);\n    if ((var1 == -1) && (var4 = *inputArray, var4 != 0)) {\n      if ((var4 == 0x1d) || (var4 == 0x16)) {\n        *inputArray = var5;\n        return 0;\n      }\n      goto LAB_00083a54;\n    }\n    var3 = (uint)*(ushort *)(outputArray + 3);\n    functionPointer = (code *)outputArray[10];\n  }\n  else {\n    var1 = outputArray[0x14];\n  }\n  if (((int)(var3 << 0x1d) < 0) && (var1 = var1 - outputArray[1], outputArray[0xc] != 0)) {\n    var1 = var1 - outputArray[0xf];\n  }\n  var1 = (*functionPointer)(inputArray,outputArray[7],var1,0);\n  if (var1 == -1) {\n    var4 = *inputArray;\n    if (var4 != 0) {\n      if ((var4 != 0x1d) && (var4 != 0x16)) {\n        *(ushort *)(outputArray + 3) = *(ushort *)(outputArray + 3) | 0x40;\n        return 0xffffffff;\n      }\n      *(ushort *)(outputArray + 3) = *(ushort *)(outputArray + 3) & 0xf7ff;\n      *outputArray = outputArray[4];\n      outputArray[1] = 0;\n      goto LAB_00083a00;\n    }\n    var2 = *(ushort *)(outputArray + 3) & 0xf7ff;\n    outputArray[1] = 0;\n    *(ushort *)(outputArray + 3) = var2;\n    *outputArray = outputArray[4];\n  }\n  else {\n    var2 = *(ushort *)(outputArray + 3) & 0xf7ff;\n    *outputArray = outputArray[4];\n    *(ushort *)(outputArray + 3) = var2;\n    outputArray[1] = 0;\n  }\n  if ((int)((uint)var2 << 0x13) < 0) {\n    outputArray[0x14] = var1;\n  }\nLAB_00083a00:\n  tempPointer = (int *)outputArray[0xc];\n  *inputArray = var5;\n  if (tempPointer == (int *)0x0) {\n    return 0;\n  }\n  if (tempPointer != outputArray + 0x10) {\n    _free_r(inputArray);\n  }\n  outputArray[0xc] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083994": "process_data_00083994",
                "param_1": "inputArray",
                "param_2": "outputArray",
                "piVar1": "tempPointer",
                "iVar2": "var1",
                "uVar3": "var2",
                "uVar4": "var3",
                "iVar5": "var4",
                "pcVar6": "functionPointer",
                "iVar7": "var5"
            },
            "calling": [
                "_fflush_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083adc": {
            "entrypoint": "0x00083adc",
            "current_name": "initialize_stream_00083adc",
            "code": "\nvoid initializeStream_00083adc(int stream,int buffer)\n\n{\n  if ((stream != 0) && (*(int *)(stream + 0x38) == 0)) {\n    __sinit();\n  }\n  if (*(short *)(buffer + 0xc) == 0) {\n    return;\n  }\n  __sflush_r(stream);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083adc": "initialize_stream_00083adc",
                "param_1": "stream",
                "param_2": "buffer"
            },
            "calling": [
                "__swbuf_r",
                "__sbprintf",
                "__sfvwrite_r",
                "_fclose_r"
            ],
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083b08": {
            "entrypoint": "0x00083b08",
            "current_name": "walk_directory_00083b08",
            "code": "\nvoid walk_directory_00083b08(undefined4 directory_path)\n\n{\n  file_walker(directory_path,0x846a5);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083b08": "walk_directory_00083b08",
                "param_1": "directory_path",
                "_fwalk": "file_walker"
            },
            "calling": [],
            "called": [
                "_fwalk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083b14": {
            "entrypoint": "0x00083b14",
            "current_name": "initialize_data_structures_00083b14",
            "code": "\nvoid initializeDataStructures_00083b14(int dataStructurePointer)\n\n{\n  undefined4 *firstPointer;\n  undefined4 *secondPointer;\n  \n  if (*(int *)(dataStructurePointer + 0x38) == 0) {\n    firstPointer = *(undefined4 **)(dataStructurePointer + 4);\n    *(undefined4 *)(dataStructurePointer + 0x3c) = 0x83b09;\n    *(undefined4 *)(dataStructurePointer + 0x2e4) = 3;\n    *(int *)(dataStructurePointer + 0x2e8) = dataStructurePointer + 0x2ec;\n    *(undefined4 *)(dataStructurePointer + 0x2e0) = 0;\n    *(undefined2 *)(firstPointer + 3) = 4;\n    *firstPointer = 0;\n    firstPointer[1] = 0;\n    firstPointer[2] = 0;\n    firstPointer[0x19] = 0;\n    *(undefined2 *)((int)firstPointer + 0xe) = 0;\n    firstPointer[4] = 0;\n    firstPointer[5] = 0;\n    firstPointer[6] = 0;\n    memset(firstPointer + 0x17,0,8);\n    secondPointer = *(undefined4 **)(dataStructurePointer + 8);\n    firstPointer[7] = firstPointer;\n    firstPointer[8] = 0x84441;\n    firstPointer[9] = 0x84465;\n    firstPointer[10] = 0x8449d;\n    firstPointer[0xb] = 0x844bd;\n    *(undefined2 *)((int)secondPointer + 0xe) = 1;\n    *(undefined2 *)(secondPointer + 3) = 9;\n    *secondPointer = 0;\n    secondPointer[1] = 0;\n    secondPointer[2] = 0;\n    secondPointer[0x19] = 0;\n    secondPointer[4] = 0;\n    secondPointer[5] = 0;\n    secondPointer[6] = 0;\n    memset(secondPointer + 0x17,0,8);\n    firstPointer = *(undefined4 **)(dataStructurePointer + 0xc);\n    secondPointer[7] = secondPointer;\n    secondPointer[8] = 0x84441;\n    secondPointer[9] = 0x84465;\n    secondPointer[10] = 0x8449d;\n    secondPointer[0xb] = 0x844bd;\n    *(undefined2 *)(firstPointer + 3) = 0x12;\n    *(undefined2 *)((int)firstPointer + 0xe) = 2;\n    *firstPointer = 0;\n    firstPointer[1] = 0;\n    firstPointer[2] = 0;\n    firstPointer[0x19] = 0;\n    firstPointer[4] = 0;\n    firstPointer[5] = 0;\n    firstPointer[6] = 0;\n    memset(firstPointer + 0x17,0,8);\n    firstPointer[7] = firstPointer;\n    firstPointer[8] = 0x84441;\n    firstPointer[9] = 0x84465;\n    firstPointer[10] = 0x8449d;\n    firstPointer[0xb] = 0x844bd;\n    *(undefined4 *)(dataStructurePointer + 0x38) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083b14": "initialize_data_structures_00083b14",
                "param_1": "dataStructurePointer",
                "puVar1": "firstPointer",
                "puVar2": "secondPointer"
            },
            "calling": [
                "__swbuf_r",
                "__swsetup_r",
                "_vfiprintf_r",
                "_fflush_r",
                "_fclose_r"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083c08": {
            "entrypoint": "0x00083c08",
            "current_name": "FUNC_00083c08",
            "code": "\nvoid FUNC_00083c08(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083c08": "FUNC_00083c08"
            },
            "calling": [
                "_fclose_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00083c0c": {
            "entrypoint": "0x00083c0c",
            "current_name": "FUNC_00083c0c",
            "code": "\nvoid FUNC_00083c0c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083c0c": "FUNC_00083c0c"
            },
            "calling": [
                "_fclose_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00083c10": {
            "entrypoint": "0x00083c10",
            "current_name": "execute_cleanup_functions_00083c10",
            "code": "\nvoid executeCleanupFunctions_00083c10(void)\n\n{\n  int cleanupCounter;\n  code **cleanupFunctionPointer;\n  \n  cleanupCounter = 1;\n  cleanupFunctionPointer = (code **)&finiArrayEnd;\n  do {\n    cleanupCounter = cleanupCounter + -1;\n    cleanupFunctionPointer = cleanupFunctionPointer + -1;\n    (**cleanupFunctionPointer)();\n  } while (cleanupCounter != 0);\n  _fini();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083c10": "execute_cleanup_functions_00083c10",
                "iVar1": "cleanupCounter",
                "ppcVar2": "cleanupFunctionPointer",
                "__fini_array_end": "finiArrayEnd"
            },
            "calling": [],
            "called": [
                "_fini",
                "__do_global_dtors_aux"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083c40": {
            "entrypoint": "0x00083c40",
            "current_name": "convert_character_to_byte_00083c40",
            "code": "\nuint convertCharacterToByte_00083c40(undefined4 param,uint inputChar,byte **outputBuffer)\n\n{\n  int maxMbCharacters;\n  uint byteCount;\n  uint convertedByte;\n  byte *bufferPtr;\n  uint index;\n  byte temporaryByte;\n  byte additionalBuffer [3];\n  \n  if (-1 < (int)((uint)*(ushort *)(outputBuffer + 3) << 0x12)) {\n    *(ushort *)(outputBuffer + 3) = *(ushort *)(outputBuffer + 3) | 0x2000;\n    outputBuffer[0x19] = (byte *)((uint)outputBuffer[0x19] | 0x2000);\n  }\n  maxMbCharacters = __locale_mb_cur_max();\n  if ((maxMbCharacters == 1) && (inputChar - 1 < 0xff)) {\n    convertedByte = inputChar & 0xff;\n    temporaryByte = (byte)convertedByte;\n    byteCount = 1;\n  }\n  else {\n    byteCount = _wcrtomb_r(param,&temporaryByte,inputChar,outputBuffer + 0x17);\n    if (byteCount == 0xffffffff) {\n      *(ushort *)(outputBuffer + 3) = *(ushort *)(outputBuffer + 3) | 0x40;\n      return 0xffffffff;\n    }\n    if (byteCount == 0) {\n      return inputChar;\n    }\n    convertedByte = (uint)temporaryByte;\n  }\n  index = 0;\n  do {\n    bufferPtr = outputBuffer[2] + -1;\n    outputBuffer[2] = bufferPtr;\n    if ((int)bufferPtr < 0) {\n      if ((int)outputBuffer[6] <= (int)bufferPtr) {\n        **outputBuffer = (byte)convertedByte;\n        bufferPtr = *outputBuffer;\n        convertedByte = (uint)*bufferPtr;\n        if (convertedByte != 10) goto LAB_00083c90;\n      }\n      maxMbCharacters = __swbuf_r(param,convertedByte,outputBuffer);\n      if (maxMbCharacters == -1) {\n        return 0xffffffff;\n      }\n    }\n    else {\n      **outputBuffer = (byte)convertedByte;\n      bufferPtr = *outputBuffer;\nLAB_00083c90:\n      *outputBuffer = bufferPtr + 1;\n    }\n    if (byteCount <= index + 1) {\n      return inputChar;\n    }\n    convertedByte = (uint)additionalBuffer[index];\n    index = index + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00083c40": "convert_character_to_byte_00083c40",
                "param_1": "param",
                "param_2": "inputChar",
                "param_3": "outputBuffer",
                "iVar1": "maxMbCharacters",
                "uVar2": "byteCount",
                "uVar3": "convertedByte",
                "pbVar4": "bufferPtr",
                "uVar5": "index",
                "local_1c": "temporaryByte",
                "abStack_1b": "additionalBuffer"
            },
            "calling": [
                "__sprint_r.part.0"
            ],
            "called": [
                "__swbuf_r",
                "__locale_mb_cur_max",
                "_wcrtomb_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083d00": {
            "entrypoint": "0x00083d00",
            "current_name": "allocate_memory_00083d00",
            "code": "\nundefined4 allocate_memory_00083d00(undefined4 param_lock,int size)\n\n{\n  int result;\n  uint total_memory;\n  int adjusted_memory;\n  \n  __malloc_lock();\n  total_memory = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n  adjusted_memory = ((total_memory - size) + 0xfef & 0xfffff000) - 0x1000;\n  if (0xfff < adjusted_memory) {\n    result = _sbrk_r(param_lock,0);\n    if (result == DAT_2007046c + total_memory) {\n      result = _sbrk_r(param_lock,-adjusted_memory);\n      if (result != -1) {\n        __malloc_current_mallinfo = __malloc_current_mallinfo - adjusted_memory;\n        *(uint *)(DAT_2007046c + 4) = total_memory - adjusted_memory | 1;\n        __malloc_unlock(param_lock);\n        return 1;\n      }\n      adjusted_memory = _sbrk_r(param_lock,0);\n      if (0xf < adjusted_memory - DAT_2007046c) {\n        __malloc_current_mallinfo = adjusted_memory - __malloc_sbrk_base;\n        *(uint *)(DAT_2007046c + 4) = adjusted_memory - DAT_2007046c | 1;\n      }\n    }\n  }\n  __malloc_unlock(param_lock);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083d00": "allocate_memory_00083d00",
                "param_1": "param_lock",
                "param_2": "size",
                "iVar1": "result",
                "uVar2": "total_memory",
                "iVar3": "adjusted_memory"
            },
            "calling": [
                "_free_r"
            ],
            "called": [
                "_sbrk_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083d9c": {
            "entrypoint": "0x00083d9c",
            "current_name": "deallocate_memory_block_00083d9c",
            "code": "\nvoid deallocateMemoryBlock_00083d9c(undefined4 param_mem_mgmt,int block_address)\n\n{\n  undefined4 *prev_block;\n  bool is_prev_block_data_segment;\n  uint block_size;\n  int current_block_data_segment;\n  int current_block_next_pointer;\n  undefined1 *iter_block;\n  uint current_block_size;\n  undefined1 *next_block;\n  int iVar9;\n  uint uVar10;\n  \n  if (block_address == 0) {\n    return;\n  }\n  __malloc_lock();\n  block_size = *(uint *)(block_address + -4);\n  iVar9 = block_address + -8;\n  current_block_size = block_size & 0xfffffffe;\n  current_block_next_pointer = iVar9 + current_block_size;\n  uVar10 = *(uint *)(current_block_next_pointer + 4) & 0xfffffffc;\n  if (DAT_2007046c == current_block_next_pointer) {\n    uVar10 = uVar10 + current_block_size;\n    if (-1 < (int)(block_size << 0x1f)) {\n      iVar9 = iVar9 - *(int *)(block_address + -8);\n      current_block_data_segment = *(int *)(iVar9 + 0xc);\n      current_block_next_pointer = *(int *)(iVar9 + 8);\n      uVar10 = uVar10 + *(int *)(block_address + -8);\n      *(int *)(current_block_next_pointer + 0xc) = current_block_data_segment;\n      *(int *)(current_block_data_segment + 8) = current_block_next_pointer;\n    }\n    block_size = __malloc_trim_threshold;\n    *(uint *)(iVar9 + 4) = uVar10 | 1;\n    DAT_2007046c = iVar9;\n    if (block_size <= uVar10) {\n      _malloc_trim_r(param_mem_mgmt,__malloc_top_pad);\n    }\n  }\n  else {\n    *(uint *)(current_block_next_pointer + 4) = uVar10;\n    if ((block_size & 1) == 0) {\n      iVar9 = iVar9 - *(int *)(block_address + -8);\n      prev_block = *(undefined4 **)(iVar9 + 8);\n      current_block_size = current_block_size + *(int *)(block_address + -8);\n      if (prev_block == &DAT_2007046c) {\n        is_prev_block_data_segment = true;\n      }\n      else {\n        current_block_data_segment = *(int *)(iVar9 + 0xc);\n        prev_block[3] = current_block_data_segment;\n        *(undefined4 **)(current_block_data_segment + 8) = prev_block;\n        is_prev_block_data_segment = false;\n      }\n    }\n    else {\n      is_prev_block_data_segment = false;\n    }\n    if (-1 < *(int *)(current_block_next_pointer + uVar10 + 4) << 0x1f) {\n      current_block_size = current_block_size + uVar10;\n      prev_block = *(undefined4 **)(current_block_next_pointer + 8);\n      if ((!is_prev_block_data_segment) && (prev_block == &DAT_2007046c)) {\n        DAT_20070474 = iVar9;\n        DAT_20070478 = iVar9;\n        *(int **)(iVar9 + 0xc) = &DAT_2007046c;\n        *(int **)(iVar9 + 8) = &DAT_2007046c;\n        *(uint *)(iVar9 + 4) = current_block_size | 1;\n        *(uint *)(iVar9 + current_block_size) = current_block_size;\n        goto LAB_00083e30;\n      }\n      current_block_next_pointer = *(int *)(current_block_next_pointer + 0xc);\n      prev_block[3] = current_block_next_pointer;\n      *(undefined4 **)(current_block_next_pointer + 8) = prev_block;\n    }\n    *(uint *)(iVar9 + 4) = current_block_size | 1;\n    *(uint *)(iVar9 + current_block_size) = current_block_size;\n    if (!is_prev_block_data_segment) {\n      if (current_block_size < 0x200) {\n        block_size = current_block_size & 0xfffffff8;\n        current_block_next_pointer = *(int *)((int)&DAT_2007046c + block_size);\n        DAT_20070468 = DAT_20070468 | 1 << ((int)(current_block_size >> 3) >> 2 & 0xffU);\n        *(int *)(iVar9 + 8) = current_block_next_pointer;\n        *(undefined1 **)(iVar9 + 0xc) = &__malloc_av_ + block_size;\n        *(int *)((int)&DAT_2007046c + block_size) = iVar9;\n        *(int *)(current_block_next_pointer + 0xc) = iVar9;\n        __malloc_unlock(param_mem_mgmt);\n        return;\n      }\n      block_size = current_block_size >> 9;\n      if (block_size < 5) {\n        current_block_next_pointer = (current_block_size >> 6) + 0x38;\n        current_block_data_segment = current_block_next_pointer * 2;\n      }\n      else if (block_size < 0x15) {\n        current_block_next_pointer = block_size + 0x5b;\n        current_block_data_segment = current_block_next_pointer * 2;\n      }\n      else if (block_size < 0x55) {\n        current_block_next_pointer = (current_block_size >> 0xc) + 0x6e;\n        current_block_data_segment = current_block_next_pointer * 2;\n      }\n      else if (block_size < 0x155) {\n        current_block_next_pointer = (current_block_size >> 0xf) + 0x77;\n        current_block_data_segment = current_block_next_pointer * 2;\n      }\n      else if (block_size < 0x555) {\n        current_block_next_pointer = (current_block_size >> 0x12) + 0x7c;\n        current_block_data_segment = current_block_next_pointer * 2;\n      }\n      else {\n        current_block_data_segment = 0xfc;\n        current_block_next_pointer = 0x7e;\n      }\n      iter_block = (undefined1 *)(&DAT_2007046c)[current_block_data_segment];\n      if (iter_block == &__malloc_av_ + current_block_data_segment * 4) {\n        DAT_20070468 = DAT_20070468 | 1 << (current_block_next_pointer >> 2 & 0xffU);\n        next_block = iter_block;\n      }\n      else {\n        do {\n          if ((*(uint *)(iter_block + 4) & 0xfffffffc) <= current_block_size) break;\n          iter_block = *(undefined1 **)(iter_block + 8);\n        } while (&__malloc_av_ + current_block_data_segment * 4 != iter_block);\n        next_block = *(undefined1 **)(iter_block + 0xc);\n      }\n      *(undefined1 **)(iVar9 + 0xc) = next_block;\n      *(undefined1 **)(iVar9 + 8) = iter_block;\n      *(int *)(next_block + 8) = iVar9;\n      *(int *)(iter_block + 0xc) = iVar9;\n    }\n  }\nLAB_00083e30:\n  __malloc_unlock(param_mem_mgmt);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083d9c": "deallocate_memory_block_00083d9c",
                "param_1": "param_mem_mgmt",
                "param_2": "block_address",
                "puVar1": "prev_block",
                "bVar2": "is_prev_block_data_segment",
                "uVar3": "block_size",
                "iVar4": "current_block_data_segment",
                "iVar5": "current_block_next_pointer",
                "puVar6": "iter_block",
                "uVar7": "current_block_size",
                "puVar8": "next_block"
            },
            "calling": [
                "__swsetup_r",
                "__sfvwrite_r",
                "_malloc_r",
                "_realloc_r",
                "__sflush_r",
                "_fclose_r",
                "free"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock",
                "_malloc_trim_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083f34": {
            "entrypoint": "0x00083f34",
            "current_name": "process_data_00083f34",
            "code": "\nundefined4 processData_00083f34(undefined4 *error,void **data,undefined4 *length)\n\n{\n  void **ptr1;\n  int result;\n  void *dest;\n  void *src;\n  void *temp1;\n  void *temp2;\n  ushort flags;\n  uint flag;\n  int remaining;\n  void **iterator;\n  void *ptr2;\n  void *ptr3;\n  void *n;\n  size_t n_2;\n  void *local_var;\n  \n  if (length[2] != 0) {\n    flags = *(ushort *)(data + 3);\n    flag = (uint)flags;\n    if (((int)(flag << 0x1c) < 0) && (data[4] != (void *)0x0)) {\n      iterator = (void **)*length;\n    }\n    else {\n      result = __swsetup_r(error,data);\n      if (result != 0) {\n        return 0xffffffff;\n      }\n      flags = *(ushort *)(data + 3);\n      flag = (uint)flags;\n      iterator = (void **)*length;\n    }\n    if ((flags & 2) == 0) {\n      temp1 = (void *)(flag & 2);\n      ptr3 = temp1;\n      ptr2 = temp1;\n      local_var = temp1;\n      if ((flag & 1) == 0) {\n        temp1 = (void *)0x0;\n        ptr3 = (void *)0x0;\n        while( true ) {\n          while (temp1 == (void *)0x0) {\n            ptr3 = *iterator;\n            ptr1 = iterator + 1;\n            iterator = iterator + 2;\n            temp1 = *ptr1;\n          }\n          ptr2 = data[2];\n          if ((int)(flag << 0x16) < 0) {\n            if (temp1 < ptr2) {\n              dest = *data;\n              ptr2 = temp1;\n            }\n            else if ((flag & 0x480) == 0) {\n              dest = *data;\n            }\n            else {\n              n_2 = (int)*data - (int)data[4];\n              ptr2 = (void *)(n_2 + 1 + (int)temp1);\n              dest = (void *)(((int)data[5] * 3) / 2);\n              if (ptr2 <= dest) {\n                ptr2 = dest;\n              }\n              if ((int)(flag << 0x15) < 0) {\n                src = (void *)_malloc_r(error,ptr2);\n                if (src == (void *)0x0) {\n                  *error = 0xc;\n                  flags = *(ushort *)(data + 3);\n                  goto LAB_00084030;\n                }\n                memcpy(src,data[4],n_2);\n                *(ushort *)(data + 3) = *(ushort *)(data + 3) & 0xfb7f | 0x80;\n              }\n              else {\n                src = (void *)_realloc_r(error);\n                if (src == (void *)0x0) {\n                  _free_r(error,data[4]);\n                  flags = *(ushort *)(data + 3) & 0xff7f;\n                  *error = 0xc;\n                  goto LAB_00084030;\n                }\n              }\n              dest = (void *)((int)src + n_2);\n              data[4] = src;\n              data[5] = ptr2;\n              *data = dest;\n              data[2] = (void *)((int)ptr2 - n_2);\n              ptr2 = temp1;\n            }\n            memmove(dest,ptr3,(size_t)ptr2);\n            data[2] = (void *)((int)data[2] - (int)ptr2);\n            *data = (void *)((int)*data + (int)ptr2);\n            ptr2 = temp1;\n          }\n          else if ((data[4] < *data) || (dest = data[5], temp1 < dest)) {\n            if (temp1 < ptr2) {\n              ptr2 = temp1;\n            }\n            memmove(*data,ptr3,(size_t)ptr2);\n            dest = data[2];\n            data[2] = (void *)((int)dest - (int)ptr2);\n            *data = (void *)((int)*data + (int)ptr2);\n            if (((void *)((int)dest - (int)ptr2) == (void *)0x0) &&\n               (result = _fflush_r(error,data), result != 0)) goto LAB_0008402e;\n          }\n          else {\n            ptr2 = (void *)0x7fffffff;\n            if (temp1 < (void *)0x7fffffff) {\n              ptr2 = temp1;\n            }\n            ptr2 = (void *)(*(code *)data[9])\n                                        (error,data[7],ptr3,\n                                         ((uint)ptr2 / (uint)dest) * (int)dest);\n            if ((int)ptr2 < 1) goto LAB_0008402e;\n          }\n          result = length[2];\n          ptr3 = (void *)((int)ptr3 + (int)ptr2);\n          temp1 = (void *)((int)temp1 - (int)ptr2);\n          length[2] = result - (int)ptr2;\n          if (result - (int)ptr2 == 0) break;\n          flag = (uint)*(ushort *)(data + 3);\n        }\n      }\n      else {\n        do {\n          while (temp1 == (void *)0x0) {\n            ptr2 = *iterator;\n            temp1 = iterator[1];\n            local_var = (void *)0x0;\n            iterator = iterator + 2;\n          }\n          if (local_var == (void *)0x0) {\n            ptr3 = memchr(ptr2,10,(size_t)temp1);\n            if (ptr3 == (void *)0x0) {\n              ptr3 = (void *)((int)temp1 + 1);\n              local_var = (void *)0x1;\n            }\n            else {\n              ptr3 = (void *)((int)ptr3 + (1 - (int)ptr2));\n              local_var = (void *)0x1;\n            }\n          }\n          src = *data;\n          dest = ptr3;\n          if (temp1 <= ptr3) {\n            dest = temp1;\n          }\n          temp2 = data[5];\n          if ((data[4] < src) &&\n             (n = (void *)((int)data[2] + (int)temp2), (int)n < (int)dest)) {\n            memmove(src,ptr2,(size_t)n);\n            *data = (void *)((int)*data + (int)n);\n            result = _fflush_r(error,data);\n            if (result != 0) goto LAB_0008402e;\n          }\n          else if ((int)dest < (int)temp2) {\n            memmove(src,ptr2,(size_t)dest);\n            data[2] = (void *)((int)data[2] - (int)dest);\n            *data = (void *)((int)dest + (int)*data);\n            n = dest;\n          }\n          else {\n            n = (void *)(*(code *)data[9])(error,data[7],ptr2,temp2);\n            if ((int)n < 1) goto LAB_0008402e;\n          }\n          ptr3 = (void *)((int)ptr3 - (int)n);\n          if (ptr3 == (void *)0x0) {\n            result = _fflush_r(error,data);\n            if (result != 0) goto LAB_0008402e;\n            local_var = (void *)0x0;\n          }\n          result = length[2];\n          ptr2 = (void *)((int)ptr2 + (int)n);\n          temp1 = (void *)((int)temp1 - (int)n);\n          length[2] = result - (int)n;\n        } while (result - (int)n != 0);\n      }\n    }\n    else {\n      ptr3 = (void *)0x0;\n      temp1 = (void *)0x0;\n      do {\n        while( true ) {\n          ptr2 = temp1;\n          if ((void *)0x7ffffbff < temp1) {\n            ptr2 = (void *)0x7ffffc00;\n          }\n          if (temp1 != (void *)0x0) break;\n          ptr3 = *iterator;\n          temp1 = iterator[1];\n          iterator = iterator + 2;\n        }\n        result = (*(code *)data[9])(error,data[7],ptr3,ptr2);\n        if (result < 1) {\nLAB_0008402e:\n          flags = *(ushort *)(data + 3);\nLAB_00084030:\n          *(ushort *)(data + 3) = flags | 0x40;\n          return 0xffffffff;\n        }\n        remaining = length[2];\n        ptr3 = (void *)((int)ptr3 + result);\n        temp1 = (void *)((int)temp1 - result);\n        length[2] = remaining - result;\n      } while (remaining - result != 0);\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083f34": "process_data_00083f34",
                "param_1": "error",
                "param_2": "data",
                "param_3": "length",
                "ppvVar1": "ptr1",
                "iVar2": "result",
                "pvVar3": "dest",
                "pvVar4": "src",
                "pvVar5": "temp1",
                "pvVar6": "temp2",
                "uVar7": "flags",
                "uVar8": "flag",
                "iVar9": "remaining",
                "ppvVar10": "iterator",
                "pvVar11": "ptr2",
                "pvVar12": "ptr3",
                "__n": "n",
                "__n_00": "n_2",
                "local_2c": "local_var"
            },
            "calling": [
                "__sprint_r.part.0"
            ],
            "called": [
                "memchr",
                "__swsetup_r",
                "_malloc_r",
                "_realloc_r",
                "_free_r",
                "memcpy",
                "_fflush_r",
                "memmove"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084248": {
            "entrypoint": "0x00084248",
            "current_name": "process_data_00084248",
            "code": "\nuint processData_00084248(int baseAddress,code *callback)\n\n{\n  uint result;\n  int dataPtr1;\n  int dataPtr2;\n  uint combinedResult;\n  int *ptrList;\n  \n  ptrList = (int *)(baseAddress + 0x2e0);\n  if (ptrList != (int *)0x0) {\n    combinedResult = 0;\n    do {\n      dataPtr1 = ptrList[2];\n      dataPtr2 = ptrList[1] + -1;\n      if (-1 < dataPtr2) {\n        do {\n          dataPtr2 = dataPtr2 + -1;\n          if ((1 < *(ushort *)(dataPtr1 + 0xc)) && (*(short *)(dataPtr1 + 0xe) != -1)) {\n            result = (*callback)(dataPtr1);\n            combinedResult = combinedResult | result;\n          }\n          dataPtr1 = dataPtr1 + 0x68;\n        } while (dataPtr2 != -1);\n      }\n      ptrList = (int *)*ptrList;\n    } while (ptrList != (int *)0x0);\n    return combinedResult;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00084248": "process_data_00084248",
                "param_1": "baseAddress",
                "param_2": "callback",
                "uVar1": "result",
                "iVar2": "dataPtr1",
                "iVar3": "dataPtr2",
                "uVar4": "combinedResult",
                "piVar5": "ptrList"
            },
            "calling": [
                "_cleanup_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084290": {
            "entrypoint": "0x00084290",
            "current_name": "get_charset_00084290",
            "code": "\nchar * getCharset_00084290(void)\n\n{\n  return charset;\n}\n\n",
            "renaming": {
                "FUN_00084290": "get_charset_00084290",
                "lc_ctype_charset": "charset"
            },
            "calling": [
                "_wcrtomb_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084298": {
            "entrypoint": "0x00084298",
            "current_name": "get_max_multibyte_size_00084298",
            "code": "\nundefined4 getMaxMultibyteSize_00084298(void)\n\n{\n  return maxMultibyteSize;\n}\n\n",
            "renaming": {
                "FUN_00084298": "get_max_multibyte_size_00084298",
                "__mb_cur_max": "maxMultibyteSize"
            },
            "calling": [
                "_fputwc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000842a4": {
            "entrypoint": "0x000842a4",
            "current_name": "process_file_parameters_000842a4",
            "code": "\nvoid processFileParameters_000842a4(int fileDescriptor,int *fileInfo)\n\n{\n  ushort fileMode;\n  int fileStats;\n  int memoryAllocation;\n  uint tempVariable;\n  bool isTTY;\n  undefined stackMemory [4];\n  uint filePermissions;\n  \n  fileMode = *(ushort *)(fileInfo + 3);\n  tempVariable = (uint)fileMode;\n  if ((int)(tempVariable << 0x1e) < 0) {\n    *fileInfo = (int)fileInfo + 0x43;\n    fileInfo[4] = (int)fileInfo + 0x43;\n    fileInfo[5] = 1;\n    return;\n  }\n  if (-1 < *(short *)((int)fileInfo + 0xe)) {\n    fileStats = _fstat_r(fileDescriptor,(int)*(short *)((int)fileInfo + 0xe),stackMemory);\n    if (-1 < fileStats) {\n      isTTY = (filePermissions & 0xf000) == 0x2000;\n      if (((filePermissions & 0xf000) == 0x8000) && (fileInfo[10] == 0x8449d)) {\n        fileStats = 0x400;\n        *(ushort *)(fileInfo + 3) = *(ushort *)(fileInfo + 3) | 0x400;\n        fileInfo[0x13] = 0x400;\n      }\n      else {\n        fileStats = 0x400;\n        *(ushort *)(fileInfo + 3) = *(ushort *)(fileInfo + 3) | 0x800;\n      }\n      goto LAB_00084300;\n    }\n    fileMode = *(ushort *)(fileInfo + 3);\n    tempVariable = (uint)fileMode;\n  }\n  *(ushort *)(fileInfo + 3) = fileMode | 0x800;\n  if ((tempVariable & 0x80) == 0) {\n    fileStats = 0x400;\n  }\n  else {\n    fileStats = 0x40;\n  }\n  isTTY = false;\nLAB_00084300:\n  memoryAllocation = _malloc_r(fileDescriptor,fileStats);\n  fileMode = *(ushort *)(fileInfo + 3);\n  if (memoryAllocation == 0) {\n    if (-1 < (int)((uint)fileMode << 0x16)) {\n      *(ushort *)(fileInfo + 3) = fileMode | 2;\n      *fileInfo = (int)fileInfo + 0x43;\n      fileInfo[4] = (int)fileInfo + 0x43;\n      fileInfo[5] = 1;\n    }\n  }\n  else {\n    *(undefined4 *)(fileDescriptor + 0x3c) = 0x83b09;\n    *(ushort *)(fileInfo + 3) = fileMode | 0x80;\n    *fileInfo = memoryAllocation;\n    fileInfo[4] = memoryAllocation;\n    fileInfo[5] = fileStats;\n    if ((isTTY) && (fileStats = _isatty_r(fileDescriptor,(int)*(short *)((int)fileInfo + 0xe)), fileStats != 0)) {\n      *(ushort *)(fileInfo + 3) = *(ushort *)(fileInfo + 3) | 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000842a4": "process_file_parameters_000842a4",
                "param_1": "fileDescriptor",
                "param_2": "fileInfo",
                "uVar1": "fileMode",
                "iVar2": "fileStats",
                "iVar3": "memoryAllocation",
                "uVar4": "tempVariable",
                "bVar5": "isTTY",
                "auStack_54": "stackMemory",
                "local_50": "filePermissions"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "_isatty_r",
                "_malloc_r",
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084384": {
            "entrypoint": "0x00084384",
            "current_name": "find_first_byte_00084384",
            "code": "\nvoid * find_first_byte_00084384(void *data,int byte,size_t length)\n\n{\n  uint byteValue;\n  uint xoredValue;\n  int index;\n  uint *ptr;\n  uint combinedValue;\n  bool isLastByte;\n  \n  byteValue = byte & 0xff;\n  if (((uint)data & 3) == 0) {\nLAB_000843b4:\n    if (3 < length) {\n      combinedValue = byteValue | byteValue << 8;\n      ptr = (uint *)data;\n      do {\n        xoredValue = *ptr ^ (combinedValue | combinedValue << 0x10);\n        data = ptr;\n        if ((xoredValue + 0xfefefeff & ~xoredValue & 0x80808080) != 0) break;\n        length = length - 4;\n        data = ptr + 1;\n        ptr = ptr + 1;\n      } while (3 < length);\n    }\n    if (length == 0) {\n      data = (uint *)0x0;\n    }\n    else {\n                    /* WARNING: Load size is inaccurate */\n      if (*data != byteValue) {\n        index = 0;\n        do {\n          data = (void *)((int)data + 1);\n          isLastByte = index == length - 1;\n          index = index + 1;\n          if (isLastByte) goto LAB_000843dc;\n                    /* WARNING: Load size is inaccurate */\n        } while (*data != byteValue);\n      }\n    }\n  }\n  else if (length == 0) {\nLAB_000843dc:\n    data = (uint *)0x0;\n  }\n  else {\n                    /* WARNING: Load size is inaccurate */\n    if (*data != byteValue) {\n      ptr = (uint *)((int)data + 1);\n      length = length - 1;\n      do {\n        data = ptr;\n        if (((uint)data & 3) == 0) goto LAB_000843b4;\n        if (length == 0) goto LAB_000843dc;\n                    /* WARNING: Load size is inaccurate */\n        ptr = (uint *)((int)data + 1);\n        length = length - 1;\n      } while (*data != byteValue);\n    }\n  }\n  return data;\n}\n\n",
            "renaming": {
                "FUN_00084384": "find_first_byte_00084384",
                "__s": "data",
                "__c": "byte",
                "__n": "length",
                "uVar1": "byteValue",
                "uVar2": "xoredValue",
                "iVar3": "index",
                "puVar4": "ptr",
                "uVar5": "combinedValue",
                "bVar6": "isLastByte"
            },
            "calling": [
                "__sfvwrite_r",
                "_vfiprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084418": {
            "entrypoint": "0x00084418",
            "current_name": "kill_process_with_signal_00084418",
            "code": "\nvoid killProcessWithSignal_00084418(int *errorCode,int processID,int signal)\n\n{\n  errorNumber = 0;\n  _kill(processID,signal);\n  if ((processID == -1) && (errorNumber != 0)) {\n    *errorCode = errorNumber;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084418": "kill_process_with_signal_00084418",
                "param_1": "errorCode",
                "param_2": "processID",
                "param_3": "signal",
                "errno": "errorNumber"
            },
            "calling": [
                "kill"
            ],
            "called": [
                "_kill"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084440": {
            "entrypoint": "0x00084440",
            "current_name": "update_data_00084440",
            "code": "\nvoid updateData_00084440(undefined4 buffer,int dataOffset)\n\n{\n  int readResult;\n  \n  readResult = _read_r(buffer,(int)*(short *)(dataOffset + 0xe));\n  if (-1 < readResult) {\n    *(int *)(dataOffset + 0x50) = *(int *)(dataOffset + 0x50) + readResult;\n    return;\n  }\n  *(ushort *)(dataOffset + 0xc) = *(ushort *)(dataOffset + 0xc) & 0xefff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084440": "update_data_00084440",
                "param_1": "buffer",
                "param_2": "dataOffset",
                "iVar1": "readResult"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084464": {
            "entrypoint": "0x00084464",
            "current_name": "update_file_00084464",
            "code": "\nvoid updateFile_00084464(undefined4 fileDescriptor,int bufferAddress,undefined4 data,undefined4 count)\n\n{\n  ushort value;\n  \n  value = *(ushort *)(bufferAddress + 0xc);\n  if ((int)((uint)value << 0x17) < 0) {\n    seekFile(fileDescriptor,(int)*(short *)(bufferAddress + 0xe),0,2);\n    value = *(ushort *)(bufferAddress + 0xc);\n  }\n  *(ushort *)(bufferAddress + 0xc) = value & 0xefff;\n  writeToFile(fileDescriptor,(int)*(short *)(bufferAddress + 0xe),data,count);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084464": "update_file_00084464",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddress",
                "param_3": "data",
                "param_4": "count",
                "uVar1": "value",
                "_lseek_r": "seekFile",
                "_write_r": "writeToFile"
            },
            "calling": [],
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008449c": {
            "entrypoint": "0x0008449c",
            "current_name": "update_file_offset_0008449c",
            "code": "\nvoid updateFileOffset_0008449c(undefined4 fileDescriptor,int bufferAddress)\n\n{\n  int seekResult;\n  ushort newOffsetValue;\n  \n  seekResult = _lseek_r(fileDescriptor,(int)*(short *)(bufferAddress + 0xe));\n  if (seekResult == -1) {\n    newOffsetValue = *(ushort *)(bufferAddress + 0xc) & 0xefff;\n  }\n  else {\n    newOffsetValue = *(ushort *)(bufferAddress + 0xc) | 0x1000;\n  }\n  if (seekResult != -1) {\n    *(int *)(bufferAddress + 0x50) = seekResult;\n  }\n  *(ushort *)(bufferAddress + 0xc) = newOffsetValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008449c": "update_file_offset_0008449c",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddress",
                "iVar1": "seekResult",
                "uVar2": "newOffsetValue"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844bc": {
            "entrypoint": "0x000844bc",
            "current_name": "close_file_000844bc",
            "code": "\nvoid closeFile_000844bc(undefined4 fileDescriptor,int bufferAddress)\n\n{\n  _close_r(fileDescriptor,(int)*(short *)(bufferAddress + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_000844bc": "close_file_000844bc",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddress"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844c4": {
            "entrypoint": "0x000844c4",
            "current_name": "process_input_000844c4",
            "code": "\nuint processInput_000844c4(int input,uint flag,undefined4 *buffer,undefined4 size)\n\n{\n  ushort value1;\n  uint value2;\n  undefined *pointer1;\n  int count;\n  \n  if ((input != 0) && (*(int *)(input + 0x38) == 0)) {\n    __sinit();\n  }\n  value1 = *(ushort *)(buffer + 3);\n  value2 = (uint)value1;\n  buffer[2] = buffer[6];\n  if ((-1 < (int)(value2 << 0x1c)) || (count = buffer[4], count == 0)) {\n    count = __swsetup_r(input,buffer,value1,value2,size);\n    if (count != 0) {\n      return 0xffffffff;\n    }\n    value1 = *(ushort *)(buffer + 3);\n    count = buffer[4];\n    value2 = (uint)value1;\n  }\n  flag = flag & 0xff;\n  if ((int)(value2 << 0x12) < 0) {\n    pointer1 = (undefined *)*buffer;\n    count = (int)pointer1 - count;\n    if (count < (int)buffer[5]) {\nLAB_000844f6:\n      count = count + 1;\n      goto LAB_000844f8;\n    }\n  }\n  else {\n    buffer[0x19] = buffer[0x19] & 0xffffdfff;\n    pointer1 = (undefined *)*buffer;\n    *(ushort *)(buffer + 3) = value1 | 0x2000;\n    count = (int)pointer1 - count;\n    if (count < (int)buffer[5]) goto LAB_000844f6;\n  }\n  count = _fflush_r(input,buffer);\n  if (count != 0) {\n    return 0xffffffff;\n  }\n  pointer1 = (undefined *)*buffer;\n  count = 1;\nLAB_000844f8:\n  buffer[2] = buffer[2] + -1;\n  *buffer = pointer1 + 1;\n  *pointer1 = (char)flag;\n  if (((buffer[5] == count) ||\n      (((int)((uint)*(ushort *)(buffer + 3) << 0x1f) < 0 && (flag == 10)))) &&\n     (count = _fflush_r(input,buffer), count != 0)) {\n    return 0xffffffff;\n  }\n  return flag;\n}\n\n",
            "renaming": {
                "FUN_000844c4": "process_input_000844c4",
                "param_1": "input",
                "param_2": "flag",
                "param_3": "buffer",
                "param_4": "size",
                "uVar1": "value1",
                "uVar2": "value2",
                "puVar3": "pointer1",
                "iVar4": "count"
            },
            "calling": [
                "_fputwc_r"
            ],
            "called": [
                "__swsetup_r",
                "_fflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008456c": {
            "entrypoint": "0x0008456c",
            "current_name": "convert_string_to_code_points_0008456c",
            "code": "\nvoid convertStringToCodePoints_0008456c(undefined4 *outString,int inputLength,undefined4 extraParam,undefined4 *outParam)\n\n{\n  code *wideCharToMultibyte;\n  undefined4 charset;\n  int result;\n  undefined tempBuffer [12];\n  \n  wideCharToMultibyte = __wctomb;\n  if (inputLength == 0) {\n    charset = __locale_charset();\n    result = (*wideCharToMultibyte)(outString,tempBuffer,0,charset,outParam);\n  }\n  else {\n    charset = __locale_charset();\n    result = (*wideCharToMultibyte)(outString,inputLength,extraParam,charset,outParam);\n  }\n  if (result == -1) {\n    *outParam = 0;\n    *outString = 0x8a;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008456c": "convert_string_to_code_points_0008456c",
                "param_1": "outString",
                "param_2": "inputLength",
                "param_3": "extraParam",
                "param_4": "outParam",
                "pcVar1": "wideCharToMultibyte",
                "uVar2": "charset",
                "iVar3": "result",
                "auStack_24": "tempBuffer"
            },
            "calling": [
                "_fputwc_r"
            ],
            "called": [
                "__locale_charset",
                "__ascii_wctomb"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000845bc": {
            "entrypoint": "0x000845bc",
            "current_name": "write_byte_to_memory_000845bc",
            "code": "\nundefined4 write_byte_to_memory_000845bc(undefined4 *destination,undefined *buffer,uint value)\n\n{\n  if (buffer == (undefined *)0x0) {\n    return 0;\n  }\n  if (value < 0x100) {\n    *buffer = (char)value;\n    return 1;\n  }\n  *destination = 0x8a;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_000845bc": "write_byte_to_memory_000845bc",
                "param_1": "destination",
                "param_2": "buffer",
                "param_3": "value"
            },
            "calling": [
                "_wcrtomb_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000845d8": {
            "entrypoint": "0x000845d8",
            "current_name": "write_data_000845d8",
            "code": "\nvoid writeData_000845d8(int *errorFlag,int fileDescriptor,char *data,int dataSize)\n\n{\n  int writeResult;\n  \n  errno = 0;\n  writeResult = _write(fileDescriptor,data,dataSize);\n  if ((writeResult == -1) && (errno != 0)) {\n    *errorFlag = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000845d8": "write_data_000845d8",
                "param_1": "errorFlag",
                "param_2": "fileDescriptor",
                "param_3": "data",
                "param_4": "dataSize",
                "iVar1": "writeResult"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084600": {
            "entrypoint": "0x00084600",
            "current_name": "close_file_and_handle_errors_00084600",
            "code": "\nvoid closeFileAndHandleErrors_00084600(int *errorFlag,int fileDescriptor)\n\n{\n  int closeResult;\n  \n  errno = 0;\n  closeResult = _close(fileDescriptor);\n  if ((closeResult == -1) && (errno != 0)) {\n    *errorFlag = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084600": "close_file_and_handle_errors_00084600",
                "param_1": "errorFlag",
                "param_2": "fileDescriptor",
                "iVar1": "closeResult"
            },
            "calling": [
                "__sclose"
            ],
            "called": [
                "_close"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084624": {
            "entrypoint": "0x00084624",
            "current_name": "flush_and_free_resources_00084624",
            "code": "\nundefined4 flushAndFreeResources_00084624(int fileDescriptor,int stream)\n\n{\n  undefined4 result;\n  int returnValue;\n  \n  if (stream != 0) {\n    if ((fileDescriptor != 0) && (*(int *)(fileDescriptor + 0x38) == 0)) {\n      __sinit();\n    }\n    if (*(short *)(stream + 0xc) != 0) {\n      result = _fflush_r(fileDescriptor,stream);\n      if ((*(code **)(stream + 0x2c) != (code *)0x0) &&\n         (returnValue = (**(code **)(stream + 0x2c))(fileDescriptor,*(undefined4 *)(stream + 0x1c)), returnValue < 0)\n         ) {\n        result = 0xffffffff;\n      }\n      if ((int)((uint)*(ushort *)(stream + 0xc) << 0x18) < 0) {\n        _free_r(fileDescriptor,*(undefined4 *)(stream + 0x10));\n      }\n      if (*(int *)(stream + 0x30) != 0) {\n        if (*(int *)(stream + 0x30) != stream + 0x40) {\n          _free_r(fileDescriptor);\n        }\n        *(undefined4 *)(stream + 0x30) = 0;\n      }\n      if (*(int *)(stream + 0x44) != 0) {\n        _free_r(fileDescriptor);\n        *(undefined4 *)(stream + 0x44) = 0;\n      }\n      __sfp_lock_acquire();\n      *(undefined2 *)(stream + 0xc) = 0;\n      __sfp_lock_release();\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00084624": "flush_and_free_resources_00084624",
                "param_1": "fileDescriptor",
                "param_2": "stream",
                "uVar1": "result",
                "iVar2": "returnValue"
            },
            "calling": [
                "fclose"
            ],
            "called": [
                "__sfp_lock_release",
                "_free_r",
                "__sfp_lock_acquire",
                "_fflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000846a4": {
            "entrypoint": "0x000846a4",
            "current_name": "close_file_000846a4",
            "code": "\nint closeFile_000846a4(FILE *file)\n\n{\n  int result;\n  \n  result = _fclose_r(_impure_ptr,file);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000846a4": "close_file_000846a4",
                "__stream": "file",
                "iVar1": "result"
            },
            "calling": [],
            "called": [
                "_fclose_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000846b4": {
            "entrypoint": "0x000846b4",
            "current_name": "get_file_metadata_000846b4",
            "code": "\nvoid get_file_metadata_000846b4(int *error_code_ptr,int file_descriptor,stat *file_stat_ptr)\n\n{\n  int result;\n  \n  last_error = 0;\n  result = _fstat(file_descriptor,file_stat_ptr);\n  if ((result == -1) && (last_error != 0)) {\n    *error_code_ptr = last_error;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000846b4": "get_file_metadata_000846b4",
                "param_1": "error_code_ptr",
                "param_2": "file_descriptor",
                "param_3": "file_stat_ptr",
                "errno": "last_error",
                "iVar1": "result"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000846dc": {
            "entrypoint": "0x000846dc",
            "current_name": "check_io_terminal_000846dc",
            "code": "\nvoid checkIOTerminal_000846dc(int *errorStatus,int fileDescriptor)\n\n{\n  int isTerminal;\n  \n  lastError = 0;\n  isTerminal = _isatty(fileDescriptor);\n  if ((isTerminal == -1) && (lastError != 0)) {\n    *errorStatus = lastError;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000846dc": "check_io_terminal_000846dc",
                "param_1": "errorStatus",
                "param_2": "fileDescriptor",
                "iVar1": "isTerminal",
                "errno": "lastError"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084700": {
            "entrypoint": "0x00084700",
            "current_name": "lseek_error_handling_00084700",
            "code": "\nvoid lseek_error_handling_00084700(int *error_code,int file_descriptor,__off_t offset,int whence)\n\n{\n  __off_t result;\n  \n  errno = 0;\n  result = _lseek(file_descriptor,offset,whence);\n  if ((result == -1) && (errno != 0)) {\n    *error_code = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084700": "lseek_error_handling_00084700",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "result"
            },
            "calling": [
                "__swrite",
                "__sseek"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084728": {
            "entrypoint": "0x00084728",
            "current_name": "read_and_set_errno_00084728",
            "code": "\nvoid readAndSetErrno_00084728(int *errorPtr,int fileDescriptor,char *buffer,int count)\n\n{\n  int readResult;\n  \n  errno = 0;\n  readResult = _read(fileDescriptor,buffer,count);\n  if ((readResult == -1) && (errno != 0)) {\n    *errorPtr = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084728": "read_and_set_errno_00084728",
                "param_1": "errorPtr",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "count",
                "iVar1": "readResult"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084750": {
            "entrypoint": "0x00084750",
            "current_name": "divide_or_throw_error_00084750",
            "code": "\nvoid divideOrThrowError_00084750(int dividend,int divisor,int remainder,int quotient)\n\n{\n  if ((quotient == 0) && (remainder == 0)) {\n    if (divisor != 0 || dividend != 0) {\n      dividend = -1;\n    }\n    __aeabi_idiv0(dividend);\n    return;\n  }\n  __gnu_uldivmod_helper();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084750": "divide_or_throw_error_00084750",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "remainder",
                "param_4": "quotient"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__gnu_uldivmod_helper",
                "__aeabi_idiv0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008477c": {
            "entrypoint": "0x0008477c",
            "current_name": "calculate_difference_0008477c",
            "code": "\nvoid calculateDifference_0008477c(uint inputValue,int intValue,undefined4 lowerWord,undefined4 upperWord,int *outputArray)\n\n{\n  uint resultValue;\n  longlong multipliedValue;\n  \n  multipliedValue = __divdi3();\n  multipliedValue = multipliedValue * CONCAT44(upperWord,lowerWord);\n  resultValue = (uint)multipliedValue;\n  *outputArray = inputValue - resultValue;\n  outputArray[1] = (intValue - (int)((ulonglong)multipliedValue >> 0x20)) - (uint)(inputValue < resultValue);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008477c": "calculate_difference_0008477c",
                "param_1": "inputValue",
                "param_2": "intValue",
                "param_3": "lowerWord",
                "param_4": "upperWord",
                "param_5": "outputArray",
                "uVar1": "resultValue",
                "lVar2": "multipliedValue"
            },
            "calling": [],
            "called": [
                "__divdi3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000847ac": {
            "entrypoint": "0x000847ac",
            "current_name": "subtract_and_adjust_000847ac",
            "code": "\nvoid subtract_and_adjust_000847ac(uint input_value,int param_value,undefined4 lower_bits,undefined4 upper_bits,int *result_array)\n\n{\n  uint result;\n  longlong product;\n  \n  product = __udivdi3();\n  product = product * CONCAT44(upper_bits,lower_bits);\n  result = (uint)product;\n  *result_array = input_value - result;\n  result_array[1] = (param_value - (int)((ulonglong)product >> 0x20)) - (uint)(input_value < result);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000847ac": "subtract_and_adjust_000847ac",
                "param_1": "input_value",
                "param_2": "param_value",
                "param_3": "lower_bits",
                "param_4": "upper_bits",
                "param_5": "result_array",
                "uVar1": "result",
                "lVar2": "product"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [
                "__udivdi3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000847dc": {
            "entrypoint": "0x000847dc",
            "current_name": "FUNC_000847dc",
            "code": "\nvoid FUNC_000847dc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000847dc": "FUNC_000847dc"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000847e0": {
            "entrypoint": "0x000847e0",
            "current_name": "divide_with_remainder_000847e0",
            "code": "\nundefined8 divideWithRemainder_000847e0(uint dividend,uint dividend_hi,uint divisor,uint divisor_hi)\n\n{\n  longlong quotient;\n  uint quotient_lo;\n  uint quotient_hi;\n  uint uVar4;\n  uint uVar5;\n  int bitShift;\n  uint uVar7;\n  uint uVar8;\n  uint isDividendNegative;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool carryFlag;\n  \n  if ((int)dividend_hi < 0) {\n    carryFlag = dividend != 0;\n    dividend = -dividend;\n    dividend_hi = -dividend_hi - (uint)carryFlag;\n    isDividendNegative = 0xffffffff;\n  }\n  else {\n    isDividendNegative = 0;\n  }\n  if ((int)divisor_hi < 0) {\n    isDividendNegative = ~isDividendNegative;\n    carryFlag = divisor != 0;\n    divisor = -divisor;\n    divisor_hi = -divisor_hi - (uint)carryFlag;\n  }\n  if (divisor_hi == 0) {\n    if (dividend_hi < divisor) {\n      bitShift = LZCOUNT(divisor);\n      if (bitShift != 0) {\n        quotient_hi = dividend >> (0x20U - bitShift & 0xff);\n        divisor = divisor << bitShift;\n        dividend = dividend << bitShift;\n        dividend_hi = dividend_hi << bitShift | quotient_hi;\n      }\n      quotient_lo = divisor >> 0x10;\n      uVar4 = dividend_hi / quotient_lo;\n      uVar7 = (divisor & 0xffff) * uVar4;\n      uVar10 = dividend >> 0x10 | (dividend_hi - quotient_lo * uVar4) * 0x10000;\n      quotient_hi = uVar4;\n      if (uVar10 <= uVar7 && uVar7 - uVar10 != 0) {\n        carryFlag = CARRY4(uVar10,divisor);\n        uVar10 = uVar10 + divisor;\n        quotient_hi = uVar4 - 1;\n        if ((carryFlag == false) && (uVar10 <= uVar7 && uVar7 - uVar10 != 0)) {\n          quotient_hi = uVar4 - 2;\n          uVar10 = uVar10 + divisor;\n        }\n      }\n      uVar8 = (uVar10 - uVar7) / quotient_lo;\n      uVar4 = (divisor & 0xffff) * uVar8;\n      uVar7 = dividend & 0xffff | ((uVar10 - uVar7) - quotient_lo * uVar8) * 0x10000;\n      quotient_lo = uVar8;\n      if (uVar7 <= uVar4 && uVar4 - uVar7 != 0) {\n        quotient_lo = uVar8 - 1;\n        if ((CARRY4(uVar7,divisor) == false) &&\n           (uVar7 + divisor <= uVar4 && uVar4 - (uVar7 + divisor) != 0)) {\n          quotient_lo = uVar8 - 2;\n        }\n      }\n      quotient_lo = quotient_lo | quotient_hi << 0x10;\n      quotient_hi = 0;\n    }\n    else {\n      if (divisor == 0) {\n        divisor = 1 / 0;\n      }\n      bitShift = LZCOUNT(divisor);\n      if (bitShift == 0) {\n        dividend_hi = dividend_hi - divisor;\n        uVar4 = divisor >> 0x10;\n        uVar12 = divisor & 0xffff;\n        quotient_hi = 1;\n      }\n      else {\n        divisor = divisor << bitShift;\n        quotient_hi = dividend_hi >> (0x20U - bitShift & 0xff);\n        uVar4 = divisor >> 0x10;\n        uVar10 = quotient_hi / uVar4;\n        uVar12 = divisor & 0xffff;\n        uVar7 = uVar12 * uVar10;\n        uVar8 = dividend >> (0x20U - bitShift & 0xff) | dividend_hi << bitShift;\n        quotient_hi = uVar8 >> 0x10 | (quotient_hi - uVar4 * uVar10) * 0x10000;\n        dividend = dividend << bitShift;\n        quotient_lo = uVar10;\n        if (quotient_hi <= uVar7 && uVar7 - quotient_hi != 0) {\n          carryFlag = CARRY4(quotient_hi,divisor);\n          quotient_hi = quotient_hi + divisor;\n          quotient_lo = uVar10 - 1;\n          if ((carryFlag == false) && (quotient_hi <= uVar7 && uVar7 - quotient_hi != 0)) {\n            quotient_lo = uVar10 - 2;\n            quotient_hi = quotient_hi + divisor;\n          }\n        }\n        uVar5 = (quotient_hi - uVar7) / uVar4;\n        uVar10 = uVar12 * uVar5;\n        dividend_hi = uVar8 & 0xffff | ((quotient_hi - uVar7) - uVar4 * uVar5) * 0x10000;\n        quotient_hi = uVar5;\n        if (dividend_hi <= uVar10 && uVar10 - dividend_hi != 0) {\n          carryFlag = CARRY4(dividend_hi,divisor);\n          dividend_hi = dividend_hi + divisor;\n          quotient_hi = uVar5 - 1;\n          if ((carryFlag == false) && (dividend_hi <= uVar10 && uVar10 - dividend_hi != 0)) {\n            quotient_hi = uVar5 - 2;\n            dividend_hi = dividend_hi + divisor;\n          }\n        }\n        dividend_hi = dividend_hi - uVar10;\n        quotient_hi = quotient_hi | quotient_lo << 0x10;\n      }\n      quotient_lo = dividend_hi / uVar4;\n      uVar10 = uVar12 * quotient_lo;\n      uVar8 = dividend >> 0x10 | (dividend_hi - uVar4 * quotient_lo) * 0x10000;\n      uVar7 = quotient_lo;\n      if (uVar8 <= uVar10 && uVar10 - uVar8 != 0) {\n        carryFlag = CARRY4(uVar8,divisor);\n        uVar8 = uVar8 + divisor;\n        uVar7 = quotient_lo - 1;\n        if ((carryFlag == false) && (uVar8 <= uVar10 && uVar10 - uVar8 != 0)) {\n          uVar7 = quotient_lo - 2;\n          uVar8 = uVar8 + divisor;\n        }\n      }\n      uVar5 = (uVar8 - uVar10) / uVar4;\n      uVar12 = uVar12 * uVar5;\n      uVar4 = dividend & 0xffff | ((uVar8 - uVar10) - uVar4 * uVar5) * 0x10000;\n      quotient_lo = uVar5;\n      if (uVar4 <= uVar12 && uVar12 - uVar4 != 0) {\n        quotient_lo = uVar5 - 1;\n        if ((CARRY4(uVar4,divisor) == false) &&\n           (uVar4 + divisor <= uVar12 && uVar12 - (uVar4 + divisor) != 0)) {\n          quotient_lo = uVar5 - 2;\n        }\n      }\n      quotient_lo = quotient_lo | uVar7 << 0x10;\n    }\n  }\n  else if (dividend_hi < divisor_hi) {\n    quotient_hi = 0;\n    quotient_lo = 0;\n  }\n  else {\n    bitShift = LZCOUNT(divisor_hi);\n    if (bitShift == 0) {\n      if ((divisor_hi < dividend_hi) || (divisor <= dividend)) {\n        quotient_hi = 0;\n        quotient_lo = 1;\n      }\n      else {\n        quotient_lo = 0;\n        quotient_hi = 0;\n      }\n    }\n    else {\n      quotient_hi = 0x20 - bitShift;\n      uVar4 = dividend_hi >> (quotient_hi & 0xff);\n      uVar12 = divisor >> (quotient_hi & 0xff) | divisor_hi << bitShift;\n      uVar10 = uVar12 >> 0x10;\n      quotient_lo = uVar4 / uVar10;\n      uVar8 = (uVar12 & 0xffff) * quotient_lo;\n      uVar7 = dividend_hi << bitShift | dividend >> (quotient_hi & 0xff);\n      uVar4 = uVar7 >> 0x10 | (uVar4 - uVar10 * quotient_lo) * 0x10000;\n      quotient_hi = quotient_lo;\n      if (uVar4 <= uVar8 && uVar8 - uVar4 != 0) {\n        carryFlag = CARRY4(uVar4,uVar12);\n        uVar4 = uVar4 + uVar12;\n        quotient_hi = quotient_lo - 1;\n        if ((carryFlag == false) && (uVar4 <= uVar8 && uVar8 - uVar4 != 0)) {\n          quotient_hi = quotient_lo - 2;\n          uVar4 = uVar4 + uVar12;\n        }\n      }\n      uVar5 = (uVar4 - uVar8) / uVar10;\n      uVar11 = (uVar12 & 0xffff) * uVar5;\n      uVar4 = uVar7 & 0xffff | ((uVar4 - uVar8) - uVar10 * uVar5) * 0x10000;\n      quotient_lo = uVar5;\n      if (uVar4 <= uVar11 && uVar11 - uVar4 != 0) {\n        carryFlag = CARRY4(uVar4,uVar12);\n        uVar4 = uVar4 + uVar12;\n        quotient_lo = uVar5 - 1;\n        if ((carryFlag == false) && (uVar4 <= uVar11 && uVar11 - uVar4 != 0)) {\n          quotient_lo = uVar5 - 2;\n          uVar4 = uVar4 + uVar12;\n        }\n      }\n      quotient_lo = quotient_lo | quotient_hi << 0x10;\n      quotient = (ulonglong)quotient_lo * (ulonglong)(divisor << bitShift);\n      uVar7 = (uint)((ulonglong)quotient >> 0x20);\n      quotient_hi = 0;\n      if ((uVar4 - uVar11 < uVar7) ||\n         ((uVar4 - uVar11 == uVar7 && (dividend << bitShift < (uint)quotient)))) {\n        quotient_lo = quotient_lo - 1;\n        quotient_hi = 0;\n      }\n    }\n  }\n  if (isDividendNegative != 0) {\n    carryFlag = quotient_lo != 0;\n    quotient_lo = -quotient_lo;\n    quotient_hi = -quotient_hi - (uint)carryFlag;\n  }\n  return CONCAT44(quotient_hi,quotient_lo);\n}\n\n",
            "renaming": {
                "FUN_000847e0": "divide_with_remainder_000847e0",
                "param_1": "dividend",
                "param_2": "dividend_hi",
                "param_3": "divisor",
                "param_4": "divisor_hi",
                "lVar1": "quotient",
                "uVar2": "quotient_lo",
                "uVar3": "quotient_hi",
                "iVar6": "bitShift",
                "uVar9": "isDividendNegative",
                "bVar13": "carryFlag"
            },
            "calling": [
                "__gnu_ldivmod_helper"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084a80": {
            "entrypoint": "0x00084a80",
            "current_name": "divide_with_remainder_00084a80",
            "code": "\nulonglong divideWithRemainder_00084a80(uint dividend,uint divisor,uint quotient,uint remainder)\n\n{\n  longlong tempLong;\n  uint quotient1;\n  uint quotient2;\n  uint remainder1;\n  uint remainder2;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  int tempInt;\n  bool carryFlag;\n  \n  if (remainder == 0) {\n    if (quotient <= divisor) {\n      if (quotient == 0) {\n        quotient = 1 / 0;\n      }\n      tempInt = LZCOUNT(quotient);\n      if (tempInt == 0) {\n        divisor = divisor - quotient;\n        quotient2 = quotient >> 0x10;\n        remainder2 = quotient & 0xffff;\n        quotient1 = 1;\n      }\n      else {\n        quotient = quotient << tempInt;\n        temp3 = divisor >> (0x20U - tempInt & 0xff);\n        quotient2 = quotient >> 0x10;\n        temp4 = temp3 / quotient2;\n        remainder2 = quotient & 0xffff;\n        quotient1 = remainder2 * temp4;\n        temp1 = dividend >> (0x20U - tempInt & 0xff) | divisor << tempInt;\n        remainder1 = temp1 >> 0x10 | (temp3 - quotient2 * temp4) * 0x10000;\n        dividend = dividend << tempInt;\n        temp3 = temp4;\n        if (remainder1 <= quotient1 && quotient1 - remainder1 != 0) {\n          carryFlag = CARRY4(remainder1,quotient);\n          remainder1 = remainder1 + quotient;\n          temp3 = temp4 - 1;\n          if ((carryFlag == false) && (remainder1 <= quotient1 && quotient1 - remainder1 != 0)) {\n            temp3 = temp4 - 2;\n            remainder1 = remainder1 + quotient;\n          }\n        }\n        temp2 = (remainder1 - quotient1) / quotient2;\n        temp4 = remainder2 * temp2;\n        divisor = temp1 & 0xffff | ((remainder1 - quotient1) - quotient2 * temp2) * 0x10000;\n        quotient1 = temp2;\n        if (divisor <= temp4 && temp4 - divisor != 0) {\n          carryFlag = CARRY4(divisor,quotient);\n          divisor = divisor + quotient;\n          quotient1 = temp2 - 1;\n          if ((carryFlag == false) && (divisor <= temp4 && temp4 - divisor != 0)) {\n            quotient1 = temp2 - 2;\n            divisor = divisor + quotient;\n          }\n        }\n        divisor = divisor - temp4;\n        quotient1 = quotient1 | temp3 << 0x10;\n      }\n      temp4 = divisor / quotient2;\n      remainder1 = remainder2 * temp4;\n      temp1 = dividend >> 0x10 | (divisor - quotient2 * temp4) * 0x10000;\n      temp3 = temp4;\n      if (temp1 <= remainder1 && remainder1 - temp1 != 0) {\n        carryFlag = CARRY4(temp1,quotient);\n        temp1 = temp1 + quotient;\n        temp3 = temp4 - 1;\n        if ((carryFlag == false) && (temp1 <= remainder1 && remainder1 - temp1 != 0)) {\n          temp3 = temp4 - 2;\n          temp1 = temp1 + quotient;\n        }\n      }\n      temp4 = (temp1 - remainder1) / quotient2;\n      remainder2 = remainder2 * temp4;\n      temp1 = dividend & 0xffff | ((temp1 - remainder1) - quotient2 * temp4) * 0x10000;\n      quotient2 = temp4;\n      if (temp1 <= remainder2 && remainder2 - temp1 != 0) {\n        quotient2 = temp4 - 1;\n        if ((CARRY4(temp1,quotient) == false) &&\n           (temp1 + quotient <= remainder2 && remainder2 - (temp1 + quotient) != 0)) {\n          quotient2 = temp4 - 2;\n        }\n      }\n      return CONCAT44(quotient1,quotient2 | temp3 << 0x10);\n    }\n    tempInt = LZCOUNT(quotient);\n    if (tempInt != 0) {\n      temp3 = dividend >> (0x20U - tempInt & 0xff);\n      quotient = quotient << tempInt;\n      dividend = dividend << tempInt;\n      divisor = temp3 | divisor << tempInt;\n    }\n    quotient1 = quotient >> 0x10;\n    quotient2 = divisor / quotient1;\n    remainder2 = (quotient & 0xffff) * quotient2;\n    temp4 = dividend >> 0x10 | (divisor - quotient1 * quotient2) * 0x10000;\n    temp3 = quotient2;\n    if (temp4 <= remainder2 && remainder2 - temp4 != 0) {\n      carryFlag = CARRY4(temp4,quotient);\n      temp4 = temp4 + quotient;\n      temp3 = quotient2 - 1;\n      if ((carryFlag == false) && (temp4 <= remainder2 && remainder2 - temp4 != 0)) {\n        temp3 = quotient2 - 2;\n        temp4 = temp4 + quotient;\n      }\n    }\n    temp1 = (temp4 - remainder2) / quotient1;\n    quotient2 = (quotient & 0xffff) * temp1;\n    remainder2 = dividend & 0xffff | ((temp4 - remainder2) - quotient1 * temp1) * 0x10000;\n    quotient1 = temp1;\n    if (remainder2 <= quotient2 && quotient2 - remainder2 != 0) {\n      quotient1 = temp1 - 1;\n      if ((CARRY4(remainder2,quotient) == false) &&\n         (remainder2 + quotient <= quotient2 && quotient2 - (remainder2 + quotient) != 0)) {\n        quotient1 = temp1 - 2;\n      }\n    }\n    quotient1 = quotient1 | temp3 << 0x10;\n  }\n  else {\n    if (divisor < remainder) {\n      return 0;\n    }\n    tempInt = LZCOUNT(remainder);\n    if (tempInt == 0) {\n      if ((remainder < divisor) || (quotient <= dividend)) {\n        return 1;\n      }\n      quotient1 = 0;\n    }\n    else {\n      quotient1 = 0x20 - tempInt;\n      temp3 = divisor >> (quotient1 & 0xff);\n      quotient2 = remainder << tempInt | quotient >> (quotient1 & 0xff);\n      remainder2 = quotient2 >> 0x10;\n      remainder1 = temp3 / remainder2;\n      temp4 = (quotient2 & 0xffff) * remainder1;\n      temp1 = dividend >> (quotient1 & 0xff) | divisor << tempInt;\n      quotient1 = temp1 >> 0x10 | (temp3 - remainder2 * remainder1) * 0x10000;\n      temp3 = remainder1;\n      if (quotient1 <= temp4 && temp4 - quotient1 != 0) {\n        carryFlag = CARRY4(quotient1,quotient2);\n        quotient1 = quotient1 + quotient2;\n        temp3 = remainder1 - 1;\n        if ((carryFlag == false) && (quotient1 <= temp4 && temp4 - quotient1 != 0)) {\n          temp3 = remainder1 - 2;\n          quotient1 = quotient1 + quotient2;\n        }\n      }\n      remainder1 = (quotient1 - temp4) / remainder2;\n      temp2 = (quotient2 & 0xffff) * remainder1;\n      remainder2 = temp1 & 0xffff | ((quotient1 - temp4) - remainder2 * remainder1) * 0x10000;\n      quotient1 = remainder1;\n      if (remainder2 <= temp2 && temp2 - remainder2 != 0) {\n        carryFlag = CARRY4(remainder2,quotient2);\n        remainder2 = remainder2 + quotient2;\n        quotient1 = remainder1 - 1;\n        if ((carryFlag == false) && (remainder2 <= temp2 && temp2 - remainder2 != 0)) {\n          quotient1 = remainder1 - 2;\n          remainder2 = remainder2 + quotient2;\n        }\n      }\n      quotient1 = quotient1 | temp3 << 0x10;\n      tempLong = (ulonglong)quotient1 * (ulonglong)(quotient << tempInt);\n      temp3 = (uint)((ulonglong)tempLong >> 0x20);\n      if ((remainder2 - temp2 < temp3) || ((remainder2 - temp2 == temp3 && (dividend << tempInt < (uint)tempLong)))\n         ) {\n        quotient1 = quotient1 - 1;\n      }\n    }\n  }\n  return (ulonglong)quotient1;\n}\n\n",
            "renaming": {
                "FUN_00084a80": "divide_with_remainder_00084a80",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "lVar1": "tempLong",
                "uVar2": "quotient1",
                "uVar3": "quotient2",
                "uVar4": "remainder1",
                "uVar5": "remainder2",
                "uVar6": "temp1",
                "uVar7": "temp2",
                "uVar8": "temp3",
                "uVar9": "temp4",
                "iVar10": "tempInt",
                "bVar11": "carryFlag"
            },
            "calling": [
                "__gnu_uldivmod_helper"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00085858": {
            "entrypoint": "0x00085858",
            "current_name": "FUNC_00085858",
            "code": "\nvoid FUNC_00085858(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00085858": "FUNC_00085858"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00085874": {
            "entrypoint": "0x00085874",
            "current_name": "FUNC_00085874",
            "code": "\nvoid FUNC_00085874(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00085874": "FUNC_00085874"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_20070000": {
            "entrypoint": "0x20070000",
            "current_name": "disable_ir_qinterrupts_20070000",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disableIRQinterrupts_20070000(void)\n\n{\n  disableIRQinterrupts_20070000();\n  do {\n  } while (-1 < *(int *)(DAT_2007001c + 8) << 0x1f);\n  *(undefined4 *)(DAT_2007001c + 4) = DAT_20070020;\n  do {\n  } while (-1 < *(int *)(DAT_2007001c + 8) << 0x1f);\n  *DAT_20070028 = DAT_20070024;\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_20070000": "disable_ir_qinterrupts_20070000"
            },
            "calling": [
                "tickReset",
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 115158,
    "layers": [
        [
            "FUN_000800f4",
            "FUN_00080148",
            "FUN_0008014c",
            "FUN_00080164",
            "FUN_000801b0",
            "FUN_0008021c",
            "FUN_00080258",
            "FUN_000802da",
            "FUN_000803d4",
            "FUN_00080410",
            "FUN_0008043e",
            "FUN_000804a8",
            "FUN_000805d0",
            "FUN_00080a68",
            "FUN_00080aac",
            "FUN_00080ac0",
            "FUN_00080acc",
            "FUN_00080ad8",
            "FUN_00080ae4",
            "FUN_00080c0c",
            "FUN_00080ce0",
            "FUN_00080d24",
            "FUN_00080d2e",
            "FUN_00080d54",
            "FUN_00080d7a",
            "FUN_00080da0",
            "FUN_00080e04",
            "FUN_00080e18",
            "FUN_00080e5c",
            "FUN_00080e9c",
            "FUN_00080f24",
            "FUN_00080f9c",
            "FUN_00081034",
            "FUN_00081042",
            "FUN_0008105c",
            "FUN_00081066",
            "FUN_0008106e",
            "FUN_00081074",
            "FUN_00081084",
            "FUN_000810bc",
            "FUN_000810f4",
            "FUN_0008112c",
            "FUN_00081164",
            "FUN_00081166",
            "FUN_0008116a",
            "FUN_0008116e",
            "FUN_00081184",
            "FUN_00081188",
            "FUN_0008118c",
            "FUN_000811a8",
            "FUN_000811ae",
            "FUN_000811b4",
            "FUN_000811be",
            "FUN_000811c2",
            "FUN_000811c6",
            "FUN_000811cc",
            "FUN_000811f0",
            "FUN_00081202",
            "FUN_00081208",
            "FUN_00081210",
            "FUN_00081318",
            "FUN_00081388",
            "FUN_000813a8",
            "FUN_000813c2",
            "FUN_000813e0",
            "FUN_000813e4",
            "FUN_000813f6",
            "FUN_00081412",
            "FUN_0008143c",
            "FUN_00081454",
            "FUN_000814a8",
            "FUN_000814e4",
            "FUN_00081508",
            "FUN_00081578",
            "FUN_00081580",
            "FUN_000815ca",
            "FUN_000815d4",
            "FUN_000815f8",
            "FUN_000815fe",
            "FUN_0008160c",
            "FUN_00081622",
            "FUN_0008163a",
            "FUN_0008165c",
            "FUN_00081682",
            "FUN_000816a8",
            "FUN_000816d4",
            "FUN_000816e0",
            "FUN_00081704",
            "FUN_00081714",
            "FUN_00081720",
            "FUN_00081728",
            "FUN_00081730",
            "FUN_00081734",
            "FUN_00081894",
            "FUN_0008189c",
            "FUN_000818b8",
            "FUN_000818c8",
            "FUN_00081944",
            "FUN_00081aac",
            "FUN_00081be4",
            "FUN_00081bec",
            "FUN_00081bf4",
            "FUN_00081c54",
            "FUN_00081c5c",
            "FUN_00081c6c",
            "FUN_00081c80",
            "FUN_00081c94",
            "FUN_00081ca8",
            "FUN_00081cbc",
            "FUN_00081cd0",
            "FUN_00081d1c",
            "FUN_00081d5c",
            "FUN_00081d68",
            "FUN_00081d7c",
            "FUN_00081dcc",
            "FUN_00081df4",
            "FUN_00081e04",
            "FUN_00081e14",
            "FUN_0008234c",
            "FUN_00082438",
            "FUN_00082504",
            "FUN_000825a0",
            "FUN_000825b0",
            "FUN_00082970",
            "FUN_00082994",
            "FUN_00082a50",
            "FUN_00082ab0",
            "FUN_00082ac0",
            "FUN_00082b38",
            "FUN_0008378c",
            "FUN_00083808",
            "FUN_000838cc",
            "FUN_00083988",
            "FUN_00083994",
            "FUN_00083adc",
            "FUN_00083b08",
            "FUN_00083b14",
            "FUN_00083c10",
            "FUN_00083c40",
            "FUN_00083d00",
            "FUN_00083d9c",
            "FUN_00083f34",
            "FUN_00084248",
            "FUN_00084290",
            "FUN_00084298",
            "FUN_000842a4",
            "FUN_00084384",
            "FUN_00084418",
            "FUN_00084440",
            "FUN_00084464",
            "FUN_0008449c",
            "FUN_000844bc",
            "FUN_000844c4",
            "FUN_0008456c",
            "FUN_000845bc",
            "FUN_000845d8",
            "FUN_00084600",
            "FUN_00084624",
            "FUN_000846a4",
            "FUN_000846b4",
            "FUN_000846dc",
            "FUN_00084700",
            "FUN_00084728",
            "FUN_00084750",
            "FUN_0008477c",
            "FUN_000847ac",
            "FUN_000847e0",
            "FUN_00084a80",
            "FUN_20070000"
        ]
    ],
    "locked_functions": []
}