{
  "functions": {
    "__do_global_dtors_aux": {
      "entrypoint": "0x08000188",
      "current_name": "__do_global_dtors_aux",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x08000194) */\n\nundefined4 __do_global_dtors_aux(undefined4 param_1)\n\n{\n  if ((char)completed_8911 \u003d\u003d \u0027\\0\u0027) {\n    completed_8911._0_1_ \u003d \u0027\\x01\u0027;\n  }\n  return param_1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_fini_array"
      ],
      "called": [
        "_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "frame_dummy": {
      "entrypoint": "0x080001ac",
      "current_name": "frame_dummy",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x080001b2) */\n\nundefined8 frame_dummy(undefined4 param_1,undefined4 param_2)\n\n{\n  return CONCAT44(param_2,param_1);\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_init_array",
        "__libc_fini_array"
      ],
      "called": [
        "_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "coolant_flood_on": {
      "entrypoint": "0x080001c8",
      "current_name": "coolant_flood_on",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid coolant_flood_on(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "coolant_run"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "coolant_flood_off": {
      "entrypoint": "0x080001d4",
      "current_name": "coolant_flood_off",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid coolant_flood_off(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "coolant_stop"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "coolant_mist_on": {
      "entrypoint": "0x080001e0",
      "current_name": "coolant_mist_on",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid coolant_mist_on(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "coolant_run"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "coolant_mist_off": {
      "entrypoint": "0x080001ec",
      "current_name": "coolant_mist_off",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid coolant_mist_off(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "coolant_stop"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "coolant_init": {
      "entrypoint": "0x080001f8",
      "current_name": "coolant_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid coolant_init(void)\n\n{\n  current_coolant_mode \u003d \u0027\\0\u0027;\n  coolant_stop();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "grbl_main"
      ],
      "called": [
        "coolant_stop"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "coolant_stop": {
      "entrypoint": "0x08000210",
      "current_name": "coolant_stop",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid coolant_stop(void)\n\n{\n  coolant_mist_off();\n  coolant_flood_off();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "coolant_run",
        "coolant_init",
        "mc_reset"
      ],
      "called": [
        "coolant_flood_off",
        "coolant_mist_off"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "coolant_run": {
      "entrypoint": "0x08000220",
      "current_name": "coolant_run",
      "code": "\nvoid coolant_run(uint8_t mode)\n\n{\n  uint8_t mode_local;\n  \n  if (mode !\u003d current_coolant_mode) {\n    plan_synchronize();\n    if (mode \u003d\u003d \u0027\\x01\u0027) {\n      coolant_flood_on();\n      current_coolant_mode \u003d mode;\n    }\n    else if (mode \u003d\u003d \u0027\\x02\u0027) {\n      coolant_mist_on();\n      current_coolant_mode \u003d mode;\n    }\n    else {\n      coolant_stop();\n      current_coolant_mode \u003d mode;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line"
      ],
      "called": [
        "coolant_stop",
        "coolant_flood_on",
        "plan_synchronize",
        "coolant_mist_on"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "get_current_usecs": {
      "entrypoint": "0x08000268",
      "current_name": "get_current_usecs",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint64_t get_current_usecs(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 \u003d HAL_GetTick();\n  return (uint64_t)((uVar1 + 1) * 1000 - _DAT_e000e018 / 0xa8);\n}\n\n",
      "renaming": {},
      "calling": [
        "_delay_us"
      ],
      "called": [
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_delay_ms": {
      "entrypoint": "0x080002a0",
      "current_name": "_delay_ms",
      "code": "\nvoid _delay_ms(uint _ms)\n\n{\n  uint _ms_local;\n  \n  HAL_Delay(_ms);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "mc_dwell"
      ],
      "called": [
        "HAL_Delay"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_delay_us": {
      "entrypoint": "0x080002b6",
      "current_name": "_delay_us",
      "code": "\nvoid _delay_us(uint _us)\n\n{\n  uint uVar1;\n  bool bVar2;\n  uint64_t uVar3;\n  uint64_t uVar4;\n  uint _us_local;\n  uint64_t timeout;\n  \n  uVar3 \u003d get_current_usecs();\n  do {\n    uVar4 \u003d get_current_usecs();\n    uVar1 \u003d (uint)(uVar4 \u003e\u003e 0x20);\n    timeout._0_4_ \u003d (uint)(uVar3 + _us);\n    timeout._4_4_ \u003d (uint)(uVar3 + _us \u003e\u003e 0x20);\n    bVar2 \u003d timeout._4_4_ \u003c\u003d uVar1;\n    if (uVar1 \u003d\u003d timeout._4_4_) {\n      bVar2 \u003d (uint)timeout \u003c\u003d (uint)uVar4;\n    }\n  } while (!bVar2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "get_current_usecs"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "eeprom_init": {
      "entrypoint": "0x080002f0",
      "current_name": "eeprom_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid eeprom_init(void)\n\n{\n  memset(eeprom_data,0xff,4);\n  eeprom_ready \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "eeprom_put_char",
        "memcpy_to_eeprom_with_checksum",
        "memcpy_from_eeprom_with_checksum",
        "eeprom_get_char"
      ],
      "called": [
        "memset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "eeprom_get_char": {
      "entrypoint": "0x08000310",
      "current_name": "eeprom_get_char",
      "code": "\nchar eeprom_get_char(uint addr)\n\n{\n  uint addr_local;\n  \n  if (eeprom_ready \u003d\u003d 0) {\n    eeprom_init();\n  }\n  return eeprom_data[addr \u0026 0x3ff];\n}\n\n",
      "renaming": {},
      "calling": [
        "memcpy_from_eeprom_with_checksum",
        "read_global_settings"
      ],
      "called": [
        "eeprom_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "eeprom_put_char": {
      "entrypoint": "0x08000340",
      "current_name": "eeprom_put_char",
      "code": "\nvoid eeprom_put_char(uint addr,uchar new_value)\n\n{\n  uchar new_value_local;\n  uint addr_local;\n  \n  if (eeprom_ready \u003d\u003d 0) {\n    eeprom_init();\n  }\n  eeprom_data[addr \u0026 0x3ff] \u003d new_value;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "memcpy_to_eeprom_with_checksum",
        "write_global_settings"
      ],
      "called": [
        "eeprom_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memcpy_to_eeprom_with_checksum": {
      "entrypoint": "0x08000374",
      "current_name": "memcpy_to_eeprom_with_checksum",
      "code": "\nvoid memcpy_to_eeprom_with_checksum(uint destination,char *source,uint size)\n\n{\n  uint size_local;\n  char *source_local;\n  uint destination_local;\n  uchar checksum;\n  \n  checksum \u003d \u0027\\0\u0027;\n  size_local \u003d size;\n  source_local \u003d source;\n  destination_local \u003d destination;\n  if (eeprom_ready \u003d\u003d 0) {\n    eeprom_init();\n    source_local \u003d source;\n    destination_local \u003d destination;\n  }\n  for (; size_local !\u003d 0; size_local \u003d size_local - 1) {\n    checksum \u003d (checksum !\u003d \u0027\\0\u0027) + *source_local;\n    eeprom_put_char(destination_local,*source_local);\n    source_local \u003d source_local + 1;\n    destination_local \u003d destination_local + 1;\n  }\n  eeprom_put_char(destination_local,checksum);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "settings_store_startup_line",
        "settings_write_coord_data",
        "write_global_settings"
      ],
      "called": [
        "eeprom_put_char",
        "eeprom_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memcpy_from_eeprom_with_checksum": {
      "entrypoint": "0x080003ec",
      "current_name": "memcpy_from_eeprom_with_checksum",
      "code": "\nint memcpy_from_eeprom_with_checksum(char *destination,uint source,uint size)\n\n{\n  char cVar1;\n  uint size_local;\n  uint source_local;\n  char *destination_local;\n  uchar data;\n  uchar checksum;\n  \n  checksum \u003d \u0027\\0\u0027;\n  size_local \u003d size;\n  source_local \u003d source;\n  destination_local \u003d destination;\n  if (eeprom_ready \u003d\u003d 0) {\n    eeprom_init();\n    source_local \u003d source;\n    destination_local \u003d destination;\n  }\n  for (; size_local !\u003d 0; size_local \u003d size_local - 1) {\n    cVar1 \u003d eeprom_get_char(source_local);\n    checksum \u003d cVar1 + (checksum !\u003d \u0027\\0\u0027);\n    *destination_local \u003d cVar1;\n    source_local \u003d source_local + 1;\n    destination_local \u003d destination_local + 1;\n  }\n  cVar1 \u003d eeprom_get_char(source_local);\n  return (uint)((uint)checksum \u003d\u003d (int)cVar1);\n}\n\n",
      "renaming": {},
      "calling": [
        "settings_read_coord_data",
        "settings_read_startup_line",
        "read_global_settings"
      ],
      "called": [
        "eeprom_init",
        "eeprom_get_char"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "select_plane": {
      "entrypoint": "0x08000478",
      "current_name": "select_plane",
      "code": "\nvoid select_plane(uint8_t axis_0,uint8_t axis_1,uint8_t axis_2)\n\n{\n  uint8_t axis_2_local;\n  uint8_t axis_1_local;\n  uint8_t axis_0_local;\n  \n  gc.plane_axis_0 \u003d axis_0;\n  gc.plane_axis_1 \u003d axis_1;\n  gc.plane_axis_2 \u003d axis_2;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line",
        "gc_init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "gc_init": {
      "entrypoint": "0x080004ac",
      "current_name": "gc_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid gc_init(void)\n\n{\n  uint8_t uVar1;\n  \n  memset(\u0026gc,0,0x38);\n  gc.feed_rate \u003d settings.default_feed_rate;\n  select_plane(\u0027\\0\u0027,\u0027\\x01\u0027,\u0027\\x02\u0027);\n  gc.absolute_mode \u003d \u0027\\x01\u0027;\n  uVar1 \u003d settings_read_coord_data(gc.coord_select,gc.coord_system);\n  if (uVar1 \u003d\u003d \u0027\\0\u0027) {\n    report_status_message(\u0027\\n\u0027);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "grbl_main"
      ],
      "called": [
        "settings_read_coord_data",
        "select_plane",
        "memset",
        "report_status_message"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "gc_set_current_position": {
      "entrypoint": "0x080004fc",
      "current_name": "gc_set_current_position",
      "code": "\nvoid gc_set_current_position(int32_t x,int32_t y,int32_t z)\n\n{\n  undefined4 uVar1;\n  int32_t z_local;\n  int32_t y_local;\n  int32_t x_local;\n  \n  uVar1 \u003d __floatsisf(x);\n  gc.position[0] \u003d (float)__aeabi_fdiv(uVar1,settings.steps_per_mm[0]);\n  uVar1 \u003d __floatsisf(y);\n  gc.position[1] \u003d (float)__aeabi_fdiv(uVar1,settings.steps_per_mm[1]);\n  uVar1 \u003d __floatsisf(z);\n  gc.position[2] \u003d (float)__aeabi_fdiv(uVar1,settings.steps_per_mm[2]);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "sys_sync_current_position"
      ],
      "called": [
        "__floatsisf",
        "__aeabi_fdiv"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "to_millimeters": {
      "entrypoint": "0x0800056c",
      "current_name": "to_millimeters",
      "code": "\nfloat to_millimeters(float value)\n\n{\n  undefined4 in_r0;\n  undefined8 uVar1;\n  float value_local;\n  \n  if (gc.inches_mode !\u003d \u0027\\0\u0027) {\n    uVar1 \u003d __aeabi_f2d(in_r0);\n    uVar1 \u003d __muldf3((int)uVar1,(int)((ulonglong)uVar1 \u003e\u003e 0x20),0x66666666,0x40396666);\n    value \u003d (float)__truncdfsf2((int)uVar1,(int)((ulonglong)uVar1 \u003e\u003e 0x20));\n  }\n  return value;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line"
      ],
      "called": [
        "__truncdfsf2",
        "__aeabi_f2d",
        "__muldf3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "gc_execute_line": {
      "entrypoint": "0x080005b4",
      "current_name": "gc_execute_line",
      "code": "\nuint8_t gc_execute_line(char *line)\n\n{\n  uint8_t uVar1;\n  int iVar2;\n  float fVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined4 extraout_r1_03;\n  undefined4 extraout_r1_04;\n  uint extraout_r1_05;\n  undefined4 extraout_r1_06;\n  undefined4 extraout_r1_07;\n  uint uVar6;\n  float fVar7;\n  float value_00;\n  undefined8 extraout_d0;\n  undefined8 extraout_d0_00;\n  undefined8 extraout_d0_01;\n  undefined8 extraout_d0_02;\n  undefined8 extraout_d0_03;\n  undefined8 extraout_d0_04;\n  undefined8 extraout_d0_05;\n  undefined8 extraout_d0_06;\n  undefined8 extraout_d0_07;\n  undefined8 extraout_d0_08;\n  undefined8 extraout_d0_09;\n  undefined8 extraout_d0_10;\n  undefined8 extraout_d0_11;\n  undefined8 extraout_d0_12;\n  undefined8 extraout_d0_13;\n  undefined8 extraout_d0_14;\n  undefined8 extraout_d0_15;\n  undefined8 extraout_d0_16;\n  undefined8 extraout_d0_17;\n  float y_00;\n  undefined8 extraout_d0_18;\n  undefined8 extraout_d0_19;\n  float extraout_s2;\n  float extraout_s2_00;\n  float extraout_s2_01;\n  float extraout_s2_02;\n  float extraout_s2_03;\n  float extraout_s2_04;\n  float extraout_s2_05;\n  float extraout_s2_06;\n  float extraout_s2_07;\n  float extraout_s2_08;\n  float extraout_s2_09;\n  float extraout_s2_10;\n  float extraout_s2_11;\n  float extraout_s2_12;\n  float extraout_s2_13;\n  float extraout_s2_14;\n  float extraout_s2_15;\n  float extraout_s2_16;\n  float extraout_s2_17;\n  float extraout_s3;\n  float extraout_s3_00;\n  float extraout_s3_01;\n  float extraout_s3_02;\n  float extraout_s3_03;\n  float extraout_s3_04;\n  float extraout_s3_05;\n  float extraout_s3_06;\n  float extraout_s3_07;\n  float extraout_s3_08;\n  float extraout_s3_09;\n  float extraout_s3_10;\n  float extraout_s3_11;\n  float extraout_s3_12;\n  float extraout_s3_13;\n  float extraout_s3_14;\n  float extraout_s3_15;\n  float extraout_s3_16;\n  float extraout_s3_17;\n  undefined8 uVar8;\n  undefined4 in_stack_ffffff48;\n  undefined4 in_stack_ffffff4c;\n  undefined4 in_stack_ffffff50;\n  undefined4 in_stack_ffffff54;\n  char *line_local;\n  float coord_data_2 [3];\n  float coord_data_1 [3];\n  float coord_data [3];\n  float offset [3];\n  float target [3];\n  float value;\n  char letter;\n  uint8_t char_counter;\n  float y;\n  float x;\n  uint8_t isclockwise;\n  float h_x2_div_d;\n  uint8_t i_3;\n  uint8_t i_2;\n  uint8_t i_1;\n  uint8_t i;\n  uint8_t l;\n  float r;\n  float p;\n  uint8_t group_number;\n  uint8_t non_modal_action;\n  uint8_t absolute_override;\n  float inverse_feed_rate;\n  uint8_t axis_words;\n  uint16_t modal_group_words;\n  int int_value;\n  \n  if (sys.state \u003d\u003d \u0027\\x06\u0027) {\n    uVar1 \u003d \u0027\\f\u0027;\n  }\n  else {\n    char_counter \u003d \u0027\\0\u0027;\n    modal_group_words \u003d 0;\n    axis_words \u003d \u0027\\0\u0027;\n    inverse_feed_rate \u003d -1.0;\n    absolute_override \u003d \u0027\\0\u0027;\n    non_modal_action \u003d \u0027\\0\u0027;\n    memset(target,0,0xc);\n    memset(offset,0,0xc);\n    gc.status_code \u003d \u0027\\0\u0027;\n    group_number \u003d \u0027\\0\u0027;\n    while (iVar2 \u003d next_statement(\u0026letter,\u0026value,line,\u0026char_counter), iVar2 !\u003d 0) {\n      uVar4 \u003d __aeabi_f2d(value);\n      trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n      int_value \u003d __aeabi_d2iz(uVar4,extraout_r1);\n      if (letter \u003d\u003d \u0027G\u0027) {\n        switch(int_value) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 0x50:\n          group_number \u003d \u0027\\x02\u0027;\n          break;\n        case 4:\n        case 10:\n        case 0x1c:\n        case 0x1e:\n        case 0x35:\n        case 0x5c:\n          group_number \u003d \u0027\\x01\u0027;\n          break;\n        case 0x11:\n        case 0x12:\n        case 0x13:\n          group_number \u003d \u0027\\x03\u0027;\n          break;\n        case 0x14:\n        case 0x15:\n          group_number \u003d \u0027\\a\u0027;\n          break;\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n          group_number \u003d \u0027\\t\u0027;\n          break;\n        case 0x5a:\n        case 0x5b:\n          group_number \u003d \u0027\\x04\u0027;\n          break;\n        case 0x5d:\n        case 0x5e:\n          group_number \u003d \u0027\\x06\u0027;\n        }\n        switch(int_value) {\n        case 0:\n          gc.motion_mode \u003d \u0027\\0\u0027;\n          break;\n        case 1:\n          gc.motion_mode \u003d \u0027\\x01\u0027;\n          break;\n        case 2:\n          gc.motion_mode \u003d \u0027\\x02\u0027;\n          break;\n        case 3:\n          gc.motion_mode \u003d \u0027\\x03\u0027;\n          break;\n        case 4:\n          non_modal_action \u003d \u0027\\x01\u0027;\n          break;\n        default:\n          gc.status_code \u003d \u0027\\x03\u0027;\n          break;\n        case 10:\n          non_modal_action \u003d \u0027\\x02\u0027;\n          break;\n        case 0x11:\n          select_plane(\u0027\\0\u0027,\u0027\\x01\u0027,\u0027\\x02\u0027);\n          break;\n        case 0x12:\n          select_plane(\u0027\\x02\u0027,\u0027\\0\u0027,\u0027\\x01\u0027);\n          break;\n        case 0x13:\n          select_plane(\u0027\\x01\u0027,\u0027\\x02\u0027,\u0027\\0\u0027);\n          break;\n        case 0x14:\n          gc.inches_mode \u003d \u0027\\x01\u0027;\n          break;\n        case 0x15:\n          gc.inches_mode \u003d \u0027\\0\u0027;\n          break;\n        case 0x1c:\n        case 0x1e:\n          uVar4 \u003d __aeabi_fmul(value,0x41200000);\n          uVar4 \u003d __aeabi_f2d(uVar4);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          int_value \u003d __aeabi_d2iz(uVar4,extraout_r1_00);\n          switch(int_value) {\n          case 0x118:\n            non_modal_action \u003d \u0027\\x03\u0027;\n            break;\n          case 0x119:\n            non_modal_action \u003d \u0027\\x04\u0027;\n            break;\n          default:\n            gc.status_code \u003d \u0027\\x03\u0027;\n            break;\n          case 300:\n            non_modal_action \u003d \u0027\\x05\u0027;\n            break;\n          case 0x12d:\n            non_modal_action \u003d \u0027\\x06\u0027;\n          }\n          break;\n        case 0x35:\n          absolute_override \u003d \u0027\\x01\u0027;\n          break;\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n          gc.coord_select \u003d (char)int_value + 0xca;\n          break;\n        case 0x50:\n          gc.motion_mode \u003d \u0027\\x04\u0027;\n          break;\n        case 0x5a:\n          gc.absolute_mode \u003d \u0027\\x01\u0027;\n          break;\n        case 0x5b:\n          gc.absolute_mode \u003d \u0027\\0\u0027;\n          break;\n        case 0x5c:\n          uVar4 \u003d __aeabi_fmul(value,0x41200000);\n          uVar4 \u003d __aeabi_f2d(uVar4);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          int_value \u003d __aeabi_d2iz(uVar4,extraout_r1_01);\n          if (int_value \u003d\u003d 0x398) {\n            non_modal_action \u003d \u0027\\a\u0027;\n          }\n          else if (int_value \u003d\u003d 0x399) {\n            non_modal_action \u003d \u0027\\b\u0027;\n          }\n          else {\n            gc.status_code \u003d \u0027\\x03\u0027;\n          }\n          break;\n        case 0x5d:\n          gc.inverse_feed_rate_mode \u003d \u0027\\x01\u0027;\n          break;\n        case 0x5e:\n          gc.inverse_feed_rate_mode \u003d \u0027\\0\u0027;\n        }\n      }\n      else if (letter \u003d\u003d \u0027M\u0027) {\n        if (int_value \u003d\u003d 0x1e) {\nLAB_08000b96:\n          group_number \u003d \u0027\\x05\u0027;\n        }\n        else if (int_value \u003c 0x1f) {\n          if (int_value \u003c 3) {\n            if (-1 \u003c int_value) goto LAB_08000b96;\n          }\n          else if (int_value - 3U \u003c 3) {\n            group_number \u003d \u0027\\b\u0027;\n          }\n        }\n        switch(int_value) {\n        case 0:\n          gc.program_flow \u003d \u0027\\x01\u0027;\n          break;\n        case 1:\n          break;\n        case 2:\n        case 0x1e:\n          gc.program_flow \u003d \u0027\\x02\u0027;\n          break;\n        case 3:\n          gc.spindle_direction \u003d \u0027\\x01\u0027;\n          break;\n        case 4:\n          gc.spindle_direction \u003d -1;\n          break;\n        case 5:\n          gc.spindle_direction \u003d \u0027\\0\u0027;\n          break;\n        default:\n          gc.status_code \u003d \u0027\\x03\u0027;\n          break;\n        case 7:\n          gc.coolant_mode \u003d \u0027\\x02\u0027;\n          break;\n        case 8:\n          gc.coolant_mode \u003d \u0027\\x01\u0027;\n          break;\n        case 9:\n          gc.coolant_mode \u003d \u0027\\0\u0027;\n        }\n      }\n      if (group_number !\u003d \u0027\\0\u0027) {\n        if (((int)(uint)modal_group_words \u003e\u003e group_number \u0026 1U) \u003d\u003d 0) {\n          modal_group_words \u003d modal_group_words | (ushort)(1 \u003c\u003c group_number);\n        }\n        else {\n          gc.status_code \u003d \u0027\\x05\u0027;\n        }\n        group_number \u003d \u0027\\0\u0027;\n      }\n    }\n    uVar1 \u003d gc.status_code;\n    if (gc.status_code \u003d\u003d \u0027\\0\u0027) {\n      p \u003d 0.0;\n      r \u003d 0.0;\n      l \u003d \u0027\\0\u0027;\n      char_counter \u003d \u0027\\0\u0027;\nswitchD_08000d18_caseD_47:\n      iVar2 \u003d next_statement(\u0026letter,\u0026value,line,\u0026char_counter);\n      if (iVar2 !\u003d 0) {\n        fVar7 \u003d (float)extraout_d0;\n        switch(letter) {\n        case \u0027F\u0027:\n          iVar2 \u003d __aeabi_fcmple(value,0);\n          if (iVar2 !\u003d 0) {\n            gc.status_code \u003d \u0027\\x06\u0027;\n          }\n          if (gc.inverse_feed_rate_mode \u003d\u003d \u0027\\0\u0027) {\n            fVar7 \u003d value;\n            to_millimeters(value_00);\n            gc.feed_rate \u003d fVar7;\n          }\n          else {\n            fVar7 \u003d value;\n            to_millimeters(value_00);\n            inverse_feed_rate \u003d fVar7;\n          }\n          break;\n        case \u0027G\u0027:\n        case \u0027M\u0027:\n        case \u0027N\u0027:\n          break;\n        default:\n          gc.status_code \u003d \u0027\\x03\u0027;\n          break;\n        case \u0027I\u0027:\n        case \u0027J\u0027:\n        case \u0027K\u0027:\n          uVar6 \u003d (uint)(byte)letter;\n          fVar3 \u003d value;\n          to_millimeters(fVar7);\n          offset[uVar6 - 0x49] \u003d fVar3;\n          break;\n        case \u0027L\u0027:\n          uVar4 \u003d __aeabi_f2d(value);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          l \u003d __aeabi_d2uiz(uVar4,extraout_r1_02);\n          break;\n        case \u0027P\u0027:\n          p \u003d value;\n          break;\n        case \u0027R\u0027:\n          fVar3 \u003d value;\n          to_millimeters(fVar7);\n          r \u003d fVar3;\n          break;\n        case \u0027S\u0027:\n          iVar2 \u003d __aeabi_fcmplt(value,0);\n          if (iVar2 !\u003d 0) {\n            gc.status_code \u003d \u0027\\x06\u0027;\n          }\n          break;\n        case \u0027T\u0027:\n          iVar2 \u003d __aeabi_fcmplt(value,0);\n          if (iVar2 !\u003d 0) {\n            gc.status_code \u003d \u0027\\x06\u0027;\n          }\n          uVar4 \u003d __aeabi_f2d(value);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          gc.tool \u003d __aeabi_d2uiz(uVar4,extraout_r1_03);\n          break;\n        case \u0027X\u0027:\n          target[0] \u003d value;\n          to_millimeters(fVar7);\n          axis_words \u003d axis_words | 1;\n          break;\n        case \u0027Y\u0027:\n          target[1] \u003d value;\n          to_millimeters(fVar7);\n          axis_words \u003d axis_words | 2;\n          break;\n        case \u0027Z\u0027:\n          target[2] \u003d value;\n          to_millimeters(fVar7);\n          axis_words \u003d axis_words | 4;\n        }\n        goto switchD_08000d18_caseD_47;\n      }\n      uVar1 \u003d gc.status_code;\n      if (gc.status_code \u003d\u003d \u0027\\0\u0027) {\n        uVar8 \u003d extraout_d0;\n        fVar7 \u003d extraout_s2;\n        fVar3 \u003d extraout_s3;\n        if (sys.state !\u003d \u0027\\a\u0027) {\n          spindle_run(gc.spindle_direction);\n          coolant_run(gc.coolant_mode);\n          uVar8 \u003d extraout_d0_00;\n          fVar7 \u003d extraout_s2_00;\n          fVar3 \u003d extraout_s3_00;\n        }\n        if ((modal_group_words \u0026 0x200) !\u003d 0) {\n          uVar1 \u003d settings_read_coord_data(gc.coord_select,coord_data);\n          if (uVar1 \u003d\u003d \u0027\\0\u0027) {\n            return \u0027\\n\u0027;\n          }\n          gc.coord_system[0] \u003d coord_data[0];\n          gc.coord_system[1] \u003d coord_data[1];\n          gc.coord_system[2] \u003d coord_data[2];\n          uVar8 \u003d extraout_d0_01;\n          fVar7 \u003d extraout_s2_01;\n          fVar3 \u003d extraout_s3_01;\n        }\n        switch(non_modal_action) {\n        case \u0027\\x01\u0027:\n          iVar2 \u003d __aeabi_fcmplt(p,0);\n          uVar8 \u003d extraout_d0_02;\n          fVar7 \u003d extraout_s2_02;\n          fVar3 \u003d extraout_s3_02;\n          if (iVar2 \u003d\u003d 0) {\n            if (sys.state !\u003d \u0027\\a\u0027) {\n              mc_dwell((float)extraout_d0_02);\n              uVar8 \u003d extraout_d0_03;\n              fVar7 \u003d extraout_s2_03;\n              fVar3 \u003d extraout_s3_03;\n            }\n          }\n          else {\n            gc.status_code \u003d \u0027\\x06\u0027;\n          }\n          break;\n        case \u0027\\x02\u0027:\n          uVar4 \u003d __aeabi_f2d(p);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          int_value \u003d __aeabi_d2iz(uVar4,extraout_r1_04);\n          uVar8 \u003d extraout_d0_04;\n          fVar7 \u003d extraout_s2_04;\n          fVar3 \u003d extraout_s3_04;\n          if ((((l \u003d\u003d \u0027\\x02\u0027) || (l \u003d\u003d \u0027\\x14\u0027)) \u0026\u0026 (-1 \u003c int_value)) \u0026\u0026 (int_value \u003c 7)) {\n            if ((axis_words \u003d\u003d \u0027\\0\u0027) \u0026\u0026 (l \u003d\u003d \u0027\\x02\u0027)) {\n              gc.status_code \u003d \u0027\\x06\u0027;\n            }\n            else {\n              if (int_value \u003c 1) {\n                int_value \u003d (int)gc.coord_select;\n              }\n              else {\n                int_value \u003d int_value + -1;\n              }\n              uVar1 \u003d settings_read_coord_data((uint8_t)int_value,coord_data_2);\n              if (uVar1 \u003d\u003d \u0027\\0\u0027) {\n                return \u0027\\n\u0027;\n              }\n              for (i \u003d \u0027\\0\u0027; i \u003c 3; i \u003d i + \u0027\\x01\u0027) {\n                if (((int)(uint)axis_words \u003e\u003e i \u0026 1U) !\u003d 0) {\n                  if (l \u003d\u003d \u0027\\x14\u0027) {\n                    uVar6 \u003d (uint)i;\n                    fVar7 \u003d (float)__aeabi_fsub(gc.position[i],target[i]);\n                    coord_data_2[uVar6] \u003d fVar7;\n                  }\n                  else {\n                    coord_data_2[i] \u003d target[i];\n                  }\n                }\n              }\n              settings_write_coord_data((uint8_t)int_value,coord_data_2);\n              uVar8 \u003d extraout_d0_05;\n              fVar7 \u003d extraout_s2_05;\n              fVar3 \u003d extraout_s3_05;\n              if (int_value \u003d\u003d (uint)gc.coord_select) {\n                gc.coord_system[0] \u003d coord_data_2[0];\n                gc.coord_system[1] \u003d coord_data_2[1];\n                gc.coord_system[2] \u003d coord_data_2[2];\n              }\n            }\n          }\n          else {\n            gc.status_code \u003d \u0027\\x03\u0027;\n          }\n          axis_words \u003d \u0027\\0\u0027;\n          break;\n        case \u0027\\x03\u0027:\n        case \u0027\\x05\u0027:\n          if (axis_words !\u003d \u0027\\0\u0027) {\n            for (i_1 \u003d \u0027\\0\u0027; i_1 \u003c 3; i_1 \u003d i_1 + \u0027\\x01\u0027) {\n              if (((int)(uint)axis_words \u003e\u003e i_1 \u0026 1U) \u003d\u003d 0) {\n                target[i_1] \u003d gc.position[i_1];\n              }\n              else if (gc.absolute_mode \u003d\u003d \u0027\\0\u0027) {\n                uVar6 \u003d (uint)i_1;\n                fVar7 \u003d (float)__addsf3(target[i_1],gc.position[i_1]);\n                target[uVar6] \u003d fVar7;\n                uVar8 \u003d extraout_d0_07;\n                fVar7 \u003d extraout_s2_07;\n                fVar3 \u003d extraout_s3_07;\n              }\n              else {\n                fVar7 \u003d target[i_1];\n                uVar4 \u003d __addsf3(gc.coord_system[i_1],gc.coord_offset[i_1]);\n                uVar6 \u003d (uint)i_1;\n                fVar7 \u003d (float)__addsf3(fVar7,uVar4);\n                target[uVar6] \u003d fVar7;\n                uVar8 \u003d extraout_d0_06;\n                fVar7 \u003d extraout_s2_06;\n                fVar3 \u003d extraout_s3_06;\n              }\n            }\n            mc_line((float)uVar8,(float)((ulonglong)uVar8 \u003e\u003e 0x20),fVar7,fVar3,SUB41(target[0],0));\n          }\n          if (non_modal_action \u003d\u003d \u0027\\x05\u0027) {\n            uVar1 \u003d settings_read_coord_data(\u0027\\a\u0027,coord_data_1);\n            uVar8 \u003d extraout_d0_08;\n            fVar7 \u003d extraout_s2_08;\n            fVar3 \u003d extraout_s3_08;\n            if (uVar1 \u003d\u003d \u0027\\0\u0027) {\n              return \u0027\\n\u0027;\n            }\n          }\n          else {\n            uVar1 \u003d settings_read_coord_data(\u0027\\x06\u0027,coord_data_1);\n            uVar8 \u003d extraout_d0_09;\n            fVar7 \u003d extraout_s2_09;\n            fVar3 \u003d extraout_s3_09;\n            if (uVar1 \u003d\u003d \u0027\\0\u0027) {\n              return \u0027\\n\u0027;\n            }\n          }\n          in_stack_ffffff48 \u003d 0;\n          mc_line((float)uVar8,(float)((ulonglong)uVar8 \u003e\u003e 0x20),fVar7,fVar3,\n                  SUB41(coord_data_1[0],0));\n          gc.position[0] \u003d coord_data_1[0];\n          gc.position[1] \u003d coord_data_1[1];\n          gc.position[2] \u003d coord_data_1[2];\n          axis_words \u003d \u0027\\0\u0027;\n          uVar8 \u003d extraout_d0_10;\n          fVar7 \u003d extraout_s2_10;\n          fVar3 \u003d extraout_s3_10;\n          break;\n        case \u0027\\x04\u0027:\n        case \u0027\\x06\u0027:\n          if (non_modal_action \u003d\u003d \u0027\\x06\u0027) {\n            settings_write_coord_data(\u0027\\a\u0027,gc.position);\n            uVar8 \u003d extraout_d0_11;\n            fVar7 \u003d extraout_s2_11;\n            fVar3 \u003d extraout_s3_11;\n          }\n          else {\n            settings_write_coord_data(\u0027\\x06\u0027,gc.position);\n            uVar8 \u003d extraout_d0_12;\n            fVar7 \u003d extraout_s2_12;\n            fVar3 \u003d extraout_s3_12;\n          }\n          break;\n        case \u0027\\a\u0027:\n          if (axis_words \u003d\u003d \u0027\\0\u0027) {\n            gc.status_code \u003d \u0027\\x06\u0027;\n          }\n          else {\n            for (i_2 \u003d \u0027\\0\u0027; i_2 \u003c 3; i_2 \u003d i_2 + \u0027\\x01\u0027) {\n              if (((int)(uint)axis_words \u003e\u003e i_2 \u0026 1U) !\u003d 0) {\n                uVar4 \u003d __aeabi_fsub(gc.position[i_2],gc.coord_system[i_2]);\n                uVar6 \u003d (uint)i_2;\n                fVar7 \u003d (float)__aeabi_fsub(uVar4,target[i_2]);\n                gc.coord_offset[uVar6] \u003d fVar7;\n                uVar8 \u003d extraout_d0_13;\n                fVar7 \u003d extraout_s2_13;\n                fVar3 \u003d extraout_s3_13;\n              }\n            }\n          }\n          axis_words \u003d \u0027\\0\u0027;\n          break;\n        case \u0027\\b\u0027:\n          memset(gc.coord_offset,0,0xc);\n          uVar8 \u003d extraout_d0_14;\n          fVar7 \u003d extraout_s2_14;\n          fVar3 \u003d extraout_s3_14;\n        }\n        if (((modal_group_words \u0026 4) !\u003d 0) || (axis_words !\u003d \u0027\\0\u0027)) {\n          if ((gc.inverse_feed_rate_mode !\u003d \u0027\\0\u0027) \u0026\u0026\n             ((iVar2 \u003d __aeabi_fcmplt(inverse_feed_rate,0), uVar8 \u003d extraout_d0_15,\n              fVar7 \u003d extraout_s2_15, fVar3 \u003d extraout_s3_15, iVar2 !\u003d 0 \u0026\u0026\n              (gc.motion_mode !\u003d \u0027\\x04\u0027)))) {\n            gc.status_code \u003d \u0027\\x06\u0027;\n          }\n          if (((absolute_override !\u003d \u0027\\0\u0027) \u0026\u0026 (gc.motion_mode !\u003d \u0027\\0\u0027)) \u0026\u0026\n             (gc.motion_mode !\u003d \u0027\\x01\u0027)) {\n            gc.status_code \u003d \u0027\\x06\u0027;\n          }\n          if (gc.status_code !\u003d \u0027\\0\u0027) {\n            return gc.status_code;\n          }\n          for (i_3 \u003d \u0027\\0\u0027; i_3 \u003c 3; i_3 \u003d i_3 + \u0027\\x01\u0027) {\n            if (((int)(uint)axis_words \u003e\u003e i_3 \u0026 1U) \u003d\u003d 0) {\n              target[i_3] \u003d gc.position[i_3];\n            }\n            else if (absolute_override \u003d\u003d \u0027\\0\u0027) {\n              if (gc.absolute_mode \u003d\u003d \u0027\\0\u0027) {\n                uVar6 \u003d (uint)i_3;\n                fVar7 \u003d (float)__addsf3(target[i_3],gc.position[i_3]);\n                target[uVar6] \u003d fVar7;\n                uVar8 \u003d extraout_d0_17;\n                fVar7 \u003d extraout_s2_17;\n                fVar3 \u003d extraout_s3_17;\n              }\n              else {\n                fVar7 \u003d target[i_3];\n                uVar4 \u003d __addsf3(gc.coord_system[i_3],gc.coord_offset[i_3]);\n                uVar6 \u003d (uint)i_3;\n                fVar7 \u003d (float)__addsf3(fVar7,uVar4);\n                target[uVar6] \u003d fVar7;\n                uVar8 \u003d extraout_d0_16;\n                fVar7 \u003d extraout_s2_16;\n                fVar3 \u003d extraout_s3_16;\n              }\n            }\n          }\n          if (gc.motion_mode \u003c 5) {\n            y_00 \u003d (float)((ulonglong)uVar8 \u003e\u003e 0x20);\n            switch(gc.motion_mode) {\n            case \u0027\\0\u0027:\n              if (axis_words \u003d\u003d \u0027\\0\u0027) {\n                gc.status_code \u003d \u0027\\x06\u0027;\n              }\n              else {\n                mc_line((float)uVar8,y_00,fVar7,fVar3,SUB41(target[0],0));\n              }\n              break;\n            case \u0027\\x01\u0027:\n              if (axis_words \u003d\u003d \u0027\\0\u0027) {\n                gc.status_code \u003d \u0027\\x06\u0027;\n              }\n              else {\n                mc_line((float)uVar8,y_00,fVar7,fVar3,SUB41(target[0],0));\n              }\n              break;\n            default:\n              axis_words \u003d axis_words \u0026 ~(byte)(1 \u003c\u003c gc.plane_axis_2);\n              if ((axis_words \u003d\u003d 0) ||\n                 (((iVar2 \u003d __aeabi_fcmpeq(r,0), iVar2 !\u003d 0 \u0026\u0026\n                   (iVar2 \u003d __aeabi_fcmpeq(offset[gc.plane_axis_0],0), iVar2 !\u003d 0)) \u0026\u0026\n                  (iVar2 \u003d __aeabi_fcmpeq(offset[gc.plane_axis_1],0), iVar2 !\u003d 0)))) {\n                gc.status_code \u003d \u0027\\x06\u0027;\n              }\n              else {\n                iVar2 \u003d __aeabi_fcmpeq(r,0);\n                if (iVar2 \u003d\u003d 0) {\n                  x \u003d (float)__aeabi_fsub(target[gc.plane_axis_0],gc.position[gc.plane_axis_0]);\n                  y \u003d (float)__aeabi_fsub(target[gc.plane_axis_1],gc.position[gc.plane_axis_1]);\n                  memset(offset,0,0xc);\n                  uVar4 \u003d __aeabi_fmul(r,0x40800000);\n                  uVar4 \u003d __aeabi_fmul(uVar4,r);\n                  uVar5 \u003d __aeabi_fmul(x,x);\n                  uVar4 \u003d __aeabi_fsub(uVar4,uVar5);\n                  uVar5 \u003d __aeabi_fmul(y,y);\n                  h_x2_div_d \u003d (float)__aeabi_fsub(uVar4,uVar5);\n                  iVar2 \u003d __aeabi_fcmplt(h_x2_div_d,0);\n                  if (iVar2 !\u003d 0) {\n                    gc.status_code \u003d \u0027\\x04\u0027;\n                    return \u0027\\x04\u0027;\n                  }\n                  uVar4 \u003d __aeabi_f2d(h_x2_div_d);\n                  sqrt((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n                  uVar5 \u003d __aeabi_f2d(x);\n                  __aeabi_f2d(y);\n                  hypot((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48),\n                        (double)CONCAT44(in_stack_ffffff54,in_stack_ffffff50));\n                  uVar8 \u003d __divdf3(uVar4,extraout_r1_05 ^ 0x80000000,uVar5,extraout_r1_06);\n                  h_x2_div_d \u003d (float)__truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20));\n                  if (gc.motion_mode \u003d\u003d \u0027\\x03\u0027) {\n                    h_x2_div_d \u003d (float)((uint)h_x2_div_d ^ 0x80000000);\n                  }\n                  iVar2 \u003d __aeabi_fcmplt(r,0);\n                  if (iVar2 !\u003d 0) {\n                    h_x2_div_d \u003d (float)((uint)h_x2_div_d ^ 0x80000000);\n                    r \u003d (float)((uint)r ^ 0x80000000);\n                  }\n                  uVar4 \u003d __aeabi_fmul(y,h_x2_div_d);\n                  uVar4 \u003d __aeabi_fsub(x,uVar4);\n                  uVar6 \u003d (uint)gc.plane_axis_0;\n                  fVar7 \u003d (float)__aeabi_fmul(uVar4,0x3f000000);\n                  offset[uVar6] \u003d fVar7;\n                  uVar4 \u003d __aeabi_fmul(x,h_x2_div_d);\n                  uVar4 \u003d __addsf3(uVar4,y);\n                  uVar6 \u003d (uint)gc.plane_axis_1;\n                  fVar7 \u003d (float)__aeabi_fmul(uVar4,0x3f000000);\n                  offset[uVar6] \u003d fVar7;\n                  uVar8 \u003d extraout_d0_18;\n                }\n                else {\n                  uVar4 \u003d __aeabi_f2d(offset[gc.plane_axis_0]);\n                  __aeabi_f2d(offset[gc.plane_axis_1]);\n                  hypot((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48),\n                        (double)CONCAT44(in_stack_ffffff54,in_stack_ffffff50));\n                  r \u003d (float)__truncdfsf2(uVar4,extraout_r1_07);\n                  uVar8 \u003d extraout_d0_19;\n                }\n                isclockwise \u003d gc.motion_mode \u003d\u003d \u0027\\x02\u0027;\n                fVar7 \u003d inverse_feed_rate;\n                if (gc.inverse_feed_rate_mode \u003d\u003d \u0027\\0\u0027) {\n                  fVar7 \u003d gc.feed_rate;\n                }\n                mc_arc(gc.position,target,offset,gc.plane_axis_0,gc.plane_axis_1,gc.plane_axis_2,\n                       (float)uVar8,SUB41(fVar7,0),(float)((ulonglong)uVar8 \u003e\u003e 0x20),\n                       gc.inverse_feed_rate_mode);\n              }\n              break;\n            case \u0027\\x04\u0027:\n              if (axis_words !\u003d \u0027\\0\u0027) {\n                gc.status_code \u003d \u0027\\x06\u0027;\n              }\n            }\n          }\n          if (gc.status_code !\u003d \u0027\\0\u0027) {\n            return gc.status_code;\n          }\n          gc.position[0] \u003d target[0];\n          gc.position[1] \u003d target[1];\n          gc.position[2] \u003d target[2];\n        }\n        uVar1 \u003d gc.status_code;\n        if (gc.program_flow !\u003d \u0027\\0\u0027) {\n          plan_synchronize();\n          sys.auto_start \u003d \u0027\\0\u0027;\n          if (gc.program_flow \u003d\u003d \u0027\\x02\u0027) {\n            mc_reset();\n            uVar1 \u003d gc.status_code;\n          }\n          else {\n            gc.program_flow \u003d \u0027\\0\u0027;\n            uVar1 \u003d gc.status_code;\n          }\n        }\n      }\n    }\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_execute_line",
        "protocol_execute_startup"
      ],
      "called": [
        "__truncdfsf2",
        "coolant_run",
        "to_millimeters",
        "mc_reset",
        "__aeabi_d2iz",
        "__aeabi_fsub",
        "select_plane",
        "trunc",
        "__divdf3",
        "__aeabi_d2uiz",
        "hypot",
        "mc_line",
        "spindle_run",
        "next_statement",
        "__aeabi_fcmpeq",
        "__addsf3",
        "plan_synchronize",
        "__aeabi_f2d",
        "memset",
        "__aeabi_fcmple",
        "mc_dwell",
        "mc_arc",
        "settings_read_coord_data",
        "settings_write_coord_data",
        "sqrt",
        "__aeabi_fmul",
        "__aeabi_fcmplt"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "next_statement": {
      "entrypoint": "0x0800184c",
      "current_name": "next_statement",
      "code": "\nint next_statement(char *letter,float *float_ptr,char *line,uint8_t *char_counter)\n\n{\n  int iVar1;\n  uint8_t *char_counter_local;\n  char *line_local;\n  float *float_ptr_local;\n  char *letter_local;\n  \n  if (line[*char_counter] \u003d\u003d \u0027\\0\u0027) {\n    iVar1 \u003d 0;\n  }\n  else {\n    *letter \u003d line[*char_counter];\n    if (((byte)*letter \u003c 0x41) || (0x5a \u003c (byte)*letter)) {\n      gc.status_code \u003d \u0027\\x02\u0027;\n      iVar1 \u003d 0;\n    }\n    else {\n      *char_counter \u003d *char_counter + \u0027\\x01\u0027;\n      iVar1 \u003d read_float(line,char_counter,float_ptr);\n      if (iVar1 \u003d\u003d 0) {\n        gc.status_code \u003d \u0027\\x01\u0027;\n        iVar1 \u003d 0;\n      }\n      else {\n        iVar1 \u003d 1;\n      }\n    }\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line"
      ],
      "called": [
        "read_float"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "step_wr": {
      "entrypoint": "0x080052ac",
      "current_name": "step_wr",
      "code": "\n\n\nvoid step_wr(uint32_t x)\n\n{\n  uint32_t x_local;\n  uint32_t val;\n  \n  _DAT_40021014 \u003d x | _DAT_40021014 \u0026 0xfffffaaf;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "st_init",
        "step_pulse_isr",
        "step_delay_isr"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "dirn_wr": {
      "entrypoint": "0x080052dc",
      "current_name": "dirn_wr",
      "code": "\n\n\nvoid dirn_wr(uint32_t x)\n\n{\n  uint32_t x_local;\n  uint32_t val;\n  \n  _DAT_40021014 \u003d x | _DAT_40021014 \u0026 0xfffff55f;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "step_period_isr"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "limits_init": {
      "entrypoint": "0x0800192c",
      "current_name": "limits_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid limits_init(void)\n\n{\n  limits_enabled \u003d (int)((settings.flags \u0026 8) !\u003d 0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "settings_store_global_setting",
        "grbl_main"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "limits_isr": {
      "entrypoint": "0x0800195c",
      "current_name": "limits_isr",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid limits_isr(void)\n\n{\n  if ((sys.state !\u003d \u0027\\x06\u0027) \u0026\u0026 ((sys.execute \u0026 0x20) \u003d\u003d 0)) {\n    mc_reset();\n    sys.execute \u003d sys.execute | 0x40;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "debounce_on_handler"
      ],
      "called": [
        "mc_reset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "homing_cycle": {
      "entrypoint": "0x08001994",
      "current_name": "homing_cycle",
      "code": "\n/* WARNING: Variable defined which should be unmapped: homing_rate-local */\n\nvoid homing_cycle(uint8_t cycle_mask,int8_t pos_dir,_Bool invert_pin,float homing_rate)\n\n{\n  bool bVar1;\n  uint16_t uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  int iVar5;\n  uint uVar6;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  uint32_t uVar7;\n  undefined4 in_r3;\n  uint32_t uVar8;\n  undefined8 uVar9;\n  float homing_rate_local;\n  undefined uStack_64;\n  _Bool invert_pin_local;\n  int8_t pos_dir_local;\n  uint8_t cycle_mask_local;\n  uint32_t steps [3];\n  uint16_t step_bits0;\n  uint32_t dt_min;\n  uint32_t delta_rate;\n  float ds;\n  uint32_t step_event_count;\n  uint32_t limit_state;\n  uint16_t step_bits;\n  uint32_t trap_counter;\n  uint32_t step_rate;\n  uint32_t step_delay;\n  int32_t counter_z;\n  int32_t counter_y;\n  int32_t counter_x;\n  uint16_t dirn_bits;\n  uint32_t dt;\n  uint8_t dist;\n  \n  bVar1 \u003d !invert_pin;\n  memset(steps,0,0xc);\n  dist \u003d (cycle_mask \u0026 1) !\u003d 0;\n  if ((bool)dist) {\n    __aeabi_f2d(settings.steps_per_mm[0]);\n    steps[0] \u003d lround((double)CONCAT17(cycle_mask,\n                                       CONCAT16(pos_dir,CONCAT15(bVar1,CONCAT14(uStack_64,in_r3)))))\n    ;\n  }\n  if ((cycle_mask \u0026 2) !\u003d 0) {\n    dist \u003d dist + \u0027\\x01\u0027;\n    __aeabi_f2d(settings.steps_per_mm[1]);\n    steps[1] \u003d lround((double)CONCAT17(cycle_mask,\n                                       CONCAT16(pos_dir,CONCAT15(bVar1,CONCAT14(uStack_64,in_r3)))))\n    ;\n  }\n  if ((cycle_mask \u0026 4) !\u003d 0) {\n    dist \u003d dist + \u0027\\x01\u0027;\n    __aeabi_f2d(settings.steps_per_mm[2]);\n    steps[2] \u003d lround((double)CONCAT17(cycle_mask,\n                                       CONCAT16(pos_dir,CONCAT15(bVar1,CONCAT14(uStack_64,in_r3)))))\n    ;\n  }\n  uVar7 \u003d steps[2];\n  if (steps[2] \u003c steps[1]) {\n    uVar7 \u003d steps[1];\n  }\n  uVar8 \u003d steps[0];\n  if (steps[0] \u003c uVar7) {\n    uVar8 \u003d uVar7;\n  }\n  uVar9 \u003d __floatunsidf(uVar8);\n  uVar3 \u003d __floatunsidf(dist);\n  sqrt((double)CONCAT17(cycle_mask,CONCAT16(pos_dir,CONCAT15(bVar1,CONCAT14(uStack_64,in_r3)))));\n  uVar9 \u003d __divdf3((int)uVar9,(int)((ulonglong)uVar9 \u003e\u003e 0x20),uVar3,extraout_r1);\n  uVar3 \u003d __truncdfsf2((int)uVar9,(int)((ulonglong)uVar9 \u003e\u003e 0x20));\n  uVar4 \u003d __aeabi_fmul(settings.acceleration,uVar3);\n  uVar4 \u003d __aeabi_fdiv(uVar4,0x453b8000);\n  uVar4 \u003d __aeabi_f2d(uVar4);\n  ceil((double)CONCAT17(cycle_mask,CONCAT16(pos_dir,CONCAT15(bVar1,CONCAT14(uStack_64,in_r3)))));\n  iVar5 \u003d __aeabi_d2uiz(uVar4,extraout_r1_00);\n  uVar4 \u003d __floatunsidf(dist);\n  sqrt((double)CONCAT17(cycle_mask,CONCAT16(pos_dir,CONCAT15(bVar1,CONCAT14(uStack_64,in_r3)))));\n  uVar9 \u003d __aeabi_f2d(in_r3);\n  uVar9 \u003d __muldf3(uVar4,extraout_r1_01,(int)uVar9,(int)((ulonglong)uVar9 \u003e\u003e 0x20));\n  uVar4 \u003d __truncdfsf2((int)uVar9,(int)((ulonglong)uVar9 \u003e\u003e 0x20));\n  uVar3 \u003d __aeabi_fmul(uVar3,uVar4);\n  uVar3 \u003d __aeabi_fdiv(0x4c64e1c0,uVar3);\n  __aeabi_f2d(uVar3);\n  uVar6 \u003d lround((double)CONCAT17(cycle_mask,\n                                  CONCAT16(pos_dir,CONCAT15(bVar1,CONCAT14(uStack_64,uVar4)))));\n  uVar2 \u003d settings.step_invert_mask;\n  dt \u003d 75000;\n  if (uVar6 \u003c 75000) {\n    dt \u003d uVar6;\n  }\n  dirn_bits \u003d settings.dirn_invert_mask ^ settings.homing_dir_mask \u0026 0xaa0;\n  if (pos_dir \u003d\u003d \u0027\\0\u0027) {\n    dirn_bits \u003d dirn_bits ^ 0xaa0;\n  }\n  dirn_wr((uint)dirn_bits);\n  step_wr((uint)uVar2);\n  counter_z \u003d -(uVar8 \u003e\u003e 1);\n  step_delay \u003d dt - settings.pulse_microseconds;\n  step_rate \u003d 0;\n  trap_counter \u003d 10000;\n  cycle_mask_local \u003d cycle_mask;\n  counter_y \u003d counter_z;\n  counter_x \u003d counter_z;\n  while( true ) {\n    step_bits \u003d uVar2;\n    limit_state \u003d debounce_rd();\n    if (bVar1) {\n      limit_state \u003d limit_state ^ 0x1e;\n    }\n    if (((cycle_mask_local \u0026 1) !\u003d 0) \u0026\u0026 (counter_x \u003d counter_x + steps[0], 0 \u003c counter_x)) {\n      if ((limit_state \u0026 0x10) \u003d\u003d 0) {\n        cycle_mask_local \u003d cycle_mask_local \u0026 0xfe;\n      }\n      else {\n        step_bits \u003d uVar2 ^ 0x10;\n      }\n      counter_x \u003d counter_x - uVar8;\n    }\n    if (((cycle_mask_local \u0026 2) !\u003d 0) \u0026\u0026 (counter_y \u003d counter_y + steps[1], 0 \u003c counter_y)) {\n      if ((limit_state \u0026 8) \u003d\u003d 0) {\n        cycle_mask_local \u003d cycle_mask_local \u0026 0xfd;\n      }\n      else {\n        step_bits \u003d step_bits ^ 0x440;\n      }\n      counter_y \u003d counter_y - uVar8;\n    }\n    if (((cycle_mask_local \u0026 4) !\u003d 0) \u0026\u0026 (counter_z \u003d counter_z + steps[2], 0 \u003c counter_z)) {\n      if ((limit_state \u0026 4) \u003d\u003d 0) {\n        cycle_mask_local \u003d cycle_mask_local \u0026 0xfb;\n      }\n      else {\n        step_bits \u003d step_bits ^ 0x100;\n      }\n      counter_z \u003d counter_z - uVar8;\n    }\n    if ((cycle_mask_local \u003d\u003d \u0027\\0\u0027) || ((sys.execute \u0026 0x10) !\u003d 0)) break;\n    step_wr((uint)step_bits);\n    delay_us((uint)settings.pulse_microseconds);\n    step_wr((uint)uVar2);\n    delay_us(step_delay);\n    if ((uVar6 \u003c dt) \u0026\u0026 (trap_counter \u003d dt + trap_counter, 20000 \u003c trap_counter)) {\n      trap_counter \u003d trap_counter - 20000;\n      step_rate \u003d iVar5 + step_rate;\n      dt \u003d 60000000 / step_rate;\n      if (60000000 / step_rate \u003c uVar6) {\n        dt \u003d uVar6;\n      }\n      step_delay \u003d dt - settings.pulse_microseconds;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "limits_go_home"
      ],
      "called": [
        "delay_us",
        "__truncdfsf2",
        "memset",
        "debounce_rd",
        "ceil",
        "__divdf3",
        "__aeabi_d2uiz",
        "dirn_wr",
        "sqrt",
        "step_wr",
        "__aeabi_fmul",
        "lround",
        "__aeabi_fdiv",
        "__floatunsidf",
        "__aeabi_f2d",
        "__muldf3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "limits_go_home": {
      "entrypoint": "0x08001d4c",
      "current_name": "limits_go_home",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid limits_go_home(void)\n\n{\n  char cVar1;\n  float homing_rate;\n  float homing_rate_00;\n  float extraout_s0;\n  float homing_rate_01;\n  float extraout_s0_00;\n  float homing_rate_02;\n  int8_t n_cycle;\n  \n  st_wake_up();\n  homing_cycle(\u0027\\x04\u0027,\u0027\\x01\u0027,false,homing_rate);\n  homing_cycle(\u0027\\x03\u0027,\u0027\\x01\u0027,false,homing_rate_00);\n  delay_ms(settings.homing_debounce_delay);\n  n_cycle \u003d \u0027\\x02\u0027;\n  homing_rate_02 \u003d extraout_s0;\n  while (cVar1 \u003d n_cycle + -1, n_cycle !\u003d \u0027\\0\u0027) {\n    homing_cycle(\u0027\\a\u0027,\u0027\\0\u0027,true,homing_rate_02);\n    delay_ms(settings.homing_debounce_delay);\n    homing_rate_02 \u003d homing_rate_01;\n    n_cycle \u003d cVar1;\n    if (\u0027\\0\u0027 \u003c cVar1) {\n      homing_cycle(\u0027\\a\u0027,\u0027\\x01\u0027,false,homing_rate_01);\n      delay_ms(settings.homing_debounce_delay);\n      homing_rate_02 \u003d extraout_s0_00;\n    }\n  }\n  st_go_idle();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "mc_go_home"
      ],
      "called": [
        "delay_ms",
        "homing_cycle",
        "st_go_idle",
        "st_wake_up"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "grbl_main": {
      "entrypoint": "0x08001ddc",
      "current_name": "grbl_main",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint grbl_main(void)\n\n{\n  serial_init();\n  settings_init();\n  st_init();\n  memset(\u0026sys,0,0x14);\n  sys.abort \u003d \u0027\\x01\u0027;\n  sys.state \u003d \u0027\\x01\u0027;\n  do {\n    if (sys.abort !\u003d \u0027\\0\u0027) {\n      serial_reset_read_buffer();\n      plan_init();\n      gc_init();\n      protocol_init();\n      spindle_init();\n      coolant_init();\n      limits_init();\n      st_reset();\n      sys_sync_current_position();\n      sys.abort \u003d \u0027\\0\u0027;\n      sys.execute \u003d \u0027\\0\u0027;\n      if ((settings.flags \u0026 2) !\u003d 0) {\n        sys.auto_start \u003d \u0027\\x01\u0027;\n      }\n      if ((sys.state \u003d\u003d \u0027\\x01\u0027) \u0026\u0026 ((settings.flags \u0026 0x10) !\u003d 0)) {\n        sys.state \u003d \u0027\\x06\u0027;\n      }\n      if (sys.state \u003d\u003d \u0027\\x06\u0027) {\n        report_feedback_message(\u0027\\x02\u0027);\n      }\n      else {\n        sys.state \u003d \u0027\\0\u0027;\n        protocol_execute_startup();\n      }\n    }\n    protocol_execute_runtime();\n    protocol_process();\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "st_init",
        "serial_reset_read_buffer",
        "sys_sync_current_position",
        "memset",
        "coolant_init",
        "limits_init",
        "st_reset",
        "settings_init",
        "spindle_init",
        "protocol_execute_startup",
        "serial_init",
        "plan_init",
        "protocol_process",
        "protocol_execute_runtime",
        "report_feedback_message",
        "protocol_init",
        "gc_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "mc_line": {
      "entrypoint": "0x08001e98",
      "current_name": "mc_line",
      "code": "\nvoid mc_line(float x,float y,float z,float feed_rate,uint8_t invert_feed_rate)\n\n{\n  uint8_t uVar1;\n  float x_00;\n  float y_00;\n  float z_00;\n  float feed_rate_00;\n  float feed_rate_local;\n  float z_local;\n  float y_local;\n  float x_local;\n  \n  if (sys.state !\u003d \u0027\\a\u0027) {\n    do {\n      protocol_execute_runtime();\n      if (sys.abort !\u003d \u0027\\0\u0027) {\n        return;\n      }\n      uVar1 \u003d plan_check_full_buffer();\n    } while (uVar1 !\u003d \u0027\\0\u0027);\n    plan_buffer_line(x_00,y_00,z_00,feed_rate_00,invert_feed_rate);\n    if (sys.state \u003d\u003d \u0027\\0\u0027) {\n      sys.state \u003d \u0027\\x02\u0027;\n    }\n    if (sys.auto_start !\u003d \u0027\\0\u0027) {\n      st_cycle_start();\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line",
        "mc_arc",
        "mc_go_home"
      ],
      "called": [
        "plan_buffer_line",
        "st_cycle_start",
        "plan_check_full_buffer",
        "protocol_execute_runtime"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "mc_arc": {
      "entrypoint": "0x08001f00",
      "current_name": "mc_arc",
      "code": "\n/* WARNING: Variable defined which should be unmapped: axis_0-local */\n\nvoid mc_arc(float *position,float *target,float *offset,uint8_t axis_0,uint8_t axis_1,\n           uint8_t axis_linear,float feed_rate,uint8_t invert_feed_rate,float radius,\n           uint8_t isclockwise)\n\n{\n  uint uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  int iVar6;\n  float fVar7;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined8 extraout_d0;\n  undefined8 extraout_d0_00;\n  undefined8 extraout_d0_01;\n  float extraout_s2;\n  float z;\n  float extraout_s2_00;\n  float extraout_s3;\n  float feed_rate_00;\n  float extraout_s3_00;\n  float feed_rate_01;\n  undefined8 uVar8;\n  undefined8 uVar9;\n  undefined3 in_stack_00000009;\n  undefined4 in_stack_00000010;\n  char in_stack_00000014;\n  uint in_stack_ffffff78;\n  undefined4 in_stack_ffffff7c;\n  undefined3 uStack_80;\n  uint8_t axis_0_local;\n  float *offset_local;\n  float *target_local;\n  float *position_local;\n  float arc_target [3];\n  float r_axisi;\n  float sin_Ti;\n  float cos_Ti;\n  float sin_T;\n  float cos_T;\n  float linear_per_segment;\n  float theta_per_segment;\n  uint16_t segments;\n  float millimeters_of_travel;\n  float rt_axis1;\n  float rt_axis0;\n  float linear_travel;\n  float center_axis1;\n  float center_axis0;\n  int8_t count;\n  uint16_t i;\n  float angular_travel;\n  float r_axis1;\n  float r_axis0;\n  \n  _uStack_80 \u003d CONCAT13(axis_0,uStack_80);\n  center_axis0 \u003d (float)__addsf3(feed_rate,position[axis_0],offset[axis_0]);\n  center_axis1 \u003d (float)__addsf3(position[axis_1],offset[axis_1]);\n  uVar1 \u003d __aeabi_fsub(target[axis_linear],position[axis_linear]);\n  r_axis0 \u003d (float)((uint)offset[axis_0] ^ 0x80000000);\n  r_axis1 \u003d (float)((uint)offset[axis_1] ^ 0x80000000);\n  uVar2 \u003d __aeabi_fsub(target[axis_0],center_axis0);\n  uVar3 \u003d __aeabi_fsub(target[axis_1],center_axis1);\n  uVar4 \u003d __aeabi_fmul(r_axis0,uVar3);\n  uVar5 \u003d __aeabi_fmul(r_axis1,uVar2);\n  uVar4 \u003d __aeabi_fsub(uVar4,uVar5);\n  uVar8 \u003d __aeabi_f2d(uVar4);\n  uVar2 \u003d __aeabi_fmul(r_axis0,uVar2);\n  uVar3 \u003d __aeabi_fmul(r_axis1,uVar3);\n  uVar2 \u003d __addsf3(uVar2,uVar3);\n  uVar9 \u003d __aeabi_f2d(uVar2);\n  uVar8 \u003d atan2((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),(int)uVar9,\n                (int)((ulonglong)uVar9 \u003e\u003e 0x20));\n  angular_travel \u003d (float)__truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20));\n  if (in_stack_00000014 \u003d\u003d \u0027\\0\u0027) {\n    iVar6 \u003d __aeabi_fcmple(angular_travel,0);\n    if (iVar6 !\u003d 0) {\n      uVar8 \u003d __aeabi_f2d(angular_travel);\n      uVar8 \u003d __aeabi_dadd((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),0x54442d18,0x401921fb);\n      angular_travel \u003d (float)__truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20));\n    }\n  }\n  else {\n    iVar6 \u003d __aeabi_fcmpge(angular_travel,0);\n    if (iVar6 !\u003d 0) {\n      uVar8 \u003d __aeabi_f2d(angular_travel);\n      uVar8 \u003d __subdf3((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),0x54442d18,0x401921fb);\n      angular_travel \u003d (float)__truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20));\n    }\n  }\n  uVar2 \u003d __aeabi_fmul(angular_travel,in_stack_00000010);\n  uVar2 \u003d __aeabi_f2d(uVar2);\n  __aeabi_f2d(uVar1 \u0026 0x7fffffff);\n  hypot((double)CONCAT44(in_stack_ffffff7c,in_stack_ffffff78),(double)CONCAT44(offset,_uStack_80));\n  uVar2 \u003d __truncdfsf2(uVar2,extraout_r1);\n  iVar6 \u003d __aeabi_fcmpeq(uVar2,0);\n  if (iVar6 \u003d\u003d 0) {\n    uVar2 \u003d __aeabi_fdiv(uVar2,settings.mm_per_arc_segment);\n    uVar2 \u003d __aeabi_f2d(uVar2);\n    floor((double)CONCAT44(in_stack_ffffff7c,in_stack_ffffff78));\n    segments \u003d __aeabi_d2uiz(uVar2,extraout_r1_00);\n    if (isclockwise !\u003d \u0027\\0\u0027) {\n      uVar2 \u003d __floatsisf(segments);\n      __aeabi_fmul(_invert_feed_rate,uVar2);\n    }\n    uVar2 \u003d __floatsisf(segments);\n    sin_T \u003d (float)__aeabi_fdiv(angular_travel,uVar2);\n    uVar2 \u003d __floatsisf(segments);\n    linear_per_segment \u003d (float)__aeabi_fdiv(uVar1,uVar2);\n    uVar8 \u003d __aeabi_f2d(sin_T);\n    uVar8 \u003d __muldf3((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),0,0x3fe00000);\n    uVar9 \u003d __aeabi_f2d(sin_T);\n    uVar8 \u003d __muldf3((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),(int)uVar9,\n                     (int)((ulonglong)uVar9 \u003e\u003e 0x20));\n    uVar8 \u003d __subdf3(0,0x3ff00000,(int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20));\n    cos_T \u003d (float)__truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20));\n    count \u003d \u0027\\0\u0027;\n    theta_per_segment \u003d sin_T;\n    arc_target[axis_linear] \u003d position[axis_linear];\n    uVar8 \u003d extraout_d0;\n    fVar7 \u003d extraout_s2;\n    feed_rate_01 \u003d extraout_s3;\n    for (i \u003d 1; i \u003c segments; i \u003d i + 1) {\n      if ((int)count \u003c (int)(uint)settings.n_arc_correction) {\n        uVar2 \u003d __aeabi_fmul(r_axis0,sin_T);\n        uVar3 \u003d __aeabi_fmul(r_axis1,cos_T);\n        fVar7 \u003d (float)__addsf3(uVar2,uVar3);\n        uVar2 \u003d __aeabi_fmul(r_axis0,cos_T);\n        uVar3 \u003d __aeabi_fmul(r_axis1,sin_T);\n        r_axis0 \u003d (float)__aeabi_fsub(uVar2,uVar3);\n        count \u003d count + \u0027\\x01\u0027;\n        r_axis1 \u003d fVar7;\n      }\n      else {\n        uVar2 \u003d __floatsisf(i);\n        uVar2 \u003d __aeabi_fmul(uVar2,theta_per_segment);\n        uVar2 \u003d __aeabi_f2d(uVar2);\n        cos((double)CONCAT44(in_stack_ffffff7c,in_stack_ffffff78));\n        uVar2 \u003d __truncdfsf2(uVar2,extraout_r1_01);\n        uVar3 \u003d __floatsisf(i);\n        uVar3 \u003d __aeabi_fmul(uVar3,theta_per_segment);\n        uVar3 \u003d __aeabi_f2d(uVar3);\n        sin((double)CONCAT44(in_stack_ffffff7c,in_stack_ffffff78));\n        uVar3 \u003d __truncdfsf2(uVar3,extraout_r1_02);\n        uVar4 \u003d __aeabi_fmul((uint)offset[axis_0] ^ 0x80000000,uVar2);\n        uVar5 \u003d __aeabi_fmul(offset[axis_1],uVar3);\n        r_axis0 \u003d (float)__addsf3(uVar4,uVar5);\n        uVar3 \u003d __aeabi_fmul((uint)offset[axis_0] ^ 0x80000000,uVar3);\n        uVar2 \u003d __aeabi_fmul(offset[axis_1],uVar2);\n        r_axis1 \u003d (float)__aeabi_fsub(uVar3,uVar2);\n        count \u003d \u0027\\0\u0027;\n      }\n      fVar7 \u003d (float)__addsf3(center_axis0,r_axis0);\n      arc_target[axis_0] \u003d fVar7;\n      fVar7 \u003d (float)__addsf3(center_axis1,r_axis1);\n      arc_target[axis_1] \u003d fVar7;\n      fVar7 \u003d (float)__addsf3(arc_target[axis_linear],linear_per_segment);\n      arc_target[axis_linear] \u003d fVar7;\n      in_stack_ffffff78 \u003d (uint)isclockwise;\n      mc_line((float)extraout_d0_00,(float)((ulonglong)extraout_d0_00 \u003e\u003e 0x20),z,feed_rate_00,\n              SUB41(arc_target[0],0));\n      if (sys.abort !\u003d \u0027\\0\u0027) {\n        return;\n      }\n      uVar8 \u003d extraout_d0_01;\n      fVar7 \u003d extraout_s2_00;\n      feed_rate_01 \u003d extraout_s3_00;\n    }\n    mc_line((float)uVar8,(float)((ulonglong)uVar8 \u003e\u003e 0x20),fVar7,feed_rate_01,SUB41(*target,0));\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line"
      ],
      "called": [
        "__floatsisf",
        "__truncdfsf2",
        "__aeabi_fcmple",
        "floor",
        "__aeabi_fcmpge",
        "cos",
        "__aeabi_dadd",
        "__aeabi_fsub",
        "sin",
        "hypot",
        "__aeabi_d2uiz",
        "mc_line",
        "__aeabi_fcmpeq",
        "__addsf3",
        "__aeabi_fmul",
        "atan2",
        "__aeabi_fdiv",
        "__aeabi_f2d",
        "__subdf3",
        "__muldf3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "mc_dwell": {
      "entrypoint": "0x08002408",
      "current_name": "mc_dwell",
      "code": "\n/* WARNING: Variable defined which should be unmapped: seconds-local */\n\nvoid mc_dwell(float seconds)\n\n{\n  uint16_t ms;\n  undefined4 in_r0;\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 uStack_20;\n  float seconds_local;\n  uint16_t i;\n  \n  uVar1 \u003d __aeabi_fmul(seconds,in_r0,0x41a00000);\n  uVar1 \u003d __aeabi_f2d(uVar1);\n  floor((double)CONCAT44(in_r0,uStack_20));\n  i \u003d __aeabi_d2uiz(uVar1,extraout_r1);\n  plan_synchronize();\n  uVar1 \u003d __aeabi_fmul(in_r0,0x447a0000);\n  uVar2 \u003d __floatsisf((uint)i * 0x32);\n  uVar1 \u003d __aeabi_fsub(uVar1,uVar2);\n  uVar1 \u003d __aeabi_f2d(uVar1);\n  floor((double)CONCAT44(in_r0,uStack_20));\n  ms \u003d __aeabi_d2uiz(uVar1,extraout_r1_00);\n  delay_ms(ms);\n  while ((i !\u003d 0 \u0026\u0026 (protocol_execute_runtime(), sys.abort \u003d\u003d \u0027\\0\u0027))) {\n    _delay_ms(0x32);\n    i \u003d i - 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line"
      ],
      "called": [
        "__aeabi_fsub",
        "__floatsisf",
        "delay_ms",
        "__aeabi_d2uiz",
        "__aeabi_fmul",
        "floor",
        "_delay_ms",
        "protocol_execute_runtime",
        "plan_synchronize",
        "__aeabi_f2d"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "mc_go_home": {
      "entrypoint": "0x080024c4",
      "current_name": "mc_go_home",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid mc_go_home(void)\n\n{\n  uint8_t invert_feed_rate;\n  undefined4 uVar1;\n  undefined8 uVar2;\n  float z;\n  float feed_rate;\n  int8_t z_dir;\n  int8_t y_dir;\n  int8_t x_dir;\n  \n  sys.state \u003d \u0027\\x05\u0027;\n  limits_enabled \u003d 0;\n  limits_go_home();\n  protocol_execute_runtime();\n  if (sys.abort \u003d\u003d \u0027\\0\u0027) {\n    memset(sys.position,0,0xc);\n    sys_sync_current_position();\n    sys.state \u003d \u0027\\0\u0027;\n    if ((settings.homing_dir_mask \u0026 0x20) \u003d\u003d 0) {\n      x_dir \u003d -1;\n    }\n    else {\n      x_dir \u003d \u0027\\x01\u0027;\n    }\n    if ((settings.homing_dir_mask \u0026 0x80) \u003d\u003d 0) {\n      y_dir \u003d -1;\n    }\n    else {\n      y_dir \u003d \u0027\\x01\u0027;\n    }\n    if ((settings.homing_dir_mask \u0026 0x200) \u003d\u003d 0) {\n      z_dir \u003d -1;\n    }\n    else {\n      z_dir \u003d \u0027\\x01\u0027;\n    }\n    uVar1 \u003d __floatsisf((int)x_dir);\n    invert_feed_rate \u003d __aeabi_fmul(uVar1,settings.homing_pulloff);\n    uVar1 \u003d __floatsisf((int)y_dir);\n    __aeabi_fmul(uVar1,settings.homing_pulloff);\n    uVar1 \u003d __floatsisf((int)z_dir);\n    uVar2 \u003d __aeabi_fmul(uVar1,settings.homing_pulloff);\n    mc_line((float)uVar2,(float)((ulonglong)uVar2 \u003e\u003e 0x20),z,feed_rate,invert_feed_rate);\n    st_cycle_start();\n    plan_synchronize();\n    sys_sync_current_position();\n    if ((settings.flags \u0026 8) !\u003d 0) {\n      limits_enabled \u003d 1;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_execute_line"
      ],
      "called": [
        "__floatsisf",
        "sys_sync_current_position",
        "mc_line",
        "memset",
        "st_cycle_start",
        "__aeabi_fmul",
        "protocol_execute_runtime",
        "plan_synchronize",
        "limits_go_home"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "mc_reset": {
      "entrypoint": "0x080025e8",
      "current_name": "mc_reset",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid mc_reset(void)\n\n{\n  if ((sys.execute \u0026 0x10) \u003d\u003d 0) {\n    sys.execute \u003d sys.execute | 0x10;\n    spindle_stop();\n    coolant_stop();\n    if (sys.state - 3 \u003c 3) {\n      sys.execute \u003d sys.execute | 0x20;\n      st_go_idle();\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line",
        "buttons_isr",
        "protocol_execute_line",
        "limits_isr",
        "serial_rx_hook"
      ],
      "called": [
        "coolant_stop",
        "st_go_idle",
        "spindle_stop"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "read_float": {
      "entrypoint": "0x08002638",
      "current_name": "read_float",
      "code": "\nint read_float(char *line,uint8_t *char_counter,float *float_ptr)\n\n{\n  byte bVar1;\n  bool bVar2;\n  bool bVar3;\n  uchar *puVar4;\n  uchar *puVar5;\n  int iVar6;\n  undefined8 uVar7;\n  float *float_ptr_local;\n  uint8_t *char_counter_local;\n  char *line_local;\n  float fval;\n  _Bool isdecimal;\n  uint8_t ndigit;\n  int8_t exp;\n  uint32_t intval;\n  _Bool isnegative;\n  uchar c;\n  char *ptr;\n  \n  puVar5 \u003d (uchar *)(line + *char_counter);\n  puVar4 \u003d puVar5 + 1;\n  c \u003d *puVar5;\n  bVar2 \u003d false;\n  if (c \u003d\u003d \u0027-\u0027) {\n    bVar2 \u003d true;\n    c \u003d *puVar4;\n    ptr \u003d (char *)(puVar5 + 2);\n  }\n  else {\n    ptr \u003d (char *)puVar4;\n    if (c \u003d\u003d \u0027+\u0027) {\n      ptr \u003d (char *)(puVar5 + 2);\n      c \u003d *puVar4;\n    }\n  }\n  intval \u003d 0;\n  exp \u003d \u0027\\0\u0027;\n  ndigit \u003d \u0027\\0\u0027;\n  bVar3 \u003d false;\n  do {\n    bVar1 \u003d c - 0x30;\n    if (bVar1 \u003c 10) {\n      ndigit \u003d ndigit + 1;\n      if (ndigit \u003c 9) {\n        if (bVar3) {\n          exp \u003d exp + -1;\n        }\n        intval \u003d (uint)bVar1 + intval * 10;\n      }\n      else if (!bVar3) {\n        exp \u003d exp + \u0027\\x01\u0027;\n      }\n    }\n    else {\n      if ((bVar1 !\u003d 0xfe) || (bVar3)) {\n        if (ndigit \u003d\u003d \u0027\\0\u0027) {\n          iVar6 \u003d 0;\n        }\n        else {\n          fval \u003d (float)__floatunsisf(intval);\n          iVar6 \u003d __aeabi_fcmpeq(fval,0);\n          if (iVar6 \u003d\u003d 0) {\n            for (; exp \u003c -1; exp \u003d exp + \u0027\\x02\u0027) {\n              uVar7 \u003d __aeabi_f2d(fval);\n              uVar7 \u003d __muldf3((int)uVar7,(int)((ulonglong)uVar7 \u003e\u003e 0x20),0x47ae147b,0x3f847ae1);\n              fval \u003d (float)__truncdfsf2((int)uVar7,(int)((ulonglong)uVar7 \u003e\u003e 0x20));\n            }\n            if (exp \u003c \u0027\\0\u0027) {\n              uVar7 \u003d __aeabi_f2d(fval);\n              uVar7 \u003d __muldf3((int)uVar7,(int)((ulonglong)uVar7 \u003e\u003e 0x20),0x9999999a,0x3fb99999);\n              fval \u003d (float)__truncdfsf2((int)uVar7,(int)((ulonglong)uVar7 \u003e\u003e 0x20));\n            }\n            else {\n              for (; \u0027\\0\u0027 \u003c exp; exp \u003d exp + -1) {\n                fval \u003d (float)__aeabi_fmul(fval,0x41200000);\n              }\n            }\n          }\n          if (bVar2) {\n            *float_ptr \u003d (float)((uint)fval ^ 0x80000000);\n          }\n          else {\n            *float_ptr \u003d fval;\n          }\n          *char_counter \u003d ((char)ptr - (char)line) + 0xff;\n          iVar6 \u003d 1;\n        }\n        return iVar6;\n      }\n      bVar3 \u003d true;\n    }\n    c \u003d *ptr;\n    ptr \u003d ptr + 1;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_execute_line",
        "next_statement"
      ],
      "called": [
        "__floatunsisf",
        "__truncdfsf2",
        "__aeabi_fcmpeq",
        "__aeabi_fmul",
        "__aeabi_f2d",
        "__muldf3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "delay_ms": {
      "entrypoint": "0x08002814",
      "current_name": "delay_ms",
      "code": "\nvoid delay_ms(uint16_t ms)\n\n{\n  uint16_t ms_local;\n  \n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "report_alarm_message",
        "mc_dwell",
        "limits_go_home"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "delay_us": {
      "entrypoint": "0x08002828",
      "current_name": "delay_us",
      "code": "\nvoid delay_us(uint32_t us)\n\n{\n  uint32_t us_local;\n  \n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "homing_cycle"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sys_sync_current_position": {
      "entrypoint": "0x0800283a",
      "current_name": "sys_sync_current_position",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sys_sync_current_position(void)\n\n{\n  plan_set_current_position(sys.position[0],sys.position[1],sys.position[2]);\n  gc_set_current_position(sys.position[0],sys.position[1],sys.position[2]);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "grbl_main",
        "mc_go_home"
      ],
      "called": [
        "gc_set_current_position",
        "plan_set_current_position"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "next_block_index": {
      "entrypoint": "0x08002870",
      "current_name": "next_block_index",
      "code": "\nuint8_t next_block_index(uint8_t block_index)\n\n{\n  uint8_t block_index_local;\n  \n  block_index_local \u003d block_index + \u0027\\x01\u0027;\n  if (block_index_local \u003d\u003d \u0027\\x12\u0027) {\n    block_index_local \u003d \u0027\\0\u0027;\n  }\n  return block_index_local;\n}\n\n",
      "renaming": {},
      "calling": [
        "plan_buffer_line",
        "planner_recalculate_trapezoids",
        "plan_discard_current_block",
        "planner_forward_pass",
        "plan_reset_buffer"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "prev_block_index": {
      "entrypoint": "0x08002896",
      "current_name": "prev_block_index",
      "code": "\nuint8_t prev_block_index(uint8_t block_index)\n\n{\n  uint8_t block_index_local;\n  \n  block_index_local \u003d block_index;\n  if (block_index \u003d\u003d \u0027\\0\u0027) {\n    block_index_local \u003d \u0027\\x12\u0027;\n  }\n  return block_index_local + 0xff;\n}\n\n",
      "renaming": {},
      "calling": [
        "planner_reverse_pass"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "estimate_acceleration_distance": {
      "entrypoint": "0x080028bc",
      "current_name": "estimate_acceleration_distance",
      "code": "\nfloat estimate_acceleration_distance(float initial_rate,float target_rate,float acceleration)\n\n{\n  undefined4 in_r0;\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 in_r1;\n  undefined4 in_r2;\n  float fVar3;\n  float acceleration_local;\n  float target_rate_local;\n  float initial_rate_local;\n  \n  uVar1 \u003d __aeabi_fmul(in_r1,in_r1);\n  uVar2 \u003d __aeabi_fmul(in_r0,in_r0);\n  uVar1 \u003d __aeabi_fsub(uVar1,uVar2);\n  uVar2 \u003d __addsf3(in_r2,in_r2);\n  fVar3 \u003d (float)__aeabi_fdiv(uVar1,uVar2);\n  return fVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "calculate_trapezoid_for_block"
      ],
      "called": [
        "__aeabi_fsub",
        "__addsf3",
        "__aeabi_fmul",
        "__aeabi_fdiv"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "intersection_distance": {
      "entrypoint": "0x08002908",
      "current_name": "intersection_distance",
      "code": "\nfloat intersection_distance(float initial_rate,float final_rate,float acceleration,float distance)\n\n{\n  undefined4 in_r0;\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 in_r1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  float fVar3;\n  float distance_local;\n  float acceleration_local;\n  float final_rate_local;\n  float initial_rate_local;\n  \n  uVar1 \u003d __addsf3(in_r2,in_r2);\n  uVar1 \u003d __aeabi_fmul(uVar1,in_r3);\n  uVar2 \u003d __aeabi_fmul(in_r0,in_r0);\n  uVar1 \u003d __aeabi_fsub(uVar1,uVar2);\n  uVar2 \u003d __aeabi_fmul(in_r1,in_r1);\n  uVar1 \u003d __addsf3(uVar1,uVar2);\n  uVar2 \u003d __aeabi_fmul(in_r2,0x40800000);\n  fVar3 \u003d (float)__aeabi_fdiv(uVar1,uVar2);\n  return fVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "calculate_trapezoid_for_block"
      ],
      "called": [
        "__aeabi_fsub",
        "__addsf3",
        "__aeabi_fmul",
        "__aeabi_fdiv"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "max_allowable_speed": {
      "entrypoint": "0x08002978",
      "current_name": "max_allowable_speed",
      "code": "\n/* WARNING: Variable defined which should be unmapped: distance-local */\n\nfloat max_allowable_speed(float acceleration,float target_velocity,float distance)\n\n{\n  undefined4 in_r0;\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 in_r1;\n  undefined4 extraout_r1;\n  undefined4 in_r2;\n  float fVar3;\n  undefined4 uStack_20;\n  float distance_local;\n  float target_velocity_local;\n  float acceleration_local;\n  \n  uVar1 \u003d __aeabi_fmul(acceleration,in_r1,in_r1);\n  uVar2 \u003d __addsf3(in_r0,in_r0);\n  uVar2 \u003d __aeabi_fmul(uVar2,in_r2);\n  uVar1 \u003d __aeabi_fsub(uVar1,uVar2);\n  uVar1 \u003d __aeabi_f2d(uVar1);\n  sqrt((double)CONCAT44(in_r2,uStack_20));\n  fVar3 \u003d (float)__truncdfsf2(uVar1,extraout_r1);\n  return fVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "plan_buffer_line",
        "planner_forward_pass_kernel",
        "planner_reverse_pass_kernel"
      ],
      "called": [
        "__aeabi_fsub",
        "__truncdfsf2",
        "sqrt",
        "__addsf3",
        "__aeabi_fmul",
        "__aeabi_f2d"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "planner_reverse_pass_kernel": {
      "entrypoint": "0x080029d8",
      "current_name": "planner_reverse_pass_kernel",
      "code": "\nvoid planner_reverse_pass_kernel(block_t *previous,block_t *current,block_t *next)\n\n{\n  int iVar1;\n  uint uVar2;\n  float fVar3;\n  float acceleration;\n  float acceleration_00;\n  float target_velocity;\n  float target_velocity_00;\n  float distance;\n  float distance_00;\n  block_t *next_local;\n  block_t *current_local;\n  block_t *previous_local;\n  \n  if (((current !\u003d (block_t *)0x0) \u0026\u0026 (next !\u003d (block_t *)0x0)) \u0026\u0026\n     (iVar1 \u003d __aeabi_fcmpeq(current-\u003eentry_speed,current-\u003emax_entry_speed), iVar1 \u003d\u003d 0)) {\n    if ((current-\u003enominal_length_flag \u003d\u003d \u0027\\0\u0027) \u0026\u0026\n       (iVar1 \u003d __aeabi_fcmpgt(current-\u003emax_entry_speed,next-\u003eentry_speed), iVar1 !\u003d 0)) {\n      fVar3 \u003d current-\u003emax_entry_speed;\n      uVar2 \u003d (uint)settings.acceleration ^ 0x80000000;\n      max_allowable_speed(acceleration,target_velocity,distance);\n      iVar1 \u003d __aeabi_fcmplt(fVar3,uVar2);\n      if (iVar1 \u003d\u003d 0) {\n        fVar3 \u003d (float)((uint)settings.acceleration ^ 0x80000000);\n        max_allowable_speed(acceleration_00,target_velocity_00,distance_00);\n      }\n      else {\n        fVar3 \u003d current-\u003emax_entry_speed;\n      }\n      current-\u003eentry_speed \u003d fVar3;\n    }\n    else {\n      current-\u003eentry_speed \u003d current-\u003emax_entry_speed;\n    }\n    current-\u003erecalculate_flag \u003d \u0027\\x01\u0027;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "planner_reverse_pass"
      ],
      "called": [
        "__aeabi_fcmpgt",
        "__aeabi_fcmpeq",
        "max_allowable_speed",
        "__aeabi_fcmplt"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "planner_reverse_pass": {
      "entrypoint": "0x08002a94",
      "current_name": "planner_reverse_pass",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid planner_reverse_pass(void)\n\n{\n  block_t *next;\n  block_t *block [3];\n  uint8_t block_index;\n  \n  block_index \u003d block_buffer_head;\n  block[0] \u003d (block_t *)0x0;\n  block[1] \u003d (block_t *)0x0;\n  while (next \u003d block[1], block_index !\u003d block_buffer_tail) {\n    block_index \u003d prev_block_index(block_index);\n    block[1] \u003d block[0];\n    planner_reverse_pass_kernel(block_buffer + block_index,block[0],next);\n    block[0] \u003d block_buffer + block_index;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "planner_recalculate"
      ],
      "called": [
        "prev_block_index",
        "planner_reverse_pass_kernel"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "planner_forward_pass_kernel": {
      "entrypoint": "0x08002afc",
      "current_name": "planner_forward_pass_kernel",
      "code": "\nvoid planner_forward_pass_kernel(block_t *previous,block_t *current,block_t *next)\n\n{\n  int iVar1;\n  uint uVar2;\n  float fVar3;\n  float acceleration;\n  float acceleration_00;\n  float target_velocity;\n  float target_velocity_00;\n  float distance;\n  float distance_00;\n  block_t *next_local;\n  block_t *current_local;\n  block_t *previous_local;\n  float entry_speed;\n  \n  if (((previous !\u003d (block_t *)0x0) \u0026\u0026 (previous-\u003enominal_length_flag \u003d\u003d \u0027\\0\u0027)) \u0026\u0026\n     (iVar1 \u003d __aeabi_fcmplt(previous-\u003eentry_speed,current-\u003eentry_speed), iVar1 !\u003d 0)) {\n    fVar3 \u003d current-\u003eentry_speed;\n    uVar2 \u003d (uint)settings.acceleration ^ 0x80000000;\n    max_allowable_speed(acceleration,target_velocity,distance);\n    iVar1 \u003d __aeabi_fcmplt(fVar3,uVar2);\n    if (iVar1 \u003d\u003d 0) {\n      fVar3 \u003d (float)((uint)settings.acceleration ^ 0x80000000);\n      max_allowable_speed(acceleration_00,target_velocity_00,distance_00);\n    }\n    else {\n      fVar3 \u003d current-\u003eentry_speed;\n    }\n    iVar1 \u003d __aeabi_fcmpeq(fVar3,current-\u003eentry_speed);\n    if (iVar1 \u003d\u003d 0) {\n      current-\u003eentry_speed \u003d fVar3;\n      current-\u003erecalculate_flag \u003d \u0027\\x01\u0027;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "planner_forward_pass"
      ],
      "called": [
        "max_allowable_speed",
        "__aeabi_fcmpeq",
        "__aeabi_fcmplt"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "planner_forward_pass": {
      "entrypoint": "0x08002ba8",
      "current_name": "planner_forward_pass",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid planner_forward_pass(void)\n\n{\n  block_t *previous;\n  uint uVar1;\n  block_t *block [3];\n  uint8_t block_index;\n  \n  block[1] \u003d (block_t *)0x0;\n  block[2] \u003d (block_t *)0x0;\n  block_index \u003d block_buffer_tail;\n  while (previous \u003d block[1], block_index !\u003d block_buffer_head) {\n    block[1] \u003d block[2];\n    uVar1 \u003d (uint)block_index;\n    planner_forward_pass_kernel(previous,block[2],block_buffer + uVar1);\n    block_index \u003d next_block_index(block_index);\n    block[2] \u003d block_buffer + uVar1;\n  }\n  planner_forward_pass_kernel(block[1],block[2],(block_t *)0x0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "planner_recalculate"
      ],
      "called": [
        "next_block_index",
        "planner_forward_pass_kernel"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "calculate_trapezoid_for_block": {
      "entrypoint": "0x08002c18",
      "current_name": "calculate_trapezoid_for_block",
      "code": "\n/* WARNING: Variable defined which should be unmapped: exit_factor-local */\n\nvoid calculate_trapezoid_for_block(block_t *block,float entry_factor,float exit_factor)\n\n{\n  undefined4 uVar1;\n  uint32_t uVar2;\n  int iVar3;\n  int iVar4;\n  uint uVar5;\n  undefined4 in_r1;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined4 extraout_r1_03;\n  undefined4 in_r2;\n  float acceleration;\n  float acceleration_00;\n  float acceleration_01;\n  float distance;\n  undefined8 uVar6;\n  undefined4 uStack_38;\n  float exit_factor_local;\n  float entry_factor_local;\n  block_t *block_local;\n  int32_t decelerate_steps;\n  int32_t acceleration_per_minute;\n  int32_t plateau_steps;\n  int32_t accelerate_steps;\n  \n  uVar1 \u003d __floatunsisf(entry_factor,block-\u003enominal_rate);\n  uVar1 \u003d __aeabi_fmul(uVar1,in_r1);\n  uVar1 \u003d __aeabi_f2d(uVar1);\n  ceil((double)CONCAT44(in_r2,uStack_38));\n  uVar2 \u003d __aeabi_d2uiz(uVar1,extraout_r1);\n  block-\u003einitial_rate \u003d uVar2;\n  uVar1 \u003d __floatunsisf(block-\u003enominal_rate);\n  uVar1 \u003d __aeabi_fmul(uVar1,in_r2);\n  uVar1 \u003d __aeabi_f2d(uVar1);\n  ceil((double)CONCAT44(in_r2,uStack_38));\n  uVar2 \u003d __aeabi_d2uiz(uVar1,extraout_r1_00);\n  block-\u003efinal_rate \u003d uVar2;\n  uVar6 \u003d __aeabi_i2d(block-\u003erate_delta * 0x32);\n  uVar6 \u003d __muldf3((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),0,0x404e0000);\n  iVar3 \u003d __aeabi_d2iz((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20));\n  uVar1 \u003d __floatunsisf(block-\u003einitial_rate);\n  __floatunsisf(block-\u003enominal_rate);\n  uVar6 \u003d __floatsisf(iVar3);\n  estimate_acceleration_distance((float)uVar6,(float)((ulonglong)uVar6 \u003e\u003e 0x20),acceleration);\n  uVar1 \u003d __aeabi_f2d(uVar1);\n  ceil((double)CONCAT44(in_r2,uStack_38));\n  accelerate_steps \u003d __aeabi_d2iz(uVar1,extraout_r1_01);\n  uVar1 \u003d __floatunsisf(block-\u003enominal_rate);\n  __floatunsisf(block-\u003efinal_rate);\n  uVar6 \u003d __floatsisf(-iVar3);\n  estimate_acceleration_distance((float)uVar6,(float)((ulonglong)uVar6 \u003e\u003e 0x20),acceleration_00);\n  uVar1 \u003d __aeabi_f2d(uVar1);\n  floor((double)CONCAT44(in_r2,uStack_38));\n  iVar4 \u003d __aeabi_d2iz(uVar1,extraout_r1_02);\n  plateau_steps \u003d (block-\u003estep_event_count - accelerate_steps) - iVar4;\n  if (plateau_steps \u003c 0) {\n    uVar1 \u003d __floatunsisf(block-\u003einitial_rate);\n    __floatunsisf(block-\u003efinal_rate);\n    __floatsisf(iVar3);\n    uVar6 \u003d __floatsisf(block-\u003estep_event_count);\n    intersection_distance((float)uVar6,(float)((ulonglong)uVar6 \u003e\u003e 0x20),acceleration_01,distance);\n    uVar1 \u003d __aeabi_f2d(uVar1);\n    ceil((double)CONCAT44(in_r2,uStack_38));\n    uVar5 \u003d __aeabi_d2iz(uVar1,extraout_r1_03);\n    uVar5 \u003d uVar5 \u0026 ~((int)uVar5 \u003e\u003e 0x1f);\n    accelerate_steps \u003d block-\u003estep_event_count;\n    if ((int)uVar5 \u003c\u003d block-\u003estep_event_count) {\n      accelerate_steps \u003d uVar5;\n    }\n    plateau_steps \u003d 0;\n  }\n  block-\u003eaccelerate_until \u003d accelerate_steps;\n  block-\u003edecelerate_after \u003d plateau_steps + accelerate_steps;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "planner_recalculate_trapezoids"
      ],
      "called": [
        "__floatsisf",
        "__floatunsisf",
        "__aeabi_d2uiz",
        "intersection_distance",
        "__aeabi_fmul",
        "__aeabi_i2d",
        "floor",
        "ceil",
        "__aeabi_f2d",
        "estimate_acceleration_distance",
        "__aeabi_d2iz",
        "__muldf3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "planner_recalculate_trapezoids": {
      "entrypoint": "0x08002e08",
      "current_name": "planner_recalculate_trapezoids",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid planner_recalculate_trapezoids(void)\n\n{\n  uint uVar1;\n  undefined8 uVar2;\n  block_t *current;\n  block_t *next;\n  uint8_t block_index;\n  \n  next \u003d (block_t *)0x0;\n  block_index \u003d block_buffer_tail;\n  while (block_index !\u003d block_buffer_head) {\n    uVar1 \u003d (uint)block_index;\n    if ((next !\u003d (block_t *)0x0) \u0026\u0026\n       ((next-\u003erecalculate_flag !\u003d \u0027\\0\u0027 || (block_buffer[uVar1].recalculate_flag !\u003d \u0027\\0\u0027)))) {\n      __aeabi_fdiv(next-\u003eentry_speed,next-\u003enominal_speed);\n      uVar2 \u003d __aeabi_fdiv(block_buffer[uVar1].entry_speed,next-\u003enominal_speed);\n      calculate_trapezoid_for_block(next,(float)uVar2,(float)((ulonglong)uVar2 \u003e\u003e 0x20));\n      next-\u003erecalculate_flag \u003d \u0027\\0\u0027;\n    }\n    block_index \u003d next_block_index(block_index);\n    next \u003d block_buffer + uVar1;\n  }\n  __aeabi_fdiv(next-\u003eentry_speed,next-\u003enominal_speed);\n  uVar2 \u003d __aeabi_fdiv(0,next-\u003enominal_speed);\n  calculate_trapezoid_for_block(next,(float)uVar2,(float)((ulonglong)uVar2 \u003e\u003e 0x20));\n  next-\u003erecalculate_flag \u003d \u0027\\0\u0027;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "planner_recalculate"
      ],
      "called": [
        "next_block_index",
        "calculate_trapezoid_for_block",
        "__aeabi_fdiv"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "planner_recalculate": {
      "entrypoint": "0x08002edc",
      "current_name": "planner_recalculate",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid planner_recalculate(void)\n\n{\n  planner_reverse_pass();\n  planner_forward_pass();\n  planner_recalculate_trapezoids();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "plan_buffer_line",
        "plan_cycle_reinitialize"
      ],
      "called": [
        "planner_recalculate_trapezoids",
        "planner_reverse_pass",
        "planner_forward_pass"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "plan_reset_buffer": {
      "entrypoint": "0x08002ef0",
      "current_name": "plan_reset_buffer",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid plan_reset_buffer(void)\n\n{\n  block_buffer_tail \u003d block_buffer_head;\n  next_buffer_head \u003d next_block_index(block_buffer_head);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "plan_init"
      ],
      "called": [
        "next_block_index"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "plan_init": {
      "entrypoint": "0x08002f24",
      "current_name": "plan_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid plan_init(void)\n\n{\n  plan_reset_buffer();\n  memset(\u0026pl,0,0x1c);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "grbl_main"
      ],
      "called": [
        "memset",
        "plan_reset_buffer"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "plan_discard_current_block": {
      "entrypoint": "0x08002f40",
      "current_name": "plan_discard_current_block",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid plan_discard_current_block(void)\n\n{\n  if (block_buffer_head !\u003d block_buffer_tail) {\n    block_buffer_tail \u003d next_block_index(block_buffer_tail);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "step_period_isr"
      ],
      "called": [
        "next_block_index"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "plan_get_current_block": {
      "entrypoint": "0x08002f74",
      "current_name": "plan_get_current_block",
      "code": "\n/* WARNING: Unknown calling convention */\n\nblock_t * plan_get_current_block(void)\n\n{\n  block_t *pbVar1;\n  \n  if (block_buffer_head \u003d\u003d block_buffer_tail) {\n    pbVar1 \u003d (block_t *)0x0;\n  }\n  else {\n    pbVar1 \u003d block_buffer + block_buffer_tail;\n  }\n  return pbVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "plan_synchronize",
        "step_period_isr"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "plan_check_full_buffer": {
      "entrypoint": "0x08002fac",
      "current_name": "plan_check_full_buffer",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t plan_check_full_buffer(void)\n\n{\n  return block_buffer_tail \u003d\u003d next_buffer_head;\n}\n\n",
      "renaming": {},
      "calling": [
        "mc_line"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "plan_synchronize": {
      "entrypoint": "0x08002fd4",
      "current_name": "plan_synchronize",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid plan_synchronize(void)\n\n{\n  block_t *pbVar1;\n  \n  while ((pbVar1 \u003d plan_get_current_block(), pbVar1 !\u003d (block_t *)0x0 || (sys.state \u003d\u003d \u0027\\x03\u0027))) {\n    protocol_execute_runtime();\n    if (sys.abort !\u003d \u0027\\0\u0027) {\n      return;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line",
        "spindle_run",
        "coolant_run",
        "mc_dwell",
        "mc_go_home"
      ],
      "called": [
        "protocol_execute_runtime",
        "plan_get_current_block"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "plan_buffer_line": {
      "entrypoint": "0x08003004",
      "current_name": "plan_buffer_line",
      "code": "\n/* WARNING: Variable defined which should be unmapped: feed_rate-local */\n\nvoid plan_buffer_line(float x,float y,float z,float feed_rate,uint8_t invert_feed_rate)\n\n{\n  undefined4 uVar1;\n  long lVar2;\n  long lVar3;\n  long lVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  undefined4 uVar8;\n  float fVar9;\n  int32_t iVar10;\n  float fVar11;\n  float fVar12;\n  float fVar13;\n  int iVar14;\n  float fVar15;\n  undefined4 in_r1;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined4 extraout_r1_03;\n  undefined4 extraout_r1_04;\n  undefined4 in_r2;\n  uint uVar16;\n  undefined4 in_r3;\n  uint uVar17;\n  block_t *pbVar18;\n  uint32_t uVar19;\n  uint uVar20;\n  undefined8 extraout_d0;\n  undefined8 extraout_d0_00;\n  undefined8 extraout_d0_01;\n  undefined8 extraout_d0_02;\n  undefined8 extraout_d0_03;\n  undefined8 extraout_d0_04;\n  float extraout_s2;\n  float extraout_s2_00;\n  float extraout_s2_01;\n  float extraout_s2_02;\n  float extraout_s2_03;\n  float extraout_s2_04;\n  undefined8 uVar21;\n  undefined8 uVar22;\n  undefined8 uVar23;\n  char in_stack_00000000;\n  float feed_rate_local;\n  float z_local;\n  float y_local;\n  float x_local;\n  float unit_vec [3];\n  float delta_mm [3];\n  int32_t target [3];\n  float v_allowable;\n  float sin_theta_d2;\n  float cos_theta;\n  float inverse_millimeters;\n  block_t *block;\n  float vmax_junction;\n  float inverse_minute;\n  \n  uVar17 \u003d (uint)block_buffer_head;\n  pbVar18 \u003d block_buffer + uVar17;\n  uVar1 \u003d __aeabi_fmul(x,settings.steps_per_mm[0],invert_feed_rate);\n  __aeabi_f2d(uVar1);\n  lVar2 \u003d lround((double)CONCAT44(in_r2,in_r3));\n  uVar1 \u003d __aeabi_fmul(settings.steps_per_mm[1],in_r1);\n  __aeabi_f2d(uVar1);\n  lVar3 \u003d lround((double)CONCAT44(in_r2,in_r3));\n  uVar1 \u003d __aeabi_fmul(settings.steps_per_mm[2],in_r2);\n  __aeabi_f2d(uVar1);\n  lVar4 \u003d lround((double)CONCAT44(in_r2,in_r3));\n  pbVar18-\u003edirection_bits \u003d 0;\n  if (lVar2 \u003c pl.position[0]) {\n    pbVar18-\u003edirection_bits \u003d pbVar18-\u003edirection_bits | 0x20;\n  }\n  if (lVar3 \u003c pl.position[1]) {\n    pbVar18-\u003edirection_bits \u003d pbVar18-\u003edirection_bits | 0x880;\n  }\n  if (lVar4 \u003c pl.position[2]) {\n    pbVar18-\u003edirection_bits \u003d pbVar18-\u003edirection_bits | 0x200;\n  }\n  uVar19 \u003d lVar2 - pl.position[0];\n  if ((int)uVar19 \u003c 0) {\n    uVar19 \u003d -uVar19;\n  }\n  block_buffer[uVar17].steps_x \u003d uVar19;\n  uVar19 \u003d lVar3 - pl.position[1];\n  if ((int)uVar19 \u003c 0) {\n    uVar19 \u003d -uVar19;\n  }\n  block_buffer[uVar17].steps_y \u003d uVar19;\n  uVar19 \u003d lVar4 - pl.position[2];\n  if ((int)uVar19 \u003c 0) {\n    uVar19 \u003d -uVar19;\n  }\n  block_buffer[uVar17].steps_z \u003d uVar19;\n  uVar16 \u003d block_buffer[uVar17].steps_z;\n  if (block_buffer[uVar17].steps_z \u003c block_buffer[uVar17].steps_y) {\n    uVar16 \u003d block_buffer[uVar17].steps_y;\n  }\n  uVar20 \u003d block_buffer[uVar17].steps_x;\n  if (block_buffer[uVar17].steps_x \u003c uVar16) {\n    uVar20 \u003d uVar16;\n  }\n  block_buffer[uVar17].step_event_count \u003d uVar20;\n  if (block_buffer[uVar17].step_event_count !\u003d 0) {\n    uVar1 \u003d __floatsisf(lVar2 - pl.position[0]);\n    uVar1 \u003d __aeabi_fdiv(uVar1,settings.steps_per_mm[0]);\n    uVar5 \u003d __floatsisf(lVar3 - pl.position[1]);\n    uVar5 \u003d __aeabi_fdiv(uVar5,settings.steps_per_mm[1]);\n    uVar6 \u003d __floatsisf(lVar4 - pl.position[2]);\n    uVar6 \u003d __aeabi_fdiv(uVar6,settings.steps_per_mm[2]);\n    uVar7 \u003d __aeabi_fmul(uVar1,uVar1);\n    uVar8 \u003d __aeabi_fmul(uVar5,uVar5);\n    uVar7 \u003d __addsf3(uVar7,uVar8);\n    uVar8 \u003d __aeabi_fmul(uVar6,uVar6);\n    uVar7 \u003d __addsf3(uVar7,uVar8);\n    uVar7 \u003d __aeabi_f2d(uVar7);\n    sqrt((double)CONCAT44(in_r2,in_r3));\n    fVar9 \u003d (float)__truncdfsf2(uVar7,extraout_r1);\n    block_buffer[uVar17].millimeters \u003d fVar9;\n    uVar7 \u003d __aeabi_fdiv(0x3f800000,block_buffer[uVar17].millimeters);\n    if (in_stack_00000000 \u003d\u003d \u0027\\0\u0027) {\n      inverse_minute \u003d (float)__aeabi_fmul(in_r3,uVar7);\n    }\n    else {\n      inverse_minute \u003d (float)__aeabi_fdiv(0x3f800000,in_r3);\n    }\n    fVar9 \u003d (float)__aeabi_fmul(block_buffer[uVar17].millimeters,inverse_minute);\n    block_buffer[uVar17].nominal_speed \u003d fVar9;\n    uVar8 \u003d __floatsisf(block_buffer[uVar17].step_event_count);\n    uVar8 \u003d __aeabi_fmul(uVar8,inverse_minute);\n    uVar8 \u003d __aeabi_f2d(uVar8);\n    ceil((double)CONCAT44(in_r2,in_r3));\n    uVar19 \u003d __aeabi_d2uiz(uVar8,extraout_r1_00);\n    block_buffer[uVar17].nominal_rate \u003d uVar19;\n    uVar8 \u003d __floatsisf(block_buffer[uVar17].step_event_count);\n    uVar8 \u003d __aeabi_fmul(uVar8,uVar7);\n    uVar8 \u003d __aeabi_fmul(uVar8,settings.acceleration);\n    uVar8 \u003d __aeabi_fdiv(uVar8,0x453b8000);\n    uVar8 \u003d __aeabi_f2d(uVar8);\n    ceil((double)CONCAT44(in_r2,in_r3));\n    iVar10 \u003d __aeabi_d2iz(uVar8,extraout_r1_01);\n    block_buffer[uVar17].rate_delta \u003d iVar10;\n    fVar11 \u003d (float)__aeabi_fmul(uVar1,uVar7);\n    fVar12 \u003d (float)__aeabi_fmul(uVar5,uVar7);\n    fVar13 \u003d (float)__aeabi_fmul(uVar6,uVar7);\n    vmax_junction \u003d 0.0;\n    uVar21 \u003d extraout_d0;\n    fVar9 \u003d extraout_s2;\n    if ((block_buffer_head !\u003d block_buffer_tail) \u0026\u0026\n       (iVar14 \u003d __aeabi_fcmpgt(pl.previous_nominal_speed,0), uVar21 \u003d extraout_d0_00,\n       fVar9 \u003d extraout_s2_00, iVar14 !\u003d 0)) {\n      uVar1 \u003d __aeabi_fmul((uint)pl.previous_unit_vec[0] ^ 0x80000000,fVar11);\n      uVar5 \u003d __aeabi_fmul(pl.previous_unit_vec[1],fVar12);\n      uVar1 \u003d __aeabi_fsub(uVar1,uVar5);\n      uVar5 \u003d __aeabi_fmul(pl.previous_unit_vec[2],fVar13);\n      uVar1 \u003d __aeabi_fsub(uVar1,uVar5);\n      uVar21 \u003d __aeabi_f2d(uVar1);\n      iVar14 \u003d __aeabi_dcmplt((int)uVar21,(int)((ulonglong)uVar21 \u003e\u003e 0x20),0x66666666,0x3fee6666);\n      uVar21 \u003d extraout_d0_01;\n      fVar9 \u003d extraout_s2_01;\n      if (iVar14 !\u003d 0) {\n        iVar14 \u003d __aeabi_fcmplt(pl.previous_nominal_speed,block_buffer[uVar17].nominal_speed);\n        vmax_junction \u003d pl.previous_nominal_speed;\n        if (iVar14 \u003d\u003d 0) {\n          vmax_junction \u003d block_buffer[uVar17].nominal_speed;\n        }\n        uVar21 \u003d __aeabi_f2d(uVar1);\n        iVar14 \u003d __aeabi_dcmpgt((int)uVar21,(int)((ulonglong)uVar21 \u003e\u003e 0x20),0x66666666,0xbfee6666);\n        uVar21 \u003d extraout_d0_02;\n        fVar9 \u003d extraout_s2_02;\n        if (iVar14 !\u003d 0) {\n          uVar21 \u003d __aeabi_f2d(uVar1);\n          uVar21 \u003d __subdf3(0,0x3ff00000,(int)uVar21,(int)((ulonglong)uVar21 \u003e\u003e 0x20));\n          uVar1 \u003d __muldf3((int)uVar21,(int)((ulonglong)uVar21 \u003e\u003e 0x20),0,0x3fe00000);\n          sqrt((double)CONCAT44(in_r2,in_r3));\n          uVar1 \u003d __truncdfsf2(uVar1,extraout_r1_02);\n          uVar21 \u003d __aeabi_f2d(vmax_junction);\n          uVar5 \u003d __aeabi_fmul(settings.acceleration,settings.junction_deviation);\n          uVar5 \u003d __aeabi_fmul(uVar5,uVar1);\n          uVar22 \u003d __aeabi_f2d(uVar5);\n          uVar23 \u003d __aeabi_f2d(uVar1);\n          uVar23 \u003d __subdf3(0,0x3ff00000,(int)uVar23,(int)((ulonglong)uVar23 \u003e\u003e 0x20));\n          uVar5 \u003d __divdf3((int)uVar22,(int)((ulonglong)uVar22 \u003e\u003e 0x20),(int)uVar23,\n                           (int)((ulonglong)uVar23 \u003e\u003e 0x20));\n          sqrt((double)CONCAT44(in_r2,in_r3));\n          iVar14 \u003d __aeabi_dcmplt((int)uVar21,(int)((ulonglong)uVar21 \u003e\u003e 0x20),uVar5,extraout_r1_03)\n          ;\n          uVar21 \u003d extraout_d0_03;\n          fVar9 \u003d extraout_s2_03;\n          if (iVar14 \u003d\u003d 0) {\n            uVar5 \u003d __aeabi_fmul(settings.acceleration,settings.junction_deviation);\n            uVar5 \u003d __aeabi_fmul(uVar5,uVar1);\n            uVar21 \u003d __aeabi_f2d(uVar5);\n            uVar22 \u003d __aeabi_f2d(uVar1);\n            uVar22 \u003d __subdf3(0,0x3ff00000,(int)uVar22,(int)((ulonglong)uVar22 \u003e\u003e 0x20));\n            uVar1 \u003d __divdf3((int)uVar21,(int)((ulonglong)uVar21 \u003e\u003e 0x20),(int)uVar22,\n                             (int)((ulonglong)uVar22 \u003e\u003e 0x20));\n            sqrt((double)CONCAT44(in_r2,in_r3));\n            vmax_junction \u003d (float)__truncdfsf2(uVar1,extraout_r1_04);\n            uVar21 \u003d extraout_d0_04;\n            fVar9 \u003d extraout_s2_04;\n          }\n        }\n      }\n    }\n    block_buffer[uVar17].max_entry_speed \u003d vmax_junction;\n    fVar15 \u003d (float)((uint)settings.acceleration ^ 0x80000000);\n    max_allowable_speed((float)uVar21,(float)((ulonglong)uVar21 \u003e\u003e 0x20),fVar9);\n    iVar14 \u003d __aeabi_fcmplt(vmax_junction,fVar15);\n    fVar9 \u003d fVar15;\n    if (iVar14 !\u003d 0) {\n      fVar9 \u003d vmax_junction;\n    }\n    block_buffer[uVar17].entry_speed \u003d fVar9;\n    iVar14 \u003d __aeabi_fcmpge(fVar15,block_buffer[uVar17].nominal_speed);\n    if (iVar14 \u003d\u003d 0) {\n      block_buffer[uVar17].nominal_length_flag \u003d \u0027\\0\u0027;\n    }\n    else {\n      block_buffer[uVar17].nominal_length_flag \u003d \u0027\\x01\u0027;\n    }\n    block_buffer[uVar17].recalculate_flag \u003d \u0027\\x01\u0027;\n    pl.previous_nominal_speed \u003d block_buffer[uVar17].nominal_speed;\n    block_buffer_head \u003d next_buffer_head;\n    pl.previous_unit_vec[0] \u003d fVar11;\n    pl.previous_unit_vec[1] \u003d fVar12;\n    pl.previous_unit_vec[2] \u003d fVar13;\n    next_buffer_head \u003d next_block_index(next_buffer_head);\n    pl.position[0] \u003d lVar2;\n    pl.position[1] \u003d lVar3;\n    pl.position[2] \u003d lVar4;\n    planner_recalculate();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "mc_line"
      ],
      "called": [
        "next_block_index",
        "__floatsisf",
        "__truncdfsf2",
        "ceil",
        "__aeabi_fcmpge",
        "__aeabi_d2iz",
        "__aeabi_fcmpgt",
        "__aeabi_fsub",
        "__divdf3",
        "__aeabi_d2uiz",
        "max_allowable_speed",
        "sqrt",
        "__addsf3",
        "__aeabi_fmul",
        "__aeabi_fcmplt",
        "lround",
        "__aeabi_fdiv",
        "__aeabi_dcmplt",
        "__aeabi_dcmpgt",
        "__aeabi_f2d",
        "__subdf3",
        "planner_recalculate",
        "__muldf3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "plan_set_current_position": {
      "entrypoint": "0x080035ec",
      "current_name": "plan_set_current_position",
      "code": "\nvoid plan_set_current_position(int32_t x,int32_t y,int32_t z)\n\n{\n  int32_t z_local;\n  int32_t y_local;\n  int32_t x_local;\n  \n  pl.position[0] \u003d x;\n  pl.position[1] \u003d y;\n  pl.position[2] \u003d z;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "sys_sync_current_position"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "plan_cycle_reinitialize": {
      "entrypoint": "0x08003618",
      "current_name": "plan_cycle_reinitialize",
      "code": "\nvoid plan_cycle_reinitialize(int32_t step_events_remaining)\n\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  float fVar4;\n  int32_t step_events_remaining_local;\n  block_t *block;\n  \n  uVar3 \u003d (uint)block_buffer_tail;\n  fVar4 \u003d block_buffer[uVar3].millimeters;\n  uVar1 \u003d __floatsisf(step_events_remaining);\n  uVar1 \u003d __aeabi_fmul(fVar4,uVar1);\n  uVar2 \u003d __floatsisf(block_buffer[uVar3].step_event_count);\n  fVar4 \u003d (float)__aeabi_fdiv(uVar1,uVar2);\n  block_buffer[uVar3].millimeters \u003d fVar4;\n  block_buffer[uVar3].step_event_count \u003d step_events_remaining;\n  block_buffer[uVar3].entry_speed \u003d 0.0;\n  block_buffer[uVar3].max_entry_speed \u003d 0.0;\n  block_buffer[uVar3].nominal_length_flag \u003d \u0027\\0\u0027;\n  block_buffer[uVar3].recalculate_flag \u003d \u0027\\x01\u0027;\n  planner_recalculate();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "st_cycle_reinitialize"
      ],
      "called": [
        "__floatsisf",
        "__aeabi_fmul",
        "__aeabi_fdiv",
        "planner_recalculate"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "printString": {
      "entrypoint": "0x0800369c",
      "current_name": "printString",
      "code": "\nvoid printString(char *s)\n\n{\n  char *s_local;\n  \n  s_local \u003d s;\n  while (*s_local !\u003d \u0027\\0\u0027) {\n    serial_write(*s_local);\n    s_local \u003d s_local + 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "report_startup_line",
        "protocol_execute_startup"
      ],
      "called": [
        "serial_write"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "printPgmString": {
      "entrypoint": "0x080036c6",
      "current_name": "printPgmString",
      "code": "\nvoid printPgmString(char *s)\n\n{\n  char *s_local;\n  \n  s_local \u003d s;\n  while (*s_local !\u003d \u0027\\0\u0027) {\n    serial_write(*s_local);\n    s_local \u003d s_local + 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "report_realtime_status",
        "report_init_message",
        "report_grbl_help",
        "report_startup_line",
        "report_alarm_message",
        "report_gcode_parameters",
        "report_status_message",
        "report_feedback_message",
        "report_grbl_settings",
        "report_gcode_modes"
      ],
      "called": [
        "serial_write"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "print_base2": {
      "entrypoint": "0x080036f0",
      "current_name": "print_base2",
      "code": "\nvoid print_base2(uint n,int bits)\n\n{\n  uint8_t data;\n  int bits_local;\n  uint n_local;\n  int i;\n  uint32_t mask;\n  \n  mask \u003d 1 \u003c\u003c (bits - 1U \u0026 0xff);\n  for (i \u003d 0; i \u003c bits; i \u003d i + 1) {\n    if ((mask \u0026 n) \u003d\u003d 0) {\n      data \u003d \u00270\u0027;\n    }\n    else {\n      data \u003d \u00271\u0027;\n    }\n    serial_write(data);\n    mask \u003d mask \u003e\u003e 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "print_uint8_base2",
        "print_uint16_base2"
      ],
      "called": [
        "serial_write"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "print_uint8_base2": {
      "entrypoint": "0x08003740",
      "current_name": "print_uint8_base2",
      "code": "\nvoid print_uint8_base2(uint8_t n)\n\n{\n  uint8_t n_local;\n  \n  print_base2((uint)n,8);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "print_base2"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "print_uint16_base2": {
      "entrypoint": "0x0800375c",
      "current_name": "print_uint16_base2",
      "code": "\nvoid print_uint16_base2(uint16_t n)\n\n{\n  uint16_t n_local;\n  \n  print_base2((uint)n,0x10);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "report_grbl_settings"
      ],
      "called": [
        "print_base2"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "print_uint32_base10": {
      "entrypoint": "0x08003778",
      "current_name": "print_uint32_base10",
      "code": "\nvoid print_uint32_base10(ulong n)\n\n{\n  uint uVar1;\n  ulong n_local;\n  uint8_t uStack_15;\n  uchar buf [10];\n  uint8_t i;\n  \n  i \u003d \u0027\\0\u0027;\n  n_local \u003d n;\n  if (n \u003d\u003d 0) {\n    serial_write(\u00270\u0027);\n  }\n  else {\n    for (; n_local !\u003d 0; n_local \u003d n_local / 10) {\n      uVar1 \u003d (uint)i;\n      i \u003d i + \u0027\\x01\u0027;\n      buf[uVar1] \u003d (char)(n_local % 10) + \u00270\u0027;\n    }\n    for (; i !\u003d \u0027\\0\u0027; i \u003d i + 0xff) {\n      serial_write(buf[i - 1]);\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "printInteger"
      ],
      "called": [
        "serial_write"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "printInteger": {
      "entrypoint": "0x080037fc",
      "current_name": "printInteger",
      "code": "\nvoid printInteger(long n)\n\n{\n  long n_local;\n  \n  n_local \u003d n;\n  if (n \u003c 0) {\n    serial_write(\u0027-\u0027);\n    n_local \u003d -n;\n  }\n  print_uint32_base10(n_local);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "report_startup_line",
        "report_grbl_settings",
        "report_gcode_modes"
      ],
      "called": [
        "serial_write",
        "print_uint32_base10"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "printFloat": {
      "entrypoint": "0x08003826",
      "current_name": "printFloat",
      "code": "\nvoid printFloat(float n)\n\n{\n  float in_r0;\n  int iVar1;\n  undefined4 uVar2;\n  byte bVar3;\n  uint uVar4;\n  float n_local;\n  uint8_t uStack_1d;\n  uchar buf [10];\n  uint32_t a;\n  uint8_t i;\n  uint8_t decimals;\n  \n  iVar1 \u003d __aeabi_fcmplt(in_r0,0);\n  n_local \u003d in_r0;\n  if (iVar1 !\u003d 0) {\n    serial_write(\u0027-\u0027);\n    n_local \u003d (float)((uint)in_r0 ^ 0x80000000);\n  }\n  for (decimals \u003d settings.decimal_places; 1 \u003c decimals; decimals \u003d decimals + 0xfe) {\n    n_local \u003d (float)__aeabi_fmul(n_local,0x42c80000);\n  }\n  if (decimals !\u003d \u0027\\0\u0027) {\n    n_local \u003d (float)__aeabi_fmul(n_local,0x41200000);\n  }\n  uVar2 \u003d __addsf3(n_local,0x3f000000);\n  i \u003d \u0027\\0\u0027;\n  a \u003d __aeabi_f2iz(uVar2);\n  buf[settings.decimal_places] \u003d \u0027.\u0027;\n  for (; a !\u003d 0; a \u003d a / 10) {\n    if (i \u003d\u003d settings.decimal_places) {\n      i \u003d i + \u0027\\x01\u0027;\n    }\n    uVar4 \u003d (uint)i;\n    i \u003d i + \u0027\\x01\u0027;\n    buf[uVar4] \u003d (char)(a % 10) + \u00270\u0027;\n  }\n  while (i \u003c settings.decimal_places) {\n    uVar4 \u003d (uint)i;\n    i \u003d i + \u0027\\x01\u0027;\n    buf[uVar4] \u003d \u00270\u0027;\n  }\n  if (i \u003d\u003d settings.decimal_places) {\n    bVar3 \u003d i + 1;\n    i \u003d i + \u0027\\x02\u0027;\n    buf[bVar3] \u003d \u00270\u0027;\n  }\n  for (; i !\u003d \u0027\\0\u0027; i \u003d i + 0xff) {\n    serial_write(buf[i - 1]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "report_realtime_status",
        "report_gcode_parameters",
        "report_grbl_settings",
        "report_gcode_modes"
      ],
      "called": [
        "__aeabi_f2iz",
        "serial_write",
        "__addsf3",
        "__aeabi_fcmplt",
        "__aeabi_fmul"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "protocol_reset_line_buffer": {
      "entrypoint": "0x08003980",
      "current_name": "protocol_reset_line_buffer",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid protocol_reset_line_buffer(void)\n\n{\n  char_counter \u003d \u0027\\0\u0027;\n  iscomment \u003d \u0027\\0\u0027;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_process",
        "protocol_init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "protocol_init": {
      "entrypoint": "0x080039a0",
      "current_name": "protocol_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid protocol_init(void)\n\n{\n  protocol_reset_line_buffer();\n  report_init_message();\n  buttons_enabled \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "grbl_main"
      ],
      "called": [
        "report_init_message",
        "protocol_reset_line_buffer"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "protocol_execute_startup": {
      "entrypoint": "0x080039bc",
      "current_name": "protocol_execute_startup",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid protocol_execute_startup(void)\n\n{\n  uint8_t uVar1;\n  uint8_t n;\n  \n  for (n \u003d \u0027\\0\u0027; n \u003c 2; n \u003d n + \u0027\\x01\u0027) {\n    uVar1 \u003d settings_read_startup_line(n,line);\n    if (uVar1 \u003d\u003d \u0027\\0\u0027) {\n      report_status_message(\u0027\\n\u0027);\n    }\n    else if (line[0] !\u003d \u0027\\0\u0027) {\n      printString(line);\n      uVar1 \u003d gc_execute_line(line);\n      report_status_message(uVar1);\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_execute_line",
        "grbl_main"
      ],
      "called": [
        "gc_execute_line",
        "settings_read_startup_line",
        "printString",
        "report_status_message"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "buttons_isr": {
      "entrypoint": "0x08003a18",
      "current_name": "buttons_isr",
      "code": "\nvoid buttons_isr(uint32_t buttons)\n\n{\n  uint32_t buttons_local;\n  \n  if ((buttons \u0026 0x80) \u003d\u003d 0) {\n    if ((buttons \u0026 0x40) \u003d\u003d 0) {\n      if ((buttons \u0026 0x20) !\u003d 0) {\n        sys.execute \u003d sys.execute | 2;\n      }\n    }\n    else {\n      sys.execute \u003d sys.execute | 8;\n    }\n  }\n  else {\n    mc_reset();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "debounce_on_handler"
      ],
      "called": [
        "mc_reset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "protocol_execute_runtime": {
      "entrypoint": "0x08003a74",
      "current_name": "protocol_execute_runtime",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x08003ad2) */\n/* WARNING: Unknown calling convention */\n\nvoid protocol_execute_runtime(void)\n\n{\n  uint8_t uVar1;\n  uint8_t rt_exec;\n  \n  uVar1 \u003d sys.execute;\n  if (sys.execute !\u003d \u0027\\0\u0027) {\n    if ((sys.execute \u0026 0x60) !\u003d 0) {\n      sys.state \u003d \u0027\\x06\u0027;\n      if ((sys.execute \u0026 0x40) !\u003d 0) {\n        report_alarm_message(-1);\n        report_feedback_message(\u0027\\x01\u0027);\n        do {\n        } while( true );\n      }\n      report_alarm_message(-2);\n      sys.execute \u003d sys.execute \u0026 0x9f;\n    }\n    if ((uVar1 \u0026 0x10) \u003d\u003d 0) {\n      if ((uVar1 \u0026 1) !\u003d 0) {\n        report_realtime_status();\n        sys.execute \u003d sys.execute \u0026 0xfe;\n      }\n      if ((uVar1 \u0026 8) !\u003d 0) {\n        st_feed_hold();\n        sys.execute \u003d sys.execute \u0026 0xf7;\n      }\n      if ((uVar1 \u0026 4) !\u003d 0) {\n        st_cycle_reinitialize();\n        sys.execute \u003d sys.execute \u0026 0xfb;\n      }\n      if ((uVar1 \u0026 2) !\u003d 0) {\n        st_cycle_start();\n        if ((settings.flags \u0026 2) !\u003d 0) {\n          sys.auto_start \u003d \u0027\\x01\u0027;\n        }\n        sys.execute \u003d sys.execute \u0026 0xfd;\n      }\n    }\n    else {\n      sys.abort \u003d \u0027\\x01\u0027;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "mc_line",
        "mc_dwell",
        "grbl_main",
        "protocol_process",
        "plan_synchronize",
        "mc_go_home"
      ],
      "called": [
        "report_realtime_status",
        "report_alarm_message",
        "st_cycle_reinitialize",
        "st_cycle_start",
        "report_feedback_message",
        "st_feed_hold"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "protocol_execute_line": {
      "entrypoint": "0x08003b98",
      "current_name": "protocol_execute_line",
      "code": "\n/* WARNING: Variable defined which should be unmapped: line-local */\n\nuint8_t protocol_execute_line(char *line)\n\n{\n  byte bVar1;\n  uint8_t uVar2;\n  int iVar3;\n  undefined4 uVar4;\n  undefined4 extraout_r1;\n  uint uVar5;\n  float value_00;\n  undefined4 uStack_20;\n  char *line_local;\n  float value;\n  float parameter;\n  uint8_t char_counter;\n  uint8_t helper_var;\n  \n  if (*line !\u003d \u0027$\u0027) {\n    uVar2 \u003d gc_execute_line(line);\n    return uVar2;\n  }\n  char_counter \u003d \u0027\\x01\u0027;\n  helper_var \u003d \u0027\\0\u0027;\n  bVar1 \u003d line[1];\n  if (bVar1 \u003d\u003d 0) {\n    report_grbl_help();\n    return \u0027\\0\u0027;\n  }\n  if ((0x58 \u003c bVar1) || (bVar1 \u003c 0x23)) goto switchD_08003bdc_caseD_25;\n  switch(bVar1) {\n  case 0x23:\n    char_counter \u003d \u0027\\x02\u0027;\n    if (line[2] !\u003d \u0027\\0\u0027) {\n      return \u0027\\x03\u0027;\n    }\n    report_gcode_parameters();\n    break;\n  case 0x24:\n    char_counter \u003d \u0027\\x02\u0027;\n    if (line[2] !\u003d \u0027\\0\u0027) {\n      return \u0027\\x03\u0027;\n    }\n    report_grbl_settings();\n    break;\n  case 0x43:\n    char_counter \u003d \u0027\\x02\u0027;\n    if (line[2] !\u003d \u0027\\0\u0027) {\n      return \u0027\\x03\u0027;\n    }\n    if (sys.state \u003d\u003d \u0027\\a\u0027) {\n      mc_reset();\n      report_feedback_message(\u0027\\x05\u0027);\n    }\n    else {\n      if (sys.state !\u003d \u0027\\0\u0027) {\n        return \u0027\\v\u0027;\n      }\n      sys.state \u003d \u0027\\a\u0027;\n      report_feedback_message(\u0027\\x04\u0027);\n    }\n    break;\n  case 0x47:\n    char_counter \u003d \u0027\\x02\u0027;\n    if (line[2] !\u003d \u0027\\0\u0027) {\n      return \u0027\\x03\u0027;\n    }\n    report_gcode_modes();\n    break;\n  case 0x48:\n    if ((settings.flags \u0026 0x10) \u003d\u003d 0) {\n      return \u0027\\a\u0027;\n    }\n    if ((sys.state !\u003d \u0027\\0\u0027) \u0026\u0026 (sys.state !\u003d \u0027\\x06\u0027)) {\n      return \u0027\\v\u0027;\n    }\n    mc_go_home();\n    if (sys.abort \u003d\u003d \u0027\\0\u0027) {\n      protocol_execute_startup();\n    }\n    break;\n  case 0x4e:\n    char_counter \u003d \u0027\\x02\u0027;\n    if (line[2] \u003d\u003d \u0027\\0\u0027) {\n      for (helper_var \u003d \u0027\\0\u0027; helper_var \u003c 2; helper_var \u003d helper_var + \u0027\\x01\u0027) {\n        uVar2 \u003d settings_read_startup_line(helper_var,line);\n        if (uVar2 \u003d\u003d \u0027\\0\u0027) {\n          report_status_message(\u0027\\n\u0027);\n        }\n        else {\n          report_startup_line(helper_var,line);\n        }\n      }\n      return \u0027\\0\u0027;\n    }\n    helper_var \u003d \u0027\\x01\u0027;\n  default:\nswitchD_08003bdc_caseD_25:\n    iVar3 \u003d read_float(line,\u0026char_counter,\u0026parameter);\n    if (iVar3 \u003d\u003d 0) {\n      return \u0027\\x01\u0027;\n    }\n    bVar1 \u003d char_counter + 1;\n    if (line[char_counter] !\u003d \u0027\u003d\u0027) {\n      return \u0027\\x03\u0027;\n    }\n    char_counter \u003d bVar1;\n    if (helper_var \u003d\u003d \u0027\\0\u0027) {\n      iVar3 \u003d read_float(line,\u0026char_counter,\u0026value);\n      if (iVar3 \u003d\u003d 0) {\n        return \u0027\\x01\u0027;\n      }\n      if (line[char_counter] \u003d\u003d \u0027\\0\u0027) {\n        iVar3 \u003d __aeabi_f2iz(parameter);\n        uVar2 \u003d settings_store_global_setting(iVar3,value_00);\n        return uVar2;\n      }\n      return \u0027\\x03\u0027;\n    }\n    do {\n      line[(uint)char_counter - (uint)bVar1] \u003d line[char_counter];\n      uVar5 \u003d (uint)char_counter;\n      char_counter \u003d char_counter + \u0027\\x01\u0027;\n    } while (line[uVar5] !\u003d \u0027\\0\u0027);\n    helper_var \u003d bVar1;\n    helper_var \u003d gc_execute_line(line);\n    if (helper_var !\u003d \u0027\\0\u0027) {\n      return helper_var;\n    }\n    uVar4 \u003d __aeabi_f2d(parameter);\n    trunc((double)CONCAT44(line,uStack_20));\n    helper_var \u003d __aeabi_d2uiz(uVar4,extraout_r1);\n    settings_store_startup_line(helper_var,line);\n    break;\n  case 0x58:\n    char_counter \u003d \u0027\\x02\u0027;\n    if (line[2] !\u003d \u0027\\0\u0027) {\n      return \u0027\\x03\u0027;\n    }\n    if (sys.state \u003d\u003d \u0027\\x06\u0027) {\n      report_feedback_message(\u0027\\x03\u0027);\n      sys.state \u003d \u0027\\0\u0027;\n    }\n  }\n  return \u0027\\0\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_process"
      ],
      "called": [
        "report_startup_line",
        "report_gcode_parameters",
        "mc_reset",
        "report_status_message",
        "read_float",
        "mc_go_home",
        "report_gcode_modes",
        "protocol_execute_startup",
        "gc_execute_line",
        "__aeabi_f2iz",
        "settings_store_startup_line",
        "settings_store_global_setting",
        "report_grbl_help",
        "trunc",
        "settings_read_startup_line",
        "__aeabi_d2uiz",
        "report_feedback_message",
        "__aeabi_f2d",
        "report_grbl_settings"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "protocol_process": {
      "entrypoint": "0x08003f34",
      "current_name": "protocol_process",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid protocol_process(void)\n\n{\n  uint8_t status_code;\n  byte bVar1;\n  uint uVar2;\n  uint8_t c;\n  \n  while( true ) {\n    while( true ) {\n      bVar1 \u003d serial_read();\n      if (bVar1 \u003d\u003d 0xff) {\n        return;\n      }\n      if ((bVar1 \u003d\u003d 10) || (bVar1 \u003d\u003d 0xd)) break;\n      if (iscomment \u003d\u003d \u0027\\0\u0027) {\n        if ((0x20 \u003c bVar1) \u0026\u0026 (bVar1 !\u003d 0x2f)) {\n          if (bVar1 \u003d\u003d 0x28) {\n            iscomment \u003d \u0027\\x01\u0027;\n          }\n          else if (char_counter \u003d\u003d 0xff) {\n            report_status_message(\u0027\\r\u0027);\n            protocol_reset_line_buffer();\n          }\n          else if ((bVar1 \u003c 0x61) || (0x7a \u003c bVar1)) {\n            uVar2 \u003d (uint)char_counter;\n            char_counter \u003d char_counter + \u0027\\x01\u0027;\n            line[uVar2] \u003d bVar1;\n          }\n          else {\n            uVar2 \u003d (uint)char_counter;\n            char_counter \u003d char_counter + \u0027\\x01\u0027;\n            line[uVar2] \u003d bVar1 - 0x20;\n          }\n        }\n      }\n      else if (bVar1 \u003d\u003d 0x29) {\n        iscomment \u003d \u0027\\0\u0027;\n      }\n    }\n    protocol_execute_runtime();\n    if (sys.abort !\u003d \u0027\\0\u0027) break;\n    if (char_counter \u003d\u003d \u0027\\0\u0027) {\n      report_status_message(\u0027\\0\u0027);\n    }\n    else {\n      line[char_counter] \u003d \u0027\\0\u0027;\n      status_code \u003d protocol_execute_line(line);\n      report_status_message(status_code);\n    }\n    protocol_reset_line_buffer();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "grbl_main"
      ],
      "called": [
        "protocol_execute_line",
        "report_status_message",
        "protocol_execute_runtime",
        "serial_read",
        "protocol_reset_line_buffer"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "report_status_message": {
      "entrypoint": "0x08004030",
      "current_name": "report_status_message",
      "code": "\nvoid report_status_message(uint8_t status_code)\n\n{\n  uint8_t status_code_local;\n  \n  if (status_code \u003d\u003d \u0027\\0\u0027) {\n    printPgmString(\"ok\\r\\n\");\n  }\n  else {\n    printPgmString(\"error: \");\n    switch(status_code) {\n    case \u0027\\x01\u0027:\n      printPgmString(\"Bad number format\");\n      break;\n    case \u0027\\x02\u0027:\n      printPgmString(\"Expected command letter\");\n      break;\n    case \u0027\\x03\u0027:\n      printPgmString(\"Unsupported statement\");\n      break;\n    case \u0027\\x04\u0027:\n      printPgmString(\"Invalid radius\");\n      break;\n    case \u0027\\x05\u0027:\n      printPgmString(\"Modal group violation\");\n      break;\n    case \u0027\\x06\u0027:\n      printPgmString(\"Invalid statement\");\n      break;\n    case \u0027\\a\u0027:\n      printPgmString(\"Setting disabled\");\n      break;\n    case \u0027\\b\u0027:\n      printPgmString(\"Value \u003c 0.0\");\n      break;\n    case \u0027\\t\u0027:\n      printPgmString(\"Value \u003c 3 usec\");\n      break;\n    case \u0027\\n\u0027:\n      printPgmString(\"EEPROM read fail. Using defaults\");\n      break;\n    case \u0027\\v\u0027:\n      printPgmString(\"Busy or queued\");\n      break;\n    case \u0027\\f\u0027:\n      printPgmString(\"Alarm lock\");\n      break;\n    case \u0027\\r\u0027:\n      printPgmString(\"Line overflow\");\n    }\n    printPgmString(\"\\r\\n\");\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_execute_line",
        "report_gcode_parameters",
        "protocol_process",
        "gc_init",
        "settings_init",
        "protocol_execute_startup"
      ],
      "called": [
        "printPgmString"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "report_alarm_message": {
      "entrypoint": "0x08004148",
      "current_name": "report_alarm_message",
      "code": "\nvoid report_alarm_message(int8_t alarm_code)\n\n{\n  int8_t alarm_code_local;\n  \n  printPgmString(\"ALARM: \");\n  if (alarm_code \u003d\u003d -2) {\n    printPgmString(\"Abort during cycle\");\n  }\n  else if (alarm_code \u003d\u003d -1) {\n    printPgmString(\"Hard limit\");\n  }\n  printPgmString(\". MPos?\\r\\n\");\n  delay_ms(500);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_execute_runtime"
      ],
      "called": [
        "delay_ms",
        "printPgmString"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "report_feedback_message": {
      "entrypoint": "0x080041a0",
      "current_name": "report_feedback_message",
      "code": "\nvoid report_feedback_message(uint8_t message_code)\n\n{\n  uint8_t message_code_local;\n  \n  printPgmString(\"[\");\n  switch(message_code) {\n  case \u0027\\x01\u0027:\n    printPgmString(\"Reset to continue\");\n    break;\n  case \u0027\\x02\u0027:\n    printPgmString(\"\\\u0027$H\\\u0027|\\\u0027$X\\\u0027 to unlock\");\n    break;\n  case \u0027\\x03\u0027:\n    printPgmString(\"Caution: Unlocked\");\n    break;\n  case \u0027\\x04\u0027:\n    printPgmString(\"Enabled\");\n    break;\n  case \u0027\\x05\u0027:\n    printPgmString(\"Disabled\");\n  }\n  printPgmString(\"]\\r\\n\");\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_execute_line",
        "grbl_main",
        "protocol_execute_runtime"
      ],
      "called": [
        "printPgmString"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "report_init_message": {
      "entrypoint": "0x08004228",
      "current_name": "report_init_message",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid report_init_message(void)\n\n{\n  printPgmString(\"\\r\\nGrbl 0.8c [\\\u0027$\\\u0027 for help]\\r\\n\");\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_init"
      ],
      "called": [
        "printPgmString"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "report_grbl_help": {
      "entrypoint": "0x0800423c",
      "current_name": "report_grbl_help",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid report_grbl_help(void)\n\n{\n  printPgmString(\n                \"$$ (view Grbl settings)\\r\\n$# (view # parameters)\\r\\n$G (view parser state)\\r\\n$N (view startup blocks)\\r\\n$x\u003dvalue (save Grbl setting)\\r\\n$Nx\u003dline (save startup block)\\r\\n$C (check gcode mode)\\r\\n$X (kill alarm lock)\\r\\n$H (run homing cycle)\\r\\n~ (cycle start)\\r\\n! (feed hold)\\r\\n? (current status)\\r\\nctrl-x (reset Grbl)\\r\\n\"\n                );\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_execute_line"
      ],
      "called": [
        "printPgmString"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "report_grbl_settings": {
      "entrypoint": "0x08004250",
      "current_name": "report_grbl_settings",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid report_grbl_settings(void)\n\n{\n  float n;\n  float n_00;\n  float n_01;\n  float n_02;\n  float n_03;\n  float n_04;\n  float n_05;\n  float n_06;\n  float n_07;\n  float n_08;\n  float n_09;\n  \n  printPgmString(\"$0\u003d\");\n  printFloat(n);\n  printPgmString(\" (x, step/mm)\\r\\n$1\u003d\");\n  printFloat(n_00);\n  printPgmString(\" (y, step/mm)\\r\\n$2\u003d\");\n  printFloat(n_01);\n  printPgmString(\" (z, step/mm)\\r\\n$3\u003d\");\n  printInteger((uint)settings.pulse_microseconds);\n  printPgmString(\" (step pulse, usec)\\r\\n$4\u003d\");\n  printFloat(n_02);\n  printPgmString(\" (default feed, mm/min)\\r\\n$5\u003d\");\n  printFloat(n_03);\n  printPgmString(\" (default seek, mm/min)\\r\\n$6\u003d\");\n  printInteger((uint)settings.step_invert_mask);\n  printPgmString(\" (step port invert mask, int:\");\n  print_uint16_base2(settings.step_invert_mask);\n  printPgmString(\")\\r\\n$7\u003d\");\n  printInteger((uint)settings.stepper_idle_lock_time);\n  printPgmString(\" (step idle delay, msec)\\r\\n$8\u003d\");\n  n_04 \u003d (float)__aeabi_fdiv(settings.acceleration,0x45610000);\n  printFloat(n_04);\n  printPgmString(\" (acceleration, mm/sec^2)\\r\\n$9\u003d\");\n  printFloat(n_05);\n  printPgmString(\" (junction deviation, mm)\\r\\n$10\u003d\");\n  printFloat(n_06);\n  printPgmString(\" (arc, mm/segment)\\r\\n$11\u003d\");\n  printInteger((uint)settings.n_arc_correction);\n  printPgmString(\" (n-arc correction, int)\\r\\n$12\u003d\");\n  printInteger((uint)settings.decimal_places);\n  printPgmString(\" (n-decimals, int)\\r\\n$13\u003d\");\n  printInteger((uint)((settings.flags \u0026 1) !\u003d 0));\n  printPgmString(\" (report inches, bool)\\r\\n$14\u003d\");\n  printInteger((uint)((settings.flags \u0026 2) !\u003d 0));\n  printPgmString(\" (auto start, bool)\\r\\n$15\u003d\");\n  printInteger((uint)((settings.flags \u0026 4) !\u003d 0));\n  printPgmString(\" (invert step enable, bool)\\r\\n$16\u003d\");\n  printInteger((uint)((settings.flags \u0026 8) !\u003d 0));\n  printPgmString(\" (hard limits, bool)\\r\\n$17\u003d\");\n  printInteger((uint)((settings.flags \u0026 0x10) !\u003d 0));\n  printPgmString(\" (homing cycle, bool)\\r\\n$18\u003d\");\n  printInteger((uint)settings.homing_dir_mask);\n  printPgmString(\" (homing dir invert mask, int:\");\n  print_uint16_base2(settings.homing_dir_mask);\n  printPgmString(\")\\r\\n$19\u003d\");\n  printFloat(n_07);\n  printPgmString(\" (homing feed, mm/min)\\r\\n$20\u003d\");\n  printFloat(n_08);\n  printPgmString(\" (homing seek, mm/min)\\r\\n$21\u003d\");\n  printInteger((uint)settings.homing_debounce_delay);\n  printPgmString(\" (homing debounce, msec)\\r\\n$22\u003d\");\n  printFloat(n_09);\n  printPgmString(\" (homing pull-off, mm)\\r\\n$23\u003d\");\n  printInteger((uint)settings.dirn_invert_mask);\n  printPgmString(\" (dir port invert mask, int:\");\n  print_uint16_base2(settings.dirn_invert_mask);\n  printPgmString(\")\\r\\n\");\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_execute_line",
        "settings_init"
      ],
      "called": [
        "printFloat",
        "print_uint16_base2",
        "printPgmString",
        "printInteger",
        "__aeabi_fdiv"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "report_gcode_parameters": {
      "entrypoint": "0x080044e8",
      "current_name": "report_gcode_parameters",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid report_gcode_parameters(void)\n\n{\n  uint8_t uVar1;\n  float extraout_s0;\n  float extraout_s0_00;\n  float extraout_s0_01;\n  float extraout_s0_02;\n  float extraout_s0_03;\n  float extraout_s0_04;\n  float extraout_s0_05;\n  float extraout_s0_06;\n  float extraout_s0_07;\n  float extraout_s0_08;\n  float extraout_s0_09;\n  float extraout_s0_10;\n  float fVar2;\n  float extraout_s0_11;\n  float extraout_s0_12;\n  undefined8 uVar3;\n  float coord_data [3];\n  uint8_t i;\n  uint8_t coord_select;\n  \n  coord_select \u003d \u0027\\0\u0027;\n  while( true ) {\n    if (7 \u003c coord_select) {\n      printPgmString(\"[G92:\");\n      fVar2 \u003d extraout_s0_10;\n      for (i \u003d \u0027\\0\u0027; i \u003c 3; i \u003d i + \u0027\\x01\u0027) {\n        if ((settings.flags \u0026 1) \u003d\u003d 0) {\n          printFloat(fVar2);\n        }\n        else {\n          uVar3 \u003d __aeabi_f2d(gc.coord_offset[i]);\n          uVar3 \u003d __muldf3((int)uVar3,(int)((ulonglong)uVar3 \u003e\u003e 0x20),0x57e16865,0x3fa42851);\n          fVar2 \u003d (float)__truncdfsf2((int)uVar3,(int)((ulonglong)uVar3 \u003e\u003e 0x20));\n          printFloat(fVar2);\n        }\n        if (i \u003c 2) {\n          printPgmString(\",\");\n          fVar2 \u003d extraout_s0_11;\n        }\n        else {\n          printPgmString(\"]\\r\\n\");\n          fVar2 \u003d extraout_s0_12;\n        }\n      }\n      return;\n    }\n    uVar1 \u003d settings_read_coord_data(coord_select,coord_data);\n    if (uVar1 \u003d\u003d \u0027\\0\u0027) break;\n    printPgmString(\"[G\");\n    fVar2 \u003d extraout_s0;\n    switch(coord_select) {\n    case \u0027\\0\u0027:\n      printPgmString(\"54:\");\n      fVar2 \u003d extraout_s0_00;\n      break;\n    case \u0027\\x01\u0027:\n      printPgmString(\"55:\");\n      fVar2 \u003d extraout_s0_01;\n      break;\n    case \u0027\\x02\u0027:\n      printPgmString(\"56:\");\n      fVar2 \u003d extraout_s0_02;\n      break;\n    case \u0027\\x03\u0027:\n      printPgmString(\"57:\");\n      fVar2 \u003d extraout_s0_03;\n      break;\n    case \u0027\\x04\u0027:\n      printPgmString(\"58:\");\n      fVar2 \u003d extraout_s0_04;\n      break;\n    case \u0027\\x05\u0027:\n      printPgmString(\"59:\");\n      fVar2 \u003d extraout_s0_05;\n      break;\n    case \u0027\\x06\u0027:\n      printPgmString(\"28:\");\n      fVar2 \u003d extraout_s0_06;\n      break;\n    case \u0027\\a\u0027:\n      printPgmString(\"30:\");\n      fVar2 \u003d extraout_s0_07;\n    }\n    for (i \u003d \u0027\\0\u0027; i \u003c 3; i \u003d i + \u0027\\x01\u0027) {\n      if ((settings.flags \u0026 1) \u003d\u003d 0) {\n        printFloat(fVar2);\n      }\n      else {\n        uVar3 \u003d __aeabi_f2d(coord_data[i]);\n        uVar3 \u003d __muldf3((int)uVar3,(int)((ulonglong)uVar3 \u003e\u003e 0x20),0x57e16865,0x3fa42851);\n        fVar2 \u003d (float)__truncdfsf2((int)uVar3,(int)((ulonglong)uVar3 \u003e\u003e 0x20));\n        printFloat(fVar2);\n      }\n      if (i \u003c 2) {\n        printPgmString(\",\");\n        fVar2 \u003d extraout_s0_08;\n      }\n      else {\n        printPgmString(\"]\\r\\n\");\n        fVar2 \u003d extraout_s0_09;\n      }\n    }\n    coord_select \u003d coord_select + \u0027\\x01\u0027;\n  }\n  report_status_message(\u0027\\n\u0027);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_execute_line"
      ],
      "called": [
        "printFloat",
        "settings_read_coord_data",
        "__truncdfsf2",
        "report_status_message",
        "printPgmString",
        "__aeabi_f2d",
        "__muldf3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "report_gcode_modes": {
      "entrypoint": "0x080046d0",
      "current_name": "report_gcode_modes",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid report_gcode_modes(void)\n\n{\n  float n;\n  float n_00;\n  undefined8 uVar1;\n  \n  switch(gc.motion_mode) {\n  case \u0027\\0\u0027:\n    printPgmString(\"[G0\");\n    break;\n  case \u0027\\x01\u0027:\n    printPgmString(\"[G1\");\n    break;\n  case \u0027\\x02\u0027:\n    printPgmString(\"[G2\");\n    break;\n  case \u0027\\x03\u0027:\n    printPgmString(\"[G3\");\n    break;\n  case \u0027\\x04\u0027:\n    printPgmString(\"[G80\");\n  }\n  printPgmString(\" G\");\n  printInteger(gc.coord_select + 0x36);\n  if (gc.plane_axis_0 \u003d\u003d \u0027\\0\u0027) {\n    if (gc.plane_axis_1 \u003d\u003d \u0027\\x01\u0027) {\n      printPgmString(\" G17\");\n    }\n    else {\n      printPgmString(\" G18\");\n    }\n  }\n  else {\n    printPgmString(\" G19\");\n  }\n  if (gc.inches_mode \u003d\u003d \u0027\\0\u0027) {\n    printPgmString(\" G21\");\n  }\n  else {\n    printPgmString(\" G20\");\n  }\n  if (gc.absolute_mode \u003d\u003d \u0027\\0\u0027) {\n    printPgmString(\" G91\");\n  }\n  else {\n    printPgmString(\" G90\");\n  }\n  if (gc.inverse_feed_rate_mode \u003d\u003d \u0027\\0\u0027) {\n    printPgmString(\" G94\");\n  }\n  else {\n    printPgmString(\" G93\");\n  }\n  if (gc.program_flow \u003d\u003d \u0027\\x02\u0027) {\n    printPgmString(\" M2\");\n  }\n  else if (gc.program_flow \u003c 3) {\n    if (gc.program_flow \u003d\u003d \u0027\\0\u0027) {\n      printPgmString(\" M0\");\n    }\n    else if (gc.program_flow \u003d\u003d \u0027\\x01\u0027) {\n      printPgmString(\" M1\");\n    }\n  }\n  if (gc.spindle_direction \u003d\u003d \u0027\\x01\u0027) {\n    printPgmString(\" M3\");\n  }\n  else if (gc.spindle_direction \u003c \u0027\\x02\u0027) {\n    if (gc.spindle_direction \u003d\u003d -1) {\n      printPgmString(\" M4\");\n    }\n    else if (gc.spindle_direction \u003d\u003d \u0027\\0\u0027) {\n      printPgmString(\" M5\");\n    }\n  }\n  if (gc.coolant_mode \u003d\u003d \u0027\\x02\u0027) {\n    printPgmString(\" M7\");\n  }\n  else if (gc.coolant_mode \u003c 3) {\n    if (gc.coolant_mode \u003d\u003d \u0027\\0\u0027) {\n      printPgmString(\" M9\");\n    }\n    else if (gc.coolant_mode \u003d\u003d \u0027\\x01\u0027) {\n      printPgmString(\" M8\");\n    }\n  }\n  printPgmString(\" T\");\n  printInteger((uint)gc.tool);\n  printPgmString(\" F\");\n  if (gc.inches_mode \u003d\u003d \u0027\\0\u0027) {\n    printFloat(n);\n  }\n  else {\n    uVar1 \u003d __aeabi_f2d(gc.feed_rate);\n    uVar1 \u003d __muldf3((int)uVar1,(int)((ulonglong)uVar1 \u003e\u003e 0x20),0x57e16865,0x3fa42851);\n    n_00 \u003d (float)__truncdfsf2((int)uVar1,(int)((ulonglong)uVar1 \u003e\u003e 0x20));\n    printFloat(n_00);\n  }\n  printPgmString(\"]\\r\\n\");\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_execute_line"
      ],
      "called": [
        "printFloat",
        "__truncdfsf2",
        "printPgmString",
        "printInteger",
        "__aeabi_f2d",
        "__muldf3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "report_startup_line": {
      "entrypoint": "0x08004900",
      "current_name": "report_startup_line",
      "code": "\nvoid report_startup_line(uint8_t n,char *line)\n\n{\n  char *line_local;\n  uint8_t n_local;\n  \n  printPgmString(\"$N\");\n  printInteger((uint)n);\n  printPgmString(\"\u003d\");\n  printString(line);\n  printPgmString(\"\\r\\n\");\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_execute_line"
      ],
      "called": [
        "printString",
        "printPgmString",
        "printInteger"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "report_realtime_status": {
      "entrypoint": "0x08004940",
      "current_name": "report_realtime_status",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid report_realtime_status(void)\n\n{\n  undefined4 uVar1;\n  float fVar2;\n  float extraout_s0;\n  float extraout_s0_00;\n  float extraout_s0_01;\n  float extraout_s0_02;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  float print_position [3];\n  int32_t current_position [3];\n  uint8_t i;\n  \n  current_position[0] \u003d sys.position[0];\n  current_position[1] \u003d sys.position[1];\n  current_position[2] \u003d sys.position[2];\n  switch(sys.state) {\n  case \u0027\\0\u0027:\n    printPgmString(\"\u003cIdle\");\n    break;\n  case \u0027\\x02\u0027:\n    printPgmString(\"\u003cQueue\");\n    break;\n  case \u0027\\x03\u0027:\n    printPgmString(\"\u003cRun\");\n    break;\n  case \u0027\\x04\u0027:\n    printPgmString(\"\u003cHold\");\n    break;\n  case \u0027\\x05\u0027:\n    printPgmString(\"\u003cHome\");\n    break;\n  case \u0027\\x06\u0027:\n    printPgmString(\"\u003cAlarm\");\n    break;\n  case \u0027\\a\u0027:\n    printPgmString(\"\u003cCheck\");\n  }\n  printPgmString(\",MPos:\");\n  for (i \u003d \u0027\\0\u0027; i \u003c 3; i \u003d i + \u0027\\x01\u0027) {\n    uVar1 \u003d __floatsisf(current_position[i]);\n    fVar2 \u003d (float)__aeabi_fdiv(uVar1,settings.steps_per_mm[i]);\n    print_position[i] \u003d fVar2;\n    fVar2 \u003d extraout_s0;\n    if ((settings.flags \u0026 1) !\u003d 0) {\n      uVar3 \u003d __aeabi_f2d(print_position[i]);\n      uVar3 \u003d __muldf3((int)uVar3,(int)((ulonglong)uVar3 \u003e\u003e 0x20),0x57e16865,0x3fa42851);\n      fVar2 \u003d (float)__truncdfsf2((int)uVar3,(int)((ulonglong)uVar3 \u003e\u003e 0x20));\n      print_position[i] \u003d fVar2;\n      fVar2 \u003d extraout_s0_00;\n    }\n    printFloat(fVar2);\n    printPgmString(\",\");\n  }\n  printPgmString(\"WPos:\");\n  for (i \u003d \u0027\\0\u0027; i \u003c 3; i \u003d i + \u0027\\x01\u0027) {\n    if ((settings.flags \u0026 1) \u003d\u003d 0) {\n      fVar2 \u003d print_position[i];\n      uVar1 \u003d __addsf3(gc.coord_system[i],gc.coord_offset[i]);\n      fVar2 \u003d (float)__aeabi_fsub(fVar2,uVar1);\n      print_position[i] \u003d fVar2;\n      fVar2 \u003d extraout_s0_02;\n    }\n    else {\n      uVar3 \u003d __aeabi_f2d(print_position[i]);\n      uVar1 \u003d __addsf3(gc.coord_system[i],gc.coord_offset[i]);\n      uVar4 \u003d __aeabi_f2d(uVar1);\n      uVar4 \u003d __muldf3((int)uVar4,(int)((ulonglong)uVar4 \u003e\u003e 0x20),0x57e16865,0x3fa42851);\n      uVar3 \u003d __subdf3((int)uVar3,(int)((ulonglong)uVar3 \u003e\u003e 0x20),(int)uVar4,\n                       (int)((ulonglong)uVar4 \u003e\u003e 0x20));\n      fVar2 \u003d (float)__truncdfsf2((int)uVar3,(int)((ulonglong)uVar3 \u003e\u003e 0x20));\n      print_position[i] \u003d fVar2;\n      fVar2 \u003d extraout_s0_01;\n    }\n    printFloat(fVar2);\n    if (i \u003c 2) {\n      printPgmString(\",\");\n    }\n  }\n  printPgmString(\"\u003e\\r\\n\");\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_execute_runtime"
      ],
      "called": [
        "__aeabi_fsub",
        "printFloat",
        "__floatsisf",
        "__truncdfsf2",
        "__addsf3",
        "printPgmString",
        "__aeabi_fdiv",
        "__aeabi_f2d",
        "__subdf3",
        "__muldf3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "settings_store_startup_line": {
      "entrypoint": "0x08004bc0",
      "current_name": "settings_store_startup_line",
      "code": "\nvoid settings_store_startup_line(uint8_t n,char *line)\n\n{\n  char *line_local;\n  uint8_t n_local;\n  uint16_t addr;\n  \n  memcpy_to_eeprom_with_checksum((uint)(ushort)((ushort)n * 0x101 + 0x300),line,0x100);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_execute_line",
        "settings_read_startup_line"
      ],
      "called": [
        "memcpy_to_eeprom_with_checksum"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "settings_write_coord_data": {
      "entrypoint": "0x08004bf4",
      "current_name": "settings_write_coord_data",
      "code": "\nvoid settings_write_coord_data(uint8_t coord_select,float *coord_data)\n\n{\n  float *coord_data_local;\n  uint8_t coord_select_local;\n  uint16_t addr;\n  \n  memcpy_to_eeprom_with_checksum\n            ((uint)(ushort)((ushort)coord_select * 0xd + 0x200),(char *)coord_data,0xc);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line",
        "settings_read_coord_data"
      ],
      "called": [
        "memcpy_to_eeprom_with_checksum"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "write_global_settings": {
      "entrypoint": "0x08004c2a",
      "current_name": "write_global_settings",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid write_global_settings(void)\n\n{\n  eeprom_put_char(0,\u0027\\x05\u0027);\n  memcpy_to_eeprom_with_checksum(1,(char *)\u0026settings,0x40);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "settings_store_global_setting",
        "settings_reset"
      ],
      "called": [
        "eeprom_put_char",
        "memcpy_to_eeprom_with_checksum"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "settings_reset": {
      "entrypoint": "0x08004c48",
      "current_name": "settings_reset",
      "code": "\nvoid settings_reset(_Bool reset_all)\n\n{\n  _Bool reset_all_local;\n  \n  if (reset_all) {\n    settings.steps_per_mm[0] \u003d 157.4803;\n    settings.steps_per_mm[1] \u003d 157.4803;\n    settings.steps_per_mm[2] \u003d 157.4803;\n    settings.pulse_microseconds \u003d \u0027\\n\u0027;\n    settings.default_feed_rate \u003d 250.0;\n    settings.default_seek_rate \u003d 500.0;\n    settings.acceleration \u003d 36000.0;\n    settings.mm_per_arc_segment \u003d 0.1;\n    settings.step_invert_mask \u003d 0;\n    settings.dirn_invert_mask \u003d 0xa80;\n    settings.junction_deviation \u003d 0.05;\n  }\n  settings.flags \u003d \u0027\\x12\u0027;\n  settings.homing_dir_mask \u003d 0;\n  settings.homing_feed_rate \u003d 25.0;\n  settings.homing_seek_rate \u003d 250.0;\n  settings.homing_debounce_delay \u003d 100;\n  settings.homing_pulloff \u003d 1.0;\n  settings.stepper_idle_lock_time \u003d \u0027\\x19\u0027;\n  settings.decimal_places \u003d \u0027\\x03\u0027;\n  settings.n_arc_correction \u003d \u0027\\x19\u0027;\n  write_global_settings();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "settings_init",
        "read_global_settings"
      ],
      "called": [
        "write_global_settings"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "settings_read_startup_line": {
      "entrypoint": "0x08004d2c",
      "current_name": "settings_read_startup_line",
      "code": "\nuint8_t settings_read_startup_line(uint8_t n,char *line)\n\n{\n  int iVar1;\n  char *line_local;\n  uint8_t n_local;\n  uint16_t addr;\n  \n  iVar1 \u003d memcpy_from_eeprom_with_checksum(line,(uint)(ushort)((ushort)n * 0x101 + 0x300),0x100);\n  if (iVar1 \u003d\u003d 0) {\n    *line \u003d \u0027\\0\u0027;\n    settings_store_startup_line(n,line);\n  }\n  return iVar1 !\u003d 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_execute_line",
        "protocol_execute_startup"
      ],
      "called": [
        "settings_store_startup_line",
        "memcpy_from_eeprom_with_checksum"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "settings_read_coord_data": {
      "entrypoint": "0x08004d7c",
      "current_name": "settings_read_coord_data",
      "code": "\nuint8_t settings_read_coord_data(uint8_t coord_select,float *coord_data)\n\n{\n  int iVar1;\n  float *coord_data_local;\n  uint8_t coord_select_local;\n  uint16_t addr;\n  \n  iVar1 \u003d memcpy_from_eeprom_with_checksum\n                    ((char *)coord_data,(uint)(ushort)((ushort)coord_select * 0xd + 0x200),0xc);\n  if (iVar1 \u003d\u003d 0) {\n    memset(coord_data,0,0xc);\n    settings_write_coord_data(coord_select,coord_data);\n  }\n  return iVar1 !\u003d 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line",
        "report_gcode_parameters",
        "gc_init",
        "settings_init"
      ],
      "called": [
        "settings_write_coord_data",
        "memset",
        "memcpy_from_eeprom_with_checksum"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "read_global_settings": {
      "entrypoint": "0x08004dd2",
      "current_name": "read_global_settings",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t read_global_settings(void)\n\n{\n  byte bVar1;\n  int iVar2;\n  uint8_t version;\n  \n  bVar1 \u003d eeprom_get_char(0);\n  if (bVar1 \u003d\u003d 5) {\n    iVar2 \u003d memcpy_from_eeprom_with_checksum((char *)\u0026settings,1,0x40);\n    if (iVar2 \u003d\u003d 0) {\n      return \u0027\\0\u0027;\n    }\n  }\n  else {\n    if (4 \u003c bVar1) {\n      return \u0027\\0\u0027;\n    }\n    iVar2 \u003d memcpy_from_eeprom_with_checksum((char *)\u0026settings,1,0x28);\n    if (iVar2 \u003d\u003d 0) {\n      return \u0027\\0\u0027;\n    }\n    settings_reset(false);\n  }\n  return \u0027\\x01\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "settings_init"
      ],
      "called": [
        "memcpy_from_eeprom_with_checksum",
        "eeprom_get_char",
        "settings_reset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "settings_store_global_setting": {
      "entrypoint": "0x08004e30",
      "current_name": "settings_store_global_setting",
      "code": "\n/* WARNING: Variable defined which should be unmapped: value-local */\n\nuint8_t settings_store_global_setting(int parameter,float value)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  float in_r1;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined4 extraout_r1_03;\n  undefined4 extraout_r1_04;\n  undefined4 extraout_r1_05;\n  undefined4 extraout_r1_06;\n  float value_local;\n  int parameter_local;\n  \n  switch(parameter) {\n  case 0:\n  case 1:\n  case 2:\n    iVar1 \u003d __aeabi_fcmple(value,in_r1,0);\n    if (iVar1 !\u003d 0) {\n      return \u0027\\b\u0027;\n    }\n    settings.steps_per_mm[parameter] \u003d in_r1;\n    break;\n  case 3:\n    iVar1 \u003d __aeabi_fcmplt(in_r1,0x40400000);\n    if (iVar1 !\u003d 0) {\n      return \u0027\\t\u0027;\n    }\n    uVar2 \u003d __aeabi_f2d(in_r1);\n    round((double)CONCAT44(parameter,in_r1));\n    settings.pulse_microseconds \u003d __aeabi_d2uiz(uVar2,extraout_r1);\n    break;\n  case 4:\n    settings.default_feed_rate \u003d in_r1;\n    break;\n  case 5:\n    settings.default_seek_rate \u003d in_r1;\n    break;\n  case 6:\n    uVar2 \u003d __aeabi_f2d(in_r1);\n    trunc((double)CONCAT44(parameter,in_r1));\n    settings.step_invert_mask \u003d __aeabi_d2uiz(uVar2,extraout_r1_00);\n    break;\n  case 7:\n    uVar2 \u003d __aeabi_f2d(in_r1);\n    round((double)CONCAT44(parameter,in_r1));\n    settings.stepper_idle_lock_time \u003d __aeabi_d2uiz(uVar2,extraout_r1_01);\n    break;\n  case 8:\n    uVar2 \u003d __aeabi_fmul(in_r1,0x42700000);\n    settings.acceleration \u003d (float)__aeabi_fmul(uVar2,0x42700000);\n    break;\n  case 9:\n    settings.junction_deviation \u003d (float)((uint)in_r1 \u0026 0x7fffffff);\n    break;\n  case 10:\n    settings.mm_per_arc_segment \u003d in_r1;\n    break;\n  case 0xb:\n    uVar2 \u003d __aeabi_f2d(in_r1);\n    round((double)CONCAT44(parameter,in_r1));\n    settings.n_arc_correction \u003d __aeabi_d2uiz(uVar2,extraout_r1_02);\n    break;\n  case 0xc:\n    uVar2 \u003d __aeabi_f2d(in_r1);\n    round((double)CONCAT44(parameter,in_r1));\n    settings.decimal_places \u003d __aeabi_d2uiz(uVar2,extraout_r1_03);\n    break;\n  case 0xd:\n    iVar1 \u003d __aeabi_fcmpeq(in_r1,0);\n    if (iVar1 \u003d\u003d 0) {\n      settings.flags \u003d settings.flags | 1;\n    }\n    else {\n      settings.flags \u003d settings.flags \u0026 0xfe;\n    }\n    break;\n  case 0xe:\n    iVar1 \u003d __aeabi_fcmpeq(in_r1,0);\n    if (iVar1 \u003d\u003d 0) {\n      settings.flags \u003d settings.flags | 2;\n    }\n    else {\n      settings.flags \u003d settings.flags \u0026 0xfd;\n    }\n    break;\n  case 0xf:\n    iVar1 \u003d __aeabi_fcmpeq(in_r1,0);\n    if (iVar1 \u003d\u003d 0) {\n      settings.flags \u003d settings.flags | 4;\n    }\n    else {\n      settings.flags \u003d settings.flags \u0026 0xfb;\n    }\n    break;\n  case 0x10:\n    iVar1 \u003d __aeabi_fcmpeq(in_r1,0);\n    if (iVar1 \u003d\u003d 0) {\n      settings.flags \u003d settings.flags | 8;\n    }\n    else {\n      settings.flags \u003d settings.flags \u0026 0xf7;\n    }\n    limits_init();\n    break;\n  case 0x11:\n    iVar1 \u003d __aeabi_fcmpeq(in_r1,0);\n    if (iVar1 \u003d\u003d 0) {\n      settings.flags \u003d settings.flags | 0x10;\n    }\n    else {\n      settings.flags \u003d settings.flags \u0026 0xef;\n    }\n    break;\n  case 0x12:\n    uVar2 \u003d __aeabi_f2d(in_r1);\n    trunc((double)CONCAT44(parameter,in_r1));\n    settings.homing_dir_mask \u003d __aeabi_d2uiz(uVar2,extraout_r1_04);\n    break;\n  case 0x13:\n    settings.homing_feed_rate \u003d in_r1;\n    break;\n  case 0x14:\n    settings.homing_seek_rate \u003d in_r1;\n    break;\n  case 0x15:\n    uVar2 \u003d __aeabi_f2d(in_r1);\n    round((double)CONCAT44(parameter,in_r1));\n    settings.homing_debounce_delay \u003d __aeabi_d2uiz(uVar2,extraout_r1_05);\n    break;\n  case 0x16:\n    settings.homing_pulloff \u003d in_r1;\n    break;\n  case 0x17:\n    uVar2 \u003d __aeabi_f2d(in_r1);\n    trunc((double)CONCAT44(parameter,in_r1));\n    settings.dirn_invert_mask \u003d __aeabi_d2uiz(uVar2,extraout_r1_06);\n    break;\n  default:\n    return \u0027\\x06\u0027;\n  }\n  write_global_settings();\n  return \u0027\\0\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_execute_line"
      ],
      "called": [
        "trunc",
        "__aeabi_d2uiz",
        "round",
        "__aeabi_fcmpeq",
        "__aeabi_fcmple",
        "__aeabi_fcmplt",
        "limits_init",
        "__aeabi_fmul",
        "write_global_settings",
        "__aeabi_f2d"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "settings_init": {
      "entrypoint": "0x080051b4",
      "current_name": "settings_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid settings_init(void)\n\n{\n  uint8_t uVar1;\n  float coord_data [3];\n  uint8_t i;\n  \n  uVar1 \u003d read_global_settings();\n  if (uVar1 \u003d\u003d \u0027\\0\u0027) {\n    report_status_message(\u0027\\n\u0027);\n    settings_reset(true);\n    report_grbl_settings();\n  }\n  for (i \u003d \u0027\\0\u0027; i \u003c 8; i \u003d i + \u0027\\x01\u0027) {\n    uVar1 \u003d settings_read_coord_data(i,coord_data);\n    if (uVar1 \u003d\u003d \u0027\\0\u0027) {\n      report_status_message(\u0027\\n\u0027);\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "grbl_main"
      ],
      "called": [
        "settings_read_coord_data",
        "report_status_message",
        "read_global_settings",
        "settings_reset",
        "report_grbl_settings"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "spindle_on": {
      "entrypoint": "0x08005208",
      "current_name": "spindle_on",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid spindle_on(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "spindle_run"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "spindle_off": {
      "entrypoint": "0x08005214",
      "current_name": "spindle_off",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid spindle_off(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "spindle_stop"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "spindle_fwd": {
      "entrypoint": "0x08005220",
      "current_name": "spindle_fwd",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid spindle_fwd(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "spindle_run"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "spindle_rev": {
      "entrypoint": "0x0800522c",
      "current_name": "spindle_rev",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid spindle_rev(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "spindle_run"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "spindle_init": {
      "entrypoint": "0x08005238",
      "current_name": "spindle_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid spindle_init(void)\n\n{\n  current_direction \u003d \u0027\\0\u0027;\n  spindle_stop();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "grbl_main"
      ],
      "called": [
        "spindle_stop"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "spindle_stop": {
      "entrypoint": "0x08005250",
      "current_name": "spindle_stop",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid spindle_stop(void)\n\n{\n  spindle_off();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "spindle_run",
        "mc_reset",
        "spindle_init"
      ],
      "called": [
        "spindle_off"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "spindle_run": {
      "entrypoint": "0x0800525c",
      "current_name": "spindle_run",
      "code": "\nvoid spindle_run(int8_t direction)\n\n{\n  int8_t direction_local;\n  \n  if ((int)direction !\u003d (uint)current_direction) {\n    plan_synchronize();\n    if (direction \u003d\u003d \u0027\\0\u0027) {\n      spindle_stop();\n      current_direction \u003d direction;\n    }\n    else {\n      if (direction \u003c \u0027\\x01\u0027) {\n        spindle_rev();\n      }\n      else {\n        spindle_fwd();\n      }\n      spindle_on();\n      current_direction \u003d direction;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line"
      ],
      "called": [
        "spindle_fwd",
        "spindle_on",
        "spindle_stop",
        "plan_synchronize",
        "spindle_rev"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stepper_motor_disable": {
      "entrypoint": "0x0800530c",
      "current_name": "stepper_motor_disable",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stepper_motor_disable(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "st_go_idle"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stepper_motor_enable": {
      "entrypoint": "0x08005318",
      "current_name": "stepper_motor_enable",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stepper_motor_enable(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "st_wake_up"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "set_step_events_per_minute": {
      "entrypoint": "0x08005324",
      "current_name": "set_step_events_per_minute",
      "code": "\nvoid set_step_events_per_minute(uint32_t steps_per_minute)\n\n{\n  uint32_t steps_per_minute_local;\n  uint32_t ticks;\n  \n  steps_per_minute_local \u003d steps_per_minute;\n  if (steps_per_minute \u003c 800) {\n    steps_per_minute_local \u003d 800;\n  }\n  st.cycles_per_step_event \u003d 1260000000 / steps_per_minute_local;\n  set_step_period(st.cycles_per_step_event);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "st_cycle_reinitialize",
        "st_reset",
        "step_period_isr"
      ],
      "called": [
        "set_step_period"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "iterate_trapezoid_cycle_counter": {
      "entrypoint": "0x08005360",
      "current_name": "iterate_trapezoid_cycle_counter",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint iterate_trapezoid_cycle_counter(void)\n\n{\n  bool bVar1;\n  \n  st.trapezoid_tick_cycle_counter \u003d st.cycles_per_step_event + st.trapezoid_tick_cycle_counter;\n  bVar1 \u003d 420000 \u003c st.trapezoid_tick_cycle_counter;\n  if (bVar1) {\n    st.trapezoid_tick_cycle_counter \u003d st.trapezoid_tick_cycle_counter - 420000;\n  }\n  return (uint)bVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "step_period_isr"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "step_period_isr": {
      "entrypoint": "0x080053a0",
      "current_name": "step_period_isr",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid step_period_isr(void)\n\n{\n  int iVar1;\n  \n  dirn_wr((uint)dirn_bits);\n  saved_step_bits \u003d step_bits;\n  if (current_block \u003d\u003d (block_t *)0x0) {\n    current_block \u003d plan_get_current_block();\n    if (current_block \u003d\u003d (block_t *)0x0) {\n      st_go_idle();\n      sys.execute \u003d sys.execute | 4;\n    }\n    else {\n      if (sys.state \u003d\u003d \u0027\\x03\u0027) {\n        st.trapezoid_adjusted_rate \u003d current_block-\u003einitial_rate;\n        set_step_events_per_minute(st.trapezoid_adjusted_rate);\n        st.trapezoid_tick_cycle_counter \u003d 210000;\n      }\n      st.min_safe_rate \u003d (current_block-\u003erate_delta \u003e\u003e 1) + current_block-\u003erate_delta;\n      st.counter_x \u003d -(current_block-\u003estep_event_count \u003e\u003e 1);\n      st.event_count \u003d current_block-\u003estep_event_count;\n      st.step_events_completed \u003d 0;\n      st.counter_y \u003d st.counter_x;\n      st.counter_z \u003d st.counter_x;\n    }\n  }\n  if (current_block !\u003d (block_t *)0x0) {\n    dirn_bits \u003d current_block-\u003edirection_bits;\n    step_bits \u003d 0;\n    st.counter_x \u003d current_block-\u003esteps_x + st.counter_x;\n    if (0 \u003c st.counter_x) {\n      step_bits \u003d 0x10;\n      st.counter_x \u003d st.counter_x - st.event_count;\n      if ((dirn_bits \u0026 0x20) \u003d\u003d 0) {\n        sys.position[0] \u003d sys.position[0] + 1;\n      }\n      else {\n        sys.position[0] \u003d sys.position[0] + -1;\n      }\n    }\n    st.counter_y \u003d current_block-\u003esteps_y + st.counter_y;\n    if (0 \u003c st.counter_y) {\n      step_bits \u003d step_bits | 0x440;\n      st.counter_y \u003d st.counter_y - st.event_count;\n      if ((dirn_bits \u0026 0x80) \u003d\u003d 0) {\n        sys.position[1] \u003d sys.position[1] + 1;\n      }\n      else {\n        sys.position[1] \u003d sys.position[1] + -1;\n      }\n    }\n    st.counter_z \u003d current_block-\u003esteps_z + st.counter_z;\n    if (0 \u003c st.counter_z) {\n      step_bits \u003d step_bits | 0x100;\n      st.counter_z \u003d st.counter_z - st.event_count;\n      if ((dirn_bits \u0026 0x200) \u003d\u003d 0) {\n        sys.position[2] \u003d sys.position[2] + 1;\n      }\n      else {\n        sys.position[2] \u003d sys.position[2] + -1;\n      }\n    }\n    st.step_events_completed \u003d st.step_events_completed + 1;\n    if (st.step_events_completed \u003c (uint)current_block-\u003estep_event_count) {\n      if (sys.state \u003d\u003d \u0027\\x04\u0027) {\n        iVar1 \u003d iterate_trapezoid_cycle_counter();\n        if (iVar1 !\u003d 0) {\n          if ((uint)current_block-\u003erate_delta \u003c st.trapezoid_adjusted_rate) {\n            st.trapezoid_adjusted_rate \u003d st.trapezoid_adjusted_rate - current_block-\u003erate_delta;\n            set_step_events_per_minute(st.trapezoid_adjusted_rate);\n          }\n          else {\n            st_go_idle();\n            sys.execute \u003d sys.execute | 4;\n          }\n        }\n      }\n      else if (st.step_events_completed \u003c current_block-\u003eaccelerate_until) {\n        iVar1 \u003d iterate_trapezoid_cycle_counter();\n        if (iVar1 !\u003d 0) {\n          st.trapezoid_adjusted_rate \u003d st.trapezoid_adjusted_rate + current_block-\u003erate_delta;\n          if (current_block-\u003enominal_rate \u003c\u003d st.trapezoid_adjusted_rate) {\n            st.trapezoid_adjusted_rate \u003d current_block-\u003enominal_rate;\n          }\n          set_step_events_per_minute(st.trapezoid_adjusted_rate);\n        }\n      }\n      else if (st.step_events_completed \u003c current_block-\u003edecelerate_after) {\n        if (st.trapezoid_adjusted_rate !\u003d current_block-\u003enominal_rate) {\n          st.trapezoid_adjusted_rate \u003d current_block-\u003enominal_rate;\n          set_step_events_per_minute(st.trapezoid_adjusted_rate);\n        }\n      }\n      else if (st.step_events_completed \u003d\u003d current_block-\u003edecelerate_after) {\n        if (st.trapezoid_adjusted_rate \u003d\u003d current_block-\u003enominal_rate) {\n          st.trapezoid_tick_cycle_counter \u003d 210000;\n        }\n        else {\n          st.trapezoid_tick_cycle_counter \u003d 420000 - st.trapezoid_tick_cycle_counter;\n        }\n      }\n      else {\n        iVar1 \u003d iterate_trapezoid_cycle_counter();\n        if (iVar1 !\u003d 0) {\n          if (st.min_safe_rate \u003c st.trapezoid_adjusted_rate) {\n            st.trapezoid_adjusted_rate \u003d st.trapezoid_adjusted_rate - current_block-\u003erate_delta;\n          }\n          else {\n            st.trapezoid_adjusted_rate \u003d st.trapezoid_adjusted_rate \u003e\u003e 1;\n          }\n          if (st.trapezoid_adjusted_rate \u003c current_block-\u003efinal_rate) {\n            st.trapezoid_adjusted_rate \u003d current_block-\u003efinal_rate;\n          }\n          set_step_events_per_minute(st.trapezoid_adjusted_rate);\n        }\n      }\n    }\n    else {\n      step_bits \u003d 0;\n      current_block \u003d (block_t *)0x0;\n      plan_discard_current_block();\n    }\n  }\n  step_bits \u003d step_bits ^ settings.step_invert_mask;\n  dirn_bits \u003d dirn_bits ^ settings.dirn_invert_mask;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "TIM2_IRQHandler"
      ],
      "called": [
        "dirn_wr",
        "iterate_trapezoid_cycle_counter",
        "st_go_idle",
        "plan_get_current_block",
        "plan_discard_current_block",
        "set_step_events_per_minute"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "step_pulse_isr": {
      "entrypoint": "0x08005760",
      "current_name": "step_pulse_isr",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid step_pulse_isr(void)\n\n{\n  step_wr((uint)settings.step_invert_mask);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "TIM2_IRQHandler"
      ],
      "called": [
        "step_wr"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "step_delay_isr": {
      "entrypoint": "0x08005778",
      "current_name": "step_delay_isr",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid step_delay_isr(void)\n\n{\n  step_wr((uint)saved_step_bits);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "TIM2_IRQHandler"
      ],
      "called": [
        "step_wr"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "st_wake_up": {
      "entrypoint": "0x08005790",
      "current_name": "st_wake_up",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid st_wake_up(void)\n\n{\n  stepper_motor_enable();\n  if (sys.state \u003d\u003d \u0027\\x03\u0027) {\n    step_bits \u003d settings.step_invert_mask;\n    dirn_bits \u003d settings.dirn_invert_mask;\n    set_step_pulse_delay(0x69);\n    set_step_pulse_time((settings.pulse_microseconds + 5) * 0x15);\n    step_isr_enable();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "st_init",
        "st_cycle_start",
        "limits_go_home"
      ],
      "called": [
        "step_isr_enable",
        "set_step_pulse_time",
        "set_step_pulse_delay",
        "stepper_motor_enable"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "st_go_idle": {
      "entrypoint": "0x080057e4",
      "current_name": "st_go_idle",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid st_go_idle(void)\n\n{\n  step_isr_disable();\n  if ((settings.stepper_idle_lock_time !\u003d 0xff) || ((sys.execute \u0026 0x20) !\u003d 0)) {\n    stepper_motor_disable();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "st_init",
        "mc_reset",
        "step_period_isr",
        "limits_go_home"
      ],
      "called": [
        "stepper_motor_disable",
        "step_isr_disable"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "st_reset": {
      "entrypoint": "0x08005814",
      "current_name": "st_reset",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid st_reset(void)\n\n{\n  memset(\u0026st,0,0x24);\n  set_step_events_per_minute(800);\n  current_block \u003d (block_t *)0x0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "grbl_main"
      ],
      "called": [
        "memset",
        "set_step_events_per_minute"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "st_init": {
      "entrypoint": "0x0800583c",
      "current_name": "st_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid st_init(void)\n\n{\n  step_wr((uint)settings.step_invert_mask);\n  st_wake_up();\n  st_go_idle();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "grbl_main"
      ],
      "called": [
        "step_wr",
        "st_go_idle",
        "st_wake_up"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "st_cycle_start": {
      "entrypoint": "0x0800585c",
      "current_name": "st_cycle_start",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid st_cycle_start(void)\n\n{\n  if (sys.state \u003d\u003d \u0027\\x02\u0027) {\n    sys.state \u003d \u0027\\x03\u0027;\n    st_wake_up();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "mc_line",
        "protocol_execute_runtime",
        "mc_go_home"
      ],
      "called": [
        "st_wake_up"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "st_feed_hold": {
      "entrypoint": "0x0800587c",
      "current_name": "st_feed_hold",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid st_feed_hold(void)\n\n{\n  if (sys.state \u003d\u003d \u0027\\x03\u0027) {\n    sys.state \u003d \u0027\\x04\u0027;\n    sys.auto_start \u003d \u0027\\0\u0027;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_execute_runtime"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "st_cycle_reinitialize": {
      "entrypoint": "0x080058a0",
      "current_name": "st_cycle_reinitialize",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid st_cycle_reinitialize(void)\n\n{\n  if (current_block \u003d\u003d (block_t *)0x0) {\n    sys.state \u003d \u0027\\0\u0027;\n  }\n  else {\n    plan_cycle_reinitialize(current_block-\u003estep_event_count - st.step_events_completed);\n    st.trapezoid_adjusted_rate \u003d 0;\n    set_step_events_per_minute(0);\n    st.trapezoid_tick_cycle_counter \u003d 210000;\n    st.step_events_completed \u003d 0;\n    sys.state \u003d \u0027\\x02\u0027;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_execute_runtime"
      ],
      "called": [
        "plan_cycle_reinitialize",
        "set_step_events_per_minute"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serial_rx_hook": {
      "entrypoint": "0x08005900",
      "current_name": "serial_rx_hook",
      "code": "\nint serial_rx_hook(uint8_t data)\n\n{\n  uint8_t data_local;\n  int rc;\n  \n  if (data \u003d\u003d \u0027~\u0027) {\n    sys.execute \u003d sys.execute | 2;\n    return 1;\n  }\n  if (data \u003c 0x7f) {\n    if (data \u003d\u003d \u0027?\u0027) {\n      sys.execute \u003d sys.execute | 1;\n      return 1;\n    }\n    if (data \u003c 0x40) {\n      if (data \u003d\u003d \u0027\\x18\u0027) {\n        mc_reset();\n        return 1;\n      }\n      if (data \u003d\u003d \u0027!\u0027) {\n        sys.execute \u003d sys.execute | 8;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "serial_read"
      ],
      "called": [
        "mc_reset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "aflCall": {
      "entrypoint": "0x0800597c",
      "current_name": "aflCall",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t aflCall(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
      "renaming": {},
      "calling": [
        "startForkserver"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "startForkserver": {
      "entrypoint": "0x08005984",
      "current_name": "startForkserver",
      "code": "\nint startForkserver(int ticks)\n\n{\n  uint32_t uVar1;\n  int ticks_local;\n  \n  if (noHyperCall \u003d\u003d 0) {\n    uVar1 \u003d aflCall(1,ticks,0);\n  }\n  else {\n    uVar1 \u003d 0;\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "aflCall"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_Init": {
      "entrypoint": "0x080059b4",
      "current_name": "HAL_Init",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef HAL_Init(void)\n\n{\n  _DAT_40023c00 \u003d _DAT_40023c00 | 0x700;\n  HAL_SYSTICK_Config(16000);\n  HAL_NVIC_SetPriorityGrouping(3);\n  HAL_MspInit();\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "HAL_SYSTICK_Config",
        "HAL_MspInit",
        "HAL_NVIC_SetPriorityGrouping"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_DeInit": {
      "entrypoint": "0x080059f8",
      "current_name": "HAL_DeInit",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef HAL_DeInit(void)\n\n{\n  _DAT_40023820 \u003d 0;\n  _DAT_40023824 \u003d 0;\n  _DAT_40023810 \u003d 0;\n  _DAT_40023814 \u003d 0;\n  _DAT_40023818 \u003d 0;\n  HAL_MspDeInit();\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_MspDeInit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_MspInit": {
      "entrypoint": "0x08005a50",
      "current_name": "HAL_MspInit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_MspInit(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_Init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_MspDeInit": {
      "entrypoint": "0x08005a5c",
      "current_name": "HAL_MspDeInit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_MspDeInit(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_DeInit"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_IncTick": {
      "entrypoint": "0x08005a68",
      "current_name": "HAL_IncTick",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_IncTick(void)\n\n{\n  uwTick \u003d uwTick + 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SysTick_Handler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GetTick": {
      "entrypoint": "0x08005a84",
      "current_name": "HAL_GetTick",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_GetTick(void)\n\n{\n  return uwTick;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_Delay",
        "HAL_RCC_OscConfig",
        "get_current_usecs",
        "HAL_RCC_ClockConfig",
        "SysTick_Handler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_Delay": {
      "entrypoint": "0x08005a98",
      "current_name": "HAL_Delay",
      "code": "\nvoid HAL_Delay(uint32_t Delay)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint32_t Delay_local;\n  uint32_t timingdelay;\n  \n  uVar1 \u003d HAL_GetTick();\n  do {\n    uVar2 \u003d HAL_GetTick();\n  } while (uVar2 \u003c Delay + uVar1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_delay_ms"
      ],
      "called": [
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GetHalVersion": {
      "entrypoint": "0x08005ac4",
      "current_name": "HAL_GetHalVersion",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_GetHalVersion(void)\n\n{\n  return 0x1000000;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GetREVID": {
      "entrypoint": "0x08005ad4",
      "current_name": "HAL_GetREVID",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_GetREVID(void)\n\n{\n  return _DAT_e0042000 \u003e\u003e 0x10;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GetDEVID": {
      "entrypoint": "0x08005aec",
      "current_name": "HAL_GetDEVID",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_GetDEVID(void)\n\n{\n  return _DAT_e0042000 \u0026 0xfff;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_EnableDBGSleepMode": {
      "entrypoint": "0x08005b04",
      "current_name": "HAL_EnableDBGSleepMode",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_EnableDBGSleepMode(void)\n\n{\n  _DAT_e0042004 \u003d _DAT_e0042004 | 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_DisableDBGSleepMode": {
      "entrypoint": "0x08005b20",
      "current_name": "HAL_DisableDBGSleepMode",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_DisableDBGSleepMode(void)\n\n{\n  _DAT_e0042004 \u003d _DAT_e0042004 \u0026 0xfffffffe;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_EnableDBGStopMode": {
      "entrypoint": "0x08005b3c",
      "current_name": "HAL_EnableDBGStopMode",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_EnableDBGStopMode(void)\n\n{\n  _DAT_e0042004 \u003d _DAT_e0042004 | 2;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_DisableDBGStopMode": {
      "entrypoint": "0x08005b58",
      "current_name": "HAL_DisableDBGStopMode",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_DisableDBGStopMode(void)\n\n{\n  _DAT_e0042004 \u003d _DAT_e0042004 \u0026 0xfffffffd;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_EnableDBGStandbyMode": {
      "entrypoint": "0x08005b74",
      "current_name": "HAL_EnableDBGStandbyMode",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_EnableDBGStandbyMode(void)\n\n{\n  _DAT_e0042004 \u003d _DAT_e0042004 | 4;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_DisableDBGStandbyMode": {
      "entrypoint": "0x08005b90",
      "current_name": "HAL_DisableDBGStandbyMode",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_DisableDBGStandbyMode(void)\n\n{\n  _DAT_e0042004 \u003d _DAT_e0042004 \u0026 0xfffffffb;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_EnableCompensationCell": {
      "entrypoint": "0x08005bac",
      "current_name": "HAL_EnableCompensationCell",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_EnableCompensationCell(void)\n\n{\n  _DAT_42270400 \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_DisableCompensationCell": {
      "entrypoint": "0x08005bc4",
      "current_name": "HAL_DisableCompensationCell",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_DisableCompensationCell(void)\n\n{\n  _DAT_42270400 \u003d 0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "NVIC_SetPriority": {
      "entrypoint": "0x08006b00",
      "current_name": "NVIC_SetPriority",
      "code": "\nvoid NVIC_SetPriority(IRQn_Type IRQn,uint32_t priority)\n\n{\n  uint32_t priority_local;\n  IRQn_Type IRQn_local;\n  \n  if (IRQn \u003c WWDG_IRQn) {\n    *(char *)(((byte)IRQn \u0026 0xf) + 0xe000ed14) \u003d (char)((priority \u0026 0xff) \u003c\u003c 4);\n  }\n  else {\n    *(char *)(IRQn + -0x1fff1c00) \u003d (char)((priority \u0026 0xff) \u003c\u003c 4);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SysTick_Config",
        "HAL_NVIC_SetPriority"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "SysTick_Config": {
      "entrypoint": "0x08006c9c",
      "current_name": "SysTick_Config",
      "code": "\n\n\nuint32_t SysTick_Config(uint32_t ticks)\n\n{\n  bool bVar1;\n  uint32_t ticks_local;\n  \n  bVar1 \u003d ticks - 1 \u003c 0x1000000;\n  if (bVar1) {\n    _DAT_e000e014 \u003d ticks - 1;\n    NVIC_SetPriority(SysTick_IRQn,0xf);\n    _DAT_e000e018 \u003d 0;\n    _DAT_e000e010 \u003d 7;\n  }\n  return (uint)!bVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_SYSTICK_Config"
      ],
      "called": [
        "NVIC_SetPriority"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_DeInit": {
      "entrypoint": "0x08005c74",
      "current_name": "HAL_RCC_DeInit",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_RCC_DeInit(void)\n\n{\n  _DAT_40023808 \u003d 0;\n  _DAT_40023804 \u003d 0x4003010;\n  _DAT_40023884 \u003d 0x20003000;\n  _DAT_40023800 \u003d _DAT_40023800 \u0026 0xfaf2ffff | 0x81;\n  _DAT_4002380c \u003d 0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_OscConfig": {
      "entrypoint": "0x08005cec",
      "current_name": "HAL_RCC_OscConfig",
      "code": "\n\n\nHAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef *RCC_OscInitStruct)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  RCC_OscInitTypeDef *RCC_OscInitStruct_local;\n  uint32_t result_2;\n  uint32_t result_3;\n  uint32_t result_4;\n  uint32_t result_5;\n  uint32_t result_6;\n  uint32_t result_7;\n  uint32_t result;\n  uint32_t result_1;\n  uint32_t timeout;\n  \n  if ((RCC_OscInitStruct-\u003eOscillatorType \u0026 1) !\u003d 0) {\n    if (((_DAT_40023808 \u0026 0xc) \u003d\u003d 4) ||\n       (((_DAT_40023808 \u0026 0xc) \u003d\u003d 8 \u0026\u0026 ((_DAT_40023804 \u0026 0x400000) \u003d\u003d 0x400000)))) {\n      if (((_DAT_40023800 \u0026 0x20000) !\u003d 0) \u0026\u0026 (RCC_OscInitStruct-\u003eHSEState !\u003d 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      _DAT_40023800 \u003d (uint3)_DAT_40023800;\n      uVar1 \u003d HAL_GetTick();\n      while ((_DAT_40023800 \u0026 0x20000) !\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (uVar1 + 5000 \u003c\u003d uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40023800 \u003d CONCAT12((char)RCC_OscInitStruct-\u003eHSEState,_DAT_40023800);\n      if (RCC_OscInitStruct-\u003eHSEState \u003d\u003d 1) {\n        uVar1 \u003d HAL_GetTick();\n        while ((_DAT_40023800 \u0026 0x20000) \u003d\u003d 0) {\n          uVar2 \u003d HAL_GetTick();\n          if (uVar1 + 5000 \u003c\u003d uVar2) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        uVar1 \u003d HAL_GetTick();\n        while ((_DAT_40023800 \u0026 0x20000) !\u003d 0) {\n          uVar2 \u003d HAL_GetTick();\n          if (uVar1 + 5000 \u003c\u003d uVar2) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct-\u003eOscillatorType \u0026 2) !\u003d 0) {\n    if (((_DAT_40023808 \u0026 0xc) \u003d\u003d 0) ||\n       (((_DAT_40023808 \u0026 0xc) \u003d\u003d 8 \u0026\u0026 ((_DAT_40023804 \u0026 0x400000) \u003d\u003d 0)))) {\n      if (((_DAT_40023800 \u0026 2) !\u003d 0) \u0026\u0026 (RCC_OscInitStruct-\u003eHSIState !\u003d 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else if (RCC_OscInitStruct-\u003eHSIState \u003d\u003d 0) {\n      _DAT_42470000 \u003d 0;\n      uVar1 \u003d HAL_GetTick();\n      while ((_DAT_40023800 \u0026 2) !\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (uVar1 + 100 \u003c\u003d uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470000 \u003d 1;\n      uVar1 \u003d HAL_GetTick();\n      while ((_DAT_40023800 \u0026 2) \u003d\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (uVar1 + 100 \u003c\u003d uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40023800 \u003d RCC_OscInitStruct-\u003eHSICalibrationValue \u003c\u003c 3 | _DAT_40023800 \u0026 0xffffff07;\n    }\n  }\n  if ((RCC_OscInitStruct-\u003eOscillatorType \u0026 8) !\u003d 0) {\n    if (RCC_OscInitStruct-\u003eLSIState \u003d\u003d 0) {\n      _DAT_42470e80 \u003d 0;\n      uVar1 \u003d HAL_GetTick();\n      while ((_DAT_40023874 \u0026 2) !\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (uVar1 + 100 \u003c\u003d uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470e80 \u003d 1;\n      uVar1 \u003d HAL_GetTick();\n      while ((_DAT_40023874 \u0026 2) \u003d\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (uVar1 + 100 \u003c\u003d uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct-\u003eOscillatorType \u0026 4) !\u003d 0) {\n    _DAT_40023840 \u003d _DAT_40023840 | 0x10000000;\n    _DAT_40007000 \u003d _DAT_40007000 | 0x100;\n    uVar1 \u003d HAL_GetTick();\n    while ((_DAT_40007000 \u0026 0x100) \u003d\u003d 0) {\n      uVar2 \u003d HAL_GetTick();\n      if (uVar1 + 100 \u003c\u003d uVar2) {\n        return HAL_TIMEOUT;\n      }\n    }\n    _DAT_40023870 \u003d _DAT_40023870 \u0026 0xffffff00;\n    uVar1 \u003d HAL_GetTick();\n    while ((_DAT_40023870 \u0026 2) !\u003d 0) {\n      uVar2 \u003d HAL_GetTick();\n      if (uVar1 + 5000 \u003c\u003d uVar2) {\n        return HAL_TIMEOUT;\n      }\n    }\n    _DAT_40023870 \u003d CONCAT31(DAT_40023870_1,(char)RCC_OscInitStruct-\u003eLSEState);\n    if (RCC_OscInitStruct-\u003eLSEState \u003d\u003d 1) {\n      uVar1 \u003d HAL_GetTick();\n      while ((_DAT_40023870 \u0026 2) \u003d\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (uVar1 + 5000 \u003c\u003d uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      uVar1 \u003d HAL_GetTick();\n      while ((_DAT_40023870 \u0026 2) !\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (uVar1 + 5000 \u003c\u003d uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct-\u003ePLL).PLLState !\u003d 0) {\n    if ((_DAT_40023808 \u0026 0xc) \u003d\u003d 8) {\n      return HAL_ERROR;\n    }\n    if ((RCC_OscInitStruct-\u003ePLL).PLLState \u003d\u003d 2) {\n      _DAT_42470060 \u003d 0;\n      uVar1 \u003d HAL_GetTick();\n      while ((_DAT_40023800 \u0026 0x2000000) !\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (uVar1 + 100 \u003c\u003d uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40023804 \u003d\n           (RCC_OscInitStruct-\u003ePLL).PLLQ \u003c\u003c 0x18 |\n           (RCC_OscInitStruct-\u003ePLL).PLLM | (RCC_OscInitStruct-\u003ePLL).PLLN \u003c\u003c 6 |\n           (((RCC_OscInitStruct-\u003ePLL).PLLP \u003e\u003e 1) - 1) * 0x10000 | (RCC_OscInitStruct-\u003ePLL).PLLSource\n           | 0x20000000;\n      _DAT_42470060 \u003d 1;\n      uVar1 \u003d HAL_GetTick();\n      while ((_DAT_40023800 \u0026 0x2000000) \u003d\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (uVar1 + 100 \u003c\u003d uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470060 \u003d 0;\n      uVar1 \u003d HAL_GetTick();\n      while ((_DAT_40023800 \u0026 0x2000000) !\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (uVar1 + 100 \u003c\u003d uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "SystemClock_Config"
      ],
      "called": [
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_ClockConfig": {
      "entrypoint": "0x0800618c",
      "current_name": "HAL_RCC_ClockConfig",
      "code": "\n\n\nHAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef *RCC_ClkInitStruct,uint32_t FLatency)\n\n{\n  uint32_t uVar1;\n  uint uVar2;\n  uint32_t FLatency_local;\n  RCC_ClkInitTypeDef *RCC_ClkInitStruct_local;\n  uint32_t timeout;\n  \n  if ((_DAT_40023c00 \u0026 0xf) \u003c FLatency) {\n    _DAT_40023c00 \u003d CONCAT31(DAT_40023c00_1,(char)FLatency);\n    if (FLatency !\u003d (FLatency \u0026 0xf)) {\n      return HAL_ERROR;\n    }\n    if ((RCC_ClkInitStruct-\u003eClockType \u0026 1) !\u003d 0) {\n      if (RCC_ClkInitStruct-\u003eSYSCLKSource \u003d\u003d 1) {\n        if ((_DAT_40023800 \u0026 0x20000) \u003d\u003d 0) {\n          return HAL_ERROR;\n        }\n      }\n      else if ((RCC_ClkInitStruct-\u003eSYSCLKSource !\u003d 2) \u0026\u0026 ((_DAT_40023800 \u0026 2) \u003d\u003d 0)) {\n        return HAL_ERROR;\n      }\n      _DAT_40023808 \u003d RCC_ClkInitStruct-\u003eSYSCLKSource | _DAT_40023808 \u0026 0xfffffffc;\n      uVar1 \u003d HAL_GetTick();\n      uVar2 \u003d uVar1 + 5000;\n      if (RCC_ClkInitStruct-\u003eSYSCLKSource \u003d\u003d 1) {\n        while ((_DAT_40023808 \u0026 0xc) !\u003d 4) {\n          uVar1 \u003d HAL_GetTick();\n          if (uVar2 \u003c\u003d uVar1) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else if (RCC_ClkInitStruct-\u003eSYSCLKSource \u003d\u003d 2) {\n        while ((_DAT_40023808 \u0026 0xc) !\u003d 8) {\n          uVar1 \u003d HAL_GetTick();\n          if (uVar2 \u003c\u003d uVar1) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        while ((_DAT_40023808 \u0026 0xc) !\u003d 0) {\n          uVar1 \u003d HAL_GetTick();\n          if (uVar2 \u003c\u003d uVar1) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  else {\n    if ((RCC_ClkInitStruct-\u003eClockType \u0026 1) !\u003d 0) {\n      if (RCC_ClkInitStruct-\u003eSYSCLKSource \u003d\u003d 1) {\n        if ((_DAT_40023800 \u0026 0x20000) \u003d\u003d 0) {\n          return HAL_ERROR;\n        }\n      }\n      else if (RCC_ClkInitStruct-\u003eSYSCLKSource \u003d\u003d 2) {\n        if ((_DAT_40023800 \u0026 0x2000000) \u003d\u003d 0) {\n          return HAL_ERROR;\n        }\n      }\n      else if ((_DAT_40023800 \u0026 2) \u003d\u003d 0) {\n        return HAL_ERROR;\n      }\n      _DAT_40023808 \u003d RCC_ClkInitStruct-\u003eSYSCLKSource | _DAT_40023808 \u0026 0xfffffffc;\n      uVar1 \u003d HAL_GetTick();\n      uVar2 \u003d uVar1 + 5000;\n      if (RCC_ClkInitStruct-\u003eSYSCLKSource \u003d\u003d 1) {\n        while ((_DAT_40023808 \u0026 0xc) !\u003d 4) {\n          uVar1 \u003d HAL_GetTick();\n          if (uVar2 \u003c\u003d uVar1) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else if (RCC_ClkInitStruct-\u003eSYSCLKSource \u003d\u003d 2) {\n        while ((_DAT_40023808 \u0026 0xc) !\u003d 8) {\n          uVar1 \u003d HAL_GetTick();\n          if (uVar2 \u003c\u003d uVar1) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        while ((_DAT_40023808 \u0026 0xc) !\u003d 0) {\n          uVar1 \u003d HAL_GetTick();\n          if (uVar2 \u003c\u003d uVar1) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    _DAT_40023c00 \u003d CONCAT31(DAT_40023c00_1,(char)FLatency);\n    if (FLatency !\u003d (FLatency \u0026 0xf)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((RCC_ClkInitStruct-\u003eClockType \u0026 2) !\u003d 0) {\n    _DAT_40023808 \u003d RCC_ClkInitStruct-\u003eAHBCLKDivider | _DAT_40023808 \u0026 0xffffff0f;\n  }\n  if ((RCC_ClkInitStruct-\u003eClockType \u0026 4) !\u003d 0) {\n    _DAT_40023808 \u003d RCC_ClkInitStruct-\u003eAPB1CLKDivider | _DAT_40023808 \u0026 0xffffe3ff;\n  }\n  if ((RCC_ClkInitStruct-\u003eClockType \u0026 8) !\u003d 0) {\n    _DAT_40023808 \u003d RCC_ClkInitStruct-\u003eAPB2CLKDivider \u003c\u003c 3 | _DAT_40023808 \u0026 0xffff1fff;\n  }\n  uVar1 \u003d HAL_RCC_GetHCLKFreq();\n  SysTick_Config(uVar1 / 1000);\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "SystemClock_Config"
      ],
      "called": [
        "SysTick_Config",
        "HAL_RCC_GetHCLKFreq",
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_MCOConfig": {
      "entrypoint": "0x0800640c",
      "current_name": "HAL_RCC_MCOConfig",
      "code": "\n\n\nvoid HAL_RCC_MCOConfig(uint32_t RCC_MCOx,uint32_t RCC_MCOSource,uint32_t RCC_MCODiv)\n\n{\n  uint32_t RCC_MCODiv_local;\n  uint32_t RCC_MCOSource_local;\n  uint32_t RCC_MCOx_local;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (RCC_MCOx \u003d\u003d 0) {\n    _DAT_40023830 \u003d _DAT_40023830 | 1;\n    GPIO_InitStruct.Pin \u003d 0x100;\n    GPIO_InitStruct.Mode \u003d 2;\n    GPIO_InitStruct.Speed \u003d 3;\n    GPIO_InitStruct.Pull \u003d 0;\n    GPIO_InitStruct.Alternate \u003d 0;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40020000,\u0026GPIO_InitStruct);\n    _DAT_40023808 \u003d RCC_MCODiv | RCC_MCOSource | _DAT_40023808 \u0026 0xf89fffff;\n  }\n  else {\n    _DAT_40023830 \u003d _DAT_40023830 | 4;\n    GPIO_InitStruct.Pin \u003d 0x200;\n    GPIO_InitStruct.Mode \u003d 2;\n    GPIO_InitStruct.Speed \u003d 3;\n    GPIO_InitStruct.Pull \u003d 0;\n    GPIO_InitStruct.Alternate \u003d 0;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40020800,\u0026GPIO_InitStruct);\n    _DAT_40023808 \u003d RCC_MCOSource | RCC_MCODiv \u003c\u003c 3 | _DAT_40023808 \u0026 0x7ffffff;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_Init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_EnableCSS": {
      "entrypoint": "0x080064bc",
      "current_name": "HAL_RCC_EnableCSS",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_RCC_EnableCSS(void)\n\n{\n  _DAT_4247004c \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_DisableCSS": {
      "entrypoint": "0x080064d4",
      "current_name": "HAL_RCC_DisableCSS",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_RCC_DisableCSS(void)\n\n{\n  _DAT_4247004c \u003d 0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_GetSysClockFreq": {
      "entrypoint": "0x080064ec",
      "current_name": "HAL_RCC_GetSysClockFreq",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_RCC_GetSysClockFreq(void)\n\n{\n  uint uVar1;\n  uint32_t result_6;\n  uint32_t result_7;\n  uint32_t result_4;\n  uint32_t result_5;\n  uint32_t result_2;\n  uint32_t result_3;\n  uint32_t result;\n  uint32_t result_1;\n  uint32_t pllp;\n  uint32_t pllm;\n  uint32_t sysclockfreq;\n  uint32_t pllvco;\n  \n  uVar1 \u003d _DAT_40023808 \u0026 0xc;\n  if (uVar1 \u003d\u003d 8) {\n    if ((_DAT_40023804 \u0026 0x400000) \u003d\u003d 0) {\n      pllvco \u003d ((_DAT_40023804 \u0026 0x7fc0) \u003e\u003e 6) * (16000000 / (_DAT_40023804 \u0026 0x3f));\n    }\n    else {\n      pllvco \u003d ((_DAT_40023804 \u0026 0x7fc0) \u003e\u003e 6) * (8000000 / (_DAT_40023804 \u0026 0x3f));\n    }\n    return pllvco / ((((_DAT_40023804 \u0026 0x30000) \u003e\u003e 0x10) + 1) * 2);\n  }\n  if (uVar1 \u003c 9) {\n    if (uVar1 \u003d\u003d 0) {\n      return 16000000;\n    }\n    if (uVar1 \u003d\u003d 4) {\n      return 8000000;\n    }\n  }\n  return 16000000;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_RCC_GetHCLKFreq"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_GetHCLKFreq": {
      "entrypoint": "0x08006628",
      "current_name": "HAL_RCC_GetHCLKFreq",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_RCC_GetHCLKFreq(void)\n\n{\n  uint32_t uVar1;\n  uint32_t result;\n  uint32_t result_1;\n  \n  uVar1 \u003d HAL_RCC_GetSysClockFreq();\n  SystemCoreClock \u003d uVar1 \u003e\u003e \"\"[(_DAT_40023808 \u0026 0xf0) \u003e\u003e 4];\n  return uVar1 \u003e\u003e \"\"[(_DAT_40023808 \u0026 0xf0) \u003e\u003e 4];\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_RCC_GetPCLK2Freq",
        "HAL_RCC_ClockConfig",
        "HAL_RCC_GetPCLK1Freq"
      ],
      "called": [
        "HAL_RCC_GetSysClockFreq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_GetPCLK1Freq": {
      "entrypoint": "0x08006680",
      "current_name": "HAL_RCC_GetPCLK1Freq",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_RCC_GetPCLK1Freq(void)\n\n{\n  uint32_t uVar1;\n  uint32_t result;\n  uint32_t result_1;\n  \n  uVar1 \u003d HAL_RCC_GetHCLKFreq();\n  return uVar1 \u003e\u003e \"\"[(_DAT_40023808 \u0026 0x1c00) \u003e\u003e 10];\n}\n\n",
      "renaming": {},
      "calling": [
        "set_baud_rate"
      ],
      "called": [
        "HAL_RCC_GetHCLKFreq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_GetPCLK2Freq": {
      "entrypoint": "0x080066cc",
      "current_name": "HAL_RCC_GetPCLK2Freq",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_RCC_GetPCLK2Freq(void)\n\n{\n  uint32_t uVar1;\n  uint32_t result;\n  uint32_t result_1;\n  \n  uVar1 \u003d HAL_RCC_GetHCLKFreq();\n  return uVar1 \u003e\u003e \"\"[(_DAT_40023808 \u0026 0xe000) \u003e\u003e 0xd];\n}\n\n",
      "renaming": {},
      "calling": [
        "set_baud_rate"
      ],
      "called": [
        "HAL_RCC_GetHCLKFreq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_GetOscConfig": {
      "entrypoint": "0x08006718",
      "current_name": "HAL_RCC_GetOscConfig",
      "code": "\n\n\nvoid HAL_RCC_GetOscConfig(RCC_OscInitTypeDef *RCC_OscInitStruct)\n\n{\n  RCC_OscInitTypeDef *RCC_OscInitStruct_local;\n  uint32_t result_2;\n  uint32_t result_3;\n  uint32_t result_4;\n  uint32_t result_5;\n  uint32_t result_6;\n  uint32_t result_7;\n  uint32_t result;\n  uint32_t result_1;\n  \n  RCC_OscInitStruct-\u003eOscillatorType \u003d 0xf;\n  if ((_DAT_40023800 \u0026 0x40000) \u003d\u003d 0x40000) {\n    RCC_OscInitStruct-\u003eHSEState \u003d 5;\n  }\n  else if ((_DAT_40023800 \u0026 0x10000) \u003d\u003d 0x10000) {\n    RCC_OscInitStruct-\u003eHSEState \u003d 1;\n  }\n  else {\n    RCC_OscInitStruct-\u003eHSEState \u003d 0;\n  }\n  if ((_DAT_40023800 \u0026 1) \u003d\u003d 1) {\n    RCC_OscInitStruct-\u003eHSIState \u003d 1;\n  }\n  else {\n    RCC_OscInitStruct-\u003eHSIState \u003d 0;\n  }\n  RCC_OscInitStruct-\u003eHSICalibrationValue \u003d (_DAT_40023800 \u0026 0xf8) \u003e\u003e 3;\n  if ((_DAT_40023870 \u0026 4) \u003d\u003d 4) {\n    RCC_OscInitStruct-\u003eLSEState \u003d 5;\n  }\n  else if ((_DAT_40023870 \u0026 1) \u003d\u003d 1) {\n    RCC_OscInitStruct-\u003eLSEState \u003d 1;\n  }\n  else {\n    RCC_OscInitStruct-\u003eLSEState \u003d 0;\n  }\n  if ((_DAT_40023874 \u0026 1) \u003d\u003d 1) {\n    RCC_OscInitStruct-\u003eLSIState \u003d 1;\n  }\n  else {\n    RCC_OscInitStruct-\u003eLSIState \u003d 0;\n  }\n  if ((_DAT_40023800 \u0026 0x1000000) \u003d\u003d 0x1000000) {\n    (RCC_OscInitStruct-\u003ePLL).PLLState \u003d 2;\n  }\n  else {\n    (RCC_OscInitStruct-\u003ePLL).PLLState \u003d 1;\n  }\n  (RCC_OscInitStruct-\u003ePLL).PLLSource \u003d _DAT_40023804 \u0026 0x400000;\n  (RCC_OscInitStruct-\u003ePLL).PLLM \u003d _DAT_40023804 \u0026 0x3f;\n  (RCC_OscInitStruct-\u003ePLL).PLLN \u003d (_DAT_40023804 \u0026 0x7fc0) \u003e\u003e 6;\n  (RCC_OscInitStruct-\u003ePLL).PLLP \u003d ((_DAT_40023804 \u0026 0x30000) + 0x10000) * 2 \u003e\u003e 0x10;\n  (RCC_OscInitStruct-\u003ePLL).PLLQ \u003d (_DAT_40023804 \u0026 0xf000000) \u003e\u003e 0x18;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_GetClockConfig": {
      "entrypoint": "0x080068bc",
      "current_name": "HAL_RCC_GetClockConfig",
      "code": "\n\n\nvoid HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef *RCC_ClkInitStruct,uint32_t *pFLatency)\n\n{\n  uint32_t *pFLatency_local;\n  RCC_ClkInitTypeDef *RCC_ClkInitStruct_local;\n  \n  RCC_ClkInitStruct-\u003eClockType \u003d 0xf;\n  RCC_ClkInitStruct-\u003eSYSCLKSource \u003d _DAT_40023808 \u0026 3;\n  RCC_ClkInitStruct-\u003eAHBCLKDivider \u003d _DAT_40023808 \u0026 0xf0;\n  RCC_ClkInitStruct-\u003eAPB1CLKDivider \u003d _DAT_40023808 \u0026 0x1c00;\n  RCC_ClkInitStruct-\u003eAPB2CLKDivider \u003d _DAT_40023808 \u003e\u003e 3 \u0026 0x1c00;\n  *pFLatency \u003d _DAT_40023c00 \u0026 0xf;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_NMI_IRQHandler": {
      "entrypoint": "0x0800691c",
      "current_name": "HAL_RCC_NMI_IRQHandler",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_RCC_NMI_IRQHandler(void)\n\n{\n  if ((_DAT_4002380c \u0026 0x80) \u003d\u003d 0x80) {\n    HAL_RCC_CCSCallback();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_RCC_CCSCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_CCSCallback": {
      "entrypoint": "0x08006944",
      "current_name": "HAL_RCC_CCSCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_RCC_CCSCallback(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_RCC_NMI_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "NVIC_SetPriorityGrouping": {
      "entrypoint": "0x08006950",
      "current_name": "NVIC_SetPriorityGrouping",
      "code": "\n\n\nvoid NVIC_SetPriorityGrouping(uint32_t PriorityGroup)\n\n{\n  uint32_t PriorityGroup_local;\n  uint32_t reg_value;\n  uint32_t PriorityGroupTmp;\n  \n  _DAT_e000ed0c \u003d _DAT_e000ed0c \u0026 0xf8ff | (PriorityGroup \u0026 7) \u003c\u003c 8 | 0x5fa0000;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_NVIC_SetPriorityGrouping"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "NVIC_GetPriorityGrouping": {
      "entrypoint": "0x08006998",
      "current_name": "NVIC_GetPriorityGrouping",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t NVIC_GetPriorityGrouping(void)\n\n{\n  return _DAT_e000ed0c \u003e\u003e 8 \u0026 7;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_NVIC_GetPriorityGrouping",
        "HAL_NVIC_SetPriority"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "NVIC_EnableIRQ": {
      "entrypoint": "0x080079e0",
      "current_name": "NVIC_EnableIRQ",
      "code": "\nvoid NVIC_EnableIRQ(IRQn_Type IRQn)\n\n{\n  IRQn_Type IRQn_local;\n  \n  *(int *)(((uint)(int)IRQn \u003e\u003e 5) * 4 + -0x1fff1f00) \u003d 1 \u003c\u003c (IRQn \u0026 0x1fU);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "enable_tim_interrupt"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "NVIC_DisableIRQ": {
      "entrypoint": "0x080069e4",
      "current_name": "NVIC_DisableIRQ",
      "code": "\nvoid NVIC_DisableIRQ(IRQn_Type IRQn)\n\n{\n  IRQn_Type IRQn_local;\n  \n  *(int *)((((uint)(int)IRQn \u003e\u003e 5) + 0x20) * 4 + -0x1fff1f00) \u003d 1 \u003c\u003c (IRQn \u0026 0x1fU);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_NVIC_DisableIRQ"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "NVIC_GetPendingIRQ": {
      "entrypoint": "0x08006a18",
      "current_name": "NVIC_GetPendingIRQ",
      "code": "\nuint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)\n\n{\n  IRQn_Type IRQn_local;\n  \n  return (uint)((*(uint *)((((uint)(int)IRQn \u003e\u003e 5) + 0x40) * 4 + -0x1fff1f00) \u0026 1 \u003c\u003c (IRQn \u0026 0x1fU))\n               !\u003d 0);\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_NVIC_GetPendingIRQ"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "NVIC_SetPendingIRQ": {
      "entrypoint": "0x08006a58",
      "current_name": "NVIC_SetPendingIRQ",
      "code": "\nvoid NVIC_SetPendingIRQ(IRQn_Type IRQn)\n\n{\n  IRQn_Type IRQn_local;\n  \n  *(int *)((((uint)(int)IRQn \u003e\u003e 5) + 0x40) * 4 + -0x1fff1f00) \u003d 1 \u003c\u003c (IRQn \u0026 0x1fU);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_NVIC_SetPendingIRQ"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "NVIC_ClearPendingIRQ": {
      "entrypoint": "0x08006a8c",
      "current_name": "NVIC_ClearPendingIRQ",
      "code": "\nvoid NVIC_ClearPendingIRQ(IRQn_Type IRQn)\n\n{\n  IRQn_Type IRQn_local;\n  \n  *(int *)((((uint)(int)IRQn \u003e\u003e 5) + 0x60) * 4 + -0x1fff1f00) \u003d 1 \u003c\u003c (IRQn \u0026 0x1fU);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_NVIC_ClearPendingIRQ"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "NVIC_GetActive": {
      "entrypoint": "0x08006ac0",
      "current_name": "NVIC_GetActive",
      "code": "\nuint32_t NVIC_GetActive(IRQn_Type IRQn)\n\n{\n  IRQn_Type IRQn_local;\n  \n  return (uint)((*(uint *)((((uint)(int)IRQn \u003e\u003e 5) + 0x80) * 4 + -0x1fff1f00) \u0026 1 \u003c\u003c (IRQn \u0026 0x1fU))\n               !\u003d 0);\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_NVIC_GetActive"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "NVIC_GetPriority": {
      "entrypoint": "0x08006b54",
      "current_name": "NVIC_GetPriority",
      "code": "\nuint32_t NVIC_GetPriority(IRQn_Type IRQn)\n\n{\n  byte bVar1;\n  IRQn_Type IRQn_local;\n  \n  if (IRQn \u003c WWDG_IRQn) {\n    bVar1 \u003d *(byte *)(((byte)IRQn \u0026 0xf) + 0xe000ed14);\n  }\n  else {\n    bVar1 \u003d *(byte *)(IRQn + -0x1fff1c00);\n  }\n  return (uint)(bVar1 \u003e\u003e 4);\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_NVIC_GetPriority"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "NVIC_EncodePriority": {
      "entrypoint": "0x08006ba0",
      "current_name": "NVIC_EncodePriority",
      "code": "\nuint32_t NVIC_EncodePriority(uint32_t PriorityGroup,uint32_t PreemptPriority,uint32_t SubPriority)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint32_t SubPriority_local;\n  uint32_t PreemptPriority_local;\n  uint32_t PriorityGroup_local;\n  uint32_t SubPriorityBits;\n  uint32_t PreemptPriorityBits;\n  uint32_t PriorityGroupTmp;\n  \n  uVar1 \u003d PriorityGroup \u0026 7;\n  uVar2 \u003d 7 - uVar1;\n  if (3 \u003c uVar2) {\n    uVar2 \u003d 4;\n  }\n  if (uVar1 + 4 \u003c 7) {\n    uVar1 \u003d 0;\n  }\n  else {\n    uVar1 \u003d uVar1 - 3;\n  }\n  return SubPriority \u0026 (1 \u003c\u003c (uVar1 \u0026 0xff)) - 1U |\n         ((1 \u003c\u003c (uVar2 \u0026 0xff)) - 1U \u0026 PreemptPriority) \u003c\u003c (uVar1 \u0026 0xff);\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_NVIC_SetPriority"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "NVIC_DecodePriority": {
      "entrypoint": "0x08006c04",
      "current_name": "NVIC_DecodePriority",
      "code": "\nvoid NVIC_DecodePriority(uint32_t Priority,uint32_t PriorityGroup,uint32_t *pPreemptPriority,\n                        uint32_t *pSubPriority)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint32_t *pSubPriority_local;\n  uint32_t *pPreemptPriority_local;\n  uint32_t PriorityGroup_local;\n  uint32_t Priority_local;\n  uint32_t SubPriorityBits;\n  uint32_t PreemptPriorityBits;\n  uint32_t PriorityGroupTmp;\n  \n  uVar1 \u003d PriorityGroup \u0026 7;\n  uVar2 \u003d 7 - uVar1;\n  if (3 \u003c uVar2) {\n    uVar2 \u003d 4;\n  }\n  if (uVar1 + 4 \u003c 7) {\n    uVar1 \u003d 0;\n  }\n  else {\n    uVar1 \u003d uVar1 - 3;\n  }\n  *pPreemptPriority \u003d (1 \u003c\u003c (uVar2 \u0026 0xff)) - 1U \u0026 Priority \u003e\u003e (uVar1 \u0026 0xff);\n  *pSubPriority \u003d (1 \u003c\u003c (uVar1 \u0026 0xff)) - 1U \u0026 Priority;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_NVIC_GetPriority"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "NVIC_SystemReset": {
      "entrypoint": "0x08006c70",
      "current_name": "NVIC_SystemReset",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid NVIC_SystemReset(void)\n\n{\n  DataSynchronizationBarrier(0xf);\n  DataSynchronizationBarrier(0xf);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_NVIC_SystemReset"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_SetPriorityGrouping": {
      "entrypoint": "0x08006ce0",
      "current_name": "HAL_NVIC_SetPriorityGrouping",
      "code": "\nvoid HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)\n\n{\n  uint32_t PriorityGroup_local;\n  \n  NVIC_SetPriorityGrouping(PriorityGroup);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_Init"
      ],
      "called": [
        "NVIC_SetPriorityGrouping"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_SetPriority": {
      "entrypoint": "0x08006cf6",
      "current_name": "HAL_NVIC_SetPriority",
      "code": "\nvoid HAL_NVIC_SetPriority(IRQn_Type IRQn,uint32_t PreemptPriority,uint32_t SubPriority)\n\n{\n  uint32_t uVar1;\n  uint32_t SubPriority_local;\n  uint32_t PreemptPriority_local;\n  IRQn_Type IRQn_local;\n  uint32_t prioritygroup;\n  \n  uVar1 \u003d NVIC_GetPriorityGrouping();\n  uVar1 \u003d NVIC_EncodePriority(uVar1,PreemptPriority,SubPriority);\n  NVIC_SetPriority(IRQn,uVar1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "enable_tim_interrupt"
      ],
      "called": [
        "NVIC_GetPriorityGrouping",
        "NVIC_SetPriority",
        "NVIC_EncodePriority"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_EnableIRQ": {
      "entrypoint": "0x08006d2e",
      "current_name": "HAL_NVIC_EnableIRQ",
      "code": "\nvoid HAL_NVIC_EnableIRQ(IRQn_Type IRQn)\n\n{\n  IRQn_Type IRQn_local;\n  \n  NVIC_EnableIRQ(IRQn);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "NVIC_EnableIRQ"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_DisableIRQ": {
      "entrypoint": "0x08006d4a",
      "current_name": "HAL_NVIC_DisableIRQ",
      "code": "\nvoid HAL_NVIC_DisableIRQ(IRQn_Type IRQn)\n\n{\n  IRQn_Type IRQn_local;\n  \n  NVIC_DisableIRQ(IRQn);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "NVIC_DisableIRQ"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_SystemReset": {
      "entrypoint": "0x08006d66",
      "current_name": "HAL_NVIC_SystemReset",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_NVIC_SystemReset(void)\n\n{\n  NVIC_SystemReset();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "NVIC_SystemReset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_SYSTICK_Config": {
      "entrypoint": "0x08006d72",
      "current_name": "HAL_SYSTICK_Config",
      "code": "\nuint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)\n\n{\n  uint32_t uVar1;\n  uint32_t TicksNumb_local;\n  \n  uVar1 \u003d SysTick_Config(TicksNumb);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_Init"
      ],
      "called": [
        "SysTick_Config"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_GetPriorityGrouping": {
      "entrypoint": "0x08006d8a",
      "current_name": "HAL_NVIC_GetPriorityGrouping",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_NVIC_GetPriorityGrouping(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 \u003d NVIC_GetPriorityGrouping();\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "NVIC_GetPriorityGrouping"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_GetPriority": {
      "entrypoint": "0x08006d98",
      "current_name": "HAL_NVIC_GetPriority",
      "code": "\nvoid HAL_NVIC_GetPriority\n               (IRQn_Type IRQn,uint32_t PriorityGroup,uint32_t *pPreemptPriority,\n               uint32_t *pSubPriority)\n\n{\n  uint32_t Priority;\n  uint32_t *pSubPriority_local;\n  uint32_t *pPreemptPriority_local;\n  uint32_t PriorityGroup_local;\n  IRQn_Type IRQn_local;\n  \n  Priority \u003d NVIC_GetPriority(IRQn);\n  NVIC_DecodePriority(Priority,PriorityGroup,pPreemptPriority,pSubPriority);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "NVIC_DecodePriority",
        "NVIC_GetPriority"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_SetPendingIRQ": {
      "entrypoint": "0x08006dc4",
      "current_name": "HAL_NVIC_SetPendingIRQ",
      "code": "\nvoid HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)\n\n{\n  IRQn_Type IRQn_local;\n  \n  NVIC_SetPendingIRQ(IRQn);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "NVIC_SetPendingIRQ"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_GetPendingIRQ": {
      "entrypoint": "0x08006de0",
      "current_name": "HAL_NVIC_GetPendingIRQ",
      "code": "\nuint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)\n\n{\n  uint32_t uVar1;\n  IRQn_Type IRQn_local;\n  \n  uVar1 \u003d NVIC_GetPendingIRQ(IRQn);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "NVIC_GetPendingIRQ"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_ClearPendingIRQ": {
      "entrypoint": "0x08006dfe",
      "current_name": "HAL_NVIC_ClearPendingIRQ",
      "code": "\nvoid HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)\n\n{\n  IRQn_Type IRQn_local;\n  \n  NVIC_ClearPendingIRQ(IRQn);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "NVIC_ClearPendingIRQ"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_GetActive": {
      "entrypoint": "0x08006e1a",
      "current_name": "HAL_NVIC_GetActive",
      "code": "\nuint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)\n\n{\n  uint32_t uVar1;\n  IRQn_Type IRQn_local;\n  \n  uVar1 \u003d NVIC_GetActive(IRQn);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "NVIC_GetActive"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_SYSTICK_CLKSourceConfig": {
      "entrypoint": "0x08006e38",
      "current_name": "HAL_SYSTICK_CLKSourceConfig",
      "code": "\n\n\nvoid HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)\n\n{\n  uint32_t CLKSource_local;\n  \n  if (CLKSource \u003d\u003d 4) {\n    _DAT_e000e010 \u003d _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 \u003d _DAT_e000e010 \u0026 0xfffffffb;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_SYSTICK_IRQHandler": {
      "entrypoint": "0x08006e70",
      "current_name": "HAL_SYSTICK_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_SYSTICK_IRQHandler(void)\n\n{\n  HAL_SYSTICK_Callback();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_SYSTICK_Callback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_SYSTICK_Callback": {
      "entrypoint": "0x08006e7c",
      "current_name": "HAL_SYSTICK_Callback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_SYSTICK_Callback(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_SYSTICK_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GPIO_Init": {
      "entrypoint": "0x08006e88",
      "current_name": "HAL_GPIO_Init",
      "code": "\n\n\nvoid HAL_GPIO_Init(GPIO_TypeDef *GPIOx,GPIO_InitTypeDef *GPIO_Init)\n\n{\n  uint32_t uVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  GPIO_InitTypeDef *GPIO_Init_local;\n  GPIO_TypeDef *GPIOx_local;\n  uint32_t temp;\n  uint32_t iocurrent;\n  uint32_t ioposition;\n  uint32_t position;\n  \n  for (position \u003d 0; position \u003c 0x10; position \u003d position + 1) {\n    uVar2 \u003d 1 \u003c\u003c (position \u0026 0xff);\n    uVar3 \u003d GPIO_Init-\u003ePin \u0026 uVar2;\n    if (uVar3 \u003d\u003d uVar2) {\n      if ((GPIO_Init-\u003eMode \u003d\u003d 2) || (GPIO_Init-\u003eMode \u003d\u003d 0x12)) {\n        uVar1 \u003d GPIO_Init-\u003eAlternate;\n        GPIOx-\u003eAFR[position \u003e\u003e 3] \u003d GPIOx-\u003eAFR[position \u003e\u003e 3] \u0026 ~(0xf \u003c\u003c ((position \u0026 7) \u003c\u003c 2));\n        GPIOx-\u003eAFR[position \u003e\u003e 3] \u003d GPIOx-\u003eAFR[position \u003e\u003e 3] | uVar1 \u003c\u003c ((position \u0026 7) \u003c\u003c 2);\n      }\n      GPIOx-\u003eMODER \u003d GPIOx-\u003eMODER \u0026 ~(3 \u003c\u003c ((position \u0026 0x7f) \u003c\u003c 1));\n      GPIOx-\u003eMODER \u003d GPIOx-\u003eMODER | (GPIO_Init-\u003eMode \u0026 3) \u003c\u003c ((position \u0026 0x7f) \u003c\u003c 1);\n      if ((((GPIO_Init-\u003eMode \u003d\u003d 1) || (GPIO_Init-\u003eMode \u003d\u003d 2)) || (GPIO_Init-\u003eMode \u003d\u003d 0x11)) ||\n         (GPIO_Init-\u003eMode \u003d\u003d 0x12)) {\n        GPIOx-\u003eOSPEEDR \u003d GPIOx-\u003eOSPEEDR \u0026 ~(3 \u003c\u003c ((position \u0026 0x7f) \u003c\u003c 1));\n        GPIOx-\u003eOSPEEDR \u003d GPIOx-\u003eOSPEEDR | GPIO_Init-\u003eSpeed \u003c\u003c ((position \u0026 0x7f) \u003c\u003c 1);\n        GPIOx-\u003eOTYPER \u003d GPIOx-\u003eOTYPER \u0026 ~(1 \u003c\u003c (position \u0026 0xff));\n        GPIOx-\u003eOTYPER \u003d GPIOx-\u003eOTYPER | (GPIO_Init-\u003eMode \u003e\u003e 4 \u0026 1) \u003c\u003c (position \u0026 0xff);\n      }\n      GPIOx-\u003ePUPDR \u003d GPIOx-\u003ePUPDR \u0026 ~(3 \u003c\u003c ((position \u0026 0x7f) \u003c\u003c 1));\n      GPIOx-\u003ePUPDR \u003d GPIOx-\u003ePUPDR | GPIO_Init-\u003ePull \u003c\u003c ((position \u0026 0x7f) \u003c\u003c 1);\n      if ((GPIO_Init-\u003eMode \u0026 0x10000000) !\u003d 0) {\n        _DAT_40023844 \u003d _DAT_40023844 | 0x4000;\n        *(uint *)(((position \u003e\u003e 2) + 2) * 4 + 0x40013800) \u003d\n             ~(0xf \u003c\u003c ((position \u0026 3) \u003c\u003c 2)) \u0026 *(uint *)(((position \u003e\u003e 2) + 2) * 4 + 0x40013800);\n        if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40020000) {\n          iVar4 \u003d 0;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40020400) {\n          iVar4 \u003d 1;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40020800) {\n          iVar4 \u003d 2;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40020c00) {\n          iVar4 \u003d 3;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40021000) {\n          iVar4 \u003d 4;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40021400) {\n          iVar4 \u003d 5;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40021800) {\n          iVar4 \u003d 6;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40021c00) {\n          iVar4 \u003d 7;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40022000) {\n          iVar4 \u003d 8;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40022400) {\n          iVar4 \u003d 9;\n        }\n        else {\n          iVar4 \u003d 10;\n        }\n        *(uint *)(((position \u003e\u003e 2) + 2) * 4 + 0x40013800) \u003d\n             iVar4 \u003c\u003c ((position \u0026 3) \u003c\u003c 2) | *(uint *)(((position \u003e\u003e 2) + 2) * 4 + 0x40013800);\n        _DAT_40013c00 \u003d ~uVar3 \u0026 _DAT_40013c00;\n        _DAT_40013c04 \u003d ~uVar3 \u0026 _DAT_40013c04;\n        if ((GPIO_Init-\u003eMode \u0026 0x10000) !\u003d 0) {\n          _DAT_40013c00 \u003d uVar3 | _DAT_40013c00;\n        }\n        if ((GPIO_Init-\u003eMode \u0026 0x20000) !\u003d 0) {\n          _DAT_40013c04 \u003d uVar3 | _DAT_40013c04;\n        }\n        _DAT_40013c08 \u003d ~uVar3 \u0026 _DAT_40013c08;\n        _DAT_40013c0c \u003d ~uVar3 \u0026 _DAT_40013c0c;\n        if ((GPIO_Init-\u003eMode \u0026 0x100000) !\u003d 0) {\n          _DAT_40013c08 \u003d uVar3 | _DAT_40013c08;\n        }\n        if ((GPIO_Init-\u003eMode \u0026 0x200000) !\u003d 0) {\n          _DAT_40013c0c \u003d uVar3 | _DAT_40013c0c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "gpio_init",
        "HAL_RCC_MCOConfig"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GPIO_DeInit": {
      "entrypoint": "0x080071d0",
      "current_name": "HAL_GPIO_DeInit",
      "code": "\n\n\nvoid HAL_GPIO_DeInit(GPIO_TypeDef *GPIOx,uint32_t GPIO_Pin)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint32_t GPIO_Pin_local;\n  GPIO_TypeDef *GPIOx_local;\n  uint32_t tmp;\n  uint32_t iocurrent;\n  uint32_t ioposition;\n  uint32_t position;\n  \n  for (position \u003d 0; position \u003c 0x10; position \u003d position + 1) {\n    uVar1 \u003d 1 \u003c\u003c (position \u0026 0xff);\n    uVar2 \u003d uVar1 \u0026 GPIO_Pin;\n    if (uVar2 \u003d\u003d uVar1) {\n      GPIOx-\u003eMODER \u003d GPIOx-\u003eMODER \u0026 ~(3 \u003c\u003c ((position \u0026 0x7f) \u003c\u003c 1));\n      GPIOx-\u003eAFR[position \u003e\u003e 3] \u003d GPIOx-\u003eAFR[position \u003e\u003e 3] \u0026 ~(0xf \u003c\u003c ((position \u0026 7) \u003c\u003c 2));\n      GPIOx-\u003eOSPEEDR \u003d GPIOx-\u003eOSPEEDR \u0026 ~(3 \u003c\u003c ((position \u0026 0x7f) \u003c\u003c 1));\n      GPIOx-\u003eOTYPER \u003d GPIOx-\u003eOTYPER \u0026 ~(1 \u003c\u003c (position \u0026 0xff));\n      GPIOx-\u003ePUPDR \u003d GPIOx-\u003ePUPDR \u0026 ~(3 \u003c\u003c ((position \u0026 0x7f) \u003c\u003c 1));\n      *(uint *)(((position \u003e\u003e 2) + 2) * 4 + 0x40013800) \u003d\n           ~(0xf \u003c\u003c ((position \u0026 3) \u003c\u003c 2)) \u0026 *(uint *)(((position \u003e\u003e 2) + 2) * 4 + 0x40013800);\n      _DAT_40013c00 \u003d ~uVar2 \u0026 _DAT_40013c00;\n      _DAT_40013c04 \u003d ~uVar2 \u0026 _DAT_40013c04;\n      _DAT_40013c08 \u003d ~uVar2 \u0026 _DAT_40013c08;\n      _DAT_40013c0c \u003d ~uVar2 \u0026 _DAT_40013c0c;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GPIO_ReadPin": {
      "entrypoint": "0x08007310",
      "current_name": "HAL_GPIO_ReadPin",
      "code": "\nGPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx,uint16_t GPIO_Pin)\n\n{\n  uint16_t GPIO_Pin_local;\n  GPIO_TypeDef *GPIOx_local;\n  GPIO_PinState bitstatus;\n  \n  return ((uint)GPIO_Pin \u0026 GPIOx-\u003eIDR) !\u003d 0;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GPIO_WritePin": {
      "entrypoint": "0x0800733e",
      "current_name": "HAL_GPIO_WritePin",
      "code": "\nvoid HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx,uint16_t GPIO_Pin,GPIO_PinState PinState)\n\n{\n  GPIO_PinState PinState_local;\n  uint16_t GPIO_Pin_local;\n  GPIO_TypeDef *GPIOx_local;\n  \n  if (PinState \u003d\u003d GPIO_PIN_RESET) {\n    GPIOx-\u003eBSRRH \u003d GPIO_Pin;\n  }\n  else {\n    GPIOx-\u003eBSRRL \u003d GPIO_Pin;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "gpio_init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GPIO_TogglePin": {
      "entrypoint": "0x0800736c",
      "current_name": "HAL_GPIO_TogglePin",
      "code": "\nvoid HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx,uint16_t GPIO_Pin)\n\n{\n  uint16_t GPIO_Pin_local;\n  GPIO_TypeDef *GPIOx_local;\n  \n  GPIOx-\u003eODR \u003d GPIOx-\u003eODR ^ (uint)GPIO_Pin;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GPIO_EXTI_IRQHandler": {
      "entrypoint": "0x0800738e",
      "current_name": "HAL_GPIO_EXTI_IRQHandler",
      "code": "\n\n\nvoid HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)\n\n{\n  uint16_t GPIO_Pin_local;\n  \n  if ((GPIO_Pin \u0026 _DAT_40013c14) !\u003d 0) {\n    _DAT_40013c14 \u003d (uint)GPIO_Pin;\n    HAL_GPIO_EXTI_Callback(GPIO_Pin);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_Callback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GPIO_EXTI_Callback": {
      "entrypoint": "0x080073c0",
      "current_name": "HAL_GPIO_EXTI_Callback",
      "code": "\nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)\n\n{\n  uint16_t GPIO_Pin_local;\n  \n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "gpio_clr": {
      "entrypoint": "0x080073d4",
      "current_name": "gpio_clr",
      "code": "\nvoid gpio_clr(int n)\n\n{\n  int n_local;\n  \n  *(short *)((n \u003e\u003e 4) * 0x400 + 0x4002001a) \u003d (short)(1 \u003c\u003c (n \u0026 0xfU));\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "debounce_off_handler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "gpio_set": {
      "entrypoint": "0x08007402",
      "current_name": "gpio_set",
      "code": "\nvoid gpio_set(int n)\n\n{\n  int n_local;\n  \n  *(short *)((n \u003e\u003e 4) * 0x400 + 0x40020018) \u003d (short)(1 \u003c\u003c (n \u0026 0xfU));\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "debounce_on_handler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "Error_Handler": {
      "entrypoint": "0x08007430",
      "current_name": "Error_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid Error_Handler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "SystemClock_Config"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "SystemClock_Config": {
      "entrypoint": "0x08007436",
      "current_name": "SystemClock_Config",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid SystemClock_Config(void)\n\n{\n  HAL_StatusTypeDef HVar1;\n  RCC_OscInitTypeDef RCC_OscInitStruct;\n  RCC_ClkInitTypeDef RCC_ClkInitStruct;\n  \n  _DAT_40023840 \u003d _DAT_40023840 | 0x10000000;\n  _DAT_40007000 \u003d _DAT_40007000 | 0xc000;\n  RCC_OscInitStruct.OscillatorType \u003d 1;\n  RCC_OscInitStruct.HSEState \u003d 1;\n  RCC_OscInitStruct.PLL.PLLState \u003d 2;\n  RCC_OscInitStruct.PLL.PLLSource \u003d 0x400000;\n  RCC_OscInitStruct.PLL.PLLM \u003d 8;\n  RCC_OscInitStruct.PLL.PLLN \u003d 0x150;\n  RCC_OscInitStruct.PLL.PLLP \u003d 2;\n  RCC_OscInitStruct.PLL.PLLQ \u003d 7;\n  HVar1 \u003d HAL_RCC_OscConfig(\u0026RCC_OscInitStruct);\n  if (HVar1 !\u003d HAL_OK) {\n    Error_Handler();\n  }\n  RCC_ClkInitStruct.ClockType \u003d 0xf;\n  RCC_ClkInitStruct.SYSCLKSource \u003d 2;\n  RCC_ClkInitStruct.AHBCLKDivider \u003d 0;\n  RCC_ClkInitStruct.APB1CLKDivider \u003d 0x1400;\n  RCC_ClkInitStruct.APB2CLKDivider \u003d 0x1000;\n  HVar1 \u003d HAL_RCC_ClockConfig(\u0026RCC_ClkInitStruct,5);\n  if (HVar1 !\u003d HAL_OK) {\n    Error_Handler();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "HAL_RCC_OscConfig",
        "HAL_RCC_ClockConfig",
        "Error_Handler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debounce_on_handler": {
      "entrypoint": "0x080078d0",
      "current_name": "debounce_on_handler",
      "code": "\nvoid debounce_on_handler(uint32_t bits)\n\n{\n  uint uVar1;\n  int in_r3;\n  undefined4 unaff_r4;\n  undefined4 unaff_r7;\n  uint unaff_r8;\n  int unaff_r11;\n  int in_r12;\n  char in_NG;\n  undefined in_CY;\n  char in_OV;\n  undefined4 in_cr4;\n  uint32_t bits_local;\n  \n  if (in_NG !\u003d in_OV) {\n    unaff_r11 \u003d in_r3 + bits * 0x200;\n  }\n  if ((bool)in_OV) {\n    uVar1 \u003d bits * 0x40000000;\n    in_CY \u003d unaff_r8 \u003c\u003d uVar1;\n    in_OV \u003d SBORROW4(uVar1,unaff_r8);\n    in_NG \u003d (int)(uVar1 - unaff_r8) \u003c 0;\n  }\n  if (!(bool)in_CY) {\n    *(int *)(in_r12 + bits * -0x40000000) \u003d unaff_r11;\n  }\n  if (in_NG \u003d\u003d in_OV) {\n    software_interrupt(0xb083);\n  }\n  else {\n    coprocessor_store(6,in_cr4,bits);\n    *(undefined4 *)bits \u003d unaff_r4;\n    software_interrupt(0x6078);\n  }\n  if ((bool)in_NG) {\n    register0x00000054 \u003d (BADSPACEBASE *)(\u0026stack0x00000000 + in_r12 * 0x4000);\n  }\n  *(undefined4 *)((int)register0x00000054 + -4) \u003d unaff_r7;\n  *(undefined4 *)((int)register0x00000054 + -0xc) \u003d 0;\n  *(undefined4 *)((int)register0x00000054 + -0x10) \u003d 0;\n  while (*(int *)((int)register0x00000054 + -0x10) \u003c 4) {\n    *(uint32_t *)((int)register0x00000054 + -0xc) \u003d\n         debounce.sample[*(int *)((int)register0x00000054 + -0x10)] |\n         *(uint *)((int)register0x00000054 + -0xc);\n    *(int *)((int)register0x00000054 + -0x10) \u003d *(int *)((int)register0x00000054 + -0x10) + 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debounce_off_handler": {
      "entrypoint": "0x080078e2",
      "current_name": "debounce_off_handler",
      "code": "\nvoid debounce_off_handler(uint32_t bits)\n\n{\n  uint uVar1;\n  int in_r3;\n  undefined4 unaff_r4;\n  uint unaff_r8;\n  int unaff_r11;\n  int in_r12;\n  char in_NG;\n  undefined in_CY;\n  char in_OV;\n  undefined4 in_cr4;\n  uint32_t bits_local;\n  \n  if (in_NG !\u003d in_OV) {\n    unaff_r11 \u003d in_r3 + bits * 0x200;\n  }\n  if ((bool)in_OV) {\n    uVar1 \u003d bits * 0x40000000;\n    in_CY \u003d unaff_r8 \u003c\u003d uVar1;\n    in_OV \u003d SBORROW4(uVar1,unaff_r8);\n    in_NG \u003d (int)(uVar1 - unaff_r8) \u003c 0;\n  }\n  if (!(bool)in_CY) {\n    *(int *)(in_r12 + bits * -0x40000000) \u003d unaff_r11;\n  }\n  if (in_NG !\u003d in_OV) {\n    coprocessor_store(6,in_cr4,bits);\n    *(undefined4 *)bits \u003d unaff_r4;\n  }\n  for (bits_local \u003d 0; (int)bits_local \u003c 4; bits_local \u003d bits_local + 1) {\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "main": {
      "entrypoint": "0x08007540",
      "current_name": "main",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint main(void)\n\n{\n  HAL_Init();\n  SystemClock_Config();\n  gpio_init();\n  timers_init();\n  debounce_init();\n  usart_init();\n  startForkserver(0);\n  grbl_main();\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "Reset_Handler"
      ],
      "called": [
        "SystemClock_Config",
        "gpio_init",
        "HAL_Init",
        "debounce_init",
        "timers_init",
        "grbl_main",
        "startForkserver",
        "usart_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "SystemInit": {
      "entrypoint": "0x0800756c",
      "current_name": "SystemInit",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid SystemInit(void)\n\n{\n  _DAT_40023808 \u003d 0;\n  _DAT_40023804 \u003d 0x24003010;\n  _DAT_40023800 \u003d _DAT_40023800 \u0026 0xfef2ffff | 1;\n  _DAT_4002380c \u003d 0;\n  _DAT_e000ed08 \u003d 0x8000000;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "Reset_Handler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "SystemCoreClockUpdate": {
      "entrypoint": "0x080075c8",
      "current_name": "SystemCoreClockUpdate",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid SystemCoreClockUpdate(void)\n\n{\n  uint uVar1;\n  uint32_t pllm;\n  uint32_t pllsource;\n  uint32_t pllp;\n  uint32_t tmp;\n  uint32_t pllvco;\n  \n  uVar1 \u003d _DAT_40023808 \u0026 0xc;\n  if (uVar1 \u003d\u003d 8) {\n    if ((_DAT_40023804 \u003e\u003e 0x16 \u0026 1) \u003d\u003d 0) {\n      pllvco \u003d (_DAT_40023804 \u003e\u003e 6 \u0026 0x1ff) * (16000000 / (_DAT_40023804 \u0026 0x3f));\n    }\n    else {\n      pllvco \u003d (_DAT_40023804 \u003e\u003e 6 \u0026 0x1ff) * (8000000 / (_DAT_40023804 \u0026 0x3f));\n    }\n    SystemCoreClock \u003d pllvco / (((_DAT_40023804 \u003e\u003e 0x10 \u0026 3) + 1) * 2);\n    goto LAB_0800768a;\n  }\n  if (uVar1 \u003c 9) {\n    if (uVar1 \u003d\u003d 0) {\n      SystemCoreClock \u003d 16000000;\n      goto LAB_0800768a;\n    }\n    if (uVar1 \u003d\u003d 4) {\n      SystemCoreClock \u003d 8000000;\n      goto LAB_0800768a;\n    }\n  }\n  SystemCoreClock \u003d 16000000;\nLAB_0800768a:\n  SystemCoreClock \u003d SystemCoreClock \u003e\u003e AHBPrescTable[_DAT_40023808 \u003e\u003e 4 \u0026 0xf];\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "gpio_toggle": {
      "entrypoint": "0x080076c8",
      "current_name": "gpio_toggle",
      "code": "\nvoid gpio_toggle(int n)\n\n{\n  int n_local;\n  \n  *(uint *)((n \u003e\u003e 4) * 0x400 + 0x40020014) \u003d\n       *(uint *)((n \u003e\u003e 4) * 0x400 + 0x40020014) ^ 1 \u003c\u003c (n \u0026 0xfU);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SysTick_Handler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "NMI_Handler": {
      "entrypoint": "0x0800770e",
      "current_name": "NMI_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid NMI_Handler(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HardFault_Handler": {
      "entrypoint": "0x0800771a",
      "current_name": "HardFault_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HardFault_Handler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "MemManage_Handler": {
      "entrypoint": "0x08007720",
      "current_name": "MemManage_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid MemManage_Handler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "BusFault_Handler": {
      "entrypoint": "0x08007726",
      "current_name": "BusFault_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid BusFault_Handler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UsageFault_Handler": {
      "entrypoint": "0x0800772c",
      "current_name": "UsageFault_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid UsageFault_Handler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "SVC_Handler": {
      "entrypoint": "0x08007732",
      "current_name": "SVC_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid SVC_Handler(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "DebugMon_Handler": {
      "entrypoint": "0x0800773e",
      "current_name": "DebugMon_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid DebugMon_Handler(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PendSV_Handler": {
      "entrypoint": "0x0800774a",
      "current_name": "PendSV_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid PendSV_Handler(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "SysTick_Handler": {
      "entrypoint": "0x08007756",
      "current_name": "SysTick_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid SysTick_Handler(void)\n\n{\n  uint32_t uVar1;\n  uint32_t ticks;\n  \n  uVar1 \u003d HAL_GetTick();\n  if ((uVar1 \u0026 0x1ff) \u003d\u003d 0) {\n    gpio_toggle(0x3c);\n  }\n  if ((uVar1 \u0026 0xf) \u003d\u003d 0) {\n    debounce_isr();\n  }\n  HAL_IncTick();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "gpio_toggle",
        "HAL_GetTick",
        "debounce_isr",
        "HAL_IncTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "gpio_init": {
      "entrypoint": "0x0800778c",
      "current_name": "gpio_init",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid gpio_init(void)\n\n{\n  GPIO_INFO *pGVar1;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  GPIO_INFO *gpio;\n  int i;\n  \n  for (i \u003d 0; (uint)i \u003c 0x11; i \u003d i + 1) {\n    pGVar1 \u003d gpio_info + i;\n    _DAT_40023830 \u003d _DAT_40023830 | 1 \u003c\u003c (pGVar1-\u003enum \u003e\u003e 4 \u0026 0xff);\n    GPIO_InitStruct.Pin \u003d 1 \u003c\u003c (pGVar1-\u003enum \u0026 0xf);\n    GPIO_InitStruct.Mode \u003d gpio_info[i].mode;\n    GPIO_InitStruct.Pull \u003d gpio_info[i].pull;\n    GPIO_InitStruct.Speed \u003d gpio_info[i].speed;\n    GPIO_InitStruct.Alternate \u003d gpio_info[i].alt;\n    HAL_GPIO_Init((GPIO_TypeDef *)(((pGVar1-\u003enum \u003e\u003e 4) + 0x100080) * 0x400),\u0026GPIO_InitStruct);\n    if (-1 \u003c gpio_info[i].init) {\n      HAL_GPIO_WritePin((GPIO_TypeDef *)(((pGVar1-\u003enum \u003e\u003e 4) + 0x100080) * 0x400),\n                        (uint16_t)(1 \u003c\u003c (pGVar1-\u003enum \u0026 0xf)),(GPIO_PinState)gpio_info[i].init);\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "HAL_GPIO_WritePin",
        "HAL_GPIO_Init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "gpio_rd": {
      "entrypoint": "0x08007854",
      "current_name": "gpio_rd",
      "code": "\nint gpio_rd(int n)\n\n{\n  int n_local;\n  \n  return *(uint *)((n \u003e\u003e 4) * 0x400 + 0x40020010) \u003e\u003e (n \u0026 0xfU) \u0026 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "debounce_input"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debounce_input": {
      "entrypoint": "0x08007884",
      "current_name": "debounce_input",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t debounce_input(void)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  uint uVar6;\n  \n  iVar1 \u003d gpio_rd(0x36);\n  iVar2 \u003d gpio_rd(0x37);\n  iVar3 \u003d gpio_rd(0x38);\n  iVar4 \u003d gpio_rd(0x39);\n  iVar5 \u003d gpio_rd(0xf);\n  uVar6 \u003d gpio_rd(0);\n  return uVar6 | iVar1 \u003c\u003c 4 | iVar2 \u003c\u003c 3 | iVar3 \u003c\u003c 2 | iVar4 \u003c\u003c 1 | iVar5 \u003c\u003c 7;\n}\n\n",
      "renaming": {},
      "calling": [
        "debounce_isr"
      ],
      "called": [
        "gpio_rd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debounce_rd": {
      "entrypoint": "0x080078f4",
      "current_name": "debounce_rd",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t debounce_rd(void)\n\n{\n  int i;\n  uint32_t state;\n  \n  state \u003d 0;\n  for (i \u003d 0; i \u003c 4; i \u003d i + 1) {\n    state \u003d debounce.sample[i] | state;\n  }\n  return state;\n}\n\n",
      "renaming": {},
      "calling": [
        "homing_cycle",
        "debounce_isr"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debounce_isr": {
      "entrypoint": "0x08007930",
      "current_name": "debounce_isr",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid debounce_isr(void)\n\n{\n  int iVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  uint bits;\n  uint32_t off_bits;\n  uint32_t on_bits;\n  uint32_t state;\n  DEBOUNCE_CTRL *db;\n  \n  iVar1 \u003d debounce.idx;\n  uVar2 \u003d debounce.state;\n  if (debounce_ready !\u003d 0) {\n    uVar2 \u003d debounce_input();\n    debounce.sample[iVar1] \u003d uVar2;\n    if (debounce.idx \u003d\u003d 3) {\n      debounce.idx \u003d 0;\n    }\n    else {\n      debounce.idx \u003d debounce.idx + 1;\n    }\n    uVar3 \u003d debounce_rd();\n    uVar2 \u003d debounce.state;\n    if (uVar3 !\u003d debounce.state) {\n      bits \u003d ~uVar3 \u0026 debounce.state;\n      if ((~debounce.state \u0026 uVar3) !\u003d 0) {\n        debounce_on_handler(~debounce.state \u0026 uVar3);\n      }\n      uVar2 \u003d uVar3;\n      if (bits !\u003d 0) {\n        debounce_off_handler(bits);\n      }\n    }\n  }\n  debounce.state \u003d uVar2;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SysTick_Handler"
      ],
      "called": [
        "debounce_input",
        "debounce_on_handler",
        "debounce_rd",
        "debounce_off_handler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debounce_init": {
      "entrypoint": "0x080079c0",
      "current_name": "debounce_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid debounce_init(void)\n\n{\n  memset(\u0026debounce,0,0x18);\n  debounce_ready \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "memset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "enable_tim_clock": {
      "entrypoint": "0x08007a10",
      "current_name": "enable_tim_clock",
      "code": "\n\n\nvoid enable_tim_clock(TIM_TypeDef *tim)\n\n{\n  TIM_TypeDef *tim_local;\n  \n  if (tim \u003d\u003d (TIM_TypeDef *)\u0026DAT_40000000) {\n    _DAT_40023840 \u003d _DAT_40023840 | 1;\n  }\n  else if (tim \u003d\u003d (TIM_TypeDef *)0x40000400) {\n    _DAT_40023840 \u003d _DAT_40023840 | 2;\n  }\n  else if (tim \u003d\u003d (TIM_TypeDef *)\u0026DAT_40000800) {\n    _DAT_40023840 \u003d _DAT_40023840 | 4;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "g540_timer_init",
        "step_timer_init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "enable_tim_interrupt": {
      "entrypoint": "0x08007a70",
      "current_name": "enable_tim_interrupt",
      "code": "\nvoid enable_tim_interrupt(TIM_TypeDef *tim,uint32_t pre,uint32_t sub)\n\n{\n  uint32_t sub_local;\n  uint32_t pre_local;\n  TIM_TypeDef *tim_local;\n  uint32_t irq;\n  \n  if (tim \u003d\u003d (TIM_TypeDef *)\u0026DAT_40000000) {\n    irq._0_1_ \u003d TIM2_IRQn;\n  }\n  else if (tim \u003d\u003d (TIM_TypeDef *)0x40000400) {\n    irq._0_1_ \u003d TIM3_IRQn;\n  }\n  else {\n    if (tim !\u003d (TIM_TypeDef *)\u0026DAT_40000800) {\n      return;\n    }\n    irq._0_1_ \u003d TIM4_IRQn;\n  }\n  HAL_NVIC_SetPriority((IRQn_Type)irq,pre,sub);\n  NVIC_EnableIRQ((IRQn_Type)irq);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "step_timer_init"
      ],
      "called": [
        "NVIC_EnableIRQ",
        "HAL_NVIC_SetPriority"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "step_timer_init": {
      "entrypoint": "0x08007ad0",
      "current_name": "step_timer_init",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid step_timer_init(void)\n\n{\n  TIM_TypeDef *TIMx;\n  \n  enable_tim_clock((TIM_TypeDef *)\u0026DAT_40000000);\n  _DAT_40000000 \u003d 0;\n  _DAT_40000004 \u003d 0;\n  _DAT_40000008 \u003d 0;\n  _DAT_4000000c \u003d 0;\n  _DAT_40000010 \u003d 0;\n  _DAT_40000018 \u003d 0;\n  _DAT_4000001c \u003d 0;\n  _DAT_40000020 \u003d 0;\n  _DAT_40000024 \u003d 0;\n  _DAT_40000028 \u003d SystemCoreClock / 42000000 - 1;\n  _DAT_4000002c \u003d 0;\n  _DAT_40000034 \u003d 0;\n  _DAT_40000038 \u003d 0;\n  _DAT_4000003c \u003d 0;\n  _DAT_40000040 \u003d 0;\n  _DAT_40000048 \u003d 0;\n  _DAT_4000004c \u003d 0;\n  enable_tim_interrupt((TIM_TypeDef *)\u0026DAT_40000000,0,0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "timers_init"
      ],
      "called": [
        "enable_tim_clock",
        "enable_tim_interrupt"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "step_isr_enable": {
      "entrypoint": "0x08007b70",
      "current_name": "step_isr_enable",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid step_isr_enable(void)\n\n{\n  TIM_TypeDef *TIMx;\n  uint32_t enable;\n  \n  enable \u003d 1;\n  if (_DAT_40000034 !\u003d 0) {\n    enable \u003d 3;\n  }\n  if (_DAT_40000038 !\u003d 0) {\n    enable \u003d enable | 4;\n  }\n  _DAT_4000000c \u003d _DAT_4000000c | enable;\n  _DAT_40000000 \u003d _DAT_40000000 | 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "st_wake_up"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "step_isr_disable": {
      "entrypoint": "0x08007bc2",
      "current_name": "step_isr_disable",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid step_isr_disable(void)\n\n{\n  TIM_TypeDef *TIMx;\n  \n  _DAT_40000000 \u003d _DAT_40000000 \u0026 0xfffffffe;\n  _DAT_4000000c \u003d _DAT_4000000c \u0026 0xfffffff8;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "st_go_idle"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "set_step_period": {
      "entrypoint": "0x08007bf0",
      "current_name": "set_step_period",
      "code": "\n\n\nvoid set_step_period(uint32_t ticks)\n\n{\n  uint32_t ticks_local;\n  uint32_t saved;\n  TIM_TypeDef *TIMx;\n  \n  _DAT_4000002c \u003d ticks;\n  if (ticks \u003c\u003d _DAT_40000024) {\n    _DAT_40000024 \u003d ticks;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "set_step_events_per_minute"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "set_step_pulse_delay": {
      "entrypoint": "0x08007c40",
      "current_name": "set_step_pulse_delay",
      "code": "\n\n\nvoid set_step_pulse_delay(uint32_t ticks)\n\n{\n  uint32_t ticks_local;\n  TIM_TypeDef *TIMx;\n  \n  _DAT_40000034 \u003d ticks;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "st_wake_up"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "set_step_pulse_time": {
      "entrypoint": "0x08007c5e",
      "current_name": "set_step_pulse_time",
      "code": "\n\n\nvoid set_step_pulse_time(uint32_t ticks)\n\n{\n  uint32_t ticks_local;\n  TIM_TypeDef *TIMx;\n  \n  _DAT_40000038 \u003d ticks;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "st_wake_up"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM2_IRQHandler": {
      "entrypoint": "0x08007c7c",
      "current_name": "TIM2_IRQHandler",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid TIM2_IRQHandler(void)\n\n{\n  TIM_TypeDef *TIMx;\n  \n  if (((_DAT_40000010 \u0026 2) !\u003d 0) \u0026\u0026 ((_DAT_4000000c \u0026 2) !\u003d 0)) {\n    _DAT_40000010 \u003d _DAT_40000010 \u0026 0xfffffffd;\n    step_delay_isr();\n  }\n  if (((_DAT_40000010 \u0026 4) !\u003d 0) \u0026\u0026 ((_DAT_4000000c \u0026 4) !\u003d 0)) {\n    _DAT_40000010 \u003d _DAT_40000010 \u0026 0xfffffffb;\n    step_pulse_isr();\n  }\n  if (((_DAT_40000010 \u0026 1) !\u003d 0) \u0026\u0026 ((_DAT_4000000c \u0026 1) !\u003d 0)) {\n    _DAT_40000010 \u003d _DAT_40000010 \u0026 0xfffffffe;\n    step_period_isr();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "step_pulse_isr",
        "step_period_isr",
        "step_delay_isr"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "g540_timer_init": {
      "entrypoint": "0x08007d08",
      "current_name": "g540_timer_init",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid g540_timer_init(void)\n\n{\n  TIM_TypeDef *TIMx;\n  \n  enable_tim_clock((TIM_TypeDef *)\u0026DAT_40000800);\n  _DAT_40000800 \u003d 0x80;\n  _DAT_40000804 \u003d 0;\n  _DAT_40000808 \u003d 0;\n  _DAT_4000080c \u003d 0;\n  _DAT_40000810 \u003d 0;\n  _DAT_40000818 \u003d 0x6800;\n  _DAT_4000081c \u003d 0;\n  _DAT_40000820 \u003d 0;\n  _DAT_40000824 \u003d 0;\n  _DAT_40000828 \u003d SystemCoreClock / 4800000 - 1;\n  _DAT_4000082c \u003d 199;\n  _DAT_40000834 \u003d 0;\n  _DAT_40000838 \u003d 100;\n  _DAT_4000083c \u003d 0;\n  _DAT_40000840 \u003d 0;\n  _DAT_40000848 \u003d 0;\n  _DAT_4000084c \u003d 0;\n  _DAT_40000814 \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "timers_init"
      ],
      "called": [
        "enable_tim_clock"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "g540_timer_start": {
      "entrypoint": "0x08007da8",
      "current_name": "g540_timer_start",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid g540_timer_start(void)\n\n{\n  TIM_TypeDef *TIMx;\n  \n  _DAT_40000820 \u003d _DAT_40000820 | 0x10;\n  _DAT_40000800 \u003d _DAT_40000800 | 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "timers_init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "g540_timer_stop": {
      "entrypoint": "0x08007dd8",
      "current_name": "g540_timer_stop",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid g540_timer_stop(void)\n\n{\n  TIM_TypeDef *TIMx;\n  \n  _DAT_40000800 \u003d _DAT_40000800 \u0026 0xfffffffe;\n  _DAT_40000820 \u003d _DAT_40000820 \u0026 0xffffffef;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "timers_init": {
      "entrypoint": "0x08007e08",
      "current_name": "timers_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid timers_init(void)\n\n{\n  step_timer_init();\n  g540_timer_init();\n  g540_timer_start();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "g540_timer_init",
        "g540_timer_start",
        "step_timer_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "usart_putc": {
      "entrypoint": "0x08007e1c",
      "current_name": "usart_putc",
      "code": "\n\n\nvoid usart_putc(char c)\n\n{\n  char c_local;\n  USART_TypeDef *usart;\n  \n  do {\n  } while ((_DAT_40004400 \u0026 0x80) \u003d\u003d 0);\n  _DAT_40004404 \u003d (uint)(byte)c;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "serial_write",
        "__io_putchar"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "usart_flush": {
      "entrypoint": "0x08007e4c",
      "current_name": "usart_flush",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid usart_flush(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "usart_tstc": {
      "entrypoint": "0x08007e58",
      "current_name": "usart_tstc",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nint usart_tstc(void)\n\n{\n  USART_TypeDef *usart;\n  \n  return (uint)((_DAT_40004400 \u0026 0x20) !\u003d 0);\n}\n\n",
      "renaming": {},
      "calling": [
        "serial_read"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "usart_getc": {
      "entrypoint": "0x08007e84",
      "current_name": "usart_getc",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nchar usart_getc(void)\n\n{\n  USART_TypeDef *usart;\n  \n  return (char)_DAT_40004404;\n}\n\n",
      "renaming": {},
      "calling": [
        "serial_read"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "enable_usart_clock": {
      "entrypoint": "0x08007ea4",
      "current_name": "enable_usart_clock",
      "code": "\n\n\nvoid enable_usart_clock(USART_TypeDef *usart)\n\n{\n  USART_TypeDef *usart_local;\n  \n  if (usart \u003d\u003d (USART_TypeDef *)0x40011000) {\n    _DAT_40023844 \u003d _DAT_40023844 | 0x10;\n  }\n  else if (usart \u003d\u003d (USART_TypeDef *)\u0026DAT_40004400) {\n    _DAT_40023840 \u003d _DAT_40023840 | 0x20000;\n  }\n  else if (usart \u003d\u003d (USART_TypeDef *)0x40004800) {\n    _DAT_40023840 \u003d _DAT_40023840 | 0x40000;\n  }\n  else if (usart \u003d\u003d (USART_TypeDef *)0x40004c00) {\n    _DAT_40023840 \u003d _DAT_40023840 | 0x80000;\n  }\n  else if (usart \u003d\u003d (USART_TypeDef *)0x40005000) {\n    _DAT_40023840 \u003d _DAT_40023840 | 0x100000;\n  }\n  else if (usart \u003d\u003d (USART_TypeDef *)0x40011400) {\n    _DAT_40023844 \u003d _DAT_40023844 | 0x20;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "usart_init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "set_baud_rate": {
      "entrypoint": "0x08007f54",
      "current_name": "set_baud_rate",
      "code": "\nvoid set_baud_rate(USART_TypeDef *usart,int baud)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  int baud_local;\n  USART_TypeDef *usart_local;\n  \n  if ((usart-\u003eCR1 \u0026 0x8000) \u003d\u003d 0) {\n    if ((usart \u003d\u003d (USART_TypeDef *)0x40011000) || (usart \u003d\u003d (USART_TypeDef *)0x40011400)) {\n      uVar1 \u003d HAL_RCC_GetPCLK2Freq();\n      uVar2 \u003d HAL_RCC_GetPCLK2Freq();\n      uVar3 \u003d HAL_RCC_GetPCLK2Freq();\n      usart-\u003eBRR \u003d (int)(((ulonglong)(uVar1 * 0x19) / (ulonglong)(uint)(baud \u003c\u003c 2)) / 100) \u003c\u003c 4 |\n                   (((uVar2 * 0x19) / (uint)(baud \u003c\u003c 2) +\n                    (int)(((ulonglong)(uVar3 * 0x19) / (ulonglong)(uint)(baud \u003c\u003c 2)) / 100) * -100)\n                    * 0x10 + 0x32) / 100 \u0026 0xf;\n    }\n    else {\n      uVar1 \u003d HAL_RCC_GetPCLK1Freq();\n      uVar2 \u003d HAL_RCC_GetPCLK1Freq();\n      uVar3 \u003d HAL_RCC_GetPCLK1Freq();\n      usart-\u003eBRR \u003d (int)(((ulonglong)(uVar1 * 0x19) / (ulonglong)(uint)(baud \u003c\u003c 2)) / 100) \u003c\u003c 4 |\n                   (((uVar2 * 0x19) / (uint)(baud \u003c\u003c 2) +\n                    (int)(((ulonglong)(uVar3 * 0x19) / (ulonglong)(uint)(baud \u003c\u003c 2)) / 100) * -100)\n                    * 0x10 + 0x32) / 100 \u0026 0xf;\n    }\n  }\n  else if ((usart \u003d\u003d (USART_TypeDef *)0x40011000) || (usart \u003d\u003d (USART_TypeDef *)0x40011400)) {\n    uVar1 \u003d HAL_RCC_GetPCLK2Freq();\n    uVar2 \u003d HAL_RCC_GetPCLK2Freq();\n    uVar3 \u003d HAL_RCC_GetPCLK2Freq();\n    usart-\u003eBRR \u003d (int)(((ulonglong)(uVar1 * 0x19) / (ulonglong)(uint)(baud \u003c\u003c 1)) / 100) \u003c\u003c 4 |\n                 (((uVar2 * 0x19) / (uint)(baud \u003c\u003c 1) +\n                  (int)(((ulonglong)(uVar3 * 0x19) / (ulonglong)(uint)(baud \u003c\u003c 1)) / 100) * -100) *\n                  0x10 + 0x32) / 100 \u0026 0xf;\n  }\n  else {\n    uVar1 \u003d HAL_RCC_GetPCLK1Freq();\n    uVar2 \u003d HAL_RCC_GetPCLK1Freq();\n    uVar3 \u003d HAL_RCC_GetPCLK1Freq();\n    usart-\u003eBRR \u003d (int)(((ulonglong)(uVar1 * 0x19) / (ulonglong)(uint)(baud \u003c\u003c 1)) / 100) \u003c\u003c 4 |\n                 (((uVar2 * 0x19) / (uint)(baud \u003c\u003c 1) +\n                  (int)(((ulonglong)(uVar3 * 0x19) / (ulonglong)(uint)(baud \u003c\u003c 1)) / 100) * -100) *\n                  0x10 + 0x32) / 100 \u0026 0xf;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "usart_init"
      ],
      "called": [
        "HAL_RCC_GetPCLK2Freq",
        "HAL_RCC_GetPCLK1Freq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "usart_init": {
      "entrypoint": "0x08008190",
      "current_name": "usart_init",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid usart_init(void)\n\n{\n  uint32_t val;\n  USART_TypeDef *usart;\n  \n  enable_usart_clock((USART_TypeDef *)\u0026DAT_40004400);\n  _DAT_4000440c \u003d _DAT_4000440c \u0026 0xffff400c | 0xc;\n  _DAT_40004410 \u003d _DAT_40004410 \u0026 0xffff8090;\n  _DAT_40004414 \u003d _DAT_40004414 \u0026 0xfffff000;\n  _DAT_40004400 \u003d _DAT_40004400 \u0026 0xfffffc00;\n  set_baud_rate((USART_TypeDef *)\u0026DAT_40004400,0x1c200);\n  _DAT_4000440c \u003d _DAT_4000440c | 0x2000;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "enable_usart_clock",
        "set_baud_rate"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serial_init": {
      "entrypoint": "0x08008244",
      "current_name": "serial_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid serial_init(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "grbl_main"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serial_write": {
      "entrypoint": "0x08008250",
      "current_name": "serial_write",
      "code": "\nvoid serial_write(uint8_t data)\n\n{\n  uint8_t data_local;\n  \n  usart_putc(data);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "printFloat",
        "printString",
        "print_base2",
        "printPgmString",
        "print_uint32_base10",
        "printInteger"
      ],
      "called": [
        "usart_putc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__io_putchar": {
      "entrypoint": "0x0800826a",
      "current_name": "__io_putchar",
      "code": "\nint __io_putchar(int ch)\n\n{\n  int ch_local;\n  \n  usart_putc((char)ch);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "usart_putc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serial_read": {
      "entrypoint": "0x08008286",
      "current_name": "serial_read",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t serial_read(void)\n\n{\n  uint8_t data;\n  int iVar1;\n  uint8_t c;\n  \n  iVar1 \u003d usart_tstc();\n  if (iVar1 !\u003d 0) {\n    data \u003d usart_getc();\n    iVar1 \u003d serial_rx_hook(data);\n    if (iVar1 \u003d\u003d 0) {\n      return data;\n    }\n  }\n  return 0xff;\n}\n\n",
      "renaming": {},
      "calling": [
        "protocol_process"
      ],
      "called": [
        "usart_getc",
        "usart_tstc",
        "serial_rx_hook"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serial_reset_read_buffer": {
      "entrypoint": "0x080082ba",
      "current_name": "serial_reset_read_buffer",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid serial_reset_read_buffer(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "grbl_main"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_drsub": {
      "entrypoint": "0x080082c8",
      "current_name": "__aeabi_drsub",
      "code": "\nvoid __aeabi_drsub(undefined4 param_1,uint param_2)\n\n{\n  __aeabi_dadd(param_1,param_2 ^ 0x80000000);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__aeabi_dadd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__subdf3": {
      "entrypoint": "0x080082d0",
      "current_name": "__subdf3",
      "code": "\nulonglong __subdf3(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  bool bVar14;\n  bool bVar15;\n  \n  uVar6 \u003d param_4 ^ 0x80000000;\n  uVar9 \u003d param_2 \u003c\u003c 1;\n  param_4 \u003d param_4 \u003c\u003c 1;\n  bVar13 \u003d ((param_2 ^ uVar6) \u0026 0x7fffffff) \u003d\u003d 0;\n  bVar14 \u003d bVar13 \u0026\u0026 param_1 \u003d\u003d param_3;\n  if (!bVar13 || param_1 !\u003d param_3) {\n    bVar14 \u003d (uVar9 | param_1) \u003d\u003d 0;\n  }\n  if (!bVar14) {\n    bVar14 \u003d (param_4 | param_3) \u003d\u003d 0;\n  }\n  iVar8 \u003d (int)uVar9 \u003e\u003e 0x15;\n  if (!bVar14) {\n    bVar14 \u003d iVar8 \u003d\u003d -1;\n  }\n  iVar1 \u003d (int)param_4 \u003e\u003e 0x15;\n  if (!bVar14) {\n    bVar14 \u003d iVar1 \u003d\u003d -1;\n  }\n  if (bVar14) {\n    if (iVar8 \u003d\u003d -1 || iVar1 \u003d\u003d -1) {\n      uVar9 \u003d uVar6;\n      uVar11 \u003d param_3;\n      if (iVar8 \u003d\u003d -1) {\n        uVar9 \u003d param_2;\n        uVar11 \u003d param_1;\n      }\n      if (iVar8 !\u003d -1 || iVar1 !\u003d -1) {\n        param_3 \u003d uVar11;\n        uVar6 \u003d uVar9;\n      }\n      bVar14 \u003d (uVar11 | uVar9 \u003c\u003c 0xc) \u003d\u003d 0;\n      if (bVar14) {\n        bVar14 \u003d (param_3 | uVar6 \u003c\u003c 0xc) \u003d\u003d 0;\n      }\n      if (bVar14) {\n        bVar14 \u003d uVar9 \u003d\u003d uVar6;\n      }\n      if (!bVar14) {\n        uVar9 \u003d uVar9 | 0x80000;\n      }\n      return CONCAT44(uVar9,uVar11);\n    }\n    if (((param_2 ^ uVar6) \u0026 0x7fffffff) !\u003d 0 || param_1 !\u003d param_3) {\n      if ((uVar9 | param_1) \u003d\u003d 0) {\n        param_1 \u003d param_3;\n        param_2 \u003d uVar6;\n      }\n      return CONCAT44(param_2,param_1);\n    }\n    if (param_2 !\u003d uVar6) {\n      return 0;\n    }\n    if (uVar9 \u003e\u003e 0x15 \u003d\u003d 0) {\n      bVar14 \u003d (param_1 \u0026 0x80000000) !\u003d 0;\n      uVar6 \u003d param_2 * 2 + (uint)bVar14;\n      if (CARRY4(param_2,param_2) || CARRY4(param_2 * 2,(uint)bVar14)) {\n        uVar6 \u003d uVar6 | 0x80000000;\n      }\n      return CONCAT44(uVar6,param_1 \u003c\u003c 1);\n    }\n    if (uVar9 \u003c 0xffc00000) {\n      return CONCAT44(param_2 + 0x100000,param_1);\n    }\n    param_2 \u003d param_2 \u0026 0x80000000;\nLAB_08008514:\n    return (ulonglong)(param_2 | 0x7ff00000) \u003c\u003c 0x20;\n  }\n  uVar9 \u003d uVar9 \u003e\u003e 0x15;\n  param_4 \u003d param_4 \u003e\u003e 0x15;\n  uVar11 \u003d param_4 - uVar9;\n  bVar14 \u003d uVar11 !\u003d 0;\n  if (param_4 \u003c uVar9) {\n    uVar11 \u003d -uVar11;\n  }\n  uVar10 \u003d param_1;\n  uVar7 \u003d param_2;\n  if (bVar14 \u0026\u0026 uVar9 \u003c\u003d param_4) {\n    uVar9 \u003d uVar9 + uVar11;\n    uVar10 \u003d param_3;\n    uVar7 \u003d uVar6;\n    param_3 \u003d param_1;\n    uVar6 \u003d param_2;\n  }\n  if (0x36 \u003c uVar11) {\n    return CONCAT44(uVar7,uVar10);\n  }\n  uVar4 \u003d uVar7 \u0026 0xfffff | 0x100000;\n  if ((uVar7 \u0026 0x80000000) !\u003d 0) {\n    bVar14 \u003d uVar10 !\u003d 0;\n    uVar10 \u003d -uVar10;\n    uVar4 \u003d -uVar4 - (uint)bVar14;\n  }\n  uVar7 \u003d uVar6 \u0026 0xfffff | 0x100000;\n  if ((uVar6 \u0026 0x80000000) !\u003d 0) {\n    bVar14 \u003d param_3 !\u003d 0;\n    param_3 \u003d -param_3;\n    uVar7 \u003d -uVar7 - (uint)bVar14;\n  }\n  if (uVar9 \u003d\u003d uVar11) {\n    uVar7 \u003d uVar7 ^ 0x100000;\n    if (uVar9 \u003d\u003d 0) {\n      uVar4 \u003d uVar4 ^ 0x100000;\n      uVar9 \u003d 1;\n    }\n    else {\n      uVar11 \u003d uVar11 - 1;\n    }\n  }\n  uVar6 \u003d -uVar11 + 0x20;\n  if ((int)uVar11 \u003c 0x21) {\n    uVar12 \u003d param_3 \u003c\u003c (uVar6 \u0026 0xff);\n    param_3 \u003d param_3 \u003e\u003e (uVar11 \u0026 0xff);\n    uVar3 \u003d uVar10 + param_3;\n    uVar5 \u003d uVar7 \u003c\u003c (uVar6 \u0026 0xff);\n    uVar6 \u003d uVar3 + uVar5;\n    uVar4 \u003d uVar4 + CARRY4(uVar10,param_3) + ((int)uVar7 \u003e\u003e (uVar11 \u0026 0xff)) +\n            (uint)CARRY4(uVar3,uVar5);\n  }\n  else {\n    uVar12 \u003d uVar7 \u003c\u003c (-uVar11 + 0x40 \u0026 0xff);\n    if (param_3 !\u003d 0) {\n      uVar12 \u003d uVar12 | 2;\n    }\n    uVar7 \u003d (int)uVar7 \u003e\u003e (uVar11 - 0x20 \u0026 0xff);\n    uVar6 \u003d uVar10 + uVar7;\n    uVar4 \u003d uVar4 + ((int)uVar7 \u003e\u003e 0x1f) + (uint)CARRY4(uVar10,uVar7);\n  }\n  param_2 \u003d uVar4 \u0026 0x80000000;\n  uVar11 \u003d uVar4;\n  if ((int)uVar4 \u003c 0) {\n    bVar14 \u003d uVar12 \u003d\u003d 0;\n    uVar12 \u003d -uVar12;\n    uVar11 \u003d -uVar6;\n    uVar6 \u003d -(uint)!bVar14 - uVar6;\n    uVar11 \u003d -(uint)(bVar14 \u003c\u003d uVar11) - uVar4;\n  }\n  if (0xfffff \u003c uVar11) {\n    uVar10 \u003d uVar9 - 1;\n    if (0x1fffff \u003c uVar11) {\n      uVar10 \u003d uVar11 \u0026 1;\n      uVar11 \u003d uVar11 \u003e\u003e 1;\n      bVar2 \u003d (byte)uVar6;\n      uVar6 \u003d (uint)(uVar10 !\u003d 0) \u003c\u003c 0x1f | uVar6 \u003e\u003e 1;\n      uVar12 \u003d (uint)(bVar2 \u0026 1) \u003c\u003c 0x1f | uVar12 \u003e\u003e 1;\n      uVar10 \u003d uVar9;\n      if (0xffbfffff \u003c uVar9 * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    bVar14 \u003d 0x7fffffff \u003c uVar12;\n    if (uVar12 \u003d\u003d 0x80000000) {\n      bVar14 \u003d (uVar6 \u0026 1) !\u003d 0;\n    }\n    return CONCAT44(uVar11 + uVar10 * 0x100000 + (uint)CARRY4(uVar6,(uint)bVar14) | param_2,\n                    uVar6 + bVar14);\n  }\n  bVar13 \u003d (uVar12 \u0026 0x80000000) !\u003d 0;\n  uVar12 \u003d uVar12 \u003c\u003c 1;\n  uVar10 \u003d uVar6 * 2;\n  bVar14 \u003d CARRY4(uVar6,uVar6);\n  uVar6 \u003d uVar6 * 2 + (uint)bVar13;\n  uVar11 \u003d uVar11 * 2 + (uint)(bVar14 || CARRY4(uVar10,(uint)bVar13));\n  uVar10 \u003d uVar9 - 2;\n  if (uVar9 - 1 !\u003d 0 \u0026\u0026 0xfffff \u003c uVar11) goto LAB_080083e0;\n  uVar7 \u003d uVar6;\n  uVar9 \u003d uVar11;\n  if (uVar11 \u003d\u003d 0) {\n    uVar7 \u003d 0;\n    uVar9 \u003d uVar6;\n  }\n  iVar8 \u003d LZCOUNT(uVar9);\n  if (uVar11 \u003d\u003d 0) {\n    iVar8 \u003d iVar8 + 0x20;\n  }\n  uVar11 \u003d iVar8 - 0xb;\n  bVar15 \u003d SBORROW4(uVar11,0x20);\n  uVar6 \u003d iVar8 - 0x2b;\n  bVar14 \u003d (int)uVar6 \u003c 0;\n  bVar13 \u003d uVar6 \u003d\u003d 0;\n  if ((int)uVar11 \u003c 0x20) {\n    bVar15 \u003d SCARRY4(uVar6,0xc);\n    iVar8 \u003d iVar8 + -0x1f;\n    bVar14 \u003d iVar8 \u003c 0;\n    bVar13 \u003d iVar8 \u003d\u003d 0;\n    uVar6 \u003d uVar11;\n    if (!bVar13 \u0026\u0026 bVar14 \u003d\u003d bVar15) {\n      uVar7 \u003d uVar9 \u003c\u003c (uVar11 \u0026 0xff);\n      uVar9 \u003d uVar9 \u003e\u003e (0xcU - iVar8 \u0026 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bVar13 || bVar14 !\u003d bVar15) {\n    uVar12 \u003d 0x20 - uVar6;\n  }\n  uVar9 \u003d uVar9 \u003c\u003c (uVar6 \u0026 0xff);\n  if (bVar13 || bVar14 !\u003d bVar15) {\n    uVar9 \u003d uVar9 | uVar7 \u003e\u003e (uVar12 \u0026 0xff);\n  }\n  if (bVar13 || bVar14 !\u003d bVar15) {\n    uVar7 \u003d uVar7 \u003c\u003c (uVar6 \u0026 0xff);\n  }\nLAB_08008458:\n  if ((int)uVar11 \u003c\u003d (int)uVar10) {\n    return CONCAT44(uVar9 + (uVar10 - uVar11) * 0x100000 | param_2,uVar7);\n  }\n  uVar6 \u003d ~(uVar10 - uVar11);\n  if ((int)uVar6 \u003c 0x1f) {\n    iVar8 \u003d uVar6 - 0x13;\n    if (iVar8 !\u003d 0 \u0026\u0026 iVar8 \u003c 0 \u003d\u003d SCARRY4(uVar6 - 0x1f,0xc)) {\n      return CONCAT44(uVar4,uVar7 \u003e\u003e (0x20 - (0xcU - iVar8) \u0026 0xff) | uVar9 \u003c\u003c (0xcU - iVar8 \u0026 0xff)\n                     ) \u0026 0x80000000ffffffff;\n    }\n    uVar6 \u003d uVar6 + 1;\n    return CONCAT44(param_2 | uVar9 \u003e\u003e (uVar6 \u0026 0xff),\n                    uVar7 \u003e\u003e (uVar6 \u0026 0xff) | uVar9 \u003c\u003c (0x20 - uVar6 \u0026 0xff));\n  }\n  return CONCAT44(uVar4,uVar9 \u003e\u003e (uVar6 - 0x1f \u0026 0xff)) \u0026 0x80000000ffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "report_realtime_status",
        "mc_arc",
        "__ieee754_atan2",
        "cos",
        "plan_buffer_line",
        "sin",
        "__ieee754_hypot",
        "__ieee754_sqrt",
        "__ieee754_rem_pio2",
        "__kernel_sin",
        "__kernel_rem_pio2",
        "atan",
        "__kernel_cos"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_dadd": {
      "entrypoint": "0x080082d4",
      "current_name": "__aeabi_dadd",
      "code": "\nulonglong __aeabi_dadd(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  bool bVar14;\n  bool bVar15;\n  \n  uVar7 \u003d param_2 \u003c\u003c 1;\n  uVar9 \u003d param_4 \u003c\u003c 1;\n  bVar13 \u003d ((param_2 ^ param_4) \u0026 0x7fffffff) \u003d\u003d 0;\n  bVar14 \u003d bVar13 \u0026\u0026 param_1 \u003d\u003d param_3;\n  if (!bVar13 || param_1 !\u003d param_3) {\n    bVar14 \u003d (uVar7 | param_1) \u003d\u003d 0;\n  }\n  if (!bVar14) {\n    bVar14 \u003d (uVar9 | param_3) \u003d\u003d 0;\n  }\n  iVar6 \u003d (int)uVar7 \u003e\u003e 0x15;\n  if (!bVar14) {\n    bVar14 \u003d iVar6 \u003d\u003d -1;\n  }\n  iVar1 \u003d (int)uVar9 \u003e\u003e 0x15;\n  if (!bVar14) {\n    bVar14 \u003d iVar1 \u003d\u003d -1;\n  }\n  if (bVar14) {\n    if (iVar6 \u003d\u003d -1 || iVar1 \u003d\u003d -1) {\n      uVar9 \u003d param_4;\n      uVar7 \u003d param_3;\n      if (iVar6 \u003d\u003d -1) {\n        uVar9 \u003d param_2;\n        uVar7 \u003d param_1;\n      }\n      if (iVar6 !\u003d -1 || iVar1 !\u003d -1) {\n        param_3 \u003d uVar7;\n        param_4 \u003d uVar9;\n      }\n      bVar14 \u003d (uVar7 | uVar9 \u003c\u003c 0xc) \u003d\u003d 0;\n      if (bVar14) {\n        bVar14 \u003d (param_3 | param_4 \u003c\u003c 0xc) \u003d\u003d 0;\n      }\n      if (bVar14) {\n        bVar14 \u003d uVar9 \u003d\u003d param_4;\n      }\n      if (!bVar14) {\n        uVar9 \u003d uVar9 | 0x80000;\n      }\n      return CONCAT44(uVar9,uVar7);\n    }\n    if (((param_2 ^ param_4) \u0026 0x7fffffff) !\u003d 0 || param_1 !\u003d param_3) {\n      if ((uVar7 | param_1) \u003d\u003d 0) {\n        param_1 \u003d param_3;\n        param_2 \u003d param_4;\n      }\n      return CONCAT44(param_2,param_1);\n    }\n    if (param_2 !\u003d param_4) {\n      return 0;\n    }\n    if (uVar7 \u003e\u003e 0x15 \u003d\u003d 0) {\n      bVar14 \u003d (param_1 \u0026 0x80000000) !\u003d 0;\n      uVar9 \u003d param_2 * 2 + (uint)bVar14;\n      if (CARRY4(param_2,param_2) || CARRY4(param_2 * 2,(uint)bVar14)) {\n        uVar9 \u003d uVar9 | 0x80000000;\n      }\n      return CONCAT44(uVar9,param_1 \u003c\u003c 1);\n    }\n    if (uVar7 \u003c 0xffc00000) {\n      return CONCAT44(param_2 + 0x100000,param_1);\n    }\n    param_2 \u003d param_2 \u0026 0x80000000;\nLAB_08008514:\n    return (ulonglong)(param_2 | 0x7ff00000) \u003c\u003c 0x20;\n  }\n  uVar7 \u003d uVar7 \u003e\u003e 0x15;\n  uVar9 \u003d uVar9 \u003e\u003e 0x15;\n  uVar10 \u003d uVar9 - uVar7;\n  bVar14 \u003d uVar10 !\u003d 0;\n  if (uVar9 \u003c uVar7) {\n    uVar10 \u003d -uVar10;\n  }\n  uVar8 \u003d param_1;\n  uVar5 \u003d param_2;\n  if (bVar14 \u0026\u0026 uVar7 \u003c\u003d uVar9) {\n    uVar7 \u003d uVar7 + uVar10;\n    uVar8 \u003d param_3;\n    uVar5 \u003d param_4;\n    param_3 \u003d param_1;\n    param_4 \u003d param_2;\n  }\n  if (0x36 \u003c uVar10) {\n    return CONCAT44(uVar5,uVar8);\n  }\n  uVar9 \u003d uVar5 \u0026 0xfffff | 0x100000;\n  if ((uVar5 \u0026 0x80000000) !\u003d 0) {\n    bVar14 \u003d uVar8 !\u003d 0;\n    uVar8 \u003d -uVar8;\n    uVar9 \u003d -uVar9 - (uint)bVar14;\n  }\n  uVar5 \u003d param_4 \u0026 0xfffff | 0x100000;\n  if ((param_4 \u0026 0x80000000) !\u003d 0) {\n    bVar14 \u003d param_3 !\u003d 0;\n    param_3 \u003d -param_3;\n    uVar5 \u003d -uVar5 - (uint)bVar14;\n  }\n  if (uVar7 \u003d\u003d uVar10) {\n    uVar5 \u003d uVar5 ^ 0x100000;\n    if (uVar7 \u003d\u003d 0) {\n      uVar9 \u003d uVar9 ^ 0x100000;\n      uVar7 \u003d 1;\n    }\n    else {\n      uVar10 \u003d uVar10 - 1;\n    }\n  }\n  uVar12 \u003d -uVar10 + 0x20;\n  if ((int)uVar10 \u003c 0x21) {\n    uVar11 \u003d param_3 \u003c\u003c (uVar12 \u0026 0xff);\n    param_3 \u003d param_3 \u003e\u003e (uVar10 \u0026 0xff);\n    uVar3 \u003d uVar8 + param_3;\n    uVar4 \u003d uVar5 \u003c\u003c (uVar12 \u0026 0xff);\n    uVar12 \u003d uVar3 + uVar4;\n    uVar9 \u003d uVar9 + CARRY4(uVar8,param_3) + ((int)uVar5 \u003e\u003e (uVar10 \u0026 0xff)) +\n            (uint)CARRY4(uVar3,uVar4);\n  }\n  else {\n    uVar11 \u003d uVar5 \u003c\u003c (-uVar10 + 0x40 \u0026 0xff);\n    if (param_3 !\u003d 0) {\n      uVar11 \u003d uVar11 | 2;\n    }\n    uVar5 \u003d (int)uVar5 \u003e\u003e (uVar10 - 0x20 \u0026 0xff);\n    uVar12 \u003d uVar8 + uVar5;\n    uVar9 \u003d uVar9 + ((int)uVar5 \u003e\u003e 0x1f) + (uint)CARRY4(uVar8,uVar5);\n  }\n  param_2 \u003d uVar9 \u0026 0x80000000;\n  uVar10 \u003d uVar9;\n  if ((int)uVar9 \u003c 0) {\n    bVar14 \u003d uVar11 \u003d\u003d 0;\n    uVar11 \u003d -uVar11;\n    uVar10 \u003d -uVar12;\n    uVar12 \u003d -(uint)!bVar14 - uVar12;\n    uVar10 \u003d -(uint)(bVar14 \u003c\u003d uVar10) - uVar9;\n  }\n  if (0xfffff \u003c uVar10) {\n    uVar8 \u003d uVar7 - 1;\n    if (0x1fffff \u003c uVar10) {\n      uVar9 \u003d uVar10 \u0026 1;\n      uVar10 \u003d uVar10 \u003e\u003e 1;\n      bVar2 \u003d (byte)uVar12;\n      uVar12 \u003d (uint)(uVar9 !\u003d 0) \u003c\u003c 0x1f | uVar12 \u003e\u003e 1;\n      uVar11 \u003d (uint)(bVar2 \u0026 1) \u003c\u003c 0x1f | uVar11 \u003e\u003e 1;\n      uVar8 \u003d uVar7;\n      if (0xffbfffff \u003c uVar7 * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    bVar14 \u003d 0x7fffffff \u003c uVar11;\n    if (uVar11 \u003d\u003d 0x80000000) {\n      bVar14 \u003d (uVar12 \u0026 1) !\u003d 0;\n    }\n    return CONCAT44(uVar10 + uVar8 * 0x100000 + (uint)CARRY4(uVar12,(uint)bVar14) | param_2,\n                    uVar12 + bVar14);\n  }\n  bVar13 \u003d (uVar11 \u0026 0x80000000) !\u003d 0;\n  uVar11 \u003d uVar11 \u003c\u003c 1;\n  uVar8 \u003d uVar12 * 2;\n  bVar14 \u003d CARRY4(uVar12,uVar12);\n  uVar12 \u003d uVar12 * 2 + (uint)bVar13;\n  uVar10 \u003d uVar10 * 2 + (uint)(bVar14 || CARRY4(uVar8,(uint)bVar13));\n  uVar8 \u003d uVar7 - 2;\n  if (uVar7 - 1 !\u003d 0 \u0026\u0026 0xfffff \u003c uVar10) goto LAB_080083e0;\n  uVar5 \u003d uVar12;\n  uVar7 \u003d uVar10;\n  if (uVar10 \u003d\u003d 0) {\n    uVar5 \u003d 0;\n    uVar7 \u003d uVar12;\n  }\n  iVar6 \u003d LZCOUNT(uVar7);\n  if (uVar10 \u003d\u003d 0) {\n    iVar6 \u003d iVar6 + 0x20;\n  }\n  uVar12 \u003d iVar6 - 0xb;\n  bVar15 \u003d SBORROW4(uVar12,0x20);\n  uVar10 \u003d iVar6 - 0x2b;\n  bVar14 \u003d (int)uVar10 \u003c 0;\n  bVar13 \u003d uVar10 \u003d\u003d 0;\n  if ((int)uVar12 \u003c 0x20) {\n    bVar15 \u003d SCARRY4(uVar10,0xc);\n    iVar6 \u003d iVar6 + -0x1f;\n    bVar14 \u003d iVar6 \u003c 0;\n    bVar13 \u003d iVar6 \u003d\u003d 0;\n    uVar10 \u003d uVar12;\n    if (!bVar13 \u0026\u0026 bVar14 \u003d\u003d bVar15) {\n      uVar5 \u003d uVar7 \u003c\u003c (uVar12 \u0026 0xff);\n      uVar7 \u003d uVar7 \u003e\u003e (0xcU - iVar6 \u0026 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bVar13 || bVar14 !\u003d bVar15) {\n    uVar11 \u003d 0x20 - uVar10;\n  }\n  uVar7 \u003d uVar7 \u003c\u003c (uVar10 \u0026 0xff);\n  if (bVar13 || bVar14 !\u003d bVar15) {\n    uVar7 \u003d uVar7 | uVar5 \u003e\u003e (uVar11 \u0026 0xff);\n  }\n  if (bVar13 || bVar14 !\u003d bVar15) {\n    uVar5 \u003d uVar5 \u003c\u003c (uVar10 \u0026 0xff);\n  }\nLAB_08008458:\n  if ((int)uVar12 \u003c\u003d (int)uVar8) {\n    return CONCAT44(uVar7 + (uVar8 - uVar12) * 0x100000 | param_2,uVar5);\n  }\n  uVar10 \u003d ~(uVar8 - uVar12);\n  if ((int)uVar10 \u003c 0x1f) {\n    iVar6 \u003d uVar10 - 0x13;\n    if (iVar6 !\u003d 0 \u0026\u0026 iVar6 \u003c 0 \u003d\u003d SCARRY4(uVar10 - 0x1f,0xc)) {\n      return CONCAT44(uVar9,uVar5 \u003e\u003e (0x20 - (0xcU - iVar6) \u0026 0xff) | uVar7 \u003c\u003c (0xcU - iVar6 \u0026 0xff)\n                     ) \u0026 0x80000000ffffffff;\n    }\n    uVar10 \u003d uVar10 + 1;\n    return CONCAT44(param_2 | uVar7 \u003e\u003e (uVar10 \u0026 0xff),\n                    uVar5 \u003e\u003e (uVar10 \u0026 0xff) | uVar7 \u003c\u003c (0x20 - uVar10 \u0026 0xff));\n  }\n  return CONCAT44(uVar9,uVar7 \u003e\u003e (uVar10 - 0x1f \u0026 0xff)) \u0026 0x80000000ffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_drsub",
        "round",
        "floor",
        "scalbn",
        "ceil",
        "mc_arc",
        "__ieee754_atan2",
        "trunc",
        "__ieee754_hypot",
        "__ieee754_sqrt",
        "__ieee754_rem_pio2",
        "__kernel_sin",
        "__kernel_rem_pio2",
        "atan",
        "__kernel_cos"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__floatunsidf": {
      "entrypoint": "0x0800854c",
      "current_name": "__floatunsidf",
      "code": "\nulonglong __floatunsidf(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  uint in_r12;\n  bool bVar5;\n  bool bVar6;\n  bool bVar7;\n  \n  if (param_1 \u003d\u003d 0) {\n    return 0;\n  }\n  uVar1 \u003d 0;\n  iVar3 \u003d LZCOUNT(param_1);\n  uVar4 \u003d iVar3 + 0x15;\n  bVar7 \u003d SBORROW4(uVar4,0x20);\n  uVar2 \u003d iVar3 - 0xb;\n  bVar5 \u003d (int)uVar2 \u003c 0;\n  bVar6 \u003d uVar2 \u003d\u003d 0;\n  if (uVar4 \u003c 0x20) {\n    bVar7 \u003d SCARRY4(uVar2,0xc);\n    bVar5 \u003d false;\n    bVar6 \u003d iVar3 + 1 \u003d\u003d 0;\n    uVar2 \u003d uVar4;\n    if (!bVar6 \u0026\u0026 bVar7 \u003d\u003d false) {\n      uVar1 \u003d param_1 \u003c\u003c uVar4;\n      param_1 \u003d param_1 \u003e\u003e (0xcU - (iVar3 + 1) \u0026 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bVar6 || bVar5 !\u003d bVar7) {\n    in_r12 \u003d 0x20 - uVar2;\n  }\n  param_1 \u003d param_1 \u003c\u003c (uVar2 \u0026 0xff);\n  if (bVar6 || bVar5 !\u003d bVar7) {\n    param_1 \u003d param_1 | 0U \u003e\u003e (in_r12 \u0026 0xff);\n  }\n  if (bVar6 || bVar5 !\u003d bVar7) {\n    uVar1 \u003d 0 \u003c\u003c (uVar2 \u0026 0xff);\n  }\nLAB_08008458:\n  if (uVar4 \u003c 0x433) {\n    return CONCAT44(param_1 + (0x432 - uVar4) * 0x100000,uVar1);\n  }\n  uVar2 \u003d ~(0x432 - uVar4);\n  if (0x1e \u003c (int)uVar2) {\n    return (ulonglong)(param_1 \u003e\u003e (uVar2 - 0x1f \u0026 0xff));\n  }\n  iVar3 \u003d uVar2 - 0x13;\n  if (iVar3 \u003d\u003d 0 || iVar3 \u003c 0 !\u003d SCARRY4(uVar2 - 0x1f,0xc)) {\n    uVar2 \u003d uVar2 + 1;\n    return CONCAT44(param_1 \u003e\u003e (uVar2 \u0026 0xff),\n                    uVar1 \u003e\u003e (uVar2 \u0026 0xff) | param_1 \u003c\u003c (0x20 - uVar2 \u0026 0xff));\n  }\n  return (ulonglong)(uVar1 \u003e\u003e (0x20 - (0xcU - iVar3) \u0026 0xff) | param_1 \u003c\u003c (0xcU - iVar3 \u0026 0xff));\n}\n\n",
      "renaming": {},
      "calling": [
        "homing_cycle"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_i2d": {
      "entrypoint": "0x0800856c",
      "current_name": "__aeabi_i2d",
      "code": "\nulonglong __aeabi_i2d(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  uint in_r12;\n  bool bVar7;\n  bool bVar8;\n  bool bVar9;\n  \n  if (param_1 \u003d\u003d 0) {\n    return 0;\n  }\n  uVar6 \u003d param_1 \u0026 0x80000000;\n  uVar2 \u003d param_1;\n  if ((int)uVar6 \u003c 0) {\n    uVar2 \u003d -param_1;\n  }\n  uVar1 \u003d 0;\n  iVar4 \u003d LZCOUNT(uVar2);\n  uVar5 \u003d iVar4 + 0x15;\n  bVar9 \u003d SBORROW4(uVar5,0x20);\n  uVar3 \u003d iVar4 - 0xb;\n  bVar7 \u003d (int)uVar3 \u003c 0;\n  bVar8 \u003d uVar3 \u003d\u003d 0;\n  if (uVar5 \u003c 0x20) {\n    bVar9 \u003d SCARRY4(uVar3,0xc);\n    bVar7 \u003d false;\n    bVar8 \u003d iVar4 + 1 \u003d\u003d 0;\n    uVar3 \u003d uVar5;\n    if (!bVar8 \u0026\u0026 bVar9 \u003d\u003d false) {\n      uVar1 \u003d uVar2 \u003c\u003c uVar5;\n      uVar2 \u003d uVar2 \u003e\u003e (0xcU - (iVar4 + 1) \u0026 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bVar8 || bVar7 !\u003d bVar9) {\n    in_r12 \u003d 0x20 - uVar3;\n  }\n  uVar2 \u003d uVar2 \u003c\u003c (uVar3 \u0026 0xff);\n  if (bVar8 || bVar7 !\u003d bVar9) {\n    uVar2 \u003d uVar2 | 0U \u003e\u003e (in_r12 \u0026 0xff);\n  }\n  if (bVar8 || bVar7 !\u003d bVar9) {\n    uVar1 \u003d 0 \u003c\u003c (uVar3 \u0026 0xff);\n  }\nLAB_08008458:\n  if (uVar5 \u003c 0x433) {\n    return CONCAT44(uVar2 + (0x432 - uVar5) * 0x100000 | uVar6,uVar1);\n  }\n  uVar3 \u003d ~(0x432 - uVar5);\n  if (0x1e \u003c (int)uVar3) {\n    return CONCAT44(param_1,uVar2 \u003e\u003e (uVar3 - 0x1f \u0026 0xff)) \u0026 0x80000000ffffffff;\n  }\n  iVar4 \u003d uVar3 - 0x13;\n  if (iVar4 \u003d\u003d 0 || iVar4 \u003c 0 !\u003d SCARRY4(uVar3 - 0x1f,0xc)) {\n    uVar3 \u003d uVar3 + 1;\n    return CONCAT44(uVar6 | uVar2 \u003e\u003e (uVar3 \u0026 0xff),\n                    uVar1 \u003e\u003e (uVar3 \u0026 0xff) | uVar2 \u003c\u003c (0x20 - uVar3 \u0026 0xff));\n  }\n  return CONCAT44(param_1,uVar1 \u003e\u003e (0x20 - (0xcU - iVar4) \u0026 0xff) | uVar2 \u003c\u003c (0xcU - iVar4 \u0026 0xff))\n         \u0026 0x80000000ffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "calculate_trapezoid_for_block",
        "__ieee754_rem_pio2",
        "__kernel_rem_pio2"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_f2d": {
      "entrypoint": "0x08008590",
      "current_name": "__aeabi_f2d",
      "code": "\nulonglong __aeabi_f2d(uint param_1,undefined4 param_2,undefined4 param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  uint uVar7;\n  uint in_r12;\n  bool bVar8;\n  bool bVar9;\n  bool bVar10;\n  \n  uVar5 \u003d param_1 \u003c\u003c 1;\n  bVar9 \u003d uVar5 \u003d\u003d 0;\n  uVar1 \u003d (uint)((param_1 \u0026 0x80000000) !\u003d 0) \u003c\u003c 0x1f;\n  uVar4 \u003d (uint)((int)uVar5 \u003e\u003e 3) \u003e\u003e 1;\n  uVar3 \u003d uVar1 | uVar4;\n  param_1 \u003d param_1 \u003c\u003c 0x1d;\n  if (!bVar9) {\n    param_4 \u003d uVar5 \u0026 0xff000000;\n    bVar9 \u003d param_4 \u003d\u003d 0;\n  }\n  if (!bVar9) {\n    bVar9 \u003d param_4 \u003d\u003d 0xff000000;\n  }\n  if (!bVar9) {\n    return CONCAT44(uVar3,param_1) ^ 0x3800000000000000;\n  }\n  if ((uVar5 \u0026 0xffffff) \u003d\u003d 0) {\n    return CONCAT44(uVar3,param_1);\n  }\n  if (param_4 \u003d\u003d 0xff000000) {\n    return CONCAT44(uVar3,param_1) | 0x8000000000000;\n  }\n  uVar2 \u003d param_1;\n  uVar5 \u003d uVar4;\n  if (uVar4 \u003d\u003d 0) {\n    uVar2 \u003d 0;\n    uVar5 \u003d param_1;\n  }\n  iVar6 \u003d LZCOUNT(uVar5);\n  if (uVar4 \u003d\u003d 0) {\n    iVar6 \u003d iVar6 + 0x20;\n  }\n  uVar7 \u003d iVar6 - 0xb;\n  bVar10 \u003d SBORROW4(uVar7,0x20);\n  uVar4 \u003d iVar6 - 0x2b;\n  bVar9 \u003d (int)uVar4 \u003c 0;\n  bVar8 \u003d uVar4 \u003d\u003d 0;\n  if ((int)uVar7 \u003c 0x20) {\n    bVar10 \u003d SCARRY4(uVar4,0xc);\n    iVar6 \u003d iVar6 + -0x1f;\n    bVar9 \u003d iVar6 \u003c 0;\n    bVar8 \u003d iVar6 \u003d\u003d 0;\n    uVar4 \u003d uVar7;\n    if (!bVar8 \u0026\u0026 bVar9 \u003d\u003d bVar10) {\n      uVar2 \u003d uVar5 \u003c\u003c (uVar7 \u0026 0xff);\n      uVar5 \u003d uVar5 \u003e\u003e (0xcU - iVar6 \u0026 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bVar8 || bVar9 !\u003d bVar10) {\n    in_r12 \u003d 0x20 - uVar4;\n  }\n  uVar5 \u003d uVar5 \u003c\u003c (uVar4 \u0026 0xff);\n  if (bVar8 || bVar9 !\u003d bVar10) {\n    uVar5 \u003d uVar5 | uVar2 \u003e\u003e (in_r12 \u0026 0xff);\n  }\n  if (bVar8 || bVar9 !\u003d bVar10) {\n    uVar2 \u003d uVar2 \u003c\u003c (uVar4 \u0026 0xff);\n  }\nLAB_08008458:\n  if ((int)uVar7 \u003c 0x381) {\n    return CONCAT44(uVar5 + (0x380 - uVar7) * 0x100000 | uVar1,uVar2);\n  }\n  uVar4 \u003d ~(0x380 - uVar7);\n  if (0x1e \u003c (int)uVar4) {\n    return CONCAT44(uVar3,uVar5 \u003e\u003e (uVar4 - 0x1f \u0026 0xff)) \u0026 0x80000000ffffffff;\n  }\n  iVar6 \u003d uVar4 - 0x13;\n  if (iVar6 \u003d\u003d 0 || iVar6 \u003c 0 !\u003d SCARRY4(uVar4 - 0x1f,0xc)) {\n    uVar4 \u003d uVar4 + 1;\n    return CONCAT44(uVar1 | uVar5 \u003e\u003e (uVar4 \u0026 0xff),\n                    uVar2 \u003e\u003e (uVar4 \u0026 0xff) | uVar5 \u003c\u003c (0x20 - uVar4 \u0026 0xff));\n  }\n  return CONCAT44(uVar3,uVar2 \u003e\u003e (0x20 - (0xcU - iVar6) \u0026 0xff) | uVar5 \u003c\u003c (0xcU - iVar6 \u0026 0xff)) \u0026\n         0x80000000ffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "report_realtime_status",
        "protocol_execute_line",
        "calculate_trapezoid_for_block",
        "report_gcode_parameters",
        "to_millimeters",
        "homing_cycle",
        "mc_dwell",
        "read_float",
        "mc_arc",
        "report_gcode_modes",
        "gc_execute_line",
        "plan_buffer_line",
        "settings_store_global_setting",
        "max_allowable_speed"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__floatundidf": {
      "entrypoint": "0x080085d4",
      "current_name": "__floatundidf",
      "code": "\nulonglong __floatundidf(uint param_1,uint param_2)\n\n{\n  byte bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  uint uVar8;\n  bool bVar9;\n  bool bVar10;\n  bool bVar11;\n  \n  if ((param_1 | param_2) \u003d\u003d 0) {\n    return CONCAT44(param_2,param_1);\n  }\n  iVar7 \u003d 0x432;\n  uVar8 \u003d param_2 \u003e\u003e 0x16;\n  if (uVar8 !\u003d 0) {\n    iVar7 \u003d 3;\n    if (param_2 \u003e\u003e 0x19 !\u003d 0) {\n      iVar7 \u003d 6;\n    }\n    if (param_2 \u003e\u003e 0x1c !\u003d 0) {\n      iVar7 \u003d iVar7 + 3;\n    }\n    uVar4 \u003d iVar7 - ((int)param_2 \u003e\u003e 0x1f);\n    uVar8 \u003d param_1 \u003c\u003c (0x20 - uVar4 \u0026 0xff);\n    param_1 \u003d param_1 \u003e\u003e (uVar4 \u0026 0xff) | param_2 \u003c\u003c (0x20 - uVar4 \u0026 0xff);\n    param_2 \u003d param_2 \u003e\u003e (uVar4 \u0026 0xff);\n    iVar7 \u003d uVar4 + 0x432;\n  }\n  if (0xfffff \u003c param_2) {\n    if (0x1fffff \u003c param_2) {\n      uVar4 \u003d param_2 \u0026 1;\n      param_2 \u003d param_2 \u003e\u003e 1;\n      bVar1 \u003d (byte)param_1;\n      param_1 \u003d (uint)(uVar4 !\u003d 0) \u003c\u003c 0x1f | param_1 \u003e\u003e 1;\n      uVar8 \u003d (uint)(bVar1 \u0026 1) \u003c\u003c 0x1f | uVar8 \u003e\u003e 1;\n      iVar7 \u003d iVar7 + 1;\n      if (0xffbfffff \u003c (uint)(iVar7 * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_080083e0:\n    bVar10 \u003d 0x7fffffff \u003c uVar8;\n    if (uVar8 \u003d\u003d 0x80000000) {\n      bVar10 \u003d (param_1 \u0026 1) !\u003d 0;\n    }\n    return CONCAT44(param_2 + iVar7 * 0x100000 + (uint)CARRY4(param_1,(uint)bVar10),param_1 + bVar10\n                   );\n  }\n  bVar9 \u003d (uVar8 \u0026 0x80000000) !\u003d 0;\n  uVar8 \u003d uVar8 \u003c\u003c 1;\n  uVar4 \u003d param_1 * 2;\n  bVar10 \u003d CARRY4(param_1,param_1);\n  param_1 \u003d param_1 * 2 + (uint)bVar9;\n  param_2 \u003d param_2 * 2 + (uint)(bVar10 || CARRY4(uVar4,(uint)bVar9));\n  bVar10 \u003d iVar7 !\u003d 0;\n  iVar7 \u003d iVar7 + -1;\n  if (bVar10 \u0026\u0026 0xfffff \u003c param_2) goto LAB_080083e0;\n  uVar2 \u003d param_1;\n  uVar4 \u003d param_2;\n  if (param_2 \u003d\u003d 0) {\n    uVar2 \u003d 0;\n    uVar4 \u003d param_1;\n  }\n  iVar5 \u003d LZCOUNT(uVar4);\n  if (param_2 \u003d\u003d 0) {\n    iVar5 \u003d iVar5 + 0x20;\n  }\n  uVar6 \u003d iVar5 - 0xb;\n  bVar11 \u003d SBORROW4(uVar6,0x20);\n  uVar3 \u003d iVar5 - 0x2b;\n  bVar10 \u003d (int)uVar3 \u003c 0;\n  bVar9 \u003d uVar3 \u003d\u003d 0;\n  if ((int)uVar6 \u003c 0x20) {\n    bVar11 \u003d SCARRY4(uVar3,0xc);\n    iVar5 \u003d iVar5 + -0x1f;\n    bVar10 \u003d iVar5 \u003c 0;\n    bVar9 \u003d iVar5 \u003d\u003d 0;\n    uVar3 \u003d uVar6;\n    if (!bVar9 \u0026\u0026 bVar10 \u003d\u003d bVar11) {\n      uVar2 \u003d uVar4 \u003c\u003c (uVar6 \u0026 0xff);\n      uVar4 \u003d uVar4 \u003e\u003e (0xcU - iVar5 \u0026 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bVar9 || bVar10 !\u003d bVar11) {\n    uVar8 \u003d 0x20 - uVar3;\n  }\n  uVar4 \u003d uVar4 \u003c\u003c (uVar3 \u0026 0xff);\n  if (bVar9 || bVar10 !\u003d bVar11) {\n    uVar4 \u003d uVar4 | uVar2 \u003e\u003e (uVar8 \u0026 0xff);\n  }\n  if (bVar9 || bVar10 !\u003d bVar11) {\n    uVar2 \u003d uVar2 \u003c\u003c (uVar3 \u0026 0xff);\n  }\nLAB_08008458:\n  if ((int)uVar6 \u003c\u003d iVar7) {\n    return CONCAT44(uVar4 + (iVar7 - uVar6) * 0x100000,uVar2);\n  }\n  uVar8 \u003d ~(iVar7 - uVar6);\n  if ((int)uVar8 \u003c 0x1f) {\n    iVar7 \u003d uVar8 - 0x13;\n    if (iVar7 !\u003d 0 \u0026\u0026 iVar7 \u003c 0 \u003d\u003d SCARRY4(uVar8 - 0x1f,0xc)) {\n      return (ulonglong)(uVar2 \u003e\u003e (0x20 - (0xcU - iVar7) \u0026 0xff) | uVar4 \u003c\u003c (0xcU - iVar7 \u0026 0xff));\n    }\n    uVar8 \u003d uVar8 + 1;\n    return CONCAT44(uVar4 \u003e\u003e (uVar8 \u0026 0xff),uVar2 \u003e\u003e (uVar8 \u0026 0xff) | uVar4 \u003c\u003c (0x20 - uVar8 \u0026 0xff)\n                   );\n  }\n  return (ulonglong)(uVar4 \u003e\u003e (uVar8 - 0x1f \u0026 0xff));\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_l2d": {
      "entrypoint": "0x080085e4",
      "current_name": "__aeabi_l2d",
      "code": "\nulonglong __aeabi_l2d(uint param_1,uint param_2)\n\n{\n  byte bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  uint uVar8;\n  uint uVar9;\n  bool bVar10;\n  bool bVar11;\n  bool bVar12;\n  \n  if ((param_1 | param_2) \u003d\u003d 0) {\n    return CONCAT44(param_2,param_1);\n  }\n  uVar8 \u003d param_2 \u0026 0x80000000;\n  uVar3 \u003d param_2;\n  if ((int)uVar8 \u003c 0) {\n    bVar11 \u003d param_1 !\u003d 0;\n    param_1 \u003d -param_1;\n    uVar3 \u003d -param_2 - (uint)bVar11;\n  }\n  iVar7 \u003d 0x432;\n  uVar9 \u003d uVar3 \u003e\u003e 0x16;\n  if (uVar9 !\u003d 0) {\n    iVar7 \u003d 3;\n    if (uVar3 \u003e\u003e 0x19 !\u003d 0) {\n      iVar7 \u003d 6;\n    }\n    if (uVar3 \u003e\u003e 0x1c !\u003d 0) {\n      iVar7 \u003d iVar7 + 3;\n    }\n    uVar4 \u003d iVar7 - ((int)uVar3 \u003e\u003e 0x1f);\n    uVar9 \u003d param_1 \u003c\u003c (0x20 - uVar4 \u0026 0xff);\n    param_1 \u003d param_1 \u003e\u003e (uVar4 \u0026 0xff) | uVar3 \u003c\u003c (0x20 - uVar4 \u0026 0xff);\n    uVar3 \u003d uVar3 \u003e\u003e (uVar4 \u0026 0xff);\n    iVar7 \u003d uVar4 + 0x432;\n  }\n  if (0xfffff \u003c uVar3) {\n    if (0x1fffff \u003c uVar3) {\n      uVar4 \u003d uVar3 \u0026 1;\n      uVar3 \u003d uVar3 \u003e\u003e 1;\n      bVar1 \u003d (byte)param_1;\n      param_1 \u003d (uint)(uVar4 !\u003d 0) \u003c\u003c 0x1f | param_1 \u003e\u003e 1;\n      uVar9 \u003d (uint)(bVar1 \u0026 1) \u003c\u003c 0x1f | uVar9 \u003e\u003e 1;\n      iVar7 \u003d iVar7 + 1;\n      if (0xffbfffff \u003c (uint)(iVar7 * 0x200000)) {\n        return (ulonglong)(uVar8 | 0x7ff00000) \u003c\u003c 0x20;\n      }\n    }\nLAB_080083e0:\n    bVar11 \u003d 0x7fffffff \u003c uVar9;\n    if (uVar9 \u003d\u003d 0x80000000) {\n      bVar11 \u003d (param_1 \u0026 1) !\u003d 0;\n    }\n    return CONCAT44(uVar3 + iVar7 * 0x100000 + (uint)CARRY4(param_1,(uint)bVar11) | uVar8,\n                    param_1 + bVar11);\n  }\n  bVar10 \u003d (uVar9 \u0026 0x80000000) !\u003d 0;\n  uVar9 \u003d uVar9 \u003c\u003c 1;\n  uVar4 \u003d param_1 * 2;\n  bVar11 \u003d CARRY4(param_1,param_1);\n  param_1 \u003d param_1 * 2 + (uint)bVar10;\n  uVar3 \u003d uVar3 * 2 + (uint)(bVar11 || CARRY4(uVar4,(uint)bVar10));\n  bVar11 \u003d iVar7 !\u003d 0;\n  iVar7 \u003d iVar7 + -1;\n  if (bVar11 \u0026\u0026 0xfffff \u003c uVar3) goto LAB_080083e0;\n  uVar2 \u003d param_1;\n  uVar4 \u003d uVar3;\n  if (uVar3 \u003d\u003d 0) {\n    uVar2 \u003d 0;\n    uVar4 \u003d param_1;\n  }\n  iVar5 \u003d LZCOUNT(uVar4);\n  if (uVar3 \u003d\u003d 0) {\n    iVar5 \u003d iVar5 + 0x20;\n  }\n  uVar6 \u003d iVar5 - 0xb;\n  bVar12 \u003d SBORROW4(uVar6,0x20);\n  uVar3 \u003d iVar5 - 0x2b;\n  bVar11 \u003d (int)uVar3 \u003c 0;\n  bVar10 \u003d uVar3 \u003d\u003d 0;\n  if ((int)uVar6 \u003c 0x20) {\n    bVar12 \u003d SCARRY4(uVar3,0xc);\n    iVar5 \u003d iVar5 + -0x1f;\n    bVar11 \u003d iVar5 \u003c 0;\n    bVar10 \u003d iVar5 \u003d\u003d 0;\n    uVar3 \u003d uVar6;\n    if (!bVar10 \u0026\u0026 bVar11 \u003d\u003d bVar12) {\n      uVar2 \u003d uVar4 \u003c\u003c (uVar6 \u0026 0xff);\n      uVar4 \u003d uVar4 \u003e\u003e (0xcU - iVar5 \u0026 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bVar10 || bVar11 !\u003d bVar12) {\n    uVar9 \u003d 0x20 - uVar3;\n  }\n  uVar4 \u003d uVar4 \u003c\u003c (uVar3 \u0026 0xff);\n  if (bVar10 || bVar11 !\u003d bVar12) {\n    uVar4 \u003d uVar4 | uVar2 \u003e\u003e (uVar9 \u0026 0xff);\n  }\n  if (bVar10 || bVar11 !\u003d bVar12) {\n    uVar2 \u003d uVar2 \u003c\u003c (uVar3 \u0026 0xff);\n  }\nLAB_08008458:\n  if ((int)uVar6 \u003c\u003d iVar7) {\n    return CONCAT44(uVar4 + (iVar7 - uVar6) * 0x100000 | uVar8,uVar2);\n  }\n  uVar3 \u003d ~(iVar7 - uVar6);\n  if ((int)uVar3 \u003c 0x1f) {\n    iVar7 \u003d uVar3 - 0x13;\n    if (iVar7 !\u003d 0 \u0026\u0026 iVar7 \u003c 0 \u003d\u003d SCARRY4(uVar3 - 0x1f,0xc)) {\n      return CONCAT44(param_2,uVar2 \u003e\u003e (0x20 - (0xcU - iVar7) \u0026 0xff) |\n                              uVar4 \u003c\u003c (0xcU - iVar7 \u0026 0xff)) \u0026 0x80000000ffffffff;\n    }\n    uVar3 \u003d uVar3 + 1;\n    return CONCAT44(uVar8 | uVar4 \u003e\u003e (uVar3 \u0026 0xff),\n                    uVar2 \u003e\u003e (uVar3 \u0026 0xff) | uVar4 \u003c\u003c (0x20 - uVar3 \u0026 0xff));\n  }\n  return CONCAT44(param_2,uVar4 \u003e\u003e (uVar3 - 0x1f \u0026 0xff)) \u0026 0x80000000ffffffff;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__muldf3": {
      "entrypoint": "0x08008640",
      "current_name": "__muldf3",
      "code": "\nulonglong __muldf3(undefined4 param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  ulonglong uVar1;\n  longlong lVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint unaff_r5;\n  uint uVar7;\n  uint uVar8;\n  bool bVar9;\n  bool bVar10;\n  bool bVar11;\n  ulonglong uVar12;\n  \n  uVar12 \u003d CONCAT44(param_2,param_1);\n  uVar7 \u003d 0x7ff;\n  uVar4 \u003d param_2 \u003e\u003e 0x14 \u0026 0x7ff;\n  bVar9 \u003d uVar4 \u003d\u003d 0;\n  if (!bVar9) {\n    unaff_r5 \u003d param_4 \u003e\u003e 0x14 \u0026 0x7ff;\n    bVar9 \u003d unaff_r5 \u003d\u003d 0;\n  }\n  if (!bVar9) {\n    bVar9 \u003d uVar4 \u003d\u003d 0x7ff;\n  }\n  if (!bVar9) {\n    bVar9 \u003d unaff_r5 \u003d\u003d 0x7ff;\n  }\n  if (bVar9) {\n    uVar12 \u003d FUN_0800881c();\n  }\n  uVar3 \u003d (uint)(uVar12 \u003e\u003e 0x20);\n  iVar5 \u003d uVar4 + unaff_r5;\n  uVar4 \u003d uVar3 ^ param_4;\n  uVar3 \u003d uVar3 \u0026 ~(uVar7 \u003c\u003c 0x15);\n  param_4 \u003d param_4 \u0026 ~(uVar7 \u003c\u003c 0x15);\n  bVar9 \u003d ((uint)uVar12 | uVar3 \u003c\u003c 0xc) \u003d\u003d 0;\n  if (!bVar9) {\n    bVar9 \u003d (param_3 | param_4 \u003c\u003c 0xc) \u003d\u003d 0;\n  }\n  uVar3 \u003d uVar3 | 0x100000;\n  param_4 \u003d param_4 | 0x100000;\n  if (bVar9) {\n    param_3 \u003d (uint)uVar12 | param_3;\n    param_4 \u003d (uVar4 \u0026 0x80000000 | uVar3) ^ param_4;\n    uVar4 \u003d uVar7 \u003e\u003e 1;\n    bVar11 \u003d SBORROW4(iVar5,uVar4);\n    uVar6 \u003d iVar5 - uVar4;\n    bVar9 \u003d uVar6 \u003d\u003d 0;\n    uVar3 \u003d uVar6;\n    if (!bVar9 \u0026\u0026 (int)uVar4 \u003c\u003d iVar5) {\n      bVar11 \u003d SBORROW4(uVar7,uVar6);\n      uVar3 \u003d uVar7 - uVar6;\n      bVar9 \u003d uVar7 \u003d\u003d uVar6;\n    }\n    if (!bVar9 \u0026\u0026 (int)uVar3 \u003c 0 \u003d\u003d bVar11) {\n      param_4 \u003d param_4 | uVar6 * 0x100000;\n    }\n    if (!bVar9 \u0026\u0026 (int)uVar3 \u003c 0 \u003d\u003d bVar11) {\n      return CONCAT44(param_4,param_3);\n    }\n    param_4 \u003d param_4 | 0x100000;\n    uVar7 \u003d 0;\n    bVar11 \u003d SBORROW4(uVar6,1);\n    uVar6 \u003d uVar6 - 1;\n    bVar9 \u003d uVar6 \u003d\u003d 0;\n    uVar4 \u003d uVar6;\n  }\n  else {\n    uVar1 \u003d (uVar12 \u0026 0xffffffff) * (ulonglong)param_3;\n    uVar12 \u003d (uVar12 \u0026 0xffffffff) * (ulonglong)param_4 +\n             (ulonglong)uVar3 * (ulonglong)param_3 + (uVar1 \u003e\u003e 0x20);\n    uVar8 \u003d (uint)uVar12;\n    lVar2 \u003d (ulonglong)uVar3 * (ulonglong)param_4 + (uVar12 \u003e\u003e 0x20);\n    uVar7 \u003d (uint)lVar2;\n    uVar3 \u003d (uint)((ulonglong)lVar2 \u003e\u003e 0x20);\n    if ((int)uVar1 !\u003d 0) {\n      uVar8 \u003d uVar8 | 1;\n    }\n    uVar6 \u003d (iVar5 + -0x3ff) - (uint)(uVar3 \u003c 0x200);\n    if (uVar3 \u003c 0x200) {\n      bVar9 \u003d (uVar8 \u0026 0x80000000) !\u003d 0;\n      uVar8 \u003d uVar8 \u003c\u003c 1;\n      lVar2 \u003d CONCAT44(uVar3 * 2 + (uint)(CARRY4(uVar7,uVar7) || CARRY4(uVar7 * 2,(uint)bVar9)),\n                       uVar7 * 2 + (uint)bVar9);\n    }\n    param_4 \u003d uVar4 \u0026 0x80000000 | (int)((ulonglong)lVar2 \u003e\u003e 0x20) \u003c\u003c 0xb | (uint)lVar2 \u003e\u003e 0x15;\n    param_3 \u003d (uint)lVar2 \u003c\u003c 0xb | uVar8 \u003e\u003e 0x15;\n    uVar7 \u003d uVar8 * 0x800;\n    bVar10 \u003d 0xfc \u003c uVar6;\n    bVar11 \u003d SBORROW4(uVar6,0xfd);\n    uVar3 \u003d uVar6 - 0xfd;\n    bVar9 \u003d uVar3 \u003d\u003d 0;\n    uVar4 \u003d uVar3;\n    if (bVar10 \u0026\u0026 !bVar9) {\n      bVar10 \u003d 0x6ff \u003c uVar3;\n      bVar11 \u003d SBORROW4(uVar3,0x700);\n      uVar4 \u003d uVar6 - 0x7fd;\n      bVar9 \u003d uVar3 \u003d\u003d 0x700;\n    }\n    if (!bVar10 || bVar9) {\n      bVar9 \u003d 0x7fffffff \u003c uVar7;\n      if (uVar7 \u003d\u003d 0x80000000) {\n        bVar9 \u003d (uVar8 \u003e\u003e 0x15 \u0026 1) !\u003d 0;\n      }\n      return CONCAT44(param_4 + uVar6 * 0x100000 + (uint)CARRY4(param_3,(uint)bVar9),param_3 + bVar9\n                     );\n    }\n  }\n  if (!bVar9 \u0026\u0026 (int)uVar4 \u003c 0 \u003d\u003d bVar11) {\n    return (ulonglong)(param_4 \u0026 0x80000000 | 0x7ff00000) \u003c\u003c 0x20;\n  }\n  bVar10 \u003d SCARRY4(uVar6,0x36);\n  bVar9 \u003d (int)(uVar6 + 0x36) \u003c 0;\n  bVar11 \u003d uVar6 \u003d\u003d 0xffffffca;\n  if (bVar11 || bVar9 !\u003d bVar10) {\n    param_3 \u003d 0;\n  }\n  if (bVar11 || bVar9 !\u003d bVar10) {\n    param_4 \u003d param_4 \u0026 0x80000000;\n  }\n  if (bVar11 || bVar9 !\u003d bVar10) {\n    return CONCAT44(param_4,param_3);\n  }\n  uVar4 \u003d -uVar6;\n  uVar3 \u003d uVar4 - 0x20;\n  if (0x1f \u003c (int)uVar4) {\n    uVar6 \u003d param_3 \u003e\u003e (uVar3 \u0026 0xff) | param_4 \u003c\u003c (0x20 - uVar3 \u0026 0xff);\n    uVar4 \u003d (param_4 \u003e\u003e (uVar3 \u0026 0xff) \u0026 ~((param_4 \u0026 0x80000000) \u003e\u003e (uVar3 \u0026 0xff))) -\n            ((int)uVar6 \u003e\u003e 0x1f);\n    if ((uVar7 | param_3 \u003c\u003c (0x20 - uVar3 \u0026 0xff) | uVar6 \u003c\u003c 1) \u003d\u003d 0) {\n      uVar4 \u003d uVar4 \u0026 ~(uVar6 \u003e\u003e 0x1f);\n    }\n    return CONCAT44(param_4,uVar4) \u0026 0x80000000ffffffff;\n  }\n  iVar5 \u003d uVar4 - 0x14;\n  if (iVar5 \u003d\u003d 0 || iVar5 \u003c 0 !\u003d SCARRY4(uVar3,0xc)) {\n    uVar8 \u003d param_3 \u003c\u003c (uVar6 + 0x20 \u0026 0xff);\n    uVar3 \u003d param_3 \u003e\u003e (uVar4 \u0026 0xff) | param_4 \u003c\u003c (uVar6 + 0x20 \u0026 0xff);\n    uVar6 \u003d uVar3 + -((int)uVar8 \u003e\u003e 0x1f);\n    if ((uVar7 | uVar8 \u003c\u003c 1) \u003d\u003d 0) {\n      uVar6 \u003d uVar6 \u0026 ~(uVar8 \u003e\u003e 0x1f);\n    }\n    return CONCAT44((param_4 \u0026 0x80000000) +\n                    ((param_4 \u0026 0x7fffffff) \u003e\u003e (uVar4 \u0026 0xff)) +\n                    (uint)CARRY4(uVar3,-((int)uVar8 \u003e\u003e 0x1f)),uVar6);\n  }\n  uVar4 \u003d 0xc - iVar5;\n  uVar6 \u003d param_3 \u003c\u003c (uVar4 \u0026 0xff);\n  uVar4 \u003d param_3 \u003e\u003e (0x20 - uVar4 \u0026 0xff) | param_4 \u003c\u003c (uVar4 \u0026 0xff);\n  uVar3 \u003d uVar4 + -((int)uVar6 \u003e\u003e 0x1f);\n  if ((uVar7 | uVar6 \u003c\u003c 1) \u003d\u003d 0) {\n    uVar3 \u003d uVar3 \u0026 ~(uVar6 \u003e\u003e 0x1f);\n  }\n  return CONCAT44((param_4 \u0026 0x80000000) + (uint)CARRY4(uVar4,-((int)uVar6 \u003e\u003e 0x1f)),uVar3);\n}\n\n",
      "renaming": {},
      "calling": [
        "report_realtime_status",
        "calculate_trapezoid_for_block",
        "report_gcode_parameters",
        "to_millimeters",
        "homing_cycle",
        "scalbn",
        "read_float",
        "mc_arc",
        "report_gcode_modes",
        "plan_buffer_line",
        "__ieee754_hypot",
        "__ieee754_sqrt",
        "__ieee754_rem_pio2",
        "__kernel_sin",
        "__kernel_rem_pio2",
        "atan",
        "__kernel_cos"
      ],
      "called": [
        "FUN_0800881c"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800881c": {
      "entrypoint": "0x0800881c",
      "current_name": "FUN_0800881c",
      "code": "\nulonglong FUN_0800881c(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  uint in_r12;\n  bool bVar4;\n  \n  uVar2 \u003d in_r12 \u0026 param_4 \u003e\u003e 0x14;\n  if (unaff_r4 !\u003d in_r12 \u0026\u0026 uVar2 !\u003d in_r12) {\n    bVar4 \u003d (param_1 | param_2 \u003c\u003c 1) \u003d\u003d 0;\n    if (!bVar4) {\n      bVar4 \u003d (param_3 | param_4 \u003c\u003c 1) \u003d\u003d 0;\n    }\n    if (bVar4) {\n      return (ulonglong)((param_2 ^ param_4) \u0026 0x80000000) \u003c\u003c 0x20;\n    }\n    if (unaff_r4 \u003d\u003d 0) {\n      uVar3 \u003d param_2 \u0026 0x80000000;\n      do {\n        uVar1 \u003d param_1 \u0026 0x80000000;\n        param_1 \u003d param_1 \u003c\u003c 1;\n        param_2 \u003d param_2 * 2 + (uint)(uVar1 !\u003d 0);\n      } while ((param_2 \u0026 0x100000) \u003d\u003d 0);\n      param_2 \u003d param_2 | uVar3;\n      if (uVar2 !\u003d 0) {\n        return CONCAT44(param_2,param_1);\n      }\n    }\n    do {\n      uVar2 \u003d param_3 \u0026 0x80000000;\n      param_3 \u003d param_3 \u003c\u003c 1;\n      param_4 \u003d param_4 * 2 + (uint)(uVar2 !\u003d 0);\n    } while ((param_4 \u0026 0x100000) \u003d\u003d 0);\n    return CONCAT44(param_2,param_1);\n  }\n  bVar4 \u003d (param_1 | param_2 \u003c\u003c 1) \u003d\u003d 0;\n  if (bVar4) {\n    param_2 \u003d param_4;\n    param_1 \u003d param_3;\n  }\n  if (!bVar4) {\n    bVar4 \u003d (param_3 | param_4 \u003c\u003c 1) \u003d\u003d 0;\n  }\n  uVar3 \u003d param_2;\n  if (((!bVar4) \u0026\u0026 ((unaff_r4 !\u003d in_r12 || ((param_1 | param_2 \u003c\u003c 0xc) \u003d\u003d 0)))) \u0026\u0026\n     ((uVar2 !\u003d in_r12 || (param_1 \u003d param_3, uVar3 \u003d param_4, (param_3 | param_4 \u003c\u003c 0xc) \u003d\u003d 0)))) {\n    return (ulonglong)((param_2 ^ param_4) \u0026 0x80000000 | 0x7ff00000) \u003c\u003c 0x20;\n  }\n  return CONCAT44(uVar3,param_1) | 0x7ff8000000000000;\n}\n\n",
      "renaming": {},
      "calling": [
        "__muldf3"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__divdf3": {
      "entrypoint": "0x08008894",
      "current_name": "__divdf3",
      "code": "\nulonglong __divdf3(undefined4 param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  uint uVar9;\n  uint unaff_r5;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  bool bVar14;\n  bool bVar15;\n  bool bVar16;\n  undefined8 uVar17;\n  \n  uVar17 \u003d CONCAT44(param_2,param_1);\n  uVar13 \u003d 0x7ff;\n  uVar7 \u003d param_2 \u003e\u003e 0x14 \u0026 0x7ff;\n  bVar14 \u003d uVar7 \u003d\u003d 0;\n  if (!bVar14) {\n    unaff_r5 \u003d param_4 \u003e\u003e 0x14 \u0026 0x7ff;\n    bVar14 \u003d unaff_r5 \u003d\u003d 0;\n  }\n  if (!bVar14) {\n    bVar14 \u003d uVar7 \u003d\u003d 0x7ff;\n  }\n  if (!bVar14) {\n    bVar14 \u003d unaff_r5 \u003d\u003d 0x7ff;\n  }\n  if (bVar14) {\n    uVar17 \u003d FUN_08008a02();\n  }\n  uVar9 \u003d (uint)((ulonglong)uVar17 \u003e\u003e 0x20);\n  uVar11 \u003d (uint)uVar17;\n  iVar8 \u003d uVar7 - unaff_r5;\n  if ((param_3 | param_4 \u003c\u003c 0xc) \u003d\u003d 0) {\n    uVar7 \u003d (uVar9 ^ param_4) \u0026 0x80000000 | uVar9 \u0026 0xfffff;\n    bVar16 \u003d SCARRY4(iVar8,uVar13 \u003e\u003e 1);\n    uVar9 \u003d iVar8 + (uVar13 \u003e\u003e 1);\n    bVar14 \u003d (int)uVar9 \u003c 0;\n    bVar15 \u003d uVar9 \u003d\u003d 0;\n    if (!bVar15 \u0026\u0026 bVar14 \u003d\u003d bVar16) {\n      bVar16 \u003d SBORROW4(uVar13,uVar9);\n      bVar14 \u003d (int)(uVar13 - uVar9) \u003c 0;\n      bVar15 \u003d uVar13 \u003d\u003d uVar9;\n    }\n    if (!bVar15 \u0026\u0026 bVar14 \u003d\u003d bVar16) {\n      uVar7 \u003d uVar7 | uVar9 * 0x100000;\n    }\n    if (!bVar15 \u0026\u0026 bVar14 \u003d\u003d bVar16) {\n      return CONCAT44(uVar7,uVar11);\n    }\n    uVar7 \u003d uVar7 | 0x100000;\n    uVar13 \u003d 0;\n    bVar15 \u003d SBORROW4(uVar9,1);\n    uVar9 \u003d uVar9 - 1;\n    bVar14 \u003d uVar9 \u003d\u003d 0;\n    uVar3 \u003d uVar9;\n  }\n  else {\n    uVar3 \u003d (param_4 \u003c\u003c 0xc) \u003e\u003e 4 | 0x10000000 | param_3 \u003e\u003e 0x18;\n    uVar13 \u003d param_3 \u003c\u003c 8;\n    uVar10 \u003d (uVar9 \u003c\u003c 0xc) \u003e\u003e 4 | 0x10000000 | uVar11 \u003e\u003e 0x18;\n    uVar11 \u003d uVar11 * 0x100;\n    uVar7 \u003d (uVar9 ^ param_4) \u0026 0x80000000;\n    bVar14 \u003d uVar3 \u003c\u003d uVar10;\n    if (uVar10 \u003d\u003d uVar3) {\n      bVar14 \u003d uVar13 \u003c\u003d uVar11;\n    }\n    iVar8 \u003d iVar8 + (uint)bVar14;\n    uVar9 \u003d iVar8 + 0x3fd;\n    if (bVar14 \u003d\u003d false) {\n      uVar3 \u003d uVar3 \u003e\u003e 1;\n      uVar13 \u003d (uint)((param_3 \u003e\u003e 0x18 \u0026 1) !\u003d 0) \u003c\u003c 0x1f | uVar13 \u003e\u003e 1;\n    }\n    uVar12 \u003d uVar11 - uVar13;\n    uVar10 \u003d (uVar10 - uVar3) - (uint)(uVar11 \u003c uVar13);\n    uVar4 \u003d uVar3 \u003e\u003e 1;\n    uVar1 \u003d (uint)((uVar3 \u0026 1) !\u003d 0) \u003c\u003c 0x1f | uVar13 \u003e\u003e 1;\n    uVar11 \u003d 0x100000;\n    uVar3 \u003d 0x80000;\n    while( true ) {\n      bVar14 \u003d uVar1 \u003c\u003d uVar12;\n      if (uVar4 \u003c uVar10 || uVar10 - uVar4 \u003c (uint)bVar14) {\n        uVar12 \u003d uVar12 - uVar1;\n        uVar11 \u003d uVar11 | uVar3;\n        uVar10 \u003d (uVar10 - uVar4) - (uint)!bVar14;\n      }\n      uVar5 \u003d uVar4 \u003e\u003e 1;\n      uVar1 \u003d (uint)((uVar4 \u0026 1) !\u003d 0) \u003c\u003c 0x1f | uVar1 \u003e\u003e 1;\n      bVar15 \u003d uVar1 \u003c\u003d uVar12;\n      bVar14 \u003d uVar10 - uVar5 \u003c (uint)bVar15;\n      uVar13 \u003d uVar10;\n      if (uVar5 \u003c uVar10 || bVar14) {\n        uVar12 \u003d uVar12 - uVar1;\n        uVar13 \u003d (uVar10 - uVar5) - (uint)!bVar15;\n      }\n      if (uVar5 \u003c uVar10 || bVar14) {\n        uVar11 \u003d uVar11 | uVar3 \u003e\u003e 1;\n      }\n      uVar10 \u003d uVar4 \u003e\u003e 2;\n      uVar2 \u003d (uint)((uVar5 \u0026 1) !\u003d 0) \u003c\u003c 0x1f | uVar1 \u003e\u003e 1;\n      bVar15 \u003d uVar2 \u003c\u003d uVar12;\n      bVar14 \u003d uVar13 - uVar10 \u003c (uint)bVar15;\n      uVar5 \u003d uVar13;\n      if (uVar10 \u003c uVar13 || bVar14) {\n        uVar12 \u003d uVar12 - uVar2;\n        uVar5 \u003d (uVar13 - uVar10) - (uint)!bVar15;\n      }\n      if (uVar10 \u003c uVar13 || bVar14) {\n        uVar11 \u003d uVar11 | uVar3 \u003e\u003e 2;\n      }\n      uVar6 \u003d uVar4 \u003e\u003e 3;\n      uVar1 \u003d (uint)((uVar10 \u0026 1) !\u003d 0) \u003c\u003c 0x1f | uVar2 \u003e\u003e 1;\n      bVar15 \u003d uVar1 \u003c\u003d uVar12;\n      bVar14 \u003d uVar5 - uVar6 \u003c (uint)bVar15;\n      uVar10 \u003d uVar5;\n      if (uVar6 \u003c uVar5 || bVar14) {\n        uVar12 \u003d uVar12 - uVar1;\n        uVar10 \u003d (uVar5 - uVar6) - (uint)!bVar15;\n      }\n      if (uVar6 \u003c uVar5 || bVar14) {\n        uVar11 \u003d uVar11 | uVar3 \u003e\u003e 3;\n      }\n      uVar13 \u003d uVar10 | uVar12;\n      if (uVar13 \u003d\u003d 0) break;\n      uVar10 \u003d uVar10 \u003c\u003c 4 | uVar12 \u003e\u003e 0x1c;\n      uVar12 \u003d uVar12 \u003c\u003c 4;\n      uVar4 \u003d uVar4 \u0026 0xfffffff8 | uVar1 \u003e\u003e 0x1d;\n      uVar1 \u003d (uVar2 \u003e\u003e 1) \u003c\u003c 3;\n      uVar3 \u003d uVar3 \u003e\u003e 4;\n      if (uVar3 \u003d\u003d 0) {\n        uVar6 \u003d uVar4;\n        if ((uVar7 \u0026 0x100000) !\u003d 0) goto LAB_080089b2;\n        uVar7 \u003d uVar7 | uVar11;\n        uVar11 \u003d 0;\n        uVar3 \u003d 0x80000000;\n      }\n    }\n    if ((uVar7 \u0026 0x100000) \u003d\u003d 0) {\n      uVar7 \u003d uVar7 | uVar11;\n      uVar11 \u003d 0;\n    }\nLAB_080089b2:\n    bVar16 \u003d 0xfc \u003c uVar9;\n    bVar15 \u003d SBORROW4(uVar9,0xfd);\n    uVar4 \u003d iVar8 + 0x300;\n    bVar14 \u003d uVar4 \u003d\u003d 0;\n    uVar3 \u003d uVar4;\n    if (bVar16 \u0026\u0026 !bVar14) {\n      bVar16 \u003d 0x6ff \u003c uVar4;\n      bVar15 \u003d SBORROW4(uVar4,0x700);\n      uVar3 \u003d iVar8 - 0x400;\n      bVar14 \u003d uVar4 \u003d\u003d 0x700;\n    }\n    if (!bVar16 || bVar14) {\n      bVar14 \u003d uVar6 \u003c\u003d uVar10;\n      if (uVar10 \u003d\u003d uVar6) {\n        bVar14 \u003d uVar1 \u003c\u003d uVar12;\n      }\n      if (uVar10 \u003d\u003d uVar6 \u0026\u0026 uVar12 \u003d\u003d uVar1) {\n        bVar14 \u003d (uVar11 \u0026 1) !\u003d 0;\n      }\n      return CONCAT44(uVar7 + uVar9 * 0x100000 + (uint)CARRY4(uVar11,(uint)bVar14),uVar11 + bVar14);\n    }\n  }\n  if (!bVar14 \u0026\u0026 (int)uVar3 \u003c 0 \u003d\u003d bVar15) {\n    return (ulonglong)(uVar7 \u0026 0x80000000 | 0x7ff00000) \u003c\u003c 0x20;\n  }\n  bVar16 \u003d SCARRY4(uVar9,0x36);\n  bVar14 \u003d (int)(uVar9 + 0x36) \u003c 0;\n  bVar15 \u003d uVar9 \u003d\u003d 0xffffffca;\n  if (bVar15 || bVar14 !\u003d bVar16) {\n    uVar11 \u003d 0;\n  }\n  if (bVar15 || bVar14 !\u003d bVar16) {\n    uVar7 \u003d uVar7 \u0026 0x80000000;\n  }\n  if (bVar15 || bVar14 !\u003d bVar16) {\n    return CONCAT44(uVar7,uVar11);\n  }\n  uVar3 \u003d -uVar9;\n  uVar10 \u003d uVar3 - 0x20;\n  if (0x1f \u003c (int)uVar3) {\n    uVar3 \u003d uVar11 \u003e\u003e (uVar10 \u0026 0xff) | uVar7 \u003c\u003c (0x20 - uVar10 \u0026 0xff);\n    uVar9 \u003d (uVar7 \u003e\u003e (uVar10 \u0026 0xff) \u0026 ~((uVar7 \u0026 0x80000000) \u003e\u003e (uVar10 \u0026 0xff))) -\n            ((int)uVar3 \u003e\u003e 0x1f);\n    if ((uVar13 | uVar11 \u003c\u003c (0x20 - uVar10 \u0026 0xff) | uVar3 \u003c\u003c 1) \u003d\u003d 0) {\n      uVar9 \u003d uVar9 \u0026 ~(uVar3 \u003e\u003e 0x1f);\n    }\n    return CONCAT44(uVar7,uVar9) \u0026 0x80000000ffffffff;\n  }\n  iVar8 \u003d uVar3 - 0x14;\n  if (iVar8 !\u003d 0 \u0026\u0026 iVar8 \u003c 0 \u003d\u003d SCARRY4(uVar10,0xc)) {\n    uVar9 \u003d 0xc - iVar8;\n    uVar3 \u003d uVar11 \u003c\u003c (uVar9 \u0026 0xff);\n    uVar11 \u003d uVar11 \u003e\u003e (0x20 - uVar9 \u0026 0xff) | uVar7 \u003c\u003c (uVar9 \u0026 0xff);\n    uVar9 \u003d uVar11 + -((int)uVar3 \u003e\u003e 0x1f);\n    if ((uVar13 | uVar3 \u003c\u003c 1) \u003d\u003d 0) {\n      uVar9 \u003d uVar9 \u0026 ~(uVar3 \u003e\u003e 0x1f);\n    }\n    return CONCAT44((uVar7 \u0026 0x80000000) + (uint)CARRY4(uVar11,-((int)uVar3 \u003e\u003e 0x1f)),uVar9);\n  }\n  uVar10 \u003d uVar11 \u003c\u003c (uVar9 + 0x20 \u0026 0xff);\n  uVar11 \u003d uVar11 \u003e\u003e (uVar3 \u0026 0xff) | uVar7 \u003c\u003c (uVar9 + 0x20 \u0026 0xff);\n  uVar9 \u003d uVar11 + -((int)uVar10 \u003e\u003e 0x1f);\n  if ((uVar13 | uVar10 \u003c\u003c 1) \u003d\u003d 0) {\n    uVar9 \u003d uVar9 \u0026 ~(uVar10 \u003e\u003e 0x1f);\n  }\n  return CONCAT44((uVar7 \u0026 0x80000000) +\n                  ((uVar7 \u0026 0x7fffffff) \u003e\u003e (uVar3 \u0026 0xff)) +\n                  (uint)CARRY4(uVar11,-((int)uVar10 \u003e\u003e 0x1f)),uVar9);\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line",
        "plan_buffer_line",
        "sqrt",
        "homing_cycle",
        "__ieee754_sqrt",
        "atan",
        "__ieee754_atan2"
      ],
      "called": [
        "FUN_08008a02"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08008a02": {
      "entrypoint": "0x08008a02",
      "current_name": "FUN_08008a02",
      "code": "\nulonglong FUN_08008a02(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  uint in_r12;\n  bool bVar4;\n  \n  uVar2 \u003d in_r12 \u0026 param_4 \u003e\u003e 0x14;\n  uVar3 \u003d param_2;\n  if (unaff_r4 !\u003d in_r12 || uVar2 !\u003d in_r12) {\n    if (unaff_r4 \u003d\u003d in_r12) {\n      if (((param_1 | param_2 \u003c\u003c 0xc) \u003d\u003d 0) \u0026\u0026 (param_1 \u003d param_3, uVar3 \u003d param_4, uVar2 !\u003d in_r12)\n         ) {\nLAB_08008874:\n        return (ulonglong)((param_2 ^ param_4) \u0026 0x80000000 | 0x7ff00000) \u003c\u003c 0x20;\n      }\n    }\n    else if (uVar2 \u003d\u003d in_r12) {\n      param_1 \u003d param_3;\n      uVar3 \u003d param_4;\n      if ((param_3 | param_4 \u003c\u003c 0xc) \u003d\u003d 0) {\nLAB_08008838:\n        return (ulonglong)((param_2 ^ param_4) \u0026 0x80000000) \u003c\u003c 0x20;\n      }\n    }\n    else {\n      bVar4 \u003d (param_1 | param_2 \u003c\u003c 1) \u003d\u003d 0;\n      if (!bVar4) {\n        bVar4 \u003d (param_3 | param_4 \u003c\u003c 1) \u003d\u003d 0;\n      }\n      if (!bVar4) {\n        if (unaff_r4 \u003d\u003d 0) {\n          uVar3 \u003d param_2 \u0026 0x80000000;\n          do {\n            uVar1 \u003d param_1 \u0026 0x80000000;\n            param_1 \u003d param_1 \u003c\u003c 1;\n            param_2 \u003d param_2 * 2 + (uint)(uVar1 !\u003d 0);\n          } while ((param_2 \u0026 0x100000) \u003d\u003d 0);\n          param_2 \u003d param_2 | uVar3;\n          if (uVar2 !\u003d 0) {\n            return CONCAT44(param_2,param_1);\n          }\n        }\n        do {\n          uVar3 \u003d param_3 \u0026 0x80000000;\n          param_3 \u003d param_3 \u003c\u003c 1;\n          param_4 \u003d param_4 * 2 + (uint)(uVar3 !\u003d 0);\n        } while ((param_4 \u0026 0x100000) \u003d\u003d 0);\n        return CONCAT44(param_2,param_1);\n      }\n      if ((param_1 | param_2 \u003c\u003c 1) !\u003d 0) goto LAB_08008874;\n      if ((param_3 | param_4 \u003c\u003c 1) !\u003d 0) goto LAB_08008838;\n    }\n  }\n  return CONCAT44(uVar3,param_1) | 0x7ff8000000000000;\n}\n\n",
      "renaming": {},
      "calling": [
        "__divdf3"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__gedf2": {
      "entrypoint": "0x08008a64",
      "current_name": "__gedf2",
      "code": "\nuint __gedf2(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  bool bVar2;\n  bool bVar3;\n  \n  if (((int)(param_2 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1 || (int)(param_4 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1) \u0026\u0026\n     ((((int)(param_2 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1 \u0026\u0026 ((param_1 | param_2 \u003c\u003c 0xc) !\u003d 0)) ||\n      (((int)(param_4 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1 \u0026\u0026 ((param_3 | param_4 \u003c\u003c 0xc) !\u003d 0)))))) {\n    return 0xffffffff;\n  }\n  bVar2 \u003d (param_1 | param_2 \u003c\u003c 1) \u003d\u003d 0;\n  if (bVar2) {\n    bVar2 \u003d (param_3 | param_4 \u003c\u003c 1) \u003d\u003d 0;\n  }\n  if (!bVar2) {\n    bVar2 \u003d param_2 \u003d\u003d param_4;\n  }\n  if (bVar2) {\n    bVar2 \u003d param_1 \u003d\u003d param_3;\n  }\n  if (!bVar2) {\n    uVar1 \u003d param_2 ^ param_4;\n    bVar2 \u003d uVar1 \u003d\u003d 0;\n    if (-1 \u003c (int)uVar1) {\n      bVar2 \u003d param_2 \u003d\u003d param_4;\n    }\n    bVar3 \u003d -1 \u003c (int)uVar1 \u0026\u0026 param_4 \u003c\u003d param_2;\n    if (bVar2) {\n      bVar3 \u003d param_3 \u003c\u003d param_1;\n    }\n    param_4 \u003d (int)param_4 \u003e\u003e 0x1f;\n    if (!bVar3) {\n      param_4 \u003d ~param_4;\n    }\n    return param_4 | 1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__ledf2": {
      "entrypoint": "0x08008a6c",
      "current_name": "__ledf2",
      "code": "\nuint __ledf2(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  bool bVar2;\n  bool bVar3;\n  \n  if (((int)(param_2 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1 || (int)(param_4 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1) \u0026\u0026\n     ((((int)(param_2 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1 \u0026\u0026 ((param_1 | param_2 \u003c\u003c 0xc) !\u003d 0)) ||\n      (((int)(param_4 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1 \u0026\u0026 ((param_3 | param_4 \u003c\u003c 0xc) !\u003d 0)))))) {\n    return 1;\n  }\n  bVar2 \u003d (param_1 | param_2 \u003c\u003c 1) \u003d\u003d 0;\n  if (bVar2) {\n    bVar2 \u003d (param_3 | param_4 \u003c\u003c 1) \u003d\u003d 0;\n  }\n  if (!bVar2) {\n    bVar2 \u003d param_2 \u003d\u003d param_4;\n  }\n  if (bVar2) {\n    bVar2 \u003d param_1 \u003d\u003d param_3;\n  }\n  if (!bVar2) {\n    uVar1 \u003d param_2 ^ param_4;\n    bVar2 \u003d uVar1 \u003d\u003d 0;\n    if (-1 \u003c (int)uVar1) {\n      bVar2 \u003d param_2 \u003d\u003d param_4;\n    }\n    bVar3 \u003d -1 \u003c (int)uVar1 \u0026\u0026 param_4 \u003c\u003d param_2;\n    if (bVar2) {\n      bVar3 \u003d param_3 \u003c\u003d param_1;\n    }\n    param_4 \u003d (int)param_4 \u003e\u003e 0x1f;\n    if (!bVar3) {\n      param_4 \u003d ~param_4;\n    }\n    return param_4 | 1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__nedf2": {
      "entrypoint": "0x08008a74",
      "current_name": "__nedf2",
      "code": "\nuint __nedf2(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  bool bVar2;\n  bool bVar3;\n  \n  if (((int)(param_2 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1 || (int)(param_4 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1) \u0026\u0026\n     ((((int)(param_2 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1 \u0026\u0026 ((param_1 | param_2 \u003c\u003c 0xc) !\u003d 0)) ||\n      (((int)(param_4 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1 \u0026\u0026 ((param_3 | param_4 \u003c\u003c 0xc) !\u003d 0)))))) {\n    return 1;\n  }\n  bVar2 \u003d (param_1 | param_2 \u003c\u003c 1) \u003d\u003d 0;\n  if (bVar2) {\n    bVar2 \u003d (param_3 | param_4 \u003c\u003c 1) \u003d\u003d 0;\n  }\n  if (!bVar2) {\n    bVar2 \u003d param_2 \u003d\u003d param_4;\n  }\n  if (bVar2) {\n    bVar2 \u003d param_1 \u003d\u003d param_3;\n  }\n  if (!bVar2) {\n    uVar1 \u003d param_2 ^ param_4;\n    bVar2 \u003d uVar1 \u003d\u003d 0;\n    if (-1 \u003c (int)uVar1) {\n      bVar2 \u003d param_2 \u003d\u003d param_4;\n    }\n    bVar3 \u003d -1 \u003c (int)uVar1 \u0026\u0026 param_4 \u003c\u003d param_2;\n    if (bVar2) {\n      bVar3 \u003d param_3 \u003c\u003d param_1;\n    }\n    param_4 \u003d (int)param_4 \u003e\u003e 0x1f;\n    if (!bVar3) {\n      param_4 \u003d ~param_4;\n    }\n    return param_4 | 1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_cdcmpeq"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_cdrcmple": {
      "entrypoint": "0x08008af0",
      "current_name": "__aeabi_cdrcmple",
      "code": "\nvoid __aeabi_cdrcmple(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  __aeabi_cdcmpeq(param_3,param_4,param_1,param_2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_dcmpge",
        "__aeabi_dcmpgt"
      ],
      "called": [
        "__aeabi_cdcmpeq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_cdcmpeq": {
      "entrypoint": "0x08008b00",
      "current_name": "__aeabi_cdcmpeq",
      "code": "\nundefined4 __aeabi_cdcmpeq(undefined4 param_1)\n\n{\n  __nedf2();\n  return param_1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_dcmple",
        "__aeabi_dcmpeq",
        "__aeabi_dcmplt",
        "__aeabi_cdrcmple"
      ],
      "called": [
        "__nedf2"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_dcmpeq": {
      "entrypoint": "0x08008b10",
      "current_name": "__aeabi_dcmpeq",
      "code": "\nbool __aeabi_dcmpeq(void)\n\n{\n  char in_ZR;\n  \n  __aeabi_cdcmpeq();\n  return in_ZR !\u003d \u0027\\0\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "__ieee754_rem_pio2",
        "__kernel_rem_pio2"
      ],
      "called": [
        "__aeabi_cdcmpeq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_dcmplt": {
      "entrypoint": "0x08008b24",
      "current_name": "__aeabi_dcmplt",
      "code": "\nbool __aeabi_dcmplt(void)\n\n{\n  char in_CY;\n  \n  __aeabi_cdcmpeq();\n  return in_CY \u003d\u003d \u0027\\0\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "plan_buffer_line",
        "__ieee754_hypot",
        "sqrt"
      ],
      "called": [
        "__aeabi_cdcmpeq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_dcmple": {
      "entrypoint": "0x08008b38",
      "current_name": "__aeabi_dcmple",
      "code": "\nbool __aeabi_dcmple(void)\n\n{\n  undefined in_ZR;\n  undefined in_CY;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)in_CY || (bool)in_ZR;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__aeabi_cdcmpeq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_dcmpge": {
      "entrypoint": "0x08008b4c",
      "current_name": "__aeabi_dcmpge",
      "code": "\nbool __aeabi_dcmpge(void)\n\n{\n  undefined in_ZR;\n  undefined in_CY;\n  \n  __aeabi_cdrcmple();\n  return !(bool)in_CY || (bool)in_ZR;\n}\n\n",
      "renaming": {},
      "calling": [
        "__kernel_rem_pio2"
      ],
      "called": [
        "__aeabi_cdrcmple"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_dcmpgt": {
      "entrypoint": "0x08008b60",
      "current_name": "__aeabi_dcmpgt",
      "code": "\nbool __aeabi_dcmpgt(void)\n\n{\n  char in_CY;\n  \n  __aeabi_cdrcmple();\n  return in_CY \u003d\u003d \u0027\\0\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "plan_buffer_line",
        "floor",
        "ceil",
        "atan"
      ],
      "called": [
        "__aeabi_cdrcmple"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__unorddf2": {
      "entrypoint": "0x08008b74",
      "current_name": "__unorddf2",
      "code": "\nundefined4 __unorddf2(uint param_1,int param_2,uint param_3,int param_4)\n\n{\n  if ((((param_2 \u003c\u003c 1) \u003e\u003e 0x15 !\u003d -1) || ((param_1 | param_2 \u003c\u003c 0xc) \u003d\u003d 0)) \u0026\u0026\n     (((param_4 \u003c\u003c 1) \u003e\u003e 0x15 !\u003d -1 || ((param_3 | param_4 \u003c\u003c 0xc) \u003d\u003d 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "sqrt"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_d2iz": {
      "entrypoint": "0x08008ba0",
      "current_name": "__aeabi_d2iz",
      "code": "\nuint __aeabi_d2iz(uint param_1,uint param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  uint uVar3;\n  \n  iVar2 \u003d param_2 * 2 + 0x200000;\n  if (param_2 * 2 \u003c 0xffe00000) {\n    if (-1 \u003c iVar2) {\n      return 0;\n    }\n    uVar1 \u003d iVar2 \u003e\u003e 0x15;\n    uVar3 \u003d -uVar1 - 0x3e1;\n    if (uVar1 \u003c 0xfffffc20 \u0026\u0026 uVar3 !\u003d 0) {\n      uVar1 \u003d (param_2 \u003c\u003c 0xb | 0x80000000 | param_1 \u003e\u003e 0x15) \u003e\u003e (uVar3 \u0026 0xff);\n      if ((param_2 \u0026 0x80000000) !\u003d 0) {\n        uVar1 \u003d -uVar1;\n      }\n      return uVar1;\n    }\n  }\n  else if ((param_1 | param_2 \u003c\u003c 0xc) !\u003d 0) {\n    return 0;\n  }\n  param_2 \u003d param_2 \u0026 0x80000000;\n  if (param_2 \u003d\u003d 0) {\n    param_2 \u003d 0x7fffffff;\n  }\n  return param_2;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line",
        "plan_buffer_line",
        "calculate_trapezoid_for_block",
        "lround",
        "__ieee754_rem_pio2",
        "__kernel_sin",
        "__kernel_rem_pio2",
        "__kernel_cos"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_d2uiz": {
      "entrypoint": "0x08008bf0",
      "current_name": "__aeabi_d2uiz",
      "code": "\nuint __aeabi_d2uiz(uint param_1,uint param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  \n  if ((param_2 \u0026 0x80000000) !\u003d 0) {\n    return 0;\n  }\n  iVar1 \u003d param_2 * 2 + 0x200000;\n  if (param_2 * 2 \u003c 0xffe00000) {\n    if (-1 \u003c iVar1) {\n      return 0;\n    }\n    uVar2 \u003d -(iVar1 \u003e\u003e 0x15) - 0x3e1;\n    if (-1 \u003c (int)uVar2) {\n      return (param_2 \u003c\u003c 0xb | 0x80000000 | param_1 \u003e\u003e 0x15) \u003e\u003e (uVar2 \u0026 0xff);\n    }\n  }\n  else if ((param_1 | param_2 \u003c\u003c 0xc) !\u003d 0) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "plan_buffer_line",
        "gc_execute_line",
        "protocol_execute_line",
        "settings_store_global_setting",
        "calculate_trapezoid_for_block",
        "homing_cycle",
        "mc_dwell",
        "mc_arc"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__truncdfsf2": {
      "entrypoint": "0x08008c30",
      "current_name": "__truncdfsf2",
      "code": "\nuint __truncdfsf2(uint param_1,uint param_2)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint in_r12;\n  bool bVar4;\n  bool bVar5;\n  \n  uVar2 \u003d param_2 * 2;\n  bVar5 \u003d uVar2 \u003c 0x70000000;\n  uVar3 \u003d uVar2 + 0x90000000;\n  uVar1 \u003d uVar3;\n  if (!bVar5) {\n    in_r12 \u003d uVar2 + 0x8fe00000;\n    uVar1 \u003d in_r12;\n  }\n  bVar4 \u003d uVar1 \u003d\u003d 0;\n  if (!bVar5 \u0026\u0026 uVar3 \u003e\u003d 0x200000) {\n    bVar4 \u003d in_r12 \u003d\u003d 0x1fc00000;\n  }\n  if (((bVar5 || uVar3 \u003c 0x200000) || 0x1fc00000 \u003c in_r12) || bVar4) {\n    if ((param_2 \u0026 0x40000000) !\u003d 0) {\n      if (((int)uVar2 \u003e\u003e 0x15 \u003d\u003d -1) \u0026\u0026 ((param_1 | param_2 \u003c\u003c 0xc) !\u003d 0)) {\n        return 0x7fc00000;\n      }\n      return param_2 \u0026 0x80000000 | 0x7f800000;\n    }\n    if ((int)(uVar2 + 0x92e00000) \u003c 0 !\u003d SCARRY4(uVar3,0x2e00000)) {\n      return param_2 \u0026 0x80000000;\n    }\n    uVar2 \u003d 0x18 - (uVar2 + 0x92e00000 \u003e\u003e 0x15);\n    uVar1 \u003d param_1 \u003e\u003e (uVar2 \u0026 0xff);\n    if (param_1 \u003c\u003c (0x20 - uVar2 \u0026 0xff) !\u003d 0) {\n      uVar1 \u003d uVar1 | 1;\n    }\n    uVar3 \u003d param_2 \u0026 0x1fffff | 0x100000;\n    param_1 \u003d uVar1 | uVar3 \u003c\u003c (0x20 - uVar2 \u0026 0xff);\n    uVar3 \u003d (uVar3 \u003e\u003e (uVar2 \u0026 0xff)) \u003c\u003c 1;\n  }\n  uVar1 \u003d (param_2 \u0026 0x80000000 | param_1 \u003e\u003e 0x1d) + uVar3 * 4 + (uint)(0x7fffffff \u003c param_1 * 8);\n  if (param_1 * 8 \u003d\u003d 0x80000000) {\n    uVar1 \u003d uVar1 \u0026 0xfffffffe;\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "report_realtime_status",
        "gc_execute_line",
        "plan_buffer_line",
        "report_gcode_parameters",
        "max_allowable_speed",
        "to_millimeters",
        "homing_cycle",
        "read_float",
        "mc_arc",
        "report_gcode_modes"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_frsub": {
      "entrypoint": "0x08008cd0",
      "current_name": "__aeabi_frsub",
      "code": "\nvoid __aeabi_frsub(uint param_1)\n\n{\n  __addsf3(param_1 ^ 0x80000000);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__addsf3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_fsub": {
      "entrypoint": "0x08008cd8",
      "current_name": "__aeabi_fsub",
      "code": "\nuint __aeabi_fsub(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  int iVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  bool bVar8;\n  \n  uVar3 \u003d param_2 ^ 0x80000000;\n  uVar5 \u003d param_1 \u003c\u003c 1;\n  bVar8 \u003d uVar5 \u003d\u003d 0;\n  if (!bVar8) {\n    param_4 \u003d param_2 \u003c\u003c 1;\n    bVar8 \u003d param_4 \u003d\u003d 0;\n  }\n  if (!bVar8) {\n    bVar8 \u003d uVar5 \u003d\u003d param_4;\n  }\n  iVar1 \u003d (int)uVar5 \u003e\u003e 0x18;\n  if (!bVar8) {\n    bVar8 \u003d iVar1 \u003d\u003d -1;\n  }\n  if (!bVar8) {\n    bVar8 \u003d (int)param_4 \u003e\u003e 0x18 \u003d\u003d -1;\n  }\n  if (bVar8) {\n    iVar2 \u003d (int)(param_2 \u003c\u003c 1) \u003e\u003e 0x18;\n    if (iVar1 \u003d\u003d -1 || iVar2 \u003d\u003d -1) {\n      uVar5 \u003d uVar3;\n      if (iVar1 \u003d\u003d -1) {\n        uVar5 \u003d param_1;\n      }\n      if (iVar1 !\u003d -1 || iVar2 !\u003d -1) {\n        uVar3 \u003d uVar5;\n      }\n      bVar8 \u003d (uVar5 \u0026 0x7fffff) \u003d\u003d 0;\n      if (bVar8) {\n        bVar8 \u003d (uVar3 \u0026 0x7fffff) \u003d\u003d 0;\n      }\n      if (bVar8) {\n        bVar8 \u003d uVar5 \u003d\u003d uVar3;\n      }\n      if (!bVar8) {\n        uVar5 \u003d uVar5 | 0x400000;\n      }\n      return uVar5;\n    }\n    if (((param_1 ^ uVar3) \u0026 0x7fffffff) !\u003d 0) {\n      if (uVar5 \u003d\u003d 0) {\n        param_1 \u003d uVar3;\n      }\n      return param_1;\n    }\n    if (param_1 !\u003d uVar3) {\n      return 0;\n    }\n    if ((uVar5 \u0026 0xff000000) \u003d\u003d 0) {\n      uVar3 \u003d param_1 \u003c\u003c 1;\n      if ((param_1 \u0026 0x80000000) !\u003d 0) {\n        uVar3 \u003d uVar3 | 0x80000000;\n      }\n      return uVar3;\n    }\n    if (uVar5 \u003c 0xfe000000) {\n      return param_1 + 0x800000;\n    }\n    param_1 \u003d param_1 \u0026 0x80000000;\nLAB_08008e12:\n    return param_1 | 0x7f800000;\n  }\n  uVar5 \u003d uVar5 \u003e\u003e 0x18;\n  param_4 \u003d param_4 \u003e\u003e 0x18;\n  uVar7 \u003d param_4 - uVar5;\n  bVar8 \u003d uVar7 !\u003d 0;\n  uVar6 \u003d uVar5;\n  if (bVar8 \u0026\u0026 uVar5 \u003c\u003d param_4) {\n    uVar6 \u003d uVar5 + uVar7;\n  }\n  if (bVar8 \u0026\u0026 uVar5 \u003c\u003d param_4) {\n    uVar3 \u003d uVar3 ^ param_1;\n  }\n  if (bVar8 \u0026\u0026 uVar5 \u003c\u003d param_4) {\n    param_1 \u003d param_1 ^ uVar3;\n  }\n  if (bVar8 \u0026\u0026 uVar5 \u003c\u003d param_4) {\n    uVar3 \u003d uVar3 ^ param_1;\n  }\n  if (param_4 \u003c uVar5) {\n    uVar7 \u003d -uVar7;\n  }\n  if (0x19 \u003c uVar7) {\n    return param_1;\n  }\n  uVar5 \u003d param_1 \u0026 0xffffff | 0x800000;\n  if ((param_1 \u0026 0x80000000) !\u003d 0) {\n    uVar5 \u003d -uVar5;\n  }\n  uVar4 \u003d uVar3 \u0026 0xffffff | 0x800000;\n  if ((uVar3 \u0026 0x80000000) !\u003d 0) {\n    uVar4 \u003d -uVar4;\n  }\n  if (uVar6 \u003d\u003d uVar7) {\n    uVar4 \u003d uVar4 ^ 0x800000;\n    if (uVar6 \u003d\u003d 0) {\n      uVar5 \u003d uVar5 ^ 0x800000;\n      uVar6 \u003d 1;\n    }\n    else {\n      uVar7 \u003d uVar7 - 1;\n    }\n  }\n  uVar5 \u003d uVar5 + ((int)uVar4 \u003e\u003e (uVar7 \u0026 0xff));\n  uVar4 \u003d uVar4 \u003c\u003c (0x20 - uVar7 \u0026 0xff);\n  param_1 \u003d uVar5 \u0026 0x80000000;\n  if ((int)uVar5 \u003c 0) {\n    bVar8 \u003d uVar4 !\u003d 0;\n    uVar4 \u003d -uVar4;\n    uVar5 \u003d -uVar5 - (uint)bVar8;\n  }\n  if (uVar5 \u003c 0x800000) {\n    uVar3 \u003d uVar4 \u0026 0x80000000;\n    uVar4 \u003d uVar4 \u003c\u003c 1;\n    uVar5 \u003d uVar5 * 2 + (uint)(uVar3 !\u003d 0);\n    uVar3 \u003d uVar6 - 2;\n    if (uVar6 - 1 \u003d\u003d 0 || uVar5 \u003c 0x800000) {\n      uVar7 \u003d LZCOUNT(uVar5) - 8;\n      uVar5 \u003d uVar5 \u003c\u003c (uVar7 \u0026 0xff);\n      if ((int)uVar3 \u003c (int)uVar7) {\n        uVar5 \u003d uVar5 \u003e\u003e (-(uVar3 - uVar7) \u0026 0xff);\n      }\n      else {\n        uVar5 \u003d uVar5 + (uVar3 - uVar7) * 0x800000;\n      }\n      return uVar5 | param_1;\n    }\n  }\n  else {\n    uVar3 \u003d uVar6 - 1;\n    if (0xffffff \u003c uVar5) {\n      uVar3 \u003d uVar5 \u0026 1;\n      uVar5 \u003d uVar5 \u003e\u003e 1;\n      uVar4 \u003d (uint)(uVar3 !\u003d 0) \u003c\u003c 0x1f | uVar4 \u003e\u003e 1;\n      uVar3 \u003d uVar6;\n      if (0xfd \u003c uVar6) goto LAB_08008e12;\n    }\n  }\n  uVar5 \u003d uVar5 + uVar3 * 0x800000 + (uint)(0x7fffffff \u003c uVar4);\n  if (uVar4 \u003d\u003d 0x80000000) {\n    uVar5 \u003d uVar5 \u0026 0xfffffffe;\n  }\n  return uVar5 | param_1;\n}\n\n",
      "renaming": {},
      "calling": [
        "report_realtime_status",
        "gc_execute_line",
        "plan_buffer_line",
        "max_allowable_speed",
        "intersection_distance",
        "mc_dwell",
        "mc_arc",
        "estimate_acceleration_distance"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__addsf3": {
      "entrypoint": "0x08008cdc",
      "current_name": "__addsf3",
      "code": "\nuint __addsf3(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  int iVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  bool bVar7;\n  \n  uVar4 \u003d param_1 \u003c\u003c 1;\n  bVar7 \u003d uVar4 \u003d\u003d 0;\n  if (!bVar7) {\n    param_4 \u003d param_2 \u003c\u003c 1;\n    bVar7 \u003d param_4 \u003d\u003d 0;\n  }\n  if (!bVar7) {\n    bVar7 \u003d uVar4 \u003d\u003d param_4;\n  }\n  iVar1 \u003d (int)uVar4 \u003e\u003e 0x18;\n  if (!bVar7) {\n    bVar7 \u003d iVar1 \u003d\u003d -1;\n  }\n  if (!bVar7) {\n    bVar7 \u003d (int)param_4 \u003e\u003e 0x18 \u003d\u003d -1;\n  }\n  if (bVar7) {\n    iVar2 \u003d (int)(param_2 \u003c\u003c 1) \u003e\u003e 0x18;\n    if (iVar1 \u003d\u003d -1 || iVar2 \u003d\u003d -1) {\n      uVar4 \u003d param_2;\n      if (iVar1 \u003d\u003d -1) {\n        uVar4 \u003d param_1;\n      }\n      if (iVar1 !\u003d -1 || iVar2 !\u003d -1) {\n        param_2 \u003d uVar4;\n      }\n      bVar7 \u003d (uVar4 \u0026 0x7fffff) \u003d\u003d 0;\n      if (bVar7) {\n        bVar7 \u003d (param_2 \u0026 0x7fffff) \u003d\u003d 0;\n      }\n      if (bVar7) {\n        bVar7 \u003d uVar4 \u003d\u003d param_2;\n      }\n      if (!bVar7) {\n        uVar4 \u003d uVar4 | 0x400000;\n      }\n      return uVar4;\n    }\n    if (((param_1 ^ param_2) \u0026 0x7fffffff) !\u003d 0) {\n      if (uVar4 \u003d\u003d 0) {\n        param_1 \u003d param_2;\n      }\n      return param_1;\n    }\n    if (param_1 !\u003d param_2) {\n      return 0;\n    }\n    if ((uVar4 \u0026 0xff000000) \u003d\u003d 0) {\n      uVar4 \u003d param_1 \u003c\u003c 1;\n      if ((param_1 \u0026 0x80000000) !\u003d 0) {\n        uVar4 \u003d uVar4 | 0x80000000;\n      }\n      return uVar4;\n    }\n    if (uVar4 \u003c 0xfe000000) {\n      return param_1 + 0x800000;\n    }\n    param_1 \u003d param_1 \u0026 0x80000000;\nLAB_08008e12:\n    return param_1 | 0x7f800000;\n  }\n  uVar4 \u003d uVar4 \u003e\u003e 0x18;\n  param_4 \u003d param_4 \u003e\u003e 0x18;\n  uVar6 \u003d param_4 - uVar4;\n  bVar7 \u003d uVar6 !\u003d 0;\n  uVar5 \u003d uVar4;\n  if (bVar7 \u0026\u0026 uVar4 \u003c\u003d param_4) {\n    uVar5 \u003d uVar4 + uVar6;\n  }\n  if (bVar7 \u0026\u0026 uVar4 \u003c\u003d param_4) {\n    param_2 \u003d param_2 ^ param_1;\n  }\n  if (bVar7 \u0026\u0026 uVar4 \u003c\u003d param_4) {\n    param_1 \u003d param_1 ^ param_2;\n  }\n  if (bVar7 \u0026\u0026 uVar4 \u003c\u003d param_4) {\n    param_2 \u003d param_2 ^ param_1;\n  }\n  if (param_4 \u003c uVar4) {\n    uVar6 \u003d -uVar6;\n  }\n  if (0x19 \u003c uVar6) {\n    return param_1;\n  }\n  uVar4 \u003d param_1 \u0026 0xffffff | 0x800000;\n  if ((param_1 \u0026 0x80000000) !\u003d 0) {\n    uVar4 \u003d -uVar4;\n  }\n  uVar3 \u003d param_2 \u0026 0xffffff | 0x800000;\n  if ((param_2 \u0026 0x80000000) !\u003d 0) {\n    uVar3 \u003d -uVar3;\n  }\n  if (uVar5 \u003d\u003d uVar6) {\n    uVar3 \u003d uVar3 ^ 0x800000;\n    if (uVar5 \u003d\u003d 0) {\n      uVar4 \u003d uVar4 ^ 0x800000;\n      uVar5 \u003d 1;\n    }\n    else {\n      uVar6 \u003d uVar6 - 1;\n    }\n  }\n  uVar4 \u003d uVar4 + ((int)uVar3 \u003e\u003e (uVar6 \u0026 0xff));\n  uVar3 \u003d uVar3 \u003c\u003c (0x20 - uVar6 \u0026 0xff);\n  param_1 \u003d uVar4 \u0026 0x80000000;\n  if ((int)uVar4 \u003c 0) {\n    bVar7 \u003d uVar3 !\u003d 0;\n    uVar3 \u003d -uVar3;\n    uVar4 \u003d -uVar4 - (uint)bVar7;\n  }\n  if (uVar4 \u003c 0x800000) {\n    uVar6 \u003d uVar3 \u0026 0x80000000;\n    uVar3 \u003d uVar3 \u003c\u003c 1;\n    uVar4 \u003d uVar4 * 2 + (uint)(uVar6 !\u003d 0);\n    uVar6 \u003d uVar5 - 2;\n    if (uVar5 - 1 \u003d\u003d 0 || uVar4 \u003c 0x800000) {\n      uVar5 \u003d LZCOUNT(uVar4) - 8;\n      uVar4 \u003d uVar4 \u003c\u003c (uVar5 \u0026 0xff);\n      if ((int)uVar6 \u003c (int)uVar5) {\n        uVar4 \u003d uVar4 \u003e\u003e (-(uVar6 - uVar5) \u0026 0xff);\n      }\n      else {\n        uVar4 \u003d uVar4 + (uVar6 - uVar5) * 0x800000;\n      }\n      return uVar4 | param_1;\n    }\n  }\n  else {\n    uVar6 \u003d uVar5 - 1;\n    if (0xffffff \u003c uVar4) {\n      uVar6 \u003d uVar4 \u0026 1;\n      uVar4 \u003d uVar4 \u003e\u003e 1;\n      uVar3 \u003d (uint)(uVar6 !\u003d 0) \u003c\u003c 0x1f | uVar3 \u003e\u003e 1;\n      uVar6 \u003d uVar5;\n      if (0xfd \u003c uVar5) goto LAB_08008e12;\n    }\n  }\n  uVar4 \u003d uVar4 + uVar6 * 0x800000 + (uint)(0x7fffffff \u003c uVar3);\n  if (uVar3 \u003d\u003d 0x80000000) {\n    uVar4 \u003d uVar4 \u0026 0xfffffffe;\n  }\n  return uVar4 | param_1;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line",
        "report_realtime_status",
        "plan_buffer_line",
        "printFloat",
        "__aeabi_frsub",
        "max_allowable_speed",
        "intersection_distance",
        "mc_arc",
        "estimate_acceleration_distance"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__floatunsisf": {
      "entrypoint": "0x08008e3c",
      "current_name": "__floatunsisf",
      "code": "\nuint __floatunsisf(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  \n  if (param_1 \u003d\u003d 0) {\n    return 0;\n  }\n  uVar1 \u003d LZCOUNT(param_1);\n  uVar2 \u003d uVar1 - 8;\n  iVar3 \u003d uVar2 * -0x800000 + 0x4a800000;\n  if (7 \u003c uVar1) {\n    uVar4 \u003d 0 \u003c\u003c (uVar2 \u0026 0xff);\n    uVar1 \u003d iVar3 + (param_1 \u003c\u003c (uVar2 \u0026 0xff)) +\n            (0U \u003e\u003e (0x20 - uVar2 \u0026 0xff)) + (uint)(0x7fffffff \u003c uVar4);\n    if (uVar4 \u003d\u003d 0x80000000) {\n      uVar1 \u003d uVar1 \u0026 0xfffffffe;\n    }\n    return uVar1;\n  }\n  uVar2 \u003d param_1 \u003c\u003c uVar1 + 0x18;\n  uVar1 \u003d iVar3 + ((param_1 \u003e\u003e (0x20 - (uVar1 + 0x18) \u0026 0xff)) - ((int)uVar2 \u003e\u003e 0x1f));\n  if ((uVar2 \u0026 0x7fffffff) \u003d\u003d 0) {\n    uVar1 \u003d uVar1 \u0026 ~(uVar2 \u003e\u003e 0x1f);\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "calculate_trapezoid_for_block",
        "read_float"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__floatsisf": {
      "entrypoint": "0x08008e44",
      "current_name": "__floatsisf",
      "code": "\nuint __floatsisf(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  \n  uVar3 \u003d param_1 \u0026 0x80000000;\n  if ((int)uVar3 \u003c 0) {\n    param_1 \u003d -param_1;\n  }\n  if (param_1 \u003d\u003d 0) {\n    return 0;\n  }\n  uVar1 \u003d LZCOUNT(param_1);\n  uVar2 \u003d uVar1 - 8;\n  iVar4 \u003d ((uVar3 | 0x4b000000) - 0x800000) + uVar2 * -0x800000;\n  if (7 \u003c uVar1) {\n    uVar1 \u003d 0 \u003c\u003c (uVar2 \u0026 0xff);\n    uVar3 \u003d iVar4 + (param_1 \u003c\u003c (uVar2 \u0026 0xff)) +\n            (0U \u003e\u003e (0x20 - uVar2 \u0026 0xff)) + (uint)(0x7fffffff \u003c uVar1);\n    if (uVar1 \u003d\u003d 0x80000000) {\n      uVar3 \u003d uVar3 \u0026 0xfffffffe;\n    }\n    return uVar3;\n  }\n  uVar2 \u003d param_1 \u003c\u003c uVar1 + 0x18;\n  uVar3 \u003d iVar4 + ((param_1 \u003e\u003e (0x20 - (uVar1 + 0x18) \u0026 0xff)) - ((int)uVar2 \u003e\u003e 0x1f));\n  if ((uVar2 \u0026 0x7fffffff) \u003d\u003d 0) {\n    uVar3 \u003d uVar3 \u0026 ~(uVar2 \u003e\u003e 0x1f);\n  }\n  return uVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "report_realtime_status",
        "plan_buffer_line",
        "plan_cycle_reinitialize",
        "gc_set_current_position",
        "calculate_trapezoid_for_block",
        "mc_dwell",
        "mc_arc",
        "mc_go_home"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_ul2f": {
      "entrypoint": "0x08008e60",
      "current_name": "__aeabi_ul2f",
      "code": "\nuint __aeabi_ul2f(uint param_1,uint param_2)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  \n  if ((param_1 | param_2) \u003d\u003d 0) {\n    return param_1;\n  }\n  uVar1 \u003d param_1;\n  uVar2 \u003d param_2;\n  if (param_2 \u003d\u003d 0) {\n    uVar1 \u003d 0;\n    uVar2 \u003d param_1;\n  }\n  iVar5 \u003d 0x5b000000;\n  if (param_2 \u003d\u003d 0) {\n    iVar5 \u003d 0x4b000000;\n  }\n  uVar3 \u003d LZCOUNT(uVar2);\n  uVar4 \u003d uVar3 - 8;\n  iVar5 \u003d iVar5 + -0x800000 + uVar4 * -0x800000;\n  if (uVar3 \u003c 8) {\n    uVar4 \u003d uVar2 \u003c\u003c uVar3 + 0x18;\n    uVar2 \u003d iVar5 + ((uVar2 \u003e\u003e (0x20 - (uVar3 + 0x18) \u0026 0xff)) - ((int)uVar4 \u003e\u003e 0x1f));\n    if ((uVar1 | uVar4 \u003c\u003c 1) \u003d\u003d 0) {\n      uVar2 \u003d uVar2 \u0026 ~(uVar4 \u003e\u003e 0x1f);\n    }\n    return uVar2;\n  }\n  uVar3 \u003d uVar1 \u003c\u003c (uVar4 \u0026 0xff);\n  uVar2 \u003d iVar5 + (uVar2 \u003c\u003c (uVar4 \u0026 0xff)) +\n          (uVar1 \u003e\u003e (0x20 - uVar4 \u0026 0xff)) + (uint)(0x7fffffff \u003c uVar3);\n  if (uVar3 \u003d\u003d 0x80000000) {\n    uVar2 \u003d uVar2 \u0026 0xfffffffe;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_l2f": {
      "entrypoint": "0x08008e70",
      "current_name": "__aeabi_l2f",
      "code": "\nuint __aeabi_l2f(uint param_1,uint param_2)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  bool bVar7;\n  \n  if ((param_1 | param_2) \u003d\u003d 0) {\n    return param_1;\n  }\n  uVar5 \u003d param_2 \u0026 0x80000000;\n  if ((int)uVar5 \u003c 0) {\n    bVar7 \u003d param_1 !\u003d 0;\n    param_1 \u003d -param_1;\n    param_2 \u003d -param_2 - (uint)bVar7;\n  }\n  uVar2 \u003d param_1;\n  uVar1 \u003d param_2;\n  if (param_2 \u003d\u003d 0) {\n    uVar2 \u003d 0;\n    uVar1 \u003d param_1;\n  }\n  uVar5 \u003d uVar5 | 0x5b000000;\n  if (param_2 \u003d\u003d 0) {\n    uVar5 \u003d uVar5 + 0xf0000000;\n  }\n  uVar3 \u003d LZCOUNT(uVar1);\n  uVar4 \u003d uVar3 - 8;\n  iVar6 \u003d (uVar5 - 0x800000) + uVar4 * -0x800000;\n  if (uVar3 \u003c 8) {\n    uVar4 \u003d uVar1 \u003c\u003c uVar3 + 0x18;\n    uVar5 \u003d iVar6 + ((uVar1 \u003e\u003e (0x20 - (uVar3 + 0x18) \u0026 0xff)) - ((int)uVar4 \u003e\u003e 0x1f));\n    if ((uVar2 | uVar4 \u003c\u003c 1) \u003d\u003d 0) {\n      uVar5 \u003d uVar5 \u0026 ~(uVar4 \u003e\u003e 0x1f);\n    }\n    return uVar5;\n  }\n  uVar3 \u003d uVar2 \u003c\u003c (uVar4 \u0026 0xff);\n  uVar5 \u003d iVar6 + (uVar1 \u003c\u003c (uVar4 \u0026 0xff)) +\n          (uVar2 \u003e\u003e (0x20 - uVar4 \u0026 0xff)) + (uint)(0x7fffffff \u003c uVar3);\n  if (uVar3 \u003d\u003d 0x80000000) {\n    uVar5 \u003d uVar5 \u0026 0xfffffffe;\n  }\n  return uVar5;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_fmul": {
      "entrypoint": "0x08008eec",
      "current_name": "__aeabi_fmul",
      "code": "\nuint __aeabi_fmul(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  longlong lVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  uint uVar8;\n  bool bVar9;\n  bool bVar10;\n  \n  uVar3 \u003d param_1 \u003e\u003e 0x17 \u0026 0xff;\n  bVar9 \u003d uVar3 \u003d\u003d 0;\n  if (!bVar9) {\n    param_4 \u003d param_2 \u003e\u003e 0x17 \u0026 0xff;\n    bVar9 \u003d param_4 \u003d\u003d 0;\n  }\n  if (!bVar9) {\n    bVar9 \u003d uVar3 \u003d\u003d 0xff;\n  }\n  if (!bVar9) {\n    bVar9 \u003d param_4 \u003d\u003d 0xff;\n  }\n  if (bVar9) {\n    param_4 \u003d param_2 \u003e\u003e 0x17 \u0026 0xff;\n    if (uVar3 \u003d\u003d 0xff || param_4 \u003d\u003d 0xff) {\n      bVar9 \u003d param_1 \u003d\u003d 0 || param_1 \u003d\u003d 0x80000000;\n      uVar2 \u003d param_2;\n      if (param_1 !\u003d 0 \u0026\u0026 param_1 !\u003d 0x80000000) {\n        bVar9 \u003d param_2 \u003d\u003d 0;\n        uVar2 \u003d param_1;\n      }\n      if (!bVar9) {\n        bVar9 \u003d param_2 \u003d\u003d 0x80000000;\n      }\n      uVar8 \u003d uVar2;\n      if (((bVar9) || ((uVar3 \u003d\u003d 0xff \u0026\u0026 ((uVar2 \u0026 0x7fffff) !\u003d 0)))) ||\n         ((param_4 \u003d\u003d 0xff \u0026\u0026 (uVar8 \u003d param_2, (param_2 \u0026 0x7fffff) !\u003d 0)))) {\n        return uVar8 | 0x7fc00000;\n      }\n      uVar2 \u003d uVar2 ^ param_2;\n      goto LAB_0800903c;\n    }\n    bVar9 \u003d (param_1 \u0026 0x7fffffff) \u003d\u003d 0;\n    if (!bVar9) {\n      bVar9 \u003d (param_2 \u0026 0x7fffffff) \u003d\u003d 0;\n    }\n    if (bVar9) {\n      return (param_1 ^ param_2) \u0026 0x80000000;\n    }\n    bVar9 \u003d uVar3 \u003d\u003d 0;\n    uVar2 \u003d param_1 \u0026 0x80000000;\n    while( true ) {\n      if (bVar9) {\n        param_1 \u003d param_1 \u003c\u003c 1;\n        bVar9 \u003d (param_1 \u0026 0x800000) \u003d\u003d 0;\n      }\n      if (!bVar9) break;\n      uVar3 \u003d uVar3 - 1;\n    }\n    param_1 \u003d param_1 | uVar2;\n    bVar9 \u003d param_4 \u003d\u003d 0;\n    uVar2 \u003d param_2 \u0026 0x80000000;\n    while( true ) {\n      if (bVar9) {\n        param_2 \u003d param_2 \u003c\u003c 1;\n        bVar9 \u003d (param_2 \u0026 0x800000) \u003d\u003d 0;\n      }\n      if (!bVar9) break;\n      param_4 \u003d param_4 - 1;\n    }\n    param_2 \u003d param_2 | uVar2;\n  }\n  iVar4 \u003d uVar3 + param_4;\n  uVar8 \u003d param_1 ^ param_2;\n  uVar3 \u003d param_1 \u003c\u003c 9;\n  bVar9 \u003d uVar3 \u003d\u003d 0;\n  if (!bVar9) {\n    param_2 \u003d param_2 \u003c\u003c 9;\n    bVar9 \u003d param_2 \u003d\u003d 0;\n  }\n  if (bVar9) {\n    if (uVar3 \u003d\u003d 0) {\n      param_2 \u003d param_2 \u003c\u003c 9;\n    }\n    uVar2 \u003d uVar8 \u0026 0x80000000 | param_1 \u0026 0x7fffff | param_2 \u003e\u003e 9;\n    bVar10 \u003d SBORROW4(iVar4,0x7f);\n    iVar5 \u003d iVar4 + -0x7f;\n    bVar9 \u003d iVar5 \u003d\u003d 0;\n    iVar7 \u003d iVar5;\n    if (!bVar9 \u0026\u0026 0x7e \u003c iVar4) {\n      bVar10 \u003d SBORROW4(0xff,iVar5);\n      iVar7 \u003d 0xff - iVar5;\n      bVar9 \u003d iVar5 \u003d\u003d 0xff;\n    }\n    if (!bVar9 \u0026\u0026 iVar7 \u003c 0 \u003d\u003d bVar10) {\n      uVar2 \u003d uVar2 | iVar5 * 0x800000;\n    }\n    if (!bVar9 \u0026\u0026 iVar7 \u003c 0 \u003d\u003d bVar10) {\n      return uVar2;\n    }\n    uVar2 \u003d uVar2 | 0x800000;\n    uVar6 \u003d 0;\n    bVar10 \u003d SBORROW4(iVar5,1);\n    uVar8 \u003d iVar4 - 0x80;\n    bVar9 \u003d uVar8 \u003d\u003d 0;\n    uVar3 \u003d uVar8;\n  }\n  else {\n    lVar1 \u003d (ulonglong)(uVar3 \u003e\u003e 5 | 0x8000000) * (ulonglong)(param_2 \u003e\u003e 5 | 0x8000000);\n    uVar6 \u003d (uint)lVar1;\n    uVar2 \u003d (uint)((ulonglong)lVar1 \u003e\u003e 0x20);\n    bVar9 \u003d uVar2 \u003c 0x800000;\n    if (bVar9) {\n      uVar2 \u003d uVar2 \u003c\u003c 1;\n    }\n    if (bVar9) {\n      uVar2 \u003d uVar2 | uVar6 \u003e\u003e 0x1f;\n      uVar6 \u003d uVar6 \u003c\u003c 1;\n    }\n    uVar2 \u003d uVar8 \u0026 0x80000000 | uVar2;\n    uVar8 \u003d (iVar4 + -0x7f) - (uint)bVar9;\n    bVar10 \u003d SBORROW4(uVar8,0xfd);\n    bVar9 \u003d uVar8 \u003d\u003d 0xfd;\n    uVar3 \u003d uVar8 - 0xfd;\n    if (uVar8 \u003c 0xfe) {\n      uVar2 \u003d uVar2 + uVar8 * 0x800000 + (uint)(0x7fffffff \u003c uVar6);\n      if (uVar6 \u003d\u003d 0x80000000) {\n        uVar2 \u003d uVar2 \u0026 0xfffffffe;\n      }\n      return uVar2;\n    }\n  }\n  if (bVar9 || (int)uVar3 \u003c 0 !\u003d bVar10) {\n    bVar9 \u003d (int)(uVar8 + 0x19) \u003c 0;\n    if (uVar8 \u003d\u003d 0xffffffe7 || bVar9 !\u003d SCARRY4(uVar8,0x19)) {\n      uVar2 \u003d uVar2 \u0026 0x80000000;\n    }\n    if (uVar8 !\u003d 0xffffffe7 \u0026\u0026 bVar9 \u003d\u003d SCARRY4(uVar8,0x19)) {\n      uVar3 \u003d (uVar2 \u003c\u003c 1) \u003e\u003e (-uVar8 \u0026 0xff);\n      uVar8 \u003d uVar2 \u003c\u003c (uVar8 + 0x20 \u0026 0xff);\n      uVar3 \u003d ((uint)((uVar2 \u0026 0x80000000) !\u003d 0) \u003c\u003c 0x1f | uVar3 \u003e\u003e 1) + (uint)((byte)uVar3 \u0026 1);\n      if ((uVar6 | uVar8 \u003c\u003c 1) \u003d\u003d 0) {\n        uVar3 \u003d uVar3 \u0026 ~(uVar8 \u003e\u003e 0x1f);\n      }\n      return uVar3;\n    }\n    return uVar2;\n  }\nLAB_0800903c:\n  return uVar2 \u0026 0x80000000 | 0x7f800000;\n}\n\n",
      "renaming": {},
      "calling": [
        "printFloat",
        "plan_cycle_reinitialize",
        "calculate_trapezoid_for_block",
        "homing_cycle",
        "mc_dwell",
        "read_float",
        "mc_arc",
        "estimate_acceleration_distance",
        "mc_go_home",
        "gc_execute_line",
        "plan_buffer_line",
        "settings_store_global_setting",
        "max_allowable_speed",
        "intersection_distance"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_fdiv": {
      "entrypoint": "0x08009054",
      "current_name": "__aeabi_fdiv",
      "code": "\nuint __aeabi_fdiv(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  bool bVar7;\n  bool bVar8;\n  bool bVar9;\n  \n  uVar2 \u003d param_1 \u003e\u003e 0x17 \u0026 0xff;\n  bVar7 \u003d uVar2 \u003d\u003d 0;\n  if (!bVar7) {\n    param_4 \u003d param_2 \u003e\u003e 0x17 \u0026 0xff;\n    bVar7 \u003d param_4 \u003d\u003d 0;\n  }\n  if (!bVar7) {\n    bVar7 \u003d uVar2 \u003d\u003d 0xff;\n  }\n  if (!bVar7) {\n    bVar7 \u003d param_4 \u003d\u003d 0xff;\n  }\n  if (bVar7) {\n    param_4 \u003d param_2 \u003e\u003e 0x17 \u0026 0xff;\n    uVar6 \u003d param_1;\n    if (uVar2 \u003d\u003d 0xff) {\n      if (((param_1 \u0026 0x7fffff) !\u003d 0) || (uVar6 \u003d param_2, param_4 \u003d\u003d 0xff)) {\nLAB_0800904a:\n        return uVar6 | 0x7fc00000;\n      }\n    }\n    else {\n      if (param_4 \u003d\u003d 0xff) {\n        uVar6 \u003d param_2;\n        if ((param_2 \u0026 0x7fffff) \u003d\u003d 0) {\nLAB_08009000:\n          return (param_1 ^ param_2) \u0026 0x80000000;\n        }\n        goto LAB_0800904a;\n      }\n      bVar7 \u003d (param_1 \u0026 0x7fffffff) \u003d\u003d 0;\n      if (!bVar7) {\n        bVar7 \u003d (param_2 \u0026 0x7fffffff) \u003d\u003d 0;\n      }\n      if (!bVar7) {\n        bVar7 \u003d uVar2 \u003d\u003d 0;\n        uVar6 \u003d param_1 \u0026 0x80000000;\n        while( true ) {\n          if (bVar7) {\n            param_1 \u003d param_1 \u003c\u003c 1;\n            bVar7 \u003d (param_1 \u0026 0x800000) \u003d\u003d 0;\n          }\n          if (!bVar7) break;\n          uVar2 \u003d uVar2 - 1;\n        }\n        param_1 \u003d param_1 | uVar6;\n        bVar7 \u003d param_4 \u003d\u003d 0;\n        uVar6 \u003d param_2 \u0026 0x80000000;\n        while( true ) {\n          if (bVar7) {\n            param_2 \u003d param_2 \u003c\u003c 1;\n            bVar7 \u003d (param_2 \u0026 0x800000) \u003d\u003d 0;\n          }\n          if (!bVar7) break;\n          param_4 \u003d param_4 - 1;\n        }\n        param_2 \u003d param_2 | uVar6;\n        goto LAB_0800906c;\n      }\n      if ((param_1 \u0026 0x7fffffff) \u003d\u003d 0) {\n        if ((param_2 \u0026 0x7fffffff) !\u003d 0) goto LAB_08009000;\n        goto LAB_0800904a;\n      }\n    }\n    param_1 \u003d param_1 ^ param_2;\n  }\n  else {\nLAB_0800906c:\n    iVar3 \u003d uVar2 - param_4;\n    if (param_2 \u003c\u003c 9 \u003d\u003d 0) {\n      param_1 \u003d (param_1 ^ param_2) \u0026 0x80000000 | param_1 \u0026 0x7fffff;\n      bVar9 \u003d SCARRY4(iVar3,0x7f);\n      iVar5 \u003d iVar3 + 0x7f;\n      bVar7 \u003d iVar5 \u003c 0;\n      bVar8 \u003d iVar5 \u003d\u003d 0;\n      if (!bVar8 \u0026\u0026 bVar7 \u003d\u003d bVar9) {\n        bVar9 \u003d SBORROW4(0xff,iVar5);\n        bVar7 \u003d 0xff - iVar5 \u003c 0;\n        bVar8 \u003d iVar5 \u003d\u003d 0xff;\n      }\n      if (!bVar8 \u0026\u0026 bVar7 \u003d\u003d bVar9) {\n        param_1 \u003d param_1 | iVar5 * 0x800000;\n      }\n      if (!bVar8 \u0026\u0026 bVar7 \u003d\u003d bVar9) {\n        return param_1;\n      }\n      param_1 \u003d param_1 | 0x800000;\n      uVar2 \u003d 0;\n      bVar8 \u003d SBORROW4(iVar5,1);\n      uVar4 \u003d iVar3 + 0x7e;\n      bVar7 \u003d uVar4 \u003d\u003d 0;\n      uVar6 \u003d uVar4;\n    }\n    else {\n      uVar1 \u003d (param_2 \u003c\u003c 9) \u003e\u003e 4 | 0x10000000;\n      uVar2 \u003d (param_1 \u003c\u003c 9) \u003e\u003e 4 | 0x10000000;\n      param_1 \u003d (param_1 ^ param_2) \u0026 0x80000000;\n      bVar7 \u003d uVar1 \u003c\u003d uVar2;\n      if (!bVar7) {\n        uVar2 \u003d uVar2 \u003c\u003c 1;\n      }\n      uVar4 \u003d iVar3 + 0x7d + (uint)bVar7;\n      uVar6 \u003d 0x800000;\n      do {\n        if (uVar1 \u003c\u003d uVar2) {\n          uVar2 \u003d uVar2 - uVar1;\n          param_1 \u003d param_1 | uVar6;\n        }\n        bVar7 \u003d uVar1 \u003e\u003e 1 \u003c\u003d uVar2;\n        if (bVar7) {\n          uVar2 \u003d uVar2 - (uVar1 \u003e\u003e 1);\n        }\n        if (bVar7) {\n          param_1 \u003d param_1 | uVar6 \u003e\u003e 1;\n        }\n        bVar7 \u003d uVar1 \u003e\u003e 2 \u003c\u003d uVar2;\n        if (bVar7) {\n          uVar2 \u003d uVar2 - (uVar1 \u003e\u003e 2);\n        }\n        if (bVar7) {\n          param_1 \u003d param_1 | uVar6 \u003e\u003e 2;\n        }\n        bVar7 \u003d uVar1 \u003e\u003e 3 \u003c\u003d uVar2;\n        if (bVar7) {\n          uVar2 \u003d uVar2 - (uVar1 \u003e\u003e 3);\n        }\n        if (bVar7) {\n          param_1 \u003d param_1 | uVar6 \u003e\u003e 3;\n        }\n        uVar2 \u003d uVar2 * 0x10;\n        bVar7 \u003d uVar2 \u003d\u003d 0;\n        if (!bVar7) {\n          uVar6 \u003d uVar6 \u003e\u003e 4;\n          bVar7 \u003d uVar6 \u003d\u003d 0;\n        }\n      } while (!bVar7);\n      bVar8 \u003d SBORROW4(uVar4,0xfd);\n      bVar7 \u003d uVar4 \u003d\u003d 0xfd;\n      uVar6 \u003d uVar4 - 0xfd;\n      if (uVar4 \u003c 0xfe) {\n        param_1 \u003d param_1 + uVar4 * 0x800000 + (uint)(uVar1 \u003c\u003d uVar2);\n        if (uVar2 - uVar1 \u003d\u003d 0) {\n          param_1 \u003d param_1 \u0026 0xfffffffe;\n        }\n        return param_1;\n      }\n    }\n    if (bVar7 || (int)uVar6 \u003c 0 !\u003d bVar8) {\n      bVar7 \u003d (int)(uVar4 + 0x19) \u003c 0;\n      if (uVar4 \u003d\u003d 0xffffffe7 || bVar7 !\u003d SCARRY4(uVar4,0x19)) {\n        param_1 \u003d param_1 \u0026 0x80000000;\n      }\n      if (uVar4 \u003d\u003d 0xffffffe7 || bVar7 !\u003d SCARRY4(uVar4,0x19)) {\n        return param_1;\n      }\n      uVar6 \u003d (param_1 \u003c\u003c 1) \u003e\u003e (-uVar4 \u0026 0xff);\n      uVar4 \u003d param_1 \u003c\u003c (uVar4 + 0x20 \u0026 0xff);\n      uVar6 \u003d ((uint)((param_1 \u0026 0x80000000) !\u003d 0) \u003c\u003c 0x1f | uVar6 \u003e\u003e 1) + (uint)((byte)uVar6 \u0026 1);\n      if ((uVar2 | uVar4 \u003c\u003c 1) \u003d\u003d 0) {\n        uVar6 \u003d uVar6 \u0026 ~(uVar4 \u003e\u003e 0x1f);\n      }\n      return uVar6;\n    }\n  }\n  return param_1 \u0026 0x80000000 | 0x7f800000;\n}\n\n",
      "renaming": {},
      "calling": [
        "report_realtime_status",
        "plan_buffer_line",
        "plan_cycle_reinitialize",
        "gc_set_current_position",
        "planner_recalculate_trapezoids",
        "intersection_distance",
        "homing_cycle",
        "mc_arc",
        "estimate_acceleration_distance",
        "report_grbl_settings"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__gesf2": {
      "entrypoint": "0x0800918c",
      "current_name": "__gesf2",
      "code": "\nuint __gesf2(uint param_1,uint param_2)\n\n{\n  bool bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  bool bVar5;\n  \n  uVar2 \u003d param_1 * 2;\n  uVar3 \u003d param_2 * 2;\n  if (((int)uVar2 \u003e\u003e 0x18 \u003d\u003d -1 || (int)uVar3 \u003e\u003e 0x18 \u003d\u003d -1) \u0026\u0026\n     ((((int)uVar2 \u003e\u003e 0x18 \u003d\u003d -1 \u0026\u0026 ((param_1 \u0026 0x7fffff) !\u003d 0)) ||\n      (((int)uVar3 \u003e\u003e 0x18 \u003d\u003d -1 \u0026\u0026 ((param_2 \u0026 0x7fffff) !\u003d 0)))))) {\n    return 0xffffffff;\n  }\n  uVar4 \u003d uVar2 | param_2 \u0026 0x7fffffff;\n  bVar5 \u003d uVar4 \u003d\u003d 0;\n  if (!bVar5) {\n    uVar4 \u003d param_1 ^ param_2;\n    bVar5 \u003d uVar4 \u003d\u003d 0;\n  }\n  bVar1 \u003d -1 \u003c (int)uVar4;\n  if (bVar1) {\n    param_1 \u003d uVar2 + param_2 * -2;\n    bVar5 \u003d param_1 \u003d\u003d 0;\n  }\n  if ((bVar1 \u0026\u0026 uVar3 \u003c\u003d uVar2) \u0026\u0026 !bVar5) {\n    param_1 \u003d (int)param_2 \u003e\u003e 0x1f;\n  }\n  if (!bVar1 || uVar3 \u003e uVar2) {\n    param_1 \u003d ~((int)param_2 \u003e\u003e 0x1f);\n  }\n  if (!bVar5) {\n    param_1 \u003d param_1 | 1;\n  }\n  return param_1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__ltsf2": {
      "entrypoint": "0x08009194",
      "current_name": "__ltsf2",
      "code": "\nuint __ltsf2(uint param_1,uint param_2)\n\n{\n  bool bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  bool bVar5;\n  \n  uVar2 \u003d param_1 * 2;\n  uVar3 \u003d param_2 * 2;\n  if (((int)uVar2 \u003e\u003e 0x18 \u003d\u003d -1 || (int)uVar3 \u003e\u003e 0x18 \u003d\u003d -1) \u0026\u0026\n     ((((int)uVar2 \u003e\u003e 0x18 \u003d\u003d -1 \u0026\u0026 ((param_1 \u0026 0x7fffff) !\u003d 0)) ||\n      (((int)uVar3 \u003e\u003e 0x18 \u003d\u003d -1 \u0026\u0026 ((param_2 \u0026 0x7fffff) !\u003d 0)))))) {\n    return 1;\n  }\n  uVar4 \u003d uVar2 | param_2 \u0026 0x7fffffff;\n  bVar5 \u003d uVar4 \u003d\u003d 0;\n  if (!bVar5) {\n    uVar4 \u003d param_1 ^ param_2;\n    bVar5 \u003d uVar4 \u003d\u003d 0;\n  }\n  bVar1 \u003d -1 \u003c (int)uVar4;\n  if (bVar1) {\n    param_1 \u003d uVar2 + param_2 * -2;\n    bVar5 \u003d param_1 \u003d\u003d 0;\n  }\n  if ((bVar1 \u0026\u0026 uVar3 \u003c\u003d uVar2) \u0026\u0026 !bVar5) {\n    param_1 \u003d (int)param_2 \u003e\u003e 0x1f;\n  }\n  if (!bVar1 || uVar3 \u003e uVar2) {\n    param_1 \u003d ~((int)param_2 \u003e\u003e 0x1f);\n  }\n  if (!bVar5) {\n    param_1 \u003d param_1 | 1;\n  }\n  return param_1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__cmpsf2": {
      "entrypoint": "0x0800919c",
      "current_name": "__cmpsf2",
      "code": "\nuint __cmpsf2(uint param_1,uint param_2)\n\n{\n  bool bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  bool bVar5;\n  \n  uVar2 \u003d param_1 * 2;\n  uVar3 \u003d param_2 * 2;\n  if (((int)uVar2 \u003e\u003e 0x18 \u003d\u003d -1 || (int)uVar3 \u003e\u003e 0x18 \u003d\u003d -1) \u0026\u0026\n     ((((int)uVar2 \u003e\u003e 0x18 \u003d\u003d -1 \u0026\u0026 ((param_1 \u0026 0x7fffff) !\u003d 0)) ||\n      (((int)uVar3 \u003e\u003e 0x18 \u003d\u003d -1 \u0026\u0026 ((param_2 \u0026 0x7fffff) !\u003d 0)))))) {\n    return 1;\n  }\n  uVar4 \u003d uVar2 | param_2 \u0026 0x7fffffff;\n  bVar5 \u003d uVar4 \u003d\u003d 0;\n  if (!bVar5) {\n    uVar4 \u003d param_1 ^ param_2;\n    bVar5 \u003d uVar4 \u003d\u003d 0;\n  }\n  bVar1 \u003d -1 \u003c (int)uVar4;\n  if (bVar1) {\n    param_1 \u003d uVar2 + param_2 * -2;\n    bVar5 \u003d param_1 \u003d\u003d 0;\n  }\n  if ((bVar1 \u0026\u0026 uVar3 \u003c\u003d uVar2) \u0026\u0026 !bVar5) {\n    param_1 \u003d (int)param_2 \u003e\u003e 0x1f;\n  }\n  if (!bVar1 || uVar3 \u003e uVar2) {\n    param_1 \u003d ~((int)param_2 \u003e\u003e 0x1f);\n  }\n  if (!bVar5) {\n    param_1 \u003d param_1 | 1;\n  }\n  return param_1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_cfcmpeq"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_cfrcmple": {
      "entrypoint": "0x080091fc",
      "current_name": "__aeabi_cfrcmple",
      "code": "\nvoid __aeabi_cfrcmple(undefined4 param_1,undefined4 param_2)\n\n{\n  __aeabi_cfcmpeq(param_2,param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_fcmpgt",
        "__aeabi_fcmpge"
      ],
      "called": [
        "__aeabi_cfcmpeq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_cfcmpeq": {
      "entrypoint": "0x08009204",
      "current_name": "__aeabi_cfcmpeq",
      "code": "\nundefined8 __aeabi_cfcmpeq(undefined4 param_1,undefined4 param_2)\n\n{\n  __cmpsf2();\n  return CONCAT44(param_2,param_1);\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_fcmpeq",
        "__aeabi_fcmple",
        "__aeabi_fcmplt",
        "__aeabi_cfrcmple"
      ],
      "called": [
        "__cmpsf2"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_fcmpeq": {
      "entrypoint": "0x08009214",
      "current_name": "__aeabi_fcmpeq",
      "code": "\nbool __aeabi_fcmpeq(void)\n\n{\n  char in_ZR;\n  \n  __aeabi_cfcmpeq();\n  return in_ZR !\u003d \u0027\\0\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line",
        "settings_store_global_setting",
        "read_float",
        "mc_arc",
        "planner_forward_pass_kernel",
        "planner_reverse_pass_kernel"
      ],
      "called": [
        "__aeabi_cfcmpeq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_fcmplt": {
      "entrypoint": "0x08009228",
      "current_name": "__aeabi_fcmplt",
      "code": "\nbool __aeabi_fcmplt(void)\n\n{\n  char in_CY;\n  \n  __aeabi_cfcmpeq();\n  return in_CY \u003d\u003d \u0027\\0\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line",
        "plan_buffer_line",
        "printFloat",
        "settings_store_global_setting",
        "planner_forward_pass_kernel",
        "planner_reverse_pass_kernel"
      ],
      "called": [
        "__aeabi_cfcmpeq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_fcmple": {
      "entrypoint": "0x0800923c",
      "current_name": "__aeabi_fcmple",
      "code": "\nbool __aeabi_fcmple(void)\n\n{\n  undefined in_ZR;\n  undefined in_CY;\n  \n  __aeabi_cfcmpeq();\n  return !(bool)in_CY || (bool)in_ZR;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line",
        "settings_store_global_setting",
        "mc_arc"
      ],
      "called": [
        "__aeabi_cfcmpeq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_fcmpge": {
      "entrypoint": "0x08009250",
      "current_name": "__aeabi_fcmpge",
      "code": "\nbool __aeabi_fcmpge(void)\n\n{\n  undefined in_ZR;\n  undefined in_CY;\n  \n  __aeabi_cfrcmple();\n  return !(bool)in_CY || (bool)in_ZR;\n}\n\n",
      "renaming": {},
      "calling": [
        "plan_buffer_line",
        "mc_arc"
      ],
      "called": [
        "__aeabi_cfrcmple"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_fcmpgt": {
      "entrypoint": "0x08009264",
      "current_name": "__aeabi_fcmpgt",
      "code": "\nbool __aeabi_fcmpgt(void)\n\n{\n  char in_CY;\n  \n  __aeabi_cfrcmple();\n  return in_CY \u003d\u003d \u0027\\0\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "plan_buffer_line",
        "planner_reverse_pass_kernel"
      ],
      "called": [
        "__aeabi_cfrcmple"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_f2iz": {
      "entrypoint": "0x08009278",
      "current_name": "__aeabi_f2iz",
      "code": "\nuint __aeabi_f2iz(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  if (param_1 \u003c\u003c 1 \u003c 0x7f000000) {\n    return 0;\n  }\n  uVar1 \u003d (param_1 \u003c\u003c 1) \u003e\u003e 0x18;\n  uVar2 \u003d 0x9e - uVar1;\n  if (uVar1 \u003c 0x9f \u0026\u0026 uVar2 !\u003d 0) {\n    uVar1 \u003d (param_1 \u003c\u003c 8 | 0x80000000) \u003e\u003e (uVar2 \u0026 0xff);\n    if ((param_1 \u0026 0x80000000) !\u003d 0) {\n      uVar1 \u003d -uVar1;\n    }\n    return uVar1;\n  }\n  if ((uVar2 \u003d\u003d 0xffffff9f) \u0026\u0026 ((param_1 \u0026 0x7fffff) !\u003d 0)) {\n    return 0;\n  }\n  param_1 \u003d param_1 \u0026 0x80000000;\n  if (param_1 \u003d\u003d 0) {\n    param_1 \u003d 0x7fffffff;\n  }\n  return param_1;\n}\n\n",
      "renaming": {},
      "calling": [
        "printFloat",
        "protocol_execute_line"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "Reset_Handler": {
      "entrypoint": "0x080092c4",
      "current_name": "Reset_Handler",
      "code": "\n/* WARNING: This function may have set the stack pointer */\n\nvoid Reset_Handler(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  code *UNRECOVERED_JUMPTABLE;\n  \n  for (iVar1 \u003d 0; (undefined4 *)(iVar1 + 0x20000000) \u003c \u0026completed_8911; iVar1 \u003d iVar1 + 4) {\n    *(undefined4 *)(iVar1 + 0x20000000) \u003d *(undefined4 *)(\u0026__fini_array_end + iVar1);\n  }\n  for (puVar2 \u003d \u0026completed_8911; puVar2 \u003c \u0026_ebss; puVar2 \u003d puVar2 + 1) {\n    *puVar2 \u003d 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  UNRECOVERED_JUMPTABLE \u003d (code *)0x80092fa;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x080092fa. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "main",
        "__libc_init_array",
        "SystemInit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "DMA1_Stream3_IRQHandler": {
      "entrypoint": "0x08009314",
      "current_name": "DMA1_Stream3_IRQHandler",
      "code": "\nvoid DMA1_Stream3_IRQHandler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "DMA1_Stream3_IRQHandler"
      ],
      "called": [
        "DMA1_Stream3_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ceil": {
      "entrypoint": "0x08009318",
      "current_name": "ceil",
      "code": "\ndouble ceil(double __x)\n\n{\n  uint in_r0;\n  uint in_r1;\n  uint uVar1;\n  uint uVar2;\n  double in_d0;\n  double extraout_d0;\n  double extraout_d0_00;\n  double extraout_d0_01;\n  undefined8 uVar3;\n  \n  uVar2 \u003d (in_r1 \u003c\u003c 1) \u003e\u003e 0x15;\n  uVar1 \u003d uVar2 - 0x3ff;\n  if ((int)uVar1 \u003c 0x14) {\n    if ((int)uVar1 \u003c 0) {\n      uVar3 \u003d __aeabi_dadd(in_r0,in_r1,0x8800759c,0x7e37e43c);\n      __aeabi_dcmpgt((int)uVar3,(int)((ulonglong)uVar3 \u003e\u003e 0x20),0,0);\n      in_d0 \u003d extraout_d0_00;\n    }\n    else if ((in_r1 \u0026 0xfffff \u003e\u003e (uVar1 \u0026 0xff) | in_r0) !\u003d 0) {\n      uVar3 \u003d __aeabi_dadd(in_r0,in_r1,0x8800759c,0x7e37e43c);\n      __aeabi_dcmpgt((int)uVar3,(int)((ulonglong)uVar3 \u003e\u003e 0x20),0,0);\n      in_d0 \u003d extraout_d0;\n    }\n  }\n  else if ((int)uVar1 \u003c 0x34) {\n    if ((0xffffffffU \u003e\u003e (uVar2 - 0x413 \u0026 0xff) \u0026 in_r0) !\u003d 0) {\n      uVar3 \u003d __aeabi_dadd(in_r0,in_r1,0x8800759c,0x7e37e43c);\n      __aeabi_dcmpgt((int)uVar3,(int)((ulonglong)uVar3 \u003e\u003e 0x20),0,0);\n      in_d0 \u003d extraout_d0_01;\n    }\n  }\n  else if (uVar1 \u003d\u003d 0x400) {\n    in_d0 \u003d (double)__aeabi_dadd();\n  }\n  return in_d0;\n}\n\n",
      "renaming": {},
      "calling": [
        "plan_buffer_line",
        "calculate_trapezoid_for_block",
        "homing_cycle"
      ],
      "called": [
        "__aeabi_dcmpgt",
        "__aeabi_dadd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "cos": {
      "entrypoint": "0x08009410",
      "current_name": "cos",
      "code": "\ndouble cos(double __x)\n\n{\n  undefined4 in_r0;\n  uint uVar1;\n  uint in_r1;\n  double dVar2;\n  undefined4 local_28;\n  undefined4 uStack_24;\n  undefined4 local_20;\n  undefined4 uStack_1c;\n  \n  if (0x3fe921fb \u003c (in_r1 \u0026 0x7fffffff)) {\n    if ((in_r1 \u0026 0x7fffffff) \u003c 0x7ff00000) {\n      uVar1 \u003d __ieee754_rem_pio2(in_r0,in_r1,\u0026local_28);\n      uVar1 \u003d uVar1 \u0026 3;\n      if (uVar1 \u003d\u003d 1) {\n        dVar2 \u003d (double)__kernel_sin(local_28,uStack_24,local_20,uStack_1c,1);\n      }\n      else if (uVar1 \u003d\u003d 2) {\n        dVar2 \u003d (double)__kernel_cos(local_28,uStack_24,local_20,uStack_1c);\n      }\n      else if (uVar1 \u003d\u003d 0) {\n        dVar2 \u003d (double)__kernel_cos(local_28,uStack_24,local_20,uStack_1c);\n      }\n      else {\n        dVar2 \u003d (double)__kernel_sin(local_28,uStack_24,local_20,uStack_1c,1);\n      }\n    }\n    else {\n      dVar2 \u003d (double)__subdf3();\n    }\n    return dVar2;\n  }\n  dVar2 \u003d (double)__kernel_cos(in_r0,in_r1,0,0);\n  return dVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "mc_arc"
      ],
      "called": [
        "__kernel_sin",
        "__ieee754_rem_pio2",
        "__kernel_cos",
        "__subdf3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "floor": {
      "entrypoint": "0x080094c0",
      "current_name": "floor",
      "code": "\ndouble floor(double __x)\n\n{\n  uint in_r0;\n  uint in_r1;\n  uint uVar1;\n  uint uVar2;\n  double in_d0;\n  double extraout_d0;\n  double extraout_d0_00;\n  double extraout_d0_01;\n  undefined8 uVar3;\n  \n  uVar2 \u003d (in_r1 \u003c\u003c 1) \u003e\u003e 0x15;\n  uVar1 \u003d uVar2 - 0x3ff;\n  if ((int)uVar1 \u003c 0x14) {\n    if ((int)uVar1 \u003c 0) {\n      uVar3 \u003d __aeabi_dadd(in_r0,in_r1,0x8800759c,0x7e37e43c);\n      __aeabi_dcmpgt((int)uVar3,(int)((ulonglong)uVar3 \u003e\u003e 0x20),0,0);\n      in_d0 \u003d extraout_d0_01;\n    }\n    else if ((in_r1 \u0026 0xfffff \u003e\u003e (uVar1 \u0026 0xff) | in_r0) !\u003d 0) {\n      uVar3 \u003d __aeabi_dadd(in_r0,in_r1,0x8800759c,0x7e37e43c);\n      __aeabi_dcmpgt((int)uVar3,(int)((ulonglong)uVar3 \u003e\u003e 0x20),0,0);\n      in_d0 \u003d extraout_d0;\n    }\n  }\n  else if ((int)uVar1 \u003c 0x34) {\n    if ((0xffffffffU \u003e\u003e (uVar2 - 0x413 \u0026 0xff) \u0026 in_r0) !\u003d 0) {\n      uVar3 \u003d __aeabi_dadd(in_r0,in_r1,0x8800759c,0x7e37e43c);\n      __aeabi_dcmpgt((int)uVar3,(int)((ulonglong)uVar3 \u003e\u003e 0x20),0,0);\n      in_d0 \u003d extraout_d0_00;\n    }\n  }\n  else if (uVar1 \u003d\u003d 0x400) {\n    in_d0 \u003d (double)__aeabi_dadd();\n  }\n  return in_d0;\n}\n\n",
      "renaming": {},
      "calling": [
        "calculate_trapezoid_for_block",
        "mc_dwell",
        "mc_arc",
        "__kernel_rem_pio2"
      ],
      "called": [
        "__aeabi_dcmpgt",
        "__aeabi_dadd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "lround": {
      "entrypoint": "0x080095b8",
      "current_name": "lround",
      "code": "\nlong lround(double __x)\n\n{\n  uint in_r0;\n  uint in_r1;\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  long lVar4;\n  uint uVar5;\n  \n  uVar2 \u003d (in_r1 \u003c\u003c 1) \u003e\u003e 0x15;\n  uVar5 \u003d uVar2 - 0x3ff;\n  if ((int)in_r1 \u003c 0) {\n    lVar4 \u003d -1;\n  }\n  else {\n    lVar4 \u003d 1;\n  }\n  uVar3 \u003d in_r1 \u0026 0xfffff | 0x100000;\n  if ((int)uVar5 \u003c 0x14) {\n    if ((int)uVar5 \u003c 0) {\n      if (uVar5 !\u003d 0xffffffff) {\n        lVar4 \u003d 0;\n      }\n      return lVar4;\n    }\n    uVar3 \u003d uVar3 + (0x80000 \u003e\u003e (uVar5 \u0026 0xff)) \u003e\u003e (0x14 - uVar5 \u0026 0xff);\n  }\n  else {\n    if (0x1e \u003c uVar5) {\n      lVar4 \u003d __aeabi_d2iz();\n      return lVar4;\n    }\n    if ((int)uVar5 \u003c 0x34) {\n      uVar1 \u003d 0x80000000 \u003e\u003e (uVar2 - 0x413 \u0026 0xff);\n      if (CARRY4(uVar1,in_r0) !\u003d false) {\n        uVar3 \u003d uVar3 + 1;\n      }\n      uVar3 \u003d uVar3 \u003c\u003c (uVar2 - 0x413 \u0026 0xff);\n      if (uVar5 !\u003d 0x14) {\n        uVar3 \u003d uVar3 | uVar1 + in_r0 \u003e\u003e (0x34 - uVar5 \u0026 0xff);\n      }\n    }\n    else {\n      uVar3 \u003d uVar3 \u003c\u003c (uVar2 - 0x413 \u0026 0xff) | in_r0 \u003c\u003c (uVar2 - 0x433 \u0026 0xff);\n    }\n  }\n  return uVar3 * lVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "plan_buffer_line",
        "homing_cycle"
      ],
      "called": [
        "__aeabi_d2iz"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "round": {
      "entrypoint": "0x08009654",
      "current_name": "round",
      "code": "\ndouble round(double __x)\n\n{\n  int in_r1;\n  int iVar1;\n  double in_d0;\n  \n  iVar1 \u003d ((uint)(in_r1 \u003c\u003c 1) \u003e\u003e 0x15) - 0x3ff;\n  if (((0x13 \u003c iVar1) \u0026\u0026 (0x33 \u003c iVar1)) \u0026\u0026 (iVar1 \u003d\u003d 0x400)) {\n    in_d0 \u003d (double)__aeabi_dadd();\n  }\n  return in_d0;\n}\n\n",
      "renaming": {},
      "calling": [
        "settings_store_global_setting"
      ],
      "called": [
        "__aeabi_dadd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sin": {
      "entrypoint": "0x080096e8",
      "current_name": "sin",
      "code": "\ndouble sin(double __x)\n\n{\n  undefined4 in_r0;\n  uint uVar1;\n  uint in_r1;\n  double dVar2;\n  undefined4 local_28;\n  undefined4 uStack_24;\n  undefined4 local_20;\n  undefined4 uStack_1c;\n  \n  if (0x3fe921fb \u003c (in_r1 \u0026 0x7fffffff)) {\n    if ((in_r1 \u0026 0x7fffffff) \u003c 0x7ff00000) {\n      uVar1 \u003d __ieee754_rem_pio2(in_r0,in_r1,\u0026local_28);\n      uVar1 \u003d uVar1 \u0026 3;\n      if (uVar1 \u003d\u003d 1) {\n        dVar2 \u003d (double)__kernel_cos(local_28,uStack_24,local_20,uStack_1c);\n      }\n      else if (uVar1 \u003d\u003d 2) {\n        dVar2 \u003d (double)__kernel_sin(local_28,uStack_24,local_20,uStack_1c,1);\n      }\n      else if (uVar1 \u003d\u003d 0) {\n        dVar2 \u003d (double)__kernel_sin(local_28,uStack_24,local_20,uStack_1c,1);\n      }\n      else {\n        dVar2 \u003d (double)__kernel_cos(local_28,uStack_24,local_20,uStack_1c);\n      }\n    }\n    else {\n      dVar2 \u003d (double)__subdf3();\n    }\n    return dVar2;\n  }\n  dVar2 \u003d (double)__kernel_sin(in_r0,in_r1,0,0,0);\n  return dVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "mc_arc"
      ],
      "called": [
        "__ieee754_rem_pio2",
        "__kernel_sin",
        "__kernel_cos",
        "__subdf3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "trunc": {
      "entrypoint": "0x08009798",
      "current_name": "trunc",
      "code": "\ndouble trunc(double __x)\n\n{\n  int in_r1;\n  int iVar1;\n  double in_d0;\n  \n  iVar1 \u003d ((uint)(in_r1 \u003c\u003c 1) \u003e\u003e 0x15) - 0x3ff;\n  if (iVar1 \u003c 0x14) {\n    if (iVar1 \u003c 0) {\n      return in_d0;\n    }\n  }\n  else {\n    if (iVar1 \u003c 0x34) {\n      return in_d0;\n    }\n    if (iVar1 !\u003d 0x400) {\n      return in_d0;\n    }\n    in_d0 \u003d (double)__aeabi_dadd();\n  }\n  return in_d0;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line",
        "protocol_execute_line",
        "settings_store_global_setting"
      ],
      "called": [
        "__aeabi_dadd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "atan2": {
      "entrypoint": "0x08009818",
      "current_name": "atan2",
      "code": "\nvoid atan2(uint param_1,uint param_2,uint param_3,uint param_4,double param_5)\n\n{\n  int iVar1;\n  undefined4 unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  \n  uVar3 \u003d param_4 \u0026 0x7fffffff;\n  if (((uVar3 | (-param_3 | param_3) \u003e\u003e 0x1f) \u003c 0x7ff00001) \u0026\u0026\n     (uVar4 \u003d param_2 \u0026 0x7fffffff, (uVar4 | (-param_1 | param_1) \u003e\u003e 0x1f) \u003c 0x7ff00001)) {\n    if ((param_4 + 0xc0100000 | param_3) \u003d\u003d 0) {\n      atan(param_5);\n      return;\n    }\n    uVar2 \u003d (int)param_4 \u003e\u003e 0x1e \u0026 2U | param_2 \u003e\u003e 0x1f;\n    if (((((uVar4 | param_1) !\u003d 0) \u0026\u0026 ((uVar3 | param_3) !\u003d 0)) \u0026\u0026 (uVar3 !\u003d 0x7ff00000)) \u0026\u0026\n       (uVar4 !\u003d 0x7ff00000)) {\n      iVar1 \u003d (int)(uVar4 - uVar3) \u003e\u003e 0x14;\n      if (((int)(uVar4 - uVar3) \u003c 0x3d00000) \u0026\u0026\n         ((-1 \u003c (int)param_4 || (iVar1 + 0x3c \u003c 0 \u003d\u003d SCARRY4(iVar1,0x3c))))) {\n        __divdf3(param_1,param_2,param_3,param_4);\n        fabs((double)CONCAT44(unaff_r4,param_4));\n        atan((double)CONCAT44(unaff_r4,param_4));\n      }\n      if (uVar2 !\u003d 1) {\n        if (uVar2 \u003d\u003d 2) {\n          uVar5 \u003d __subdf3();\n          __subdf3(0x54442d18,0x400921fb,(int)uVar5,(int)((ulonglong)uVar5 \u003e\u003e 0x20));\n        }\n        else if (uVar2 !\u003d 0) {\n          uVar5 \u003d __subdf3();\n          __subdf3((int)uVar5,(int)((ulonglong)uVar5 \u003e\u003e 0x20),0x54442d18,0x400921fb);\n        }\n      }\n    }\n  }\n  else {\n    __aeabi_dadd(param_3,param_4,param_1,param_2);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "mc_arc"
      ],
      "called": [
        "__ieee754_atan2"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "hypot": {
      "entrypoint": "0x0800981c",
      "current_name": "hypot",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x080098b6) */\n\ndouble hypot(double __x,double __y)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  double dVar3;\n  double extraout_d0;\n  double extraout_d0_00;\n  double extraout_d0_01;\n  double extraout_d0_02;\n  double extraout_d0_03;\n  int in_stack_ffffffb0;\n  char *in_stack_ffffffb4;\n  \n  dVar3 \u003d (double)__ieee754_hypot();\n  if ((((__fdlib_version !\u003d -1) \u0026\u0026\n       (iVar1 \u003d finite((double)CONCAT44(in_stack_ffffffb4,in_stack_ffffffb0)), dVar3 \u003d extraout_d0,\n       iVar1 \u003d\u003d 0)) \u0026\u0026\n      (iVar1 \u003d finite((double)CONCAT44(in_stack_ffffffb4,in_stack_ffffffb0)), dVar3 \u003d extraout_d0_00\n      , iVar1 !\u003d 0)) \u0026\u0026\n     ((iVar1 \u003d finite((double)CONCAT44(in_stack_ffffffb4,in_stack_ffffffb0)), dVar3 \u003d extraout_d0_01\n      , iVar1 !\u003d 0 \u0026\u0026\n      (((__fdlib_version !\u003d \u0027\\0\u0027 \u0026\u0026 (__fdlib_version \u003d\u003d \u0027\\x02\u0027)) ||\n       (iVar1 \u003d matherr((exception *)\u0026stack0xffffffb0), dVar3 \u003d extraout_d0_03, iVar1 \u003d\u003d 0)))))) {\n    puVar2 \u003d (undefined4 *)__errno();\n    *puVar2 \u003d 0x22;\n    dVar3 \u003d extraout_d0_02;\n  }\n  return dVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line",
        "mc_arc"
      ],
      "called": [
        "__ieee754_hypot",
        "matherr",
        "finite",
        "__errno"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sqrt": {
      "entrypoint": "0x080098d0",
      "current_name": "sqrt",
      "code": "\ndouble sqrt(double __x)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined4 *puVar3;\n  int *piVar4;\n  double dVar5;\n  double extraout_d0;\n  double extraout_d0_00;\n  double extraout_d0_01;\n  double extraout_d0_02;\n  double extraout_d0_03;\n  undefined local_50 [24];\n  undefined8 local_38;\n  int local_30;\n  \n  dVar5 \u003d (double)__ieee754_sqrt();\n  cVar1 \u003d __fdlib_version;\n  if (((__fdlib_version \u003d\u003d -1) || (local_30 \u003d __unorddf2(), dVar5 \u003d extraout_d0, local_30 !\u003d 0)) ||\n     (iVar2 \u003d __aeabi_dcmplt(), dVar5 \u003d extraout_d0_00, iVar2 \u003d\u003d 0)) {\n    return dVar5;\n  }\n  local_50._0_4_ \u003d 1;\n  local_50._4_4_ \u003d \"sqrt\";\n  if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n    local_38 \u003d 0.0;\nLAB_0800996c:\n    iVar2 \u003d matherr((exception *)local_50);\n    dVar5 \u003d extraout_d0_02;\n    if (iVar2 !\u003d 0) goto joined_r0x0800997a;\n  }\n  else {\n    local_38 \u003d (double)__divdf3(0,0,0,0);\n    if (cVar1 !\u003d \u0027\\x02\u0027) goto LAB_0800996c;\n  }\n  puVar3 \u003d (undefined4 *)__errno();\n  *puVar3 \u003d 0x21;\n  dVar5 \u003d extraout_d0_01;\njoined_r0x0800997a:\n  if (local_30 !\u003d 0) {\n    piVar4 \u003d (int *)__errno();\n    *piVar4 \u003d local_30;\n    dVar5 \u003d extraout_d0_03;\n  }\n  return dVar5;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line",
        "plan_buffer_line",
        "max_allowable_speed",
        "homing_cycle"
      ],
      "called": [
        "__divdf3",
        "__unorddf2",
        "matherr",
        "__ieee754_sqrt",
        "__aeabi_dcmplt",
        "__errno"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__ieee754_atan2": {
      "entrypoint": "0x08009990",
      "current_name": "__ieee754_atan2",
      "code": "\nvoid __ieee754_atan2(uint param_1,uint param_2,uint param_3,uint param_4,double param_5)\n\n{\n  int iVar1;\n  undefined4 unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  \n  uVar3 \u003d param_4 \u0026 0x7fffffff;\n  if (((uVar3 | (-param_3 | param_3) \u003e\u003e 0x1f) \u003c 0x7ff00001) \u0026\u0026\n     (uVar4 \u003d param_2 \u0026 0x7fffffff, (uVar4 | (-param_1 | param_1) \u003e\u003e 0x1f) \u003c 0x7ff00001)) {\n    if ((param_4 + 0xc0100000 | param_3) \u003d\u003d 0) {\n      atan(param_5);\n      return;\n    }\n    uVar2 \u003d (int)param_4 \u003e\u003e 0x1e \u0026 2U | param_2 \u003e\u003e 0x1f;\n    if (((((uVar4 | param_1) !\u003d 0) \u0026\u0026 ((uVar3 | param_3) !\u003d 0)) \u0026\u0026 (uVar3 !\u003d 0x7ff00000)) \u0026\u0026\n       (uVar4 !\u003d 0x7ff00000)) {\n      iVar1 \u003d (int)(uVar4 - uVar3) \u003e\u003e 0x14;\n      if (((int)(uVar4 - uVar3) \u003c 0x3d00000) \u0026\u0026\n         ((-1 \u003c (int)param_4 || (iVar1 + 0x3c \u003c 0 \u003d\u003d SCARRY4(iVar1,0x3c))))) {\n        __divdf3(param_1,param_2,param_3,param_4);\n        fabs((double)CONCAT44(unaff_r4,param_4));\n        atan((double)CONCAT44(unaff_r4,param_4));\n      }\n      if (uVar2 !\u003d 1) {\n        if (uVar2 \u003d\u003d 2) {\n          uVar5 \u003d __subdf3();\n          __subdf3(0x54442d18,0x400921fb,(int)uVar5,(int)((ulonglong)uVar5 \u003e\u003e 0x20));\n        }\n        else if (uVar2 !\u003d 0) {\n          uVar5 \u003d __subdf3();\n          __subdf3((int)uVar5,(int)((ulonglong)uVar5 \u003e\u003e 0x20),0x54442d18,0x400921fb);\n        }\n      }\n    }\n  }\n  else {\n    __aeabi_dadd(param_3,param_4,param_1,param_2);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "atan2"
      ],
      "called": [
        "fabs",
        "__divdf3",
        "atan",
        "__subdf3",
        "__aeabi_dadd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__ieee754_hypot": {
      "entrypoint": "0x08009b24",
      "current_name": "__ieee754_hypot",
      "code": "\nuint __ieee754_hypot(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  uint uVar3;\n  int iVar4;\n  undefined4 uVar5;\n  int iVar6;\n  uint uVar7;\n  undefined4 uVar8;\n  undefined4 uVar9;\n  undefined8 uVar10;\n  undefined8 uVar11;\n  undefined8 uVar12;\n  undefined8 uVar13;\n  int local_3c;\n  \n  param_2 \u003d param_2 \u0026 0x7fffffff;\n  param_4 \u003d param_4 \u0026 0x7fffffff;\n  uVar3 \u003d param_1;\n  uVar7 \u003d param_2;\n  if (param_2 \u003c param_4) {\n    uVar3 \u003d param_3;\n    param_3 \u003d param_1;\n    uVar7 \u003d param_4;\n    param_4 \u003d param_2;\n  }\n  if (0x3c00000 \u003c (int)(uVar7 - param_4)) {\n    uVar3 \u003d __aeabi_dadd(uVar3,uVar7,param_3,param_4);\n    return uVar3;\n  }\n  if (uVar7 \u003c 0x5f300001) {\n    local_3c \u003d 0;\n  }\n  else {\n    if (0x7fefffff \u003c uVar7) {\n      if ((uVar7 \u0026 0xfffff | uVar3) !\u003d 0) {\n        uVar3 \u003d __aeabi_dadd(uVar3,uVar7,param_3,param_4);\n      }\n      if ((param_4 ^ 0x7ff00000 | param_3) !\u003d 0) {\n        return uVar3;\n      }\n      return param_3;\n    }\n    uVar7 \u003d uVar7 + 0xda800000;\n    param_4 \u003d param_4 + 0xda800000;\n    local_3c \u003d 600;\n  }\n  uVar11 \u003d CONCAT44(uVar7,uVar3);\n  uVar10 \u003d CONCAT44(param_4,param_3);\n  if ((int)param_4 \u003c 0x20b00000) {\n    if ((int)param_4 \u003c 0x100000) {\n      if ((param_4 | param_3) \u003d\u003d 0) {\n        return uVar3;\n      }\n      uVar10 \u003d __muldf3(param_3,param_4,0,0x7fd00000);\n      uVar11 \u003d __muldf3(uVar3,uVar7,0,0x7fd00000);\n      local_3c \u003d local_3c + -0x3fe;\n    }\n    else {\n      uVar7 \u003d uVar7 + 0x25800000;\n      uVar11 \u003d CONCAT44(uVar7,uVar3);\n      param_4 \u003d param_4 + 0x25800000;\n      uVar10 \u003d CONCAT44(param_4,param_3);\n      local_3c \u003d local_3c + -600;\n    }\n  }\n  uVar9 \u003d (undefined4)((ulonglong)uVar11 \u003e\u003e 0x20);\n  uVar8 \u003d (undefined4)uVar11;\n  iVar6 \u003d (int)((ulonglong)uVar10 \u003e\u003e 0x20);\n  uVar5 \u003d (undefined4)uVar10;\n  uVar10 \u003d __subdf3(uVar8,uVar9,uVar5,iVar6);\n  iVar4 \u003d (int)((ulonglong)uVar10 \u003e\u003e 0x20);\n  uVar1 \u003d (undefined4)uVar10;\n  iVar2 \u003d __aeabi_dcmplt(uVar5,iVar6,uVar1,iVar4);\n  if (iVar2 \u003d\u003d 0) {\n    uVar10 \u003d __muldf3(0,param_4,0);\n    uVar11 \u003d __muldf3(uVar1,iVar4 + -0x80000000,uVar1,iVar4);\n    uVar12 \u003d __aeabi_dadd(uVar8,uVar9,uVar8,uVar9);\n    uVar12 \u003d __subdf3((int)uVar12,(int)((ulonglong)uVar12 \u003e\u003e 0x20),0,uVar7 + 0x100000);\n    uVar12 \u003d __muldf3((int)uVar12,(int)((ulonglong)uVar12 \u003e\u003e 0x20),uVar5,iVar6);\n    uVar13 \u003d __subdf3(uVar5,iVar6,0,param_4);\n    uVar13 \u003d __muldf3((int)uVar13,(int)((ulonglong)uVar13 \u003e\u003e 0x20),0,uVar7 + 0x100000);\n    uVar12 \u003d __aeabi_dadd((int)uVar12,(int)((ulonglong)uVar12 \u003e\u003e 0x20),(int)uVar13,\n                          (int)((ulonglong)uVar13 \u003e\u003e 0x20));\n    uVar11 \u003d __subdf3((int)uVar11,(int)((ulonglong)uVar11 \u003e\u003e 0x20),(int)uVar12,\n                      (int)((ulonglong)uVar12 \u003e\u003e 0x20));\n    __subdf3((int)uVar10,(int)((ulonglong)uVar10 \u003e\u003e 0x20),(int)uVar11,\n             (int)((ulonglong)uVar11 \u003e\u003e 0x20));\n    uVar10 \u003d __ieee754_sqrt();\n  }\n  else {\n    uVar10 \u003d __muldf3(0,uVar7,0,uVar7);\n    uVar11 \u003d __muldf3(uVar5,iVar6 + -0x80000000,uVar5,iVar6);\n    uVar12 \u003d __aeabi_dadd(uVar8,uVar9,0,uVar7);\n    uVar13 \u003d __subdf3(uVar8,uVar9,0,uVar7);\n    uVar12 \u003d __muldf3((int)uVar12,(int)((ulonglong)uVar12 \u003e\u003e 0x20),(int)uVar13,\n                      (int)((ulonglong)uVar13 \u003e\u003e 0x20));\n    uVar11 \u003d __subdf3((int)uVar11,(int)((ulonglong)uVar11 \u003e\u003e 0x20),(int)uVar12,\n                      (int)((ulonglong)uVar12 \u003e\u003e 0x20));\n    __subdf3((int)uVar10,(int)((ulonglong)uVar10 \u003e\u003e 0x20),(int)uVar11,\n             (int)((ulonglong)uVar11 \u003e\u003e 0x20));\n    uVar10 \u003d __ieee754_sqrt();\n  }\n  uVar3 \u003d (uint)uVar10;\n  if (local_3c !\u003d 0) {\n    uVar3 \u003d __muldf3(uVar3,(int)((ulonglong)uVar10 \u003e\u003e 0x20),0,local_3c * 0x100000 + 0x3ff00000);\n  }\n  return uVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "hypot"
      ],
      "called": [
        "__ieee754_sqrt",
        "__aeabi_dcmplt",
        "__subdf3",
        "__muldf3",
        "__aeabi_dadd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__ieee754_rem_pio2": {
      "entrypoint": "0x08009d78",
      "current_name": "__ieee754_rem_pio2",
      "code": "\nint __ieee754_rem_pio2(undefined4 param_1,uint param_2,undefined8 *param_3)\n\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 extraout_r1;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  uint uVar8;\n  int iVar9;\n  undefined8 uVar10;\n  undefined8 uVar11;\n  undefined8 uVar12;\n  undefined4 in_stack_ffffffa8;\n  undefined4 in_stack_ffffffac;\n  undefined4 local_50;\n  undefined4 uStack_4c;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  \n  uVar8 \u003d param_2 \u0026 0x7fffffff;\n  if (uVar8 \u003c 0x3fe921fc) {\n    *(undefined4 *)param_3 \u003d param_1;\n    *(uint *)((int)param_3 + 4) \u003d param_2;\n    *(undefined4 *)(param_3 + 1) \u003d 0;\n    *(undefined4 *)((int)param_3 + 0xc) \u003d 0;\n    return 0;\n  }\n  if (uVar8 \u003c 0x4002d97c) {\n    if ((int)param_2 \u003c 1) {\n      uVar10 \u003d __aeabi_dadd(param_1,param_2,0x54400000,0x3ff921fb);\n      uVar2 \u003d (undefined4)((ulonglong)uVar10 \u003e\u003e 0x20);\n      uVar1 \u003d (undefined4)uVar10;\n      if (uVar8 !\u003d 0x3ff921fb) {\n        uVar10 \u003d __aeabi_dadd(uVar1,uVar2,0x1a626331,0x3dd0b461);\n        *param_3 \u003d uVar10;\n        uVar10 \u003d __subdf3(uVar1,uVar2);\n        uVar10 \u003d __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 \u003e\u003e 0x20),0x1a626331,0x3dd0b461);\n        param_3[1] \u003d uVar10;\n        return -1;\n      }\n      uVar10 \u003d __aeabi_dadd(uVar1,uVar2,0x1a600000,0x3dd0b461);\n      uVar1 \u003d (undefined4)((ulonglong)uVar10 \u003e\u003e 0x20);\n      uVar11 \u003d __aeabi_dadd((int)uVar10,uVar1,0x2e037073,0x3ba3198a);\n      *param_3 \u003d uVar11;\n      uVar10 \u003d __subdf3((int)uVar10,uVar1);\n      uVar10 \u003d __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 \u003e\u003e 0x20),0x2e037073,0x3ba3198a);\n      param_3[1] \u003d uVar10;\n      return -1;\n    }\n    uVar10 \u003d __subdf3();\n    uVar2 \u003d (undefined4)((ulonglong)uVar10 \u003e\u003e 0x20);\n    uVar1 \u003d (undefined4)uVar10;\n    if (uVar8 !\u003d 0x3ff921fb) {\n      uVar10 \u003d __subdf3(uVar1,uVar2,0x1a626331,0x3dd0b461);\n      *param_3 \u003d uVar10;\n      uVar10 \u003d __subdf3(uVar1,uVar2);\n      uVar10 \u003d __subdf3((int)uVar10,(int)((ulonglong)uVar10 \u003e\u003e 0x20),0x1a626331,0x3dd0b461);\n      param_3[1] \u003d uVar10;\n      return 1;\n    }\n    uVar10 \u003d __subdf3(uVar1,uVar2,0x1a600000,0x3dd0b461);\n    uVar1 \u003d (undefined4)((ulonglong)uVar10 \u003e\u003e 0x20);\n    uVar11 \u003d __subdf3((int)uVar10,uVar1,0x2e037073,0x3ba3198a);\n    *param_3 \u003d uVar11;\n    uVar10 \u003d __subdf3((int)uVar10,uVar1);\n    uVar10 \u003d __subdf3((int)uVar10,(int)((ulonglong)uVar10 \u003e\u003e 0x20),0x2e037073,0x3ba3198a);\n    param_3[1] \u003d uVar10;\n    return 1;\n  }\n  if (0x413921fb \u003c uVar8) {\n    if (0x7fefffff \u003c uVar8) {\n      uVar10 \u003d __subdf3(param_1,param_2,param_1,param_2);\n      param_3[1] \u003d uVar10;\n      *param_3 \u003d uVar10;\n      return 0;\n    }\n    iVar9 \u003d ((int)uVar8 \u003e\u003e 0x14) + -0x416;\n    __aeabi_d2iz();\n    local_40 \u003d __aeabi_i2d();\n    uVar10 \u003d __subdf3(param_1,uVar8 + iVar9 * -0x100000,(int)local_40,\n                      (int)((ulonglong)local_40 \u003e\u003e 0x20));\n    uVar10 \u003d __muldf3((int)uVar10,(int)((ulonglong)uVar10 \u003e\u003e 0x20),0,0x41700000);\n    __aeabi_d2iz();\n    local_38 \u003d __aeabi_i2d();\n    uVar10 \u003d __subdf3((int)uVar10,(int)((ulonglong)uVar10 \u003e\u003e 0x20));\n    local_30 \u003d __muldf3((int)uVar10,(int)((ulonglong)uVar10 \u003e\u003e 0x20),0,0x41700000);\n    __aeabi_dcmpeq((int)local_30,(int)((ulonglong)local_30 \u003e\u003e 0x20),0,0);\n    iVar9 \u003d __kernel_rem_pio2(\u0026local_40,param_3,iVar9);\n    if (-1 \u003c (int)param_2) {\n      return iVar9;\n    }\n    *(int *)((int)param_3 + 4) \u003d *(int *)((int)param_3 + 4) + -0x80000000;\n    *(int *)((int)param_3 + 0xc) \u003d *(int *)((int)param_3 + 0xc) + -0x80000000;\n    return -iVar9;\n  }\n  fabs((double)CONCAT44(in_stack_ffffffac,in_stack_ffffffa8));\n  uVar10 \u003d __muldf3();\n  __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 \u003e\u003e 0x20),0,0x3fe00000);\n  iVar9 \u003d __aeabi_d2iz();\n  uVar10 \u003d __aeabi_i2d();\n  uVar4 \u003d (undefined4)((ulonglong)uVar10 \u003e\u003e 0x20);\n  uVar1 \u003d (undefined4)uVar10;\n  uVar10 \u003d __muldf3(uVar1,uVar4,0x54400000,0x3ff921fb);\n  uVar10 \u003d __subdf3(param_1,extraout_r1,(int)uVar10,(int)((ulonglong)uVar10 \u003e\u003e 0x20));\n  uVar5 \u003d (undefined4)((ulonglong)uVar10 \u003e\u003e 0x20);\n  uVar2 \u003d (undefined4)uVar10;\n  uVar11 \u003d __muldf3(uVar1,uVar4,0x1a626331,0x3dd0b461);\n  if ((0x1f \u003c iVar9) || (*(uint *)(\u0026npio2_hw + (iVar9 + -1) * 4) \u003d\u003d uVar8)) {\n    uVar12 \u003d __subdf3(uVar2,uVar5,(int)uVar11,(int)((ulonglong)uVar11 \u003e\u003e 0x20));\n    if ((int)((uVar8 \u003e\u003e 0x14) - ((uint)((int)((ulonglong)uVar12 \u003e\u003e 0x20) \u003c\u003c 1) \u003e\u003e 0x15)) \u003c 0x11)\n    goto LAB_0800a0ce;\n    uVar11 \u003d __muldf3(uVar1,uVar4,0x1a600000,0x3dd0b461);\n    uVar6 \u003d (undefined4)((ulonglong)uVar11 \u003e\u003e 0x20);\n    uVar10 \u003d __subdf3(uVar2,uVar5,(int)uVar11,uVar6);\n    uVar7 \u003d (undefined4)((ulonglong)uVar10 \u003e\u003e 0x20);\n    uVar3 \u003d (undefined4)uVar10;\n    uVar12 \u003d __subdf3(uVar2,uVar5,uVar3,uVar7);\n    uVar11 \u003d __subdf3((int)uVar12,(int)((ulonglong)uVar12 \u003e\u003e 0x20),(int)uVar11,uVar6);\n    uVar12 \u003d __muldf3(uVar1,uVar4,0x2e037073,0x3ba3198a);\n    uVar11 \u003d __subdf3((int)uVar12,(int)((ulonglong)uVar12 \u003e\u003e 0x20),(int)uVar11,\n                      (int)((ulonglong)uVar11 \u003e\u003e 0x20));\n    uVar12 \u003d __subdf3(uVar3,uVar7,(int)uVar11,(int)((ulonglong)uVar11 \u003e\u003e 0x20));\n    if ((int)(((int)uVar8 \u003e\u003e 0x14) - ((uint)((int)((ulonglong)uVar12 \u003e\u003e 0x20) \u003c\u003c 1) \u003e\u003e 0x15)) \u003c 0x32\n       ) goto LAB_0800a0ce;\n    uVar11 \u003d __muldf3(uVar1,uVar4,0x2e000000,0x3ba3198a);\n    uVar2 \u003d (undefined4)((ulonglong)uVar11 \u003e\u003e 0x20);\n    uVar10 \u003d __subdf3(uVar3,uVar7,(int)uVar11,uVar2);\n    uVar12 \u003d __subdf3(uVar3,uVar7);\n    uVar11 \u003d __subdf3((int)uVar12,(int)((ulonglong)uVar12 \u003e\u003e 0x20),(int)uVar11,uVar2);\n    uVar12 \u003d __muldf3(uVar1,uVar4,0x252049c1,0x397b839a);\n    uVar11 \u003d __subdf3((int)uVar12,(int)((ulonglong)uVar12 \u003e\u003e 0x20),(int)uVar11,\n                      (int)((ulonglong)uVar11 \u003e\u003e 0x20));\n  }\n  uVar12 \u003d __subdf3((int)uVar10,(int)((ulonglong)uVar10 \u003e\u003e 0x20),(int)uVar11,\n                    (int)((ulonglong)uVar11 \u003e\u003e 0x20));\nLAB_0800a0ce:\n  uStack_4c \u003d (undefined4)((ulonglong)uVar10 \u003e\u003e 0x20);\n  local_50 \u003d (undefined4)uVar10;\n  *param_3 \u003d uVar12;\n  uVar10 \u003d __subdf3(local_50,uStack_4c);\n  uVar10 \u003d __subdf3((int)uVar10,(int)((ulonglong)uVar10 \u003e\u003e 0x20),(int)uVar11,\n                    (int)((ulonglong)uVar11 \u003e\u003e 0x20));\n  param_3[1] \u003d uVar10;\n  if ((int)param_2 \u003c 0) {\n    *(int *)param_3 \u003d (int)uVar12;\n    *(int *)((int)param_3 + 4) \u003d (int)((ulonglong)uVar12 \u003e\u003e 0x20) + -0x80000000;\n    *(int *)(param_3 + 1) \u003d (int)uVar10;\n    *(int *)((int)param_3 + 0xc) \u003d (int)((ulonglong)uVar10 \u003e\u003e 0x20) + -0x80000000;\n    iVar9 \u003d -iVar9;\n  }\n  return iVar9;\n}\n\n",
      "renaming": {},
      "calling": [
        "sin",
        "cos"
      ],
      "called": [
        "fabs",
        "__aeabi_i2d",
        "__aeabi_dcmpeq",
        "__kernel_rem_pio2",
        "__subdf3",
        "__aeabi_d2iz",
        "__muldf3",
        "__aeabi_dadd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__ieee754_sqrt": {
      "entrypoint": "0x0800a1bc",
      "current_name": "__ieee754_sqrt",
      "code": "\nuint __ieee754_sqrt(uint param_1,uint param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  uint uVar3;\n  undefined4 uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  int iVar10;\n  uint uVar11;\n  uint uVar12;\n  undefined8 uVar13;\n  \n  if ((~param_2 \u0026 0x7ff00000) \u003d\u003d 0) {\n    uVar13 \u003d __muldf3(param_1,param_2,param_1,param_2);\n    uVar7 \u003d __aeabi_dadd((int)uVar13,(int)((ulonglong)uVar13 \u003e\u003e 0x20),param_1,param_2);\n    return uVar7;\n  }\n  if ((int)param_2 \u003c 1) {\n    if ((param_2 \u0026 0x7fffffff | param_1) \u003d\u003d 0) {\n      return param_1;\n    }\n    if (param_2 !\u003d 0) {\n      uVar13 \u003d __subdf3(param_1,param_2,param_1);\n      uVar4 \u003d (undefined4)((ulonglong)uVar13 \u003e\u003e 0x20);\n      uVar7 \u003d __divdf3((int)uVar13,uVar4,(int)uVar13,uVar4);\n      return uVar7;\n    }\n    do {\n      uVar9 \u003d param_1;\n      uVar7 \u003d uVar9 \u003e\u003e 0xb;\n      param_2 \u003d param_2 - 0x15;\n      param_1 \u003d uVar9 \u003c\u003c 0x15;\n    } while (uVar7 \u003d\u003d 0);\n    uVar1 \u003d param_2;\n    if (-1 \u003c (int)uVar9) goto LAB_0800a290;\n    uVar12 \u003d 0x20;\n    uVar5 \u003d 0xffffffff;\n    uVar9 \u003d param_1;\n  }\n  else {\n    uVar1 \u003d (int)param_2 \u003e\u003e 0x14;\n    uVar7 \u003d param_2;\n    uVar9 \u003d param_1;\n    if (uVar1 !\u003d 0) goto LAB_0800a1da;\nLAB_0800a290:\n    uVar9 \u003d 0;\n    uVar12 \u003d uVar7;\n    do {\n      uVar5 \u003d uVar9;\n      uVar7 \u003d uVar12 \u003c\u003c 1;\n      iVar10 \u003d uVar12 \u003c\u003c 0xc;\n      uVar9 \u003d uVar5 + 1;\n      uVar12 \u003d uVar7;\n    } while (-1 \u003c iVar10);\n    uVar12 \u003d 0x20 - uVar9;\n    param_2 \u003d uVar1;\n    uVar9 \u003d param_1 \u003c\u003c (uVar9 \u0026 0xff);\n  }\n  uVar7 \u003d param_1 \u003e\u003e (uVar12 \u0026 0xff) | uVar7;\n  uVar1 \u003d param_2 - uVar5;\nLAB_0800a1da:\n  uVar7 \u003d uVar7 \u0026 0xfffff | 0x100000;\n  if (-1 \u003c (int)(uVar1 \u003c\u003c 0x1f)) {\n    uVar7 \u003d uVar7 * 2 - ((int)uVar9 \u003e\u003e 0x1f);\n    uVar9 \u003d uVar9 \u003c\u003c 1;\n  }\n  uVar12 \u003d 0;\n  uVar7 \u003d uVar7 * 2 - ((int)uVar9 \u003e\u003e 0x1f);\n  uVar9 \u003d uVar9 \u003c\u003c 1;\n  uVar1 \u003d 0;\n  iVar10 \u003d 0x16;\n  uVar5 \u003d 0x200000;\n  do {\n    iVar2 \u003d uVar1 + uVar5;\n    if (iVar2 \u003c\u003d (int)uVar7) {\n      uVar7 \u003d uVar7 - iVar2;\n      uVar1 \u003d iVar2 + uVar5;\n      uVar12 \u003d uVar12 + uVar5;\n    }\n    iVar10 \u003d iVar10 + -1;\n    uVar7 \u003d uVar7 * 2 - ((int)uVar9 \u003e\u003e 0x1f);\n    uVar5 \u003d uVar5 \u003e\u003e 1;\n    uVar9 \u003d uVar9 \u003c\u003c 1;\n  } while (iVar10 !\u003d 0);\n  iVar2 \u003d 0x20;\n  uVar6 \u003d 0x80000000;\n  iVar10 \u003d 0;\n  uVar5 \u003d 0;\n  do {\n    uVar3 \u003d uVar6 + iVar10;\n    uVar11 \u003d uVar1;\n    if ((int)uVar1 \u003c (int)uVar7) {\n      if ((int)uVar3 \u003c 0) {\nLAB_0800a26a:\n        if (-1 \u003c (int)(uVar3 + uVar6)) {\n          uVar11 \u003d uVar1 + 1;\n        }\n      }\n      uVar8 \u003d uVar7 - uVar1;\n      uVar1 \u003d uVar11;\n      if (uVar9 \u003c uVar3) {\n        uVar8 \u003d uVar8 - 1;\n      }\nLAB_0800a262:\n      iVar10 \u003d uVar3 + uVar6;\n      uVar9 \u003d uVar9 - uVar3;\n      uVar5 \u003d uVar5 + uVar6;\n      uVar7 \u003d uVar8;\n    }\n    else if ((uVar7 \u003d\u003d uVar1) \u0026\u0026 (uVar3 \u003c\u003d uVar9)) {\n      if ((int)uVar3 \u003c 0) goto LAB_0800a26a;\n      uVar8 \u003d 0;\n      uVar1 \u003d uVar7;\n      goto LAB_0800a262;\n    }\n    iVar2 \u003d iVar2 + -1;\n    uVar6 \u003d uVar6 \u003e\u003e 1;\n    uVar7 \u003d uVar7 * 2 - ((int)uVar9 \u003e\u003e 0x1f);\n    uVar9 \u003d uVar9 \u003c\u003c 1;\n    if (iVar2 \u003d\u003d 0) {\n      if ((uVar7 | uVar9) \u003d\u003d 0) {\n        uVar5 \u003d uVar5 \u003e\u003e 1;\n      }\n      else if (uVar5 \u003d\u003d 0xffffffff) {\n        uVar12 \u003d uVar12 + 1;\n        uVar5 \u003d 0;\n      }\n      else {\n        uVar5 \u003d uVar5 + 1 \u003e\u003e 1;\n      }\n      if ((uVar12 \u0026 1) !\u003d 0) {\n        uVar5 \u003d uVar5 | 0x80000000;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "__ieee754_hypot",
        "sqrt"
      ],
      "called": [
        "__divdf3",
        "__subdf3",
        "__aeabi_dadd",
        "__muldf3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__kernel_cos": {
      "entrypoint": "0x0800a348",
      "current_name": "__kernel_cos",
      "code": "\nundefined4 __kernel_cos(undefined4 param_1,uint param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  undefined4 local_30;\n  undefined4 uStack_2c;\n  undefined4 local_28;\n  undefined4 uStack_24;\n  \n  uVar4 \u003d param_2 \u0026 0x7fffffff;\n  if (uVar4 \u003c 0x3e400000) {\n    iVar1 \u003d __aeabi_d2iz();\n    if (iVar1 \u003d\u003d 0) {\n      return 0;\n    }\n    uVar5 \u003d __muldf3(param_1,param_2,param_1,param_2);\n    uVar3 \u003d (undefined4)((ulonglong)uVar5 \u003e\u003e 0x20);\n    uVar2 \u003d (undefined4)uVar5;\n    uVar6 \u003d __muldf3(uVar2,uVar3,0xbe8838d4,0xbda8fae9);\n    uVar6 \u003d __aeabi_dadd((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),0xbdb4b1c4,0x3e21ee9e);\n    uVar6 \u003d __muldf3((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),uVar2,uVar3);\n    uVar6 \u003d __subdf3((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),0x809c52ad,0x3e927e4f);\n    uVar6 \u003d __muldf3((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),uVar2,uVar3);\n    uVar6 \u003d __aeabi_dadd((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),0x19cb1590,0x3efa01a0);\n    uVar6 \u003d __muldf3((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),uVar2,uVar3);\n    uVar6 \u003d __subdf3((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),0x16c15177,0x3f56c16c);\n    uVar6 \u003d __muldf3((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),uVar2,uVar3);\n    uVar6 \u003d __aeabi_dadd((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),0x5555554c,0x3fa55555);\n    uVar6 \u003d __muldf3((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),uVar2,uVar3);\n  }\n  else {\n    uVar5 \u003d __muldf3(param_1,param_2,param_1,param_2);\n    uVar3 \u003d (undefined4)((ulonglong)uVar5 \u003e\u003e 0x20);\n    uVar2 \u003d (undefined4)uVar5;\n    uVar6 \u003d __muldf3(uVar2,uVar3,0xbe8838d4,0xbda8fae9);\n    uVar6 \u003d __aeabi_dadd((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),0xbdb4b1c4,0x3e21ee9e);\n    uVar6 \u003d __muldf3((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),uVar2,uVar3);\n    uVar6 \u003d __subdf3((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),0x809c52ad,0x3e927e4f);\n    uVar6 \u003d __muldf3((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),uVar2,uVar3);\n    uVar6 \u003d __aeabi_dadd((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),0x19cb1590,0x3efa01a0);\n    uVar6 \u003d __muldf3((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),uVar2,uVar3);\n    uVar6 \u003d __subdf3((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),0x16c15177,0x3f56c16c);\n    uVar6 \u003d __muldf3((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),uVar2,uVar3);\n    uVar6 \u003d __aeabi_dadd((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),0x5555554c,0x3fa55555);\n    uVar6 \u003d __muldf3((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),uVar2,uVar3);\n    if (0x3fd33332 \u003c uVar4) {\n      if (uVar4 \u003c 0x3fe90001) {\n        iVar1 \u003d uVar4 - 0x200000;\n        uVar5 \u003d __subdf3(0,0x3ff00000,0,iVar1);\n      }\n      else {\n        iVar1 \u003d 0x3fd20000;\n        uVar5 \u003d 0x3fe7000000000000;\n      }\n      uStack_24 \u003d (undefined4)((ulonglong)uVar5 \u003e\u003e 0x20);\n      local_28 \u003d (undefined4)uVar5;\n      uVar5 \u003d __muldf3(uVar2,uVar3,0,0x3fe00000);\n      uVar5 \u003d __subdf3((int)uVar5,(int)((ulonglong)uVar5 \u003e\u003e 0x20),0,iVar1);\n      uVar6 \u003d __muldf3(uVar2,uVar3,(int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20));\n      uVar7 \u003d __muldf3(param_1,param_2,param_3,param_4);\n      uVar6 \u003d __subdf3((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),(int)uVar7,\n                       (int)((ulonglong)uVar7 \u003e\u003e 0x20));\n      uVar5 \u003d __subdf3((int)uVar5,(int)((ulonglong)uVar5 \u003e\u003e 0x20),(int)uVar6,\n                       (int)((ulonglong)uVar6 \u003e\u003e 0x20));\n      uVar2 \u003d __subdf3(local_28,uStack_24,(int)uVar5,(int)((ulonglong)uVar5 \u003e\u003e 0x20));\n      return uVar2;\n    }\n  }\n  uStack_2c \u003d (undefined4)((ulonglong)uVar6 \u003e\u003e 0x20);\n  local_30 \u003d (undefined4)uVar6;\n  uVar2 \u003d (undefined4)((ulonglong)uVar5 \u003e\u003e 0x20);\n  uVar6 \u003d __muldf3((int)uVar5,uVar2,0,0x3fe00000);\n  uVar5 \u003d __muldf3((int)uVar5,uVar2,local_30,uStack_2c);\n  uVar7 \u003d __muldf3(param_1,param_2,param_3,param_4);\n  uVar5 \u003d __subdf3((int)uVar5,(int)((ulonglong)uVar5 \u003e\u003e 0x20),(int)uVar7,\n                   (int)((ulonglong)uVar7 \u003e\u003e 0x20));\n  uVar5 \u003d __subdf3((int)uVar6,(int)((ulonglong)uVar6 \u003e\u003e 0x20),(int)uVar5,\n                   (int)((ulonglong)uVar5 \u003e\u003e 0x20));\n  uVar2 \u003d __subdf3(0,0x3ff00000,(int)uVar5,(int)((ulonglong)uVar5 \u003e\u003e 0x20));\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "sin",
        "cos"
      ],
      "called": [
        "__subdf3",
        "__aeabi_d2iz",
        "__muldf3",
        "__aeabi_dadd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__kernel_rem_pio2": {
      "entrypoint": "0x0800a5a0",
      "current_name": "__kernel_rem_pio2",
      "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nuint __kernel_rem_pio2(int param_1,undefined8 *param_2,int param_3,int param_4,int param_5,\n                      int param_6)\n\n{\n  undefined4 *puVar1;\n  uint uVar2;\n  undefined4 uVar3;\n  uint uVar4;\n  undefined4 extraout_r1;\n  int iVar5;\n  uint *puVar6;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined4 uVar7;\n  uint **ppuVar8;\n  int iVar9;\n  int iVar10;\n  undefined4 *puVar11;\n  undefined4 uVar12;\n  uint uVar13;\n  uint *puVar14;\n  int iVar15;\n  int iVar16;\n  undefined8 *puVar17;\n  undefined8 *puVar18;\n  undefined8 *puVar19;\n  undefined4 *puVar20;\n  undefined8 *puVar21;\n  undefined4 uVar22;\n  int iVar23;\n  undefined4 *puVar24;\n  bool bVar25;\n  undefined8 uVar26;\n  undefined8 uVar27;\n  undefined8 uVar28;\n  undefined4 in_stack_fffffd78;\n  int local_280;\n  int local_26c;\n  uint *local_260 [2];\n  uint local_258 [20];\n  undefined8 uStack_208;\n  undefined4 local_168;\n  undefined4 local_164;\n  undefined8 local_160;\n  undefined8 uStack_c8;\n  \n  iVar16 \u003d *(int *)(\u0026init_jk + param_5 * 4);\n  iVar9 \u003d param_4 + -1;\n  local_260[1] \u003d (uint *)param_2;\n  if (param_3 + 0x14 \u003c 0 \u003d\u003d SCARRY4(param_3,0x14)) {\n    local_26c \u003d (param_3 + -3) / 0x18;\n    iVar10 \u003d (local_26c + 1) * -0x18;\n  }\n  else {\n    iVar10 \u003d -0x18;\n    local_26c \u003d 0;\n  }\n  param_3 \u003d param_3 + iVar10;\n  iVar10 \u003d local_26c - iVar9;\n  if (-1 \u003c iVar16 + iVar9) {\n    iVar23 \u003d iVar16 + iVar9 + 1 + iVar10;\n    puVar19 \u003d \u0026uStack_208;\n    do {\n      while (iVar10 \u003c 0) {\n        iVar10 \u003d iVar10 + 1;\n        *(undefined4 *)puVar19 \u003d 0;\n        *(undefined4 *)((int)puVar19 + 4) \u003d 0;\n        puVar19 \u003d puVar19 + 1;\n        if (iVar10 \u003d\u003d iVar23) goto LAB_0800a626;\n      }\n      uVar27 \u003d __aeabi_i2d(*(undefined4 *)(param_6 + iVar10 * 4));\n      iVar10 \u003d iVar10 + 1;\n      *puVar19 \u003d uVar27;\n      puVar19 \u003d puVar19 + 1;\n    } while (iVar10 !\u003d iVar23);\n  }\nLAB_0800a626:\n  puVar11 \u003d (undefined4 *)(param_1 + -8);\n  if (-1 \u003c iVar16) {\n    puVar17 \u003d \u0026uStack_208 + param_4;\n    iVar23 \u003d iVar16 + param_4;\n    iVar10 \u003d iVar9;\n    puVar19 \u003d \u0026uStack_c8;\n    do {\n      if (iVar9 \u003c 0) {\n        uVar27 \u003d 0;\n      }\n      else {\n        uVar27 \u003d 0;\n        puVar24 \u003d puVar11;\n        puVar21 \u003d puVar17;\n        do {\n          puVar20 \u003d puVar24 + 2;\n          uVar26 \u003d __muldf3(*puVar20,puVar24[3],*(undefined4 *)(puVar21 + -1),\n                            *(undefined4 *)((int)puVar21 + -4));\n          uVar27 \u003d __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 \u003e\u003e 0x20),(int)uVar26,\n                                (int)((ulonglong)uVar26 \u003e\u003e 0x20));\n          puVar24 \u003d puVar20;\n          puVar21 \u003d puVar21 + -1;\n        } while (puVar20 !\u003d puVar11 + param_4 * 2);\n      }\n      iVar10 \u003d iVar10 + 1;\n      *puVar19 \u003d uVar27;\n      puVar17 \u003d puVar17 + 1;\n      puVar19 \u003d puVar19 + 1;\n    } while (iVar10 !\u003d iVar23);\n  }\n  local_260[0] \u003d local_258 + iVar16 + -1;\n  local_280 \u003d iVar16;\n  do {\n    iVar23 \u003d *(int *)(\u0026uStack_c8 + local_280);\n    uVar27 \u003d CONCAT44(*(undefined4 *)((int)\u0026uStack_c8 + local_280 * 8 + 4),iVar23);\n    iVar10 \u003d local_280;\n    if (0 \u003c local_280) {\n      puVar19 \u003d \u0026uStack_c8 + local_280;\n      puVar6 \u003d local_258;\n      do {\n        uVar7 \u003d (undefined4)((ulonglong)uVar27 \u003e\u003e 0x20);\n        __muldf3((int)uVar27,uVar7,0,0x3e700000);\n        __aeabi_d2iz();\n        uVar26 \u003d __aeabi_i2d();\n        uVar3 \u003d (undefined4)((ulonglong)uVar26 \u003e\u003e 0x20);\n        uVar28 \u003d __muldf3((int)uVar26,uVar3,0,0x41700000);\n        __subdf3((int)uVar27,uVar7,(int)uVar28,(int)((ulonglong)uVar28 \u003e\u003e 0x20));\n        uVar2 \u003d __aeabi_d2iz();\n        puVar17 \u003d puVar19 + -1;\n        uVar7 \u003d *(undefined4 *)puVar17;\n        uVar12 \u003d *(undefined4 *)((int)puVar19 + -4);\n        *puVar6 \u003d uVar2;\n        uVar27 \u003d __aeabi_dadd((int)uVar26,uVar3,uVar7,uVar12);\n        iVar23 \u003d (int)uVar27;\n        puVar19 \u003d puVar17;\n        puVar6 \u003d puVar6 + 1;\n      } while (puVar17 !\u003d \u0026uStack_c8);\n    }\n    scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),iVar23);\n    __muldf3();\n    floor((double)CONCAT44(iVar10,in_stack_fffffd78));\n    uVar27 \u003d __muldf3();\n    uVar27 \u003d __subdf3(iVar23,extraout_r1,(int)uVar27,(int)((ulonglong)uVar27 \u003e\u003e 0x20));\n    uVar2 \u003d __aeabi_d2iz();\n    uVar26 \u003d __aeabi_i2d();\n    uVar27 \u003d __subdf3((int)uVar27,(int)((ulonglong)uVar27 \u003e\u003e 0x20),(int)uVar26,\n                      (int)((ulonglong)uVar26 \u003e\u003e 0x20));\n    uVar7 \u003d (undefined4)((ulonglong)uVar27 \u003e\u003e 0x20);\n    uVar3 \u003d (undefined4)uVar27;\n    if (param_3 \u003c 1) {\n      if (param_3 \u003d\u003d 0) {\n        iVar23 \u003d (int)local_258[iVar10 + -1] \u003e\u003e 0x17;\n        goto joined_r0x0800a8b8;\n      }\n      iVar23 \u003d __aeabi_dcmpge(uVar3,uVar7,0,0x3fe00000);\n      if (iVar23 !\u003d 0) {\n        uVar2 \u003d uVar2 + 1;\n        if (iVar10 \u003c 1) {\n          uVar27 \u003d __subdf3(0,0x3ff00000,uVar3,uVar7);\n          iVar23 \u003d 2;\n          goto LAB_0800a7a4;\n        }\n        iVar23 \u003d 2;\n        goto LAB_0800a8c8;\n      }\n    }\n    else {\n      iVar5 \u003d (int)local_258[iVar10 + -1] \u003e\u003e (0x18U - param_3 \u0026 0xff);\n      uVar13 \u003d local_258[iVar10 + -1] - (iVar5 \u003c\u003c (0x18U - param_3 \u0026 0xff));\n      iVar23 \u003d (int)uVar13 \u003e\u003e (0x17U - param_3 \u0026 0xff);\n      local_258[iVar10 + -1] \u003d uVar13;\n      uVar2 \u003d uVar2 + iVar5;\njoined_r0x0800a8b8:\n      if (0 \u003c iVar23) {\n        uVar2 \u003d uVar2 + 1;\n        if (iVar10 \u003c 1) {\n          bVar25 \u003d false;\n        }\n        else {\nLAB_0800a8c8:\n          if (local_258[0] \u003d\u003d 0) {\n            bVar25 \u003d false;\n            if (iVar10 !\u003d 1) {\n              puVar6 \u003d local_258;\n              iVar5 \u003d 1;\n              do {\n                puVar6 \u003d puVar6 + 1;\n                if (*puVar6 !\u003d 0) {\n                  iVar15 \u003d iVar5 + 1;\n                  uVar13 \u003d *puVar6;\n                  goto LAB_0800a8e2;\n                }\n                iVar5 \u003d iVar5 + 1;\n              } while (iVar5 !\u003d iVar10);\n              bVar25 \u003d false;\n            }\n          }\n          else {\n            iVar15 \u003d 1;\n            iVar5 \u003d 0;\n            uVar13 \u003d local_258[0];\nLAB_0800a8e2:\n            local_258[iVar5] \u003d 0x1000000 - uVar13;\n            if (iVar15 \u003c iVar10) {\n              uVar13 \u003d local_258[iVar15];\n              puVar6 \u003d local_258 + iVar15;\n              while( true ) {\n                puVar14 \u003d puVar6 + 1;\n                *puVar6 \u003d 0xffffff - uVar13;\n                if (puVar14 \u003d\u003d local_258 + iVar10) break;\n                uVar13 \u003d *puVar14;\n                puVar6 \u003d puVar14;\n              }\n            }\n            bVar25 \u003d true;\n          }\n        }\n        if (0 \u003c param_3) {\n          if (param_3 \u003d\u003d 1) {\n            local_258[iVar10 + -1] \u003d local_258[iVar10 + -1] \u0026 0x7fffff;\n          }\n          else if (param_3 \u003d\u003d 2) {\n            local_258[iVar10 + -1] \u003d local_258[iVar10 + -1] \u0026 0x3fffff;\n          }\n        }\n        if (iVar23 \u003d\u003d 2) {\n          uVar27 \u003d __subdf3(0,0x3ff00000,uVar3,uVar7);\n          if (bVar25) {\n            uVar3 \u003d 0;\n            scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),0);\n            uVar27 \u003d __subdf3((int)uVar27,(int)((ulonglong)uVar27 \u003e\u003e 0x20),uVar3,extraout_r1_00);\n          }\n        }\n      }\n    }\nLAB_0800a7a4:\n    iVar15 \u003d (int)uVar27;\n    iVar5 \u003d __aeabi_dcmpeq(iVar15,(int)((ulonglong)uVar27 \u003e\u003e 0x20),0,0);\n    if (iVar5 \u003d\u003d 0) {\n      scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),iVar15);\n      iVar9 \u003d __aeabi_dcmpge();\n      if (iVar9 \u003d\u003d 0) {\n        iVar5 \u003d iVar10;\n        uVar13 \u003d __aeabi_d2iz(iVar15,extraout_r1_02);\n        local_258[iVar5] \u003d uVar13;\n        iVar10 \u003d iVar5;\n      }\n      else {\n        __muldf3(iVar15,extraout_r1_02,0,0x3e700000);\n        uVar13 \u003d __aeabi_d2iz();\n        uVar27 \u003d __aeabi_i2d();\n        uVar27 \u003d __muldf3((int)uVar27,(int)((ulonglong)uVar27 \u003e\u003e 0x20),0,0x41700000);\n        __subdf3(iVar15,extraout_r1_02,(int)uVar27,(int)((ulonglong)uVar27 \u003e\u003e 0x20));\n        iVar9 \u003d iVar10;\n        uVar4 \u003d __aeabi_d2iz();\n        iVar5 \u003d iVar10 + 1;\n        local_258[iVar10] \u003d uVar4;\n        local_258[iVar5] \u003d uVar13;\n        iVar10 \u003d iVar9;\n      }\n      goto LAB_0800a9f6;\n    }\n    iVar5 \u003d iVar10 + -1;\n    if (iVar16 \u003c\u003d iVar5) {\n      uVar13 \u003d 0;\n      puVar6 \u003d local_258 + iVar10 + 0x3fffffff;\n      do {\n        puVar14 \u003d puVar6 + -1;\n        uVar13 \u003d uVar13 | *puVar6;\n        puVar6 \u003d puVar14;\n      } while (puVar14 !\u003d local_260[0]);\n      if (uVar13 !\u003d 0) break;\n    }\n    if (local_258[iVar16 + -1] \u003d\u003d 0) {\n      local_280 \u003d 1;\n      ppuVar8 \u003d local_260 + iVar16;\n      do {\n        puVar6 \u003d *ppuVar8;\n        local_280 \u003d local_280 + 1;\n        ppuVar8 \u003d ppuVar8 + -1;\n      } while (puVar6 \u003d\u003d (uint *)0x0);\n      local_280 \u003d iVar10 + local_280;\n    }\n    else {\n      local_280 \u003d iVar10 + 1;\n    }\n    iVar23 \u003d iVar10 + 1;\n    puVar24 \u003d (undefined4 *)(param_6 + (iVar23 + local_26c + 0x3fffffff) * 4);\n    puVar19 \u003d \u0026uStack_208 + iVar10 + param_4;\n    puVar17 \u003d \u0026uStack_c8 + iVar23;\n    do {\n      puVar24 \u003d puVar24 + 1;\n      uVar27 \u003d __aeabi_i2d(*puVar24);\n      *puVar19 \u003d uVar27;\n      puVar21 \u003d puVar19 + 1;\n      if (iVar9 \u003c 0) {\n        uVar26 \u003d 0;\n      }\n      else {\n        uVar26 \u003d 0;\n        puVar20 \u003d puVar11;\n        while( true ) {\n          puVar19 \u003d puVar19 + -1;\n          puVar1 \u003d puVar20 + 2;\n          uVar27 \u003d __muldf3((int)uVar27,(int)((ulonglong)uVar27 \u003e\u003e 0x20),*puVar1,puVar20[3]);\n          uVar26 \u003d __aeabi_dadd((int)uVar26,(int)((ulonglong)uVar26 \u003e\u003e 0x20),(int)uVar27,\n                                (int)((ulonglong)uVar27 \u003e\u003e 0x20));\n          if (puVar1 \u003d\u003d puVar11 + param_4 * 2) break;\n          uVar27 \u003d *puVar19;\n          puVar20 \u003d puVar1;\n        }\n      }\n      *puVar17 \u003d uVar26;\n      iVar23 \u003d iVar23 + 1;\n      puVar19 \u003d puVar21;\n      puVar17 \u003d puVar17 + 1;\n    } while (iVar23 \u003c\u003d local_280);\n  } while( true );\n  if (local_258[iVar5] \u003d\u003d 0) {\n    puVar6 \u003d local_258 + iVar10 + 0x3ffffffe;\n    do {\n      uVar13 \u003d *puVar6;\n      iVar5 \u003d iVar5 + -1;\n      puVar6 \u003d puVar6 + -1;\n    } while (uVar13 \u003d\u003d 0);\n  }\nLAB_0800a9f6:\n  uVar3 \u003d 0;\n  scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),0);\n  uVar27 \u003d CONCAT44(extraout_r1_01,uVar3);\n  if (iVar5 \u003c 0) {\n    if (2 \u003c param_5) {\n      if (param_5 \u003d\u003d 3) {\n        puVar19 \u003d (undefined8 *)\u0026local_168;\n        uVar27 \u003d 0;\nLAB_0800abe4:\n        if (iVar23 \u003d\u003d 0) {\n          uVar3 \u003d *(undefined4 *)(puVar19 + 1);\n          uVar7 \u003d *(undefined4 *)((int)puVar19 + 0xc);\n          *local_260[1] \u003d local_168;\n          *(undefined4 *)((int)local_260[1] + 4) \u003d local_164;\n          *(undefined8 *)((int)local_260[1] + 0x10) \u003d uVar27;\n          *(undefined4 *)((int)local_260[1] + 8) \u003d uVar3;\n          *(undefined4 *)((int)local_260[1] + 0xc) \u003d uVar7;\n          return uVar2 \u0026 7;\n        }\n        iVar9 \u003d *(int *)((int)puVar19 + 4);\n        *(int *)((int)local_260[1] + 0x10) \u003d (int)uVar27;\n        iVar16 \u003d *(int *)((int)puVar19 + 0xc);\n        *(undefined4 *)((int)local_260[1] + 8) \u003d *(undefined4 *)(puVar19 + 1);\n        *(int *)((int)local_260[1] + 0x14) \u003d (int)((ulonglong)uVar27 \u003e\u003e 0x20) + -0x80000000;\n        uVar3 \u003d *(undefined4 *)puVar19;\n        *(int *)((int)local_260[1] + 4) \u003d iVar9 + -0x80000000;\n        *(int *)((int)local_260[1] + 0xc) \u003d iVar16 + -0x80000000;\n        *local_260[1] \u003d uVar3;\n        return uVar2 \u0026 7;\n      }\n      goto LAB_0800ab0e;\n    }\n    if (param_5 \u003c 1) {\n      if (param_5 !\u003d 0) goto LAB_0800ab0e;\n      uVar27 \u003d 0;\nLAB_0800aafc:\n      iVar9 \u003d (int)((ulonglong)uVar27 \u003e\u003e 0x20);\n      if (iVar23 !\u003d 0) {\n        iVar9 \u003d iVar9 + -0x80000000;\n      }\n      *local_260[1] \u003d (int)uVar27;\n      *(int *)((int)local_260[1] + 4) \u003d iVar9;\nLAB_0800ab0e:\n      return uVar2 \u0026 7;\n    }\n    uVar27 \u003d 0;\n  }\n  else {\n    puVar17 \u003d \u0026uStack_c8 + iVar5;\n    puVar6 \u003d local_258 + iVar5 + 1;\n    puVar19 \u003d \u0026uStack_c8 + iVar5 + 1;\n    do {\n      uVar3 \u003d (undefined4)((ulonglong)uVar27 \u003e\u003e 0x20);\n      puVar6 \u003d puVar6 + -1;\n      uVar26 \u003d __aeabi_i2d(*puVar6);\n      uVar26 \u003d __muldf3((int)uVar26,(int)((ulonglong)uVar26 \u003e\u003e 0x20),(int)uVar27,uVar3);\n      puVar19 \u003d puVar19 + -1;\n      *puVar19 \u003d uVar26;\n      uVar27 \u003d __muldf3((int)uVar27,uVar3,0,0x3e700000);\n    } while (puVar6 !\u003d local_258);\n    puVar19 \u003d (undefined8 *)\u0026local_168;\n    iVar9 \u003d 0;\n    do {\n      if (iVar16 \u003c 0) {\n        uVar27 \u003d 0;\n      }\n      else {\n        uVar3 \u003d 0x40000000;\n        uVar7 \u003d 0x3ff921fb;\n        uVar27 \u003d 0;\n        iVar10 \u003d 0;\n        puVar21 \u003d puVar17;\n        puVar11 \u003d \u0026DAT_0800c028;\n        while( true ) {\n          uVar26 \u003d __muldf3(*(undefined4 *)puVar21,*(undefined4 *)((int)puVar21 + 4),uVar3,uVar7);\n          uVar27 \u003d __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 \u003e\u003e 0x20),(int)uVar26,\n                                (int)((ulonglong)uVar26 \u003e\u003e 0x20));\n          iVar10 \u003d iVar10 + 1;\n          if ((iVar16 \u003c iVar10) || (iVar9 \u003c iVar10)) break;\n          uVar3 \u003d *puVar11;\n          uVar7 \u003d puVar11[1];\n          puVar21 \u003d puVar21 + 1;\n          puVar11 \u003d puVar11 + 2;\n        }\n      }\n      bVar25 \u003d iVar9 !\u003d iVar5;\n      puVar19[iVar9] \u003d uVar27;\n      puVar17 \u003d puVar17 + -1;\n      iVar9 \u003d iVar9 + 1;\n    } while (bVar25);\n    if (2 \u003c param_5) {\n      if (param_5 \u003d\u003d 3) {\n        if (iVar5 !\u003d 0) {\n          puVar17 \u003d puVar19 + iVar5;\n          uVar27 \u003d *puVar17;\n          do {\n            uVar7 \u003d (undefined4)((ulonglong)uVar27 \u003e\u003e 0x20);\n            uVar3 \u003d (undefined4)uVar27;\n            uVar12 \u003d *(undefined4 *)(puVar17 + -1);\n            uVar22 \u003d *(undefined4 *)((int)puVar17 + -4);\n            uVar27 \u003d __aeabi_dadd(uVar3,uVar7,uVar12,uVar22);\n            uVar26 \u003d __subdf3(uVar12,uVar22,(int)uVar27,(int)((ulonglong)uVar27 \u003e\u003e 0x20));\n            uVar26 \u003d __aeabi_dadd((int)uVar26,(int)((ulonglong)uVar26 \u003e\u003e 0x20),uVar3,uVar7);\n            *puVar17 \u003d uVar26;\n            puVar17 \u003d puVar17 + -1;\n            *puVar17 \u003d uVar27;\n          } while (puVar19 !\u003d puVar17);\n          if (1 \u003c iVar5) {\n            puVar21 \u003d puVar19 + iVar5;\n            uVar27 \u003d *puVar21;\n            puVar17 \u003d puVar21;\n            do {\n              uVar7 \u003d (undefined4)((ulonglong)uVar27 \u003e\u003e 0x20);\n              uVar3 \u003d (undefined4)uVar27;\n              uVar12 \u003d *(undefined4 *)(puVar17 + -1);\n              uVar22 \u003d *(undefined4 *)((int)puVar17 + -4);\n              uVar27 \u003d __aeabi_dadd(uVar3,uVar7,uVar12,uVar22);\n              uVar26 \u003d __subdf3(uVar12,uVar22,(int)uVar27,(int)((ulonglong)uVar27 \u003e\u003e 0x20));\n              uVar26 \u003d __aeabi_dadd((int)uVar26,(int)((ulonglong)uVar26 \u003e\u003e 0x20),uVar3,uVar7);\n              *puVar17 \u003d uVar26;\n              puVar17 \u003d puVar17 + -1;\n              *puVar17 \u003d uVar27;\n            } while (\u0026local_160 !\u003d puVar17);\n            uVar27 \u003d 0;\n            puVar18 \u003d puVar19 + 2;\n            puVar17 \u003d puVar21 + 1;\n            do {\n              puVar21 \u003d puVar17 + -1;\n              uVar27 \u003d __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 \u003e\u003e 0x20),\n                                    *(undefined4 *)puVar21,*(undefined4 *)((int)puVar17 + -4));\n              puVar17 \u003d puVar21;\n            } while (puVar18 !\u003d puVar21);\n            goto LAB_0800abe4;\n          }\n        }\n        uVar27 \u003d 0;\n        goto LAB_0800abe4;\n      }\n      goto LAB_0800ab0e;\n    }\n    if (param_5 \u003c 1) {\n      if (param_5 !\u003d 0) goto LAB_0800ab0e;\n      uVar27 \u003d 0;\n      puVar17 \u003d puVar19 + iVar5 + 1;\n      do {\n        puVar21 \u003d puVar17 + -1;\n        uVar27 \u003d __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 \u003e\u003e 0x20),*(undefined4 *)puVar21,\n                              *(undefined4 *)((int)puVar17 + -4));\n        puVar17 \u003d puVar21;\n      } while (puVar19 !\u003d puVar21);\n      goto LAB_0800aafc;\n    }\n    uVar27 \u003d 0;\n    puVar17 \u003d puVar19 + iVar5 + 1;\n    do {\n      puVar21 \u003d puVar17 + -1;\n      uVar27 \u003d __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 \u003e\u003e 0x20),*(undefined4 *)puVar21,\n                            *(undefined4 *)((int)puVar17 + -4));\n      puVar17 \u003d puVar21;\n    } while (puVar19 !\u003d puVar21);\n  }\n  iVar9 \u003d (int)((ulonglong)uVar27 \u003e\u003e 0x20);\n  uVar3 \u003d (undefined4)uVar27;\n  if (iVar23 \u003d\u003d 0) {\n    *(undefined8 *)local_260[1] \u003d uVar27;\n    uVar27 \u003d __subdf3(local_168,local_164,uVar3,iVar9);\n    if (iVar5 \u003c 1) goto LAB_0800ad26;\nLAB_0800ad04:\n    iVar9 \u003d 1;\n    puVar19 \u003d (undefined8 *)\u0026local_168;\n    do {\n      uVar27 \u003d __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 \u003e\u003e 0x20),\n                            *(undefined4 *)(puVar19 + 1),*(undefined4 *)((int)puVar19 + 0xc));\n      iVar9 \u003d iVar9 + 1;\n      puVar19 \u003d puVar19 + 1;\n    } while (iVar9 \u003c\u003d iVar5);\n    if (iVar23 \u003d\u003d 0) goto LAB_0800ad26;\n  }\n  else {\n    *local_260[1] \u003d uVar3;\n    *(int *)((int)local_260[1] + 4) \u003d iVar9 + -0x80000000;\n    uVar27 \u003d __subdf3(local_168,local_164,uVar3,iVar9);\n    if (0 \u003c iVar5) goto LAB_0800ad04;\n  }\n  uVar27 \u003d CONCAT44((int)((ulonglong)uVar27 \u003e\u003e 0x20) + -0x80000000,(int)uVar27);\nLAB_0800ad26:\n  *(undefined8 *)((int)local_260[1] + 8) \u003d uVar27;\n  return uVar2 \u0026 7;\n}\n\n",
      "renaming": {},
      "calling": [
        "__ieee754_rem_pio2"
      ],
      "called": [
        "__aeabi_dcmpge",
        "__aeabi_i2d",
        "scalbn",
        "floor",
        "__aeabi_dcmpeq",
        "__subdf3",
        "__aeabi_d2iz",
        "__muldf3",
        "__aeabi_dadd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__kernel_sin": {
      "entrypoint": "0x0800adf0",
      "current_name": "__kernel_sin",
      "code": "\nundefined4\n__kernel_sin(undefined4 param_1,uint param_2,undefined4 param_3,undefined4 param_4,int param_5)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  \n  if (((param_2 \u0026 0x7fffffff) \u003c 0x3e400000) \u0026\u0026 (iVar1 \u003d __aeabi_d2iz(), iVar1 \u003d\u003d 0)) {\n    return param_1;\n  }\n  uVar7 \u003d __muldf3(param_1,param_2,param_1);\n  uVar4 \u003d (undefined4)((ulonglong)uVar7 \u003e\u003e 0x20);\n  uVar3 \u003d (undefined4)uVar7;\n  uVar7 \u003d __muldf3(param_1,param_2,uVar3,uVar4);\n  uVar5 \u003d (undefined4)((ulonglong)uVar7 \u003e\u003e 0x20);\n  uVar2 \u003d (undefined4)uVar7;\n  uVar7 \u003d __muldf3(uVar3,uVar4,0x5acfd57c,0x3de5d93a);\n  uVar7 \u003d __subdf3((int)uVar7,(int)((ulonglong)uVar7 \u003e\u003e 0x20),0x8a2b9ceb,0x3e5ae5e6);\n  uVar7 \u003d __muldf3((int)uVar7,(int)((ulonglong)uVar7 \u003e\u003e 0x20),uVar3,uVar4);\n  uVar7 \u003d __aeabi_dadd((int)uVar7,(int)((ulonglong)uVar7 \u003e\u003e 0x20),0x57b1fe7d,0x3ec71de3);\n  uVar7 \u003d __muldf3((int)uVar7,(int)((ulonglong)uVar7 \u003e\u003e 0x20),uVar3,uVar4);\n  uVar7 \u003d __subdf3((int)uVar7,(int)((ulonglong)uVar7 \u003e\u003e 0x20),0x19c161d5,0x3f2a01a0);\n  uVar7 \u003d __muldf3((int)uVar7,(int)((ulonglong)uVar7 \u003e\u003e 0x20),uVar3,uVar4);\n  uVar7 \u003d __aeabi_dadd((int)uVar7,(int)((ulonglong)uVar7 \u003e\u003e 0x20),0x1110f8a6,0x3f811111);\n  uVar6 \u003d (undefined4)((ulonglong)uVar7 \u003e\u003e 0x20);\n  if (param_5 !\u003d 0) {\n    uVar8 \u003d __muldf3(param_3,param_4,0,0x3fe00000);\n    uVar7 \u003d __muldf3(uVar2,uVar5,(int)uVar7,uVar6);\n    uVar7 \u003d __subdf3((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),(int)uVar7,\n                     (int)((ulonglong)uVar7 \u003e\u003e 0x20));\n    uVar7 \u003d __muldf3((int)uVar7,(int)((ulonglong)uVar7 \u003e\u003e 0x20),uVar3,uVar4);\n    uVar7 \u003d __subdf3((int)uVar7,(int)((ulonglong)uVar7 \u003e\u003e 0x20),param_3,param_4);\n    uVar8 \u003d __muldf3(uVar2,uVar5,0x55555549,0x3fc55555);\n    uVar7 \u003d __aeabi_dadd((int)uVar7,(int)((ulonglong)uVar7 \u003e\u003e 0x20),(int)uVar8,\n                         (int)((ulonglong)uVar8 \u003e\u003e 0x20));\n    uVar3 \u003d __subdf3(param_1,param_2,(int)uVar7,(int)((ulonglong)uVar7 \u003e\u003e 0x20));\n    return uVar3;\n  }\n  uVar7 \u003d __muldf3(uVar3,uVar4,(int)uVar7,uVar6);\n  uVar7 \u003d __subdf3((int)uVar7,(int)((ulonglong)uVar7 \u003e\u003e 0x20),0x55555549,0x3fc55555);\n  uVar7 \u003d __muldf3((int)uVar7,(int)((ulonglong)uVar7 \u003e\u003e 0x20),uVar2,uVar5);\n  uVar3 \u003d __aeabi_dadd((int)uVar7,(int)((ulonglong)uVar7 \u003e\u003e 0x20),param_1,param_2);\n  return uVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "sin",
        "cos"
      ],
      "called": [
        "__subdf3",
        "__aeabi_d2iz",
        "__aeabi_dadd",
        "__muldf3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "atan": {
      "entrypoint": "0x0800af78",
      "current_name": "atan",
      "code": "\ndouble atan(double __x)\n\n{\n  int in_r0;\n  undefined4 uVar1;\n  undefined4 uVar2;\n  uint in_r1;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 extraout_r1;\n  uint uVar5;\n  int iVar6;\n  double in_d0;\n  double dVar7;\n  double extraout_d0;\n  undefined8 uVar8;\n  undefined8 uVar9;\n  undefined4 in_stack_ffffffd0;\n  uint uVar10;\n  \n  uVar5 \u003d in_r1 \u0026 0x7fffffff;\n  if (uVar5 \u003c 0x44100000) {\n    if (uVar5 \u003c 0x3fdc0000) {\n      uVar10 \u003d in_r1;\n      if (uVar5 \u003c 0x3e200000) {\n        uVar8 \u003d __aeabi_dadd(in_r0,in_r1,0x8800759c,0x7e37e43c);\n        iVar6 \u003d __aeabi_dcmpgt((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),0,0x3ff00000);\n        if (iVar6 !\u003d 0) {\n          return extraout_d0;\n        }\n      }\n      iVar6 \u003d -1;\n    }\n    else {\n      fabs((double)CONCAT44(in_r1,in_stack_ffffffd0));\n      if (uVar5 \u003c 0x3ff30000) {\n        if (uVar5 \u003c 0x3fe60000) {\n          uVar8 \u003d __aeabi_dadd();\n          uVar8 \u003d __subdf3((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),0,0x3ff00000);\n          uVar9 \u003d __aeabi_dadd(in_r0,extraout_r1,0,0x40000000);\n          uVar8 \u003d __divdf3((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),(int)uVar9,\n                           (int)((ulonglong)uVar9 \u003e\u003e 0x20));\n          uVar10 \u003d (uint)((ulonglong)uVar8 \u003e\u003e 0x20);\n          in_r0 \u003d (int)uVar8;\n          iVar6 \u003d 0;\n        }\n        else {\n          uVar8 \u003d __subdf3();\n          uVar9 \u003d __aeabi_dadd(in_r0,extraout_r1,0,0x3ff00000);\n          uVar8 \u003d __divdf3((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),(int)uVar9,\n                           (int)((ulonglong)uVar9 \u003e\u003e 0x20));\n          uVar10 \u003d (uint)((ulonglong)uVar8 \u003e\u003e 0x20);\n          in_r0 \u003d (int)uVar8;\n          iVar6 \u003d 1;\n        }\n      }\n      else if (uVar5 \u003c 0x40038000) {\n        uVar8 \u003d __subdf3();\n        uVar9 \u003d __muldf3(in_r0,extraout_r1,0,0x3ff80000);\n        uVar9 \u003d __aeabi_dadd((int)uVar9,(int)((ulonglong)uVar9 \u003e\u003e 0x20),0,0x3ff00000);\n        uVar8 \u003d __divdf3((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),(int)uVar9,\n                         (int)((ulonglong)uVar9 \u003e\u003e 0x20));\n        uVar10 \u003d (uint)((ulonglong)uVar8 \u003e\u003e 0x20);\n        in_r0 \u003d (int)uVar8;\n        iVar6 \u003d 2;\n      }\n      else {\n        uVar8 \u003d __divdf3(0,0xbff00000,in_r0,extraout_r1);\n        uVar10 \u003d (uint)((ulonglong)uVar8 \u003e\u003e 0x20);\n        in_r0 \u003d (int)uVar8;\n        iVar6 \u003d 3;\n      }\n    }\n    uVar8 \u003d __muldf3(in_r0,uVar10,in_r0);\n    uVar3 \u003d (undefined4)((ulonglong)uVar8 \u003e\u003e 0x20);\n    uVar1 \u003d (undefined4)uVar8;\n    uVar8 \u003d __muldf3(uVar1,uVar3,uVar1,uVar3);\n    uVar4 \u003d (undefined4)((ulonglong)uVar8 \u003e\u003e 0x20);\n    uVar2 \u003d (undefined4)uVar8;\n    uVar8 \u003d __muldf3(uVar2,uVar4,0xe322da11,0x3f90ad3a);\n    uVar8 \u003d __aeabi_dadd((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),0x24760deb,0x3fa97b4b);\n    uVar8 \u003d __muldf3((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),uVar2,uVar4);\n    uVar8 \u003d __aeabi_dadd((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),0xa0d03d51,0x3fb10d66);\n    uVar8 \u003d __muldf3((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),uVar2,uVar4);\n    uVar8 \u003d __aeabi_dadd((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),0xc54c206e,0x3fb745cd);\n    uVar8 \u003d __muldf3((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),uVar2,uVar4);\n    uVar8 \u003d __aeabi_dadd((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),0x920083ff,0x3fc24924);\n    uVar8 \u003d __muldf3((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),uVar2,uVar4);\n    uVar8 \u003d __aeabi_dadd((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),0x5555550d,0x3fd55555);\n    uVar8 \u003d __muldf3((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),uVar1,uVar3);\n    uVar1 \u003d (undefined4)((ulonglong)uVar8 \u003e\u003e 0x20);\n    uVar9 \u003d __muldf3(uVar2,uVar4,0x2c6a6c2f,0xbfa2b444);\n    uVar9 \u003d __subdf3((int)uVar9,(int)((ulonglong)uVar9 \u003e\u003e 0x20),0x52defd9a,0x3fadde2d);\n    uVar9 \u003d __muldf3((int)uVar9,(int)((ulonglong)uVar9 \u003e\u003e 0x20),uVar2,uVar4);\n    uVar9 \u003d __subdf3((int)uVar9,(int)((ulonglong)uVar9 \u003e\u003e 0x20),0xaf749a6d,0x3fb3b0f2);\n    uVar9 \u003d __muldf3((int)uVar9,(int)((ulonglong)uVar9 \u003e\u003e 0x20),uVar2,uVar4);\n    uVar9 \u003d __subdf3((int)uVar9,(int)((ulonglong)uVar9 \u003e\u003e 0x20),0xfe231671,0x3fbc71c6);\n    uVar9 \u003d __muldf3((int)uVar9,(int)((ulonglong)uVar9 \u003e\u003e 0x20),uVar2,uVar4);\n    uVar9 \u003d __subdf3((int)uVar9,(int)((ulonglong)uVar9 \u003e\u003e 0x20),0x9998ebc4,0x3fc99999);\n    uVar9 \u003d __muldf3((int)uVar9,(int)((ulonglong)uVar9 \u003e\u003e 0x20),uVar2,uVar4);\n    uVar2 \u003d (undefined4)((ulonglong)uVar9 \u003e\u003e 0x20);\n    if (iVar6 \u003d\u003d -1) {\n      uVar8 \u003d __aeabi_dadd((int)uVar8,uVar1,(int)uVar9,uVar2);\n      uVar8 \u003d __muldf3((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),in_r0,uVar10);\n      dVar7 \u003d (double)__subdf3(in_r0,uVar10,(int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20));\n      return dVar7;\n    }\n    uVar8 \u003d __aeabi_dadd((int)uVar8,uVar1,(int)uVar9,uVar2);\n    uVar8 \u003d __muldf3((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),in_r0,uVar10);\n    uVar8 \u003d __subdf3((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),*(undefined4 *)(\u0026atanlo + iVar6 * 8)\n                     ,*(undefined4 *)(\u0026UNK_0800c094 + iVar6 * 8));\n    uVar8 \u003d __subdf3((int)uVar8,(int)((ulonglong)uVar8 \u003e\u003e 0x20),in_r0,uVar10);\n    in_d0 \u003d (double)__subdf3(*(undefined4 *)(\u0026atanhi + iVar6 * 8),\n                             *(undefined4 *)(\u0026UNK_0800c074 + iVar6 * 8),(int)uVar8,\n                             (int)((ulonglong)uVar8 \u003e\u003e 0x20));\n    if ((int)in_r1 \u003c 0) {\n      return in_d0;\n    }\n  }\n  else if ((0x7ff00000 \u003c uVar5) || ((uVar5 \u003d\u003d 0x7ff00000 \u0026\u0026 (in_r0 !\u003d 0)))) {\n    dVar7 \u003d (double)__aeabi_dadd();\n    return dVar7;\n  }\n  return in_d0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__ieee754_atan2"
      ],
      "called": [
        "fabs",
        "__divdf3",
        "__aeabi_dcmpgt",
        "__subdf3",
        "__aeabi_dadd",
        "__muldf3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fabs": {
      "entrypoint": "0x0800b2cc",
      "current_name": "fabs",
      "code": "\ndouble fabs(double __x)\n\n{\n  double in_d0;\n  \n  return in_d0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__ieee754_rem_pio2",
        "atan",
        "__ieee754_atan2"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "finite": {
      "entrypoint": "0x0800b2d4",
      "current_name": "finite",
      "code": "\nint finite(double __value)\n\n{\n  uint in_r1;\n  \n  return (in_r1 | 0x80000000) + 0x100000 \u003e\u003e 0x1f;\n}\n\n",
      "renaming": {},
      "calling": [
        "hypot"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "matherr": {
      "entrypoint": "0x0800b2e0",
      "current_name": "matherr",
      "code": "\nint matherr(exception *__exc)\n\n{\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "hypot",
        "sqrt"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "scalbn": {
      "entrypoint": "0x0800b2e8",
      "current_name": "scalbn",
      "code": "\ndouble scalbn(double __x,int __n)\n\n{\n  uint in_r1;\n  int in_r2;\n  uint uVar1;\n  int iVar2;\n  uint uVar3;\n  double in_d0;\n  double extraout_d0;\n  double dVar4;\n  undefined8 uVar5;\n  \n  uVar5 \u003d CONCAT44(in_r1,__n);\n  uVar1 \u003d (in_r1 \u003c\u003c 1) \u003e\u003e 0x15;\n  if (uVar1 \u003d\u003d 0) {\n    if ((__n | in_r1 \u0026 0x7fffffff) \u003d\u003d 0) {\n      return in_d0;\n    }\n    uVar5 \u003d __muldf3(__n,in_r1,0,0x43500000);\n    if (in_r2 \u003c -50000) goto LAB_0800b34a;\n    uVar1 \u003d ((uint)((int)((ulonglong)uVar5 \u003e\u003e 0x20) \u003c\u003c 1) \u003e\u003e 0x15) - 0x36;\n    in_d0 \u003d extraout_d0;\n  }\n  else if (uVar1 \u003d\u003d 0x7ff) {\n    dVar4 \u003d (double)__aeabi_dadd(__n,in_r1,__n);\n    return dVar4;\n  }\n  uVar3 \u003d (uint)((ulonglong)uVar5 \u003e\u003e 0x20);\n  iVar2 \u003d uVar1 + in_r2;\n  if (iVar2 \u003c 0x7ff) {\n    if (0 \u003c iVar2) {\n      return in_d0;\n    }\n    if (iVar2 + 0x35 \u003c 0 \u003d\u003d SCARRY4(iVar2,0x35)) {\n      dVar4 \u003d (double)__muldf3((int)uVar5,uVar3 \u0026 0x800fffff | (iVar2 + 0x36) * 0x100000,0,\n                               0x3c900000);\n      return dVar4;\n    }\n    if (in_r2 \u003c 0xc351) {\n      uVar5 \u003d CONCAT44(uVar3 \u0026 0x80000000 | 0x1a56e1f,0xc2f8f359);\nLAB_0800b34a:\n      dVar4 \u003d (double)__muldf3((int)uVar5,(int)((ulonglong)uVar5 \u003e\u003e 0x20),0xc2f8f359,0x1a56e1f);\n      return dVar4;\n    }\n  }\n  dVar4 \u003d (double)__muldf3(0x8800759c,uVar3 \u0026 0x80000000 | 0x7e37e43c,0x8800759c,0x7e37e43c);\n  return dVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "__kernel_rem_pio2"
      ],
      "called": [
        "__muldf3",
        "__aeabi_dadd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__errno": {
      "entrypoint": "0x0800b3dc",
      "current_name": "__errno",
      "code": "\nundefined4 __errno(void)\n\n{\n  return _impure_ptr;\n}\n\n",
      "renaming": {},
      "calling": [
        "hypot",
        "sqrt"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__libc_init_array": {
      "entrypoint": "0x0800b3e8",
      "current_name": "__libc_init_array",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x0800b3f4) */\n/* WARNING: Removing unreachable block (ram,0x0800b3f6) */\n\nvoid __libc_init_array(EVP_PKEY_CTX *param_1)\n\n{\n  int iVar1;\n  code **ppcVar2;\n  \n  _init(param_1);\n  iVar1 \u003d 0;\n  ppcVar2 \u003d (code **)\u0026__preinit_array_end;\n  do {\n    iVar1 \u003d iVar1 + 1;\n    (**ppcVar2)();\n    ppcVar2 \u003d ppcVar2 + 1;\n  } while (iVar1 !\u003d 2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "Reset_Handler"
      ],
      "called": [
        "_init",
        "frame_dummy",
        "register_fini"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memset": {
      "entrypoint": "0x0800b430",
      "current_name": "memset",
      "code": "\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  uint uVar1;\n  uint *puVar2;\n  uint *puVar3;\n  uint *puVar4;\n  uint uVar5;\n  bool bVar6;\n  \n  puVar2 \u003d (uint *)__s;\n  if (((uint)__s \u0026 3) !\u003d 0) {\n    uVar5 \u003d __n - 1;\n    puVar3 \u003d (uint *)__s;\n    if (__n \u003d\u003d 0) {\n      return __s;\n    }\n    while( true ) {\n      puVar2 \u003d (uint *)((int)puVar3 + 1);\n      *(char *)puVar3 \u003d (char)__c;\n      __n \u003d uVar5;\n      if (((uint)puVar2 \u0026 3) \u003d\u003d 0) break;\n      bVar6 \u003d uVar5 \u003d\u003d 0;\n      uVar5 \u003d uVar5 - 1;\n      puVar3 \u003d puVar2;\n      if (bVar6) {\n        return __s;\n      }\n    }\n  }\n  if (3 \u003c __n) {\n    uVar5 \u003d __c \u0026 0xffU | (__c \u0026 0xffU) \u003c\u003c 8;\n    uVar5 \u003d uVar5 | uVar5 \u003c\u003c 0x10;\n    if (0xf \u003c __n) {\n      puVar3 \u003d puVar2 + 4;\n      do {\n        puVar3[-4] \u003d uVar5;\n        puVar3[-3] \u003d uVar5;\n        puVar3[-2] \u003d uVar5;\n        puVar3[-1] \u003d uVar5;\n        puVar3 \u003d puVar3 + 4;\n      } while (puVar3 !\u003d (uint *)((int)puVar2 + (__n - 0x10 \u0026 0xfffffff0) + 0x20));\n      uVar1 \u003d __n \u0026 0xc;\n      puVar2 \u003d puVar2 + ((__n - 0x10 \u003e\u003e 4) + 1) * 4;\n      __n \u003d __n \u0026 0xf;\n      if (uVar1 \u003d\u003d 0) goto joined_r0x0800b4a8;\n    }\n    puVar3 \u003d (uint *)((__n - 4 \u0026 0xfffffffc) + 4 + (int)puVar2);\n    do {\n      puVar4 \u003d puVar2 + 1;\n      *puVar2 \u003d uVar5;\n      puVar2 \u003d puVar4;\n    } while (puVar3 !\u003d puVar4);\n    __n \u003d __n \u0026 3;\n    puVar2 \u003d puVar3;\n  }\njoined_r0x0800b4a8:\n  if (__n !\u003d 0) {\n    puVar3 \u003d puVar2;\n    do {\n      puVar4 \u003d (uint *)((int)puVar3 + 1);\n      *(char *)puVar3 \u003d (char)__c;\n      puVar3 \u003d puVar4;\n    } while ((uint *)(__n + (int)puVar2) !\u003d puVar4);\n  }\n  return __s;\n}\n\n",
      "renaming": {},
      "calling": [
        "gc_execute_line",
        "settings_read_coord_data",
        "homing_cycle",
        "debounce_init",
        "plan_init",
        "grbl_main",
        "st_reset",
        "gc_init",
        "eeprom_init",
        "mc_go_home"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "register_fini": {
      "entrypoint": "0x0800b4d0",
      "current_name": "register_fini",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x0800b4d4) */\n\nvoid register_fini(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_init_array"
      ],
      "called": [
        "atexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "atexit": {
      "entrypoint": "0x0800b4e4",
      "current_name": "atexit",
      "code": "\nint atexit(__func *__func)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d __register_exitproc(0,__func,0);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "register_fini"
      ],
      "called": [
        "__register_exitproc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__libc_fini_array": {
      "entrypoint": "0x0800b4f0",
      "current_name": "__libc_fini_array",
      "code": "\nvoid __libc_fini_array(void)\n\n{\n  int iVar1;\n  code **ppcVar2;\n  \n  iVar1 \u003d 1;\n  ppcVar2 \u003d (code **)\u0026__do_global_dtors_aux_fini_array_entry;\n  do {\n    iVar1 \u003d iVar1 + -1;\n    (**ppcVar2)();\n    ppcVar2 \u003d ppcVar2 + -1;\n  } while (iVar1 !\u003d 0);\n  _fini();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_fini",
        "__do_global_dtors_aux",
        "frame_dummy"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__retarget_lock_acquire_recursive": {
      "entrypoint": "0x0800b51c",
      "current_name": "__retarget_lock_acquire_recursive",
      "code": "\nvoid __retarget_lock_acquire_recursive(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__register_exitproc"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__retarget_lock_release_recursive": {
      "entrypoint": "0x0800b520",
      "current_name": "__retarget_lock_release_recursive",
      "code": "\nvoid __retarget_lock_release_recursive(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__register_exitproc"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__register_exitproc": {
      "entrypoint": "0x0800b524",
      "current_name": "__register_exitproc",
      "code": "\nundefined4 __register_exitproc(int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined *puVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  __retarget_lock_acquire_recursive(__atexit_recursive_mutex);\n  if (DAT_20000168 \u003d\u003d (undefined *)0x0) {\n    DAT_20000168 \u003d \u0026DAT_2000016c;\n  }\n  puVar1 \u003d DAT_20000168;\n  uVar4 \u003d *(uint *)(DAT_20000168 + 4);\n  if ((int)uVar4 \u003c 0x20) {\n    if (param_1 !\u003d 0) {\n      *(undefined4 *)(DAT_20000168 + uVar4 * 4 + 0x88) \u003d param_3;\n      uVar3 \u003d 1 \u003c\u003c (uVar4 \u0026 0xff);\n      *(uint *)(puVar1 + 0x188) \u003d *(uint *)(puVar1 + 0x188) | uVar3;\n      *(undefined4 *)(puVar1 + uVar4 * 4 + 0x108) \u003d param_4;\n      if (param_1 \u003d\u003d 2) {\n        *(uint *)(puVar1 + 0x18c) \u003d uVar3 | *(uint *)(puVar1 + 0x18c);\n      }\n    }\n    uVar2 \u003d __atexit_recursive_mutex;\n    *(uint *)(puVar1 + 4) \u003d uVar4 + 1;\n    *(undefined4 *)(puVar1 + (uVar4 + 2) * 4) \u003d param_2;\n    __retarget_lock_release_recursive(uVar2);\n    uVar2 \u003d 0;\n  }\n  else {\n    __retarget_lock_release_recursive(__atexit_recursive_mutex);\n    uVar2 \u003d 0xffffffff;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "atexit"
      ],
      "called": [
        "__retarget_lock_acquire_recursive",
        "__retarget_lock_release_recursive"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_init": {
      "entrypoint": "0x0800b5b0",
      "current_name": "_init",
      "code": "\nint _init(EVP_PKEY_CTX *ctx)\n\n{\n  return (int)ctx;\n}\n\n",
      "renaming": {},
      "calling": [
        "__do_global_dtors_aux",
        "__libc_init_array",
        "frame_dummy"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fini": {
      "entrypoint": "0x0800b5bc",
      "current_name": "_fini",
      "code": "\nvoid _fini(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_fini_array"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    }
  },
  "layers": [],
  "locked_functions": [],
  "used_tokens": 0
}