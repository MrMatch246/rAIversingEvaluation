{
    "functions": {
        "spindle_run": {
            "renaming": {}, 
            "code": "\nvoid spindle_run(int8_t direction)\n\n{\n  if ((int)direction != (uint)(byte)*PTR_current_direction_080052a8) {\n    plan_synchronize();\n    if (direction == '\\0') {\n      spindle_stop();\n    }\n    else {\n      if (direction < '\\x01') {\n        spindle_rev();\n      }\n      else {\n        spindle_fwd();\n      }\n      spindle_on();\n    }\n    *PTR_current_direction_080052a8 = direction;\n  }\n  return;\n}\n\n", 
            "called": [
                "spindle_rev", 
                "spindle_fwd", 
                "plan_synchronize", 
                "spindle_on", 
                "spindle_stop"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800525c", 
            "calling": [
                "gc_execute_line"
            ], 
            "imported": false, 
            "current_name": "spindle_run"
        }, 
        "set_step_period": {
            "renaming": {}, 
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid set_step_period(uint32_t ticks)\n\n{\n  uint32_t saved;\n  TIM_TypeDef *TIMx;\n  \n  _DAT_4000002c = ticks;\n  if (ticks <= _DAT_40000024) {\n    _DAT_40000024 = ticks;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007bf0", 
            "calling": [
                "set_step_events_per_minute"
            ], 
            "imported": false, 
            "current_name": "set_step_period"
        }, 
        "set_step_pulse_time": {
            "renaming": {}, 
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid set_step_pulse_time(uint32_t ticks)\n\n{\n  TIM_TypeDef *TIMx;\n  \n  _DAT_40000038 = ticks;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007c5e", 
            "calling": [
                "st_wake_up"
            ], 
            "imported": false, 
            "current_name": "set_step_pulse_time"
        }, 
        "serial_init": {
            "renaming": {}, 
            "code": "\nvoid serial_init(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008244", 
            "calling": [
                "grbl_main"
            ], 
            "imported": false, 
            "current_name": "serial_init"
        }, 
        "planner_recalculate_trapezoids": {
            "renaming": {}, 
            "code": "\nvoid planner_recalculate_trapezoids(void)\n\n{\n  block_t *pbVar1;\n  undefined8 uVar2;\n  block_t *current;\n  block_t *next;\n  uint8_t block_index;\n  \n  block_index = *PTR_block_buffer_tail_08002ed0;\n  next = (block_t *)0x0;\n  while (block_index != *PTR_block_buffer_head_08002ed8) {\n    pbVar1 = (block_t *)(PTR_block_buffer_08002ed4 + (uint)block_index * 0x40);\n    if ((next != (block_t *)0x0) &&\n       ((next->recalculate_flag != '\\0' || (pbVar1->recalculate_flag != '\\0')))) {\n      __aeabi_fdiv(next->entry_speed,next->nominal_speed);\n      uVar2 = __aeabi_fdiv(pbVar1->entry_speed,next->nominal_speed);\n      calculate_trapezoid_for_block(next,(float)uVar2,(float)((ulonglong)uVar2 >> 0x20));\n      next->recalculate_flag = '\\0';\n    }\n    block_index = next_block_index(block_index);\n    next = pbVar1;\n  }\n  __aeabi_fdiv(next->entry_speed,next->nominal_speed);\n  uVar2 = __aeabi_fdiv(0,next->nominal_speed);\n  calculate_trapezoid_for_block(next,(float)uVar2,(float)((ulonglong)uVar2 >> 0x20));\n  next->recalculate_flag = '\\0';\n  return;\n}\n\n", 
            "called": [
                "next_block_index", 
                "__aeabi_fdiv", 
                "calculate_trapezoid_for_block"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002e08", 
            "calling": [
                "planner_recalculate"
            ], 
            "imported": false, 
            "current_name": "planner_recalculate_trapezoids"
        }, 
        "HAL_RCC_GetSysClockFreq": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_RCC_GetSysClockFreq(void)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint32_t result_6;\n  uint32_t result_7;\n  uint32_t result_4;\n  uint32_t result_5;\n  uint32_t result_2;\n  uint32_t result_3;\n  uint32_t result;\n  uint32_t result_1;\n  uint32_t pllp;\n  uint32_t pllm;\n  uint32_t sysclockfreq;\n  uint32_t pllvco;\n  \n  uVar1 = *(uint *)(DAT_0800661c + 8) & 0xc;\n  if (uVar1 == 8) {\n    uVar2 = *(uint *)(DAT_0800661c + 4) & 0x3f;\n    uVar1 = count_leading_zeroes(0x200);\n    if ((*(uint *)(DAT_0800661c + 4) & 0x400000) >> (uVar1 & 0xff) == 0) {\n      uVar1 = count_leading_zeroes(0x3fe0000);\n      pllvco = ((*(uint *)(DAT_0800661c + 4) & 0x7fc0) >> (uVar1 & 0xff)) * (DAT_08006620 / uVar2);\n    }\n    else {\n      uVar1 = count_leading_zeroes(0x3fe0000);\n      pllvco = ((*(uint *)(DAT_0800661c + 4) & 0x7fc0) >> (uVar1 & 0xff)) * (DAT_08006624 / uVar2);\n    }\n    uVar1 = count_leading_zeroes(0xc000);\n    return pllvco / ((((*(uint *)(DAT_0800661c + 4) & 0x30000) >> (uVar1 & 0xff)) + 1) * 2);\n  }\n  if (uVar1 < 9) {\n    if (uVar1 == 0) {\n      return DAT_08006620;\n    }\n    if (uVar1 == 4) {\n      return DAT_08006624;\n    }\n  }\n  return DAT_08006620;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080064ec", 
            "calling": [
                "HAL_RCC_GetHCLKFreq"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_GetSysClockFreq"
        }, 
        "NVIC_SetPriority": {
            "renaming": {}, 
            "code": "\nvoid NVIC_SetPriority(IRQn_Type IRQn,uint32_t priority)\n\n{\n  if (IRQn < WWDG_IRQn) {\n    *(char *)(((byte)IRQn & 0xf) + DAT_08006b4c + 0x14) = (char)((priority & 0xff) << 4);\n  }\n  else {\n    *(char *)(IRQn + DAT_08006b50 + 0x300) = (char)((priority & 0xff) << 4);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006b00", 
            "calling": [
                "SysTick_Config", 
                "HAL_NVIC_SetPriority"
            ], 
            "imported": false, 
            "current_name": "NVIC_SetPriority"
        }, 
        "print_uint16_base2": {
            "renaming": {}, 
            "code": "\nvoid print_uint16_base2(uint16_t n)\n\n{\n  print_base2((uint)n,0x10);\n  return;\n}\n\n", 
            "called": [
                "print_base2"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800375c", 
            "calling": [
                "report_grbl_settings"
            ], 
            "imported": false, 
            "current_name": "print_uint16_base2"
        }, 
        "NMI_Handler": {
            "renaming": {}, 
            "code": "\nvoid NMI_Handler(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800770e", 
            "calling": [], 
            "imported": false, 
            "current_name": "NMI_Handler"
        }, 
        "plan_get_current_block": {
            "renaming": {}, 
            "code": "\nblock_t * plan_get_current_block(void)\n\n{\n  block_t *pbVar1;\n  \n  if (*PTR_block_buffer_head_08002fa0 == *PTR_block_buffer_tail_08002fa4) {\n    pbVar1 = (block_t *)0x0;\n  }\n  else {\n    pbVar1 = (block_t *)\n             (PTR_block_buffer_08002fa8 + (uint)(byte)*PTR_block_buffer_tail_08002fa4 * 0x40);\n  }\n  return pbVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002f74", 
            "calling": [
                "step_period_isr", 
                "plan_synchronize"
            ], 
            "imported": false, 
            "current_name": "plan_get_current_block"
        }, 
        "timers_init": {
            "renaming": {}, 
            "code": "\nvoid timers_init(void)\n\n{\n  step_timer_init();\n  g540_timer_init();\n  g540_timer_start();\n  return;\n}\n\n", 
            "called": [
                "step_timer_init", 
                "g540_timer_init", 
                "g540_timer_start"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007e08", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "timers_init"
        }, 
        "step_wr": {
            "renaming": {}, 
            "code": "\nvoid step_wr(uint32_t x)\n\n{\n  uint32_t val;\n  \n  *(uint32_t *)(DAT_080052d8 + 0x14) = x | *(uint *)(DAT_080052d8 + 0x14) & 0xfffffaaf;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080052ac", 
            "calling": [
                "st_init", 
                "step_pulse_isr", 
                "step_delay_isr"
            ], 
            "imported": false, 
            "current_name": "step_wr"
        }, 
        "HAL_NVIC_SetPriorityGrouping": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)\n\n{\n  NVIC_SetPriorityGrouping(PriorityGroup);\n  return;\n}\n\n", 
            "called": [
                "NVIC_SetPriorityGrouping"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006ce0", 
            "calling": [
                "HAL_Init"
            ], 
            "imported": false, 
            "current_name": "HAL_NVIC_SetPriorityGrouping"
        }, 
        "__aeabi_cfcmpeq": {
            "renaming": {}, 
            "code": "\nundefined8 __aeabi_cfcmpeq(undefined4 param_1,undefined4 param_2)\n\n{\n  __cmpsf2();\n  return CONCAT44(param_2,param_1);\n}\n\n", 
            "called": [
                "__cmpsf2"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009204", 
            "calling": [
                "__aeabi_fcmpeq", 
                "__aeabi_fcmple", 
                "__aeabi_cfrcmple", 
                "__aeabi_fcmplt"
            ], 
            "imported": false, 
            "current_name": "__aeabi_cfcmpeq"
        }, 
        "st_cycle_reinitialize": {
            "renaming": {}, 
            "code": "\nvoid st_cycle_reinitialize(void)\n\n{\n  if (*(int *)PTR_current_block_080058f0 == 0) {\n    PTR_sys_080058fc[1] = 0;\n  }\n  else {\n    plan_cycle_reinitialize\n              (*(int *)(*(int *)PTR_current_block_080058f0 + 0x10) -\n               *(int *)(PTR_st_080058f4 + 0x10));\n    *(undefined4 *)(PTR_st_080058f4 + 0x1c) = 0;\n    set_step_events_per_minute(*(uint32_t *)(PTR_st_080058f4 + 0x1c));\n    *(undefined4 *)(PTR_st_080058f4 + 0x18) = DAT_080058f8;\n    *(undefined4 *)(PTR_st_080058f4 + 0x10) = 0;\n    PTR_sys_080058fc[1] = 2;\n  }\n  return;\n}\n\n", 
            "called": [
                "set_step_events_per_minute", 
                "plan_cycle_reinitialize"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080058a0", 
            "calling": [
                "protocol_execute_runtime"
            ], 
            "imported": false, 
            "current_name": "st_cycle_reinitialize"
        }, 
        "NVIC_EncodePriority": {
            "renaming": {}, 
            "code": "\nuint32_t NVIC_EncodePriority(uint32_t PriorityGroup,uint32_t PreemptPriority,uint32_t SubPriority)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint32_t SubPriorityBits;\n  uint32_t PreemptPriorityBits;\n  uint32_t PriorityGroupTmp;\n  \n  uVar1 = PriorityGroup & 7;\n  uVar2 = 7 - uVar1;\n  if (3 < uVar2) {\n    uVar2 = 4;\n  }\n  if (uVar1 + 4 < 7) {\n    uVar1 = 0;\n  }\n  else {\n    uVar1 = uVar1 - 3;\n  }\n  return SubPriority & (1 << (uVar1 & 0xff)) - 1U |\n         ((1 << (uVar2 & 0xff)) - 1U & PreemptPriority) << (uVar1 & 0xff);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006ba0", 
            "calling": [
                "HAL_NVIC_SetPriority"
            ], 
            "imported": false, 
            "current_name": "NVIC_EncodePriority"
        }, 
        "st_wake_up": {
            "renaming": {}, 
            "code": "\nvoid st_wake_up(void)\n\n{\n  stepper_motor_enable();\n  if (PTR_sys_080057d4[1] == '\\x03') {\n    *(undefined2 *)PTR_step_bits_080057dc = *(undefined2 *)(PTR_settings_080057d8 + 0x18);\n    *(undefined2 *)PTR_dirn_bits_080057e0 = *(undefined2 *)(PTR_settings_080057d8 + 0x1a);\n    set_step_pulse_delay(0x69);\n    set_step_pulse_time(((byte)PTR_settings_080057d8[0xd] + 5) * 0x15);\n    step_isr_enable();\n  }\n  return;\n}\n\n", 
            "called": [
                "set_step_pulse_delay", 
                "step_isr_enable", 
                "stepper_motor_enable", 
                "set_step_pulse_time"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005790", 
            "calling": [
                "st_init", 
                "limits_go_home", 
                "st_cycle_start"
            ], 
            "imported": false, 
            "current_name": "st_wake_up"
        }, 
        "plan_reset_buffer": {
            "renaming": {}, 
            "code": "\nvoid plan_reset_buffer(void)\n\n{\n  uint8_t uVar1;\n  \n  *PTR_block_buffer_tail_08002f1c = *PTR_block_buffer_head_08002f18;\n  uVar1 = next_block_index(*PTR_block_buffer_head_08002f18);\n  *PTR_next_buffer_head_08002f20 = uVar1;\n  return;\n}\n\n", 
            "called": [
                "next_block_index"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002ef0", 
            "calling": [
                "plan_init"
            ], 
            "imported": false, 
            "current_name": "plan_reset_buffer"
        }, 
        "spindle_rev": {
            "renaming": {}, 
            "code": "\nvoid spindle_rev(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800522c", 
            "calling": [
                "spindle_run"
            ], 
            "imported": false, 
            "current_name": "spindle_rev"
        }, 
        "frame_dummy": {
            "renaming": {}, 
            "code": "\nundefined8 frame_dummy(undefined *param_1,undefined *param_2)\n\n{\n  if (DAT_080001bc != 0) {\n    param_1 = PTR__init_080001c4;\n    param_2 = PTR_object_8916_080001c0;\n  }\n  return CONCAT44(param_2,param_1);\n}\n\n", 
            "called": [
                "_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080001ac", 
            "calling": [
                "__libc_fini_array", 
                "__libc_init_array"
            ], 
            "imported": false, 
            "current_name": "frame_dummy"
        }, 
        "HAL_SYSTICK_Callback": {
            "renaming": {}, 
            "code": "\nvoid HAL_SYSTICK_Callback(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006e7c", 
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_SYSTICK_Callback"
        }, 
        "__aeabi_dcmpgt": {
            "renaming": {}, 
            "code": "\nbool __aeabi_dcmpgt(void)\n\n{\n  char in_CY;\n  \n  __aeabi_cdrcmple();\n  return in_CY == '\\0';\n}\n\n", 
            "called": [
                "__aeabi_cdrcmple"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008b60", 
            "calling": [
                "atan", 
                "plan_buffer_line", 
                "floor", 
                "ceil"
            ], 
            "imported": false, 
            "current_name": "__aeabi_dcmpgt"
        }, 
        "HAL_RCC_GetPCLK2Freq": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_RCC_GetPCLK2Freq(void)\n\n{\n  uint32_t uVar1;\n  uint uVar2;\n  uint32_t result;\n  uint32_t result_1;\n  \n  uVar1 = HAL_RCC_GetHCLKFreq();\n  uVar2 = count_leading_zeroes(0x70000);\n  return uVar1 >> PTR_APBAHBPrescTable_08006714\n                  [(*(uint *)(DAT_08006710 + 8) & 0xe000) >> (uVar2 & 0xff)];\n}\n\n", 
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080066cc", 
            "calling": [
                "set_baud_rate"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_GetPCLK2Freq"
        }, 
        "plan_check_full_buffer": {
            "renaming": {}, 
            "code": "\nuint8_t plan_check_full_buffer(void)\n\n{\n  return *PTR_block_buffer_tail_08002fcc == *PTR_next_buffer_head_08002fd0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002fac", 
            "calling": [
                "mc_line"
            ], 
            "imported": false, 
            "current_name": "plan_check_full_buffer"
        }, 
        "iterate_trapezoid_cycle_counter": {
            "renaming": {}, 
            "code": "\nint iterate_trapezoid_cycle_counter(void)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  *(int *)(PTR_st_08005398 + 0x18) =\n       *(int *)(PTR_st_08005398 + 0x14) + *(int *)(PTR_st_08005398 + 0x18);\n  uVar1 = DAT_0800539c;\n  uVar2 = *(uint *)(PTR_st_08005398 + 0x18);\n  if (DAT_0800539c < uVar2) {\n    *(int *)(PTR_st_08005398 + 0x18) = *(int *)(PTR_st_08005398 + 0x18) + -420000;\n  }\n  return (uint)(uVar1 < uVar2);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005360", 
            "calling": [
                "step_period_isr"
            ], 
            "imported": false, 
            "current_name": "iterate_trapezoid_cycle_counter"
        }, 
        "HAL_GPIO_TogglePin": {
            "renaming": {}, 
            "code": "\nvoid HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx,uint16_t GPIO_Pin)\n\n{\n  GPIOx->ODR = GPIOx->ODR ^ (uint)GPIO_Pin;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800736c", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_GPIO_TogglePin"
        }, 
        "HAL_RCC_GetHCLKFreq": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_RCC_GetHCLKFreq(void)\n\n{\n  uint32_t uVar1;\n  uint uVar2;\n  uint32_t result;\n  uint32_t result_1;\n  \n  uVar1 = HAL_RCC_GetSysClockFreq();\n  uVar2 = count_leading_zeroes(0xf000000);\n  *(uint32_t *)PTR_SystemCoreClock_0800667c =\n       uVar1 >> PTR_APBAHBPrescTable_08006678\n                [(*(uint *)(DAT_08006674 + 8) & 0xf0) >> (uVar2 & 0xff)];\n  return *(uint32_t *)PTR_SystemCoreClock_0800667c;\n}\n\n", 
            "called": [
                "HAL_RCC_GetSysClockFreq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006628", 
            "calling": [
                "HAL_RCC_GetPCLK2Freq", 
                "HAL_RCC_ClockConfig", 
                "HAL_RCC_GetPCLK1Freq"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_GetHCLKFreq"
        }, 
        "HAL_NVIC_SetPendingIRQ": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)\n\n{\n  NVIC_SetPendingIRQ(IRQn);\n  return;\n}\n\n", 
            "called": [
                "NVIC_SetPendingIRQ"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006dc4", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_NVIC_SetPendingIRQ"
        }, 
        "startForkserver": {
            "renaming": {}, 
            "code": "\nint startForkserver(int ticks)\n\n{\n  uint32_t uVar1;\n  \n  if (*(int *)PTR_noHyperCall_080059b0 == 0) {\n    uVar1 = aflCall(1,ticks,0);\n  }\n  else {\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n", 
            "called": [
                "aflCall"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005984", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "startForkserver"
        }, 
        "__aeabi_f2d": {
            "renaming": {}, 
            "code": "\nulonglong __aeabi_f2d(uint param_1,undefined4 param_2,undefined4 param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  uint uVar7;\n  uint in_r12;\n  bool bVar8;\n  bool bVar9;\n  bool bVar10;\n  \n  uVar5 = param_1 << 1;\n  bVar9 = uVar5 == 0;\n  uVar1 = (uint)((param_1 & 0x80000000) != 0) << 0x1f;\n  uVar4 = (uint)((int)uVar5 >> 3) >> 1;\n  uVar3 = uVar1 | uVar4;\n  param_1 = param_1 << 0x1d;\n  if (!bVar9) {\n    param_4 = uVar5 & 0xff000000;\n    bVar9 = param_4 == 0;\n  }\n  if (!bVar9) {\n    bVar9 = param_4 == 0xff000000;\n  }\n  if (!bVar9) {\n    return CONCAT44(uVar3,param_1) ^ 0x3800000000000000;\n  }\n  if ((uVar5 & 0xffffff) == 0) {\n    return CONCAT44(uVar3,param_1);\n  }\n  if (param_4 == 0xff000000) {\n    return CONCAT44(uVar3,param_1) | 0x8000000000000;\n  }\n  uVar2 = param_1;\n  uVar5 = uVar4;\n  if (uVar4 == 0) {\n    uVar2 = 0;\n    uVar5 = param_1;\n  }\n  iVar6 = count_leading_zeroes(uVar5);\n  if (uVar4 == 0) {\n    iVar6 = iVar6 + 0x20;\n  }\n  uVar7 = iVar6 - 0xb;\n  bVar10 = SBORROW4(uVar7,0x20);\n  uVar4 = iVar6 - 0x2b;\n  bVar9 = (int)uVar4 < 0;\n  bVar8 = uVar4 == 0;\n  if ((int)uVar7 < 0x20) {\n    bVar10 = SCARRY4(uVar4,0xc);\n    iVar6 = iVar6 + -0x1f;\n    bVar9 = iVar6 < 0;\n    bVar8 = iVar6 == 0;\n    uVar4 = uVar7;\n    if (!bVar8 && bVar9 == bVar10) {\n      uVar2 = uVar5 << (uVar7 & 0xff);\n      uVar5 = uVar5 >> (0xcU - iVar6 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bVar8 || bVar9 != bVar10) {\n    in_r12 = 0x20 - uVar4;\n  }\n  uVar5 = uVar5 << (uVar4 & 0xff);\n  if (bVar8 || bVar9 != bVar10) {\n    uVar5 = uVar5 | uVar2 >> (in_r12 & 0xff);\n  }\n  if (bVar8 || bVar9 != bVar10) {\n    uVar2 = uVar2 << (uVar4 & 0xff);\n  }\nLAB_08008458:\n  if ((int)uVar7 < 0x381) {\n    return CONCAT44(uVar5 + (0x380 - uVar7) * 0x100000 | uVar1,uVar2);\n  }\n  uVar4 = ~(0x380 - uVar7);\n  if (0x1e < (int)uVar4) {\n    return CONCAT44(uVar3,uVar5 >> (uVar4 - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  iVar6 = uVar4 - 0x13;\n  if (iVar6 == 0 || iVar6 < 0 != SCARRY4(uVar4 - 0x1f,0xc)) {\n    uVar4 = uVar4 + 1;\n    return CONCAT44(uVar1 | uVar5 >> (uVar4 & 0xff),\n                    uVar2 >> (uVar4 & 0xff) | uVar5 << (0x20 - uVar4 & 0xff));\n  }\n  return CONCAT44(uVar3,uVar2 >> (0x20 - (0xcU - iVar6) & 0xff) | uVar5 << (0xcU - iVar6 & 0xff)) &\n         0x80000000ffffffff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008590", 
            "calling": [
                "report_realtime_status", 
                "to_millimeters", 
                "max_allowable_speed", 
                "protocol_execute_line", 
                "settings_store_global_setting", 
                "read_float", 
                "report_gcode_modes", 
                "homing_cycle", 
                "mc_arc", 
                "plan_buffer_line", 
                "mc_dwell", 
                "calculate_trapezoid_for_block", 
                "gc_execute_line", 
                "report_gcode_parameters"
            ], 
            "imported": false, 
            "current_name": "__aeabi_f2d"
        }, 
        "_delay_us": {
            "renaming": {}, 
            "code": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nvoid _delay_us(uint _us)\n\n{\n  uint uVar1;\n  bool bVar2;\n  uint64_t uVar3;\n  uint64_t uVar4;\n  uint64_t timeout;\n  \n  uVar3 = get_current_usecs();\n  do {\n    uVar4 = get_current_usecs();\n    uVar1 = (uint)(uVar4 >> 0x20);\n    timeout._0_4_ = (uint)(uVar3 + _us);\n    timeout._4_4_ = (uint)(uVar3 + _us >> 0x20);\n    bVar2 = timeout._4_4_ <= uVar1;\n    if (uVar1 == timeout._4_4_) {\n      bVar2 = (uint)timeout <= (uint)uVar4;\n    }\n  } while (!bVar2);\n  return;\n}\n\n", 
            "called": [
                "get_current_usecs"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080002b6", 
            "calling": [], 
            "imported": false, 
            "current_name": "_delay_us"
        }, 
        "HAL_NVIC_SetPriority": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_SetPriority(IRQn_Type IRQn,uint32_t PreemptPriority,uint32_t SubPriority)\n\n{\n  uint32_t uVar1;\n  uint32_t prioritygroup;\n  \n  uVar1 = NVIC_GetPriorityGrouping();\n  uVar1 = NVIC_EncodePriority(uVar1,PreemptPriority,SubPriority);\n  NVIC_SetPriority(IRQn,uVar1);\n  return;\n}\n\n", 
            "called": [
                "NVIC_EncodePriority", 
                "NVIC_SetPriority", 
                "NVIC_GetPriorityGrouping"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006cf6", 
            "calling": [
                "enable_tim_interrupt"
            ], 
            "imported": false, 
            "current_name": "HAL_NVIC_SetPriority"
        }, 
        "__aeabi_fcmpgt": {
            "renaming": {}, 
            "code": "\nbool __aeabi_fcmpgt(void)\n\n{\n  char in_CY;\n  \n  __aeabi_cfrcmple();\n  return in_CY == '\\0';\n}\n\n", 
            "called": [
                "__aeabi_cfrcmple"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009264", 
            "calling": [
                "planner_reverse_pass_kernel", 
                "plan_buffer_line"
            ], 
            "imported": false, 
            "current_name": "__aeabi_fcmpgt"
        }, 
        "settings_read_startup_line": {
            "renaming": {}, 
            "code": "\nuint8_t settings_read_startup_line(uint8_t n,char *line)\n\n{\n  int iVar1;\n  uint16_t addr;\n  \n  iVar1 = memcpy_from_eeprom_with_checksum(line,(uint)(ushort)((ushort)n * 0x101 + 0x300),0x100);\n  if (iVar1 == 0) {\n    *line = '\\0';\n    settings_store_startup_line(n,line);\n  }\n  return iVar1 != 0;\n}\n\n", 
            "called": [
                "settings_store_startup_line", 
                "memcpy_from_eeprom_with_checksum"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004d2c", 
            "calling": [
                "protocol_execute_startup", 
                "protocol_execute_line"
            ], 
            "imported": false, 
            "current_name": "settings_read_startup_line"
        }, 
        "settings_store_global_setting": {
            "renaming": {}, 
            "code": "\nuint8_t settings_store_global_setting(int parameter,float value)\n\n{\n  undefined uVar1;\n  undefined2 uVar2;\n  int iVar3;\n  undefined4 uVar4;\n  uint in_r1;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined4 extraout_r1_03;\n  undefined4 extraout_r1_04;\n  undefined4 extraout_r1_05;\n  undefined4 extraout_r1_06;\n  \n  switch(parameter) {\n  case 0:\n  case 1:\n  case 2:\n    iVar3 = __aeabi_fcmple(value,in_r1,0);\n    if (iVar3 != 0) {\n      return '\\b';\n    }\n    *(uint *)(PTR_settings_080051a8 + parameter * 4) = in_r1;\n    break;\n  case 3:\n    iVar3 = __aeabi_fcmplt(in_r1,DAT_080051ac);\n    if (iVar3 != 0) {\n      return '\\t';\n    }\n    uVar4 = __aeabi_f2d(in_r1);\n    round((double)CONCAT44(parameter,in_r1));\n    uVar1 = __aeabi_d2uiz(uVar4,extraout_r1);\n    PTR_settings_080051a8[0xd] = uVar1;\n    break;\n  case 4:\n    *(uint *)(PTR_settings_080051a8 + 0x10) = in_r1;\n    break;\n  case 5:\n    *(uint *)(PTR_settings_080051a8 + 0x14) = in_r1;\n    break;\n  case 6:\n    uVar4 = __aeabi_f2d(in_r1);\n    trunc((double)CONCAT44(parameter,in_r1));\n    uVar2 = __aeabi_d2uiz(uVar4,extraout_r1_00);\n    *(undefined2 *)(PTR_settings_080051a8 + 0x18) = uVar2;\n    break;\n  case 7:\n    uVar4 = __aeabi_f2d(in_r1);\n    round((double)CONCAT44(parameter,in_r1));\n    uVar1 = __aeabi_d2uiz(uVar4,extraout_r1_01);\n    PTR_settings_080051a8[0x3c] = uVar1;\n    break;\n  case 8:\n    uVar4 = __aeabi_fmul(in_r1,DAT_080051b0);\n    uVar4 = __aeabi_fmul(uVar4,DAT_080051b0);\n    *(undefined4 *)(PTR_settings_080051a8 + 0x20) = uVar4;\n    break;\n  case 9:\n    *(uint *)(PTR_settings_080051a8 + 0x24) = in_r1 & 0x7fffffff;\n    break;\n  case 10:\n    *(uint *)(PTR_settings_080051a8 + 0x1c) = in_r1;\n    break;\n  case 0xb:\n    uVar4 = __aeabi_f2d(in_r1);\n    round((double)CONCAT44(parameter,in_r1));\n    uVar1 = __aeabi_d2uiz(uVar4,extraout_r1_02);\n    PTR_settings_080051a8[0x3e] = uVar1;\n    break;\n  case 0xc:\n    uVar4 = __aeabi_f2d(in_r1);\n    round((double)CONCAT44(parameter,in_r1));\n    uVar1 = __aeabi_d2uiz(uVar4,extraout_r1_03);\n    PTR_settings_080051a8[0x3d] = uVar1;\n    break;\n  case 0xd:\n    iVar3 = __aeabi_fcmpeq(in_r1,0);\n    if (iVar3 == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 1;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xfe;\n    }\n    break;\n  case 0xe:\n    iVar3 = __aeabi_fcmpeq(in_r1,0);\n    if (iVar3 == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 2;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xfd;\n    }\n    break;\n  case 0xf:\n    iVar3 = __aeabi_fcmpeq(in_r1,0);\n    if (iVar3 == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 4;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xfb;\n    }\n    break;\n  case 0x10:\n    iVar3 = __aeabi_fcmpeq(in_r1,0);\n    if (iVar3 == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 8;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xf7;\n    }\n    limits_init();\n    break;\n  case 0x11:\n    iVar3 = __aeabi_fcmpeq(in_r1,0);\n    if (iVar3 == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 0x10;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xef;\n    }\n    break;\n  case 0x12:\n    uVar4 = __aeabi_f2d(in_r1);\n    trunc((double)CONCAT44(parameter,in_r1));\n    uVar2 = __aeabi_d2uiz(uVar4,extraout_r1_04);\n    *(undefined2 *)(PTR_settings_080051a8 + 0x2a) = uVar2;\n    break;\n  case 0x13:\n    *(uint *)(PTR_settings_080051a8 + 0x2c) = in_r1;\n    break;\n  case 0x14:\n    *(uint *)(PTR_settings_080051a8 + 0x30) = in_r1;\n    break;\n  case 0x15:\n    uVar4 = __aeabi_f2d(in_r1);\n    round((double)CONCAT44(parameter,in_r1));\n    uVar2 = __aeabi_d2uiz(uVar4,extraout_r1_05);\n    *(undefined2 *)(PTR_settings_080051a8 + 0x34) = uVar2;\n    break;\n  case 0x16:\n    *(uint *)(PTR_settings_080051a8 + 0x38) = in_r1;\n    break;\n  case 0x17:\n    uVar4 = __aeabi_f2d(in_r1);\n    trunc((double)CONCAT44(parameter,in_r1));\n    uVar2 = __aeabi_d2uiz(uVar4,extraout_r1_06);\n    *(undefined2 *)(PTR_settings_080051a8 + 0x1a) = uVar2;\n    break;\n  default:\n    return '\\x06';\n  }\n  write_global_settings();\n  return '\\0';\n}\n\n", 
            "called": [
                "__aeabi_fcmpeq", 
                "limits_init", 
                "__aeabi_f2d", 
                "__aeabi_d2uiz", 
                "round", 
                "__aeabi_fmul", 
                "__aeabi_fcmple", 
                "trunc", 
                "__aeabi_fcmplt", 
                "write_global_settings"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004e30", 
            "calling": [
                "protocol_execute_line"
            ], 
            "imported": false, 
            "current_name": "settings_store_global_setting"
        }, 
        "gpio_set": {
            "renaming": {}, 
            "code": "\nvoid gpio_set(int n)\n\n{\n  *(short *)((n >> 4) * 0x400 + 0x40020018) = (short)(1 << (n & 0xfU));\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007402", 
            "calling": [
                "debounce_on_handler"
            ], 
            "imported": false, 
            "current_name": "gpio_set"
        }, 
        "__cmpsf2": {
            "renaming": {}, 
            "code": "\nuint __cmpsf2(uint param_1,uint param_2)\n\n{\n  bool bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  bool bVar5;\n  \n  uVar2 = param_1 * 2;\n  uVar3 = param_2 * 2;\n  if (((int)uVar2 >> 0x18 == -1 || (int)uVar3 >> 0x18 == -1) &&\n     ((((int)uVar2 >> 0x18 == -1 && ((param_1 & 0x7fffff) != 0)) ||\n      (((int)uVar3 >> 0x18 == -1 && ((param_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  uVar4 = uVar2 | param_2 & 0x7fffffff;\n  bVar5 = uVar4 == 0;\n  if (!bVar5) {\n    uVar4 = param_1 ^ param_2;\n    bVar5 = uVar4 == 0;\n  }\n  bVar1 = -1 < (int)uVar4;\n  if (bVar1) {\n    param_1 = uVar2 + param_2 * -2;\n    bVar5 = param_1 == 0;\n  }\n  if ((bVar1 && uVar3 <= uVar2) && !bVar5) {\n    param_1 = (int)param_2 >> 0x1f;\n  }\n  if (!bVar1 || uVar3 > uVar2) {\n    param_1 = ~((int)param_2 >> 0x1f);\n  }\n  if (!bVar5) {\n    param_1 = param_1 | 1;\n  }\n  return param_1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800919c", 
            "calling": [
                "__aeabi_cfcmpeq"
            ], 
            "imported": false, 
            "current_name": "__cmpsf2"
        }, 
        "__aeabi_fsub": {
            "renaming": {}, 
            "code": "\nuint __aeabi_fsub(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  int iVar7;\n  bool bVar8;\n  \n  uVar2 = param_2 ^ 0x80000000;\n  uVar4 = param_1 << 1;\n  bVar8 = uVar4 == 0;\n  if (!bVar8) {\n    param_4 = param_2 << 1;\n    bVar8 = param_4 == 0;\n  }\n  if (!bVar8) {\n    bVar8 = uVar4 == param_4;\n  }\n  iVar7 = (int)uVar4 >> 0x18;\n  if (!bVar8) {\n    bVar8 = iVar7 == -1;\n  }\n  if (!bVar8) {\n    bVar8 = (int)param_4 >> 0x18 == -1;\n  }\n  if (bVar8) {\n    iVar1 = (int)(param_2 << 1) >> 0x18;\n    if (iVar7 == -1 || iVar1 == -1) {\n      uVar4 = uVar2;\n      if (iVar7 == -1) {\n        uVar4 = param_1;\n      }\n      if (iVar7 != -1 || iVar1 != -1) {\n        uVar2 = uVar4;\n      }\n      bVar8 = (uVar4 & 0x7fffff) == 0;\n      if (bVar8) {\n        bVar8 = (uVar2 & 0x7fffff) == 0;\n      }\n      if (bVar8) {\n        bVar8 = uVar4 == uVar2;\n      }\n      if (!bVar8) {\n        uVar4 = uVar4 | 0x400000;\n      }\n      return uVar4;\n    }\n    if (((param_1 ^ uVar2) & 0x7fffffff) != 0) {\n      if (uVar4 == 0) {\n        param_1 = uVar2;\n      }\n      return param_1;\n    }\n    if (param_1 != uVar2) {\n      return 0;\n    }\n    if ((uVar4 & 0xff000000) == 0) {\n      uVar2 = param_1 << 1;\n      if ((param_1 & 0x80000000) != 0) {\n        uVar2 = uVar2 | 0x80000000;\n      }\n      return uVar2;\n    }\n    if (uVar4 < 0xfe000000) {\n      return param_1 + 0x800000;\n    }\n    param_1 = param_1 & 0x80000000;\nLAB_08008e12:\n    return param_1 | 0x7f800000;\n  }\n  uVar4 = uVar4 >> 0x18;\n  param_4 = param_4 >> 0x18;\n  uVar6 = param_4 - uVar4;\n  bVar8 = uVar6 != 0;\n  uVar5 = uVar4;\n  if (bVar8 && uVar4 <= param_4) {\n    uVar5 = uVar4 + uVar6;\n  }\n  if (bVar8 && uVar4 <= param_4) {\n    uVar2 = uVar2 ^ param_1;\n  }\n  if (bVar8 && uVar4 <= param_4) {\n    param_1 = param_1 ^ uVar2;\n  }\n  if (bVar8 && uVar4 <= param_4) {\n    uVar2 = uVar2 ^ param_1;\n  }\n  if (param_4 < uVar4) {\n    uVar6 = -uVar6;\n  }\n  if (0x19 < uVar6) {\n    return param_1;\n  }\n  uVar4 = param_1 & 0xffffff | 0x800000;\n  if ((param_1 & 0x80000000) != 0) {\n    uVar4 = -uVar4;\n  }\n  uVar3 = uVar2 & 0xffffff | 0x800000;\n  if ((uVar2 & 0x80000000) != 0) {\n    uVar3 = -uVar3;\n  }\n  if (uVar5 == uVar6) {\n    uVar3 = uVar3 ^ 0x800000;\n    if (uVar5 == 0) {\n      uVar4 = uVar4 ^ 0x800000;\n      uVar5 = 1;\n    }\n    else {\n      uVar6 = uVar6 - 1;\n    }\n  }\n  uVar4 = uVar4 + ((int)uVar3 >> (uVar6 & 0xff));\n  uVar3 = uVar3 << (0x20 - uVar6 & 0xff);\n  param_1 = uVar4 & 0x80000000;\n  if ((int)uVar4 < 0) {\n    bVar8 = uVar3 != 0;\n    uVar3 = -uVar3;\n    uVar4 = -uVar4 - (uint)bVar8;\n  }\n  if (uVar4 < 0x800000) {\n    uVar2 = uVar3 & 0x80000000;\n    uVar3 = uVar3 << 1;\n    uVar4 = uVar4 * 2 + (uint)(uVar2 != 0);\n    uVar2 = uVar5 - 2;\n    if (uVar5 - 1 == 0 || uVar4 < 0x800000) {\n      iVar7 = count_leading_zeroes(uVar4);\n      uVar6 = iVar7 - 8;\n      uVar4 = uVar4 << (uVar6 & 0xff);\n      if ((int)uVar2 < (int)uVar6) {\n        uVar4 = uVar4 >> (-(uVar2 - uVar6) & 0xff);\n      }\n      else {\n        uVar4 = uVar4 + (uVar2 - uVar6) * 0x800000;\n      }\n      return uVar4 | param_1;\n    }\n  }\n  else {\n    uVar2 = uVar5 - 1;\n    if (0xffffff < uVar4) {\n      uVar2 = uVar4 & 1;\n      uVar4 = uVar4 >> 1;\n      uVar3 = (uint)(uVar2 != 0) << 0x1f | uVar3 >> 1;\n      uVar2 = uVar5;\n      if (0xfd < uVar5) goto LAB_08008e12;\n    }\n  }\n  uVar4 = uVar4 + uVar2 * 0x800000 + (uint)(0x7fffffff < uVar3);\n  if (uVar3 == 0x80000000) {\n    uVar4 = uVar4 & 0xfffffffe;\n  }\n  return uVar4 | param_1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008cd8", 
            "calling": [
                "estimate_acceleration_distance", 
                "intersection_distance", 
                "report_realtime_status", 
                "mc_arc", 
                "plan_buffer_line", 
                "mc_dwell", 
                "max_allowable_speed", 
                "gc_execute_line"
            ], 
            "imported": false, 
            "current_name": "__aeabi_fsub"
        }, 
        "usart_getc": {
            "renaming": {}, 
            "code": "\nchar usart_getc(void)\n\n{\n  USART_TypeDef *usart;\n  \n  return (char)*(undefined4 *)(DAT_08007ea0 + 4);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007e84", 
            "calling": [
                "serial_read"
            ], 
            "imported": false, 
            "current_name": "usart_getc"
        }, 
        "__aeabi_fcmpge": {
            "renaming": {}, 
            "code": "\nbool __aeabi_fcmpge(void)\n\n{\n  undefined in_ZR;\n  undefined in_CY;\n  \n  __aeabi_cfrcmple();\n  return !(bool)in_CY || (bool)in_ZR;\n}\n\n", 
            "called": [
                "__aeabi_cfrcmple"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009250", 
            "calling": [
                "mc_arc", 
                "plan_buffer_line"
            ], 
            "imported": false, 
            "current_name": "__aeabi_fcmpge"
        }, 
        "DMA1_Stream3_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid DMA1_Stream3_IRQHandler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
            "called": [
                "DMA1_Stream3_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009314", 
            "calling": [
                "DMA1_Stream3_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "DMA1_Stream3_IRQHandler"
        }, 
        "plan_discard_current_block": {
            "renaming": {}, 
            "code": "\nvoid plan_discard_current_block(void)\n\n{\n  uint8_t uVar1;\n  \n  if (*PTR_block_buffer_head_08002f6c != *PTR_block_buffer_tail_08002f70) {\n    uVar1 = next_block_index(*PTR_block_buffer_tail_08002f70);\n    *PTR_block_buffer_tail_08002f70 = uVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "next_block_index"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002f40", 
            "calling": [
                "step_period_isr"
            ], 
            "imported": false, 
            "current_name": "plan_discard_current_block"
        }, 
        "step_timer_init": {
            "renaming": {}, 
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid step_timer_init(void)\n\n{\n  TIM_TypeDef *TIMx;\n  \n  enable_tim_clock((TIM_TypeDef *)&DAT_40000000);\n  _DAT_40000000 = 0;\n  _DAT_40000004 = 0;\n  _DAT_40000008 = 0;\n  _DAT_4000000c = 0;\n  _DAT_40000010 = 0;\n  _DAT_40000018 = 0;\n  _DAT_4000001c = 0;\n  _DAT_40000020 = 0;\n  _DAT_40000024 = 0;\n  _DAT_40000028 =\n       (uint)((ulonglong)DAT_08007b6c * (ulonglong)*(uint *)PTR_SystemCoreClock_08007b68 >> 0x38) -\n       1;\n  _DAT_4000002c = 0;\n  _DAT_40000034 = 0;\n  _DAT_40000038 = 0;\n  _DAT_4000003c = 0;\n  _DAT_40000040 = 0;\n  _DAT_40000048 = 0;\n  _DAT_4000004c = 0;\n  enable_tim_interrupt((TIM_TypeDef *)&DAT_40000000,0,0);\n  return;\n}\n\n", 
            "called": [
                "enable_tim_interrupt", 
                "enable_tim_clock"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007ad0", 
            "calling": [
                "timers_init"
            ], 
            "imported": false, 
            "current_name": "step_timer_init"
        }, 
        "HAL_NVIC_SystemReset": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_SystemReset(void)\n\n{\n  NVIC_SystemReset();\n  return;\n}\n\n", 
            "called": [
                "NVIC_SystemReset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006d66", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_NVIC_SystemReset"
        }, 
        "report_alarm_message": {
            "renaming": {}, 
            "code": "\nvoid report_alarm_message(int8_t alarm_code)\n\n{\n  printPgmString(PTR_s_ALARM__08004190);\n  if (alarm_code == -2) {\n    printPgmString(PTR_s_Abort_during_cycle_08004198);\n  }\n  else if (alarm_code == -1) {\n    printPgmString(PTR_s_Hard_limit_08004194);\n  }\n  printPgmString(PTR_s___MPos__0800419c);\n  delay_ms(500);\n  return;\n}\n\n", 
            "called": [
                "printPgmString", 
                "delay_ms"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004148", 
            "calling": [
                "protocol_execute_runtime"
            ], 
            "imported": false, 
            "current_name": "report_alarm_message"
        }, 
        "spindle_init": {
            "renaming": {}, 
            "code": "\nvoid spindle_init(void)\n\n{\n  *PTR_current_direction_0800524c = 0;\n  spindle_stop();\n  return;\n}\n\n", 
            "called": [
                "spindle_stop"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005238", 
            "calling": [
                "grbl_main"
            ], 
            "imported": false, 
            "current_name": "spindle_init"
        }, 
        "__aeabi_fdiv": {
            "renaming": {}, 
            "code": "\nuint __aeabi_fdiv(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  bool bVar7;\n  bool bVar8;\n  bool bVar9;\n  \n  uVar2 = param_1 >> 0x17 & 0xff;\n  bVar7 = uVar2 == 0;\n  if (!bVar7) {\n    param_4 = param_2 >> 0x17 & 0xff;\n    bVar7 = param_4 == 0;\n  }\n  if (!bVar7) {\n    bVar7 = uVar2 == 0xff;\n  }\n  if (!bVar7) {\n    bVar7 = param_4 == 0xff;\n  }\n  if (bVar7) {\n    param_4 = param_2 >> 0x17 & 0xff;\n    uVar6 = param_1;\n    if (uVar2 == 0xff) {\n      if (((param_1 & 0x7fffff) != 0) || (uVar6 = param_2, param_4 == 0xff)) {\nLAB_0800904a:\n        return uVar6 | 0x7fc00000;\n      }\n    }\n    else {\n      if (param_4 == 0xff) {\n        uVar6 = param_2;\n        if ((param_2 & 0x7fffff) == 0) {\nLAB_08009000:\n          return (param_1 ^ param_2) & 0x80000000;\n        }\n        goto LAB_0800904a;\n      }\n      bVar7 = (param_1 & 0x7fffffff) == 0;\n      if (!bVar7) {\n        bVar7 = (param_2 & 0x7fffffff) == 0;\n      }\n      if (!bVar7) {\n        bVar7 = uVar2 == 0;\n        uVar6 = param_1 & 0x80000000;\n        while( true ) {\n          if (bVar7) {\n            param_1 = param_1 << 1;\n            bVar7 = (param_1 & 0x800000) == 0;\n          }\n          if (!bVar7) break;\n          uVar2 = uVar2 - 1;\n        }\n        param_1 = param_1 | uVar6;\n        bVar7 = param_4 == 0;\n        uVar6 = param_2 & 0x80000000;\n        while( true ) {\n          if (bVar7) {\n            param_2 = param_2 << 1;\n            bVar7 = (param_2 & 0x800000) == 0;\n          }\n          if (!bVar7) break;\n          param_4 = param_4 - 1;\n        }\n        param_2 = param_2 | uVar6;\n        goto LAB_0800906c;\n      }\n      if ((param_1 & 0x7fffffff) == 0) {\n        if ((param_2 & 0x7fffffff) != 0) goto LAB_08009000;\n        goto LAB_0800904a;\n      }\n    }\n    param_1 = param_1 ^ param_2;\n  }\n  else {\nLAB_0800906c:\n    iVar3 = uVar2 - param_4;\n    if (param_2 << 9 == 0) {\n      param_1 = (param_1 ^ param_2) & 0x80000000 | param_1 & 0x7fffff;\n      bVar9 = SCARRY4(iVar3,0x7f);\n      iVar5 = iVar3 + 0x7f;\n      bVar7 = iVar5 < 0;\n      bVar8 = iVar5 == 0;\n      if (!bVar8 && bVar7 == bVar9) {\n        bVar9 = SBORROW4(0xff,iVar5);\n        bVar7 = 0xff - iVar5 < 0;\n        bVar8 = iVar5 == 0xff;\n      }\n      if (!bVar8 && bVar7 == bVar9) {\n        param_1 = param_1 | iVar5 * 0x800000;\n      }\n      if (!bVar8 && bVar7 == bVar9) {\n        return param_1;\n      }\n      param_1 = param_1 | 0x800000;\n      uVar2 = 0;\n      bVar8 = SBORROW4(iVar5,1);\n      uVar4 = iVar3 + 0x7e;\n      bVar7 = uVar4 == 0;\n      uVar6 = uVar4;\n    }\n    else {\n      uVar1 = (param_2 << 9) >> 4 | 0x10000000;\n      uVar2 = (param_1 << 9) >> 4 | 0x10000000;\n      param_1 = (param_1 ^ param_2) & 0x80000000;\n      bVar7 = uVar1 <= uVar2;\n      if (!bVar7) {\n        uVar2 = uVar2 << 1;\n      }\n      uVar4 = iVar3 + 0x7d + (uint)bVar7;\n      uVar6 = 0x800000;\n      do {\n        if (uVar1 <= uVar2) {\n          uVar2 = uVar2 - uVar1;\n          param_1 = param_1 | uVar6;\n        }\n        bVar7 = uVar1 >> 1 <= uVar2;\n        if (bVar7) {\n          uVar2 = uVar2 - (uVar1 >> 1);\n        }\n        if (bVar7) {\n          param_1 = param_1 | uVar6 >> 1;\n        }\n        bVar7 = uVar1 >> 2 <= uVar2;\n        if (bVar7) {\n          uVar2 = uVar2 - (uVar1 >> 2);\n        }\n        if (bVar7) {\n          param_1 = param_1 | uVar6 >> 2;\n        }\n        bVar7 = uVar1 >> 3 <= uVar2;\n        if (bVar7) {\n          uVar2 = uVar2 - (uVar1 >> 3);\n        }\n        if (bVar7) {\n          param_1 = param_1 | uVar6 >> 3;\n        }\n        uVar2 = uVar2 * 0x10;\n        bVar7 = uVar2 == 0;\n        if (!bVar7) {\n          uVar6 = uVar6 >> 4;\n          bVar7 = uVar6 == 0;\n        }\n      } while (!bVar7);\n      bVar8 = SBORROW4(uVar4,0xfd);\n      bVar7 = uVar4 == 0xfd;\n      uVar6 = uVar4 - 0xfd;\n      if (uVar4 < 0xfe) {\n        param_1 = param_1 + uVar4 * 0x800000 + (uint)(uVar1 <= uVar2);\n        if (uVar2 - uVar1 == 0) {\n          param_1 = param_1 & 0xfffffffe;\n        }\n        return param_1;\n      }\n    }\n    if (bVar7 || (int)uVar6 < 0 != bVar8) {\n      bVar7 = (int)(uVar4 + 0x19) < 0;\n      if (uVar4 == 0xffffffe7 || bVar7 != SCARRY4(uVar4,0x19)) {\n        param_1 = param_1 & 0x80000000;\n      }\n      if (uVar4 == 0xffffffe7 || bVar7 != SCARRY4(uVar4,0x19)) {\n        return param_1;\n      }\n      uVar6 = (param_1 << 1) >> (-uVar4 & 0xff);\n      uVar4 = param_1 << (uVar4 + 0x20 & 0xff);\n      uVar6 = ((uint)((param_1 & 0x80000000) != 0) << 0x1f | uVar6 >> 1) + (uint)((byte)uVar6 & 1);\n      if ((uVar2 | uVar4 << 1) == 0) {\n        uVar6 = uVar6 & ~(uVar4 >> 0x1f);\n      }\n      return uVar6;\n    }\n  }\n  return param_1 & 0x80000000 | 0x7f800000;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009054", 
            "calling": [
                "estimate_acceleration_distance", 
                "intersection_distance", 
                "report_realtime_status", 
                "gc_set_current_position", 
                "homing_cycle", 
                "mc_arc", 
                "plan_buffer_line", 
                "planner_recalculate_trapezoids", 
                "plan_cycle_reinitialize", 
                "report_grbl_settings"
            ], 
            "imported": false, 
            "current_name": "__aeabi_fdiv"
        }, 
        "next_block_index": {
            "renaming": {}, 
            "code": "\nuint8_t next_block_index(uint8_t block_index)\n\n{\n  uint8_t local_9;\n  \n  local_9 = block_index + '\\x01';\n  if (local_9 == '\\x12') {\n    local_9 = '\\0';\n  }\n  return local_9;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002870", 
            "calling": [
                "plan_buffer_line", 
                "plan_reset_buffer", 
                "planner_forward_pass", 
                "plan_discard_current_block", 
                "planner_recalculate_trapezoids"
            ], 
            "imported": false, 
            "current_name": "next_block_index"
        }, 
        "__aeabi_d2uiz": {
            "renaming": {}, 
            "code": "\nuint __aeabi_d2uiz(uint param_1,uint param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  \n  if ((param_2 & 0x80000000) != 0) {\n    return 0;\n  }\n  iVar1 = param_2 * 2 + 0x200000;\n  if (param_2 * 2 < 0xffe00000) {\n    if (-1 < iVar1) {\n      return 0;\n    }\n    uVar2 = -(iVar1 >> 0x15) - 0x3e1;\n    if (-1 < (int)uVar2) {\n      return (param_2 << 0xb | 0x80000000 | param_1 >> 0x15) >> (uVar2 & 0xff);\n    }\n  }\n  else if ((param_1 | param_2 << 0xc) != 0) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008bf0", 
            "calling": [
                "homing_cycle", 
                "mc_arc", 
                "plan_buffer_line", 
                "mc_dwell", 
                "calculate_trapezoid_for_block", 
                "protocol_execute_line", 
                "settings_store_global_setting", 
                "gc_execute_line"
            ], 
            "imported": false, 
            "current_name": "__aeabi_d2uiz"
        }, 
        "report_realtime_status": {
            "renaming": {}, 
            "code": "\nvoid report_realtime_status(void)\n\n{\n  undefined4 uVar1;\n  float fVar2;\n  float extraout_s0;\n  float extraout_s0_00;\n  float extraout_s0_01;\n  float extraout_s0_02;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  float print_position [3];\n  int32_t current_position [3];\n  uint8_t i;\n  \n  current_position[0] = *(int32_t *)(PTR_sys_08004b88 + 4);\n  current_position[1] = *(int32_t *)(PTR_sys_08004b88 + 8);\n  current_position[2] = *(int32_t *)(PTR_sys_08004b88 + 0xc);\n  if ((byte)PTR_sys_08004b88[1] < 8) {\n                    /* WARNING: Could not recover jumptable at 0x0800495e. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (*(code *)(&switchD_0800495e::switchdataD_08004964)[(byte)PTR_sys_08004b88[1]])();\n    return;\n  }\n  printPgmString(PTR_s__MPos__08004ba8);\n  for (i = '\\0'; i < 3; i = i + '\\x01') {\n    uVar1 = __floatsisf(current_position[i]);\n    fVar2 = (float)__aeabi_fdiv(uVar1,*(undefined4 *)(PTR_settings_08004bac + (uint)i * 4));\n    print_position[i] = fVar2;\n    fVar2 = extraout_s0;\n    if ((PTR_settings_08004bac[0x28] & 1) != 0) {\n      uVar3 = __aeabi_f2d(print_position[i]);\n      uVar3 = __muldf3((int)uVar3,(int)((ulonglong)uVar3 >> 0x20),DAT_08004b80,DAT_08004b84);\n      fVar2 = (float)__truncdfsf2((int)uVar3,(int)((ulonglong)uVar3 >> 0x20));\n      print_position[i] = fVar2;\n      fVar2 = extraout_s0_00;\n    }\n    printFloat(fVar2);\n    printPgmString(PTR_DAT_08004bb0);\n  }\n  printPgmString(PTR_s_WPos__08004bb4);\n  for (i = '\\0'; i < 3; i = i + '\\x01') {\n    if ((PTR_settings_08004bac[0x28] & 1) == 0) {\n      fVar2 = print_position[i];\n      uVar1 = __addsf3(*(undefined4 *)(PTR_gc_08004bb8 + (i + 8) * 4),\n                       *(undefined4 *)(PTR_gc_08004bb8 + (i + 10) * 4 + 4));\n      fVar2 = (float)__aeabi_fsub(fVar2,uVar1);\n      print_position[i] = fVar2;\n      fVar2 = extraout_s0_02;\n    }\n    else {\n      uVar3 = __aeabi_f2d(print_position[i]);\n      uVar1 = __addsf3(*(undefined4 *)(PTR_gc_08004bb8 + (i + 8) * 4),\n                       *(undefined4 *)(PTR_gc_08004bb8 + (i + 10) * 4 + 4));\n      uVar4 = __aeabi_f2d(uVar1);\n      uVar4 = __muldf3((int)uVar4,(int)((ulonglong)uVar4 >> 0x20),DAT_08004b80,DAT_08004b84);\n      uVar3 = __subdf3((int)uVar3,(int)((ulonglong)uVar3 >> 0x20),(int)uVar4,\n                       (int)((ulonglong)uVar4 >> 0x20));\n      fVar2 = (float)__truncdfsf2((int)uVar3,(int)((ulonglong)uVar3 >> 0x20));\n      print_position[i] = fVar2;\n      fVar2 = extraout_s0_01;\n    }\n    printFloat(fVar2);\n    if (i < 2) {\n      printPgmString(PTR_DAT_08004bb0);\n    }\n  }\n  printPgmString(PTR_DAT_08004bbc);\n  return;\n}\n\n", 
            "called": [
                "__addsf3", 
                "__truncdfsf2", 
                "__floatsisf", 
                "printPgmString", 
                "__aeabi_f2d", 
                "__muldf3", 
                "__aeabi_fdiv", 
                "__aeabi_fsub", 
                "printFloat", 
                "__subdf3"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004940", 
            "calling": [
                "protocol_execute_runtime"
            ], 
            "imported": false, 
            "current_name": "report_realtime_status"
        }, 
        "TIM2_IRQHandler": {
            "renaming": {}, 
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid TIM2_IRQHandler(void)\n\n{\n  TIM_TypeDef *TIMx;\n  \n  if (((_DAT_40000010 & 2) != 0) && ((_DAT_4000000c & 2) != 0)) {\n    _DAT_40000010 = _DAT_40000010 & 0xfffffffd;\n    step_delay_isr();\n  }\n  if (((_DAT_40000010 & 4) != 0) && ((_DAT_4000000c & 4) != 0)) {\n    _DAT_40000010 = _DAT_40000010 & 0xfffffffb;\n    step_pulse_isr();\n  }\n  if (((_DAT_40000010 & 1) != 0) && ((_DAT_4000000c & 1) != 0)) {\n    _DAT_40000010 = _DAT_40000010 & 0xfffffffe;\n    step_period_isr();\n  }\n  return;\n}\n\n", 
            "called": [
                "step_pulse_isr", 
                "step_period_isr", 
                "step_delay_isr"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007c7c", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM2_IRQHandler"
        }, 
        "report_grbl_settings": {
            "renaming": {}, 
            "code": "\nvoid report_grbl_settings(void)\n\n{\n  float n;\n  float n_00;\n  float n_01;\n  float n_02;\n  float n_03;\n  float n_04;\n  float n_05;\n  float n_06;\n  float n_07;\n  float n_08;\n  float n_09;\n  \n  printPgmString(PTR_DAT_08004470);\n  printFloat(n);\n  printPgmString(PTR_s___x__step_mm___1__08004478);\n  printFloat(n_00);\n  printPgmString(PTR_s___y__step_mm___2__0800447c);\n  printFloat(n_01);\n  printPgmString(PTR_s___z__step_mm___3__08004480);\n  printInteger((uint)(byte)PTR_settings_08004474[0xd]);\n  printPgmString(PTR_s___step_pulse__usec___4__08004484);\n  printFloat(n_02);\n  printPgmString(PTR_s___default_feed__mm_min___5__08004488);\n  printFloat(n_03);\n  printPgmString(PTR_s___default_seek__mm_min___6__0800448c);\n  printInteger((uint)*(ushort *)(PTR_settings_08004474 + 0x18));\n  printPgmString(PTR_s___step_port_invert_mask__int__08004490);\n  print_uint16_base2(*(uint16_t *)(PTR_settings_08004474 + 0x18));\n  printPgmString(PTR_s____7__08004494);\n  printInteger((uint)(byte)PTR_settings_08004474[0x3c]);\n  printPgmString(PTR_s___step_idle_delay__msec___8__08004498);\n  n_04 = (float)__aeabi_fdiv(*(undefined4 *)(PTR_settings_08004474 + 0x20),DAT_0800449c);\n  printFloat(n_04);\n  printPgmString(PTR_s___acceleration__mm_sec_2___9__080044a0);\n  printFloat(n_05);\n  printPgmString(PTR_s___junction_deviation__mm___10__080044a4);\n  printFloat(n_06);\n  printPgmString(PTR_s___arc__mm_segment___11__080044a8);\n  printInteger((uint)(byte)PTR_settings_08004474[0x3e]);\n  printPgmString(PTR_s___n_arc_correction__int___12__080044ac);\n  printInteger((uint)(byte)PTR_settings_08004474[0x3d]);\n  printPgmString(PTR_s___n_decimals__int___13__080044b0);\n  printInteger((uint)((PTR_settings_08004474[0x28] & 1) != 0));\n  printPgmString(PTR_s___report_inches__bool___14__080044b4);\n  printInteger((uint)((PTR_settings_08004474[0x28] & 2) != 0));\n  printPgmString(PTR_s___auto_start__bool___15__080044b8);\n  printInteger((uint)((PTR_settings_08004474[0x28] & 4) != 0));\n  printPgmString(PTR_s___invert_step_enable__bool___16__080044bc);\n  printInteger((uint)((PTR_settings_08004474[0x28] & 8) != 0));\n  printPgmString(PTR_s___hard_limits__bool___17__080044c0);\n  printInteger((uint)((PTR_settings_08004474[0x28] & 0x10) != 0));\n  printPgmString(PTR_s___homing_cycle__bool___18__080044c4);\n  printInteger((uint)*(ushort *)(PTR_settings_08004474 + 0x2a));\n  printPgmString(PTR_s___homing_dir_invert_mask__int__080044c8);\n  print_uint16_base2(*(uint16_t *)(PTR_settings_08004474 + 0x2a));\n  printPgmString(PTR_s____19__080044cc);\n  printFloat(n_07);\n  printPgmString(PTR_s___homing_feed__mm_min___20__080044d0);\n  printFloat(n_08);\n  printPgmString(PTR_s___homing_seek__mm_min___21__080044d4);\n  printInteger((uint)*(ushort *)(PTR_settings_08004474 + 0x34));\n  printPgmString(PTR_s___homing_debounce__msec___22__080044d8);\n  printFloat(n_09);\n  printPgmString(PTR_s___homing_pull_off__mm___23__080044dc);\n  printInteger((uint)*(ushort *)(PTR_settings_08004474 + 0x1a));\n  printPgmString(PTR_s___dir_port_invert_mask__int__080044e0);\n  print_uint16_base2(*(uint16_t *)(PTR_settings_08004474 + 0x1a));\n  printPgmString(PTR_DAT_080044e4);\n  return;\n}\n\n", 
            "called": [
                "printPgmString", 
                "__aeabi_fdiv", 
                "printFloat", 
                "printInteger", 
                "print_uint16_base2"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004250", 
            "calling": [
                "settings_init", 
                "protocol_execute_line"
            ], 
            "imported": false, 
            "current_name": "report_grbl_settings"
        }, 
        "settings_init": {
            "renaming": {}, 
            "code": "\nvoid settings_init(void)\n\n{\n  uint8_t uVar1;\n  float coord_data [3];\n  uint8_t i;\n  \n  uVar1 = read_global_settings();\n  if (uVar1 == '\\0') {\n    report_status_message('\\n');\n    settings_reset(true);\n    report_grbl_settings();\n  }\n  for (i = '\\0'; i < 8; i = i + '\\x01') {\n    uVar1 = settings_read_coord_data(i,coord_data);\n    if (uVar1 == '\\0') {\n      report_status_message('\\n');\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "settings_reset", 
                "read_global_settings", 
                "report_status_message", 
                "settings_read_coord_data", 
                "report_grbl_settings"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080051b4", 
            "calling": [
                "grbl_main"
            ], 
            "imported": false, 
            "current_name": "settings_init"
        }, 
        "debounce_off_handler": {
            "renaming": {}, 
            "code": "\nvoid debounce_off_handler(uint32_t bits)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080078e2", 
            "calling": [], 
            "imported": false, 
            "current_name": "debounce_off_handler"
        }, 
        "FUN_08008a02": {
            "renaming": {}, 
            "code": "\nulonglong FUN_08008a02(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  uint in_r12;\n  bool bVar4;\n  \n  uVar2 = in_r12 & param_4 >> 0x14;\n  uVar3 = param_2;\n  if (unaff_r4 != in_r12 || uVar2 != in_r12) {\n    if (unaff_r4 == in_r12) {\n      if (((param_1 | param_2 << 0xc) == 0) && (param_1 = param_3, uVar3 = param_4, uVar2 != in_r12)\n         ) {\nLAB_08008874:\n        return (ulonglong)((param_2 ^ param_4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (uVar2 == in_r12) {\n      param_1 = param_3;\n      uVar3 = param_4;\n      if ((param_3 | param_4 << 0xc) == 0) {\nLAB_08008838:\n        return (ulonglong)((param_2 ^ param_4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      bVar4 = (param_1 | param_2 << 1) == 0;\n      if (!bVar4) {\n        bVar4 = (param_3 | param_4 << 1) == 0;\n      }\n      if (!bVar4) {\n        if (unaff_r4 == 0) {\n          uVar3 = param_2 & 0x80000000;\n          do {\n            uVar1 = param_1 & 0x80000000;\n            param_1 = param_1 << 1;\n            param_2 = param_2 * 2 + (uint)(uVar1 != 0);\n          } while ((param_2 & 0x100000) == 0);\n          param_2 = param_2 | uVar3;\n          if (uVar2 != 0) {\n            return CONCAT44(param_2,param_1);\n          }\n        }\n        do {\n          uVar3 = param_3 & 0x80000000;\n          param_3 = param_3 << 1;\n          param_4 = param_4 * 2 + (uint)(uVar3 != 0);\n        } while ((param_4 & 0x100000) == 0);\n        return CONCAT44(param_2,param_1);\n      }\n      if ((param_1 | param_2 << 1) != 0) goto LAB_08008874;\n      if ((param_3 | param_4 << 1) != 0) goto LAB_08008838;\n    }\n  }\n  return CONCAT44(uVar3,param_1) | 0x7ff8000000000000;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": false, 
            "entrypoint": "0x08008a02", 
            "calling": [
                "__divdf3"
            ], 
            "imported": false, 
            "current_name": "FUN_08008a02"
        }, 
        "hypot": {
            "renaming": {}, 
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080098b6) */\n\ndouble hypot(double __x,double __y)\n\n{\n  char cVar1;\n  undefined *puVar2;\n  int iVar3;\n  undefined4 *puVar4;\n  double dVar5;\n  double extraout_d0;\n  double extraout_d0_00;\n  double extraout_d0_01;\n  double extraout_d0_02;\n  double extraout_d0_03;\n  int in_stack_ffffffb0;\n  char *in_stack_ffffffb4;\n  \n  puVar2 = PTR___fdlib_version_080098cc;\n  dVar5 = (double)__ieee754_hypot();\n  if ((((*puVar2 != -1) &&\n       (iVar3 = finite((double)CONCAT44(in_stack_ffffffb4,in_stack_ffffffb0)), dVar5 = extraout_d0,\n       iVar3 == 0)) &&\n      (iVar3 = finite((double)CONCAT44(in_stack_ffffffb4,in_stack_ffffffb0)), dVar5 = extraout_d0_00\n      , iVar3 != 0)) &&\n     ((iVar3 = finite((double)CONCAT44(in_stack_ffffffb4,in_stack_ffffffb0)), dVar5 = extraout_d0_01\n      , iVar3 != 0 &&\n      (((cVar1 = *puVar2, cVar1 != '\\0' && (cVar1 == '\\x02')) ||\n       (iVar3 = matherr((exception *)&stack0xffffffb0), dVar5 = extraout_d0_03, iVar3 == 0)))))) {\n    puVar4 = (undefined4 *)__errno();\n    *puVar4 = 0x22;\n    dVar5 = extraout_d0_02;\n  }\n  return dVar5;\n}\n\n", 
            "called": [
                "__errno", 
                "__ieee754_hypot", 
                "finite", 
                "matherr"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800981c", 
            "calling": [
                "mc_arc", 
                "gc_execute_line"
            ], 
            "imported": false, 
            "current_name": "hypot"
        }, 
        "HAL_RCC_EnableCSS": {
            "renaming": {}, 
            "code": "\nvoid HAL_RCC_EnableCSS(void)\n\n{\n  *DAT_080064d0 = 1;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080064bc", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_RCC_EnableCSS"
        }, 
        "__ledf2": {
            "renaming": {}, 
            "code": "\nuint __ledf2(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  bool bVar2;\n  bool bVar3;\n  \n  if (((int)(param_2 << 1) >> 0x15 == -1 || (int)(param_4 << 1) >> 0x15 == -1) &&\n     ((((int)(param_2 << 1) >> 0x15 == -1 && ((param_1 | param_2 << 0xc) != 0)) ||\n      (((int)(param_4 << 1) >> 0x15 == -1 && ((param_3 | param_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  bVar2 = (param_1 | param_2 << 1) == 0;\n  if (bVar2) {\n    bVar2 = (param_3 | param_4 << 1) == 0;\n  }\n  if (!bVar2) {\n    bVar2 = param_2 == param_4;\n  }\n  if (bVar2) {\n    bVar2 = param_1 == param_3;\n  }\n  if (!bVar2) {\n    uVar1 = param_2 ^ param_4;\n    bVar2 = uVar1 == 0;\n    if (-1 < (int)uVar1) {\n      bVar2 = param_2 == param_4;\n    }\n    bVar3 = -1 < (int)uVar1 && param_4 <= param_2;\n    if (bVar2) {\n      bVar3 = param_3 <= param_1;\n    }\n    param_4 = (int)param_4 >> 0x1f;\n    if (!bVar3) {\n      param_4 = ~param_4;\n    }\n    return param_4 | 1;\n  }\n  return 0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008a6c", 
            "calling": [], 
            "imported": false, 
            "current_name": "__ledf2"
        }, 
        "write_global_settings": {
            "renaming": {}, 
            "code": "\nvoid write_global_settings(void)\n\n{\n  eeprom_put_char(0,'\\x05');\n  memcpy_to_eeprom_with_checksum(1,PTR_settings_08004c44,0x40);\n  return;\n}\n\n", 
            "called": [
                "eeprom_put_char", 
                "memcpy_to_eeprom_with_checksum"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004c2a", 
            "calling": [
                "settings_reset", 
                "settings_store_global_setting"
            ], 
            "imported": false, 
            "current_name": "write_global_settings"
        }, 
        "debounce_rd": {
            "renaming": {}, 
            "code": "\nuint32_t debounce_rd(void)\n\n{\n  int i;\n  uint32_t state;\n  \n  state = 0;\n  for (i = 0; i < 4; i = i + 1) {\n    state = *(uint *)(PTR_debounce_0800792c + i * 4) | state;\n  }\n  return state;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080078f4", 
            "calling": [
                "homing_cycle", 
                "debounce_isr"
            ], 
            "imported": false, 
            "current_name": "debounce_rd"
        }, 
        "HAL_IncTick": {
            "renaming": {}, 
            "code": "\nvoid HAL_IncTick(void)\n\n{\n  *(int *)PTR_uwTick_08005a80 = *(int *)PTR_uwTick_08005a80 + 1;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005a68", 
            "calling": [
                "SysTick_Handler"
            ], 
            "imported": false, 
            "current_name": "HAL_IncTick"
        }, 
        "__ltsf2": {
            "renaming": {}, 
            "code": "\nuint __ltsf2(uint param_1,uint param_2)\n\n{\n  bool bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  bool bVar5;\n  \n  uVar2 = param_1 * 2;\n  uVar3 = param_2 * 2;\n  if (((int)uVar2 >> 0x18 == -1 || (int)uVar3 >> 0x18 == -1) &&\n     ((((int)uVar2 >> 0x18 == -1 && ((param_1 & 0x7fffff) != 0)) ||\n      (((int)uVar3 >> 0x18 == -1 && ((param_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  uVar4 = uVar2 | param_2 & 0x7fffffff;\n  bVar5 = uVar4 == 0;\n  if (!bVar5) {\n    uVar4 = param_1 ^ param_2;\n    bVar5 = uVar4 == 0;\n  }\n  bVar1 = -1 < (int)uVar4;\n  if (bVar1) {\n    param_1 = uVar2 + param_2 * -2;\n    bVar5 = param_1 == 0;\n  }\n  if ((bVar1 && uVar3 <= uVar2) && !bVar5) {\n    param_1 = (int)param_2 >> 0x1f;\n  }\n  if (!bVar1 || uVar3 > uVar2) {\n    param_1 = ~((int)param_2 >> 0x1f);\n  }\n  if (!bVar5) {\n    param_1 = param_1 | 1;\n  }\n  return param_1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009194", 
            "calling": [], 
            "imported": false, 
            "current_name": "__ltsf2"
        }, 
        "fabs": {
            "renaming": {}, 
            "code": "\ndouble fabs(double __x)\n\n{\n  double in_d0;\n  \n  return in_d0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800b2cc", 
            "calling": [
                "__ieee754_rem_pio2", 
                "atan", 
                "__ieee754_atan2"
            ], 
            "imported": false, 
            "current_name": "fabs"
        }, 
        "lround": {
            "renaming": {}, 
            "code": "\nlong lround(double __x)\n\n{\n  uint in_r0;\n  uint in_r1;\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  long lVar4;\n  uint uVar5;\n  \n  uVar2 = (in_r1 << 1) >> 0x15;\n  uVar5 = uVar2 - 0x3ff;\n  if ((int)in_r1 < 0) {\n    lVar4 = -1;\n  }\n  else {\n    lVar4 = 1;\n  }\n  uVar3 = in_r1 & 0xfffff | 0x100000;\n  if ((int)uVar5 < 0x14) {\n    if ((int)uVar5 < 0) {\n      if (uVar5 != 0xffffffff) {\n        lVar4 = 0;\n      }\n      return lVar4;\n    }\n    uVar3 = uVar3 + (0x80000 >> (uVar5 & 0xff)) >> (0x14 - uVar5 & 0xff);\n  }\n  else {\n    if (0x1e < uVar5) {\n      lVar4 = __aeabi_d2iz();\n      return lVar4;\n    }\n    if ((int)uVar5 < 0x34) {\n      uVar1 = 0x80000000 >> (uVar2 - 0x413 & 0xff);\n      if (CARRY4(uVar1,in_r0) != false) {\n        uVar3 = uVar3 + 1;\n      }\n      uVar3 = uVar3 << (uVar2 - 0x413 & 0xff);\n      if (uVar5 != 0x14) {\n        uVar3 = uVar3 | uVar1 + in_r0 >> (0x34 - uVar5 & 0xff);\n      }\n    }\n    else {\n      uVar3 = uVar3 << (uVar2 - 0x413 & 0xff) | in_r0 << (uVar2 - 0x433 & 0xff);\n    }\n  }\n  return uVar3 * lVar4;\n}\n\n", 
            "called": [
                "__aeabi_d2iz"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080095b8", 
            "calling": [
                "homing_cycle", 
                "plan_buffer_line"
            ], 
            "imported": false, 
            "current_name": "lround"
        }, 
        "__aeabi_cdcmpeq": {
            "renaming": {}, 
            "code": "\nundefined4 __aeabi_cdcmpeq(undefined4 param_1)\n\n{\n  __nedf2();\n  return param_1;\n}\n\n", 
            "called": [
                "__nedf2"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008b00", 
            "calling": [
                "__aeabi_cdrcmple", 
                "__aeabi_dcmplt", 
                "__aeabi_dcmple", 
                "__aeabi_dcmpeq"
            ], 
            "imported": false, 
            "current_name": "__aeabi_cdcmpeq"
        }, 
        "__retarget_lock_acquire_recursive": {
            "renaming": {}, 
            "code": "\nvoid __retarget_lock_acquire_recursive(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800b51c", 
            "calling": [
                "__register_exitproc"
            ], 
            "imported": false, 
            "current_name": "__retarget_lock_acquire_recursive"
        }, 
        "DebugMon_Handler": {
            "renaming": {}, 
            "code": "\nvoid DebugMon_Handler(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800773e", 
            "calling": [], 
            "imported": false, 
            "current_name": "DebugMon_Handler"
        }, 
        "HAL_MspInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_MspInit(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005a50", 
            "calling": [
                "HAL_Init"
            ], 
            "imported": false, 
            "current_name": "HAL_MspInit"
        }, 
        "step_delay_isr": {
            "renaming": {}, 
            "code": "\nvoid step_delay_isr(void)\n\n{\n  step_wr((uint)*(ushort *)PTR_saved_step_bits_0800578c);\n  return;\n}\n\n", 
            "called": [
                "step_wr"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005778", 
            "calling": [
                "TIM2_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "step_delay_isr"
        }, 
        "gc_init": {
            "renaming": {}, 
            "code": "\nvoid gc_init(void)\n\n{\n  uint8_t uVar1;\n  \n  memset(PTR_gc_080004f0,0,0x38);\n  *(undefined4 *)(PTR_gc_080004f0 + 8) = *(undefined4 *)(PTR_settings_080004f4 + 0x10);\n  select_plane('\\0','\\x01','\\x02');\n  PTR_gc_080004f0[4] = 1;\n  uVar1 = settings_read_coord_data(PTR_gc_080004f0[0x1c],DAT_080004f8);\n  if (uVar1 == '\\0') {\n    report_status_message('\\n');\n  }\n  return;\n}\n\n", 
            "called": [
                "select_plane", 
                "settings_read_coord_data", 
                "report_status_message", 
                "memset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080004ac", 
            "calling": [
                "grbl_main"
            ], 
            "imported": false, 
            "current_name": "gc_init"
        }, 
        "HAL_RCC_GetOscConfig": {
            "renaming": {}, 
            "code": "\nvoid HAL_RCC_GetOscConfig(RCC_OscInitTypeDef *RCC_OscInitStruct)\n\n{\n  uint uVar1;\n  uint32_t result_2;\n  uint32_t result_3;\n  uint32_t result_4;\n  uint32_t result_5;\n  uint32_t result_6;\n  uint32_t result_7;\n  uint32_t result;\n  uint32_t result_1;\n  \n  RCC_OscInitStruct->OscillatorType = 0xf;\n  if ((*DAT_080068b8 & 0x40000) == 0x40000) {\n    RCC_OscInitStruct->HSEState = 5;\n  }\n  else if ((*DAT_080068b8 & 0x10000) == 0x10000) {\n    RCC_OscInitStruct->HSEState = 1;\n  }\n  else {\n    RCC_OscInitStruct->HSEState = 0;\n  }\n  if ((*DAT_080068b8 & 1) == 1) {\n    RCC_OscInitStruct->HSIState = 1;\n  }\n  else {\n    RCC_OscInitStruct->HSIState = 0;\n  }\n  uVar1 = count_leading_zeroes(0x1f000000);\n  RCC_OscInitStruct->HSICalibrationValue = (*DAT_080068b8 & 0xf8) >> (uVar1 & 0xff);\n  if ((DAT_080068b8[0x1c] & 4) == 4) {\n    RCC_OscInitStruct->LSEState = 5;\n  }\n  else if ((DAT_080068b8[0x1c] & 1) == 1) {\n    RCC_OscInitStruct->LSEState = 1;\n  }\n  else {\n    RCC_OscInitStruct->LSEState = 0;\n  }\n  if ((DAT_080068b8[0x1d] & 1) == 1) {\n    RCC_OscInitStruct->LSIState = 1;\n  }\n  else {\n    RCC_OscInitStruct->LSIState = 0;\n  }\n  if ((*DAT_080068b8 & 0x1000000) == 0x1000000) {\n    (RCC_OscInitStruct->PLL).PLLState = 2;\n  }\n  else {\n    (RCC_OscInitStruct->PLL).PLLState = 1;\n  }\n  (RCC_OscInitStruct->PLL).PLLSource = DAT_080068b8[1] & 0x400000;\n  (RCC_OscInitStruct->PLL).PLLM = DAT_080068b8[1] & 0x3f;\n  uVar1 = count_leading_zeroes(0x3fe0000);\n  (RCC_OscInitStruct->PLL).PLLN = (DAT_080068b8[1] & 0x7fc0) >> (uVar1 & 0xff);\n  uVar1 = count_leading_zeroes(0xc000);\n  (RCC_OscInitStruct->PLL).PLLP = ((DAT_080068b8[1] & 0x30000) + 0x10000) * 2 >> (uVar1 & 0xff);\n  uVar1 = count_leading_zeroes(0xf0);\n  (RCC_OscInitStruct->PLL).PLLQ = (DAT_080068b8[1] & 0xf000000) >> (uVar1 & 0xff);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006718", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_RCC_GetOscConfig"
        }, 
        "__ieee754_sqrt": {
            "renaming": {}, 
            "code": "\nuint __ieee754_sqrt(uint param_1,uint param_2)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  undefined4 uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  undefined8 uVar14;\n  \n  if ((DAT_0800a340 & ~param_2) == 0) {\n    uVar14 = __muldf3(param_1,param_2,param_1,param_2);\n    uVar8 = __aeabi_dadd((int)uVar14,(int)((ulonglong)uVar14 >> 0x20),param_1,param_2);\n    return uVar8;\n  }\n  if ((int)param_2 < 1) {\n    if ((param_2 & 0x7fffffff | param_1) == 0) {\n      return param_1;\n    }\n    if (param_2 != 0) {\n      uVar14 = __subdf3(param_1,param_2,param_1);\n      uVar5 = (undefined4)((ulonglong)uVar14 >> 0x20);\n      uVar8 = __divdf3((int)uVar14,uVar5,(int)uVar14,uVar5);\n      return uVar8;\n    }\n    do {\n      uVar10 = param_1;\n      uVar8 = uVar10 >> 0xb;\n      param_2 = param_2 - 0x15;\n      param_1 = uVar10 << 0x15;\n    } while (uVar8 == 0);\n    uVar2 = param_2;\n    if (-1 < (int)uVar10) goto LAB_0800a290;\n    uVar11 = 0x20;\n    uVar6 = 0xffffffff;\n    uVar10 = param_1;\n  }\n  else {\n    uVar2 = (int)param_2 >> 0x14;\n    uVar8 = param_2;\n    uVar10 = param_1;\n    if (uVar2 != 0) goto LAB_0800a1da;\nLAB_0800a290:\n    uVar10 = 0;\n    uVar11 = uVar8;\n    do {\n      uVar6 = uVar10;\n      uVar8 = uVar11 << 1;\n      iVar3 = uVar11 << 0xc;\n      uVar10 = uVar6 + 1;\n      uVar11 = uVar8;\n    } while (-1 < iVar3);\n    uVar11 = 0x20 - uVar10;\n    param_2 = uVar2;\n    uVar10 = param_1 << (uVar10 & 0xff);\n  }\n  uVar8 = param_1 >> (uVar11 & 0xff) | uVar8;\n  uVar2 = param_2 - uVar6;\nLAB_0800a1da:\n  uVar8 = uVar8 & 0xfffff | 0x100000;\n  if (-1 < (int)(uVar2 << 0x1f)) {\n    uVar8 = uVar8 * 2 - ((int)uVar10 >> 0x1f);\n    uVar10 = uVar10 << 1;\n  }\n  uVar13 = 0;\n  uVar8 = uVar8 * 2 - ((int)uVar10 >> 0x1f);\n  uVar10 = uVar10 << 1;\n  uVar2 = 0;\n  uVar11 = 0x16;\n  uVar6 = 0x200000;\n  do {\n    iVar3 = uVar2 + uVar6;\n    if (iVar3 <= (int)uVar8) {\n      uVar8 = uVar8 - iVar3;\n      uVar2 = iVar3 + uVar6;\n      uVar13 = uVar13 + uVar6;\n    }\n    uVar11 = uVar11 - 1;\n    uVar8 = uVar8 * 2 - ((int)uVar10 >> 0x1f);\n    uVar6 = uVar6 >> 1;\n    uVar10 = uVar10 << 1;\n  } while (uVar11 != 0);\n  uVar1 = 0x20;\n  uVar7 = 0x80000000;\n  uVar6 = uVar11;\n  do {\n    uVar4 = uVar7 + uVar11;\n    uVar12 = uVar2;\n    if ((int)uVar2 < (int)uVar8) {\n      if ((int)uVar4 < 0) {\nLAB_0800a26a:\n        if (-1 < (int)(uVar4 + uVar7)) {\n          uVar12 = uVar2 + 1;\n        }\n      }\n      uVar9 = uVar8 - uVar2;\n      uVar2 = uVar12;\n      if (uVar10 < uVar4) {\n        uVar9 = uVar9 - 1;\n      }\nLAB_0800a262:\n      uVar11 = uVar4 + uVar7;\n      uVar10 = uVar10 - uVar4;\n      uVar6 = uVar6 + uVar7;\n      uVar8 = uVar9;\n    }\n    else if ((uVar8 == uVar2) && (uVar4 <= uVar10)) {\n      if ((int)uVar4 < 0) goto LAB_0800a26a;\n      uVar9 = 0;\n      uVar2 = uVar8;\n      goto LAB_0800a262;\n    }\n    uVar1 = uVar1 - 1;\n    uVar7 = uVar7 >> 1;\n    uVar8 = uVar8 * 2 - ((int)uVar10 >> 0x1f);\n    uVar10 = uVar10 << 1;\n    if (uVar1 == 0) {\n      if ((uVar8 | uVar10) == 0) {\n        uVar1 = uVar6 >> 1;\n      }\n      else if (uVar6 == 0xffffffff) {\n        uVar13 = uVar13 + 1;\n      }\n      else {\n        uVar1 = uVar6 + 1 >> 1;\n      }\n      if ((uVar13 & 1) != 0) {\n        uVar1 = uVar1 | 0x80000000;\n      }\n      return uVar1;\n    }\n  } while( true );\n}\n\n", 
            "called": [
                "__divdf3", 
                "__muldf3", 
                "__subdf3", 
                "__aeabi_dadd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800a1bc", 
            "calling": [
                "__ieee754_hypot", 
                "sqrt"
            ], 
            "imported": false, 
            "current_name": "__ieee754_sqrt"
        }, 
        "__aeabi_cdrcmple": {
            "renaming": {}, 
            "code": "\nvoid __aeabi_cdrcmple(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  __aeabi_cdcmpeq(param_3,param_4,param_1,param_2);\n  return;\n}\n\n", 
            "called": [
                "__aeabi_cdcmpeq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008af0", 
            "calling": [
                "__aeabi_dcmpgt", 
                "__aeabi_dcmpge"
            ], 
            "imported": false, 
            "current_name": "__aeabi_cdrcmple"
        }, 
        "__aeabi_frsub": {
            "renaming": {}, 
            "code": "\nuint __aeabi_frsub(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  int iVar7;\n  bool bVar8;\n  \n  uVar2 = param_1 ^ 0x80000000;\n  uVar4 = param_1 << 1;\n  bVar8 = uVar4 == 0;\n  if (!bVar8) {\n    param_4 = param_2 << 1;\n    bVar8 = param_4 == 0;\n  }\n  if (!bVar8) {\n    bVar8 = uVar4 == param_4;\n  }\n  iVar7 = (int)uVar4 >> 0x18;\n  if (!bVar8) {\n    bVar8 = iVar7 == -1;\n  }\n  if (!bVar8) {\n    bVar8 = (int)param_4 >> 0x18 == -1;\n  }\n  if (bVar8) {\n    iVar1 = (int)(param_2 << 1) >> 0x18;\n    if (iVar7 == -1 || iVar1 == -1) {\n      uVar4 = param_2;\n      if (iVar7 == -1) {\n        uVar4 = uVar2;\n      }\n      if (iVar7 != -1 || iVar1 != -1) {\n        param_2 = uVar4;\n      }\n      bVar8 = (uVar4 & 0x7fffff) == 0;\n      if (bVar8) {\n        bVar8 = (param_2 & 0x7fffff) == 0;\n      }\n      if (bVar8) {\n        bVar8 = uVar4 == param_2;\n      }\n      if (!bVar8) {\n        uVar4 = uVar4 | 0x400000;\n      }\n      return uVar4;\n    }\n    if (((param_1 ^ param_2) & 0x7fffffff) != 0) {\n      if (uVar4 == 0) {\n        uVar2 = param_2;\n      }\n      return uVar2;\n    }\n    if (uVar2 != param_2) {\n      return 0;\n    }\n    if ((uVar4 & 0xff000000) == 0) {\n      param_1 = param_1 << 1;\n      if ((uVar2 & 0x80000000) != 0) {\n        param_1 = param_1 | 0x80000000;\n      }\n      return param_1;\n    }\n    if (uVar4 < 0xfe000000) {\n      return uVar2 + 0x800000;\n    }\n    uVar2 = uVar2 & 0x80000000;\nLAB_08008e12:\n    return uVar2 | 0x7f800000;\n  }\n  uVar4 = uVar4 >> 0x18;\n  param_4 = param_4 >> 0x18;\n  uVar6 = param_4 - uVar4;\n  bVar8 = uVar6 != 0;\n  uVar5 = uVar4;\n  if (bVar8 && uVar4 <= param_4) {\n    uVar5 = uVar4 + uVar6;\n  }\n  if (bVar8 && uVar4 <= param_4) {\n    param_2 = param_2 ^ uVar2;\n  }\n  if (bVar8 && uVar4 <= param_4) {\n    uVar2 = uVar2 ^ param_2;\n  }\n  if (bVar8 && uVar4 <= param_4) {\n    param_2 = param_2 ^ uVar2;\n  }\n  if (param_4 < uVar4) {\n    uVar6 = -uVar6;\n  }\n  if (0x19 < uVar6) {\n    return uVar2;\n  }\n  uVar4 = uVar2 & 0xffffff | 0x800000;\n  if ((uVar2 & 0x80000000) != 0) {\n    uVar4 = -uVar4;\n  }\n  uVar3 = param_2 & 0xffffff | 0x800000;\n  if ((param_2 & 0x80000000) != 0) {\n    uVar3 = -uVar3;\n  }\n  if (uVar5 == uVar6) {\n    uVar3 = uVar3 ^ 0x800000;\n    if (uVar5 == 0) {\n      uVar4 = uVar4 ^ 0x800000;\n      uVar5 = 1;\n    }\n    else {\n      uVar6 = uVar6 - 1;\n    }\n  }\n  uVar4 = uVar4 + ((int)uVar3 >> (uVar6 & 0xff));\n  uVar3 = uVar3 << (0x20 - uVar6 & 0xff);\n  uVar2 = uVar4 & 0x80000000;\n  if ((int)uVar4 < 0) {\n    bVar8 = uVar3 != 0;\n    uVar3 = -uVar3;\n    uVar4 = -uVar4 - (uint)bVar8;\n  }\n  if (uVar4 < 0x800000) {\n    uVar6 = uVar3 & 0x80000000;\n    uVar3 = uVar3 << 1;\n    uVar4 = uVar4 * 2 + (uint)(uVar6 != 0);\n    uVar6 = uVar5 - 2;\n    if (uVar5 - 1 == 0 || uVar4 < 0x800000) {\n      iVar7 = count_leading_zeroes(uVar4);\n      uVar5 = iVar7 - 8;\n      uVar4 = uVar4 << (uVar5 & 0xff);\n      if ((int)uVar6 < (int)uVar5) {\n        uVar4 = uVar4 >> (-(uVar6 - uVar5) & 0xff);\n      }\n      else {\n        uVar4 = uVar4 + (uVar6 - uVar5) * 0x800000;\n      }\n      return uVar4 | uVar2;\n    }\n  }\n  else {\n    uVar6 = uVar5 - 1;\n    if (0xffffff < uVar4) {\n      uVar6 = uVar4 & 1;\n      uVar4 = uVar4 >> 1;\n      uVar3 = (uint)(uVar6 != 0) << 0x1f | uVar3 >> 1;\n      uVar6 = uVar5;\n      if (0xfd < uVar5) goto LAB_08008e12;\n    }\n  }\n  uVar4 = uVar4 + uVar6 * 0x800000 + (uint)(0x7fffffff < uVar3);\n  if (uVar3 == 0x80000000) {\n    uVar4 = uVar4 & 0xfffffffe;\n  }\n  return uVar4 | uVar2;\n}\n\n", 
            "called": [
                "__addsf3"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008cd0", 
            "calling": [], 
            "imported": false, 
            "current_name": "__aeabi_frsub"
        }, 
        "print_uint8_base2": {
            "renaming": {}, 
            "code": "\nvoid print_uint8_base2(uint8_t n)\n\n{\n  print_base2((uint)n,8);\n  return;\n}\n\n", 
            "called": [
                "print_base2"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003740", 
            "calling": [], 
            "imported": false, 
            "current_name": "print_uint8_base2"
        }, 
        "NVIC_GetPriority": {
            "renaming": {}, 
            "code": "\nuint32_t NVIC_GetPriority(IRQn_Type IRQn)\n\n{\n  byte bVar1;\n  \n  if (IRQn < WWDG_IRQn) {\n    bVar1 = *(byte *)(((byte)IRQn & 0xf) + DAT_08006b98 + 0x14);\n  }\n  else {\n    bVar1 = *(byte *)(IRQn + DAT_08006b9c + 0x300);\n  }\n  return (uint)(bVar1 >> 4);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006b54", 
            "calling": [
                "HAL_NVIC_GetPriority"
            ], 
            "imported": false, 
            "current_name": "NVIC_GetPriority"
        }, 
        "__unorddf2": {
            "renaming": {}, 
            "code": "\nundefined4 __unorddf2(uint param_1,int param_2,uint param_3,int param_4)\n\n{\n  if ((((param_2 << 1) >> 0x15 != -1) || ((param_1 | param_2 << 0xc) == 0)) &&\n     (((param_4 << 1) >> 0x15 != -1 || ((param_3 | param_4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008b74", 
            "calling": [
                "sqrt"
            ], 
            "imported": false, 
            "current_name": "__unorddf2"
        }, 
        "step_pulse_isr": {
            "renaming": {}, 
            "code": "\nvoid step_pulse_isr(void)\n\n{\n  step_wr((uint)*(ushort *)(PTR_settings_08005774 + 0x18));\n  return;\n}\n\n", 
            "called": [
                "step_wr"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005760", 
            "calling": [
                "TIM2_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "step_pulse_isr"
        }, 
        "g540_timer_stop": {
            "renaming": {}, 
            "code": "\nvoid g540_timer_stop(void)\n\n{\n  uint *puVar1;\n  TIM_TypeDef *TIMx;\n  \n  puVar1 = DAT_08007e04;\n  *DAT_08007e04 = *DAT_08007e04 & 0xfffffffe;\n  puVar1[8] = puVar1[8] & 0xffffffef;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007dd8", 
            "calling": [], 
            "imported": false, 
            "current_name": "g540_timer_stop"
        }, 
        "NVIC_GetPendingIRQ": {
            "renaming": {}, 
            "code": "\nuint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)\n\n{\n  return (uint)((*(uint *)(DAT_08006a54 + (((uint)(int)IRQn >> 5) + 0x40) * 4) & 1 << (IRQn & 0x1fU)\n                ) != 0);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006a18", 
            "calling": [
                "HAL_NVIC_GetPendingIRQ"
            ], 
            "imported": false, 
            "current_name": "NVIC_GetPendingIRQ"
        }, 
        "Error_Handler": {
            "renaming": {}, 
            "code": "\nvoid Error_Handler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007430", 
            "calling": [
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "Error_Handler"
        }, 
        "__aeabi_fcmpeq": {
            "renaming": {}, 
            "code": "\nbool __aeabi_fcmpeq(void)\n\n{\n  char in_ZR;\n  \n  __aeabi_cfcmpeq();\n  return in_ZR != '\\0';\n}\n\n", 
            "called": [
                "__aeabi_cfcmpeq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009214", 
            "calling": [
                "planner_reverse_pass_kernel", 
                "mc_arc", 
                "planner_forward_pass_kernel", 
                "gc_execute_line", 
                "settings_store_global_setting", 
                "read_float"
            ], 
            "imported": false, 
            "current_name": "__aeabi_fcmpeq"
        }, 
        "HAL_RCC_DisableCSS": {
            "renaming": {}, 
            "code": "\nvoid HAL_RCC_DisableCSS(void)\n\n{\n  *DAT_080064e8 = 0;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080064d4", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_RCC_DisableCSS"
        }, 
        "protocol_init": {
            "renaming": {}, 
            "code": "\nvoid protocol_init(void)\n\n{\n  protocol_reset_line_buffer();\n  report_init_message();\n  *(undefined4 *)PTR_buttons_enabled_080039b8 = 1;\n  return;\n}\n\n", 
            "called": [
                "protocol_reset_line_buffer", 
                "report_init_message"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080039a0", 
            "calling": [
                "grbl_main"
            ], 
            "imported": false, 
            "current_name": "protocol_init"
        }, 
        "HAL_NVIC_GetPendingIRQ": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = NVIC_GetPendingIRQ(IRQn);\n  return uVar1;\n}\n\n", 
            "called": [
                "NVIC_GetPendingIRQ"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006de0", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_NVIC_GetPendingIRQ"
        }, 
        "delay_us": {
            "renaming": {}, 
            "code": "\nvoid delay_us(uint32_t us)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002828", 
            "calling": [
                "homing_cycle"
            ], 
            "imported": false, 
            "current_name": "delay_us"
        }, 
        "coolant_init": {
            "renaming": {}, 
            "code": "\nvoid coolant_init(void)\n\n{\n  *PTR_current_coolant_mode_0800020c = 0;\n  coolant_stop();\n  return;\n}\n\n", 
            "called": [
                "coolant_stop"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080001f8", 
            "calling": [
                "grbl_main"
            ], 
            "imported": false, 
            "current_name": "coolant_init"
        }, 
        "HAL_RCC_DeInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_RCC_DeInit(void)\n\n{\n  *DAT_08005ce4 = *DAT_08005ce4 | 0x81;\n  DAT_08005ce4[2] = 0;\n  *DAT_08005ce4 = *DAT_08005ce4 & 0xfaf6ffff;\n  DAT_08005ce4[1] = 0;\n  DAT_08005ce4[1] = DAT_08005ce8 | DAT_08005ce4[1];\n  DAT_08005ce4[0x21] = 0;\n  DAT_08005ce4[0x21] = DAT_08005ce4[0x21] | 0x20003000;\n  *DAT_08005ce4 = *DAT_08005ce4 & 0xfffbffff;\n  DAT_08005ce4[3] = 0;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005c74", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_RCC_DeInit"
        }, 
        "memcpy_to_eeprom_with_checksum": {
            "renaming": {}, 
            "code": "\nvoid memcpy_to_eeprom_with_checksum(uint destination,char *source,uint size)\n\n{\n  uint local_1c;\n  uchar *local_18;\n  uint local_14;\n  uchar checksum;\n  \n  checksum = '\\0';\n  local_1c = size;\n  local_18 = (uchar *)source;\n  local_14 = destination;\n  if (*(int *)PTR_eeprom_ready_080003e8 == 0) {\n    eeprom_init();\n    local_18 = (uchar *)source;\n    local_14 = destination;\n  }\n  for (; local_1c != 0; local_1c = local_1c - 1) {\n    checksum = (checksum != '\\0') + *local_18;\n    eeprom_put_char(local_14,*local_18);\n    local_18 = local_18 + 1;\n    local_14 = local_14 + 1;\n  }\n  eeprom_put_char(local_14,checksum);\n  return;\n}\n\n", 
            "called": [
                "eeprom_put_char", 
                "eeprom_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000374", 
            "calling": [
                "settings_store_startup_line", 
                "settings_write_coord_data", 
                "write_global_settings"
            ], 
            "imported": false, 
            "current_name": "memcpy_to_eeprom_with_checksum"
        }, 
        "__libc_fini_array": {
            "renaming": {}, 
            "code": "\nvoid __libc_fini_array(void)\n\n{\n  int iVar1;\n  code **ppcVar2;\n  \n  iVar1 = (int)PTR___fini_array_end_0800b514 -\n          (int)PTR___do_global_dtors_aux_fini_array_entry_0800b518 >> 2;\n  if (iVar1 != 0) {\n    ppcVar2 = (code **)(PTR___do_global_dtors_aux_fini_array_entry_0800b518 +\n                       ((int)PTR___fini_array_end_0800b514 -\n                       (int)PTR___do_global_dtors_aux_fini_array_entry_0800b518) + -4);\n    do {\n      iVar1 = iVar1 + -1;\n      (**ppcVar2)();\n      ppcVar2 = ppcVar2 + -1;\n    } while (iVar1 != 0);\n  }\n  _fini();\n  return;\n}\n\n", 
            "called": [
                "frame_dummy", 
                "__do_global_dtors_aux", 
                "_fini"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800b4f0", 
            "calling": [], 
            "imported": false, 
            "current_name": "__libc_fini_array"
        }, 
        "_init": {
            "renaming": {}, 
            "code": "\nint _init(EVP_PKEY_CTX *ctx)\n\n{\n  return (int)ctx;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800b5b0", 
            "calling": [
                "frame_dummy", 
                "__do_global_dtors_aux", 
                "__libc_init_array"
            ], 
            "imported": false, 
            "current_name": "_init"
        }, 
        "plan_set_current_position": {
            "renaming": {}, 
            "code": "\nvoid plan_set_current_position(int32_t x,int32_t y,int32_t z)\n\n{\n  *(int32_t *)PTR_pl_08003614 = x;\n  *(int32_t *)(PTR_pl_08003614 + 4) = y;\n  *(int32_t *)(PTR_pl_08003614 + 8) = z;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080035ec", 
            "calling": [
                "sys_sync_current_position"
            ], 
            "imported": false, 
            "current_name": "plan_set_current_position"
        }, 
        "NVIC_GetPriorityGrouping": {
            "renaming": {}, 
            "code": "\nuint32_t NVIC_GetPriorityGrouping(void)\n\n{\n  return *(uint *)(DAT_080069b0 + 0xc) >> 8 & 7;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006998", 
            "calling": [
                "HAL_NVIC_SetPriority", 
                "HAL_NVIC_GetPriorityGrouping"
            ], 
            "imported": false, 
            "current_name": "NVIC_GetPriorityGrouping"
        }, 
        "__floatundidf": {
            "renaming": {}, 
            "code": "\nulonglong __floatundidf(uint param_1,uint param_2)\n\n{\n  byte bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  uint uVar8;\n  bool bVar9;\n  bool bVar10;\n  bool bVar11;\n  \n  if ((param_1 | param_2) == 0) {\n    return CONCAT44(param_2,param_1);\n  }\n  iVar7 = 0x432;\n  uVar8 = param_2 >> 0x16;\n  if (uVar8 != 0) {\n    iVar7 = 3;\n    if (param_2 >> 0x19 != 0) {\n      iVar7 = 6;\n    }\n    if (param_2 >> 0x1c != 0) {\n      iVar7 = iVar7 + 3;\n    }\n    uVar4 = iVar7 - ((int)param_2 >> 0x1f);\n    uVar8 = param_1 << (0x20 - uVar4 & 0xff);\n    param_1 = param_1 >> (uVar4 & 0xff) | param_2 << (0x20 - uVar4 & 0xff);\n    param_2 = param_2 >> (uVar4 & 0xff);\n    iVar7 = uVar4 + 0x432;\n  }\n  if (0xfffff < param_2) {\n    if (0x1fffff < param_2) {\n      uVar4 = param_2 & 1;\n      param_2 = param_2 >> 1;\n      bVar1 = (byte)param_1;\n      param_1 = (uint)(uVar4 != 0) << 0x1f | param_1 >> 1;\n      uVar8 = (uint)(bVar1 & 1) << 0x1f | uVar8 >> 1;\n      iVar7 = iVar7 + 1;\n      if (0xffbfffff < (uint)(iVar7 * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_080083e0:\n    bVar10 = 0x7fffffff < uVar8;\n    if (uVar8 == 0x80000000) {\n      bVar10 = (param_1 & 1) != 0;\n    }\n    return CONCAT44(param_2 + iVar7 * 0x100000 + (uint)CARRY4(param_1,(uint)bVar10),param_1 + bVar10\n                   );\n  }\n  bVar9 = (uVar8 & 0x80000000) != 0;\n  uVar8 = uVar8 << 1;\n  uVar4 = param_1 * 2;\n  bVar10 = CARRY4(param_1,param_1);\n  param_1 = param_1 * 2 + (uint)bVar9;\n  param_2 = param_2 * 2 + (uint)(bVar10 || CARRY4(uVar4,(uint)bVar9));\n  bVar10 = iVar7 != 0;\n  iVar7 = iVar7 + -1;\n  if (bVar10 && 0xfffff < param_2) goto LAB_080083e0;\n  uVar2 = param_1;\n  uVar4 = param_2;\n  if (param_2 == 0) {\n    uVar2 = 0;\n    uVar4 = param_1;\n  }\n  iVar5 = count_leading_zeroes(uVar4);\n  if (param_2 == 0) {\n    iVar5 = iVar5 + 0x20;\n  }\n  uVar6 = iVar5 - 0xb;\n  bVar11 = SBORROW4(uVar6,0x20);\n  uVar3 = iVar5 - 0x2b;\n  bVar10 = (int)uVar3 < 0;\n  bVar9 = uVar3 == 0;\n  if ((int)uVar6 < 0x20) {\n    bVar11 = SCARRY4(uVar3,0xc);\n    iVar5 = iVar5 + -0x1f;\n    bVar10 = iVar5 < 0;\n    bVar9 = iVar5 == 0;\n    uVar3 = uVar6;\n    if (!bVar9 && bVar10 == bVar11) {\n      uVar2 = uVar4 << (uVar6 & 0xff);\n      uVar4 = uVar4 >> (0xcU - iVar5 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bVar9 || bVar10 != bVar11) {\n    uVar8 = 0x20 - uVar3;\n  }\n  uVar4 = uVar4 << (uVar3 & 0xff);\n  if (bVar9 || bVar10 != bVar11) {\n    uVar4 = uVar4 | uVar2 >> (uVar8 & 0xff);\n  }\n  if (bVar9 || bVar10 != bVar11) {\n    uVar2 = uVar2 << (uVar3 & 0xff);\n  }\nLAB_08008458:\n  if ((int)uVar6 <= iVar7) {\n    return CONCAT44(uVar4 + (iVar7 - uVar6) * 0x100000,uVar2);\n  }\n  uVar8 = ~(iVar7 - uVar6);\n  if ((int)uVar8 < 0x1f) {\n    iVar7 = uVar8 - 0x13;\n    if (iVar7 != 0 && iVar7 < 0 == SCARRY4(uVar8 - 0x1f,0xc)) {\n      return (ulonglong)(uVar2 >> (0x20 - (0xcU - iVar7) & 0xff) | uVar4 << (0xcU - iVar7 & 0xff));\n    }\n    uVar8 = uVar8 + 1;\n    return CONCAT44(uVar4 >> (uVar8 & 0xff),uVar2 >> (uVar8 & 0xff) | uVar4 << (0x20 - uVar8 & 0xff)\n                   );\n  }\n  return (ulonglong)(uVar4 >> (uVar8 - 0x1f & 0xff));\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080085d4", 
            "calling": [], 
            "imported": false, 
            "current_name": "__floatundidf"
        }, 
        "HAL_RCC_MCOConfig": {
            "renaming": {}, 
            "code": "\nvoid HAL_RCC_MCOConfig(uint32_t RCC_MCOx,uint32_t RCC_MCOSource,uint32_t RCC_MCODiv)\n\n{\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (RCC_MCOx == 0) {\n    *(uint *)(DAT_080064b0 + 0x30) = *(uint *)(DAT_080064b0 + 0x30) | 1;\n    GPIO_InitStruct.Pin = 0x100;\n    GPIO_InitStruct.Mode = 2;\n    GPIO_InitStruct.Speed = 3;\n    GPIO_InitStruct.Pull = 0;\n    GPIO_InitStruct.Alternate = 0;\n    HAL_GPIO_Init(DAT_080064b4,&GPIO_InitStruct);\n    *(uint32_t *)(DAT_080064b0 + 8) =\n         RCC_MCODiv | RCC_MCOSource | *(uint *)(DAT_080064b0 + 8) & 0xf89fffff;\n  }\n  else {\n    *(uint *)(DAT_080064b0 + 0x30) = *(uint *)(DAT_080064b0 + 0x30) | 4;\n    GPIO_InitStruct.Pin = 0x200;\n    GPIO_InitStruct.Mode = 2;\n    GPIO_InitStruct.Speed = 3;\n    GPIO_InitStruct.Pull = 0;\n    GPIO_InitStruct.Alternate = 0;\n    HAL_GPIO_Init(DAT_080064b8,&GPIO_InitStruct);\n    *(uint32_t *)(DAT_080064b0 + 8) =\n         RCC_MCOSource | RCC_MCODiv << 3 | *(uint *)(DAT_080064b0 + 8) & 0x7ffffff;\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_Init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800640c", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_RCC_MCOConfig"
        }, 
        "UsageFault_Handler": {
            "renaming": {}, 
            "code": "\nvoid UsageFault_Handler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800772c", 
            "calling": [], 
            "imported": false, 
            "current_name": "UsageFault_Handler"
        }, 
        "eeprom_put_char": {
            "renaming": {}, 
            "code": "\nvoid eeprom_put_char(uint addr,uchar new_value)\n\n{\n  if (*(int *)PTR_eeprom_ready_0800036c == 0) {\n    eeprom_init();\n  }\n  PTR_eeprom_data_08000370[addr & 0x3ff] = new_value;\n  return;\n}\n\n", 
            "called": [
                "eeprom_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000340", 
            "calling": [
                "memcpy_to_eeprom_with_checksum", 
                "write_global_settings"
            ], 
            "imported": false, 
            "current_name": "eeprom_put_char"
        }, 
        "report_feedback_message": {
            "renaming": {}, 
            "code": "\nvoid report_feedback_message(uint8_t message_code)\n\n{\n  printPgmString(PTR_DAT_0800420c);\n  switch(message_code) {\n  case '\\x01':\n    printPgmString(PTR_s_Reset_to_continue_08004210);\n    break;\n  case '\\x02':\n    printPgmString(PTR_s___H____X__to_unlock_08004214);\n    break;\n  case '\\x03':\n    printPgmString(PTR_s_Caution__Unlocked_08004218);\n    break;\n  case '\\x04':\n    printPgmString(PTR_s_Enabled_0800421c);\n    break;\n  case '\\x05':\n    printPgmString(PTR_s_Disabled_08004220);\n  }\n  printPgmString(PTR_DAT_08004224);\n  return;\n}\n\n", 
            "called": [
                "printPgmString"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080041a0", 
            "calling": [
                "protocol_execute_runtime", 
                "grbl_main", 
                "protocol_execute_line"
            ], 
            "imported": false, 
            "current_name": "report_feedback_message"
        }, 
        "NVIC_EnableIRQ": {
            "renaming": {}, 
            "code": "\nvoid NVIC_EnableIRQ(IRQn_Type IRQn)\n\n{\n  *(int *)(DAT_08007a0c + ((uint)(int)IRQn >> 5) * 4) = 1 << (IRQn & 0x1fU);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080079e0", 
            "calling": [
                "enable_tim_interrupt"
            ], 
            "imported": false, 
            "current_name": "NVIC_EnableIRQ"
        }, 
        "usart_init": {
            "renaming": {}, 
            "code": "\nvoid usart_init(void)\n\n{\n  USART_TypeDef *usart_00;\n  uint32_t val;\n  USART_TypeDef *usart;\n  \n  usart_00 = DAT_08008240;\n  enable_usart_clock(DAT_08008240);\n  usart_00->CR1 = usart_00->CR1 & 0xffffdfff;\n  usart_00->CR1 = usart_00->CR1 & 0xffff400c | 0xc;\n  usart_00->CR2 = usart_00->CR2 & 0xffff8090;\n  usart_00->CR3 = usart_00->CR3 & 0xfffff000;\n  usart_00->SR = usart_00->SR & 0xfffffc00;\n  set_baud_rate(usart_00,0x1c200);\n  usart_00->GTPR = usart_00->GTPR;\n  usart_00->CR1 = usart_00->CR1 | 0x2000;\n  return;\n}\n\n", 
            "called": [
                "enable_usart_clock", 
                "set_baud_rate"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008190", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "usart_init"
        }, 
        "HAL_EnableDBGStandbyMode": {
            "renaming": {}, 
            "code": "\nvoid HAL_EnableDBGStandbyMode(void)\n\n{\n  *(uint *)(DAT_08005b8c + 4) = *(uint *)(DAT_08005b8c + 4) | 4;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005b74", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_EnableDBGStandbyMode"
        }, 
        "HAL_DeInit": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef HAL_DeInit(void)\n\n{\n  *(undefined4 *)(DAT_08005a4c + 0x20) = 0xffffffff;\n  *(undefined4 *)(DAT_08005a4c + 0x20) = 0;\n  *(undefined4 *)(DAT_08005a4c + 0x24) = 0xffffffff;\n  *(undefined4 *)(DAT_08005a4c + 0x24) = 0;\n  *(undefined4 *)(DAT_08005a4c + 0x10) = 0xffffffff;\n  *(undefined4 *)(DAT_08005a4c + 0x10) = 0;\n  *(undefined4 *)(DAT_08005a4c + 0x14) = 0xffffffff;\n  *(undefined4 *)(DAT_08005a4c + 0x14) = 0;\n  *(undefined4 *)(DAT_08005a4c + 0x18) = 0xffffffff;\n  *(undefined4 *)(DAT_08005a4c + 0x18) = 0;\n  HAL_MspDeInit();\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_MspDeInit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080059f8", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_DeInit"
        }, 
        "__aeabi_dadd": {
            "renaming": {}, 
            "code": "\nulonglong __aeabi_dadd(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  bool bVar14;\n  bool bVar15;\n  \n  uVar7 = param_2 << 1;\n  uVar9 = param_4 << 1;\n  bVar13 = ((param_2 ^ param_4) & 0x7fffffff) == 0;\n  bVar14 = bVar13 && param_1 == param_3;\n  if (!bVar13 || param_1 != param_3) {\n    bVar14 = (uVar7 | param_1) == 0;\n  }\n  if (!bVar14) {\n    bVar14 = (uVar9 | param_3) == 0;\n  }\n  iVar6 = (int)uVar7 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar6 == -1;\n  }\n  iVar1 = (int)uVar9 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar1 == -1;\n  }\n  if (bVar14) {\n    if (iVar6 == -1 || iVar1 == -1) {\n      uVar9 = param_4;\n      uVar7 = param_3;\n      if (iVar6 == -1) {\n        uVar9 = param_2;\n        uVar7 = param_1;\n      }\n      if (iVar6 != -1 || iVar1 != -1) {\n        param_3 = uVar7;\n        param_4 = uVar9;\n      }\n      bVar14 = (uVar7 | uVar9 << 0xc) == 0;\n      if (bVar14) {\n        bVar14 = (param_3 | param_4 << 0xc) == 0;\n      }\n      if (bVar14) {\n        bVar14 = uVar9 == param_4;\n      }\n      if (!bVar14) {\n        uVar9 = uVar9 | 0x80000;\n      }\n      return CONCAT44(uVar9,uVar7);\n    }\n    if (((param_2 ^ param_4) & 0x7fffffff) != 0 || param_1 != param_3) {\n      if ((uVar7 | param_1) == 0) {\n        param_1 = param_3;\n        param_2 = param_4;\n      }\n      return CONCAT44(param_2,param_1);\n    }\n    if (param_2 != param_4) {\n      return 0;\n    }\n    if (uVar7 >> 0x15 == 0) {\n      bVar14 = (param_1 & 0x80000000) != 0;\n      uVar9 = param_2 * 2 + (uint)bVar14;\n      if (CARRY4(param_2,param_2) || CARRY4(param_2 * 2,(uint)bVar14)) {\n        uVar9 = uVar9 | 0x80000000;\n      }\n      return CONCAT44(uVar9,param_1 << 1);\n    }\n    if (uVar7 < 0xffc00000) {\n      return CONCAT44(param_2 + 0x100000,param_1);\n    }\n    param_2 = param_2 & 0x80000000;\nLAB_08008514:\n    return (ulonglong)(param_2 | 0x7ff00000) << 0x20;\n  }\n  uVar7 = uVar7 >> 0x15;\n  uVar9 = uVar9 >> 0x15;\n  uVar10 = uVar9 - uVar7;\n  bVar14 = uVar10 != 0;\n  if (uVar9 < uVar7) {\n    uVar10 = -uVar10;\n  }\n  uVar8 = param_1;\n  uVar5 = param_2;\n  if (bVar14 && uVar7 <= uVar9) {\n    uVar7 = uVar7 + uVar10;\n    uVar8 = param_3;\n    uVar5 = param_4;\n    param_3 = param_1;\n    param_4 = param_2;\n  }\n  if (0x36 < uVar10) {\n    return CONCAT44(uVar5,uVar8);\n  }\n  uVar9 = uVar5 & 0xfffff | 0x100000;\n  if ((uVar5 & 0x80000000) != 0) {\n    bVar14 = uVar8 != 0;\n    uVar8 = -uVar8;\n    uVar9 = -uVar9 - (uint)bVar14;\n  }\n  uVar5 = param_4 & 0xfffff | 0x100000;\n  if ((param_4 & 0x80000000) != 0) {\n    bVar14 = param_3 != 0;\n    param_3 = -param_3;\n    uVar5 = -uVar5 - (uint)bVar14;\n  }\n  if (uVar7 == uVar10) {\n    uVar5 = uVar5 ^ 0x100000;\n    if (uVar7 == 0) {\n      uVar9 = uVar9 ^ 0x100000;\n      uVar7 = 1;\n    }\n    else {\n      uVar10 = uVar10 - 1;\n    }\n  }\n  uVar12 = -uVar10 + 0x20;\n  if ((int)uVar10 < 0x21) {\n    uVar11 = param_3 << (uVar12 & 0xff);\n    param_3 = param_3 >> (uVar10 & 0xff);\n    uVar3 = uVar8 + param_3;\n    uVar4 = uVar5 << (uVar12 & 0xff);\n    uVar12 = uVar3 + uVar4;\n    uVar9 = uVar9 + CARRY4(uVar8,param_3) + ((int)uVar5 >> (uVar10 & 0xff)) +\n            (uint)CARRY4(uVar3,uVar4);\n  }\n  else {\n    uVar11 = uVar5 << (-uVar10 + 0x40 & 0xff);\n    if (param_3 != 0) {\n      uVar11 = uVar11 | 2;\n    }\n    uVar5 = (int)uVar5 >> (uVar10 - 0x20 & 0xff);\n    uVar12 = uVar8 + uVar5;\n    uVar9 = uVar9 + ((int)uVar5 >> 0x1f) + (uint)CARRY4(uVar8,uVar5);\n  }\n  param_2 = uVar9 & 0x80000000;\n  uVar10 = uVar9;\n  if ((int)uVar9 < 0) {\n    bVar14 = uVar11 == 0;\n    uVar11 = -uVar11;\n    uVar10 = -uVar12;\n    uVar12 = -(uint)!bVar14 - uVar12;\n    uVar10 = -(uint)(bVar14 <= uVar10) - uVar9;\n  }\n  if (0xfffff < uVar10) {\n    uVar8 = uVar7 - 1;\n    if (0x1fffff < uVar10) {\n      uVar9 = uVar10 & 1;\n      uVar10 = uVar10 >> 1;\n      bVar2 = (byte)uVar12;\n      uVar12 = (uint)(uVar9 != 0) << 0x1f | uVar12 >> 1;\n      uVar11 = (uint)(bVar2 & 1) << 0x1f | uVar11 >> 1;\n      uVar8 = uVar7;\n      if (0xffbfffff < uVar7 * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    bVar14 = 0x7fffffff < uVar11;\n    if (uVar11 == 0x80000000) {\n      bVar14 = (uVar12 & 1) != 0;\n    }\n    return CONCAT44(uVar10 + uVar8 * 0x100000 + (uint)CARRY4(uVar12,(uint)bVar14) | param_2,\n                    uVar12 + bVar14);\n  }\n  bVar13 = (uVar11 & 0x80000000) != 0;\n  uVar11 = uVar11 << 1;\n  uVar8 = uVar12 * 2;\n  bVar14 = CARRY4(uVar12,uVar12);\n  uVar12 = uVar12 * 2 + (uint)bVar13;\n  uVar10 = uVar10 * 2 + (uint)(bVar14 || CARRY4(uVar8,(uint)bVar13));\n  uVar8 = uVar7 - 2;\n  if (uVar7 - 1 != 0 && 0xfffff < uVar10) goto LAB_080083e0;\n  uVar5 = uVar12;\n  uVar7 = uVar10;\n  if (uVar10 == 0) {\n    uVar5 = 0;\n    uVar7 = uVar12;\n  }\n  iVar6 = count_leading_zeroes(uVar7);\n  if (uVar10 == 0) {\n    iVar6 = iVar6 + 0x20;\n  }\n  uVar12 = iVar6 - 0xb;\n  bVar15 = SBORROW4(uVar12,0x20);\n  uVar10 = iVar6 - 0x2b;\n  bVar14 = (int)uVar10 < 0;\n  bVar13 = uVar10 == 0;\n  if ((int)uVar12 < 0x20) {\n    bVar15 = SCARRY4(uVar10,0xc);\n    iVar6 = iVar6 + -0x1f;\n    bVar14 = iVar6 < 0;\n    bVar13 = iVar6 == 0;\n    uVar10 = uVar12;\n    if (!bVar13 && bVar14 == bVar15) {\n      uVar5 = uVar7 << (uVar12 & 0xff);\n      uVar7 = uVar7 >> (0xcU - iVar6 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar11 = 0x20 - uVar10;\n  }\n  uVar7 = uVar7 << (uVar10 & 0xff);\n  if (bVar13 || bVar14 != bVar15) {\n    uVar7 = uVar7 | uVar5 >> (uVar11 & 0xff);\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar5 = uVar5 << (uVar10 & 0xff);\n  }\nLAB_08008458:\n  if ((int)uVar12 <= (int)uVar8) {\n    return CONCAT44(uVar7 + (uVar8 - uVar12) * 0x100000 | param_2,uVar5);\n  }\n  uVar10 = ~(uVar8 - uVar12);\n  if ((int)uVar10 < 0x1f) {\n    iVar6 = uVar10 - 0x13;\n    if (iVar6 != 0 && iVar6 < 0 == SCARRY4(uVar10 - 0x1f,0xc)) {\n      return CONCAT44(uVar9,uVar5 >> (0x20 - (0xcU - iVar6) & 0xff) | uVar7 << (0xcU - iVar6 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    uVar10 = uVar10 + 1;\n    return CONCAT44(param_2 | uVar7 >> (uVar10 & 0xff),\n                    uVar5 >> (uVar10 & 0xff) | uVar7 << (0x20 - uVar10 & 0xff));\n  }\n  return CONCAT44(uVar9,uVar7 >> (uVar10 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080082d4", 
            "calling": [
                "__kernel_cos", 
                "scalbn", 
                "__aeabi_drsub", 
                "__ieee754_sqrt", 
                "atan", 
                "__kernel_rem_pio2", 
                "__ieee754_atan2", 
                "floor", 
                "__ieee754_hypot", 
                "ceil", 
                "__ieee754_rem_pio2", 
                "__kernel_sin", 
                "mc_arc", 
                "round", 
                "trunc"
            ], 
            "imported": false, 
            "current_name": "__aeabi_dadd"
        }, 
        "protocol_process": {
            "renaming": {}, 
            "code": "\nvoid protocol_process(void)\n\n{\n  byte bVar1;\n  uint8_t status_code;\n  byte bVar2;\n  uint8_t c;\n  \n  while( true ) {\n    while( true ) {\n      bVar2 = serial_read();\n      if (bVar2 == 0xff) {\n        return;\n      }\n      if ((bVar2 == 10) || (bVar2 == 0xd)) break;\n      if (*PTR_iscomment_08004028 == '\\0') {\n        if ((0x20 < bVar2) && (bVar2 != 0x2f)) {\n          if (bVar2 == 0x28) {\n            *PTR_iscomment_08004028 = 1;\n          }\n          else if (*PTR_char_counter_08004020 == -1) {\n            report_status_message('\\r');\n            protocol_reset_line_buffer();\n          }\n          else if ((bVar2 < 0x61) || (0x7a < bVar2)) {\n            bVar1 = *PTR_char_counter_08004020;\n            *PTR_char_counter_08004020 = bVar1 + 1;\n            PTR_line_08004024[bVar1] = bVar2;\n          }\n          else {\n            bVar1 = *PTR_char_counter_08004020;\n            *PTR_char_counter_08004020 = bVar1 + 1;\n            PTR_line_08004024[bVar1] = bVar2 - 0x20;\n          }\n        }\n      }\n      else if (bVar2 == 0x29) {\n        *PTR_iscomment_08004028 = 0;\n      }\n    }\n    protocol_execute_runtime();\n    if (*PTR_sys_0800401c != '\\0') break;\n    if (*PTR_char_counter_08004020 == '\\0') {\n      report_status_message('\\0');\n    }\n    else {\n      PTR_line_08004024[(byte)*PTR_char_counter_08004020] = 0;\n      status_code = protocol_execute_line(PTR_line_08004024);\n      report_status_message(status_code);\n    }\n    protocol_reset_line_buffer();\n  }\n  return;\n}\n\n", 
            "called": [
                "protocol_execute_runtime", 
                "protocol_reset_line_buffer", 
                "serial_read", 
                "report_status_message", 
                "protocol_execute_line"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003f34", 
            "calling": [
                "grbl_main"
            ], 
            "imported": false, 
            "current_name": "protocol_process"
        }, 
        "report_init_message": {
            "renaming": {}, 
            "code": "\nvoid report_init_message(void)\n\n{\n  printPgmString(PTR_s__Grbl_0_8c______for_help__08004238);\n  return;\n}\n\n", 
            "called": [
                "printPgmString"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004228", 
            "calling": [
                "protocol_init"
            ], 
            "imported": false, 
            "current_name": "report_init_message"
        }, 
        "settings_store_startup_line": {
            "renaming": {}, 
            "code": "\nvoid settings_store_startup_line(uint8_t n,char *line)\n\n{\n  uint16_t addr;\n  \n  memcpy_to_eeprom_with_checksum((uint)(ushort)((ushort)n * 0x101 + 0x300),line,0x100);\n  return;\n}\n\n", 
            "called": [
                "memcpy_to_eeprom_with_checksum"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004bc0", 
            "calling": [
                "settings_read_startup_line", 
                "protocol_execute_line"
            ], 
            "imported": false, 
            "current_name": "settings_store_startup_line"
        }, 
        "NVIC_DisableIRQ": {
            "renaming": {}, 
            "code": "\nvoid NVIC_DisableIRQ(IRQn_Type IRQn)\n\n{\n  *(int *)(DAT_08006a14 + (((uint)(int)IRQn >> 5) + 0x20) * 4) = 1 << (IRQn & 0x1fU);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080069e4", 
            "calling": [
                "HAL_NVIC_DisableIRQ"
            ], 
            "imported": false, 
            "current_name": "NVIC_DisableIRQ"
        }, 
        "PendSV_Handler": {
            "renaming": {}, 
            "code": "\nvoid PendSV_Handler(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800774a", 
            "calling": [], 
            "imported": false, 
            "current_name": "PendSV_Handler"
        }, 
        "set_step_events_per_minute": {
            "renaming": {}, 
            "code": "\nvoid set_step_events_per_minute(uint32_t steps_per_minute)\n\n{\n  uint ticks_00;\n  uint32_t local_14;\n  uint32_t ticks;\n  \n  local_14 = steps_per_minute;\n  if (steps_per_minute < 800) {\n    local_14 = 800;\n  }\n  ticks_00 = DAT_08005358 / local_14;\n  *(uint *)(PTR_st_0800535c + 0x14) = ticks_00;\n  set_step_period(ticks_00);\n  return;\n}\n\n", 
            "called": [
                "set_step_period"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005324", 
            "calling": [
                "st_cycle_reinitialize", 
                "step_period_isr", 
                "st_reset"
            ], 
            "imported": false, 
            "current_name": "set_step_events_per_minute"
        }, 
        "mc_line": {
            "renaming": {}, 
            "code": "\nvoid mc_line(float x,float y,float z,float feed_rate,uint8_t invert_feed_rate)\n\n{\n  uint8_t uVar1;\n  float x_00;\n  float y_00;\n  float z_00;\n  float feed_rate_00;\n  \n  if (PTR_sys_08001efc[1] != '\\a') {\n    do {\n      protocol_execute_runtime();\n      if (*PTR_sys_08001efc != '\\0') {\n        return;\n      }\n      uVar1 = plan_check_full_buffer();\n    } while (uVar1 != '\\0');\n    plan_buffer_line(x_00,y_00,z_00,feed_rate_00,invert_feed_rate);\n    if (PTR_sys_08001efc[1] == '\\0') {\n      PTR_sys_08001efc[1] = 2;\n    }\n    if (PTR_sys_08001efc[0x10] != '\\0') {\n      st_cycle_start();\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "protocol_execute_runtime", 
                "plan_check_full_buffer", 
                "plan_buffer_line", 
                "st_cycle_start"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001e98", 
            "calling": [
                "mc_arc", 
                "gc_execute_line", 
                "mc_go_home"
            ], 
            "imported": false, 
            "current_name": "mc_line"
        }, 
        "__kernel_sin": {
            "renaming": {}, 
            "code": "\nundefined4\n__kernel_sin(undefined4 param_1,uint param_2,undefined4 param_3,undefined4 param_4,int param_5)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  \n  if (((param_2 & 0x7fffffff) < 0x3e400000) && (iVar1 = __aeabi_d2iz(), iVar1 == 0)) {\n    return param_1;\n  }\n  uVar7 = __muldf3(param_1,param_2,param_1);\n  uVar4 = (undefined4)((ulonglong)uVar7 >> 0x20);\n  uVar3 = (undefined4)uVar7;\n  uVar7 = __muldf3(param_1,param_2,uVar3,uVar4);\n  uVar5 = (undefined4)((ulonglong)uVar7 >> 0x20);\n  uVar2 = (undefined4)uVar7;\n  uVar7 = __muldf3(uVar3,uVar4,DAT_0800af40,DAT_0800af44);\n  uVar7 = __subdf3((int)uVar7,(int)((ulonglong)uVar7 >> 0x20),DAT_0800af48,DAT_0800af4c);\n  uVar7 = __muldf3((int)uVar7,(int)((ulonglong)uVar7 >> 0x20),uVar3,uVar4);\n  uVar7 = __aeabi_dadd((int)uVar7,(int)((ulonglong)uVar7 >> 0x20),DAT_0800af50,DAT_0800af54);\n  uVar7 = __muldf3((int)uVar7,(int)((ulonglong)uVar7 >> 0x20),uVar3,uVar4);\n  uVar7 = __subdf3((int)uVar7,(int)((ulonglong)uVar7 >> 0x20),DAT_0800af58,DAT_0800af5c);\n  uVar7 = __muldf3((int)uVar7,(int)((ulonglong)uVar7 >> 0x20),uVar3,uVar4);\n  uVar7 = __aeabi_dadd((int)uVar7,(int)((ulonglong)uVar7 >> 0x20),DAT_0800af60,DAT_0800af64);\n  uVar6 = (undefined4)((ulonglong)uVar7 >> 0x20);\n  if (param_5 != 0) {\n    uVar8 = __muldf3(param_3,param_4,0,DAT_0800af70);\n    uVar7 = __muldf3(uVar2,uVar5,(int)uVar7,uVar6);\n    uVar7 = __subdf3((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),(int)uVar7,\n                     (int)((ulonglong)uVar7 >> 0x20));\n    uVar7 = __muldf3((int)uVar7,(int)((ulonglong)uVar7 >> 0x20),uVar3,uVar4);\n    uVar7 = __subdf3((int)uVar7,(int)((ulonglong)uVar7 >> 0x20),param_3,param_4);\n    uVar8 = __muldf3(uVar2,uVar5,DAT_0800af68,DAT_0800af6c);\n    uVar7 = __aeabi_dadd((int)uVar7,(int)((ulonglong)uVar7 >> 0x20),(int)uVar8,\n                         (int)((ulonglong)uVar8 >> 0x20));\n    uVar3 = __subdf3(param_1,param_2,(int)uVar7,(int)((ulonglong)uVar7 >> 0x20));\n    return uVar3;\n  }\n  uVar7 = __muldf3(uVar3,uVar4,(int)uVar7,uVar6);\n  uVar7 = __subdf3((int)uVar7,(int)((ulonglong)uVar7 >> 0x20),DAT_0800af68,DAT_0800af6c);\n  uVar7 = __muldf3((int)uVar7,(int)((ulonglong)uVar7 >> 0x20),uVar2,uVar5);\n  uVar3 = __aeabi_dadd((int)uVar7,(int)((ulonglong)uVar7 >> 0x20),param_1,param_2);\n  return uVar3;\n}\n\n", 
            "called": [
                "__aeabi_d2iz", 
                "__muldf3", 
                "__subdf3", 
                "__aeabi_dadd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800adf0", 
            "calling": [
                "sin", 
                "cos"
            ], 
            "imported": false, 
            "current_name": "__kernel_sin"
        }, 
        "__libc_init_array": {
            "renaming": {}, 
            "code": "\nvoid __libc_init_array(EVP_PKEY_CTX *param_1)\n\n{\n  int iVar1;\n  code **ppcVar2;\n  int iVar3;\n  \n  iVar3 = (int)PTR___preinit_array_end_0800b420 - (int)PTR___preinit_array_end_0800b424 >> 2;\n  if (iVar3 != 0) {\n    iVar1 = 0;\n    ppcVar2 = (code **)PTR___preinit_array_end_0800b424;\n    do {\n      iVar1 = iVar1 + 1;\n      param_1 = (EVP_PKEY_CTX *)(**ppcVar2)();\n      ppcVar2 = ppcVar2 + 1;\n    } while (iVar3 != iVar1);\n  }\n  ppcVar2 = (code **)PTR___preinit_array_end_0800b42c;\n  iVar3 = (int)PTR___do_global_dtors_aux_fini_array_entry_0800b428 -\n          (int)PTR___preinit_array_end_0800b42c;\n  _init(param_1);\n  iVar3 = iVar3 >> 2;\n  if (iVar3 != 0) {\n    iVar1 = 0;\n    do {\n      iVar1 = iVar1 + 1;\n      (**ppcVar2)();\n      ppcVar2 = ppcVar2 + 1;\n    } while (iVar3 != iVar1);\n  }\n  return;\n}\n\n", 
            "called": [
                "frame_dummy", 
                "_init", 
                "register_fini"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800b3e8", 
            "calling": [
                "Reset_Handler"
            ], 
            "imported": false, 
            "current_name": "__libc_init_array"
        }, 
        "usart_tstc": {
            "renaming": {}, 
            "code": "\nint usart_tstc(void)\n\n{\n  USART_TypeDef *usart;\n  \n  return (uint)((*DAT_08007e80 & 0x20) != 0);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007e58", 
            "calling": [
                "serial_read"
            ], 
            "imported": false, 
            "current_name": "usart_tstc"
        }, 
        "planner_reverse_pass": {
            "renaming": {}, 
            "code": "\nvoid planner_reverse_pass(void)\n\n{\n  block_t *next;\n  block_t *previous;\n  block_t *block [3];\n  uint8_t block_index;\n  \n  block_index = *PTR_block_buffer_head_08002af0;\n  block[0] = (block_t *)0x0;\n  block[1] = (block_t *)0x0;\n  while (next = block[1], block_index != *PTR_block_buffer_tail_08002af8) {\n    block_index = prev_block_index(block_index);\n    block[1] = block[0];\n    previous = (block_t *)(PTR_block_buffer_08002af4 + (uint)block_index * 0x40);\n    planner_reverse_pass_kernel(previous,block[0],next);\n    block[0] = previous;\n  }\n  return;\n}\n\n", 
            "called": [
                "prev_block_index", 
                "planner_reverse_pass_kernel"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002a94", 
            "calling": [
                "planner_recalculate"
            ], 
            "imported": false, 
            "current_name": "planner_reverse_pass"
        }, 
        "usart_putc": {
            "renaming": {}, 
            "code": "\nvoid usart_putc(char c)\n\n{\n  USART_TypeDef *usart;\n  \n  do {\n  } while ((*DAT_08007e48 & 0x80) == 0);\n  DAT_08007e48[1] = (uint)(byte)c;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007e1c", 
            "calling": [
                "serial_write", 
                "__io_putchar"
            ], 
            "imported": false, 
            "current_name": "usart_putc"
        }, 
        "finite": {
            "renaming": {}, 
            "code": "\nint finite(double __value)\n\n{\n  uint in_r1;\n  \n  return (in_r1 | 0x80000000) + 0x100000 >> 0x1f;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800b2d4", 
            "calling": [
                "hypot"
            ], 
            "imported": false, 
            "current_name": "finite"
        }, 
        "__ieee754_rem_pio2": {
            "renaming": {}, 
            "code": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nint __ieee754_rem_pio2(undefined4 param_1,uint param_2,undefined8 *param_3)\n\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 extraout_r1;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  uint uVar8;\n  int iVar9;\n  undefined8 uVar10;\n  undefined8 uVar11;\n  undefined8 uVar12;\n  undefined4 in_stack_ffffffa8;\n  undefined4 in_stack_ffffffac;\n  undefined4 local_50;\n  undefined4 uStack_4c;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  \n  uVar8 = param_2 & 0x7fffffff;\n  if ((int)uVar8 <= DAT_08009fb0) {\n    *(undefined4 *)param_3 = param_1;\n    *(uint *)((int)param_3 + 4) = param_2;\n    *(undefined4 *)(param_3 + 1) = 0;\n    *(undefined4 *)((int)param_3 + 0xc) = 0;\n    return 0;\n  }\n  if ((int)uVar8 <= DAT_08009fb4) {\n    if ((int)param_2 < 1) {\n      uVar10 = __aeabi_dadd(param_1,param_2,DAT_08009f88,DAT_08009f8c);\n      uVar2 = (undefined4)((ulonglong)uVar10 >> 0x20);\n      uVar1 = (undefined4)uVar10;\n      if (uVar8 != DAT_0800a1b8) {\n        uVar10 = __aeabi_dadd(uVar1,uVar2,DAT_0800a1b0,DAT_0800a1b4);\n        *param_3 = uVar10;\n        uVar10 = __subdf3(uVar1,uVar2);\n        uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_0800a1b0,DAT_0800a1b4\n                             );\n        param_3[1] = uVar10;\n        return -1;\n      }\n      uVar10 = __aeabi_dadd(uVar1,uVar2,DAT_0800a190,DAT_0800a194);\n      uVar1 = (undefined4)((ulonglong)uVar10 >> 0x20);\n      uVar11 = __aeabi_dadd((int)uVar10,uVar1,DAT_0800a198,DAT_0800a19c);\n      *param_3 = uVar11;\n      uVar10 = __subdf3((int)uVar10,uVar1);\n      uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_0800a198,DAT_0800a19c);\n      param_3[1] = uVar10;\n      return -1;\n    }\n    uVar10 = __subdf3();\n    uVar2 = (undefined4)((ulonglong)uVar10 >> 0x20);\n    uVar1 = (undefined4)uVar10;\n    if (uVar8 != DAT_08009fb8) {\n      uVar10 = __subdf3(uVar1,uVar2,DAT_08009f90,DAT_08009f94);\n      *param_3 = uVar10;\n      uVar10 = __subdf3(uVar1,uVar2);\n      uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08009f90,DAT_08009f94);\n      param_3[1] = uVar10;\n      return 1;\n    }\n    uVar10 = __subdf3(uVar1,uVar2,DAT_08009f98,DAT_08009f9c);\n    uVar1 = (undefined4)((ulonglong)uVar10 >> 0x20);\n    uVar11 = __subdf3((int)uVar10,uVar1,DAT_08009fa0,DAT_08009fa4);\n    *param_3 = uVar11;\n    uVar10 = __subdf3((int)uVar10,uVar1);\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_08009fa0,DAT_08009fa4);\n    param_3[1] = uVar10;\n    return 1;\n  }\n  if (DAT_08009fbc < (int)uVar8) {\n    if (DAT_08009fc0 < (int)uVar8) {\n      uVar10 = __subdf3(param_1,param_2,param_1,param_2);\n      param_3[1] = uVar10;\n      *param_3 = uVar10;\n      return 0;\n    }\n    iVar9 = ((int)uVar8 >> 0x14) + -0x416;\n    __aeabi_d2iz();\n    local_40 = __aeabi_i2d();\n    uVar10 = __subdf3(param_1,uVar8 + iVar9 * -0x100000,(int)local_40,\n                      (int)((ulonglong)local_40 >> 0x20));\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),0,DAT_08009fc4);\n    __aeabi_d2iz();\n    local_38 = __aeabi_i2d();\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20));\n    local_30 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),0,DAT_08009fc4);\n    __aeabi_dcmpeq((int)local_30,(int)((ulonglong)local_30 >> 0x20),0,0);\n    iVar9 = __kernel_rem_pio2(&local_40,param_3,iVar9);\n    if (-1 < (int)param_2) {\n      return iVar9;\n    }\n    *(int *)((int)param_3 + 4) = *(int *)((int)param_3 + 4) + -0x80000000;\n    *(int *)((int)param_3 + 0xc) = *(int *)((int)param_3 + 0xc) + -0x80000000;\n    return -iVar9;\n  }\n  fabs((double)CONCAT44(in_stack_ffffffac,in_stack_ffffffa8));\n  uVar10 = __muldf3();\n  __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),0,DAT_08009fcc);\n  iVar9 = __aeabi_d2iz();\n  uVar10 = __aeabi_i2d();\n  uVar4 = (undefined4)((ulonglong)uVar10 >> 0x20);\n  uVar1 = (undefined4)uVar10;\n  uVar10 = __muldf3(uVar1,uVar4,DAT_08009f88,DAT_08009f8c);\n  uVar10 = __subdf3(param_1,extraout_r1,(int)uVar10,(int)((ulonglong)uVar10 >> 0x20));\n  uVar5 = (undefined4)((ulonglong)uVar10 >> 0x20);\n  uVar2 = (undefined4)uVar10;\n  uVar11 = __muldf3(uVar1,uVar4,DAT_08009f90,DAT_08009f94);\n  if ((0x1f < iVar9) || (*(uint *)(PTR_npio2_hw_08009fd0 + (iVar9 + -1) * 4) == uVar8)) {\n    uVar12 = __subdf3(uVar2,uVar5,(int)uVar11,(int)((ulonglong)uVar11 >> 0x20));\n    if ((int)((uVar8 >> 0x14) - ((uint)((int)((ulonglong)uVar12 >> 0x20) << 1) >> 0x15)) < 0x11)\n    goto LAB_0800a0ce;\n    uVar11 = __muldf3(uVar1,uVar4,DAT_0800a190,DAT_0800a194);\n    uVar6 = (undefined4)((ulonglong)uVar11 >> 0x20);\n    uVar10 = __subdf3(uVar2,uVar5,(int)uVar11,uVar6);\n    uVar7 = (undefined4)((ulonglong)uVar10 >> 0x20);\n    uVar3 = (undefined4)uVar10;\n    uVar12 = __subdf3(uVar2,uVar5,uVar3,uVar7);\n    uVar11 = __subdf3((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),(int)uVar11,uVar6);\n    uVar12 = __muldf3(uVar1,uVar4,DAT_0800a198,DAT_0800a19c);\n    uVar11 = __subdf3((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),(int)uVar11,\n                      (int)((ulonglong)uVar11 >> 0x20));\n    uVar12 = __subdf3(uVar3,uVar7,(int)uVar11,(int)((ulonglong)uVar11 >> 0x20));\n    if ((int)(((int)uVar8 >> 0x14) - ((uint)((int)((ulonglong)uVar12 >> 0x20) << 1) >> 0x15)) < 0x32\n       ) goto LAB_0800a0ce;\n    uVar11 = __muldf3(uVar1,uVar4,DAT_0800a1a0,DAT_0800a1a4);\n    uVar2 = (undefined4)((ulonglong)uVar11 >> 0x20);\n    uVar10 = __subdf3(uVar3,uVar7,(int)uVar11,uVar2);\n    uVar12 = __subdf3(uVar3,uVar7);\n    uVar11 = __subdf3((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),(int)uVar11,uVar2);\n    uVar12 = __muldf3(uVar1,uVar4,DAT_0800a1a8,DAT_0800a1ac);\n    uVar11 = __subdf3((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),(int)uVar11,\n                      (int)((ulonglong)uVar11 >> 0x20));\n  }\n  uVar12 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),(int)uVar11,\n                    (int)((ulonglong)uVar11 >> 0x20));\nLAB_0800a0ce:\n  uStack_4c = (undefined4)((ulonglong)uVar10 >> 0x20);\n  local_50 = (undefined4)uVar10;\n  *param_3 = uVar12;\n  uVar10 = __subdf3(local_50,uStack_4c);\n  uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),(int)uVar11,\n                    (int)((ulonglong)uVar11 >> 0x20));\n  param_3[1] = uVar10;\n  if ((int)param_2 < 0) {\n    *(int *)param_3 = (int)uVar12;\n    *(int *)((int)param_3 + 4) = (int)((ulonglong)uVar12 >> 0x20) + -0x80000000;\n    *(int *)(param_3 + 1) = (int)uVar10;\n    *(int *)((int)param_3 + 0xc) = (int)((ulonglong)uVar10 >> 0x20) + -0x80000000;\n    iVar9 = -iVar9;\n  }\n  return iVar9;\n}\n\n", 
            "called": [
                "fabs", 
                "__aeabi_d2iz", 
                "__kernel_rem_pio2", 
                "__muldf3", 
                "__aeabi_dcmpeq", 
                "__subdf3", 
                "__aeabi_i2d", 
                "__aeabi_dadd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009d78", 
            "calling": [
                "sin", 
                "cos"
            ], 
            "imported": false, 
            "current_name": "__ieee754_rem_pio2"
        }, 
        "HAL_RCC_GetPCLK1Freq": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_RCC_GetPCLK1Freq(void)\n\n{\n  uint32_t uVar1;\n  uint uVar2;\n  uint32_t result;\n  uint32_t result_1;\n  \n  uVar1 = HAL_RCC_GetHCLKFreq();\n  uVar2 = count_leading_zeroes(0x380000);\n  return uVar1 >> PTR_APBAHBPrescTable_080066c8\n                  [(*(uint *)(DAT_080066c4 + 8) & 0x1c00) >> (uVar2 & 0xff)];\n}\n\n", 
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006680", 
            "calling": [
                "set_baud_rate"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_GetPCLK1Freq"
        }, 
        "NVIC_GetActive": {
            "renaming": {}, 
            "code": "\nuint32_t NVIC_GetActive(IRQn_Type IRQn)\n\n{\n  return (uint)((*(uint *)(DAT_08006afc + (((uint)(int)IRQn >> 5) + 0x80) * 4) & 1 << (IRQn & 0x1fU)\n                ) != 0);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006ac0", 
            "calling": [
                "HAL_NVIC_GetActive"
            ], 
            "imported": false, 
            "current_name": "NVIC_GetActive"
        }, 
        "NVIC_SystemReset": {
            "renaming": {}, 
            "code": "\nvoid NVIC_SystemReset(void)\n\n{\n  DataSynchronizationBarrier(0xf);\n  *(uint *)(DAT_08006c94 + 0xc) = DAT_08006c98 | *(uint *)(DAT_08006c94 + 0xc) & 0x700;\n  DataSynchronizationBarrier(0xf);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006c70", 
            "calling": [
                "HAL_NVIC_SystemReset"
            ], 
            "imported": false, 
            "current_name": "NVIC_SystemReset"
        }, 
        "settings_read_coord_data": {
            "renaming": {}, 
            "code": "\nuint8_t settings_read_coord_data(uint8_t coord_select,float *coord_data)\n\n{\n  int iVar1;\n  uint16_t addr;\n  \n  iVar1 = memcpy_from_eeprom_with_checksum\n                    ((char *)coord_data,(uint)(ushort)((ushort)coord_select * 0xd + 0x200),0xc);\n  if (iVar1 == 0) {\n    memset(coord_data,0,0xc);\n    settings_write_coord_data(coord_select,coord_data);\n  }\n  return iVar1 != 0;\n}\n\n", 
            "called": [
                "settings_write_coord_data", 
                "memcpy_from_eeprom_with_checksum", 
                "memset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004d7c", 
            "calling": [
                "settings_init", 
                "gc_init", 
                "gc_execute_line", 
                "report_gcode_parameters"
            ], 
            "imported": false, 
            "current_name": "settings_read_coord_data"
        }, 
        "NVIC_DecodePriority": {
            "renaming": {}, 
            "code": "\nvoid NVIC_DecodePriority(uint32_t Priority,uint32_t PriorityGroup,uint32_t *pPreemptPriority,\n                        uint32_t *pSubPriority)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint32_t SubPriorityBits;\n  uint32_t PreemptPriorityBits;\n  uint32_t PriorityGroupTmp;\n  \n  uVar1 = PriorityGroup & 7;\n  uVar2 = 7 - uVar1;\n  if (3 < uVar2) {\n    uVar2 = 4;\n  }\n  if (uVar1 + 4 < 7) {\n    uVar1 = 0;\n  }\n  else {\n    uVar1 = uVar1 - 3;\n  }\n  *pPreemptPriority = (1 << (uVar2 & 0xff)) - 1U & Priority >> (uVar1 & 0xff);\n  *pSubPriority = (1 << (uVar1 & 0xff)) - 1U & Priority;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006c04", 
            "calling": [
                "HAL_NVIC_GetPriority"
            ], 
            "imported": false, 
            "current_name": "NVIC_DecodePriority"
        }, 
        "HAL_GetTick": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_GetTick(void)\n\n{\n  return *(uint32_t *)PTR_uwTick_08005a94;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005a84", 
            "calling": [
                "HAL_Delay", 
                "HAL_RCC_OscConfig", 
                "HAL_RCC_ClockConfig", 
                "SysTick_Handler", 
                "get_current_usecs"
            ], 
            "imported": false, 
            "current_name": "HAL_GetTick"
        }, 
        "BusFault_Handler": {
            "renaming": {}, 
            "code": "\nvoid BusFault_Handler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007726", 
            "calling": [], 
            "imported": false, 
            "current_name": "BusFault_Handler"
        }, 
        "__aeabi_fmul": {
            "renaming": {}, 
            "code": "\nuint __aeabi_fmul(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  longlong lVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  uint uVar8;\n  bool bVar9;\n  bool bVar10;\n  \n  uVar3 = param_1 >> 0x17 & 0xff;\n  bVar9 = uVar3 == 0;\n  if (!bVar9) {\n    param_4 = param_2 >> 0x17 & 0xff;\n    bVar9 = param_4 == 0;\n  }\n  if (!bVar9) {\n    bVar9 = uVar3 == 0xff;\n  }\n  if (!bVar9) {\n    bVar9 = param_4 == 0xff;\n  }\n  if (bVar9) {\n    param_4 = param_2 >> 0x17 & 0xff;\n    if (uVar3 == 0xff || param_4 == 0xff) {\n      bVar9 = param_1 == 0 || param_1 == 0x80000000;\n      uVar2 = param_2;\n      if (param_1 != 0 && param_1 != 0x80000000) {\n        bVar9 = param_2 == 0;\n        uVar2 = param_1;\n      }\n      if (!bVar9) {\n        bVar9 = param_2 == 0x80000000;\n      }\n      uVar8 = uVar2;\n      if (((bVar9) || ((uVar3 == 0xff && ((uVar2 & 0x7fffff) != 0)))) ||\n         ((param_4 == 0xff && (uVar8 = param_2, (param_2 & 0x7fffff) != 0)))) {\n        return uVar8 | 0x7fc00000;\n      }\n      uVar2 = uVar2 ^ param_2;\n      goto LAB_0800903c;\n    }\n    bVar9 = (param_1 & 0x7fffffff) == 0;\n    if (!bVar9) {\n      bVar9 = (param_2 & 0x7fffffff) == 0;\n    }\n    if (bVar9) {\n      return (param_1 ^ param_2) & 0x80000000;\n    }\n    bVar9 = uVar3 == 0;\n    uVar2 = param_1 & 0x80000000;\n    while( true ) {\n      if (bVar9) {\n        param_1 = param_1 << 1;\n        bVar9 = (param_1 & 0x800000) == 0;\n      }\n      if (!bVar9) break;\n      uVar3 = uVar3 - 1;\n    }\n    param_1 = param_1 | uVar2;\n    bVar9 = param_4 == 0;\n    uVar2 = param_2 & 0x80000000;\n    while( true ) {\n      if (bVar9) {\n        param_2 = param_2 << 1;\n        bVar9 = (param_2 & 0x800000) == 0;\n      }\n      if (!bVar9) break;\n      param_4 = param_4 - 1;\n    }\n    param_2 = param_2 | uVar2;\n  }\n  iVar4 = uVar3 + param_4;\n  uVar8 = param_1 ^ param_2;\n  uVar3 = param_1 << 9;\n  bVar9 = uVar3 == 0;\n  if (!bVar9) {\n    param_2 = param_2 << 9;\n    bVar9 = param_2 == 0;\n  }\n  if (bVar9) {\n    if (uVar3 == 0) {\n      param_2 = param_2 << 9;\n    }\n    uVar2 = uVar8 & 0x80000000 | param_1 & 0x7fffff | param_2 >> 9;\n    bVar10 = SBORROW4(iVar4,0x7f);\n    iVar5 = iVar4 + -0x7f;\n    bVar9 = iVar5 == 0;\n    iVar7 = iVar5;\n    if (!bVar9 && 0x7e < iVar4) {\n      bVar10 = SBORROW4(0xff,iVar5);\n      iVar7 = 0xff - iVar5;\n      bVar9 = iVar5 == 0xff;\n    }\n    if (!bVar9 && iVar7 < 0 == bVar10) {\n      uVar2 = uVar2 | iVar5 * 0x800000;\n    }\n    if (!bVar9 && iVar7 < 0 == bVar10) {\n      return uVar2;\n    }\n    uVar2 = uVar2 | 0x800000;\n    uVar6 = 0;\n    bVar10 = SBORROW4(iVar5,1);\n    uVar8 = iVar4 - 0x80;\n    bVar9 = uVar8 == 0;\n    uVar3 = uVar8;\n  }\n  else {\n    lVar1 = (ulonglong)(uVar3 >> 5 | 0x8000000) * (ulonglong)(param_2 >> 5 | 0x8000000);\n    uVar6 = (uint)lVar1;\n    uVar2 = (uint)((ulonglong)lVar1 >> 0x20);\n    bVar9 = uVar2 < 0x800000;\n    if (bVar9) {\n      uVar2 = uVar2 << 1;\n    }\n    if (bVar9) {\n      uVar2 = uVar2 | uVar6 >> 0x1f;\n      uVar6 = uVar6 << 1;\n    }\n    uVar2 = uVar8 & 0x80000000 | uVar2;\n    uVar8 = (iVar4 + -0x7f) - (uint)bVar9;\n    bVar10 = SBORROW4(uVar8,0xfd);\n    bVar9 = uVar8 == 0xfd;\n    uVar3 = uVar8 - 0xfd;\n    if (uVar8 < 0xfe) {\n      uVar2 = uVar2 + uVar8 * 0x800000 + (uint)(0x7fffffff < uVar6);\n      if (uVar6 == 0x80000000) {\n        uVar2 = uVar2 & 0xfffffffe;\n      }\n      return uVar2;\n    }\n  }\n  if (bVar9 || (int)uVar3 < 0 != bVar10) {\n    bVar9 = (int)(uVar8 + 0x19) < 0;\n    if (uVar8 == 0xffffffe7 || bVar9 != SCARRY4(uVar8,0x19)) {\n      uVar2 = uVar2 & 0x80000000;\n    }\n    if (uVar8 != 0xffffffe7 && bVar9 == SCARRY4(uVar8,0x19)) {\n      uVar3 = (uVar2 << 1) >> (-uVar8 & 0xff);\n      uVar8 = uVar2 << (uVar8 + 0x20 & 0xff);\n      uVar3 = ((uint)((uVar2 & 0x80000000) != 0) << 0x1f | uVar3 >> 1) + (uint)((byte)uVar3 & 1);\n      if ((uVar6 | uVar8 << 1) == 0) {\n        uVar3 = uVar3 & ~(uVar8 >> 0x1f);\n      }\n      return uVar3;\n    }\n    return uVar2;\n  }\nLAB_0800903c:\n  return uVar2 & 0x80000000 | 0x7f800000;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008eec", 
            "calling": [
                "intersection_distance", 
                "printFloat", 
                "max_allowable_speed", 
                "plan_cycle_reinitialize", 
                "settings_store_global_setting", 
                "read_float", 
                "estimate_acceleration_distance", 
                "homing_cycle", 
                "mc_arc", 
                "plan_buffer_line", 
                "mc_dwell", 
                "calculate_trapezoid_for_block", 
                "gc_execute_line", 
                "mc_go_home"
            ], 
            "imported": false, 
            "current_name": "__aeabi_fmul"
        }, 
        "__register_exitproc": {
            "renaming": {}, 
            "code": "\nundefined4 __register_exitproc(int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined *puVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  uint uVar6;\n  \n  puVar1 = PTR___atexit_recursive_mutex_0800b5ac;\n  __retarget_lock_acquire_recursive(*(undefined4 *)PTR___atexit_recursive_mutex_0800b5ac);\n  iVar4 = *(int *)PTR__global_impure_ptr_0800b5a8;\n  iVar5 = *(int *)(iVar4 + 0x148);\n  if (iVar5 == 0) {\n    iVar5 = iVar4 + 0x14c;\n    *(int *)(iVar4 + 0x148) = iVar5;\n  }\n  uVar6 = *(uint *)(iVar5 + 4);\n  if ((int)uVar6 < 0x20) {\n    if (param_1 != 0) {\n      iVar4 = iVar5 + uVar6 * 4;\n      *(undefined4 *)(iVar4 + 0x88) = param_3;\n      uVar3 = 1 << (uVar6 & 0xff);\n      *(uint *)(iVar5 + 0x188) = *(uint *)(iVar5 + 0x188) | uVar3;\n      *(undefined4 *)(iVar4 + 0x108) = param_4;\n      if (param_1 == 2) {\n        *(uint *)(iVar5 + 0x18c) = uVar3 | *(uint *)(iVar5 + 0x18c);\n      }\n    }\n    uVar2 = *(undefined4 *)puVar1;\n    *(uint *)(iVar5 + 4) = uVar6 + 1;\n    *(undefined4 *)(iVar5 + (uVar6 + 2) * 4) = param_2;\n    __retarget_lock_release_recursive(uVar2);\n    uVar2 = 0;\n  }\n  else {\n    __retarget_lock_release_recursive(*(undefined4 *)puVar1);\n    uVar2 = 0xffffffff;\n  }\n  return uVar2;\n}\n\n", 
            "called": [
                "__retarget_lock_acquire_recursive", 
                "__retarget_lock_release_recursive"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800b524", 
            "calling": [
                "atexit"
            ], 
            "imported": false, 
            "current_name": "__register_exitproc"
        }, 
        "aflCall": {
            "renaming": {}, 
            "code": "\nuint32_t aflCall(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800597c", 
            "calling": [
                "startForkserver"
            ], 
            "imported": false, 
            "current_name": "aflCall"
        }, 
        "select_plane": {
            "renaming": {}, 
            "code": "\nvoid select_plane(uint8_t axis_0,uint8_t axis_1,uint8_t axis_2)\n\n{\n  PTR_gc_080004a8[0x19] = axis_0;\n  PTR_gc_080004a8[0x1a] = axis_1;\n  PTR_gc_080004a8[0x1b] = axis_2;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000478", 
            "calling": [
                "gc_init", 
                "gc_execute_line"
            ], 
            "imported": false, 
            "current_name": "select_plane"
        }, 
        "usart_flush": {
            "renaming": {}, 
            "code": "\nvoid usart_flush(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007e4c", 
            "calling": [], 
            "imported": false, 
            "current_name": "usart_flush"
        }, 
        "spindle_on": {
            "renaming": {}, 
            "code": "\nvoid spindle_on(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005208", 
            "calling": [
                "spindle_run"
            ], 
            "imported": false, 
            "current_name": "spindle_on"
        }, 
        "HAL_GPIO_EXTI_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)\n\n{\n  if (((uint)GPIO_Pin & *(uint *)(DAT_080073bc + 0x14)) != 0) {\n    *(uint *)(DAT_080073bc + 0x14) = (uint)GPIO_Pin;\n    HAL_GPIO_EXTI_Callback(GPIO_Pin);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800738e", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_GPIO_EXTI_IRQHandler"
        }, 
        "coolant_run": {
            "renaming": {}, 
            "code": "\nvoid coolant_run(uint8_t mode)\n\n{\n  if (mode != *PTR_current_coolant_mode_08000264) {\n    plan_synchronize();\n    if (mode == '\\x01') {\n      coolant_flood_on();\n    }\n    else if (mode == '\\x02') {\n      coolant_mist_on();\n    }\n    else {\n      coolant_stop();\n    }\n    *PTR_current_coolant_mode_08000264 = mode;\n  }\n  return;\n}\n\n", 
            "called": [
                "coolant_stop", 
                "coolant_flood_on", 
                "plan_synchronize", 
                "coolant_mist_on"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000220", 
            "calling": [
                "gc_execute_line"
            ], 
            "imported": false, 
            "current_name": "coolant_run"
        }, 
        "Reset_Handler": {
            "renaming": {}, 
            "code": "\nvoid Reset_Handler(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  code *UNRECOVERED_JUMPTABLE;\n  \n  for (iVar1 = 0; puVar2 = (undefined4 *)PTR_completed_8911_0800930c,\n      PTR_SystemCoreClock_08009304 + iVar1 < PTR_completed_8911_08009308; iVar1 = iVar1 + 4) {\n    *(undefined4 *)(PTR_SystemCoreClock_08009304 + iVar1) =\n         *(undefined4 *)(PTR___fini_array_end_08009300 + iVar1);\n  }\n  for (; puVar2 < PTR__ebss_08009310; puVar2 = puVar2 + 1) {\n    *puVar2 = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  UNRECOVERED_JUMPTABLE = (code *)0x80092fa;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x080092fa. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n", 
            "called": [
                "main", 
                "SystemInit", 
                "__libc_init_array"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080092c4", 
            "calling": [], 
            "imported": false, 
            "current_name": "Reset_Handler"
        }, 
        "report_gcode_parameters": {
            "renaming": {}, 
            "code": "\nvoid report_gcode_parameters(void)\n\n{\n  uint8_t uVar1;\n  float extraout_s0;\n  float extraout_s0_00;\n  float extraout_s0_01;\n  float extraout_s0_02;\n  float extraout_s0_03;\n  float extraout_s0_04;\n  float extraout_s0_05;\n  float extraout_s0_06;\n  float extraout_s0_07;\n  float extraout_s0_08;\n  float extraout_s0_09;\n  float extraout_s0_10;\n  float fVar2;\n  float extraout_s0_11;\n  float extraout_s0_12;\n  undefined8 uVar3;\n  float coord_data [3];\n  uint8_t i;\n  uint8_t coord_select;\n  \n  coord_select = '\\0';\n  while( true ) {\n    if (7 < coord_select) {\n      printPgmString(PTR_s__G92__080046c8);\n      fVar2 = extraout_s0_10;\n      for (i = '\\0'; i < 3; i = i + '\\x01') {\n        if ((PTR_settings_080046bc[0x28] & 1) == 0) {\n          printFloat(fVar2);\n        }\n        else {\n          uVar3 = __aeabi_f2d(*(undefined4 *)(PTR_gc_080046cc + (i + 10) * 4 + 4));\n          uVar3 = __muldf3((int)uVar3,(int)((ulonglong)uVar3 >> 0x20),DAT_08004690,DAT_08004694);\n          fVar2 = (float)__truncdfsf2((int)uVar3,(int)((ulonglong)uVar3 >> 0x20));\n          printFloat(fVar2);\n        }\n        if (i < 2) {\n          printPgmString(PTR_DAT_080046c0);\n          fVar2 = extraout_s0_11;\n        }\n        else {\n          printPgmString(PTR_DAT_080046c4);\n          fVar2 = extraout_s0_12;\n        }\n      }\n      return;\n    }\n    uVar1 = settings_read_coord_data(coord_select,coord_data);\n    if (uVar1 == '\\0') break;\n    printPgmString(PTR_DAT_08004698);\n    fVar2 = extraout_s0;\n    switch(coord_select) {\n    case '\\0':\n      printPgmString(PTR_DAT_0800469c);\n      fVar2 = extraout_s0_00;\n      break;\n    case '\\x01':\n      printPgmString(PTR_DAT_080046a0);\n      fVar2 = extraout_s0_01;\n      break;\n    case '\\x02':\n      printPgmString(PTR_DAT_080046a4);\n      fVar2 = extraout_s0_02;\n      break;\n    case '\\x03':\n      printPgmString(PTR_DAT_080046a8);\n      fVar2 = extraout_s0_03;\n      break;\n    case '\\x04':\n      printPgmString(PTR_DAT_080046ac);\n      fVar2 = extraout_s0_04;\n      break;\n    case '\\x05':\n      printPgmString(PTR_DAT_080046b0);\n      fVar2 = extraout_s0_05;\n      break;\n    case '\\x06':\n      printPgmString(PTR_DAT_080046b4);\n      fVar2 = extraout_s0_06;\n      break;\n    case '\\a':\n      printPgmString(PTR_DAT_080046b8);\n      fVar2 = extraout_s0_07;\n    }\n    for (i = '\\0'; i < 3; i = i + '\\x01') {\n      if ((PTR_settings_080046bc[0x28] & 1) == 0) {\n        printFloat(fVar2);\n      }\n      else {\n        uVar3 = __aeabi_f2d(coord_data[i]);\n        uVar3 = __muldf3((int)uVar3,(int)((ulonglong)uVar3 >> 0x20),DAT_08004690,DAT_08004694);\n        fVar2 = (float)__truncdfsf2((int)uVar3,(int)((ulonglong)uVar3 >> 0x20));\n        printFloat(fVar2);\n      }\n      if (i < 2) {\n        printPgmString(PTR_DAT_080046c0);\n        fVar2 = extraout_s0_08;\n      }\n      else {\n        printPgmString(PTR_DAT_080046c4);\n        fVar2 = extraout_s0_09;\n      }\n    }\n    coord_select = coord_select + '\\x01';\n  }\n  report_status_message('\\n');\n  return;\n}\n\n", 
            "called": [
                "__truncdfsf2", 
                "printPgmString", 
                "__muldf3", 
                "__aeabi_f2d", 
                "printFloat", 
                "report_status_message", 
                "settings_read_coord_data"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080044e8", 
            "calling": [
                "protocol_execute_line"
            ], 
            "imported": false, 
            "current_name": "report_gcode_parameters"
        }, 
        "plan_synchronize": {
            "renaming": {}, 
            "code": "\nvoid plan_synchronize(void)\n\n{\n  block_t *pbVar1;\n  \n  while ((pbVar1 = plan_get_current_block(), pbVar1 != (block_t *)0x0 ||\n         (PTR_sys_08003000[1] == '\\x03'))) {\n    protocol_execute_runtime();\n    if (*PTR_sys_08003000 != '\\0') {\n      return;\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "protocol_execute_runtime", 
                "plan_get_current_block"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002fd4", 
            "calling": [
                "coolant_run", 
                "spindle_run", 
                "mc_dwell", 
                "gc_execute_line", 
                "mc_go_home"
            ], 
            "imported": false, 
            "current_name": "plan_synchronize"
        }, 
        "HAL_SYSTICK_CLKSourceConfig": {
            "renaming": {}, 
            "code": "\nvoid HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)\n\n{\n  if (CLKSource == 4) {\n    *DAT_08006e6c = *DAT_08006e6c | 4;\n  }\n  else {\n    *DAT_08006e6c = *DAT_08006e6c & 0xfffffffb;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006e38", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_SYSTICK_CLKSourceConfig"
        }, 
        "gpio_init": {
            "renaming": {}, 
            "code": "\nvoid gpio_init(void)\n\n{\n  uint *puVar1;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  GPIO_INFO *gpio;\n  int i;\n  \n  for (i = 0; (uint)i < 0x11; i = i + 1) {\n    puVar1 = (uint *)(PTR_gpio_info_0800784c + i * 0x18);\n    *(uint *)(DAT_08007850 + 0x30) = *(uint *)(DAT_08007850 + 0x30) | 1 << (*puVar1 >> 4 & 0xff);\n    GPIO_InitStruct.Pin = 1 << (*puVar1 & 0xf);\n    GPIO_InitStruct.Mode = puVar1[1];\n    GPIO_InitStruct.Pull = puVar1[2];\n    GPIO_InitStruct.Speed = puVar1[3];\n    GPIO_InitStruct.Alternate = puVar1[4];\n    HAL_GPIO_Init((GPIO_TypeDef *)(((*puVar1 >> 4) + 0x100080) * 0x400),&GPIO_InitStruct);\n    if (-1 < (int)puVar1[5]) {\n      HAL_GPIO_WritePin((GPIO_TypeDef *)(((*puVar1 >> 4) + 0x100080) * 0x400),\n                        (uint16_t)(1 << (*puVar1 & 0xf)),(GPIO_PinState)puVar1[5]);\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_Init", 
                "HAL_GPIO_WritePin"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800778c", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "gpio_init"
        }, 
        "__aeabi_d2iz": {
            "renaming": {}, 
            "code": "\nuint __aeabi_d2iz(uint param_1,uint param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  uint uVar3;\n  \n  iVar2 = param_2 * 2 + 0x200000;\n  if (param_2 * 2 < 0xffe00000) {\n    if (-1 < iVar2) {\n      return 0;\n    }\n    uVar1 = iVar2 >> 0x15;\n    uVar3 = -uVar1 - 0x3e1;\n    if (uVar1 < 0xfffffc20 && uVar3 != 0) {\n      uVar1 = (param_2 << 0xb | 0x80000000 | param_1 >> 0x15) >> (uVar3 & 0xff);\n      if ((param_2 & 0x80000000) != 0) {\n        uVar1 = -uVar1;\n      }\n      return uVar1;\n    }\n  }\n  else if ((param_1 | param_2 << 0xc) != 0) {\n    return 0;\n  }\n  param_2 = param_2 & 0x80000000;\n  if (param_2 == 0) {\n    param_2 = 0x7fffffff;\n  }\n  return param_2;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008ba0", 
            "calling": [
                "__ieee754_rem_pio2", 
                "__kernel_cos", 
                "__kernel_sin", 
                "__kernel_rem_pio2", 
                "plan_buffer_line", 
                "lround", 
                "calculate_trapezoid_for_block", 
                "gc_execute_line"
            ], 
            "imported": false, 
            "current_name": "__aeabi_d2iz"
        }, 
        "sin": {
            "renaming": {}, 
            "code": "\ndouble sin(double __x)\n\n{\n  undefined4 in_r0;\n  uint uVar1;\n  uint in_r1;\n  double dVar2;\n  undefined4 local_28;\n  undefined4 uStack_24;\n  undefined4 local_20;\n  undefined4 uStack_1c;\n  \n  if (DAT_08009790 < (int)(in_r1 & 0x7fffffff)) {\n    if (DAT_08009794 < (int)(in_r1 & 0x7fffffff)) {\n      dVar2 = (double)__subdf3();\n    }\n    else {\n      uVar1 = __ieee754_rem_pio2(in_r0,in_r1,&local_28);\n      uVar1 = uVar1 & 3;\n      if (uVar1 == 1) {\n        dVar2 = (double)__kernel_cos(local_28,uStack_24,local_20,uStack_1c);\n      }\n      else if (uVar1 == 2) {\n        dVar2 = (double)__kernel_sin(local_28,uStack_24,local_20,uStack_1c,1);\n      }\n      else if (uVar1 == 0) {\n        dVar2 = (double)__kernel_sin(local_28,uStack_24,local_20,uStack_1c,1);\n      }\n      else {\n        dVar2 = (double)__kernel_cos(local_28,uStack_24,local_20,uStack_1c);\n      }\n    }\n    return dVar2;\n  }\n  dVar2 = (double)__kernel_sin(in_r0,in_r1,0,0,0);\n  return dVar2;\n}\n\n", 
            "called": [
                "__kernel_cos", 
                "__ieee754_rem_pio2", 
                "__kernel_sin", 
                "__subdf3"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080096e8", 
            "calling": [
                "mc_arc"
            ], 
            "imported": false, 
            "current_name": "sin"
        }, 
        "planner_recalculate": {
            "renaming": {}, 
            "code": "\nvoid planner_recalculate(void)\n\n{\n  planner_reverse_pass();\n  planner_forward_pass();\n  planner_recalculate_trapezoids();\n  return;\n}\n\n", 
            "called": [
                "planner_forward_pass", 
                "planner_recalculate_trapezoids", 
                "planner_reverse_pass"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002edc", 
            "calling": [
                "plan_buffer_line", 
                "plan_cycle_reinitialize"
            ], 
            "imported": false, 
            "current_name": "planner_recalculate"
        }, 
        "printInteger": {
            "renaming": {}, 
            "code": "\nvoid printInteger(long n)\n\n{\n  ulong local_c;\n  \n  local_c = n;\n  if (n < 0) {\n    serial_write('-');\n    local_c = -n;\n  }\n  print_uint32_base10(local_c);\n  return;\n}\n\n", 
            "called": [
                "serial_write", 
                "print_uint32_base10"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080037fc", 
            "calling": [
                "report_gcode_modes", 
                "report_startup_line", 
                "report_grbl_settings"
            ], 
            "imported": false, 
            "current_name": "printInteger"
        }, 
        "HardFault_Handler": {
            "renaming": {}, 
            "code": "\nvoid HardFault_Handler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800771a", 
            "calling": [], 
            "imported": false, 
            "current_name": "HardFault_Handler"
        }, 
        "printPgmString": {
            "renaming": {}, 
            "code": "\nvoid printPgmString(char *s)\n\n{\n  uint8_t *local_c;\n  \n  local_c = (uint8_t *)s;\n  while (*local_c != '\\0') {\n    serial_write(*local_c);\n    local_c = local_c + 1;\n  }\n  return;\n}\n\n", 
            "called": [
                "serial_write"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080036c6", 
            "calling": [
                "report_gcode_modes", 
                "report_startup_line", 
                "report_alarm_message", 
                "report_realtime_status", 
                "report_feedback_message", 
                "report_status_message", 
                "report_init_message", 
                "report_grbl_help", 
                "report_grbl_settings", 
                "report_gcode_parameters"
            ], 
            "imported": false, 
            "current_name": "printPgmString"
        }, 
        "HAL_DisableCompensationCell": {
            "renaming": {}, 
            "code": "\nvoid HAL_DisableCompensationCell(void)\n\n{\n  *DAT_08005bd8 = 0;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005bc4", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_DisableCompensationCell"
        }, 
        "__aeabi_dcmpeq": {
            "renaming": {}, 
            "code": "\nbool __aeabi_dcmpeq(void)\n\n{\n  char in_ZR;\n  \n  __aeabi_cdcmpeq();\n  return in_ZR != '\\0';\n}\n\n", 
            "called": [
                "__aeabi_cdcmpeq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008b10", 
            "calling": [
                "__ieee754_rem_pio2", 
                "__kernel_rem_pio2"
            ], 
            "imported": false, 
            "current_name": "__aeabi_dcmpeq"
        }, 
        "HAL_GetHalVersion": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_GetHalVersion(void)\n\n{\n  return 0x1000000;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005ac4", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_GetHalVersion"
        }, 
        "HAL_NVIC_GetPriority": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_GetPriority\n               (IRQn_Type IRQn,uint32_t PriorityGroup,uint32_t *pPreemptPriority,\n               uint32_t *pSubPriority)\n\n{\n  uint32_t Priority;\n  \n  Priority = NVIC_GetPriority(IRQn);\n  NVIC_DecodePriority(Priority,PriorityGroup,pPreemptPriority,pSubPriority);\n  return;\n}\n\n", 
            "called": [
                "NVIC_GetPriority", 
                "NVIC_DecodePriority"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006d98", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_NVIC_GetPriority"
        }, 
        "SystemInit": {
            "renaming": {}, 
            "code": "\nvoid SystemInit(void)\n\n{\n  *DAT_080075bc = *DAT_080075bc | 1;\n  DAT_080075bc[2] = 0;\n  *DAT_080075bc = *DAT_080075bc & 0xfef6ffff;\n  DAT_080075bc[1] = DAT_080075c0;\n  *DAT_080075bc = *DAT_080075bc & 0xfffbffff;\n  DAT_080075bc[3] = 0;\n  *(undefined4 *)(DAT_080075c4 + 8) = 0x8000000;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800756c", 
            "calling": [
                "Reset_Handler"
            ], 
            "imported": false, 
            "current_name": "SystemInit"
        }, 
        "st_init": {
            "renaming": {}, 
            "code": "\nvoid st_init(void)\n\n{\n  step_wr((uint)*(ushort *)(PTR_settings_08005858 + 0x18));\n  st_wake_up();\n  st_go_idle();\n  return;\n}\n\n", 
            "called": [
                "step_wr", 
                "st_wake_up", 
                "st_go_idle"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800583c", 
            "calling": [
                "grbl_main"
            ], 
            "imported": false, 
            "current_name": "st_init"
        }, 
        "grbl_main": {
            "renaming": {}, 
            "code": "\nint grbl_main(void)\n\n{\n  serial_init();\n  settings_init();\n  st_init();\n  memset(PTR_sys_08001e90,0,0x14);\n  *PTR_sys_08001e90 = 1;\n  PTR_sys_08001e90[1] = 1;\n  do {\n    if (*PTR_sys_08001e90 != '\\0') {\n      serial_reset_read_buffer();\n      plan_init();\n      gc_init();\n      protocol_init();\n      spindle_init();\n      coolant_init();\n      limits_init();\n      st_reset();\n      sys_sync_current_position();\n      *PTR_sys_08001e90 = 0;\n      PTR_sys_08001e90[2] = 0;\n      if ((PTR_settings_08001e94[0x28] & 2) != 0) {\n        PTR_sys_08001e90[0x10] = 1;\n      }\n      if ((PTR_sys_08001e90[1] == '\\x01') && ((PTR_settings_08001e94[0x28] & 0x10) != 0)) {\n        PTR_sys_08001e90[1] = 6;\n      }\n      if (PTR_sys_08001e90[1] == '\\x06') {\n        report_feedback_message('\\x02');\n      }\n      else {\n        PTR_sys_08001e90[1] = 0;\n        protocol_execute_startup();\n      }\n    }\n    protocol_execute_runtime();\n    protocol_process();\n  } while( true );\n}\n\n", 
            "called": [
                "protocol_execute_runtime", 
                "coolant_init", 
                "limits_init", 
                "protocol_process", 
                "protocol_execute_startup", 
                "sys_sync_current_position", 
                "serial_reset_read_buffer", 
                "st_reset", 
                "memset", 
                "spindle_init", 
                "protocol_init", 
                "settings_init", 
                "serial_init", 
                "report_feedback_message", 
                "gc_init", 
                "plan_init", 
                "st_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001ddc", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "grbl_main"
        }, 
        "__addsf3": {
            "renaming": {}, 
            "code": "\nuint __addsf3(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  bool bVar7;\n  \n  uVar3 = param_1 << 1;\n  bVar7 = uVar3 == 0;\n  if (!bVar7) {\n    param_4 = param_2 << 1;\n    bVar7 = param_4 == 0;\n  }\n  if (!bVar7) {\n    bVar7 = uVar3 == param_4;\n  }\n  iVar6 = (int)uVar3 >> 0x18;\n  if (!bVar7) {\n    bVar7 = iVar6 == -1;\n  }\n  if (!bVar7) {\n    bVar7 = (int)param_4 >> 0x18 == -1;\n  }\n  if (bVar7) {\n    iVar1 = (int)(param_2 << 1) >> 0x18;\n    if (iVar6 == -1 || iVar1 == -1) {\n      uVar3 = param_2;\n      if (iVar6 == -1) {\n        uVar3 = param_1;\n      }\n      if (iVar6 != -1 || iVar1 != -1) {\n        param_2 = uVar3;\n      }\n      bVar7 = (uVar3 & 0x7fffff) == 0;\n      if (bVar7) {\n        bVar7 = (param_2 & 0x7fffff) == 0;\n      }\n      if (bVar7) {\n        bVar7 = uVar3 == param_2;\n      }\n      if (!bVar7) {\n        uVar3 = uVar3 | 0x400000;\n      }\n      return uVar3;\n    }\n    if (((param_1 ^ param_2) & 0x7fffffff) != 0) {\n      if (uVar3 == 0) {\n        param_1 = param_2;\n      }\n      return param_1;\n    }\n    if (param_1 != param_2) {\n      return 0;\n    }\n    if ((uVar3 & 0xff000000) == 0) {\n      uVar3 = param_1 << 1;\n      if ((param_1 & 0x80000000) != 0) {\n        uVar3 = uVar3 | 0x80000000;\n      }\n      return uVar3;\n    }\n    if (uVar3 < 0xfe000000) {\n      return param_1 + 0x800000;\n    }\n    param_1 = param_1 & 0x80000000;\nLAB_08008e12:\n    return param_1 | 0x7f800000;\n  }\n  uVar3 = uVar3 >> 0x18;\n  param_4 = param_4 >> 0x18;\n  uVar5 = param_4 - uVar3;\n  bVar7 = uVar5 != 0;\n  uVar4 = uVar3;\n  if (bVar7 && uVar3 <= param_4) {\n    uVar4 = uVar3 + uVar5;\n  }\n  if (bVar7 && uVar3 <= param_4) {\n    param_2 = param_2 ^ param_1;\n  }\n  if (bVar7 && uVar3 <= param_4) {\n    param_1 = param_1 ^ param_2;\n  }\n  if (bVar7 && uVar3 <= param_4) {\n    param_2 = param_2 ^ param_1;\n  }\n  if (param_4 < uVar3) {\n    uVar5 = -uVar5;\n  }\n  if (0x19 < uVar5) {\n    return param_1;\n  }\n  uVar3 = param_1 & 0xffffff | 0x800000;\n  if ((param_1 & 0x80000000) != 0) {\n    uVar3 = -uVar3;\n  }\n  uVar2 = param_2 & 0xffffff | 0x800000;\n  if ((param_2 & 0x80000000) != 0) {\n    uVar2 = -uVar2;\n  }\n  if (uVar4 == uVar5) {\n    uVar2 = uVar2 ^ 0x800000;\n    if (uVar4 == 0) {\n      uVar3 = uVar3 ^ 0x800000;\n      uVar4 = 1;\n    }\n    else {\n      uVar5 = uVar5 - 1;\n    }\n  }\n  uVar3 = uVar3 + ((int)uVar2 >> (uVar5 & 0xff));\n  uVar2 = uVar2 << (0x20 - uVar5 & 0xff);\n  param_1 = uVar3 & 0x80000000;\n  if ((int)uVar3 < 0) {\n    bVar7 = uVar2 != 0;\n    uVar2 = -uVar2;\n    uVar3 = -uVar3 - (uint)bVar7;\n  }\n  if (uVar3 < 0x800000) {\n    uVar5 = uVar2 & 0x80000000;\n    uVar2 = uVar2 << 1;\n    uVar3 = uVar3 * 2 + (uint)(uVar5 != 0);\n    uVar5 = uVar4 - 2;\n    if (uVar4 - 1 == 0 || uVar3 < 0x800000) {\n      iVar6 = count_leading_zeroes(uVar3);\n      uVar4 = iVar6 - 8;\n      uVar3 = uVar3 << (uVar4 & 0xff);\n      if ((int)uVar5 < (int)uVar4) {\n        uVar3 = uVar3 >> (-(uVar5 - uVar4) & 0xff);\n      }\n      else {\n        uVar3 = uVar3 + (uVar5 - uVar4) * 0x800000;\n      }\n      return uVar3 | param_1;\n    }\n  }\n  else {\n    uVar5 = uVar4 - 1;\n    if (0xffffff < uVar3) {\n      uVar5 = uVar3 & 1;\n      uVar3 = uVar3 >> 1;\n      uVar2 = (uint)(uVar5 != 0) << 0x1f | uVar2 >> 1;\n      uVar5 = uVar4;\n      if (0xfd < uVar4) goto LAB_08008e12;\n    }\n  }\n  uVar3 = uVar3 + uVar5 * 0x800000 + (uint)(0x7fffffff < uVar2);\n  if (uVar2 == 0x80000000) {\n    uVar3 = uVar3 & 0xfffffffe;\n  }\n  return uVar3 | param_1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008cdc", 
            "calling": [
                "estimate_acceleration_distance", 
                "intersection_distance", 
                "report_realtime_status", 
                "mc_arc", 
                "plan_buffer_line", 
                "printFloat", 
                "__aeabi_frsub", 
                "max_allowable_speed", 
                "gc_execute_line"
            ], 
            "imported": false, 
            "current_name": "__addsf3"
        }, 
        "st_go_idle": {
            "renaming": {}, 
            "code": "\nvoid st_go_idle(void)\n\n{\n  step_isr_disable();\n  if ((PTR_settings_0800580c[0x3c] != -1) || ((PTR_sys_08005810[2] & 0x20) != 0)) {\n    stepper_motor_disable();\n  }\n  return;\n}\n\n", 
            "called": [
                "step_isr_disable", 
                "stepper_motor_disable"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080057e4", 
            "calling": [
                "st_init", 
                "step_period_isr", 
                "limits_go_home", 
                "mc_reset"
            ], 
            "imported": false, 
            "current_name": "st_go_idle"
        }, 
        "__aeabi_dcmpge": {
            "renaming": {}, 
            "code": "\nbool __aeabi_dcmpge(void)\n\n{\n  undefined in_ZR;\n  undefined in_CY;\n  \n  __aeabi_cdrcmple();\n  return !(bool)in_CY || (bool)in_ZR;\n}\n\n", 
            "called": [
                "__aeabi_cdrcmple"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008b4c", 
            "calling": [
                "__kernel_rem_pio2"
            ], 
            "imported": false, 
            "current_name": "__aeabi_dcmpge"
        }, 
        "HAL_DisableDBGStandbyMode": {
            "renaming": {}, 
            "code": "\nvoid HAL_DisableDBGStandbyMode(void)\n\n{\n  *(uint *)(DAT_08005ba8 + 4) = *(uint *)(DAT_08005ba8 + 4) & 0xfffffffb;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005b90", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_DisableDBGStandbyMode"
        }, 
        "HAL_DisableDBGSleepMode": {
            "renaming": {}, 
            "code": "\nvoid HAL_DisableDBGSleepMode(void)\n\n{\n  *(uint *)(DAT_08005b38 + 4) = *(uint *)(DAT_08005b38 + 4) & 0xfffffffe;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005b20", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_DisableDBGSleepMode"
        }, 
        "HAL_RCC_ClockConfig": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef *RCC_ClkInitStruct,uint32_t FLatency)\n\n{\n  uint32_t uVar1;\n  uint uVar2;\n  uint32_t timeout;\n  \n  if ((*DAT_08006400 & 0xf) < FLatency) {\n    *(char *)DAT_08006400 = (char)FLatency;\n    if (FLatency != (*DAT_08006400 & 0xf)) {\n      return HAL_ERROR;\n    }\n    if ((RCC_ClkInitStruct->ClockType & 1) != 0) {\n      if (RCC_ClkInitStruct->SYSCLKSource == 1) {\n        if ((*DAT_08006404 & 0x20000) == 0) {\n          return HAL_ERROR;\n        }\n      }\n      else if ((RCC_ClkInitStruct->SYSCLKSource != 2) && ((*DAT_08006404 & 2) == 0)) {\n        return HAL_ERROR;\n      }\n      DAT_08006404[2] = RCC_ClkInitStruct->SYSCLKSource | DAT_08006404[2] & 0xfffffffc;\n      uVar1 = HAL_GetTick();\n      uVar2 = uVar1 + 5000;\n      if (RCC_ClkInitStruct->SYSCLKSource == 1) {\n        while ((DAT_08006404[2] & 0xc) != 4) {\n          uVar1 = HAL_GetTick();\n          if (uVar2 <= uVar1) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else if (RCC_ClkInitStruct->SYSCLKSource == 2) {\n        while ((DAT_08006404[2] & 0xc) != 8) {\n          uVar1 = HAL_GetTick();\n          if (uVar2 <= uVar1) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        while ((DAT_08006404[2] & 0xc) != 0) {\n          uVar1 = HAL_GetTick();\n          if (uVar2 <= uVar1) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  else {\n    if ((RCC_ClkInitStruct->ClockType & 1) != 0) {\n      if (RCC_ClkInitStruct->SYSCLKSource == 1) {\n        if ((*DAT_08006404 & 0x20000) == 0) {\n          return HAL_ERROR;\n        }\n      }\n      else if (RCC_ClkInitStruct->SYSCLKSource == 2) {\n        if ((*DAT_08006404 & 0x2000000) == 0) {\n          return HAL_ERROR;\n        }\n      }\n      else if ((*DAT_08006404 & 2) == 0) {\n        return HAL_ERROR;\n      }\n      DAT_08006404[2] = RCC_ClkInitStruct->SYSCLKSource | DAT_08006404[2] & 0xfffffffc;\n      uVar1 = HAL_GetTick();\n      uVar2 = uVar1 + 5000;\n      if (RCC_ClkInitStruct->SYSCLKSource == 1) {\n        while ((DAT_08006404[2] & 0xc) != 4) {\n          uVar1 = HAL_GetTick();\n          if (uVar2 <= uVar1) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else if (RCC_ClkInitStruct->SYSCLKSource == 2) {\n        while ((DAT_08006404[2] & 0xc) != 8) {\n          uVar1 = HAL_GetTick();\n          if (uVar2 <= uVar1) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        while ((DAT_08006404[2] & 0xc) != 0) {\n          uVar1 = HAL_GetTick();\n          if (uVar2 <= uVar1) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    *(char *)DAT_08006400 = (char)FLatency;\n    if (FLatency != (*DAT_08006400 & 0xf)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((RCC_ClkInitStruct->ClockType & 2) != 0) {\n    DAT_08006404[2] = RCC_ClkInitStruct->AHBCLKDivider | DAT_08006404[2] & 0xffffff0f;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 4) != 0) {\n    DAT_08006404[2] = RCC_ClkInitStruct->APB1CLKDivider | DAT_08006404[2] & 0xffffe3ff;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 8) != 0) {\n    DAT_08006404[2] = RCC_ClkInitStruct->APB2CLKDivider << 3 | DAT_08006404[2] & 0xffff1fff;\n  }\n  uVar1 = HAL_RCC_GetHCLKFreq();\n  SysTick_Config((uint)((ulonglong)DAT_08006408 * (ulonglong)uVar1 >> 0x26));\n  return HAL_OK;\n}\n\n", 
            "called": [
                "SysTick_Config", 
                "HAL_RCC_GetHCLKFreq", 
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800618c", 
            "calling": [
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_ClockConfig"
        }, 
        "mc_dwell": {
            "renaming": {}, 
            "code": "\nvoid mc_dwell(float seconds)\n\n{\n  uint16_t ms;\n  undefined4 in_r0;\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 in_stack_ffffffe0;\n  uint16_t i;\n  \n  uVar1 = __aeabi_fmul(seconds,in_r0,DAT_080024b8);\n  uVar1 = __aeabi_f2d(uVar1);\n  floor((double)CONCAT44(in_r0,in_stack_ffffffe0));\n  i = __aeabi_d2uiz(uVar1,extraout_r1);\n  plan_synchronize();\n  uVar1 = __aeabi_fmul(in_r0,DAT_080024bc);\n  uVar2 = __floatsisf((uint)i * 0x32);\n  uVar1 = __aeabi_fsub(uVar1,uVar2);\n  uVar1 = __aeabi_f2d(uVar1);\n  floor((double)CONCAT44(in_r0,in_stack_ffffffe0));\n  ms = __aeabi_d2uiz(uVar1,extraout_r1_00);\n  delay_ms(ms);\n  while ((i != 0 && (protocol_execute_runtime(), *PTR_sys_080024c0 == '\\0'))) {\n    _delay_ms(0x32);\n    i = i - 1;\n  }\n  return;\n}\n\n", 
            "called": [
                "protocol_execute_runtime", 
                "__floatsisf", 
                "__aeabi_f2d", 
                "__aeabi_d2uiz", 
                "floor", 
                "__aeabi_fsub", 
                "__aeabi_fmul", 
                "plan_synchronize", 
                "_delay_ms", 
                "delay_ms"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002408", 
            "calling": [
                "gc_execute_line"
            ], 
            "imported": false, 
            "current_name": "mc_dwell"
        }, 
        "__kernel_rem_pio2": {
            "renaming": {}, 
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nuint __kernel_rem_pio2(int param_1,undefined8 *param_2,int param_3,int param_4,int param_5,\n                      int param_6)\n\n{\n  undefined4 *puVar1;\n  uint uVar2;\n  undefined4 uVar3;\n  uint uVar4;\n  undefined4 extraout_r1;\n  int iVar5;\n  uint *puVar6;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined4 uVar7;\n  uint **ppuVar8;\n  int iVar9;\n  int iVar10;\n  undefined4 *puVar11;\n  undefined4 uVar12;\n  uint uVar13;\n  uint *puVar14;\n  int iVar15;\n  int iVar16;\n  undefined8 *puVar17;\n  undefined8 *puVar18;\n  undefined8 *puVar19;\n  undefined4 *puVar20;\n  undefined8 *puVar21;\n  undefined4 uVar22;\n  int iVar23;\n  undefined4 *puVar24;\n  bool bVar25;\n  undefined8 uVar26;\n  undefined8 uVar27;\n  undefined8 uVar28;\n  undefined8 uVar29;\n  ulonglong uVar30;\n  undefined4 in_stack_fffffd78;\n  int local_280;\n  int local_26c;\n  uint *local_260 [2];\n  uint local_258 [20];\n  undefined8 uStack_208;\n  undefined4 local_168;\n  undefined4 uStack_164;\n  undefined8 local_160;\n  undefined8 uStack_c8;\n  \n  uVar29 = CONCAT44(param_5,param_5);\n  iVar16 = *(int *)(PTR_init_jk_0800a894 + param_5 * 4);\n  iVar9 = param_4 + -1;\n  local_260[1] = (uint *)param_2;\n  if (param_3 + 0x14 < 0 == SCARRY4(param_3,0x14)) {\n    local_26c = (int)((longlong)DAT_0800a898 * (longlong)(param_3 + -3) >> 0x22) -\n                (param_3 + -3 >> 0x1f);\n    iVar10 = (local_26c + 1) * -0x18;\n  }\n  else {\n    iVar10 = -0x18;\n    local_26c = 0;\n  }\n  param_3 = param_3 + iVar10;\n  iVar10 = local_26c - iVar9;\n  if (-1 < iVar16 + iVar9) {\n    iVar23 = iVar16 + iVar9 + 1 + iVar10;\n    puVar19 = &uStack_208;\n    do {\n      while (iVar10 < 0) {\n        iVar10 = iVar10 + 1;\n        *(undefined4 *)puVar19 = 0;\n        *(undefined4 *)((int)puVar19 + 4) = 0;\n        puVar19 = puVar19 + 1;\n        if (iVar10 == iVar23) goto LAB_0800a626;\n      }\n      uVar27 = __aeabi_i2d(*(undefined4 *)(param_6 + iVar10 * 4));\n      iVar10 = iVar10 + 1;\n      *puVar19 = uVar27;\n      puVar19 = puVar19 + 1;\n    } while (iVar10 != iVar23);\n  }\nLAB_0800a626:\n  puVar11 = (undefined4 *)(param_1 + -8);\n  if (-1 < iVar16) {\n    puVar17 = &uStack_208 + param_4;\n    iVar23 = iVar16 + param_4;\n    iVar10 = iVar9;\n    puVar19 = &uStack_c8;\n    do {\n      if (iVar9 < 0) {\n        uVar27 = 0;\n      }\n      else {\n        uVar27 = 0;\n        puVar24 = puVar11;\n        puVar21 = puVar17;\n        do {\n          puVar20 = puVar24 + 2;\n          uVar26 = __muldf3(*puVar20,puVar24[3],*(undefined4 *)(puVar21 + -1),\n                            *(undefined4 *)((int)puVar21 + -4));\n          uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,\n                                (int)((ulonglong)uVar26 >> 0x20));\n          puVar24 = puVar20;\n          puVar21 = puVar21 + -1;\n        } while (puVar20 != puVar11 + param_4 * 2);\n      }\n      iVar10 = iVar10 + 1;\n      *puVar19 = uVar27;\n      puVar17 = puVar17 + 1;\n      puVar19 = puVar19 + 1;\n    } while (iVar10 != iVar23);\n  }\n  local_260[0] = local_258 + iVar16 + -1;\n  local_280 = iVar16;\n  do {\n    iVar23 = *(int *)(&uStack_c8 + local_280);\n    uVar27 = CONCAT44(*(undefined4 *)((int)&uStack_c8 + local_280 * 8 + 4),iVar23);\n    iVar10 = local_280;\n    if (0 < local_280) {\n      puVar19 = &uStack_c8 + local_280;\n      puVar6 = local_258;\n      do {\n        uVar7 = (undefined4)((ulonglong)uVar27 >> 0x20);\n        __muldf3((int)uVar27,uVar7,0,DAT_0800a89c);\n        __aeabi_d2iz();\n        uVar26 = __aeabi_i2d();\n        uVar3 = (undefined4)((ulonglong)uVar26 >> 0x20);\n        uVar28 = __muldf3((int)uVar26,uVar3,0,DAT_0800a8a0);\n        __subdf3((int)uVar27,uVar7,(int)uVar28,(int)((ulonglong)uVar28 >> 0x20));\n        uVar2 = __aeabi_d2iz();\n        puVar17 = puVar19 + -1;\n        uVar7 = *(undefined4 *)puVar17;\n        uVar12 = *(undefined4 *)((int)puVar19 + -4);\n        *puVar6 = uVar2;\n        uVar27 = __aeabi_dadd((int)uVar26,uVar3,uVar7,uVar12);\n        iVar23 = (int)uVar27;\n        puVar19 = puVar17;\n        puVar6 = puVar6 + 1;\n      } while (puVar17 != &uStack_c8);\n    }\n    scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),iVar23);\n    __muldf3();\n    floor((double)CONCAT44(iVar10,in_stack_fffffd78));\n    uVar27 = __muldf3();\n    uVar27 = __subdf3(iVar23,extraout_r1,(int)uVar27,(int)((ulonglong)uVar27 >> 0x20));\n    uVar2 = __aeabi_d2iz();\n    uVar26 = __aeabi_i2d();\n    uVar27 = __subdf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,\n                      (int)((ulonglong)uVar26 >> 0x20));\n    uVar7 = (undefined4)((ulonglong)uVar27 >> 0x20);\n    uVar3 = (undefined4)uVar27;\n    if (param_3 < 1) {\n      if (param_3 == 0) {\n        iVar23 = (int)local_258[iVar10 + -1] >> 0x17;\n        goto joined_r0x0800a8b8;\n      }\n      iVar23 = __aeabi_dcmpge(uVar3,uVar7,0,DAT_0800ac3c);\n      if (iVar23 != 0) {\n        uVar2 = uVar2 + 1;\n        if (iVar10 < 1) {\n          uVar27 = __subdf3(0,DAT_0800ac38,uVar3,uVar7);\n          iVar23 = 2;\n          goto LAB_0800a7a4;\n        }\n        iVar23 = 2;\n        goto LAB_0800a8c8;\n      }\n    }\n    else {\n      iVar5 = (int)local_258[iVar10 + -1] >> (0x18U - param_3 & 0xff);\n      uVar13 = local_258[iVar10 + -1] - (iVar5 << (0x18U - param_3 & 0xff));\n      iVar23 = (int)uVar13 >> (0x17U - param_3 & 0xff);\n      local_258[iVar10 + -1] = uVar13;\n      uVar2 = uVar2 + iVar5;\njoined_r0x0800a8b8:\n      if (0 < iVar23) {\n        uVar2 = uVar2 + 1;\n        if (iVar10 < 1) {\n          uVar13 = 0;\n        }\n        else {\nLAB_0800a8c8:\n          uVar13 = local_258[0];\n          if (local_258[0] == 0) {\n            if (iVar10 != 1) {\n              puVar6 = local_258;\n              iVar5 = 1;\n              do {\n                puVar6 = puVar6 + 1;\n                uVar13 = *puVar6;\n                if (uVar13 != 0) {\n                  iVar15 = iVar5 + 1;\n                  goto LAB_0800a8e2;\n                }\n                iVar5 = iVar5 + 1;\n              } while (iVar5 != iVar10);\n            }\n          }\n          else {\n            iVar15 = 1;\n            iVar5 = 0;\nLAB_0800a8e2:\n            local_258[iVar5] = 0x1000000 - uVar13;\n            if (iVar15 < iVar10) {\n              uVar13 = local_258[iVar15];\n              puVar6 = local_258 + iVar15;\n              while( true ) {\n                puVar14 = puVar6 + 1;\n                *puVar6 = 0xffffff - uVar13;\n                if (puVar14 == local_258 + iVar10) break;\n                uVar13 = *puVar14;\n                puVar6 = puVar14;\n              }\n            }\n            uVar13 = 1;\n          }\n        }\n        if (0 < param_3) {\n          if (param_3 == 1) {\n            local_258[iVar10 + -1] = local_258[iVar10 + -1] & 0x7fffff;\n          }\n          else if (param_3 == 2) {\n            local_258[iVar10 + -1] = local_258[iVar10 + -1] & 0x3fffff;\n          }\n        }\n        if (iVar23 == 2) {\n          uVar27 = __subdf3(0,DAT_0800ac38,uVar3,uVar7);\n          if (uVar13 != 0) {\n            uVar3 = 0;\n            scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),0);\n            uVar27 = __subdf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),uVar3,extraout_r1_00);\n          }\n        }\n      }\n    }\nLAB_0800a7a4:\n    iVar15 = (int)uVar27;\n    iVar5 = __aeabi_dcmpeq(iVar15,(int)((ulonglong)uVar27 >> 0x20),0,0);\n    if (iVar5 == 0) {\n      scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),iVar15);\n      iVar9 = __aeabi_dcmpge();\n      if (iVar9 == 0) {\n        iVar5 = iVar10;\n        uVar13 = __aeabi_d2iz(iVar15,extraout_r1_02);\n        local_258[iVar5] = uVar13;\n        iVar10 = iVar5;\n      }\n      else {\n        __muldf3(iVar15,extraout_r1_02,0,DAT_0800ade8);\n        uVar13 = __aeabi_d2iz();\n        uVar27 = __aeabi_i2d();\n        uVar27 = __muldf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),0,DAT_0800ade4);\n        __subdf3(iVar15,extraout_r1_02,(int)uVar27,(int)((ulonglong)uVar27 >> 0x20));\n        iVar9 = iVar10;\n        uVar4 = __aeabi_d2iz();\n        iVar5 = iVar10 + 1;\n        local_258[iVar10] = uVar4;\n        local_258[iVar5] = uVar13;\n        iVar10 = iVar9;\n      }\n      goto LAB_0800a9f6;\n    }\n    iVar5 = iVar10 + -1;\n    if (iVar16 <= iVar5) {\n      uVar13 = 0;\n      puVar6 = local_258 + iVar10 + 0x3fffffff;\n      do {\n        puVar14 = puVar6 + -1;\n        uVar13 = uVar13 | *puVar6;\n        puVar6 = puVar14;\n      } while (puVar14 != local_260[0]);\n      if (uVar13 != 0) break;\n    }\n    if (local_258[iVar16 + -1] == 0) {\n      local_280 = 1;\n      ppuVar8 = local_260 + iVar16;\n      do {\n        puVar6 = *ppuVar8;\n        local_280 = local_280 + 1;\n        ppuVar8 = ppuVar8 + -1;\n      } while (puVar6 == (uint *)0x0);\n      local_280 = iVar10 + local_280;\n    }\n    else {\n      local_280 = iVar10 + 1;\n    }\n    iVar23 = iVar10 + 1;\n    puVar24 = (undefined4 *)(param_6 + (iVar23 + local_26c + 0x3fffffff) * 4);\n    puVar19 = &uStack_208 + iVar10 + param_4;\n    puVar17 = &uStack_c8 + iVar23;\n    do {\n      puVar24 = puVar24 + 1;\n      uVar27 = __aeabi_i2d(*puVar24);\n      *puVar19 = uVar27;\n      puVar21 = puVar19 + 1;\n      if (iVar9 < 0) {\n        uVar26 = 0;\n      }\n      else {\n        uVar26 = 0;\n        puVar20 = puVar11;\n        while( true ) {\n          puVar19 = puVar19 + -1;\n          puVar1 = puVar20 + 2;\n          uVar27 = __muldf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),*puVar1,puVar20[3]);\n          uVar26 = __aeabi_dadd((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),(int)uVar27,\n                                (int)((ulonglong)uVar27 >> 0x20));\n          if (puVar1 == puVar11 + param_4 * 2) break;\n          uVar27 = *puVar19;\n          puVar20 = puVar1;\n        }\n      }\n      *puVar17 = uVar26;\n      iVar23 = iVar23 + 1;\n      puVar19 = puVar21;\n      puVar17 = puVar17 + 1;\n    } while (iVar23 <= local_280);\n  } while( true );\n  if (local_258[iVar5] == 0) {\n    puVar6 = local_258 + iVar10 + 0x3ffffffe;\n    do {\n      uVar13 = *puVar6;\n      iVar5 = iVar5 + -1;\n      puVar6 = puVar6 + -1;\n    } while (uVar13 == 0);\n  }\nLAB_0800a9f6:\n  uVar3 = 0;\n  scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),0);\n  uVar27 = CONCAT44(extraout_r1_01,uVar3);\n  if (iVar5 < 0) {\n    if (2 < param_5) {\n      if (param_5 == 3) {\n        puVar19 = (undefined8 *)&local_168;\n        uVar29 = 0;\nLAB_0800abe4:\n        if (iVar23 == 0) {\n          uVar3 = *(undefined4 *)(puVar19 + 1);\n          uVar7 = *(undefined4 *)((int)puVar19 + 0xc);\n          *local_260[1] = local_168;\n          *(undefined4 *)((int)local_260[1] + 4) = uStack_164;\n          *(undefined8 *)((int)local_260[1] + 0x10) = uVar29;\n          *(undefined4 *)((int)local_260[1] + 8) = uVar3;\n          *(undefined4 *)((int)local_260[1] + 0xc) = uVar7;\n          return uVar2 & 7;\n        }\n        iVar9 = *(int *)((int)puVar19 + 4);\n        *(int *)((int)local_260[1] + 0x10) = (int)uVar29;\n        iVar16 = *(int *)((int)puVar19 + 0xc);\n        *(undefined4 *)((int)local_260[1] + 8) = *(undefined4 *)(puVar19 + 1);\n        *(int *)((int)local_260[1] + 0x14) = (int)((ulonglong)uVar29 >> 0x20) + -0x80000000;\n        uVar3 = *(undefined4 *)puVar19;\n        *(int *)((int)local_260[1] + 4) = iVar9 + -0x80000000;\n        *(int *)((int)local_260[1] + 0xc) = iVar16 + -0x80000000;\n        *local_260[1] = uVar3;\n        return uVar2 & 7;\n      }\n      goto LAB_0800ab0e;\n    }\n    if (param_5 < 1) {\n      if (param_5 != 0) goto LAB_0800ab0e;\nLAB_0800aafc:\n      iVar9 = (int)((ulonglong)uVar29 >> 0x20);\n      if (iVar23 != 0) {\n        iVar9 = iVar9 + -0x80000000;\n      }\n      *local_260[1] = (int)uVar29;\n      *(int *)((int)local_260[1] + 4) = iVar9;\nLAB_0800ab0e:\n      return uVar2 & 7;\n    }\n    uVar29 = 0;\n  }\n  else {\n    puVar17 = &uStack_c8 + iVar5;\n    puVar6 = local_258 + iVar5 + 1;\n    puVar19 = &uStack_c8 + iVar5 + 1;\n    do {\n      uVar3 = (undefined4)((ulonglong)uVar27 >> 0x20);\n      puVar6 = puVar6 + -1;\n      uVar26 = __aeabi_i2d(*puVar6);\n      uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),(int)uVar27,uVar3);\n      puVar19 = puVar19 + -1;\n      *puVar19 = uVar26;\n      uVar27 = __muldf3((int)uVar27,uVar3,0,DAT_0800ac40);\n    } while (puVar6 != local_258);\n    puVar19 = (undefined8 *)&local_168;\n    iVar9 = 0;\n    uVar3 = DAT_0800ac30;\n    uVar7 = DAT_0800ac34;\n    do {\n      DAT_0800ac30 = uVar3;\n      DAT_0800ac34 = uVar7;\n      if (iVar16 < 0) {\n        uVar27 = 0;\n      }\n      else {\n        uVar27 = 0;\n        iVar10 = 0;\n        puVar21 = puVar17;\n        puVar11 = (undefined4 *)PTR_DAT_0800ac44;\n        while( true ) {\n          uVar26 = __muldf3(*(undefined4 *)puVar21,*(undefined4 *)((int)puVar21 + 4),uVar3,uVar7);\n          uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,\n                                (int)((ulonglong)uVar26 >> 0x20));\n          iVar10 = iVar10 + 1;\n          if ((iVar16 < iVar10) || (iVar9 < iVar10)) break;\n          uVar3 = *puVar11;\n          uVar7 = puVar11[1];\n          puVar21 = puVar21 + 1;\n          puVar11 = puVar11 + 2;\n        }\n      }\n      bVar25 = iVar9 != iVar5;\n      puVar19[iVar9] = uVar27;\n      puVar17 = puVar17 + -1;\n      iVar9 = iVar9 + 1;\n      uVar3 = DAT_0800ac30;\n      uVar7 = DAT_0800ac34;\n    } while (bVar25);\n    if (2 < param_5) {\n      if (param_5 == 3) {\n        if (iVar5 != 0) {\n          puVar17 = puVar19 + iVar5;\n          uVar29 = *puVar17;\n          do {\n            uVar7 = (undefined4)((ulonglong)uVar29 >> 0x20);\n            uVar3 = (undefined4)uVar29;\n            uVar12 = *(undefined4 *)(puVar17 + -1);\n            uVar22 = *(undefined4 *)((int)puVar17 + -4);\n            uVar29 = __aeabi_dadd(uVar3,uVar7,uVar12,uVar22);\n            uVar27 = __subdf3(uVar12,uVar22,(int)uVar29,(int)((ulonglong)uVar29 >> 0x20));\n            uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),uVar3,uVar7);\n            *puVar17 = uVar27;\n            puVar17 = puVar17 + -1;\n            *puVar17 = uVar29;\n          } while (puVar19 != puVar17);\n          if (1 < iVar5) {\n            puVar21 = puVar19 + iVar5;\n            uVar29 = *puVar21;\n            puVar17 = puVar21;\n            do {\n              uVar7 = (undefined4)((ulonglong)uVar29 >> 0x20);\n              uVar3 = (undefined4)uVar29;\n              uVar12 = *(undefined4 *)(puVar17 + -1);\n              uVar22 = *(undefined4 *)((int)puVar17 + -4);\n              uVar29 = __aeabi_dadd(uVar3,uVar7,uVar12,uVar22);\n              uVar27 = __subdf3(uVar12,uVar22,(int)uVar29,(int)((ulonglong)uVar29 >> 0x20));\n              uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),uVar3,uVar7);\n              *puVar17 = uVar27;\n              puVar17 = puVar17 + -1;\n              *puVar17 = uVar29;\n            } while (&local_160 != puVar17);\n            uVar29 = 0;\n            puVar18 = puVar19 + 2;\n            puVar17 = puVar21 + 1;\n            do {\n              puVar21 = puVar17 + -1;\n              uVar29 = __aeabi_dadd((int)uVar29,(int)((ulonglong)uVar29 >> 0x20),\n                                    *(undefined4 *)puVar21,*(undefined4 *)((int)puVar17 + -4));\n              puVar17 = puVar21;\n            } while (puVar18 != puVar21);\n            goto LAB_0800abe4;\n          }\n        }\n        uVar29 = 0;\n        goto LAB_0800abe4;\n      }\n      goto LAB_0800ab0e;\n    }\n    if (param_5 < 1) {\n      if (param_5 != 0) goto LAB_0800ab0e;\n      puVar17 = puVar19 + iVar5 + 1;\n      do {\n        puVar21 = puVar17 + -1;\n        uVar29 = __aeabi_dadd((int)uVar29,(int)((ulonglong)uVar29 >> 0x20),*(undefined4 *)puVar21,\n                              *(undefined4 *)((int)puVar17 + -4));\n        puVar17 = puVar21;\n      } while (puVar19 != puVar21);\n      goto LAB_0800aafc;\n    }\n    uVar29 = 0;\n    puVar17 = puVar19 + iVar5 + 1;\n    do {\n      puVar21 = puVar17 + -1;\n      uVar29 = __aeabi_dadd((int)uVar29,(int)((ulonglong)uVar29 >> 0x20),*(undefined4 *)puVar21,\n                            *(undefined4 *)((int)puVar17 + -4));\n      puVar17 = puVar21;\n    } while (puVar19 != puVar21);\n  }\n  iVar9 = (int)((ulonglong)uVar29 >> 0x20);\n  uVar3 = (undefined4)uVar29;\n  if (iVar23 == 0) {\n    *(undefined8 *)local_260[1] = uVar29;\n    uVar30 = __subdf3(local_168,uStack_164,uVar3,iVar9);\n    if (iVar5 < 1) goto LAB_0800ad26;\nLAB_0800ad04:\n    iVar9 = 1;\n    puVar19 = (undefined8 *)&local_168;\n    do {\n      uVar30 = __aeabi_dadd((int)uVar30,(int)(uVar30 >> 0x20),*(undefined4 *)(puVar19 + 1),\n                            *(undefined4 *)((int)puVar19 + 0xc));\n      iVar9 = iVar9 + 1;\n      puVar19 = puVar19 + 1;\n    } while (iVar9 <= iVar5);\n    if (iVar23 == 0) goto LAB_0800ad26;\n  }\n  else {\n    *local_260[1] = uVar3;\n    *(int *)((int)local_260[1] + 4) = iVar9 + -0x80000000;\n    uVar30 = __subdf3(local_168,uStack_164,uVar3,iVar9);\n    if (0 < iVar5) goto LAB_0800ad04;\n  }\n  uVar30 = uVar30 & 0xffffffff | (ulonglong)((int)(uVar30 >> 0x20) + 0x80000000) << 0x20;\nLAB_0800ad26:\n  *(ulonglong *)((int)local_260[1] + 8) = uVar30;\n  return uVar2 & 7;\n}\n\n", 
            "called": [
                "scalbn", 
                "__aeabi_d2iz", 
                "__muldf3", 
                "__aeabi_dcmpeq", 
                "floor", 
                "__aeabi_dcmpge", 
                "__subdf3", 
                "__aeabi_i2d", 
                "__aeabi_dadd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800a5a0", 
            "calling": [
                "__ieee754_rem_pio2"
            ], 
            "imported": false, 
            "current_name": "__kernel_rem_pio2"
        }, 
        "print_base2": {
            "renaming": {}, 
            "code": "\nvoid print_base2(uint n,int bits)\n\n{\n  uint8_t data;\n  int i;\n  uint32_t mask;\n  \n  mask = 1 << (bits - 1U & 0xff);\n  for (i = 0; i < bits; i = i + 1) {\n    if ((mask & n) == 0) {\n      data = '0';\n    }\n    else {\n      data = '1';\n    }\n    serial_write(data);\n    mask = mask >> 1;\n  }\n  return;\n}\n\n", 
            "called": [
                "serial_write"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080036f0", 
            "calling": [
                "print_uint16_base2", 
                "print_uint8_base2"
            ], 
            "imported": false, 
            "current_name": "print_base2"
        }, 
        "__ieee754_hypot": {
            "renaming": {}, 
            "code": "\nuint __ieee754_hypot(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  uint uVar3;\n  int iVar4;\n  undefined4 uVar5;\n  int iVar6;\n  uint uVar7;\n  undefined4 uVar8;\n  undefined4 uVar9;\n  undefined8 uVar10;\n  undefined8 uVar11;\n  undefined8 uVar12;\n  undefined8 uVar13;\n  int local_3c;\n  \n  uVar1 = DAT_08009d70;\n  param_2 = param_2 & 0x7fffffff;\n  param_4 = param_4 & 0x7fffffff;\n  uVar3 = param_1;\n  uVar7 = param_2;\n  if (param_2 < param_4) {\n    uVar3 = param_3;\n    param_3 = param_1;\n    uVar7 = param_4;\n    param_4 = param_2;\n  }\n  if (0x3c00000 < (int)(uVar7 - param_4)) {\n    uVar3 = __aeabi_dadd(uVar3,uVar7,param_3,param_4);\n    return uVar3;\n  }\n  if (DAT_08009d68 < (int)uVar7) {\n    if (DAT_08009d74 < (int)uVar7) {\n      if ((uVar7 & 0xfffff | uVar3) != 0) {\n        uVar3 = __aeabi_dadd(uVar3,uVar7,param_3,param_4);\n      }\n      if ((param_4 ^ 0x7ff00000 | param_3) != 0) {\n        return uVar3;\n      }\n      return param_3;\n    }\n    uVar7 = uVar7 + 0xda800000;\n    param_4 = param_4 + 0xda800000;\n    local_3c = 600;\n  }\n  else {\n    local_3c = 0;\n  }\n  uVar11 = CONCAT44(uVar7,uVar3);\n  uVar10 = CONCAT44(param_4,param_3);\n  if ((int)param_4 <= DAT_08009d6c) {\n    if ((int)param_4 < 0x100000) {\n      if ((param_4 | param_3) == 0) {\n        return uVar3;\n      }\n      uVar10 = __muldf3(param_3,param_4,0,DAT_08009d70);\n      uVar11 = __muldf3(uVar3,uVar7,0,uVar1);\n      local_3c = local_3c + -0x3fe;\n    }\n    else {\n      uVar7 = uVar7 + 0x25800000;\n      uVar11 = CONCAT44(uVar7,uVar3);\n      param_4 = param_4 + 0x25800000;\n      uVar10 = CONCAT44(param_4,param_3);\n      local_3c = local_3c + -600;\n    }\n  }\n  uVar9 = (undefined4)((ulonglong)uVar11 >> 0x20);\n  uVar8 = (undefined4)uVar11;\n  iVar6 = (int)((ulonglong)uVar10 >> 0x20);\n  uVar5 = (undefined4)uVar10;\n  uVar10 = __subdf3(uVar8,uVar9,uVar5,iVar6);\n  iVar4 = (int)((ulonglong)uVar10 >> 0x20);\n  uVar1 = (undefined4)uVar10;\n  iVar2 = __aeabi_dcmplt(uVar5,iVar6,uVar1,iVar4);\n  if (iVar2 == 0) {\n    uVar10 = __muldf3(0,param_4,0);\n    uVar11 = __muldf3(uVar1,iVar4 + -0x80000000,uVar1,iVar4);\n    uVar12 = __aeabi_dadd(uVar8,uVar9,uVar8,uVar9);\n    uVar12 = __subdf3((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),0,uVar7 + 0x100000);\n    uVar12 = __muldf3((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),uVar5,iVar6);\n    uVar13 = __subdf3(uVar5,iVar6,0,param_4);\n    uVar13 = __muldf3((int)uVar13,(int)((ulonglong)uVar13 >> 0x20),0,uVar7 + 0x100000);\n    uVar12 = __aeabi_dadd((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),(int)uVar13,\n                          (int)((ulonglong)uVar13 >> 0x20));\n    uVar11 = __subdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),(int)uVar12,\n                      (int)((ulonglong)uVar12 >> 0x20));\n    __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),(int)uVar11,\n             (int)((ulonglong)uVar11 >> 0x20));\n    uVar10 = __ieee754_sqrt();\n  }\n  else {\n    uVar10 = __muldf3(0,uVar7,0,uVar7);\n    uVar11 = __muldf3(uVar5,iVar6 + -0x80000000,uVar5,iVar6);\n    uVar12 = __aeabi_dadd(uVar8,uVar9,0,uVar7);\n    uVar13 = __subdf3(uVar8,uVar9,0,uVar7);\n    uVar12 = __muldf3((int)uVar12,(int)((ulonglong)uVar12 >> 0x20),(int)uVar13,\n                      (int)((ulonglong)uVar13 >> 0x20));\n    uVar11 = __subdf3((int)uVar11,(int)((ulonglong)uVar11 >> 0x20),(int)uVar12,\n                      (int)((ulonglong)uVar12 >> 0x20));\n    __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),(int)uVar11,\n             (int)((ulonglong)uVar11 >> 0x20));\n    uVar10 = __ieee754_sqrt();\n  }\n  uVar3 = (uint)uVar10;\n  if (local_3c != 0) {\n    uVar3 = __muldf3(uVar3,(int)((ulonglong)uVar10 >> 0x20),0,local_3c * 0x100000 + 0x3ff00000);\n  }\n  return uVar3;\n}\n\n", 
            "called": [
                "__ieee754_sqrt", 
                "__aeabi_dcmplt", 
                "__muldf3", 
                "__subdf3", 
                "__aeabi_dadd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009b24", 
            "calling": [
                "hypot"
            ], 
            "imported": false, 
            "current_name": "__ieee754_hypot"
        }, 
        "report_startup_line": {
            "renaming": {}, 
            "code": "\nvoid report_startup_line(uint8_t n,char *line)\n\n{\n  printPgmString(PTR_DAT_08004934);\n  printInteger((uint)n);\n  printPgmString(PTR_DAT_08004938);\n  printString(line);\n  printPgmString(PTR_DAT_0800493c);\n  return;\n}\n\n", 
            "called": [
                "printString", 
                "printPgmString", 
                "printInteger"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004900", 
            "calling": [
                "protocol_execute_line"
            ], 
            "imported": false, 
            "current_name": "report_startup_line"
        }, 
        "buttons_isr": {
            "renaming": {}, 
            "code": "\nvoid buttons_isr(uint32_t buttons)\n\n{\n  if ((buttons & 0x80) == 0) {\n    if ((buttons & 0x40) == 0) {\n      if ((buttons & 0x20) != 0) {\n        PTR_sys_08003a70[2] = PTR_sys_08003a70[2] | 2;\n      }\n    }\n    else {\n      PTR_sys_08003a70[2] = PTR_sys_08003a70[2] | 8;\n    }\n  }\n  else {\n    mc_reset();\n  }\n  return;\n}\n\n", 
            "called": [
                "mc_reset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003a18", 
            "calling": [
                "debounce_on_handler"
            ], 
            "imported": false, 
            "current_name": "buttons_isr"
        }, 
        "register_fini": {
            "renaming": {}, 
            "code": "\nvoid register_fini(void)\n\n{\n  if (DAT_0800b4dc != 0) {\n    atexit(DAT_0800b4e0);\n    return;\n  }\n  return;\n}\n\n", 
            "called": [
                "atexit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800b4d0", 
            "calling": [
                "__libc_init_array"
            ], 
            "imported": false, 
            "current_name": "register_fini"
        }, 
        "st_reset": {
            "renaming": {}, 
            "code": "\nvoid st_reset(void)\n\n{\n  memset(PTR_st_08005834,0,0x24);\n  set_step_events_per_minute(800);\n  *(undefined4 *)PTR_current_block_08005838 = 0;\n  return;\n}\n\n", 
            "called": [
                "set_step_events_per_minute", 
                "memset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005814", 
            "calling": [
                "grbl_main"
            ], 
            "imported": false, 
            "current_name": "st_reset"
        }, 
        "intersection_distance": {
            "renaming": {}, 
            "code": "\nfloat intersection_distance(float initial_rate,float final_rate,float acceleration,float distance)\n\n{\n  undefined4 in_r0;\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 in_r1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  float fVar3;\n  \n  uVar1 = __addsf3(in_r2,in_r2);\n  uVar1 = __aeabi_fmul(uVar1,in_r3);\n  uVar2 = __aeabi_fmul(in_r0,in_r0);\n  uVar1 = __aeabi_fsub(uVar1,uVar2);\n  uVar2 = __aeabi_fmul(in_r1,in_r1);\n  uVar1 = __addsf3(uVar1,uVar2);\n  uVar2 = __aeabi_fmul(in_r2,0x40800000);\n  fVar3 = (float)__aeabi_fdiv(uVar1,uVar2);\n  return fVar3;\n}\n\n", 
            "called": [
                "__addsf3", 
                "__aeabi_fdiv", 
                "__aeabi_fsub", 
                "__aeabi_fmul"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002908", 
            "calling": [
                "calculate_trapezoid_for_block"
            ], 
            "imported": false, 
            "current_name": "intersection_distance"
        }, 
        "HAL_GPIO_EXTI_Callback": {
            "renaming": {}, 
            "code": "\nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080073c0", 
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_GPIO_EXTI_Callback"
        }, 
        "coolant_flood_off": {
            "renaming": {}, 
            "code": "\nvoid coolant_flood_off(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080001d4", 
            "calling": [
                "coolant_stop"
            ], 
            "imported": false, 
            "current_name": "coolant_flood_off"
        }, 
        "__divdf3": {
            "renaming": {}, 
            "code": "\nulonglong __divdf3(undefined4 param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  uint uVar9;\n  uint unaff_r5;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  bool bVar14;\n  bool bVar15;\n  bool bVar16;\n  ulonglong uVar17;\n  \n  uVar17 = CONCAT44(param_2,param_1);\n  uVar13 = 0x7ff;\n  uVar7 = param_2 >> 0x14 & 0x7ff;\n  bVar14 = uVar7 == 0;\n  if (!bVar14) {\n    unaff_r5 = param_4 >> 0x14 & 0x7ff;\n    bVar14 = unaff_r5 == 0;\n  }\n  if (!bVar14) {\n    bVar14 = uVar7 == 0x7ff;\n  }\n  if (!bVar14) {\n    bVar14 = unaff_r5 == 0x7ff;\n  }\n  if (bVar14) {\n    uVar17 = FUN_08008a02();\n  }\n  uVar9 = (uint)(uVar17 >> 0x20);\n  uVar11 = (uint)uVar17;\n  iVar8 = uVar7 - unaff_r5;\n  if ((param_3 | param_4 << 0xc) == 0) {\n    uVar7 = (uVar9 ^ param_4) & 0x80000000 | uVar9 & 0xfffff;\n    bVar16 = SCARRY4(iVar8,uVar13 >> 1);\n    uVar9 = iVar8 + (uVar13 >> 1);\n    bVar14 = (int)uVar9 < 0;\n    bVar15 = uVar9 == 0;\n    if (!bVar15 && bVar14 == bVar16) {\n      bVar16 = SBORROW4(uVar13,uVar9);\n      bVar14 = (int)(uVar13 - uVar9) < 0;\n      bVar15 = uVar13 == uVar9;\n    }\n    if (!bVar15 && bVar14 == bVar16) {\n      uVar7 = uVar7 | uVar9 * 0x100000;\n    }\n    if (!bVar15 && bVar14 == bVar16) {\n      return uVar17 & 0xffffffff | (ulonglong)uVar7 << 0x20;\n    }\n    uVar7 = uVar7 | 0x100000;\n    uVar13 = 0;\n    bVar15 = SBORROW4(uVar9,1);\n    uVar9 = uVar9 - 1;\n    bVar14 = uVar9 == 0;\n    uVar3 = uVar9;\n  }\n  else {\n    uVar3 = (param_4 << 0xc) >> 4 | 0x10000000 | param_3 >> 0x18;\n    uVar13 = param_3 << 8;\n    uVar10 = (uVar9 << 0xc) >> 4 | 0x10000000 | uVar11 >> 0x18;\n    uVar11 = uVar11 * 0x100;\n    uVar7 = (uVar9 ^ param_4) & 0x80000000;\n    bVar14 = uVar3 <= uVar10;\n    if (uVar10 == uVar3) {\n      bVar14 = uVar13 <= uVar11;\n    }\n    iVar8 = iVar8 + (uint)bVar14;\n    uVar9 = iVar8 + 0x3fd;\n    if (bVar14 == false) {\n      uVar3 = uVar3 >> 1;\n      uVar13 = (uint)((param_3 >> 0x18 & 1) != 0) << 0x1f | uVar13 >> 1;\n    }\n    uVar12 = uVar11 - uVar13;\n    uVar10 = (uVar10 - uVar3) - (uint)(uVar11 < uVar13);\n    uVar4 = uVar3 >> 1;\n    uVar1 = (uint)((uVar3 & 1) != 0) << 0x1f | uVar13 >> 1;\n    uVar11 = 0x100000;\n    uVar3 = 0x80000;\n    while( true ) {\n      bVar14 = uVar1 <= uVar12;\n      if (uVar4 < uVar10 || uVar10 - uVar4 < (uint)bVar14) {\n        uVar12 = uVar12 - uVar1;\n        uVar11 = uVar11 | uVar3;\n        uVar10 = (uVar10 - uVar4) - (uint)!bVar14;\n      }\n      uVar5 = uVar4 >> 1;\n      uVar1 = (uint)((uVar4 & 1) != 0) << 0x1f | uVar1 >> 1;\n      bVar15 = uVar1 <= uVar12;\n      bVar14 = uVar10 - uVar5 < (uint)bVar15;\n      uVar13 = uVar10;\n      if (uVar5 < uVar10 || bVar14) {\n        uVar12 = uVar12 - uVar1;\n        uVar13 = (uVar10 - uVar5) - (uint)!bVar15;\n      }\n      if (uVar5 < uVar10 || bVar14) {\n        uVar11 = uVar11 | uVar3 >> 1;\n      }\n      uVar10 = uVar4 >> 2;\n      uVar2 = (uint)((uVar5 & 1) != 0) << 0x1f | uVar1 >> 1;\n      bVar15 = uVar2 <= uVar12;\n      bVar14 = uVar13 - uVar10 < (uint)bVar15;\n      uVar5 = uVar13;\n      if (uVar10 < uVar13 || bVar14) {\n        uVar12 = uVar12 - uVar2;\n        uVar5 = (uVar13 - uVar10) - (uint)!bVar15;\n      }\n      if (uVar10 < uVar13 || bVar14) {\n        uVar11 = uVar11 | uVar3 >> 2;\n      }\n      uVar6 = uVar4 >> 3;\n      uVar1 = (uint)((uVar10 & 1) != 0) << 0x1f | uVar2 >> 1;\n      bVar15 = uVar1 <= uVar12;\n      bVar14 = uVar5 - uVar6 < (uint)bVar15;\n      uVar10 = uVar5;\n      if (uVar6 < uVar5 || bVar14) {\n        uVar12 = uVar12 - uVar1;\n        uVar10 = (uVar5 - uVar6) - (uint)!bVar15;\n      }\n      if (uVar6 < uVar5 || bVar14) {\n        uVar11 = uVar11 | uVar3 >> 3;\n      }\n      uVar13 = uVar10 | uVar12;\n      if (uVar13 == 0) break;\n      uVar10 = uVar10 << 4 | uVar12 >> 0x1c;\n      uVar12 = uVar12 << 4;\n      uVar4 = uVar4 & 0xfffffff8 | uVar1 >> 0x1d;\n      uVar1 = (uVar2 >> 1) << 3;\n      uVar3 = uVar3 >> 4;\n      if (uVar3 == 0) {\n        uVar6 = uVar4;\n        if ((uVar7 & 0x100000) != 0) goto LAB_080089b2;\n        uVar7 = uVar7 | uVar11;\n        uVar11 = 0;\n        uVar3 = 0x80000000;\n      }\n    }\n    if ((uVar7 & 0x100000) == 0) {\n      uVar7 = uVar7 | uVar11;\n      uVar11 = 0;\n    }\nLAB_080089b2:\n    bVar16 = 0xfc < uVar9;\n    bVar15 = SBORROW4(uVar9,0xfd);\n    uVar4 = iVar8 + 0x300;\n    bVar14 = uVar4 == 0;\n    uVar3 = uVar4;\n    if (bVar16 && !bVar14) {\n      bVar16 = 0x6ff < uVar4;\n      bVar15 = SBORROW4(uVar4,0x700);\n      uVar3 = iVar8 - 0x400;\n      bVar14 = uVar4 == 0x700;\n    }\n    if (!bVar16 || bVar14) {\n      bVar14 = uVar6 <= uVar10;\n      if (uVar10 == uVar6) {\n        bVar14 = uVar1 <= uVar12;\n      }\n      if (uVar10 == uVar6 && uVar12 == uVar1) {\n        bVar14 = (uVar11 & 1) != 0;\n      }\n      return CONCAT44(uVar7 + uVar9 * 0x100000 + (uint)CARRY4(uVar11,(uint)bVar14),uVar11 + bVar14);\n    }\n  }\n  if (!bVar14 && (int)uVar3 < 0 == bVar15) {\n    return (ulonglong)(uVar7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  bVar16 = SCARRY4(uVar9,0x36);\n  bVar14 = (int)(uVar9 + 0x36) < 0;\n  bVar15 = uVar9 == 0xffffffca;\n  if (bVar15 || bVar14 != bVar16) {\n    uVar11 = 0;\n  }\n  if (bVar15 || bVar14 != bVar16) {\n    uVar7 = uVar7 & 0x80000000;\n  }\n  if (bVar15 || bVar14 != bVar16) {\n    return CONCAT44(uVar7,uVar11);\n  }\n  uVar3 = -uVar9;\n  uVar10 = uVar3 - 0x20;\n  if (0x1f < (int)uVar3) {\n    uVar3 = uVar11 >> (uVar10 & 0xff) | uVar7 << (0x20 - uVar10 & 0xff);\n    uVar9 = (uVar7 >> (uVar10 & 0xff) & ~((uVar7 & 0x80000000) >> (uVar10 & 0xff))) -\n            ((int)uVar3 >> 0x1f);\n    if ((uVar13 | uVar11 << (0x20 - uVar10 & 0xff) | uVar3 << 1) == 0) {\n      uVar9 = uVar9 & ~(uVar3 >> 0x1f);\n    }\n    return CONCAT44(uVar7,uVar9) & 0x80000000ffffffff;\n  }\n  iVar8 = uVar3 - 0x14;\n  if (iVar8 != 0 && iVar8 < 0 == SCARRY4(uVar10,0xc)) {\n    uVar9 = 0xc - iVar8;\n    uVar3 = uVar11 << (uVar9 & 0xff);\n    uVar11 = uVar11 >> (0x20 - uVar9 & 0xff) | uVar7 << (uVar9 & 0xff);\n    uVar9 = uVar11 + -((int)uVar3 >> 0x1f);\n    if ((uVar13 | uVar3 << 1) == 0) {\n      uVar9 = uVar9 & ~(uVar3 >> 0x1f);\n    }\n    return CONCAT44((uVar7 & 0x80000000) + (uint)CARRY4(uVar11,-((int)uVar3 >> 0x1f)),uVar9);\n  }\n  uVar10 = uVar11 << (uVar9 + 0x20 & 0xff);\n  uVar11 = uVar11 >> (uVar3 & 0xff) | uVar7 << (uVar9 + 0x20 & 0xff);\n  uVar9 = uVar11 + -((int)uVar10 >> 0x1f);\n  if ((uVar13 | uVar10 << 1) == 0) {\n    uVar9 = uVar9 & ~(uVar10 >> 0x1f);\n  }\n  return CONCAT44((uVar7 & 0x80000000) +\n                  ((uVar7 & 0x7fffffff) >> (uVar3 & 0xff)) +\n                  (uint)CARRY4(uVar11,-((int)uVar10 >> 0x1f)),uVar9);\n}\n\n", 
            "called": [
                "FUN_08008a02"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008894", 
            "calling": [
                "homing_cycle", 
                "__ieee754_sqrt", 
                "atan", 
                "__ieee754_atan2", 
                "plan_buffer_line", 
                "sqrt", 
                "gc_execute_line"
            ], 
            "imported": false, 
            "current_name": "__divdf3"
        }, 
        "serial_rx_hook": {
            "renaming": {}, 
            "code": "\nint serial_rx_hook(uint8_t data)\n\n{\n  int rc;\n  \n  if (data == '~') {\n    PTR_sys_08005978[2] = PTR_sys_08005978[2] | 2;\n    return 1;\n  }\n  if (data < 0x7f) {\n    if (data == '?') {\n      PTR_sys_08005978[2] = PTR_sys_08005978[2] | 1;\n      return 1;\n    }\n    if (data < 0x40) {\n      if (data == '\\x18') {\n        mc_reset();\n        return 1;\n      }\n      if (data == '!') {\n        PTR_sys_08005978[2] = PTR_sys_08005978[2] | 8;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\n", 
            "called": [
                "mc_reset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005900", 
            "calling": [
                "serial_read"
            ], 
            "imported": false, 
            "current_name": "serial_rx_hook"
        }, 
        "gc_set_current_position": {
            "renaming": {}, 
            "code": "\nvoid gc_set_current_position(int32_t x,int32_t y,int32_t z)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 = __floatsisf(x);\n  uVar1 = __aeabi_fdiv(uVar1,*(undefined4 *)PTR_settings_08000564);\n  *(undefined4 *)(PTR_gc_08000568 + 0xc) = uVar1;\n  uVar1 = __floatsisf(y);\n  uVar1 = __aeabi_fdiv(uVar1,*(undefined4 *)(PTR_settings_08000564 + 4));\n  *(undefined4 *)(PTR_gc_08000568 + 0x10) = uVar1;\n  uVar1 = __floatsisf(z);\n  uVar1 = __aeabi_fdiv(uVar1,*(undefined4 *)(PTR_settings_08000564 + 8));\n  *(undefined4 *)(PTR_gc_08000568 + 0x14) = uVar1;\n  return;\n}\n\n", 
            "called": [
                "__floatsisf", 
                "__aeabi_fdiv"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080004fc", 
            "calling": [
                "sys_sync_current_position"
            ], 
            "imported": false, 
            "current_name": "gc_set_current_position"
        }, 
        "__floatunsidf": {
            "renaming": {}, 
            "code": "\nulonglong __floatunsidf(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  uint in_r12;\n  bool bVar5;\n  bool bVar6;\n  bool bVar7;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  uVar1 = 0;\n  iVar3 = count_leading_zeroes(param_1);\n  uVar4 = iVar3 + 0x15;\n  bVar7 = SBORROW4(uVar4,0x20);\n  uVar2 = iVar3 - 0xb;\n  bVar5 = (int)uVar2 < 0;\n  bVar6 = uVar2 == 0;\n  if ((int)uVar4 < 0x20) {\n    bVar7 = SCARRY4(uVar2,0xc);\n    iVar3 = iVar3 + 1;\n    bVar5 = iVar3 < 0;\n    bVar6 = iVar3 == 0;\n    uVar2 = uVar4;\n    if (!bVar6 && bVar5 == bVar7) {\n      uVar1 = param_1 << (uVar4 & 0xff);\n      param_1 = param_1 >> (0xcU - iVar3 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bVar6 || bVar5 != bVar7) {\n    in_r12 = 0x20 - uVar2;\n  }\n  param_1 = param_1 << (uVar2 & 0xff);\n  if (bVar6 || bVar5 != bVar7) {\n    param_1 = param_1 | 0U >> (in_r12 & 0xff);\n  }\n  if (bVar6 || bVar5 != bVar7) {\n    uVar1 = 0 << (uVar2 & 0xff);\n  }\nLAB_08008458:\n  if ((int)uVar4 < 0x433) {\n    return CONCAT44(param_1 + (0x432 - uVar4) * 0x100000,uVar1);\n  }\n  uVar2 = ~(0x432 - uVar4);\n  if (0x1e < (int)uVar2) {\n    return (ulonglong)(param_1 >> (uVar2 - 0x1f & 0xff));\n  }\n  iVar3 = uVar2 - 0x13;\n  if (iVar3 == 0 || iVar3 < 0 != SCARRY4(uVar2 - 0x1f,0xc)) {\n    uVar2 = uVar2 + 1;\n    return CONCAT44(param_1 >> (uVar2 & 0xff),\n                    uVar1 >> (uVar2 & 0xff) | param_1 << (0x20 - uVar2 & 0xff));\n  }\n  return (ulonglong)(uVar1 >> (0x20 - (0xcU - iVar3) & 0xff) | param_1 << (0xcU - iVar3 & 0xff));\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800854c", 
            "calling": [
                "homing_cycle"
            ], 
            "imported": false, 
            "current_name": "__floatunsidf"
        }, 
        "debounce_on_handler": {
            "renaming": {}, 
            "code": "\nvoid debounce_on_handler(uint32_t bits)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080078d0", 
            "calling": [], 
            "imported": false, 
            "current_name": "debounce_on_handler"
        }, 
        "HAL_NVIC_GetPriorityGrouping": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_NVIC_GetPriorityGrouping(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = NVIC_GetPriorityGrouping();\n  return uVar1;\n}\n\n", 
            "called": [
                "NVIC_GetPriorityGrouping"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006d8a", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_NVIC_GetPriorityGrouping"
        }, 
        "__retarget_lock_release_recursive": {
            "renaming": {}, 
            "code": "\nvoid __retarget_lock_release_recursive(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800b520", 
            "calling": [
                "__register_exitproc"
            ], 
            "imported": false, 
            "current_name": "__retarget_lock_release_recursive"
        }, 
        "homing_cycle": {
            "renaming": {}, 
            "code": "\nvoid homing_cycle(uint8_t cycle_mask,int8_t pos_dir,_Bool invert_pin,float homing_rate)\n\n{\n  ushort uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  int iVar4;\n  uint uVar5;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  uint32_t uVar6;\n  undefined4 in_r3;\n  uint32_t uVar7;\n  undefined8 uVar8;\n  undefined in_stack_ffffff9c;\n  char cVar9;\n  uint32_t steps [3];\n  uint16_t step_bits0;\n  uint32_t dt_min;\n  uint32_t delta_rate;\n  float ds;\n  uint32_t step_event_count;\n  uint32_t limit_state;\n  uint16_t step_bits;\n  uint32_t trap_counter;\n  uint32_t step_rate;\n  uint32_t step_delay;\n  int32_t counter_z;\n  int32_t counter_y;\n  int32_t counter_x;\n  uint16_t dirn_bits;\n  uint32_t dt;\n  uint8_t dist;\n  \n  cVar9 = !invert_pin;\n  memset(steps,0,0xc);\n  dist = (cycle_mask & 1) != 0;\n  if ((bool)dist) {\n    __aeabi_f2d(*(undefined4 *)PTR_settings_08001c90);\n    steps[0] = lround((double)CONCAT17(cycle_mask,\n                                       CONCAT16(pos_dir,CONCAT15(cVar9,CONCAT14(in_stack_ffffff9c,\n                                                                                in_r3)))));\n  }\n  if ((cycle_mask & 2) != 0) {\n    dist = dist + '\\x01';\n    __aeabi_f2d(*(undefined4 *)(PTR_settings_08001c90 + 4));\n    steps[1] = lround((double)CONCAT17(cycle_mask,\n                                       CONCAT16(pos_dir,CONCAT15(cVar9,CONCAT14(in_stack_ffffff9c,\n                                                                                in_r3)))));\n  }\n  if ((cycle_mask & 4) != 0) {\n    dist = dist + '\\x01';\n    __aeabi_f2d(*(undefined4 *)(PTR_settings_08001c90 + 8));\n    steps[2] = lround((double)CONCAT17(cycle_mask,\n                                       CONCAT16(pos_dir,CONCAT15(cVar9,CONCAT14(in_stack_ffffff9c,\n                                                                                in_r3)))));\n  }\n  uVar6 = steps[2];\n  if (steps[2] < steps[1]) {\n    uVar6 = steps[1];\n  }\n  uVar7 = steps[0];\n  if (steps[0] < uVar6) {\n    uVar7 = uVar6;\n  }\n  uVar8 = __floatunsidf(uVar7);\n  uVar2 = __floatunsidf(dist);\n  sqrt((double)CONCAT17(cycle_mask,\n                        CONCAT16(pos_dir,CONCAT15(cVar9,CONCAT14(in_stack_ffffff9c,in_r3)))));\n  uVar8 = __divdf3((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),uVar2,extraout_r1);\n  uVar2 = __truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n  uVar3 = __aeabi_fmul(*(undefined4 *)(PTR_settings_08001c90 + 0x20),uVar2);\n  uVar3 = __aeabi_fdiv(uVar3,DAT_08001c94);\n  uVar3 = __aeabi_f2d(uVar3);\n  ceil((double)CONCAT17(cycle_mask,\n                        CONCAT16(pos_dir,CONCAT15(cVar9,CONCAT14(in_stack_ffffff9c,in_r3)))));\n  iVar4 = __aeabi_d2uiz(uVar3,extraout_r1_00);\n  uVar3 = __floatunsidf(dist);\n  sqrt((double)CONCAT17(cycle_mask,\n                        CONCAT16(pos_dir,CONCAT15(cVar9,CONCAT14(in_stack_ffffff9c,in_r3)))));\n  uVar8 = __aeabi_f2d(in_r3);\n  uVar8 = __muldf3(uVar3,extraout_r1_01,(int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n  uVar3 = __truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n  uVar2 = __aeabi_fmul(uVar2,uVar3);\n  uVar2 = __aeabi_fdiv(DAT_08001c98,uVar2);\n  __aeabi_f2d(uVar2);\n  uVar5 = lround((double)CONCAT17(cycle_mask,\n                                  CONCAT16(pos_dir,CONCAT15(cVar9,CONCAT14(in_stack_ffffff9c,uVar3))\n                                          )));\n  dt = DAT_08001c9c;\n  if (uVar5 < DAT_08001c9c) {\n    dt = uVar5;\n  }\n  uVar1 = *(ushort *)(PTR_settings_08001c90 + 0x18);\n  dirn_bits = *(ushort *)(PTR_settings_08001c90 + 0x1a) ^\n              *(ushort *)(PTR_settings_08001c90 + 0x2a) & 0xaa0;\n  if (pos_dir == '\\0') {\n    dirn_bits = dirn_bits ^ 0xaa0;\n  }\n  dirn_wr((uint)dirn_bits);\n  step_wr((uint)uVar1);\n  counter_z = -(uVar7 >> 1);\n  step_delay = dt - (byte)PTR_settings_08001c90[0xd];\n  step_rate = 0;\n  trap_counter = 10000;\n  counter_y = counter_z;\n  counter_x = counter_z;\n  while( true ) {\n    limit_state = debounce_rd();\n    if (cVar9 != '\\0') {\n      limit_state = limit_state ^ 0x1e;\n    }\n    step_bits = uVar1;\n    if (((cycle_mask & 1) != 0) && (counter_x = counter_x + steps[0], 0 < counter_x)) {\n      if ((limit_state & 0x10) == 0) {\n        cycle_mask = cycle_mask & 0xfe;\n      }\n      else {\n        step_bits = uVar1 ^ 0x10;\n      }\n      counter_x = counter_x - uVar7;\n    }\n    if (((cycle_mask & 2) != 0) && (counter_y = counter_y + steps[1], 0 < counter_y)) {\n      if ((limit_state & 8) == 0) {\n        cycle_mask = cycle_mask & 0xfd;\n      }\n      else {\n        step_bits = step_bits ^ 0x440;\n      }\n      counter_y = counter_y - uVar7;\n    }\n    if (((cycle_mask & 4) != 0) && (counter_z = counter_z + steps[2], 0 < counter_z)) {\n      if ((limit_state & 4) == 0) {\n        cycle_mask = cycle_mask & 0xfb;\n      }\n      else {\n        step_bits = step_bits ^ 0x100;\n      }\n      counter_z = counter_z - uVar7;\n    }\n    if ((cycle_mask == 0) || ((PTR_sys_08001d40[2] & 0x10) != 0)) break;\n    step_wr((uint)step_bits);\n    delay_us((uint)(byte)PTR_settings_08001d44[0xd]);\n    step_wr((uint)uVar1);\n    delay_us(step_delay);\n    if ((uVar5 < dt) && (trap_counter = dt + trap_counter, 20000 < trap_counter)) {\n      trap_counter = trap_counter - 20000;\n      step_rate = iVar4 + step_rate;\n      dt = DAT_08001d48 / step_rate;\n      if (DAT_08001d48 / step_rate < uVar5) {\n        dt = uVar5;\n      }\n      step_delay = dt - (byte)PTR_settings_08001d44[0xd];\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "step_wr", 
                "__aeabi_fdiv", 
                "__muldf3", 
                "__aeabi_fmul", 
                "sqrt", 
                "ceil", 
                "delay_us", 
                "memset", 
                "__floatunsidf", 
                "dirn_wr", 
                "__divdf3", 
                "__truncdfsf2", 
                "__aeabi_f2d", 
                "__aeabi_d2uiz", 
                "lround", 
                "debounce_rd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001994", 
            "calling": [
                "limits_go_home"
            ], 
            "imported": false, 
            "current_name": "homing_cycle"
        }, 
        "get_current_usecs": {
            "renaming": {}, 
            "code": "\nuint64_t get_current_usecs(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = HAL_GetTick();\n  return (uint64_t)\n         ((uVar1 + 1) * 1000 -\n         (uint)((ulonglong)DAT_0800029c * (ulonglong)(*(uint *)(DAT_08000298 + 8) >> 3) >> 0x21));\n}\n\n", 
            "called": [
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000268", 
            "calling": [
                "_delay_us"
            ], 
            "imported": false, 
            "current_name": "get_current_usecs"
        }, 
        "__gedf2": {
            "renaming": {}, 
            "code": "\nuint __gedf2(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  bool bVar2;\n  bool bVar3;\n  \n  if (((int)(param_2 << 1) >> 0x15 == -1 || (int)(param_4 << 1) >> 0x15 == -1) &&\n     ((((int)(param_2 << 1) >> 0x15 == -1 && ((param_1 | param_2 << 0xc) != 0)) ||\n      (((int)(param_4 << 1) >> 0x15 == -1 && ((param_3 | param_4 << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  bVar2 = (param_1 | param_2 << 1) == 0;\n  if (bVar2) {\n    bVar2 = (param_3 | param_4 << 1) == 0;\n  }\n  if (!bVar2) {\n    bVar2 = param_2 == param_4;\n  }\n  if (bVar2) {\n    bVar2 = param_1 == param_3;\n  }\n  if (!bVar2) {\n    uVar1 = param_2 ^ param_4;\n    bVar2 = uVar1 == 0;\n    if (-1 < (int)uVar1) {\n      bVar2 = param_2 == param_4;\n    }\n    bVar3 = -1 < (int)uVar1 && param_4 <= param_2;\n    if (bVar2) {\n      bVar3 = param_3 <= param_1;\n    }\n    param_4 = (int)param_4 >> 0x1f;\n    if (!bVar3) {\n      param_4 = ~param_4;\n    }\n    return param_4 | 1;\n  }\n  return 0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008a64", 
            "calling": [], 
            "imported": false, 
            "current_name": "__gedf2"
        }, 
        "sqrt": {
            "renaming": {}, 
            "code": "\n/* WARNING: Could not reconcile some variable overlaps */\n\ndouble sqrt(double __x)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined4 *puVar3;\n  int *piVar4;\n  double dVar5;\n  double extraout_d0;\n  double extraout_d0_00;\n  double extraout_d0_01;\n  double extraout_d0_02;\n  double extraout_d0_03;\n  undefined local_50 [24];\n  undefined8 local_38;\n  int local_30;\n  \n  dVar5 = (double)__ieee754_sqrt();\n  cVar1 = *PTR___fdlib_version_08009988;\n  if (((cVar1 == -1) || (local_30 = __unorddf2(), dVar5 = extraout_d0, local_30 != 0)) ||\n     (iVar2 = __aeabi_dcmplt(), dVar5 = extraout_d0_00, iVar2 == 0)) {\n    return dVar5;\n  }\n  local_50._0_4_ = 1;\n  local_50._4_4_ = PTR_DAT_0800998c;\n  if (cVar1 == '\\0') {\n    local_38 = 0.0;\nLAB_0800996c:\n    iVar2 = matherr((exception *)local_50);\n    dVar5 = extraout_d0_02;\n    if (iVar2 != 0) goto joined_r0x0800997a;\n  }\n  else {\n    local_38 = (double)__divdf3(0,0,0,0);\n    if (cVar1 != '\\x02') goto LAB_0800996c;\n  }\n  puVar3 = (undefined4 *)__errno();\n  *puVar3 = 0x21;\n  dVar5 = extraout_d0_01;\njoined_r0x0800997a:\n  if (local_30 != 0) {\n    piVar4 = (int *)__errno();\n    *piVar4 = local_30;\n    dVar5 = extraout_d0_03;\n  }\n  return dVar5;\n}\n\n", 
            "called": [
                "__errno", 
                "__unorddf2", 
                "__ieee754_sqrt", 
                "__aeabi_dcmplt", 
                "__divdf3", 
                "matherr"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080098d0", 
            "calling": [
                "homing_cycle", 
                "plan_buffer_line", 
                "max_allowable_speed", 
                "gc_execute_line"
            ], 
            "imported": false, 
            "current_name": "sqrt"
        }, 
        "HAL_RCC_CCSCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_RCC_CCSCallback(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006944", 
            "calling": [
                "HAL_RCC_NMI_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_CCSCallback"
        }, 
        "coolant_mist_off": {
            "renaming": {}, 
            "code": "\nvoid coolant_mist_off(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080001ec", 
            "calling": [
                "coolant_stop"
            ], 
            "imported": false, 
            "current_name": "coolant_mist_off"
        }, 
        "step_period_isr": {
            "renaming": {}, 
            "code": "\nvoid step_period_isr(void)\n\n{\n  block_t *pbVar1;\n  int iVar2;\n  \n  dirn_wr((uint)*(ushort *)PTR_dirn_bits_080055f0);\n  *(undefined2 *)PTR_saved_step_bits_080055f8 = *(undefined2 *)PTR_step_bits_080055f4;\n  if (*(int *)PTR_current_block_080055fc == 0) {\n    pbVar1 = plan_get_current_block();\n    *(block_t **)PTR_current_block_080055fc = pbVar1;\n    if (*(int *)PTR_current_block_080055fc == 0) {\n      st_go_idle();\n      PTR_sys_08005600[2] = PTR_sys_08005600[2] | 4;\n    }\n    else {\n      if (PTR_sys_08005600[1] == '\\x03') {\n        *(undefined4 *)(PTR_st_08005604 + 0x1c) =\n             *(undefined4 *)(*(int *)PTR_current_block_080055fc + 0x28);\n        set_step_events_per_minute(*(uint32_t *)(PTR_st_08005604 + 0x1c));\n        *(undefined4 *)(PTR_st_08005604 + 0x18) = DAT_08005608;\n      }\n      *(int *)(PTR_st_08005604 + 0x20) =\n           (*(int *)(*(int *)PTR_current_block_080055fc + 0x30) >> 1) +\n           *(int *)(*(int *)PTR_current_block_080055fc + 0x30);\n      *(int *)PTR_st_08005604 = -(*(int *)(*(int *)PTR_current_block_080055fc + 0x10) >> 1);\n      *(undefined4 *)(PTR_st_08005604 + 4) = *(undefined4 *)PTR_st_08005604;\n      *(undefined4 *)(PTR_st_08005604 + 8) = *(undefined4 *)PTR_st_08005604;\n      *(undefined4 *)(PTR_st_08005604 + 0xc) =\n           *(undefined4 *)(*(int *)PTR_current_block_080055fc + 0x10);\n      *(undefined4 *)(PTR_st_08005604 + 0x10) = 0;\n    }\n  }\n  if (*(int *)PTR_current_block_080055fc != 0) {\n    *(undefined2 *)PTR_dirn_bits_080055f0 = **(undefined2 **)PTR_current_block_080055fc;\n    *(undefined2 *)PTR_step_bits_080055f4 = 0;\n    *(int *)PTR_st_08005604 =\n         *(int *)(*(int *)PTR_current_block_080055fc + 4) + *(int *)PTR_st_08005604;\n    if (0 < *(int *)PTR_st_08005604) {\n      *(ushort *)PTR_step_bits_080055f4 = *(ushort *)PTR_step_bits_080055f4 | 0x10;\n      *(int *)PTR_st_08005604 = *(int *)PTR_st_08005604 - *(int *)(PTR_st_08005604 + 0xc);\n      if ((*(ushort *)PTR_dirn_bits_080055f0 & 0x20) == 0) {\n        *(int *)(PTR_sys_08005600 + 4) = *(int *)(PTR_sys_08005600 + 4) + 1;\n      }\n      else {\n        *(int *)(PTR_sys_08005600 + 4) = *(int *)(PTR_sys_08005600 + 4) + -1;\n      }\n    }\n    *(int *)(PTR_st_08005604 + 4) =\n         *(int *)(*(int *)PTR_current_block_080055fc + 8) + *(int *)(PTR_st_08005604 + 4);\n    if (0 < *(int *)(PTR_st_08005604 + 4)) {\n      *(ushort *)PTR_step_bits_080055f4 = *(ushort *)PTR_step_bits_080055f4 | 0x440;\n      *(int *)(PTR_st_08005604 + 4) =\n           *(int *)(PTR_st_08005604 + 4) - *(int *)(PTR_st_08005604 + 0xc);\n      if ((*(ushort *)PTR_dirn_bits_080055f0 & 0x80) == 0) {\n        *(int *)(PTR_sys_08005600 + 8) = *(int *)(PTR_sys_08005600 + 8) + 1;\n      }\n      else {\n        *(int *)(PTR_sys_08005600 + 8) = *(int *)(PTR_sys_08005600 + 8) + -1;\n      }\n    }\n    *(int *)(PTR_st_08005604 + 8) =\n         *(int *)(*(int *)PTR_current_block_080055fc + 0xc) + *(int *)(PTR_st_08005604 + 8);\n    if (0 < *(int *)(PTR_st_08005604 + 8)) {\n      *(ushort *)PTR_step_bits_080055f4 = *(ushort *)PTR_step_bits_080055f4 | 0x100;\n      *(int *)(PTR_st_08005604 + 8) =\n           *(int *)(PTR_st_08005604 + 8) - *(int *)(PTR_st_08005604 + 0xc);\n      if ((*(ushort *)PTR_dirn_bits_080055f0 & 0x200) == 0) {\n        *(int *)(PTR_sys_08005600 + 0xc) = *(int *)(PTR_sys_08005600 + 0xc) + 1;\n      }\n      else {\n        *(int *)(PTR_sys_08005600 + 0xc) = *(int *)(PTR_sys_08005600 + 0xc) + -1;\n      }\n    }\n    *(int *)(PTR_st_08005604 + 0x10) = *(int *)(PTR_st_08005604 + 0x10) + 1;\n    if (*(uint *)(PTR_st_08005604 + 0x10) < *(uint *)(*(int *)PTR_current_block_080055fc + 0x10)) {\n      if (PTR_sys_08005600[1] == '\\x04') {\n        iVar2 = iterate_trapezoid_cycle_counter();\n        if (iVar2 != 0) {\n          if (*(uint *)(*(int *)PTR_current_block_080055fc + 0x30) <\n              *(uint *)(PTR_st_08005604 + 0x1c)) {\n            *(int *)(PTR_st_08005604 + 0x1c) =\n                 *(int *)(PTR_st_08005604 + 0x1c) -\n                 *(int *)(*(int *)PTR_current_block_080055fc + 0x30);\n            set_step_events_per_minute(*(uint32_t *)(PTR_st_08005604 + 0x1c));\n          }\n          else {\n            st_go_idle();\n            PTR_sys_08005600[2] = PTR_sys_08005600[2] | 4;\n          }\n        }\n      }\n      else if (*(uint *)(PTR_st_08005748 + 0x10) <\n               *(uint *)(*(int *)PTR_current_block_0800574c + 0x34)) {\n        iVar2 = iterate_trapezoid_cycle_counter();\n        if (iVar2 != 0) {\n          *(int *)(PTR_st_08005748 + 0x1c) =\n               *(int *)(PTR_st_08005748 + 0x1c) +\n               *(int *)(*(int *)PTR_current_block_0800574c + 0x30);\n          if (*(uint *)(*(int *)PTR_current_block_0800574c + 0x3c) <=\n              *(uint *)(PTR_st_08005748 + 0x1c)) {\n            *(undefined4 *)(PTR_st_08005748 + 0x1c) =\n                 *(undefined4 *)(*(int *)PTR_current_block_0800574c + 0x3c);\n          }\n          set_step_events_per_minute(*(uint32_t *)(PTR_st_08005748 + 0x1c));\n        }\n      }\n      else if (*(uint *)(PTR_st_08005748 + 0x10) <\n               *(uint *)(*(int *)PTR_current_block_0800574c + 0x38)) {\n        if (*(int *)(PTR_st_08005748 + 0x1c) != *(int *)(*(int *)PTR_current_block_0800574c + 0x3c))\n        {\n          *(undefined4 *)(PTR_st_08005748 + 0x1c) =\n               *(undefined4 *)(*(int *)PTR_current_block_0800574c + 0x3c);\n          set_step_events_per_minute(*(uint32_t *)(PTR_st_08005748 + 0x1c));\n        }\n      }\n      else if (*(int *)(PTR_st_08005748 + 0x10) ==\n               *(int *)(*(int *)PTR_current_block_0800574c + 0x38)) {\n        if (*(int *)(PTR_st_08005748 + 0x1c) == *(int *)(*(int *)PTR_current_block_0800574c + 0x3c))\n        {\n          *(undefined4 *)(PTR_st_08005748 + 0x18) = DAT_08005750;\n        }\n        else {\n          *(int *)(PTR_st_08005748 + 0x18) = 420000 - *(int *)(PTR_st_08005748 + 0x18);\n        }\n      }\n      else {\n        iVar2 = iterate_trapezoid_cycle_counter();\n        if (iVar2 != 0) {\n          if (*(uint *)(PTR_st_08005748 + 0x20) < *(uint *)(PTR_st_08005748 + 0x1c)) {\n            *(int *)(PTR_st_08005748 + 0x1c) =\n                 *(int *)(PTR_st_08005748 + 0x1c) -\n                 *(int *)(*(int *)PTR_current_block_0800574c + 0x30);\n          }\n          else {\n            *(uint *)(PTR_st_08005748 + 0x1c) = *(uint *)(PTR_st_08005748 + 0x1c) >> 1;\n          }\n          if (*(uint *)(PTR_st_08005748 + 0x1c) <\n              *(uint *)(*(int *)PTR_current_block_0800574c + 0x2c)) {\n            *(undefined4 *)(PTR_st_08005748 + 0x1c) =\n                 *(undefined4 *)(*(int *)PTR_current_block_0800574c + 0x2c);\n          }\n          set_step_events_per_minute(*(uint32_t *)(PTR_st_08005748 + 0x1c));\n        }\n      }\n    }\n    else {\n      *(undefined2 *)PTR_step_bits_08005754 = 0;\n      *(undefined4 *)PTR_current_block_0800574c = 0;\n      plan_discard_current_block();\n    }\n  }\n  *(ushort *)PTR_step_bits_08005754 =\n       *(ushort *)PTR_step_bits_08005754 ^ *(ushort *)(PTR_settings_08005758 + 0x18);\n  *(ushort *)PTR_dirn_bits_0800575c =\n       *(ushort *)PTR_dirn_bits_0800575c ^ *(ushort *)(PTR_settings_08005758 + 0x1a);\n  return;\n}\n\n", 
            "called": [
                "set_step_events_per_minute", 
                "dirn_wr", 
                "iterate_trapezoid_cycle_counter", 
                "st_go_idle", 
                "plan_discard_current_block", 
                "plan_get_current_block"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080053a0", 
            "calling": [
                "TIM2_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "step_period_isr"
        }, 
        "step_isr_disable": {
            "renaming": {}, 
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid step_isr_disable(void)\n\n{\n  TIM_TypeDef *TIMx;\n  \n  _DAT_40000000 = _DAT_40000000 & 0xfffffffe;\n  _DAT_4000000c = _DAT_4000000c & 0xfffffff8;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007bc2", 
            "calling": [
                "st_go_idle"
            ], 
            "imported": false, 
            "current_name": "step_isr_disable"
        }, 
        "mc_reset": {
            "renaming": {}, 
            "code": "\nvoid mc_reset(void)\n\n{\n  if ((PTR_sys_08002634[2] & 0x10) == 0) {\n    PTR_sys_08002634[2] = PTR_sys_08002634[2] | 0x10;\n    spindle_stop();\n    coolant_stop();\n    if ((byte)PTR_sys_08002634[1] - 3 < 3) {\n      PTR_sys_08002634[2] = PTR_sys_08002634[2] | 0x20;\n      st_go_idle();\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "coolant_stop", 
                "st_go_idle", 
                "spindle_stop"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080025e8", 
            "calling": [
                "serial_rx_hook", 
                "protocol_execute_line", 
                "gc_execute_line", 
                "limits_isr", 
                "buttons_isr"
            ], 
            "imported": false, 
            "current_name": "mc_reset"
        }, 
        "SystemCoreClockUpdate": {
            "renaming": {}, 
            "code": "\nvoid SystemCoreClockUpdate(void)\n\n{\n  uint uVar1;\n  uint32_t pllm;\n  uint32_t pllsource;\n  uint32_t pllp;\n  uint32_t tmp;\n  uint32_t pllvco;\n  \n  uVar1 = *(uint *)(DAT_080076b4 + 8) & 0xc;\n  if (uVar1 == 8) {\n    uVar1 = *(uint *)(DAT_080076b4 + 4) & 0x3f;\n    if ((*(uint *)(DAT_080076b4 + 4) >> 0x16 & 1) == 0) {\n      pllvco = (*(uint *)(DAT_080076b4 + 4) >> 6 & 0x1ff) * (DAT_080076bc / uVar1);\n    }\n    else {\n      pllvco = (*(uint *)(DAT_080076b4 + 4) >> 6 & 0x1ff) * (DAT_080076c0 / uVar1);\n    }\n    *(uint *)PTR_SystemCoreClock_080076b8 =\n         pllvco / (((*(uint *)(DAT_080076b4 + 4) >> 0x10 & 3) + 1) * 2);\n    goto LAB_0800768a;\n  }\n  if (uVar1 < 9) {\n    if (uVar1 == 0) {\n      *(uint *)PTR_SystemCoreClock_080076b8 = DAT_080076bc;\n      goto LAB_0800768a;\n    }\n    if (uVar1 == 4) {\n      *(uint *)PTR_SystemCoreClock_080076b8 = DAT_080076c0;\n      goto LAB_0800768a;\n    }\n  }\n  *(uint *)PTR_SystemCoreClock_080076b8 = DAT_080076bc;\nLAB_0800768a:\n  *(uint *)PTR_SystemCoreClock_080076b8 =\n       *(uint *)PTR_SystemCoreClock_080076b8 >>\n       PTR_AHBPrescTable_080076c4[*(uint *)(DAT_080076b4 + 8) >> 4 & 0xf];\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080075c8", 
            "calling": [], 
            "imported": false, 
            "current_name": "SystemCoreClockUpdate"
        }, 
        "gpio_rd": {
            "renaming": {}, 
            "code": "\nint gpio_rd(int n)\n\n{\n  return *(uint *)((n >> 4) * 0x400 + 0x40020010) >> (n & 0xfU) & 1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007854", 
            "calling": [
                "debounce_input"
            ], 
            "imported": false, 
            "current_name": "gpio_rd"
        }, 
        "atan2": {
            "renaming": {}, 
            "code": "\nvoid atan2(uint param_1,uint param_2,uint param_3,uint param_4,double param_5)\n\n{\n  int iVar1;\n  undefined4 unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  \n  uVar3 = param_4 & 0x7fffffff;\n  if ((DAT_08009b18 < (uVar3 | (-param_3 | param_3) >> 0x1f)) ||\n     (uVar4 = param_2 & 0x7fffffff, DAT_08009b18 < (uVar4 | (-param_1 | param_1) >> 0x1f))) {\n    __aeabi_dadd(param_3,param_4,param_1,param_2);\n  }\n  else {\n    if ((param_4 + 0xc0100000 | param_3) == 0) {\n      atan(param_5);\n      return;\n    }\n    uVar2 = (int)param_4 >> 0x1e & 2U | param_2 >> 0x1f;\n    if (((((uVar4 | param_1) != 0) && ((uVar3 | param_3) != 0)) && (uVar3 != DAT_08009b18)) &&\n       (uVar4 != DAT_08009b18)) {\n      iVar1 = (int)(uVar4 - uVar3) >> 0x14;\n      if (((int)(uVar4 - uVar3) < 0x3d00000) &&\n         ((-1 < (int)param_4 || (iVar1 + 0x3c < 0 == SCARRY4(iVar1,0x3c))))) {\n        __divdf3(param_1,param_2,param_3,param_4);\n        fabs((double)CONCAT44(unaff_r4,param_4));\n        atan((double)CONCAT44(unaff_r4,param_4));\n      }\n      if (uVar2 != 1) {\n        if (uVar2 == 2) {\n          uVar5 = __subdf3();\n          __subdf3(DAT_08009af0,DAT_08009af4,(int)uVar5,(int)((ulonglong)uVar5 >> 0x20));\n        }\n        else if (uVar2 != 0) {\n          uVar5 = __subdf3();\n          __subdf3((int)uVar5,(int)((ulonglong)uVar5 >> 0x20),DAT_08009af0,DAT_08009af4);\n        }\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "__ieee754_atan2"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009818", 
            "calling": [
                "mc_arc"
            ], 
            "imported": false, 
            "current_name": "atan2"
        }, 
        "HAL_SYSTICK_Config": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = SysTick_Config(TicksNumb);\n  return uVar1;\n}\n\n", 
            "called": [
                "SysTick_Config"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006d72", 
            "calling": [
                "HAL_Init"
            ], 
            "imported": false, 
            "current_name": "HAL_SYSTICK_Config"
        }, 
        "SysTick_Config": {
            "renaming": {}, 
            "code": "\nuint32_t SysTick_Config(uint32_t ticks)\n\n{\n  bool bVar1;\n  \n  bVar1 = ticks - 1 < 0x1000000;\n  if (bVar1) {\n    DAT_08006cdc[1] = ticks - 1;\n    NVIC_SetPriority(SysTick_IRQn,0xf);\n    DAT_08006cdc[2] = 0;\n    *DAT_08006cdc = 7;\n  }\n  return (uint)!bVar1;\n}\n\n", 
            "called": [
                "NVIC_SetPriority"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006c9c", 
            "calling": [
                "HAL_SYSTICK_Config"
            ], 
            "imported": false, 
            "current_name": "SysTick_Config"
        }, 
        "HAL_MspDeInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_MspDeInit(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005a5c", 
            "calling": [
                "HAL_DeInit"
            ], 
            "imported": false, 
            "current_name": "HAL_MspDeInit"
        }, 
        "spindle_stop": {
            "renaming": {}, 
            "code": "\nvoid spindle_stop(void)\n\n{\n  spindle_off();\n  return;\n}\n\n", 
            "called": [
                "spindle_off"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005250", 
            "calling": [
                "spindle_run", 
                "mc_reset", 
                "spindle_init"
            ], 
            "imported": false, 
            "current_name": "spindle_stop"
        }, 
        "coolant_flood_on": {
            "renaming": {}, 
            "code": "\nvoid coolant_flood_on(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080001c8", 
            "calling": [
                "coolant_run"
            ], 
            "imported": false, 
            "current_name": "coolant_flood_on"
        }, 
        "SysTick_Handler": {
            "renaming": {}, 
            "code": "\nvoid SysTick_Handler(void)\n\n{\n  uint32_t uVar1;\n  uint32_t ticks;\n  \n  uVar1 = HAL_GetTick();\n  if ((uVar1 & 0x1ff) == 0) {\n    gpio_toggle(0x3c);\n  }\n  if ((uVar1 & 0xf) == 0) {\n    debounce_isr();\n  }\n  HAL_IncTick();\n  return;\n}\n\n", 
            "called": [
                "HAL_IncTick", 
                "debounce_isr", 
                "HAL_GetTick", 
                "gpio_toggle"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007756", 
            "calling": [], 
            "imported": false, 
            "current_name": "SysTick_Handler"
        }, 
        "plan_init": {
            "renaming": {}, 
            "code": "\nvoid plan_init(void)\n\n{\n  plan_reset_buffer();\n  memset(PTR_pl_08002f3c,0,0x1c);\n  return;\n}\n\n", 
            "called": [
                "plan_reset_buffer", 
                "memset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002f24", 
            "calling": [
                "grbl_main"
            ], 
            "imported": false, 
            "current_name": "plan_init"
        }, 
        "ceil": {
            "renaming": {}, 
            "code": "\ndouble ceil(double __x)\n\n{\n  uint in_r0;\n  uint in_r1;\n  uint uVar1;\n  uint uVar2;\n  double in_d0;\n  double extraout_d0;\n  double extraout_d0_00;\n  double extraout_d0_01;\n  undefined8 uVar3;\n  \n  uVar2 = (in_r1 << 1) >> 0x15;\n  uVar1 = uVar2 - 0x3ff;\n  if ((int)uVar1 < 0x14) {\n    if ((int)uVar1 < 0) {\n      uVar3 = __aeabi_dadd(in_r0,in_r1,DAT_08009400,DAT_08009404);\n      __aeabi_dcmpgt((int)uVar3,(int)((ulonglong)uVar3 >> 0x20),0,0);\n      in_d0 = extraout_d0_00;\n    }\n    else if ((in_r1 & DAT_08009408 >> (uVar1 & 0xff) | in_r0) != 0) {\n      uVar3 = __aeabi_dadd(in_r0,in_r1,DAT_08009400,DAT_08009404);\n      __aeabi_dcmpgt((int)uVar3,(int)((ulonglong)uVar3 >> 0x20),0,0);\n      in_d0 = extraout_d0;\n    }\n  }\n  else if ((int)uVar1 < 0x34) {\n    if ((0xffffffffU >> (uVar2 - 0x413 & 0xff) & in_r0) != 0) {\n      uVar3 = __aeabi_dadd(in_r0,in_r1,DAT_08009400,DAT_08009404);\n      __aeabi_dcmpgt((int)uVar3,(int)((ulonglong)uVar3 >> 0x20),0,0);\n      in_d0 = extraout_d0_01;\n    }\n  }\n  else if (uVar1 == 0x400) {\n    in_d0 = (double)__aeabi_dadd();\n  }\n  return in_d0;\n}\n\n", 
            "called": [
                "__aeabi_dcmpgt", 
                "__aeabi_dadd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009318", 
            "calling": [
                "homing_cycle", 
                "plan_buffer_line", 
                "calculate_trapezoid_for_block"
            ], 
            "imported": false, 
            "current_name": "ceil"
        }, 
        "spindle_off": {
            "renaming": {}, 
            "code": "\nvoid spindle_off(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005214", 
            "calling": [
                "spindle_stop"
            ], 
            "imported": false, 
            "current_name": "spindle_off"
        }, 
        "debounce_input": {
            "renaming": {}, 
            "code": "\nuint32_t debounce_input(void)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  uint uVar6;\n  \n  iVar1 = gpio_rd(0x36);\n  iVar2 = gpio_rd(0x37);\n  iVar3 = gpio_rd(0x38);\n  iVar4 = gpio_rd(0x39);\n  iVar5 = gpio_rd(0xf);\n  uVar6 = gpio_rd(0);\n  return uVar6 | iVar1 << 4 | iVar2 << 3 | iVar3 << 2 | iVar4 << 1 | iVar5 << 7;\n}\n\n", 
            "called": [
                "gpio_rd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007884", 
            "calling": [
                "debounce_isr"
            ], 
            "imported": false, 
            "current_name": "debounce_input"
        }, 
        "limits_isr": {
            "renaming": {}, 
            "code": "\nvoid limits_isr(void)\n\n{\n  if ((PTR_sys_08001990[1] != '\\x06') && ((PTR_sys_08001990[2] & 0x20) == 0)) {\n    mc_reset();\n    PTR_sys_08001990[2] = PTR_sys_08001990[2] | 0x40;\n  }\n  return;\n}\n\n", 
            "called": [
                "mc_reset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800195c", 
            "calling": [
                "debounce_on_handler"
            ], 
            "imported": false, 
            "current_name": "limits_isr"
        }, 
        "__muldf3": {
            "renaming": {}, 
            "code": "\nulonglong __muldf3(undefined4 param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  ulonglong uVar1;\n  longlong lVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint unaff_r5;\n  uint uVar7;\n  uint uVar8;\n  bool bVar9;\n  bool bVar10;\n  bool bVar11;\n  ulonglong uVar12;\n  \n  uVar12 = CONCAT44(param_2,param_1);\n  uVar7 = 0x7ff;\n  uVar4 = param_2 >> 0x14 & 0x7ff;\n  bVar9 = uVar4 == 0;\n  if (!bVar9) {\n    unaff_r5 = param_4 >> 0x14 & 0x7ff;\n    bVar9 = unaff_r5 == 0;\n  }\n  if (!bVar9) {\n    bVar9 = uVar4 == 0x7ff;\n  }\n  if (!bVar9) {\n    bVar9 = unaff_r5 == 0x7ff;\n  }\n  if (bVar9) {\n    uVar12 = FUN_0800881c();\n  }\n  uVar3 = (uint)(uVar12 >> 0x20);\n  iVar5 = uVar4 + unaff_r5;\n  uVar4 = uVar3 ^ param_4;\n  uVar3 = uVar3 & ~(uVar7 << 0x15);\n  param_4 = param_4 & ~(uVar7 << 0x15);\n  bVar9 = ((uint)uVar12 | uVar3 << 0xc) == 0;\n  if (!bVar9) {\n    bVar9 = (param_3 | param_4 << 0xc) == 0;\n  }\n  uVar3 = uVar3 | 0x100000;\n  param_4 = param_4 | 0x100000;\n  if (bVar9) {\n    param_3 = (uint)uVar12 | param_3;\n    param_4 = (uVar4 & 0x80000000 | uVar3) ^ param_4;\n    uVar4 = uVar7 >> 1;\n    bVar11 = SBORROW4(iVar5,uVar4);\n    uVar6 = iVar5 - uVar4;\n    bVar9 = uVar6 == 0;\n    uVar3 = uVar6;\n    if (!bVar9 && (int)uVar4 <= iVar5) {\n      bVar11 = SBORROW4(uVar7,uVar6);\n      uVar3 = uVar7 - uVar6;\n      bVar9 = uVar7 == uVar6;\n    }\n    if (!bVar9 && (int)uVar3 < 0 == bVar11) {\n      param_4 = param_4 | uVar6 * 0x100000;\n    }\n    if (!bVar9 && (int)uVar3 < 0 == bVar11) {\n      return CONCAT44(param_4,param_3);\n    }\n    param_4 = param_4 | 0x100000;\n    uVar7 = 0;\n    bVar11 = SBORROW4(uVar6,1);\n    uVar6 = uVar6 - 1;\n    bVar9 = uVar6 == 0;\n    uVar4 = uVar6;\n  }\n  else {\n    uVar1 = (uVar12 & 0xffffffff) * (ulonglong)param_3;\n    uVar12 = (uVar12 & 0xffffffff) * (ulonglong)param_4 +\n             (ulonglong)uVar3 * (ulonglong)param_3 + (uVar1 >> 0x20);\n    uVar8 = (uint)uVar12;\n    lVar2 = (ulonglong)uVar3 * (ulonglong)param_4 + (uVar12 >> 0x20);\n    uVar7 = (uint)lVar2;\n    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);\n    if ((int)uVar1 != 0) {\n      uVar8 = uVar8 | 1;\n    }\n    uVar6 = (iVar5 + -0x3ff) - (uint)(uVar3 < 0x200);\n    if (uVar3 < 0x200) {\n      bVar9 = (uVar8 & 0x80000000) != 0;\n      uVar8 = uVar8 << 1;\n      lVar2 = CONCAT44(uVar3 * 2 + (uint)(CARRY4(uVar7,uVar7) || CARRY4(uVar7 * 2,(uint)bVar9)),\n                       uVar7 * 2 + (uint)bVar9);\n    }\n    param_4 = uVar4 & 0x80000000 | (int)((ulonglong)lVar2 >> 0x20) << 0xb | (uint)lVar2 >> 0x15;\n    param_3 = (uint)lVar2 << 0xb | uVar8 >> 0x15;\n    uVar7 = uVar8 * 0x800;\n    bVar10 = 0xfc < uVar6;\n    bVar11 = SBORROW4(uVar6,0xfd);\n    uVar3 = uVar6 - 0xfd;\n    bVar9 = uVar3 == 0;\n    uVar4 = uVar3;\n    if (bVar10 && !bVar9) {\n      bVar10 = 0x6ff < uVar3;\n      bVar11 = SBORROW4(uVar3,0x700);\n      uVar4 = uVar6 - 0x7fd;\n      bVar9 = uVar3 == 0x700;\n    }\n    if (!bVar10 || bVar9) {\n      bVar9 = 0x7fffffff < uVar7;\n      if (uVar7 == 0x80000000) {\n        bVar9 = (uVar8 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(param_4 + uVar6 * 0x100000 + (uint)CARRY4(param_3,(uint)bVar9),param_3 + bVar9\n                     );\n    }\n  }\n  if (!bVar9 && (int)uVar4 < 0 == bVar11) {\n    return (ulonglong)(param_4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  bVar10 = SCARRY4(uVar6,0x36);\n  bVar9 = (int)(uVar6 + 0x36) < 0;\n  bVar11 = uVar6 == 0xffffffca;\n  if (bVar11 || bVar9 != bVar10) {\n    param_3 = 0;\n  }\n  if (bVar11 || bVar9 != bVar10) {\n    param_4 = param_4 & 0x80000000;\n  }\n  if (bVar11 || bVar9 != bVar10) {\n    return CONCAT44(param_4,param_3);\n  }\n  uVar4 = -uVar6;\n  uVar3 = uVar4 - 0x20;\n  if (0x1f < (int)uVar4) {\n    uVar6 = param_3 >> (uVar3 & 0xff) | param_4 << (0x20 - uVar3 & 0xff);\n    uVar4 = (param_4 >> (uVar3 & 0xff) & ~((param_4 & 0x80000000) >> (uVar3 & 0xff))) -\n            ((int)uVar6 >> 0x1f);\n    if ((uVar7 | param_3 << (0x20 - uVar3 & 0xff) | uVar6 << 1) == 0) {\n      uVar4 = uVar4 & ~(uVar6 >> 0x1f);\n    }\n    return CONCAT44(param_4,uVar4) & 0x80000000ffffffff;\n  }\n  iVar5 = uVar4 - 0x14;\n  if (iVar5 == 0 || iVar5 < 0 != SCARRY4(uVar3,0xc)) {\n    uVar8 = param_3 << (uVar6 + 0x20 & 0xff);\n    uVar3 = param_3 >> (uVar4 & 0xff) | param_4 << (uVar6 + 0x20 & 0xff);\n    uVar6 = uVar3 + -((int)uVar8 >> 0x1f);\n    if ((uVar7 | uVar8 << 1) == 0) {\n      uVar6 = uVar6 & ~(uVar8 >> 0x1f);\n    }\n    return CONCAT44((param_4 & 0x80000000) +\n                    ((param_4 & 0x7fffffff) >> (uVar4 & 0xff)) +\n                    (uint)CARRY4(uVar3,-((int)uVar8 >> 0x1f)),uVar6);\n  }\n  uVar4 = 0xc - iVar5;\n  uVar6 = param_3 << (uVar4 & 0xff);\n  uVar4 = param_3 >> (0x20 - uVar4 & 0xff) | param_4 << (uVar4 & 0xff);\n  uVar3 = uVar4 + -((int)uVar6 >> 0x1f);\n  if ((uVar7 | uVar6 << 1) == 0) {\n    uVar3 = uVar3 & ~(uVar6 >> 0x1f);\n  }\n  return CONCAT44((param_4 & 0x80000000) + (uint)CARRY4(uVar4,-((int)uVar6 >> 0x1f)),uVar3);\n}\n\n", 
            "called": [
                "FUN_0800881c"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008640", 
            "calling": [
                "__kernel_cos", 
                "scalbn", 
                "report_realtime_status", 
                "__ieee754_sqrt", 
                "atan", 
                "__kernel_rem_pio2", 
                "__ieee754_hypot", 
                "to_millimeters", 
                "read_float", 
                "__ieee754_rem_pio2", 
                "report_gcode_modes", 
                "__kernel_sin", 
                "homing_cycle", 
                "mc_arc", 
                "plan_buffer_line", 
                "calculate_trapezoid_for_block", 
                "report_gcode_parameters"
            ], 
            "imported": false, 
            "current_name": "__muldf3"
        }, 
        "__nedf2": {
            "renaming": {}, 
            "code": "\nuint __nedf2(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  bool bVar2;\n  bool bVar3;\n  \n  if (((int)(param_2 << 1) >> 0x15 == -1 || (int)(param_4 << 1) >> 0x15 == -1) &&\n     ((((int)(param_2 << 1) >> 0x15 == -1 && ((param_1 | param_2 << 0xc) != 0)) ||\n      (((int)(param_4 << 1) >> 0x15 == -1 && ((param_3 | param_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  bVar2 = (param_1 | param_2 << 1) == 0;\n  if (bVar2) {\n    bVar2 = (param_3 | param_4 << 1) == 0;\n  }\n  if (!bVar2) {\n    bVar2 = param_2 == param_4;\n  }\n  if (bVar2) {\n    bVar2 = param_1 == param_3;\n  }\n  if (!bVar2) {\n    uVar1 = param_2 ^ param_4;\n    bVar2 = uVar1 == 0;\n    if (-1 < (int)uVar1) {\n      bVar2 = param_2 == param_4;\n    }\n    bVar3 = -1 < (int)uVar1 && param_4 <= param_2;\n    if (bVar2) {\n      bVar3 = param_3 <= param_1;\n    }\n    param_4 = (int)param_4 >> 0x1f;\n    if (!bVar3) {\n      param_4 = ~param_4;\n    }\n    return param_4 | 1;\n  }\n  return 0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008a74", 
            "calling": [
                "__aeabi_cdcmpeq"
            ], 
            "imported": false, 
            "current_name": "__nedf2"
        }, 
        "__truncdfsf2": {
            "renaming": {}, 
            "code": "\nuint __truncdfsf2(uint param_1,uint param_2)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint in_r12;\n  bool bVar4;\n  bool bVar5;\n  \n  uVar2 = param_2 * 2;\n  bVar5 = uVar2 < 0x70000000;\n  uVar3 = uVar2 + 0x90000000;\n  uVar1 = uVar3;\n  if (!bVar5) {\n    in_r12 = uVar2 + 0x8fe00000;\n    uVar1 = in_r12;\n  }\n  bVar4 = uVar1 == 0;\n  if (!bVar5 && uVar3 >= 0x200000) {\n    bVar4 = in_r12 == 0x1fc00000;\n  }\n  if (((bVar5 || uVar3 < 0x200000) || 0x1fc00000 < in_r12) || bVar4) {\n    if ((param_2 & 0x40000000) != 0) {\n      if (((int)uVar2 >> 0x15 == -1) && ((param_1 | param_2 << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return param_2 & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(uVar2 + 0x92e00000) < 0 != SCARRY4(uVar3,0x2e00000)) {\n      return param_2 & 0x80000000;\n    }\n    uVar2 = 0x18 - (uVar2 + 0x92e00000 >> 0x15);\n    uVar1 = param_1 >> (uVar2 & 0xff);\n    if (param_1 << (0x20 - uVar2 & 0xff) != 0) {\n      uVar1 = uVar1 | 1;\n    }\n    uVar3 = param_2 & 0x1fffff | 0x100000;\n    param_1 = uVar1 | uVar3 << (0x20 - uVar2 & 0xff);\n    uVar3 = (uVar3 >> (uVar2 & 0xff)) << 1;\n  }\n  uVar1 = (param_2 & 0x80000000 | param_1 >> 0x1d) + uVar3 * 4 + (uint)(0x7fffffff < param_1 * 8);\n  if (param_1 * 8 == 0x80000000) {\n    uVar1 = uVar1 & 0xfffffffe;\n  }\n  return uVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008c30", 
            "calling": [
                "report_gcode_modes", 
                "report_realtime_status", 
                "homing_cycle", 
                "mc_arc", 
                "plan_buffer_line", 
                "to_millimeters", 
                "max_allowable_speed", 
                "gc_execute_line", 
                "read_float", 
                "report_gcode_parameters"
            ], 
            "imported": false, 
            "current_name": "__truncdfsf2"
        }, 
        "max_allowable_speed": {
            "renaming": {}, 
            "code": "\nfloat max_allowable_speed(float acceleration,float target_velocity,float distance)\n\n{\n  undefined4 in_r0;\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 in_r1;\n  undefined4 extraout_r1;\n  undefined4 in_r2;\n  float fVar3;\n  undefined4 in_stack_ffffffe0;\n  \n  uVar1 = __aeabi_fmul(acceleration,in_r1,in_r1);\n  uVar2 = __addsf3(in_r0,in_r0);\n  uVar2 = __aeabi_fmul(uVar2,in_r2);\n  uVar1 = __aeabi_fsub(uVar1,uVar2);\n  uVar1 = __aeabi_f2d(uVar1);\n  sqrt((double)CONCAT44(in_r2,in_stack_ffffffe0));\n  fVar3 = (float)__truncdfsf2(uVar1,extraout_r1);\n  return fVar3;\n}\n\n", 
            "called": [
                "__addsf3", 
                "__truncdfsf2", 
                "__aeabi_f2d", 
                "__aeabi_fsub", 
                "__aeabi_fmul", 
                "sqrt"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002978", 
            "calling": [
                "planner_reverse_pass_kernel", 
                "plan_buffer_line", 
                "planner_forward_pass_kernel"
            ], 
            "imported": false, 
            "current_name": "max_allowable_speed"
        }, 
        "trunc": {
            "renaming": {}, 
            "code": "\ndouble trunc(double __x)\n\n{\n  int in_r1;\n  int iVar1;\n  double in_d0;\n  \n  iVar1 = ((uint)(in_r1 << 1) >> 0x15) - 0x3ff;\n  if (iVar1 < 0x14) {\n    if (iVar1 < 0) {\n      return in_d0;\n    }\n  }\n  else {\n    if (iVar1 < 0x34) {\n      return in_d0;\n    }\n    if (iVar1 != 0x400) {\n      return in_d0;\n    }\n    in_d0 = (double)__aeabi_dadd();\n  }\n  return in_d0;\n}\n\n", 
            "called": [
                "__aeabi_dadd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009798", 
            "calling": [
                "protocol_execute_line", 
                "gc_execute_line", 
                "settings_store_global_setting"
            ], 
            "imported": false, 
            "current_name": "trunc"
        }, 
        "debounce_init": {
            "renaming": {}, 
            "code": "\nvoid debounce_init(void)\n\n{\n  memset(PTR_debounce_080079d8,0,0x18);\n  *(undefined4 *)PTR_debounce_ready_080079dc = 1;\n  return;\n}\n\n", 
            "called": [
                "memset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080079c0", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "debounce_init"
        }, 
        "HAL_DisableDBGStopMode": {
            "renaming": {}, 
            "code": "\nvoid HAL_DisableDBGStopMode(void)\n\n{\n  *(uint *)(DAT_08005b70 + 4) = *(uint *)(DAT_08005b70 + 4) & 0xfffffffd;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005b58", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_DisableDBGStopMode"
        }, 
        "printString": {
            "renaming": {}, 
            "code": "\nvoid printString(char *s)\n\n{\n  uint8_t *local_c;\n  \n  local_c = (uint8_t *)s;\n  while (*local_c != '\\0') {\n    serial_write(*local_c);\n    local_c = local_c + 1;\n  }\n  return;\n}\n\n", 
            "called": [
                "serial_write"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800369c", 
            "calling": [
                "report_startup_line", 
                "protocol_execute_startup"
            ], 
            "imported": false, 
            "current_name": "printString"
        }, 
        "eeprom_init": {
            "renaming": {}, 
            "code": "\nvoid eeprom_init(void)\n\n{\n  memset(PTR_eeprom_data_08000308,0xff,4);\n  *(undefined4 *)PTR_eeprom_ready_0800030c = 1;\n  return;\n}\n\n", 
            "called": [
                "memset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080002f0", 
            "calling": [
                "eeprom_put_char", 
                "memcpy_to_eeprom_with_checksum", 
                "eeprom_get_char", 
                "memcpy_from_eeprom_with_checksum"
            ], 
            "imported": false, 
            "current_name": "eeprom_init"
        }, 
        "delay_ms": {
            "renaming": {}, 
            "code": "\nvoid delay_ms(uint16_t ms)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002814", 
            "calling": [
                "report_alarm_message", 
                "mc_dwell", 
                "limits_go_home"
            ], 
            "imported": false, 
            "current_name": "delay_ms"
        }, 
        "report_gcode_modes": {
            "renaming": {}, 
            "code": "\nvoid report_gcode_modes(void)\n\n{\n  byte bVar1;\n  char cVar2;\n  float n;\n  float n_00;\n  undefined8 uVar3;\n  \n  if (4 < (byte)PTR_gc_08004890[1]) {\n    printPgmString(PTR_DAT_080048a8);\n    printInteger((byte)PTR_gc_08004890[0x1c] + 0x36);\n    if (PTR_gc_08004890[0x19] == '\\0') {\n      if (PTR_gc_08004890[0x1a] == '\\x01') {\n        printPgmString(PTR_DAT_080048ac);\n      }\n      else {\n        printPgmString(PTR_DAT_080048b0);\n      }\n    }\n    else {\n      printPgmString(PTR_DAT_080048b4);\n    }\n    if (PTR_gc_08004890[3] == '\\0') {\n      printPgmString(PTR_DAT_080048bc);\n    }\n    else {\n      printPgmString(PTR_DAT_080048b8);\n    }\n    if (PTR_gc_08004890[4] == '\\0') {\n      printPgmString(PTR_DAT_080048c4);\n    }\n    else {\n      printPgmString(PTR_DAT_080048c0);\n    }\n    if (PTR_gc_08004890[2] == '\\0') {\n      printPgmString(PTR_DAT_080048cc);\n    }\n    else {\n      printPgmString(PTR_DAT_080048c8);\n    }\n    bVar1 = PTR_gc_08004890[5];\n    if (bVar1 == 2) {\n      printPgmString(PTR_DAT_080048d8);\n    }\n    else if (bVar1 < 3) {\n      if (bVar1 == 0) {\n        printPgmString(PTR_DAT_080048d0);\n      }\n      else if (bVar1 == 1) {\n        printPgmString(PTR_DAT_080048d4);\n      }\n    }\n    cVar2 = PTR_gc_08004890[6];\n    if (cVar2 == '\\x01') {\n      printPgmString(PTR_DAT_080048dc);\n    }\n    else if (cVar2 < '\\x02') {\n      if (cVar2 == -1) {\n        printPgmString(PTR_DAT_080048e0);\n      }\n      else if (cVar2 == '\\0') {\n        printPgmString(PTR_DAT_080048e4);\n      }\n    }\n    bVar1 = PTR_gc_08004890[7];\n    if (bVar1 == 2) {\n      printPgmString(PTR_DAT_080048f0);\n    }\n    else if (bVar1 < 3) {\n      if (bVar1 == 0) {\n        printPgmString(PTR_DAT_080048e8);\n      }\n      else if (bVar1 == 1) {\n        printPgmString(PTR_DAT_080048ec);\n      }\n    }\n    printPgmString(PTR_DAT_080048f4);\n    printInteger((uint)(byte)PTR_gc_08004890[0x18]);\n    printPgmString(PTR_DAT_080048f8);\n    if (PTR_gc_08004890[3] == '\\0') {\n      printFloat(n);\n    }\n    else {\n      uVar3 = __aeabi_f2d(*(undefined4 *)(PTR_gc_08004890 + 8));\n      uVar3 = __muldf3((int)uVar3,(int)((ulonglong)uVar3 >> 0x20),DAT_08004888,DAT_0800488c);\n      n_00 = (float)__truncdfsf2((int)uVar3,(int)((ulonglong)uVar3 >> 0x20));\n      printFloat(n_00);\n    }\n    printPgmString(PTR_DAT_080048fc);\n    return;\n  }\n                    /* WARNING: Could not recover jumptable at 0x080046de. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(&switchD_080046de::switchdataD_080046e4)[(byte)PTR_gc_08004890[1]])();\n  return;\n}\n\n", 
            "called": [
                "__truncdfsf2", 
                "printPgmString", 
                "__muldf3", 
                "__aeabi_f2d", 
                "printFloat", 
                "printInteger"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080046d0", 
            "calling": [
                "protocol_execute_line"
            ], 
            "imported": false, 
            "current_name": "report_gcode_modes"
        }, 
        "planner_reverse_pass_kernel": {
            "renaming": {}, 
            "code": "\nvoid planner_reverse_pass_kernel(block_t *previous,block_t *current,block_t *next)\n\n{\n  int iVar1;\n  uint uVar2;\n  float fVar3;\n  float acceleration;\n  float acceleration_00;\n  float target_velocity;\n  float target_velocity_00;\n  float distance;\n  float distance_00;\n  \n  if (((current != (block_t *)0x0) && (next != (block_t *)0x0)) &&\n     (iVar1 = __aeabi_fcmpeq(current->entry_speed,current->max_entry_speed), iVar1 == 0)) {\n    if ((current->nominal_length_flag == '\\0') &&\n       (iVar1 = __aeabi_fcmpgt(current->max_entry_speed,next->entry_speed), iVar1 != 0)) {\n      fVar3 = current->max_entry_speed;\n      uVar2 = *(uint *)(PTR_settings_08002a90 + 0x20) ^ 0x80000000;\n      max_allowable_speed(acceleration,target_velocity,distance);\n      iVar1 = __aeabi_fcmplt(fVar3,uVar2);\n      if (iVar1 == 0) {\n        fVar3 = (float)(*(uint *)(PTR_settings_08002a90 + 0x20) ^ 0x80000000);\n        max_allowable_speed(acceleration_00,target_velocity_00,distance_00);\n      }\n      else {\n        fVar3 = current->max_entry_speed;\n      }\n      current->entry_speed = fVar3;\n    }\n    else {\n      current->entry_speed = current->max_entry_speed;\n    }\n    current->recalculate_flag = '\\x01';\n  }\n  return;\n}\n\n", 
            "called": [
                "__aeabi_fcmpeq", 
                "max_allowable_speed", 
                "__aeabi_fcmpgt", 
                "__aeabi_fcmplt"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080029d8", 
            "calling": [
                "planner_reverse_pass"
            ], 
            "imported": false, 
            "current_name": "planner_reverse_pass_kernel"
        }, 
        "__subdf3": {
            "renaming": {}, 
            "code": "\nulonglong __subdf3(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  bool bVar14;\n  bool bVar15;\n  \n  uVar6 = param_4 ^ 0x80000000;\n  uVar9 = param_2 << 1;\n  param_4 = param_4 << 1;\n  bVar13 = ((param_2 ^ uVar6) & 0x7fffffff) == 0;\n  bVar14 = bVar13 && param_1 == param_3;\n  if (!bVar13 || param_1 != param_3) {\n    bVar14 = (uVar9 | param_1) == 0;\n  }\n  if (!bVar14) {\n    bVar14 = (param_4 | param_3) == 0;\n  }\n  iVar8 = (int)uVar9 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar8 == -1;\n  }\n  iVar1 = (int)param_4 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar1 == -1;\n  }\n  if (bVar14) {\n    if (iVar8 == -1 || iVar1 == -1) {\n      uVar9 = uVar6;\n      uVar11 = param_3;\n      if (iVar8 == -1) {\n        uVar9 = param_2;\n        uVar11 = param_1;\n      }\n      if (iVar8 != -1 || iVar1 != -1) {\n        param_3 = uVar11;\n        uVar6 = uVar9;\n      }\n      bVar14 = (uVar11 | uVar9 << 0xc) == 0;\n      if (bVar14) {\n        bVar14 = (param_3 | uVar6 << 0xc) == 0;\n      }\n      if (bVar14) {\n        bVar14 = uVar9 == uVar6;\n      }\n      if (!bVar14) {\n        uVar9 = uVar9 | 0x80000;\n      }\n      return CONCAT44(uVar9,uVar11);\n    }\n    if (((param_2 ^ uVar6) & 0x7fffffff) != 0 || param_1 != param_3) {\n      if ((uVar9 | param_1) == 0) {\n        param_1 = param_3;\n        param_2 = uVar6;\n      }\n      return CONCAT44(param_2,param_1);\n    }\n    if (param_2 != uVar6) {\n      return 0;\n    }\n    if (uVar9 >> 0x15 == 0) {\n      bVar14 = (param_1 & 0x80000000) != 0;\n      uVar6 = param_2 * 2 + (uint)bVar14;\n      if (CARRY4(param_2,param_2) || CARRY4(param_2 * 2,(uint)bVar14)) {\n        uVar6 = uVar6 | 0x80000000;\n      }\n      return CONCAT44(uVar6,param_1 << 1);\n    }\n    if (uVar9 < 0xffc00000) {\n      return CONCAT44(param_2 + 0x100000,param_1);\n    }\n    param_2 = param_2 & 0x80000000;\nLAB_08008514:\n    return (ulonglong)(param_2 | 0x7ff00000) << 0x20;\n  }\n  uVar9 = uVar9 >> 0x15;\n  param_4 = param_4 >> 0x15;\n  uVar11 = param_4 - uVar9;\n  bVar14 = uVar11 != 0;\n  if (param_4 < uVar9) {\n    uVar11 = -uVar11;\n  }\n  uVar10 = param_1;\n  uVar7 = param_2;\n  if (bVar14 && uVar9 <= param_4) {\n    uVar9 = uVar9 + uVar11;\n    uVar10 = param_3;\n    uVar7 = uVar6;\n    param_3 = param_1;\n    uVar6 = param_2;\n  }\n  if (0x36 < uVar11) {\n    return CONCAT44(uVar7,uVar10);\n  }\n  uVar4 = uVar7 & 0xfffff | 0x100000;\n  if ((uVar7 & 0x80000000) != 0) {\n    bVar14 = uVar10 != 0;\n    uVar10 = -uVar10;\n    uVar4 = -uVar4 - (uint)bVar14;\n  }\n  uVar7 = uVar6 & 0xfffff | 0x100000;\n  if ((uVar6 & 0x80000000) != 0) {\n    bVar14 = param_3 != 0;\n    param_3 = -param_3;\n    uVar7 = -uVar7 - (uint)bVar14;\n  }\n  if (uVar9 == uVar11) {\n    uVar7 = uVar7 ^ 0x100000;\n    if (uVar9 == 0) {\n      uVar4 = uVar4 ^ 0x100000;\n      uVar9 = 1;\n    }\n    else {\n      uVar11 = uVar11 - 1;\n    }\n  }\n  uVar6 = -uVar11 + 0x20;\n  if ((int)uVar11 < 0x21) {\n    uVar12 = param_3 << (uVar6 & 0xff);\n    param_3 = param_3 >> (uVar11 & 0xff);\n    uVar3 = uVar10 + param_3;\n    uVar5 = uVar7 << (uVar6 & 0xff);\n    uVar6 = uVar3 + uVar5;\n    uVar4 = uVar4 + CARRY4(uVar10,param_3) + ((int)uVar7 >> (uVar11 & 0xff)) +\n            (uint)CARRY4(uVar3,uVar5);\n  }\n  else {\n    uVar12 = uVar7 << (-uVar11 + 0x40 & 0xff);\n    if (param_3 != 0) {\n      uVar12 = uVar12 | 2;\n    }\n    uVar7 = (int)uVar7 >> (uVar11 - 0x20 & 0xff);\n    uVar6 = uVar10 + uVar7;\n    uVar4 = uVar4 + ((int)uVar7 >> 0x1f) + (uint)CARRY4(uVar10,uVar7);\n  }\n  param_2 = uVar4 & 0x80000000;\n  uVar11 = uVar4;\n  if ((int)uVar4 < 0) {\n    bVar14 = uVar12 == 0;\n    uVar12 = -uVar12;\n    uVar11 = -uVar6;\n    uVar6 = -(uint)!bVar14 - uVar6;\n    uVar11 = -(uint)(bVar14 <= uVar11) - uVar4;\n  }\n  if (0xfffff < uVar11) {\n    uVar10 = uVar9 - 1;\n    if (0x1fffff < uVar11) {\n      uVar10 = uVar11 & 1;\n      uVar11 = uVar11 >> 1;\n      bVar2 = (byte)uVar6;\n      uVar6 = (uint)(uVar10 != 0) << 0x1f | uVar6 >> 1;\n      uVar12 = (uint)(bVar2 & 1) << 0x1f | uVar12 >> 1;\n      uVar10 = uVar9;\n      if (0xffbfffff < uVar9 * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    bVar14 = 0x7fffffff < uVar12;\n    if (uVar12 == 0x80000000) {\n      bVar14 = (uVar6 & 1) != 0;\n    }\n    return CONCAT44(uVar11 + uVar10 * 0x100000 + (uint)CARRY4(uVar6,(uint)bVar14) | param_2,\n                    uVar6 + bVar14);\n  }\n  bVar13 = (uVar12 & 0x80000000) != 0;\n  uVar12 = uVar12 << 1;\n  uVar10 = uVar6 * 2;\n  bVar14 = CARRY4(uVar6,uVar6);\n  uVar6 = uVar6 * 2 + (uint)bVar13;\n  uVar11 = uVar11 * 2 + (uint)(bVar14 || CARRY4(uVar10,(uint)bVar13));\n  uVar10 = uVar9 - 2;\n  if (uVar9 - 1 != 0 && 0xfffff < uVar11) goto LAB_080083e0;\n  uVar7 = uVar6;\n  uVar9 = uVar11;\n  if (uVar11 == 0) {\n    uVar7 = 0;\n    uVar9 = uVar6;\n  }\n  iVar8 = count_leading_zeroes(uVar9);\n  if (uVar11 == 0) {\n    iVar8 = iVar8 + 0x20;\n  }\n  uVar11 = iVar8 - 0xb;\n  bVar15 = SBORROW4(uVar11,0x20);\n  uVar6 = iVar8 - 0x2b;\n  bVar14 = (int)uVar6 < 0;\n  bVar13 = uVar6 == 0;\n  if ((int)uVar11 < 0x20) {\n    bVar15 = SCARRY4(uVar6,0xc);\n    iVar8 = iVar8 + -0x1f;\n    bVar14 = iVar8 < 0;\n    bVar13 = iVar8 == 0;\n    uVar6 = uVar11;\n    if (!bVar13 && bVar14 == bVar15) {\n      uVar7 = uVar9 << (uVar11 & 0xff);\n      uVar9 = uVar9 >> (0xcU - iVar8 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar12 = 0x20 - uVar6;\n  }\n  uVar9 = uVar9 << (uVar6 & 0xff);\n  if (bVar13 || bVar14 != bVar15) {\n    uVar9 = uVar9 | uVar7 >> (uVar12 & 0xff);\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar7 = uVar7 << (uVar6 & 0xff);\n  }\nLAB_08008458:\n  if ((int)uVar11 <= (int)uVar10) {\n    return CONCAT44(uVar9 + (uVar10 - uVar11) * 0x100000 | param_2,uVar7);\n  }\n  uVar6 = ~(uVar10 - uVar11);\n  if ((int)uVar6 < 0x1f) {\n    iVar8 = uVar6 - 0x13;\n    if (iVar8 != 0 && iVar8 < 0 == SCARRY4(uVar6 - 0x1f,0xc)) {\n      return CONCAT44(uVar4,uVar7 >> (0x20 - (0xcU - iVar8) & 0xff) | uVar9 << (0xcU - iVar8 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    uVar6 = uVar6 + 1;\n    return CONCAT44(param_2 | uVar9 >> (uVar6 & 0xff),\n                    uVar7 >> (uVar6 & 0xff) | uVar9 << (0x20 - uVar6 & 0xff));\n  }\n  return CONCAT44(uVar4,uVar9 >> (uVar6 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080082d0", 
            "calling": [
                "__kernel_cos", 
                "report_realtime_status", 
                "__ieee754_sqrt", 
                "atan", 
                "__kernel_rem_pio2", 
                "__ieee754_atan2", 
                "__ieee754_hypot", 
                "__ieee754_rem_pio2", 
                "__kernel_sin", 
                "mc_arc", 
                "plan_buffer_line", 
                "sin", 
                "cos"
            ], 
            "imported": false, 
            "current_name": "__subdf3"
        }, 
        "__aeabi_l2f": {
            "renaming": {}, 
            "code": "\nuint __aeabi_l2f(uint param_1,uint param_2)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  uint uVar7;\n  bool bVar8;\n  \n  if ((param_1 | param_2) == 0) {\n    return param_1;\n  }\n  uVar5 = param_2 & 0x80000000;\n  if ((int)uVar5 < 0) {\n    bVar8 = param_1 != 0;\n    param_1 = -param_1;\n    param_2 = -param_2 - (uint)bVar8;\n  }\n  uVar2 = param_1;\n  uVar1 = param_2;\n  if (param_2 == 0) {\n    uVar2 = 0;\n    uVar1 = param_1;\n  }\n  uVar5 = uVar5 | 0x5b000000;\n  if (param_2 == 0) {\n    uVar5 = uVar5 + 0xf0000000;\n  }\n  iVar3 = count_leading_zeroes(uVar1);\n  uVar4 = iVar3 - 8;\n  iVar6 = (uVar5 - 0x800000) + uVar4 * -0x800000;\n  if (iVar3 < 8) {\n    uVar4 = uVar1 << (iVar3 + 0x18U & 0xff);\n    uVar5 = iVar6 + ((uVar1 >> (0x20 - (iVar3 + 0x18U) & 0xff)) - ((int)uVar4 >> 0x1f));\n    if ((uVar2 | uVar4 << 1) == 0) {\n      uVar5 = uVar5 & ~(uVar4 >> 0x1f);\n    }\n    return uVar5;\n  }\n  uVar7 = uVar2 << (uVar4 & 0xff);\n  uVar5 = iVar6 + (uVar1 << (uVar4 & 0xff)) +\n          (uVar2 >> (0x20 - uVar4 & 0xff)) + (uint)(0x7fffffff < uVar7);\n  if (uVar7 == 0x80000000) {\n    uVar5 = uVar5 & 0xfffffffe;\n  }\n  return uVar5;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008e70", 
            "calling": [], 
            "imported": false, 
            "current_name": "__aeabi_l2f"
        }, 
        "_delay_ms": {
            "renaming": {}, 
            "code": "\nvoid _delay_ms(uint _ms)\n\n{\n  HAL_Delay(_ms);\n  return;\n}\n\n", 
            "called": [
                "HAL_Delay"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080002a0", 
            "calling": [
                "mc_dwell"
            ], 
            "imported": false, 
            "current_name": "_delay_ms"
        }, 
        "planner_forward_pass_kernel": {
            "renaming": {}, 
            "code": "\nvoid planner_forward_pass_kernel(block_t *previous,block_t *current,block_t *next)\n\n{\n  int iVar1;\n  uint uVar2;\n  float fVar3;\n  float acceleration;\n  float acceleration_00;\n  float target_velocity;\n  float target_velocity_00;\n  float distance;\n  float distance_00;\n  float entry_speed;\n  \n  if (((previous != (block_t *)0x0) && (previous->nominal_length_flag == '\\0')) &&\n     (iVar1 = __aeabi_fcmplt(previous->entry_speed,current->entry_speed), iVar1 != 0)) {\n    fVar3 = current->entry_speed;\n    uVar2 = *(uint *)(PTR_settings_08002ba4 + 0x20) ^ 0x80000000;\n    max_allowable_speed(acceleration,target_velocity,distance);\n    iVar1 = __aeabi_fcmplt(fVar3,uVar2);\n    if (iVar1 == 0) {\n      fVar3 = (float)(*(uint *)(PTR_settings_08002ba4 + 0x20) ^ 0x80000000);\n      max_allowable_speed(acceleration_00,target_velocity_00,distance_00);\n    }\n    else {\n      fVar3 = current->entry_speed;\n    }\n    iVar1 = __aeabi_fcmpeq(fVar3,current->entry_speed);\n    if (iVar1 == 0) {\n      current->entry_speed = fVar3;\n      current->recalculate_flag = '\\x01';\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "__aeabi_fcmpeq", 
                "max_allowable_speed", 
                "__aeabi_fcmplt"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002afc", 
            "calling": [
                "planner_forward_pass"
            ], 
            "imported": false, 
            "current_name": "planner_forward_pass_kernel"
        }, 
        "printFloat": {
            "renaming": {}, 
            "code": "\nvoid printFloat(float n)\n\n{\n  uint in_r0;\n  int iVar1;\n  undefined4 uVar2;\n  byte bVar3;\n  uint uVar4;\n  uint local_24;\n  uint8_t uStack_1d;\n  uchar buf [10];\n  uint32_t a;\n  uint8_t i;\n  uint8_t decimals;\n  \n  iVar1 = __aeabi_fcmplt(in_r0,0);\n  local_24 = in_r0;\n  if (iVar1 != 0) {\n    serial_write('-');\n    local_24 = in_r0 ^ 0x80000000;\n  }\n  for (decimals = PTR_settings_08003970[0x3d]; 1 < decimals; decimals = decimals + 0xfe) {\n    local_24 = __aeabi_fmul(local_24,DAT_08003974);\n  }\n  if (decimals != '\\0') {\n    local_24 = __aeabi_fmul(local_24,DAT_08003978);\n  }\n  uVar2 = __addsf3(local_24,0x3f000000);\n  i = '\\0';\n  a = __aeabi_f2iz(uVar2);\n  buf[(byte)PTR_settings_08003970[0x3d]] = '.';\n  for (; a != 0; a = (uint32_t)((ulonglong)DAT_0800397c * (ulonglong)a >> 0x23)) {\n    if (i == PTR_settings_08003970[0x3d]) {\n      i = i + '\\x01';\n    }\n    uVar4 = (uint)i;\n    i = i + '\\x01';\n    buf[uVar4] = (char)a + (char)(uint)((ulonglong)DAT_0800397c * (ulonglong)a >> 0x23) * -10 + '0';\n  }\n  while (i < (byte)PTR_settings_08003970[0x3d]) {\n    uVar4 = (uint)i;\n    i = i + '\\x01';\n    buf[uVar4] = '0';\n  }\n  if (i == PTR_settings_08003970[0x3d]) {\n    bVar3 = i + 1;\n    i = i + '\\x02';\n    buf[bVar3] = '0';\n  }\n  for (; i != '\\0'; i = i + 0xff) {\n    serial_write(buf[i - 1]);\n  }\n  return;\n}\n\n", 
            "called": [
                "__addsf3", 
                "__aeabi_fmul", 
                "serial_write", 
                "__aeabi_f2iz", 
                "__aeabi_fcmplt"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003826", 
            "calling": [
                "report_gcode_modes", 
                "report_realtime_status", 
                "report_grbl_settings", 
                "report_gcode_parameters"
            ], 
            "imported": false, 
            "current_name": "printFloat"
        }, 
        "gpio_toggle": {
            "renaming": {}, 
            "code": "\nvoid gpio_toggle(int n)\n\n{\n  *(uint *)((n >> 4) * 0x400 + 0x40020014) =\n       *(uint *)((n >> 4) * 0x400 + 0x40020014) ^ 1 << (n & 0xfU);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080076c8", 
            "calling": [
                "SysTick_Handler"
            ], 
            "imported": false, 
            "current_name": "gpio_toggle"
        }, 
        "__aeabi_l2d": {
            "renaming": {}, 
            "code": "\nulonglong __aeabi_l2d(uint param_1,uint param_2)\n\n{\n  byte bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  uint uVar8;\n  uint uVar9;\n  bool bVar10;\n  bool bVar11;\n  bool bVar12;\n  \n  if ((param_1 | param_2) == 0) {\n    return CONCAT44(param_2,param_1);\n  }\n  uVar8 = param_2 & 0x80000000;\n  uVar3 = param_2;\n  if ((int)uVar8 < 0) {\n    bVar11 = param_1 != 0;\n    param_1 = -param_1;\n    uVar3 = -param_2 - (uint)bVar11;\n  }\n  iVar7 = 0x432;\n  uVar9 = uVar3 >> 0x16;\n  if (uVar9 != 0) {\n    iVar7 = 3;\n    if (uVar3 >> 0x19 != 0) {\n      iVar7 = 6;\n    }\n    if (uVar3 >> 0x1c != 0) {\n      iVar7 = iVar7 + 3;\n    }\n    uVar4 = iVar7 - ((int)uVar3 >> 0x1f);\n    uVar9 = param_1 << (0x20 - uVar4 & 0xff);\n    param_1 = param_1 >> (uVar4 & 0xff) | uVar3 << (0x20 - uVar4 & 0xff);\n    uVar3 = uVar3 >> (uVar4 & 0xff);\n    iVar7 = uVar4 + 0x432;\n  }\n  if (0xfffff < uVar3) {\n    if (0x1fffff < uVar3) {\n      uVar4 = uVar3 & 1;\n      uVar3 = uVar3 >> 1;\n      bVar1 = (byte)param_1;\n      param_1 = (uint)(uVar4 != 0) << 0x1f | param_1 >> 1;\n      uVar9 = (uint)(bVar1 & 1) << 0x1f | uVar9 >> 1;\n      iVar7 = iVar7 + 1;\n      if (0xffbfffff < (uint)(iVar7 * 0x200000)) {\n        return (ulonglong)(uVar8 | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_080083e0:\n    bVar11 = 0x7fffffff < uVar9;\n    if (uVar9 == 0x80000000) {\n      bVar11 = (param_1 & 1) != 0;\n    }\n    return CONCAT44(uVar3 + iVar7 * 0x100000 + (uint)CARRY4(param_1,(uint)bVar11) | uVar8,\n                    param_1 + bVar11);\n  }\n  bVar10 = (uVar9 & 0x80000000) != 0;\n  uVar9 = uVar9 << 1;\n  uVar4 = param_1 * 2;\n  bVar11 = CARRY4(param_1,param_1);\n  param_1 = param_1 * 2 + (uint)bVar10;\n  uVar3 = uVar3 * 2 + (uint)(bVar11 || CARRY4(uVar4,(uint)bVar10));\n  bVar11 = iVar7 != 0;\n  iVar7 = iVar7 + -1;\n  if (bVar11 && 0xfffff < uVar3) goto LAB_080083e0;\n  uVar2 = param_1;\n  uVar4 = uVar3;\n  if (uVar3 == 0) {\n    uVar2 = 0;\n    uVar4 = param_1;\n  }\n  iVar5 = count_leading_zeroes(uVar4);\n  if (uVar3 == 0) {\n    iVar5 = iVar5 + 0x20;\n  }\n  uVar6 = iVar5 - 0xb;\n  bVar12 = SBORROW4(uVar6,0x20);\n  uVar3 = iVar5 - 0x2b;\n  bVar11 = (int)uVar3 < 0;\n  bVar10 = uVar3 == 0;\n  if ((int)uVar6 < 0x20) {\n    bVar12 = SCARRY4(uVar3,0xc);\n    iVar5 = iVar5 + -0x1f;\n    bVar11 = iVar5 < 0;\n    bVar10 = iVar5 == 0;\n    uVar3 = uVar6;\n    if (!bVar10 && bVar11 == bVar12) {\n      uVar2 = uVar4 << (uVar6 & 0xff);\n      uVar4 = uVar4 >> (0xcU - iVar5 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bVar10 || bVar11 != bVar12) {\n    uVar9 = 0x20 - uVar3;\n  }\n  uVar4 = uVar4 << (uVar3 & 0xff);\n  if (bVar10 || bVar11 != bVar12) {\n    uVar4 = uVar4 | uVar2 >> (uVar9 & 0xff);\n  }\n  if (bVar10 || bVar11 != bVar12) {\n    uVar2 = uVar2 << (uVar3 & 0xff);\n  }\nLAB_08008458:\n  if ((int)uVar6 <= iVar7) {\n    return CONCAT44(uVar4 + (iVar7 - uVar6) * 0x100000 | uVar8,uVar2);\n  }\n  uVar3 = ~(iVar7 - uVar6);\n  if ((int)uVar3 < 0x1f) {\n    iVar7 = uVar3 - 0x13;\n    if (iVar7 != 0 && iVar7 < 0 == SCARRY4(uVar3 - 0x1f,0xc)) {\n      return CONCAT44(param_2,uVar2 >> (0x20 - (0xcU - iVar7) & 0xff) |\n                              uVar4 << (0xcU - iVar7 & 0xff)) & 0x80000000ffffffff;\n    }\n    uVar3 = uVar3 + 1;\n    return CONCAT44(uVar8 | uVar4 >> (uVar3 & 0xff),\n                    uVar2 >> (uVar3 & 0xff) | uVar4 << (0x20 - uVar3 & 0xff));\n  }\n  return CONCAT44(param_2,uVar4 >> (uVar3 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080085e4", 
            "calling": [], 
            "imported": false, 
            "current_name": "__aeabi_l2d"
        }, 
        "__kernel_cos": {
            "renaming": {}, 
            "code": "\nundefined4 __kernel_cos(undefined4 param_1,uint param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  longlong lVar8;\n  undefined4 local_30;\n  undefined4 uStack_2c;\n  undefined4 local_28;\n  undefined4 uStack_24;\n  \n  uVar4 = param_2 & 0x7fffffff;\n  if (uVar4 < 0x3e400000) {\n    iVar1 = __aeabi_d2iz();\n    if (iVar1 == 0) {\n      return 0;\n    }\n    uVar5 = __muldf3(param_1,param_2,param_1,param_2);\n    uVar3 = (undefined4)((ulonglong)uVar5 >> 0x20);\n    uVar2 = (undefined4)uVar5;\n    uVar6 = __muldf3(uVar2,uVar3,DAT_0800a558,DAT_0800a55c);\n    uVar6 = __aeabi_dadd((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a560,DAT_0800a564);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n    uVar6 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a568,DAT_0800a56c);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n    uVar6 = __aeabi_dadd((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a570,DAT_0800a574);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n    uVar6 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a578,DAT_0800a57c);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n    uVar6 = __aeabi_dadd((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a580,DAT_0800a584);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n  }\n  else {\n    uVar5 = __muldf3(param_1,param_2,param_1,param_2);\n    uVar3 = (undefined4)((ulonglong)uVar5 >> 0x20);\n    uVar2 = (undefined4)uVar5;\n    uVar6 = __muldf3(uVar2,uVar3,DAT_0800a558,DAT_0800a55c);\n    uVar6 = __aeabi_dadd((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a560,DAT_0800a564);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n    uVar6 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a568,DAT_0800a56c);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n    uVar6 = __aeabi_dadd((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a570,DAT_0800a574);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n    uVar6 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a578,DAT_0800a57c);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n    uVar6 = __aeabi_dadd((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),DAT_0800a580,DAT_0800a584);\n    uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),uVar2,uVar3);\n    if (DAT_0800a590 < (int)uVar4) {\n      if (DAT_0800a594 < (int)uVar4) {\n        lVar8 = (ulonglong)DAT_0800a598 << 0x20;\n        iVar1 = DAT_0800a59c;\n      }\n      else {\n        lVar8 = __subdf3(0,DAT_0800a58c,0,uVar4 - 0x200000);\n        iVar1 = uVar4 - 0x200000;\n      }\n      uStack_24 = (undefined4)((ulonglong)lVar8 >> 0x20);\n      local_28 = (undefined4)lVar8;\n      uVar5 = __muldf3(uVar2,uVar3,0,DAT_0800a588);\n      uVar5 = __subdf3((int)uVar5,(int)((ulonglong)uVar5 >> 0x20),0,iVar1);\n      uVar6 = __muldf3(uVar2,uVar3,(int)uVar6,(int)((ulonglong)uVar6 >> 0x20));\n      uVar7 = __muldf3(param_1,param_2,param_3,param_4);\n      uVar6 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),(int)uVar7,\n                       (int)((ulonglong)uVar7 >> 0x20));\n      uVar5 = __subdf3((int)uVar5,(int)((ulonglong)uVar5 >> 0x20),(int)uVar6,\n                       (int)((ulonglong)uVar6 >> 0x20));\n      uVar2 = __subdf3(local_28,uStack_24,(int)uVar5,(int)((ulonglong)uVar5 >> 0x20));\n      return uVar2;\n    }\n  }\n  uStack_2c = (undefined4)((ulonglong)uVar6 >> 0x20);\n  local_30 = (undefined4)uVar6;\n  uVar2 = (undefined4)((ulonglong)uVar5 >> 0x20);\n  uVar6 = __muldf3((int)uVar5,uVar2,0,DAT_0800a588);\n  uVar5 = __muldf3((int)uVar5,uVar2,local_30,uStack_2c);\n  uVar7 = __muldf3(param_1,param_2,param_3,param_4);\n  uVar5 = __subdf3((int)uVar5,(int)((ulonglong)uVar5 >> 0x20),(int)uVar7,\n                   (int)((ulonglong)uVar7 >> 0x20));\n  uVar5 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),(int)uVar5,\n                   (int)((ulonglong)uVar5 >> 0x20));\n  uVar2 = __subdf3(0,DAT_0800a58c,(int)uVar5,(int)((ulonglong)uVar5 >> 0x20));\n  return uVar2;\n}\n\n", 
            "called": [
                "__aeabi_d2iz", 
                "__muldf3", 
                "__subdf3", 
                "__aeabi_dadd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800a348", 
            "calling": [
                "sin", 
                "cos"
            ], 
            "imported": false, 
            "current_name": "__kernel_cos"
        }, 
        "settings_write_coord_data": {
            "renaming": {}, 
            "code": "\nvoid settings_write_coord_data(uint8_t coord_select,float *coord_data)\n\n{\n  uint16_t addr;\n  \n  memcpy_to_eeprom_with_checksum\n            ((uint)(ushort)((ushort)coord_select * 0xd + 0x200),(char *)coord_data,0xc);\n  return;\n}\n\n", 
            "called": [
                "memcpy_to_eeprom_with_checksum"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004bf4", 
            "calling": [
                "settings_read_coord_data", 
                "gc_execute_line"
            ], 
            "imported": false, 
            "current_name": "settings_write_coord_data"
        }, 
        "HAL_NVIC_ClearPendingIRQ": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)\n\n{\n  NVIC_ClearPendingIRQ(IRQn);\n  return;\n}\n\n", 
            "called": [
                "NVIC_ClearPendingIRQ"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006dfe", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_NVIC_ClearPendingIRQ"
        }, 
        "enable_usart_clock": {
            "renaming": {}, 
            "code": "\nvoid enable_usart_clock(USART_TypeDef *usart)\n\n{\n  if (usart == DAT_08007f38) {\n    *(uint *)(DAT_08007f3c + 0x44) = *(uint *)(DAT_08007f3c + 0x44) | 0x10;\n  }\n  else if (usart == DAT_08007f40) {\n    *(uint *)(DAT_08007f3c + 0x40) = *(uint *)(DAT_08007f3c + 0x40) | 0x20000;\n  }\n  else if (usart == DAT_08007f44) {\n    *(uint *)(DAT_08007f3c + 0x40) = *(uint *)(DAT_08007f3c + 0x40) | 0x40000;\n  }\n  else if (usart == DAT_08007f48) {\n    *(uint *)(DAT_08007f3c + 0x40) = *(uint *)(DAT_08007f3c + 0x40) | 0x80000;\n  }\n  else if (usart == DAT_08007f4c) {\n    *(uint *)(DAT_08007f3c + 0x40) = *(uint *)(DAT_08007f3c + 0x40) | 0x100000;\n  }\n  else if (usart == DAT_08007f50) {\n    *(uint *)(DAT_08007f3c + 0x44) = *(uint *)(DAT_08007f3c + 0x44) | 0x20;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007ea4", 
            "calling": [
                "usart_init"
            ], 
            "imported": false, 
            "current_name": "enable_usart_clock"
        }, 
        "protocol_execute_startup": {
            "renaming": {}, 
            "code": "\nvoid protocol_execute_startup(void)\n\n{\n  uint8_t uVar1;\n  uint8_t n;\n  \n  for (n = '\\0'; n < 2; n = n + '\\x01') {\n    uVar1 = settings_read_startup_line(n,PTR_line_08003a14);\n    if (uVar1 == '\\0') {\n      report_status_message('\\n');\n    }\n    else if (*PTR_line_08003a14 != '\\0') {\n      printString(PTR_line_08003a14);\n      uVar1 = gc_execute_line(PTR_line_08003a14);\n      report_status_message(uVar1);\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "printString", 
                "report_status_message", 
                "settings_read_startup_line", 
                "gc_execute_line"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080039bc", 
            "calling": [
                "grbl_main", 
                "protocol_execute_line"
            ], 
            "imported": false, 
            "current_name": "protocol_execute_startup"
        }, 
        "__errno": {
            "renaming": {}, 
            "code": "\nundefined4 __errno(void)\n\n{\n  return *(undefined4 *)PTR__impure_ptr_0800b3e4;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800b3dc", 
            "calling": [
                "hypot", 
                "sqrt"
            ], 
            "imported": false, 
            "current_name": "__errno"
        }, 
        "HAL_Delay": {
            "renaming": {}, 
            "code": "\nvoid HAL_Delay(uint32_t Delay)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint32_t timingdelay;\n  \n  uVar1 = HAL_GetTick();\n  do {\n    uVar2 = HAL_GetTick();\n  } while (uVar2 < Delay + uVar1);\n  return;\n}\n\n", 
            "called": [
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005a98", 
            "calling": [
                "_delay_ms"
            ], 
            "imported": false, 
            "current_name": "HAL_Delay"
        }, 
        "__aeabi_drsub": {
            "renaming": {}, 
            "code": "\nulonglong __aeabi_drsub(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  bool bVar14;\n  bool bVar15;\n  \n  uVar4 = param_2 ^ 0x80000000;\n  uVar7 = param_2 << 1;\n  uVar9 = param_4 << 1;\n  bVar13 = ((uVar4 ^ param_4) & 0x7fffffff) == 0;\n  bVar14 = bVar13 && param_1 == param_3;\n  if (!bVar13 || param_1 != param_3) {\n    bVar14 = (uVar7 | param_1) == 0;\n  }\n  if (!bVar14) {\n    bVar14 = (uVar9 | param_3) == 0;\n  }\n  iVar6 = (int)uVar7 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar6 == -1;\n  }\n  iVar1 = (int)uVar9 >> 0x15;\n  if (!bVar14) {\n    bVar14 = iVar1 == -1;\n  }\n  if (bVar14) {\n    if (iVar6 == -1 || iVar1 == -1) {\n      uVar9 = param_4;\n      uVar7 = param_3;\n      if (iVar6 == -1) {\n        uVar9 = uVar4;\n        uVar7 = param_1;\n      }\n      if (iVar6 != -1 || iVar1 != -1) {\n        param_3 = uVar7;\n        param_4 = uVar9;\n      }\n      bVar14 = (uVar7 | uVar9 << 0xc) == 0;\n      if (bVar14) {\n        bVar14 = (param_3 | param_4 << 0xc) == 0;\n      }\n      if (bVar14) {\n        bVar14 = uVar9 == param_4;\n      }\n      if (!bVar14) {\n        uVar9 = uVar9 | 0x80000;\n      }\n      return CONCAT44(uVar9,uVar7);\n    }\n    if (((uVar4 ^ param_4) & 0x7fffffff) != 0 || param_1 != param_3) {\n      if ((uVar7 | param_1) == 0) {\n        param_1 = param_3;\n        uVar4 = param_4;\n      }\n      return CONCAT44(uVar4,param_1);\n    }\n    if (uVar4 != param_4) {\n      return 0;\n    }\n    if (uVar7 >> 0x15 == 0) {\n      bVar14 = (param_1 & 0x80000000) != 0;\n      uVar9 = param_2 * 2 + (uint)bVar14;\n      if (CARRY4(uVar4,uVar4) || CARRY4(param_2 * 2,(uint)bVar14)) {\n        uVar9 = uVar9 | 0x80000000;\n      }\n      return CONCAT44(uVar9,param_1 << 1);\n    }\n    if (uVar7 < 0xffc00000) {\n      return CONCAT44(uVar4 + 0x100000,param_1);\n    }\n    uVar4 = uVar4 & 0x80000000;\nLAB_08008514:\n    return (ulonglong)(uVar4 | 0x7ff00000) << 0x20;\n  }\n  uVar7 = uVar7 >> 0x15;\n  uVar9 = uVar9 >> 0x15;\n  uVar10 = uVar9 - uVar7;\n  bVar14 = uVar10 != 0;\n  if (uVar9 < uVar7) {\n    uVar10 = -uVar10;\n  }\n  uVar8 = param_1;\n  uVar12 = uVar4;\n  if (bVar14 && uVar7 <= uVar9) {\n    uVar7 = uVar7 + uVar10;\n    uVar8 = param_3;\n    uVar12 = param_4;\n    param_3 = param_1;\n    param_4 = uVar4;\n  }\n  if (0x36 < uVar10) {\n    return CONCAT44(uVar12,uVar8);\n  }\n  uVar9 = uVar12 & 0xfffff | 0x100000;\n  if ((uVar12 & 0x80000000) != 0) {\n    bVar14 = uVar8 != 0;\n    uVar8 = -uVar8;\n    uVar9 = -uVar9 - (uint)bVar14;\n  }\n  uVar4 = param_4 & 0xfffff | 0x100000;\n  if ((param_4 & 0x80000000) != 0) {\n    bVar14 = param_3 != 0;\n    param_3 = -param_3;\n    uVar4 = -uVar4 - (uint)bVar14;\n  }\n  if (uVar7 == uVar10) {\n    uVar4 = uVar4 ^ 0x100000;\n    if (uVar7 == 0) {\n      uVar9 = uVar9 ^ 0x100000;\n      uVar7 = 1;\n    }\n    else {\n      uVar10 = uVar10 - 1;\n    }\n  }\n  uVar12 = -uVar10 + 0x20;\n  if ((int)uVar10 < 0x21) {\n    uVar11 = param_3 << (uVar12 & 0xff);\n    param_3 = param_3 >> (uVar10 & 0xff);\n    uVar3 = uVar8 + param_3;\n    uVar5 = uVar4 << (uVar12 & 0xff);\n    uVar12 = uVar3 + uVar5;\n    uVar9 = uVar9 + CARRY4(uVar8,param_3) + ((int)uVar4 >> (uVar10 & 0xff)) +\n            (uint)CARRY4(uVar3,uVar5);\n  }\n  else {\n    uVar11 = uVar4 << (-uVar10 + 0x40 & 0xff);\n    if (param_3 != 0) {\n      uVar11 = uVar11 | 2;\n    }\n    uVar4 = (int)uVar4 >> (uVar10 - 0x20 & 0xff);\n    uVar12 = uVar8 + uVar4;\n    uVar9 = uVar9 + ((int)uVar4 >> 0x1f) + (uint)CARRY4(uVar8,uVar4);\n  }\n  uVar4 = uVar9 & 0x80000000;\n  uVar10 = uVar9;\n  if ((int)uVar9 < 0) {\n    bVar14 = uVar11 == 0;\n    uVar11 = -uVar11;\n    uVar10 = -uVar12;\n    uVar12 = -(uint)!bVar14 - uVar12;\n    uVar10 = -(uint)(bVar14 <= uVar10) - uVar9;\n  }\n  if (0xfffff < uVar10) {\n    uVar8 = uVar7 - 1;\n    if (0x1fffff < uVar10) {\n      uVar9 = uVar10 & 1;\n      uVar10 = uVar10 >> 1;\n      bVar2 = (byte)uVar12;\n      uVar12 = (uint)(uVar9 != 0) << 0x1f | uVar12 >> 1;\n      uVar11 = (uint)(bVar2 & 1) << 0x1f | uVar11 >> 1;\n      uVar8 = uVar7;\n      if (0xffbfffff < uVar7 * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    bVar14 = 0x7fffffff < uVar11;\n    if (uVar11 == 0x80000000) {\n      bVar14 = (uVar12 & 1) != 0;\n    }\n    return CONCAT44(uVar10 + uVar8 * 0x100000 + (uint)CARRY4(uVar12,(uint)bVar14) | uVar4,\n                    uVar12 + bVar14);\n  }\n  bVar13 = (uVar11 & 0x80000000) != 0;\n  uVar11 = uVar11 << 1;\n  uVar8 = uVar12 * 2;\n  bVar14 = CARRY4(uVar12,uVar12);\n  uVar12 = uVar12 * 2 + (uint)bVar13;\n  uVar10 = uVar10 * 2 + (uint)(bVar14 || CARRY4(uVar8,(uint)bVar13));\n  uVar8 = uVar7 - 2;\n  if (uVar7 - 1 != 0 && 0xfffff < uVar10) goto LAB_080083e0;\n  uVar3 = uVar12;\n  uVar7 = uVar10;\n  if (uVar10 == 0) {\n    uVar3 = 0;\n    uVar7 = uVar12;\n  }\n  iVar6 = count_leading_zeroes(uVar7);\n  if (uVar10 == 0) {\n    iVar6 = iVar6 + 0x20;\n  }\n  uVar12 = iVar6 - 0xb;\n  bVar15 = SBORROW4(uVar12,0x20);\n  uVar10 = iVar6 - 0x2b;\n  bVar14 = (int)uVar10 < 0;\n  bVar13 = uVar10 == 0;\n  if ((int)uVar12 < 0x20) {\n    bVar15 = SCARRY4(uVar10,0xc);\n    iVar6 = iVar6 + -0x1f;\n    bVar14 = iVar6 < 0;\n    bVar13 = iVar6 == 0;\n    uVar10 = uVar12;\n    if (!bVar13 && bVar14 == bVar15) {\n      uVar3 = uVar7 << (uVar12 & 0xff);\n      uVar7 = uVar7 >> (0xcU - iVar6 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar11 = 0x20 - uVar10;\n  }\n  uVar7 = uVar7 << (uVar10 & 0xff);\n  if (bVar13 || bVar14 != bVar15) {\n    uVar7 = uVar7 | uVar3 >> (uVar11 & 0xff);\n  }\n  if (bVar13 || bVar14 != bVar15) {\n    uVar3 = uVar3 << (uVar10 & 0xff);\n  }\nLAB_08008458:\n  if ((int)uVar12 <= (int)uVar8) {\n    return CONCAT44(uVar7 + (uVar8 - uVar12) * 0x100000 | uVar4,uVar3);\n  }\n  uVar10 = ~(uVar8 - uVar12);\n  if ((int)uVar10 < 0x1f) {\n    iVar6 = uVar10 - 0x13;\n    if (iVar6 != 0 && iVar6 < 0 == SCARRY4(uVar10 - 0x1f,0xc)) {\n      return CONCAT44(uVar9,uVar3 >> (0x20 - (0xcU - iVar6) & 0xff) | uVar7 << (0xcU - iVar6 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    uVar10 = uVar10 + 1;\n    return CONCAT44(uVar4 | uVar7 >> (uVar10 & 0xff),\n                    uVar3 >> (uVar10 & 0xff) | uVar7 << (0x20 - uVar10 & 0xff));\n  }\n  return CONCAT44(uVar9,uVar7 >> (uVar10 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n", 
            "called": [
                "__aeabi_dadd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080082c8", 
            "calling": [], 
            "imported": false, 
            "current_name": "__aeabi_drsub"
        }, 
        "g540_timer_start": {
            "renaming": {}, 
            "code": "\nvoid g540_timer_start(void)\n\n{\n  uint *puVar1;\n  TIM_TypeDef *TIMx;\n  \n  puVar1 = DAT_08007dd4;\n  DAT_08007dd4[8] = DAT_08007dd4[8] | 0x10;\n  *puVar1 = *puVar1 | 1;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007da8", 
            "calling": [
                "timers_init"
            ], 
            "imported": false, 
            "current_name": "g540_timer_start"
        }, 
        "__floatunsisf": {
            "renaming": {}, 
            "code": "\nuint __floatunsisf(uint param_1)\n\n{\n  int iVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  iVar1 = count_leading_zeroes(param_1);\n  uVar2 = iVar1 - 8;\n  iVar3 = uVar2 * -0x800000 + 0x4a800000;\n  if (7 < iVar1) {\n    uVar4 = 0 << (uVar2 & 0xff);\n    uVar2 = iVar3 + (param_1 << (uVar2 & 0xff)) +\n            (0U >> (0x20 - uVar2 & 0xff)) + (uint)(0x7fffffff < uVar4);\n    if (uVar4 == 0x80000000) {\n      uVar2 = uVar2 & 0xfffffffe;\n    }\n    return uVar2;\n  }\n  uVar4 = param_1 << (iVar1 + 0x18U & 0xff);\n  uVar2 = iVar3 + ((param_1 >> (0x20 - (iVar1 + 0x18U) & 0xff)) - ((int)uVar4 >> 0x1f));\n  if ((uVar4 & 0x7fffffff) == 0) {\n    uVar2 = uVar2 & ~(uVar4 >> 0x1f);\n  }\n  return uVar2;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008e3c", 
            "calling": [
                "calculate_trapezoid_for_block", 
                "read_float"
            ], 
            "imported": false, 
            "current_name": "__floatunsisf"
        }, 
        "enable_tim_interrupt": {
            "renaming": {}, 
            "code": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nvoid enable_tim_interrupt(TIM_TypeDef *tim,uint32_t pre,uint32_t sub)\n\n{\n  uint32_t irq;\n  \n  if (tim == (TIM_TypeDef *)&DAT_40000000) {\n    irq._0_1_ = TIM2_IRQn;\n  }\n  else if (tim == DAT_08007ac8) {\n    irq._0_1_ = TIM3_IRQn;\n  }\n  else {\n    if (tim != DAT_08007acc) {\n      return;\n    }\n    irq._0_1_ = TIM4_IRQn;\n  }\n  HAL_NVIC_SetPriority((IRQn_Type)irq,pre,sub);\n  NVIC_EnableIRQ((IRQn_Type)irq);\n  return;\n}\n\n", 
            "called": [
                "HAL_NVIC_SetPriority", 
                "NVIC_EnableIRQ"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007a70", 
            "calling": [
                "step_timer_init"
            ], 
            "imported": false, 
            "current_name": "enable_tim_interrupt"
        }, 
        "HAL_EnableCompensationCell": {
            "renaming": {}, 
            "code": "\nvoid HAL_EnableCompensationCell(void)\n\n{\n  *DAT_08005bc0 = 1;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005bac", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_EnableCompensationCell"
        }, 
        "limits_go_home": {
            "renaming": {}, 
            "code": "\nvoid limits_go_home(void)\n\n{\n  char cVar1;\n  float homing_rate;\n  float homing_rate_00;\n  float extraout_s0;\n  float homing_rate_01;\n  float extraout_s0_00;\n  float homing_rate_02;\n  int8_t n_cycle;\n  \n  st_wake_up();\n  homing_cycle('\\x04','\\x01',false,homing_rate);\n  homing_cycle('\\x03','\\x01',false,homing_rate_00);\n  delay_ms(*(uint16_t *)(PTR_settings_08001dd8 + 0x34));\n  n_cycle = '\\x02';\n  homing_rate_02 = extraout_s0;\n  while (cVar1 = n_cycle + -1, n_cycle != '\\0') {\n    homing_cycle('\\a','\\0',true,homing_rate_02);\n    delay_ms(*(uint16_t *)(PTR_settings_08001dd8 + 0x34));\n    homing_rate_02 = homing_rate_01;\n    n_cycle = cVar1;\n    if ('\\0' < cVar1) {\n      homing_cycle('\\a','\\x01',false,homing_rate_01);\n      delay_ms(*(uint16_t *)(PTR_settings_08001dd8 + 0x34));\n      homing_rate_02 = extraout_s0_00;\n    }\n  }\n  st_go_idle();\n  return;\n}\n\n", 
            "called": [
                "homing_cycle", 
                "st_wake_up", 
                "st_go_idle", 
                "delay_ms"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001d4c", 
            "calling": [
                "mc_go_home"
            ], 
            "imported": false, 
            "current_name": "limits_go_home"
        }, 
        "prev_block_index": {
            "renaming": {}, 
            "code": "\nuint8_t prev_block_index(uint8_t block_index)\n\n{\n  uint8_t local_9;\n  \n  local_9 = block_index;\n  if (block_index == '\\0') {\n    local_9 = '\\x12';\n  }\n  return local_9 + 0xff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002896", 
            "calling": [
                "planner_reverse_pass"
            ], 
            "imported": false, 
            "current_name": "prev_block_index"
        }, 
        "gc_execute_line": {
            "renaming": {}, 
            "code": "\nuint8_t gc_execute_line(char *line)\n\n{\n  undefined *puVar1;\n  undefined uVar2;\n  uint8_t uVar3;\n  int iVar4;\n  float fVar5;\n  undefined4 uVar6;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined4 extraout_r1_03;\n  undefined4 extraout_r1_04;\n  uint uVar7;\n  float fVar8;\n  float value_00;\n  float seconds;\n  undefined8 extraout_d0;\n  undefined8 extraout_d0_00;\n  undefined8 extraout_d0_01;\n  undefined8 extraout_d0_02;\n  undefined8 extraout_d0_03;\n  undefined8 uVar9;\n  undefined8 extraout_d0_04;\n  undefined8 extraout_d0_05;\n  float extraout_s2;\n  float extraout_s2_00;\n  float extraout_s2_01;\n  float extraout_s2_02;\n  float extraout_s2_03;\n  float extraout_s2_04;\n  float extraout_s2_05;\n  float extraout_s3;\n  float extraout_s3_00;\n  float extraout_s3_01;\n  float extraout_s3_02;\n  float extraout_s3_03;\n  float extraout_s3_04;\n  float extraout_s3_05;\n  undefined4 in_stack_ffffff48;\n  undefined4 in_stack_ffffff4c;\n  float coord_data_2 [3];\n  float coord_data_1 [3];\n  float coord_data [3];\n  float offset [3];\n  float target [3];\n  float value;\n  char letter;\n  uint8_t char_counter;\n  float y;\n  float x;\n  uint8_t isclockwise;\n  float h_x2_div_d;\n  uint8_t i_3;\n  uint8_t i_2;\n  uint8_t i_1;\n  uint8_t i;\n  uint8_t l;\n  float r;\n  float p;\n  uint8_t group_number;\n  uint8_t non_modal_action;\n  uint8_t absolute_override;\n  float inverse_feed_rate;\n  uint8_t axis_words;\n  uint16_t modal_group_words;\n  int int_value;\n  \n  if (PTR_sys_08000808[1] == '\\x06') {\n    uVar3 = '\\f';\n  }\n  else {\n    char_counter = '\\0';\n    modal_group_words = 0;\n    axis_words = '\\0';\n    inverse_feed_rate = DAT_0800080c;\n    absolute_override = '\\0';\n    non_modal_action = '\\0';\n    memset(target,0,0xc);\n    memset(offset,0,0xc);\n    *PTR_gc_08000810 = 0;\n    group_number = '\\0';\n    while (iVar4 = next_statement(&letter,&value,line,&char_counter), iVar4 != 0) {\n      uVar6 = __aeabi_f2d(value);\n      trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n      int_value = __aeabi_d2iz(uVar6,extraout_r1);\n      if (letter == 'G') {\n        switch(int_value) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 0x50:\n          group_number = '\\x02';\n          break;\n        case 4:\n        case 10:\n        case 0x1c:\n        case 0x1e:\n        case 0x35:\n        case 0x5c:\n          group_number = '\\x01';\n          break;\n        case 0x11:\n        case 0x12:\n        case 0x13:\n          group_number = '\\x03';\n          break;\n        case 0x14:\n        case 0x15:\n          group_number = '\\a';\n          break;\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n          group_number = '\\t';\n          break;\n        case 0x5a:\n        case 0x5b:\n          group_number = '\\x04';\n          break;\n        case 0x5d:\n        case 0x5e:\n          group_number = '\\x06';\n        }\n        switch(int_value) {\n        case 0:\n          PTR_gc_08000ca0[1] = 0;\n          break;\n        case 1:\n          PTR_gc_08000ca0[1] = 1;\n          break;\n        case 2:\n          PTR_gc_08000ca0[1] = 2;\n          break;\n        case 3:\n          PTR_gc_08000ca0[1] = 3;\n          break;\n        case 4:\n          non_modal_action = '\\x01';\n          break;\n        default:\n          *PTR_gc_08000ca0 = 3;\n          break;\n        case 10:\n          non_modal_action = '\\x02';\n          break;\n        case 0x11:\n          select_plane('\\0','\\x01','\\x02');\n          break;\n        case 0x12:\n          select_plane('\\x02','\\0','\\x01');\n          break;\n        case 0x13:\n          select_plane('\\x01','\\x02','\\0');\n          break;\n        case 0x14:\n          PTR_gc_08000ca0[3] = 1;\n          break;\n        case 0x15:\n          PTR_gc_08000ca0[3] = 0;\n          break;\n        case 0x1c:\n        case 0x1e:\n          uVar6 = __aeabi_fmul(value,DAT_08000ca4);\n          uVar6 = __aeabi_f2d(uVar6);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          int_value = __aeabi_d2iz(uVar6,extraout_r1_00);\n          switch(int_value) {\n          case 0x118:\n            non_modal_action = '\\x03';\n            break;\n          case 0x119:\n            non_modal_action = '\\x04';\n            break;\n          default:\n            *PTR_gc_08000ca0 = 3;\n            break;\n          case 300:\n            non_modal_action = '\\x05';\n            break;\n          case 0x12d:\n            non_modal_action = '\\x06';\n          }\n          break;\n        case 0x35:\n          absolute_override = '\\x01';\n          break;\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n          PTR_gc_08000ca0[0x1c] = (char)int_value + -0x36;\n          break;\n        case 0x50:\n          PTR_gc_08000ca0[1] = 4;\n          break;\n        case 0x5a:\n          PTR_gc_08000ca0[4] = 1;\n          break;\n        case 0x5b:\n          PTR_gc_08000ca0[4] = 0;\n          break;\n        case 0x5c:\n          uVar6 = __aeabi_fmul(value,DAT_08000ca4);\n          uVar6 = __aeabi_f2d(uVar6);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          int_value = __aeabi_d2iz(uVar6,extraout_r1_01);\n          if (int_value == 0x398) {\n            non_modal_action = '\\a';\n          }\n          else if (int_value == 0x399) {\n            non_modal_action = '\\b';\n          }\n          else {\n            *PTR_gc_08000ca0 = 3;\n          }\n          break;\n        case 0x5d:\n          PTR_gc_08000ca0[2] = 1;\n          break;\n        case 0x5e:\n          PTR_gc_08000ca0[2] = 0;\n        }\n      }\n      else if (letter == 'M') {\n        if (int_value == 0x1e) {\nLAB_08000b96:\n          group_number = '\\x05';\n        }\n        else if (int_value < 0x1f) {\n          if (int_value < 3) {\n            if (-1 < int_value) goto LAB_08000b96;\n          }\n          else if (int_value - 3U < 3) {\n            group_number = '\\b';\n          }\n        }\n        switch(int_value) {\n        case 0:\n          PTR_gc_08000ca0[5] = 1;\n          break;\n        case 1:\n          break;\n        case 2:\n        case 0x1e:\n          PTR_gc_08000ca0[5] = 2;\n          break;\n        case 3:\n          PTR_gc_08000ca0[6] = 1;\n          break;\n        case 4:\n          PTR_gc_08000ca0[6] = 0xff;\n          break;\n        case 5:\n          PTR_gc_08000ca0[6] = 0;\n          break;\n        default:\n          *PTR_gc_08000ca0 = 3;\n          break;\n        case 7:\n          PTR_gc_08000ca0[7] = 2;\n          break;\n        case 8:\n          PTR_gc_08000ca0[7] = 1;\n          break;\n        case 9:\n          PTR_gc_08000ca0[7] = 0;\n        }\n      }\n      if (group_number != '\\0') {\n        if (((int)(uint)modal_group_words >> group_number & 1U) == 0) {\n          modal_group_words = modal_group_words | (ushort)(1 << group_number);\n        }\n        else {\n          *PTR_gc_08000ca0 = 5;\n        }\n        group_number = '\\0';\n      }\n    }\n    if (*PTR_gc_08000ff0 == '\\0') {\n      p = 0.0;\n      r = 0.0;\n      l = '\\0';\n      char_counter = '\\0';\nswitchD_08000d18_caseD_47:\n      iVar4 = next_statement(&letter,&value,line,&char_counter);\n      if (iVar4 != 0) {\n        fVar8 = (float)extraout_d0;\n        switch(letter) {\n        case 'F':\n          iVar4 = __aeabi_fcmple(value,0);\n          if (iVar4 != 0) {\n            *PTR_gc_08000ff0 = 6;\n          }\n          if (PTR_gc_08000ff0[2] == '\\0') {\n            fVar8 = value;\n            to_millimeters(value_00);\n            *(float *)(PTR_gc_08000ff0 + 8) = fVar8;\n          }\n          else {\n            fVar8 = value;\n            to_millimeters(value_00);\n            inverse_feed_rate = fVar8;\n          }\n          break;\n        case 'G':\n        case 'M':\n        case 'N':\n          break;\n        default:\n          *PTR_gc_08000ff0 = 3;\n          break;\n        case 'I':\n        case 'J':\n        case 'K':\n          uVar7 = (uint)(byte)letter;\n          fVar5 = value;\n          to_millimeters(fVar8);\n          offset[uVar7 - 0x49] = fVar5;\n          break;\n        case 'L':\n          uVar6 = __aeabi_f2d(value);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          l = __aeabi_d2uiz(uVar6,extraout_r1_02);\n          break;\n        case 'P':\n          p = value;\n          break;\n        case 'R':\n          fVar5 = value;\n          to_millimeters(fVar8);\n          r = fVar5;\n          break;\n        case 'S':\n          iVar4 = __aeabi_fcmplt(value,0);\n          if (iVar4 != 0) {\n            *PTR_gc_08000ff0 = 6;\n          }\n          break;\n        case 'T':\n          iVar4 = __aeabi_fcmplt(value,0);\n          if (iVar4 != 0) {\n            *PTR_gc_08000ff0 = 6;\n          }\n          uVar6 = __aeabi_f2d(value);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          uVar2 = __aeabi_d2uiz(uVar6,extraout_r1_03);\n          PTR_gc_08000ff0[0x18] = uVar2;\n          break;\n        case 'X':\n          target[0] = value;\n          to_millimeters(fVar8);\n          axis_words = axis_words | 1;\n          break;\n        case 'Y':\n          target[1] = value;\n          to_millimeters(fVar8);\n          axis_words = axis_words | 2;\n          break;\n        case 'Z':\n          target[2] = value;\n          to_millimeters(fVar8);\n          axis_words = axis_words | 4;\n        }\n        goto switchD_08000d18_caseD_47;\n      }\n      if (*PTR_gc_08000ff0 == '\\0') {\n        uVar9 = extraout_d0;\n        fVar8 = extraout_s2;\n        fVar5 = extraout_s3;\n        if (PTR_sys_08000ff4[1] != '\\a') {\n          spindle_run(PTR_gc_08000ff0[6]);\n          coolant_run(PTR_gc_08000ff0[7]);\n          uVar9 = extraout_d0_00;\n          fVar8 = extraout_s2_00;\n          fVar5 = extraout_s3_00;\n        }\n        if ((modal_group_words & 0x200) != 0) {\n          uVar3 = settings_read_coord_data(PTR_gc_08000ff0[0x1c],coord_data);\n          puVar1 = PTR_gc_08000ff0;\n          if (uVar3 == '\\0') {\n            return '\\n';\n          }\n          *(float *)(PTR_gc_08000ff0 + 0x20) = coord_data[0];\n          *(float *)(puVar1 + 0x24) = coord_data[1];\n          *(float *)(puVar1 + 0x28) = coord_data[2];\n          uVar9 = extraout_d0_01;\n          fVar8 = extraout_s2_01;\n          fVar5 = extraout_s3_01;\n        }\n        switch(non_modal_action) {\n        case '\\x01':\n          iVar4 = __aeabi_fcmplt(p,0);\n          if (iVar4 == 0) {\n            if (PTR_sys_08000ff4[1] != '\\a') {\n              mc_dwell(seconds);\n            }\n          }\n          else {\n            *PTR_gc_08000ff0 = 6;\n          }\n          break;\n        case '\\x02':\n          uVar6 = __aeabi_f2d(p);\n          trunc((double)CONCAT44(in_stack_ffffff4c,in_stack_ffffff48));\n          int_value = __aeabi_d2iz(uVar6,extraout_r1_04);\n          if ((((l == '\\x02') || (l == '\\x14')) && (-1 < int_value)) && (int_value < 7)) {\n            if ((axis_words == '\\0') && (l == '\\x02')) {\n              *PTR_gc_08000ff0 = 6;\n            }\n            else {\n              if (int_value < 1) {\n                int_value = (int)(byte)PTR_gc_08001304[0x1c];\n              }\n              else {\n                int_value = int_value + -1;\n              }\n              uVar3 = settings_read_coord_data((uint8_t)int_value,coord_data_2);\n              if (uVar3 == '\\0') {\n                return '\\n';\n              }\n              for (i = '\\0'; i < 3; i = i + '\\x01') {\n                if (((int)(uint)axis_words >> i & 1U) != 0) {\n                  if (l == '\\x14') {\n                    uVar7 = (uint)i;\n                    fVar8 = (float)__aeabi_fsub(*(undefined4 *)(PTR_gc_08001304 + (i + 2) * 4 + 4),\n                                                target[i]);\n                    coord_data_2[uVar7] = fVar8;\n                  }\n                  else {\n                    coord_data_2[i] = target[i];\n                  }\n                }\n              }\n              settings_write_coord_data((uint8_t)int_value,coord_data_2);\n              puVar1 = PTR_gc_08001304;\n              if (int_value == (uint)(byte)PTR_gc_08001304[0x1c]) {\n                *(float *)(PTR_gc_08001304 + 0x20) = coord_data_2[0];\n                *(float *)(puVar1 + 0x24) = coord_data_2[1];\n                *(float *)(puVar1 + 0x28) = coord_data_2[2];\n              }\n            }\n          }\n          else {\n            *PTR_gc_08000ff0 = 3;\n          }\n          axis_words = '\\0';\n          break;\n        case '\\x03':\n        case '\\x05':\n          if (axis_words != '\\0') {\n            for (i_1 = '\\0'; i_1 < 3; i_1 = i_1 + '\\x01') {\n              if (((int)(uint)axis_words >> i_1 & 1U) == 0) {\n                target[i_1] = *(float *)(PTR_gc_08001304 + (i_1 + 2) * 4 + 4);\n              }\n              else if (PTR_gc_08001304[4] == '\\0') {\n                uVar7 = (uint)i_1;\n                fVar8 = (float)__addsf3(target[i_1],\n                                        *(undefined4 *)(PTR_gc_08001304 + (i_1 + 2) * 4 + 4));\n                target[uVar7] = fVar8;\n                uVar9 = extraout_d0_03;\n                fVar8 = extraout_s2_03;\n                fVar5 = extraout_s3_03;\n              }\n              else {\n                fVar8 = target[i_1];\n                uVar6 = __addsf3(*(undefined4 *)(PTR_gc_08001304 + (i_1 + 8) * 4),\n                                 *(undefined4 *)(PTR_gc_08001304 + (i_1 + 10) * 4 + 4));\n                uVar7 = (uint)i_1;\n                fVar8 = (float)__addsf3(fVar8,uVar6);\n                target[uVar7] = fVar8;\n                uVar9 = extraout_d0_02;\n                fVar8 = extraout_s2_02;\n                fVar5 = extraout_s3_02;\n              }\n            }\n            mc_line((float)uVar9,(float)((ulonglong)uVar9 >> 0x20),fVar8,fVar5,SUB41(target[0],0));\n          }\n          if (non_modal_action == '\\x05') {\n            uVar3 = settings_read_coord_data('\\a',coord_data_1);\n            uVar9 = extraout_d0_04;\n            fVar8 = extraout_s2_04;\n            fVar5 = extraout_s3_04;\n            if (uVar3 == '\\0') {\n              return '\\n';\n            }\n          }\n          else {\n            uVar3 = settings_read_coord_data('\\x06',coord_data_1);\n            uVar9 = extraout_d0_05;\n            fVar8 = extraout_s2_05;\n            fVar5 = extraout_s3_05;\n            if (uVar3 == '\\0') {\n              return '\\n';\n            }\n          }\n          mc_line((float)uVar9,(float)((ulonglong)uVar9 >> 0x20),fVar8,fVar5,\n                  SUB41(coord_data_1[0],0));\n          puVar1 = PTR_gc_08001304;\n          *(float *)(PTR_gc_08001304 + 0xc) = coord_data_1[0];\n          *(float *)(puVar1 + 0x10) = coord_data_1[1];\n          *(float *)(puVar1 + 0x14) = coord_data_1[2];\n          axis_words = '\\0';\n          break;\n        case '\\x04':\n        case '\\x06':\n          if (non_modal_action == '\\x06') {\n            settings_write_coord_data('\\a',DAT_0800130c);\n          }\n          else {\n            settings_write_coord_data('\\x06',DAT_0800130c);\n          }\n          break;\n        case '\\a':\n          if (axis_words == '\\0') {\n            *PTR_gc_08001304 = 6;\n          }\n          else {\n            for (i_2 = '\\0'; i_2 < 3; i_2 = i_2 + '\\x01') {\n              if (((int)(uint)axis_words >> i_2 & 1U) != 0) {\n                uVar6 = __aeabi_fsub(*(undefined4 *)(PTR_gc_08001304 + (i_2 + 2) * 4 + 4),\n                                     *(undefined4 *)(PTR_gc_08001304 + (i_2 + 8) * 4));\n                uVar7 = (uint)i_2;\n                uVar6 = __aeabi_fsub(uVar6,target[i_2]);\n                *(undefined4 *)(PTR_gc_08001304 + (uVar7 + 10) * 4 + 4) = uVar6;\n              }\n            }\n          }\n          axis_words = '\\0';\n          break;\n        case '\\b':\n          memset(DAT_08001310,0,0xc);\n        }\n        if (((modal_group_words & 4) != 0) || (axis_words != '\\0')) {\n          if ((PTR_gc_08001574[2] != '\\0') &&\n             ((iVar4 = __aeabi_fcmplt(inverse_feed_rate,0), iVar4 != 0 &&\n              (PTR_gc_08001574[1] != '\\x04')))) {\n            *PTR_gc_08001574 = 6;\n          }\n          if (((absolute_override != '\\0') && (PTR_gc_08001574[1] != '\\0')) &&\n             (PTR_gc_08001574[1] != '\\x01')) {\n            *PTR_gc_08001574 = 6;\n          }\n          if (*PTR_gc_08001574 != '\\0') {\n            return *PTR_gc_08001574;\n          }\n          for (i_3 = '\\0'; puVar1 = PTR_gc_08001840, i_3 < 3; i_3 = i_3 + '\\x01') {\n            if (((int)(uint)axis_words >> i_3 & 1U) == 0) {\n              target[i_3] = *(float *)(PTR_gc_08001574 + (i_3 + 2) * 4 + 4);\n            }\n            else if (absolute_override == '\\0') {\n              if (PTR_gc_08001574[4] == '\\0') {\n                uVar7 = (uint)i_3;\n                fVar8 = (float)__addsf3(target[i_3],\n                                        *(undefined4 *)(PTR_gc_08001574 + (i_3 + 2) * 4 + 4));\n                target[uVar7] = fVar8;\n              }\n              else {\n                fVar8 = target[i_3];\n                uVar6 = __addsf3(*(undefined4 *)(PTR_gc_08001574 + (i_3 + 8) * 4),\n                                 *(undefined4 *)(PTR_gc_08001574 + (i_3 + 10) * 4 + 4));\n                uVar7 = (uint)i_3;\n                fVar8 = (float)__addsf3(fVar8,uVar6);\n                target[uVar7] = fVar8;\n              }\n            }\n          }\n          if ((byte)PTR_gc_08001574[1] < 5) {\n                    /* WARNING: Could not recover jumptable at 0x08001474. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n            uVar3 = (*(code *)(&switchD_08001474::switchdataD_08001478)[(byte)PTR_gc_08001574[1]])()\n            ;\n            return uVar3;\n          }\n          if (*PTR_gc_08001840 != '\\0') {\n            return *PTR_gc_08001840;\n          }\n          *(float *)(PTR_gc_08001840 + 0xc) = target[0];\n          *(float *)(puVar1 + 0x10) = target[1];\n          *(float *)(puVar1 + 0x14) = target[2];\n        }\n        if (PTR_gc_08001840[5] != '\\0') {\n          plan_synchronize();\n          PTR_sys_08001848[0x10] = 0;\n          if (PTR_gc_08001840[5] == '\\x02') {\n            mc_reset();\n          }\n          else {\n            PTR_gc_08001840[5] = 0;\n          }\n        }\n        uVar3 = *PTR_gc_08001840;\n      }\n      else {\n        uVar3 = *PTR_gc_08000ff0;\n      }\n    }\n    else {\n      uVar3 = *PTR_gc_08000ff0;\n    }\n  }\n  return uVar3;\n}\n\n", 
            "called": [
                "__aeabi_d2iz", 
                "coolant_run", 
                "settings_write_coord_data", 
                "select_plane", 
                "settings_read_coord_data", 
                "memset", 
                "__aeabi_fcmpeq", 
                "__divdf3", 
                "mc_arc", 
                "spindle_run", 
                "__aeabi_fsub", 
                "mc_reset", 
                "mc_line", 
                "hypot", 
                "__aeabi_fmul", 
                "to_millimeters", 
                "sqrt", 
                "__addsf3", 
                "__truncdfsf2", 
                "__aeabi_f2d", 
                "next_statement", 
                "__aeabi_d2uiz", 
                "mc_dwell", 
                "plan_synchronize", 
                "__aeabi_fcmple", 
                "trunc", 
                "__aeabi_fcmplt"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080005b4", 
            "calling": [
                "protocol_execute_startup", 
                "protocol_execute_line"
            ], 
            "imported": false, 
            "current_name": "gc_execute_line"
        }, 
        "spindle_fwd": {
            "renaming": {}, 
            "code": "\nvoid spindle_fwd(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005220", 
            "calling": [
                "spindle_run"
            ], 
            "imported": false, 
            "current_name": "spindle_fwd"
        }, 
        "coolant_mist_on": {
            "renaming": {}, 
            "code": "\nvoid coolant_mist_on(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080001e0", 
            "calling": [
                "coolant_run"
            ], 
            "imported": false, 
            "current_name": "coolant_mist_on"
        }, 
        "MemManage_Handler": {
            "renaming": {}, 
            "code": "\nvoid MemManage_Handler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007720", 
            "calling": [], 
            "imported": false, 
            "current_name": "MemManage_Handler"
        }, 
        "planner_forward_pass": {
            "renaming": {}, 
            "code": "\nvoid planner_forward_pass(void)\n\n{\n  block_t *previous;\n  block_t *next;\n  block_t *block [3];\n  uint8_t block_index;\n  \n  block_index = *PTR_block_buffer_tail_08002c0c;\n  block[1] = (block_t *)0x0;\n  block[2] = (block_t *)0x0;\n  while (previous = block[1], block_index != *PTR_block_buffer_head_08002c14) {\n    block[1] = block[2];\n    next = (block_t *)(PTR_block_buffer_08002c10 + (uint)block_index * 0x40);\n    planner_forward_pass_kernel(previous,block[2],next);\n    block_index = next_block_index(block_index);\n    block[2] = next;\n  }\n  planner_forward_pass_kernel(block[1],block[2],(block_t *)0x0);\n  return;\n}\n\n", 
            "called": [
                "next_block_index", 
                "planner_forward_pass_kernel"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002ba8", 
            "calling": [
                "planner_recalculate"
            ], 
            "imported": false, 
            "current_name": "planner_forward_pass"
        }, 
        "gpio_clr": {
            "renaming": {}, 
            "code": "\nvoid gpio_clr(int n)\n\n{\n  *(short *)((n >> 4) * 0x400 + 0x4002001a) = (short)(1 << (n & 0xfU));\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080073d4", 
            "calling": [
                "debounce_off_handler"
            ], 
            "imported": false, 
            "current_name": "gpio_clr"
        }, 
        "enable_tim_clock": {
            "renaming": {}, 
            "code": "\nvoid enable_tim_clock(TIM_TypeDef *tim)\n\n{\n  if (tim == (TIM_TypeDef *)&DAT_40000000) {\n    *(uint *)(DAT_08007a64 + 0x40) = *(uint *)(DAT_08007a64 + 0x40) | 1;\n  }\n  else if (tim == DAT_08007a68) {\n    *(uint *)(DAT_08007a64 + 0x40) = *(uint *)(DAT_08007a64 + 0x40) | 2;\n  }\n  else if (tim == DAT_08007a6c) {\n    *(uint *)(DAT_08007a64 + 0x40) = *(uint *)(DAT_08007a64 + 0x40) | 4;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007a10", 
            "calling": [
                "step_timer_init", 
                "g540_timer_init"
            ], 
            "imported": false, 
            "current_name": "enable_tim_clock"
        }, 
        "set_baud_rate": {
            "renaming": {}, 
            "code": "\nvoid set_baud_rate(USART_TypeDef *usart,int baud)\n\n{\n  ulonglong uVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  \n  if ((usart->CR1 & 0x8000) == 0) {\n    if ((usart == DAT_08008184) || (usart == DAT_08008188)) {\n      uVar2 = HAL_RCC_GetPCLK2Freq();\n      uVar1 = (ulonglong)DAT_0800818c;\n      uVar3 = HAL_RCC_GetPCLK2Freq();\n      uVar4 = HAL_RCC_GetPCLK2Freq();\n      usart->BRR = (uint)(uVar1 * ((ulonglong)(uVar2 * 0x19) / (ulonglong)(uint)(baud << 2)) >> 0x25\n                         ) << 4 |\n                   (uint)((ulonglong)DAT_0800818c *\n                          (ulonglong)\n                          (((uVar3 * 0x19) / (uint)(baud << 2) +\n                           (uint)((ulonglong)DAT_0800818c *\n                                  ((ulonglong)(uVar4 * 0x19) / (ulonglong)(uint)(baud << 2)) >> 0x25\n                                 ) * -100) * 0x10 + 0x32) >> 0x25) & 0xf;\n    }\n    else {\n      uVar2 = HAL_RCC_GetPCLK1Freq();\n      uVar1 = (ulonglong)DAT_0800818c;\n      uVar3 = HAL_RCC_GetPCLK1Freq();\n      uVar4 = HAL_RCC_GetPCLK1Freq();\n      usart->BRR = (uint)(uVar1 * ((ulonglong)(uVar2 * 0x19) / (ulonglong)(uint)(baud << 2)) >> 0x25\n                         ) << 4 |\n                   (uint)((ulonglong)DAT_0800818c *\n                          (ulonglong)\n                          (((uVar3 * 0x19) / (uint)(baud << 2) +\n                           (uint)((ulonglong)DAT_0800818c *\n                                  ((ulonglong)(uVar4 * 0x19) / (ulonglong)(uint)(baud << 2)) >> 0x25\n                                 ) * -100) * 0x10 + 0x32) >> 0x25) & 0xf;\n    }\n  }\n  else if ((usart == DAT_08008184) || (usart == DAT_08008188)) {\n    uVar2 = HAL_RCC_GetPCLK2Freq();\n    uVar1 = (ulonglong)DAT_0800818c;\n    uVar3 = HAL_RCC_GetPCLK2Freq();\n    uVar4 = HAL_RCC_GetPCLK2Freq();\n    usart->BRR = (uint)(uVar1 * ((ulonglong)(uVar2 * 0x19) / (ulonglong)(uint)(baud << 1)) >> 0x25)\n                 << 4 | (uint)((ulonglong)DAT_0800818c *\n                               (ulonglong)\n                               (((uVar3 * 0x19) / (uint)(baud << 1) +\n                                (uint)((ulonglong)DAT_0800818c *\n                                       ((ulonglong)(uVar4 * 0x19) / (ulonglong)(uint)(baud << 1)) >>\n                                      0x25) * -100) * 0x10 + 0x32) >> 0x25) & 0xf;\n  }\n  else {\n    uVar2 = HAL_RCC_GetPCLK1Freq();\n    uVar1 = (ulonglong)DAT_0800818c;\n    uVar3 = HAL_RCC_GetPCLK1Freq();\n    uVar4 = HAL_RCC_GetPCLK1Freq();\n    usart->BRR = (uint)(uVar1 * ((ulonglong)(uVar2 * 0x19) / (ulonglong)(uint)(baud << 1)) >> 0x25)\n                 << 4 | (uint)((ulonglong)DAT_0800818c *\n                               (ulonglong)\n                               (((uVar3 * 0x19) / (uint)(baud << 1) +\n                                (uint)((ulonglong)DAT_0800818c *\n                                       ((ulonglong)(uVar4 * 0x19) / (ulonglong)(uint)(baud << 1)) >>\n                                      0x25) * -100) * 0x10 + 0x32) >> 0x25) & 0xf;\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_RCC_GetPCLK2Freq", 
                "HAL_RCC_GetPCLK1Freq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007f54", 
            "calling": [
                "usart_init"
            ], 
            "imported": false, 
            "current_name": "set_baud_rate"
        }, 
        "HAL_RCC_NMI_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_RCC_NMI_IRQHandler(void)\n\n{\n  if ((*(uint *)(DAT_0800693c + 0xc) & 0x80) == 0x80) {\n    HAL_RCC_CCSCallback();\n    *DAT_08006940 = 0x80;\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_RCC_CCSCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800691c", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_RCC_NMI_IRQHandler"
        }, 
        "plan_cycle_reinitialize": {
            "renaming": {}, 
            "code": "\nvoid plan_cycle_reinitialize(int32_t step_events_remaining)\n\n{\n  byte bVar1;\n  undefined *puVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  block_t *block;\n  \n  puVar2 = PTR_block_buffer_08003698;\n  bVar1 = *PTR_block_buffer_tail_08003694;\n  uVar4 = *(undefined4 *)(PTR_block_buffer_08003698 + (uint)bVar1 * 0x40 + 0x20);\n  uVar3 = __floatsisf(step_events_remaining);\n  uVar3 = __aeabi_fmul(uVar4,uVar3);\n  uVar4 = __floatsisf(*(undefined4 *)(puVar2 + (uint)bVar1 * 0x40 + 0x10));\n  uVar3 = __aeabi_fdiv(uVar3,uVar4);\n  *(undefined4 *)(puVar2 + (uint)bVar1 * 0x40 + 0x20) = uVar3;\n  *(int32_t *)(puVar2 + (uint)bVar1 * 0x40 + 0x10) = step_events_remaining;\n  *(undefined4 *)(puVar2 + (uint)bVar1 * 0x40 + 0x18) = 0;\n  *(undefined4 *)(puVar2 + (uint)bVar1 * 0x40 + 0x1c) = 0;\n  puVar2[(uint)bVar1 * 0x40 + 0x25] = 0;\n  puVar2[(uint)bVar1 * 0x40 + 0x24] = 1;\n  planner_recalculate();\n  return;\n}\n\n", 
            "called": [
                "__floatsisf", 
                "__aeabi_fdiv", 
                "__aeabi_fmul", 
                "planner_recalculate"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003618", 
            "calling": [
                "st_cycle_reinitialize"
            ], 
            "imported": false, 
            "current_name": "plan_cycle_reinitialize"
        }, 
        "HAL_EnableDBGStopMode": {
            "renaming": {}, 
            "code": "\nvoid HAL_EnableDBGStopMode(void)\n\n{\n  *(uint *)(DAT_08005b54 + 4) = *(uint *)(DAT_08005b54 + 4) | 2;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005b3c", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_EnableDBGStopMode"
        }, 
        "__aeabi_ul2f": {
            "renaming": {}, 
            "code": "\nuint __aeabi_ul2f(uint param_1,uint param_2)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  \n  if ((param_1 | param_2) == 0) {\n    return param_1;\n  }\n  uVar1 = param_1;\n  uVar2 = param_2;\n  if (param_2 == 0) {\n    uVar1 = 0;\n    uVar2 = param_1;\n  }\n  iVar5 = 0x5b000000;\n  if (param_2 == 0) {\n    iVar5 = 0x4b000000;\n  }\n  iVar3 = count_leading_zeroes(uVar2);\n  uVar4 = iVar3 - 8;\n  iVar5 = iVar5 + -0x800000 + uVar4 * -0x800000;\n  if (iVar3 < 8) {\n    uVar4 = uVar2 << (iVar3 + 0x18U & 0xff);\n    uVar2 = iVar5 + ((uVar2 >> (0x20 - (iVar3 + 0x18U) & 0xff)) - ((int)uVar4 >> 0x1f));\n    if ((uVar1 | uVar4 << 1) == 0) {\n      uVar2 = uVar2 & ~(uVar4 >> 0x1f);\n    }\n    return uVar2;\n  }\n  uVar6 = uVar1 << (uVar4 & 0xff);\n  uVar2 = iVar5 + (uVar2 << (uVar4 & 0xff)) +\n          (uVar1 >> (0x20 - uVar4 & 0xff)) + (uint)(0x7fffffff < uVar6);\n  if (uVar6 == 0x80000000) {\n    uVar2 = uVar2 & 0xfffffffe;\n  }\n  return uVar2;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008e60", 
            "calling": [], 
            "imported": false, 
            "current_name": "__aeabi_ul2f"
        }, 
        "HAL_RCC_GetClockConfig": {
            "renaming": {}, 
            "code": "\nvoid HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef *RCC_ClkInitStruct,uint32_t *pFLatency)\n\n{\n  RCC_ClkInitStruct->ClockType = 0xf;\n  RCC_ClkInitStruct->SYSCLKSource = *(uint *)(DAT_08006914 + 8) & 3;\n  RCC_ClkInitStruct->AHBCLKDivider = *(uint *)(DAT_08006914 + 8) & 0xf0;\n  RCC_ClkInitStruct->APB1CLKDivider = *(uint *)(DAT_08006914 + 8) & 0x1c00;\n  RCC_ClkInitStruct->APB2CLKDivider = *(uint *)(DAT_08006914 + 8) >> 3 & 0x1c00;\n  *pFLatency = *DAT_08006918 & 0xf;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080068bc", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_RCC_GetClockConfig"
        }, 
        "calculate_trapezoid_for_block": {
            "renaming": {}, 
            "code": "\nvoid calculate_trapezoid_for_block(block_t *block,float entry_factor,float exit_factor)\n\n{\n  undefined4 uVar1;\n  uint32_t uVar2;\n  int iVar3;\n  int iVar4;\n  uint uVar5;\n  undefined4 in_r1;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined4 extraout_r1_03;\n  undefined4 in_r2;\n  float acceleration;\n  float acceleration_00;\n  float acceleration_01;\n  float distance;\n  undefined8 uVar6;\n  undefined4 in_stack_ffffffc8;\n  int32_t decelerate_steps;\n  int32_t acceleration_per_minute;\n  int32_t plateau_steps;\n  int32_t accelerate_steps;\n  \n  uVar1 = __floatunsisf(entry_factor,block->nominal_rate);\n  uVar1 = __aeabi_fmul(uVar1,in_r1);\n  uVar1 = __aeabi_f2d(uVar1);\n  ceil((double)CONCAT44(in_r2,in_stack_ffffffc8));\n  uVar2 = __aeabi_d2uiz(uVar1,extraout_r1);\n  block->initial_rate = uVar2;\n  uVar1 = __floatunsisf(block->nominal_rate);\n  uVar1 = __aeabi_fmul(uVar1,in_r2);\n  uVar1 = __aeabi_f2d(uVar1);\n  ceil((double)CONCAT44(in_r2,in_stack_ffffffc8));\n  uVar2 = __aeabi_d2uiz(uVar1,extraout_r1_00);\n  block->final_rate = uVar2;\n  uVar6 = __aeabi_i2d(block->rate_delta * 0x32);\n  uVar6 = __muldf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),0,DAT_08002e04);\n  iVar3 = __aeabi_d2iz((int)uVar6,(int)((ulonglong)uVar6 >> 0x20));\n  uVar1 = __floatunsisf(block->initial_rate);\n  __floatunsisf(block->nominal_rate);\n  uVar6 = __floatsisf(iVar3);\n  estimate_acceleration_distance((float)uVar6,(float)((ulonglong)uVar6 >> 0x20),acceleration);\n  uVar1 = __aeabi_f2d(uVar1);\n  ceil((double)CONCAT44(in_r2,in_stack_ffffffc8));\n  accelerate_steps = __aeabi_d2iz(uVar1,extraout_r1_01);\n  uVar1 = __floatunsisf(block->nominal_rate);\n  __floatunsisf(block->final_rate);\n  uVar6 = __floatsisf(-iVar3);\n  estimate_acceleration_distance((float)uVar6,(float)((ulonglong)uVar6 >> 0x20),acceleration_00);\n  uVar1 = __aeabi_f2d(uVar1);\n  floor((double)CONCAT44(in_r2,in_stack_ffffffc8));\n  iVar4 = __aeabi_d2iz(uVar1,extraout_r1_02);\n  plateau_steps = (block->step_event_count - accelerate_steps) - iVar4;\n  if (plateau_steps < 0) {\n    uVar1 = __floatunsisf(block->initial_rate);\n    __floatunsisf(block->final_rate);\n    __floatsisf(iVar3);\n    uVar6 = __floatsisf(block->step_event_count);\n    intersection_distance((float)uVar6,(float)((ulonglong)uVar6 >> 0x20),acceleration_01,distance);\n    uVar1 = __aeabi_f2d(uVar1);\n    ceil((double)CONCAT44(in_r2,in_stack_ffffffc8));\n    uVar5 = __aeabi_d2iz(uVar1,extraout_r1_03);\n    uVar5 = uVar5 & ~((int)uVar5 >> 0x1f);\n    accelerate_steps = block->step_event_count;\n    if ((int)uVar5 <= block->step_event_count) {\n      accelerate_steps = uVar5;\n    }\n    plateau_steps = 0;\n  }\n  block->accelerate_until = accelerate_steps;\n  block->decelerate_after = plateau_steps + accelerate_steps;\n  return;\n}\n\n", 
            "called": [
                "estimate_acceleration_distance", 
                "intersection_distance", 
                "__floatsisf", 
                "__aeabi_d2iz", 
                "__floatunsisf", 
                "__aeabi_d2uiz", 
                "__aeabi_f2d", 
                "__muldf3", 
                "floor", 
                "__aeabi_fmul", 
                "ceil", 
                "__aeabi_i2d"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002c18", 
            "calling": [
                "planner_recalculate_trapezoids"
            ], 
            "imported": false, 
            "current_name": "calculate_trapezoid_for_block"
        }, 
        "debounce_isr": {
            "renaming": {}, 
            "code": "\nvoid debounce_isr(void)\n\n{\n  undefined *puVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  int iVar4;\n  uint32_t off_bits;\n  uint32_t on_bits;\n  uint32_t state;\n  DEBOUNCE_CTRL *db;\n  \n  puVar1 = PTR_debounce_080079b8;\n  if (*(int *)PTR_debounce_ready_080079bc != 0) {\n    iVar4 = *(int *)(PTR_debounce_080079b8 + 0x14);\n    uVar2 = debounce_input();\n    *(uint32_t *)(puVar1 + iVar4 * 4) = uVar2;\n    if (*(int *)(puVar1 + 0x14) == 3) {\n      iVar4 = 0;\n    }\n    else {\n      iVar4 = *(int *)(puVar1 + 0x14) + 1;\n    }\n    *(int *)(puVar1 + 0x14) = iVar4;\n    uVar2 = debounce_rd();\n    if (uVar2 != *(uint32_t *)(puVar1 + 0x10)) {\n      uVar3 = *(uint *)(puVar1 + 0x10);\n      if ((~*(uint *)(puVar1 + 0x10) & uVar2) != 0) {\n        debounce_on_handler(~*(uint *)(puVar1 + 0x10) & uVar2);\n      }\n      if ((~uVar2 & uVar3) != 0) {\n        debounce_off_handler(~uVar2 & uVar3);\n      }\n      *(uint32_t *)(puVar1 + 0x10) = uVar2;\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "debounce_off_handler", 
                "debounce_input", 
                "debounce_on_handler", 
                "debounce_rd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007930", 
            "calling": [
                "SysTick_Handler"
            ], 
            "imported": false, 
            "current_name": "debounce_isr"
        }, 
        "matherr": {
            "renaming": {}, 
            "code": "\nint matherr(exception *__exc)\n\n{\n  return 0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800b2e0", 
            "calling": [
                "hypot", 
                "sqrt"
            ], 
            "imported": false, 
            "current_name": "matherr"
        }, 
        "g540_timer_init": {
            "renaming": {}, 
            "code": "\nvoid g540_timer_init(void)\n\n{\n  TIM_TypeDef *pTVar1;\n  TIM_TypeDef *TIMx;\n  \n  pTVar1 = DAT_08007d9c;\n  enable_tim_clock(DAT_08007d9c);\n  pTVar1->CR1 = 0x80;\n  pTVar1->CR2 = 0;\n  pTVar1->SMCR = 0;\n  pTVar1->DIER = 0;\n  pTVar1->SR = 0;\n  pTVar1->CCMR1 = 0x6800;\n  pTVar1->CCMR2 = 0;\n  pTVar1->CCER = 0;\n  pTVar1->CNT = 0;\n  pTVar1->PSC = (uint)((ulonglong)DAT_08007da4 * (ulonglong)*(uint *)PTR_SystemCoreClock_08007da0 >>\n                      0x35) - 1;\n  pTVar1->ARR = 199;\n  pTVar1->CCR1 = 0;\n  pTVar1->CCR2 = 100;\n  pTVar1->CCR3 = 0;\n  pTVar1->CCR4 = 0;\n  pTVar1->DCR = 0;\n  pTVar1->DMAR = 0;\n  pTVar1->EGR = 1;\n  return;\n}\n\n", 
            "called": [
                "enable_tim_clock"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007d08", 
            "calling": [
                "timers_init"
            ], 
            "imported": false, 
            "current_name": "g540_timer_init"
        }, 
        "NVIC_SetPendingIRQ": {
            "renaming": {}, 
            "code": "\nvoid NVIC_SetPendingIRQ(IRQn_Type IRQn)\n\n{\n  *(int *)(DAT_08006a88 + (((uint)(int)IRQn >> 5) + 0x40) * 4) = 1 << (IRQn & 0x1fU);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006a58", 
            "calling": [
                "HAL_NVIC_SetPendingIRQ"
            ], 
            "imported": false, 
            "current_name": "NVIC_SetPendingIRQ"
        }, 
        "protocol_execute_runtime": {
            "renaming": {}, 
            "code": "\nvoid protocol_execute_runtime(void)\n\n{\n  byte bVar1;\n  uint8_t rt_exec;\n  \n  if (PTR_sys_08003b90[2] != '\\0') {\n    bVar1 = PTR_sys_08003b90[2];\n    if ((bVar1 & 0x60) != 0) {\n      PTR_sys_08003b90[1] = 6;\n      if ((bVar1 & 0x40) == 0) {\n        report_alarm_message(-2);\n      }\n      else {\n        report_alarm_message(-1);\n        report_feedback_message('\\x01');\n        PTR_sys_08003b90[2] = PTR_sys_08003b90[2] & 0xef;\n        do {\n        } while ((PTR_sys_08003b90[2] & 0x10) == 0);\n      }\n      PTR_sys_08003b90[2] = PTR_sys_08003b90[2] & 0x9f;\n    }\n    if ((bVar1 & 0x10) == 0) {\n      if ((bVar1 & 1) != 0) {\n        report_realtime_status();\n        PTR_sys_08003b90[2] = PTR_sys_08003b90[2] & 0xfe;\n      }\n      if ((bVar1 & 8) != 0) {\n        st_feed_hold();\n        PTR_sys_08003b90[2] = PTR_sys_08003b90[2] & 0xf7;\n      }\n      if ((bVar1 & 4) != 0) {\n        st_cycle_reinitialize();\n        PTR_sys_08003b90[2] = PTR_sys_08003b90[2] & 0xfb;\n      }\n      if ((bVar1 & 2) != 0) {\n        st_cycle_start();\n        if ((PTR_settings_08003b94[0x28] & 2) != 0) {\n          PTR_sys_08003b90[0x10] = 1;\n        }\n        PTR_sys_08003b90[2] = PTR_sys_08003b90[2] & 0xfd;\n      }\n    }\n    else {\n      *PTR_sys_08003b90 = 1;\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "report_realtime_status", 
                "report_alarm_message", 
                "report_feedback_message", 
                "st_cycle_reinitialize", 
                "st_cycle_start", 
                "st_feed_hold"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003a74", 
            "calling": [
                "protocol_process", 
                "mc_dwell", 
                "grbl_main", 
                "plan_synchronize", 
                "mc_line", 
                "mc_go_home"
            ], 
            "imported": false, 
            "current_name": "protocol_execute_runtime"
        }, 
        "__aeabi_dcmple": {
            "renaming": {}, 
            "code": "\nbool __aeabi_dcmple(void)\n\n{\n  undefined in_ZR;\n  undefined in_CY;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)in_CY || (bool)in_ZR;\n}\n\n", 
            "called": [
                "__aeabi_cdcmpeq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008b38", 
            "calling": [], 
            "imported": false, 
            "current_name": "__aeabi_dcmple"
        }, 
        "report_status_message": {
            "renaming": {}, 
            "code": "\nvoid report_status_message(uint8_t status_code)\n\n{\n  if (status_code == '\\0') {\n    printPgmString(PTR__etext_08004108);\n  }\n  else {\n    printPgmString(PTR_s_error__0800410c);\n    switch(status_code) {\n    case '\\x01':\n      printPgmString(PTR_s_Bad_number_format_08004110);\n      break;\n    case '\\x02':\n      printPgmString(PTR_s_Expected_command_letter_08004114);\n      break;\n    case '\\x03':\n      printPgmString(PTR_s_Unsupported_statement_08004118);\n      break;\n    case '\\x04':\n      printPgmString(PTR_s_Invalid_radius_0800411c);\n      break;\n    case '\\x05':\n      printPgmString(PTR_s_Modal_group_violation_08004120);\n      break;\n    case '\\x06':\n      printPgmString(PTR_s_Invalid_statement_08004124);\n      break;\n    case '\\a':\n      printPgmString(PTR_s_Setting_disabled_08004128);\n      break;\n    case '\\b':\n      printPgmString(PTR_s_Value___0_0_0800412c);\n      break;\n    case '\\t':\n      printPgmString(PTR_s_Value___3_usec_08004130);\n      break;\n    case '\\n':\n      printPgmString(PTR_s_EEPROM_read_fail__Using_defaults_08004134);\n      break;\n    case '\\v':\n      printPgmString(PTR_s_Busy_or_queued_08004138);\n      break;\n    case '\\f':\n      printPgmString(PTR_s_Alarm_lock_0800413c);\n      break;\n    case '\\r':\n      printPgmString(PTR_s_Line_overflow_08004140);\n    }\n    printPgmString(PTR_DAT_08004144);\n  }\n  return;\n}\n\n", 
            "called": [
                "printPgmString"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004030", 
            "calling": [
                "settings_init", 
                "protocol_process", 
                "protocol_execute_startup", 
                "gc_init", 
                "protocol_execute_line", 
                "report_gcode_parameters"
            ], 
            "imported": false, 
            "current_name": "report_status_message"
        }, 
        "report_grbl_help": {
            "renaming": {}, 
            "code": "\nvoid report_grbl_help(void)\n\n{\n  printPgmString(PTR_s_____view_Grbl_settings______view_0800424c);\n  return;\n}\n\n", 
            "called": [
                "printPgmString"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800423c", 
            "calling": [
                "protocol_execute_line"
            ], 
            "imported": false, 
            "current_name": "report_grbl_help"
        }, 
        "serial_read": {
            "renaming": {}, 
            "code": "\nuint8_t serial_read(void)\n\n{\n  uint8_t data;\n  int iVar1;\n  uint8_t c;\n  \n  iVar1 = usart_tstc();\n  if (iVar1 != 0) {\n    data = usart_getc();\n    iVar1 = serial_rx_hook(data);\n    if (iVar1 == 0) {\n      return data;\n    }\n  }\n  return 0xff;\n}\n\n", 
            "called": [
                "usart_getc", 
                "serial_rx_hook", 
                "usart_tstc"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008286", 
            "calling": [
                "protocol_process"
            ], 
            "imported": false, 
            "current_name": "serial_read"
        }, 
        "__aeabi_cfrcmple": {
            "renaming": {}, 
            "code": "\nvoid __aeabi_cfrcmple(undefined4 param_1,undefined4 param_2)\n\n{\n  __aeabi_cfcmpeq(param_2,param_1);\n  return;\n}\n\n", 
            "called": [
                "__aeabi_cfcmpeq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080091fc", 
            "calling": [
                "__aeabi_fcmpge", 
                "__aeabi_fcmpgt"
            ], 
            "imported": false, 
            "current_name": "__aeabi_cfrcmple"
        }, 
        "cos": {
            "renaming": {}, 
            "code": "\ndouble cos(double __x)\n\n{\n  undefined4 in_r0;\n  uint uVar1;\n  uint in_r1;\n  double dVar2;\n  undefined4 local_28;\n  undefined4 uStack_24;\n  undefined4 local_20;\n  undefined4 uStack_1c;\n  \n  if (DAT_080094b4 < (int)(in_r1 & 0x7fffffff)) {\n    if (DAT_080094b8 < (int)(in_r1 & 0x7fffffff)) {\n      dVar2 = (double)__subdf3();\n    }\n    else {\n      uVar1 = __ieee754_rem_pio2(in_r0,in_r1,&local_28);\n      uVar1 = uVar1 & 3;\n      if (uVar1 == 1) {\n        dVar2 = (double)__kernel_sin(local_28,uStack_24,local_20,uStack_1c,1);\n      }\n      else if (uVar1 == 2) {\n        dVar2 = (double)__kernel_cos(local_28,uStack_24,local_20,uStack_1c);\n      }\n      else if (uVar1 == 0) {\n        dVar2 = (double)__kernel_cos(local_28,uStack_24,local_20,uStack_1c);\n      }\n      else {\n        dVar2 = (double)__kernel_sin(local_28,uStack_24,local_20,uStack_1c,1);\n      }\n    }\n    return dVar2;\n  }\n  dVar2 = (double)__kernel_cos(in_r0,in_r1,0,0);\n  return dVar2;\n}\n\n", 
            "called": [
                "__kernel_cos", 
                "__ieee754_rem_pio2", 
                "__kernel_sin", 
                "__subdf3"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009410", 
            "calling": [
                "mc_arc"
            ], 
            "imported": false, 
            "current_name": "cos"
        }, 
        "NVIC_SetPriorityGrouping": {
            "renaming": {}, 
            "code": "\nvoid NVIC_SetPriorityGrouping(uint32_t PriorityGroup)\n\n{\n  uint32_t reg_value;\n  uint32_t PriorityGroupTmp;\n  \n  *(uint *)(DAT_08006994 + 0xc) =\n       *(uint *)(DAT_08006994 + 0xc) & 0xf8ff | (PriorityGroup & 7) << 8 | 0x5fa0000;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006950", 
            "calling": [
                "HAL_NVIC_SetPriorityGrouping"
            ], 
            "imported": false, 
            "current_name": "NVIC_SetPriorityGrouping"
        }, 
        "main": {
            "renaming": {}, 
            "code": "\nint main(void)\n\n{\n  HAL_Init();\n  SystemClock_Config();\n  gpio_init();\n  timers_init();\n  debounce_init();\n  usart_init();\n  startForkserver(0);\n  grbl_main();\n  return 0;\n}\n\n", 
            "called": [
                "startForkserver", 
                "timers_init", 
                "usart_init", 
                "HAL_Init", 
                "gpio_init", 
                "SystemClock_Config", 
                "grbl_main", 
                "debounce_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007540", 
            "calling": [
                "Reset_Handler"
            ], 
            "imported": false, 
            "current_name": "main"
        }, 
        "__ieee754_atan2": {
            "renaming": {}, 
            "code": "\nvoid __ieee754_atan2(uint param_1,uint param_2,uint param_3,uint param_4,double param_5)\n\n{\n  int iVar1;\n  undefined4 unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  \n  uVar3 = param_4 & 0x7fffffff;\n  if ((DAT_08009b18 < (uVar3 | (-param_3 | param_3) >> 0x1f)) ||\n     (uVar4 = param_2 & 0x7fffffff, DAT_08009b18 < (uVar4 | (-param_1 | param_1) >> 0x1f))) {\n    __aeabi_dadd(param_3,param_4,param_1,param_2);\n  }\n  else {\n    if ((param_4 + 0xc0100000 | param_3) == 0) {\n      atan(param_5);\n      return;\n    }\n    uVar2 = (int)param_4 >> 0x1e & 2U | param_2 >> 0x1f;\n    if (((((uVar4 | param_1) != 0) && ((uVar3 | param_3) != 0)) && (uVar3 != DAT_08009b18)) &&\n       (uVar4 != DAT_08009b18)) {\n      iVar1 = (int)(uVar4 - uVar3) >> 0x14;\n      if (((int)(uVar4 - uVar3) < 0x3d00000) &&\n         ((-1 < (int)param_4 || (iVar1 + 0x3c < 0 == SCARRY4(iVar1,0x3c))))) {\n        __divdf3(param_1,param_2,param_3,param_4);\n        fabs((double)CONCAT44(unaff_r4,param_4));\n        atan((double)CONCAT44(unaff_r4,param_4));\n      }\n      if (uVar2 != 1) {\n        if (uVar2 == 2) {\n          uVar5 = __subdf3();\n          __subdf3(DAT_08009af0,DAT_08009af4,(int)uVar5,(int)((ulonglong)uVar5 >> 0x20));\n        }\n        else if (uVar2 != 0) {\n          uVar5 = __subdf3();\n          __subdf3((int)uVar5,(int)((ulonglong)uVar5 >> 0x20),DAT_08009af0,DAT_08009af4);\n        }\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "fabs", 
                "__divdf3", 
                "atan", 
                "__subdf3", 
                "__aeabi_dadd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009990", 
            "calling": [
                "atan2"
            ], 
            "imported": false, 
            "current_name": "__ieee754_atan2"
        }, 
        "atan": {
            "renaming": {}, 
            "code": "\ndouble atan(double __x)\n\n{\n  undefined *puVar1;\n  int in_r0;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  uint in_r1;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 extraout_r1;\n  uint uVar6;\n  int iVar7;\n  double in_d0;\n  double dVar8;\n  double extraout_d0;\n  undefined8 uVar9;\n  undefined8 uVar10;\n  undefined4 in_stack_ffffffd0;\n  uint uVar11;\n  \n  uVar6 = in_r1 & 0x7fffffff;\n  if (DAT_0800b298 < (int)uVar6) {\n    if ((uVar6 != DAT_0800b29c && (int)DAT_0800b29c <= (int)uVar6) ||\n       ((uVar6 == DAT_0800b29c && (in_r0 != 0)))) {\n      dVar8 = (double)__aeabi_dadd();\n      return dVar8;\n    }\n  }\n  else {\n    if (DAT_0800b2ac < (int)uVar6) {\n      fabs((double)CONCAT44(in_r1,in_stack_ffffffd0));\n      if (DAT_0800b2bc < (int)uVar6) {\n        if ((int)uVar6 < DAT_0800b2c0) {\n          uVar9 = __subdf3();\n          uVar10 = __muldf3(in_r0,extraout_r1,0,DAT_0800b2c4);\n          uVar10 = __aeabi_dadd((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),0,DAT_0800b2b8);\n          uVar9 = __divdf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),(int)uVar10,\n                           (int)((ulonglong)uVar10 >> 0x20));\n          uVar11 = (uint)((ulonglong)uVar9 >> 0x20);\n          in_r0 = (int)uVar9;\n          iVar7 = 2;\n        }\n        else {\n          uVar9 = __divdf3(0,DAT_0800b2c8,in_r0,extraout_r1);\n          uVar11 = (uint)((ulonglong)uVar9 >> 0x20);\n          in_r0 = (int)uVar9;\n          iVar7 = 3;\n        }\n      }\n      else if (DAT_0800b2bc + -0xd0000 < (int)uVar6) {\n        uVar9 = __subdf3();\n        uVar10 = __aeabi_dadd(in_r0,extraout_r1,0,DAT_0800b2b8);\n        uVar9 = __divdf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),(int)uVar10,\n                         (int)((ulonglong)uVar10 >> 0x20));\n        uVar11 = (uint)((ulonglong)uVar9 >> 0x20);\n        in_r0 = (int)uVar9;\n        iVar7 = 1;\n      }\n      else {\n        uVar9 = __aeabi_dadd();\n        uVar9 = __subdf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),0,DAT_0800b2b8);\n        uVar10 = __aeabi_dadd(in_r0,extraout_r1,0,0x40000000);\n        uVar9 = __divdf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),(int)uVar10,\n                         (int)((ulonglong)uVar10 >> 0x20));\n        uVar11 = (uint)((ulonglong)uVar9 >> 0x20);\n        in_r0 = (int)uVar9;\n        iVar7 = 0;\n      }\n    }\n    else {\n      uVar11 = in_r1;\n      if ((int)uVar6 <= DAT_0800b2ac + -0x1bc0000) {\n        uVar9 = __aeabi_dadd(in_r0,in_r1,DAT_0800b290,DAT_0800b294);\n        iVar7 = __aeabi_dcmpgt((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),0,DAT_0800b2b8);\n        if (iVar7 != 0) {\n          return extraout_d0;\n        }\n      }\n      iVar7 = -1;\n    }\n    uVar9 = __muldf3(in_r0,uVar11,in_r0);\n    uVar4 = (undefined4)((ulonglong)uVar9 >> 0x20);\n    uVar2 = (undefined4)uVar9;\n    uVar9 = __muldf3(uVar2,uVar4,uVar2,uVar4);\n    uVar5 = (undefined4)((ulonglong)uVar9 >> 0x20);\n    uVar3 = (undefined4)uVar9;\n    uVar9 = __muldf3(uVar3,uVar5,DAT_0800b238,DAT_0800b23c);\n    uVar9 = __aeabi_dadd((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),DAT_0800b240,DAT_0800b244);\n    uVar9 = __muldf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),uVar3,uVar5);\n    uVar9 = __aeabi_dadd((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),DAT_0800b248,DAT_0800b24c);\n    uVar9 = __muldf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),uVar3,uVar5);\n    uVar9 = __aeabi_dadd((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),DAT_0800b250,DAT_0800b254);\n    uVar9 = __muldf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),uVar3,uVar5);\n    uVar9 = __aeabi_dadd((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),DAT_0800b258,DAT_0800b25c);\n    uVar9 = __muldf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),uVar3,uVar5);\n    uVar9 = __aeabi_dadd((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),DAT_0800b260,DAT_0800b264);\n    uVar9 = __muldf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),uVar2,uVar4);\n    uVar2 = (undefined4)((ulonglong)uVar9 >> 0x20);\n    uVar10 = __muldf3(uVar3,uVar5,DAT_0800b268,DAT_0800b26c);\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_0800b270,DAT_0800b274);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar3,uVar5);\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_0800b278,DAT_0800b27c);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar3,uVar5);\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_0800b280,DAT_0800b284);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar3,uVar5);\n    uVar10 = __subdf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),DAT_0800b288,DAT_0800b28c);\n    uVar10 = __muldf3((int)uVar10,(int)((ulonglong)uVar10 >> 0x20),uVar3,uVar5);\n    uVar3 = (undefined4)((ulonglong)uVar10 >> 0x20);\n    if (iVar7 == -1) {\n      uVar9 = __aeabi_dadd((int)uVar9,uVar2,(int)uVar10,uVar3);\n      uVar9 = __muldf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),in_r0,uVar11);\n      dVar8 = (double)__subdf3(in_r0,uVar11,(int)uVar9,(int)((ulonglong)uVar9 >> 0x20));\n      return dVar8;\n    }\n    uVar9 = __aeabi_dadd((int)uVar9,uVar2,(int)uVar10,uVar3);\n    puVar1 = PTR_atanhi_0800b2b0;\n    uVar9 = __muldf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),in_r0,uVar11);\n    uVar9 = __subdf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),\n                     *(undefined4 *)(PTR_atanlo_0800b2b4 + iVar7 * 8),\n                     *(undefined4 *)((int)(PTR_atanlo_0800b2b4 + iVar7 * 8) + 4));\n    uVar9 = __subdf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),in_r0,uVar11);\n    in_d0 = (double)__subdf3(*(undefined4 *)(puVar1 + iVar7 * 8),\n                             *(undefined4 *)((int)(puVar1 + iVar7 * 8) + 4),(int)uVar9,\n                             (int)((ulonglong)uVar9 >> 0x20));\n    if ((int)in_r1 < 0) {\n      return in_d0;\n    }\n  }\n  return in_d0;\n}\n\n", 
            "called": [
                "fabs", 
                "__divdf3", 
                "__muldf3", 
                "__aeabi_dcmpgt", 
                "__subdf3", 
                "__aeabi_dadd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800af78", 
            "calling": [
                "__ieee754_atan2"
            ], 
            "imported": false, 
            "current_name": "atan"
        }, 
        "__aeabi_i2d": {
            "renaming": {}, 
            "code": "\nulonglong __aeabi_i2d(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  uint in_r12;\n  bool bVar7;\n  bool bVar8;\n  bool bVar9;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  uVar6 = param_1 & 0x80000000;\n  uVar2 = param_1;\n  if ((int)uVar6 < 0) {\n    uVar2 = -param_1;\n  }\n  uVar1 = 0;\n  iVar4 = count_leading_zeroes(uVar2);\n  uVar5 = iVar4 + 0x15;\n  bVar9 = SBORROW4(uVar5,0x20);\n  uVar3 = iVar4 - 0xb;\n  bVar7 = (int)uVar3 < 0;\n  bVar8 = uVar3 == 0;\n  if ((int)uVar5 < 0x20) {\n    bVar9 = SCARRY4(uVar3,0xc);\n    iVar4 = iVar4 + 1;\n    bVar7 = iVar4 < 0;\n    bVar8 = iVar4 == 0;\n    uVar3 = uVar5;\n    if (!bVar8 && bVar7 == bVar9) {\n      uVar1 = uVar2 << (uVar5 & 0xff);\n      uVar2 = uVar2 >> (0xcU - iVar4 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bVar8 || bVar7 != bVar9) {\n    in_r12 = 0x20 - uVar3;\n  }\n  uVar2 = uVar2 << (uVar3 & 0xff);\n  if (bVar8 || bVar7 != bVar9) {\n    uVar2 = uVar2 | 0U >> (in_r12 & 0xff);\n  }\n  if (bVar8 || bVar7 != bVar9) {\n    uVar1 = 0 << (uVar3 & 0xff);\n  }\nLAB_08008458:\n  if ((int)uVar5 < 0x433) {\n    return CONCAT44(uVar2 + (0x432 - uVar5) * 0x100000 | uVar6,uVar1);\n  }\n  uVar3 = ~(0x432 - uVar5);\n  if (0x1e < (int)uVar3) {\n    return CONCAT44(param_1,uVar2 >> (uVar3 - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  iVar4 = uVar3 - 0x13;\n  if (iVar4 == 0 || iVar4 < 0 != SCARRY4(uVar3 - 0x1f,0xc)) {\n    uVar3 = uVar3 + 1;\n    return CONCAT44(uVar6 | uVar2 >> (uVar3 & 0xff),\n                    uVar1 >> (uVar3 & 0xff) | uVar2 << (0x20 - uVar3 & 0xff));\n  }\n  return CONCAT44(param_1,uVar1 >> (0x20 - (0xcU - iVar4) & 0xff) | uVar2 << (0xcU - iVar4 & 0xff))\n         & 0x80000000ffffffff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800856c", 
            "calling": [
                "__ieee754_rem_pio2", 
                "__kernel_rem_pio2", 
                "calculate_trapezoid_for_block"
            ], 
            "imported": false, 
            "current_name": "__aeabi_i2d"
        }, 
        "HAL_GPIO_DeInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_GPIO_DeInit(GPIO_TypeDef *GPIOx,uint32_t GPIO_Pin)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint32_t tmp;\n  uint32_t iocurrent;\n  uint32_t ioposition;\n  uint32_t position;\n  \n  for (position = 0; position < 0x10; position = position + 1) {\n    uVar1 = 1 << (position & 0xff);\n    uVar2 = uVar1 & GPIO_Pin;\n    if (uVar2 == uVar1) {\n      GPIOx->MODER = GPIOx->MODER & ~(3 << ((position & 0x7f) << 1));\n      GPIOx->AFR[position >> 3] = GPIOx->AFR[position >> 3] & ~(0xf << ((position & 7) << 2));\n      GPIOx->OSPEEDR = GPIOx->OSPEEDR & ~(3 << ((position & 0x7f) << 1));\n      GPIOx->OTYPER = GPIOx->OTYPER & ~(1 << (position & 0xff));\n      GPIOx->PUPDR = GPIOx->PUPDR & ~(3 << ((position & 0x7f) << 1));\n      *(uint *)(DAT_08007308 + ((position >> 2) + 2) * 4) =\n           ~(0xf << ((position & 3) << 2)) & *(uint *)(DAT_08007308 + ((position >> 2) + 2) * 4);\n      *DAT_0800730c = ~uVar2 & *DAT_0800730c;\n      DAT_0800730c[1] = ~uVar2 & DAT_0800730c[1];\n      DAT_0800730c[2] = ~uVar2 & DAT_0800730c[2];\n      DAT_0800730c[3] = ~uVar2 & DAT_0800730c[3];\n    }\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080071d0", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_GPIO_DeInit"
        }, 
        "memcpy_from_eeprom_with_checksum": {
            "renaming": {}, 
            "code": "\nint memcpy_from_eeprom_with_checksum(char *destination,uint source,uint size)\n\n{\n  char cVar1;\n  uint local_1c;\n  uint local_18;\n  char *local_14;\n  uchar data;\n  uchar checksum;\n  \n  checksum = '\\0';\n  local_1c = size;\n  local_18 = source;\n  local_14 = destination;\n  if (*(int *)PTR_eeprom_ready_08000470 == 0) {\n    eeprom_init();\n    local_18 = source;\n    local_14 = destination;\n  }\n  for (; local_1c != 0; local_1c = local_1c - 1) {\n    cVar1 = eeprom_get_char(local_18);\n    checksum = cVar1 + (checksum != '\\0');\n    *local_14 = cVar1;\n    local_18 = local_18 + 1;\n    local_14 = local_14 + 1;\n  }\n  cVar1 = eeprom_get_char(local_18);\n  return (uint)((uint)checksum == (int)cVar1);\n}\n\n", 
            "called": [
                "eeprom_init", 
                "eeprom_get_char"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080003ec", 
            "calling": [
                "settings_read_coord_data", 
                "settings_read_startup_line", 
                "read_global_settings"
            ], 
            "imported": false, 
            "current_name": "memcpy_from_eeprom_with_checksum"
        }, 
        "__aeabi_f2iz": {
            "renaming": {}, 
            "code": "\nuint __aeabi_f2iz(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  if (param_1 << 1 < 0x7f000000) {\n    return 0;\n  }\n  uVar1 = (param_1 << 1) >> 0x18;\n  uVar2 = 0x9e - uVar1;\n  if (uVar1 < 0x9f && uVar2 != 0) {\n    uVar1 = (param_1 << 8 | 0x80000000) >> (uVar2 & 0xff);\n    if ((param_1 & 0x80000000) != 0) {\n      uVar1 = -uVar1;\n    }\n    return uVar1;\n  }\n  if ((uVar2 == 0xffffff9f) && ((param_1 & 0x7fffff) != 0)) {\n    return 0;\n  }\n  param_1 = param_1 & 0x80000000;\n  if (param_1 == 0) {\n    param_1 = 0x7fffffff;\n  }\n  return param_1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009278", 
            "calling": [
                "printFloat", 
                "protocol_execute_line"
            ], 
            "imported": false, 
            "current_name": "__aeabi_f2iz"
        }, 
        "read_float": {
            "renaming": {}, 
            "code": "\nint read_float(char *line,uint8_t *char_counter,float *float_ptr)\n\n{\n  byte bVar1;\n  bool bVar2;\n  bool bVar3;\n  uchar *puVar4;\n  uchar *puVar5;\n  int iVar6;\n  undefined8 uVar7;\n  float fval;\n  _Bool isdecimal;\n  uint8_t ndigit;\n  int8_t exp;\n  uint32_t intval;\n  _Bool isnegative;\n  uchar c;\n  char *ptr;\n  \n  puVar5 = (uchar *)(line + *char_counter);\n  puVar4 = puVar5 + 1;\n  c = *puVar5;\n  bVar2 = false;\n  if (c == '-') {\n    bVar2 = true;\n    c = *puVar4;\n    ptr = (char *)(puVar5 + 2);\n  }\n  else {\n    ptr = (char *)puVar4;\n    if (c == '+') {\n      ptr = (char *)(puVar5 + 2);\n      c = *puVar4;\n    }\n  }\n  intval = 0;\n  exp = '\\0';\n  ndigit = '\\0';\n  bVar3 = false;\n  do {\n    bVar1 = c - 0x30;\n    if (bVar1 < 10) {\n      ndigit = ndigit + 1;\n      if (ndigit < 9) {\n        if (bVar3) {\n          exp = exp + -1;\n        }\n        intval = (uint)bVar1 + intval * 10;\n      }\n      else if (!bVar3) {\n        exp = exp + '\\x01';\n      }\n    }\n    else {\n      if ((bVar1 != 0xfe) || (bVar3)) {\n        if (ndigit == '\\0') {\n          iVar6 = 0;\n        }\n        else {\n          fval = (float)__floatunsisf(intval);\n          iVar6 = __aeabi_fcmpeq(fval,0);\n          if (iVar6 == 0) {\n            for (; exp < -1; exp = exp + '\\x02') {\n              uVar7 = __aeabi_f2d(fval);\n              uVar7 = __muldf3((int)uVar7,(int)((ulonglong)uVar7 >> 0x20),DAT_08002800,DAT_08002804)\n              ;\n              fval = (float)__truncdfsf2((int)uVar7,(int)((ulonglong)uVar7 >> 0x20));\n            }\n            if (exp < '\\0') {\n              uVar7 = __aeabi_f2d(fval);\n              uVar7 = __muldf3((int)uVar7,(int)((ulonglong)uVar7 >> 0x20),DAT_08002808,DAT_0800280c)\n              ;\n              fval = (float)__truncdfsf2((int)uVar7,(int)((ulonglong)uVar7 >> 0x20));\n            }\n            else {\n              for (; '\\0' < exp; exp = exp + -1) {\n                fval = (float)__aeabi_fmul(fval,DAT_08002810);\n              }\n            }\n          }\n          if (bVar2) {\n            *float_ptr = (float)((uint)fval ^ 0x80000000);\n          }\n          else {\n            *float_ptr = fval;\n          }\n          *char_counter = ((char)ptr - (char)line) + 0xff;\n          iVar6 = 1;\n        }\n        return iVar6;\n      }\n      bVar3 = true;\n    }\n    c = *ptr;\n    ptr = ptr + 1;\n  } while( true );\n}\n\n", 
            "called": [
                "__aeabi_fcmpeq", 
                "__truncdfsf2", 
                "__floatunsisf", 
                "__muldf3", 
                "__aeabi_f2d", 
                "__aeabi_fmul"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002638", 
            "calling": [
                "next_statement", 
                "protocol_execute_line"
            ], 
            "imported": false, 
            "current_name": "read_float"
        }, 
        "HAL_GPIO_Init": {
            "renaming": {}, 
            "code": "\nvoid HAL_GPIO_Init(GPIO_TypeDef *GPIOx,GPIO_InitTypeDef *GPIO_Init)\n\n{\n  uint32_t uVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  uint32_t temp;\n  uint32_t iocurrent;\n  uint32_t ioposition;\n  uint32_t position;\n  \n  for (position = 0; position < 0x10; position = position + 1) {\n    uVar2 = 1 << (position & 0xff);\n    uVar3 = GPIO_Init->Pin & uVar2;\n    if (uVar3 == uVar2) {\n      if ((GPIO_Init->Mode == 2) || (GPIO_Init->Mode == 0x12)) {\n        uVar1 = GPIO_Init->Alternate;\n        GPIOx->AFR[position >> 3] = GPIOx->AFR[position >> 3] & ~(0xf << ((position & 7) << 2));\n        GPIOx->AFR[position >> 3] = GPIOx->AFR[position >> 3] | uVar1 << ((position & 7) << 2);\n      }\n      GPIOx->MODER = GPIOx->MODER & ~(3 << ((position & 0x7f) << 1));\n      GPIOx->MODER = GPIOx->MODER | (GPIO_Init->Mode & 3) << ((position & 0x7f) << 1);\n      if ((((GPIO_Init->Mode == 1) || (GPIO_Init->Mode == 2)) || (GPIO_Init->Mode == 0x11)) ||\n         (GPIO_Init->Mode == 0x12)) {\n        GPIOx->OSPEEDR = GPIOx->OSPEEDR & ~(3 << ((position & 0x7f) << 1));\n        GPIOx->OSPEEDR = GPIOx->OSPEEDR | GPIO_Init->Speed << ((position & 0x7f) << 1);\n        GPIOx->OTYPER = GPIOx->OTYPER & ~(1 << (position & 0xff));\n        GPIOx->OTYPER = GPIOx->OTYPER | (GPIO_Init->Mode >> 4 & 1) << (position & 0xff);\n      }\n      GPIOx->PUPDR = GPIOx->PUPDR & ~(3 << ((position & 0x7f) << 1));\n      GPIOx->PUPDR = GPIOx->PUPDR | GPIO_Init->Pull << ((position & 0x7f) << 1);\n      if ((GPIO_Init->Mode & 0x10000000) != 0) {\n        *(uint *)(DAT_0800719c + 0x44) = *(uint *)(DAT_0800719c + 0x44) | 0x4000;\n        *(uint *)(DAT_080071a0 + ((position >> 2) + 2) * 4) =\n             ~(0xf << ((position & 3) << 2)) & *(uint *)(DAT_080071a0 + ((position >> 2) + 2) * 4);\n        if (GPIOx == DAT_080071a4) {\n          iVar4 = 0;\n        }\n        else if (GPIOx == DAT_080071a8) {\n          iVar4 = 1;\n        }\n        else if (GPIOx == DAT_080071ac) {\n          iVar4 = 2;\n        }\n        else if (GPIOx == DAT_080071b0) {\n          iVar4 = 3;\n        }\n        else if (GPIOx == DAT_080071b4) {\n          iVar4 = 4;\n        }\n        else if (GPIOx == DAT_080071b8) {\n          iVar4 = 5;\n        }\n        else if (GPIOx == DAT_080071bc) {\n          iVar4 = 6;\n        }\n        else if (GPIOx == DAT_080071c0) {\n          iVar4 = 7;\n        }\n        else if (GPIOx == DAT_080071c4) {\n          iVar4 = 8;\n        }\n        else if (GPIOx == DAT_080071c8) {\n          iVar4 = 9;\n        }\n        else {\n          iVar4 = 10;\n        }\n        *(uint *)(DAT_080071a0 + ((position >> 2) + 2) * 4) =\n             iVar4 << ((position & 3) << 2) | *(uint *)(DAT_080071a0 + ((position >> 2) + 2) * 4);\n        *DAT_080071cc = ~uVar3 & *DAT_080071cc;\n        DAT_080071cc[1] = ~uVar3 & DAT_080071cc[1];\n        if ((GPIO_Init->Mode & 0x10000) != 0) {\n          *DAT_080071cc = uVar3 | *DAT_080071cc;\n        }\n        if ((GPIO_Init->Mode & 0x20000) != 0) {\n          DAT_080071cc[1] = uVar3 | DAT_080071cc[1];\n        }\n        DAT_080071cc[2] = ~uVar3 & DAT_080071cc[2];\n        DAT_080071cc[3] = ~uVar3 & DAT_080071cc[3];\n        if ((GPIO_Init->Mode & 0x100000) != 0) {\n          DAT_080071cc[2] = uVar3 | DAT_080071cc[2];\n        }\n        if ((GPIO_Init->Mode & 0x200000) != 0) {\n          DAT_080071cc[3] = uVar3 | DAT_080071cc[3];\n        }\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006e88", 
            "calling": [
                "HAL_RCC_MCOConfig", 
                "gpio_init"
            ], 
            "imported": false, 
            "current_name": "HAL_GPIO_Init"
        }, 
        "coolant_stop": {
            "renaming": {}, 
            "code": "\nvoid coolant_stop(void)\n\n{\n  coolant_mist_off();\n  coolant_flood_off();\n  return;\n}\n\n", 
            "called": [
                "coolant_mist_off", 
                "coolant_flood_off"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000210", 
            "calling": [
                "coolant_init", 
                "coolant_run", 
                "mc_reset"
            ], 
            "imported": false, 
            "current_name": "coolant_stop"
        }, 
        "__aeabi_fcmplt": {
            "renaming": {}, 
            "code": "\nbool __aeabi_fcmplt(void)\n\n{\n  char in_CY;\n  \n  __aeabi_cfcmpeq();\n  return in_CY == '\\0';\n}\n\n", 
            "called": [
                "__aeabi_cfcmpeq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009228", 
            "calling": [
                "planner_reverse_pass_kernel", 
                "plan_buffer_line", 
                "printFloat", 
                "planner_forward_pass_kernel", 
                "gc_execute_line", 
                "settings_store_global_setting"
            ], 
            "imported": false, 
            "current_name": "__aeabi_fcmplt"
        }, 
        "to_millimeters": {
            "renaming": {}, 
            "code": "\nfloat to_millimeters(float value)\n\n{\n  undefined4 in_r0;\n  undefined8 uVar1;\n  \n  if (PTR_gc_080005b0[3] != '\\0') {\n    uVar1 = __aeabi_f2d(in_r0);\n    uVar1 = __muldf3((int)uVar1,(int)((ulonglong)uVar1 >> 0x20),DAT_080005a8,DAT_080005ac);\n    value = (float)__truncdfsf2((int)uVar1,(int)((ulonglong)uVar1 >> 0x20));\n  }\n  return value;\n}\n\n", 
            "called": [
                "__truncdfsf2", 
                "__aeabi_f2d", 
                "__muldf3"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800056c", 
            "calling": [
                "gc_execute_line"
            ], 
            "imported": false, 
            "current_name": "to_millimeters"
        }, 
        "NVIC_ClearPendingIRQ": {
            "renaming": {}, 
            "code": "\nvoid NVIC_ClearPendingIRQ(IRQn_Type IRQn)\n\n{\n  *(int *)(DAT_08006abc + (((uint)(int)IRQn >> 5) + 0x60) * 4) = 1 << (IRQn & 0x1fU);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006a8c", 
            "calling": [
                "HAL_NVIC_ClearPendingIRQ"
            ], 
            "imported": false, 
            "current_name": "NVIC_ClearPendingIRQ"
        }, 
        "settings_reset": {
            "renaming": {}, 
            "code": "\nvoid settings_reset(_Bool reset_all)\n\n{\n  if (reset_all) {\n    *(undefined4 *)PTR_settings_08004d0c = DAT_08004d10;\n    *(undefined4 *)(PTR_settings_08004d0c + 4) = DAT_08004d10;\n    *(undefined4 *)(PTR_settings_08004d0c + 8) = DAT_08004d10;\n    PTR_settings_08004d0c[0xd] = 10;\n    *(undefined4 *)(PTR_settings_08004d0c + 0x10) = DAT_08004d14;\n    *(undefined4 *)(PTR_settings_08004d0c + 0x14) = DAT_08004d18;\n    *(undefined4 *)(PTR_settings_08004d0c + 0x20) = DAT_08004d1c;\n    *(undefined4 *)(PTR_settings_08004d0c + 0x1c) = DAT_08004d20;\n    *(undefined2 *)(PTR_settings_08004d0c + 0x18) = 0;\n    *(undefined2 *)(PTR_settings_08004d0c + 0x1a) = 0xa80;\n    *(undefined4 *)(PTR_settings_08004d0c + 0x24) = DAT_08004d24;\n  }\n  PTR_settings_08004d0c[0x28] = 0;\n  PTR_settings_08004d0c[0x28] = PTR_settings_08004d0c[0x28] | 2;\n  PTR_settings_08004d0c[0x28] = PTR_settings_08004d0c[0x28] | 0x10;\n  *(undefined2 *)(PTR_settings_08004d0c + 0x2a) = 0;\n  *(undefined4 *)(PTR_settings_08004d0c + 0x2c) = DAT_08004d28;\n  *(undefined4 *)(PTR_settings_08004d0c + 0x30) = DAT_08004d14;\n  *(undefined2 *)(PTR_settings_08004d0c + 0x34) = 100;\n  *(undefined4 *)(PTR_settings_08004d0c + 0x38) = 0x3f800000;\n  PTR_settings_08004d0c[0x3c] = 0x19;\n  PTR_settings_08004d0c[0x3d] = 3;\n  PTR_settings_08004d0c[0x3e] = 0x19;\n  write_global_settings();\n  return;\n}\n\n", 
            "called": [
                "write_global_settings"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004c48", 
            "calling": [
                "settings_init", 
                "read_global_settings"
            ], 
            "imported": false, 
            "current_name": "settings_reset"
        }, 
        "__gesf2": {
            "renaming": {}, 
            "code": "\nuint __gesf2(uint param_1,uint param_2)\n\n{\n  bool bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  bool bVar5;\n  \n  uVar2 = param_1 * 2;\n  uVar3 = param_2 * 2;\n  if (((int)uVar2 >> 0x18 == -1 || (int)uVar3 >> 0x18 == -1) &&\n     ((((int)uVar2 >> 0x18 == -1 && ((param_1 & 0x7fffff) != 0)) ||\n      (((int)uVar3 >> 0x18 == -1 && ((param_2 & 0x7fffff) != 0)))))) {\n    return 0xffffffff;\n  }\n  uVar4 = uVar2 | param_2 & 0x7fffffff;\n  bVar5 = uVar4 == 0;\n  if (!bVar5) {\n    uVar4 = param_1 ^ param_2;\n    bVar5 = uVar4 == 0;\n  }\n  bVar1 = -1 < (int)uVar4;\n  if (bVar1) {\n    param_1 = uVar2 + param_2 * -2;\n    bVar5 = param_1 == 0;\n  }\n  if ((bVar1 && uVar3 <= uVar2) && !bVar5) {\n    param_1 = (int)param_2 >> 0x1f;\n  }\n  if (!bVar1 || uVar3 > uVar2) {\n    param_1 = ~((int)param_2 >> 0x1f);\n  }\n  if (!bVar5) {\n    param_1 = param_1 | 1;\n  }\n  return param_1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800918c", 
            "calling": [], 
            "imported": false, 
            "current_name": "__gesf2"
        }, 
        "__aeabi_fcmple": {
            "renaming": {}, 
            "code": "\nbool __aeabi_fcmple(void)\n\n{\n  undefined in_ZR;\n  undefined in_CY;\n  \n  __aeabi_cfcmpeq();\n  return !(bool)in_CY || (bool)in_ZR;\n}\n\n", 
            "called": [
                "__aeabi_cfcmpeq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800923c", 
            "calling": [
                "mc_arc", 
                "gc_execute_line", 
                "settings_store_global_setting"
            ], 
            "imported": false, 
            "current_name": "__aeabi_fcmple"
        }, 
        "HAL_Init": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef HAL_Init(void)\n\n{\n  *DAT_080059f4 = *DAT_080059f4 | 0x200;\n  *DAT_080059f4 = *DAT_080059f4 | 0x400;\n  *DAT_080059f4 = *DAT_080059f4 | 0x100;\n  HAL_SYSTICK_Config(16000);\n  HAL_NVIC_SetPriorityGrouping(3);\n  HAL_MspInit();\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_NVIC_SetPriorityGrouping", 
                "HAL_SYSTICK_Config", 
                "HAL_MspInit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080059b4", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "HAL_Init"
        }, 
        "stepper_motor_enable": {
            "renaming": {}, 
            "code": "\nvoid stepper_motor_enable(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005318", 
            "calling": [
                "st_wake_up"
            ], 
            "imported": false, 
            "current_name": "stepper_motor_enable"
        }, 
        "HAL_SYSTICK_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_SYSTICK_IRQHandler(void)\n\n{\n  HAL_SYSTICK_Callback();\n  return;\n}\n\n", 
            "called": [
                "HAL_SYSTICK_Callback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006e70", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_SYSTICK_IRQHandler"
        }, 
        "HAL_GetREVID": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_GetREVID(void)\n\n{\n  return *DAT_08005ae8 >> 0x10;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005ad4", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_GetREVID"
        }, 
        "HAL_RCC_OscConfig": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef *RCC_OscInitStruct)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint32_t result_2;\n  uint32_t result_3;\n  uint32_t result_4;\n  uint32_t result_5;\n  uint32_t result_6;\n  uint32_t result_7;\n  uint32_t result;\n  uint32_t result_1;\n  uint32_t timeout;\n  \n  if ((RCC_OscInitStruct->OscillatorType & 1) != 0) {\n    if (((DAT_08005fac[2] & 0xc) == 4) ||\n       (((DAT_08005fac[2] & 0xc) == 8 && ((DAT_08005fac[1] & 0x400000) == 0x400000)))) {\n      if (((*DAT_08005fac & 0x20000) != 0) && (RCC_OscInitStruct->HSEState != 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      *DAT_08005fb0 = 0;\n      uVar1 = HAL_GetTick();\n      while ((*DAT_08005fac & 0x20000) != 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 5000 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n      *DAT_08005fb0 = (char)RCC_OscInitStruct->HSEState;\n      if (RCC_OscInitStruct->HSEState == 1) {\n        uVar1 = HAL_GetTick();\n        while ((*DAT_08005fac & 0x20000) == 0) {\n          uVar2 = HAL_GetTick();\n          if (uVar1 + 5000 <= uVar2) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        uVar1 = HAL_GetTick();\n        while ((*DAT_08005fac & 0x20000) != 0) {\n          uVar2 = HAL_GetTick();\n          if (uVar1 + 5000 <= uVar2) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 2) != 0) {\n    if (((DAT_08005fac[2] & 0xc) == 0) ||\n       (((DAT_08005fac[2] & 0xc) == 8 && ((DAT_08005fac[1] & 0x400000) == 0)))) {\n      if (((*DAT_08005fac & 2) != 0) && (RCC_OscInitStruct->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else if (RCC_OscInitStruct->HSIState == 0) {\n      *DAT_08005fb4 = 0;\n      uVar1 = HAL_GetTick();\n      while ((*DAT_08005fac & 2) != 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 100 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005fb4 = 1;\n      uVar1 = HAL_GetTick();\n      while ((*DAT_08005fac & 2) == 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 100 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n      uVar3 = count_leading_zeroes(0x1f000000);\n      *DAT_08005fac =\n           RCC_OscInitStruct->HSICalibrationValue << (uVar3 & 0xff) | *DAT_08005fac & 0xffffff07;\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 8) != 0) {\n    if (RCC_OscInitStruct->LSIState == 0) {\n      *DAT_08005fb8 = 0;\n      uVar1 = HAL_GetTick();\n      while ((DAT_08005fac[0x1d] & 2) != 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 100 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005fb8 = 1;\n      uVar1 = HAL_GetTick();\n      while ((DAT_08005fac[0x1d] & 2) == 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 100 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 4) != 0) {\n    DAT_08005fac[0x10] = DAT_08005fac[0x10] | 0x10000000;\n    *DAT_08005fbc = *DAT_08005fbc | 0x100;\n    uVar1 = HAL_GetTick();\n    while ((*DAT_08005fbc & 0x100) == 0) {\n      uVar2 = HAL_GetTick();\n      if (uVar1 + 100 <= uVar2) {\n        return HAL_TIMEOUT;\n      }\n    }\n    *DAT_08005fc0 = 0;\n    uVar1 = HAL_GetTick();\n    while ((DAT_08006180[0x1c] & 2) != 0) {\n      uVar2 = HAL_GetTick();\n      if (uVar1 + 5000 <= uVar2) {\n        return HAL_TIMEOUT;\n      }\n    }\n    *DAT_08006184 = (char)RCC_OscInitStruct->LSEState;\n    if (RCC_OscInitStruct->LSEState == 1) {\n      uVar1 = HAL_GetTick();\n      while ((DAT_08006180[0x1c] & 2) == 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 5000 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      uVar1 = HAL_GetTick();\n      while ((DAT_08006180[0x1c] & 2) != 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 5000 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct->PLL).PLLState != 0) {\n    if ((DAT_08006180[2] & 0xc) == 8) {\n      return HAL_ERROR;\n    }\n    if ((RCC_OscInitStruct->PLL).PLLState == 2) {\n      *DAT_08006188 = 0;\n      uVar1 = HAL_GetTick();\n      while ((*DAT_08006180 & 0x2000000) != 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 100 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n      uVar3 = count_leading_zeroes(0x3fe0000);\n      uVar4 = count_leading_zeroes(0xc000);\n      uVar5 = count_leading_zeroes(0xf0);\n      DAT_08006180[1] =\n           (RCC_OscInitStruct->PLL).PLLQ << (uVar5 & 0xff) |\n           (RCC_OscInitStruct->PLL).PLLM | (RCC_OscInitStruct->PLL).PLLN << (uVar3 & 0xff) |\n           ((RCC_OscInitStruct->PLL).PLLP >> 1) - 1 << (uVar4 & 0xff) |\n           (RCC_OscInitStruct->PLL).PLLSource | 0x20000000;\n      *DAT_08006188 = 1;\n      uVar1 = HAL_GetTick();\n      while ((*DAT_08006180 & 0x2000000) == 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 100 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08006188 = 0;\n      uVar1 = HAL_GetTick();\n      while ((*DAT_08006180 & 0x2000000) != 0) {\n        uVar2 = HAL_GetTick();\n        if (uVar1 + 100 <= uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005cec", 
            "calling": [
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_OscConfig"
        }, 
        "set_step_pulse_delay": {
            "renaming": {}, 
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid set_step_pulse_delay(uint32_t ticks)\n\n{\n  TIM_TypeDef *TIMx;\n  \n  _DAT_40000034 = ticks;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007c40", 
            "calling": [
                "st_wake_up"
            ], 
            "imported": false, 
            "current_name": "set_step_pulse_delay"
        }, 
        "memset": {
            "renaming": {}, 
            "code": "\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  uint uVar1;\n  uint *puVar2;\n  uint *puVar3;\n  uint *puVar4;\n  uint uVar5;\n  bool bVar6;\n  \n  puVar2 = (uint *)__s;\n  if (((uint)__s & 3) != 0) {\n    uVar5 = __n - 1;\n    puVar3 = (uint *)__s;\n    if (__n == 0) {\n      return __s;\n    }\n    while( true ) {\n      puVar2 = (uint *)((int)puVar3 + 1);\n      *(char *)puVar3 = (char)__c;\n      __n = uVar5;\n      if (((uint)puVar2 & 3) == 0) break;\n      bVar6 = uVar5 == 0;\n      uVar5 = uVar5 - 1;\n      puVar3 = puVar2;\n      if (bVar6) {\n        return __s;\n      }\n    }\n  }\n  if (3 < __n) {\n    uVar5 = __c & 0xffU | (__c & 0xffU) << 8;\n    uVar5 = uVar5 | uVar5 << 0x10;\n    if (0xf < __n) {\n      puVar3 = puVar2 + 4;\n      do {\n        puVar3[-4] = uVar5;\n        puVar3[-3] = uVar5;\n        puVar3[-2] = uVar5;\n        puVar3[-1] = uVar5;\n        puVar3 = puVar3 + 4;\n      } while (puVar3 != (uint *)((int)puVar2 + (__n - 0x10 & 0xfffffff0) + 0x20));\n      uVar1 = __n & 0xc;\n      puVar2 = puVar2 + ((__n - 0x10 >> 4) + 1) * 4;\n      __n = __n & 0xf;\n      if (uVar1 == 0) goto joined_r0x0800b4a8;\n    }\n    puVar3 = (uint *)((__n - 4 & 0xfffffffc) + 4 + (int)puVar2);\n    do {\n      puVar4 = puVar2 + 1;\n      *puVar2 = uVar5;\n      puVar2 = puVar4;\n    } while (puVar3 != puVar4);\n    __n = __n & 3;\n    puVar2 = puVar3;\n  }\njoined_r0x0800b4a8:\n  if (__n != 0) {\n    puVar3 = puVar2;\n    do {\n      puVar4 = (uint *)((int)puVar3 + 1);\n      *(char *)puVar3 = (char)__c;\n      puVar3 = puVar4;\n    } while ((uint *)(__n + (int)puVar2) != puVar4);\n  }\n  return __s;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800b430", 
            "calling": [
                "homing_cycle", 
                "eeprom_init", 
                "gc_init", 
                "plan_init", 
                "grbl_main", 
                "settings_read_coord_data", 
                "st_reset", 
                "gc_execute_line", 
                "mc_go_home", 
                "debounce_init"
            ], 
            "imported": false, 
            "current_name": "memset"
        }, 
        "__aeabi_dcmplt": {
            "renaming": {}, 
            "code": "\nbool __aeabi_dcmplt(void)\n\n{\n  char in_CY;\n  \n  __aeabi_cdcmpeq();\n  return in_CY == '\\0';\n}\n\n", 
            "called": [
                "__aeabi_cdcmpeq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008b24", 
            "calling": [
                "plan_buffer_line", 
                "__ieee754_hypot", 
                "sqrt"
            ], 
            "imported": false, 
            "current_name": "__aeabi_dcmplt"
        }, 
        "__io_putchar": {
            "renaming": {}, 
            "code": "\nint __io_putchar(int ch)\n\n{\n  usart_putc((char)ch);\n  return 0;\n}\n\n", 
            "called": [
                "usart_putc"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800826a", 
            "calling": [], 
            "imported": false, 
            "current_name": "__io_putchar"
        }, 
        "mc_arc": {
            "renaming": {}, 
            "code": "\nvoid mc_arc(float *position,float *target,float *offset,uint8_t axis_0,uint8_t axis_1,\n           uint8_t axis_linear,float feed_rate,uint8_t invert_feed_rate,float radius,\n           uint8_t isclockwise)\n\n{\n  uint uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  int iVar6;\n  float fVar7;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined8 extraout_d0;\n  undefined8 extraout_d0_00;\n  undefined8 extraout_d0_01;\n  float extraout_s2;\n  float z;\n  float extraout_s2_00;\n  float extraout_s3;\n  float feed_rate_00;\n  float extraout_s3_00;\n  float feed_rate_01;\n  undefined8 uVar8;\n  undefined8 uVar9;\n  undefined3 in_stack_00000009;\n  undefined4 in_stack_00000010;\n  char in_stack_00000014;\n  uint in_stack_ffffff78;\n  undefined4 in_stack_ffffff7c;\n  undefined3 in_stack_ffffff80;\n  uint uVar10;\n  byte bVar11;\n  float arc_target [3];\n  float r_axisi;\n  float sin_Ti;\n  float cos_Ti;\n  float sin_T;\n  float cos_T;\n  float linear_per_segment;\n  float theta_per_segment;\n  uint16_t segments;\n  float millimeters_of_travel;\n  float rt_axis1;\n  float rt_axis0;\n  float linear_travel;\n  float center_axis1;\n  float center_axis0;\n  int8_t count;\n  uint16_t i;\n  float angular_travel;\n  float r_axis1;\n  float r_axis0;\n  \n  uVar10 = CONCAT13(axis_0,in_stack_ffffff80);\n  center_axis0 = (float)__addsf3(feed_rate,position[axis_0],offset[axis_0]);\n  center_axis1 = (float)__addsf3(position[axis_1],offset[axis_1]);\n  uVar1 = __aeabi_fsub(target[axis_linear],position[axis_linear]);\n  bVar11 = (byte)(uVar10 >> 0x18);\n  r_axis0 = (float)((uint)offset[bVar11] ^ 0x80000000);\n  r_axis1 = (float)((uint)offset[axis_1] ^ 0x80000000);\n  uVar2 = __aeabi_fsub(target[bVar11],center_axis0);\n  uVar3 = __aeabi_fsub(target[axis_1],center_axis1);\n  uVar4 = __aeabi_fmul(r_axis0,uVar3);\n  uVar5 = __aeabi_fmul(r_axis1,uVar2);\n  uVar4 = __aeabi_fsub(uVar4,uVar5);\n  uVar8 = __aeabi_f2d(uVar4);\n  uVar2 = __aeabi_fmul(r_axis0,uVar2);\n  uVar3 = __aeabi_fmul(r_axis1,uVar3);\n  uVar2 = __addsf3(uVar2,uVar3);\n  uVar9 = __aeabi_f2d(uVar2);\n  uVar8 = atan2((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),(int)uVar9,\n                (int)((ulonglong)uVar9 >> 0x20));\n  angular_travel = (float)__truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n  if (in_stack_00000014 == '\\0') {\n    iVar6 = __aeabi_fcmple(angular_travel,0);\n    if (iVar6 != 0) {\n      uVar8 = __aeabi_f2d(angular_travel);\n      uVar8 = __aeabi_dadd((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),DAT_08002240,DAT_08002244);\n      angular_travel = (float)__truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n    }\n  }\n  else {\n    iVar6 = __aeabi_fcmpge(angular_travel,0);\n    if (iVar6 != 0) {\n      uVar8 = __aeabi_f2d(angular_travel);\n      uVar8 = __subdf3((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),DAT_08002240,DAT_08002244);\n      angular_travel = (float)__truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n    }\n  }\n  uVar2 = __aeabi_fmul(angular_travel,in_stack_00000010);\n  uVar2 = __aeabi_f2d(uVar2);\n  __aeabi_f2d(uVar1 & 0x7fffffff);\n  hypot((double)CONCAT44(in_stack_ffffff7c,in_stack_ffffff78),(double)CONCAT44(offset,uVar10));\n  uVar2 = __truncdfsf2(uVar2,extraout_r1);\n  iVar6 = __aeabi_fcmpeq(uVar2,0);\n  if (iVar6 == 0) {\n    uVar2 = __aeabi_fdiv(uVar2,*(undefined4 *)(PTR_settings_08002248 + 0x1c));\n    uVar2 = __aeabi_f2d(uVar2);\n    floor((double)CONCAT44(in_stack_ffffff7c,in_stack_ffffff78));\n    segments = __aeabi_d2uiz(uVar2,extraout_r1_00);\n    if (isclockwise != '\\0') {\n      uVar2 = __floatsisf(segments);\n      __aeabi_fmul(_invert_feed_rate,uVar2);\n    }\n    uVar2 = __floatsisf(segments);\n    sin_T = (float)__aeabi_fdiv(angular_travel,uVar2);\n    uVar2 = __floatsisf(segments);\n    linear_per_segment = (float)__aeabi_fdiv(uVar1,uVar2);\n    uVar8 = __aeabi_f2d(sin_T);\n    uVar8 = __muldf3((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),0,DAT_0800224c);\n    uVar9 = __aeabi_f2d(sin_T);\n    uVar8 = __muldf3((int)uVar8,(int)((ulonglong)uVar8 >> 0x20),(int)uVar9,\n                     (int)((ulonglong)uVar9 >> 0x20));\n    uVar8 = __subdf3(0,DAT_08002250,(int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n    cos_T = (float)__truncdfsf2((int)uVar8,(int)((ulonglong)uVar8 >> 0x20));\n    count = '\\0';\n    theta_per_segment = sin_T;\n    arc_target[axis_linear] = position[axis_linear];\n    uVar8 = extraout_d0;\n    fVar7 = extraout_s2;\n    feed_rate_01 = extraout_s3;\n    for (i = 1; i < segments; i = i + 1) {\n      if ((int)count < (int)(uint)(byte)PTR_settings_08002248[0x3e]) {\n        uVar2 = __aeabi_fmul(r_axis0,sin_T);\n        uVar3 = __aeabi_fmul(r_axis1,cos_T);\n        fVar7 = (float)__addsf3(uVar2,uVar3);\n        uVar2 = __aeabi_fmul(r_axis0,cos_T);\n        uVar3 = __aeabi_fmul(r_axis1,sin_T);\n        r_axis0 = (float)__aeabi_fsub(uVar2,uVar3);\n        count = count + '\\x01';\n        r_axis1 = fVar7;\n      }\n      else {\n        uVar2 = __floatsisf(i);\n        uVar2 = __aeabi_fmul(uVar2,theta_per_segment);\n        uVar2 = __aeabi_f2d(uVar2);\n        cos((double)CONCAT44(in_stack_ffffff7c,in_stack_ffffff78));\n        uVar2 = __truncdfsf2(uVar2,extraout_r1_01);\n        uVar3 = __floatsisf(i);\n        uVar3 = __aeabi_fmul(uVar3,theta_per_segment);\n        uVar3 = __aeabi_f2d(uVar3);\n        sin((double)CONCAT44(in_stack_ffffff7c,in_stack_ffffff78));\n        uVar3 = __truncdfsf2(uVar3,extraout_r1_02);\n        uVar4 = __aeabi_fmul((uint)offset[uVar10 >> 0x18] ^ 0x80000000,uVar2);\n        uVar5 = __aeabi_fmul(offset[axis_1],uVar3);\n        r_axis0 = (float)__addsf3(uVar4,uVar5);\n        uVar3 = __aeabi_fmul((uint)offset[uVar10 >> 0x18] ^ 0x80000000,uVar3);\n        uVar2 = __aeabi_fmul(offset[axis_1],uVar2);\n        r_axis1 = (float)__aeabi_fsub(uVar3,uVar2);\n        count = '\\0';\n      }\n      uVar1 = uVar10 >> 0x18;\n      fVar7 = (float)__addsf3(center_axis0,r_axis0);\n      arc_target[uVar1] = fVar7;\n      fVar7 = (float)__addsf3(center_axis1,r_axis1);\n      arc_target[axis_1] = fVar7;\n      fVar7 = (float)__addsf3(arc_target[axis_linear],linear_per_segment);\n      arc_target[axis_linear] = fVar7;\n      in_stack_ffffff78 = (uint)isclockwise;\n      mc_line((float)extraout_d0_00,(float)((ulonglong)extraout_d0_00 >> 0x20),z,feed_rate_00,\n              SUB41(arc_target[0],0));\n      if (*PTR_sys_08002404 != '\\0') {\n        return;\n      }\n      uVar8 = extraout_d0_01;\n      fVar7 = extraout_s2_00;\n      feed_rate_01 = extraout_s3_00;\n    }\n    mc_line((float)uVar8,(float)((ulonglong)uVar8 >> 0x20),fVar7,feed_rate_01,SUB41(*target,0));\n  }\n  return;\n}\n\n", 
            "called": [
                "__floatsisf", 
                "hypot", 
                "__aeabi_fdiv", 
                "__muldf3", 
                "floor", 
                "__aeabi_fmul", 
                "__subdf3", 
                "atan2", 
                "__addsf3", 
                "__aeabi_fcmpeq", 
                "__truncdfsf2", 
                "__aeabi_f2d", 
                "sin", 
                "__aeabi_d2uiz", 
                "__aeabi_fsub", 
                "__aeabi_fcmple", 
                "__aeabi_dadd", 
                "__aeabi_fcmpge", 
                "cos", 
                "mc_line"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001f00", 
            "calling": [
                "gc_execute_line"
            ], 
            "imported": false, 
            "current_name": "mc_arc"
        }, 
        "FUN_0800881c": {
            "renaming": {}, 
            "code": "\nulonglong FUN_0800881c(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  uint in_r12;\n  bool bVar4;\n  \n  uVar2 = in_r12 & param_4 >> 0x14;\n  if (unaff_r4 != in_r12 && uVar2 != in_r12) {\n    bVar4 = (param_1 | param_2 << 1) == 0;\n    if (!bVar4) {\n      bVar4 = (param_3 | param_4 << 1) == 0;\n    }\n    if (bVar4) {\n      return (ulonglong)((param_2 ^ param_4) & 0x80000000) << 0x20;\n    }\n    if (unaff_r4 == 0) {\n      uVar3 = param_2 & 0x80000000;\n      do {\n        uVar1 = param_1 & 0x80000000;\n        param_1 = param_1 << 1;\n        param_2 = param_2 * 2 + (uint)(uVar1 != 0);\n      } while ((param_2 & 0x100000) == 0);\n      param_2 = param_2 | uVar3;\n      if (uVar2 != 0) {\n        return CONCAT44(param_2,param_1);\n      }\n    }\n    do {\n      uVar2 = param_3 & 0x80000000;\n      param_3 = param_3 << 1;\n      param_4 = param_4 * 2 + (uint)(uVar2 != 0);\n    } while ((param_4 & 0x100000) == 0);\n    return CONCAT44(param_2,param_1);\n  }\n  bVar4 = (param_1 | param_2 << 1) == 0;\n  if (bVar4) {\n    param_2 = param_4;\n    param_1 = param_3;\n  }\n  if (!bVar4) {\n    bVar4 = (param_3 | param_4 << 1) == 0;\n  }\n  uVar3 = param_2;\n  if (((!bVar4) && ((unaff_r4 != in_r12 || ((param_1 | param_2 << 0xc) == 0)))) &&\n     ((uVar2 != in_r12 || (param_1 = param_3, uVar3 = param_4, (param_3 | param_4 << 0xc) == 0)))) {\n    return (ulonglong)((param_2 ^ param_4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(uVar3,param_1) | 0x7ff8000000000000;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": false, 
            "entrypoint": "0x0800881c", 
            "calling": [
                "__muldf3"
            ], 
            "imported": false, 
            "current_name": "FUN_0800881c"
        }, 
        "HAL_EnableDBGSleepMode": {
            "renaming": {}, 
            "code": "\nvoid HAL_EnableDBGSleepMode(void)\n\n{\n  *(uint *)(DAT_08005b1c + 4) = *(uint *)(DAT_08005b1c + 4) | 1;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005b04", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_EnableDBGSleepMode"
        }, 
        "limits_init": {
            "renaming": {}, 
            "code": "\nvoid limits_init(void)\n\n{\n  if ((PTR_settings_08001954[0x28] & 8) == 0) {\n    *(undefined4 *)PTR_limits_enabled_08001958 = 0;\n  }\n  else {\n    *(undefined4 *)PTR_limits_enabled_08001958 = 1;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800192c", 
            "calling": [
                "grbl_main", 
                "settings_store_global_setting"
            ], 
            "imported": false, 
            "current_name": "limits_init"
        }, 
        "atexit": {
            "renaming": {}, 
            "code": "\nint atexit(__func *__func)\n\n{\n  int iVar1;\n  \n  iVar1 = __register_exitproc(0,__func,0);\n  return iVar1;\n}\n\n", 
            "called": [
                "__register_exitproc"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800b4e4", 
            "calling": [
                "register_fini"
            ], 
            "imported": false, 
            "current_name": "atexit"
        }, 
        "serial_write": {
            "renaming": {}, 
            "code": "\nvoid serial_write(uint8_t data)\n\n{\n  usart_putc(data);\n  return;\n}\n\n", 
            "called": [
                "usart_putc"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008250", 
            "calling": [
                "printString", 
                "printPgmString", 
                "printFloat", 
                "printInteger", 
                "print_base2", 
                "print_uint32_base10"
            ], 
            "imported": false, 
            "current_name": "serial_write"
        }, 
        "dirn_wr": {
            "renaming": {}, 
            "code": "\nvoid dirn_wr(uint32_t x)\n\n{\n  uint32_t val;\n  \n  *(uint32_t *)(DAT_08005308 + 0x14) = x | *(uint *)(DAT_08005308 + 0x14) & 0xfffff55f;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080052dc", 
            "calling": [
                "step_period_isr"
            ], 
            "imported": false, 
            "current_name": "dirn_wr"
        }, 
        "st_feed_hold": {
            "renaming": {}, 
            "code": "\nvoid st_feed_hold(void)\n\n{\n  if (PTR_sys_0800589c[1] == '\\x03') {\n    PTR_sys_0800589c[1] = 4;\n    PTR_sys_0800589c[0x10] = 0;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800587c", 
            "calling": [
                "protocol_execute_runtime"
            ], 
            "imported": false, 
            "current_name": "st_feed_hold"
        }, 
        "estimate_acceleration_distance": {
            "renaming": {}, 
            "code": "\nfloat estimate_acceleration_distance(float initial_rate,float target_rate,float acceleration)\n\n{\n  undefined4 in_r0;\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 in_r1;\n  undefined4 in_r2;\n  float fVar3;\n  \n  uVar1 = __aeabi_fmul(in_r1,in_r1);\n  uVar2 = __aeabi_fmul(in_r0,in_r0);\n  uVar1 = __aeabi_fsub(uVar1,uVar2);\n  uVar2 = __addsf3(in_r2,in_r2);\n  fVar3 = (float)__aeabi_fdiv(uVar1,uVar2);\n  return fVar3;\n}\n\n", 
            "called": [
                "__addsf3", 
                "__aeabi_fdiv", 
                "__aeabi_fsub", 
                "__aeabi_fmul"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080028bc", 
            "calling": [
                "calculate_trapezoid_for_block"
            ], 
            "imported": false, 
            "current_name": "estimate_acceleration_distance"
        }, 
        "print_uint32_base10": {
            "renaming": {}, 
            "code": "\nvoid print_uint32_base10(ulong n)\n\n{\n  uint uVar1;\n  ulong local_1c;\n  uint8_t uStack_15;\n  uchar buf [10];\n  uint8_t i;\n  \n  i = '\\0';\n  local_1c = n;\n  if (n == 0) {\n    serial_write('0');\n  }\n  else {\n    for (; local_1c != 0; local_1c = (ulong)((ulonglong)DAT_080037f8 * (ulonglong)local_1c >> 0x23))\n    {\n      uVar1 = (uint)i;\n      i = i + '\\x01';\n      buf[uVar1] = (char)local_1c +\n                   (char)(uint)((ulonglong)DAT_080037f8 * (ulonglong)local_1c >> 0x23) * -10 + '0';\n    }\n    for (; i != '\\0'; i = i + 0xff) {\n      serial_write(buf[i - 1]);\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "serial_write"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003778", 
            "calling": [
                "printInteger"
            ], 
            "imported": false, 
            "current_name": "print_uint32_base10"
        }, 
        "read_global_settings": {
            "renaming": {}, 
            "code": "\nuint8_t read_global_settings(void)\n\n{\n  byte bVar1;\n  int iVar2;\n  uint8_t version;\n  \n  bVar1 = eeprom_get_char(0);\n  if (bVar1 == 5) {\n    iVar2 = memcpy_from_eeprom_with_checksum(PTR_settings_08004e2c,1,0x40);\n    if (iVar2 == 0) {\n      return '\\0';\n    }\n  }\n  else {\n    if (4 < bVar1) {\n      return '\\0';\n    }\n    iVar2 = memcpy_from_eeprom_with_checksum(PTR_settings_08004e2c,1,0x28);\n    if (iVar2 == 0) {\n      return '\\0';\n    }\n    settings_reset(false);\n  }\n  return '\\x01';\n}\n\n", 
            "called": [
                "eeprom_get_char", 
                "settings_reset", 
                "memcpy_from_eeprom_with_checksum"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004dd2", 
            "calling": [
                "settings_init"
            ], 
            "imported": false, 
            "current_name": "read_global_settings"
        }, 
        "protocol_reset_line_buffer": {
            "renaming": {}, 
            "code": "\nvoid protocol_reset_line_buffer(void)\n\n{\n  *PTR_char_counter_08003998 = 0;\n  *PTR_iscomment_0800399c = 0;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003980", 
            "calling": [
                "protocol_init", 
                "protocol_process"
            ], 
            "imported": false, 
            "current_name": "protocol_reset_line_buffer"
        }, 
        "HAL_GPIO_WritePin": {
            "renaming": {}, 
            "code": "\nvoid HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx,uint16_t GPIO_Pin,GPIO_PinState PinState)\n\n{\n  if (PinState == GPIO_PIN_RESET) {\n    GPIOx->BSRRH = GPIO_Pin;\n  }\n  else {\n    GPIOx->BSRRL = GPIO_Pin;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800733e", 
            "calling": [
                "gpio_init"
            ], 
            "imported": false, 
            "current_name": "HAL_GPIO_WritePin"
        }, 
        "stepper_motor_disable": {
            "renaming": {}, 
            "code": "\nvoid stepper_motor_disable(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800530c", 
            "calling": [
                "st_go_idle"
            ], 
            "imported": false, 
            "current_name": "stepper_motor_disable"
        }, 
        "scalbn": {
            "renaming": {}, 
            "code": "\ndouble scalbn(double __x,int __n)\n\n{\n  uint in_r1;\n  int in_r2;\n  uint uVar1;\n  int iVar2;\n  uint uVar3;\n  double in_d0;\n  double extraout_d0;\n  double dVar4;\n  ulonglong uVar5;\n  \n  uVar5 = CONCAT44(in_r1,__n);\n  uVar1 = (in_r1 << 1) >> 0x15;\n  if (uVar1 == 0) {\n    if ((__n | in_r1 & 0x7fffffff) == 0) {\n      return in_d0;\n    }\n    uVar5 = __muldf3(__n,in_r1,0,DAT_0800b3c8);\n    if (in_r2 < DAT_0800b3cc) goto LAB_0800b34a;\n    uVar1 = ((uint)((int)(uVar5 >> 0x20) << 1) >> 0x15) - 0x36;\n    in_d0 = extraout_d0;\n  }\n  else if (uVar1 == 0x7ff) {\n    dVar4 = (double)__aeabi_dadd(__n,in_r1,__n);\n    return dVar4;\n  }\n  uVar3 = (uint)(uVar5 >> 0x20);\n  iVar2 = uVar1 + in_r2;\n  if (iVar2 < 0x7ff) {\n    if (0 < iVar2) {\n      return in_d0;\n    }\n    if (iVar2 + 0x35 < 0 == SCARRY4(iVar2,0x35)) {\n      dVar4 = (double)__muldf3((int)uVar5,uVar3 & 0x800fffff | (iVar2 + 0x36) * 0x100000,0,\n                               DAT_0800b3d8);\n      return dVar4;\n    }\n    if (in_r2 < 0xc351) {\n      uVar5 = uVar5 & 0x8000000000000000 | (ulonglong)DAT_0800b3d0 | 0x1a56e1f00000000;\nLAB_0800b34a:\n      dVar4 = (double)__muldf3((int)uVar5,(int)(uVar5 >> 0x20),DAT_0800b3b8,DAT_0800b3bc);\n      return dVar4;\n    }\n  }\n  dVar4 = (double)__muldf3(DAT_0800b3d4,uVar3 & 0x80000000 | 0x7e37e43c,DAT_0800b3c0,DAT_0800b3c4);\n  return dVar4;\n}\n\n", 
            "called": [
                "__muldf3", 
                "__aeabi_dadd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800b2e8", 
            "calling": [
                "__kernel_rem_pio2"
            ], 
            "imported": false, 
            "current_name": "scalbn"
        }, 
        "protocol_execute_line": {
            "renaming": {}, 
            "code": "\nuint8_t protocol_execute_line(char *line)\n\n{\n  byte bVar1;\n  uint8_t uVar2;\n  int iVar3;\n  undefined4 uVar4;\n  undefined4 extraout_r1;\n  uint uVar5;\n  float value_00;\n  undefined4 in_stack_ffffffe0;\n  float value;\n  float parameter;\n  uint8_t char_counter;\n  uint8_t helper_var;\n  \n  if (*line != '$') {\n    uVar2 = gc_execute_line(line);\n    return uVar2;\n  }\n  char_counter = '\\x01';\n  helper_var = '\\0';\n  bVar1 = line[1];\n  if (bVar1 == 0) {\n    report_grbl_help();\n    return '\\0';\n  }\n  if ((0x58 < bVar1) || (bVar1 < 0x23)) goto switchD_08003bdc_caseD_25;\n  switch(bVar1) {\n  case 0x23:\n    char_counter = '\\x02';\n    if (line[2] != '\\0') {\n      return '\\x03';\n    }\n    report_gcode_parameters();\n    break;\n  case 0x24:\n    char_counter = '\\x02';\n    if (line[2] != '\\0') {\n      return '\\x03';\n    }\n    report_grbl_settings();\n    break;\n  case 0x43:\n    char_counter = '\\x02';\n    if (line[2] != '\\0') {\n      return '\\x03';\n    }\n    if (PTR_sys_08003f2c[1] == '\\a') {\n      mc_reset();\n      report_feedback_message('\\x05');\n    }\n    else {\n      if (PTR_sys_08003f2c[1] != '\\0') {\n        return '\\v';\n      }\n      PTR_sys_08003f2c[1] = 7;\n      report_feedback_message('\\x04');\n    }\n    break;\n  case 0x47:\n    char_counter = '\\x02';\n    if (line[2] != '\\0') {\n      return '\\x03';\n    }\n    report_gcode_modes();\n    break;\n  case 0x48:\n    if ((PTR_settings_08003f30[0x28] & 0x10) == 0) {\n      return '\\a';\n    }\n    if ((PTR_sys_08003f2c[1] != '\\0') && (PTR_sys_08003f2c[1] != '\\x06')) {\n      return '\\v';\n    }\n    mc_go_home();\n    if (*PTR_sys_08003f2c == '\\0') {\n      protocol_execute_startup();\n    }\n    break;\n  case 0x4e:\n    char_counter = '\\x02';\n    if (line[2] == '\\0') {\n      for (helper_var = '\\0'; helper_var < 2; helper_var = helper_var + '\\x01') {\n        uVar2 = settings_read_startup_line(helper_var,line);\n        if (uVar2 == '\\0') {\n          report_status_message('\\n');\n        }\n        else {\n          report_startup_line(helper_var,line);\n        }\n      }\n      return '\\0';\n    }\n    helper_var = '\\x01';\n  default:\nswitchD_08003bdc_caseD_25:\n    iVar3 = read_float(line,&char_counter,&parameter);\n    if (iVar3 == 0) {\n      return '\\x01';\n    }\n    bVar1 = char_counter + 1;\n    if (line[char_counter] != '=') {\n      return '\\x03';\n    }\n    char_counter = bVar1;\n    if (helper_var == '\\0') {\n      iVar3 = read_float(line,&char_counter,&value);\n      if (iVar3 == 0) {\n        return '\\x01';\n      }\n      if (line[char_counter] == '\\0') {\n        iVar3 = __aeabi_f2iz(parameter);\n        uVar2 = settings_store_global_setting(iVar3,value_00);\n        return uVar2;\n      }\n      return '\\x03';\n    }\n    do {\n      line[(uint)char_counter - (uint)bVar1] = line[char_counter];\n      uVar5 = (uint)char_counter;\n      char_counter = char_counter + '\\x01';\n    } while (line[uVar5] != '\\0');\n    helper_var = bVar1;\n    helper_var = gc_execute_line(line);\n    if (helper_var != '\\0') {\n      return helper_var;\n    }\n    uVar4 = __aeabi_f2d(parameter);\n    trunc((double)CONCAT44(line,in_stack_ffffffe0));\n    helper_var = __aeabi_d2uiz(uVar4,extraout_r1);\n    settings_store_startup_line(helper_var,line);\n    break;\n  case 0x58:\n    char_counter = '\\x02';\n    if (line[2] != '\\0') {\n      return '\\x03';\n    }\n    if (PTR_sys_08003f2c[1] == '\\x06') {\n      report_feedback_message('\\x03');\n      PTR_sys_08003f2c[1] = 0;\n    }\n  }\n  return '\\0';\n}\n\n", 
            "called": [
                "report_startup_line", 
                "settings_store_startup_line", 
                "protocol_execute_startup", 
                "report_status_message", 
                "settings_read_startup_line", 
                "settings_store_global_setting", 
                "report_grbl_help", 
                "read_float", 
                "report_gcode_modes", 
                "report_feedback_message", 
                "__aeabi_d2uiz", 
                "__aeabi_f2d", 
                "mc_reset", 
                "__aeabi_f2iz", 
                "gc_execute_line", 
                "trunc", 
                "report_grbl_settings", 
                "mc_go_home", 
                "report_gcode_parameters"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003b98", 
            "calling": [
                "protocol_process"
            ], 
            "imported": false, 
            "current_name": "protocol_execute_line"
        }, 
        "HAL_NVIC_DisableIRQ": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_DisableIRQ(IRQn_Type IRQn)\n\n{\n  NVIC_DisableIRQ(IRQn);\n  return;\n}\n\n", 
            "called": [
                "NVIC_DisableIRQ"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006d4a", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_NVIC_DisableIRQ"
        }, 
        "floor": {
            "renaming": {}, 
            "code": "\ndouble floor(double __x)\n\n{\n  uint in_r0;\n  uint in_r1;\n  uint uVar1;\n  uint uVar2;\n  double in_d0;\n  double extraout_d0;\n  double extraout_d0_00;\n  double extraout_d0_01;\n  undefined8 uVar3;\n  \n  uVar2 = (in_r1 << 1) >> 0x15;\n  uVar1 = uVar2 - 0x3ff;\n  if ((int)uVar1 < 0x14) {\n    if ((int)uVar1 < 0) {\n      uVar3 = __aeabi_dadd(in_r0,in_r1,DAT_080095a8,DAT_080095ac);\n      __aeabi_dcmpgt((int)uVar3,(int)((ulonglong)uVar3 >> 0x20),0,0);\n      in_d0 = extraout_d0_01;\n    }\n    else if ((in_r1 & DAT_080095b0 >> (uVar1 & 0xff) | in_r0) != 0) {\n      uVar3 = __aeabi_dadd(in_r0,in_r1,DAT_080095a8,DAT_080095ac);\n      __aeabi_dcmpgt((int)uVar3,(int)((ulonglong)uVar3 >> 0x20),0,0);\n      in_d0 = extraout_d0;\n    }\n  }\n  else if ((int)uVar1 < 0x34) {\n    if ((0xffffffffU >> (uVar2 - 0x413 & 0xff) & in_r0) != 0) {\n      uVar3 = __aeabi_dadd(in_r0,in_r1,DAT_080095a8,DAT_080095ac);\n      __aeabi_dcmpgt((int)uVar3,(int)((ulonglong)uVar3 >> 0x20),0,0);\n      in_d0 = extraout_d0_00;\n    }\n  }\n  else if (uVar1 == 0x400) {\n    in_d0 = (double)__aeabi_dadd();\n  }\n  return in_d0;\n}\n\n", 
            "called": [
                "__aeabi_dcmpgt", 
                "__aeabi_dadd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080094c0", 
            "calling": [
                "mc_arc", 
                "__kernel_rem_pio2", 
                "mc_dwell", 
                "calculate_trapezoid_for_block"
            ], 
            "imported": false, 
            "current_name": "floor"
        }, 
        "eeprom_get_char": {
            "renaming": {}, 
            "code": "\nchar eeprom_get_char(uint addr)\n\n{\n  if (*(int *)PTR_eeprom_ready_08000338 == 0) {\n    eeprom_init();\n  }\n  return PTR_eeprom_data_0800033c[addr & 0x3ff];\n}\n\n", 
            "called": [
                "eeprom_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000310", 
            "calling": [
                "memcpy_from_eeprom_with_checksum", 
                "read_global_settings"
            ], 
            "imported": false, 
            "current_name": "eeprom_get_char"
        }, 
        "SVC_Handler": {
            "renaming": {}, 
            "code": "\nvoid SVC_Handler(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007732", 
            "calling": [], 
            "imported": false, 
            "current_name": "SVC_Handler"
        }, 
        "SystemClock_Config": {
            "renaming": {}, 
            "code": "\nvoid SystemClock_Config(void)\n\n{\n  HAL_StatusTypeDef HVar1;\n  RCC_OscInitTypeDef RCC_OscInitStruct;\n  RCC_ClkInitTypeDef RCC_ClkInitStruct;\n  \n  *(uint *)(DAT_080074c0 + 0x40) = *(uint *)(DAT_080074c0 + 0x40) | 0x10000000;\n  *DAT_080074c4 = *DAT_080074c4 | 0xc000;\n  RCC_OscInitStruct.OscillatorType = 1;\n  RCC_OscInitStruct.HSEState = 1;\n  RCC_OscInitStruct.PLL.PLLState = 2;\n  RCC_OscInitStruct.PLL.PLLSource = 0x400000;\n  RCC_OscInitStruct.PLL.PLLM = 8;\n  RCC_OscInitStruct.PLL.PLLN = 0x150;\n  RCC_OscInitStruct.PLL.PLLP = 2;\n  RCC_OscInitStruct.PLL.PLLQ = 7;\n  HVar1 = HAL_RCC_OscConfig(&RCC_OscInitStruct);\n  if (HVar1 != HAL_OK) {\n    Error_Handler();\n  }\n  RCC_ClkInitStruct.ClockType = 0xf;\n  RCC_ClkInitStruct.SYSCLKSource = 2;\n  RCC_ClkInitStruct.AHBCLKDivider = 0;\n  RCC_ClkInitStruct.APB1CLKDivider = 0x1400;\n  RCC_ClkInitStruct.APB2CLKDivider = 0x1000;\n  HVar1 = HAL_RCC_ClockConfig(&RCC_ClkInitStruct,5);\n  if (HVar1 != HAL_OK) {\n    Error_Handler();\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_RCC_OscConfig", 
                "HAL_RCC_ClockConfig", 
                "Error_Handler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007436", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "SystemClock_Config"
        }, 
        "st_cycle_start": {
            "renaming": {}, 
            "code": "\nvoid st_cycle_start(void)\n\n{\n  if (PTR_sys_08005878[1] == '\\x02') {\n    PTR_sys_08005878[1] = 3;\n    st_wake_up();\n  }\n  return;\n}\n\n", 
            "called": [
                "st_wake_up"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800585c", 
            "calling": [
                "protocol_execute_runtime", 
                "mc_line", 
                "mc_go_home"
            ], 
            "imported": false, 
            "current_name": "st_cycle_start"
        }, 
        "step_isr_enable": {
            "renaming": {}, 
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid step_isr_enable(void)\n\n{\n  TIM_TypeDef *TIMx;\n  uint32_t enable;\n  \n  enable = 1;\n  if (_DAT_40000034 != 0) {\n    enable = 3;\n  }\n  if (_DAT_40000038 != 0) {\n    enable = enable | 4;\n  }\n  _DAT_4000000c = _DAT_4000000c | enable;\n  _DAT_40000000 = _DAT_40000000 | 1;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007b70", 
            "calling": [
                "st_wake_up"
            ], 
            "imported": false, 
            "current_name": "step_isr_enable"
        }, 
        "mc_go_home": {
            "renaming": {}, 
            "code": "\nvoid mc_go_home(void)\n\n{\n  uint8_t invert_feed_rate;\n  undefined4 uVar1;\n  undefined8 uVar2;\n  float z;\n  float feed_rate;\n  int8_t z_dir;\n  int8_t y_dir;\n  int8_t x_dir;\n  \n  PTR_sys_080025d8[1] = 5;\n  *(undefined4 *)PTR_limits_enabled_080025dc = 0;\n  limits_go_home();\n  protocol_execute_runtime();\n  if (*PTR_sys_080025d8 == '\\0') {\n    memset(DAT_080025e0,0,0xc);\n    sys_sync_current_position();\n    PTR_sys_080025d8[1] = 0;\n    if ((*(ushort *)(PTR_settings_080025e4 + 0x2a) & 0x20) == 0) {\n      x_dir = -1;\n    }\n    else {\n      x_dir = '\\x01';\n    }\n    if ((*(ushort *)(PTR_settings_080025e4 + 0x2a) & 0x80) == 0) {\n      y_dir = -1;\n    }\n    else {\n      y_dir = '\\x01';\n    }\n    if ((*(ushort *)(PTR_settings_080025e4 + 0x2a) & 0x200) == 0) {\n      z_dir = -1;\n    }\n    else {\n      z_dir = '\\x01';\n    }\n    uVar1 = __floatsisf((int)x_dir);\n    invert_feed_rate = __aeabi_fmul(uVar1,*(undefined4 *)(PTR_settings_080025e4 + 0x38));\n    uVar1 = __floatsisf((int)y_dir);\n    __aeabi_fmul(uVar1,*(undefined4 *)(PTR_settings_080025e4 + 0x38));\n    uVar1 = __floatsisf((int)z_dir);\n    uVar2 = __aeabi_fmul(uVar1,*(undefined4 *)(PTR_settings_080025e4 + 0x38));\n    mc_line((float)uVar2,(float)((ulonglong)uVar2 >> 0x20),z,feed_rate,invert_feed_rate);\n    st_cycle_start();\n    plan_synchronize();\n    sys_sync_current_position();\n    if ((PTR_settings_080025e4[0x28] & 8) != 0) {\n      *(undefined4 *)PTR_limits_enabled_080025dc = 1;\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "protocol_execute_runtime", 
                "__floatsisf", 
                "sys_sync_current_position", 
                "__aeabi_fmul", 
                "plan_synchronize", 
                "limits_go_home", 
                "st_cycle_start", 
                "mc_line", 
                "memset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080024c4", 
            "calling": [
                "protocol_execute_line"
            ], 
            "imported": false, 
            "current_name": "mc_go_home"
        }, 
        "__floatsisf": {
            "renaming": {}, 
            "code": "\nuint __floatsisf(uint param_1)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  uint uVar5;\n  \n  uVar3 = param_1 & 0x80000000;\n  if ((int)uVar3 < 0) {\n    param_1 = -param_1;\n  }\n  if (param_1 == 0) {\n    return 0;\n  }\n  iVar1 = count_leading_zeroes(param_1);\n  uVar2 = iVar1 - 8;\n  iVar4 = ((uVar3 | 0x4b000000) - 0x800000) + uVar2 * -0x800000;\n  if (7 < iVar1) {\n    uVar5 = 0 << (uVar2 & 0xff);\n    uVar3 = iVar4 + (param_1 << (uVar2 & 0xff)) +\n            (0U >> (0x20 - uVar2 & 0xff)) + (uint)(0x7fffffff < uVar5);\n    if (uVar5 == 0x80000000) {\n      uVar3 = uVar3 & 0xfffffffe;\n    }\n    return uVar3;\n  }\n  uVar2 = param_1 << (iVar1 + 0x18U & 0xff);\n  uVar3 = iVar4 + ((param_1 >> (0x20 - (iVar1 + 0x18U) & 0xff)) - ((int)uVar2 >> 0x1f));\n  if ((uVar2 & 0x7fffffff) == 0) {\n    uVar3 = uVar3 & ~(uVar2 >> 0x1f);\n  }\n  return uVar3;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08008e44", 
            "calling": [
                "report_realtime_status", 
                "gc_set_current_position", 
                "mc_arc", 
                "plan_buffer_line", 
                "mc_dwell", 
                "calculate_trapezoid_for_block", 
                "plan_cycle_reinitialize", 
                "mc_go_home"
            ], 
            "imported": false, 
            "current_name": "__floatsisf"
        }, 
        "HAL_GetDEVID": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_GetDEVID(void)\n\n{\n  return *DAT_08005b00 & 0xfff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005aec", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_GetDEVID"
        }, 
        "round": {
            "renaming": {}, 
            "code": "\ndouble round(double __x)\n\n{\n  int in_r1;\n  int iVar1;\n  double in_d0;\n  \n  iVar1 = ((uint)(in_r1 << 1) >> 0x15) - 0x3ff;\n  if (((0x13 < iVar1) && (0x33 < iVar1)) && (iVar1 == 0x400)) {\n    in_d0 = (double)__aeabi_dadd();\n  }\n  return in_d0;\n}\n\n", 
            "called": [
                "__aeabi_dadd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08009654", 
            "calling": [
                "settings_store_global_setting"
            ], 
            "imported": false, 
            "current_name": "round"
        }, 
        "plan_buffer_line": {
            "renaming": {}, 
            "code": "\nvoid plan_buffer_line(float x,float y,float z,float feed_rate,uint8_t invert_feed_rate)\n\n{\n  undefined *puVar1;\n  uint8_t uVar2;\n  undefined4 uVar3;\n  long lVar4;\n  long lVar5;\n  long lVar6;\n  undefined4 uVar7;\n  undefined4 uVar8;\n  undefined4 uVar9;\n  undefined4 uVar10;\n  float fVar11;\n  undefined4 in_r1;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined4 extraout_r1_03;\n  undefined4 extraout_r1_04;\n  undefined4 in_r2;\n  uint uVar12;\n  undefined4 in_r3;\n  ushort *puVar13;\n  int iVar14;\n  uint uVar15;\n  float fVar16;\n  undefined8 extraout_d0;\n  undefined8 extraout_d0_00;\n  undefined8 extraout_d0_01;\n  undefined8 extraout_d0_02;\n  undefined8 extraout_d0_03;\n  undefined8 extraout_d0_04;\n  float extraout_s2;\n  float extraout_s2_00;\n  float extraout_s2_01;\n  float extraout_s2_02;\n  float extraout_s2_03;\n  float extraout_s2_04;\n  undefined8 uVar17;\n  undefined8 uVar18;\n  undefined8 uVar19;\n  char in_stack_00000000;\n  float unit_vec [3];\n  float delta_mm [3];\n  int32_t target [3];\n  float v_allowable;\n  float sin_theta_d2;\n  float cos_theta;\n  float inverse_millimeters;\n  block_t *block;\n  float vmax_junction;\n  float inverse_minute;\n  \n  puVar13 = (ushort *)\n            (PTR_block_buffer_08003234 + (uint)(byte)*PTR_block_buffer_head_08003230 * 0x40);\n  uVar3 = __aeabi_fmul(x,*(undefined4 *)PTR_settings_08003238,invert_feed_rate);\n  __aeabi_f2d(uVar3);\n  lVar4 = lround((double)CONCAT44(in_r2,in_r3));\n  uVar3 = __aeabi_fmul(*(undefined4 *)(PTR_settings_08003238 + 4),in_r1);\n  __aeabi_f2d(uVar3);\n  lVar5 = lround((double)CONCAT44(in_r2,in_r3));\n  uVar3 = __aeabi_fmul(*(undefined4 *)(PTR_settings_08003238 + 8),in_r2);\n  __aeabi_f2d(uVar3);\n  lVar6 = lround((double)CONCAT44(in_r2,in_r3));\n  *puVar13 = 0;\n  if (lVar4 < *(int *)PTR_pl_0800323c) {\n    *puVar13 = *puVar13 | 0x20;\n  }\n  if (lVar5 < *(int *)(PTR_pl_0800323c + 4)) {\n    *puVar13 = *puVar13 | 0x880;\n  }\n  if (lVar6 < *(int *)(PTR_pl_0800323c + 8)) {\n    *puVar13 = *puVar13 | 0x200;\n  }\n  iVar14 = lVar4 - *(int *)PTR_pl_0800323c;\n  if (iVar14 < 0) {\n    iVar14 = -iVar14;\n  }\n  *(int *)(puVar13 + 2) = iVar14;\n  iVar14 = lVar5 - *(int *)(PTR_pl_0800323c + 4);\n  if (iVar14 < 0) {\n    iVar14 = -iVar14;\n  }\n  *(int *)(puVar13 + 4) = iVar14;\n  iVar14 = lVar6 - *(int *)(PTR_pl_0800323c + 8);\n  if (iVar14 < 0) {\n    iVar14 = -iVar14;\n  }\n  *(int *)(puVar13 + 6) = iVar14;\n  uVar12 = *(uint *)(puVar13 + 6);\n  if (*(uint *)(puVar13 + 6) < *(uint *)(puVar13 + 4)) {\n    uVar12 = *(uint *)(puVar13 + 4);\n  }\n  uVar15 = *(uint *)(puVar13 + 2);\n  if (*(uint *)(puVar13 + 2) < uVar12) {\n    uVar15 = uVar12;\n  }\n  *(uint *)(puVar13 + 8) = uVar15;\n  if (*(int *)(puVar13 + 8) != 0) {\n    uVar3 = __floatsisf(lVar4 - *(int *)PTR_pl_0800323c);\n    uVar3 = __aeabi_fdiv(uVar3,*(undefined4 *)PTR_settings_08003238);\n    uVar7 = __floatsisf(lVar5 - *(int *)(PTR_pl_0800323c + 4));\n    uVar7 = __aeabi_fdiv(uVar7,*(undefined4 *)(PTR_settings_08003238 + 4));\n    uVar8 = __floatsisf(lVar6 - *(int *)(PTR_pl_0800323c + 8));\n    uVar8 = __aeabi_fdiv(uVar8,*(undefined4 *)(PTR_settings_08003238 + 8));\n    uVar9 = __aeabi_fmul(uVar3,uVar3);\n    uVar10 = __aeabi_fmul(uVar7,uVar7);\n    uVar9 = __addsf3(uVar9,uVar10);\n    uVar10 = __aeabi_fmul(uVar8,uVar8);\n    uVar9 = __addsf3(uVar9,uVar10);\n    uVar9 = __aeabi_f2d(uVar9);\n    sqrt((double)CONCAT44(in_r2,in_r3));\n    uVar9 = __truncdfsf2(uVar9,extraout_r1);\n    *(undefined4 *)(puVar13 + 0x10) = uVar9;\n    uVar9 = __aeabi_fdiv(0x3f800000,*(undefined4 *)(puVar13 + 0x10));\n    if (in_stack_00000000 == '\\0') {\n      inverse_minute = (float)__aeabi_fmul(in_r3,uVar9);\n    }\n    else {\n      inverse_minute = (float)__aeabi_fdiv(0x3f800000,in_r3);\n    }\n    uVar10 = __aeabi_fmul(*(undefined4 *)(puVar13 + 0x10),inverse_minute);\n    *(undefined4 *)(puVar13 + 10) = uVar10;\n    uVar10 = __floatsisf(*(undefined4 *)(puVar13 + 8));\n    uVar10 = __aeabi_fmul(uVar10,inverse_minute);\n    uVar10 = __aeabi_f2d(uVar10);\n    ceil((double)CONCAT44(in_r2,in_r3));\n    uVar10 = __aeabi_d2uiz(uVar10,extraout_r1_00);\n    *(undefined4 *)(puVar13 + 0x1e) = uVar10;\n    uVar10 = __floatsisf(*(undefined4 *)(puVar13 + 8));\n    uVar10 = __aeabi_fmul(uVar10,uVar9);\n    uVar10 = __aeabi_fmul(uVar10,*(undefined4 *)(PTR_settings_08003560 + 0x20));\n    uVar10 = __aeabi_fdiv(uVar10,DAT_08003564);\n    uVar10 = __aeabi_f2d(uVar10);\n    ceil((double)CONCAT44(in_r2,in_r3));\n    uVar10 = __aeabi_d2iz(uVar10,extraout_r1_01);\n    *(undefined4 *)(puVar13 + 0x18) = uVar10;\n    uVar3 = __aeabi_fmul(uVar3,uVar9);\n    uVar7 = __aeabi_fmul(uVar7,uVar9);\n    uVar8 = __aeabi_fmul(uVar8,uVar9);\n    vmax_junction = 0.0;\n    uVar17 = extraout_d0;\n    fVar16 = extraout_s2;\n    if ((*PTR_block_buffer_head_08003568 != *PTR_block_buffer_tail_0800356c) &&\n       (iVar14 = __aeabi_fcmpgt(*(undefined4 *)(PTR_pl_08003570 + 0x18),0), uVar17 = extraout_d0_00,\n       fVar16 = extraout_s2_00, iVar14 != 0)) {\n      uVar9 = __aeabi_fmul(*(uint *)(PTR_pl_08003570 + 0xc) ^ 0x80000000,uVar3);\n      uVar10 = __aeabi_fmul(*(undefined4 *)(PTR_pl_08003570 + 0x10),uVar7);\n      uVar9 = __aeabi_fsub(uVar9,uVar10);\n      uVar10 = __aeabi_fmul(*(undefined4 *)(PTR_pl_08003570 + 0x14),uVar8);\n      uVar9 = __aeabi_fsub(uVar9,uVar10);\n      uVar17 = __aeabi_f2d(uVar9);\n      iVar14 = __aeabi_dcmplt((int)uVar17,(int)((ulonglong)uVar17 >> 0x20),DAT_08003550,DAT_08003554\n                             );\n      uVar17 = extraout_d0_01;\n      fVar16 = extraout_s2_01;\n      if (iVar14 != 0) {\n        iVar14 = __aeabi_fcmplt(*(undefined4 *)(PTR_pl_08003570 + 0x18),\n                                *(undefined4 *)(puVar13 + 10));\n        if (iVar14 == 0) {\n          vmax_junction = *(float *)(puVar13 + 10);\n        }\n        else {\n          vmax_junction = *(float *)(PTR_pl_08003570 + 0x18);\n        }\n        uVar17 = __aeabi_f2d(uVar9);\n        iVar14 = __aeabi_dcmpgt((int)uVar17,(int)((ulonglong)uVar17 >> 0x20),DAT_08003558,\n                                DAT_0800355c);\n        uVar17 = extraout_d0_02;\n        fVar16 = extraout_s2_02;\n        if (iVar14 != 0) {\n          uVar17 = __aeabi_f2d(uVar9);\n          uVar17 = __subdf3(0,DAT_08003574,(int)uVar17,(int)((ulonglong)uVar17 >> 0x20));\n          uVar9 = __muldf3((int)uVar17,(int)((ulonglong)uVar17 >> 0x20),0,DAT_08003578);\n          sqrt((double)CONCAT44(in_r2,in_r3));\n          uVar9 = __truncdfsf2(uVar9,extraout_r1_02);\n          uVar17 = __aeabi_f2d(vmax_junction);\n          uVar10 = __aeabi_fmul(*(undefined4 *)(PTR_settings_08003560 + 0x20),\n                                *(undefined4 *)(PTR_settings_08003560 + 0x24));\n          uVar10 = __aeabi_fmul(uVar10,uVar9);\n          uVar18 = __aeabi_f2d(uVar10);\n          uVar19 = __aeabi_f2d(uVar9);\n          uVar19 = __subdf3(0,DAT_08003574,(int)uVar19,(int)((ulonglong)uVar19 >> 0x20));\n          uVar10 = __divdf3((int)uVar18,(int)((ulonglong)uVar18 >> 0x20),(int)uVar19,\n                            (int)((ulonglong)uVar19 >> 0x20));\n          sqrt((double)CONCAT44(in_r2,in_r3));\n          iVar14 = __aeabi_dcmplt((int)uVar17,(int)((ulonglong)uVar17 >> 0x20),uVar10,extraout_r1_03\n                                 );\n          uVar17 = extraout_d0_03;\n          fVar16 = extraout_s2_03;\n          if (iVar14 == 0) {\n            uVar10 = __aeabi_fmul(*(undefined4 *)(PTR_settings_08003560 + 0x20),\n                                  *(undefined4 *)(PTR_settings_08003560 + 0x24));\n            uVar10 = __aeabi_fmul(uVar10,uVar9);\n            uVar17 = __aeabi_f2d(uVar10);\n            uVar18 = __aeabi_f2d(uVar9);\n            uVar18 = __subdf3(0,DAT_08003574,(int)uVar18,(int)((ulonglong)uVar18 >> 0x20));\n            uVar9 = __divdf3((int)uVar17,(int)((ulonglong)uVar17 >> 0x20),(int)uVar18,\n                             (int)((ulonglong)uVar18 >> 0x20));\n            sqrt((double)CONCAT44(in_r2,in_r3));\n            vmax_junction = (float)__truncdfsf2(uVar9,extraout_r1_04);\n            uVar17 = extraout_d0_04;\n            fVar16 = extraout_s2_04;\n          }\n        }\n      }\n    }\n    *(float *)(puVar13 + 0xe) = vmax_junction;\n    fVar11 = (float)(*(uint *)(PTR_settings_08003560 + 0x20) ^ 0x80000000);\n    max_allowable_speed((float)uVar17,(float)((ulonglong)uVar17 >> 0x20),fVar16);\n    iVar14 = __aeabi_fcmplt(vmax_junction,fVar11);\n    fVar16 = fVar11;\n    if (iVar14 != 0) {\n      fVar16 = vmax_junction;\n    }\n    *(float *)(puVar13 + 0xc) = fVar16;\n    iVar14 = __aeabi_fcmpge(fVar11,*(undefined4 *)(puVar13 + 10));\n    if (iVar14 == 0) {\n      *(undefined *)((int)puVar13 + 0x25) = 0;\n    }\n    else {\n      *(undefined *)((int)puVar13 + 0x25) = 1;\n    }\n    *(undefined *)(puVar13 + 0x12) = 1;\n    puVar1 = PTR_pl_080035e0;\n    *(undefined4 *)(PTR_pl_080035e0 + 0xc) = uVar3;\n    *(undefined4 *)(puVar1 + 0x10) = uVar7;\n    *(undefined4 *)(puVar1 + 0x14) = uVar8;\n    *(undefined4 *)(PTR_pl_080035e0 + 0x18) = *(undefined4 *)(puVar13 + 10);\n    *PTR_block_buffer_head_080035e8 = *PTR_next_buffer_head_080035e4;\n    uVar2 = next_block_index(*PTR_block_buffer_head_080035e8);\n    *PTR_next_buffer_head_080035e4 = uVar2;\n    puVar1 = PTR_pl_080035e0;\n    *(long *)PTR_pl_080035e0 = lVar4;\n    *(long *)(puVar1 + 4) = lVar5;\n    *(long *)(puVar1 + 8) = lVar6;\n    planner_recalculate();\n  }\n  return;\n}\n\n", 
            "called": [
                "__floatsisf", 
                "__aeabi_d2iz", 
                "__aeabi_fdiv", 
                "__muldf3", 
                "__aeabi_fmul", 
                "__aeabi_dcmpgt", 
                "__subdf3", 
                "sqrt", 
                "ceil", 
                "max_allowable_speed", 
                "__aeabi_fcmpgt", 
                "planner_recalculate", 
                "__addsf3", 
                "__truncdfsf2", 
                "__divdf3", 
                "__aeabi_dcmplt", 
                "next_block_index", 
                "__aeabi_f2d", 
                "__aeabi_d2uiz", 
                "__aeabi_fsub", 
                "lround", 
                "__aeabi_fcmpge", 
                "__aeabi_fcmplt"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003004", 
            "calling": [
                "mc_line"
            ], 
            "imported": false, 
            "current_name": "plan_buffer_line"
        }, 
        "__do_global_dtors_aux": {
            "renaming": {}, 
            "code": "\nundefined * __do_global_dtors_aux(undefined *param_1)\n\n{\n  if (*PTR_completed_8911_080001a0 == '\\0') {\n    if (DAT_080001a4 != 0) {\n      param_1 = PTR__init_080001a8;\n    }\n    *PTR_completed_8911_080001a0 = 1;\n  }\n  return param_1;\n}\n\n", 
            "called": [
                "_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000188", 
            "calling": [
                "__libc_fini_array"
            ], 
            "imported": false, 
            "current_name": "__do_global_dtors_aux"
        }, 
        "HAL_GPIO_ReadPin": {
            "renaming": {}, 
            "code": "\nGPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx,uint16_t GPIO_Pin)\n\n{\n  GPIO_PinState bitstatus;\n  \n  return ((uint)GPIO_Pin & GPIOx->IDR) != 0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08007310", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_GPIO_ReadPin"
        }, 
        "_fini": {
            "renaming": {}, 
            "code": "\nvoid _fini(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800b5bc", 
            "calling": [
                "__libc_fini_array"
            ], 
            "imported": false, 
            "current_name": "_fini"
        }, 
        "HAL_NVIC_GetActive": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = NVIC_GetActive(IRQn);\n  return uVar1;\n}\n\n", 
            "called": [
                "NVIC_GetActive"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006e1a", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_NVIC_GetActive"
        }, 
        "sys_sync_current_position": {
            "renaming": {}, 
            "code": "\nvoid sys_sync_current_position(void)\n\n{\n  plan_set_current_position\n            (*(int32_t *)(PTR_sys_08002868 + 4),*(int32_t *)(PTR_sys_08002868 + 8),\n             *(int32_t *)(PTR_sys_08002868 + 0xc));\n  gc_set_current_position\n            (*(int32_t *)(PTR_sys_08002868 + 4),*(int32_t *)(PTR_sys_08002868 + 8),\n             *(int32_t *)(PTR_sys_08002868 + 0xc));\n  return;\n}\n\n", 
            "called": [
                "gc_set_current_position", 
                "plan_set_current_position"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800283a", 
            "calling": [
                "grbl_main", 
                "mc_go_home"
            ], 
            "imported": false, 
            "current_name": "sys_sync_current_position"
        }, 
        "serial_reset_read_buffer": {
            "renaming": {}, 
            "code": "\nvoid serial_reset_read_buffer(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080082ba", 
            "calling": [
                "grbl_main"
            ], 
            "imported": false, 
            "current_name": "serial_reset_read_buffer"
        }, 
        "HAL_NVIC_EnableIRQ": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_EnableIRQ(IRQn_Type IRQn)\n\n{\n  NVIC_EnableIRQ(IRQn);\n  return;\n}\n\n", 
            "called": [
                "NVIC_EnableIRQ"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08006d2e", 
            "calling": [], 
            "imported": false, 
            "current_name": "HAL_NVIC_EnableIRQ"
        }, 
        "next_statement": {
            "renaming": {}, 
            "code": "\nint next_statement(char *letter,float *float_ptr,char *line,uint8_t *char_counter)\n\n{\n  int iVar1;\n  \n  if (line[*char_counter] == '\\0') {\n    iVar1 = 0;\n  }\n  else {\n    *letter = line[*char_counter];\n    if (((byte)*letter < 0x41) || (0x5a < (byte)*letter)) {\n      *PTR_gc_080018c8 = 2;\n      iVar1 = 0;\n    }\n    else {\n      *char_counter = *char_counter + '\\x01';\n      iVar1 = read_float(line,char_counter,float_ptr);\n      if (iVar1 == 0) {\n        *PTR_gc_080018c8 = 1;\n        iVar1 = 0;\n      }\n      else {\n        iVar1 = 1;\n      }\n    }\n  }\n  return iVar1;\n}\n\n", 
            "called": [
                "read_float"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800184c", 
            "calling": [
                "gc_execute_line"
            ], 
            "imported": false, 
            "current_name": "next_statement"
        }
    }, 
    "locked_functions": [], 
    "used_tokens": 0, 
    "layers": []
}