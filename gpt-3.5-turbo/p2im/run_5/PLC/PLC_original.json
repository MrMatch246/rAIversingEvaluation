{
    "functions": {
        "setTx": {
            "renaming": {}, 
            "code": "\nvoid __thiscall HardwareSerial::setTx(HardwareSerial *this,uint32_t _tx)\n\n{\n  PinName PVar1;\n  \n  if (_tx < 0x60) {\n    PVar1 = *(PinName *)(PTR_digitalPin_08004478 + _tx * 2);\n  }\n  else {\n    PVar1 = NC;\n  }\n  (this->_serial).pin_tx = PVar1;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004460", 
            "calling": [
                "HardwareSerial"
            ], 
            "imported": false, 
            "current_name": "setTx"
        }, 
        "HAL_RCC_GetSysClockFreq": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_RCC_GetSysClockFreq(void)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  uVar1 = *(uint *)(DAT_0800247c + 8) & 0xc;\n  if (uVar1 == 4) {\n    return DAT_08002484;\n  }\n  if (uVar1 != 8) {\n    return DAT_08002480;\n  }\n  uVar1 = *(uint *)(DAT_0800247c + 4) & 0x3f;\n  if ((*(uint *)(DAT_0800247c + 4) & 0x400000) == 0) {\n    uVar2 = (uint)(*(int *)(DAT_0800247c + 4) << 0x11) >> 0x17;\n    uVar1 = __aeabi_uldivmod(uVar2 * 16000000,\n                             (((uint)(uVar2 * 0x20 < uVar2) * -0x3f -\n                              (uint)(uVar2 * 0x7c0 < uVar2 * 0x1f)) * 8 +\n                             (uint)CARRY4(uVar2 * 0x3d08,uVar2)) * 0x400 | uVar2 * 0x3d09 >> 0x16,\n                             uVar1,0);\n  }\n  else {\n    uVar2 = (uint)(*(int *)(DAT_0800247c + 4) << 0x11) >> 0x17;\n    uVar1 = __aeabi_uldivmod(uVar2 * 8000000,\n                             (((uint)(uVar2 * 0x20 < uVar2) * -0x3f -\n                              (uint)(uVar2 * 0x7c0 < uVar2 * 0x1f)) * 8 +\n                             (uint)CARRY4(uVar2 * 0x3d08,uVar2)) * 0x200,uVar1,0);\n  }\n  return uVar1 / ((((uint)(*(int *)(DAT_0800247c + 4) << 0xe) >> 0x1e) + 1) * 2);\n}\n\n", 
            "called": [
                "__aeabi_uldivmod"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080023b4", 
            "calling": [
                "HAL_RCC_ClockConfig"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_GetSysClockFreq"
        }, 
        "TIM6_DAC_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM6_DAC_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef **)(PTR_timer_handles_080037f8 + 0x14) != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef **)(PTR_timer_handles_080037f8 + 0x14));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080037e8", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM6_DAC_IRQHandler"
        }, 
        "HAL_NVIC_SetPriorityGrouping": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)\n\n{\n  *(uint32_t *)(DAT_08000e5c + 0xc) =\n       (PriorityGroup & 7) << 8 | *(uint *)(DAT_08000e5c + 0xc) & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000e3c", 
            "calling": [
                "HAL_Init", 
                "premain"
            ], 
            "imported": false, 
            "current_name": "HAL_NVIC_SetPriorityGrouping"
        }, 
        "I2C_SlaveTransmit_TXE": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  byte *pbVar2;\n  \n  HVar1 = hi2c->State;\n  if (hi2c->XferCount != 0) {\n    pbVar2 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = pbVar2 + 1;\n    hi2c->Instance->DR = (uint)*pbVar2;\n    hi2c->XferCount = hi2c->XferCount - 1;\n    if ((hi2c->XferCount == 0) && (HVar1 == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffbff;\n      hi2c->PreviousState = 0x21;\n      hi2c->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(hi2c);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080015bc", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_SlaveTransmit_TXE"
        }, 
        "set_pin_configured": {
            "renaming": {}, 
            "code": "\nvoid set_pin_configured(PinName_conflict pin,uint32_t *map)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)((int)pin << 0x18) >> 0x1c;\n  map[uVar1] = map[uVar1] | 1 << ((int)pin & 0xfU);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800314e", 
            "calling": [
                "pinMode"
            ], 
            "imported": false, 
            "current_name": "set_pin_configured"
        }, 
        "get_pin_id": {
            "renaming": {}, 
            "code": "\nuint8_t get_pin_id(uint16_t pin)\n\n{\n  uint uVar1;\n  uint8_t uVar2;\n  \n  uVar2 = '\\0';\n  for (uVar1 = (uint)pin; uVar1 != 1; uVar1 = uVar1 >> 1) {\n    uVar2 = uVar2 + '\\x01';\n  }\n  return uVar2;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004678", 
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ], 
            "imported": false, 
            "current_name": "get_pin_id"
        }, 
        "buildException": {
            "renaming": {}, 
            "code": "\nvoid __thiscall Modbus::buildException(Modbus *this,uint8_t u8exception)\n\n{\n  byte bVar1;\n  \n  bVar1 = this->au8Buffer[1];\n  this->au8Buffer[0] = this->u8id;\n  this->au8Buffer[1] = bVar1 ^ 0x80;\n  this->au8Buffer[2] = u8exception;\n  this->u8BufferSize = '\\x03';\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080008cc", 
            "calling": [
                "poll"
            ], 
            "imported": false, 
            "current_name": "buildException"
        }, 
        "TIM_CCxNChannelCmd": {
            "renaming": {}, 
            "code": "\nvoid TIM_CCxNChannelCmd(TIM_TypeDef *TIMx,uint32_t Channel,uint32_t ChannelNState)\n\n{\n  TIMx->CCER = TIMx->CCER & ~(4 << (Channel & 0xff));\n  TIMx->CCER = TIMx->CCER | ChannelNState << (Channel & 0xff);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080028d4", 
            "calling": [
                "HAL_TIMEx_PWMN_Stop"
            ], 
            "imported": false, 
            "current_name": "TIM_CCxNChannelCmd"
        }, 
        "pinmap_function": {
            "renaming": {}, 
            "code": "\nuint32_t pinmap_function(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  uint32_t uVar1;\n  \n  if (pin == NC) {\n    return 0xffffffff;\n  }\n  uVar1 = pinmap_find_function(pin,map);\n  return uVar1;\n}\n\n", 
            "called": [
                "pinmap_find_function"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800354a", 
            "calling": [
                "uart_init", 
                "get_pwm_channel", 
                "pwm_stop", 
                "get_dac_channel"
            ], 
            "imported": false, 
            "current_name": "pinmap_function"
        }, 
        "EXTI0_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI0_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(1);\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004760", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI0_IRQHandler"
        }, 
        "HAL_TIMEx_BreakCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800293e", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIMEx_BreakCallback"
        }, 
        "get_i2c_obj": {
            "renaming": {}, 
            "code": "\ni2c_t * get_i2c_obj(I2C_HandleTypeDef *hi2c)\n\n{\n  return (i2c_t *)&hi2c[-1].EventCount;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800387c", 
            "calling": [
                "HAL_I2C_ErrorCallback", 
                "HAL_I2C_ListenCpltCallback", 
                "HAL_I2C_AddrCallback"
            ], 
            "imported": false, 
            "current_name": "get_i2c_obj"
        }, 
        "HAL_SYSTICK_Callback": {
            "renaming": {}, 
            "code": "\nvoid HAL_SYSTICK_Callback(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000f4c", 
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_SYSTICK_Callback"
        }, 
        "frame_dummy": {
            "renaming": {}, 
            "code": "\nvoid frame_dummy(void)\n\n{\n  if (DAT_08000204 == 0) {\n    if ((*(int *)PTR_completed_8667_08000210 != 0) && (DAT_08000214 != (code *)0x0)) {\n                    /* WARNING: Could not recover jumptable at 0x08000200. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*DAT_08000214)();\n      return;\n    }\n    return;\n  }\n  if ((*(int *)PTR_completed_8667_08000210 != 0) && (DAT_08000214 != (code *)0x0)) {\n                    /* WARNING: Could not recover jumptable at 0x080001f8. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (*DAT_08000214)(PTR_completed_8667_08000210,PTR_object_8672_0800020c);\n    return;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080001d0", 
            "calling": [], 
            "imported": false, 
            "current_name": "frame_dummy"
        }, 
        "HAL_UART_GetState": {
            "renaming": {}, 
            "code": "\nHAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)\n\n{\n  return huart->RxState | huart->gState;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800312c", 
            "calling": [
                "serial_tx_active", 
                "serial_rx_active"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_GetState"
        }, 
        "_vfiprintf_r": {
            "renaming": {}, 
            "code": "\nint _vfiprintf_r(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  bool bVar1;\n  undefined *puVar2;\n  int iVar3;\n  void *pvVar4;\n  int *piVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  int unaff_r9;\n  int iVar8;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 local_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  local_8c = param_4;\n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_2 == PTR___sf_fake_stdin_08004c90) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR___sf_fake_stdout_08004c98) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR___sf_fake_stderr_08004c9c) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar8 = __swsetup_r(param_1,param_2), iVar8 != 0)) {\n    return -1;\n  }\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar6 = param_3;\nLAB_08004ac6:\n  pbVar7 = pbVar6;\n  if (*pbVar7 != 0) goto LAB_08004b7c;\n  goto LAB_08004ad0;\nLAB_08004b7c:\n  pbVar6 = pbVar7 + 1;\n  if (*pbVar7 != 0x25) goto LAB_08004ac6;\nLAB_08004ad0:\n  iVar8 = (int)pbVar7 - (int)param_3;\n  if (iVar8 != 0) {\n    iVar3 = __sfputs_r(param_1,param_2,param_3,iVar8);\n    if (iVar3 == -1) {\nLAB_08004c70:\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar8;\n  }\n  if (*pbVar7 == 0) goto LAB_08004c70;\n  local_88 = 0;\n  local_7c = 0;\n  local_84 = -1;\n  local_80 = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar6 = pbVar7 + 1;\n  while( true ) {\n    pvVar4 = memchr(PTR_s___0__08004c94,(uint)*pbVar6,5);\n    puVar2 = PTR_DAT_08004ca0;\n    param_3 = pbVar6 + 1;\n    if (pvVar4 == (void *)0x0) break;\n    local_88 = 1 << ((int)pvVar4 - (int)PTR_s___0__08004c94 & 0xffU) | local_88;\n    pbVar6 = param_3;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar6 == 0x2a) {\n    piVar5 = local_8c + 1;\n    iVar8 = *local_8c;\n    local_8c = piVar5;\n    if (-1 < iVar8) goto LAB_08004ba0;\n    local_7c = -iVar8;\n    local_88 = local_88 | 2;\n  }\n  else {\n    bVar1 = false;\n    iVar8 = local_7c;\n    param_3 = pbVar6;\n    while( true ) {\n      if (9 < *param_3 - 0x30) break;\n      iVar8 = iVar8 * 10 + (*param_3 - 0x30);\n      bVar1 = true;\n      param_3 = param_3 + 1;\n    }\n    if (bVar1) {\nLAB_08004ba0:\n      local_7c = iVar8;\n    }\n  }\n  if (*param_3 == 0x2e) {\n    if (param_3[1] == 0x2a) {\n      local_84 = *local_8c;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n      param_3 = param_3 + 2;\n      local_8c = local_8c + 1;\n    }\n    else {\n      bVar1 = false;\n      local_84 = 0;\n      iVar8 = 0;\n      while( true ) {\n        param_3 = param_3 + 1;\n        if (9 < *param_3 - 0x30) break;\n        iVar8 = iVar8 * 10 + (*param_3 - 0x30);\n        bVar1 = true;\n      }\n      if (bVar1) {\n        local_84 = iVar8;\n      }\n    }\n  }\n  pvVar4 = memchr(PTR_DAT_08004ca0,(uint)*param_3,3);\n  if (pvVar4 != (void *)0x0) {\n    local_88 = local_88 | 0x40 << ((int)pvVar4 - (int)puVar2 & 0xffU);\n    param_3 = param_3 + 1;\n  }\n  local_70 = *param_3;\n  param_3 = param_3 + 1;\n  pvVar4 = memchr(PTR_s_efgEFG_08004ca4,(uint)local_70,6);\n  if (pvVar4 == (void *)0x0) {\n    iVar8 = _printf_i(param_1,&local_88,param_2,DAT_08004cac,&local_8c);\n  }\n  else {\n    iVar8 = param_1;\n    if (DAT_08004ca8 == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar8 = unaff_r9;\n      goto LAB_08004c22;\n    }\n  }\n  if (iVar8 == -1) goto LAB_08004c70;\nLAB_08004c22:\n  local_74 = local_74 + iVar8;\n  pbVar6 = param_3;\n  unaff_r9 = iVar8;\n  goto LAB_08004ac6;\n}\n\n", 
            "called": [
                "_printf_i", 
                "__swsetup_r", 
                "memchr", 
                "__sinit", 
                "__sfputs_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004a84", 
            "calling": [
                "iprintf", 
                "fiprintf"
            ], 
            "imported": false, 
            "current_name": "_vfiprintf_r"
        }, 
        "TIM1_BRK_TIM9_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM1_BRK_TIM9_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef **)(PTR_timer_handles_0800383c + 0x20) != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef **)(PTR_timer_handles_0800383c + 0x20));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800382c", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM1_BRK_TIM9_IRQHandler"
        }, 
        "HAL_RCC_GetPCLK2Freq": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_RCC_GetPCLK2Freq(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = HAL_RCC_GetHCLKFreq();\n  return uVar1 >> PTR_APBPrescTable_08002628[(uint)(*(int *)(DAT_08002624 + 8) << 0x10) >> 0x1d];\n}\n\n", 
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800260c", 
            "calling": [
                "UART_SetConfig"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_GetPCLK2Freq"
        }, 
        "I2C_MasterTransmit_BTF": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c)\n\n{\n  uint32_t uVar1;\n  byte *pbVar2;\n  \n  uVar1 = hi2c->XferOptions;\n  if (hi2c->State == HAL_I2C_STATE_BUSY_TX) {\n    if (hi2c->XferCount == 0) {\n      if (((uVar1 == 4) || (uVar1 == 8)) || (uVar1 == 0xffff0000)) {\n        hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n        hi2c->PreviousState = 0;\n        hi2c->State = HAL_I2C_STATE_READY;\n        if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n          hi2c->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(hi2c);\n        }\n        else {\n          hi2c->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(hi2c);\n        }\n      }\n      else {\n        hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n        hi2c->PreviousState = 0x11;\n        hi2c->Mode = HAL_I2C_MODE_NONE;\n        hi2c->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(hi2c);\n      }\n    }\n    else {\n      pbVar2 = hi2c->pBuffPtr;\n      hi2c->pBuffPtr = pbVar2 + 1;\n      hi2c->Instance->DR = (uint)*pbVar2;\n      hi2c->XferCount = hi2c->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_MemTxCpltCallback", 
                "HAL_I2C_MasterTxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001864", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_MasterTransmit_BTF"
        }, 
        "pinmap_pin": {
            "renaming": {}, 
            "code": "\nPinName_conflict pinmap_pin(void *peripheral,PinMap_conflict *map)\n\n{\n  PinName_conflict PVar1;\n  \n  if (peripheral != (void *)0x0) {\n    PVar1 = pinmap_find_pin(peripheral,map);\n    return PVar1;\n  }\n  return NC;\n}\n\n", 
            "called": [
                "pinmap_find_pin"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800351e", 
            "calling": [
                "HardwareSerial", 
                "uart_debug_init"
            ], 
            "imported": false, 
            "current_name": "pinmap_pin"
        }, 
        "CAN2_SCE_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid CAN2_SCE_IRQHandler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
            "called": [
                "CAN2_SCE_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000d8c", 
            "calling": [
                "CAN2_SCE_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "CAN2_SCE_IRQHandler"
        }, 
        "HAL_InitTick": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = HAL_SYSTICK_Config((uint32_t)\n                             ((ulonglong)*(uint *)PTR_SystemCoreClock_08000ddc /\n                             (1000 / (ulonglong)(byte)*PTR_uwTickFreq_08000dd8)));\n  if (uVar1 != 0) {\n    return HAL_ERROR;\n  }\n  if (0xf < TickPriority) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn,TickPriority,0);\n  *(uint32_t *)PTR_uwTickPrio_08000de0 = TickPriority;\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_NVIC_SetPriority", 
                "HAL_SYSTICK_Config"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000d98", 
            "calling": [
                "HAL_Init", 
                "HAL_RCC_ClockConfig"
            ], 
            "imported": false, 
            "current_name": "HAL_InitTick"
        }, 
        "timer_disable_clock": {
            "renaming": {}, 
            "code": "\nvoid timer_disable_clock(TIM_HandleTypeDef *htim)\n\n{\n  if (htim->Instance == DAT_08003718) {\n    *(uint *)(DAT_0800374c + 0x44) = *(uint *)(DAT_0800374c + 0x44) & 0xfffffffe;\n  }\n  if (htim->Instance == (TIM_TypeDef *)0x40000000) {\n    *(uint *)(DAT_0800374c + 0x40) = *(uint *)(DAT_0800374c + 0x40) & 0xfffffffe;\n  }\n  if (htim->Instance == DAT_0800371c) {\n    *(uint *)(DAT_0800374c + 0x40) = *(uint *)(DAT_0800374c + 0x40) & 0xfffffffd;\n  }\n  if (htim->Instance == DAT_08003720) {\n    *(uint *)(DAT_0800374c + 0x40) = *(uint *)(DAT_0800374c + 0x40) & 0xfffffffb;\n  }\n  if (htim->Instance == DAT_08003724) {\n    *(uint *)(DAT_0800374c + 0x40) = *(uint *)(DAT_0800374c + 0x40) & 0xfffffff7;\n  }\n  if (htim->Instance == DAT_08003728) {\n    *(uint *)(DAT_0800374c + 0x40) = *(uint *)(DAT_0800374c + 0x40) & 0xffffffef;\n  }\n  if (htim->Instance == DAT_0800372c) {\n    *(uint *)(DAT_0800374c + 0x40) = *(uint *)(DAT_0800374c + 0x40) & 0xffffffdf;\n  }\n  if (htim->Instance == DAT_08003730) {\n    *(uint *)(DAT_0800374c + 0x44) = *(uint *)(DAT_0800374c + 0x44) & 0xfffffffd;\n  }\n  if (htim->Instance == DAT_08003734) {\n    *(uint *)(DAT_0800374c + 0x44) = *(uint *)(DAT_0800374c + 0x44) & 0xfffeffff;\n  }\n  if (htim->Instance == DAT_08003738) {\n    *(uint *)(DAT_0800374c + 0x44) = *(uint *)(DAT_0800374c + 0x44) & 0xfffdffff;\n  }\n  if (htim->Instance == DAT_0800373c) {\n    *(uint *)(DAT_0800374c + 0x44) = *(uint *)(DAT_0800374c + 0x44) & 0xfffbffff;\n  }\n  if (htim->Instance == DAT_08003740) {\n    *(uint *)(DAT_0800374c + 0x40) = *(uint *)(DAT_0800374c + 0x40) & 0xffffffbf;\n  }\n  if (htim->Instance == DAT_08003744) {\n    *(uint *)(DAT_0800374c + 0x40) = *(uint *)(DAT_0800374c + 0x40) & 0xffffff7f;\n  }\n  if (htim->Instance == DAT_08003748) {\n    *(uint *)(DAT_0800374c + 0x40) = *(uint *)(DAT_0800374c + 0x40) & 0xfffffeff;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080035fc", 
            "calling": [
                "HAL_TIM_PWM_MspDeInit"
            ], 
            "imported": false, 
            "current_name": "timer_disable_clock"
        }, 
        "HAL_RCC_GetHCLKFreq": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_RCC_GetHCLKFreq(void)\n\n{\n  return *(uint32_t *)PTR_SystemCoreClock_080025e8;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080025e0", 
            "calling": [
                "HAL_RCC_GetPCLK2Freq", 
                "HAL_RCC_GetPCLK1Freq", 
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_GetHCLKFreq"
        }, 
        "TIM7_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM7_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef **)(PTR_timer_handles_0800380c + 0x18) != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef **)(PTR_timer_handles_0800380c + 0x18));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080037fc", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM7_IRQHandler"
        }, 
        "HAL_I2C_SlaveRxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800160c", 
            "calling": [
                "I2C_SlaveReceive_RXNE", 
                "I2C_Slave_STOPF"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_SlaveRxCpltCallback"
        }, 
        "I2C_MasterTransmit_TXE": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  byte *pbVar2;\n  uint32_t uVar3;\n  \n  HVar1 = hi2c->State;\n  uVar3 = hi2c->XferOptions;\n  if ((hi2c->XferSize == 0) && (HVar1 == HAL_I2C_STATE_BUSY_TX)) {\n    if ((uVar3 == 4) || ((uVar3 == 8 || (uVar3 == 0xffff0000)))) {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n      hi2c->PreviousState = 0;\n      hi2c->State = HAL_I2C_STATE_READY;\n      if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n        hi2c->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(hi2c);\n      }\n      else {\n        hi2c->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(hi2c);\n      }\n    }\n    else {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n      hi2c->PreviousState = 0x11;\n      hi2c->Mode = HAL_I2C_MODE_NONE;\n      hi2c->State = HAL_I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(hi2c);\n    }\n  }\n  else if ((HVar1 == HAL_I2C_STATE_BUSY_TX) ||\n          ((hi2c->Mode == HAL_I2C_MODE_MEM && (HVar1 == HAL_I2C_STATE_BUSY_RX)))) {\n    if (hi2c->XferCount == 0) {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffbff;\n    }\n    else if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n      if (hi2c->EventCount == 0) {\n        if (hi2c->MemaddSize == 1) {\n          hi2c->Instance->DR = hi2c->Memaddress & 0xff;\n          hi2c->EventCount = hi2c->EventCount + 2;\n        }\n        else {\n          hi2c->Instance->DR = (hi2c->Memaddress << 0x10) >> 0x18;\n          hi2c->EventCount = hi2c->EventCount + 1;\n        }\n      }\n      else if (hi2c->EventCount == 1) {\n        hi2c->Instance->DR = hi2c->Memaddress & 0xff;\n        hi2c->EventCount = hi2c->EventCount + 1;\n      }\n      else if (hi2c->EventCount == 2) {\n        if (hi2c->State == HAL_I2C_STATE_BUSY_RX) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x100;\n        }\n        else if (hi2c->State == HAL_I2C_STATE_BUSY_TX) {\n          pbVar2 = hi2c->pBuffPtr;\n          hi2c->pBuffPtr = pbVar2 + 1;\n          hi2c->Instance->DR = (uint)*pbVar2;\n          hi2c->XferCount = hi2c->XferCount - 1;\n        }\n      }\n    }\n    else {\n      pbVar2 = hi2c->pBuffPtr;\n      hi2c->pBuffPtr = pbVar2 + 1;\n      hi2c->Instance->DR = (uint)*pbVar2;\n      hi2c->XferCount = hi2c->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_MasterTxCpltCallback", 
                "HAL_I2C_MemTxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800171a", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_MasterTransmit_TXE"
        }, 
        "startForkserver": {
            "renaming": {}, 
            "code": "\nint startForkserver(int ticks)\n\n{\n  uint32_t uVar1;\n  \n  if (*(int *)PTR_noHyperCall_080005fc != 0) {\n    return 0;\n  }\n  uVar1 = aflCall(1,ticks,0);\n  return uVar1;\n}\n\n", 
            "called": [
                "aflCall"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080005e4", 
            "calling": [
                "setup"
            ], 
            "imported": false, 
            "current_name": "startForkserver"
        }, 
        "__sinit": {
            "renaming": {}, 
            "code": "\nvoid __sinit(int param_1)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  bool bVar3;\n  \n  if (*(int *)(param_1 + 0x18) == 0) {\n    *(undefined4 *)(param_1 + 0x48) = 0;\n    *(undefined4 *)(param_1 + 0x4c) = 0;\n    *(undefined4 *)(param_1 + 0x50) = 0;\n    iVar2 = *(int *)PTR__global_impure_ptr_080053f8;\n    *(undefined4 *)(param_1 + 0x28) = DAT_080053fc;\n    bVar3 = param_1 == iVar2;\n    if (bVar3) {\n      iVar2 = 1;\n    }\n    if (bVar3) {\n      *(int *)(param_1 + 0x18) = iVar2;\n    }\n    uVar1 = __sfp();\n    *(undefined4 *)(param_1 + 4) = uVar1;\n    uVar1 = __sfp(param_1);\n    *(undefined4 *)(param_1 + 8) = uVar1;\n    uVar1 = __sfp(param_1);\n    *(undefined4 *)(param_1 + 0xc) = uVar1;\n    std_isra_0(*(undefined4 *)(param_1 + 4),4,0);\n    std_isra_0(*(undefined4 *)(param_1 + 8),9,1);\n    std_isra_0(*(undefined4 *)(param_1 + 0xc),0x12,2);\n    *(undefined4 *)(param_1 + 0x18) = 1;\n  }\n  return;\n}\n\n", 
            "called": [
                "std.isra.0", 
                "__sfp"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080053a0", 
            "calling": [
                "_fflush_r", 
                "__sfp", 
                "__swsetup_r", 
                "__swbuf_r", 
                "_vfiprintf_r", 
                "iprintf"
            ], 
            "imported": false, 
            "current_name": "__sinit"
        }, 
        "HAL_NVIC_SetPriority": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_SetPriority(IRQn_Type_conflict IRQn,uint32_t PreemptPriority,uint32_t SubPriority)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  \n  uVar1 = (uint)IRQn;\n  uVar2 = (uint)(*(int *)(DAT_08000ebc + 0xc) << 0x15) >> 0x1d;\n  uVar3 = 7 - uVar2;\n  if (3 < uVar3) {\n    uVar3 = 4;\n  }\n  if (uVar2 + 4 < 7) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = uVar2 - 3;\n  }\n  uVar2 = (PreemptPriority & (1 << (uVar3 & 0xff)) - 1U) << (uVar2 & 0xff) |\n          (1 << (uVar2 & 0xff)) - 1U & SubPriority;\n  if ((int)uVar1 < 0) {\n    *(char *)(DAT_08000ec0 + (uVar1 & 0xf)) = (char)(uVar2 << 4);\n  }\n  else {\n    *(char *)(uVar1 + 0xe000e400) = (char)(uVar2 << 4);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000e60", 
            "calling": [
                "HAL_InitTick", 
                "uart_attach_tx_callback", 
                "SystemClock_Config", 
                "uart_attach_rx_callback"
            ], 
            "imported": false, 
            "current_name": "HAL_NVIC_SetPriority"
        }, 
        "GetCurrentMilli": {
            "renaming": {}, 
            "code": "\nuint32_t GetCurrentMilli(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = HAL_GetTick();\n  return uVar1;\n}\n\n", 
            "called": [
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800346c", 
            "calling": [
                "millis"
            ], 
            "imported": false, 
            "current_name": "GetCurrentMilli"
        }, 
        "UART_DMAAbortOnError": {
            "renaming": {}, 
            "code": "\nvoid UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)\n\n{\n  UART_HandleTypeDef *huart;\n  \n  huart = (UART_HandleTypeDef *)hdma->Parent;\n  huart->RxXferCount = 0;\n  huart->TxXferCount = 0;\n  HAL_UART_ErrorCallback(huart);\n  return;\n}\n\n", 
            "called": [
                "HAL_UART_ErrorCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800311c", 
            "calling": [], 
            "imported": false, 
            "current_name": "UART_DMAAbortOnError"
        }, 
        "_write": {
            "renaming": {}, 
            "code": "\nint _write(int file_UNUSED,char *ptr,int len)\n\n{\n  size_t sVar1;\n  \n  sVar1 = uart_debug_write((uint8_t *)ptr,len);\n  return sVar1;\n}\n\n", 
            "called": [
                "uart_debug_write"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080040ec", 
            "calling": [
                "_write_r"
            ], 
            "imported": false, 
            "current_name": "_write"
        }, 
        "I2C_SlaveTransmit_BTF": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c)\n\n{\n  byte *pbVar1;\n  \n  if (hi2c->XferCount != 0) {\n    pbVar1 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = pbVar1 + 1;\n    hi2c->Instance->DR = (uint)*pbVar1;\n    hi2c->XferCount = hi2c->XferCount - 1;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001420", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_SlaveTransmit_BTF"
        }, 
        "__aeabi_idiv0": {
            "renaming": {}, 
            "code": "\nvoid __aeabi_idiv0(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080005dc", 
            "calling": [
                "__aeabi_uldivmod"
            ], 
            "imported": false, 
            "current_name": "__aeabi_idiv0"
        }, 
        "digital_io_write": {
            "renaming": {}, 
            "code": "\nvoid digital_io_write(GPIO_TypeDef *port,uint32_t pin,uint32_t val)\n\n{\n  if (val == 0) {\n    HAL_GPIO_WritePin(port,(uint16_t)pin,GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(port,(uint16_t)pin,GPIO_PIN_SET);\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_WritePin"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080034b6", 
            "calling": [
                "digitalWrite"
            ], 
            "imported": false, 
            "current_name": "digital_io_write"
        }, 
        "TIM1_UP_TIM10_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM1_UP_TIM10_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef **)PTR_timer_handles_08003794 != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef **)PTR_timer_handles_08003794);\n  }\n  if (*(TIM_HandleTypeDef **)(PTR_timer_handles_08003794 + 0x24) != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef **)(PTR_timer_handles_08003794 + 0x24));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800377c", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM1_UP_TIM10_IRQHandler"
        }, 
        "HAL_I2C_ListenCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  i2c_t *piVar1;\n  uint uVar2;\n  \n  piVar1 = get_i2c_obj(hi2c);\n  if (((piVar1->i2c_onSlaveReceive != (_func_void_uint8_t_ptr_int *)0x0) &&\n      (piVar1->slaveMode == '\\x01')) &&\n     (uVar2 = 0x20 - *(byte *)&(piVar1->handle).XferSize & 0xff, uVar2 != 0)) {\n    (*piVar1->i2c_onSlaveReceive)(piVar1->i2cTxRxBuffer,uVar2);\n  }\n  HAL_I2C_EnableListen_IT(hi2c);\n  return;\n}\n\n", 
            "called": [
                "get_i2c_obj", 
                "HAL_I2C_EnableListen_IT"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080038d0", 
            "calling": [
                "I2C_ITError", 
                "I2C_Slave_AF", 
                "I2C_Slave_STOPF"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_ListenCpltCallback"
        }, 
        "EXTI1_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI1_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(2);\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800476a", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI1_IRQHandler"
        }, 
        "hw_config_init": {
            "renaming": {}, 
            "code": "\nvoid hw_config_init(void)\n\n{\n  HAL_Init();\n  SystemClock_Config();\n  return;\n}\n\n", 
            "called": [
                "HAL_Init", 
                "SystemClock_Config"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080034ce", 
            "calling": [
                "init"
            ], 
            "imported": false, 
            "current_name": "hw_config_init"
        }, 
        "I2C_Master_ADD10": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef I2C_Master_ADD10(I2C_HandleTypeDef *hi2c)\n\n{\n  hi2c->Instance->DR = hi2c->Devaddress & 0xff;\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800124a", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_Master_ADD10"
        }, 
        "HAL_TIM_TriggerCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080026cc", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_TriggerCallback"
        }, 
        "UART_EndTransmit_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)\n\n{\n  huart->Instance->CR1 = huart->Instance->CR1 & 0xffffffbf;\n  huart->gState = HAL_UART_STATE_READY;\n  HAL_UART_TxCpltCallback(huart);\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_UART_TxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002f4c", 
            "calling": [
                "HAL_UART_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "UART_EndTransmit_IT"
        }, 
        "TIM2_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM2_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef **)(PTR_timer_handles_080037a8 + 4) != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef **)(PTR_timer_handles_080037a8 + 4));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003798", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM2_IRQHandler"
        }, 
        "__sfputc_r": {
            "renaming": {}, 
            "code": "\nuint __sfputc_r(undefined4 param_1,byte param_2,byte **param_3)\n\n{\n  uint uVar1;\n  byte *pbVar2;\n  \n  pbVar2 = param_3[2] + -1;\n  param_3[2] = pbVar2;\n  if (((int)pbVar2 < 0) && (((int)pbVar2 < (int)param_3[6] || (param_2 == 10)))) {\n    uVar1 = __swbuf_r();\n    return uVar1;\n  }\n  pbVar2 = *param_3;\n  *param_3 = pbVar2 + 1;\n  *pbVar2 = param_2;\n  return (uint)param_2;\n}\n\n", 
            "called": [
                "__swbuf_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004a34", 
            "calling": [
                "__sfputs_r"
            ], 
            "imported": false, 
            "current_name": "__sfputc_r"
        }, 
        "I2C_SlaveReceive_RXNE": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  uint8_t *puVar2;\n  \n  HVar1 = hi2c->State;\n  if (hi2c->XferCount != 0) {\n    puVar2 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = puVar2 + 1;\n    *puVar2 = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n    if ((hi2c->XferCount == 0) && (HVar1 == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffbff;\n      hi2c->PreviousState = 0x22;\n      hi2c->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveRxCpltCallback(hi2c);\n    }\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800160e", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_SlaveReceive_RXNE"
        }, 
        "HAL_TIM_PeriodElapsedCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\n\n{\n  stimer_t *psVar1;\n  \n  psVar1 = get_timer_obj(htim);\n  if (psVar1->irqHandle != (_func_void_stimer_t_ptr *)0x0) {\n    (*psVar1->irqHandle)(psVar1);\n  }\n  return;\n}\n\n", 
            "called": [
                "get_timer_obj"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800376e", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_PeriodElapsedCallback"
        }, 
        "_GLOBAL__sub_I_Serial3": {
            "renaming": {}, 
            "code": "\nvoid _GLOBAL__sub_I_Serial3(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n", 
            "called": [
                "__static_initialization_and_destruction_0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080044fc", 
            "calling": [], 
            "imported": false, 
            "current_name": "_GLOBAL__sub_I_Serial3"
        }, 
        "_isatty": {
            "renaming": {}, 
            "code": "\nint _isatty(int file_UNUSED)\n\n{\n  return 1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080040e0", 
            "calling": [
                "_isatty_r"
            ], 
            "imported": false, 
            "current_name": "_isatty"
        }, 
        "I2C_MasterReceive_RXNE": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c)\n\n{\n  uint8_t *puVar1;\n  \n  if (hi2c->State == HAL_I2C_STATE_BUSY_RX) {\n    if (hi2c->XferCount < 4) {\n      if (hi2c->XferCount < 2) {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n        hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n        puVar1 = hi2c->pBuffPtr;\n        hi2c->pBuffPtr = puVar1 + 1;\n        *puVar1 = (uint8_t)hi2c->Instance->DR;\n        hi2c->XferCount = hi2c->XferCount - 1;\n        hi2c->State = HAL_I2C_STATE_READY;\n        hi2c->PreviousState = 0;\n        if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n          hi2c->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemRxCpltCallback(hi2c);\n        }\n        else {\n          hi2c->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterRxCpltCallback(hi2c);\n        }\n      }\n    }\n    else {\n      puVar1 = hi2c->pBuffPtr;\n      hi2c->pBuffPtr = puVar1 + 1;\n      *puVar1 = (uint8_t)hi2c->Instance->DR;\n      hi2c->XferCount = hi2c->XferCount - 1;\n      if (hi2c->XferCount == 3) {\n        hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffbff;\n      }\n    }\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_MasterRxCpltCallback", 
                "HAL_I2C_MemRxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001904", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_MasterReceive_RXNE"
        }, 
        "HAL_IncTick": {
            "renaming": {}, 
            "code": "\nvoid HAL_IncTick(void)\n\n{\n  *(uint *)PTR_uwTick_08000e28 = (uint)(byte)*PTR_uwTickFreq_08000e2c + *(int *)PTR_uwTick_08000e28;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000e18", 
            "calling": [
                "SysTick_Handler"
            ], 
            "imported": false, 
            "current_name": "HAL_IncTick"
        }, 
        "fiprintf": {
            "renaming": {}, 
            "code": "\nint fiprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  uStack_8 = in_r2;\n  uStack_4 = in_r3;\n  iVar1 = _vfiprintf_r(*(undefined4 *)PTR__impure_ptr_08004880,__stream,__format,&uStack_8,__stream,\n                       &uStack_8);\n  return iVar1;\n}\n\n", 
            "called": [
                "_vfiprintf_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004860", 
            "calling": [
                "__assert_func"
            ], 
            "imported": false, 
            "current_name": "fiprintf"
        }, 
        "__sfputs_r": {
            "renaming": {}, 
            "code": "\nint __sfputs_r(undefined4 param_1,undefined4 param_2,undefined *param_3,int param_4)\n\n{\n  int iVar1;\n  undefined *puVar2;\n  int iVar3;\n  \n  puVar2 = param_3 + param_4;\n  iVar3 = param_4;\n  do {\n    if (param_3 == puVar2) {\n      return 0;\n    }\n    iVar1 = __sfputc_r(param_1,*param_3,param_2,param_4,iVar3);\n    param_4 = iVar1 + 1;\n    param_3 = param_3 + 1;\n  } while (param_4 != 0);\n  return iVar1;\n}\n\n", 
            "called": [
                "__sfputc_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004a60", 
            "calling": [
                "_vfiprintf_r"
            ], 
            "imported": false, 
            "current_name": "__sfputs_r"
        }, 
        "HAL_MspInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_MspInit(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000d96", 
            "calling": [
                "HAL_Init"
            ], 
            "imported": false, 
            "current_name": "HAL_MspInit"
        }, 
        "UART7_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid UART7_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(UART7_IRQn);\n  HAL_UART_IRQHandler(*(UART_HandleTypeDef **)(PTR_uart_handlers_08004078 + 0x18));\n  return;\n}\n\n", 
            "called": [
                "HAL_UART_IRQHandler", 
                "HAL_NVIC_ClearPendingIRQ"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004064", 
            "calling": [], 
            "imported": false, 
            "current_name": "UART7_IRQHandler"
        }, 
        "HAL_I2C_AbortCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001aac", 
            "calling": [
                "I2C_ITError", 
                "I2C_DMAAbort"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_AbortCpltCallback"
        }, 
        "makeWord": {
            "renaming": {}, 
            "code": "\nuint16_t makeWord(uint8_t h,uint8_t l)\n\n{\n  return CONCAT11(h,l);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004640", 
            "calling": [
                "process_FC3", 
                "validateRequest", 
                "process_FC5", 
                "process_FC6", 
                "process_FC15", 
                "process_FC1", 
                "process_FC16"
            ], 
            "imported": false, 
            "current_name": "makeWord"
        }, 
        "HAL_TIM_OC_DelayElapsedCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)\n\n{\n  stimer_t *psVar1;\n  \n  psVar1 = get_timer_obj(htim);\n  if ((psVar1->irqHandleOC != (_func_void_stimer_t_ptr_uint32_t *)0x0) &&\n     (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*psVar1->irqHandleOC)(psVar1,0);\n  }\n  return;\n}\n\n", 
            "called": [
                "get_timer_obj"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003754", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_OC_DelayElapsedCallback"
        }, 
        "IPAddress": {
            "renaming": {}, 
            "code": "\nIPAddress * __thiscall\nIPAddress::IPAddress\n          (IPAddress *this,uint8_t first_octet,uint8_t second_octet,uint8_t third_octet,\n          uint8_t fourth_octet)\n\n{\n  (this->super_Printable)._vptr_Printable = (_func_int_varargs **)PTR_DAT_0800455c;\n  (this->_address).bytes[0] = first_octet;\n  (this->_address).bytes[1] = second_octet;\n  (this->_address).bytes[2] = third_octet;\n  (this->_address).bytes[3] = fourth_octet;\n  return this;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004544", 
            "calling": [
                "__static_initialization_and_destruction_0"
            ], 
            "imported": false, 
            "current_name": "IPAddress"
        }, 
        "_rx_complete_irq": {
            "renaming": {}, 
            "code": "\nvoid HardwareSerial::_rx_complete_irq(serial_t_conflict *obj)\n\n{\n  int iVar1;\n  ushort uVar2;\n  uchar c;\n  \n  iVar1 = uart_getc((serial_t *)obj,&c);\n  if ((iVar1 == 0) && (uVar2 = obj->rx_head + 1 & 0x3f, uVar2 != obj->rx_tail)) {\n    obj->rx_buff[obj->rx_head] = c;\n    obj->rx_head = uVar2;\n  }\n  return;\n}\n\n", 
            "called": [
                "uart_getc"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080042ac", 
            "calling": [], 
            "imported": false, 
            "current_name": "_rx_complete_irq"
        }, 
        "HAL_TIMEx_PWMN_Stop": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim,uint32_t Channel)\n\n{\n  TIM_TypeDef *pTVar1;\n  \n  TIM_CCxNChannelCmd(htim->Instance,Channel,0);\n  pTVar1 = htim->Instance;\n  if (((pTVar1->CCER & 0x1111) == 0) && ((pTVar1->CCER & 0x444) == 0)) {\n    pTVar1->BDTR = pTVar1->BDTR & 0xffff7fff;\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->CCER & 0x1111) == 0) && ((pTVar1->CCER & 0x444) == 0)) {\n    pTVar1->CR1 = pTVar1->CR1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "TIM_CCxNChannelCmd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080028f0", 
            "calling": [
                "pwm_stop"
            ], 
            "imported": false, 
            "current_name": "HAL_TIMEx_PWMN_Stop"
        }, 
        "USART3_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid USART3_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART3_IRQn);\n  if (*(UART_HandleTypeDef **)(PTR_uart_handlers_08004018 + 8) != (UART_HandleTypeDef *)0x0) {\n    HAL_UART_IRQHandler(*(UART_HandleTypeDef **)(PTR_uart_handlers_08004018 + 8));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_UART_IRQHandler", 
                "HAL_NVIC_ClearPendingIRQ"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004004", 
            "calling": [], 
            "imported": false, 
            "current_name": "USART3_IRQHandler"
        }, 
        "_init": {
            "renaming": {}, 
            "code": "\nvoid _init(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080059f8", 
            "calling": [
                "__do_global_dtors_aux", 
                "__libc_init_array"
            ], 
            "imported": false, 
            "current_name": "_init"
        }, 
        "__swsetup_r": {
            "renaming": {}, 
            "code": "\nuint __swsetup_r(undefined4 *param_1,undefined4 *param_2)\n\n{\n  uint uVar1;\n  ushort uVar2;\n  int iVar3;\n  \n  iVar3 = *(int *)PTR__impure_ptr_0800519c;\n  if ((iVar3 != 0) && (*(int *)(iVar3 + 0x18) == 0)) {\n    __sinit(iVar3);\n  }\n  if (param_2 == (undefined4 *)PTR___sf_fake_stdin_080051a0) {\n    param_2 = *(undefined4 **)(iVar3 + 4);\n  }\n  else if (param_2 == (undefined4 *)PTR___sf_fake_stdout_080051a4) {\n    param_2 = *(undefined4 **)(iVar3 + 8);\n  }\n  else if (param_2 == (undefined4 *)PTR___sf_fake_stderr_080051a8) {\n    param_2 = *(undefined4 **)(iVar3 + 0xc);\n  }\n  uVar2 = *(ushort *)(param_2 + 3);\n  uVar1 = (uint)uVar2;\n  if (-1 < (int)(uVar1 << 0x1c)) {\n    if (-1 < (int)(uVar1 << 0x1b)) {\n      *param_1 = 9;\n      goto LAB_08005100;\n    }\n    if ((int)(uVar1 << 0x1d) < 0) {\n      if ((undefined4 *)param_2[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)param_2[0xd] != param_2 + 0x11) {\n          _free_r(param_1);\n        }\n        param_2[0xd] = 0;\n      }\n      *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xffdb;\n      param_2[1] = 0;\n      *param_2 = param_2[4];\n    }\n    *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 8;\n  }\n  if ((param_2[4] == 0) && ((*(ushort *)(param_2 + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(param_1,param_2);\n  }\n  uVar2 = *(ushort *)(param_2 + 3);\n  uVar1 = uVar2 & 1;\n  if ((uVar2 & 1) == 0) {\n    if (-1 < (int)((uint)uVar2 << 0x1e)) {\n      uVar1 = param_2[5];\n    }\n    param_2[2] = uVar1;\n  }\n  else {\n    param_2[2] = 0;\n    param_2[6] = -param_2[5];\n  }\n  if (param_2[4] == 0) {\n    uVar2 = *(ushort *)(param_2 + 3);\n    uVar1 = (int)(short)uVar2 & 0x80;\n    if (uVar1 != 0) {\nLAB_08005100:\n      *(ushort *)(param_2 + 3) = uVar2 | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n", 
            "called": [
                "__smakebuf_r", 
                "_free_r", 
                "__sinit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080050d0", 
            "calling": [
                "__swbuf_r", 
                "_vfiprintf_r"
            ], 
            "imported": false, 
            "current_name": "__swsetup_r"
        }, 
        "UART5_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid UART5_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(UART5_IRQn);\n  HAL_UART_IRQHandler(*(UART_HandleTypeDef **)(PTR_uart_handlers_08004048 + 0x10));\n  return;\n}\n\n", 
            "called": [
                "HAL_UART_IRQHandler", 
                "HAL_NVIC_ClearPendingIRQ"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004034", 
            "calling": [], 
            "imported": false, 
            "current_name": "UART5_IRQHandler"
        }, 
        "available": {
            "renaming": {}, 
            "code": "\nint __thiscall HardwareSerial::available(HardwareSerial *this)\n\n{\n  return ((this->_serial).rx_head + 0x40) - (uint)(this->_serial).rx_tail & 0x3f;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004240", 
            "calling": [
                "serialEventRun"
            ], 
            "imported": false, 
            "current_name": "available"
        }, 
        "dac_stop": {
            "renaming": {}, 
            "code": "\nvoid dac_stop(PinName_conflict pin)\n\n{\n  uint32_t Channel;\n  DAC_HandleTypeDef DacHandle;\n  \n  DacHandle.Instance =\n       (DAC_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_DAC_08003408);\n  if ((DacHandle.Instance != (DAC_TypeDef *)0x0) &&\n     ((Channel = get_dac_channel(pin), Channel == 0 || (Channel == 0x10)))) {\n    HAL_DAC_Stop(&DacHandle,Channel);\n    HAL_DAC_DeInit(&DacHandle);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_DAC_Stop", 
                "get_dac_channel", 
                "pinmap_peripheral", 
                "HAL_DAC_DeInit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080033d8", 
            "calling": [
                "pinMode"
            ], 
            "imported": false, 
            "current_name": "dac_stop"
        }, 
        "EXTI15_10_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI15_10_IRQHandler(void)\n\n{\n  uint uVar1;\n  \n  for (uVar1 = 0x400; uVar1 < 0x8001; uVar1 = uVar1 << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)uVar1);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080047a8", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI15_10_IRQHandler"
        }, 
        "__malloc_lock": {
            "renaming": {}, 
            "code": "\nvoid __malloc_lock(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800557c", 
            "calling": [
                "_malloc_r", 
                "_free_r"
            ], 
            "imported": false, 
            "current_name": "__malloc_lock"
        }, 
        "UART8_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid UART8_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(UART8_IRQn);\n  HAL_UART_IRQHandler(*(UART_HandleTypeDef **)(PTR_uart_handlers_08004090 + 0x1c));\n  return;\n}\n\n", 
            "called": [
                "HAL_UART_IRQHandler", 
                "HAL_NVIC_ClearPendingIRQ"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800407c", 
            "calling": [], 
            "imported": false, 
            "current_name": "UART8_IRQHandler"
        }, 
        "strlen": {
            "renaming": {}, 
            "code": "\nsize_t strlen(char *__s)\n\n{\n  char cVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  pcVar3 = __s;\n  do {\n    pcVar2 = pcVar3 + 1;\n    cVar1 = *pcVar3;\n    pcVar3 = pcVar2;\n  } while (cVar1 != '\\0');\n  return (size_t)(pcVar2 + (-1 - (int)__s));\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000218", 
            "calling": [
                "printNumber"
            ], 
            "imported": false, 
            "current_name": "strlen"
        }, 
        "HAL_DAC_Stop": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef HAL_DAC_Stop(DAC_HandleTypeDef *hdac,uint32_t Channel)\n\n{\n  hdac->Instance->CR = hdac->Instance->CR & ~(1 << (Channel & 0xff));\n  hdac->State = HAL_DAC_STATE_READY;\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000f72", 
            "calling": [
                "dac_stop"
            ], 
            "imported": false, 
            "current_name": "HAL_DAC_Stop"
        }, 
        "HAL_TIM_PWM_DeInit": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)\n\n{\n  TIM_TypeDef *pTVar1;\n  \n  htim->State = HAL_TIM_STATE_BUSY;\n  pTVar1 = htim->Instance;\n  if (((pTVar1->CCER & 0x1111) == 0) && ((pTVar1->CCER & 0x444) == 0)) {\n    pTVar1->CR1 = pTVar1->CR1 & 0xfffffffe;\n  }\n  HAL_TIM_PWM_MspDeInit(htim);\n  htim->State = HAL_TIM_STATE_RESET;\n  htim->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800268e", 
            "calling": [
                "pwm_stop"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_PWM_DeInit"
        }, 
        "HAL_UART_ErrorCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)\n\n{\n  uint32_t tmpval;\n  \n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003f94", 
            "calling": [
                "HAL_UART_IRQHandler", 
                "UART_DMAAbortOnError"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_ErrorCallback"
        }, 
        "loop": {
            "renaming": {}, 
            "code": "\nvoid loop(void)\n\n{\n  Modbus::poll((Modbus *)PTR_slave_08000c78,(uint16_t *)PTR_au16data_08000c74,'\\x10');\n  return;\n}\n\n", 
            "called": [
                "poll"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000c64", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "loop"
        }, 
        "_exit": {
            "renaming": {}, 
            "code": "\nvoid _exit(int status_UNUSED)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
            "called": [
                "_exit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080040f8", 
            "calling": [
                "_exit", 
                "abort"
            ], 
            "imported": false, 
            "current_name": "_exit"
        }, 
        "_close_r": {
            "renaming": {}, 
            "code": "\nvoid _close_r(int *param_1,int param_2)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_080056d0;\n  *(undefined4 *)PTR_errno_080056d0 = 0;\n  iVar2 = _close(param_2);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_close"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080056b4", 
            "calling": [
                "__sclose"
            ], 
            "imported": false, 
            "current_name": "_close_r"
        }, 
        "_sbrk_r": {
            "renaming": {}, 
            "code": "\nvoid _sbrk_r(int *param_1,int param_2)\n\n{\n  undefined *puVar1;\n  caddr_t pcVar2;\n  \n  puVar1 = PTR_errno_08005028;\n  *(undefined4 *)PTR_errno_08005028 = 0;\n  pcVar2 = _sbrk(param_2);\n  if ((pcVar2 == (caddr_t)0xffffffff) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_sbrk"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800500c", 
            "calling": [
                "_malloc_r"
            ], 
            "imported": false, 
            "current_name": "_sbrk_r"
        }, 
        "_read_r": {
            "renaming": {}, 
            "code": "\nvoid _read_r(int *param_1,int param_2,char *param_3,int param_4)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_0800575c;\n  *(undefined4 *)PTR_errno_0800575c = 0;\n  iVar2 = _read(param_2,param_3,param_4);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_read"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800573c", 
            "calling": [
                "__sread"
            ], 
            "imported": false, 
            "current_name": "_read_r"
        }, 
        "__libc_init_array": {
            "renaming": {}, 
            "code": "\nvoid __libc_init_array(void)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  int iVar4;\n  int iVar5;\n  \n  puVar1 = PTR___preinit_array_end_080048bc;\n  iVar4 = (int)PTR___preinit_array_end_080048c0 - (int)PTR___preinit_array_end_080048bc;\n  for (iVar5 = 0; puVar3 = PTR___do_global_dtors_aux_fini_array_entry_080048c8,\n      puVar2 = PTR___preinit_array_end_080048c4, iVar5 != iVar4 >> 2; iVar5 = iVar5 + 1) {\n    (**(code **)(puVar1 + iVar5 * 4))();\n  }\n  _init();\n  for (iVar4 = 0; iVar4 != (int)puVar3 - (int)puVar2 >> 2; iVar4 = iVar4 + 1) {\n    (**(code **)(puVar2 + iVar4 * 4))();\n  }\n  return;\n}\n\n", 
            "called": [
                "premain", 
                "_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004884", 
            "calling": [
                "Reset_Handler"
            ], 
            "imported": false, 
            "current_name": "__libc_init_array"
        }, 
        "HAL_I2C_SlaveTxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080015ba", 
            "calling": [
                "I2C_Slave_AF", 
                "I2C_SlaveTransmit_TXE"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_SlaveTxCpltCallback"
        }, 
        "I2C3_ER_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid I2C3_ER_IRQHandler(void)\n\n{\n  HAL_I2C_ER_IRQHandler(*(I2C_HandleTypeDef **)(PTR_i2c_handles_08003974 + 8));\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003968", 
            "calling": [], 
            "imported": false, 
            "current_name": "I2C3_ER_IRQHandler"
        }, 
        "HAL_UART_TxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)\n\n{\n  byte bVar1;\n  int iVar3;\n  int iVar4;\n  uint uVar2;\n  \n  bVar1 = uart_index(huart);\n  uVar2 = (uint)bVar1;\n  iVar4 = *(int *)(PTR_tx_callback_obj_08003f88 + uVar2 * 4);\n  if ((uVar2 < 10) &&\n     (iVar3 = (**(code **)(PTR_tx_callback_08003f8c + uVar2 * 4))(iVar4), iVar3 != -1)) {\n    HAL_UART_Transmit_IT\n              (*(UART_HandleTypeDef **)\n                (PTR_uart_handlers_08003f90 + (uint)*(byte *)(iVar4 + 0x44) * 4),\n               (uint8_t *)(*(int *)(iVar4 + 0x68) + (uint)*(ushort *)(iVar4 + 0x6e)),1);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_UART_Transmit_IT", 
                "uart_index"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003f48", 
            "calling": [
                "UART_EndTransmit_IT"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_TxCpltCallback"
        }, 
        "_getpid_r": {
            "renaming": {}, 
            "code": "\n__pid_t _getpid_r(void)\n\n{\n  return 1;\n}\n\n", 
            "called": [
                "_getpid"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005604", 
            "calling": [
                "_raise_r"
            ], 
            "imported": false, 
            "current_name": "_getpid_r"
        }, 
        "__sclose": {
            "renaming": {}, 
            "code": "\nvoid __sclose(undefined4 param_1,int param_2)\n\n{\n  _close_r(param_1,(int)*(short *)(param_2 + 0xe));\n  return;\n}\n\n", 
            "called": [
                "_close_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005686", 
            "calling": [], 
            "imported": false, 
            "current_name": "__sclose"
        }, 
        "HAL_DAC_DeInit": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef HAL_DAC_DeInit(DAC_HandleTypeDef *hdac)\n\n{\n  if (hdac != (DAC_HandleTypeDef *)0x0) {\n    hdac->State = HAL_DAC_STATE_BUSY;\n    HAL_DAC_MspDeInit(hdac);\n    hdac->ErrorCode = 0;\n    hdac->State = HAL_DAC_STATE_RESET;\n    hdac->Lock = HAL_UNLOCKED;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n", 
            "called": [
                "HAL_DAC_MspDeInit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000f56", 
            "calling": [
                "dac_stop"
            ], 
            "imported": false, 
            "current_name": "HAL_DAC_DeInit"
        }, 
        "HAL_RCC_GetPCLK1Freq": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_RCC_GetPCLK1Freq(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = HAL_RCC_GetHCLKFreq();\n  return uVar1 >> PTR_APBPrescTable_08002608[(uint)(*(int *)(DAT_08002604 + 8) << 0x13) >> 0x1d];\n}\n\n", 
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080025ec", 
            "calling": [
                "UART_SetConfig"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_GetPCLK1Freq"
        }, 
        "__static_initialization_and_destruction_0": {
            "renaming": {}, 
            "code": "\nvoid __static_initialization_and_destruction_0(int __initialize_p,int __priority)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = PTR_gpio_irq_conf_08004754;\n  if (__initialize_p != 1) {\n    return;\n  }\n  if (__priority == 0xffff) {\n    *PTR_gpio_irq_conf_08004754 = 6;\n    *(undefined4 *)(puVar1 + 0xc) = 0;\n    puVar1[0x14] = 7;\n    *(undefined4 *)(puVar1 + 0x20) = 0;\n    puVar1[0x28] = 8;\n    *(undefined4 *)(puVar1 + 0x34) = 0;\n    puVar1[0x3c] = 9;\n    *(undefined4 *)(puVar1 + 0x48) = 0;\n    puVar1[0x50] = 10;\n    *(undefined4 *)(puVar1 + 0x5c) = 0;\n    puVar1[100] = 0x17;\n    *(undefined4 *)(puVar1 + 0x70) = 0;\n    puVar1[0x78] = 0x17;\n    *(undefined4 *)(puVar1 + 0x84) = 0;\n    puVar1[0x8c] = 0x17;\n    *(undefined4 *)(puVar1 + 0x98) = 0;\n    puVar1[0xa0] = 0x17;\n    *(undefined4 *)(puVar1 + 0xac) = 0;\n    puVar1[0xb4] = 0x17;\n    *(undefined4 *)(puVar1 + 0xc0) = 0;\n    puVar1[200] = 0x28;\n    *(undefined4 *)(puVar1 + 0xd4) = 0;\n    puVar1[0xdc] = 0x28;\n    *(undefined4 *)(puVar1 + 0xe8) = 0;\n    puVar1[0xf0] = 0x28;\n    *(undefined4 *)(puVar1 + 0xfc) = 0;\n    puVar1[0x104] = 0x28;\n    *(undefined4 *)(puVar1 + 0x110) = 0;\n    puVar1[0x118] = 0x28;\n    *(undefined4 *)(puVar1 + 0x124) = 0;\n    puVar1[300] = 0x28;\n    *(undefined4 *)(puVar1 + 0x138) = 0;\n    __aeabi_atexit(0,DAT_0800475c,PTR___dso_handle_08004758);\n  }\n  return;\n}\n\n", 
            "called": [
                "__aeabi_atexit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080046b4", 
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ], 
            "imported": false, 
            "current_name": "__static_initialization_and_destruction_0"
        }, 
        "UART_Receive_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)\n\n{\n  byte *pbVar1;\n  uint16_t uVar2;\n  uint8_t *puVar3;\n  \n  if (huart->RxState != HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  if ((huart->Init).WordLength == 0x1000) {\n    if ((huart->Init).Parity == 0) {\n      *(ushort *)huart->pRxBuffPtr = (ushort)((huart->Instance->DR << 0x17) >> 0x17);\n      huart->pRxBuffPtr = huart->pRxBuffPtr + 2;\n    }\n    else {\n      *(ushort *)huart->pRxBuffPtr = (ushort)huart->Instance->DR & 0xff;\n      huart->pRxBuffPtr = huart->pRxBuffPtr + 1;\n    }\n  }\n  else if ((huart->Init).Parity == 0) {\n    puVar3 = huart->pRxBuffPtr;\n    huart->pRxBuffPtr = puVar3 + 1;\n    *puVar3 = (uint8_t)huart->Instance->DR;\n  }\n  else {\n    pbVar1 = huart->pRxBuffPtr;\n    huart->pRxBuffPtr = pbVar1 + 1;\n    *pbVar1 = (byte)huart->Instance->DR & 0x7f;\n  }\n  uVar2 = huart->RxXferCount - 1;\n  huart->RxXferCount = uVar2;\n  if (uVar2 != 0) {\n    return HAL_OK;\n  }\n  huart->Instance->CR1 = huart->Instance->CR1 & 0xfffffedf;\n  huart->Instance->CR3 = huart->Instance->CR3 & 0xfffffffe;\n  huart->RxState = HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(huart);\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_UART_RxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002f66", 
            "calling": [
                "HAL_UART_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "UART_Receive_IT"
        }, 
        "HAL_GetTick": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_GetTick(void)\n\n{\n  return *(uint32_t *)PTR_uwTick_08000e38;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000e30", 
            "calling": [
                "HAL_RCC_OscConfig", 
                "GetCurrentMilli", 
                "UART_WaitOnFlagUntilTimeout", 
                "uart_debug_write", 
                "HAL_RCC_ClockConfig", 
                "HAL_UART_Transmit", 
                "HAL_PWREx_EnableOverDrive"
            ], 
            "imported": false, 
            "current_name": "HAL_GetTick"
        }, 
        "EXTI9_5_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI9_5_IRQHandler(void)\n\n{\n  uint uVar1;\n  \n  for (uVar1 = 0x20; uVar1 < 0x201; uVar1 = uVar1 << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)uVar1);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004792", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI9_5_IRQHandler"
        }, 
        "I2C_Master_SB": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef I2C_Master_SB(I2C_HandleTypeDef *hi2c)\n\n{\n  if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n    if (hi2c->EventCount == 0) {\n      hi2c->Instance->DR = hi2c->Devaddress & 0xfe;\n    }\n    else {\n      hi2c->Instance->DR = hi2c->Devaddress & 0xff | 1;\n    }\n  }\n  else if ((hi2c->Init).AddressingMode == 0x4000) {\n    if (hi2c->State == HAL_I2C_STATE_BUSY_TX) {\n      hi2c->Instance->DR = hi2c->Devaddress & 0xfe;\n    }\n    else {\n      hi2c->Instance->DR = hi2c->Devaddress & 0xff | 1;\n    }\n  }\n  else if (hi2c->EventCount == 0) {\n    hi2c->Instance->DR = (hi2c->Devaddress << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (hi2c->EventCount == 1) {\n    hi2c->Instance->DR = (hi2c->Devaddress << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080011c0", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_Master_SB"
        }, 
        "TIM_CCxChannelCmd": {
            "renaming": {}, 
            "code": "\nvoid TIM_CCxChannelCmd(TIM_TypeDef *TIMx,uint32_t Channel,uint32_t ChannelState)\n\n{\n  TIMx->CCER = TIMx->CCER & ~(1 << (Channel & 0xff));\n  TIMx->CCER = TIMx->CCER | ChannelState << (Channel & 0xff);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002848", 
            "calling": [
                "HAL_TIM_PWM_Stop"
            ], 
            "imported": false, 
            "current_name": "TIM_CCxChannelCmd"
        }, 
        "get_timer_obj": {
            "renaming": {}, 
            "code": "\nstimer_t * get_timer_obj(TIM_HandleTypeDef *htim)\n\n{\n  return (stimer_t *)&htim[-1].Lock;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003750", 
            "calling": [
                "HAL_TIM_OC_DelayElapsedCallback", 
                "HAL_TIM_PeriodElapsedCallback"
            ], 
            "imported": false, 
            "current_name": "get_timer_obj"
        }, 
        "I2C1_EV_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid I2C1_EV_IRQHandler(void)\n\n{\n  HAL_I2C_EV_IRQHandler(*(I2C_HandleTypeDef **)PTR_i2c_handles_08003924);\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003918", 
            "calling": [], 
            "imported": false, 
            "current_name": "I2C1_EV_IRQHandler"
        }, 
        "abort": {
            "renaming": {}, 
            "code": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid abort(void)\n\n{\n  raise(6);\n                    /* WARNING: Subroutine does not return */\n  _exit(1);\n}\n\n", 
            "called": [
                "_exit", 
                "raise"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080051ac", 
            "calling": [
                "__assert_func", 
                "__throw_bad_function_call"
            ], 
            "imported": false, 
            "current_name": "abort"
        }, 
        "get_GPIO_Port": {
            "renaming": {}, 
            "code": "\nGPIO_TypeDef * get_GPIO_Port(uint32_t port_idx)\n\n{\n  switch(port_idx) {\n  case 0:\n    return DAT_080031d0;\n  case 1:\n    return DAT_080031f8;\n  case 2:\n    return DAT_080031d4;\n  case 3:\n    return DAT_080031d8;\n  case 4:\n    return DAT_080031dc;\n  case 5:\n    return DAT_080031e0;\n  case 6:\n    return DAT_080031e4;\n  case 7:\n    return DAT_080031e8;\n  case 8:\n    return DAT_080031ec;\n  case 9:\n    return DAT_080031f0;\n  case 10:\n    return DAT_080031f4;\n  default:\n    return (GPIO_TypeDef *)0x0;\n  }\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800318c", 
            "calling": [
                "digitalWrite"
            ], 
            "imported": false, 
            "current_name": "get_GPIO_Port"
        }, 
        "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm": {
            "renaming": {}, 
            "code": "\nvoid _GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n", 
            "called": [
                "__static_initialization_and_destruction_0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080047f0", 
            "calling": [], 
            "imported": false, 
            "current_name": "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
        }, 
        "_isatty_r": {
            "renaming": {}, 
            "code": "\nvoid _isatty_r(int *param_1,int param_2)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_08005714;\n  *(undefined4 *)PTR_errno_08005714 = 0;\n  iVar2 = _isatty(param_2);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_isatty"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080056f8", 
            "calling": [
                "__smakebuf_r"
            ], 
            "imported": false, 
            "current_name": "_isatty_r"
        }, 
        "aflCall": {
            "renaming": {}, 
            "code": "\nuint32_t aflCall(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080005e0", 
            "calling": [
                "startForkserver"
            ], 
            "imported": false, 
            "current_name": "aflCall"
        }, 
        "HAL_GPIO_EXTI_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)\n\n{\n  if ((*(uint *)(DAT_080011bc + 0x14) & (uint)GPIO_Pin) != 0) {\n    *(uint *)(DAT_080011bc + 0x14) = (uint)GPIO_Pin;\n    HAL_GPIO_EXTI_Callback(GPIO_Pin);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080011a4", 
            "calling": [
                "EXTI9_5_IRQHandler", 
                "EXTI4_IRQHandler", 
                "EXTI0_IRQHandler", 
                "EXTI1_IRQHandler", 
                "EXTI3_IRQHandler", 
                "EXTI2_IRQHandler", 
                "EXTI15_10_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_GPIO_EXTI_IRQHandler"
        }, 
        "__sread": {
            "renaming": {}, 
            "code": "\nvoid __sread(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  bool bVar3;\n  \n  iVar1 = _read_r(param_1,(int)*(short *)(param_2 + 0xe));\n  bVar3 = -1 < iVar1;\n  if (bVar3) {\n    uVar2 = *(int *)(param_2 + 0x54) + iVar1;\n  }\n  else {\n    uVar2 = *(ushort *)(param_2 + 0xc) & 0xffffefff;\n  }\n  if (bVar3) {\n    *(uint *)(param_2 + 0x54) = uVar2;\n  }\n  if (!bVar3) {\n    *(short *)(param_2 + 0xc) = (short)uVar2;\n  }\n  return;\n}\n\n", 
            "called": [
                "_read_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005608", 
            "calling": [], 
            "imported": false, 
            "current_name": "__sread"
        }, 
        "Reset_Handler": {
            "renaming": {}, 
            "code": "\nvoid Reset_Handler(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  code *UNRECOVERED_JUMPTABLE;\n  \n  for (iVar1 = 0; puVar2 = (undefined4 *)PTR_completed_8667_08000d84,\n      PTR___dso_handle_08000d7c + iVar1 < PTR_completed_8667_08000d80; iVar1 = iVar1 + 4) {\n    *(undefined4 *)(PTR___dso_handle_08000d7c + iVar1) =\n         *(undefined4 *)(PTR__sidata_08000d78 + iVar1);\n  }\n  for (; puVar2 < PTR__ebss_08000d88; puVar2 = puVar2 + 1) {\n    *puVar2 = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  UNRECOVERED_JUMPTABLE = (code *)0x8000d72;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08000d72. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n", 
            "called": [
                "main", 
                "__libc_init_array", 
                "SystemInit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000d3c", 
            "calling": [], 
            "imported": false, 
            "current_name": "Reset_Handler"
        }, 
        "pinMode": {
            "renaming": {}, 
            "code": "\nvoid pinMode(uint32_t ulPin,uint32_t ulMode)\n\n{\n  _Bool _Var1;\n  PinName_conflict pin;\n  \n  if (ulPin < 0x60) {\n    pin = *(PinName_conflict *)(PTR_digitalPin_080041a8 + ulPin * 2);\n  }\n  else {\n    pin = NC;\n  }\n  if (pin != NC) {\n    _Var1 = is_pin_configured(pin,(uint32_t *)PTR_g_anOutputPinConfigured_080041ac);\n    if (_Var1) {\n      _Var1 = pin_in_pinmap(pin,(PinMap_conflict *)PTR_PinMap_DAC_080041b0);\n      if (_Var1) {\n        dac_stop(pin);\n      }\n      else {\n        _Var1 = pin_in_pinmap(pin,(PinMap_conflict *)PTR_PinMap_PWM_080041b4);\n        if (_Var1) {\n          pwm_stop(pin);\n        }\n      }\n      reset_pin_configured(pin,(uint32_t *)PTR_g_anOutputPinConfigured_080041ac);\n    }\n    switch(ulMode) {\n    case 0:\n      digital_io_init(pin,0,0);\n      break;\n    case 1:\n      digital_io_init(pin,1,0);\n      break;\n    case 2:\n      digital_io_init(pin,0,1);\n      break;\n    case 3:\n      digital_io_init(pin,0,2);\n    }\n    set_pin_configured(pin,(uint32_t *)PTR_g_digPinConfigured_080041b8);\n  }\n  return;\n}\n\n", 
            "called": [
                "pin_in_pinmap", 
                "digital_io_init", 
                "reset_pin_configured", 
                "pwm_stop", 
                "set_pin_configured", 
                "dac_stop", 
                "is_pin_configured"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004110", 
            "calling": [
                "begin"
            ], 
            "imported": false, 
            "current_name": "pinMode"
        }, 
        "HAL_RTCEx_AlarmBEventCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_RTCEx_AlarmBEventCallback(RTC_HandleTypeDef *hrtc)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800268c", 
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_RTCEx_AlarmBEventCallback"
        }, 
        "set_GPIO_Port_Clock": {
            "renaming": {}, 
            "code": "\nGPIO_TypeDef * set_GPIO_Port_Clock(uint32_t port_idx)\n\n{\n  GPIO_TypeDef *pGVar1;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  uint32_t tmpreg_10;\n  \n  switch(port_idx) {\n  case 0:\n    *(uint *)(DAT_08003350 + 0x30) = *(uint *)(DAT_08003350 + 0x30) | 1;\n    pGVar1 = DAT_08003354;\n    break;\n  case 1:\n    *(uint *)(DAT_08003350 + 0x30) = *(uint *)(DAT_08003350 + 0x30) | 2;\n    pGVar1 = DAT_08003358;\n    break;\n  case 2:\n    *(uint *)(DAT_08003350 + 0x30) = *(uint *)(DAT_08003350 + 0x30) | 4;\n    pGVar1 = DAT_0800335c;\n    break;\n  case 3:\n    *(uint *)(DAT_08003350 + 0x30) = *(uint *)(DAT_08003350 + 0x30) | 8;\n    pGVar1 = DAT_08003360;\n    break;\n  case 4:\n    *(uint *)(DAT_08003350 + 0x30) = *(uint *)(DAT_08003350 + 0x30) | 0x10;\n    pGVar1 = DAT_08003364;\n    break;\n  case 5:\n    *(uint *)(DAT_08003350 + 0x30) = *(uint *)(DAT_08003350 + 0x30) | 0x20;\n    pGVar1 = DAT_08003368;\n    break;\n  case 6:\n    *(uint *)(DAT_08003350 + 0x30) = *(uint *)(DAT_08003350 + 0x30) | 0x40;\n    pGVar1 = DAT_0800336c;\n    break;\n  case 7:\n    *(uint *)(DAT_08003350 + 0x30) = *(uint *)(DAT_08003350 + 0x30) | 0x80;\n    pGVar1 = DAT_08003370;\n    break;\n  case 8:\n    *(uint *)(DAT_08003350 + 0x30) = *(uint *)(DAT_08003350 + 0x30) | 0x100;\n    pGVar1 = DAT_08003374;\n    break;\n  case 9:\n    *(uint *)(DAT_08003350 + 0x30) = *(uint *)(DAT_08003350 + 0x30) | 0x200;\n    pGVar1 = DAT_08003378;\n    break;\n  case 10:\n    *(uint *)(DAT_08003350 + 0x30) = *(uint *)(DAT_08003350 + 0x30) | 0x400;\n    pGVar1 = DAT_0800337c;\n    break;\n  default:\n    pGVar1 = (GPIO_TypeDef *)0x0;\n  }\n  return pGVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080031fc", 
            "calling": [
                "uart_init", 
                "digital_io_init"
            ], 
            "imported": false, 
            "current_name": "set_GPIO_Port_Clock"
        }, 
        "_write_r": {
            "renaming": {}, 
            "code": "\nvoid _write_r(int *param_1,int param_2,char *param_3,int param_4)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_080056b0;\n  *(undefined4 *)PTR_errno_080056b0 = 0;\n  iVar2 = _write(param_2,param_3,param_4);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_write"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005690", 
            "calling": [
                "__swrite"
            ], 
            "imported": false, 
            "current_name": "_write_r"
        }, 
        "HAL_I2C_MemTxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001718", 
            "calling": [
                "I2C_MasterTransmit_TXE", 
                "I2C_MasterTransmit_BTF"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_MemTxCpltCallback"
        }, 
        "uart_debug_write": {
            "renaming": {}, 
            "code": "\nsize_t uart_debug_write(uint8_t *data,uint32_t size)\n\n{\n  PinName_conflict pin;\n  HAL_StatusTypeDef HVar1;\n  uint32_t uVar2;\n  void *pvVar3;\n  uint32_t uVar4;\n  uint uVar5;\n  \n  uVar2 = HAL_GetTick();\n  pin = *(PinName_conflict *)(PTR_digitalPin_08003dc0 + 0x9a);\n  pvVar3 = pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_UART_TX_08003dc4);\n  if (pvVar3 == (void *)0x0) {\n    return 0;\n  }\n  uVar5 = 0;\n  while ((uVar5 < 10 &&\n         ((*(int *)(PTR_uart_handlers_08003dc8 + uVar5 * 4) == 0 ||\n          (pvVar3 = pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_UART_TX_08003dc4),\n          **(void ***)(PTR_uart_handlers_08003dc8 + uVar5 * 4) != pvVar3))))) {\n    uVar5 = uVar5 + 1 & 0xff;\n  }\n  if (9 < uVar5) {\n    if ((9 < (byte)PTR_serial_debug_08003dcc[0x44]) &&\n       (uart_debug_init(), 9 < (byte)PTR_serial_debug_08003dcc[0x44])) {\n      return 0;\n    }\n    uVar5 = (uint)(byte)PTR_serial_debug_08003dcc[0x44];\n  }\n  do {\n    HVar1 = HAL_UART_Transmit(*(UART_HandleTypeDef **)(PTR_uart_handlers_08003dc8 + uVar5 * 4),data,\n                              (uint16_t)size,1000);\n    if (HVar1 == HAL_OK) {\n      return size;\n    }\n    uVar4 = HAL_GetTick();\n  } while (uVar4 - uVar2 < 1000);\n  return 0;\n}\n\n", 
            "called": [
                "uart_debug_init", 
                "HAL_UART_Transmit", 
                "pinmap_peripheral", 
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003d18", 
            "calling": [
                "_write"
            ], 
            "imported": false, 
            "current_name": "uart_debug_write"
        }, 
        "HAL_SYSTICK_CLKSourceConfig": {
            "renaming": {}, 
            "code": "\nvoid HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)\n\n{\n  if (CLKSource != 4) {\n    *DAT_08000f48 = *DAT_08000f48 & 0xfffffffb;\n    return;\n  }\n  *DAT_08000f48 = *DAT_08000f48 | 4;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000f2c", 
            "calling": [
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_SYSTICK_CLKSourceConfig"
        }, 
        "setRx": {
            "renaming": {}, 
            "code": "\nvoid __thiscall HardwareSerial::setRx(HardwareSerial *this,uint32_t _rx)\n\n{\n  PinName PVar1;\n  \n  if (_rx < 0x60) {\n    PVar1 = *(PinName *)(PTR_digitalPin_0800445c + _rx * 2);\n  }\n  else {\n    PVar1 = NC;\n  }\n  (this->_serial).pin_rx = PVar1;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004444", 
            "calling": [
                "HardwareSerial"
            ], 
            "imported": false, 
            "current_name": "setRx"
        }, 
        "getRxBuffer": {
            "renaming": {}, 
            "code": "\nint8_t __thiscall Modbus::getRxBuffer(Modbus *this)\n\n{\n  bool bVar1;\n  int iVar2;\n  byte bVar3;\n  \n  if (1 < this->u8txenpin) {\n    digitalWrite((uint)this->u8txenpin,0);\n  }\n  this->u8BufferSize = '\\0';\n  if (this->u8serno < 4) {\n    bVar1 = false;\n    while (iVar2 = (*(this->port->super_Stream).super_Print._vptr_Print[2])(), iVar2 != 0) {\n      bVar3 = this->u8BufferSize;\n      iVar2 = (*(this->port->super_Stream).super_Print._vptr_Print[3])();\n      this->au8Buffer[bVar3] = (uint8_t)iVar2;\n      bVar3 = this->u8BufferSize + 1;\n      this->u8BufferSize = bVar3;\n      if (0x3f < bVar3) {\n        bVar1 = true;\n      }\n    }\n  }\n  else {\n    bVar1 = false;\n  }\n  this->u16InCnt = this->u16InCnt + 1;\n  if (bVar1) {\n    this->u16errCnt = this->u16errCnt + 1;\n    return -3;\n  }\n  return this->u8BufferSize;\n}\n\n", 
            "called": [
                "digitalWrite"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080006b4", 
            "calling": [
                "poll"
            ], 
            "imported": false, 
            "current_name": "getRxBuffer"
        }, 
        "I2C2_EV_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid I2C2_EV_IRQHandler(void)\n\n{\n  HAL_I2C_EV_IRQHandler(*(I2C_HandleTypeDef **)(PTR_i2c_handles_08003944 + 4));\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003938", 
            "calling": [], 
            "imported": false, 
            "current_name": "I2C2_EV_IRQHandler"
        }, 
        "flush": {
            "renaming": {}, 
            "code": "\nvoid __thiscall HardwareSerial::flush(HardwareSerial *this)\n\n{\n  if (this->_written != false) {\n    do {\n    } while ((this->_serial).tx_head != (this->_serial).tx_tail);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004298", 
            "calling": [], 
            "imported": false, 
            "current_name": "flush"
        }, 
        "HAL_RTC_AlarmAEventCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)\n\n{\n  if (*(code **)PTR_RTCUserCallback_080035a4 != (code *)0x0) {\n    (**(code **)PTR_RTCUserCallback_080035a4)(*(undefined4 *)PTR_callbackUserData_080035a8);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003594", 
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_RTC_AlarmAEventCallback"
        }, 
        "_sbrk": {
            "renaming": {}, 
            "code": "\ncaddr_t _sbrk(int incr)\n\n{\n  caddr_t pcVar1;\n  caddr_t pcVar2;\n  \n  if (*(int *)PTR_heap_end_080040c4 == 0) {\n    *(undefined **)PTR_heap_end_080040c4 = PTR__ebss_080040c8;\n  }\n  pcVar1 = *(caddr_t *)PTR_heap_end_080040c4;\n  pcVar2 = pcVar1 + incr;\n  if (pcVar2 <= &stack0x00000000) {\n    *(caddr_t *)PTR_heap_end_080040c4 = pcVar2;\n    return pcVar1;\n  }\n  *(undefined4 *)PTR_errno_080040cc = 0xc;\n  return (caddr_t)0xffffffff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004094", 
            "calling": [
                "_sbrk_r"
            ], 
            "imported": false, 
            "current_name": "_sbrk"
        }, 
        "UART_EndRxTransfer": {
            "renaming": {}, 
            "code": "\nvoid UART_EndRxTransfer(UART_HandleTypeDef *huart)\n\n{\n  huart->Instance->CR1 = huart->Instance->CR1 & 0xfffffedf;\n  huart->Instance->CR3 = huart->Instance->CR3 & 0xfffffffe;\n  huart->RxState = HAL_UART_STATE_READY;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002940", 
            "calling": [
                "HAL_UART_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "UART_EndRxTransfer"
        }, 
        "__cxa_atexit": {
            "renaming": {}, 
            "code": "\nlonglong __cxa_atexit(undefined4 param_1,uint param_2)\n\n{\n  if (DAT_0800485c != 0) {\n    return CONCAT44(param_1,2);\n  }\n  return (ulonglong)param_2 << 0x20;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004844", 
            "calling": [
                "__aeabi_atexit"
            ], 
            "imported": false, 
            "current_name": "__cxa_atexit"
        }, 
        "uart_debug_init": {
            "renaming": {}, 
            "code": "\nvoid uart_debug_init(void)\n\n{\n  PinName_conflict pin;\n  undefined *obj;\n  PinName_conflict PVar1;\n  void *pvVar2;\n  \n  pin = *(PinName_conflict *)(PTR_digitalPin_08003d08 + 0x9a);\n  pvVar2 = pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_UART_TX_08003d0c);\n  if (pvVar2 != (void *)0x0) {\n    pvVar2 = pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_UART_TX_08003d0c);\n    PVar1 = pinmap_pin(pvVar2,(PinMap_conflict *)PTR_PinMap_UART_RX_08003d10);\n    obj = PTR_serial_debug_08003d14;\n    *(PinName_conflict *)(PTR_serial_debug_08003d14 + 0x5a) = PVar1;\n    *(PinName_conflict *)(obj + 0x58) = pin;\n    *(undefined4 *)(obj + 0x48) = 0x2580;\n    *(undefined4 *)(obj + 0x54) = 0;\n    *(undefined4 *)(obj + 0x4c) = 0;\n    *(undefined4 *)(obj + 0x50) = 0;\n    uart_init((serial_t *)obj);\n  }\n  return;\n}\n\n", 
            "called": [
                "uart_init", 
                "pinmap_peripheral", 
                "pinmap_pin"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003cc8", 
            "calling": [
                "uart_debug_write"
            ], 
            "imported": false, 
            "current_name": "uart_debug_init"
        }, 
        "HAL_DMA_Abort_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)\n\n{\n  if (hdma->State != HAL_DMA_STATE_BUSY) {\n    hdma->ErrorCode = 0x80;\n    return HAL_ERROR;\n  }\n  hdma->State = HAL_DMA_STATE_ABORT;\n  hdma->Instance->CR = hdma->Instance->CR & 0xfffffffe;\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000f8c", 
            "calling": [
                "HAL_UART_IRQHandler", 
                "I2C_ITError"
            ], 
            "imported": false, 
            "current_name": "HAL_DMA_Abort_IT"
        }, 
        "HAL_UART_MspInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_UART_MspInit(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002d70", 
            "calling": [
                "HAL_UART_Init"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_MspInit"
        }, 
        "_fwalk_reent": {
            "renaming": {}, 
            "code": "\nuint _fwalk_reent(int param_1,code *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  uint uVar1;\n  int iVar2;\n  int *piVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  \n  uVar5 = 0;\n  for (piVar3 = (int *)(param_1 + 0x48); piVar3 != (int *)0x0; piVar3 = (int *)*piVar3) {\n    iVar4 = piVar3[2];\n    iVar6 = piVar3[1];\n    while (iVar6 = iVar6 + -1, -1 < iVar6) {\n      if ((1 < *(ushort *)(iVar4 + 0xc)) && (iVar2 = *(short *)(iVar4 + 0xe) + 1, iVar2 != 0)) {\n        uVar1 = (*param_2)(param_1,iVar4,param_3,iVar2,param_4);\n        uVar5 = uVar5 | uVar1;\n      }\n      iVar4 = iVar4 + 0x68;\n    }\n  }\n  return uVar5;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005478", 
            "calling": [
                "_cleanup_r"
            ], 
            "imported": false, 
            "current_name": "_fwalk_reent"
        }, 
        "pinmap_peripheral": {
            "renaming": {}, 
            "code": "\nvoid * pinmap_peripheral(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  void *pvVar1;\n  \n  if (pin != NC) {\n    pvVar1 = pinmap_find_peripheral(pin,map);\n    return pvVar1;\n  }\n  return (void *)0x0;\n}\n\n", 
            "called": [
                "pinmap_find_peripheral"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080034f4", 
            "calling": [
                "uart_init", 
                "uart_debug_write", 
                "pwm_stop", 
                "uart_debug_init", 
                "dac_stop"
            ], 
            "imported": false, 
            "current_name": "pinmap_peripheral"
        }, 
        "SystemInit": {
            "renaming": {}, 
            "code": "\nvoid SystemInit(void)\n\n{\n  uint *puVar1;\n  \n  puVar1 = DAT_080035f0;\n  *DAT_080035f0 = *DAT_080035f0 | 1;\n  puVar1[2] = 0;\n  *puVar1 = *puVar1 & 0xfef6ffff;\n  puVar1[1] = DAT_080035f4;\n  *puVar1 = *puVar1 & 0xfffbffff;\n  puVar1[3] = 0;\n  *(undefined4 *)(DAT_080035f8 + 8) = 0x8000000;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080035bc", 
            "calling": [
                "Reset_Handler"
            ], 
            "imported": false, 
            "current_name": "SystemInit"
        }, 
        "uart_getc": {
            "renaming": {}, 
            "code": "\nint uart_getc(serial_t *obj,uchar *c)\n\n{\n  uint8_t uVar1;\n  \n  if (obj == (serial_t *)0x0) {\n    return -1;\n  }\n  uVar1 = serial_rx_active(obj);\n  if (uVar1 == '\\0') {\n    *c = obj->recv;\n    HAL_UART_Receive_IT(*(UART_HandleTypeDef **)(PTR_uart_handlers_08003e50 + (uint)obj->index * 4),\n                        &obj->recv,1);\n    return 0;\n  }\n  return -1;\n}\n\n", 
            "called": [
                "HAL_UART_Receive_IT", 
                "serial_rx_active"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003e18", 
            "calling": [
                "_rx_complete_irq"
            ], 
            "imported": false, 
            "current_name": "uart_getc"
        }, 
        "uart_attach_rx_callback": {
            "renaming": {}, 
            "code": "\nvoid uart_attach_rx_callback(serial_t *obj,_func_void_serial_t_ptr *callback)\n\n{\n  byte bVar1;\n  uint8_t uVar2;\n  \n  if (obj != (serial_t *)0x0) {\n    uVar2 = serial_rx_active(obj);\n    if (uVar2 == '\\0') {\n      bVar1 = obj->index;\n      *(_func_void_serial_t_ptr **)(PTR_rx_callback_08003ea0 + (uint)bVar1 * 4) = callback;\n      *(serial_t **)(PTR_rx_callback_obj_08003ea4 + (uint)bVar1 * 4) = obj;\n      HAL_NVIC_SetPriority(obj->irq,0,1);\n      HAL_NVIC_EnableIRQ(obj->irq);\n      HAL_UART_Receive_IT(*(UART_HandleTypeDef **)\n                           (PTR_uart_handlers_08003ea8 + (uint)obj->index * 4),&obj->recv,1);\n    }\n    return;\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_UART_Receive_IT", 
                "HAL_NVIC_SetPriority", 
                "HAL_NVIC_EnableIRQ", 
                "serial_rx_active"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003e54", 
            "calling": [
                "begin"
            ], 
            "imported": false, 
            "current_name": "uart_attach_rx_callback"
        }, 
        "operator()": {
            "renaming": {}, 
            "code": "\nvoid __thiscall std::function<void()>::operator__(function_void___ *this)\n\n{\n  if ((this->super__Function_base)._M_manager != (_Manager_type)0x0) {\n    (*this->_M_invoker)((_Any_data *)this);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __throw_bad_function_call();\n}\n\n", 
            "called": [
                "__throw_bad_function_call"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080047c0", 
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ], 
            "imported": false, 
            "current_name": "operator()"
        }, 
        "pinmap_merge_peripheral": {
            "renaming": {}, 
            "code": "\nvoid * pinmap_merge_peripheral(void *a,void *b)\n\n{\n  if (a != b) {\n    if (a == (void *)0x0) {\n      return b;\n    }\n    if (b == (void *)0x0) {\n      return a;\n    }\n    a = (void *)0x0;\n  }\n  return a;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003582", 
            "calling": [
                "uart_init"
            ], 
            "imported": false, 
            "current_name": "pinmap_merge_peripheral"
        }, 
        "HAL_I2C_AddrCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c,uint8_t TransferDirection,uint16_t AddrMatchCode)\n\n{\n  i2c_t *piVar1;\n  \n  piVar1 = get_i2c_obj(hi2c);\n  if ((uint)AddrMatchCode == (hi2c->Init).OwnAddress1) {\n    if (TransferDirection == '\\0') {\n      piVar1->i2cTxRxBufferSize = '\\0';\n      piVar1->slaveMode = '\\0';\n      if (piVar1->i2c_onSlaveTransmit != (_func_void *)0x0) {\n        (*piVar1->i2c_onSlaveTransmit)();\n      }\n      HAL_I2C_Slave_Sequential_Transmit_IT\n                (hi2c,piVar1->i2cTxRxBuffer,(ushort)piVar1->i2cTxRxBufferSize,8);\n      return;\n    }\n    piVar1->slaveMode = '\\x01';\n    HAL_I2C_Slave_Sequential_Receive_IT(hi2c,piVar1->i2cTxRxBuffer,0x20,8);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_Slave_Sequential_Transmit_IT", 
                "get_i2c_obj", 
                "HAL_I2C_Slave_Sequential_Receive_IT"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003880", 
            "calling": [
                "I2C_Slave_ADDR"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_AddrCallback"
        }, 
        "UART_SetConfig": {
            "renaming": {}, 
            "code": "\nvoid UART_SetConfig(UART_HandleTypeDef *huart)\n\n{\n  ulonglong uVar1;\n  uint uVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  uint32_t uVar5;\n  uint32_t uVar6;\n  uint32_t uVar7;\n  uint32_t uVar8;\n  uint32_t uVar9;\n  uint32_t uVar10;\n  uint32_t uVar11;\n  USART_TypeDef *pUVar12;\n  \n  huart->Instance->CR2 = huart->Instance->CR2 & 0xffffcfff | (huart->Init).StopBits;\n  huart->Instance->CR1 =\n       huart->Instance->CR1 & 0xffff69f3 |\n       (huart->Init).WordLength | (huart->Init).Parity | (huart->Init).Mode |\n       (huart->Init).OverSampling;\n  huart->Instance->CR3 = huart->Instance->CR3 & 0xfffffcff | (huart->Init).HwFlowCtl;\n  if ((huart->Init).OverSampling == 0x8000) {\n    pUVar12 = huart->Instance;\n    if ((pUVar12 != (USART_TypeDef *)0x40011000) && (pUVar12 != (USART_TypeDef *)0x40011400)) {\n      uVar3 = HAL_RCC_GetPCLK1Freq();\n      uVar2 = DAT_08002d08;\n      uVar8 = (huart->Init).BaudRate;\n      uVar1 = (ulonglong)DAT_08002d08;\n      uVar4 = HAL_RCC_GetPCLK1Freq();\n      uVar9 = (huart->Init).BaudRate;\n      uVar5 = HAL_RCC_GetPCLK1Freq();\n      uVar10 = (huart->Init).BaudRate;\n      uVar6 = HAL_RCC_GetPCLK1Freq();\n      uVar11 = (huart->Init).BaudRate;\n      uVar7 = HAL_RCC_GetPCLK1Freq();\n      pUVar12->BRR = ((uint)((int)((ulonglong)uVar2 *\n                                   (ulonglong)\n                                   (((uVar6 * 0x19) / (uVar11 << 1) +\n                                    (uint)((ulonglong)uVar2 *\n                                           ((ulonglong)(uVar7 * 0x19) /\n                                           (ulonglong)((huart->Init).BaudRate << 1)) >> 0x25) * -100\n                                    ) * 8 + 0x32) >> 0x20) << 0x18) >> 0x1d) +\n                     ((uint)((ulonglong)uVar2 *\n                             (ulonglong)\n                             (((uVar4 * 0x19) / (uVar9 << 1) +\n                              (uint)((ulonglong)uVar2 *\n                                     ((ulonglong)(uVar5 * 0x19) / (ulonglong)(uVar10 << 1)) >> 0x25)\n                              * -100) * 8 + 0x32) >> 0x25) & 0xf8) * 2 +\n                     (uint)(uVar1 * ((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 << 1)) >> 0x25) *\n                     0x10;\n      return;\n    }\n    uVar3 = HAL_RCC_GetPCLK2Freq();\n    uVar2 = DAT_08002d08;\n    uVar8 = (huart->Init).BaudRate;\n    uVar1 = (ulonglong)DAT_08002d08;\n    uVar4 = HAL_RCC_GetPCLK2Freq();\n    uVar9 = (huart->Init).BaudRate;\n    uVar5 = HAL_RCC_GetPCLK2Freq();\n    uVar10 = (huart->Init).BaudRate;\n    uVar6 = HAL_RCC_GetPCLK2Freq();\n    uVar11 = (huart->Init).BaudRate;\n    uVar7 = HAL_RCC_GetPCLK2Freq();\n    pUVar12->BRR = ((uint)((int)((ulonglong)uVar2 *\n                                 (ulonglong)\n                                 (((uVar6 * 0x19) / (uVar11 << 1) +\n                                  (uint)((ulonglong)uVar2 *\n                                         ((ulonglong)(uVar7 * 0x19) /\n                                         (ulonglong)((huart->Init).BaudRate << 1)) >> 0x25) * -100)\n                                  * 8 + 0x32) >> 0x20) << 0x18) >> 0x1d) +\n                   ((uint)((ulonglong)uVar2 *\n                           (ulonglong)\n                           (((uVar4 * 0x19) / (uVar9 << 1) +\n                            (uint)((ulonglong)uVar2 *\n                                   ((ulonglong)(uVar5 * 0x19) / (ulonglong)(uVar10 << 1)) >> 0x25) *\n                            -100) * 8 + 0x32) >> 0x25) & 0xf8) * 2 +\n                   (uint)(uVar1 * ((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 << 1)) >> 0x25) *\n                   0x10;\n    return;\n  }\n  pUVar12 = huart->Instance;\n  if ((pUVar12 != DAT_08002d04) && (pUVar12 != (USART_TypeDef *)&DAT_08002d04[0x24].CR2)) {\n    uVar3 = HAL_RCC_GetPCLK1Freq();\n    uVar2 = DAT_08002d08;\n    uVar8 = (huart->Init).BaudRate;\n    uVar1 = (ulonglong)DAT_08002d08;\n    uVar4 = HAL_RCC_GetPCLK1Freq();\n    uVar9 = (huart->Init).BaudRate;\n    uVar5 = HAL_RCC_GetPCLK1Freq();\n    uVar10 = (huart->Init).BaudRate;\n    uVar6 = HAL_RCC_GetPCLK1Freq();\n    uVar11 = (huart->Init).BaudRate;\n    uVar7 = HAL_RCC_GetPCLK1Freq();\n    pUVar12->BRR = ((uint)((int)((ulonglong)uVar2 *\n                                 (ulonglong)\n                                 (((uVar6 * 0x19) / (uVar11 << 2) +\n                                  (uint)((ulonglong)uVar2 *\n                                         ((ulonglong)(uVar7 * 0x19) /\n                                         (ulonglong)((huart->Init).BaudRate << 2)) >> 0x25) * -100)\n                                  * 0x10 + 0x32) >> 0x20) << 0x17) >> 0x1c) +\n                   ((uint)((ulonglong)uVar2 *\n                           (ulonglong)\n                           (((uVar4 * 0x19) / (uVar9 << 2) +\n                            (uint)((ulonglong)uVar2 *\n                                   ((ulonglong)(uVar5 * 0x19) / (ulonglong)(uVar10 << 2)) >> 0x25) *\n                            -100) * 0x10 + 0x32) >> 0x25) & 0xf0) +\n                   (uint)(uVar1 * ((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 << 2)) >> 0x25) *\n                   0x10;\n    return;\n  }\n  uVar3 = HAL_RCC_GetPCLK2Freq();\n  uVar2 = DAT_08002d08;\n  uVar8 = (huart->Init).BaudRate;\n  uVar1 = (ulonglong)DAT_08002d08;\n  uVar4 = HAL_RCC_GetPCLK2Freq();\n  uVar9 = (huart->Init).BaudRate;\n  uVar5 = HAL_RCC_GetPCLK2Freq();\n  uVar10 = (huart->Init).BaudRate;\n  uVar6 = HAL_RCC_GetPCLK2Freq();\n  uVar11 = (huart->Init).BaudRate;\n  uVar7 = HAL_RCC_GetPCLK2Freq();\n  pUVar12->BRR = ((uint)((int)((ulonglong)uVar2 *\n                               (ulonglong)\n                               (((uVar6 * 0x19) / (uVar11 << 2) +\n                                (uint)((ulonglong)uVar2 *\n                                       ((ulonglong)(uVar7 * 0x19) /\n                                       (ulonglong)((huart->Init).BaudRate << 2)) >> 0x25) * -100) *\n                                0x10 + 0x32) >> 0x20) << 0x17) >> 0x1c) +\n                 ((uint)((ulonglong)uVar2 *\n                         (ulonglong)\n                         (((uVar4 * 0x19) / (uVar9 << 2) +\n                          (uint)((ulonglong)uVar2 *\n                                 ((ulonglong)(uVar5 * 0x19) / (ulonglong)(uVar10 << 2)) >> 0x25) *\n                          -100) * 0x10 + 0x32) >> 0x25) & 0xf0) +\n                 (uint)(uVar1 * ((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 << 2)) >> 0x25) *\n                 0x10;\n  return;\n}\n\n", 
            "called": [
                "HAL_RCC_GetPCLK2Freq", 
                "HAL_RCC_GetPCLK1Freq"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080029c8", 
            "calling": [
                "HAL_UART_Init"
            ], 
            "imported": false, 
            "current_name": "UART_SetConfig"
        }, 
        "is_pin_configured": {
            "renaming": {}, 
            "code": "\n_Bool is_pin_configured(PinName_conflict pin,uint32_t *map)\n\n{\n  return (_Bool)((byte)(map[(uint)((int)pin << 0x18) >> 0x1c] >> ((int)pin & 0xfU)) & 1);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003138", 
            "calling": [
                "digitalWrite", 
                "pinMode"
            ], 
            "imported": false, 
            "current_name": "is_pin_configured"
        }, 
        "reset_pin_configured": {
            "renaming": {}, 
            "code": "\nvoid reset_pin_configured(PinName_conflict pin,uint32_t *map)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)((int)pin << 0x18) >> 0x1c;\n  map[uVar1] = map[uVar1] & ~(1 << ((int)pin & 0xfU));\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800316c", 
            "calling": [
                "pinMode"
            ], 
            "imported": false, 
            "current_name": "reset_pin_configured"
        }, 
        "_kill_r": {
            "renaming": {}, 
            "code": "\nvoid _kill_r(int *param_1,int param_2,int param_3)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_08005600;\n  *(undefined4 *)PTR_errno_08005600 = 0;\n  iVar2 = _kill(param_2,param_3);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_kill"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080055e0", 
            "calling": [
                "_raise_r"
            ], 
            "imported": false, 
            "current_name": "_kill_r"
        }, 
        "HAL_RCC_ClockConfig": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef\nHAL_RCC_ClockConfig(RCC_ClkInitTypeDef_conflict *RCC_ClkInitStruct,uint32_t FLatency)\n\n{\n  uint *puVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  uint uVar4;\n  \n  puVar1 = DAT_080025d0;\n  if (RCC_ClkInitStruct == (RCC_ClkInitTypeDef_conflict *)0x0) {\n    return HAL_ERROR;\n  }\n  if (((*DAT_080025d0 & 0xf) < FLatency) &&\n     (*(char *)DAT_080025d0 = (char)FLatency, FLatency != (*puVar1 & 0xf))) {\n    return HAL_ERROR;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 2) != 0) {\n    if ((RCC_ClkInitStruct->ClockType & 4) != 0) {\n      DAT_080025d4[2] = DAT_080025d4[2] | 0x1c00;\n    }\n    if ((RCC_ClkInitStruct->ClockType & 8) != 0) {\n      DAT_080025d4[2] = DAT_080025d4[2] | 0xe000;\n    }\n    DAT_080025d4[2] = DAT_080025d4[2] & 0xffffff0f | RCC_ClkInitStruct->AHBCLKDivider;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 1) != 0) {\n    uVar4 = RCC_ClkInitStruct->SYSCLKSource;\n    if (uVar4 == 1) {\n      if ((*DAT_080025d4 & 0x20000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if (uVar4 - 2 < 2) {\n      if ((*DAT_080025d4 & 0x2000000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((*DAT_080025d4 & 2) == 0) {\n      return HAL_ERROR;\n    }\n    DAT_080025d4[2] = uVar4 | DAT_080025d4[2] & 0xfffffffc;\n    uVar2 = HAL_GetTick();\n    while ((DAT_080025d4[2] & 0xc) != RCC_ClkInitStruct->SYSCLKSource * 4) {\n      uVar3 = HAL_GetTick();\n      if (5000 < uVar3 - uVar2) {\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  puVar1 = DAT_080025d0;\n  if ((FLatency < (*DAT_080025d0 & 0xf)) &&\n     (*(char *)DAT_080025d0 = (char)FLatency, FLatency != (*puVar1 & 0xf))) {\n    return HAL_ERROR;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 4) != 0) {\n    DAT_080025d4[2] = DAT_080025d4[2] & 0xffffe3ff | RCC_ClkInitStruct->APB1CLKDivider;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 8) != 0) {\n    DAT_080025d4[2] = DAT_080025d4[2] & 0xffff1fff | RCC_ClkInitStruct->APB2CLKDivider << 3;\n  }\n  uVar2 = HAL_RCC_GetSysClockFreq();\n  *(uint32_t *)PTR_SystemCoreClock_080025dc =\n       uVar2 >> PTR_AHBPrescTable_080025d8[(DAT_080025d4[2] << 0x18) >> 0x1c];\n  HAL_InitTick(0xf);\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_InitTick", 
                "HAL_RCC_GetSysClockFreq", 
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002488", 
            "calling": [
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_ClockConfig"
        }, 
        "print": {
            "renaming": {}, 
            "code": "\nsize_t __thiscall Print::print(Print *this,uchar b,int base)\n\n{\n  size_t sVar1;\n  \n  sVar1 = print(this,(uint)b,base);\n  return sVar1;\n}\n\n", 
            "called": [
                "print"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004638", 
            "calling": [
                "printTo"
            ], 
            "imported": false, 
            "current_name": "print"
        }, 
        "__swhatbuf_r": {
            "renaming": {}, 
            "code": "\nundefined4 __swhatbuf_r(undefined4 param_1,int param_2,undefined4 *param_3,uint *param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_4c [4];\n  uint local_48;\n  \n  if ((*(short *)(param_2 + 0xe) < 0) ||\n     (iVar1 = _fstat_r(param_1,(int)*(short *)(param_2 + 0xe),auStack_4c), iVar1 < 0)) {\n    *param_4 = 0;\n    if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x18) < 0) {\n      uVar2 = 0x40;\n      goto LAB_080054f4;\n    }\n  }\n  else {\n    *param_4 = (uint)((local_48 & 0xf000) == 0x2000);\n  }\n  uVar2 = 0x400;\nLAB_080054f4:\n  *param_3 = uVar2;\n  return 0;\n}\n\n", 
            "called": [
                "_fstat_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080054b4", 
            "calling": [
                "__smakebuf_r"
            ], 
            "imported": false, 
            "current_name": "__swhatbuf_r"
        }, 
        "pinmap_find_peripheral": {
            "renaming": {}, 
            "code": "\nvoid * pinmap_find_peripheral(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  while( true ) {\n    if (map->pin == NC) {\n      return (void *)0x0;\n    }\n    if (map->pin == pin) break;\n    map = map + 1;\n  }\n  return map->peripheral;\n}\n\n", 
            "called": [
                "pinmap_find_peripheral"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080034da", 
            "calling": [
                "pinmap_find_peripheral", 
                "pinmap_peripheral"
            ], 
            "imported": false, 
            "current_name": "pinmap_find_peripheral"
        }, 
        "HAL_I2C_ErrorCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  i2c_t *piVar1;\n  \n  piVar1 = get_i2c_obj(hi2c);\n  if (piVar1->isMaster == '\\0') {\n    HAL_I2C_EnableListen_IT(hi2c);\n  }\n  return;\n}\n\n", 
            "called": [
                "get_i2c_obj", 
                "HAL_I2C_EnableListen_IT"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003900", 
            "calling": [
                "I2C_ITError", 
                "I2C_DMAAbort"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_ErrorCallback"
        }, 
        "I2C_SlaveReceive_BTF": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c)\n\n{\n  uint8_t *puVar1;\n  \n  if (hi2c->XferCount != 0) {\n    puVar1 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = puVar1 + 1;\n    *puVar1 = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001440", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_SlaveReceive_BTF"
        }, 
        "HAL_I2C_MasterTxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080015b6", 
            "calling": [
                "I2C_MasterTransmit_TXE", 
                "I2C_MasterTransmit_BTF"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_MasterTxCpltCallback"
        }, 
        "_fstat_r": {
            "renaming": {}, 
            "code": "\nvoid _fstat_r(int *param_1,int param_2,stat *param_3)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_080056f4;\n  *(undefined4 *)PTR_errno_080056f4 = 0;\n  iVar2 = _fstat(param_2,param_3);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_fstat"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080056d4", 
            "calling": [
                "__swhatbuf_r"
            ], 
            "imported": false, 
            "current_name": "_fstat_r"
        }, 
        "__malloc_unlock": {
            "renaming": {}, 
            "code": "\nvoid __malloc_unlock(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800557e", 
            "calling": [
                "_malloc_r", 
                "_free_r"
            ], 
            "imported": false, 
            "current_name": "__malloc_unlock"
        }, 
        "setup": {
            "renaming": {}, 
            "code": "\nvoid setup(void)\n\n{\n  startForkserver(0);\n  Modbus::begin((Modbus *)PTR_slave_08000c60,0x4b00);\n  return;\n}\n\n", 
            "called": [
                "begin", 
                "startForkserver"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000c4c", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "setup"
        }, 
        "RTC_Alarm_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid RTC_Alarm_IRQHandler(void)\n\n{\n  HAL_RTC_AlarmIRQHandler((RTC_HandleTypeDef *)PTR_RtcHandle_080035b8);\n  return;\n}\n\n", 
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080035ac", 
            "calling": [], 
            "imported": false, 
            "current_name": "RTC_Alarm_IRQHandler"
        }, 
        "USART1_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid USART1_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART1_IRQn);\n  HAL_UART_IRQHandler(*(UART_HandleTypeDef **)PTR_uart_handlers_08003fe8);\n  return;\n}\n\n", 
            "called": [
                "HAL_UART_IRQHandler", 
                "HAL_NVIC_ClearPendingIRQ"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003fd4", 
            "calling": [], 
            "imported": false, 
            "current_name": "USART1_IRQHandler"
        }, 
        "UART_Transmit_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)\n\n{\n  uint16_t uVar1;\n  byte *pbVar2;\n  \n  if (huart->gState != HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  if ((huart->Init).WordLength == 0x1000) {\n    huart->Instance->DR = *(ushort *)huart->pTxBuffPtr & 0x1ff;\n    if ((huart->Init).Parity == 0) {\n      huart->pTxBuffPtr = huart->pTxBuffPtr + 2;\n    }\n    else {\n      huart->pTxBuffPtr = huart->pTxBuffPtr + 1;\n    }\n  }\n  else {\n    pbVar2 = huart->pTxBuffPtr;\n    huart->pTxBuffPtr = pbVar2 + 1;\n    huart->Instance->DR = (uint)*pbVar2;\n  }\n  uVar1 = huart->TxXferCount - 1;\n  huart->TxXferCount = uVar1;\n  if (uVar1 == 0) {\n    huart->Instance->CR1 = huart->Instance->CR1 & 0xffffff7f;\n    huart->Instance->CR1 = huart->Instance->CR1 | 0x40;\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800295c", 
            "calling": [
                "HAL_UART_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "UART_Transmit_IT"
        }, 
        "I2C3_EV_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid I2C3_EV_IRQHandler(void)\n\n{\n  HAL_I2C_EV_IRQHandler(*(I2C_HandleTypeDef **)(PTR_i2c_handles_08003964 + 8));\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003958", 
            "calling": [], 
            "imported": false, 
            "current_name": "I2C3_EV_IRQHandler"
        }, 
        "HAL_GPIO_EXTI_Callback": {
            "renaming": {}, 
            "code": "\nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)\n\n{\n  byte bVar1;\n  \n  bVar1 = get_pin_id(GPIO_Pin);\n  if (*(int *)(PTR_gpio_irq_conf_080047ec + (uint)bVar1 * 0x14 + 0xc) != 0) {\n    std::function<void()>::operator__\n              ((function_void___ *)(PTR_gpio_irq_conf_080047ec + (uint)bVar1 * 0x14 + 4));\n  }\n  return;\n}\n\n", 
            "called": [
                "get_pin_id", 
                "operator()"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080047d0", 
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_GPIO_EXTI_Callback"
        }, 
        "_GLOBAL__sub_I__ZN9IPAddressC2Ev": {
            "renaming": {}, 
            "code": "\nvoid _GLOBAL__sub_I__ZN9IPAddressC2Ev(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n", 
            "called": [
                "__static_initialization_and_destruction_0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800458c", 
            "calling": [], 
            "imported": false, 
            "current_name": "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
        }, 
        "HAL_TIM_PWM_PulseFinishedCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080026ca", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_PWM_PulseFinishedCallback"
        }, 
        "_read": {
            "renaming": {}, 
            "code": "\nint _read(int file_UNUSED,char *ptr_UNUSED,int len_UNUSED)\n\n{\n  return 0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080040e8", 
            "calling": [
                "_read_r"
            ], 
            "imported": false, 
            "current_name": "_read"
        }, 
        "iprintf": {
            "renaming": {}, 
            "code": "\nint iprintf(char *__format,...)\n\n{\n  undefined4 in_r1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  int iVar1;\n  char *pcVar2;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  iVar1 = *(int *)PTR__impure_ptr_08005008;\n  pcVar2 = __format;\n  uStack_c = in_r1;\n  uStack_8 = in_r2;\n  uStack_4 = in_r3;\n  if ((iVar1 != 0) && (*(int *)(iVar1 + 0x18) == 0)) {\n    __sinit(iVar1);\n  }\n  iVar1 = _vfiprintf_r(iVar1,*(undefined4 *)(iVar1 + 8),__format,&uStack_c,pcVar2,&uStack_c);\n  return iVar1;\n}\n\n", 
            "called": [
                "_vfiprintf_r", 
                "__sinit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004fdc", 
            "calling": [
                "uart_init"
            ], 
            "imported": false, 
            "current_name": "iprintf"
        }, 
        "I2C_Slave_STOPF": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  I2C_TypeDef *pIVar2;\n  uint8_t *puVar3;\n  uint32_t tmpreg;\n  \n  HVar1 = hi2c->State;\n  hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 | 1;\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n  pIVar2 = hi2c->Instance;\n  if ((pIVar2->CR2 & 0x800) != 0) {\n    if ((hi2c->State == HAL_I2C_STATE_BUSY_RX) || (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      hi2c->XferCount = (uint16_t)hi2c->hdmarx->Instance->NDTR;\n    }\n    else {\n      hi2c->XferCount = (uint16_t)hi2c->hdmatx->Instance->NDTR;\n    }\n  }\n  if (hi2c->XferCount != 0) {\n    if ((pIVar2->SR1 & 4) != 0) {\n      puVar3 = hi2c->pBuffPtr;\n      hi2c->pBuffPtr = puVar3 + 1;\n      *puVar3 = (uint8_t)pIVar2->DR;\n      hi2c->XferCount = hi2c->XferCount - 1;\n    }\n    if ((hi2c->Instance->SR1 & 0x40) != 0) {\n      puVar3 = hi2c->pBuffPtr;\n      hi2c->pBuffPtr = puVar3 + 1;\n      *puVar3 = (uint8_t)hi2c->Instance->DR;\n      hi2c->XferCount = hi2c->XferCount - 1;\n    }\n    hi2c->ErrorCode = hi2c->ErrorCode | 4;\n  }\n  if (hi2c->ErrorCode == 0) {\n    if (((HVar1 == HAL_I2C_STATE_LISTEN) || (HVar1 == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (HVar1 == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      hi2c->XferOptions = DAT_08001cfc;\n      hi2c->PreviousState = 0;\n      hi2c->State = HAL_I2C_STATE_READY;\n      hi2c->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(hi2c);\n    }\n    else if ((hi2c->PreviousState == 0x22) || (HVar1 == HAL_I2C_STATE_BUSY_RX)) {\n      hi2c->PreviousState = 0;\n      hi2c->State = HAL_I2C_STATE_READY;\n      hi2c->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(hi2c);\n    }\n  }\n  else {\n    I2C_ITError(hi2c);\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_ListenCpltCallback", 
                "I2C_ITError", 
                "HAL_I2C_SlaveRxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001bfc", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_Slave_STOPF"
        }, 
        "HAL_TIM_PWM_MspDeInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)\n\n{\n  timer_disable_clock(htim);\n  return;\n}\n\n", 
            "called": [
                "timer_disable_clock"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800340c", 
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_PWM_MspDeInit"
        }, 
        "digital_io_init": {
            "renaming": {}, 
            "code": "\nvoid digital_io_init(PinName_conflict pin,uint32_t mode,uint32_t pull)\n\n{\n  GPIO_TypeDef *GPIOx;\n  GPIO_InitTypeDef GPIO_InitStructure;\n  \n  GPIOx = set_GPIO_Port_Clock((uint)((int)pin << 0x18) >> 0x1c);\n  GPIO_InitStructure.Pin = 1 << ((int)pin & 0xfU) & 0xffff;\n  GPIO_InitStructure.Speed = 2;\n  GPIO_InitStructure.Mode = mode;\n  GPIO_InitStructure.Pull = pull;\n  HAL_GPIO_Init(GPIOx,&GPIO_InitStructure);\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_Init", 
                "set_GPIO_Port_Clock"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003486", 
            "calling": [
                "pinMode"
            ], 
            "imported": false, 
            "current_name": "digital_io_init"
        }, 
        "uart_index": {
            "renaming": {}, 
            "code": "\nuint8_t uart_index(UART_HandleTypeDef *huart)\n\n{\n  uint uVar1;\n  \n  if (huart == (UART_HandleTypeDef *)0x0) {\n    uVar1 = 10;\n  }\n  else {\n    uVar1 = 0;\n    while( true ) {\n      if (9 < uVar1) {\n        return (uint8_t)uVar1;\n      }\n      if (huart == *(UART_HandleTypeDef **)(PTR_uart_handlers_08003f20 + uVar1 * 4)) break;\n      uVar1 = uVar1 + 1 & 0xff;\n    }\n  }\n  return (uint8_t)uVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003f00", 
            "calling": [
                "HAL_UART_RxCpltCallback", 
                "HAL_UART_TxCpltCallback"
            ], 
            "imported": false, 
            "current_name": "uart_index"
        }, 
        "_printf_common": {
            "renaming": {}, 
            "code": "\nundefined4\n_printf_common(undefined4 param_1,uint *param_2,uint *param_3,undefined4 param_4,code *param_5)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  bool bVar4;\n  \n  uVar2 = param_2[4];\n  if ((int)param_2[4] < (int)param_2[2]) {\n    uVar2 = param_2[2];\n  }\n  *param_3 = uVar2;\n  if (*(char *)((int)param_2 + 0x43) != '\\0') {\n    *param_3 = uVar2 + 1;\n  }\n  if ((int)(*param_2 << 0x1a) < 0) {\n    *param_3 = *param_3 + 2;\n  }\n  uVar2 = *param_2 & 6;\n  if (uVar2 == 0) {\n    for (; (int)uVar2 < (int)(param_2[3] - *param_3); uVar2 = uVar2 + 1) {\n      iVar1 = (*param_5)(param_1,param_4,(int)param_2 + 0x19,1);\n      if (iVar1 == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  uVar2 = (uint)*(byte *)((int)param_2 + 0x43);\n  if (uVar2 != 0) {\n    uVar2 = 1;\n  }\n  if ((int)(*param_2 << 0x1a) < 0) {\n    *(undefined *)((int)param_2 + uVar2 + 0x43) = 0x30;\n    *(undefined *)((int)param_2 + uVar2 + 0x44) = *(undefined *)((int)param_2 + 0x45);\n    uVar2 = uVar2 + 2;\n  }\n  iVar1 = (*param_5)(param_1,param_4,(int)param_2 + 0x43,uVar2);\n  if (iVar1 != -1) {\n    uVar2 = param_2[3];\n    bVar4 = (*param_2 & 6) == 4;\n    if (bVar4) {\n      uVar2 = uVar2 - *param_3;\n    }\n    if (bVar4) {\n      uVar2 = uVar2 & ~((int)uVar2 >> 0x1f);\n    }\n    else {\n      uVar2 = 0;\n    }\n    if ((int)param_2[4] < (int)param_2[2]) {\n      uVar2 = uVar2 + (param_2[2] - param_2[4]);\n    }\n    uVar3 = 0;\n    while( true ) {\n      if (uVar2 == uVar3) {\n        return 0;\n      }\n      iVar1 = (*param_5)(param_1,param_4,(int)param_2 + 0x1a,1);\n      if (iVar1 == -1) break;\n      uVar3 = uVar3 + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004cb0", 
            "calling": [
                "_printf_i"
            ], 
            "imported": false, 
            "current_name": "_printf_common"
        }, 
        "EXTI3_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI3_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(8);\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800477e", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI3_IRQHandler"
        }, 
        "HardwareSerial": {
            "renaming": {}, 
            "code": "\nHardwareSerial * __thiscall HardwareSerial::HardwareSerial(HardwareSerial *this,void *peripheral)\n\n{\n  PinName_conflict PVar1;\n  EVP_PKEY_CTX *extraout_r1;\n  EVP_PKEY_CTX *ctx;\n  EVP_PKEY_CTX *extraout_r1_00;\n  \n  (this->super_Stream).super_Print.write_error = 0;\n  (this->super_Stream)._timeout = 1000;\n  (this->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)PTR_PTR_write_1_080044c8;\n  if (this == (HardwareSerial *)PTR_Serial3_080044cc) {\n    setRx(this,0x4c);\n    setTx(this,0x4d);\n    ctx = extraout_r1_00;\n  }\n  else {\n    PVar1 = pinmap_pin(peripheral,(PinMap_conflict *)PTR_PinMap_UART_RX_080044d0);\n    (this->_serial).pin_rx = PVar1;\n    PVar1 = pinmap_pin(peripheral,(PinMap_conflict *)PTR_PinMap_UART_TX_080044d4);\n    (this->_serial).pin_tx = PVar1;\n    ctx = extraout_r1;\n  }\n  init(this,ctx);\n  return this;\n}\n\n", 
            "called": [
                "init", 
                "setTx", 
                "pinmap_pin", 
                "setRx"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800447c", 
            "calling": [
                "__static_initialization_and_destruction_0"
            ], 
            "imported": false, 
            "current_name": "HardwareSerial"
        }, 
        "I2C_Master_ADDR": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef I2C_Master_ADDR(I2C_HandleTypeDef *hi2c)\n\n{\n  uint32_t uVar1;\n  I2C_TypeDef *pIVar2;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  \n  uVar1 = hi2c->XferOptions;\n  if ((hi2c->State == HAL_I2C_STATE_BUSY_RX) &&\n     ((hi2c->EventCount != 0 || (hi2c->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((hi2c->EventCount == 0) && ((hi2c->Init).AddressingMode == 0xc000)) {\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x100;\n      hi2c->EventCount = hi2c->EventCount + 1;\n    }\n    else {\n      if (hi2c->XferCount == 0) {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n      }\n      else if (hi2c->XferCount == 1) {\n        if (uVar1 == 0xffff0000) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n          pIVar2 = hi2c->Instance;\n          if ((pIVar2->CR2 & 0x800) == 0) {\n            pIVar2->CR1 = pIVar2->CR1 | 0x200;\n          }\n          else {\n            pIVar2->CR1 = pIVar2->CR1 & 0xfffffbff;\n          }\n        }\n        else if (((uVar1 == 4) || (uVar1 == 8)) || (hi2c->PreviousState == 0x12)) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n        }\n        else if (hi2c->XferOptions == 2) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n        }\n        else {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n        }\n      }\n      else if (hi2c->XferCount == 2) {\n        if (hi2c->XferOptions == 2) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n        }\n        else {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x800;\n        }\n        pIVar2 = hi2c->Instance;\n        if ((pIVar2->CR2 & 0x800) != 0) {\n          pIVar2->CR2 = pIVar2->CR2 | 0x1000;\n        }\n      }\n      else {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n        pIVar2 = hi2c->Instance;\n        if ((pIVar2->CR2 & 0x800) != 0) {\n          pIVar2->CR2 = pIVar2->CR2 | 0x1000;\n        }\n      }\n      hi2c->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001256", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_Master_ADDR"
        }, 
        "write": {
            "renaming": {}, 
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080045ae */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nsize_t __thiscall Print::write(Print *this,uint8_t *buffer,size_t size)\n\n{\n  Print *pPVar1;\n  size_t sVar2;\n  \n  sVar2 = 0;\n  pPVar1 = this;\n  while( true ) {\n    if (size == 0) {\n      return sVar2;\n    }\n    pPVar1 = (Print *)(**this->_vptr_Print)(pPVar1,(uint)*buffer);\n    if (pPVar1 == (Print *)0x0) break;\n    sVar2 = sVar2 + 1;\n    buffer = buffer + 1;\n    size = size - 1;\n  }\n  return sVar2;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800459a", 
            "calling": [], 
            "imported": false, 
            "current_name": "write"
        }, 
        "I2C2_ER_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid I2C2_ER_IRQHandler(void)\n\n{\n  HAL_I2C_ER_IRQHandler(*(I2C_HandleTypeDef **)(PTR_i2c_handles_08003954 + 4));\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003948", 
            "calling": [], 
            "imported": false, 
            "current_name": "I2C2_ER_IRQHandler"
        }, 
        "HAL_SYSTICK_Config": {
            "renaming": {}, 
            "code": "\nuint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)\n\n{\n  undefined4 *puVar1;\n  \n  puVar1 = DAT_08000f04;\n  if (TicksNumb - 1 < 0x1000000) {\n    DAT_08000f04[1] = TicksNumb - 1;\n    *(undefined *)(DAT_08000f08 + 0x23) = 0xf0;\n    puVar1[2] = 0;\n    *puVar1 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000ee0", 
            "calling": [
                "HAL_InitTick", 
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_SYSTICK_Config"
        }, 
        "init": {
            "renaming": {}, 
            "code": "\nint __thiscall HardwareSerial::init(HardwareSerial *this,EVP_PKEY_CTX *ctx)\n\n{\n  (this->_serial).rx_buff = this->_rx_buffer;\n  (this->_serial).rx_head = 0;\n  (this->_serial).rx_tail = 0;\n  (this->_serial).tx_buff = this->_tx_buffer;\n  (this->_serial).tx_head = 0;\n  (this->_serial).tx_tail = 0;\n  return (int)this;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004364", 
            "calling": [
                "HardwareSerial"
            ], 
            "imported": false, 
            "current_name": "init"
        }, 
        "HAL_UART_RxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)\n\n{\n  byte bVar1;\n  uint uVar2;\n  \n  bVar1 = uart_index(huart);\n  uVar2 = (uint)bVar1;\n  if (uVar2 < 10) {\n    (**(code **)(PTR_rx_callback_08003f40 + uVar2 * 4))\n              (*(undefined4 *)(PTR_rx_callback_obj_08003f44 + uVar2 * 4));\n  }\n  return;\n}\n\n", 
            "called": [
                "uart_index"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003f24", 
            "calling": [
                "UART_Receive_IT"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_RxCpltCallback"
        }, 
        "__smakebuf_r": {
            "renaming": {}, 
            "code": "\nvoid __smakebuf_r(int param_1,int *param_2)\n\n{\n  ushort uVar1;\n  int iVar2;\n  int local_18;\n  int *local_14;\n  \n  if (-1 < (int)((uint)*(ushort *)(param_2 + 3) << 0x1e)) {\n    local_18 = param_1;\n    local_14 = param_2;\n    uVar1 = __swhatbuf_r(param_1,param_2,&local_18,&local_14);\n    iVar2 = _malloc_r(param_1,local_18);\n    if (iVar2 != 0) {\n      *(undefined4 *)(param_1 + 0x28) = DAT_08005578;\n      *param_2 = iVar2;\n      *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 0x80;\n      param_2[5] = local_18;\n      param_2[4] = iVar2;\n      if ((local_14 != (int *)0x0) &&\n         (iVar2 = _isatty_r(param_1,(int)*(short *)((int)param_2 + 0xe)), iVar2 != 0)) {\n        *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(param_2 + 3) = uVar1 | *(ushort *)(param_2 + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(param_2 + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xfffc | 2;\n  }\n  *param_2 = (int)param_2 + 0x47;\n  param_2[4] = (int)param_2 + 0x47;\n  param_2[5] = 1;\n  return;\n}\n\n", 
            "called": [
                "__swhatbuf_r", 
                "_malloc_r", 
                "_isatty_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080054fc", 
            "calling": [
                "__swsetup_r"
            ], 
            "imported": false, 
            "current_name": "__smakebuf_r"
        }, 
        "HAL_TIM_IC_CaptureCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080026c8", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_IC_CaptureCallback"
        }, 
        "TIM8_TRG_COM_TIM14_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM8_TRG_COM_TIM14_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef **)(PTR_timer_handles_08003878 + 0x34) != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef **)(PTR_timer_handles_08003878 + 0x34));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003868", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM8_TRG_COM_TIM14_IRQHandler"
        }, 
        "SysTick_Handler": {
            "renaming": {}, 
            "code": "\nvoid SysTick_Handler(void)\n\n{\n  HAL_IncTick();\n  HAL_SYSTICK_IRQHandler();\n  noOsSystickHandler();\n  return;\n}\n\n", 
            "called": [
                "HAL_SYSTICK_IRQHandler", 
                "HAL_IncTick", 
                "noOsSystickHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003476", 
            "calling": [], 
            "imported": false, 
            "current_name": "SysTick_Handler"
        }, 
        "uart_attach_tx_callback": {
            "renaming": {}, 
            "code": "\nvoid uart_attach_tx_callback(serial_t *obj,_func_int_serial_t_ptr *callback)\n\n{\n  byte bVar1;\n  \n  if (obj != (serial_t *)0x0) {\n    bVar1 = obj->index;\n    *(_func_int_serial_t_ptr **)(PTR_tx_callback_08003ef4 + (uint)bVar1 * 4) = callback;\n    *(serial_t **)(PTR_tx_callback_obj_08003ef8 + (uint)bVar1 * 4) = obj;\n    HAL_NVIC_SetPriority(obj->irq,0,2);\n    HAL_NVIC_EnableIRQ(obj->irq);\n    HAL_UART_Transmit_IT\n              (*(UART_HandleTypeDef **)(PTR_uart_handlers_08003efc + (uint)obj->index * 4),\n               obj->tx_buff + obj->tx_tail,1);\n    return;\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_NVIC_SetPriority", 
                "HAL_NVIC_EnableIRQ", 
                "HAL_UART_Transmit_IT"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003eac", 
            "calling": [
                "write"
            ], 
            "imported": false, 
            "current_name": "uart_attach_tx_callback"
        }, 
        "__throw_bad_function_call": {
            "renaming": {}, 
            "code": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n/* std::__throw_bad_function_call() */\n\nvoid std::__throw_bad_function_call(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
            "called": [
                "abort"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005760", 
            "calling": [
                "operator()"
            ], 
            "imported": false, 
            "current_name": "__throw_bad_function_call"
        }, 
        "_lseek_r": {
            "renaming": {}, 
            "code": "\nvoid _lseek_r(int *param_1,int param_2,int param_3,int param_4)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  \n  puVar1 = PTR_errno_08005738;\n  *(undefined4 *)PTR_errno_08005738 = 0;\n  iVar2 = _lseek(param_2,param_3,param_4);\n  if ((iVar2 == -1) && (*(int *)puVar1 != 0)) {\n    *param_1 = *(int *)puVar1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_lseek"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005718", 
            "calling": [
                "__sseek", 
                "__swrite"
            ], 
            "imported": false, 
            "current_name": "_lseek_r"
        }, 
        "__udivmoddi4": {
            "renaming": {}, 
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080005aa) */\n\nulonglong __udivmoddi4(uint param_1,uint param_2,uint param_3,uint param_4,uint *param_5)\n\n{\n  ulonglong uVar1;\n  uint *puVar2;\n  uint uVar3;\n  uint *puVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  \n  if (param_4 == 0) {\n    if (param_2 < param_3) {\n      uVar12 = count_leading_zeroes(param_3);\n      if (uVar12 != 0) {\n        param_3 = param_3 << (uVar12 & 0xff);\n        param_2 = param_1 >> (0x20 - uVar12 & 0xff) | param_2 << (uVar12 & 0xff);\n        param_1 = param_1 << (uVar12 & 0xff);\n      }\n      uVar10 = param_3 >> 0x10;\n      uVar8 = param_2 / uVar10;\n      uVar7 = param_1 >> 0x10 | (param_2 - uVar10 * uVar8) * 0x10000;\n      uVar6 = uVar8 * (param_3 & 0xffff);\n      uVar5 = uVar8;\n      if (uVar7 <= uVar6 && uVar6 - uVar7 != 0) {\n        bVar13 = CARRY4(uVar7,param_3);\n        uVar7 = uVar7 + param_3;\n        uVar5 = uVar8 - 1;\n        if ((bVar13 == false) && (uVar7 <= uVar6 && uVar6 - uVar7 != 0)) {\n          uVar5 = uVar8 - 2;\n          uVar7 = uVar7 + param_3;\n        }\n      }\n      uVar8 = (uVar7 - uVar6) / uVar10;\n      uVar7 = param_1 & 0xffff | ((uVar7 - uVar6) - uVar10 * uVar8) * 0x10000;\n      uVar10 = uVar8 * (param_3 & 0xffff);\n      uVar6 = uVar8;\n      if (uVar7 <= uVar10 && uVar10 - uVar7 != 0) {\n        bVar13 = CARRY4(uVar7,param_3);\n        uVar7 = uVar7 + param_3;\n        uVar6 = uVar8 - 1;\n        if ((bVar13 == false) && (uVar7 <= uVar10 && uVar10 - uVar7 != 0)) {\n          uVar6 = uVar8 - 2;\n          uVar7 = uVar7 + param_3;\n        }\n      }\n      uVar7 = uVar7 - uVar10;\n      puVar2 = (uint *)(uVar6 | uVar5 << 0x10);\n      puVar4 = (uint *)0x0;\n    }\n    else {\n      if (param_3 == 0) {\n        param_3 = 1 / 0;\n      }\n      uVar12 = count_leading_zeroes(param_3);\n      if (uVar12 == 0) {\n        param_2 = param_2 - param_3;\n        uVar7 = param_3 >> 0x10;\n        uVar11 = param_3 & 0xffff;\n        puVar4 = (uint *)0x1;\n      }\n      else {\n        param_3 = param_3 << (uVar12 & 0xff);\n        uVar7 = param_3 >> 0x10;\n        uVar5 = param_2 >> (0x20 - uVar12 & 0xff);\n        uVar9 = param_1 >> (0x20 - uVar12 & 0xff) | param_2 << (uVar12 & 0xff);\n        uVar6 = uVar5 / uVar7;\n        uVar11 = param_3 & 0xffff;\n        uVar10 = uVar9 >> 0x10 | (uVar5 - uVar7 * uVar6) * 0x10000;\n        uVar8 = uVar6 * uVar11;\n        param_1 = param_1 << (uVar12 & 0xff);\n        uVar5 = uVar6;\n        if (uVar10 <= uVar8 && uVar8 - uVar10 != 0) {\n          bVar13 = CARRY4(uVar10,param_3);\n          uVar10 = uVar10 + param_3;\n          uVar5 = uVar6 - 1;\n          if ((bVar13 == false) && (uVar10 <= uVar8 && uVar8 - uVar10 != 0)) {\n            uVar5 = uVar6 - 2;\n            uVar10 = uVar10 + param_3;\n          }\n        }\n        uVar3 = (uVar10 - uVar8) / uVar7;\n        param_2 = uVar9 & 0xffff | ((uVar10 - uVar8) - uVar7 * uVar3) * 0x10000;\n        uVar8 = uVar3 * uVar11;\n        uVar6 = uVar3;\n        if (param_2 <= uVar8 && uVar8 - param_2 != 0) {\n          bVar13 = CARRY4(param_2,param_3);\n          param_2 = param_2 + param_3;\n          uVar6 = uVar3 - 1;\n          if ((bVar13 == false) && (param_2 <= uVar8 && uVar8 - param_2 != 0)) {\n            uVar6 = uVar3 - 2;\n            param_2 = param_2 + param_3;\n          }\n        }\n        param_2 = param_2 - uVar8;\n        puVar4 = (uint *)(uVar6 | uVar5 << 0x10);\n      }\n      uVar10 = param_2 / uVar7;\n      uVar8 = param_1 >> 0x10 | (param_2 - uVar7 * uVar10) * 0x10000;\n      uVar6 = uVar11 * uVar10;\n      uVar5 = uVar10;\n      if (uVar8 <= uVar6 && uVar6 - uVar8 != 0) {\n        bVar13 = CARRY4(uVar8,param_3);\n        uVar8 = uVar8 + param_3;\n        uVar5 = uVar10 - 1;\n        if ((bVar13 == false) && (uVar8 <= uVar6 && uVar6 - uVar8 != 0)) {\n          uVar5 = uVar10 - 2;\n          uVar8 = uVar8 + param_3;\n        }\n      }\n      uVar10 = (uVar8 - uVar6) / uVar7;\n      uVar7 = param_1 & 0xffff | ((uVar8 - uVar6) - uVar7 * uVar10) * 0x10000;\n      uVar11 = uVar11 * uVar10;\n      uVar6 = uVar10;\n      if (uVar7 <= uVar11 && uVar11 - uVar7 != 0) {\n        bVar13 = CARRY4(uVar7,param_3);\n        uVar7 = uVar7 + param_3;\n        uVar6 = uVar10 - 1;\n        if ((bVar13 == false) && (uVar7 <= uVar11 && uVar11 - uVar7 != 0)) {\n          uVar6 = uVar10 - 2;\n          uVar7 = uVar7 + param_3;\n        }\n      }\n      uVar7 = uVar7 - uVar11;\n      puVar2 = (uint *)(uVar6 | uVar5 << 0x10);\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = uVar7 >> (uVar12 & 0xff);\n      param_5[1] = 0;\n      return CONCAT44(puVar4,puVar2);\n    }\n  }\n  else if (param_2 < param_4) {\n    puVar2 = param_5;\n    puVar4 = param_5;\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n      return 0;\n    }\n  }\n  else {\n    puVar4 = (uint *)count_leading_zeroes(param_4);\n    if (puVar4 != (uint *)0x0) {\n      uVar8 = 0x20 - (int)puVar4;\n      uVar5 = param_3 >> (uVar8 & 0xff) | param_4 << ((uint)puVar4 & 0xff);\n      uVar9 = uVar5 >> 0x10;\n      uVar12 = param_2 >> (uVar8 & 0xff);\n      uVar11 = param_1 >> (uVar8 & 0xff) | param_2 << ((uint)puVar4 & 0xff);\n      uVar10 = uVar12 / uVar9;\n      uVar7 = uVar11 >> 0x10 | (uVar12 - uVar9 * uVar10) * 0x10000;\n      uVar6 = uVar10 * (uVar5 & 0xffff);\n      param_3 = param_3 << ((uint)puVar4 & 0xff);\n      param_1 = param_1 << ((uint)puVar4 & 0xff);\n      uVar12 = uVar10;\n      if (uVar7 <= uVar6 && uVar6 - uVar7 != 0) {\n        bVar13 = CARRY4(uVar7,uVar5);\n        uVar7 = uVar7 + uVar5;\n        uVar12 = uVar10 - 1;\n        if ((bVar13 == false) && (uVar7 <= uVar6 && uVar6 - uVar7 != 0)) {\n          uVar12 = uVar10 - 2;\n          uVar7 = uVar7 + uVar5;\n        }\n      }\n      uVar10 = (uVar7 - uVar6) / uVar9;\n      uVar7 = uVar11 & 0xffff | ((uVar7 - uVar6) - uVar9 * uVar10) * 0x10000;\n      uVar9 = uVar10 * (uVar5 & 0xffff);\n      uVar6 = uVar10;\n      if (uVar7 <= uVar9 && uVar9 - uVar7 != 0) {\n        bVar13 = CARRY4(uVar7,uVar5);\n        uVar7 = uVar7 + uVar5;\n        uVar6 = uVar10 - 1;\n        if ((bVar13 == false) && (uVar7 <= uVar9 && uVar9 - uVar7 != 0)) {\n          uVar6 = uVar10 - 2;\n          uVar7 = uVar7 + uVar5;\n        }\n      }\n      uVar6 = uVar6 | uVar12 << 0x10;\n      uVar1 = (ulonglong)uVar6 * (ulonglong)param_3;\n      if (CONCAT44(uVar7 - uVar9,param_1) < uVar1) {\n        uVar1 = uVar1 - CONCAT44(uVar5,param_3);\n        uVar6 = uVar6 - 1;\n      }\n      if (param_5 != (uint *)0x0) {\n        uVar12 = ((uVar7 - uVar9) - (int)(uVar1 >> 0x20)) - (uint)(param_1 < (uint)uVar1);\n        *param_5 = uVar12 << (uVar8 & 0xff) | param_1 - (uint)uVar1 >> ((uint)puVar4 & 0xff);\n        param_5[1] = uVar12 >> ((uint)puVar4 & 0xff);\n      }\n      return (ulonglong)uVar6;\n    }\n    if ((param_4 < param_2) || (puVar2 = puVar4, param_3 <= param_1)) {\n      bVar13 = param_1 < param_3;\n      param_1 = param_1 - param_3;\n      param_2 = (param_2 - param_4) - (uint)bVar13;\n      puVar2 = (uint *)0x1;\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n      return ZEXT48(puVar2);\n    }\n  }\n  return CONCAT44(puVar4,puVar2);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000300", 
            "calling": [
                "__aeabi_uldivmod"
            ], 
            "imported": false, 
            "current_name": "__udivmoddi4"
        }, 
        "printTo": {
            "renaming": {}, 
            "code": "\nsize_t __thiscall IPAddress::printTo(IPAddress *this,Print *p)\n\n{\n  size_t sVar1;\n  size_t sVar2;\n  int iVar3;\n  int iVar4;\n  \n  iVar4 = 0;\n  for (iVar3 = 0; iVar3 < 3; iVar3 = iVar3 + 1) {\n    sVar1 = Print::print(p,(this->_address).bytes[iVar3],10);\n    sVar2 = Print::print(p,'.');\n    iVar4 = iVar4 + sVar1 + sVar2;\n  }\n  sVar1 = Print::print(p,(this->_address).bytes[3],10);\n  return sVar1 + iVar4;\n}\n\n", 
            "called": [
                "print", 
                "print"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800450a", 
            "calling": [], 
            "imported": false, 
            "current_name": "printTo"
        }, 
        "__sfmoreglue": {
            "renaming": {}, 
            "code": "\nundefined4 * __sfmoreglue(undefined4 param_1,int param_2)\n\n{\n  undefined4 *puVar1;\n  int iVar2;\n  \n  iVar2 = (param_2 + -1) * 0x68;\n  puVar1 = (undefined4 *)_malloc_r(param_1,iVar2 + 0x74);\n  if (puVar1 != (undefined4 *)0x0) {\n    *puVar1 = 0;\n    puVar1[1] = param_2;\n    puVar1[2] = puVar1 + 3;\n    memset(puVar1 + 3,0,iVar2 + 0x68);\n  }\n  return puVar1;\n}\n\n", 
            "called": [
                "_malloc_r", 
                "memset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005374", 
            "calling": [
                "__sfp"
            ], 
            "imported": false, 
            "current_name": "__sfmoreglue"
        }, 
        "pinmap_find_pin": {
            "renaming": {}, 
            "code": "\nPinName_conflict pinmap_find_pin(void *peripheral,PinMap_conflict *map)\n\n{\n  while( true ) {\n    if (map->peripheral == (void *)0x0) {\n      return NC;\n    }\n    if (map->peripheral == peripheral) break;\n    map = map + 1;\n  }\n  return map->pin;\n}\n\n", 
            "called": [
                "pinmap_find_pin"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003506", 
            "calling": [
                "pinmap_find_pin", 
                "pinmap_pin"
            ], 
            "imported": false, 
            "current_name": "pinmap_find_pin"
        }, 
        "_raise_r": {
            "renaming": {}, 
            "code": "\nundefined4 _raise_r(undefined4 *param_1,uint param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  __pid_t _Var1;\n  undefined4 uVar2;\n  int iVar3;\n  code *pcVar4;\n  \n  if (0x1f < param_2) {\n    *param_1 = 0x16;\n    return 0xffffffff;\n  }\n  iVar3 = param_1[0x11];\n  if ((iVar3 != 0) && (pcVar4 = *(code **)(iVar3 + param_2 * 4), pcVar4 != (code *)0x0)) {\n    if (pcVar4 != (code *)0x1) {\n      if (pcVar4 == (code *)0xffffffff) {\n        *param_1 = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(iVar3 + param_2 * 4) = 0;\n      (*pcVar4)(param_2);\n    }\n    return 0;\n  }\n  _Var1 = _getpid_r();\n  uVar2 = _kill_r(param_1,_Var1,param_2,param_4);\n  return uVar2;\n}\n\n", 
            "called": [
                "_kill_r", 
                "_getpid_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005580", 
            "calling": [
                "raise"
            ], 
            "imported": false, 
            "current_name": "_raise_r"
        }, 
        "_GLOBAL__sub_I_ctype_byname": {
            "renaming": {}, 
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::_GLOBAL__sub_I_ctype_byname(void)\n\n{\n  if (-1 < *(int *)PTR_id_080059d8 << 0x1f) {\n    *(undefined4 *)PTR_id_080059d8 = 1;\n  }\n  if (-1 < *(int *)PTR_id_080059dc << 0x1f) {\n    *(undefined4 *)PTR_id_080059dc = 1;\n  }\n  if (-1 < *(int *)PTR_id_080059e0 << 0x1f) {\n    *(undefined4 *)PTR_id_080059e0 = 1;\n  }\n  if (-1 < *(int *)PTR_id_080059e4 << 0x1f) {\n    *(undefined4 *)PTR_id_080059e4 = 1;\n  }\n  if (-1 < *(int *)PTR_id_080059e8 << 0x1f) {\n    *(undefined4 *)PTR_id_080059e8 = 1;\n  }\n  if (-1 < *(int *)PTR_id_080059ec << 0x1f) {\n    *(undefined4 *)PTR_id_080059ec = 1;\n  }\n  if (-1 < *(int *)PTR_id_080059f0 << 0x1f) {\n    *(undefined4 *)PTR_id_080059f0 = 1;\n  }\n  if (-1 < *(int *)PTR_id_080059f4 << 0x1f) {\n    *(undefined4 *)PTR_id_080059f4 = 1;\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005974", 
            "calling": [], 
            "imported": false, 
            "current_name": "_GLOBAL__sub_I_ctype_byname"
        }, 
        "_close": {
            "renaming": {}, 
            "code": "\nint _close(int file_UNUSED)\n\n{\n  return -1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080040d0", 
            "calling": [
                "_close_r"
            ], 
            "imported": false, 
            "current_name": "_close"
        }, 
        "begin": {
            "renaming": {}, 
            "code": "\nvoid __thiscall HardwareSerial::begin(HardwareSerial *this,ulong baud,byte config)\n\n{\n  byte bVar1;\n  int iVar2;\n  \n  (this->_serial).baudrate = baud;\n  this->_config = config;\n  bVar1 = config & 7;\n  if (bVar1 == 4) {\n    iVar2 = 7;\n  }\n  else if (bVar1 == 6) {\n    iVar2 = 8;\n  }\n  else if (bVar1 == 2) {\n    iVar2 = 6;\n  }\n  else {\n    iVar2 = 0;\n  }\n  if ((config & 0x30) == 0x30) {\n    (this->_serial).parity = 0x600;\n    iVar2 = iVar2 + 1;\n  }\n  else if ((config & 0x20) == 0) {\n    (this->_serial).parity = 0;\n  }\n  else {\n    (this->_serial).parity = 0x400;\n    iVar2 = iVar2 + 1;\n  }\n  if ((config & 8) == 0) {\n    (this->_serial).stopbits = 0;\n  }\n  else {\n    (this->_serial).stopbits = 0x2000;\n  }\n  if (iVar2 == 8) {\n    (this->_serial).databits = 0;\n  }\n  else if (iVar2 == 9) {\n    (this->_serial).databits = 0x1000;\n  }\n  else {\n    iVar2 = 0;\n  }\n  if (iVar2 != 0) {\n    uart_init((serial_t *)&this->_serial);\n    uart_attach_rx_callback((serial_t *)&this->_serial,DAT_08004434);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __assert_func(PTR_s__home_bo__arduino15_packages_STM_08004440,299,PTR___PRETTY_FUNCTION___0800443c\n                ,PTR_s_databits__0_08004438);\n}\n\n", 
            "called": [
                "uart_init", 
                "__assert_func", 
                "uart_attach_rx_callback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004388", 
            "calling": [
                "begin"
            ], 
            "imported": false, 
            "current_name": "begin"
        }, 
        "EXTI4_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI4_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(0x10);\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004788", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI4_IRQHandler"
        }, 
        "validateRequest": {
            "renaming": {}, 
            "code": "\nuint8_t __thiscall Modbus::validateRequest(Modbus *this)\n\n{\n  bool bVar1;\n  uint16_t uVar2;\n  uint16_t uVar3;\n  uint uVar4;\n  \n  uVar4 = 0;\n  do {\n    if (7 < uVar4) {\n      bVar1 = false;\nLAB_0800080a:\n      if (!bVar1) {\n        this->u16errCnt = this->u16errCnt + 1;\n        return '\\x01';\n      }\n      switch(this->au8Buffer[1]) {\n      case '\\x01':\n      case '\\x02':\n      case '\\x0f':\n        goto switchD_08000816_caseD_1;\n      case '\\x03':\n      case '\\x04':\n      case '\\x10':\n        uVar2 = makeWord(this->au8Buffer[2],this->au8Buffer[3]);\n        uVar3 = makeWord(this->au8Buffer[4],this->au8Buffer[5]);\n        if (this->u8regsize < (byte)((char)uVar3 + (char)uVar2)) {\n          return '\\x02';\n        }\n        return '\\0';\n      case '\\x05':\n        uVar2 = makeWord(this->au8Buffer[2],this->au8Buffer[3]);\n        if ((uint)this->u8regsize < ((uint)uVar2 << 0x14) >> 0x18) {\n          return '\\x02';\n        }\n        return '\\0';\n      case '\\x06':\n        uVar2 = makeWord(this->au8Buffer[2],this->au8Buffer[3]);\n        if (this->u8regsize < (byte)uVar2) {\n          return '\\x02';\n        }\n        return '\\0';\n      default:\n        return '\\0';\n      }\n    }\n    if (PTR_fctsupported_080008c8[uVar4] == this->au8Buffer[1]) {\n      bVar1 = true;\n      goto LAB_0800080a;\n    }\n    uVar4 = uVar4 + 1 & 0xff;\n  } while( true );\nswitchD_08000816_caseD_1:\n  uVar2 = makeWord(this->au8Buffer[2],this->au8Buffer[3]);\n  uVar3 = makeWord(this->au8Buffer[4],this->au8Buffer[5]);\n  if ((uint)this->u8regsize <\n      ((((uint)uVar2 << 0xc) >> 0x10) + (((uint)uVar3 << 0xc) >> 0x10) & 0xff)) {\n    return '\\x02';\n  }\n  return '\\0';\n}\n\n", 
            "called": [
                "makeWord"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080007f0", 
            "calling": [
                "poll"
            ], 
            "imported": false, 
            "current_name": "validateRequest"
        }, 
        "serial_tx_active": {
            "renaming": {}, 
            "code": "\nuint8_t serial_tx_active(serial_t *obj)\n\n{\n  HAL_UART_StateTypeDef HVar1;\n  \n  HVar1 = HAL_UART_GetState(*(UART_HandleTypeDef **)\n                             (PTR_uart_handlers_08003e14 + (uint)obj->index * 4));\n  return (HVar1 & 0x21U) == 0x21;\n}\n\n", 
            "called": [
                "HAL_UART_GetState"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003df4", 
            "calling": [
                "write"
            ], 
            "imported": false, 
            "current_name": "serial_tx_active"
        }, 
        "HAL_UART_Init": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)\n\n{\n  if (huart != (UART_HandleTypeDef *)0x0) {\n    if (huart->gState == HAL_UART_STATE_RESET) {\n      huart->Lock = HAL_UNLOCKED;\n      HAL_UART_MspInit(huart);\n    }\n    huart->gState = HAL_UART_STATE_BUSY;\n    huart->Instance->CR1 = huart->Instance->CR1 & 0xffffdfff;\n    UART_SetConfig(huart);\n    huart->Instance->CR2 = huart->Instance->CR2 & 0xffffb7ff;\n    huart->Instance->CR3 = huart->Instance->CR3 & 0xffffffd5;\n    huart->Instance->CR1 = huart->Instance->CR1 | 0x2000;\n    huart->ErrorCode = 0;\n    huart->gState = HAL_UART_STATE_READY;\n    huart->RxState = HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n", 
            "called": [
                "HAL_UART_MspInit", 
                "UART_SetConfig"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002d72", 
            "calling": [
                "uart_init"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_Init"
        }, 
        "_tx_complete_irq": {
            "renaming": {}, 
            "code": "\nint HardwareSerial::_tx_complete_irq(serial_t_conflict *obj)\n\n{\n  ushort uVar1;\n  uint16_t uVar2;\n  int iVar3;\n  \n  iVar3 = obj->tx_tail + 1;\n  uVar1 = (ushort)iVar3;\n  uVar2 = uVar1 & 0x7f;\n  if (iVar3 == 0) {\n    uVar2 = -(-uVar1 & 0x7f);\n  }\n  obj->tx_tail = uVar2;\n  if (obj->tx_head != obj->tx_tail) {\n    return 0;\n  }\n  return -1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800420c", 
            "calling": [], 
            "imported": false, 
            "current_name": "_tx_complete_irq"
        }, 
        "HAL_UART_Transmit_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size)\n\n{\n  if (huart->gState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (pData == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (Size == 0) {\n    return HAL_ERROR;\n  }\n  if (huart->Lock != HAL_LOCKED) {\n    huart->pTxBuffPtr = pData;\n    huart->TxXferSize = Size;\n    huart->TxXferCount = Size;\n    huart->ErrorCode = 0;\n    huart->gState = HAL_UART_STATE_BUSY_TX;\n    huart->Lock = HAL_UNLOCKED;\n    huart->Instance->CR1 = huart->Instance->CR1 | 0x80;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002eb2", 
            "calling": [
                "uart_attach_tx_callback", 
                "HAL_UART_TxCpltCallback"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_Transmit_IT"
        }, 
        "TIM1_TRG_COM_TIM11_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM1_TRG_COM_TIM11_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef **)(PTR_timer_handles_08003850 + 0x28) != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef **)(PTR_timer_handles_08003850 + 0x28));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003840", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM1_TRG_COM_TIM11_IRQHandler"
        }, 
        "TIM5_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM5_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef **)(PTR_timer_handles_080037e4 + 0x10) != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef **)(PTR_timer_handles_080037e4 + 0x10));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080037d4", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM5_IRQHandler"
        }, 
        "_cleanup_r": {
            "renaming": {}, 
            "code": "\nvoid _cleanup_r(undefined4 param_1)\n\n{\n  _fwalk_reent(param_1,DAT_08005328);\n  return;\n}\n\n", 
            "called": [
                "_fwalk_reent"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005320", 
            "calling": [], 
            "imported": false, 
            "current_name": "_cleanup_r"
        }, 
        "process_FC3": {
            "renaming": {}, 
            "code": "\nint8_t __thiscall Modbus::process_FC3(Modbus *this,uint16_t *regs,uint8_t u8size)\n\n{\n  byte bVar1;\n  uint8_t uVar2;\n  uint16_t uVar3;\n  uint16_t uVar4;\n  uint uVar5;\n  uint uVar6;\n  \n  uVar3 = makeWord(this->au8Buffer[2],this->au8Buffer[3]);\n  uVar4 = makeWord(this->au8Buffer[4],this->au8Buffer[5]);\n  this->au8Buffer[2] = (byte)uVar4 << 1;\n  this->u8BufferSize = '\\x03';\n  for (uVar5 = (uint)(byte)uVar3; uVar5 < (uint)(byte)uVar3 + (uint)(byte)uVar4;\n      uVar5 = uVar5 + 1 & 0xff) {\n    bVar1 = this->u8BufferSize;\n    this->au8Buffer[bVar1] = (uint8_t)(regs[uVar5] >> 8);\n    uVar6 = bVar1 + 1 & 0xff;\n    uVar2 = (uint8_t)uVar6;\n    this->u8BufferSize = uVar2;\n    this->au8Buffer[uVar6] = *(uint8_t *)(regs + uVar5);\n    this->u8BufferSize = uVar2 + '\\x01';\n  }\n  uVar2 = this->u8BufferSize;\n  sendTxBuffer(this);\n  return uVar2 + '\\x02';\n}\n\n", 
            "called": [
                "sendTxBuffer", 
                "makeWord"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000998", 
            "calling": [
                "poll"
            ], 
            "imported": false, 
            "current_name": "process_FC3"
        }, 
        "_kill": {
            "renaming": {}, 
            "code": "\nint _kill(int pid_UNUSED,int sig_UNUSED)\n\n{\n  *(undefined4 *)PTR_errno_08004108 = 0x16;\n  return -1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080040fc", 
            "calling": [
                "_kill_r"
            ], 
            "imported": false, 
            "current_name": "_kill"
        }, 
        "HAL_NVIC_ClearPendingIRQ": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_ClearPendingIRQ(IRQn_Type_conflict IRQn)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)IRQn;\n  if (-1 < (int)uVar1) {\n    *(int *)(DAT_08000f28 + ((uVar1 >> 5) + 0x60) * 4) = 1 << (uVar1 & 0x1f);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000f0c", 
            "calling": [
                "UART4_IRQHandler", 
                "USART6_IRQHandler", 
                "USART1_IRQHandler", 
                "USART2_IRQHandler", 
                "UART7_IRQHandler", 
                "USART3_IRQHandler", 
                "UART5_IRQHandler", 
                "UART8_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_NVIC_ClearPendingIRQ"
        }, 
        "process_FC1": {
            "renaming": {}, 
            "code": "\nint8_t __thiscall Modbus::process_FC1(Modbus *this,uint16_t *regs,uint8_t u8size)\n\n{\n  uint16_t uVar1;\n  uint16_t uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint8_t uVar5;\n  \n  uVar1 = makeWord(this->au8Buffer[2],this->au8Buffer[3]);\n  uVar2 = makeWord(this->au8Buffer[4],this->au8Buffer[5]);\n  uVar5 = (uint8_t)(((uint)uVar2 << 0x15) >> 0x18);\n  if ((uVar2 & 7) != 0) {\n    uVar5 = uVar5 + '\\x01';\n  }\n  this->au8Buffer[2] = uVar5;\n  this->u8BufferSize = '\\x03';\n  uVar4 = 0;\n  for (uVar3 = 0; uVar3 < uVar2; uVar3 = uVar3 + 1 & 0xffff) {\n    if (((int)(uint)regs[(uVar3 + uVar1) * 0x100000 >> 0x18] >> (uVar3 + uVar1 & 0xf) & 1U) == 0) {\n      this->au8Buffer[this->u8BufferSize] =\n           this->au8Buffer[this->u8BufferSize] & ~(byte)(1 << uVar4);\n    }\n    else {\n      this->au8Buffer[this->u8BufferSize] = this->au8Buffer[this->u8BufferSize] | (byte)(1 << uVar4)\n      ;\n    }\n    uVar4 = uVar4 + 1 & 0xff;\n    if (7 < uVar4) {\n      this->u8BufferSize = this->u8BufferSize + '\\x01';\n      uVar4 = 0;\n    }\n  }\n  if ((uVar2 & 7) != 0) {\n    this->u8BufferSize = this->u8BufferSize + '\\x01';\n  }\n  uVar5 = this->u8BufferSize;\n  sendTxBuffer(this);\n  return uVar5 + '\\x02';\n}\n\n", 
            "called": [
                "sendTxBuffer", 
                "makeWord"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080008e2", 
            "calling": [
                "poll"
            ], 
            "imported": false, 
            "current_name": "process_FC1"
        }, 
        "_fstat": {
            "renaming": {}, 
            "code": "\nint _fstat(int file_UNUSED,stat *st)\n\n{\n  st->st_mode = 0x2000;\n  return 0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080040d6", 
            "calling": [
                "_fstat_r"
            ], 
            "imported": false, 
            "current_name": "_fstat"
        }, 
        "HAL_UART_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_UART_IRQHandler(UART_HandleTypeDef *huart)\n\n{\n  HAL_StatusTypeDef HVar1;\n  uint uVar2;\n  USART_TypeDef *pUVar3;\n  uint uVar4;\n  uint uVar5;\n  \n  pUVar3 = huart->Instance;\n  uVar5 = pUVar3->SR;\n  uVar2 = pUVar3->CR1;\n  if ((((uVar5 & 0xf) == 0) && ((uVar5 & 0x20) != 0)) && ((uVar2 & 0x20) != 0)) {\n    UART_Receive_IT(huart);\n    return;\n  }\n  if (((uVar5 & 0xf) == 0) || ((uVar4 = pUVar3->CR3 & 1, uVar4 == 0 && ((uVar2 & 0x120) == 0)))) {\n    if (((uVar5 & 0x80) != 0) && ((uVar2 & 0x80) != 0)) {\n      UART_Transmit_IT(huart);\n      return;\n    }\n    if (((uVar5 & 0x40) != 0) && ((uVar2 & 0x40) != 0)) {\n      UART_EndTransmit_IT(huart);\n    }\n  }\n  else {\n    if (((uVar5 & 1) != 0) && ((uVar2 & 0x100) != 0)) {\n      huart->ErrorCode = huart->ErrorCode | 1;\n    }\n    if (((uVar5 & 4) != 0) && (uVar4 != 0)) {\n      huart->ErrorCode = huart->ErrorCode | 2;\n    }\n    if (((uVar5 & 2) != 0) && (uVar4 != 0)) {\n      huart->ErrorCode = huart->ErrorCode | 4;\n    }\n    if (((uVar5 & 8) != 0) && (uVar4 != 0)) {\n      huart->ErrorCode = huart->ErrorCode | 8;\n    }\n    if (huart->ErrorCode != 0) {\n      if (((uVar5 & 0x20) != 0) && ((uVar2 & 0x20) != 0)) {\n        UART_Receive_IT(huart);\n      }\n      if (((huart->ErrorCode & 8) == 0) && ((huart->Instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(huart);\n        huart->ErrorCode = 0;\n        return;\n      }\n      UART_EndRxTransfer(huart);\n      pUVar3 = huart->Instance;\n      if ((pUVar3->CR3 & 0x40) == 0) {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      pUVar3->CR3 = pUVar3->CR3 & 0xffffffbf;\n      if (huart->hdmarx == (DMA_HandleTypeDef *)0x0) {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      huart->hdmarx->XferAbortCallback = DAT_08003118;\n      HVar1 = HAL_DMA_Abort_IT(huart->hdmarx);\n      if (HVar1 != HAL_OK) {\n        (*huart->hdmarx->XferAbortCallback)(huart->hdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "UART_Transmit_IT", 
                "UART_EndTransmit_IT", 
                "HAL_UART_ErrorCallback", 
                "UART_Receive_IT", 
                "HAL_DMA_Abort_IT", 
                "UART_EndRxTransfer"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002ffc", 
            "calling": [
                "UART4_IRQHandler", 
                "USART6_IRQHandler", 
                "USART1_IRQHandler", 
                "USART2_IRQHandler", 
                "UART7_IRQHandler", 
                "USART3_IRQHandler", 
                "UART5_IRQHandler", 
                "UART8_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_IRQHandler"
        }, 
        "_GLOBAL__sub_I__ZN6ModbusC2Ev": {
            "renaming": {}, 
            "code": "\nvoid _GLOBAL__sub_I__ZN6ModbusC2Ev(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n", 
            "called": [
                "__static_initialization_and_destruction_0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000c7c", 
            "calling": [], 
            "imported": false, 
            "current_name": "_GLOBAL__sub_I__ZN6ModbusC2Ev"
        }, 
        "HAL_TIM_PWM_Stop": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim,uint32_t Channel)\n\n{\n  bool bVar1;\n  TIM_TypeDef *pTVar2;\n  \n  TIM_CCxChannelCmd(htim->Instance,Channel,0);\n  pTVar2 = htim->Instance;\n  if (pTVar2 == DAT_080028d0) {\n    bVar1 = true;\n  }\n  else if (pTVar2 == (TIM_TypeDef *)&DAT_080028d0[0xc].SR) {\n    bVar1 = true;\n  }\n  else {\n    bVar1 = false;\n  }\n  if (((bVar1) && ((pTVar2->CCER & 0x1111) == 0)) && ((pTVar2->CCER & 0x444) == 0)) {\n    pTVar2->BDTR = pTVar2->BDTR & 0xffff7fff;\n  }\n  pTVar2 = htim->Instance;\n  if (((pTVar2->CCER & 0x1111) == 0) && ((pTVar2->CCER & 0x444) == 0)) {\n    pTVar2->CR1 = pTVar2->CR1 & 0xfffffffe;\n  }\n  htim->State = HAL_TIM_STATE_READY;\n  return HAL_OK;\n}\n\n", 
            "called": [
                "TIM_CCxChannelCmd"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002864", 
            "calling": [
                "pwm_stop"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_PWM_Stop"
        }, 
        "UART4_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid UART4_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(UART4_IRQn);\n  HAL_UART_IRQHandler(*(UART_HandleTypeDef **)(PTR_uart_handlers_08004030 + 0xc));\n  return;\n}\n\n", 
            "called": [
                "HAL_UART_IRQHandler", 
                "HAL_NVIC_ClearPendingIRQ"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800401c", 
            "calling": [], 
            "imported": false, 
            "current_name": "UART4_IRQHandler"
        }, 
        "process_FC5": {
            "renaming": {}, 
            "code": "\nint8_t __thiscall Modbus::process_FC5(Modbus *this,uint16_t *regs,uint8_t u8size)\n\n{\n  uint16_t uVar1;\n  uint uVar2;\n  uint uVar3;\n  \n  uVar1 = makeWord(this->au8Buffer[2],this->au8Buffer[3]);\n  uVar3 = ((uint)uVar1 << 0x14) >> 0x18;\n  uVar2 = uVar1 & 0xf;\n  if (this->au8Buffer[4] == 0xff) {\n    regs[uVar3] = (ushort)(1 << uVar2) | regs[uVar3];\n  }\n  else {\n    regs[uVar3] = regs[uVar3] & ~(ushort)(1 << uVar2);\n  }\n  this->u8BufferSize = '\\x06';\n  sendTxBuffer(this);\n  return '\\b';\n}\n\n", 
            "called": [
                "sendTxBuffer", 
                "makeWord"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000a00", 
            "calling": [
                "poll"
            ], 
            "imported": false, 
            "current_name": "process_FC5"
        }, 
        "process_FC6": {
            "renaming": {}, 
            "code": "\nint8_t __thiscall Modbus::process_FC6(Modbus *this,uint16_t *regs,uint8_t u8size)\n\n{\n  uint16_t uVar1;\n  uint16_t uVar2;\n  \n  uVar1 = makeWord(this->au8Buffer[2],this->au8Buffer[3]);\n  uVar2 = makeWord(this->au8Buffer[4],this->au8Buffer[5]);\n  regs[(byte)uVar1] = uVar2;\n  this->u8BufferSize = '\\x06';\n  sendTxBuffer(this);\n  return '\\b';\n}\n\n", 
            "called": [
                "sendTxBuffer", 
                "makeWord"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000a4e", 
            "calling": [
                "poll"
            ], 
            "imported": false, 
            "current_name": "process_FC6"
        }, 
        "HAL_RTC_AlarmIRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)\n\n{\n  if (((hrtc->Instance->ISR & 0x100) != 0) && ((hrtc->Instance->CR & 0x1000) != 0)) {\n    HAL_RTC_AlarmAEventCallback(hrtc);\n    hrtc->Instance->ISR = hrtc->Instance->ISR & 0xff | 0xfffffe7f;\n  }\n  if (((hrtc->Instance->ISR & 0x200) != 0) && ((hrtc->Instance->CR & 0x2000) != 0)) {\n    HAL_RTCEx_AlarmBEventCallback(hrtc);\n    hrtc->Instance->ISR = hrtc->Instance->ISR & 0xff | 0xfffffd7f;\n  }\n  *(undefined4 *)(DAT_08002688 + 0x14) = 0x20000;\n  hrtc->State = HAL_RTC_STATE_READY;\n  return;\n}\n\n", 
            "called": [
                "HAL_RTCEx_AlarmBEventCallback", 
                "HAL_RTC_AlarmAEventCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800262c", 
            "calling": [
                "RTC_Alarm_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_RTC_AlarmIRQHandler"
        }, 
        "EXTI2_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid EXTI2_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(4);\n  return;\n}\n\n", 
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004774", 
            "calling": [], 
            "imported": false, 
            "current_name": "EXTI2_IRQHandler"
        }, 
        "HAL_I2C_Slave_Sequential_Receive_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef\nHAL_I2C_Slave_Sequential_Receive_IT\n          (I2C_HandleTypeDef *hi2c,uint8_t *pData,uint16_t Size,uint32_t XferOptions)\n\n{\n  HAL_StatusTypeDef HVar1;\n  I2C_TypeDef *pIVar2;\n  uint32_t tmpreg;\n  \n  if (hi2c->State == HAL_I2C_STATE_LISTEN) {\n    if (pData == (uint8_t *)0x0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (Size == 0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (hi2c->Lock == HAL_LOCKED) {\n      HVar1 = HAL_BUSY;\n    }\n    else {\n      hi2c->Lock = HAL_LOCKED;\n      pIVar2 = hi2c->Instance;\n      if ((pIVar2->CR1 & 1) == 0) {\n        pIVar2->CR1 = pIVar2->CR1 | 1;\n      }\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffff7ff;\n      hi2c->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      hi2c->Mode = HAL_I2C_MODE_SLAVE;\n      HVar1 = HAL_OK;\n      hi2c->ErrorCode = 0;\n      hi2c->pBuffPtr = pData;\n      hi2c->XferCount = Size;\n      hi2c->XferOptions = XferOptions;\n      hi2c->XferSize = hi2c->XferCount;\n      hi2c->Lock = HAL_UNLOCKED;\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    HVar1 = HAL_BUSY;\n  }\n  return HVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080014ec", 
            "calling": [
                "HAL_I2C_AddrCallback"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_Slave_Sequential_Receive_IT"
        }, 
        "HAL_PWREx_EnableOverDrive": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint32_t tmpreg;\n  \n  *(uint *)(DAT_0800200c + 0x40) = *(uint *)(DAT_0800200c + 0x40) | 0x10000000;\n  *DAT_08002010 = 1;\n  uVar1 = HAL_GetTick();\n  do {\n    if ((*(uint *)(DAT_08002014 + 4) & 0x10000) != 0) {\n      *DAT_08002018 = 1;\n      uVar1 = HAL_GetTick();\n      do {\n        if ((*(uint *)(DAT_08002014 + 4) & 0x20000) != 0) {\n          return HAL_OK;\n        }\n        uVar2 = HAL_GetTick();\n      } while (uVar2 - uVar1 < 0x3e9);\n      return HAL_TIMEOUT;\n    }\n    uVar2 = HAL_GetTick();\n  } while (uVar2 - uVar1 < 0x3e9);\n  return HAL_TIMEOUT;\n}\n\n", 
            "called": [
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001f9c", 
            "calling": [
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_PWREx_EnableOverDrive"
        }, 
        "_getpid": {
            "renaming": {}, 
            "code": "\n__pid_t _getpid(void)\n\n{\n  return 1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800410c", 
            "calling": [
                "_getpid_r"
            ], 
            "imported": false, 
            "current_name": "_getpid"
        }, 
        "I2C_MasterReceive_BTF": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c)\n\n{\n  uint8_t *puVar1;\n  \n  if (hi2c->XferCount == 4) {\n    hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffbff;\n    puVar1 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = puVar1 + 1;\n    *puVar1 = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n  }\n  else if (hi2c->XferCount == 3) {\n    hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffbff;\n    hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n    puVar1 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = puVar1 + 1;\n    *puVar1 = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n  }\n  else if (hi2c->XferCount == 2) {\n    if (hi2c->XferOptions - 1 < 2) {\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x100;\n    }\n    else {\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n    }\n    puVar1 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = puVar1 + 1;\n    *puVar1 = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n    puVar1 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = puVar1 + 1;\n    *puVar1 = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n    hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffcff;\n    hi2c->State = HAL_I2C_STATE_READY;\n    hi2c->PreviousState = 0;\n    if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n      hi2c->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MemRxCpltCallback(hi2c);\n    }\n    else {\n      hi2c->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MasterRxCpltCallback(hi2c);\n    }\n  }\n  else {\n    puVar1 = hi2c->pBuffPtr;\n    hi2c->pBuffPtr = puVar1 + 1;\n    *puVar1 = (uint8_t)hi2c->Instance->DR;\n    hi2c->XferCount = hi2c->XferCount - 1;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_MasterRxCpltCallback", 
                "HAL_I2C_MemRxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080019a0", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_MasterReceive_BTF"
        }, 
        "TIM3_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM3_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef **)(PTR_timer_handles_080037bc + 8) != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef **)(PTR_timer_handles_080037bc + 8));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080037ac", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM3_IRQHandler"
        }, 
        "peek": {
            "renaming": {}, 
            "code": "\nint __thiscall HardwareSerial::peek(HardwareSerial *this)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)(this->_serial).rx_tail;\n  if ((this->_serial).rx_head != uVar1) {\n    return (uint)(this->_serial).rx_buff[uVar1];\n  }\n  return -1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004254", 
            "calling": [], 
            "imported": false, 
            "current_name": "peek"
        }, 
        "__aeabi_uldivmod": {
            "renaming": {}, 
            "code": "\nvoid __aeabi_uldivmod(int param_1,int param_2,int param_3,int param_4)\n\n{\n  if ((param_4 == 0) && (param_3 == 0)) {\n    if (param_2 != 0 || param_1 != 0) {\n      param_2 = -1;\n      param_1 = -1;\n    }\n    __aeabi_idiv0(param_1,param_2);\n    return;\n  }\n  __udivmoddi4();\n  return;\n}\n\n", 
            "called": [
                "__aeabi_idiv0", 
                "__udivmoddi4"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080002d0", 
            "calling": [
                "HAL_RCC_GetSysClockFreq"
            ], 
            "imported": false, 
            "current_name": "__aeabi_uldivmod"
        }, 
        "HAL_UART_Receive_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size)\n\n{\n  if (huart->RxState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (pData == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (Size == 0) {\n    return HAL_ERROR;\n  }\n  if (huart->Lock != HAL_LOCKED) {\n    huart->pRxBuffPtr = pData;\n    huart->RxXferSize = Size;\n    huart->RxXferCount = Size;\n    huart->ErrorCode = 0;\n    huart->RxState = HAL_UART_STATE_BUSY_RX;\n    huart->Lock = HAL_UNLOCKED;\n    huart->Instance->CR3 = huart->Instance->CR3 | 1;\n    huart->Instance->CR1 = huart->Instance->CR1 | 0x120;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002efa", 
            "calling": [
                "uart_getc", 
                "uart_attach_rx_callback"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_Receive_IT"
        }, 
        "memchr": {
            "renaming": {}, 
            "code": "\nvoid * memchr(void *__s,int __c,size_t __n)\n\n{\n  byte bVar1;\n  char cVar2;\n  char cVar3;\n  char cVar4;\n  char cVar5;\n  byte *pbVar6;\n  uint *puVar7;\n  byte *pbVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  bool bVar14;\n  bool bVar15;\n  bool bVar16;\n  bool bVar17;\n  \n  uVar9 = __c & 0xff;\n  if ((int)__n < 0x10) {\njoined_r0x08000290:\n    do {\n      if (__n == 0) {\n        return (void *)0x0;\n      }\n                    /* WARNING: Load size is inaccurate */\n      puVar7 = (uint *)((int)__s + 1);\n      bVar1 = *__s;\n      __n = __n - 1;\n      __s = puVar7;\n    } while (bVar1 != uVar9);\n  }\n  else {\n    uVar10 = (uint)__s & 7;\n    while( true ) {\n      if (uVar10 == 0) {\n        uVar10 = uVar9 | uVar9 << 8;\n        uVar10 = uVar10 | uVar10 << 0x10;\n        uVar11 = __n & 0xfffffff8;\n        do {\n          puVar7 = (uint *)((int)__s + 8);\n                    /* WARNING: Load size is inaccurate */\n          uVar11 = uVar11 - 8;\n          uVar12 = *__s ^ uVar10;\n          uVar13 = *(uint *)((int)__s + 4) ^ uVar10;\n          cVar2 = -((char)uVar12 == '\\0');\n          cVar3 = -((char)(uVar12 >> 8) == '\\0');\n          cVar4 = -((char)(uVar12 >> 0x10) == '\\0');\n          cVar5 = -((char)(uVar12 >> 0x18) == '\\0');\n          uVar12 = CONCAT13(cVar5,CONCAT12(cVar4,CONCAT11(cVar3,cVar2)));\n          bVar14 = (char)uVar13 != '\\0';\n          bVar15 = (char)(uVar13 >> 8) != '\\0';\n          bVar16 = (char)(uVar13 >> 0x10) != '\\0';\n          bVar17 = (char)(uVar13 >> 0x18) != '\\0';\n          uVar13 = CONCAT13(bVar17 * cVar5 - !bVar17,\n                            CONCAT12(bVar16 * cVar4 - !bVar16,\n                                     CONCAT11(bVar15 * cVar3 - !bVar15,bVar14 * cVar2 - !bVar14)));\n          if (uVar13 != 0) {\n            if (uVar12 == 0) {\n              pbVar8 = (byte *)((int)__s + 5);\n              uVar12 = uVar13;\n            }\n            else {\n              pbVar8 = (byte *)((int)__s + 1);\n            }\n            if ((uVar12 & 1) == 0) {\n              bVar14 = (uVar12 & 0x100) == 0;\n              pbVar6 = pbVar8 + 1;\n              if (bVar14) {\n                bVar14 = (uVar12 & 0x18000) == 0;\n                pbVar6 = pbVar8 + 2;\n              }\n              pbVar8 = pbVar6;\n              if (bVar14) {\n                pbVar8 = pbVar8 + 1;\n              }\n            }\n            return pbVar8 + -1;\n          }\n          __s = puVar7;\n        } while (uVar11 != 0);\n        __n = __n & 7;\n        goto joined_r0x08000290;\n      }\n                    /* WARNING: Load size is inaccurate */\n      puVar7 = (uint *)((int)__s + 1);\n      __n = __n - 1;\n      if (*__s == uVar9) break;\n      uVar10 = (uint)puVar7 & 7;\n      __s = puVar7;\n      if (__n == 0) {\n        return (void *)0x0;\n      }\n    }\n  }\n  return (byte *)((int)puVar7 + -1);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000230", 
            "calling": [
                "_printf_i", 
                "_vfiprintf_r"
            ], 
            "imported": false, 
            "current_name": "memchr"
        }, 
        "I2C_Slave_ADDR": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c)\n\n{\n  uint16_t AddrMatchCode;\n  \n  if ((hi2c->Instance->SR2 & 0x80) == 0) {\n    AddrMatchCode = *(uint16_t *)&(hi2c->Init).OwnAddress1;\n  }\n  else {\n    AddrMatchCode = *(uint16_t *)&(hi2c->Init).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(hi2c,(hi2c->Instance->SR2 & 4) == 0,AddrMatchCode);\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_AddrCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800165a", 
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_Slave_ADDR"
        }, 
        "I2C1_ER_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid I2C1_ER_IRQHandler(void)\n\n{\n  HAL_I2C_ER_IRQHandler(*(I2C_HandleTypeDef **)PTR_i2c_handles_08003934);\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003928", 
            "calling": [], 
            "imported": false, 
            "current_name": "I2C1_ER_IRQHandler"
        }, 
        "TIM8_UP_TIM13_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM8_UP_TIM13_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef **)(PTR_timer_handles_08003828 + 0x1c) != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef **)(PTR_timer_handles_08003828 + 0x1c));\n  }\n  if (*(TIM_HandleTypeDef **)(PTR_timer_handles_08003828 + 0x30) != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef **)(PTR_timer_handles_08003828 + 0x30));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003810", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM8_UP_TIM13_IRQHandler"
        }, 
        "__sflush_r": {
            "renaming": {}, 
            "code": "\nundefined4 __sflush_r(uint *param_1,int *param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  uint uVar3;\n  ushort uVar4;\n  int iVar5;\n  code *pcVar6;\n  int iVar7;\n  uint uVar8;\n  bool bVar9;\n  \n  uVar4 = *(ushort *)(param_2 + 3);\n  uVar3 = (uint)uVar4;\n  if ((int)(uVar3 << 0x1c) < 0) {\n    iVar1 = param_2[4];\n    if (iVar1 != 0) {\n      iVar5 = uVar3 << 0x1e;\n      bVar9 = iVar5 == 0;\n      iVar7 = *param_2;\n      if (bVar9) {\n        iVar5 = param_2[5];\n      }\n      *param_2 = iVar1;\n      if (!bVar9) {\n        iVar5 = 0;\n      }\n      param_2[2] = iVar5;\n      for (iVar7 = iVar7 - iVar1; 0 < iVar7; iVar7 = iVar7 - iVar5) {\n        iVar5 = (*(code *)param_2[10])(param_1,param_2[8],iVar1,iVar7);\n        if (iVar5 < 1) {\n          uVar4 = *(ushort *)(param_2 + 3);\n          goto LAB_080052b2;\n        }\n        iVar1 = iVar1 + iVar5;\n      }\n    }\n  }\n  else if (((0 < param_2[1]) || (0 < param_2[0x10])) &&\n          (pcVar6 = (code *)param_2[0xb], pcVar6 != (code *)0x0)) {\n    uVar8 = *param_1;\n    *param_1 = 0;\n    if ((uVar4 & 0x1000) == 0) {\n      iVar1 = (*pcVar6)(param_1,param_2[8],uVar3 & 0x1000,1);\n      if ((iVar1 == -1) && (uVar3 = *param_1, uVar3 != 0)) {\n        if ((uVar3 != 0x1d) && (uVar3 != 0x16)) {\n          *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *param_1 = uVar8;\n        return 0;\n      }\n    }\n    else {\n      iVar1 = param_2[0x15];\n    }\n    if (((int)((uint)*(ushort *)(param_2 + 3) << 0x1d) < 0) &&\n       (iVar1 = iVar1 - param_2[1], param_2[0xd] != 0)) {\n      iVar1 = iVar1 - param_2[0x10];\n    }\n    iVar1 = (*(code *)param_2[0xb])(param_1,param_2[8],iVar1,0);\n    uVar4 = *(ushort *)(param_2 + 3);\n    if ((iVar1 == -1) &&\n       ((0x1d < *param_1 || (-1 < (int)((DAT_080052c8 >> (*param_1 & 0xff)) << 0x1f))))) {\nLAB_080052b2:\n      *(ushort *)(param_2 + 3) = uVar4 | 0x40;\n      return 0xffffffff;\n    }\n    param_2[1] = 0;\n    *param_2 = param_2[4];\n    if (((int)((uint)uVar4 << 0x13) < 0) && ((iVar1 != -1 || (*param_1 == 0)))) {\n      param_2[0x15] = iVar1;\n    }\n    piVar2 = (int *)param_2[0xd];\n    *param_1 = uVar8;\n    if (piVar2 != (int *)0x0) {\n      if (piVar2 != param_2 + 0x11) {\n        _free_r(param_1);\n      }\n      param_2[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n", 
            "called": [
                "_free_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080051bc", 
            "calling": [
                "_fflush_r"
            ], 
            "imported": false, 
            "current_name": "__sflush_r"
        }, 
        "TIM4_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM4_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef **)(PTR_timer_handles_080037d0 + 0xc) != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef **)(PTR_timer_handles_080037d0 + 0xc));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080037c0", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM4_IRQHandler"
        }, 
        "noOsSystickHandler": {
            "renaming": {}, 
            "code": "\nvoid noOsSystickHandler(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003474", 
            "calling": [
                "SysTick_Handler"
            ], 
            "imported": false, 
            "current_name": "noOsSystickHandler"
        }, 
        "_printf_i": {
            "renaming": {}, 
            "code": "\nuint _printf_i(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  byte bVar1;\n  int iVar2;\n  uint *puVar3;\n  void *pvVar4;\n  int iVar5;\n  undefined *puVar6;\n  uint uVar7;\n  uint **ppuVar8;\n  uint uVar9;\n  uint uVar10;\n  undefined *puVar11;\n  undefined *__s;\n  uint local_24 [2];\n  \n  bVar1 = *(byte *)(param_2 + 6);\n  __s = (undefined *)((int)param_2 + 0x43);\n  if (bVar1 != 0x6e) {\n    if (bVar1 < 0x6f) {\n      if (bVar1 != 99) {\n        if (bVar1 < 100) {\n          if (bVar1 == 0) goto LAB_08004f56;\n          if (bVar1 != 0x58) goto LAB_08004dcc;\n          *(undefined *)((int)param_2 + 0x45) = 0x58;\n          puVar6 = PTR_s_0123456789ABCDEF_08004fd8;\nLAB_08004ee6:\n          uVar7 = *param_2;\n          puVar3 = *param_5;\n          *param_5 = puVar3 + 1;\n          if (((uVar7 & 0x80) == 0) && ((int)(uVar7 << 0x19) < 0)) {\n            uVar9 = (uint)*(ushort *)puVar3;\n          }\n          else {\n            uVar9 = *puVar3;\n          }\n          if ((int)(uVar7 << 0x1f) < 0) {\n            *param_2 = uVar7 | 0x20;\n          }\n          if (uVar9 == 0) {\n            *param_2 = *param_2 & 0xffffffdf;\n          }\n          uVar7 = 0x10;\nLAB_08004e7c:\n          *(undefined *)((int)param_2 + 0x43) = 0;\n        }\n        else {\n          if ((bVar1 != 100) && (bVar1 != 0x69)) goto LAB_08004dcc;\n          uVar9 = *param_2;\n          puVar3 = *param_5;\n          if ((uVar9 & 0x80) == 0) {\n            *param_5 = puVar3 + 1;\n            if ((uVar9 & 0x40) == 0) goto LAB_08004dec;\n            uVar9 = (uint)(short)*(ushort *)puVar3;\n          }\n          else {\n            *param_5 = puVar3 + 1;\nLAB_08004dec:\n            uVar9 = *puVar3;\n          }\n          if ((int)uVar9 < 0) {\n            uVar9 = -uVar9;\n            *(undefined *)((int)param_2 + 0x43) = 0x2d;\n          }\n          uVar7 = 10;\n          puVar6 = PTR_s_0123456789ABCDEF_08004fd8;\n        }\n        uVar10 = param_2[1];\n        param_2[2] = uVar10;\n        puVar11 = __s;\n        if ((int)uVar10 < 0) {\n          if (uVar9 != 0) goto LAB_08004f1a;\nLAB_08004fc8:\n          *(undefined *)((int)param_2 + 0x42) = *puVar6;\n          puVar11 = (undefined *)((int)param_2 + 0x42);\n        }\n        else {\n          *param_2 = *param_2 & 0xfffffffb;\n          if (uVar9 == 0) {\n            if (uVar10 != 0) goto LAB_08004fc8;\n          }\n          else {\nLAB_08004f1a:\n            do {\n              uVar10 = uVar9 / uVar7;\n              puVar11 = puVar11 + -1;\n              *puVar11 = puVar6[uVar9 - uVar7 * uVar10];\n              uVar9 = uVar10;\n            } while (uVar10 != 0);\n          }\n        }\n        if (((uVar7 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4]))\n        {\n          puVar11[-1] = 0x30;\n          puVar11 = puVar11 + -1;\n        }\n        param_2[4] = (int)__s - (int)puVar11;\n        __s = puVar11;\n        goto LAB_08004ec2;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      *(char *)((int)param_2 + 0x42) = (char)*puVar3;\nLAB_08004e2c:\n      __s = (undefined *)((int)param_2 + 0x42);\n      uVar9 = 1;\n    }\n    else {\n      if (bVar1 != 0x73) {\n        if (bVar1 < 0x74) {\n          if (bVar1 == 0x6f) {\nLAB_08004e52:\n            uVar9 = *param_2;\n            puVar3 = *param_5;\n            if ((uVar9 & 0x80) == 0) {\n              *param_5 = puVar3 + 1;\n              if ((uVar9 & 0x40) == 0) goto LAB_08004e60;\n              uVar9 = (uint)*(ushort *)puVar3;\n            }\n            else {\n              *param_5 = puVar3 + 1;\nLAB_08004e60:\n              uVar9 = *puVar3;\n            }\n            puVar6 = PTR_s_0123456789ABCDEF_08004fd8;\n            if (bVar1 == 0x6f) {\n              uVar7 = 8;\n            }\n            else {\n              uVar7 = 10;\n            }\n            goto LAB_08004e7c;\n          }\n          if (bVar1 == 0x70) {\n            *param_2 = *param_2 | 0x20;\nLAB_08004e12:\n            *(undefined *)((int)param_2 + 0x45) = 0x78;\n            puVar6 = PTR_s_0123456789abcdef_08004fd4;\n            goto LAB_08004ee6;\n          }\n        }\n        else {\n          if (bVar1 == 0x75) goto LAB_08004e52;\n          if (bVar1 == 0x78) goto LAB_08004e12;\n        }\nLAB_08004dcc:\n        *(byte *)((int)param_2 + 0x42) = bVar1;\n        goto LAB_08004e2c;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      __s = (undefined *)*puVar3;\n      pvVar4 = memchr(__s,0,param_2[1]);\n      if (pvVar4 != (void *)0x0) {\n        param_2[1] = (int)pvVar4 - (int)__s;\n      }\n      uVar9 = param_2[1];\n    }\n    param_2[4] = uVar9;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_08004ec2;\n  }\n  uVar9 = *param_2;\n  ppuVar8 = (uint **)*param_5;\n  uVar7 = param_2[5];\n  if ((uVar9 & 0x80) == 0) {\n    *param_5 = (uint *)(ppuVar8 + 1);\n    puVar3 = *ppuVar8;\n    if ((uVar9 & 0x40) == 0) goto LAB_08004f42;\n    *(short *)puVar3 = (short)uVar7;\n  }\n  else {\n    *param_5 = (uint *)(ppuVar8 + 1);\n    puVar3 = *ppuVar8;\nLAB_08004f42:\n    *puVar3 = uVar7;\n  }\nLAB_08004f56:\n  param_2[4] = 0;\nLAB_08004ec2:\n  iVar2 = _printf_common(param_1,param_2,local_24,param_3,param_4);\n  if ((iVar2 == -1) || (iVar2 = (*param_4)(param_1,param_3,__s,param_2[4]), iVar2 == -1)) {\nLAB_08004ed6:\n    uVar9 = 0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar2 = 0; iVar2 < (int)(param_2[3] - local_24[0]); iVar2 = iVar2 + 1) {\n        iVar5 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar5 == -1) goto LAB_08004ed6;\n      }\n    }\n    uVar9 = param_2[3];\n    if ((int)param_2[3] < (int)local_24[0]) {\n      uVar9 = local_24[0];\n    }\n  }\n  return uVar9;\n}\n\n", 
            "called": [
                "_printf_common", 
                "memchr"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004d9c", 
            "calling": [
                "_vfiprintf_r"
            ], 
            "imported": false, 
            "current_name": "_printf_i"
        }, 
        "HAL_UART_Transmit": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef\nHAL_UART_Transmit(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size,uint32_t Timeout)\n\n{\n  HAL_StatusTypeDef HVar1;\n  uint32_t Tickstart;\n  \n  if (huart->gState == HAL_UART_STATE_READY) {\n    if (pData == (uint8_t *)0x0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (Size == 0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (huart->Lock == HAL_LOCKED) {\n      HVar1 = HAL_BUSY;\n    }\n    else {\n      huart->Lock = HAL_LOCKED;\n      huart->ErrorCode = 0;\n      huart->gState = HAL_UART_STATE_BUSY_TX;\n      Tickstart = HAL_GetTick();\n      huart->TxXferSize = Size;\n      huart->TxXferCount = Size;\n      while (huart->TxXferCount != 0) {\n        huart->TxXferCount = huart->TxXferCount - 1;\n        if ((huart->Init).WordLength == 0x1000) {\n          HVar1 = UART_WaitOnFlagUntilTimeout(huart,0x80,RESET,Tickstart,Timeout);\n          if (HVar1 != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          huart->Instance->DR = *(ushort *)pData & 0x1ff;\n          if ((huart->Init).Parity == 0) {\n            pData = (uint8_t *)((int)pData + 2);\n          }\n          else {\n            pData = (uint8_t *)((int)pData + 1);\n          }\n        }\n        else {\n          HVar1 = UART_WaitOnFlagUntilTimeout(huart,0x80,RESET,Tickstart,Timeout);\n          if (HVar1 != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          huart->Instance->DR = (uint)*pData;\n          pData = (uint8_t *)((int)pData + 1);\n        }\n      }\n      HVar1 = UART_WaitOnFlagUntilTimeout(huart,0x40,RESET,Tickstart,Timeout);\n      if (HVar1 == HAL_OK) {\n        huart->gState = HAL_UART_STATE_READY;\n        huart->Lock = HAL_UNLOCKED;\n      }\n      else {\n        HVar1 = HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    HVar1 = HAL_BUSY;\n  }\n  return HVar1;\n}\n\n", 
            "called": [
                "UART_WaitOnFlagUntilTimeout", 
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002dd0", 
            "calling": [
                "uart_debug_write"
            ], 
            "imported": false, 
            "current_name": "HAL_UART_Transmit"
        }, 
        "main": {
            "renaming": {}, 
            "code": "\nint main(void)\n\n{\n  initVariant();\n  setup();\n  do {\n    do {\n      loop();\n    } while (DAT_08004674 == 0);\n    serialEventRun();\n  } while( true );\n}\n\n", 
            "called": [
                "serialEventRun", 
                "initVariant", 
                "setup", 
                "loop"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004658", 
            "calling": [
                "Reset_Handler"
            ], 
            "imported": false, 
            "current_name": "main"
        }, 
        "_free_r": {
            "renaming": {}, 
            "code": "\nvoid _free_r(undefined4 *param_1,int param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined *puVar1;\n  int *piVar2;\n  int *extraout_r1;\n  int **ppiVar3;\n  int **ppiVar4;\n  int **ppiVar5;\n  int **ppiVar6;\n  int **ppiVar7;\n  bool bVar8;\n  \n  if (param_2 == 0) {\n    return;\n  }\n  ppiVar7 = (int **)(param_2 + -4);\n  if (*(int *)(param_2 + -4) < 0) {\n    ppiVar7 = (int **)((int)ppiVar7 + *(int *)(param_2 + -4));\n  }\n  __malloc_lock();\n  puVar1 = PTR___malloc_free_list_08004974;\n  ppiVar5 = *(int ***)PTR___malloc_free_list_08004974;\n  if (ppiVar5 == (int **)0x0) {\n    ppiVar7[1] = (int *)0x0;\n    *(int ***)puVar1 = ppiVar7;\n    ppiVar3 = (int **)extraout_r1;\n    ppiVar4 = (int **)puVar1;\n  }\n  else if (ppiVar7 < ppiVar5) {\n    ppiVar3 = (int **)*ppiVar7;\n    ppiVar4 = (int **)((int)ppiVar7 + (int)ppiVar3);\n    bVar8 = ppiVar5 == ppiVar4;\n    if (bVar8) {\n      ppiVar4 = (int **)*ppiVar5;\n      ppiVar5 = (int **)ppiVar5[1];\n    }\n    ppiVar7[1] = (int *)ppiVar5;\n    if (bVar8) {\n      ppiVar4 = (int **)((int)ppiVar4 + (int)ppiVar3);\n      *ppiVar7 = (int *)ppiVar4;\n    }\n    *(int ***)puVar1 = ppiVar7;\n  }\n  else {\n    do {\n      ppiVar6 = ppiVar5;\n      ppiVar4 = (int **)ppiVar6[1];\n      if (ppiVar4 == (int **)0x0) break;\n      ppiVar5 = ppiVar4;\n    } while (ppiVar4 <= ppiVar7);\n    ppiVar3 = (int **)*ppiVar6;\n    if ((int **)((int)ppiVar6 + (int)ppiVar3) == ppiVar7) {\n      ppiVar3 = (int **)((int)ppiVar3 + (int)*ppiVar7);\n      *ppiVar6 = (int *)ppiVar3;\n      if (ppiVar4 == (int **)((int)ppiVar6 + (int)ppiVar3)) {\n        piVar2 = *ppiVar4;\n        ppiVar4 = (int **)ppiVar4[1];\n        ppiVar6[1] = (int *)ppiVar4;\n        ppiVar3 = (int **)((int)ppiVar3 + (int)piVar2);\n        *ppiVar6 = (int *)ppiVar3;\n      }\n    }\n    else if (ppiVar7 < (int **)((int)ppiVar6 + (int)ppiVar3)) {\n      *param_1 = 0xc;\n    }\n    else {\n      ppiVar3 = (int **)((int)ppiVar7 + (int)*ppiVar7);\n      bVar8 = ppiVar4 == ppiVar3;\n      if (bVar8) {\n        ppiVar3 = (int **)*ppiVar4;\n        ppiVar4 = (int **)ppiVar4[1];\n      }\n      ppiVar7[1] = (int *)ppiVar4;\n      if (bVar8) {\n        ppiVar3 = (int **)((int)ppiVar3 + (int)*ppiVar7);\n        *ppiVar7 = (int *)ppiVar3;\n      }\n      ppiVar6[1] = (int *)ppiVar7;\n    }\n  }\n  __malloc_unlock(param_1,ppiVar3,ppiVar4,param_4);\n  return;\n}\n\n", 
            "called": [
                "__malloc_unlock", 
                "__malloc_lock"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080048dc", 
            "calling": [
                "__swsetup_r", 
                "__sflush_r"
            ], 
            "imported": false, 
            "current_name": "_free_r"
        }, 
        "poll": {
            "renaming": {}, 
            "code": "\nint8_t __thiscall Modbus::poll(Modbus *this,uint16_t *regs,uint8_t u8size)\n\n{\n  uint8_t uVar1;\n  uint8_t u8exception;\n  uint uVar2;\n  uint32_t uVar3;\n  uint unaff_r5;\n  \n  this->au16regs = regs;\n  this->u8regsize = u8size;\n  if (this->u8serno < 4) {\n    uVar2 = (*(this->port->super_Stream).super_Print._vptr_Print[2])();\n    unaff_r5 = uVar2 & 0xff;\n  }\n  if (unaff_r5 == 0) {\n    uVar1 = '\\0';\n  }\n  else if ((int)unaff_r5 < 8) {\n    uVar1 = '\\0';\n  }\n  else {\n    uVar1 = getRxBuffer(this);\n    this->u8lastError = uVar1;\n    if (this->au8Buffer[0] == this->u8id) {\n      u8exception = validateRequest(this);\n      if (u8exception == '\\0') {\n        uVar3 = millis();\n        this->u32timeOut = this->u16timeOut + uVar3;\n        this->u8lastError = '\\0';\n        switch(this->au8Buffer[1]) {\n        case '\\x01':\n        case '\\x02':\n          uVar1 = process_FC1(this,regs,u8size);\n          break;\n        case '\\x03':\n        case '\\x04':\n          uVar1 = process_FC3(this,regs,u8size);\n          break;\n        case '\\x05':\n          uVar1 = process_FC5(this,regs,u8size);\n          break;\n        case '\\x06':\n          uVar1 = process_FC6(this,regs,u8size);\n          break;\n        case '\\x0f':\n          uVar1 = process_FC15(this,regs,u8size);\n          break;\n        case '\\x10':\n          uVar1 = process_FC16(this,regs,u8size);\n        }\n      }\n      else {\n        if (u8exception != 0xff) {\n          buildException(this,u8exception);\n          sendTxBuffer(this);\n        }\n        this->u8lastError = u8exception;\n        uVar1 = u8exception;\n      }\n    }\n    else {\n      uVar1 = '\\0';\n    }\n  }\n  return uVar1;\n}\n\n", 
            "called": [
                "process_FC3", 
                "validateRequest", 
                "getRxBuffer", 
                "millis", 
                "process_FC5", 
                "process_FC6", 
                "buildException", 
                "sendTxBuffer", 
                "process_FC15", 
                "process_FC1", 
                "process_FC16"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000b54", 
            "calling": [
                "loop"
            ], 
            "imported": false, 
            "current_name": "poll"
        }, 
        "std.isra.0": {
            "renaming": {}, 
            "code": "\nvoid std_isra_0(undefined4 *param_1,undefined2 param_2,undefined2 param_3)\n\n{\n  undefined4 uVar1;\n  \n  *param_1 = 0;\n  param_1[1] = 0;\n  param_1[2] = 0;\n  *(undefined2 *)(param_1 + 3) = param_2;\n  param_1[0x19] = 0;\n  *(undefined2 *)((int)param_1 + 0xe) = param_3;\n  param_1[4] = 0;\n  param_1[5] = 0;\n  param_1[6] = 0;\n  memset(param_1 + 0x17,0,8);\n  param_1[9] = DAT_08005364;\n  param_1[10] = DAT_08005368;\n  param_1[0xb] = DAT_0800536c;\n  uVar1 = DAT_08005370;\n  param_1[8] = param_1;\n  param_1[0xc] = uVar1;\n  return;\n}\n\n", 
            "called": [
                "memset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800532c", 
            "calling": [
                "__sinit"
            ], 
            "imported": false, 
            "current_name": "std.isra.0"
        }, 
        "calcCRC": {
            "renaming": {}, 
            "code": "\nuint16_t __thiscall Modbus::calcCRC(Modbus *this,uint8_t u8length)\n\n{\n  byte bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  uVar2 = 0xffff;\n  for (uVar4 = 0; uVar4 < u8length; uVar4 = uVar4 + 1 & 0xff) {\n    uVar2 = uVar2 ^ this->au8Buffer[uVar4];\n    for (bVar1 = 1; bVar1 < 9; bVar1 = bVar1 + 1) {\n      uVar3 = uVar2 & 1;\n      uVar2 = uVar2 >> 1;\n      if (uVar3 != 0) {\n        uVar2 = uVar2 ^ 0xa001;\n      }\n    }\n  }\n  return (ushort)(uVar2 << 8) | (ushort)(uVar2 >> 8);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000728", 
            "calling": [
                "sendTxBuffer"
            ], 
            "imported": false, 
            "current_name": "calcCRC"
        }, 
        "HAL_GPIO_Init": {
            "renaming": {}, 
            "code": "\nvoid HAL_GPIO_Init(GPIO_TypeDef *GPIOx,GPIO_InitTypeDef *GPIO_Init)\n\n{\n  uint *puVar1;\n  uint *puVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint32_t uVar7;\n  int iVar8;\n  uint uVar9;\n  int iVar10;\n  uint32_t tmpreg;\n  \n  for (uVar5 = 0; uVar5 < 0x10; uVar5 = uVar5 + 1) {\n    uVar4 = 1 << (uVar5 & 0xff);\n    uVar6 = uVar4 & GPIO_Init->Pin;\n    if (uVar4 == uVar6) {\n      if ((GPIO_Init->Mode == 2) || (GPIO_Init->Mode == 0x12)) {\n        iVar10 = (uVar5 & 7) << 2;\n        GPIOx->AFR[uVar5 >> 3] =\n             GPIOx->AFR[uVar5 >> 3] & ~(0xf << iVar10) | GPIO_Init->Alternate << iVar10;\n      }\n      uVar9 = uVar5 << 1;\n      uVar3 = ~(3 << (uVar9 & 0xff));\n      GPIOx->MODER = GPIOx->MODER & uVar3 | (GPIO_Init->Mode & 3) << (uVar9 & 0xff);\n      uVar7 = GPIO_Init->Mode;\n      if (((uVar7 - 1 < 2) || (uVar7 == 0x11)) || (uVar7 == 0x12)) {\n        GPIOx->OSPEEDR = GPIOx->OSPEEDR & uVar3 | GPIO_Init->Speed << (uVar9 & 0xff);\n        GPIOx->OTYPER =\n             GPIOx->OTYPER & ~uVar4 | ((GPIO_Init->Mode << 0x1b) >> 0x1f) << (uVar5 & 0xff);\n      }\n      GPIOx->PUPDR = uVar3 & GPIOx->PUPDR | GPIO_Init->Pull << (uVar9 & 0xff);\n      if ((GPIO_Init->Mode & 0x10000000) != 0) {\n        *(uint *)(DAT_0800118c + 0x44) = *(uint *)(DAT_0800118c + 0x44) | 0x4000;\n        iVar10 = (uVar5 & 3) << 2;\n        if (GPIOx == DAT_08001190) {\n          iVar8 = 0;\n        }\n        else if (GPIOx == DAT_08001194) {\n          iVar8 = 1;\n        }\n        else if (GPIOx == (GPIO_TypeDef *)&DAT_08001194[0x19].BSRR) {\n          iVar8 = 2;\n        }\n        else if (GPIOx == (GPIO_TypeDef *)&DAT_08001194[0x33].OSPEEDR) {\n          iVar8 = 3;\n        }\n        else if (GPIOx == (GPIO_TypeDef *)DAT_08001194[0x4c].AFR) {\n          iVar8 = 4;\n        }\n        else if (GPIOx == (GPIO_TypeDef *)&DAT_08001194[0x66].IDR) {\n          iVar8 = 5;\n        }\n        else if (GPIOx == DAT_08001194 + 0x80) {\n          iVar8 = 6;\n        }\n        else if (GPIOx == (GPIO_TypeDef *)&DAT_08001194[0x99].BSRR) {\n          iVar8 = 7;\n        }\n        else if (GPIOx == (GPIO_TypeDef *)&DAT_08001194[0xb3].OSPEEDR) {\n          iVar8 = 8;\n        }\n        else if (GPIOx == (GPIO_TypeDef *)DAT_08001194[0xcc].AFR) {\n          iVar8 = 9;\n        }\n        else {\n          iVar8 = 10;\n        }\n        *(uint *)(DAT_08001184 + ((uVar5 >> 2) + 2) * 4) =\n             *(uint *)(DAT_08001184 + ((uVar5 >> 2) + 2) * 4) & ~(0xf << iVar10) | iVar8 << iVar10;\n        puVar1 = DAT_08001188;\n        uVar4 = ~uVar6;\n        uVar3 = *DAT_08001188 & uVar4;\n        if ((GPIO_Init->Mode & 0x10000) != 0) {\n          uVar3 = uVar6 | *DAT_08001188;\n        }\n        *DAT_08001188 = uVar3;\n        puVar2 = DAT_08001188;\n        uVar3 = uVar4 & puVar1[1];\n        if ((GPIO_Init->Mode & 0x20000) != 0) {\n          uVar3 = uVar6 | puVar1[1];\n        }\n        DAT_08001188[1] = uVar3;\n        puVar1 = DAT_08001188;\n        uVar3 = uVar4 & puVar2[2];\n        if ((GPIO_Init->Mode & 0x100000) != 0) {\n          uVar3 = uVar6 | puVar2[2];\n        }\n        DAT_08001188[2] = uVar3;\n        uVar4 = uVar4 & puVar1[3];\n        if ((GPIO_Init->Mode & 0x200000) != 0) {\n          uVar4 = uVar6 | puVar1[3];\n        }\n        DAT_08001188[3] = uVar4;\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000fb4", 
            "calling": [
                "uart_init", 
                "digital_io_init"
            ], 
            "imported": false, 
            "current_name": "HAL_GPIO_Init"
        }, 
        "__assert_func": {
            "renaming": {}, 
            "code": "\nvoid __assert_func(undefined4 param_1,undefined4 param_2,undefined *param_3,undefined4 param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  \n  puVar1 = PTR_s__08004840;\n  puVar2 = PTR_s__08004840;\n  if (param_3 != (undefined *)0x0) {\n    puVar1 = param_3;\n    puVar2 = PTR_s___function__08004838;\n  }\n  fiprintf(*(FILE **)(*(int *)PTR__impure_ptr_08004834 + 0xc),\n           PTR_s_assertion___s__failed__file___s__0800483c,param_4,param_1,param_2,puVar2,puVar1,\n           param_4);\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
            "called": [
                "abort", 
                "fiprintf"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004808", 
            "calling": [
                "begin"
            ], 
            "imported": false, 
            "current_name": "__assert_func"
        }, 
        "USART6_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid USART6_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART6_IRQn);\n  HAL_UART_IRQHandler(*(UART_HandleTypeDef **)(PTR_uart_handlers_08004060 + 0x14));\n  return;\n}\n\n", 
            "called": [
                "HAL_UART_IRQHandler", 
                "HAL_NVIC_ClearPendingIRQ"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800404c", 
            "calling": [], 
            "imported": false, 
            "current_name": "USART6_IRQHandler"
        }, 
        "raise": {
            "renaming": {}, 
            "code": "\nint raise(int __sig)\n\n{\n  int iVar1;\n  \n  iVar1 = _raise_r(*(undefined4 *)PTR__impure_ptr_080055dc,__sig);\n  return iVar1;\n}\n\n", 
            "called": [
                "_raise_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080055d0", 
            "calling": [
                "abort"
            ], 
            "imported": false, 
            "current_name": "raise"
        }, 
        "UART_WaitOnFlagUntilTimeout": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef\nUART_WaitOnFlagUntilTimeout\n          (UART_HandleTypeDef *huart,uint32_t Flag,FlagStatus Status,uint32_t Tickstart,\n          uint32_t Timeout)\n\n{\n  uint32_t uVar1;\n  \n  do {\n    if (((Flag & ~huart->Instance->SR) == 0) != (bool)Status) {\n      return HAL_OK;\n    }\n  } while ((Timeout == 0xffffffff) ||\n          ((Timeout != 0 && (uVar1 = HAL_GetTick(), uVar1 - Tickstart <= Timeout))));\n  huart->Instance->CR1 = huart->Instance->CR1 & 0xfffffe5f;\n  huart->Instance->CR3 = huart->Instance->CR3 & 0xfffffffe;\n  huart->gState = HAL_UART_STATE_READY;\n  huart->RxState = HAL_UART_STATE_READY;\n  huart->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n", 
            "called": [
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08002d0c", 
            "calling": [
                "HAL_UART_Transmit"
            ], 
            "imported": false, 
            "current_name": "UART_WaitOnFlagUntilTimeout"
        }, 
        "uart_init": {
            "renaming": {}, 
            "code": "\nvoid uart_init(serial_t *obj)\n\n{\n  USART_TypeDef *pUVar1;\n  USART_TypeDef *pUVar2;\n  USART_TypeDef *pUVar3;\n  USART_TypeDef *pUVar4;\n  USART_TypeDef *pUVar5;\n  USART_TypeDef *pUVar6;\n  USART_TypeDef *pUVar7;\n  USART_TypeDef *pUVar8;\n  void *a;\n  void *b;\n  USART_TypeDef *pUVar9;\n  GPIO_TypeDef *pGVar10;\n  uint32_t uVar11;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (obj != (serial_t *)0x0) {\n    a = pinmap_peripheral(obj->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08003c58);\n    b = pinmap_peripheral(obj->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08003c5c);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(PTR_s_ERROR__at_least_one_UART_pin_has_08003c84);\n    }\n    else {\n      pUVar9 = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      obj->uart = pUVar9;\n      pUVar8 = DAT_08003c7c;\n      pUVar7 = DAT_08003c78;\n      pUVar6 = DAT_08003c74;\n      pUVar5 = DAT_08003c70;\n      pUVar4 = DAT_08003c6c;\n      pUVar3 = DAT_08003c68;\n      pUVar2 = DAT_08003c64;\n      pUVar1 = DAT_08003c60;\n      if (pUVar9 == (USART_TypeDef *)0x0) {\n        iprintf(PTR_s_ERROR__U_S_ART_pins_mismatch_08003c88);\n      }\n      else {\n        if (pUVar9 == DAT_08003c60) {\n          DAT_08003c60[0xa93].CR2 = DAT_08003c60[0xa93].CR2 | 0x10;\n          pUVar1[0xa93].CR2 = pUVar1[0xa93].CR2 & 0xffffffef;\n          pUVar1[0xa94].CR3 = pUVar1[0xa94].CR3 | 0x10;\n          obj->index = '\\0';\n          obj->irq = USART1_IRQn;\n        }\n        else if (pUVar9 == DAT_08003c64) {\n          DAT_08003c64[0x11dc].CR2 = DAT_08003c64[0x11dc].CR2 | 0x20000;\n          pUVar2[0x11dc].CR2 = pUVar2[0x11dc].CR2 & 0xfffdffff;\n          pUVar2[0x11dd].CR3 = pUVar2[0x11dd].CR3 | 0x20000;\n          obj->index = '\\x01';\n          obj->irq = USART2_IRQn;\n        }\n        else if (pUVar9 == DAT_08003c68) {\n          DAT_08003c68[0x11b8].SR = DAT_08003c68[0x11b8].SR | 0x40000;\n          pUVar3[0x11b8].SR = pUVar3[0x11b8].SR & 0xfffbffff;\n          pUVar3[0x11b9].DR = pUVar3[0x11b9].DR | 0x40000;\n          obj->index = '\\x02';\n          obj->irq = USART3_IRQn;\n        }\n        else if (pUVar9 == DAT_08003c6c) {\n          DAT_08003c6c[0x1193].CR1 = DAT_08003c6c[0x1193].CR1 | 0x80000;\n          pUVar4[0x1193].CR1 = pUVar4[0x1193].CR1 & 0xfff7ffff;\n          pUVar4[0x1194].CR2 = pUVar4[0x1194].CR2 | 0x80000;\n          obj->index = '\\x03';\n          obj->irq = UART4_IRQn;\n        }\n        else if (pUVar9 == DAT_08003c70) {\n          DAT_08003c70[0x116e].GTPR = DAT_08003c70[0x116e].GTPR | 0x100000;\n          pUVar5[0x116e].GTPR = pUVar5[0x116e].GTPR & 0xffefffff;\n          pUVar5[0x1170].SR = pUVar5[0x1170].SR | 0x100000;\n          obj->index = '\\x04';\n          obj->irq = UART5_IRQn;\n        }\n        else if (pUVar9 == DAT_08003c74) {\n          DAT_08003c74[0xa6f].SR = DAT_08003c74[0xa6f].SR | 0x20;\n          pUVar6[0xa6f].SR = pUVar6[0xa6f].SR & 0xffffffdf;\n          pUVar6[0xa70].DR = pUVar6[0xa70].DR | 0x20;\n          obj->index = '\\x05';\n          obj->irq = USART6_IRQn;\n        }\n        else if (pUVar9 == DAT_08003c78) {\n          DAT_08003c78[0x1001].DR = DAT_08003c78[0x1001].DR | 0x40000000;\n          pUVar7[0x1001].DR = pUVar7[0x1001].DR & 0xbfffffff;\n          pUVar7[0x1002].BRR = pUVar7[0x1002].BRR | 0x40000000;\n          obj->index = '\\x06';\n          obj->irq = UART7_IRQn;\n        }\n        else if (pUVar9 == DAT_08003c7c) {\n          DAT_08003c7c[0xfdc].CR2 = DAT_08003c7c[0xfdc].CR2 | 0x80000000;\n          pUVar8[0xfdc].CR2 = pUVar8[0xfdc].CR2 & 0x7fffffff;\n          pUVar8[0xfdd].CR3 = pUVar8[0xfdd].CR3 | 0x80000000;\n          obj->index = '\\a';\n          obj->irq = UART8_IRQn;\n        }\n        pGVar10 = set_GPIO_Port_Clock((uint)((int)obj->pin_rx << 0x18) >> 0x1c);\n        uVar11 = pinmap_function(obj->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08003c5c);\n        GPIO_InitStruct.Pin = 1 << (obj->pin_rx & 0xfU) & 0xffff;\n        GPIO_InitStruct.Mode = (uVar11 >> 3 & 1) << 4 | uVar11 & 7;\n        GPIO_InitStruct.Pull = (uVar11 << 0x1a) >> 0x1e;\n        GPIO_InitStruct.Alternate = (uVar11 << 0x11) >> 0x19;\n        GPIO_InitStruct.Speed = 3;\n        HAL_GPIO_Init(pGVar10,&GPIO_InitStruct);\n        pGVar10 = set_GPIO_Port_Clock((uint)((int)obj->pin_tx << 0x18) >> 0x1c);\n        uVar11 = pinmap_function(obj->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08003c58);\n        GPIO_InitStruct.Pin = 1 << (obj->pin_tx & 0xfU) & 0xffff;\n        GPIO_InitStruct.Mode = (uVar11 >> 3 & 1) << 4 | uVar11 & 7;\n        GPIO_InitStruct.Pull = (uVar11 << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(pGVar10,&GPIO_InitStruct);\n        *(UART_HandleTypeDef **)(PTR_uart_handlers_08003c80 + (uint)obj->index * 4) = &obj->handle;\n        (obj->handle).Instance = obj->uart;\n        (obj->handle).Init.BaudRate = obj->baudrate;\n        (obj->handle).Init.WordLength = obj->databits;\n        (obj->handle).Init.StopBits = obj->stopbits;\n        (obj->handle).Init.Parity = obj->parity;\n        (obj->handle).Init.Mode = 0xc;\n        (obj->handle).Init.HwFlowCtl = 0;\n        (obj->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&obj->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n", 
            "called": [
                "pinmap_function", 
                "HAL_UART_Init", 
                "pinmap_merge_peripheral", 
                "iprintf", 
                "pinmap_peripheral", 
                "HAL_GPIO_Init", 
                "set_GPIO_Port_Clock"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003978", 
            "calling": [
                "begin", 
                "uart_debug_init"
            ], 
            "imported": false, 
            "current_name": "uart_init"
        }, 
        "__sseek": {
            "renaming": {}, 
            "code": "\nvoid __sseek(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  ushort uVar2;\n  bool bVar3;\n  \n  iVar1 = _lseek_r(param_1,(int)*(short *)(param_2 + 0xe));\n  bVar3 = iVar1 == -1;\n  if (bVar3) {\n    uVar2 = *(ushort *)(param_2 + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(param_2 + 0x54) = iVar1;\n    uVar2 = *(ushort *)(param_2 + 0xc) | 0x1000;\n  }\n  if (bVar3) {\n    *(ushort *)(param_2 + 0xc) = uVar2;\n  }\n  if (!bVar3) {\n    *(ushort *)(param_2 + 0xc) = uVar2;\n  }\n  return;\n}\n\n", 
            "called": [
                "_lseek_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005662", 
            "calling": [], 
            "imported": false, 
            "current_name": "__sseek"
        }, 
        "TIM8_BRK_TIM12_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid TIM8_BRK_TIM12_IRQHandler(void)\n\n{\n  if (*(TIM_HandleTypeDef **)(PTR_timer_handles_08003864 + 0x2c) != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(*(TIM_HandleTypeDef **)(PTR_timer_handles_08003864 + 0x2c));\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_IRQHandler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003854", 
            "calling": [], 
            "imported": false, 
            "current_name": "TIM8_BRK_TIM12_IRQHandler"
        }, 
        "initVariant": {
            "renaming": {}, 
            "code": "\nvoid initVariant(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004646", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "initVariant"
        }, 
        "HAL_DAC_MspDeInit": {
            "renaming": {}, 
            "code": "\nvoid HAL_DAC_MspDeInit(DAC_HandleTypeDef *hdac)\n\n{\n  *(uint *)(DAT_080033d4 + 0x40) = *(uint *)(DAT_080033d4 + 0x40) & 0xdfffffff;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080033c8", 
            "calling": [
                "HAL_DAC_DeInit"
            ], 
            "imported": false, 
            "current_name": "HAL_DAC_MspDeInit"
        }, 
        "pwm_stop": {
            "renaming": {}, 
            "code": "\nvoid pwm_stop(PinName_conflict pin)\n\n{\n  uint32_t Channel;\n  uint32_t uVar1;\n  TIM_HandleTypeDef timHandle;\n  \n  timHandle.Instance =\n       (TIM_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)PTR_PinMap_PWM_08003468);\n  if ((timHandle.Instance != (TIM_TypeDef *)0x0) &&\n     ((((Channel = get_pwm_channel(pin), Channel == 0 || (Channel == 4)) || (Channel == 8)) ||\n      ((Channel == 0xc || (Channel == 0x18)))))) {\n    uVar1 = pinmap_function(pin,(PinMap_conflict *)PTR_PinMap_PWM_08003468);\n    if ((uVar1 & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(&timHandle,Channel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(&timHandle,Channel);\n    }\n    HAL_TIM_PWM_DeInit(&timHandle);\n  }\n  return;\n}\n\n", 
            "called": [
                "get_pwm_channel", 
                "pinmap_function", 
                "HAL_TIM_PWM_Stop", 
                "HAL_TIM_PWM_DeInit", 
                "pinmap_peripheral", 
                "HAL_TIMEx_PWMN_Stop"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003414", 
            "calling": [
                "pinMode"
            ], 
            "imported": false, 
            "current_name": "pwm_stop"
        }, 
        "_lseek": {
            "renaming": {}, 
            "code": "\nint _lseek(int file_UNUSED,int ptr_UNUSED,int dir_UNUSED)\n\n{\n  return 0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080040e4", 
            "calling": [
                "_lseek_r"
            ], 
            "imported": false, 
            "current_name": "_lseek"
        }, 
        "get_pwm_channel": {
            "renaming": {}, 
            "code": "\nuint32_t get_pwm_channel(PinName_conflict pin)\n\n{\n  uint32_t uVar1;\n  uint uVar2;\n  \n  uVar1 = pinmap_function(pin,(PinMap_conflict *)PTR_PinMap_PWM_080033c4);\n  uVar2 = (uVar1 << 0xc) >> 0x1b;\n  if (uVar2 == 3) {\n    return 8;\n  }\n  if (uVar2 != 4) {\n    if (uVar2 != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n", 
            "called": [
                "pinmap_function"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800339c", 
            "calling": [
                "pwm_stop"
            ], 
            "imported": false, 
            "current_name": "get_pwm_channel"
        }, 
        "read": {
            "renaming": {}, 
            "code": "\nssize_t __thiscall HardwareSerial::read(HardwareSerial *this,int __fd,void *__buf,size_t __nbytes)\n\n{\n  byte bVar1;\n  ushort uVar2;\n  \n  uVar2 = (this->_serial).rx_tail;\n  if ((uint)(this->_serial).rx_head != (uint)uVar2) {\n    bVar1 = (this->_serial).rx_buff[uVar2];\n    (this->_serial).rx_tail = uVar2 + 1 & 0x3f;\n    return (uint)bVar1;\n  }\n  return -1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004270", 
            "calling": [], 
            "imported": false, 
            "current_name": "read"
        }, 
        "HAL_TIM_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)\n\n{\n  TIM_TypeDef *pTVar1;\n  \n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 2) != 0) && ((pTVar1->DIER & 2) != 0)) {\n    pTVar1->SR = 0xfffffffd;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n    if ((htim->Instance->CCMR1 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 4) != 0) && ((pTVar1->DIER & 4) != 0)) {\n    pTVar1->SR = 0xfffffffb;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n    if ((htim->Instance->CCMR1 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 8) != 0) && ((pTVar1->DIER & 8) != 0)) {\n    pTVar1->SR = 0xfffffff7;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n    if ((htim->Instance->CCMR2 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 0x10) != 0) && ((pTVar1->DIER & 0x10) != 0)) {\n    pTVar1->SR = 0xffffffef;\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n    if ((htim->Instance->CCMR2 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 1) != 0) && ((pTVar1->DIER & 1) != 0)) {\n    pTVar1->SR = 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(htim);\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 0x80) != 0) && ((pTVar1->DIER & 0x80) != 0)) {\n    pTVar1->SR = 0xffffff7f;\n    HAL_TIMEx_BreakCallback(htim);\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 0x40) != 0) && ((pTVar1->DIER & 0x40) != 0)) {\n    pTVar1->SR = 0xffffffbf;\n    HAL_TIM_TriggerCallback(htim);\n  }\n  pTVar1 = htim->Instance;\n  if (((pTVar1->SR & 0x20) != 0) && ((pTVar1->DIER & 0x20) != 0)) {\n    pTVar1->SR = 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(htim);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_TIM_TriggerCallback", 
                "HAL_TIMEx_BreakCallback", 
                "HAL_TIM_IC_CaptureCallback", 
                "HAL_TIM_OC_DelayElapsedCallback", 
                "HAL_TIM_PWM_PulseFinishedCallback", 
                "HAL_TIMEx_CommutationCallback", 
                "HAL_TIM_PeriodElapsedCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080026ce", 
            "calling": [
                "TIM2_IRQHandler", 
                "TIM6_DAC_IRQHandler", 
                "TIM1_BRK_TIM9_IRQHandler", 
                "TIM1_TRG_COM_TIM11_IRQHandler", 
                "TIM4_IRQHandler", 
                "TIM1_UP_TIM10_IRQHandler", 
                "TIM5_IRQHandler", 
                "TIM3_IRQHandler", 
                "TIM8_TRG_COM_TIM14_IRQHandler", 
                "TIM7_IRQHandler", 
                "TIM8_UP_TIM13_IRQHandler", 
                "TIM8_BRK_TIM12_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIM_IRQHandler"
        }, 
        "HAL_Init": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef HAL_Init(void)\n\n{\n  uint *puVar1;\n  \n  puVar1 = DAT_08000e14;\n  *DAT_08000e14 = *DAT_08000e14 | 0x200;\n  *puVar1 = *puVar1 | 0x400;\n  *puVar1 = *puVar1 | 0x100;\n  HAL_NVIC_SetPriorityGrouping(3);\n  HAL_InitTick(0xf);\n  HAL_MspInit();\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_MspInit", 
                "HAL_InitTick", 
                "HAL_NVIC_SetPriorityGrouping"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000de4", 
            "calling": [
                "hw_config_init"
            ], 
            "imported": false, 
            "current_name": "HAL_Init"
        }, 
        "HAL_SYSTICK_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_SYSTICK_IRQHandler(void)\n\n{\n  HAL_SYSTICK_Callback();\n  return;\n}\n\n", 
            "called": [
                "HAL_SYSTICK_Callback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000f4e", 
            "calling": [
                "SysTick_Handler"
            ], 
            "imported": false, 
            "current_name": "HAL_SYSTICK_IRQHandler"
        }, 
        "HAL_RCC_OscConfig": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef_conflict *RCC_OscInitStruct)\n\n{\n  uint *puVar1;\n  HAL_StatusTypeDef HVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  bool bVar5;\n  uint32_t tmpreg;\n  \n  puVar1 = DAT_080022d0;\n  if (RCC_OscInitStruct == (RCC_OscInitTypeDef_conflict *)0x0) {\n    return HAL_ERROR;\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 1) != 0) {\n    if (((DAT_080022d0[2] & 0xc) == 4) ||\n       (((DAT_080022d0[2] & 0xc) == 8 && ((DAT_080022d0[1] & 0x400000) != 0)))) {\n      if (((*DAT_080022d0 & 0x20000) != 0) && (RCC_OscInitStruct->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      if (RCC_OscInitStruct->HSEState == 0x10000) {\n        *DAT_080022d0 = *DAT_080022d0 | 0x10000;\n      }\n      else if (RCC_OscInitStruct->HSEState == 0x50000) {\n        *DAT_080022d0 = *DAT_080022d0 | 0x40000;\n        *puVar1 = *puVar1 | 0x10000;\n      }\n      else {\n        *DAT_080022d0 = *DAT_080022d0 & 0xfffeffff;\n        *puVar1 = *puVar1 & 0xfffbffff;\n      }\n      if (RCC_OscInitStruct->HSEState == 0) {\n        uVar3 = HAL_GetTick();\n        while ((*DAT_080022d0 & 0x20000) != 0) {\n          uVar4 = HAL_GetTick();\n          if (100 < uVar4 - uVar3) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        uVar3 = HAL_GetTick();\n        while ((*DAT_080022d0 & 0x20000) == 0) {\n          uVar4 = HAL_GetTick();\n          if (100 < uVar4 - uVar3) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 2) != 0) {\n    if (((DAT_080022d0[2] & 0xc) == 0) ||\n       (((DAT_080022d0[2] & 0xc) == 8 && ((DAT_080022d0[1] & 0x400000) == 0)))) {\n      if (((*DAT_080022d0 & 2) != 0) && (RCC_OscInitStruct->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      *DAT_080022d0 = *DAT_080022d0 & 0xffffff07 | RCC_OscInitStruct->HSICalibrationValue << 3;\n    }\n    else if (RCC_OscInitStruct->HSIState == 0) {\n      *DAT_080022d4 = 0;\n      uVar3 = HAL_GetTick();\n      while ((*DAT_080022d0 & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_080022d4 = 1;\n      uVar3 = HAL_GetTick();\n      while ((*DAT_080022d0 & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n      *DAT_080022d0 = *DAT_080022d0 & 0xffffff07 | RCC_OscInitStruct->HSICalibrationValue << 3;\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 8) != 0) {\n    if (RCC_OscInitStruct->LSIState == 0) {\n      *DAT_080022d8 = 0;\n      uVar3 = HAL_GetTick();\n      while ((DAT_080022d0[0x1d] & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_080022d8 = 1;\n      uVar3 = HAL_GetTick();\n      while ((DAT_080022d0[0x1d] & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 4) != 0) {\n    bVar5 = (DAT_080022d0[0x10] & 0x10000000) == 0;\n    if (bVar5) {\n      DAT_080022d0[0x10] = DAT_080022d0[0x10] | 0x10000000;\n    }\n    if ((*DAT_080022dc & 0x100) == 0) {\n      *DAT_080022dc = *DAT_080022dc | 0x100;\n      uVar3 = HAL_GetTick();\n      while ((*DAT_080022dc & 0x100) == 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    puVar1 = DAT_080022d0;\n    if (RCC_OscInitStruct->LSEState == 1) {\n      DAT_080022d0[0x1c] = DAT_080022d0[0x1c] | 1;\n    }\n    else if (RCC_OscInitStruct->LSEState == 5) {\n      DAT_080022d0[0x1c] = DAT_080022d0[0x1c] | 4;\n      puVar1[0x1c] = puVar1[0x1c] | 1;\n    }\n    else {\n      DAT_080022d0[0x1c] = DAT_080022d0[0x1c] & 0xfffffffe;\n      puVar1[0x1c] = puVar1[0x1c] & 0xfffffffb;\n    }\n    if (RCC_OscInitStruct->LSEState == 0) {\n      uVar3 = HAL_GetTick();\n      while ((DAT_080022d0[0x1c] & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (5000 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      uVar3 = HAL_GetTick();\n      while ((DAT_080022d0[0x1c] & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (5000 < uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (bVar5) {\n      DAT_080023ac[0x10] = DAT_080023ac[0x10] & 0xefffffff;\n    }\n  }\n  uVar3 = (RCC_OscInitStruct->PLL).PLLState;\n  if (uVar3 == 0) {\n    HVar2 = HAL_OK;\n  }\n  else if ((DAT_080023ac[2] & 0xc) == 8) {\n    HVar2 = HAL_ERROR;\n  }\n  else if (uVar3 == 2) {\n    *DAT_080023b0 = 0;\n    uVar3 = HAL_GetTick();\n    do {\n      if ((*DAT_080023ac & 0x2000000) == 0) {\n        DAT_080023ac[1] =\n             (RCC_OscInitStruct->PLL).PLLSource | (RCC_OscInitStruct->PLL).PLLM |\n             (RCC_OscInitStruct->PLL).PLLN << 6 |\n             (((RCC_OscInitStruct->PLL).PLLP >> 1) - 1) * 0x10000 |\n             (RCC_OscInitStruct->PLL).PLLQ << 0x18;\n        *DAT_080023b0 = 1;\n        uVar3 = HAL_GetTick();\n        do {\n          if ((*DAT_080023ac & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          uVar4 = HAL_GetTick();\n        } while (uVar4 - uVar3 < 3);\n        return HAL_TIMEOUT;\n      }\n      uVar4 = HAL_GetTick();\n    } while (uVar4 - uVar3 < 3);\n    HVar2 = HAL_TIMEOUT;\n  }\n  else {\n    *DAT_080023b0 = 0;\n    uVar3 = HAL_GetTick();\n    do {\n      if ((*DAT_080023ac & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      uVar4 = HAL_GetTick();\n    } while (uVar4 - uVar3 < 3);\n    HVar2 = HAL_TIMEOUT;\n  }\n  return HVar2;\n}\n\n", 
            "called": [
                "HAL_GetTick"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800201c", 
            "calling": [
                "SystemClock_Config"
            ], 
            "imported": false, 
            "current_name": "HAL_RCC_OscConfig"
        }, 
        "get_dac_channel": {
            "renaming": {}, 
            "code": "\nuint32_t get_dac_channel(PinName_conflict pin)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = pinmap_function(pin,(PinMap_conflict *)PTR_PinMap_DAC_08003398);\n  if ((uVar1 << 0xc) >> 0x1b != 2) {\n    return 0;\n  }\n  return 0x10;\n}\n\n", 
            "called": [
                "pinmap_function"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003380", 
            "calling": [
                "dac_stop"
            ], 
            "imported": false, 
            "current_name": "get_dac_channel"
        }, 
        "memset": {
            "renaming": {}, 
            "code": "\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  undefined *puVar1;\n  \n  for (puVar1 = (undefined *)__s; puVar1 != (undefined *)(__n + (int)__s); puVar1 = puVar1 + 1) {\n    *puVar1 = (char)__c;\n  }\n  return __s;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080048cc", 
            "calling": [
                "std.isra.0", 
                "__sfp", 
                "__sfmoreglue"
            ], 
            "imported": false, 
            "current_name": "memset"
        }, 
        "HAL_TIMEx_CommutationCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800293c", 
            "calling": [
                "HAL_TIM_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_TIMEx_CommutationCallback"
        }, 
        "I2C_Slave_AF": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef I2C_Slave_AF(I2C_HandleTypeDef *hi2c)\n\n{\n  if (((hi2c->XferOptions == 4) || (hi2c->XferOptions == 8)) &&\n     (hi2c->State == HAL_I2C_STATE_LISTEN)) {\n    hi2c->XferOptions = DAT_08001714;\n    hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n    hi2c->Instance->SR1 = 0xfffffbff;\n    hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n    hi2c->PreviousState = 0;\n    hi2c->State = HAL_I2C_STATE_READY;\n    hi2c->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(hi2c);\n  }\n  else if (hi2c->State == HAL_I2C_STATE_BUSY_TX) {\n    hi2c->XferOptions = DAT_08001714;\n    hi2c->PreviousState = 0x21;\n    hi2c->State = HAL_I2C_STATE_READY;\n    hi2c->Mode = HAL_I2C_MODE_NONE;\n    hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffff8ff;\n    hi2c->Instance->SR1 = 0xfffffbff;\n    hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback(hi2c);\n  }\n  else {\n    hi2c->Instance->SR1 = 0xfffffbff;\n  }\n  return HAL_OK;\n}\n\n", 
            "called": [
                "HAL_I2C_ListenCpltCallback", 
                "HAL_I2C_SlaveTxCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001684", 
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "I2C_Slave_AF"
        }, 
        "millis": {
            "renaming": {}, 
            "code": "\nuint32_t millis(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = GetCurrentMilli();\n  return uVar1;\n}\n\n", 
            "called": [
                "GetCurrentMilli"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004204", 
            "calling": [
                "sendTxBuffer", 
                "poll"
            ], 
            "imported": false, 
            "current_name": "millis"
        }, 
        "I2C_ITError": {
            "renaming": {}, 
            "code": "\nvoid I2C_ITError(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_StatusTypeDef HVar1;\n  uint8_t *puVar2;\n  I2C_TypeDef *pIVar3;\n  \n  if ((byte)hi2c->State - 0x29 < 2) {\n    hi2c->PreviousState = 0;\n    hi2c->State = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((hi2c->State != HAL_I2C_STATE_ABORT) && ((hi2c->Instance->CR2 & 0x800) == 0)) {\n      hi2c->State = HAL_I2C_STATE_READY;\n    }\n    hi2c->PreviousState = 0;\n    hi2c->Mode = HAL_I2C_MODE_NONE;\n  }\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffff7ff;\n  pIVar3 = hi2c->Instance;\n  if ((pIVar3->CR2 & 0x800) == 0) {\n    if (hi2c->State == HAL_I2C_STATE_ABORT) {\n      hi2c->State = HAL_I2C_STATE_READY;\n      hi2c->ErrorCode = 0;\n      if ((pIVar3->SR1 & 0x40) != 0) {\n        puVar2 = hi2c->pBuffPtr;\n        hi2c->pBuffPtr = puVar2 + 1;\n        *puVar2 = (uint8_t)pIVar3->DR;\n      }\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(hi2c);\n    }\n    else {\n      if ((pIVar3->SR1 & 0x40) != 0) {\n        puVar2 = hi2c->pBuffPtr;\n        hi2c->pBuffPtr = puVar2 + 1;\n        *puVar2 = (uint8_t)pIVar3->DR;\n      }\n      HAL_I2C_ErrorCallback(hi2c);\n    }\n  }\n  else {\n    pIVar3->CR2 = pIVar3->CR2 & 0xfffff7ff;\n    if (hi2c->hdmatx->State == HAL_DMA_STATE_READY) {\n      hi2c->hdmarx->XferAbortCallback = DAT_08001bf4;\n      HVar1 = HAL_DMA_Abort_IT(hi2c->hdmarx);\n      if (HVar1 != HAL_OK) {\n        if ((hi2c->Instance->SR1 & 0x40) != 0) {\n          puVar2 = hi2c->pBuffPtr;\n          hi2c->pBuffPtr = puVar2 + 1;\n          *puVar2 = (uint8_t)hi2c->Instance->DR;\n        }\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffffe;\n        hi2c->State = HAL_I2C_STATE_READY;\n        (*hi2c->hdmarx->XferAbortCallback)(hi2c->hdmarx);\n      }\n    }\n    else {\n      hi2c->hdmatx->XferAbortCallback = DAT_08001bf4;\n      HVar1 = HAL_DMA_Abort_IT(hi2c->hdmatx);\n      if (HVar1 != HAL_OK) {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffffe;\n        hi2c->State = HAL_I2C_STATE_READY;\n        (*hi2c->hdmatx->XferAbortCallback)(hi2c->hdmatx);\n      }\n    }\n  }\n  if ((hi2c->State == HAL_I2C_STATE_LISTEN) && ((hi2c->ErrorCode & 4) != 0)) {\n    hi2c->XferOptions = DAT_08001bf8;\n    hi2c->PreviousState = 0;\n    hi2c->State = HAL_I2C_STATE_READY;\n    hi2c->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(hi2c);\n  }\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_ErrorCallback", 
                "HAL_I2C_ListenCpltCallback", 
                "HAL_I2C_AbortCpltCallback", 
                "HAL_DMA_Abort_IT"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001ab0", 
            "calling": [
                "HAL_I2C_ER_IRQHandler", 
                "I2C_Slave_STOPF"
            ], 
            "imported": false, 
            "current_name": "I2C_ITError"
        }, 
        "HAL_I2C_Slave_Sequential_Transmit_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef\nHAL_I2C_Slave_Sequential_Transmit_IT\n          (I2C_HandleTypeDef *hi2c,uint8_t *pData,uint16_t Size,uint32_t XferOptions)\n\n{\n  HAL_StatusTypeDef HVar1;\n  I2C_TypeDef *pIVar2;\n  uint32_t tmpreg;\n  \n  if (hi2c->State == HAL_I2C_STATE_LISTEN) {\n    if (pData == (uint8_t *)0x0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (Size == 0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (hi2c->Lock == HAL_LOCKED) {\n      HVar1 = HAL_BUSY;\n    }\n    else {\n      hi2c->Lock = HAL_LOCKED;\n      pIVar2 = hi2c->Instance;\n      if ((pIVar2->CR1 & 1) == 0) {\n        pIVar2->CR1 = pIVar2->CR1 | 1;\n      }\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffff7ff;\n      hi2c->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      hi2c->Mode = HAL_I2C_MODE_SLAVE;\n      HVar1 = HAL_OK;\n      hi2c->ErrorCode = 0;\n      hi2c->pBuffPtr = pData;\n      hi2c->XferCount = Size;\n      hi2c->XferOptions = XferOptions;\n      hi2c->XferSize = hi2c->XferCount;\n      hi2c->Lock = HAL_UNLOCKED;\n      hi2c->Instance->CR2 = hi2c->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    HVar1 = HAL_BUSY;\n  }\n  return HVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001460", 
            "calling": [
                "HAL_I2C_AddrCallback"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_Slave_Sequential_Transmit_IT"
        }, 
        "pin_in_pinmap": {
            "renaming": {}, 
            "code": "\n_Bool pin_in_pinmap(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  if (pin == NC) {\n    return false;\n  }\n  while( true ) {\n    if (map->pin == NC) {\n      return false;\n    }\n    if (pin == map->pin) break;\n    map = map + 1;\n  }\n  return true;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800355e", 
            "calling": [
                "pinMode"
            ], 
            "imported": false, 
            "current_name": "pin_in_pinmap"
        }, 
        "HAL_I2C_EV_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)\n\n{\n  I2C_TypeDef *pIVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  pIVar1 = hi2c->Instance;\n  uVar4 = pIVar1->SR2;\n  uVar2 = pIVar1->SR1;\n  uVar3 = pIVar1->CR2;\n  if ((hi2c->Mode == HAL_I2C_MODE_MASTER) || (hi2c->Mode == HAL_I2C_MODE_MEM)) {\n    if (((uVar2 & 0x10001) == 0) || ((uVar3 & 0x200) == 0)) {\n      if (((DAT_08001e60 & uVar2) == 0) || ((uVar3 & 0x200) == 0)) {\n        if (((DAT_08001e4c & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n          I2C_Master_ADDR(hi2c);\n        }\n      }\n      else {\n        I2C_Master_ADD10(hi2c);\n      }\n    }\n    else {\n      I2C_Master_SB(hi2c);\n    }\n    if ((DAT_08001e54 & uVar4) == 0) {\n      if ((((DAT_08001e64 & uVar2) != 0) && ((uVar3 & 0x400) != 0)) && ((DAT_08001e5c & uVar2) == 0)\n         ) {\n        I2C_MasterReceive_RXNE(hi2c);\n        return;\n      }\n      if (((DAT_08001e5c & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(hi2c);\n        return;\n      }\n    }\n    else {\n      if ((((DAT_08001e58 & uVar2) != 0) && ((uVar3 & 0x400) != 0)) && ((DAT_08001e5c & uVar2) == 0)\n         ) {\n        I2C_MasterTransmit_TXE(hi2c);\n        return;\n      }\n      if (((DAT_08001e5c & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(hi2c);\n        return;\n      }\n    }\n  }\n  else {\n    if (((DAT_08001e4c & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n      I2C_Slave_ADDR(hi2c);\n      return;\n    }\n    if (((DAT_08001e50 & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n      I2C_Slave_STOPF(hi2c);\n      return;\n    }\n    if ((DAT_08001e54 & uVar4) == 0) {\n      if ((((DAT_08001e64 & uVar2) != 0) && ((uVar3 & 0x400) != 0)) && ((DAT_08001e5c & uVar2) == 0)\n         ) {\n        I2C_SlaveReceive_RXNE(hi2c);\n        return;\n      }\n      if (((DAT_08001e5c & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(hi2c);\n      }\n    }\n    else {\n      if ((((DAT_08001e58 & uVar2) != 0) && ((uVar3 & 0x400) != 0)) && ((DAT_08001e5c & uVar2) == 0)\n         ) {\n        I2C_SlaveTransmit_TXE(hi2c);\n        return;\n      }\n      if (((DAT_08001e5c & uVar2) != 0) && ((uVar3 & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(hi2c);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "I2C_SlaveReceive_RXNE", 
                "I2C_MasterReceive_BTF", 
                "I2C_SlaveTransmit_BTF", 
                "I2C_MasterTransmit_TXE", 
                "I2C_Master_ADD10", 
                "I2C_SlaveTransmit_TXE", 
                "I2C_Master_SB", 
                "I2C_Slave_ADDR", 
                "I2C_MasterReceive_RXNE", 
                "I2C_Master_ADDR", 
                "I2C_SlaveReceive_BTF", 
                "I2C_Slave_STOPF", 
                "I2C_MasterTransmit_BTF"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001d00", 
            "calling": [
                "I2C1_EV_IRQHandler", 
                "I2C3_EV_IRQHandler", 
                "I2C2_EV_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_EV_IRQHandler"
        }, 
        "process_FC16": {
            "renaming": {}, 
            "code": "\nint8_t __thiscall Modbus::process_FC16(Modbus *this,uint16_t *regs,uint8_t u8size)\n\n{\n  byte bVar1;\n  byte bVar2;\n  uint8_t uVar3;\n  uint16_t uVar4;\n  uint uVar5;\n  \n  bVar1 = this->au8Buffer[3];\n  bVar2 = this->au8Buffer[5];\n  this->au8Buffer[4] = '\\0';\n  this->au8Buffer[5] = bVar2;\n  this->u8BufferSize = '\\x06';\n  for (uVar5 = 0; uVar5 < bVar2; uVar5 = uVar5 + 1 & 0xff) {\n    uVar4 = makeWord(this->au8Buffer[uVar5 * 2 + 7],this->au8Buffer[uVar5 * 2 + 8]);\n    regs[bVar1 + uVar5] = uVar4;\n  }\n  uVar3 = this->u8BufferSize;\n  sendTxBuffer(this);\n  return uVar3 + '\\x02';\n}\n\n", 
            "called": [
                "sendTxBuffer", 
                "makeWord"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000b04", 
            "calling": [
                "poll"
            ], 
            "imported": false, 
            "current_name": "process_FC16"
        }, 
        "_malloc_r": {
            "renaming": {}, 
            "code": "\nuint _malloc_r(undefined4 *param_1,uint param_2)\n\n{\n  undefined *puVar1;\n  undefined4 uVar2;\n  uint *puVar3;\n  int iVar4;\n  uint uVar5;\n  uint *puVar6;\n  uint *puVar7;\n  uint uVar8;\n  \n  uVar8 = (param_2 + 3 & 0xfffffffc) + 8;\n  if (uVar8 < 0xc) {\n    uVar8 = 0xc;\n  }\n  if (((int)uVar8 < 0) || (uVar8 < param_2)) {\n    *param_1 = 0xc;\n  }\n  else {\n    __malloc_lock();\n    puVar1 = PTR___malloc_sbrk_start_08004a30;\n    puVar3 = *(uint **)PTR___malloc_free_list_08004a2c;\n    puVar6 = *(uint **)PTR___malloc_free_list_08004a2c;\n    while (puVar7 = puVar3, puVar7 != (uint *)0x0) {\n      uVar5 = *puVar7 - uVar8;\n      if (-1 < (int)uVar5) {\n        if (uVar5 < 0xc) {\n          if (puVar6 == puVar7) {\n            uVar8 = puVar6[1];\n          }\n          else {\n            uVar8 = puVar7[1];\n          }\n          if (puVar6 == puVar7) {\n            *(uint *)PTR___malloc_free_list_08004a2c = uVar8;\n            puVar7 = puVar6;\n          }\n          else {\n            puVar6[1] = uVar8;\n          }\n        }\n        else {\n          *puVar7 = uVar5;\n          *(uint *)((int)puVar7 + uVar5) = uVar8;\n          puVar7 = (uint *)((int)puVar7 + uVar5);\n        }\n        goto LAB_080049dc;\n      }\n      puVar6 = puVar7;\n      puVar3 = (uint *)puVar7[1];\n    }\n    if (*(int *)PTR___malloc_sbrk_start_08004a30 == 0) {\n      uVar2 = _sbrk_r(param_1);\n      *(undefined4 *)puVar1 = uVar2;\n    }\n    puVar3 = (uint *)_sbrk_r(param_1,uVar8);\n    if ((puVar3 != (uint *)0xffffffff) &&\n       ((puVar7 = (uint *)((int)puVar3 + 3U & 0xfffffffc), puVar3 == puVar7 ||\n        (iVar4 = _sbrk_r(param_1,(int)puVar7 - (int)puVar3), iVar4 != -1)))) {\n      *puVar7 = uVar8;\nLAB_080049dc:\n      __malloc_unlock(param_1);\n      uVar8 = (int)puVar7 + 0xbU & 0xfffffff8;\n      iVar4 = uVar8 - (int)(puVar7 + 1);\n      if (iVar4 != 0) {\n        *(int *)((int)puVar7 + iVar4) = -iVar4;\n        return uVar8;\n      }\n      return uVar8;\n    }\n    *param_1 = 0xc;\n    __malloc_unlock(param_1);\n  }\n  return 0;\n}\n\n", 
            "called": [
                "_sbrk_r", 
                "__malloc_unlock", 
                "__malloc_lock"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004978", 
            "calling": [
                "__smakebuf_r", 
                "__sfmoreglue"
            ], 
            "imported": false, 
            "current_name": "_malloc_r"
        }, 
        "process_FC15": {
            "renaming": {}, 
            "code": "\nint8_t __thiscall Modbus::process_FC15(Modbus *this,uint16_t *regs,uint8_t u8size)\n\n{\n  uint16_t uVar1;\n  uint16_t uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  \n  uVar1 = makeWord(this->au8Buffer[2],this->au8Buffer[3]);\n  uVar2 = makeWord(this->au8Buffer[4],this->au8Buffer[5]);\n  uVar4 = 0;\n  uVar7 = 7;\n  for (uVar3 = 0; uVar3 < uVar2; uVar3 = uVar3 + 1 & 0xffff) {\n    uVar6 = (uVar3 + uVar1) * 0x100000 >> 0x18;\n    uVar5 = uVar3 + uVar1 & 0xf;\n    if (((int)(uint)this->au8Buffer[uVar7] >> uVar4 & 1U) == 0) {\n      regs[uVar6] = regs[uVar6] & ~(ushort)(1 << uVar5);\n    }\n    else {\n      regs[uVar6] = (ushort)(1 << uVar5) | regs[uVar6];\n    }\n    uVar4 = uVar4 + 1 & 0xff;\n    if (7 < uVar4) {\n      uVar7 = uVar7 + 1 & 0xff;\n      uVar4 = 0;\n    }\n  }\n  this->u8BufferSize = '\\x06';\n  sendTxBuffer(this);\n  return '\\b';\n}\n\n", 
            "called": [
                "sendTxBuffer", 
                "makeWord"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000a7a", 
            "calling": [
                "poll"
            ], 
            "imported": false, 
            "current_name": "process_FC15"
        }, 
        "I2C_DMAAbort": {
            "renaming": {}, 
            "code": "\nvoid I2C_DMAAbort(DMA_HandleTypeDef *hdma)\n\n{\n  I2C_HandleTypeDef *hi2c;\n  \n  hi2c = (I2C_HandleTypeDef *)hdma->Parent;\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n  hi2c->XferCount = 0;\n  hi2c->hdmatx->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  hi2c->hdmarx->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  if (hi2c->State != HAL_I2C_STATE_ABORT) {\n    hi2c->State = HAL_I2C_STATE_READY;\n    hi2c->Mode = HAL_I2C_MODE_NONE;\n    hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffffe;\n    HAL_I2C_ErrorCallback(hi2c);\n    return;\n  }\n  hi2c->State = HAL_I2C_STATE_READY;\n  hi2c->Mode = HAL_I2C_MODE_NONE;\n  hi2c->ErrorCode = 0;\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffffe;\n  HAL_I2C_AbortCpltCallback(hi2c);\n  return;\n}\n\n", 
            "called": [
                "HAL_I2C_ErrorCallback", 
                "HAL_I2C_AbortCpltCallback"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001f3c", 
            "calling": [], 
            "imported": false, 
            "current_name": "I2C_DMAAbort"
        }, 
        "__swrite": {
            "renaming": {}, 
            "code": "\nvoid __swrite(undefined4 param_1,int param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x17) < 0) {\n    _lseek_r(param_1,(int)*(short *)(param_2 + 0xe),0,2);\n  }\n  *(ushort *)(param_2 + 0xc) = *(ushort *)(param_2 + 0xc) & 0xefff;\n  _write_r(param_1,(int)*(short *)(param_2 + 0xe),param_3,param_4);\n  return;\n}\n\n", 
            "called": [
                "_write_r", 
                "_lseek_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800562a", 
            "calling": [], 
            "imported": false, 
            "current_name": "__swrite"
        }, 
        "HAL_I2C_MemRxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001902", 
            "calling": [
                "I2C_MasterReceive_BTF", 
                "I2C_MasterReceive_RXNE"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_MemRxCpltCallback"
        }, 
        "USART2_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid USART2_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART2_IRQn);\n  HAL_UART_IRQHandler(*(UART_HandleTypeDef **)(PTR_uart_handlers_08004000 + 4));\n  return;\n}\n\n", 
            "called": [
                "HAL_UART_IRQHandler", 
                "HAL_NVIC_ClearPendingIRQ"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003fec", 
            "calling": [], 
            "imported": false, 
            "current_name": "USART2_IRQHandler"
        }, 
        "HAL_GPIO_WritePin": {
            "renaming": {}, 
            "code": "\nvoid HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx,uint16_t GPIO_Pin,GPIO_PinState PinState)\n\n{\n  if (PinState == GPIO_PIN_RESET) {\n    GPIOx->BSRR = (uint)GPIO_Pin << 0x10;\n    return;\n  }\n  GPIOx->BSRR = (uint)GPIO_Pin;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001198", 
            "calling": [
                "digital_io_write"
            ], 
            "imported": false, 
            "current_name": "HAL_GPIO_WritePin"
        }, 
        "premain": {
            "renaming": {}, 
            "code": "\nvoid premain(void)\n\n{\n  EVP_PKEY_CTX *ctx;\n  \n  ctx = (EVP_PKEY_CTX *)0x3;\n  HAL_NVIC_SetPriorityGrouping(3);\n  init(ctx);\n  return;\n}\n\n", 
            "called": [
                "init", 
                "HAL_NVIC_SetPriorityGrouping"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004648", 
            "calling": [
                "__libc_init_array"
            ], 
            "imported": false, 
            "current_name": "premain"
        }, 
        "serial_rx_active": {
            "renaming": {}, 
            "code": "\nuint8_t serial_rx_active(serial_t *obj)\n\n{\n  HAL_UART_StateTypeDef HVar1;\n  \n  HVar1 = HAL_UART_GetState(*(UART_HandleTypeDef **)\n                             (PTR_uart_handlers_08003df0 + (uint)obj->index * 4));\n  return (HVar1 & 0x22U) == 0x22;\n}\n\n", 
            "called": [
                "HAL_UART_GetState"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08003dd0", 
            "calling": [
                "uart_getc", 
                "uart_attach_rx_callback"
            ], 
            "imported": false, 
            "current_name": "serial_rx_active"
        }, 
        "HAL_I2C_EnableListen_IT": {
            "renaming": {}, 
            "code": "\nHAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)\n\n{\n  I2C_TypeDef *pIVar1;\n  \n  if (hi2c->State != HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  hi2c->State = HAL_I2C_STATE_LISTEN;\n  pIVar1 = hi2c->Instance;\n  if ((pIVar1->CR1 & 1) == 0) {\n    pIVar1->CR1 = pIVar1->CR1 | 1;\n  }\n  hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n  hi2c->Instance->CR2 = hi2c->Instance->CR2 | 0x300;\n  return HAL_OK;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001578", 
            "calling": [
                "HAL_I2C_ErrorCallback", 
                "HAL_I2C_ListenCpltCallback"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_EnableListen_IT"
        }, 
        "sendTxBuffer": {
            "renaming": {}, 
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080007ec */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nvoid __thiscall Modbus::sendTxBuffer(Modbus *this)\n\n{\n  byte u8length;\n  uint16_t uVar1;\n  int iVar2;\n  uint32_t uVar3;\n  uint uVar4;\n  \n  u8length = this->u8BufferSize;\n  uVar1 = calcCRC(this,u8length);\n  this->au8Buffer[u8length] = (uint8_t)((uint)uVar1 >> 8);\n  uVar4 = u8length + 1 & 0xff;\n  this->au8Buffer[uVar4] = (uint8_t)uVar1;\n  this->u8BufferSize = (char)uVar4 + '\\x01';\n  if (1 < this->u8txenpin) {\n    digitalWrite((uint)this->u8txenpin,1);\n  }\n  if (this->u8serno < 4) {\n    (*(this->port->super_Stream).super_Print._vptr_Print[1])\n              (this->port,this->au8Buffer,(uint)this->u8BufferSize);\n  }\n  if (1 < this->u8txenpin) {\n    digitalWrite((uint)this->u8txenpin,0);\n  }\n  if (this->u8serno < 4) {\n    do {\n      iVar2 = (*(this->port->super_Stream).super_Print._vptr_Print[3])();\n    } while (-1 < iVar2);\n  }\n  this->u8BufferSize = '\\0';\n  uVar3 = millis();\n  this->u32timeOut = uVar3 + this->u16timeOut;\n  this->u16OutCnt = this->u16OutCnt + 1;\n  return;\n}\n\n", 
            "called": [
                "millis", 
                "digitalWrite", 
                "calcCRC"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800076c", 
            "calling": [
                "process_FC3", 
                "process_FC5", 
                "process_FC6", 
                "process_FC15", 
                "poll", 
                "process_FC1", 
                "process_FC16"
            ], 
            "imported": false, 
            "current_name": "sendTxBuffer"
        }, 
        "SystemClock_Config": {
            "renaming": {}, 
            "code": "\nvoid SystemClock_Config(void)\n\n{\n  uint32_t uVar1;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  RCC_OscInitTypeDef RCC_OscInitStruct;\n  RCC_ClkInitTypeDef RCC_ClkInitStruct;\n  \n  *(uint *)(DAT_08000d30 + 0x40) = *(uint *)(DAT_08000d30 + 0x40) | 0x10000000;\n  *DAT_08000d34 = *DAT_08000d34 | 0xc000;\n  RCC_OscInitStruct.OscillatorType = 1;\n  RCC_OscInitStruct.HSEState = 0x50000;\n  RCC_OscInitStruct.PLL.PLLState = 2;\n  RCC_OscInitStruct.PLL.PLLSource = 0x400000;\n  RCC_OscInitStruct.PLL.PLLM = 8;\n  RCC_OscInitStruct.PLL.PLLN = 0x150;\n  RCC_OscInitStruct.PLL.PLLP = 2;\n  RCC_OscInitStruct.PLL.PLLQ = 7;\n  HAL_RCC_OscConfig((RCC_OscInitTypeDef_conflict *)&RCC_OscInitStruct);\n  HAL_PWREx_EnableOverDrive();\n  RCC_ClkInitStruct.ClockType = 0xf;\n  RCC_ClkInitStruct.SYSCLKSource = 2;\n  RCC_ClkInitStruct.AHBCLKDivider = 0;\n  RCC_ClkInitStruct.APB1CLKDivider = 0x1400;\n  RCC_ClkInitStruct.APB2CLKDivider = 0x1000;\n  HAL_RCC_ClockConfig((RCC_ClkInitTypeDef_conflict *)&RCC_ClkInitStruct,5);\n  uVar1 = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config((uint)((ulonglong)DAT_08000d38 * (ulonglong)uVar1 >> 0x26));\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n", 
            "called": [
                "HAL_RCC_OscConfig", 
                "HAL_SYSTICK_CLKSourceConfig", 
                "HAL_RCC_ClockConfig", 
                "HAL_NVIC_SetPriority", 
                "HAL_RCC_GetHCLKFreq", 
                "HAL_PWREx_EnableOverDrive", 
                "HAL_SYSTICK_Config"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000c8c", 
            "calling": [
                "hw_config_init"
            ], 
            "imported": false, 
            "current_name": "SystemClock_Config"
        }, 
        "__aeabi_atexit": {
            "renaming": {}, 
            "code": "\nvoid __aeabi_atexit(undefined4 param_1,undefined4 param_2)\n\n{\n  __cxa_atexit(param_2,param_1);\n  return;\n}\n\n", 
            "called": [
                "__cxa_atexit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080047fe", 
            "calling": [
                "__static_initialization_and_destruction_0"
            ], 
            "imported": false, 
            "current_name": "__aeabi_atexit"
        }, 
        "Modbus": {
            "renaming": {}, 
            "code": "\nModbus * __thiscall Modbus::Modbus(Modbus *this,uint8_t u8id,uint8_t u8serno,uint8_t u8txenpin)\n\n{\n  init(this,u8id,u8serno,u8txenpin);\n  return this;\n}\n\n", 
            "called": [
                "init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000682", 
            "calling": [
                "__static_initialization_and_destruction_0"
            ], 
            "imported": false, 
            "current_name": "Modbus"
        }, 
        "__swbuf_r": {
            "renaming": {}, 
            "code": "\nuint __swbuf_r(int param_1,uint param_2,int *param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined *puVar3;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_3 == (int *)PTR___sf_fake_stdin_080050c4) {\n    param_3 = *(int **)(param_1 + 4);\n  }\n  else if (param_3 == (int *)PTR___sf_fake_stdout_080050c8) {\n    param_3 = *(int **)(param_1 + 8);\n  }\n  else if (param_3 == (int *)PTR___sf_fake_stderr_080050cc) {\n    param_3 = *(int **)(param_1 + 0xc);\n  }\n  param_3[2] = param_3[6];\n  uVar2 = (uint)*(ushort *)(param_3 + 3);\n  iVar1 = uVar2 << 0x1c;\n  if (((iVar1 < 0) && (uVar2 = param_3[4], uVar2 != 0)) ||\n     (iVar1 = __swsetup_r(param_1,param_3,iVar1,uVar2,param_4), iVar1 == 0)) {\n    iVar1 = *param_3 - param_3[4];\n    param_2 = param_2 & 0xff;\n    if ((iVar1 < param_3[5]) || (iVar1 = _fflush_r(param_1,param_3), iVar1 == 0)) {\n      param_3[2] = param_3[2] + -1;\n      puVar3 = (undefined *)*param_3;\n      *param_3 = (int)(puVar3 + 1);\n      *puVar3 = (char)param_2;\n      if (iVar1 + 1 != param_3[5]) {\n        if (-1 < (int)((uint)*(ushort *)(param_3 + 3) << 0x1f)) {\n          return param_2;\n        }\n        if (param_2 != 10) {\n          return param_2;\n        }\n      }\n      iVar1 = _fflush_r(param_1,param_3);\n      if (iVar1 == 0) {\n        return param_2;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n", 
            "called": [
                "_fflush_r", 
                "__swsetup_r", 
                "__sinit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800502c", 
            "calling": [
                "__sfputc_r"
            ], 
            "imported": false, 
            "current_name": "__swbuf_r"
        }, 
        "printNumber": {
            "renaming": {}, 
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08004618 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n\nsize_t __thiscall Print::printNumber(Print *this,ulong n,uint8_t base)\n\n{\n  char cVar1;\n  size_t sVar2;\n  size_t sVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  char *__s;\n  char buf [33];\n  \n  uVar5 = (uint)base;\n  buf[32] = '\\0';\n  if (uVar5 < 2) {\n    uVar5 = 10;\n  }\n  __s = buf + 0x20;\n  do {\n    uVar6 = n / uVar5;\n    uVar4 = (n & 0xff) - ((int)(short)uVar6 * (int)(short)uVar5 & 0xffU) & 0xff;\n    __s = __s + -1;\n    cVar1 = (char)uVar4;\n    if (uVar4 < 10) {\n      cVar1 = cVar1 + '0';\n    }\n    else {\n      cVar1 = cVar1 + '7';\n    }\n    *__s = cVar1;\n    n = uVar6;\n  } while (uVar6 != 0);\n  if (__s == (char *)0x0) {\n    sVar3 = 0;\n  }\n  else {\n    sVar2 = strlen(__s);\n    sVar3 = (*this->_vptr_Print[1])(sVar2,__s,sVar2);\n  }\n  return sVar3;\n}\n\n", 
            "called": [
                "strlen"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080045c8", 
            "calling": [
                "print"
            ], 
            "imported": false, 
            "current_name": "printNumber"
        }, 
        "HAL_I2C_ER_IRQHandler": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  I2C_TypeDef *pIVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  pIVar2 = hi2c->Instance;\n  uVar3 = pIVar2->SR1;\n  uVar4 = pIVar2->CR2;\n  if (((uVar3 & DAT_08001f38) != 0) && ((uVar4 & 0x100) != 0)) {\n    hi2c->ErrorCode = hi2c->ErrorCode | 1;\n    pIVar2->SR1 = 0xfffffeff;\n  }\n  if (((uVar3 & 0x10200) != 0) && ((uVar4 & 0x100) != 0)) {\n    hi2c->ErrorCode = hi2c->ErrorCode | 2;\n    hi2c->Instance->SR1 = 0xfffffdff;\n  }\n  if (((uVar3 & 0x10400) != 0) && ((uVar4 & 0x100) != 0)) {\n    HVar1 = hi2c->State;\n    if (((hi2c->Mode == HAL_I2C_MODE_SLAVE) && (hi2c->XferCount == 0)) &&\n       (((HVar1 == HAL_I2C_STATE_BUSY_TX || (HVar1 == HAL_I2C_STATE_BUSY_TX_LISTEN)) ||\n        ((HVar1 == HAL_I2C_STATE_LISTEN && (hi2c->PreviousState == 0x21)))))) {\n      I2C_Slave_AF(hi2c);\n    }\n    else {\n      hi2c->ErrorCode = hi2c->ErrorCode | 4;\n      if (hi2c->Mode == HAL_I2C_MODE_MASTER) {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n      }\n      hi2c->Instance->SR1 = 0xfffffbff;\n    }\n  }\n  if (((uVar3 & 0x10800) != 0) && ((uVar4 & 0x100) != 0)) {\n    hi2c->ErrorCode = hi2c->ErrorCode | 8;\n    hi2c->Instance->SR1 = 0xfffff7ff;\n  }\n  if (hi2c->ErrorCode != 0) {\n    I2C_ITError(hi2c);\n  }\n  return;\n}\n\n", 
            "called": [
                "I2C_ITError", 
                "I2C_Slave_AF"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08001e68", 
            "calling": [
                "I2C1_ER_IRQHandler", 
                "I2C2_ER_IRQHandler", 
                "I2C3_ER_IRQHandler"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_ER_IRQHandler"
        }, 
        "__tcf_0": {
            "renaming": {}, 
            "code": "\nvoid __tcf_0(void *param_1)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  \n  puVar1 = PTR___malloc_free_list_080046ac;\n  while (puVar2 = puVar1, puVar2 != PTR_gpio_irq_conf_080046b0) {\n    puVar1 = puVar2 + -0x14;\n    if (*(code **)(puVar2 + -8) != (code *)0x0) {\n      (**(code **)(puVar2 + -8))(puVar2 + -0x10,puVar2 + -0x10,3);\n    }\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800468c", 
            "calling": [], 
            "imported": false, 
            "current_name": "__tcf_0"
        }, 
        "__do_global_dtors_aux": {
            "renaming": {}, 
            "code": "\nundefined * __do_global_dtors_aux(undefined *param_1)\n\n{\n  if (*PTR_completed_8667_080001c4 == '\\0') {\n    if (DAT_080001c8 != 0) {\n      param_1 = PTR__init_080001cc;\n    }\n    *PTR_completed_8667_080001c4 = 1;\n  }\n  return param_1;\n}\n\n", 
            "called": [
                "_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080001ac", 
            "calling": [], 
            "imported": false, 
            "current_name": "__do_global_dtors_aux"
        }, 
        "_fini": {
            "renaming": {}, 
            "code": "\nvoid _fini(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005a04", 
            "calling": [], 
            "imported": false, 
            "current_name": "_fini"
        }, 
        "HAL_I2C_MasterRxCpltCallback": {
            "renaming": {}, 
            "code": "\nvoid HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080015b8", 
            "calling": [
                "I2C_MasterReceive_BTF", 
                "I2C_MasterReceive_RXNE"
            ], 
            "imported": false, 
            "current_name": "HAL_I2C_MasterRxCpltCallback"
        }, 
        "digitalWrite": {
            "renaming": {}, 
            "code": "\nvoid digitalWrite(uint32_t ulPin,uint32_t ulVal)\n\n{\n  _Bool _Var1;\n  GPIO_TypeDef *port;\n  uint uVar2;\n  \n  if (ulPin < 0x60) {\n    uVar2 = (uint)*(short *)(PTR_digitalPin_080041fc + ulPin * 2);\n  }\n  else {\n    uVar2 = 0xffffffff;\n  }\n  if ((uVar2 != 0xffffffff) &&\n     (_Var1 = is_pin_configured((PinName_conflict)uVar2,(uint32_t *)PTR_g_digPinConfigured_08004200)\n     , _Var1)) {\n    port = get_GPIO_Port((uVar2 << 0x18) >> 0x1c);\n    digital_io_write(port,1 << (uVar2 & 0xf) & 0xffff,ulVal);\n  }\n  return;\n}\n\n", 
            "called": [
                "get_GPIO_Port", 
                "digital_io_write", 
                "is_pin_configured"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080041bc", 
            "calling": [
                "getRxBuffer", 
                "sendTxBuffer", 
                "begin"
            ], 
            "imported": false, 
            "current_name": "digitalWrite"
        }, 
        "pinmap_find_function": {
            "renaming": {}, 
            "code": "\nuint32_t pinmap_find_function(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  while( true ) {\n    if (map->pin == NC) {\n      return 0xffffffff;\n    }\n    if (map->pin == pin) break;\n    map = map + 1;\n  }\n  return map->function;\n}\n\n", 
            "called": [
                "pinmap_find_function"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0800352e", 
            "calling": [
                "pinmap_function", 
                "pinmap_find_function"
            ], 
            "imported": false, 
            "current_name": "pinmap_find_function"
        }, 
        "serialEventRun": {
            "renaming": {}, 
            "code": "\nvoid serialEventRun(void)\n\n{\n  if (DAT_0800435c != 0) {\n    HardwareSerial::available((HardwareSerial *)PTR_Serial3_08004360);\n  }\n  return;\n}\n\n", 
            "called": [
                "available"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08004338", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "serialEventRun"
        }, 
        "_fflush_r": {
            "renaming": {}, 
            "code": "\nundefined4 _fflush_r(int param_1,undefined *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 uVar1;\n  \n  if (*(int *)(param_2 + 0x10) != 0) {\n    if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n      __sinit();\n    }\n    if (param_2 == PTR___sf_fake_stdin_08005314) {\n      param_2 = *(undefined **)(param_1 + 4);\n    }\n    else if (param_2 == PTR___sf_fake_stdout_08005318) {\n      param_2 = *(undefined **)(param_1 + 8);\n    }\n    else if (param_2 == PTR___sf_fake_stderr_0800531c) {\n      param_2 = *(undefined **)(param_1 + 0xc);\n    }\n    if (*(short *)(param_2 + 0xc) != 0) {\n      uVar1 = __sflush_r(param_1,param_2,param_3,param_4);\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n", 
            "called": [
                "__sflush_r", 
                "__sinit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x080052cc", 
            "calling": [
                "__swbuf_r"
            ], 
            "imported": false, 
            "current_name": "_fflush_r"
        }, 
        "__sfp": {
            "renaming": {}, 
            "code": "\nint * __sfp(undefined4 *param_1)\n\n{\n  int *piVar1;\n  int *piVar2;\n  int iVar3;\n  int **ppiVar4;\n  \n  iVar3 = *(int *)PTR__global_impure_ptr_08005474;\n  if (*(int *)(iVar3 + 0x18) == 0) {\n    __sinit(iVar3);\n  }\n  ppiVar4 = (int **)(iVar3 + 0x48);\n  do {\n    piVar2 = ppiVar4[2];\n    piVar1 = ppiVar4[1];\n    while (piVar1 = (int *)((int)piVar1 + -1), -1 < (int)piVar1) {\n      if (*(short *)(piVar2 + 3) == 0) {\n        *(undefined2 *)((int)piVar2 + 0xe) = 0xffff;\n        *(undefined2 *)(piVar2 + 3) = 1;\n        piVar2[0x19] = 0;\n        *piVar2 = 0;\n        piVar2[2] = 0;\n        piVar2[1] = 0;\n        piVar2[4] = 0;\n        piVar2[5] = 0;\n        piVar2[6] = 0;\n        memset(piVar2 + 0x17,0,8);\n        piVar2[0xd] = 0;\n        piVar2[0xe] = 0;\n        piVar2[0x12] = 0;\n        piVar2[0x13] = 0;\n        return piVar2;\n      }\n      piVar2 = piVar2 + 0x1a;\n    }\n    if (*ppiVar4 == (int *)0x0) {\n      piVar1 = (int *)__sfmoreglue(param_1,4);\n      *ppiVar4 = piVar1;\n      if (piVar1 == (int *)0x0) {\n        *param_1 = 0xc;\n        return (int *)0x0;\n      }\n    }\n    ppiVar4 = (int **)*ppiVar4;\n  } while( true );\n}\n\n", 
            "called": [
                "memset", 
                "__sinit", 
                "__sfmoreglue"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08005400", 
            "calling": [
                "__sinit"
            ], 
            "imported": false, 
            "current_name": "__sfp"
        }, 
        "HAL_NVIC_EnableIRQ": {
            "renaming": {}, 
            "code": "\nvoid HAL_NVIC_EnableIRQ(IRQn_Type_conflict IRQn)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)IRQn;\n  if (-1 < (int)uVar1) {\n    *(int *)(DAT_08000edc + (uVar1 >> 5) * 4) = 1 << (uVar1 & 0x1f);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x08000ec4", 
            "calling": [
                "uart_attach_tx_callback", 
                "uart_attach_rx_callback"
            ], 
            "imported": false, 
            "current_name": "HAL_NVIC_EnableIRQ"
        }
    }, 
    "locked_functions": [], 
    "used_tokens": 0, 
    "layers": []
}