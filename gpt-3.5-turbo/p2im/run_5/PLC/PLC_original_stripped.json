{
    "functions": {
        "FUN_080001ac": {
            "entrypoint": "0x080001ac",
            "current_name": "initialize_completed_flag_080001ac",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080001b8) */\n\nundefined4 initializeCompletedFlag_080001ac(undefined4 inputValue)\n\n{\n  if ((char)completedFlag == '\\0') {\n    completedFlag._0_1_ = '\\x01';\n  }\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_080001ac": "initialize_completed_flag_080001ac",
                "param_1": "inputValue",
                "completed_8667": "completedFlag"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080001d0": {
            "entrypoint": "0x080001d0",
            "current_name": "FUNC_080001d0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080001d4) */\n/* WARNING: Removing unreachable block (ram,0x080001ee) */\n/* WARNING: Removing unreachable block (ram,0x080001e4) */\n/* WARNING: Removing unreachable block (ram,0x08000200) */\n/* WARNING: Removing unreachable block (ram,0x080001f4) */\n\nvoid FUNC_080001d0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080001d0": "FUNC_080001d0"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000218": {
            "entrypoint": "0x08000218",
            "current_name": "calculate_string_length_08000218",
            "code": "\nsize_t calculate_string_length_08000218(char *input_string)\n\n{\n  char current_character;\n  char *next_character;\n  char *current_position;\n  \n  current_position = input_string;\n  do {\n    next_character = current_position + 1;\n    current_character = *current_position;\n    current_position = next_character;\n  } while (current_character != '\\0');\n  return (size_t)(next_character + (-1 - (int)input_string));\n}\n\n",
            "renaming": {
                "FUN_08000218": "calculate_string_length_08000218",
                "__s": "input_string",
                "cVar1": "current_character",
                "pcVar2": "next_character",
                "pcVar3": "current_position"
            },
            "calling": [
                "printNumber"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000230": {
            "entrypoint": "0x08000230",
            "current_name": "find_byte_in_block_08000230",
            "code": "\nvoid * find_byte_in_block_08000230(void *block,int byte_to_find,size_t block_size)\n\n{\n  byte current_byte;\n  char is_current_byte_zero;\n  char is_second_byte_zero;\n  char is_third_byte_zero;\n  char is_fourth_byte_zero;\n  byte *next_byte_ptr;\n  uint *block_ptr;\n  byte *last_matching_byte_ptr;\n  uint byte_to_find_value;\n  uint block_alignment;\n  uint block_size_aligned;\n  uint current_byte_xor;\n  uint second_byte_xor;\n  bool is_second_xor_byte_nonzero;\n  bool is_third_xor_byte_nonzero;\n  bool is_fourth_xor_byte_nonzero;\n  bool is_fifth_xor_byte_nonzero;\n  \n  byte_to_find_value = byte_to_find & 0xff;\n  if ((int)block_size < 0x10) {\njoined_r0x08000290:\n    do {\n      if (block_size == 0) {\n        return (void *)0x0;\n      }\n                    /* WARNING: Load size is inaccurate */\n      block_ptr = (uint *)((int)block + 1);\n      current_byte = *block;\n      block_size = block_size - 1;\n      block = block_ptr;\n    } while (current_byte != byte_to_find_value);\n  }\n  else {\n    block_alignment = (uint)block & 7;\n    while( true ) {\n      if (block_alignment == 0) {\n        block_alignment = byte_to_find_value | byte_to_find_value << 8;\n        block_alignment = block_alignment | block_alignment << 0x10;\n        block_size_aligned = block_size & 0xfffffff8;\n        do {\n          block_ptr = (uint *)((int)block + 8);\n                    /* WARNING: Load size is inaccurate */\n          block_size_aligned = block_size_aligned - 8;\n          current_byte_xor = *block ^ block_alignment;\n          second_byte_xor = *(uint *)((int)block + 4) ^ block_alignment;\n          is_current_byte_zero = -((char)current_byte_xor == '\\0');\n          is_second_byte_zero = -((char)(current_byte_xor >> 8) == '\\0');\n          is_third_byte_zero = -((char)(current_byte_xor >> 0x10) == '\\0');\n          is_fourth_byte_zero = -((char)(current_byte_xor >> 0x18) == '\\0');\n          current_byte_xor = CONCAT13(is_fourth_byte_zero,CONCAT12(is_third_byte_zero,CONCAT11(is_second_byte_zero,is_current_byte_zero)));\n          is_second_xor_byte_nonzero = (char)second_byte_xor != '\\0';\n          is_third_xor_byte_nonzero = (char)(second_byte_xor >> 8) != '\\0';\n          is_fourth_xor_byte_nonzero = (char)(second_byte_xor >> 0x10) != '\\0';\n          is_fifth_xor_byte_nonzero = (char)(second_byte_xor >> 0x18) != '\\0';\n          second_byte_xor = CONCAT13(is_fifth_xor_byte_nonzero * is_fourth_byte_zero - !is_fifth_xor_byte_nonzero,\n                            CONCAT12(is_fourth_xor_byte_nonzero * is_third_byte_zero - !is_fourth_xor_byte_nonzero,\n                                     CONCAT11(is_third_xor_byte_nonzero * is_second_byte_zero - !is_third_xor_byte_nonzero,is_second_xor_byte_nonzero * is_current_byte_zero - !is_second_xor_byte_nonzero)));\n          if (second_byte_xor != 0) {\n            if (current_byte_xor == 0) {\n              last_matching_byte_ptr = (byte *)((int)block + 5);\n              current_byte_xor = second_byte_xor;\n            }\n            else {\n              last_matching_byte_ptr = (byte *)((int)block + 1);\n            }\n            if ((current_byte_xor & 1) == 0) {\n              is_second_xor_byte_nonzero = (current_byte_xor & 0x100) == 0;\n              next_byte_ptr = last_matching_byte_ptr + 1;\n              if (is_second_xor_byte_nonzero) {\n                is_second_xor_byte_nonzero = (current_byte_xor & 0x18000) == 0;\n                next_byte_ptr = last_matching_byte_ptr + 2;\n              }\n              last_matching_byte_ptr = next_byte_ptr;\n              if (is_second_xor_byte_nonzero) {\n                last_matching_byte_ptr = last_matching_byte_ptr + 1;\n              }\n            }\n            return last_matching_byte_ptr + -1;\n          }\n          block = block_ptr;\n        } while (block_size_aligned != 0);\n        block_size = block_size & 7;\n        goto joined_r0x08000290;\n      }\n                    /* WARNING: Load size is inaccurate */\n      block_ptr = (uint *)((int)block + 1);\n      block_size = block_size - 1;\n      if (*block == byte_to_find_value) break;\n      block_alignment = (uint)block_ptr & 7;\n      block = block_ptr;\n      if (block_size == 0) {\n        return (void *)0x0;\n      }\n    }\n  }\n  return (byte *)((int)block_ptr + -1);\n}\n\n",
            "renaming": {
                "FUN_08000230": "find_byte_in_block_08000230",
                "__s": "block",
                "__c": "byte_to_find",
                "__n": "block_size",
                "bVar1": "current_byte",
                "cVar2": "is_current_byte_zero",
                "cVar3": "is_second_byte_zero",
                "cVar4": "is_third_byte_zero",
                "cVar5": "is_fourth_byte_zero",
                "pbVar6": "next_byte_ptr",
                "puVar7": "block_ptr",
                "pbVar8": "last_matching_byte_ptr",
                "uVar9": "byte_to_find_value",
                "uVar10": "block_alignment",
                "uVar11": "block_size_aligned",
                "uVar12": "current_byte_xor",
                "uVar13": "second_byte_xor",
                "bVar14": "is_second_xor_byte_nonzero",
                "bVar15": "is_third_xor_byte_nonzero",
                "bVar16": "is_fourth_xor_byte_nonzero",
                "bVar17": "is_fifth_xor_byte_nonzero"
            },
            "calling": [
                "_printf_i",
                "_vfiprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080002d0": {
            "entrypoint": "0x080002d0",
            "current_name": "perform_division_or_throw_error_080002d0",
            "code": "\nvoid performDivisionOrThrowError_080002d0(int numerator,int denominator,int temp_param_3,int temp_param_4)\n\n{\n  if ((temp_param_4 == 0) && (temp_param_3 == 0)) {\n    if (denominator != 0 || numerator != 0) {\n      denominator = -1;\n      numerator = -1;\n    }\n    __aeabi_idiv0(numerator,denominator);\n    return;\n  }\n  __udivmoddi4();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080002d0": "perform_division_or_throw_error_080002d0",
                "param_1": "numerator",
                "param_2": "denominator",
                "param_3": "temp_param_3",
                "param_4": "temp_param_4"
            },
            "calling": [
                "HAL_RCC_GetSysClockFreq"
            ],
            "called": [
                "__aeabi_idiv0",
                "__udivmoddi4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000300": {
            "entrypoint": "0x08000300",
            "current_name": "calculate_division_remainder_08000300",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080005aa) */\n\nulonglong calculate_division_remainder_08000300(uint dividend,uint dividend_upper,uint divisor_upper,uint divisor,uint *remainder)\n\n{\n  ulonglong result;\n  uint quotient_lower;\n  uint quotient_upper;\n  uint temp_q1;\n  uint temp_rem1;\n  uint temp_q2;\n  uint temp_rem2;\n  uint temp_val;\n  uint temp_div;\n  int bit_shift;\n  bool carry_flag;\n  \n  if (divisor == 0) {\n    if (dividend_upper < divisor_upper) {\n      bit_shift = LZCOUNT(divisor_upper);\n      if (bit_shift != 0) {\n        divisor_upper = divisor_upper << bit_shift;\n        dividend_upper = dividend >> (0x20U - bit_shift & 0xff) | dividend_upper << bit_shift;\n        dividend = dividend << bit_shift;\n      }\n      temp_val = divisor_upper >> 0x10;\n      temp_q2 = dividend_upper / temp_val;\n      temp_rem1 = dividend >> 0x10 | (dividend_upper - temp_val * temp_q2) * 0x10000;\n      temp_q1 = temp_q2 * (divisor_upper & 0xffff);\n      quotient_upper = temp_q2;\n      if (temp_rem1 <= temp_q1 && temp_q1 - temp_rem1 != 0) {\n        carry_flag = CARRY4(temp_rem1,divisor_upper);\n        temp_rem1 = temp_rem1 + divisor_upper;\n        quotient_upper = temp_q2 - 1;\n        if ((carry_flag == false) && (temp_rem1 <= temp_q1 && temp_q1 - temp_rem1 != 0)) {\n          quotient_upper = temp_q2 - 2;\n          temp_rem1 = temp_rem1 + divisor_upper;\n        }\n      }\n      temp_q2 = (temp_rem1 - temp_q1) / temp_val;\n      temp_rem1 = dividend & 0xffff | ((temp_rem1 - temp_q1) - temp_val * temp_q2) * 0x10000;\n      temp_val = temp_q2 * (divisor_upper & 0xffff);\n      temp_q1 = temp_q2;\n      if (temp_rem1 <= temp_val && temp_val - temp_rem1 != 0) {\n        carry_flag = CARRY4(temp_rem1,divisor_upper);\n        temp_rem1 = temp_rem1 + divisor_upper;\n        temp_q1 = temp_q2 - 1;\n        if ((carry_flag == false) && (temp_rem1 <= temp_val && temp_val - temp_rem1 != 0)) {\n          temp_q1 = temp_q2 - 2;\n          temp_rem1 = temp_rem1 + divisor_upper;\n        }\n      }\n      temp_rem1 = temp_rem1 - temp_val;\n      temp_q1 = temp_q1 | quotient_upper << 0x10;\n      quotient_upper = 0;\n    }\n    else {\n      if (divisor_upper == 0) {\n        divisor_upper = 1 / 0;\n      }\n      bit_shift = LZCOUNT(divisor_upper);\n      if (bit_shift == 0) {\n        dividend_upper = dividend_upper - divisor_upper;\n        temp_rem1 = divisor_upper >> 0x10;\n        temp_div = divisor_upper & 0xffff;\n        quotient_upper = 1;\n      }\n      else {\n        divisor_upper = divisor_upper << bit_shift;\n        temp_rem1 = divisor_upper >> 0x10;\n        temp_q1 = dividend_upper >> (0x20U - bit_shift & 0xff);\n        temp_rem2 = dividend >> (0x20U - bit_shift & 0xff) | dividend_upper << bit_shift;\n        quotient_upper = temp_q1 / temp_rem1;\n        temp_div = divisor_upper & 0xffff;\n        temp_val = temp_rem2 >> 0x10 | (temp_q1 - temp_rem1 * quotient_upper) * 0x10000;\n        temp_q2 = quotient_upper * temp_div;\n        dividend = dividend << bit_shift;\n        temp_q1 = quotient_upper;\n        if (temp_val <= temp_q2 && temp_q2 - temp_val != 0) {\n          carry_flag = CARRY4(temp_val,divisor_upper);\n          temp_val = temp_val + divisor_upper;\n          temp_q1 = quotient_upper - 1;\n          if ((carry_flag == false) && (temp_val <= temp_q2 && temp_q2 - temp_val != 0)) {\n            temp_q1 = quotient_upper - 2;\n            temp_val = temp_val + divisor_upper;\n          }\n        }\n        quotient_lower = (temp_val - temp_q2) / temp_rem1;\n        dividend_upper = temp_rem2 & 0xffff | ((temp_val - temp_q2) - temp_rem1 * quotient_lower) * 0x10000;\n        temp_q2 = quotient_lower * temp_div;\n        quotient_upper = quotient_lower;\n        if (dividend_upper <= temp_q2 && temp_q2 - dividend_upper != 0) {\n          carry_flag = CARRY4(dividend_upper,divisor_upper);\n          dividend_upper = dividend_upper + divisor_upper;\n          quotient_upper = quotient_lower - 1;\n          if ((carry_flag == false) && (dividend_upper <= temp_q2 && temp_q2 - dividend_upper != 0)) {\n            quotient_upper = quotient_lower - 2;\n            dividend_upper = dividend_upper + divisor_upper;\n          }\n        }\n        dividend_upper = dividend_upper - temp_q2;\n        quotient_upper = quotient_upper | temp_q1 << 0x10;\n      }\n      temp_rem2 = dividend_upper / temp_rem1;\n      temp_val = dividend >> 0x10 | (dividend_upper - temp_rem1 * temp_rem2) * 0x10000;\n      temp_q1 = temp_div * temp_rem2;\n      temp_q2 = temp_rem2;\n      if (temp_val <= temp_q1 && temp_q1 - temp_val != 0) {\n        carry_flag = CARRY4(temp_val,divisor_upper);\n        temp_val = temp_val + divisor_upper;\n        temp_q2 = temp_rem2 - 1;\n        if ((carry_flag == false) && (temp_val <= temp_q1 && temp_q1 - temp_val != 0)) {\n          temp_q2 = temp_rem2 - 2;\n          temp_val = temp_val + divisor_upper;\n        }\n      }\n      temp_rem2 = (temp_val - temp_q1) / temp_rem1;\n      temp_rem1 = dividend & 0xffff | ((temp_val - temp_q1) - temp_rem1 * temp_rem2) * 0x10000;\n      temp_div = temp_div * temp_rem2;\n      temp_q1 = temp_rem2;\n      if (temp_rem1 <= temp_div && temp_div - temp_rem1 != 0) {\n        carry_flag = CARRY4(temp_rem1,divisor_upper);\n        temp_rem1 = temp_rem1 + divisor_upper;\n        temp_q1 = temp_rem2 - 1;\n        if ((carry_flag == false) && (temp_rem1 <= temp_div && temp_div - temp_rem1 != 0)) {\n          temp_q1 = temp_rem2 - 2;\n          temp_rem1 = temp_rem1 + divisor_upper;\n        }\n      }\n      temp_rem1 = temp_rem1 - temp_div;\n      temp_q1 = temp_q1 | temp_q2 << 0x10;\n    }\n    if (remainder != (uint *)0x0) {\n      *remainder = temp_rem1 >> bit_shift;\n      remainder[1] = 0;\n      return CONCAT44(quotient_upper,temp_q1);\n    }\n  }\n  else if (dividend_upper < divisor) {\n    if (remainder != (uint *)0x0) {\n      *remainder = dividend;\n      remainder[1] = dividend_upper;\n      return 0;\n    }\n    temp_q1 = 0;\n    quotient_upper = 0;\n  }\n  else {\n    bit_shift = LZCOUNT(divisor);\n    if (bit_shift != 0) {\n      temp_val = 0x20 - bit_shift;\n      quotient_upper = divisor_upper >> (temp_val & 0xff) | divisor << bit_shift;\n      temp_div = quotient_upper >> 0x10;\n      temp_q1 = dividend_upper >> (temp_val & 0xff);\n      quotient_lower = dividend >> (temp_val & 0xff) | dividend_upper << bit_shift;\n      temp_rem2 = temp_q1 / temp_div;\n      temp_q2 = quotient_lower >> 0x10 | (temp_q1 - temp_div * temp_rem2) * 0x10000;\n      temp_rem1 = temp_rem2 * (quotient_upper & 0xffff);\n      dividend = dividend << bit_shift;\n      temp_q1 = temp_rem2;\n      if (temp_q2 <= temp_rem1 && temp_rem1 - temp_q2 != 0) {\n        carry_flag = CARRY4(temp_q2,quotient_upper);\n        temp_q2 = temp_q2 + quotient_upper;\n        temp_q1 = temp_rem2 - 1;\n        if ((carry_flag == false) && (temp_q2 <= temp_rem1 && temp_rem1 - temp_q2 != 0)) {\n          temp_q1 = temp_rem2 - 2;\n          temp_q2 = temp_q2 + quotient_upper;\n        }\n      }\n      temp_rem2 = (temp_q2 - temp_rem1) / temp_div;\n      temp_q2 = quotient_lower & 0xffff | ((temp_q2 - temp_rem1) - temp_div * temp_rem2) * 0x10000;\n      temp_div = temp_rem2 * (quotient_upper & 0xffff);\n      temp_rem1 = temp_rem2;\n      if (temp_q2 <= temp_div && temp_div - temp_q2 != 0) {\n        carry_flag = CARRY4(temp_q2,quotient_upper);\n        temp_q2 = temp_q2 + quotient_upper;\n        temp_rem1 = temp_rem2 - 1;\n        if ((carry_flag == false) && (temp_q2 <= temp_div && temp_div - temp_q2 != 0)) {\n          temp_rem1 = temp_rem2 - 2;\n          temp_q2 = temp_q2 + quotient_upper;\n        }\n      }\n      temp_rem1 = temp_rem1 | temp_q1 << 0x10;\n      result = (ulonglong)temp_rem1 * (ulonglong)(divisor_upper << bit_shift);\n      if (CONCAT44(temp_q2 - temp_div,dividend) < result) {\n        result = result - CONCAT44(quotient_upper,divisor_upper << bit_shift);\n        temp_rem1 = temp_rem1 - 1;\n      }\n      if (remainder != (uint *)0x0) {\n        temp_q1 = ((temp_q2 - temp_div) - (int)(result >> 0x20)) - (uint)(dividend < (uint)result);\n        *remainder = temp_q1 << (temp_val & 0xff) | dividend - (uint)result >> bit_shift;\n        remainder[1] = temp_q1 >> bit_shift;\n      }\n      return (ulonglong)temp_rem1;\n    }\n    if ((divisor < dividend_upper) || (divisor_upper <= dividend)) {\n      carry_flag = dividend < divisor_upper;\n      dividend = dividend - divisor_upper;\n      dividend_upper = (dividend_upper - divisor) - (uint)carry_flag;\n      temp_q1 = 1;\n    }\n    else {\n      temp_q1 = 0;\n    }\n    quotient_upper = 0;\n    if (remainder != (uint *)0x0) {\n      *remainder = dividend;\n      remainder[1] = dividend_upper;\n      return (ulonglong)temp_q1;\n    }\n  }\n  return CONCAT44(quotient_upper,temp_q1);\n}\n\n",
            "renaming": {
                "FUN_08000300": "calculate_division_remainder_08000300",
                "param_1": "dividend",
                "param_2": "dividend_upper",
                "param_3": "divisor_upper",
                "param_4": "divisor",
                "param_5": "remainder",
                "uVar1": "result",
                "uVar2": "quotient_lower",
                "uVar3": "quotient_upper",
                "uVar4": "temp_q1",
                "uVar5": "temp_rem1",
                "uVar6": "temp_q2",
                "uVar7": "temp_rem2",
                "uVar8": "temp_val",
                "uVar9": "temp_div",
                "iVar10": "bit_shift",
                "bVar11": "carry_flag"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005dc": {
            "entrypoint": "0x080005dc",
            "current_name": "FUNC_080005dc",
            "code": "\nvoid FUNC_080005dc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080005dc": "FUNC_080005dc"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080005e0": {
            "entrypoint": "0x080005e0",
            "current_name": "execute_system_call_080005e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_system_call_080005e0(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_080005e0": "execute_system_call_080005e0"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005e4": {
            "entrypoint": "0x080005e4",
            "current_name": "execute_afl_call_080005e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint executeAflCall_080005e4(int numTicks)\n\n{\n  uint32_t aflResult;\n  \n  if (noHyperCall != 0) {\n    return 0;\n  }\n  aflResult = aflCall(1,numTicks,0);\n  return aflResult;\n}\n\n",
            "renaming": {
                "FUN_080005e4": "execute_afl_call_080005e4",
                "ticks": "numTicks",
                "uVar1": "aflResult"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000600": {
            "entrypoint": "0x08000600",
            "current_name": "initialize_modbus_08000600",
            "code": "\n/* DWARF original prototype: void  begin(Modbus * modbusInstance, long baudRate) */\n\nvoid __modbusInstancecall Modbus::initializeModbus_08000600(Modbus *modbusInstance,long baudRate)\n\n{\n  uint8_t serialNumber;\n  int readResult;\n  \n  serialNumber = modbusInstance->u8serno;\n  if (serialNumber == '\\x02') {\n    modbusInstance->port = &Serial3;\n  }\n  else if (serialNumber == '\\x03') {\n    modbusInstance->port = &Serial3;\n  }\n  else if (serialNumber == '\\x01') {\n    modbusInstance->port = &Serial3;\n  }\n  else {\n    modbusInstance->port = &Serial3;\n  }\n  HardwareSerial::begin(modbusInstance->port,baudRate,'\\x06');\n  if (1 < modbusInstance->u8txenpin) {\n    pinMode((uint)modbusInstance->u8txenpin,1);\n    digitalWrite((uint)modbusInstance->u8txenpin,0);\n  }\n  do {\n    readResult = (*(modbusInstance->port->super_Stream).super_Print._vptr_Print[3])();\n  } while (-1 < readResult);\n  modbusInstance->u8BufferSize = '\\0';\n  modbusInstance->u8lastRec = '\\0';\n  modbusInstance->u16errCnt = 0;\n  modbusInstance->u16OutCnt = 0;\n  modbusInstance->u16InCnt = 0;\n  return;\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "u32speed": "baudRate",
                "uVar1": "serialNumber",
                "iVar2": "readResult",
                "FUN_08000600": "initialize_modbus_08000600"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "begin",
                "pinMode",
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800066c": {
            "entrypoint": "0x0800066c",
            "current_name": "initialize_modbus_0800066c",
            "code": "\n/* DWARF original prototype: void  init(Modbus * modbusInstance, uint8_t identifier, uint8_t serialNumber, uint8_t\n   transmitEnablePin) */\n\nint __modbusInstancecall Modbus::initializeModbus_0800066c(Modbus *modbusInstance,EVP_PKEY_CTX *context)\n\n{\n  int inputValue;\n  uint8_t inputPin;\n  \n  modbusInstance->identifier = (uint8_t)context;\n  if (3 < inputValue) {\n    inputValue = 0;\n  }\n  modbusInstance->serialNumber = (uint8_t)inputValue;\n  modbusInstance->transmitEnablePin = inputPin;\n  modbusInstance->timeOut = 1000;\n  return (int)modbusInstance;\n}\n\n",
            "renaming": {
                "FUN_0800066c": "initialize_modbus_0800066c",
                "this": "modbusInstance",
                "ctx": "context",
                "in_r2": "inputValue",
                "in_r3": "inputPin",
                "u8id": "identifier",
                "u8serno": "serialNumber",
                "u8txenpin": "transmitEnablePin",
                "u16timeOut": "timeOut"
            },
            "calling": [
                "Modbus"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000682": {
            "entrypoint": "0x08000682",
            "current_name": "initialize_modbus_08000682",
            "code": "\n/* DWARF original prototype: Modbus *  Modbus(Modbus * modbusInstance, uint8_t deviceId, uint8_t serialNumber, uint8_t\n   transmitEnablePin) */\n\nModbus * __modbusInstancecall\nModbus::initializeModbus_08000682(Modbus *modbusInstance,uint8_t deviceId,uint8_t serialNumber,uint8_t transmitEnablePin)\n\n{\n  initialize(modbusInstance,(SecurityContext *)(uint)deviceId);\n  return modbusInstance;\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "u8id": "deviceId",
                "u8serno": "serialNumber",
                "u8txenpin": "transmitEnablePin",
                "init": "initialize",
                "EVP_PKEY_CTX": "SecurityContext",
                "FUN_08000682": "initialize_modbus_08000682"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000690": {
            "entrypoint": "0x08000690",
            "current_name": "initialize_modbus_slave_08000690",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeModbusSlave_08000690(int isInitialized,int priorityLevel)\n\n{\n  if (isInitialized != 1) {\n    return;\n  }\n  if (priorityLevel == 0xffff) {\n    initializeModbusConnection(&modbusSlave,'\\x01','\\0','\\0');\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000690": "initialize_modbus_slave_08000690",
                "__initialize_p": "isInitialized",
                "__priority": "priorityLevel",
                "Modbus::Modbus": "initializeModbusConnection",
                "slave": "modbusSlave"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN6ModbusC2Ev"
            ],
            "called": [
                "Modbus"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006b4": {
            "entrypoint": "0x080006b4",
            "current_name": "get_rx_buffer_080006b4",
            "code": "\n/* DWARF original prototype: int8_t  getRxBuffer_080006b4(Modbus * modbusInstance) */\n\nint8_t __modbusInstancecall Modbus::getRxBuffer_080006b4(Modbus *modbusInstance)\n\n{\n  bool bufferOverflow;\n  int serialReadResult;\n  byte bufferIndex;\n  \n  if (1 < modbusInstance->txEnablePin) {\n    digitalWrite((uint)modbusInstance->txEnablePin,0);\n  }\n  modbusInstance->bufferSize = '\\0';\n  if (modbusInstance->serialNumber < 4) {\n    bufferOverflow = false;\n    while (serialReadResult = (*(modbusInstance->port->super_Stream).super_Print._vptr_Print[2])(), serialReadResult != 0) {\n      bufferIndex = modbusInstance->bufferSize;\n      serialReadResult = (*(modbusInstance->port->super_Stream).super_Print._vptr_Print[3])();\n      modbusInstance->receiveBuffer[bufferIndex] = (uint8_t)serialReadResult;\n      bufferIndex = modbusInstance->bufferSize + 1;\n      modbusInstance->bufferSize = bufferIndex;\n      if (0x3f < bufferIndex) {\n        bufferOverflow = true;\n      }\n    }\n  }\n  else {\n    bufferOverflow = false;\n  }\n  modbusInstance->inputCount = modbusInstance->inputCount + 1;\n  if (bufferOverflow) {\n    modbusInstance->errorCount = modbusInstance->errorCount + 1;\n    return -3;\n  }\n  return modbusInstance->bufferSize;\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "bVar1": "bufferOverflow",
                "iVar2": "serialReadResult",
                "bVar3": "bufferIndex",
                "u8txenpin": "txEnablePin",
                "u8BufferSize": "bufferSize",
                "u8serno": "serialNumber",
                "au8Buffer": "receiveBuffer",
                "u16InCnt": "inputCount",
                "u16errCnt": "errorCount",
                "FUN_080006b4": "get_rx_buffer_080006b4"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000728": {
            "entrypoint": "0x08000728",
            "current_name": "calculate_crc_08000728",
            "code": "\n/* DWARF original prototype: uint16_t  calcCRC(Modbus * modbusInstance, uint8_t dataLength) */\n\nuint16_t __modbusInstancecall Modbus::calculateCRC_08000728(Modbus *modbusInstance,uint8_t dataLength)\n\n{\n  uchar bit;\n  uint crc;\n  uint unusedFlag;\n  uint bitCheck;\n  uint index;\n  \n  crc = 0xffff;\n  for (index = 0; index < dataLength; index = index + 1 & 0xff) {\n    crc = crc ^ modbusInstance->au8Buffer[index];\n    for (bit = 1; bit < 9; bit = bit + 1) {\n      bitCheck = crc & 1;\n      crc = crc >> 1;\n      if (bitCheck != 0) {\n        crc = crc ^ 0xa001;\n      }\n    }\n  }\n  return (ushort)(crc << 8) | (ushort)(crc >> 8);\n}\n\n",
            "renaming": {
                "FUN_08000728": "calculate_crc_08000728",
                "this": "modbusInstance",
                "u8length": "dataLength",
                "j": "bit",
                "uVar1": "crc",
                "flag": "unusedFlag",
                "uVar2": "bitCheck",
                "uVar3": "index"
            },
            "calling": [
                "sendTxBuffer"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800076c": {
            "entrypoint": "0x0800076c",
            "current_name": "send_tx_buffer_0800076c",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080007ec */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendTxBuffer_0800076c(Modbus * this) */\n\nvoid __thiscall Modbus::sendTxBuffer_0800076c(Modbus *this)\n\n{\n  byte bufferSize;\n  uint16_t crc;\n  uint16_t crc16;\n  int printResult;\n  uint32_t currentMillis;\n  uint newBufferSize;\n  \n  bufferSize = this->u8BufferSize;\n  crc = calcCRC(this,bufferSize);\n  this->au8Buffer[bufferSize] = (uint8_t)(crc >> 8);\n  newBufferSize = bufferSize + 1 & 0xff;\n  this->au8Buffer[newBufferSize] = (uint8_t)crc;\n  this->u8BufferSize = (char)newBufferSize + '\\x01';\n  if (1 < this->u8txenpin) {\n    digitalWrite((uint)this->u8txenpin,1);\n  }\n  if (this->u8serno < 4) {\n    (*(this->port->super_Stream).super_Print._vptr_Print[1])\n              (this->port,this->au8Buffer,(uint)this->u8BufferSize);\n  }\n  if (1 < this->u8txenpin) {\n    digitalWrite((uint)this->u8txenpin,0);\n  }\n  if (this->u8serno < 4) {\n    do {\n      printResult = (*(this->port->super_Stream).super_Print._vptr_Print[3])();\n    } while (-1 < printResult);\n  }\n  this->u8BufferSize = '\\0';\n  currentMillis = millis();\n  this->u32timeOut = currentMillis + this->u16timeOut;\n  this->u16OutCnt = this->u16OutCnt + 1;\n  return;\n}\n\n",
            "renaming": {
                "u8length": "bufferSize",
                "uVar1": "crc",
                "u16crc": "crc16",
                "iVar2": "printResult",
                "uVar3": "currentMillis",
                "uVar4": "newBufferSize",
                "FUN_0800076c": "send_tx_buffer_0800076c"
            },
            "calling": [
                "process_FC1",
                "process_FC3",
                "process_FC15",
                "process_FC5",
                "process_FC6",
                "poll",
                "process_FC16"
            ],
            "called": [
                "calcCRC",
                "digitalWrite",
                "millis"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080007f0": {
            "entrypoint": "0x080007f0",
            "current_name": "check_request_validity_080007f0",
            "code": "\n/* DWARF original prototype: uint8_t  validateRequest(Modbus * modbusObject) */\n\nuint8_t __modbusObjectcall Modbus::checkRequestValidity_080007f0(Modbus *modbusObject)\n\n{\n  bool isRequestValid;\n  uint16_t regStartAddress;\n  uint16_t regNum;\n  uint index;\n  uint8_t regSize;\n  \n  index = 0;\n  do {\n    if (7 < index) {\n      isRequestValid = false;\nLAB_0800080a:\n      if (!isRequestValid) {\n        modbusObject->u16errCnt = modbusObject->u16errCnt + 1;\n        return '\\x01';\n      }\n      switch(modbusObject->requestBuffer[1]) {\n      case '\\x01':\n      case '\\x02':\n      case '\\x0f':\n        goto switchD_08000816_caseD_1;\n      case '\\x03':\n      case '\\x04':\n      case '\\x10':\n        regStartAddress = makeWord(modbusObject->requestBuffer[2],modbusObject->requestBuffer[3]);\n        regNum = makeWord(modbusObject->requestBuffer[4],modbusObject->requestBuffer[5]);\n        if (modbusObject->regSizeize < (byte)((char)regNum + (char)regStartAddress)) {\n          return '\\x02';\n        }\n        return '\\0';\n      case '\\x05':\n        regStartAddress = makeWord(modbusObject->requestBuffer[2],modbusObject->requestBuffer[3]);\n        if ((uint)modbusObject->regSizeize < ((uint)regStartAddress << 0x14) >> 0x18) {\n          return '\\x02';\n        }\n        return '\\0';\n      case '\\x06':\n        regStartAddress = makeWord(modbusObject->requestBuffer[2],modbusObject->requestBuffer[3]);\n        if (modbusObject->regSizeize < (byte)regStartAddress) {\n          return '\\x02';\n        }\n        return '\\0';\n      default:\n        return '\\0';\n      }\n    }\n    if (\"\\x01\\x02\\x03\\x04\\x05\\x06\\x0f\\x10\"[index] == modbusObject->requestBuffer[1]) {\n      isRequestValid = true;\n      goto LAB_0800080a;\n    }\n    index = index + 1 & 0xff;\n  } while( true );\nswitchD_08000816_caseD_1:\n  regStartAddress = makeWord(modbusObject->requestBuffer[2],modbusObject->requestBuffer[3]);\n  regNum = makeWord(modbusObject->requestBuffer[4],modbusObject->requestBuffer[5]);\n  if ((uint)modbusObject->regSizeize <\n      ((((uint)regStartAddress << 0xc) >> 0x10) + (((uint)regNum << 0xc) >> 0x10) & 0xff)) {\n    return '\\x02';\n  }\n  return '\\0';\n}\n\n",
            "renaming": {
                "this": "modbusObject",
                "bVar1": "isRequestValid",
                "uVar2": "regStartAddress",
                "uVar3": "regNum",
                "uVar4": "index",
                "u8regs": "regSize",
                "au8Buffer": "requestBuffer",
                "FUN_080007f0": "check_request_validity_080007f0"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008cc": {
            "entrypoint": "0x080008cc",
            "current_name": "build_exception_080008cc",
            "code": "\n/* DWARF original prototype: void  buildException_080008cc(Modbus * modbusInstance, uint8_t exception) */\n\nvoid __modbusInstancecall Modbus::buildException_080008cc(Modbus *modbusInstance,uint8_t exception)\n\n{\n  byte bufferElement;\n  uint8_t functionCode;\n  \n  bufferElement = modbusInstance->au8Buffer[1];\n  modbusInstance->au8Buffer[0] = modbusInstance->u8id;\n  modbusInstance->au8Buffer[1] = bufferElement ^ 0x80;\n  modbusInstance->au8Buffer[2] = exception;\n  modbusInstance->u8BufferSize = '\\x03';\n  return;\n}\n\n",
            "renaming": {
                "FUN_080008cc": "build_exception_080008cc",
                "this": "modbusInstance",
                "u8exception": "exception",
                "bVar1": "bufferElement",
                "u8func": "functionCode"
            },
            "calling": [
                "poll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008e2": {
            "entrypoint": "0x080008e2",
            "current_name": "process_coils_080008e2",
            "code": "\n/* DWARF original prototype: int8_t  process_FC1(Modbus * modbusInstance, uint16_t * coilRegisters, uint8_t registerSize) */\n\nint8_t __modbusInstancecall Modbus::processCoils_080008e2(Modbus *modbusInstance,uint16_t *coilRegisters,uint8_t registerSize)\n\n{\n  uint16_t startAddress;\n  uint16_t numCoils;\n  uint16_t coilNumber;\n  uint counter;\n  uint bitCounter;\n  uint8_t numBytes;\n  uint8_t numBytesNo;\n  uint8_t copyBufferSize;\n  uint16_t startCoil;\n  \n  startAddress = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n  numCoils = makeWord(modbusInstance->au8Buffer[4],modbusInstance->au8Buffer[5]);\n  numBytes = (uint8_t)(((uint)numCoils << 0x15) >> 0x18);\n  if ((numCoils & 7) != 0) {\n    numBytes = numBytes + '\\x01';\n  }\n  modbusInstance->au8Buffer[2] = numBytes;\n  modbusInstance->u8BufferSize = '\\x03';\n  bitCounter = 0;\n  for (counter = 0; counter < numCoils; counter = counter + 1 & 0xffff) {\n    if (((int)(uint)coilRegisters[(counter + startAddress) * 0x100000 >> 0x18] >> (counter + startAddress & 0xf) & 1U) == 0) {\n      modbusInstance->au8Buffer[modbusInstance->u8BufferSize] =\n           modbusInstance->au8Buffer[modbusInstance->u8BufferSize] & ~(byte)(1 << bitCounter);\n    }\n    else {\n      modbusInstance->au8Buffer[modbusInstance->u8BufferSize] = modbusInstance->au8Buffer[modbusInstance->u8BufferSize] | (byte)(1 << bitCounter)\n      ;\n    }\n    bitCounter = bitCounter + 1 & 0xff;\n    if (7 < bitCounter) {\n      modbusInstance->u8BufferSize = modbusInstance->u8BufferSize + '\\x01';\n      bitCounter = 0;\n    }\n  }\n  if ((numCoils & 7) != 0) {\n    modbusInstance->u8BufferSize = modbusInstance->u8BufferSize + '\\x01';\n  }\n  numBytes = modbusInstance->u8BufferSize;\n  sendTxBuffer(modbusInstance);\n  return numBytes + '\\x02';\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "regs": "coilRegisters",
                "u8size": "registerSize",
                "uVar1": "startAddress",
                "uVar2": "numCoils",
                "u16Coilno": "coilNumber",
                "uVar3": "counter",
                "uVar4": "bitCounter",
                "uVar5": "numBytes",
                "u8bytesno": "numBytesNo",
                "u8CopyBufferSize": "copyBufferSize",
                "u16StartCoil": "startCoil",
                "FUN_080008e2": "process_coils_080008e2"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "process_fc3_08000998",
            "code": "\n/* DWARF orindexgindexnal prototype: indexnt8_t  process_FC3_08000998(Modbus * modbus, uindexnt16_t * registerArray, uindexnt8_t registerCount) */\n\nindexnt8_t __modbuscall Modbus::process_FC3_08000998(Modbus *modbus,uindexnt16_t *registerArray,uindexnt8_t registerCount)\n\n{\n  uint8_t bufferSize;\n  uindexnt8_t uVar2;\n  uindexnt8_t u8registerArrayno;\n  uindexnt16_t startAddress;\n  uindexnt16_t registerQuantity;\n  uindexnt currentAddress;\n  uindexnt bufferIndex;\n  uindexnt8_t bufferSize;\n  uindexnt8_t startAddress;\n  uindexnt8_t index;\n  \n  startAddress = makeWord(modbus->au8Buffer[2],modbus->au8Buffer[3]);\n  registerQuantity = makeWord(modbus->au8Buffer[4],modbus->au8Buffer[5]);\n  modbus->au8Buffer[2] = (uint8_t)registerQuantity << 1;\n  modbus->u8BufferSindexze = '\\x03';\n  for (currentAddress = (uindexnt)(uint8_t)startAddress; currentAddress < (uindexnt)(uint8_t)startAddress + (uindexnt)(uint8_t)registerQuantity;\n      currentAddress = currentAddress + 1 & 0xff) {\n    bufferSize = modbus->u8BufferSindexze;\n    modbus->au8Buffer[bufferSize] = (uindexnt8_t)(registerArray[currentAddress] >> 8);\n    bufferIndex = bufferSize + 1 & 0xff;\n    uVar2 = (uindexnt8_t)bufferIndex;\n    modbus->u8BufferSindexze = uVar2;\n    modbus->au8Buffer[bufferIndex] = *(uindexnt8_t *)(registerArray + currentAddress);\n    modbus->u8BufferSindexze = uVar2 + '\\x01';\n  }\n  uVar2 = modbus->u8BufferSindexze;\n  sendTxBuffer(modbus);\n  return uVar2 + '\\x02';\n}\n\n",
            "renaming": {
                "this": "modbus",
                "regs": "registerArray",
                "u8size": "registerCount",
                "uVar3": "startAddress",
                "uVar4": "registerQuantity",
                "uVar5": "currentAddress",
                "uVar6": "bufferIndex",
                "u8CopyBufferSize": "bufferSize",
                "u8StartAdd": "startAddress",
                "i": "index",
                "bVar1": "bufferSize",
                "byte": "uint8_t",
                "FUN_08000998": "process_fc3_08000998"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a00": {
            "entrypoint": "0x08000a00",
            "current_name": "process_modbus_fc5_08000a00",
            "code": "\n/* DWARF original prototype: int8_t  process_FC5(Modbus * modbus_object, uint16_t * registers, uint8_t num_registers) */\n\nint8_t __modbus_objectcall Modbus::process_Modbus_FC5_08000a00(Modbus *modbus_object,uint16_t *registers,uint8_t num_registers)\n\n{\n  uint8_t current_bit;\n  uint16_t buffer_value;\n  uint16_t coil_value;\n  uint lower_bits;\n  uint8_t current_register;\n  uint upper_bits;\n  \n  buffer_value = makeWord(modbus_object->au8Buffer[2],modbus_object->au8Buffer[3]);\n  upper_bits = ((uint)buffer_value << 0x14) >> 0x18;\n  lower_bits = buffer_value & 0xf;\n  if (modbus_object->au8Buffer[4] == 0xff) {\n    registers[upper_bits] = (ushort)(1 << lower_bits) | registers[upper_bits];\n  }\n  else {\n    registers[upper_bits] = registers[upper_bits] & ~(ushort)(1 << lower_bits);\n  }\n  modbus_object->u8BufferSize = '\\x06';\n  sendTxBuffer(modbus_object);\n  return '\\b';\n}\n\n",
            "renaming": {
                "this": "modbus_object",
                "regs": "registers",
                "u8size": "num_registers",
                "u8currentBit": "current_bit",
                "u16coil": "coil_value",
                "uVar1": "buffer_value",
                "uVar2": "lower_bits",
                "u8currentRegister": "current_register",
                "uVar3": "upper_bits",
                "FUN_08000a00": "process_modbus_fc5_08000a00"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a4e": {
            "entrypoint": "0x08000a4e",
            "current_name": "update_register_value_08000a4e",
            "code": "\n/* DWARF original prototype: int8_t  process_FC6(Modbus * modbusInstance, uint16_t * registerArray, uint8_t arraySize) */\n\nint8_t __modbusInstancecall Modbus::updateRegisterValue_08000a4e(Modbus *modbusInstance,uint16_t *registerArray,uint8_t arraySize)\n\n{\n  uint16_t highByte;\n  uint16_t lowByte;\n  uint16_t registerValue;\n  uint8_t registerAddress;\n  \n  highByte = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n  lowByte = makeWord(modbusInstance->au8Buffer[4],modbusInstance->au8Buffer[5]);\n  registerArray[(byte)highByte] = lowByte;\n  modbusInstance->u8BufferSize = '\\x06';\n  sendTxBuffer(modbusInstance);\n  return '\\b';\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "regs": "registerArray",
                "u8size": "arraySize",
                "uVar1": "highByte",
                "uVar2": "lowByte",
                "u16val": "registerValue",
                "u8add": "registerAddress",
                "FUN_08000a4e": "update_register_value_08000a4e"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a7a": {
            "entrypoint": "0x08000a7a",
            "current_name": "process_fc15_08000a7a",
            "code": "\n/* DWARF original prototype: int8_t  process_FC15_08000a7a(Modbus * modbus_instance, uint16_t * registers, uint8_t register_count) */\n\nint8_t __modbus_instancecall Modbus::process_FC15_08000a7a(Modbus *modbus_instance,uint16_t *registers,uint8_t register_count)\n\n{\n  uint16_t start_register;\n  uint16_t coil_count;\n  uint16_t current_coil;\n  uint iteration;\n  uint bit_iteration;\n  uint8_t current_bit;\n  uint bit_position;\n  uint16_t start_coil;\n  uint8_t current_register;\n  uint target_register_index;\n  uint buffer_index;\n  \n  start_register = makeWord(modbus_instance->au8Buffer[2],modbus_instance->au8Buffer[3]);\n  coil_count = makeWord(modbus_instance->au8Buffer[4],modbus_instance->au8Buffer[5]);\n  bit_iteration = 0;\n  buffer_index = 7;\n  for (iteration = 0; iteration < coil_count; iteration = iteration + 1 & 0xffff) {\n    target_register_index = (iteration + start_register) * 0x100000 >> 0x18;\n    bit_position = iteration + start_register & 0xf;\n    if (((int)(uint)modbus_instance->au8Buffer[buffer_index] >> bit_iteration & 1U) == 0) {\n      registers[target_register_index] = registers[target_register_index] & ~(ushort)(1 << bit_position);\n    }\n    else {\n      registers[target_register_index] = (ushort)(1 << bit_position) | registers[target_register_index];\n    }\n    bit_iteration = bit_iteration + 1 & 0xff;\n    if (7 < bit_iteration) {\n      buffer_index = buffer_index + 1 & 0xff;\n      bit_iteration = 0;\n    }\n  }\n  modbus_instance->u8BufferSize = '\\x06';\n  sendTxBuffer(modbus_instance);\n  return '\\b';\n}\n\n",
            "renaming": {
                "this": "modbus_instance",
                "regs": "registers",
                "u8size": "register_count",
                "uVar1": "start_register",
                "uVar2": "coil_count",
                "u16Coilno": "current_coil",
                "uVar3": "iteration",
                "uVar4": "bit_iteration",
                "u8currentBit": "current_bit",
                "uVar5": "bit_position",
                "u16StartCoil": "start_coil",
                "u8currentRegister": "current_register",
                "uVar6": "target_register_index",
                "uVar7": "buffer_index",
                "FUN_08000a7a": "process_fc15_08000a7a"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b04": {
            "entrypoint": "0x08000b04",
            "current_name": "extract_and_send_registers_08000b04",
            "code": "\n/* DWARF orcountergcounternal prototype: counternt8_t  process_FC16(Modbus * modbus_instance, ucounternt16_t * registers, ucounternt8_t num_registers) */\n\ncounternt8_t __modbus_instancecall Modbus::extract_and_send_registers_08000b04(Modbus *modbus_instance,ucounternt16_t *registers,ucounternt8_t num_registers)\n\n{\n  byte byte1;\n  byte byte2;\n  ucounternt8_t buffer_size;\n  ucounternt16_t register_value;\n  ucounternt16_t temp_value;\n  ucounternt8_t copy_buffer_size;\n  ucounternt8_t counter;\n  ucounternt loop_counter;\n  ucounternt8_t number_of_registers;\n  ucounternt8_t start_address;\n  \n  byte1 = modbus_instance->au8Buffer[3];\n  byte2 = modbus_instance->au8Buffer[5];\n  modbus_instance->au8Buffer[4] = '\\0';\n  modbus_instance->au8Buffer[5] = byte2;\n  modbus_instance->u8BufferScounterze = '\\x06';\n  for (loop_counter = 0; loop_counter < byte2; loop_counter = loop_counter + 1 & 0xff) {\n    register_value = makeWord(modbus_instance->au8Buffer[loop_counter * 2 + 7],modbus_instance->au8Buffer[loop_counter * 2 + 8]);\n    registers[byte1 + loop_counter] = register_value;\n  }\n  buffer_size = modbus_instance->u8BufferScounterze;\n  sendTxBuffer(modbus_instance);\n  return buffer_size + '\\x02';\n}\n\n",
            "renaming": {
                "this": "modbus_instance",
                "regs": "registers",
                "u8size": "num_registers",
                "bVar1": "byte1",
                "bVar2": "byte2",
                "uVar3": "buffer_size",
                "uVar4": "register_value",
                "temp": "temp_value",
                "u8CopyBufferSize": "copy_buffer_size",
                "i": "counter",
                "uVar5": "loop_counter",
                "u8regsno": "number_of_registers",
                "u8StartAdd": "start_address",
                "FUN_08000b04": "extract_and_send_registers_08000b04"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b54": {
            "entrypoint": "0x08000b54",
            "current_name": "FUNC_08000b54",
            "code": "\n/* DWARF original prototype: int8_t  poll(Modbus * this, uint16_t * regs, uint8_t u8size) */\n\nint __thiscall Modbus::FUNC_08000b54(Modbus *this,pollfd *__fds,nfds_t __nfds,int __timeout)\n\n{\n  uint8_t u8size;\n  uint8_t uVar1;\n  int8_t i8state;\n  uint8_t u8exception;\n  int8_t iVar2;\n  uint uVar3;\n  uint32_t uVar4;\n  uint8_t u8current;\n  uint unaff_r5;\n  int iVar5;\n  \n  this->au16regs = (uint16_t *)__fds;\n  u8size = (uint8_t)__nfds;\n  this->u8regsize = u8size;\n  if (this->u8serno < 4) {\n    uVar3 = (*(this->port->super_Stream).super_Print._vptr_Print[2])();\n    unaff_r5 = uVar3 & 0xff;\n  }\n  if (unaff_r5 == 0) {\n    iVar5 = 0;\n  }\n  else if ((int)unaff_r5 < 8) {\n    iVar5 = 0;\n  }\n  else {\n    uVar1 = getRxBuffer(this);\n    iVar5 = (int)(char)uVar1;\n    this->u8lastError = uVar1;\n    if (this->au8Buffer[0] == this->u8id) {\n      uVar1 = validateRequest(this);\n      if (uVar1 == '\\0') {\n        uVar4 = millis();\n        this->u32timeOut = this->u16timeOut + uVar4;\n        this->u8lastError = '\\0';\n        switch(this->au8Buffer[1]) {\n        case '\\x01':\n        case '\\x02':\n          iVar2 = process_FC1(this,(uint16_t *)__fds,u8size);\n          iVar5 = (int)iVar2;\n          break;\n        case '\\x03':\n        case '\\x04':\n          iVar2 = process_FC3(this,(uint16_t *)__fds,u8size);\n          iVar5 = (int)iVar2;\n          break;\n        case '\\x05':\n          iVar2 = process_FC5(this,(uint16_t *)__fds,u8size);\n          iVar5 = (int)iVar2;\n          break;\n        case '\\x06':\n          iVar2 = process_FC6(this,(uint16_t *)__fds,u8size);\n          iVar5 = (int)iVar2;\n          break;\n        case '\\x0f':\n          iVar2 = process_FC15(this,(uint16_t *)__fds,u8size);\n          iVar5 = (int)iVar2;\n          break;\n        case '\\x10':\n          iVar2 = process_FC16(this,(uint16_t *)__fds,u8size);\n          iVar5 = (int)iVar2;\n        }\n      }\n      else {\n        if (uVar1 != 0xff) {\n          buildException(this,uVar1);\n          sendTxBuffer(this);\n        }\n        this->u8lastError = uVar1;\n        iVar5 = (int)(char)uVar1;\n      }\n    }\n    else {\n      iVar5 = 0;\n    }\n  }\n  return iVar5;\n}\n\n",
            "renaming": {
                "FUN_08000b54": "FUNC_08000b54"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "sendTxBuffer",
                "process_FC1",
                "process_FC3",
                "process_FC15",
                "process_FC6",
                "process_FC5",
                "getRxBuffer",
                "validateRequest",
                "buildException",
                "process_FC16",
                "millis"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000c4c": {
            "entrypoint": "0x08000c4c",
            "current_name": "initialize_modbus_08000c4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeModbus_08000c4c(void)\n\n{\n  launchForkServer(0);\n  modbusBegin(ptr_slave,0x4b00);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c4c": "initialize_modbus_08000c4c",
                "&slave": "ptr_slave",
                "startForkserver": "launchForkServer",
                "Modbus::begin": "modbusBegin"
            },
            "calling": [
                "main"
            ],
            "called": [
                "startForkserver",
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c64": {
            "entrypoint": "0x08000c64",
            "current_name": "poll_modbus_slave_08000c64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid pollModbusSlave_08000c64(void)\n\n{\n  int userInput;\n  \n  Modbus::poll(&modbusSlave,(pollfd *)pollFileDescriptors,0x10,userInput);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c64": "poll_modbus_slave_08000c64",
                "in_r3": "userInput",
                "slave": "modbusSlave",
                "au16data": "pollFileDescriptors"
            },
            "calling": [
                "main"
            ],
            "called": [
                "poll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c7c": {
            "entrypoint": "0x08000c7c",
            "current_name": "initialize_static_memory_08000c7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_memory_08000c7c(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c7c": "initialize_static_memory_08000c7c"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c8c": {
            "entrypoint": "0x08000c8c",
            "current_name": "initialize_clocks_08000c8c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeClocks_08000c8c(void)\n\n{\n  uint32_t hclkFrequency;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  RCC_OscInitTypeDef clockInitStructure;\n  RCC_ClkInitTypeDef clockConfigStructure;\n  \n  _DAT_40023840 = _DAT_40023840 | 0x10000000;\n  _DAT_40007000 = _DAT_40007000 | 0xc000;\n  clockInitStructure.OscillatorType = 1;\n  clockInitStructure.HSEState = 0x50000;\n  clockInitStructure.PLL.PLLState = 2;\n  clockInitStructure.PLL.PLLSource = 0x400000;\n  clockInitStructure.PLL.PLLM = 8;\n  clockInitStructure.PLL.PLLN = 0x150;\n  clockInitStructure.PLL.PLLP = 2;\n  clockInitStructure.PLL.PLLQ = 7;\n  HAL_RCC_OscConfig((RCC_OscInitTypeDef_conflict *)&clockInitStructure);\n  HAL_PWREx_EnableOverDrive();\n  clockConfigStructure.ClockType = 0xf;\n  clockConfigStructure.SYSCLKSource = 2;\n  clockConfigStructure.AHBCLKDivider = 0;\n  clockConfigStructure.APB1CLKDivider = 0x1400;\n  clockConfigStructure.APB2CLKDivider = 0x1000;\n  HAL_RCC_ClockConfig((RCC_ClkInitTypeDef_conflict *)&clockConfigStructure,5);\n  hclkFrequency = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFrequency / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c8c": "initialize_clocks_08000c8c",
                "RCC_OscInitStruct": "clockInitStructure",
                "RCC_ClkInitStruct": "clockConfigStructure",
                "uVar1": "hclkFrequency"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_PWREx_EnableOverDrive",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d3c": {
            "entrypoint": "0x08000d3c",
            "current_name": "initialize_system_08000d3c",
            "code": "\n/* WARNING: This function may have set the stack pointer */\n\nvoid initializeSystem_08000d3c(void)\n\n{\n  int index;\n  undefined4 *ptr;\n  code *jumptable;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &completed_8667; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&_sidata + index);\n  }\n  for (ptr = &completed_8667; ptr < &_ebss; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumptable = (code *)0x8000d72;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08000d72. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumptable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000d3c": "initialize_system_08000d3c",
                "iVar1": "index",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "jumptable"
            },
            "calling": [],
            "called": [
                "main",
                "SystemInit",
                "__libc_init_array"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d8c": {
            "entrypoint": "0x08000d8c",
            "current_name": "do_nothing_loop_08000d8c",
            "code": "\nvoid doNothingLoop_08000d8c(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08000d8c": "do_nothing_loop_08000d8c"
            },
            "calling": [
                "CAN2_SCE_IRQHandler"
            ],
            "called": [
                "CAN2_SCE_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d8e": {
            "entrypoint": "0x08000d8e",
            "current_name": "initialize_hardware_config_08000d8e",
            "code": "\nint initializeHardwareConfig_08000d8e(EVP_PKEY_CTX *context)\n\n{\n  hw_config_init();\n  return (int)context;\n}\n\n",
            "renaming": {
                "FUN_08000d8e": "initialize_hardware_config_08000d8e",
                "ctx": "context"
            },
            "calling": [
                "premain"
            ],
            "called": [
                "hw_config_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d96": {
            "entrypoint": "0x08000d96",
            "current_name": "FUNC_08000d96",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08000d96(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000d96": "FUNC_08000d96"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000d98": {
            "entrypoint": "0x08000d98",
            "current_name": "configure_sys_tick_08000d98",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureSysTick_08000d98(uint32_t priority)\n\n{\n  uint32_t configStatus;\n  \n  configStatus = HAL_SYSTICK_Config((uint32_t)((ulonglong)SystemCoreClock / (1000 / (ulonglong)uwTickFreq))\n                            );\n  if (configStatus != 0) {\n    return HAL_ERROR;\n  }\n  if (0xf < priority) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn,priority,0);\n  uwTickPrio = priority;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08000d98": "configure_sys_tick_08000d98",
                "TickPriority": "priority",
                "uVar1": "configStatus"
            },
            "calling": [
                "HAL_Init",
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000de4": {
            "entrypoint": "0x08000de4",
            "current_name": "initialize_hal_08000de4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeHAL_08000de4(void)\n\n{\n  _DAT_40023c00 = _DAT_40023c00 | 0x700;\n  setPriorityGrouping(3);\n  initializeTick(0xf);\n  initializeMsp();\n  return HAL_Success;\n}\n\n",
            "renaming": {
                "FUN_08000de4": "initialize_hal_08000de4",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializeMsp",
                "HAL_OK": "HAL_Success"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_InitTick",
                "HAL_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e18": {
            "entrypoint": "0x08000e18",
            "current_name": "update_tick_08000e18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateTick_08000e18(void)\n\n{\n  tickValue = frequency + tickValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e18": "update_tick_08000e18",
                "uwTick": "tickValue",
                "uwTickFreq": "frequency"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e30": {
            "entrypoint": "0x08000e30",
            "current_name": "get_tick_value_08000e30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTickValue_08000e30(void)\n\n{\n  return currentTick;\n}\n\n",
            "renaming": {
                "FUN_08000e30": "get_tick_value_08000e30",
                "uwTick": "currentTick"
            },
            "calling": [
                "HAL_PWREx_EnableOverDrive",
                "UART_WaitOnFlagUntilTimeout",
                "uart_debug_write",
                "GetCurrentMilli",
                "HAL_RCC_OscConfig",
                "HAL_UART_Transmit",
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e3c": {
            "entrypoint": "0x08000e3c",
            "current_name": "initialize_priority_group_08000e3c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializePriorityGroup_08000e3c(uint32_t priorityGroup)\n\n{\n  uint32_t registerValue;\n  \n  _DAT_e000ed0c = (priorityGroup & 7) << 8 | _DAT_e000ed0c & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e3c": "initialize_priority_group_08000e3c",
                "PriorityGroup": "priorityGroup",
                "reg_value": "registerValue"
            },
            "calling": [
                "premain",
                "HAL_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e60": {
            "entrypoint": "0x08000e60",
            "current_name": "configure_interrupt_priority_08000e60",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureInterruptPriority_08000e60(interruptType IRQn,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint interrupt;\n  uint priorityShift;\n  uint32_t priorityGroupTemp;\n  uint32_t subPriorityBits;\n  uint32_t preemptPriorityBits;\n  \n  interrupt = (uint)IRQn;\n  priorityShift = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  preemptPriorityBits = 7 - priorityShift;\n  if (3 < preemptPriorityBits) {\n    preemptPriorityBits = 4;\n  }\n  if (priorityShift + 4 < 7) {\n    subPriorityBits = 0;\n  }\n  else {\n    subPriorityBits = priorityShift - 3;\n  }\n  priorityShift = (preemptPriority & (1 << (preemptPriorityBits & 0xff)) - 1U) << (subPriorityBits & 0xff) |\n          (1 << (subPriorityBits & 0xff)) - 1U & subPriority;\n  if ((int)interrupt < 0) {\n    *(char *)((interrupt & 0xf) + 0xe000ed14) = (char)(priorityShift << 4);\n  }\n  else {\n    *(char *)(interrupt + 0xe000e400) = (char)(priorityShift << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e60": "configure_interrupt_priority_08000e60",
                "IRQn_Type_conflict": "interruptType",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "PriorityGroupTmp": "priorityGroupTemp",
                "SubPriorityBits": "subPriorityBits",
                "PreemptPriorityBits": "preemptPriorityBits",
                "uVar1": "interrupt",
                "uVar2": "priorityShift"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback",
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ec4": {
            "entrypoint": "0x08000ec4",
            "current_name": "set_ir_qn_type_bit_08000ec4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setIRQnTypeBit_08000ec4(IRQn IRQn)\n\n{\n  uint irqValue;\n  \n  irqValue = (uint)IRQn;\n  if (-1 < (int)irqValue) {\n    *(int *)((irqValue >> 5) * 4 + -0x1fff1f00) = 1 << (irqValue & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ec4": "set_ir_qn_type_bit_08000ec4",
                "IRQn_Type_conflict": "IRQn",
                "uVar1": "irqValue"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ee0": {
            "entrypoint": "0x08000ee0",
            "current_name": "initialize_ticks_08000ee0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t initializeTicks_08000ee0(uint32_t ticksNumber)\n\n{\n  if (ticksNumber - 1 < 0x1000000) {\n    _DAT_e000e014 = ticksNumber - 1;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08000ee0": "initialize_ticks_08000ee0",
                "TicksNumb": "ticksNumber"
            },
            "calling": [
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f0c": {
            "entrypoint": "0x08000f0c",
            "current_name": "set_interrupt_enable_bit_08000f0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setInterruptEnableBit_08000f0c(interruptNumber IRQn)\n\n{\n  uint convertedInterruptNumber;\n  \n  convertedInterruptNumber = (uint)IRQn;\n  if (-1 < (int)convertedInterruptNumber) {\n    *(int *)(((convertedInterruptNumber >> 5) + 0x60) * 4 + -0x1fff1f00) = 1 << (convertedInterruptNumber & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f0c": "set_interrupt_enable_bit_08000f0c",
                "IRQn_Type_conflict": "interruptNumber",
                "uVar1": "convertedInterruptNumber"
            },
            "calling": [
                "USART3_IRQHandler",
                "USART6_IRQHandler",
                "UART7_IRQHandler",
                "UART4_IRQHandler",
                "UART8_IRQHandler",
                "USART1_IRQHandler",
                "USART2_IRQHandler",
                "UART5_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f2c": {
            "entrypoint": "0x08000f2c",
            "current_name": "update_clk_source_08000f2c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid updateCLKSource_08000f2c(uint32_t source)\n\n{\n  if (source != 4) {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n    return;\n  }\n  _DAT_e000e010 = _DAT_e000e010 | 4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f2c": "update_clk_source_08000f2c",
                "CLKSource": "source"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f4c": {
            "entrypoint": "0x08000f4c",
            "current_name": "FUNC_08000f4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08000f4c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f4c": "FUNC_08000f4c"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000f4e": {
            "entrypoint": "0x08000f4e",
            "current_name": "handle_sys_tick_interrupt_08000f4e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickInterrupt_08000f4e(void)\n\n{\n  performSysTickCallback();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f4e": "handle_sys_tick_interrupt_08000f4e",
                "HAL_SYSTICK_Callback": "performSysTickCallback"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f56": {
            "entrypoint": "0x08000f56",
            "current_name": "initialize_dac_08000f56",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeDac_08000f56(DAC_HandleTypeDef *hdac)\n\n{\n  if (hdac != (DAC_HandleTypeDef *)0x0) {\n    hdac->State = HAL_DAC_STATE_BUSY;\n    deinitializeDac_08000f56Msp(hdac);\n    hdac->ErrorCode = 0;\n    hdac->State = HAL_DAC_STATE_RESET;\n    hdac->Lock = HAL_UNLOCKED;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08000f56": "initialize_dac_08000f56",
                "HAL_DAC_MspDeInit": "deinitializeDacMsp"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [
                "HAL_DAC_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f72": {
            "entrypoint": "0x08000f72",
            "current_name": "disable_dac_channel_08000f72",
            "code": "\n/* WARNING: Unknown calling convention */\n\nDAC_Status disableDACChannel_08000f72(DAC_HandleTypeDef *dacHandle,uint32_t channel)\n\n{\n  dacHandle->Instance->controlRegister = dacHandle->Instance->controlRegister & ~(1 << (channel & 0xff));\n  dacHandle->dacState = HAL_DAC_STATE_READY;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08000f72": "disable_dac_channel_08000f72",
                "hdac": "dacHandle",
                "Channel": "channel",
                "CR": "controlRegister",
                "State": "dacState",
                "HAL_StatusTypeDef": "DAC_Status"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f8c": {
            "entrypoint": "0x08000f8c",
            "current_name": "abort_dma_operation_08000f8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef abortDMAOperation_08000f8c(DMA_HandleTypeDef *dmaHandle)\n\n{\n  if (dmaHandle->State != DMA_STATE_BUSY) {\n    dmaHandle->error = 0x80;\n    return ERROR;\n  }\n  dmaHandle->State = DMA_STATE_ABORT;\n  dmaHandle->instance->controlRegister = dmaHandle->instance->controlRegister & 0xfffffffe;\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_08000f8c": "abort_dma_operation_08000f8c",
                "hdma": "dmaHandle",
                "HAL_DMA_STATE_BUSY": "DMA_STATE_BUSY",
                "ErrorCode": "error",
                "HAL_ERROR": "ERROR",
                "HAL_DMA_STATE_ABORT": "DMA_STATE_ABORT",
                "Instance": "instance",
                "CR": "controlRegister",
                "HAL_OK": "OK"
            },
            "calling": [
                "I2C_ITError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fb4": {
            "entrypoint": "0x08000fb4",
            "current_name": "configure_gpio_08000fb4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureGPIO_08000fb4(GPIO_TypeDef *GPIO,GPIOConfigTypeDef *GPIOConfig)\n\n{\n  uint tempVar1;\n  uint tempVar2;\n  uint tempVar3;\n  uint tempVar4;\n  uint tempVar5;\n  uint32_t tempVar6;\n  int index;\n  uint tempVar8;\n  int index2;\n  uint32_t tmp_register;\n  \n  for (tempVar3 = 0; tempVar3 < 0x10; tempVar3 = tempVar3 + 1) {\n    tempVar2 = 1 << (tempVar3 & 0xff);\n    tempVar4 = tempVar2 & GPIOConfig->Pin;\n    tempVar1 = _DAT_40013c0c;\n    if (tempVar2 == tempVar4) {\n      if ((GPIOConfig->Mode == 2) || (GPIOConfig->Mode == 0x12)) {\n        index2 = (tempVar3 & 7) << 2;\n        GPIO->AFR[tempVar3 >> 3] =\n             GPIO->AFR[tempVar3 >> 3] & ~(0xf << index2) | GPIOConfig->Alternate << index2;\n      }\n      tempVar8 = tempVar3 << 1;\n      tempVar1 = ~(3 << (tempVar8 & 0xff));\n      GPIO->MODER = GPIO->MODER & tempVar1 | (GPIOConfig->Mode & 3) << (tempVar8 & 0xff);\n      tempVar6 = GPIOConfig->Mode;\n      if (((tempVar6 - 1 < 2) || (tempVar6 == 0x11)) || (tempVar6 == 0x12)) {\n        GPIO->OSPEEDR = GPIO->OSPEEDR & tempVar1 | GPIOConfig->Speed << (tempVar8 & 0xff);\n        GPIO->OTYPER =\n             GPIO->OTYPER & ~tempVar2 | ((GPIOConfig->Mode << 0x1b) >> 0x1f) << (tempVar3 & 0xff);\n      }\n      GPIO->PUPDR = tempVar1 & GPIO->PUPDR | GPIOConfig->Pull << (tempVar8 & 0xff);\n      tempVar1 = _DAT_40013c0c;\n      if ((GPIOConfig->Mode & 0x10000000) != 0) {\n        _DAT_40023844 = _DAT_40023844 | 0x4000;\n        index2 = (tempVar3 & 3) << 2;\n        if (GPIO == (GPIO_TypeDef *)0x40020000) {\n          index = 0;\n        }\n        else if (GPIO == (GPIO_TypeDef *)0x40020400) {\n          index = 1;\n        }\n        else if (GPIO == (GPIO_TypeDef *)0x40020800) {\n          index = 2;\n        }\n        else if (GPIO == (GPIO_TypeDef *)0x40020c00) {\n          index = 3;\n        }\n        else if (GPIO == (GPIO_TypeDef *)0x40021000) {\n          index = 4;\n        }\n        else if (GPIO == (GPIO_TypeDef *)0x40021400) {\n          index = 5;\n        }\n        else if (GPIO == (GPIO_TypeDef *)0x40021800) {\n          index = 6;\n        }\n        else if (GPIO == (GPIO_TypeDef *)0x40021c00) {\n          index = 7;\n        }\n        else if (GPIO == (GPIO_TypeDef *)0x40022000) {\n          index = 8;\n        }\n        else if (GPIO == (GPIO_TypeDef *)0x40022400) {\n          index = 9;\n        }\n        else {\n          index = 10;\n        }\n        *(uint *)(((tempVar3 >> 2) + 2) * 4 + 0x40013800) =\n             *(uint *)(((tempVar3 >> 2) + 2) * 4 + 0x40013800) & ~(0xf << index2) | index << index2;\n        tempVar1 = ~tempVar4;\n        tempVar2 = _DAT_40013c00 & tempVar1;\n        if ((GPIOConfig->Mode & 0x10000) != 0) {\n          tempVar2 = tempVar4 | _DAT_40013c00;\n        }\n        tempVar8 = tempVar1 & _DAT_40013c04;\n        if ((GPIOConfig->Mode & 0x20000) != 0) {\n          tempVar8 = tempVar4 | _DAT_40013c04;\n        }\n        tempVar5 = tempVar1 & _DAT_40013c08;\n        if ((GPIOConfig->Mode & 0x100000) != 0) {\n          tempVar5 = tempVar4 | _DAT_40013c08;\n        }\n        _DAT_40013c00 = tempVar2;\n        _DAT_40013c04 = tempVar8;\n        _DAT_40013c08 = tempVar5;\n        tempVar1 = tempVar1 & _DAT_40013c0c;\n        if ((GPIOConfig->Mode & 0x200000) != 0) {\n          tempVar1 = tempVar4 | _DAT_40013c0c;\n        }\n      }\n    }\n    _DAT_40013c0c = tempVar1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fb4": "configure_gpio_08000fb4",
                "GPIOx": "GPIO",
                "GPIO_Init": "GPIOConfig",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "uVar3": "tempVar3",
                "uVar4": "tempVar4",
                "uVar5": "tempVar5",
                "uVar6": "tempVar6",
                "iVar7": "index",
                "uVar8": "tempVar8",
                "iVar9": "index2",
                "tmpreg": "tmp_register"
            },
            "calling": [
                "digital_io_init",
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001198": {
            "entrypoint": "0x08001198",
            "current_name": "set_gpio_pin_state_08001198",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setGPIOPinState_08001198(GPIO_TypeDef *gpioPort,uint16_t pinNumber,pinNumberState pinState)\n\n{\n  if (pinState == GPIO_PIN_RESET) {\n    gpioPort->BSRR = (uint)pinNumber << 0x10;\n    return;\n  }\n  gpioPort->BSRR = (uint)pinNumber;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001198": "set_gpio_pin_state_08001198",
                "GPIOx": "gpioPort",
                "GPIO_Pin": "pinNumber",
                "PinState": "pinState"
            },
            "calling": [
                "digital_io_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011a4": {
            "entrypoint": "0x080011a4",
            "current_name": "handle_gpio_interrupt_080011a4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handleGPIOInterrupt_080011a4(uint16_t pinNumber)\n\n{\n  if ((_DAT_40013c14 & pinNumber) != 0) {\n    _DAT_40013c14 = (uint)pinNumber;\n    handleGPIOCallback(pinNumber);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080011a4": "handle_gpio_interrupt_080011a4",
                "GPIO_Pin": "pinNumber",
                "HAL_GPIO_EXTI_Callback": "handleGPIOCallback"
            },
            "calling": [
                "EXTI15_10_IRQHandler",
                "EXTI1_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI9_5_IRQHandler",
                "EXTI0_IRQHandler",
                "EXTI2_IRQHandler",
                "EXTI4_IRQHandler"
            ],
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011c0": {
            "entrypoint": "0x080011c0",
            "current_name": "set_device_address_mode_080011c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef setDeviceAddressMode_080011c0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  if (i2cHandle->operationMode == memoryMode) {\n    if (i2cHandle->eventCount == 0) {\n      i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xfe;\n    }\n    else {\n      i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xff | 1;\n    }\n  }\n  else if ((i2cHandle->Init).addressingMode == 0x4000) {\n    if (i2cHandle->i2cState == busyTransmitState) {\n      i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xfe;\n    }\n    else {\n      i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xff | 1;\n    }\n  }\n  else if (i2cHandle->eventCount == 0) {\n    i2cHandle->i2cInstance->dataRegister = (i2cHandle->deviceAddress << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (i2cHandle->eventCount == 1) {\n    i2cHandle->i2cInstance->dataRegister = (i2cHandle->deviceAddress << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080011c0": "set_device_address_mode_080011c0",
                "hi2c": "i2cHandle",
                "Mode": "operationMode",
                "EventCount": "eventCount",
                "Instance": "i2cInstance",
                "DR": "dataRegister",
                "Devaddress": "deviceAddress",
                "AddressingMode": "addressingMode",
                "State": "i2cState",
                "HAL_I2C_MODE_MEM": "memoryMode",
                "HAL_I2C_STATE_BUSY_TX": "busyTransmitState"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800124a": {
            "entrypoint": "0x0800124a",
            "current_name": "set_device_address_0800124a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef setDeviceAddress_0800124a(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2cHandle->Instance->DR = i2cHandle->Devaddress & 0xff;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800124a": "set_device_address_0800124a",
                "hi2c": "i2cHandle"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001256": {
            "entrypoint": "0x08001256",
            "current_name": "process_i2_c_transfer_08001256",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef processI2CTransfer_08001256(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t transferOptionsValue;\n  I2C_TypeDef *i2cInstance;\n  uint32_t previousState;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister_1;\n  uint32_t temporaryRegister_2;\n  uint32_t temporaryRegister_3;\n  uint32_t temporaryRegister_4;\n  uint32_t temporaryRegister_5;\n  uint32_t temporaryRegister_6;\n  uint32_t temporaryRegister_7;\n  uint32_t temporaryRegister_8;\n  uint32_t temporaryRegister_9;\n  \n  transferOptionsValue = i2cHandle->XferOptions;\n  if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) &&\n     ((i2cHandle->EventCount != 0 || (i2cHandle->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((i2cHandle->EventCount == 0) && ((i2cHandle->Init).AddressingMode == 0xc000)) {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n      i2cHandle->EventCount = i2cHandle->EventCount + 1;\n    }\n    else {\n      if (i2cHandle->XferCount == 0) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      }\n      else if (i2cHandle->XferCount == 1) {\n        if (transferOptionsValue == 0xffff0000) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cInstance = i2cHandle->Instance;\n          if ((i2cInstance->CR2 & 0x800) == 0) {\n            i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n          }\n          else {\n            i2cInstance->CR1 = i2cInstance->CR1 & 0xfffffbff;\n          }\n        }\n        else if (((transferOptionsValue == 4) || (transferOptionsValue == 8)) || (i2cHandle->PreviousState == 0x12)) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        }\n        else if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n      }\n      else if (i2cHandle->XferCount == 2) {\n        if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x800;\n        }\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      else {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      i2cHandle->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001256": "process_i2_c_transfer_08001256",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "uVar1": "transferOptionsValue",
                "pIVar2": "i2cInstance",
                "Prev_State": "previousState",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister_1",
                "tmpreg_2": "temporaryRegister_2",
                "tmpreg_3": "temporaryRegister_3",
                "tmpreg_4": "temporaryRegister_4",
                "tmpreg_5": "temporaryRegister_5",
                "tmpreg_6": "temporaryRegister_6",
                "tmpreg_7": "temporaryRegister_7",
                "tmpreg_8": "temporaryRegister_8",
                "tmpreg_9": "temporaryRegister_9"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001420": {
            "entrypoint": "0x08001420",
            "current_name": "update_i2_c_data_register_08001420",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef updateI2CDataRegister_08001420(I2C_HandleTypeDef *i2cHandle)\n\n{\n  byte *bufferPointer;\n  \n  if (i2cHandle->XferCount != 0) {\n    bufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPointer + 1;\n    i2cHandle->Instance->DR = (uint)*bufferPointer;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001420": "update_i2_c_data_register_08001420",
                "hi2c": "i2cHandle",
                "pbVar1": "bufferPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001440": {
            "entrypoint": "0x08001440",
            "current_name": "read_byte_from_i2_c_08001440",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef readByteFromI2C_08001440(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint8_t *puVar1;\n  \n  if (i2cHandle->transferCount != 0) {\n    puVar1 = i2cHandle->bufferPointer;\n    i2cHandle->bufferPointer = puVar1 + 1;\n    *puVar1 = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  return success;\n}\n\n",
            "renaming": {
                "FUN_08001440": "read_byte_from_i2_c_08001440",
                "hi2c": "i2cHandle",
                "XferCount": "transferCount",
                "pBuffPtr": "bufferPointer",
                "Instance": "i2cInstance",
                "DR": "dataRegister",
                "HAL_OK": "success"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001460": {
            "entrypoint": "0x08001460",
            "current_name": "initialize_i2_c_state_08001460",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\ninitializeI2CState_08001460(I2C_HandleTypeDef *i2cHandle,uint8_t *data,uint16_t size,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef status;\n  I2C_TypeDef *i2cInstance;\n  uint32_t tempRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = data;\n      i2cHandle->XferCount = size;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->Xfersize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001460": "initialize_i2_c_state_08001460",
                "hi2c": "i2cHandle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014ec": {
            "entrypoint": "0x080014ec",
            "current_name": "set_i2_c_slave_mode_080014ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nsetI2CSlaveMode_080014ec(I2C_HandleTypeDef *i2cHandle,uint8_t *data,uint16_t size,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef status;\n  I2C_TypeDef *i2cInstance;\n  uint32_t temporaryRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = data;\n      i2cHandle->XferCount = size;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->Xfersize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080014ec": "set_i2_c_slave_mode_080014ec",
                "hi2c": "i2cHandle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001578": {
            "entrypoint": "0x08001578",
            "current_name": "configure_i2_c_08001578",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureI2C_08001578(I2C_HandleTypeDef *I2CHandle)\n\n{\n  I2CType *I2CInstance;\n  \n  if (I2CHandle->State != I2CStateReady) {\n    return HALBusy;\n  }\n  I2CHandle->State = I2CStateListen;\n  I2CInstance = I2CHandle->Instance;\n  if ((I2CInstance->ControlRegister1 & 1) == 0) {\n    I2CInstance->ControlRegister1 = I2CInstance->ControlRegister1 | 1;\n  }\n  I2CHandle->Instance->ControlRegister1 = I2CHandle->Instance->ControlRegister1 | 0x400;\n  I2CHandle->Instance->ControlRegister2 = I2CHandle->Instance->ControlRegister2 | 0x300;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001578": "configure_i2_c_08001578",
                "hi2c": "I2CHandle",
                "pIVar1": "I2CInstance",
                "HAL_I2C_STATE_READY": "I2CStateReady",
                "HAL_BUSY": "HALBusy",
                "HAL_I2C_STATE_LISTEN": "I2CStateListen",
                "I2C_TypeDef": "I2CType",
                "CR1": "ControlRegister1",
                "CR2": "ControlRegister2"
            },
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b6": {
            "entrypoint": "0x080015b6",
            "current_name": "FUNC_080015b6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080015b6(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b6": "FUNC_080015b6"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015b8": {
            "entrypoint": "0x080015b8",
            "current_name": "FUNC_080015b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080015b8(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b8": "FUNC_080015b8"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015ba": {
            "entrypoint": "0x080015ba",
            "current_name": "FUNC_080015ba",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080015ba(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015ba": "FUNC_080015ba"
            },
            "calling": [
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_AF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015bc": {
            "entrypoint": "0x080015bc",
            "current_name": "transmit_data_080015bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef transmitData_080015bc(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  byte *dataPtr;\n  \n  currentState = i2cHandle->State;\n  if (i2cHandle->XferCount != 0) {\n    dataPtr = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = dataPtr + 1;\n    i2cHandle->Instance->DR = (uint)*dataPtr;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    if ((i2cHandle->XferCount == 0) && (currentState == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      i2cHandle->PreviousState = 0x21;\n      i2cHandle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(i2cHandle);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080015bc": "transmit_data_080015bc",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "pbVar2": "dataPtr"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800160c": {
            "entrypoint": "0x0800160c",
            "current_name": "FUNC_0800160c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800160c(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800160c": "FUNC_0800160c"
            },
            "calling": [
                "I2C_Slave_STOPF",
                "I2C_SlaveReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800160e": {
            "entrypoint": "0x0800160e",
            "current_name": "receive_data_from_i2_c_0800160e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef receiveDataFromI2C_0800160e(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2CState currentState;\n  uint8_t *bufferPointer;\n  \n  currentState = i2cHandle->State;\n  if (i2cHandle->XferCount != 0) {\n    bufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    if ((i2cHandle->XferCount == 0) && (currentState == I2CState.BUSY_RX_LISTEN)) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      i2cHandle->PreviousState = 0x22;\n      i2cHandle->State = I2CState.LISTEN;\n      handleSlaveReceiveComplete(i2cHandle);\n    }\n  }\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_0800160e": "receive_data_from_i2_c_0800160e",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "puVar2": "bufferPointer",
                "HAL_I2C_StateTypeDef": "I2CState",
                "HAL_I2C_STATE_BUSY_RX_LISTEN": "I2CState.BUSY_RX_LISTEN",
                "HAL_I2C_STATE_LISTEN": "I2CState.LISTEN",
                "HAL_I2C_SlaveRxCpltCallback": "handleSlaveReceiveComplete",
                "HAL_OK": "OK"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800165a": {
            "entrypoint": "0x0800165a",
            "current_name": "handle_i2_c_address_match_0800165a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CAddressMatch_0800165a(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint16_t addressMatchCode;\n  \n  if ((i2cHandle->Instance->SR2 & 0x80) == 0) {\n    addressMatchCode = *(uint16_t *)&(i2cHandle->Init).OwnAddress1;\n  }\n  else {\n    addressMatchCode = *(uint16_t *)&(i2cHandle->Init).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(i2cHandle,(i2cHandle->Instance->SR2 & 4) == 0,addressMatchCode);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800165a": "handle_i2_c_address_match_0800165a",
                "hi2c": "i2cHandle",
                "AddrMatchCode": "addressMatchCode"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001684": {
            "entrypoint": "0x08001684",
            "current_name": "handle_i2_c_state_08001684",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CState_08001684(I2C_HandleTypeDef *i2cHandler)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t currentState;\n  \n  if (((i2cHandler->XferOptions == 4) || (i2cHandler->XferOptions == 8)) &&\n     (i2cHandler->State == HAL_I2C_STATE_LISTEN)) {\n    i2cHandler->XferOptions = 0xffff0000;\n    i2cHandler->Instance->CR2 = i2cHandler->Instance->CR2 & 0xfffff8ff;\n    i2cHandler->Instance->SR1 = 0xfffffbff;\n    i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 & 0xfffffbff;\n    i2cHandler->PreviousState = 0;\n    i2cHandler->State = HAL_I2C_STATE_READY;\n    i2cHandler->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandler);\n  }\n  else if (i2cHandler->State == HAL_I2C_STATE_BUSY_TX) {\n    i2cHandler->XferOptions = 0xffff0000;\n    i2cHandler->PreviousState = 0x21;\n    i2cHandler->State = HAL_I2C_STATE_READY;\n    i2cHandler->Mode = HAL_I2C_MODE_NONE;\n    i2cHandler->Instance->CR2 = i2cHandler->Instance->CR2 & 0xfffff8ff;\n    i2cHandler->Instance->SR1 = 0xfffffbff;\n    i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 & 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback(i2cHandler);\n  }\n  else {\n    i2cHandler->Instance->SR1 = 0xfffffbff;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001684": "handle_i2_c_state_08001684",
                "hi2c": "i2cHandler",
                "CurrentXferOptions": "currentTransferOptions",
                "CurrentState": "currentState"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001718": {
            "entrypoint": "0x08001718",
            "current_name": "FUNC_08001718",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001718(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001718": "FUNC_08001718"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800171a": {
            "entrypoint": "0x0800171a",
            "current_name": "handle_i2_c_state_0800171a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CState_0800171a(I2C_HandleTypeDef *I2CHandle)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  uint32_t currentStateValue;\n  byte *bufferPtr;\n  uint32_t xferOptions;\n  uint32_t xferOptionsValue;\n  \n  currentState = I2CHandle->State;\n  xferOptionsValue = I2CHandle->XferOptions;\n  if ((I2CHandle->XferSize == 0) && (currentState == HAL_I2C_STATE_BUSY_TX)) {\n    if ((xferOptionsValue == 4) || ((xferOptionsValue == 8 || (xferOptionsValue == 0xffff0000)))) {\n      I2CHandle->Instance->CR2 = I2CHandle->Instance->CR2 & 0xfffff8ff;\n      I2CHandle->Instance->CR1 = I2CHandle->Instance->CR1 | 0x200;\n      I2CHandle->PreviousState = 0;\n      I2CHandle->State = HAL_I2C_STATE_READY;\n      if (I2CHandle->Mode == HAL_I2C_MODE_MEM) {\n        I2CHandle->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(I2CHandle);\n      }\n      else {\n        I2CHandle->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(I2CHandle);\n      }\n    }\n    else {\n      I2CHandle->Instance->CR2 = I2CHandle->Instance->CR2 & 0xfffff8ff;\n      I2CHandle->PreviousState = 0x11;\n      I2CHandle->Mode = HAL_I2C_MODE_NONE;\n      I2CHandle->State = HAL_I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(I2CHandle);\n    }\n  }\n  else if ((currentState == HAL_I2C_STATE_BUSY_TX) ||\n          ((I2CHandle->Mode == HAL_I2C_MODE_MEM && (currentState == HAL_I2C_STATE_BUSY_RX)))) {\n    if (I2CHandle->XferCount == 0) {\n      I2CHandle->Instance->CR2 = I2CHandle->Instance->CR2 & 0xfffffbff;\n    }\n    else if (I2CHandle->Mode == HAL_I2C_MODE_MEM) {\n      if (I2CHandle->EventCount == 0) {\n        if (I2CHandle->MemaddSize == 1) {\n          I2CHandle->Instance->DR = I2CHandle->Memaddress & 0xff;\n          I2CHandle->EventCount = I2CHandle->EventCount + 2;\n        }\n        else {\n          I2CHandle->Instance->DR = (I2CHandle->Memaddress << 0x10) >> 0x18;\n          I2CHandle->EventCount = I2CHandle->EventCount + 1;\n        }\n      }\n      else if (I2CHandle->EventCount == 1) {\n        I2CHandle->Instance->DR = I2CHandle->Memaddress & 0xff;\n        I2CHandle->EventCount = I2CHandle->EventCount + 1;\n      }\n      else if (I2CHandle->EventCount == 2) {\n        if (I2CHandle->State == HAL_I2C_STATE_BUSY_RX) {\n          I2CHandle->Instance->CR1 = I2CHandle->Instance->CR1 | 0x100;\n        }\n        else if (I2CHandle->State == HAL_I2C_STATE_BUSY_TX) {\n          bufferPtr = I2CHandle->pBuffPtr;\n          I2CHandle->pBuffPtr = bufferPtr + 1;\n          I2CHandle->Instance->DR = (uint)*bufferPtr;\n          I2CHandle->XferCount = I2CHandle->XferCount - 1;\n        }\n      }\n    }\n    else {\n      bufferPtr = I2CHandle->pBuffPtr;\n      I2CHandle->pBuffPtr = bufferPtr + 1;\n      I2CHandle->Instance->DR = (uint)*bufferPtr;\n      I2CHandle->XferCount = I2CHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800171a": "handle_i2_c_state_0800171a",
                "hi2c": "I2CHandle",
                "HVar1": "currentState",
                "CurrentState": "currentStateValue",
                "pbVar2": "bufferPtr",
                "CurrentXferOptions": "xferOptions",
                "uVar3": "xferOptionsValue"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001864": {
            "entrypoint": "0x08001864",
            "current_name": "handle_i2_ct_ransfer_08001864",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CTRansfer_08001864(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t transferOptions;\n  uint32_t currentTransferOptions;\n  byte *bufferPointer;\n  \n  transferOptions = i2cHandle->XferOptions;\n  if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    if (i2cHandle->XferCount == 0) {\n      if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        i2cHandle->PreviousState = 0;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(i2cHandle);\n        }\n        else {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(i2cHandle);\n        }\n      }\n      else {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->PreviousState = 0x11;\n        i2cHandle->Mode = HAL_I2C_MODE_NONE;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      bufferPointer = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPointer + 1;\n      i2cHandle->Instance->DR = (uint)*bufferPointer;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001864": "handle_i2_ct_ransfer_08001864",
                "hi2c": "i2cHandle",
                "uVar1": "transferOptions",
                "CurrentXferOptions": "currentTransferOptions",
                "pbVar2": "bufferPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001902": {
            "entrypoint": "0x08001902",
            "current_name": "FUNC_08001902",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001902(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001902": "FUNC_08001902"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001904": {
            "entrypoint": "0x08001904",
            "current_name": "process_i2_c_rx_buff_08001904",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef processI2CRxBuff_08001904(I2C_HandleTypeDef *i2cHandler)\n\n{\n  uint8_t *dataPtr;\n  \n  if (i2cHandler->State == HAL_I2C_STATE_BUSY_RX) {\n    if (i2cHandler->XferCount < 4) {\n      if (i2cHandler->XferCount < 2) {\n        i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 & 0xfffffbff;\n        i2cHandler->Instance->CR2 = i2cHandler->Instance->CR2 & 0xfffff8ff;\n        dataPtr = i2cHandler->pBuffPtr;\n        i2cHandler->pBuffPtr = dataPtr + 1;\n        *dataPtr = (uint8_t)i2cHandler->Instance->DR;\n        i2cHandler->XferCount = i2cHandler->XferCount - 1;\n        i2cHandler->State = HAL_I2C_STATE_READY;\n        i2cHandler->PreviousState = 0;\n        if (i2cHandler->Mode == HAL_I2C_MODE_MEM) {\n          i2cHandler->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemRxCpltCallback(i2cHandler);\n        }\n        else {\n          i2cHandler->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterRxCpltCallback(i2cHandler);\n        }\n      }\n    }\n    else {\n      dataPtr = i2cHandler->pBuffPtr;\n      i2cHandler->pBuffPtr = dataPtr + 1;\n      *dataPtr = (uint8_t)i2cHandler->Instance->DR;\n      i2cHandler->XferCount = i2cHandler->XferCount - 1;\n      if (i2cHandler->XferCount == 3) {\n        i2cHandler->Instance->CR2 = i2cHandler->Instance->CR2 & 0xfffffbff;\n      }\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001904": "process_i2_c_rx_buff_08001904",
                "hi2c": "i2cHandler",
                "puVar1": "dataPtr"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080019a0": {
            "entrypoint": "0x080019a0",
            "current_name": "process_i2_c_data_080019a0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef processI2CData_080019a0(I2C_HandleTypeDef *I2C_HandleTypeDef)\n\n{\n  uint32_t xferOptions;\n  uint8_t *bufferPointer;\n  \n  if (I2C_HandleTypeDef->XferCount == 4) {\n    I2C_HandleTypeDef->Instance->CR2 = I2C_HandleTypeDef->Instance->CR2 & 0xfffffbff;\n    bufferPointer = I2C_HandleTypeDef->pBuffPtr;\n    I2C_HandleTypeDef->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)I2C_HandleTypeDef->Instance->DR;\n    I2C_HandleTypeDef->XferCount = I2C_HandleTypeDef->XferCount - 1;\n  }\n  else if (I2C_HandleTypeDef->XferCount == 3) {\n    I2C_HandleTypeDef->Instance->CR2 = I2C_HandleTypeDef->Instance->CR2 & 0xfffffbff;\n    I2C_HandleTypeDef->Instance->CR1 = I2C_HandleTypeDef->Instance->CR1 & 0xfffffbff;\n    bufferPointer = I2C_HandleTypeDef->pBuffPtr;\n    I2C_HandleTypeDef->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)I2C_HandleTypeDef->Instance->DR;\n    I2C_HandleTypeDef->XferCount = I2C_HandleTypeDef->XferCount - 1;\n  }\n  else if (I2C_HandleTypeDef->XferCount == 2) {\n    if (I2C_HandleTypeDef->XferOptions - 1 < 2) {\n      I2C_HandleTypeDef->Instance->CR1 = I2C_HandleTypeDef->Instance->CR1 & 0xfffffbff;\n      I2C_HandleTypeDef->Instance->CR1 = I2C_HandleTypeDef->Instance->CR1 | 0x100;\n    }\n    else {\n      I2C_HandleTypeDef->Instance->CR1 = I2C_HandleTypeDef->Instance->CR1 | 0x200;\n    }\n    bufferPointer = I2C_HandleTypeDef->pBuffPtr;\n    I2C_HandleTypeDef->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)I2C_HandleTypeDef->Instance->DR;\n    I2C_HandleTypeDef->XferCount = I2C_HandleTypeDef->XferCount - 1;\n    bufferPointer = I2C_HandleTypeDef->pBuffPtr;\n    I2C_HandleTypeDef->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)I2C_HandleTypeDef->Instance->DR;\n    I2C_HandleTypeDef->XferCount = I2C_HandleTypeDef->XferCount - 1;\n    I2C_HandleTypeDef->Instance->CR2 = I2C_HandleTypeDef->Instance->CR2 & 0xfffffcff;\n    I2C_HandleTypeDef->State = HAL_I2C_STATE_READY;\n    I2C_HandleTypeDef->PreviousState = 0;\n    if (I2C_HandleTypeDef->Mode == HAL_I2C_MODE_MEM) {\n      I2C_HandleTypeDef->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef);\n    }\n    else {\n      I2C_HandleTypeDef->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef);\n    }\n  }\n  else {\n    bufferPointer = I2C_HandleTypeDef->pBuffPtr;\n    I2C_HandleTypeDef->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)I2C_HandleTypeDef->Instance->DR;\n    I2C_HandleTypeDef->XferCount = I2C_HandleTypeDef->XferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080019a0": "process_i2_c_data_080019a0",
                "hi2c": "I2C_HandleTypeDef",
                "CurrentXferOptions": "xferOptions",
                "puVar1": "bufferPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001aac": {
            "entrypoint": "0x08001aac",
            "current_name": "FUNC_08001aac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001aac(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001aac": "FUNC_08001aac"
            },
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "handle_i2_c_state_08001ab0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CState_08001ab0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t *bufferPtr;\n  I2C_TypeDef *i2cInstance;\n  \n  if (i2cHandle->State - 0x29 < 2) {\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((i2cHandle->State != HAL_I2C_STATE_ABORT) && ((i2cHandle->Instance->CR2 & 0x800) == 0)) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n    }\n    i2cHandle->PreviousState = 0;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  }\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) == 0) {\n    if (i2cHandle->State == HAL_I2C_STATE_ABORT) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->ErrorCode = 0;\n      if ((i2cInstance->SR1 & 0x40) != 0) {\n        bufferPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = bufferPtr + 1;\n        *bufferPtr = (uint8_t)i2cInstance->DR;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(i2cHandle);\n    }\n    else {\n      if ((i2cInstance->SR1 & 0x40) != 0) {\n        bufferPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = bufferPtr + 1;\n        *bufferPtr = (uint8_t)i2cInstance->DR;\n      }\n      HAL_I2C_ErrorCallback(i2cHandle);\n    }\n  }\n  else {\n    i2cInstance->CR2 = i2cInstance->CR2 & 0xfffff7ff;\n    if (i2cHandle->hdmatx->State == HAL_DMA_STATE_READY) {\n      i2cHandle->hdmarx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->hdmarx);\n      if (status != HAL_OK) {\n        if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n          bufferPtr = i2cHandle->pBuffPtr;\n          i2cHandle->pBuffPtr = bufferPtr + 1;\n          *bufferPtr = (uint8_t)i2cHandle->Instance->DR;\n        }\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        (*i2cHandle->hdmarx->XferAbortCallback)(i2cHandle->hdmarx);\n      }\n    }\n    else {\n      i2cHandle->hdmatx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->hdmatx);\n      if (status != HAL_OK) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        (*i2cHandle->hdmatx->XferAbortCallback)(i2cHandle->hdmatx);\n      }\n    }\n  }\n  if ((i2cHandle->State == HAL_I2C_STATE_LISTEN) && ((i2cHandle->ErrorCode & 4) != 0)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "handle_i2_c_state_08001ab0",
                "hi2c": "i2cHandle",
                "HVar1": "status",
                "puVar2": "bufferPtr",
                "pIVar3": "i2cInstance"
            },
            "calling": [
                "I2C_Slave_STOPF",
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback",
                "HAL_DMA_Abort_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001bfc": {
            "entrypoint": "0x08001bfc",
            "current_name": "handle_i2_c_transfer_08001bfc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CTransfer_08001bfc(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  I2C_TypeDef *i2cInstance;\n  uint8_t *pBufferPtr;\n  uint32_t currentState;\n  uint32_t tempRegister;\n  \n  currentState = i2cHandle->State;\n  i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) != 0) {\n    if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) || (i2cHandle->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmarx->Instance->NDTR;\n    }\n    else {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmatx->Instance->NDTR;\n    }\n  }\n  if (i2cHandle->XferCount != 0) {\n    if ((i2cInstance->SR1 & 4) != 0) {\n      pBufferPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = pBufferPtr + 1;\n      *pBufferPtr = (uint8_t)i2cInstance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n      pBufferPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = pBufferPtr + 1;\n      *pBufferPtr = (uint8_t)i2cHandle->Instance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n  }\n  if (i2cHandle->ErrorCode == 0) {\n    if (((currentState == HAL_I2C_STATE_LISTEN) || (currentState == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (currentState == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2cHandle->XferOptions = 0xffff0000;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(i2cHandle);\n    }\n    else if ((i2cHandle->PreviousState == 0x22) || (currentState == HAL_I2C_STATE_BUSY_RX)) {\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  else {\n    I2C_ITError(i2cHandle);\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001bfc": "handle_i2_c_transfer_08001bfc",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "pIVar2": "i2cInstance",
                "puVar3": "pBufferPtr",
                "CurrentState": "currentState",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveRxCpltCallback",
                "I2C_ITError"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001d00": {
            "entrypoint": "0x08001d00",
            "current_name": "handle_i2_c_interrupt_08001d00",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CInterrupt_08001d00(I2C_HandleTypeDef *i2cHandler)\n\n{\n  I2C_TypeDef *i2cInstance;\n  uint32_t currentMode;\n  uint statusRegister1;\n  uint32_t statusFlags1;\n  uint controlRegister2;\n  uint32_t interruptSources;\n  uint statusRegister2;\n  uint32_t sr2itflags;\n  \n  i2cInstance = i2cHandler->Instance;\n  statusRegister2 = i2cInstance->SR2;\n  statusRegister1 = i2cInstance->SR1;\n  controlRegister2 = i2cInstance->CR2;\n  if ((i2cHandler->Mode == HAL_I2C_MODE_MASTER) || (i2cHandler->Mode == HAL_I2C_MODE_MEM)) {\n    if (((statusRegister1 & 0x10001) == 0) || ((controlRegister2 & 0x200) == 0)) {\n      if (((statusRegister1 & 0x10008) == 0) || ((controlRegister2 & 0x200) == 0)) {\n        if (((statusRegister1 & 0x10002) != 0) && ((controlRegister2 & 0x200) != 0)) {\n          I2C_Master_ADDR(i2cHandler);\n        }\n      }\n      else {\n        I2C_Master_ADD10(i2cHandler);\n      }\n    }\n    else {\n      I2C_Master_SB(i2cHandler);\n    }\n    if ((statusRegister2 & 0x100004) == 0) {\n      if ((((statusRegister1 & 0x10040) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_MasterReceive_RXNE(i2cHandler);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(i2cHandler);\n        return;\n      }\n    }\n    else {\n      if ((((statusRegister1 & 0x10080) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_MasterTransmit_TXE(i2cHandler);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(i2cHandler);\n        return;\n      }\n    }\n  }\n  else {\n    if (((statusRegister1 & 0x10002) != 0) && ((controlRegister2 & 0x200) != 0)) {\n      I2C_Slave_ADDR(i2cHandler);\n      return;\n    }\n    if (((statusRegister1 & 0x10010) != 0) && ((controlRegister2 & 0x200) != 0)) {\n      I2C_Slave_STOPF(i2cHandler);\n      return;\n    }\n    if ((statusRegister2 & 0x100004) == 0) {\n      if ((((statusRegister1 & 0x10040) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_SlaveReceive_RXNE(i2cHandler);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(i2cHandler);\n      }\n    }\n    else {\n      if ((((statusRegister1 & 0x10080) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_SlaveTransmit_TXE(i2cHandler);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(i2cHandler);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001d00": "handle_i2_c_interrupt_08001d00",
                "hi2c": "i2cHandler",
                "pIVar1": "i2cInstance",
                "CurrentMode": "currentMode",
                "uVar2": "statusRegister1",
                "sr1itflags": "statusFlags1",
                "uVar3": "controlRegister2",
                "itsources": "interruptSources",
                "uVar4": "statusRegister2"
            },
            "calling": [
                "I2C2_EV_IRQHandler",
                "I2C1_EV_IRQHandler",
                "I2C3_EV_IRQHandler"
            ],
            "called": [
                "I2C_Slave_STOPF",
                "I2C_MasterReceive_BTF",
                "I2C_SlaveReceive_RXNE",
                "I2C_Master_ADD10",
                "I2C_Master_SB",
                "I2C_MasterTransmit_TXE",
                "I2C_Master_ADDR",
                "I2C_SlaveReceive_BTF",
                "I2C_SlaveTransmit_TXE",
                "I2C_MasterTransmit_BTF",
                "I2C_MasterReceive_RXNE",
                "I2C_Slave_ADDR",
                "I2C_SlaveTransmit_BTF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e68": {
            "entrypoint": "0x08001e68",
            "current_name": "process_i2_c_event_08001e68",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processI2CEvent_08001e68(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef i2cState;\n  I2C_TypeDef *i2cInstance;\n  uint32_t statusRegisters;\n  uint sr1Value;\n  uint32_t itsources;\n  uint cr2Value;\n  \n  i2cInstance = i2cHandle->Instance;\n  sr1Value = i2cInstance->SR1;\n  cr2Value = i2cInstance->CR2;\n  if (((sr1Value & 0x10100) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 1;\n    i2cInstance->SR1 = 0xfffffeff;\n  }\n  if (((sr1Value & 0x10200) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 2;\n    i2cHandle->Instance->SR1 = 0xfffffdff;\n  }\n  if (((sr1Value & 0x10400) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cState = i2cHandle->State;\n    if (((i2cHandle->Mode == HAL_I2C_MODE_SLAVE) && (i2cHandle->XferCount == 0)) &&\n       (((i2cState == HAL_I2C_STATE_BUSY_TX || (i2cState == HAL_I2C_STATE_BUSY_TX_LISTEN)) ||\n        ((i2cState == HAL_I2C_STATE_LISTEN && (i2cHandle->PreviousState == 0x21)))))) {\n      I2C_Slave_AF(i2cHandle);\n    }\n    else {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n      if (i2cHandle->Mode == HAL_I2C_MODE_MASTER) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      }\n      i2cHandle->Instance->SR1 = 0xfffffbff;\n    }\n  }\n  if (((sr1Value & 0x10800) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 8;\n    i2cHandle->Instance->SR1 = 0xfffff7ff;\n  }\n  if (i2cHandle->ErrorCode != 0) {\n    I2C_ITError(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001e68": "process_i2_c_event_08001e68",
                "hi2c": "i2cHandle",
                "HVar1": "i2cState",
                "pIVar2": "i2cInstance",
                "sr1itflags": "statusRegisters",
                "uVar3": "sr1Value",
                "uVar4": "cr2Value"
            },
            "calling": [
                "I2C3_ER_IRQHandler",
                "I2C2_ER_IRQHandler",
                "I2C1_ER_IRQHandler"
            ],
            "called": [
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f3c": {
            "entrypoint": "0x08001f3c",
            "current_name": "reset_i2_c_state_08001f3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetI2CState_08001f3c(DMA_HandleTypeDef *dmaHandle)\n\n{\n  I2C_HandleTypeDef *parentI2CHandle;\n  I2C_HandleTypeDef *currentI2CHandle;\n  \n  parentI2CHandle = (I2C_HandleTypeDef *)dmaHandle->Parent;\n  parentI2CHandle->i2cInstance->controlReg1 = parentI2CHandle->i2cInstance->controlReg1 & 0xfffffbff;\n  parentI2CHandle->transferCount = 0;\n  parentI2CHandle->dmaTransmitHandle->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  parentI2CHandle->dmaReceiveHandle->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  if (parentI2CHandle->State != I2C_STATE_ABORT) {\n    parentI2CHandle->State = I2C_STATE_READY;\n    parentI2CHandle->Mode = I2C_MODE_NONE;\n    parentI2CHandle->i2cInstance->controlReg1 = parentI2CHandle->i2cInstance->controlReg1 & 0xfffffffe;\n    handleI2CError(parentI2CHandle);\n    return;\n  }\n  parentI2CHandle->State = I2C_STATE_READY;\n  parentI2CHandle->Mode = I2C_MODE_NONE;\n  parentI2CHandle->error = 0;\n  parentI2CHandle->i2cInstance->controlReg1 = parentI2CHandle->i2cInstance->controlReg1 & 0xfffffffe;\n  handleI2CAbortComplete(parentI2CHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001f3c": "reset_i2_c_state_08001f3c",
                "hdma": "dmaHandle",
                "hi2c_00": "parentI2CHandle",
                "hi2c": "currentI2CHandle",
                "HAL_I2C_STATE_ABORT": "I2C_STATE_ABORT",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_I2C_MODE_NONE": "I2C_MODE_NONE",
                "HAL_I2C_ErrorCallback": "handleI2CError",
                "HAL_I2C_AbortCpltCallback": "handleI2CAbortComplete",
                "CR1": "controlReg1",
                "XferCount": "transferCount",
                "hdmatx": "dmaTransmitHandle",
                "hdmarx": "dmaReceiveHandle",
                "ErrorCode": "error",
                "Instance": "i2cInstance"
            },
            "calling": [],
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f9c": {
            "entrypoint": "0x08001f9c",
            "current_name": "check_timeout_08001f9c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef checkTimeout_08001f9c(void)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint32_t tmpreg;\n  \n  _DAT_40023840 = _DAT_40023840 | 0x10000000;\n  _DAT_420e0040 = 1;\n  uVar1 = getCurrentTick();\n  do {\n    if ((_DAT_40007004 & 0x10000) != 0) {\n      _DAT_420e0044 = 1;\n      uVar1 = getCurrentTick();\n      do {\n        if ((_DAT_40007004 & 0x20000) != 0) {\n          return Success;\n        }\n        uVar2 = getCurrentTick();\n      } while (uVar2 - uVar1 < 0x3e9);\n      return Timeout;\n    }\n    uVar2 = getCurrentTick();\n  } while (uVar2 - uVar1 < 0x3e9);\n  return Timeout;\n}\n\n",
            "renaming": {
                "FUN_08001f9c": "check_timeout_08001f9c",
                "HAL_GetTick()": "getCurrentTick()",
                "HAL_OK": "Success",
                "HAL_TIMEOUT": "Timeout"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800201c": {
            "entrypoint": "0x0800201c",
            "current_name": "initialize_rcc_oscillators_0800201c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_Status initializeRCCOscillators_0800201c(RCC_OscInitTypeDef_conflict *oscillatorsConfig)\n\n{\n  HAL_Status status;\n  uint32_t startTick;\n  uint32_t currentTick;\n  uint32_t tickStart;\n  bool isFlagSet;\n  uint32_t tempReg;\n  \n  if (oscillatorsConfig == (RCC_OscInitTypeDef_conflict *)0x0) {\n    return HAL_ERROR;\n  }\n  if ((oscillatorsConfig->OscillatorType & 1) != 0) {\n    if (((_DAT_40023808 & 0xc) == 4) ||\n       (((_DAT_40023808 & 0xc) == 8 && ((_DAT_40023804 & 0x400000) != 0)))) {\n      if (((_DAT_40023800 & 0x20000) != 0) && (oscillatorsConfig->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      if (oscillatorsConfig->HSEState == 0x10000) {\n        _DAT_40023800 = _DAT_40023800 | 0x10000;\n      }\n      else if (oscillatorsConfig->HSEState == 0x50000) {\n        _DAT_40023800 = _DAT_40023800 | 0x50000;\n      }\n      else {\n        _DAT_40023800 = _DAT_40023800 & 0xfffaffff;\n      }\n      if (oscillatorsConfig->HSEState == 0) {\n        startTick = HAL_GetTick();\n        while ((_DAT_40023800 & 0x20000) != 0) {\n          currentTick = HAL_GetTick();\n          if (100 < currentTick - startTick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        startTick = HAL_GetTick();\n        while ((_DAT_40023800 & 0x20000) == 0) {\n          currentTick = HAL_GetTick();\n          if (100 < currentTick - startTick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((oscillatorsConfig->OscillatorType & 2) != 0) {\n    if (((_DAT_40023808 & 0xc) == 0) ||\n       (((_DAT_40023808 & 0xc) == 8 && ((_DAT_40023804 & 0x400000) == 0)))) {\n      if (((_DAT_40023800 & 2) != 0) && (oscillatorsConfig->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      _DAT_40023800 = _DAT_40023800 & 0xffffff07 | oscillatorsConfig->HSICalibrationValue << 3;\n    }\n    else if (oscillatorsConfig->HSIState == 0) {\n      _DAT_42470000 = 0;\n      startTick = HAL_GetTick();\n      while ((_DAT_40023800 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470000 = 1;\n      startTick = HAL_GetTick();\n      while ((_DAT_40023800 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40023800 = _DAT_40023800 & 0xffffff07 | oscillatorsConfig->HSICalibrationValue << 3;\n    }\n  }\n  if ((oscillatorsConfig->OscillatorType & 8) != 0) {\n    if (oscillatorsConfig->LSIState == 0) {\n      _DAT_42470e80 = 0;\n      startTick = HAL_GetTick();\n      while ((_DAT_40023874 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470e80 = 1;\n      startTick = HAL_GetTick();\n      while ((_DAT_40023874 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((oscillatorsConfig->OscillatorType & 4) != 0) {\n    isFlagSet = (_DAT_40023840 & 0x10000000) == 0;\n    if (isFlagSet) {\n      _DAT_40023840 = _DAT_40023840 | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTick = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (oscillatorsConfig->LSEState == 1) {\n      _DAT_40023870 = _DAT_40023870 | 1;\n    }\n    else if (oscillatorsConfig->LSEState == 5) {\n      _DAT_40023870 = _DAT_40023870 | 5;\n    }\n    else {\n      _DAT_40023870 = _DAT_40023870 & 0xfffffffa;\n    }\n    if (oscillatorsConfig->LSEState == 0) {\n      startTick = HAL_GetTick();\n      while ((_DAT_40023870 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (5000 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      startTick = HAL_GetTick();\n      while ((_DAT_40023870 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (5000 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (isFlagSet) {\n      _DAT_40023840 = _DAT_40023840 & 0xefffffff;\n    }\n  }\n  startTick = (oscillatorsConfig->PLL).PLLState;\n  if (startTick == 0) {\n    status = HAL_OK;\n  }\n  else if ((_DAT_40023808 & 0xc) == 8) {\n    status = HAL_ERROR;\n  }\n  else if (startTick == 2) {\n    _DAT_42470060 = 0;\n    startTick = HAL_GetTick();\n    do {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        _DAT_40023804 =\n             (oscillatorsConfig->PLL).PLLSource | (oscillatorsConfig->PLL).PLLM |\n             (oscillatorsConfig->PLL).PLLN << 6 |\n             (((oscillatorsConfig->PLL).PLLP >> 1) - 1) * 0x10000 |\n             (oscillatorsConfig->PLL).PLLQ << 0x18;\n        _DAT_42470060 = 1;\n        startTick = HAL_GetTick();\n        do {\n          if ((_DAT_40023800 & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          currentTick = HAL_GetTick();\n        } while (currentTick - startTick < 3);\n        return HAL_TIMEOUT;\n      }\n      currentTick = HAL_GetTick();\n    } while (currentTick - startTick < 3);\n    status = HAL_TIMEOUT;\n  }\n  else {\n    _DAT_42470060 = 0;\n    startTick = HAL_GetTick();\n    do {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      currentTick = HAL_GetTick();\n    } while (currentTick - startTick < 3);\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800201c": "initialize_rcc_oscillators_0800201c",
                "RCC_OscInitStruct": "oscillatorsConfig",
                "HAL_StatusTypeDef": "HAL_Status",
                "HVar1": "status",
                "uVar2": "startTick",
                "uVar3": "currentTick",
                "tickstart": "tickStart",
                "bVar4": "isFlagSet",
                "tmpreg": "tempReg"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080023b4": {
            "entrypoint": "0x080023b4",
            "current_name": "calculate_frequency_080023b4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateFrequency_080023b4(void)\n\n{\n  uint quotient;\n  \n  if ((_DAT_40023808 & 0xc) == 4) {\n    return 8000000;\n  }\n  if ((_DAT_40023808 & 0xc) != 8) {\n    return 16000000;\n  }\n  if ((_DAT_40023804 & 0x400000) == 0) {\n    quotient = (_DAT_40023804 << 0x11) >> 0x17;\n    quotient = __aeabi_uldivmod(quotient * 16000000,\n                             (((uint)(quotient * 0x20 < quotient) * -0x3f -\n                              (uint)(quotient * 0x7c0 < quotient * 0x1f)) * 8 +\n                             (uint)CARRY4(quotient * 0x3d08,quotient)) * 0x400 | quotient * 0x3d09 >> 0x16,\n                             _DAT_40023804 & 0x3f,0);\n  }\n  else {\n    quotient = (_DAT_40023804 << 0x11) >> 0x17;\n    quotient = __aeabi_uldivmod(quotient * 8000000,\n                             (((uint)(quotient * 0x20 < quotient) * -0x3f -\n                              (uint)(quotient * 0x7c0 < quotient * 0x1f)) * 8 +\n                             (uint)CARRY4(quotient * 0x3d08,quotient)) * 0x200,_DAT_40023804 & 0x3f,0);\n  }\n  return quotient / ((((_DAT_40023804 << 0xe) >> 0x1e) + 1) * 2);\n}\n\n",
            "renaming": {
                "FUN_080023b4": "calculate_frequency_080023b4",
                "uVar1": "quotient"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "__aeabi_uldivmod"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002488": {
            "entrypoint": "0x08002488",
            "current_name": "configure_clocks_08002488",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureClocks_08002488(clockConfig *RCC_ClkInitStruct,uint32_t flashLatency)\n\n{\n  uint32_t tempVar1;\n  uint32_t tempVar2;\n  uint tempVar3;\n  uint32_t timeStart;\n  \n  if (RCC_ClkInitStruct == (clockConfig *)0x0) {\n    return HAL_ERROR;\n  }\n  if (((_DAT_40023c00 & 0xf) < flashLatency) &&\n     (_DAT_40023c00 = CONCAT31(DAT_40023c00_1,(char)flashLatency), flashLatency != (flashLatency & 0xf))) {\n    return HAL_ERROR;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 2) != 0) {\n    if ((RCC_ClkInitStruct->ClockType & 4) != 0) {\n      _DAT_40023808 = _DAT_40023808 | 0x1c00;\n    }\n    if ((RCC_ClkInitStruct->ClockType & 8) != 0) {\n      _DAT_40023808 = _DAT_40023808 | 0xe000;\n    }\n    _DAT_40023808 = _DAT_40023808 & 0xffffff0f | RCC_ClkInitStruct->AHBCLKDivider;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 1) != 0) {\n    tempVar3 = RCC_ClkInitStruct->SYSCLKSource;\n    if (tempVar3 == 1) {\n      if ((_DAT_40023800 & 0x20000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if (tempVar3 - 2 < 2) {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((_DAT_40023800 & 2) == 0) {\n      return HAL_ERROR;\n    }\n    _DAT_40023808 = tempVar3 | _DAT_40023808 & 0xfffffffc;\n    tempVar1 = getElapsedTime();\n    while ((_DAT_40023808 & 0xc) != RCC_ClkInitStruct->SYSCLKSource * 4) {\n      tempVar2 = getElapsedTime();\n      if (5000 < tempVar2 - tempVar1) {\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  if ((flashLatency < (_DAT_40023c00 & 0xf)) &&\n     (_DAT_40023c00 = CONCAT31(DAT_40023c00_1,(char)flashLatency), flashLatency != (flashLatency & 0xf))) {\n    return HAL_ERROR;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 4) != 0) {\n    _DAT_40023808 = _DAT_40023808 & 0xffffe3ff | RCC_ClkInitStruct->APB1CLKDivider;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 8) != 0) {\n    _DAT_40023808 = _DAT_40023808 & 0xffff1fff | RCC_ClkInitStruct->APB2CLKDivider << 3;\n  }\n  tempVar1 = getSysClockFrequency();\n  sysCoreClock = tempVar1 >> \"\"[(_DAT_40023808 << 0x18) >> 0x1c];\n  initializeTick(0xf);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002488": "configure_clocks_08002488",
                "RCC_ClkInitTypeDef_conflict": "clockConfig",
                "FLatency": "flashLatency",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "uVar3": "tempVar3",
                "tickstart": "timeStart",
                "HAL_GetTick": "getElapsedTime",
                "SystemCoreClock": "sysCoreClock",
                "HAL_RCC_GetSysClockFreq": "getSysClockFrequency",
                "HAL_InitTick": "initializeTick"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_RCC_GetSysClockFreq",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025e0": {
            "entrypoint": "0x080025e0",
            "current_name": "get_system_core_clock_080025e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_080025e0(void)\n\n{\n  return systemCoreClock;\n}\n\n",
            "renaming": {
                "FUN_080025e0": "get_system_core_clock_080025e0",
                "SystemCoreClock": "systemCoreClock"
            },
            "calling": [
                "SystemClock_Config",
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025ec": {
            "entrypoint": "0x080025ec",
            "current_name": "get_hclk_frequency_080025ec",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getHCLKFrequency_080025ec(void)\n\n{\n  uint32_t frequency;\n  \n  frequency = HAL_RCC_GetHCLKFreq();\n  return frequency >> \"\"[(uint)(_DAT_40023808 << 0x13) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_080025ec": "get_hclk_frequency_080025ec",
                "uVar1": "frequency"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800260c": {
            "entrypoint": "0x0800260c",
            "current_name": "get_hclk_frequency_0800260c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getHCLKFrequency_0800260c(void)\n\n{\n  uint32_t hclkFrequency;\n  \n  hclkFrequency = HAL_RCC_GetHCLKFrequency();\n  return hclkFrequency >> \"\"[(uint)(_DAT_40023808 << 0x10) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_0800260c": "get_hclk_frequency_0800260c",
                "uVar1": "hclkFrequency",
                "HAL_RCC_GetHCLKFreq": "HAL_RCC_GetHCLKFrequency"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800262c": {
            "entrypoint": "0x0800262c",
            "current_name": "process_alarm_events_0800262c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid processAlarmEvents_0800262c(RTC_HandleTypeDef *rtcHandle)\n\n{\n  if (((rtcHandle->Instance->ISR & 0x100) != 0) && ((rtcHandle->Instance->CR & 0x1000) != 0)) {\n    handleAlarmEventA(rtcHandle);\n    rtcHandle->Instance->ISR = rtcHandle->Instance->ISR & 0xff | 0xfffffe7f;\n  }\n  if (((rtcHandle->Instance->ISR & 0x200) != 0) && ((rtcHandle->Instance->CR & 0x2000) != 0)) {\n    handleAlarmEventB(rtcHandle);\n    rtcHandle->Instance->ISR = rtcHandle->Instance->ISR & 0xff | 0xfffffd7f;\n  }\n  _DAT_40013c14 = 0x20000;\n  rtcHandle->State = HAL_RTC_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800262c": "process_alarm_events_0800262c",
                "hrtc": "rtcHandle",
                "HAL_RTC_AlarmAEventCallback": "handleAlarmEventA",
                "HAL_RTCEx_AlarmBEventCallback": "handleAlarmEventB"
            },
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "called": [
                "HAL_RTC_AlarmAEventCallback",
                "HAL_RTCEx_AlarmBEventCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800268c": {
            "entrypoint": "0x0800268c",
            "current_name": "FUNC_0800268c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800268c(RTC_HandleTypeDef *hrtc)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800268c": "FUNC_0800268c"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800268e": {
            "entrypoint": "0x0800268e",
            "current_name": "reset_timer_0800268e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef resetTimer_0800268e(TIM_HandleTypeDef *timer)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  timer->State = HAL_TIM_STATE_BUSY;\n  timerInstance = timer->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  HAL_TIM_PWM_MspDeInit(timer);\n  timer->State = HAL_TIM_STATE_RESET;\n  timer->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800268e": "reset_timer_0800268e",
                "htim": "timer",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080026c8": {
            "entrypoint": "0x080026c8",
            "current_name": "FUNC_080026c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080026c8(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026c8": "FUNC_080026c8"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026ca": {
            "entrypoint": "0x080026ca",
            "current_name": "FUNC_080026ca",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080026ca(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026ca": "FUNC_080026ca"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026cc": {
            "entrypoint": "0x080026cc",
            "current_name": "FUNC_080026cc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080026cc(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026cc": "FUNC_080026cc"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026ce": {
            "entrypoint": "0x080026ce",
            "current_name": "handle_tim_interrupts_080026ce",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_TIM_interrupts_080026ce(TIM_HandleTypeDef *TIM_handle)\n\n{\n  TIM_TypeDef *tim_instance;\n  \n  tim_instance = TIM_handle->Instance;\n  if (((tim_instance->status_register & 2) != 0) && ((tim_instance->DMA_interrupt_enable_register & 2) != 0)) {\n    tim_instance->status_register = 0xfffffffd;\n    TIM_handle->active_channel = TIM_CHANNEL_1;\n    if ((TIM_handle->Instance->capture_compare_mode_register_1 & 3) == 0) {\n      handle_OC_DelayElapsed_callback(TIM_handle);\n      handle_PWM_PulseFinished_callback(TIM_handle);\n    }\n    else {\n      handle_IC_Capture_callback(TIM_handle);\n    }\n    TIM_handle->active_channel = TIM_CHANNEL_CLEARED;\n  }\n  tim_instance = TIM_handle->Instance;\n  if (((tim_instance->status_register & 4) != 0) && ((tim_instance->DMA_interrupt_enable_register & 4) != 0)) {\n    tim_instance->status_register = 0xfffffffb;\n    TIM_handle->active_channel = TIM_CHANNEL_2;\n    if ((TIM_handle->Instance->capture_compare_mode_register_1 & 0x300) == 0) {\n      handle_OC_DelayElapsed_callback(TIM_handle);\n      handle_PWM_PulseFinished_callback(TIM_handle);\n    }\n    else {\n      handle_IC_Capture_callback(TIM_handle);\n    }\n    TIM_handle->active_channel = TIM_CHANNEL_CLEARED;\n  }\n  tim_instance = TIM_handle->Instance;\n  if (((tim_instance->status_register & 8) != 0) && ((tim_instance->DMA_interrupt_enable_register & 8) != 0)) {\n    tim_instance->status_register = 0xfffffff7;\n    TIM_handle->active_channel = TIM_CHANNEL_3;\n    if ((TIM_handle->Instance->capture_compare_mode_register_2 & 3) == 0) {\n      handle_OC_DelayElapsed_callback(TIM_handle);\n      handle_PWM_PulseFinished_callback(TIM_handle);\n    }\n    else {\n      handle_IC_Capture_callback(TIM_handle);\n    }\n    TIM_handle->active_channel = TIM_CHANNEL_CLEARED;\n  }\n  tim_instance = TIM_handle->Instance;\n  if (((tim_instance->status_register & 0x10) != 0) && ((tim_instance->DMA_interrupt_enable_register & 0x10) != 0)) {\n    tim_instance->status_register = 0xffffffef;\n    TIM_handle->active_channel = TIM_CHANNEL_4;\n    if ((TIM_handle->Instance->capture_compare_mode_register_2 & 0x300) == 0) {\n      handle_OC_DelayElapsed_callback(TIM_handle);\n      handle_PWM_PulseFinished_callback(TIM_handle);\n    }\n    else {\n      handle_IC_Capture_callback(TIM_handle);\n    }\n    TIM_handle->active_channel = TIM_CHANNEL_CLEARED;\n  }\n  tim_instance = TIM_handle->Instance;\n  if (((tim_instance->status_register & 1) != 0) && ((tim_instance->DMA_interrupt_enable_register & 1) != 0)) {\n    tim_instance->status_register = 0xfffffffe;\n    handle_PeriodElapsed_callback(TIM_handle);\n  }\n  tim_instance = TIM_handle->Instance;\n  if (((tim_instance->status_register & 0x80) != 0) && ((tim_instance->DMA_interrupt_enable_register & 0x80) != 0)) {\n    tim_instance->status_register = 0xffffff7f;\n    handle_Break_callback(TIM_handle);\n  }\n  tim_instance = TIM_handle->Instance;\n  if (((tim_instance->status_register & 0x40) != 0) && ((tim_instance->DMA_interrupt_enable_register & 0x40) != 0)) {\n    tim_instance->status_register = 0xffffffbf;\n    handle_Trigger_callback(TIM_handle);\n  }\n  tim_instance = TIM_handle->Instance;\n  if (((tim_instance->status_register & 0x20) != 0) && ((tim_instance->DMA_interrupt_enable_register & 0x20) != 0)) {\n    tim_instance->status_register = 0xffffffdf;\n    handle_Commutation_callback(TIM_handle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026ce": "handle_tim_interrupts_080026ce",
                "htim": "TIM_handle",
                "pTVar1": "tim_instance",
                "SR": "status_register",
                "DIER": "DMA_interrupt_enable_register",
                "Channel": "active_channel",
                "HAL_TIM_ACTIVE_CHANNEL_1": "TIM_CHANNEL_1",
                "HAL_TIM_ACTIVE_CHANNEL_2": "TIM_CHANNEL_2",
                "HAL_TIM_ACTIVE_CHANNEL_3": "TIM_CHANNEL_3",
                "HAL_TIM_ACTIVE_CHANNEL_4": "TIM_CHANNEL_4",
                "HAL_TIM_ACTIVE_CHANNEL_CLEARED": "TIM_CHANNEL_CLEARED",
                "CCMR1": "capture_compare_mode_register_1",
                "CCMR2": "capture_compare_mode_register_2",
                "HAL_TIM_OC_DelayElapsedCallback": "handle_OC_DelayElapsed_callback",
                "HAL_TIM_PWM_PulseFinishedCallback": "handle_PWM_PulseFinished_callback",
                "HAL_TIM_IC_CaptureCallback": "handle_IC_Capture_callback",
                "HAL_TIM_PeriodElapsedCallback": "handle_PeriodElapsed_callback",
                "HAL_TIMEx_BreakCallback": "handle_Break_callback",
                "HAL_TIM_TriggerCallback": "handle_Trigger_callback",
                "HAL_TIMEx_CommutationCallback": "handle_Commutation_callback"
            },
            "calling": [
                "TIM3_IRQHandler",
                "TIM5_IRQHandler",
                "TIM1_UP_TIM10_IRQHandler",
                "TIM2_IRQHandler",
                "TIM6_DAC_IRQHandler",
                "TIM8_UP_TIM13_IRQHandler",
                "TIM4_IRQHandler",
                "TIM1_BRK_TIM9_IRQHandler",
                "TIM8_BRK_TIM12_IRQHandler",
                "TIM8_TRG_COM_TIM14_IRQHandler",
                "TIM7_IRQHandler",
                "TIM1_TRG_COM_TIM11_IRQHandler"
            ],
            "called": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIMEx_BreakCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002848": {
            "entrypoint": "0x08002848",
            "current_name": "update_channel_state_08002848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateChannelState_08002848(TIM_TypeDef *timer,uint32_t channelNumber,uint32_t newChannelState)\n\n{\n  timer->CCER = timer->CCER & ~(1 << (channelNumber & 0xff));\n  timer->CCER = timer->CCER | newChannelState << (channelNumber & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002848": "update_channel_state_08002848",
                "TIMx": "timer",
                "Channel": "channelNumber",
                "ChannelState": "newChannelState"
            },
            "calling": [
                "HAL_TIM_PWM_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002864": {
            "entrypoint": "0x08002864",
            "current_name": "disable_tim_channel_08002864",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef disableTimChannel_08002864(TIM_HandleTypeDef *timHandle,uint32_t channel)\n\n{\n  bool isTIM1orTIM3;\n  TIM_TypeDef *timInstance;\n  \n  TIM_CCxchannelCmd(timHandle->Instance,channel,0);\n  timInstance = timHandle->Instance;\n  if (timInstance == (TIM_TypeDef *)0x40010000) {\n    isTIM1orTIM3 = true;\n  }\n  else if (timInstance == (TIM_TypeDef *)0x40010400) {\n    isTIM1orTIM3 = true;\n  }\n  else {\n    isTIM1orTIM3 = false;\n  }\n  if (((isTIM1orTIM3) && ((timInstance->CCER & 0x1111) == 0)) && ((timInstance->CCER & 0x444) == 0)) {\n    timInstance->BDTR = timInstance->BDTR & 0xffff7fff;\n  }\n  timInstance = timHandle->Instance;\n  if (((timInstance->CCER & 0x1111) == 0) && ((timInstance->CCER & 0x444) == 0)) {\n    timInstance->CR1 = timInstance->CR1 & 0xfffffffe;\n  }\n  timHandle->State = HAL_TIM_STATE_READY;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002864": "disable_tim_channel_08002864",
                "htim": "timHandle",
                "Channel": "channel",
                "bVar1": "isTIM1orTIM3",
                "pTVar2": "timInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028d4": {
            "entrypoint": "0x080028d4",
            "current_name": "set_channel_n_state_080028d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setChannelNState_080028d4(TIM_TypeDef *timer,uint32_t channel,uint32_t channelNState)\n\n{\n  timer->CCER = timer->CCER & ~(4 << (channel & 0xff));\n  timer->CCER = timer->CCER | channelNState << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080028d4": "set_channel_n_state_080028d4",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelNState": "channelNState"
            },
            "calling": [
                "HAL_TIMEx_PWMN_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028f0": {
            "entrypoint": "0x080028f0",
            "current_name": "disable_channel_and_check_080028f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef disableChannelAndCheck_080028f0(TIM_HandleTypeDef *timerHandle,uint32_t channel)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  TIM_CCxNchannelCmd(timerHandle->Instance,channel,0);\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->BDTR = timerInstance->BDTR & 0xffff7fff;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080028f0": "disable_channel_and_check_080028f0",
                "htim": "timerHandle",
                "Channel": "channel",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800293c": {
            "entrypoint": "0x0800293c",
            "current_name": "FUNC_0800293c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800293c(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800293c": "FUNC_0800293c"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800293e": {
            "entrypoint": "0x0800293e",
            "current_name": "FUNC_0800293e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800293e(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800293e": "FUNC_0800293e"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002940": {
            "entrypoint": "0x08002940",
            "current_name": "reset_uart_state_08002940",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetUartState_08002940(UART_HandleTypeDef *uartHandle)\n\n{\n  uartHandle->uartInstance->CR1 = uartHandle->uartInstance->CR1 & 0xfffffedf;\n  uartHandle->uartInstance->CR3 = uartHandle->uartInstance->CR3 & 0xfffffffe;\n  uartHandle->RxState = HAL_UART_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002940": "reset_uart_state_08002940",
                "huart": "uartHandle",
                "Instance": "uartInstance"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800295c": {
            "entrypoint": "0x0800295c",
            "current_name": "transmit_data_0800295c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef transmitData_0800295c(UART_HandleTypeDef *uartHandler)\n\n{\n  uint16_t remainingCount;\n  byte *txBufferPtr;\n  uint16_t *tempPtr;\n  \n  if (uartHandler->gState != HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  if ((uartHandler->Init).WordLength == 0x1000) {\n    uartHandler->Instance->DR = *(ushort *)uartHandler->pTxBuffPtr & 0x1ff;\n    if ((uartHandler->Init).Parity == 0) {\n      uartHandler->pTxBuffPtr = uartHandler->pTxBuffPtr + 2;\n    }\n    else {\n      uartHandler->pTxBuffPtr = uartHandler->pTxBuffPtr + 1;\n    }\n  }\n  else {\n    txBufferPtr = uartHandler->pTxBuffPtr;\n    uartHandler->pTxBuffPtr = txBufferPtr + 1;\n    uartHandler->Instance->DR = (uint)*txBufferPtr;\n  }\n  remainingCount = uartHandler->TxXferCount - 1;\n  uartHandler->TxXferCount = remainingCount;\n  if (remainingCount == 0) {\n    uartHandler->Instance->CR1 = uartHandler->Instance->CR1 & 0xffffff7f;\n    uartHandler->Instance->CR1 = uartHandler->Instance->CR1 | 0x40;\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800295c": "transmit_data_0800295c",
                "huart": "uartHandler",
                "uVar1": "remainingCount",
                "pbVar2": "txBufferPtr",
                "tmp": "tempPtr"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080029c8": {
            "entrypoint": "0x080029c8",
            "current_name": "configure_uart_080029c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureUART_080029c8(UART_HandleTypeDef *huart)\n\n{\n  uint32_t pclkFreq;\n  uint32_t pclkFreq2;\n  uint32_t pclkFreq3;\n  uint32_t pclkFreq4;\n  uint32_t pclkFreq5;\n  uint32_t baudRate;\n  uint32_t baudRate2;\n  uint32_t baudRate3;\n  uint32_t baudRate4;\n  USART_TypeDef *usartInstance;\n  \n  huart->Instance->CR2 = huart->Instance->CR2 & 0xffffcfff | (huart->Init).StopBits;\n  huart->Instance->CR1 =\n       huart->Instance->CR1 & 0xffff69f3 |\n       (huart->Init).WordLength | (huart->Init).Parity | (huart->Init).Mode |\n       (huart->Init).OverSampling;\n  huart->Instance->CR3 = huart->Instance->CR3 & 0xfffffcff | (huart->Init).HwFlowCtl;\n  if ((huart->Init).OverSampling == 0x8000) {\n    usartInstance = huart->Instance;\n    if ((usartInstance != (USART_TypeDef *)0x40011000) && (usartInstance != (USART_TypeDef *)0x40011400)) {\n      pclkFreq = HAL_RCC_GetPCLK1Freq();\n      baudRate = (huart->Init).BaudRate;\n      pclkFreq2 = HAL_RCC_GetPCLK1Freq();\n      baudRate2 = (huart->Init).BaudRate;\n      pclkFreq3 = HAL_RCC_GetPCLK1Freq();\n      baudRate3 = (huart->Init).BaudRate;\n      pclkFreq4 = HAL_RCC_GetPCLK1Freq();\n      baudRate4 = (huart->Init).BaudRate;\n      pclkFreq5 = HAL_RCC_GetPCLK1Freq();\n      usartInstance->BRR = ((uint)((int)((ulonglong)\n                                   (((pclkFreq4 * 0x19) / (baudRate4 << 1) +\n                                    (int)(((ulonglong)(pclkFreq5 * 0x19) /\n                                          (ulonglong)((huart->Init).BaudRate << 1)) / 100) * -100) *\n                                    8 + 0x32) * 0x51eb851f >> 0x20) << 0x18) >> 0x1d) +\n                     ((((pclkFreq2 * 0x19) / (baudRate2 << 1) +\n                       (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(baudRate3 << 1)) / 100) * -100) *\n                       8 + 0x32) / 100 & 0xf8) * 2 +\n                     (int)(((ulonglong)(pclkFreq * 0x19) / (ulonglong)(baudRate << 1)) / 100) * 0x10;\n      return;\n    }\n    pclkFreq = HAL_RCC_GetPCLK2Freq();\n    baudRate = (huart->Init).BaudRate;\n    pclkFreq2 = HAL_RCC_GetPCLK2Freq();\n    baudRate2 = (huart->Init).BaudRate;\n    pclkFreq3 = HAL_RCC_GetPCLK2Freq();\n    baudRate3 = (huart->Init).BaudRate;\n    pclkFreq4 = HAL_RCC_GetPCLK2Freq();\n    baudRate4 = (huart->Init).BaudRate;\n    pclkFreq5 = HAL_RCC_GetPCLK2Freq();\n    usartInstance->BRR = ((uint)((int)((ulonglong)\n                                 (((pclkFreq4 * 0x19) / (baudRate4 << 1) +\n                                  (int)(((ulonglong)(pclkFreq5 * 0x19) /\n                                        (ulonglong)((huart->Init).BaudRate << 1)) / 100) * -100) * 8\n                                 + 0x32) * 0x51eb851f >> 0x20) << 0x18) >> 0x1d) +\n                   ((((pclkFreq2 * 0x19) / (baudRate2 << 1) +\n                     (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(baudRate3 << 1)) / 100) * -100) * 8\n                    + 0x32) / 100 & 0xf8) * 2 +\n                   (int)(((ulonglong)(pclkFreq * 0x19) / (ulonglong)(baudRate << 1)) / 100) * 0x10;\n    return;\n  }\n  usartInstance = huart->Instance;\n  if ((usartInstance != (USART_TypeDef *)0x40011000) && (usartInstance != (USART_TypeDef *)0x40011400)) {\n    pclkFreq = HAL_RCC_GetPCLK1Freq();\n    baudRate = (huart->Init).BaudRate;\n    pclkFreq2 = HAL_RCC_GetPCLK1Freq();\n    baudRate2 = (huart->Init).BaudRate;\n    pclkFreq3 = HAL_RCC_GetPCLK1Freq();\n    baudRate3 = (huart->Init).BaudRate;\n    pclkFreq4 = HAL_RCC_GetPCLK1Freq();\n    baudRate4 = (huart->Init).BaudRate;\n    pclkFreq5 = HAL_RCC_GetPCLK1Freq();\n    usartInstance->BRR = ((uint)((int)((ulonglong)\n                                 (((pclkFreq4 * 0x19) / (baudRate4 << 2) +\n                                  (int)(((ulonglong)(pclkFreq5 * 0x19) /\n                                        (ulonglong)((huart->Init).BaudRate << 2)) / 100) * -100) *\n                                  0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                   ((((pclkFreq2 * 0x19) / (baudRate2 << 2) +\n                     (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(baudRate3 << 2)) / 100) * -100) *\n                     0x10 + 0x32) / 100 & 0xf0) +\n                   (int)(((ulonglong)(pclkFreq * 0x19) / (ulonglong)(baudRate << 2)) / 100) * 0x10;\n    return;\n  }\n  pclkFreq = HAL_RCC_GetPCLK2Freq();\n  baudRate = (huart->Init).BaudRate;\n  pclkFreq2 = HAL_RCC_GetPCLK2Freq();\n  baudRate2 = (huart->Init).BaudRate;\n  pclkFreq3 = HAL_RCC_GetPCLK2Freq();\n  baudRate3 = (huart->Init).BaudRate;\n  pclkFreq4 = HAL_RCC_GetPCLK2Freq();\n  baudRate4 = (huart->Init).BaudRate;\n  pclkFreq5 = HAL_RCC_GetPCLK2Freq();\n  usartInstance->BRR = ((uint)((int)((ulonglong)\n                               (((pclkFreq4 * 0x19) / (baudRate4 << 2) +\n                                (int)(((ulonglong)(pclkFreq5 * 0x19) /\n                                      (ulonglong)((huart->Init).BaudRate << 2)) / 100) * -100) *\n                                0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                 ((((pclkFreq2 * 0x19) / (baudRate2 << 2) +\n                   (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(baudRate3 << 2)) / 100) * -100) * 0x10\n                  + 0x32) / 100 & 0xf0) +\n                 (int)(((ulonglong)(pclkFreq * 0x19) / (ulonglong)(baudRate << 2)) / 100) * 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080029c8": "configure_uart_080029c8",
                "uVar1": "pclkFreq",
                "uVar2": "pclkFreq2",
                "uVar3": "pclkFreq3",
                "uVar4": "pclkFreq4",
                "uVar5": "pclkFreq5",
                "uVar6": "baudRate",
                "uVar7": "baudRate2",
                "uVar8": "baudRate3",
                "uVar9": "baudRate4",
                "pUVar10": "usartInstance"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d0c": {
            "entrypoint": "0x08002d0c",
            "current_name": "check_flag_status_08002d0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_desiredStatusTypeDef\ncheckFlagStatus_08002d0c(UART_HandleTypeDef *uartHandle,uint32_t flag,flagdesiredStatus desiredStatus,uint32_t startTick,\n            uint32_t timeout)\n\n{\n  uint32_t currentTick;\n  \n  do {\n    if (((flag & ~uartHandle->Instance->SR) == 0) != (bool)desiredStatus) {\n      return HAL_OK;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - startTick <= timeout))));\n  uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffe5f;\n  uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n  uartHandle->gState = HAL_UART_STATE_READY;\n  uartHandle->RxState = HAL_UART_STATE_READY;\n  uartHandle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08002d0c": "check_flag_status_08002d0c",
                "huart": "uartHandle",
                "Flag": "flag",
                "Status": "desiredStatus",
                "Tickstart": "startTick",
                "Timeout": "timeout",
                "uVar1": "currentTick"
            },
            "calling": [
                "HAL_UART_Transmit"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d70": {
            "entrypoint": "0x08002d70",
            "current_name": "FUNC_08002d70",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002d70(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d70": "FUNC_08002d70"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d72": {
            "entrypoint": "0x08002d72",
            "current_name": "initialize_uart_08002d72",
            "code": "\n/* WARNING: Unknown calling convention */\n\nstatus initialize_UART_08002d72(UART_HandleTypeDef *UART_handler)\n\n{\n  if (UART_handler != (UART_HandleTypeDef *)0x0) {\n    if (UART_handler->state == HAL_UART_STATE_RESET) {\n      UART_handler->isLocked = HAL_UNLOCKED;\n      HAL_UART_MspInit(UART_handler);\n    }\n    UART_handler->state = HAL_UART_STATE_BUSY;\n    UART_handler->UART_instance->control_register_1 = UART_handler->UART_instance->control_register_1 & 0xffffdfff;\n    UART_SetConfig(UART_handler);\n    UART_handler->UART_instance->control_register_2 = UART_handler->UART_instance->control_register_2 & 0xffffb7ff;\n    UART_handler->UART_instance->control_register_3 = UART_handler->UART_instance->control_register_3 & 0xffffffd5;\n    UART_handler->UART_instance->control_register_1 = UART_handler->UART_instance->control_register_1 | 0x2000;\n    UART_handler->error_code = 0;\n    UART_handler->state = HAL_UART_STATE_READY;\n    UART_handler->receive_state = HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002d72": "initialize_uart_08002d72",
                "huart": "UART_handler",
                "gState": "state",
                "Lock": "isLocked",
                "Instance": "UART_instance",
                "CR1": "control_register_1",
                "CR2": "control_register_2",
                "CR3": "control_register_3",
                "ErrorCode": "error_code",
                "RxState": "receive_state",
                "HAL_StatusTypeDef": "status"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002dd0": {
            "entrypoint": "0x08002dd0",
            "current_name": "send_data_08002dd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nsendData_08002dd0(UART_HandleTypeDef *uart,uint8_t *data,uint16_t size,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t tickStart;\n  uint16_t *temp;\n  \n  if (uart->gState == HAL_UART_STATE_READY) {\n    if (data == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (uart->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      uart->Lock = HAL_LOCKED;\n      uart->ErrorCode = 0;\n      uart->gState = HAL_UART_STATE_BUSY_TX;\n      tickStart = HAL_GetTick();\n      uart->TxXfersize = size;\n      uart->TxXferCount = size;\n      while (uart->TxXferCount != 0) {\n        uart->TxXferCount = uart->TxXferCount - 1;\n        if ((uart->Init).WordLength == 0x1000) {\n          status = UART_WaitOnFlagUntiltimeout(uart,0x80,RESET,tickStart,timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uart->Instance->DR = *(ushort *)data & 0x1ff;\n          if ((uart->Init).Parity == 0) {\n            data = (uint8_t *)((int)data + 2);\n          }\n          else {\n            data = (uint8_t *)((int)data + 1);\n          }\n        }\n        else {\n          status = UART_WaitOnFlagUntiltimeout(uart,0x80,RESET,tickStart,timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uart->Instance->DR = (uint)*data;\n          data = (uint8_t *)((int)data + 1);\n        }\n      }\n      status = UART_WaitOnFlagUntiltimeout(uart,0x40,RESET,tickStart,timeout);\n      if (status == HAL_OK) {\n        uart->gState = HAL_UART_STATE_READY;\n        uart->Lock = HAL_UNLOCKED;\n        status = HAL_OK;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002dd0": "send_data_08002dd0",
                "huart": "uart",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "tickStart",
                "tmp": "temp"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002eb2": {
            "entrypoint": "0x08002eb2",
            "current_name": "initialize_uart_transfer_08002eb2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatus initialize_uart_transfer_08002eb2(UART_HandleTypeDef *uart_handle,uint8_t *data_ptr,uint16_t data_size)\n\n{\n  if (uart_handle->gState != UART_READY) {\n    return BUSY;\n  }\n  if (data_ptr == (uint8_t *)0x0) {\n    return ERROR;\n  }\n  if (data_size == 0) {\n    return ERROR;\n  }\n  if (uart_handle->Lock != LOCKED) {\n    uart_handle->pTxBuffPtr = data_ptr;\n    uart_handle->TxXferdata_size = data_size;\n    uart_handle->TxXferCount = data_size;\n    uart_handle->ErrorCode = 0;\n    uart_handle->gState = HAL_UART_STATE_BUSY_TX;\n    uart_handle->Lock = UNLOCKED;\n    uart_handle->Instance->CR1 = uart_handle->Instance->CR1 | 0x80;\n    return HAL_OK;\n  }\n  return BUSY;\n}\n\n",
            "renaming": {
                "FUN_08002eb2": "initialize_uart_transfer_08002eb2",
                "huart": "uart_handle",
                "pData": "data_ptr",
                "Size": "data_size",
                "HAL_StatusTypeDef": "Status",
                "HAL_UART_STATE_READY": "UART_READY",
                "HAL_BUSY": "BUSY",
                "HAL_ERROR": "ERROR",
                "HAL_LOCKED": "LOCKED",
                "HAL_UNLOCKED": "UNLOCKED"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "uart_attach_tx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002efa": {
            "entrypoint": "0x08002efa",
            "current_name": "initialize_uart_receive_08002efa",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeUartReceive_08002efa(UART_HandleTypeDef *uartHandle,uint8_t *receiveBuffer,uint16_t bufferSize)\n\n{\n  if (uartHandle->RxState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (receiveBuffer == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (bufferSize == 0) {\n    return HAL_ERROR;\n  }\n  if (uartHandle->Lock != HAL_LOCKED) {\n    uartHandle->pRxBuffPtr = receiveBuffer;\n    uartHandle->RxXferbufferSize = bufferSize;\n    uartHandle->RxXferCount = bufferSize;\n    uartHandle->ErrorCode = 0;\n    uartHandle->RxState = HAL_UART_STATE_BUSY_RX;\n    uartHandle->Lock = HAL_UNLOCKED;\n    uartHandle->Instance->CR3 = uartHandle->Instance->CR3 | 1;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x120;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_08002efa": "initialize_uart_receive_08002efa",
                "huart": "uartHandle",
                "pData": "receiveBuffer",
                "Size": "bufferSize"
            },
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f4c": {
            "entrypoint": "0x08002f4c",
            "current_name": "initialize_uart_08002f4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeUART_08002f4c(UART_HandleTypeDef *uartHandler)\n\n{\n  uartHandler->uartInstance->controlRegister1 = uartHandler->uartInstance->controlRegister1 & 0xffffffbf;\n  uartHandler->uartState = readyState;\n  txCompleteCallback(uartHandler);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002f4c": "initialize_uart_08002f4c",
                "huart": "uartHandler",
                "Instance": "uartInstance",
                "CR1": "controlRegister1",
                "gState": "uartState",
                "HAL_UART_STATE_READY": "readyState",
                "HAL_UART_TxCpltCallback": "txCompleteCallback"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f66": {
            "entrypoint": "0x08002f66",
            "current_name": "handle_received_data_08002f66",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleReceivedData_08002f66(UART_HandleTypeDef *uartHandle)\n\n{\n  uint16_t *dataPtr;\n  byte *bytePtr;\n  uint16_t remainingCount;\n  uint8_t *uint8Ptr;\n  \n  if (uartHandle->RxState != HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  if ((uartHandle->Init).WordLength == 0x1000) {\n    if ((uartHandle->Init).Parity == 0) {\n      *(ushort *)uartHandle->pRxBuffPtr = (ushort)((uartHandle->Instance->DR << 0x17) >> 0x17);\n      uartHandle->pRxBuffPtr = uartHandle->pRxBuffPtr + 2;\n    }\n    else {\n      *(ushort *)uartHandle->pRxBuffPtr = (ushort)uartHandle->Instance->DR & 0xff;\n      uartHandle->pRxBuffPtr = uartHandle->pRxBuffPtr + 1;\n    }\n  }\n  else if ((uartHandle->Init).Parity == 0) {\n    uint8Ptr = uartHandle->pRxBuffPtr;\n    uartHandle->pRxBuffPtr = uint8Ptr + 1;\n    *uint8Ptr = (uint8_t)uartHandle->Instance->DR;\n  }\n  else {\n    bytePtr = uartHandle->pRxBuffPtr;\n    uartHandle->pRxBuffPtr = bytePtr + 1;\n    *bytePtr = (byte)uartHandle->Instance->DR & 0x7f;\n  }\n  remainingCount = uartHandle->RxXferCount - 1;\n  uartHandle->RxXferCount = remainingCount;\n  if (remainingCount != 0) {\n    return HAL_OK;\n  }\n  uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffedf;\n  uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n  uartHandle->RxState = HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(uartHandle);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002f66": "handle_received_data_08002f66",
                "huart": "uartHandle",
                "tmp": "dataPtr",
                "pbVar1": "bytePtr",
                "uVar2": "remainingCount",
                "puVar3": "uint8Ptr"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ffc": {
            "entrypoint": "0x08002ffc",
            "current_name": "process_uart_status_08002ffc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processUARTStatus_08002ffc(UART_HandleTypeDef *UARTHandle)\n\n{\n  HAL_StatusTypeDef status;\n  uint controlReg1;\n  uint32_t cr1Interrupts;\n  USART_TypeDef *uartInstance;\n  uint32_t cr3Interrupts;\n  uint enableRxInterrupt;\n  uint statusReg;\n  uint32_t interruptFlags;\n  \n  uartInstance = UARTHandle->Instance;\n  statusReg = uartInstance->SR;\n  controlReg1 = uartInstance->CR1;\n  if ((((statusReg & 0xf) == 0) && ((statusReg & 0x20) != 0)) && ((controlReg1 & 0x20) != 0)) {\n    UART_Receive_IT(UARTHandle);\n    return;\n  }\n  if (((statusReg & 0xf) == 0) || ((enableRxInterrupt = uartInstance->CR3 & 1, enableRxInterrupt == 0 && ((controlReg1 & 0x120) == 0)))) {\n    if (((statusReg & 0x80) != 0) && ((controlReg1 & 0x80) != 0)) {\n      UART_Transmit_IT(UARTHandle);\n      return;\n    }\n    if (((statusReg & 0x40) != 0) && ((controlReg1 & 0x40) != 0)) {\n      UART_EndTransmit_IT(UARTHandle);\n    }\n  }\n  else {\n    if (((statusReg & 1) != 0) && ((controlReg1 & 0x100) != 0)) {\n      UARTHandle->ErrorCode = UARTHandle->ErrorCode | 1;\n    }\n    if (((statusReg & 4) != 0) && (enableRxInterrupt != 0)) {\n      UARTHandle->ErrorCode = UARTHandle->ErrorCode | 2;\n    }\n    if (((statusReg & 2) != 0) && (enableRxInterrupt != 0)) {\n      UARTHandle->ErrorCode = UARTHandle->ErrorCode | 4;\n    }\n    if (((statusReg & 8) != 0) && (enableRxInterrupt != 0)) {\n      UARTHandle->ErrorCode = UARTHandle->ErrorCode | 8;\n    }\n    if (UARTHandle->ErrorCode != 0) {\n      if (((statusReg & 0x20) != 0) && ((controlReg1 & 0x20) != 0)) {\n        UART_Receive_IT(UARTHandle);\n      }\n      if (((UARTHandle->ErrorCode & 8) == 0) && ((UARTHandle->Instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(UARTHandle);\n        UARTHandle->ErrorCode = 0;\n        return;\n      }\n      UART_EndRxTransfer(UARTHandle);\n      uartInstance = UARTHandle->Instance;\n      if ((uartInstance->CR3 & 0x40) == 0) {\n        HAL_UART_ErrorCallback(UARTHandle);\n        return;\n      }\n      uartInstance->CR3 = uartInstance->CR3 & 0xffffffbf;\n      if (UARTHandle->hdmarx == (DMA_HandleTypeDef *)0x0) {\n        HAL_UART_ErrorCallback(UARTHandle);\n        return;\n      }\n      UARTHandle->hdmarx->XferAbortCallback = UART_DMAAbortOnError + 1;\n      status = HAL_DMA_Abort_IT(UARTHandle->hdmarx);\n      if (status != HAL_OK) {\n        (*UARTHandle->hdmarx->XferAbortCallback)(UARTHandle->hdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ffc": "process_uart_status_08002ffc",
                "huart": "UARTHandle",
                "HVar1": "status",
                "uVar2": "controlReg1",
                "uVar4": "enableRxInterrupt",
                "uVar5": "statusReg",
                "cr1its": "cr1Interrupts",
                "cr3its": "cr3Interrupts",
                "isrflags": "interruptFlags",
                "pUVar3": "uartInstance"
            },
            "calling": [
                "USART3_IRQHandler",
                "USART6_IRQHandler",
                "UART7_IRQHandler",
                "UART4_IRQHandler",
                "UART8_IRQHandler",
                "USART1_IRQHandler",
                "USART2_IRQHandler",
                "UART5_IRQHandler"
            ],
            "called": [
                "UART_Receive_IT",
                "UART_Transmit_IT",
                "UART_EndRxTransfer",
                "UART_EndTransmit_IT",
                "HAL_UART_ErrorCallback",
                "HAL_DMA_Abort_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800311c": {
            "entrypoint": "0x0800311c",
            "current_name": "reset_uart_and_notify_error_0800311c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetUartAndNotifyError_0800311c(DMA_HandleTypeDef *dma)\n\n{\n  UART_HandleTypeDef *uartParent;\n  UART_HandleTypeDef *uart;\n  \n  uartParent = (UART_HandleTypeDef *)dma->Parent;\n  uartParent->RxXferCount = 0;\n  uartParent->TxXferCount = 0;\n  HAL_UART_ErrorCallback(uartParent);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800311c": "reset_uart_and_notify_error_0800311c",
                "hdma": "dma",
                "huart_00": "uartParent",
                "huart": "uart"
            },
            "calling": [],
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800312c": {
            "entrypoint": "0x0800312c",
            "current_name": "get_uart_state_0800312c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_UART_StateTypeDef get_uart_state_0800312c(UART_HandleTypeDef *uart_handle)\n\n{\n  return uart_handle->receive_state | uart_handle->global_state;\n}\n\n",
            "renaming": {
                "FUN_0800312c": "get_uart_state_0800312c",
                "huart": "uart_handle",
                "RxState": "receive_state",
                "gState": "global_state"
            },
            "calling": [
                "serial_tx_active",
                "serial_rx_active"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003138": {
            "entrypoint": "0x08003138",
            "current_name": "check_pin_status_08003138",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool checkPinStatus_08003138(pinName pin,uint32_t *pinMap)\n\n{\n  uint32_t pinIndex;\n  \n  pinIndex = pinMap[(uint)((int)pin << 0x18) >> 0x1c];\n  return (_Bool)((byte)(pinIndex >> ((int)pin & 0xfU)) & 1);\n}\n\n",
            "renaming": {
                "FUN_08003138": "check_pin_status_08003138",
                "PinName_conflict": "pinName",
                "map": "pinMap",
                "index": "pinIndex"
            },
            "calling": [
                "pinMode",
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800314e": {
            "entrypoint": "0x0800314e",
            "current_name": "set_pin_in_map_0800314e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinInMap_0800314e(pin pin,uint32_t *pinMap)\n\n{\n  uint index;\n  uint32_t index;\n  \n  index = (uint)((int)pin << 0x18) >> 0x1c;\n  pinMap[index] = pinMap[index] | 1 << ((int)pin & 0xfU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800314e": "set_pin_in_map_0800314e",
                "PinName_conflict": "pin",
                "map": "pinMap",
                "uVar1": "index"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800316c": {
            "entrypoint": "0x0800316c",
            "current_name": "update_pin_map_0800316c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updatePinMap_0800316c(PinName_conflict pinName,uint32_t *pinMap)\n\n{\n  uint shiftedIndex;\n  uint32_t originalIndex;\n  \n  shiftedIndex = (uint)((int)pinName << 0x18) >> 0x1c;\n  pinMap[shiftedIndex] = pinMap[shiftedIndex] & ~(1 << ((int)pinName & 0xfU));\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800316c": "update_pin_map_0800316c",
                "pin": "pinName",
                "map": "pinMap",
                "uVar1": "shiftedIndex",
                "index": "originalIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800318c": {
            "entrypoint": "0x0800318c",
            "current_name": "get_gpio_type_from_port_index_0800318c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * getGPIOTypeFromPortIndex_0800318c(uint32_t portIndex)\n\n{\n  switch(portIndex) {\n  case 0:\n    return (GPIO_TypeDef *)0x40020000;\n  case 1:\n    return (GPIO_TypeDef *)0x40020400;\n  case 2:\n    return (GPIO_TypeDef *)0x40020800;\n  case 3:\n    return (GPIO_TypeDef *)0x40020c00;\n  case 4:\n    return (GPIO_TypeDef *)0x40021000;\n  case 5:\n    return (GPIO_TypeDef *)0x40021400;\n  case 6:\n    return (GPIO_TypeDef *)0x40021800;\n  case 7:\n    return (GPIO_TypeDef *)0x40021c00;\n  case 8:\n    return (GPIO_TypeDef *)0x40022000;\n  case 9:\n    return (GPIO_TypeDef *)0x40022400;\n  case 10:\n    return (GPIO_TypeDef *)0x40022800;\n  default:\n    return (GPIO_TypeDef *)0x0;\n  }\n}\n\n",
            "renaming": {
                "FUN_0800318c": "get_gpio_type_from_port_index_0800318c",
                "port_idx": "portIndex"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080031fc": {
            "entrypoint": "0x080031fc",
            "current_name": "get_gpio_port_080031fc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * getGPIO_Port_080031fc(uint32_t portIndex)\n\n{\n  GPIO_TypeDef *portGPIO;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister_1;\n  uint32_t temporaryRegister_2;\n  uint32_t temporaryRegister_3;\n  uint32_t temporaryRegister_4;\n  uint32_t temporaryRegister_5;\n  uint32_t temporaryRegister_6;\n  uint32_t temporaryRegister_7;\n  uint32_t temporaryRegister_8;\n  uint32_t temporaryRegister_9;\n  uint32_t temporaryRegister_10;\n  \n  switch(portIndex) {\n  case 0:\n    _DAT_40023830 = _DAT_40023830 | 1;\n    portGPIO = (GPIO_TypeDef *)0x40020000;\n    break;\n  case 1:\n    _DAT_40023830 = _DAT_40023830 | 2;\n    portGPIO = (GPIO_TypeDef *)0x40020400;\n    break;\n  case 2:\n    _DAT_40023830 = _DAT_40023830 | 4;\n    portGPIO = (GPIO_TypeDef *)0x40020800;\n    break;\n  case 3:\n    _DAT_40023830 = _DAT_40023830 | 8;\n    portGPIO = (GPIO_TypeDef *)0x40020c00;\n    break;\n  case 4:\n    _DAT_40023830 = _DAT_40023830 | 0x10;\n    portGPIO = (GPIO_TypeDef *)0x40021000;\n    break;\n  case 5:\n    _DAT_40023830 = _DAT_40023830 | 0x20;\n    portGPIO = (GPIO_TypeDef *)0x40021400;\n    break;\n  case 6:\n    _DAT_40023830 = _DAT_40023830 | 0x40;\n    portGPIO = (GPIO_TypeDef *)0x40021800;\n    break;\n  case 7:\n    _DAT_40023830 = _DAT_40023830 | 0x80;\n    portGPIO = (GPIO_TypeDef *)0x40021c00;\n    break;\n  case 8:\n    _DAT_40023830 = _DAT_40023830 | 0x100;\n    portGPIO = (GPIO_TypeDef *)0x40022000;\n    break;\n  case 9:\n    _DAT_40023830 = _DAT_40023830 | 0x200;\n    portGPIO = (GPIO_TypeDef *)0x40022400;\n    break;\n  case 10:\n    _DAT_40023830 = _DAT_40023830 | 0x400;\n    portGPIO = (GPIO_TypeDef *)0x40022800;\n    break;\n  default:\n    portGPIO = (GPIO_TypeDef *)0x0;\n  }\n  return portGPIO;\n}\n\n",
            "renaming": {
                "FUN_080031fc": "get_gpio_port_080031fc",
                "port_idx": "portIndex",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister_1",
                "tmpreg_2": "temporaryRegister_2",
                "tmpreg_3": "temporaryRegister_3",
                "tmpreg_4": "temporaryRegister_4",
                "tmpreg_5": "temporaryRegister_5",
                "tmpreg_6": "temporaryRegister_6",
                "tmpreg_7": "temporaryRegister_7",
                "tmpreg_8": "temporaryRegister_8",
                "tmpreg_9": "temporaryRegister_9",
                "tmpreg_10": "temporaryRegister_10",
                "pGVar1": "portGPIO"
            },
            "calling": [
                "digital_io_init",
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003380": {
            "entrypoint": "0x08003380",
            "current_name": "get_dac_pin_function_08003380",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_dac_pin_function_08003380(PinName_conflict pin_name)\n\n{\n  uint32_t pin_function;\n  uint32_t shifted_function;\n  \n  pin_function = pin_namemap_shifted_function(pin_name,(PinMap_conflict *)&PinMap_DAC);\n  shifted_function = pin_function << 0xc;\n  shifted_function = shifted_function >> 0x1b;\n  if (shifted_function != 2) {\n    return 0;\n  }\n  return 0x10;\n}\n\n",
            "renaming": {
                "FUN_08003380": "get_dac_pin_function_08003380",
                "pin": "pin_name",
                "uVar1": "pin_function",
                "function": "shifted_function"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800339c": {
            "entrypoint": "0x0800339c",
            "current_name": "get_pin_function_0800339c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getPinFunction_0800339c(PinName_conflict pinName)\n\n{\n  uint32_t pinFunction;\n  uint32_t shiftedValue;\n  \n  pinFunction = pinNamemap_shiftedValue(pinName,(PinMap_conflict *)&PinMap_PWM);\n  shiftedValue = pinFunction << 0xc;\n  shiftedValue = shiftedValue >> 0x1b;\n  if (shiftedValue == 3) {\n    return 8;\n  }\n  if (shiftedValue != 4) {\n    if (shiftedValue != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
            "renaming": {
                "FUN_0800339c": "get_pin_function_0800339c",
                "pin": "pinName",
                "uVar1": "pinFunction",
                "function": "shiftedValue"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033c8": {
            "entrypoint": "0x080033c8",
            "current_name": "clear_dac_interrupt_flag_080033c8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid clearDACInterruptFlag_080033c8(DAC_HandleTypeDef *dacHandler)\n\n{\n  _DAT_40023840 = _DAT_40023840 & 0xdfffffff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033c8": "clear_dac_interrupt_flag_080033c8",
                "hdac": "dacHandler"
            },
            "calling": [
                "HAL_DAC_DeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033d8": {
            "entrypoint": "0x080033d8",
            "current_name": "stop_and_de_init_dac_080033d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopAndDeInitDAC_080033d8(pin pin)\n\n{\n  uint32_t channel;\n  uint32_t dacchannel;\n  DAC_HandleTypeDef dacHandle;\n  \n  dacHandle.Instance = (DAC_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)&PinMap_DAC);\n  if ((dacHandle.Instance != (DAC_TypeDef *)0x0) &&\n     ((channel = get_dac_channel(pin), channel == 0 || (channel == 0x10)))) {\n    HAL_DAC_Stop(&dacHandle,channel);\n    HAL_DAC_DeInit(&dacHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033d8": "stop_and_de_init_dac_080033d8",
                "PinName_conflict": "pin",
                "Channel": "channel",
                "DacHandle": "dacHandle"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_DAC_Stop",
                "get_dac_channel",
                "HAL_DAC_DeInit",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800340c": {
            "entrypoint": "0x0800340c",
            "current_name": "disable_timer_clock_0800340c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_timer_clock_0800340c(TIM_HandleTypeDef *timer_handle)\n\n{\n  disable_timer_clock_0800340c(timer_handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800340c": "disable_timer_clock_0800340c",
                "htim": "timer_handle",
                "timer_disable_clock": "disable_timer_clock"
            },
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "called": [
                "timer_disable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003414": {
            "entrypoint": "0x08003414",
            "current_name": "stop_pwm_channel_08003414",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopPWMChannel_08003414(pin pin)\n\n{\n  uint32_t pwmChannel;\n  uint32_t timpwmChannel;\n  uint32_t pinFunction;\n  TIM_HandleTypeDef timerHandle;\n  \n  timerHandle.Instance = (TIM_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)&PinMap_PWM);\n  if ((timerHandle.Instance != (TIM_TypeDef *)0x0) &&\n     ((((pwmChannel = get_pwm_channel(pin), pwmChannel == 0 || (pwmChannel == 4)) || (pwmChannel == 8)) ||\n      ((pwmChannel == 0xc || (pwmChannel == 0x18)))))) {\n    pinFunction = pinmap_function(pin,(PinMap_conflict *)&PinMap_PWM);\n    if ((pinFunction & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(&timerHandle,pwmChannel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(&timerHandle,pwmChannel);\n    }\n    HAL_TIM_PWM_DeInit(&timerHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003414": "stop_pwm_channel_08003414",
                "PinName_conflict": "pin",
                "Channel": "pwmChannel",
                "uVar1": "pinFunction",
                "timHandle": "timerHandle"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "pinmap_function",
                "HAL_TIM_PWM_Stop",
                "get_pwm_channel",
                "HAL_TIM_PWM_DeInit",
                "pinmap_peripheral",
                "HAL_TIMEx_PWMN_Stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800346c": {
            "entrypoint": "0x0800346c",
            "current_name": "get_tick_value_0800346c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTickValue_0800346c(void)\n\n{\n  uint32_t tickValue;\n  \n  tickValue = HAL_GetTick();\n  return tickValue;\n}\n\n",
            "renaming": {
                "FUN_0800346c": "get_tick_value_0800346c",
                "uVar1": "tickValue"
            },
            "calling": [
                "millis"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003474": {
            "entrypoint": "0x08003474",
            "current_name": "FUNC_08003474",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003474(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003474": "FUNC_08003474"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003476": {
            "entrypoint": "0x08003476",
            "current_name": "handle_system_tick_08003476",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSystemTick_08003476(void)\n\n{\n  incrementTickCounter();\n  handleSysTickInterrupt();\n  handleNoOsSysTick();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003476": "handle_system_tick_08003476",
                "HAL_IncTick": "incrementTickCounter",
                "HAL_SYSTICK_IRQHandler": "handleSysTickInterrupt",
                "noOsSystickHandler": "handleNoOsSysTick"
            },
            "calling": [],
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "noOsSystickHandler",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003486": {
            "entrypoint": "0x08003486",
            "current_name": "configure_pin_08003486",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_08003486(pin pin,uint32_t mode,uint32_t pull)\n\n{\n  GPIO_TypeDef *gpioPort;\n  GPIO_TypeDef *gpioPort;\n  GPIO_InitTypeDef gpioConfig;\n  \n  gpioPort = set_GPIO_Port_Clock((uint)((int)pin << 0x18) >> 0x1c);\n  gpioConfig.Pin = 1 << ((int)pin & 0xfU) & 0xffff;\n  gpioConfig.Speed = 2;\n  gpioConfig.Mode = mode;\n  gpioConfig.Pull = pull;\n  HAL_GPIO_Init(gpioPort,&gpioConfig);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003486": "configure_pin_08003486",
                "PinName_conflict": "pin",
                "GPIOx": "gpioPort",
                "port": "gpioPort",
                "GPIO_InitStructure": "gpioConfig"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034b6": {
            "entrypoint": "0x080034b6",
            "current_name": "set_pin_state_080034b6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinState_080034b6(GPIO_TypeDef *gpioPort,uint32_t pinNumber,uint32_t state)\n\n{\n  if (state == 0) {\n    HAL_GPIO_WritePin(gpioPort,(uint16_t)pinNumber,GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(gpioPort,(uint16_t)pinNumber,GPIO_PIN_SET);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080034b6": "set_pin_state_080034b6",
                "port": "gpioPort",
                "pin": "pinNumber",
                "val": "state"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034ce": {
            "entrypoint": "0x080034ce",
            "current_name": "initialize_system_080034ce",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_080034ce(void)\n\n{\n  initializeHardware();\n  configureSystemClock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080034ce": "initialize_system_080034ce",
                "HAL_Init": "initializeHardware",
                "SystemClock_Config": "configureSystemClock"
            },
            "calling": [
                "init"
            ],
            "called": [
                "SystemClock_Config",
                "HAL_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034da": {
            "entrypoint": "0x080034da",
            "current_name": "find_peripheral_by_pin_080034da",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * find_peripheral_by_pin_080034da(PinName_conflict desired_pin,PinMap_conflict *pin_map)\n\n{\n  while( true ) {\n    if (pin_map->desired_pin == not_connected) {\n      return (void *)0x0;\n    }\n    if (pin_map->desired_pin == desired_pin) break;\n    pin_map = pin_map + 1;\n  }\n  return pin_map->found_peripheral;\n}\n\n",
            "renaming": {
                "FUN_080034da": "find_peripheral_by_pin_080034da",
                "pin": "desired_pin",
                "map": "pin_map",
                "NC": "not_connected",
                "peripheral": "found_peripheral"
            },
            "calling": [
                "pinmap_find_peripheral",
                "pinmap_peripheral"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034f4": {
            "entrypoint": "0x080034f4",
            "current_name": "find_peripheral_080034f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * find_peripheral_080034f4(PinName_conflict pin,PinMap_conflict *pin_map)\n\n{\n  void *peripheral;\n  \n  if (pin != NC) {\n    peripheral = pinpin_map_find_peripheral_080034f4(pin,pin_map);\n    return peripheral;\n  }\n  return (void *)0x0;\n}\n\n",
            "renaming": {
                "FUN_080034f4": "find_peripheral_080034f4",
                "map": "pin_map",
                "pvVar1": "peripheral"
            },
            "calling": [
                "uart_debug_write",
                "uart_debug_init",
                "dac_stop",
                "uart_init",
                "pwm_stop"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003506": {
            "entrypoint": "0x08003506",
            "current_name": "find_pin_from_peripheral_08003506",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName findPinFromPeripheral_08003506(void *peripheral,PinMap *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->peripheral == (void *)0x0) {\n      return NoConnection;\n    }\n    if (pinMap->peripheral == peripheral) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->pin;\n}\n\n",
            "renaming": {
                "FUN_08003506": "find_pin_from_peripheral_08003506",
                "map": "pinMap",
                "PinName_conflict": "PinName",
                "PinMap_conflict": "PinMap",
                "NC": "NoConnection"
            },
            "calling": [
                "pinmap_find_pin",
                "pinmap_pin"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800351e": {
            "entrypoint": "0x0800351e",
            "current_name": "find_pin_name_0800351e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict findPinName_0800351e(void *inputPeripheral,PinMap_conflict *pinMap)\n\n{\n  PinName_conflict foundPin;\n  \n  if (inputPeripheral != (void *)0x0) {\n    foundPin = pinpinMap_find_pin(inputPeripheral,pinMap);\n    return foundPin;\n  }\n  return NC;\n}\n\n",
            "renaming": {
                "FUN_0800351e": "find_pin_name_0800351e",
                "peripheral": "inputPeripheral",
                "map": "pinMap",
                "PVar1": "foundPin"
            },
            "calling": [
                "HardwareSerial",
                "uart_debug_init"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800352e": {
            "entrypoint": "0x0800352e",
            "current_name": "find_pin_function_0800352e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t findPinFunction_0800352e(PinName_conflict targetPin,PinMap_conflict *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->targetPin == NotConnected) {\n      return 0xffffffff;\n    }\n    if (pinMap->targetPin == targetPin) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->function;\n}\n\n",
            "renaming": {
                "FUN_0800352e": "find_pin_function_0800352e",
                "pin": "targetPin",
                "map": "pinMap",
                "NC": "NotConnected"
            },
            "calling": [
                "pinmap_function",
                "pinmap_find_function"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800354a": {
            "entrypoint": "0x0800354a",
            "current_name": "find_pin_function_0800354a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t find_pin_function_0800354a(PinName_conflict pin,PinMap_conflict *pin_map)\n\n{\n  uint32_t result;\n  \n  if (pin == NC) {\n    return 0xffffffff;\n  }\n  result = pinpin_map_find_function(pin,pin_map);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800354a": "find_pin_function_0800354a",
                "map": "pin_map",
                "uVar1": "result"
            },
            "calling": [
                "get_dac_channel",
                "get_pwm_channel",
                "uart_init",
                "pwm_stop"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800355e": {
            "entrypoint": "0x0800355e",
            "current_name": "pin_exists_0800355e",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool pinExists_0800355e(PinName pinName,PinMap *pinMap)\n\n{\n  if (pinName == NotConnected) {\n    return false;\n  }\n  while( true ) {\n    if (pinMap->pinName == NotConnected) {\n      return false;\n    }\n    if (pinName == pinMap->pinName) break;\n    pinMap = pinMap + 1;\n  }\n  return true;\n}\n\n",
            "renaming": {
                "FUN_0800355e": "pin_exists_0800355e",
                "pin": "pinName",
                "map": "pinMap",
                "NC": "NotConnected",
                "PinName_conflict": "PinName",
                "PinMap_conflict": "PinMap"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003582": {
            "entrypoint": "0x08003582",
            "current_name": "merge_pointers_08003582",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * merge_pointers_08003582(void *a,void *b)\n\n{\n  if (a != b) {\n    if (a == (void *)0x0) {\n      return b;\n    }\n    if (b == (void *)0x0) {\n      return a;\n    }\n    a = (void *)0x0;\n  }\n  return a;\n}\n\n",
            "renaming": {
                "FUN_08003582": "merge_pointers_08003582"
            },
            "calling": [
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003594": {
            "entrypoint": "0x08003594",
            "current_name": "execute_rtc_user_callback_08003594",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid execute_RTC_user_callback_08003594(RTC_HandleTypeDef *RTC_handle)\n\n{\n  if (user_callback != (voidCallbackPtr)0x0) {\n    (*user_callback)(user_callback_data);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003594": "execute_rtc_user_callback_08003594",
                "hrtc": "RTC_handle",
                "RTCUserCallback": "user_callback",
                "callbackUserData": "user_callback_data"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035ac": {
            "entrypoint": "0x080035ac",
            "current_name": "handle_alarm_irq_080035ac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleAlarmIRQ_080035ac(void)\n\n{\n  HAL_RTC_AlarmIRQHandler(rtcHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035ac": "handle_alarm_irq_080035ac",
                "&RtcHandle": "rtcHandle"
            },
            "calling": [],
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035bc": {
            "entrypoint": "0x080035bc",
            "current_name": "initialize_registers_080035bc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeRegisters_080035bc(void)\n\n{\n  _DAT_40023808 = 0;\n  _DAT_40023804 = 0x24003010;\n  _DAT_40023800 = _DAT_40023800 & 0xfef2ffff | 1;\n  _DAT_4002380c = 0;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035bc": "initialize_registers_080035bc"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fc": {
            "entrypoint": "0x080035fc",
            "current_name": "update_tim_registers_080035fc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid update_TIM_registers_080035fc(TIM_HandleTypeDef *timer_handle)\n\n{\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40010000) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffffffe;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40000000) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffe;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40000400) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffd;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40000800) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffb;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40000c00) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffff7;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40001000) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffef;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40001400) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffdf;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40010400) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffffffd;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40014000) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffeffff;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40014400) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffdffff;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40014800) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffbffff;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40001800) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffbf;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40001c00) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffff7f;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40002000) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffeff;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fc": "update_tim_registers_080035fc",
                "htim": "timer_handle"
            },
            "calling": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003750": {
            "entrypoint": "0x08003750",
            "current_name": "get_timer_from_handle_08003750",
            "code": "\n/* WARNING: Unknown calling convention */\n\ntimer * getTimerFromHandle_08003750(timerHandle *handle)\n\n{\n  return (timer *)&handle[-1].lock;\n}\n\n",
            "renaming": {
                "FUN_08003750": "get_timer_from_handle_08003750",
                "TIM_HandleTypeDef": "timerHandle",
                "htim": "handle",
                "stimer_t": "timer",
                "Lock": "lock"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_OC_DelayElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003754": {
            "entrypoint": "0x08003754",
            "current_name": "handle_timer_interrupt_08003754",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_timer_interrupt_08003754(TIM_HandleTypeDef *timer_handle)\n\n{\n  stimer_t *timer_obj;\n  stimer_t *pointer_obj;\n  \n  timer_obj = get_timer_pointer_obj(timer_handle);\n  if ((timer_obj->irqHandleOC != (_func_void_stimer_t_ptr_uint32_t *)0x0) &&\n     (timer_handle->Channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*timer_obj->irqHandleOC)(timer_obj,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003754": "handle_timer_interrupt_08003754",
                "htim": "timer_handle",
                "psVar1": "timer_obj",
                "obj": "pointer_obj"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800376e": {
            "entrypoint": "0x0800376e",
            "current_name": "handle_timer_interrupt_0800376e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_timer_interrupt_0800376e(TIM_HandleTypeDef *timer_handle)\n\n{\n  stimer_t *timer_obj;\n  stimer_t *timer_obj_handle;\n  \n  timer_obj = get_timer_timer_obj_handle(timer_handle);\n  if (timer_obj->irqHandle != (_func_void_stimer_t_ptr *)0x0) {\n    (*timer_obj->irqHandle)(timer_obj);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800376e": "handle_timer_interrupt_0800376e",
                "htim": "timer_handle",
                "psVar1": "timer_obj",
                "obj": "timer_obj_handle"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800377c": {
            "entrypoint": "0x0800377c",
            "current_name": "handle_timers_0800377c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimers_0800377c(void)\n\n{\n  if (timerHandles[0] != (TimerHandle *)0x0) {\n    handleTimerIRQ(timerHandles[0]);\n  }\n  if (timerHandles[9] != (TimerHandle *)0x0) {\n    handleTimerIRQ(timerHandles[9]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800377c": "handle_timers_0800377c",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleTimerIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003798": {
            "entrypoint": "0x08003798",
            "current_name": "handle_second_timer_interrupt_08003798",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSecondTimerInterrupt_08003798(void)\n\n{\n  if (timerHandles[1] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[1]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003798": "handle_second_timer_interrupt_08003798",
                "timer_handles": "timerHandles"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037ac": {
            "entrypoint": "0x080037ac",
            "current_name": "handle_timer_interrupt_080037ac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_080037ac(void)\n\n{\n  if (timerHandles[2] != (TimerHandleStruct *)0x0) {\n    handleTimerIRQ(timerHandles[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037ac": "handle_timer_interrupt_080037ac",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandleStruct",
                "HAL_TIM_IRQHandler": "handleTimerIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037c0": {
            "entrypoint": "0x080037c0",
            "current_name": "handle_timer_irq_080037c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerIRQ_080037c0(void)\n\n{\n  if (timerHandles[3] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[3]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037c0": "handle_timer_irq_080037c0",
                "timer_handles": "timerHandles"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037d4": {
            "entrypoint": "0x080037d4",
            "current_name": "handle_timer_interrupt_080037d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_080037d4(void)\n\n{\n  if (timerList[4] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerList[4]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037d4": "handle_timer_interrupt_080037d4",
                "timer_handles": "timerList"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037e8": {
            "entrypoint": "0x080037e8",
            "current_name": "handle_timer_interrupt_080037e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_080037e8(void)\n\n{\n  if (timerHandles[5] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[5]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037e8": "handle_timer_interrupt_080037e8",
                "timer_handles": "timerHandles"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037fc": {
            "entrypoint": "0x080037fc",
            "current_name": "handle_timer_irq_080037fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerIRQ_080037fc(void)\n\n{\n  if (timerHandles[6] != (TimerHandle *)0x0) {\n    handleTimerInterrupt(timerHandles[6]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037fc": "handle_timer_irq_080037fc",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleTimerInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003810": {
            "entrypoint": "0x08003810",
            "current_name": "handle_timers_08003810",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimers_08003810(void)\n\n{\n  if (timers[7] != (TimerHandle *)0x0) {\n    handleTimerInterrupt(timers[7]);\n  }\n  if (timers[12] != (TimerHandle *)0x0) {\n    handleTimerInterrupt(timers[12]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003810": "handle_timers_08003810",
                "timer_handles": "timers",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleTimerInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800382c": {
            "entrypoint": "0x0800382c",
            "current_name": "handle_timer_interrupt_0800382c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_0800382c(void)\n\n{\n  if (timerHandles[8] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[8]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800382c": "handle_timer_interrupt_0800382c",
                "timer_handles": "timerHandles"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003840": {
            "entrypoint": "0x08003840",
            "current_name": "handle_timers_08003840",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimers_08003840(void)\n\n{\n  if (timerHandles[10] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[10]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003840": "handle_timers_08003840",
                "timer_handles": "timerHandles"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003854": {
            "entrypoint": "0x08003854",
            "current_name": "handle_timer_interrupt_08003854",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08003854(void)\n\n{\n  if (timerHandles[11] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[11]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003854": "handle_timer_interrupt_08003854",
                "timer_handles": "timerHandles"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003868": {
            "entrypoint": "0x08003868",
            "current_name": "handle_timer_interrupt_08003868",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08003868(void)\n\n{\n  if (timerHandles[13] != (TimerHandle *)0x0) {\n    handleTimerInterrupt_08003868Request(timerHandles[13]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003868": "handle_timer_interrupt_08003868",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleTimerInterruptRequest"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800387c": {
            "entrypoint": "0x0800387c",
            "current_name": "get_i2_c_pointer_0800387c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nI2CData * getI2CPointer_0800387c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  return (I2CData *)&i2cHandle[-1].eventCount;\n}\n\n",
            "renaming": {
                "FUN_0800387c": "get_i2_c_pointer_0800387c",
                "hi2c": "i2cHandle",
                "i2c_t": "I2CData",
                "EventCount": "eventCount"
            },
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003880": {
            "entrypoint": "0x08003880",
            "current_name": "handle_i2_c_transfer_08003880",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CTransfer_08003880(I2C_HandleTypeDef *i2cHandle,uint8_t direction,uint16_t addressCode)\n\n{\n  i2cStruct *currentI2C;\n  i2cStruct *i2cObject;\n  \n  currentI2C = getI2CObject(i2cHandle);\n  if ((uint)addressCode == (i2cHandle->i2cConfig).ownAddress1) {\n    if (direction == '\\0') {\n      currentI2C->bufferSize = '\\0';\n      currentI2C->isSlaveMode = '\\0';\n      if (currentI2C->onSlaveTransmitFunction != (_func_void *)0x0) {\n        (*currentI2C->onSlaveTransmitFunction)();\n      }\n      transmitSequentiallyIT\n                (i2cHandle,currentI2C->buffer,(ushort)currentI2C->bufferSize,8);\n      return;\n    }\n    currentI2C->isSlaveMode = '\\x01';\n    receiveSequentiallyIT(i2cHandle,currentI2C->buffer,0x20,8);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003880": "handle_i2_c_transfer_08003880",
                "hi2c": "i2cHandle",
                "TransferDirection": "direction",
                "AddrMatchCode": "addressCode",
                "i2c_t": "i2cStruct",
                "piVar1": "currentI2C",
                "obj": "i2cObject",
                "get_i2c_obj": "getI2CObject",
                "Init": "i2cConfig",
                "OwnAddress1": "ownAddress1",
                "i2cTxRxBufferSize": "bufferSize",
                "slaveMode": "isSlaveMode",
                "i2c_onSlaveTransmit": "onSlaveTransmitFunction",
                "HAL_I2C_Slave_Sequential_Transmit_IT": "transmitSequentiallyIT",
                "i2cTxRxBuffer": "buffer",
                "HAL_I2C_Slave_Sequential_Receive_IT": "receiveSequentiallyIT"
            },
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "HAL_I2C_Slave_Sequential_Transmit_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080038d0": {
            "entrypoint": "0x080038d0",
            "current_name": "handle_slave_receive_event_080038d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSlaveReceiveEvent_080038d0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2c_t *i2cObject;\n  i2c_t *i2cObject;\n  uint remainingBytes;\n  \n  i2cObject = get_i2c_i2cObject(i2cHandle);\n  if (((i2cObject->i2c_onSlaveReceive != (_func_void_uint8_t_ptr_int *)0x0) &&\n      (i2cObject->slaveMode == '\\x01')) &&\n     (remainingBytes = 0x20 - *(byte *)&(i2cObject->handle).XferSize & 0xff, remainingBytes != 0)) {\n    (*i2cObject->i2c_onSlaveReceive)(i2cObject->i2cTxRxBuffer,remainingBytes);\n  }\n  HAL_I2C_EnableListen_IT(i2cHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080038d0": "handle_slave_receive_event_080038d0",
                "hi2c": "i2cHandle",
                "piVar1": "i2cObject",
                "obj": "i2cObject",
                "uVar2": "remainingBytes"
            },
            "calling": [
                "I2C_Slave_STOPF",
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003900": {
            "entrypoint": "0x08003900",
            "current_name": "enable_listen_interrupt_08003900",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableListenInterrupt_08003900(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2c_t *i2cObj;\n  i2c_t *i2cObjPtr;\n  \n  i2cObj = get_i2c_i2cObjPtr(i2cHandle);\n  if (i2cObj->isMaster == '\\0') {\n    HAL_I2C_EnableListen_IT(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003900": "enable_listen_interrupt_08003900",
                "hi2c": "i2cHandle",
                "piVar1": "i2cObj",
                "obj": "i2cObjPtr"
            },
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003918": {
            "entrypoint": "0x08003918",
            "current_name": "handle_i2_c_event_interrupt_08003918",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEventInterrupt_08003918(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2c_handles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003918": "handle_i2_c_event_interrupt_08003918"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003928": {
            "entrypoint": "0x08003928",
            "current_name": "handle_i2_c_error_08003928",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CError_08003928(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2cHandles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003928": "handle_i2_c_error_08003928",
                "i2c_handles": "i2cHandles"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003938": {
            "entrypoint": "0x08003938",
            "current_name": "handle_i2_c2_error_event_08003938",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2C2ErrorEvent_08003938(void)\n\n{\n  handleErrorEventInterrupt(I2C2ErrorInterrupt::handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003938": "handle_i2_c2_error_event_08003938",
                "HAL_I2C_EV_IRQHandler": "handleErrorEventInterrupt",
                "I2C2_ER_IRQHandler": "I2C2ErrorInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003948": {
            "entrypoint": "0x08003948",
            "current_name": "handle_i2_c2_errors_08003948",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2C2Errors_08003948(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c2ErrorHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003948": "handle_i2_c2_errors_08003948",
                "I2C2_ER_IRQHandler::handle": "i2c2ErrorHandler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003958": {
            "entrypoint": "0x08003958",
            "current_name": "handle_i2_c3_errored_event_08003958",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2C3ErroredEvent_08003958(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2c3Handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003958": "handle_i2_c3_errored_event_08003958",
                "I2C3_ER_IRQHandler::handle": "i2c3Handle"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003968": {
            "entrypoint": "0x08003968",
            "current_name": "handle_i2_c_error_08003968",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CError_08003968(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2cErrorHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003968": "handle_i2_c_error_08003968",
                "I2C3_ER_IRQHandler::handle": "i2cErrorHandler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003978": {
            "entrypoint": "0x08003978",
            "current_name": "initialize_serial_object_08003978",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialObject_08003978(SerialObject *serialObj)\n\n{\n  void *a;\n  USART_TypeDef *txUART;\n  void *b;\n  USART_TypeDef *rxUART;\n  USART_TypeDef *mergedUART;\n  GPIO_TypeDef *GPIO_Port;\n  GPIO_TypeDef *GPIO_Port;\n  uint32_t pinFunction;\n  UART_HandleTypeDef *uartHandle;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  GPIO_InitTypeDef GPIO_InitConfig;\n  \n  if (serialObj != (SerialObject *)0x0) {\n    a = getPeripheralFromPinMap(serialObj->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n    b = getPeripheralFromPinMap(serialObj->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(\"ERROR: at least one UART pin has no peripheral\\n\");\n    }\n    else {\n      mergedUART = (USART_TypeDef *)mergePeripheralsFromPinMap(a,b);\n      serialObj->uart = mergedUART;\n      if (mergedUART == (USART_TypeDef *)0x0) {\n        iprintf(\"ERROR: U(S)ART pins mismatch\\n\");\n      }\n      else {\n        if (mergedUART == (USART_TypeDef *)0x40011000) {\n          _DAT_40023824 = _DAT_40023824 & 0xffffffef;\n          _DAT_40023844 = _DAT_40023844 | 0x10;\n          serialObj->index = '\\0';\n          serialObj->irq = USART1_IRQn;\n        }\n        else if (mergedUART == (USART_TypeDef *)0x40004400) {\n          _DAT_40023820 = _DAT_40023820 & 0xfffdffff;\n          _DAT_40023840 = _DAT_40023840 | 0x20000;\n          serialObj->index = '\\x01';\n          serialObj->irq = USART2_IRQn;\n        }\n        else if (mergedUART == (USART_TypeDef *)0x40004800) {\n          _DAT_40023820 = _DAT_40023820 & 0xfffbffff;\n          _DAT_40023840 = _DAT_40023840 | 0x40000;\n          serialObj->index = '\\x02';\n          serialObj->irq = USART3_IRQn;\n        }\n        else if (mergedUART == (USART_TypeDef *)0x40004c00) {\n          _DAT_40023820 = _DAT_40023820 & 0xfff7ffff;\n          _DAT_40023840 = _DAT_40023840 | 0x80000;\n          serialObj->index = '\\x03';\n          serialObj->irq = UART4_IRQn;\n        }\n        else if (mergedUART == (USART_TypeDef *)0x40005000) {\n          _DAT_40023820 = _DAT_40023820 & 0xffefffff;\n          _DAT_40023840 = _DAT_40023840 | 0x100000;\n          serialObj->index = '\\x04';\n          serialObj->irq = UART5_IRQn;\n        }\n        else if (mergedUART == (USART_TypeDef *)0x40011400) {\n          _DAT_40023824 = _DAT_40023824 & 0xffffffdf;\n          _DAT_40023844 = _DAT_40023844 | 0x20;\n          serialObj->index = '\\x05';\n          serialObj->irq = USART6_IRQn;\n        }\n        else if (mergedUART == (USART_TypeDef *)0x40007800) {\n          _DAT_40023820 = _DAT_40023820 & 0xbfffffff;\n          _DAT_40023840 = _DAT_40023840 | 0x40000000;\n          serialObj->index = '\\x06';\n          serialObj->irq = UART7_IRQn;\n        }\n        else if (mergedUART == (USART_TypeDef *)0x40007c00) {\n          _DAT_40023820 = _DAT_40023820 & 0x7fffffff;\n          _DAT_40023840 = _DAT_40023840 | 0x80000000;\n          serialObj->index = '\\a';\n          serialObj->irq = UART8_IRQn;\n        }\n        GPIO_Port = setGPIOClock((uint)((int)serialObj->pin_rx << 0x18) >> 0x1c);\n        pinFunction = getFunctionFromPinMap(serialObj->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n        GPIO_InitConfig.Pin = 1 << (serialObj->pin_rx & 0xfU) & 0xffff;\n        GPIO_InitConfig.Mode = (pinFunction >> 3 & 1) << 4 | pinFunction & 7;\n        GPIO_InitConfig.Pull = (pinFunction << 0x1a) >> 0x1e;\n        GPIO_InitConfig.Alternate = (pinFunction << 0x11) >> 0x19;\n        GPIO_InitConfig.Speed = 3;\n        initializeGPIO(GPIO_Port,&GPIO_InitConfig);\n        GPIO_Port = setGPIOClock((uint)((int)serialObj->pin_tx << 0x18) >> 0x1c);\n        pinFunction = getFunctionFromPinMap(serialObj->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n        GPIO_InitConfig.Pin = 1 << (serialObj->pin_tx & 0xfU) & 0xffff;\n        GPIO_InitConfig.Mode = (pinFunction >> 3 & 1) << 4 | pinFunction & 7;\n        GPIO_InitConfig.Pull = (pinFunction << 0x1a) >> 0x1e;\n        initializeGPIO(GPIO_Port,&GPIO_InitConfig);\n        uartHandlers[serialObj->index] = &serialObj->handle;\n        (serialObj->handle).Instance = serialObj->uart;\n        (serialObj->handle).Init.BaudRate = serialObj->baudrate;\n        (serialObj->handle).Init.WordLength = serialObj->databits;\n        (serialObj->handle).Init.StopBits = serialObj->stopbits;\n        (serialObj->handle).Init.Parity = serialObj->parity;\n        (serialObj->handle).Init.Mode = 0xc;\n        (serialObj->handle).Init.HwFlowCtl = 0;\n        (serialObj->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&serialObj->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003978": "initialize_serial_object_08003978",
                "serial_t": "SerialObject",
                "obj": "serialObj",
                "uart_tx": "txUART",
                "uart_rx": "rxUART",
                "pUVar1": "mergedUART",
                "pGVar2": "GPIO_Port",
                "port": "GPIO_Port",
                "uVar3": "pinFunction",
                "huart": "uartHandle",
                "GPIO_InitStruct": "GPIO_InitConfig",
                "pinmap_peripheral": "getPeripheralFromPinMap",
                "pinmap_merge_peripheral": "mergePeripheralsFromPinMap",
                "pinmap_function": "getFunctionFromPinMap",
                "set_GPIO_Port_Clock": "setGPIOClock",
                "HAL_GPIO_Init": "initializeGPIO",
                "uart_handlers": "uartHandlers"
            },
            "calling": [
                "begin",
                "uart_debug_init"
            ],
            "called": [
                "pinmap_function",
                "HAL_UART_Init",
                "pinmap_merge_peripheral",
                "HAL_GPIO_Init",
                "iprintf",
                "set_GPIO_Port_Clock",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003cc8": {
            "entrypoint": "0x08003cc8",
            "current_name": "initialize_serial_debug_08003cc8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialDebug_08003cc8(void)\n\n{\n  void *peripheral;\n  \n  peripheral = pinmap_peripheral(pinPD_8,(conflictMap *)&UARTTX_Map);\n  if (peripheral != (void *)0x0) {\n    peripheral = pinmap_peripheral(pinPD_8,(conflictMap *)&UARTTX_Map);\n    debugSerial.pin_rx = pinmap_pin(peripheral,(conflictMap *)&UARTRX_Map);\n    debugSerial.pin_tx = pinPD_8;\n    debugSerial.baudrate = 0x2580;\n    debugSerial.parity = 0;\n    debugSerial.databits = 0;\n    debugSerial.stopbits = 0;\n    uart_init(&debugSerial);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003cc8": "initialize_serial_debug_08003cc8",
                "pvVar1": "peripheral",
                "PinMap_conflict": "conflictMap",
                "serial_debug": "debugSerial",
                "PD_8": "pinPD_8",
                "PinMap_UART_TX": "UARTTX_Map",
                "PinMap_UART_RX": "UARTRX_Map"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "pinmap_pin",
                "uart_init",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d18": {
            "entrypoint": "0x08003d18",
            "current_name": "transmit_data_08003d18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nbufferSize_t transmitData_08003d18(uint8_t *dataBuffer,uint32_t bufferSize)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTime;\n  uint32_t tickStart;\n  void *uartPeriph;\n  USART_TypeDef *uartInstance;\n  uint32_t currentTime;\n  uint uartIndex;\n  \n  startTime = HAL_GetTick();\n  uartPeriph = pinmap_peripheral(PD_8,(PinMap_conflict *)&PinMap_UART_TX);\n  if (uartPeriph == (void *)0x0) {\n    return 0;\n  }\n  uartIndex = 0;\n  while ((uartIndex < 10 &&\n         ((uart_handlers[uartIndex] == (UART_HandleTypeDef *)0x0 ||\n          (uartInstance = (USART_TypeDef *)pinmap_peripheral(PD_8,(PinMap_conflict *)&PinMap_UART_TX),\n          uart_handlers[uartIndex]->Instance != uartInstance))))) {\n    uartIndex = uartIndex + 1 & 0xff;\n  }\n  if (9 < uartIndex) {\n    if ((9 < serial_debug.index) && (uart_debug_init(), 9 < serial_debug.index)) {\n      return 0;\n    }\n    uartIndex = (uint)serial_debug.index;\n  }\n  do {\n    status = HAL_UART_Transmit(uart_handlers[uartIndex],dataBuffer,(uint16_t)bufferSize,1000);\n    if (status == HAL_OK) {\n      return bufferSize;\n    }\n    currentTime = HAL_GetTick();\n  } while (currentTime - startTime < 1000);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08003d18": "transmit_data_08003d18",
                "data": "dataBuffer",
                "size": "bufferSize",
                "HVar1": "status",
                "uVar2": "startTime",
                "tickstart": "tickStart",
                "pvVar3": "uartPeriph",
                "pUVar4": "uartInstance",
                "uVar5": "currentTime",
                "uVar6": "uartIndex"
            },
            "calling": [
                "_write"
            ],
            "called": [
                "HAL_GetTick",
                "uart_debug_init",
                "HAL_UART_Transmit",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003dd0": {
            "entrypoint": "0x08003dd0",
            "current_name": "check_uart_state_08003dd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_state_08003dd0(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(uart_handlers[serial_object->index]);\n  return (uart_state & 0x22) == 0x22;\n}\n\n",
            "renaming": {
                "FUN_08003dd0": "check_uart_state_08003dd0",
                "obj": "serial_object",
                "HVar1": "uart_state"
            },
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003df4": {
            "entrypoint": "0x08003df4",
            "current_name": "check_uart_state_08003df4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_state_08003df4(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(uart_handlers[serial_object->index]);\n  return (uart_state & 0x21) == 0x21;\n}\n\n",
            "renaming": {
                "FUN_08003df4": "check_uart_state_08003df4",
                "obj": "serial_object",
                "HVar1": "uart_state"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e18": {
            "entrypoint": "0x08003e18",
            "current_name": "receive_data_08003e18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint receiveData_08003e18(serial_t *serialObject,uchar *c)\n\n{\n  uint8_t isActive;\n  \n  if (serialObject == (serial_t *)0x0) {\n    return -1;\n  }\n  isActive = serial_rx_active(serialObject);\n  if (isActive == '\\0') {\n    *c = serialObject->recv;\n    HAL_UART_Receive_IT(uart_handlers[serialObject->index],&serialObject->recv,1);\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08003e18": "receive_data_08003e18",
                "obj": "serialObject",
                "uVar1": "isActive"
            },
            "calling": [
                "_rx_complete_irq"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e54": {
            "entrypoint": "0x08003e54",
            "current_name": "initialize_serial_connection_08003e54",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialConnection_08003e54(serial_t *serialObject,_func_void_serial_t_ptr *serialCallback)\n\n{\n  byte indexByte;\n  uint8_t rxActive;\n  \n  if (serialObject != (serial_t *)0x0) {\n    rxActive = serial_rx_active(serialObject);\n    if (rxActive == '\\0') {\n      indexByte = serialObject->index;\n      receiveCallback[indexByte] = serialCallback;\n      receiveCallbackObject[indexByte] = serialObject;\n      HAL_NVIC_SetPriority(serialObject->irq,0,1);\n      HAL_NVIC_EnableIRQ(serialObject->irq);\n      HAL_UART_Receive_IT(uart_handlers[serialObject->index],&serialObject->recv,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e54": "initialize_serial_connection_08003e54",
                "obj": "serialObject",
                "callback": "serialCallback",
                "bVar1": "indexByte",
                "uVar2": "rxActive",
                "rx_callback": "receiveCallback",
                "rx_callback_obj": "receiveCallbackObject"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority",
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003eac": {
            "entrypoint": "0x08003eac",
            "current_name": "transmit_serial_data_08003eac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitSerialData_08003eac(serial_t *serialObject,_func_int_serial_t_ptr *callbackFunction)\n\n{\n  byte objectIndex;\n  \n  if (serialObject != (serial_t *)0x0) {\n    objectIndex = serialObject->index;\n    transmitCallback[objectIndex] = callbackFunction;\n    transmitCallbackObject[objectIndex] = serialObject;\n    setInterruptPriority(serialObject->irq,0,2);\n    enableInterrupt(serialObject->irq);\n    transmitDataInterrupt(uartHandlers[serialObject->index],serialObject->transmitBuffer + serialObject->transmitTail,1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003eac": "transmit_serial_data_08003eac",
                "obj": "serialObject",
                "callback": "callbackFunction",
                "bVar1": "objectIndex",
                "tx_callback": "transmitCallback",
                "tx_callback_obj": "transmitCallbackObject",
                "HAL_NVIC_SetPriority": "setInterruptPriority",
                "HAL_NVIC_EnableIRQ": "enableInterrupt",
                "HAL_UART_Transmit_IT": "transmitDataInterrupt",
                "uart_handlers": "uartHandlers",
                "tx_buff": "transmitBuffer",
                "tx_tail": "transmitTail"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f00": {
            "entrypoint": "0x08003f00",
            "current_name": "find_uart_handler_index_08003f00",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t find_uart_handler_index_08003f00(UART_HandleTypeDef *uart_handler)\n\n{\n  uint index;\n  \n  if (uart_handler == (UART_HandleTypeDef *)0x0) {\n    index = 10;\n  }\n  else {\n    index = 0;\n    while( true ) {\n      if (9 < index) {\n        return (uint8_t)index;\n      }\n      if (uart_handler == uart_handlers[index]) break;\n      index = index + 1 & 0xff;\n    }\n  }\n  return (uint8_t)index;\n}\n\n",
            "renaming": {
                "FUN_08003f00": "find_uart_handler_index_08003f00",
                "huart": "uart_handler",
                "uVar1": "index"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "HAL_UART_RxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f24": {
            "entrypoint": "0x08003f24",
            "current_name": "process_received_data_08003f24",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processReceivedData_08003f24(UART_HandleTypeDef *uartHandler)\n\n{\n  byte uartIndex;\n  uint8_t loopIndex;\n  uint convertedUartIndex;\n  \n  uartIndex = uart_loopIndex(uartHandler);\n  convertedUartIndex = (uint)uartIndex;\n  if (convertedUartIndex < 10) {\n    (*rx_callback[convertedUartIndex])(rx_callback_obj[convertedUartIndex]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f24": "process_received_data_08003f24",
                "huart": "uartHandler",
                "bVar1": "uartIndex",
                "index": "loopIndex",
                "uVar2": "convertedUartIndex"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f48": {
            "entrypoint": "0x08003f48",
            "current_name": "transmit_data_08003f48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitData_08003f48(UART_HandleTypeDef *uartHandler)\n\n{\n  byte uartIndex;\n  uint8_t serialIndex;\n  int transmitResult;\n  serial_t *serialObject;\n  serial_t *callbackObject;\n  uint callbackIndex;\n  \n  uartIndex = uart_serialIndex(uartHandler);\n  callbackIndex = (uint)uartIndex;\n  callbackObject = tx_callback_serialObject[callbackIndex];\n  if ((callbackIndex < 10) && (transmitResult = (*tx_callback[callbackIndex])(callbackObject), transmitResult != -1)) {\n    HAL_UART_Transmit_IT(uart_handlers[callbackObject->serialIndex],callbackObject->tx_buff + callbackObject->tx_tail,1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f48": "transmit_data_08003f48",
                "huart": "uartHandler",
                "bVar1": "uartIndex",
                "index": "serialIndex",
                "iVar3": "transmitResult",
                "obj": "serialObject",
                "psVar4": "callbackObject",
                "uVar2": "callbackIndex"
            },
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f94": {
            "entrypoint": "0x08003f94",
            "current_name": "initialize_uart_08003f94",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_uart_08003f94(UART_HandleTypeDef *uart_handler)\n\n{\n  uint32_t temporary_value;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f94": "initialize_uart_08003f94",
                "huart": "uart_handler",
                "tmpval": "temporary_value"
            },
            "calling": [
                "UART_DMAAbortOnError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fd4": {
            "entrypoint": "0x08003fd4",
            "current_name": "handle_uart1_interrupt_08003fd4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART1_interrupt_08003fd4(void)\n\n{\n  clear_pending_interrupt(UART1_interrupt);\n  handle_IRQ(UART_handler_0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fd4": "handle_uart1_interrupt_08003fd4",
                "USART1_IRQn": "UART1_interrupt",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "HAL_UART_IRQHandler": "handle_IRQ",
                "uart_handlers[0]": "UART_handler_0"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fec": {
            "entrypoint": "0x08003fec",
            "current_name": "handle_uart2_interrupt_08003fec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART2_interrupt_08003fec(void)\n\n{\n  clear_pending_UART_interrupt(UART2_interrupt_number);\n  process_UART_interrupt(UART_interrupt_handlers[1]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fec": "handle_uart2_interrupt_08003fec",
                "USART2_IRQn": "UART2_interrupt_number",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_UART_interrupt",
                "HAL_UART_IRQHandler": "process_UART_interrupt",
                "uart_handlers": "UART_interrupt_handlers"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004004": {
            "entrypoint": "0x08004004",
            "current_name": "handle_usart3_pending_interrupt_08004004",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_USART3_pending_interrupt_08004004(void)\n\n{\n  clear_pending_interrupt(USART3_interrupt);\n  if (uart_handler_array[2] != (UART_HandleTypeDef *)0x0) {\n    handle_UART_interrupt(uart_handler_array[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004004": "handle_usart3_pending_interrupt_08004004",
                "uart_handlers": "uart_handler_array",
                "USART3_IRQn": "USART3_interrupt",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "HAL_UART_IRQHandler": "handle_UART_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800401c": {
            "entrypoint": "0x0800401c",
            "current_name": "handle_uart4_interrupt_0800401c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART4_interrupt_0800401c(void)\n\n{\n  clear_pending_interrupt(UART4_interrupt_number);\n  handle_UART_interrupt(UART_handlers[3]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800401c": "handle_uart4_interrupt_0800401c",
                "UART4_IRQn": "UART4_interrupt_number",
                "uart_handlers": "UART_handlers",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "HAL_UART_IRQHandler": "handle_UART_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004034": {
            "entrypoint": "0x08004034",
            "current_name": "handle_uart5_interrupt_08004034",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART5_interrupt_08004034(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(UART5_Interrupt);\n  HAL_UART_IRQHandler(UART_handlers[4]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004034": "handle_uart5_interrupt_08004034",
                "UART5_IRQn": "UART5_Interrupt",
                "uart_handlers": "UART_handlers"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800404c": {
            "entrypoint": "0x0800404c",
            "current_name": "handle_usart6_ir_qn_0800404c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_USART6_IRQn_0800404c(void)\n\n{\n  clear_pending_IRQ(irq_number);\n  handle_UART_IRQ(UART_handlers[5]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800404c": "handle_usart6_ir_qn_0800404c",
                "USART6_IRQn": "irq_number",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_IRQ",
                "HAL_UART_IRQHandler": "handle_UART_IRQ",
                "uart_handlers": "UART_handlers"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004064": {
            "entrypoint": "0x08004064",
            "current_name": "clear_pending_irq_and_handle_uart_08004064",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearPendingIRQAndHandleUART_08004064(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(UART7Interrupt);\n  HAL_UART_IRQHandler(uartHandler6);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004064": "clear_pending_irq_and_handle_uart_08004064",
                "UART7_IRQn": "UART7Interrupt",
                "uart_handlers[6]": "uartHandler6"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800407c": {
            "entrypoint": "0x0800407c",
            "current_name": "handle_uart8_interrupt_0800407c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART8_interrupt_0800407c(void)\n\n{\n  clear_pending_interrupt(uart8_interrupt);\n  handle_UART_interrupt(handlers[7]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800407c": "handle_uart8_interrupt_0800407c",
                "UART8_IRQn": "uart8_interrupt",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "HAL_UART_IRQHandler": "handle_UART_interrupt",
                "uart_handlers": "handlers"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004094": {
            "entrypoint": "0x08004094",
            "current_name": "allocate_memory_08004094",
            "code": "\nvoid * allocate_memory_08004094(intptr_t memory_size)\n\n{\n  char *current_heap_end;\n  char *previous_heap_end;\n  \n  if (_sbrk::heap_end == (char *)0x0) {\n    _sbrk::heap_end = &_ebss;\n  }\n  current_heap_end = _sbrk::heap_end;\n  if (_sbrk::heap_end + memory_size <= &stack0x00000000) {\n    _sbrk::heap_end = _sbrk::heap_end + memory_size;\n    return current_heap_end;\n  }\n  errno = 0xc;\n  return (void *)0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08004094": "allocate_memory_08004094",
                "__delta": "memory_size",
                "pcVar1": "current_heap_end",
                "prev_heap_end": "previous_heap_end"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040d0": {
            "entrypoint": "0x080040d0",
            "current_name": "check_fd_080040d0",
            "code": "\nint check_fd_080040d0(int file_descriptor)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_080040d0": "check_fd_080040d0",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_close_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040d6": {
            "entrypoint": "0x080040d6",
            "current_name": "initialize_stat_structure_080040d6",
            "code": "\nint initializeStatStructure_080040d6(int fileDescriptor,stat *statStructure)\n\n{\n  *(undefined4 *)((int)&statStructure->st_dev + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040d6": "initialize_stat_structure_080040d6",
                "__fd": "fileDescriptor",
                "__buf": "statStructure"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e0": {
            "entrypoint": "0x080040e0",
            "current_name": "check_file_descriptor_080040e0",
            "code": "\nint checkFileDescriptor_080040e0(int fileDescriptor)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080040e0": "check_file_descriptor_080040e0",
                "__fd": "fileDescriptor"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e4": {
            "entrypoint": "0x080040e4",
            "current_name": "get_file_offset_080040e4",
            "code": "\n__off_t getFileOffset_080040e4(int fileDescriptor,__off_t offset,int origin)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040e4": "get_file_offset_080040e4",
                "__fd": "fileDescriptor",
                "__offset": "offset",
                "__whence": "origin"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e8": {
            "entrypoint": "0x080040e8",
            "current_name": "clear_unused_data_080040e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint clear_unused_data_080040e8(int file_descriptor,char *unused_pointer,int unused_length)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040e8": "clear_unused_data_080040e8",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "unused_pointer",
                "len_UNUSED": "unused_length"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040ec": {
            "entrypoint": "0x080040ec",
            "current_name": "write_data_to_uart_080040ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint write_data_to_uart_080040ec(int unused_file_parameter,char *data_pointer,int data_length)\n\n{\n  size_t bytes_written;\n  \n  bytes_written = uart_debug_write((uint8_t *)data_pointer,data_length);\n  return bytes_written;\n}\n\n",
            "renaming": {
                "FUN_080040ec": "write_data_to_uart_080040ec",
                "file_UNUSED": "unused_file_parameter",
                "ptr": "data_pointer",
                "len": "data_length",
                "sVar1": "bytes_written"
            },
            "calling": [
                "_write_r"
            ],
            "called": [
                "uart_debug_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040f8": {
            "entrypoint": "0x080040f8",
            "current_name": "infinite_loop_080040f8",
            "code": "\nvoid infiniteLoop_080040f8(int status)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080040f8": "infinite_loop_080040f8",
                "__status": "status"
            },
            "calling": [
                "abort",
                "_exit"
            ],
            "called": [
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040fc": {
            "entrypoint": "0x080040fc",
            "current_name": "set_errno_and_return_080040fc",
            "code": "\nint setErrnoAndReturn_080040fc(processId_t processId,int signal)\n\n{\n  errorNumber = 0x16;\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_080040fc": "set_errno_and_return_080040fc",
                "__pid": "processId",
                "__sig": "signal",
                "errno": "errorNumber"
            },
            "calling": [
                "_kill_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800410c": {
            "entrypoint": "0x0800410c",
            "current_name": "get_process_id_0800410c",
            "code": "\n\n\npid get_process_id_0800410c(void)\n\n{\n  pid 1;\n}\n\n",
            "renaming": {
                "FUN_0800410c": "get_process_id_0800410c",
                "__pid_t": "pid",
                "return": "pid"
            },
            "calling": [
                "_getpid_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004110": {
            "entrypoint": "0x08004110",
            "current_name": "configure_pin_08004110",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_08004110(uint32_t pinNumber,uint32_t mode)\n\n{\n  bool _Var1;\n  PinName pin;\n  \n  if (pinNumber < 0x60) {\n    pin = *(PinName *)(&digitalPin + pinNumber * 2);\n  }\n  else {\n    pin = NotConnected;\n  }\n  if (pin != NotConnected) {\n    _Var1 = isOutputPinConfigured(pin,outputPinConfigured);\n    if (_Var1) {\n      _Var1 = isPinInPinmap(pin,(PinMap *)&PinMapDAC);\n      if (_Var1) {\n        stopDAC(pin);\n      }\n      else {\n        _Var1 = isPinInPinmap(pin,(PinMap *)&PinMapPWM);\n        if (_Var1) {\n          stopPWM(pin);\n        }\n      }\n      resetOutputPinConfigured(pin,outputPinConfigured);\n    }\n    switch(mode) {\n    case 0:\n      initializeDigitalIO(pin,0,0);\n      break;\n    case 1:\n      initializeDigitalIO(pin,1,0);\n      break;\n    case 2:\n      initializeDigitalIO(pin,0,1);\n      break;\n    case 3:\n      initializeDigitalIO(pin,0,2);\n    }\n    setDigitalPinConfigured(pin,digitalPinConfigured);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004110": "configure_pin_08004110",
                "ulPin": "pinNumber",
                "ulMode": "mode",
                "_Bool": "bool",
                "PinName_conflict": "PinName",
                "p": "pin",
                "g_anOutputPinConfigured": "outputPinConfigured",
                "is_pin_configured": "isOutputPinConfigured",
                "PinMap_conflict": "PinMap",
                "PinMap_DAC": "PinMapDAC",
                "dac_stop": "stopDAC",
                "pin_in_pinmap": "isPinInPinmap",
                "PinMap_PWM": "PinMapPWM",
                "pwm_stop": "stopPWM",
                "reset_pin_configured": "resetOutputPinConfigured",
                "digital_io_init": "initializeDigitalIO",
                "g_digPinConfigured": "digitalPinConfigured",
                "set_pin_configured": "setDigitalPinConfigured",
                "NC": "NotConnected"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "pin_in_pinmap",
                "reset_pin_configured",
                "digital_io_init",
                "set_pin_configured",
                "dac_stop",
                "is_pin_configured",
                "pwm_stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041bc": {
            "entrypoint": "0x080041bc",
            "current_name": "set_pin_value_080041bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinValue_080041bc(uint32_t pinNumber,uint32_t pinValue)\n\n{\n  _Bool pinConfigured;\n  GPIO_TypinNameeDef *gpioPort;\n  PinName_conflict pinName;\n  uint mappedPin;\n  \n  if (pinNumber < 0x60) {\n    mappedPin = (uint)*(short *)(&pinMappings + pinNumber * 2);\n  }\n  else {\n    mappedPin = 0xffffffff;\n  }\n  if ((mappedPin != 0xffffffff) &&\n     (pinConfigured = isPinConfigured((PinName_conflict)mappedPin,pinConfigurationStatus), pinConfigured)) {\n    gpioPort = getGPIOPort((mappedPin << 0x18) >> 0x1c);\n    writeDigitalIO(gpioPort,1 << (mappedPin & 0xf) & 0xffff,pinValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041bc": "set_pin_value_080041bc",
                "ulPin": "pinNumber",
                "ulVal": "pinValue",
                "_Var1": "pinConfigured",
                "port": "gpioPort",
                "p": "pinName",
                "uVar2": "mappedPin",
                "digitalPin": "pinMappings",
                "is_pin_configured": "isPinConfigured",
                "g_digPinConfigured": "pinConfigurationStatus",
                "get_GPIO_Port": "getGPIOPort",
                "digital_io_write": "writeDigitalIO"
            },
            "calling": [
                "sendTxBuffer",
                "getRxBuffer",
                "begin"
            ],
            "called": [
                "digital_io_write",
                "get_GPIO_Port",
                "is_pin_configured"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004204": {
            "entrypoint": "0x08004204",
            "current_name": "get_current_millisecond_08004204",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_millisecond_08004204(void)\n\n{\n  uint32_t current_millisecond;\n  \n  current_millisecond = GetCurrentMilli();\n  return current_millisecond;\n}\n\n",
            "renaming": {
                "FUN_08004204": "get_current_millisecond_08004204",
                "uVar1": "current_millisecond"
            },
            "calling": [
                "sendTxBuffer",
                "poll"
            ],
            "called": [
                "GetCurrentMilli"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800420c": {
            "entrypoint": "0x0800420c",
            "current_name": "update_tx_tail_and_check_head_0800420c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint HardwareSerial::updateTxTailAndCheckHead_0800420c(serialObj *serialObject)\n\n{\n  ushort newValue;\n  uint16_t maskedValue;\n  int updatedValue;\n  \n  updatedValue = serialObject->tx_tail + 1;\n  newValue = (ushort)updatedValue;\n  maskedValue = newValue & 0x7f;\n  if (updatedValue == 0) {\n    maskedValue = -(-newValue & 0x7f);\n  }\n  serialObject->tx_tail = maskedValue;\n  if (serialObject->tx_head != serialObject->tx_tail) {\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_0800420c": "update_tx_tail_and_check_head_0800420c",
                "serial_t_conflict": "serialObj",
                "obj": "serialObject",
                "uVar1": "newValue",
                "uVar2": "maskedValue",
                "iVar3": "updatedValue"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004240": {
            "entrypoint": "0x08004240",
            "current_name": "calculate_available_08004240",
            "code": "\n/* DWARF original prototype: int  available(HardwareSerial * serial) */\n\nint __serialcall HardwareSerial::calculateAvailable_08004240(HardwareSerial *serial)\n\n{\n  return ((serial->serialData).receiveHead + 0x40) - (uint)(serial->serialData).receiveTail & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_08004240": "calculate_available_08004240",
                "this": "serial",
                "_serial": "serialData",
                "rx_head": "receiveHead",
                "rx_tail": "receiveTail"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004254": {
            "entrypoint": "0x08004254",
            "current_name": "peek_08004254",
            "code": "\n/* DWARF original prototype: int  peek_08004254(HardwareSerial * serial) */\n\nint __serialcall HardwareSerial::peek_08004254(HardwareSerial *serial)\n\n{\n  uint rx_tail;\n  \n  rx_tail = (uint)(serial->serial).rx_tail;\n  if ((serial->serial).rx_head != rx_tail) {\n    return (uint)(serial->serial).rx_buff[rx_tail];\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08004254": "peek_08004254",
                "this": "serial",
                "uVar1": "rx_tail",
                "_serial": "serial"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004270": {
            "entrypoint": "0x08004270",
            "current_name": "read_data_08004270",
            "code": "\n/* DWARF original prototype: int  read(HardwareSerial * this) */\n\nssize_t __thiscall\nHardwareSerial::readData_08004270(HardwareSerial *this,int fileDescriptor,void *buffer,size_t numBytes)\n\n{\n  byte byteValue;\n  ushort tailIndex;\n  uchar c;\n  \n  tailIndex = (this->_serial).rx_tail;\n  if ((uint)(this->_serial).rx_head != (uint)tailIndex) {\n    byteValue = (this->_serial).rx_buff[tailIndex];\n    (this->_serial).rx_tail = tailIndex + 1 & 0x3f;\n    return (uint)byteValue;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08004270": "read_data_08004270",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "bVar1": "byteValue",
                "uVar2": "tailIndex"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004298": {
            "entrypoint": "0x08004298",
            "current_name": "flush_serial_08004298",
            "code": "\n/* DWARF original prototype: void  flush(HardwareSerial * serial) */\n\nvoid __serialcall HardwareSerial::flushSerial_08004298(HardwareSerial *serial)\n\n{\n  if (serial->hasDataToWrite != false) {\n    do {\n    } while ((serial->serialData).transmitHead != (serial->serialData).transmitTail);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004298": "flush_serial_08004298",
                "this": "serial",
                "_written": "hasDataToWrite",
                "_serial": "serialData",
                "tx_head": "transmitHead",
                "tx_tail": "transmitTail"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042ac": {
            "entrypoint": "0x080042ac",
            "current_name": "read_and_store_serial_data_080042ac",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd HardwareSerindexal::readAndStoreSerialData_080042ac(serindexal_t_conflindexct *serialObject)\n\n{\n  indexnt returnValue;\n  rx_buffer_indexndex_t index;\n  ushort updatedIndex;\n  uchar c;\n  \n  returnValue = uart_getc((serindexal_t *)serialObject,&c);\n  indexf ((returnValue == 0) && (updatedIndex = serialObject->rx_head + 1 & 0x3f, updatedIndex != serialObject->rx_taindexl)) {\n    serialObject->rx_buff[serialObject->rx_head] = c;\n    serialObject->rx_head = updatedIndex;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080042ac": "read_and_store_serial_data_080042ac",
                "obj": "serialObject",
                "iVar1": "returnValue",
                "i": "index",
                "uVar2": "updatedIndex"
            },
            "calling": [],
            "called": [
                "uart_getc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042e8": {
            "entrypoint": "0x080042e8",
            "current_name": "write_data_080042e8",
            "code": "\n/* DWARF orindexVargindexVarnal prototype: sindexVarze_t  wrindexVarte(HardwareSerindexVaral * serialPtr, uindexVarnt8_t c) */\n\nssindexVarze_t __serialPtrcall\nHardwareSerindexVaral::writeData_080042e8(HardwareSerindexVaral *serialPtr,indexVarnt fileDescriptor,voindexVard *bufferPtr,sindexVarze_t bufferSize)\n\n{\n  byte byteVar1;\n  uindexVarnt8_t uint8Var2;\n  byte byteVar3;\n  indexVarnt intVar4;\n  uindexVarnt uintVar5;\n  tx_buffer_indexVarndex_t indexVar;\n  \n  serialPtr->_wrindexVartten = true;\n  uintVar5 = (uindexVarnt)(serialPtr->_serindexVaral).tx_head;\n  intVar4 = uintVar5 + 1;\n  byteVar1 = (byte)intVar4;\n  byteVar3 = byteVar1 & 0x7f;\n  indexVarf (intVar4 == 0) {\n    byteVar3 = -(-byteVar1 & 0x7f);\n  }\n  do {\n  } whindexVarle ((serialPtr->_serindexVaral).tx_taindexVarl == (ushort)byteVar3);\n  (serialPtr->_serindexVaral).tx_buff[uintVar5] = (uindexVarnt8_t)fileDescriptor;\n  (serialPtr->_serindexVaral).tx_head = (ushort)byteVar3;\n  uint8Var2 = serindexVaral_tx_actindexVarve((serindexVaral_t *)&serialPtr->_serindexVaral);\n  indexVarf (uint8Var2 == '\\0') {\n    uart_attach_tx_callback((serindexVaral_t *)&serialPtr->_serindexVaral,_tx_complete_indexVarrq + 1);\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "this": "serialPtr",
                "__fd": "fileDescriptor",
                "__buf": "bufferPtr",
                "__n": "bufferSize",
                "bVar1": "byteVar1",
                "uVar2": "uint8Var2",
                "bVar3": "byteVar3",
                "iVar4": "intVar4",
                "uVar5": "uintVar5",
                "i": "indexVar",
                "FUN_080042e8": "write_data_080042e8"
            },
            "calling": [],
            "called": [
                "uart_attach_tx_callback",
                "serial_tx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004338": {
            "entrypoint": "0x08004338",
            "current_name": "FUNC_08004338",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800433e) */\n/* WARNING: Removing unreachable block (ram,0x08004350) */\n/* WARNING: Removing unreachable block (ram,0x08004346) */\n/* WARNING: Removing unreachable block (ram,0x08004358) */\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004338(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004338": "FUNC_08004338"
            },
            "calling": [
                "main"
            ],
            "called": [
                "available"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004364": {
            "entrypoint": "0x08004364",
            "current_name": "initialize_serial_08004364",
            "code": "\n/* DWARF original prototype: void  init(HardwareSerial * serial) */\n\nint __serialcall HardwareSerial::initializeSerial_08004364(HardwareSerial *serial,EVP_PKEY_CTX *context)\n\n{\n  (serial->_serial).rx_buff = serial->_rx_buffer;\n  (serial->_serial).rx_head = 0;\n  (serial->_serial).rx_tail = 0;\n  (serial->_serial).tx_buff = serial->_tx_buffer;\n  (serial->_serial).tx_head = 0;\n  (serial->_serial).tx_tail = 0;\n  return (int)serial;\n}\n\n",
            "renaming": {
                "FUN_08004364": "initialize_serial_08004364",
                "this": "serial",
                "ctx": "context"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004388": {
            "entrypoint": "0x08004388",
            "current_name": "configure_serial_port_08004388",
            "code": "\n/* DWARF original prototype: void  begin(HardwareSerial * serialObj, ulong baudRate, byte configByte) */\n\nvoid __serialObjcall HardwareSerial::configureSerialPort_08004388(HardwareSerial *serialObj,ulong baudRate,byte configByte)\n\n{\n  byte configBits;\n  int bitRate;\n  \n  (serialObj->_serial).baudRaterate = baudRate;\n  serialObj->_configByte = configByte;\n  configBits = configByte & 7;\n  if (configBits == 4) {\n    bitRate = 7;\n  }\n  else if (configBits == 6) {\n    bitRate = 8;\n  }\n  else if (configBits == 2) {\n    bitRate = 6;\n  }\n  else {\n    bitRate = 0;\n  }\n  if ((configByte & 0x30) == 0x30) {\n    (serialObj->_serial).parity = 0x600;\n    bitRate = bitRate + 1;\n  }\n  else if ((configByte & 0x20) == 0) {\n    (serialObj->_serial).parity = 0;\n  }\n  else {\n    (serialObj->_serial).parity = 0x400;\n    bitRate = bitRate + 1;\n  }\n  if ((configByte & 8) == 0) {\n    (serialObj->_serial).stopbits = 0;\n  }\n  else {\n    (serialObj->_serial).stopbits = 0x2000;\n  }\n  if (bitRate == 8) {\n    (serialObj->_serial).databits = 0;\n  }\n  else if (bitRate == 9) {\n    (serialObj->_serial).databits = 0x1000;\n  }\n  else {\n    bitRate = 0;\n  }\n  if (bitRate != 0) {\n    initializeUART((serial_t *)&serialObj->_serial);\n    attachRXCallbackToUART((serial_t *)&serialObj->_serial,rxCompleteIRQ + 1);\n    return;\n  }\n                    \n  assertFunction(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/cores/arduino/HardwareSerial.cpp\"\n                ,299,\"void HardwareSerial::begin(long unsigned int, byte)\",\"databits!=0\");\n}\n\n",
            "renaming": {
                "this": "serialObj",
                "baud": "baudRate",
                "config": "configByte",
                "bVar1": "configBits",
                "iVar2": "bitRate",
                "uart_init": "initializeUART",
                "uart_attach_rx_callback": "attachRXCallbackToUART",
                "_rx_complete_irq": "rxCompleteIRQ",
                "__assert_func": "assertFunction",
                "FUN_08004388": "configure_serial_port_08004388"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "uart_attach_rx_callback",
                "__assert_func",
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004444": {
            "entrypoint": "0x08004444",
            "current_name": "set_rx_pin_08004444",
            "code": "\n/* DWARF original prototype: void  setRx(HardwareSerial * serialObject, uint32_t rxPinNumber) */\n\nvoid __serialObjectcall HardwareSerial::setRxPin_08004444(HardwareSerial *serialObject,uint32_t rxPinNumber)\n\n{\n  PinName pinName;\n  \n  if (rxPinNumber < 0x60) {\n    pinName = *(PinName *)(&digitalPin + rxPinNumber * 2);\n  }\n  else {\n    pinName = NC;\n  }\n  (serialObject->_serial).pinrxPinNumber = pinName;\n  return;\n}\n\n",
            "renaming": {
                "this": "serialObject",
                "_rx": "rxPinNumber",
                "PVar1": "pinName",
                "FUN_08004444": "set_rx_pin_08004444"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004460": {
            "entrypoint": "0x08004460",
            "current_name": "set_tx_08004460",
            "code": "\n/* DWARF original prototype: void  setTx_08004460(HardwareSerial * serialObject, uint32_t txPinIndex) */\n\nvoid __serialObjectcall HardwareSerial::setTx_08004460(HardwareSerial *serialObject,uint32_t txPinIndex)\n\n{\n  PinName txPinName;\n  \n  if (txPinIndex < 0x60) {\n    txPinName = *(PinName *)(&digitalPin + txPinIndex * 2);\n  }\n  else {\n    txPinName = NC;\n  }\n  (serialObject->_serial).pintxPinIndex = txPinName;\n  return;\n}\n\n",
            "renaming": {
                "this": "serialObject",
                "_tx": "txPinIndex",
                "PVar1": "txPinName",
                "FUN_08004460": "set_tx_08004460"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800447c": {
            "entrypoint": "0x0800447c",
            "current_name": "initialize_serial_0800447c",
            "code": "\n/* DWARF original prototype: HardwareSerial *  HardwareSerial(HardwareSerial * serial, void *\n   device) */\n\nHardwareSerial * __serialcall HardwareSerial::initializeSerial_0800447c(HardwareSerial *serial,void *device)\n\n{\n  PinName rxPin;\n  EVP_PKEY_CTX *ctx;\n  EVP_PKEY_CTX *ctx;\n  EVP_PKEY_CTX *ctx;\n  \n  (serial->super_Stream).super_Print.write_error = 0;\n  (serial->super_Stream)._timeout = 1000;\n  (serial->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)&PTR_write_1_08005ed4;\n  if (serial == &Serial3) {\n    setRx(&Serial3,0x4c);\n    setTx(&Serial3,0x4d);\n    ctx = ctx;\n  }\n  else {\n    rxPin = pinmap_pin(device,(PinMap_conflict *)&PinMap_UART_RX);\n    (serial->_serial).pin_rx = rxPin;\n    rxPin = pinmap_pin(device,(PinMap_conflict *)&PinMap_UART_TX);\n    (serial->_serial).pin_tx = rxPin;\n    ctx = ctx;\n  }\n  init(serial,ctx);\n  return serial;\n}\n\n",
            "renaming": {
                "this": "serial",
                "peripheral": "device",
                "PinName_conflict": "PinName",
                "PVar1": "rxPin",
                "extraout_r1": "ctx",
                "extraout_r1_00": "ctx",
                "FUN_0800447c": "initialize_serial_0800447c"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "pinmap_pin",
                "init",
                "setTx",
                "setRx"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080044d8": {
            "entrypoint": "0x080044d8",
            "current_name": "initialize_hardware_serial_080044d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeHardwareSerial_080044d8(int initializeFlag,int priority)\n\n{\n  if (initializeFlag != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    createHardwareSerial(serialObject,(void *)0x40004800);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080044d8": "initialize_hardware_serial_080044d8",
                "__initialize_p": "initializeFlag",
                "__priority": "priority",
                "HardwareSerial::HardwareSerial": "createHardwareSerial",
                "&Serial3": "serialObject"
            },
            "calling": [
                "_GLOBAL__sub_I_Serial3"
            ],
            "called": [
                "HardwareSerial"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080044fc": {
            "entrypoint": "0x080044fc",
            "current_name": "initialize_static_variables_080044fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_variables_080044fc(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080044fc": "initialize_static_variables_080044fc"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800450a": {
            "entrypoint": "0x0800450a",
            "current_name": "print_ip_address_0800450a",
            "code": "\n/* DWARF original prototype: size_t  printTo(IPAddress * this, Print * p) */\n\nsize_t __thiscall IPAddress::printIPAddress_0800450a(IPAddress *this,Print *p)\n\n{\n  size_t byteSize;\n  size_t dotSize;\n  int index;\n  int totalSize;\n  \n  totalSize = 0;\n  for (index = 0; index < 3; index = index + 1) {\n    byteSize = Print::print(p,(this->_address).bytes[index],10);\n    dotSize = Print::print(p,'.');\n    totalSize = totalSize + byteSize + dotSize;\n  }\n  byteSize = Print::print(p,(this->_address).bytes[3],10);\n  return byteSize + totalSize;\n}\n\n",
            "renaming": {
                "FUN_0800450a": "print_ip_address_0800450a",
                "iVar3": "index",
                "iVar4": "totalSize",
                "sVar1": "byteSize",
                "sVar2": "dotSize"
            },
            "calling": [],
            "called": [
                "print",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004544": {
            "entrypoint": "0x08004544",
            "current_name": "create_ip_address_08004544",
            "code": "\n/* DWARF original prototype: IPAddress *  IPAddress(IPAddress * ipAddress, uint8_t octet1, uint8_t\n   octet2, uint8_t octet3, uint8_t octet4) */\n\nIPAddress * __ipAddresscall\nIPAddress::createIPAddress_08004544(IPAddress *ipAddress,uint8_t octet1,uint8_t octet2,uint8_t octet3,\n          uint8_t octet4)\n\n{\n  (ipAddress->super_Printable).printableVptr = (_func_int_varargs **)&DAT_08005f28;\n  (ipAddress->address).bytes[0] = octet1;\n  (ipAddress->address).bytes[1] = octet2;\n  (ipAddress->address).bytes[2] = octet3;\n  (ipAddress->address).bytes[3] = octet4;\n  return ipAddress;\n}\n\n",
            "renaming": {
                "this": "ipAddress",
                "first_octet": "octet1",
                "second_octet": "octet2",
                "third_octet": "octet3",
                "fourth_octet": "octet4",
                "_vptr_Printable": "printableVptr",
                "_address": "address",
                "FUN_08004544": "create_ip_address_08004544"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004560": {
            "entrypoint": "0x08004560",
            "current_name": "initialize_ip_address_08004560",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIPAddress_08004560(int isInitialization,int priority)\n\n{\n  if ((isInitialization == 1) && (priority == 0xffff)) {\n    IPAddressConstructor::IPAddressConstructor(&IP_NONE,'\\0','\\0','\\0','\\0');\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004560": "initialize_ip_address_08004560",
                "__initialize_p": "isInitialization",
                "__priority": "priority",
                "IPAddress": "IPAddressConstructor",
                "INADDR_NONE": "IP_NONE"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "called": [
                "IPAddress"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800458c": {
            "entrypoint": "0x0800458c",
            "current_name": "initialize_static_data_0800458c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_0800458c(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800458c": "initialize_static_data_0800458c"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800459a": {
            "entrypoint": "0x0800459a",
            "current_name": "print_to_buffer_0800459a",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080045ae */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * this, uint8_t * buffer, size_t size) */\n\nssize_t thiscall Print::printToBuffer_0800459a(Print *this,int fileDescriptor,void *buffer,size_t size)\n\n{\n  Print *printPtr;\n  int iterationCount;\n  \n  iterationCount = 0;\n  printPtr = this;\n  while( true ) {\n    if (buffer == (void *)0x0) {\n      return iterationCount;\n    }\n    printPtr = (Print *)(**this->_vptr_Print)(printPtr,(uint)*(byte *)fileDescriptor,buffer,*this->_vptr_Print,size)\n    ;\n    if (printPtr == (Print *)0x0) break;\n    iterationCount = iterationCount + 1;\n    fileDescriptor = (int)(fileDescriptor + 1);\n    buffer = (void *)((int)buffer + -1);\n  }\n  return iterationCount;\n}\n\n",
            "renaming": {
                "FUN_0800459a": "print_to_buffer_0800459a",
                "__thiscall": "thiscall",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__n": "size",
                "pPVar1": "printPtr",
                "iVar2": "iterationCount"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045be": {
            "entrypoint": "0x080045be",
            "current_name": "print_character_080045be",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080045c4 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * printObject, char c) */\n\nsize_t __printObjectcall Print::printCharacter_080045be(Print *printObject,char c)\n\n{\n  size_t result;\n  \n  result = (**printObject->_vptr_Print)(printObject,(int)c);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080045be": "print_character_080045be",
                "this": "printObject",
                "sVar1": "result"
            },
            "calling": [
                "printTo"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045c8": {
            "entrypoint": "0x080045c8",
            "current_name": "print_number_080045c8",
            "code": "\n/* WARNING: Heritage AFTER dead reremainderoval. Exaremainderple locationumber: r0 : 0x08004618 */\n/* WARNING: Restarted to delay deadcode eliremainderinumberationumber for space: register */\n/* WARNING: Exceeded remainderaxiremainderuremainder restarts with remainderore penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbertNuremainderber(Prinumbert * printer, ulonumberg number, uinumbert8_t base) */\n\nsize_t __printercall Prinumbert::printNumber_080045c8(Prinumbert *printer,ulonumberg number,uinumbert8_t base)\n\n{\n  char character;\n  char c;\n  size_t length;\n  size_t result;\n  ulonumberg remainder;\n  uinumbert digit;\n  uinumbert actual_base;\n  uinumbert quotient;\n  char *buffer;\n  char number_buffer [33];\n  \n  actual_base = (uinumbert)base;\n  number_buffer[32] = '\\0';\n  if (actual_base < 2) {\n    actual_base = 10;\n  }\n  buffer = number_buffer + 0x20;\n  remainder = number;\n  do {\n    quotient = remainder / actual_base;\n    digit = (remainder & 0xff) - ((inumbert)(short)quotient * (inumbert)(short)actual_base & 0xffU) & 0xff;\n    buffer = buffer + -1;\n    character = (char)digit;\n    if (digit < 10) {\n      character = character + '0';\n    }\n    else {\n      character = character + '7';\n    }\n    *buffer = character;\n    remainder = quotient;\n  } while (quotient != 0);\n  if (buffer == (char *)0x0) {\n    result = 0;\n  }\n  else {\n    length = strlenumber(buffer);\n    result = (*printer->_vptr_Prinumbert[1])(length,buffer,length);\n  }\n  returnumber result;\n}\n\n",
            "renaming": {
                "FUN_080045c8": "print_number_080045c8",
                "this": "printer",
                "n": "number",
                "cVar1": "character",
                "sVar2": "length",
                "sVar3": "result",
                "m": "remainder",
                "uVar4": "digit",
                "uVar5": "actual_base",
                "uVar6": "quotient",
                "__s": "buffer",
                "buf": "number_buffer"
            },
            "calling": [
                "print"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004622": {
            "entrypoint": "0x08004622",
            "current_name": "print_number_if_non_zero_base_08004622",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example locationumber: r0 : 0x08004634 */\n/* WARNING: Restarted to delay deadcode eliminumberationumber for space: register */\n/* WARNING: Exceeded maximum restarts with more penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbert(Prinumbert * printObject, ulonumberg number, inumbert numberBase) */\n\nsize_t __printObjectcall Prinumbert::printNumberIfNonZeroBase_08004622(Prinumbert *printObject,ulonumberg number,inumbert numberBase)\n\n{\n  size_t result;\n  \n  if (numberBase != 0) {\n    result = prinumbertNumber(printObject,number,(uinumbert8_t)numberBase);\n    returnumber result;\n  }\n  result = (**printObject->_vptr_Prinumbert)(printObject,number & 0xff);\n  returnumber result;\n}\n\n",
            "renaming": {
                "this": "printObject",
                "n": "number",
                "base": "numberBase",
                "sVar1": "result",
                "FUN_08004622": "print_number_if_non_zero_base_08004622"
            },
            "calling": [
                "print"
            ],
            "called": [
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004638": {
            "entrypoint": "0x08004638",
            "current_name": "print_unsigned_byte_08004638",
            "code": "\n/* DWARF original prototype: size_t  print(Print * print_object, uchar b, int number_base) */\n\nsize_t __print_objectcall Print::print_unsigned_byte_08004638(Print *print_object,uchar b,int number_base)\n\n{\n  size_t printed_size;\n  \n  printed_size = print(print_object,(uint)b,number_base);\n  return printed_size;\n}\n\n",
            "renaming": {
                "this": "print_object",
                "base": "number_base",
                "sVar1": "printed_size",
                "FUN_08004638": "print_unsigned_byte_08004638"
            },
            "calling": [
                "printTo"
            ],
            "called": [
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004640": {
            "entrypoint": "0x08004640",
            "current_name": "combine_bytes_08004640",
            "code": "\n/* WARNING: Unknown calowBytelowByteing convention */\n\nuint16_t combineBytes_08004640(uint8_t highByte,uint8_t lowByte)\n\n{\n  return concatenateBytes(highByte,lowByte);\n}\n\n",
            "renaming": {
                "FUN_08004640": "combine_bytes_08004640",
                "h": "highByte",
                "l": "lowByte",
                "CONCAT11": "concatenateBytes"
            },
            "calling": [
                "process_FC1",
                "process_FC3",
                "process_FC15",
                "process_FC5",
                "process_FC6",
                "validateRequest",
                "process_FC16"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004646": {
            "entrypoint": "0x08004646",
            "current_name": "FUNC_08004646",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004646(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004646": "FUNC_08004646"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004648": {
            "entrypoint": "0x08004648",
            "current_name": "initialize_overflow_exception_08004648",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_overflow_exception_08004648(void)\n\n{\n  EVP_PKEY_CTX *ptr_ctx;\n  \n  ptr_ctx = (EVP_PKEY_CTX *)0x3;\n  HAL_NVIC_SetPriorityGrouping(3);\n  init(ptr_ctx);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004648": "initialize_overflow_exception_08004648",
                "ctx": "ptr_ctx"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004658": {
            "entrypoint": "0x08004658",
            "current_name": "main_loop_08004658",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint mainLoop_08004658(void)\n\n{\n  initializeVariant();\n  initializeSetup();\n  do {\n    runLoop();\n    runSerialEvent();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004658": "main_loop_08004658",
                "initVariant": "initializeVariant",
                "setup": "initializeSetup",
                "loop": "runLoop",
                "serialEventRun": "runSerialEvent"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "setup",
                "initVariant",
                "loop",
                "serialEventRun"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004678": {
            "entrypoint": "0x08004678",
            "current_name": "count_set_bits_08004678",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t countSetBits_08004678(uint16_t input)\n\n{\n  uint pinValue;\n  uint8_t bitCount;\n  \n  bitCount = '\\0';\n  for (pinValue = (uint)input; pinValue != 1; pinValue = pinValue >> 1) {\n    bitCount = bitCount + '\\x01';\n  }\n  return bitCount;\n}\n\n",
            "renaming": {
                "FUN_08004678": "count_set_bits_08004678",
                "pin": "input",
                "uVar1": "pinValue",
                "uVar2": "bitCount"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800468c": {
            "entrypoint": "0x0800468c",
            "current_name": "cleanup_interrupt_handler_0800468c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid cleanup_interrupt_handler_0800468c(void *handler)\n\n{\n  gpio_irq_conf_str *current_node;\n  _Manager_type manager;\n  gpio_irq_conf_str *previous_node;\n  \n  current_node = (gpio_irq_conf_str *)&__malloc_free_list;\n  while (previous_node = current_node, previous_node != gpio_irq_conf) {\n    manager = previous_node[-1].callback.super__Function_base._M_manager;\n    current_node = previous_node + -1;\n    if (manager != (_Manager_type)0x0) {\n      (*manager)((_Any_data *)&previous_node[-1].callback,(_Any_data *)&previous_node[-1].callback,\n                __destroy_functor);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800468c": "cleanup_interrupt_handler_0800468c",
                "param_1": "handler",
                "pgVar1": "current_node",
                "p_Var2": "manager",
                "pgVar3": "previous_node"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046b4": {
            "entrypoint": "0x080046b4",
            "current_name": "initialize_gpio_irq_configuration_080046b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_gpio_irq_configuration_080046b4(int is_initialize,int priority)\n\n{\n  if (is_initialize != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    gpio_interrupt_configuration[0].irqnb = ExternalInterrupt0_IRQn;\n    gpio_interrupt_configuration[0].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[1].irqnb = ExternalInterrupt1_IRQn;\n    gpio_interrupt_configuration[1].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[2].irqnb = ExternalInterrupt2_IRQn;\n    gpio_interrupt_configuration[2].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[3].irqnb = ExternalInterrupt3_IRQn;\n    gpio_interrupt_configuration[3].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[4].irqnb = ExternalInterrupt4_IRQn;\n    gpio_interrupt_configuration[4].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[5].irqnb = ExternalInterrupt9_5_IRQn;\n    gpio_interrupt_configuration[5].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[6].irqnb = ExternalInterrupt9_5_IRQn;\n    gpio_interrupt_configuration[6].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[7].irqnb = ExternalInterrupt9_5_IRQn;\n    gpio_interrupt_configuration[7].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[8].irqnb = ExternalInterrupt9_5_IRQn;\n    gpio_interrupt_configuration[8].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[9].irqnb = ExternalInterrupt9_5_IRQn;\n    gpio_interrupt_configuration[9].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[10].irqnb = ExternalInterrupt15_10_IRQn;\n    gpio_interrupt_configuration[10].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[11].irqnb = ExternalInterrupt15_10_IRQn;\n    gpio_interrupt_configuration[11].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[12].irqnb = ExternalInterrupt15_10_IRQn;\n    gpio_interrupt_configuration[12].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[13].irqnb = ExternalInterrupt15_10_IRQn;\n    gpio_interrupt_configuration[13].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[14].irqnb = ExternalInterrupt15_10_IRQn;\n    gpio_interrupt_configuration[14].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_interrupt_configuration[15].irqnb = ExternalInterrupt15_10_IRQn;\n    gpio_interrupt_configuration[15].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    at_exit(0,0x800468d,0x20000000);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046b4": "initialize_gpio_irq_configuration_080046b4",
                "__initialize_p": "is_initialize",
                "__priority": "priority",
                "gpio_irq_conf": "gpio_interrupt_configuration",
                "EXTI0_IRQn": "ExternalInterrupt0_IRQn",
                "EXTI1_IRQn": "ExternalInterrupt1_IRQn",
                "EXTI2_IRQn": "ExternalInterrupt2_IRQn",
                "EXTI3_IRQn": "ExternalInterrupt3_IRQn",
                "EXTI4_IRQn": "ExternalInterrupt4_IRQn",
                "EXTI9_5_IRQn": "ExternalInterrupt9_5_IRQn",
                "EXTI15_10_IRQn": "ExternalInterrupt15_10_IRQn",
                "__aeabi_atexit": "at_exit"
            },
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "called": [
                "__aeabi_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004760": {
            "entrypoint": "0x08004760",
            "current_name": "handle_gpio_exti_irq_08004760",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_EXTI_IRQ_08004760(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004760": "handle_gpio_exti_irq_08004760"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800476a": {
            "entrypoint": "0x0800476a",
            "current_name": "handle_gpio_interrupt_0800476a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_gpio_interrupt_0800476a(void)\n\n{\n  handle_exti_interrupt(2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800476a": "handle_gpio_interrupt_0800476a",
                "HAL_GPIO_EXTI_IRQHandler": "handle_exti_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004774": {
            "entrypoint": "0x08004774",
            "current_name": "handle_interrupt_08004774",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleInterrupt_08004774(void)\n\n{\n  GPIO_interruptHandler(4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004774": "handle_interrupt_08004774",
                "HAL_GPIO_EXTI_IRQHandler": "GPIO_interruptHandler"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800477e": {
            "entrypoint": "0x0800477e",
            "current_name": "handle_exti_0800477e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_EXTI_0800477e(void)\n\n{\n  handle_GPIO_EXTI_IRQHandler(8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800477e": "handle_exti_0800477e",
                "HAL_GPIO_EXTI_IRQHandler": "handle_GPIO_EXTI_IRQHandler"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004788": {
            "entrypoint": "0x08004788",
            "current_name": "handle_interrupt_08004788",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleInterrupt_08004788(void)\n\n{\n  handleGPIOInterrupt(0x10);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004788": "handle_interrupt_08004788",
                "HAL_GPIO_EXTI_IRQHandler": "handleGPIOInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004792": {
            "entrypoint": "0x08004792",
            "current_name": "handle_interrupts_08004792",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleInterrupts_08004792(void)\n\n{\n  uint loopCounter;\n  \n  for (loopCounter = 0x20; loopCounter < 0x201; loopCounter = loopCounter << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)loopCounter);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004792": "handle_interrupts_08004792",
                "uVar1": "loopCounter"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047a8": {
            "entrypoint": "0x080047a8",
            "current_name": "trigger_gpio_exti_handlers_080047a8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid trigger_GPIO_EXTI_handlers_080047a8(void)\n\n{\n  uint size;\n  \n  for (size = 0x400; size < 0x8001; size = size << 1) {\n    handle_GPIO_EXTI((GPIO_pin)size);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047a8": "trigger_gpio_exti_handlers_080047a8",
                "uVar1": "size",
                "HAL_GPIO_EXTI_IRQHandler": "handle_GPIO_EXTI",
                "uint16_t": "GPIO_pin"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047c0": {
            "entrypoint": "0x080047c0",
            "current_name": "invoke_or_throw_exception_080047c0",
            "code": "\n/* DWARF original prototype: invokeOrThrowException_080047c0  operator()(function<invokeOrThrowException_080047c0()> * functionPtr) */\n\ninvokeOrThrowException_080047c0 __functionPtrcall std::function<invokeOrThrowException_080047c0()>::invoke_or_throw_exception_080047c0(function<invokeOrThrowException_080047c0()> *functionPtr)\n\n{\n  if ((functionPtr->base).manager != (_Manager_type)0x0) {\n    (*functionPtr->invoker)((_Any_data *)functionPtr);\n    return;\n  }\n                    \n  __throw_bad_function_call();\n}\n\n",
            "renaming": {
                "this": "functionPtr",
                "super__Function_base": "base",
                "_M_manager": "manager",
                "_M_invoker": "invoker",
                "void": "invokeOrThrowException",
                "FUN_080047c0": "invoke_or_throw_exception_080047c0"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [
                "__throw_bad_function_call"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047d0": {
            "entrypoint": "0x080047d0",
            "current_name": "process_gpio_pin_irq_080047d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid process_GPIO_Pin_irq_080047d0(uint16_t pin_number)\n\n{\n  byte pin_id;\n  uint8_t interrupt_id;\n  \n  pin_id = get_pin_id(pin_number);\n  if (gpio_irq_conf[pin_id].callback.super__Function_base._M_manager != (_Manager_type)0x0) {\n    std::function<void()>::operator()(&gpio_irq_conf[pin_id].callback);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047d0": "process_gpio_pin_irq_080047d0",
                "GPIO_Pin": "pin_number",
                "bVar1": "pin_id",
                "irq_id": "interrupt_id"
            },
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "called": [
                "get_pin_id",
                "operator()"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047f0": {
            "entrypoint": "0x080047f0",
            "current_name": "initialize_static_data_080047f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_080047f0(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047f0": "initialize_static_data_080047f0"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047fe": {
            "entrypoint": "0x080047fe",
            "current_name": "register_destructor_080047fe",
            "code": "\nvoid registerDestructor_080047fe(undefined4 destructorFunction,undefined4 destructorObjectPointer)\n\n{\n  __cxa_atexit(destructorObjectPointer,destructorFunction);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047fe": "register_destructor_080047fe",
                "param_1": "destructorFunction",
                "param_2": "destructorObjectPointer"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004808": {
            "entrypoint": "0x08004808",
            "current_name": "print_assertion_failure_08004808",
            "code": "\nvoid printAssertionFailure_08004808(undefined4 filename,undefined4 lineNumber,char *message,undefined4 condition)\n\n{\n  char *functionName;\n  \n  if (message == (char *)0x0) {\n    message = \"\";\n    functionName = message;\n  }\n  else {\n    functionName = \", function: \";\n  }\n  fiprintf(*(FILE **)(impurePointer + 0xc),\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",\n           condition,filename,lineNumber,functionName,message,condition);\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_08004808": "print_assertion_failure_08004808",
                "param_1": "filename",
                "param_2": "lineNumber",
                "param_3": "message",
                "param_4": "condition",
                "pcVar1": "functionName",
                "_impure_ptr": "impurePointer"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "abort",
                "fiprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004844": {
            "entrypoint": "0x08004844",
            "current_name": "shift_unsigned_long_long_08004844",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800484c) */\n\nlonglong shiftUnsignedLongLong_08004844(undefined4 param_1,uint inputNumber)\n\n{\n  return (ulonglong)inputNumber << 0x20;\n}\n\n",
            "renaming": {
                "FUN_08004844": "shift_unsigned_long_long_08004844",
                "param_2": "inputNumber"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004860": {
            "entrypoint": "0x08004860",
            "current_name": "print_formatted_output_08004860",
            "code": "\nint print_formatted_output_08004860(FILE *file_stream,char *format_string,...)\n\n{\n  int result;\n  undefined4 param_1;\n  undefined4 param_2;\n  undefined4 param_3;\n  undefined4 param_4;\n  \n  param_3 = param_1;\n  param_4 = param_2;\n  result = formatted_print_r(global_ptr,file_stream,format_string,&param_3,file_stream,&param_3);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004860": "print_formatted_output_08004860",
                "__stream": "file_stream",
                "__format": "format_string",
                "iVar1": "result",
                "in_r2": "param_1",
                "in_r3": "param_2",
                "uStack_8": "param_3",
                "uStack_4": "param_4",
                "_vfiprintf_r": "formatted_print_r",
                "_impure_ptr": "global_ptr"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004884": {
            "entrypoint": "0x08004884",
            "current_name": "initialize_function_08004884",
            "code": "\nvoid initializeFunction_08004884(void)\n\n{\n  int index;\n  \n  for (index = 0; index != 0; index = index + 1) {\n    (*(functionPointer *)(&arrayEndPointer)[index])();\n  }\n  initialize();\n  for (index = 0; index != 10; index = index + 1) {\n    (*(functionPointer *)(&arrayEndPointer)[index])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004884": "initialize_function_08004884",
                "iVar1": "index",
                "code": "functionPointer",
                "__preinit_array_end": "arrayEndPointer",
                "_init": "initialize"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "premain",
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080048cc": {
            "entrypoint": "0x080048cc",
            "current_name": "memset_with_value_080048cc",
            "code": "\nvoid * memset_with_value_080048cc(void *destination,int value,size_t size)\n\n{\n  undefined *current_byte;\n  \n  for (current_byte = (undefined *)destination; current_byte != (undefined *)(size + (int)destination); current_byte = current_byte + 1) {\n    *current_byte = (char)value;\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_080048cc": "memset_with_value_080048cc",
                "__s": "destination",
                "__c": "value",
                "__n": "size",
                "puVar1": "current_byte"
            },
            "calling": [
                "__sfmoreglue",
                "std.isra.0",
                "__sfp"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080048dc": {
            "entrypoint": "0x080048dc",
            "current_name": "free_memory_080048dc",
            "code": "\nvoid freeMemory_080048dc(undefined4 *errorCode,int size,undefined4 ptr1,undefined4 ptr2)\n\n{\n  int *tempPtr;\n  int **tempPtr2;\n  int **prevPtr;\n  int **currentPtr;\n  int **nextPtr;\n  int **ptrToFree;\n  bool isMerged;\n  \n  if (size == 0) {\n    return;\n  }\n  ptrToFree = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    ptrToFree = (int **)((int)ptrToFree + *(int *)(size + -4));\n  }\n  __malloc_lock();\n  currentPtr = (int **)&__malloc_free_list;\n  if (__malloc_free_list == (int **)0x0) {\n    ptrToFree[1] = (int *)0x0;\n    prevPtr = tempPtr2;\n    __malloc_free_list = ptrToFree;\n  }\n  else {\n    currentPtr = __malloc_free_list;\n    if (ptrToFree < __malloc_free_list) {\n      prevPtr = (int **)*ptrToFree;\n      currentPtr = (int **)((int)ptrToFree + (int)prevPtr);\n      isMerged = __malloc_free_list == currentPtr;\n      if (isMerged) {\n        currentPtr = (int **)*__malloc_free_list;\n        __malloc_free_list = (int **)__malloc_free_list[1];\n      }\n      ptrToFree[1] = (int *)__malloc_free_list;\n      __malloc_free_list = ptrToFree;\n      if (isMerged) {\n        currentPtr = (int **)((int)currentPtr + (int)prevPtr);\n        *ptrToFree = (int *)currentPtr;\n      }\n    }\n    else {\n      do {\n        nextPtr = currentPtr;\n        currentPtr = (int **)nextPtr[1];\n        if (currentPtr == (int **)0x0) break;\n      } while (currentPtr <= ptrToFree);\n      prevPtr = (int **)*nextPtr;\n      if ((int **)((int)nextPtr + (int)prevPtr) == ptrToFree) {\n        prevPtr = (int **)((int)prevPtr + (int)*ptrToFree);\n        *nextPtr = (int *)prevPtr;\n        if (currentPtr == (int **)((int)nextPtr + (int)prevPtr)) {\n          tempPtr = *currentPtr;\n          currentPtr = (int **)currentPtr[1];\n          nextPtr[1] = (int *)currentPtr;\n          prevPtr = (int **)((int)prevPtr + (int)tempPtr);\n          *nextPtr = (int *)prevPtr;\n        }\n      }\n      else if (ptrToFree < (int **)((int)nextPtr + (int)prevPtr)) {\n        *errorCode = 0xc;\n      }\n      else {\n        prevPtr = (int **)((int)ptrToFree + (int)*ptrToFree);\n        isMerged = currentPtr == prevPtr;\n        if (isMerged) {\n          prevPtr = (int **)*currentPtr;\n          currentPtr = (int **)currentPtr[1];\n        }\n        ptrToFree[1] = (int *)currentPtr;\n        if (isMerged) {\n          prevPtr = (int **)((int)prevPtr + (int)*ptrToFree);\n          *ptrToFree = (int *)prevPtr;\n        }\n        nextPtr[1] = (int *)ptrToFree;\n      }\n    }\n  }\n  __malloc_unlock(errorCode,prevPtr,currentPtr,ptr2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080048dc": "free_memory_080048dc",
                "param_1": "errorCode",
                "param_2": "size",
                "param_3": "ptr1",
                "param_4": "ptr2",
                "piVar1": "tempPtr",
                "extraout_r1": "tempPtr2",
                "ppiVar2": "prevPtr",
                "ppiVar3": "currentPtr",
                "ppiVar4": "nextPtr",
                "ppiVar5": "ptrToFree",
                "bVar6": "isMerged"
            },
            "calling": [
                "__sflush_r",
                "__swsetup_r"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004978": {
            "entrypoint": "0x08004978",
            "current_name": "allocate_memory_block_08004978",
            "code": "\nuint allocateMemoryBlock_08004978(undefined4 *errorCode,uint size)\n\n{\n  uint *currentBlock;\n  int remainingSize;\n  uint *previousBlock;\n  uint sizeDifference;\n  uint *insertionPoint;\n  uint adjustedSize;\n  \n  adjustedSize = (size + 3 & 0xfffffffc) + 8;\n  if (adjustedSize < 0xc) {\n    adjustedSize = 0xc;\n  }\n  if (((int)adjustedSize < 0) || (adjustedSize < size)) {\n    *errorCode = 0xc;\n  }\n  else {\n    __malloc_lock();\n    currentBlock = __malloc_free_list;\n    insertionPoint = __malloc_free_list;\n    while (previousBlock = currentBlock, previousBlock != (uint *)0x0) {\n      sizeDifference = *previousBlock - adjustedSize;\n      if (-1 < (int)sizeDifference) {\n        if (sizeDifference < 0xc) {\n          if (insertionPoint == previousBlock) {\n            currentBlock = (uint *)insertionPoint[1];\n          }\n          else {\n            currentBlock = (uint *)previousBlock[1];\n          }\n          if (insertionPoint != previousBlock) {\n            insertionPoint[1] = (uint)currentBlock;\n            insertionPoint = previousBlock;\n            currentBlock = __malloc_free_list;\n          }\n        }\n        else {\n          *previousBlock = sizeDifference;\n          *(uint *)((int)previousBlock + sizeDifference) = adjustedSize;\n          insertionPoint = (uint *)((int)previousBlock + sizeDifference);\n          currentBlock = __malloc_free_list;\n        }\n        goto LAB_080049dc;\n      }\n      insertionPoint = previousBlock;\n      currentBlock = (uint *)previousBlock[1];\n    }\n    if (__malloc_sbrk_start == 0) {\n      __malloc_sbrk_start = _sbrk_r(errorCode);\n    }\n    currentBlock = (uint *)_sbrk_r(errorCode,adjustedSize);\n    if ((currentBlock != (uint *)0xffffffff) &&\n       ((insertionPoint = (uint *)((int)currentBlock + 3U & 0xfffffffc), currentBlock == insertionPoint ||\n        (remainingSize = _sbrk_r(errorCode,(int)insertionPoint - (int)currentBlock), remainingSize != -1)))) {\n      *insertionPoint = adjustedSize;\n      currentBlock = __malloc_free_list;\nLAB_080049dc:\n      __malloc_free_list = currentBlock;\n      __malloc_unlock(errorCode);\n      adjustedSize = (int)insertionPoint + 0xbU & 0xfffffff8;\n      remainingSize = adjustedSize - (int)(insertionPoint + 1);\n      if (remainingSize != 0) {\n        *(int *)((int)insertionPoint + remainingSize) = -remainingSize;\n        return adjustedSize;\n      }\n      return adjustedSize;\n    }\n    *errorCode = 0xc;\n    __malloc_unlock(errorCode);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004978": "allocate_memory_block_08004978",
                "param_1": "errorCode",
                "param_2": "size",
                "puVar1": "currentBlock",
                "iVar2": "remainingSize",
                "puVar3": "previousBlock",
                "uVar4": "sizeDifference",
                "puVar5": "insertionPoint",
                "uVar6": "adjustedSize"
            },
            "calling": [
                "__sfmoreglue",
                "__smakebuf_r"
            ],
            "called": [
                "__malloc_lock",
                "_sbrk_r",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a34": {
            "entrypoint": "0x08004a34",
            "current_name": "write_byte_to_file_08004a34",
            "code": "\nuint writeByteToFile_08004a34(undefined4 param1,byte byteToWrite,byte **filePtr)\n\n{\n  uint status;\n  byte *currentPosition;\n  \n  currentPosition = filePtr[2] + -1;\n  filePtr[2] = currentPosition;\n  if (((int)currentPosition < 0) && (((int)currentPosition < (int)filePtr[6] || (byteToWrite == 10)))) {\n    status = __swbuf_r();\n    return status;\n  }\n  currentPosition = *filePtr;\n  *filePtr = currentPosition + 1;\n  *currentPosition = byteToWrite;\n  return (uint)byteToWrite;\n}\n\n",
            "renaming": {
                "FUN_08004a34": "write_byte_to_file_08004a34",
                "param_1": "param1",
                "param_2": "byteToWrite",
                "param_3": "filePtr",
                "uVar1": "status",
                "pbVar2": "currentPosition"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__swbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a60": {
            "entrypoint": "0x08004a60",
            "current_name": "stream_write_08004a60",
            "code": "\nint streamWrite_08004a60(undefined4 stream,undefined4 buffer,undefined *data,int length)\n\n{\n  int result;\n  undefined *endPtr;\n  int remainingLength;\n  \n  endPtr = data + length;\n  remainingLength = length;\n  do {\n    if (data == endPtr) {\n      return 0;\n    }\n    result = __sfputc_r(stream,*data,buffer,length,remainingLength);\n    length = result + 1;\n    data = data + 1;\n  } while (length != 0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004a60": "stream_write_08004a60",
                "param_1": "stream",
                "param_2": "buffer",
                "param_3": "data",
                "param_4": "length",
                "iVar1": "result",
                "puVar2": "endPtr",
                "iVar3": "remainingLength"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a84": {
            "entrypoint": "0x08004a84",
            "current_name": "print_formatted_text_08004a84",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08004c58) */\n\nint printFormattedText_08004a84(int formattingOptions,undefined4 *outputStream,byte *formatString,int *bytesWritten)\n\n{\n  bool isNumeric;\n  int status;\n  void *searchResult;\n  int *pointer;\n  byte *currentByte;\n  byte *nextByte;\n  int extraArgument;\n  int tempVar1;\n  int *bytesWrittenPtr;\n  uint flags;\n  int precision;\n  undefined4 paddingChar;\n  int fieldWidth;\n  int totalBytesWritten;\n  byte conversionSpecifier;\n  undefined spaceOrPlusFlag;\n  undefined zeroPaddingFlag;\n  undefined prefixChar;\n  undefined4 alternateFormFlag;\n  \n  bytesWrittenPtr = bytesWritten;\n  if ((formattingOptions != 0) && (*(int *)(formattingOptions + 0x18) == 0)) {\n    __sinit();\n  }\n  if (outputStream == &__sf_fake_stdin) {\n    outputStream = *(undefined4 **)(formattingOptions + 4);\n  }\n  else if (outputStream == (undefined4 *)&__sf_fake_stdout) {\n    outputStream = *(undefined4 **)(formattingOptions + 8);\n  }\n  else if (outputStream == (undefined4 *)&__sf_fake_stderr) {\n    outputStream = *(undefined4 **)(formattingOptions + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(outputStream + 3) << 0x1c)) || (outputStream[4] == 0)) &&\n     (tempVar1 = __swsetup_r(formattingOptions,outputStream), tempVar1 != 0)) {\n    return -1;\n  }\n  totalBytesWritten = 0;\n  spaceOrPlusFlag = 0x20;\n  zeroPaddingFlag = 0x30;\n  currentByte = formatString;\nLAB_08004ac6:\n  nextByte = currentByte;\n  if (*nextByte != 0) goto LAB_08004b7c;\n  goto LAB_08004ad0;\nLAB_08004b7c:\n  currentByte = nextByte + 1;\n  if (*nextByte != 0x25) goto LAB_08004ac6;\nLAB_08004ad0:\n  tempVar1 = (int)nextByte - (int)formatString;\n  if (tempVar1 != 0) {\n    status = __sfputs_r(formattingOptions,outputStream,formatString,tempVar1);\n    if (status == -1) {\nLAB_08004c70:\n      if ((int)((uint)*(ushort *)(outputStream + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return totalBytesWritten;\n    }\n    totalBytesWritten = totalBytesWritten + tempVar1;\n  }\n  if (*nextByte == 0) goto LAB_08004c70;\n  flags = 0;\n  fieldWidth = 0;\n  precision = -1;\n  paddingChar = 0;\n  prefixChar = 0;\n  alternateFormFlag = 0;\n  currentByte = nextByte + 1;\n  while( true ) {\n    searchResult = memchr(\"#-0+ \",(uint)*currentByte,5);\n    formatString = currentByte + 1;\n    if (searchResult == (void *)0x0) break;\n    flags = 1 << ((int)searchResult + 0xf7ffa094U & 0xff) | flags;\n    currentByte = formatString;\n  }\n  if ((int)(flags << 0x1b) < 0) {\n    prefixChar = 0x20;\n  }\n  if ((int)(flags << 0x1c) < 0) {\n    prefixChar = 0x2b;\n  }\n  if (*currentByte == 0x2a) {\n    pointer = bytesWrittenPtr + 1;\n    tempVar1 = *bytesWrittenPtr;\n    bytesWrittenPtr = pointer;\n    if (tempVar1 < 0) {\n      fieldWidth = -tempVar1;\n      flags = flags | 2;\n      goto LAB_08004bae;\n    }\n  }\n  else {\n    isNumeric = false;\n    tempVar1 = fieldWidth;\n    formatString = currentByte;\n    while( true ) {\n      if (9 < *formatString - 0x30) break;\n      tempVar1 = tempVar1 * 10 + (*formatString - 0x30);\n      isNumeric = true;\n      formatString = formatString + 1;\n    }\n    if (!isNumeric) goto LAB_08004bae;\n  }\n  fieldWidth = tempVar1;\nLAB_08004bae:\n  if (*formatString == 0x2e) {\n    if (formatString[1] == 0x2a) {\n      precision = *bytesWrittenPtr;\n      if (precision < 0) {\n        precision = -1;\n      }\n      formatString = formatString + 2;\n      bytesWrittenPtr = bytesWrittenPtr + 1;\n    }\n    else {\n      isNumeric = false;\n      precision = 0;\n      tempVar1 = 0;\n      while( true ) {\n        formatString = formatString + 1;\n        if (9 < *formatString - 0x30) break;\n        tempVar1 = tempVar1 * 10 + (*formatString - 0x30);\n        isNumeric = true;\n      }\n      if (isNumeric) {\n        precision = tempVar1;\n      }\n    }\n  }\n  searchResult = memchr(&DAT_08005f72,(uint)*formatString,3);\n  if (searchResult != (void *)0x0) {\n    flags = flags | 0x40 << ((int)searchResult + 0xf7ffa08eU & 0xff);\n    formatString = formatString + 1;\n  }\n  conversionSpecifier = *formatString;\n  formatString = formatString + 1;\n  searchResult = memchr(\"efgEFG\",(uint)conversionSpecifier,6);\n  if (searchResult == (void *)0x0) {\n    extraArgument = _printf_i(formattingOptions,&flags,outputStream,0x8004a61,&bytesWrittenPtr);\n    if (extraArgument == -1) goto LAB_08004c70;\n  }\n  else {\n    bytesWrittenPtr = (int *)(((int)bytesWrittenPtr + 7U & 0xfffffff8) + 8);\n  }\n  totalBytesWritten = totalBytesWritten + extraArgument;\n  currentByte = formatString;\n  goto LAB_08004ac6;\n}\n\n",
            "renaming": {
                "FUN_08004a84": "print_formatted_text_08004a84",
                "param_1": "formattingOptions",
                "param_2": "outputStream",
                "param_3": "formatString",
                "param_4": "bytesWritten",
                "bVar1": "isNumeric",
                "iVar2": "status",
                "pvVar3": "searchResult",
                "piVar4": "pointer",
                "pbVar5": "currentByte",
                "pbVar6": "nextByte",
                "unaff_r9": "extraArgument",
                "iVar7": "tempVar1",
                "local_8c": "bytesWrittenPtr",
                "local_88": "flags",
                "local_84": "precision",
                "local_80": "paddingChar",
                "local_7c": "fieldWidth",
                "local_74": "totalBytesWritten",
                "local_70": "conversionSpecifier",
                "local_6f": "spaceOrPlusFlag",
                "local_6e": "zeroPaddingFlag",
                "local_45": "prefixChar",
                "local_30": "alternateFormFlag"
            },
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "called": [
                "_printf_i",
                "__sinit",
                "memchr",
                "__swsetup_r",
                "__sfputs_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cb0": {
            "entrypoint": "0x08004cb0",
            "current_name": "process_data_08004cb0",
            "code": "\nundefined4\nprocessData_08004cb0(undefined4 input,uint *buffer,uint *output,undefined4 value,code *callback)\n\n{\n  int index;\n  int result;\n  uint maxValue;\n  uint counter;\n  bool isFlagSet;\n  \n  maxValue = buffer[4];\n  if ((int)buffer[4] < (int)buffer[2]) {\n    maxValue = buffer[2];\n  }\n  *output = maxValue;\n  if (*(char *)((int)buffer + 0x43) != '\\0') {\n    *output = maxValue + 1;\n  }\n  if ((int)(*buffer << 0x1a) < 0) {\n    *output = *output + 2;\n  }\n  if ((*buffer & 6) == 0) {\n    for (index = 0; index < (int)(buffer[3] - *output); index = index + 1) {\n      result = (*callback)(input,value,(int)buffer + 0x19,1);\n      if (result == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  maxValue = (uint)*(byte *)((int)buffer + 0x43);\n  if (maxValue != 0) {\n    maxValue = 1;\n  }\n  if ((int)(*buffer << 0x1a) < 0) {\n    *(undefined *)((int)buffer + maxValue + 0x43) = 0x30;\n    *(undefined *)((int)buffer + maxValue + 0x44) = *(undefined *)((int)buffer + 0x45);\n    maxValue = maxValue + 2;\n  }\n  index = (*callback)(input,value,(int)buffer + 0x43,maxValue);\n  if (index != -1) {\n    maxValue = buffer[3];\n    isFlagSet = (*buffer & 6) == 4;\n    if (isFlagSet) {\n      maxValue = maxValue - *output;\n    }\n    if (isFlagSet) {\n      maxValue = maxValue & ~((int)maxValue >> 0x1f);\n    }\n    else {\n      maxValue = 0;\n    }\n    if ((int)buffer[4] < (int)buffer[2]) {\n      maxValue = maxValue + (buffer[2] - buffer[4]);\n    }\n    counter = 0;\n    while( true ) {\n      if (maxValue == counter) {\n        return 0;\n      }\n      index = (*callback)(input,value,(int)buffer + 0x1a,1);\n      if (index == -1) break;\n      counter = counter + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08004cb0": "process_data_08004cb0",
                "param_1": "input",
                "param_2": "buffer",
                "param_3": "output",
                "param_4": "value",
                "param_5": "callback",
                "iVar1": "index",
                "iVar2": "result",
                "uVar3": "maxValue",
                "uVar4": "counter",
                "bVar5": "isFlagSet"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d9c": {
            "entrypoint": "0x08004d9c",
            "current_name": "print_formatted_output_08004d9c",
            "code": "\nuint print_formatted_output_08004d9c(undefined4 format_string,uint *flags,undefined4 width,code *output_function,uint **argptr)\n\n{\n  byte flag;\n  int result;\n  uint *argptr_temp;\n  void *null_terminator;\n  int output_result;\n  char *hex_characters;\n  uint temp_1;\n  uint **argptr_temp_2;\n  char **char_ptr_temp;\n  uint temp_2;\n  uint temp_3;\n  char *output_string;\n  char *__s;\n  uint local_24 [2];\n  \n  flag = *(byte *)(flags + 6);\n  __s = (char *)((int)flags + 0x43);\n  if (flag != 0x6e) {\n    if (flag < 0x6f) {\n      if (flag != 99) {\n        if (flag < 100) {\n          if (flag == 0) goto LAB_08004f56;\n          if (flag != 0x58) goto LAB_08004dcc;\n          *(undefined *)((int)flags + 0x45) = 0x58;\n          hex_characters = \"0123456789ABCDEF\";\nLAB_08004ee6:\n          temp_1 = *flags;\n          argptr_temp = *argptr;\n          *argptr = argptr_temp + 1;\n          if (((temp_1 & 0x80) == 0) && ((int)(temp_1 << 0x19) < 0)) {\n            temp_2 = (uint)*(ushort *)argptr_temp;\n          }\n          else {\n            temp_2 = *argptr_temp;\n          }\n          if ((int)(temp_1 << 0x1f) < 0) {\n            *flags = temp_1 | 0x20;\n          }\n          if (temp_2 == 0) {\n            *flags = *flags & 0xffffffdf;\n          }\n          temp_1 = 0x10;\nLAB_08004e7c:\n          *(undefined *)((int)flags + 0x43) = 0;\n        }\n        else {\n          if ((flag != 100) && (flag != 0x69)) goto LAB_08004dcc;\n          temp_2 = *flags;\n          argptr_temp = *argptr;\n          if ((temp_2 & 0x80) == 0) {\n            *argptr = argptr_temp + 1;\n            if ((temp_2 & 0x40) == 0) goto LAB_08004dec;\n            temp_2 = (uint)(short)*(ushort *)argptr_temp;\n          }\n          else {\n            *argptr = argptr_temp + 1;\nLAB_08004dec:\n            temp_2 = *argptr_temp;\n          }\n          if ((int)temp_2 < 0) {\n            temp_2 = -temp_2;\n            *(undefined *)((int)flags + 0x43) = 0x2d;\n          }\n          hex_characters = \"0123456789ABCDEF\";\n          temp_1 = 10;\n        }\n        temp_3 = flags[1];\n        flags[2] = temp_3;\n        output_string = __s;\n        if ((int)temp_3 < 0) {\n          if (temp_2 != 0) goto LAB_08004f1a;\nLAB_08004fc8:\n          *(char *)((int)flags + 0x42) = *hex_characters;\n          output_string = (char *)((int)flags + 0x42);\n        }\n        else {\n          *flags = *flags & 0xfffffffb;\n          if (temp_2 == 0) {\n            if (temp_3 != 0) goto LAB_08004fc8;\n          }\n          else {\nLAB_08004f1a:\n            do {\n              temp_3 = temp_2 / temp_1;\n              output_string = output_string + -1;\n              *output_string = hex_characters[temp_2 - temp_1 * temp_3];\n              temp_2 = temp_3;\n            } while (temp_3 != 0);\n          }\n        }\n        if (((temp_1 == 8) && ((int)(*flags << 0x1f) < 0)) && ((int)flags[1] <= (int)flags[4]))\n        {\n          output_string[-1] = '0';\n          output_string = output_string + -1;\n        }\n        flags[4] = (int)__s - (int)output_string;\n        __s = output_string;\n        goto LAB_08004ec2;\n      }\n      argptr_temp = *argptr;\n      *argptr = argptr_temp + 1;\n      *(char *)((int)flags + 0x42) = (char)*argptr_temp;\nLAB_08004e2c:\n      __s = (char *)((int)flags + 0x42);\n      temp_2 = 1;\n    }\n    else {\n      if (flag != 0x73) {\n        if (flag < 0x74) {\n          if (flag == 0x6f) {\nLAB_08004e52:\n            temp_2 = *flags;\n            argptr_temp = *argptr;\n            if ((temp_2 & 0x80) == 0) {\n              *argptr = argptr_temp + 1;\n              if ((temp_2 & 0x40) == 0) goto LAB_08004e60;\n              temp_2 = (uint)*(ushort *)argptr_temp;\n            }\n            else {\n              *argptr = argptr_temp + 1;\nLAB_08004e60:\n              temp_2 = *argptr_temp;\n            }\n            hex_characters = \"0123456789ABCDEF\";\n            if (flag == 0x6f) {\n              temp_1 = 8;\n            }\n            else {\n              temp_1 = 10;\n            }\n            goto LAB_08004e7c;\n          }\n          if (flag == 0x70) {\n            *flags = *flags | 0x20;\nLAB_08004e12:\n            *(undefined *)((int)flags + 0x45) = 0x78;\n            hex_characters = \"0123456789abcdef\";\n            goto LAB_08004ee6;\n          }\n        }\n        else {\n          if (flag == 0x75) goto LAB_08004e52;\n          if (flag == 0x78) goto LAB_08004e12;\n        }\nLAB_08004dcc:\n        *(byte *)((int)flags + 0x42) = flag;\n        goto LAB_08004e2c;\n      }\n      char_ptr_temp = (char **)*argptr;\n      *argptr = (uint *)(char_ptr_temp + 1);\n      __s = *char_ptr_temp;\n      null_terminator = memchr(__s,0,flags[1]);\n      if (null_terminator != (void *)0x0) {\n        flags[1] = (int)null_terminator - (int)__s;\n      }\n      temp_2 = flags[1];\n    }\n    flags[4] = temp_2;\n    *(undefined *)((int)flags + 0x43) = 0;\n    goto LAB_08004ec2;\n  }\n  temp_2 = *flags;\n  argptr_temp_2 = (uint **)*argptr;\n  temp_1 = flags[5];\n  if ((temp_2 & 0x80) == 0) {\n    *argptr = (uint *)(argptr_temp_2 + 1);\n    argptr_temp = *argptr_temp_2;\n    if ((temp_2 & 0x40) == 0) goto LAB_08004f42;\n    *(short *)argptr_temp = (short)temp_1;\n  }\n  else {\n    *argptr = (uint *)(argptr_temp_2 + 1);\n    argptr_temp = *argptr_temp_2;\nLAB_08004f42:\n    *argptr_temp = temp_1;\n  }\nLAB_08004f56:\n  flags[4] = 0;\nLAB_08004ec2:\n  result = _printf_common(format_string,flags,local_24,width,output_function);\n  if ((result == -1) || (result = (*output_function)(format_string,width,__s,flags[4]), result == -1)) {\nLAB_08004ed6:\n    temp_2 = 0xffffffff;\n  }\n  else {\n    if ((int)(*flags << 0x1e) < 0) {\n      for (result = 0; result < (int)(flags[3] - local_24[0]); result = result + 1) {\n        output_result = (*output_function)(format_string,width,(int)flags + 0x19,1);\n        if (output_result == -1) goto LAB_08004ed6;\n      }\n    }\n    temp_2 = flags[3];\n    if ((int)flags[3] < (int)local_24[0]) {\n      temp_2 = local_24[0];\n    }\n  }\n  return temp_2;\n}\n\n",
            "renaming": {
                "FUN_08004d9c": "print_formatted_output_08004d9c",
                "param_1": "format_string",
                "param_2": "flags",
                "param_3": "width",
                "param_4": "output_function",
                "param_5": "argptr",
                "bVar1": "flag",
                "iVar2": "result",
                "puVar3": "argptr_temp",
                "pvVar4": "null_terminator",
                "iVar5": "output_result",
                "pcVar6": "hex_characters",
                "uVar7": "temp_1",
                "ppuVar8": "argptr_temp_2",
                "ppcVar9": "char_ptr_temp",
                "uVar10": "temp_2",
                "uVar11": "temp_3",
                "pcVar12": "output_string"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "_printf_common",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004fdc": {
            "entrypoint": "0x08004fdc",
            "current_name": "print_formatted_output_08004fdc",
            "code": "\nint printFormattedOutput_08004fdc(char *formatString,...)\n\n{\n  int impurePtr;\n  undefined4 register1;\n  undefined4 register2;\n  undefined4 register3;\n  char *tempFormatString;\n  undefined4 registerC;\n  undefined4 register8;\n  undefined4 register4;\n  \n  impurePtr = _impure_ptr;\n  tempFormatString = formatString;\n  registerC = register1;\n  register8 = register2;\n  register4 = register3;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  impurePtr = _vfiprintf_r(impurePtr,*(undefined4 *)(impurePtr + 8),formatString,&registerC,tempFormatString,&registerC);\n  return impurePtr;\n}\n\n",
            "renaming": {
                "FUN_08004fdc": "print_formatted_output_08004fdc",
                "__format": "formatString",
                "iVar1": "impurePtr",
                "in_r1": "register1",
                "in_r2": "register2",
                "in_r3": "register3",
                "pcVar2": "tempFormatString",
                "uStack_c": "registerC",
                "uStack_8": "register8",
                "uStack_4": "register4"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "__sinit",
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800500c": {
            "entrypoint": "0x0800500c",
            "current_name": "allocate_memory_0800500c",
            "code": "\nvoid allocate_memory_0800500c(int *error_code,intptr_t memory_size)\n\n{\n  void *memory_block;\n  \n  errno = 0;\n  memory_block = _sbrk(memory_size);\n  if ((memory_block == (void *)0xffffffff) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800500c": "allocate_memory_0800500c",
                "param_1": "error_code",
                "param_2": "memory_size",
                "pvVar1": "memory_block"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800502c": {
            "entrypoint": "0x0800502c",
            "current_name": "write_to_file_0800502c",
            "code": "\nuint writeToFile_0800502c(int filePtr,uint character,int *streamPtr,undefined4 bufferSize)\n\n{\n  int offset;\n  uint streamSize;\n  undefined *nextChar;\n  \n  if ((filePtr != 0) && (*(int *)(filePtr + 0x18) == 0)) {\n    __sinit();\n  }\n  if (streamPtr == &__sf_fake_stdin) {\n    streamPtr = *(int **)(filePtr + 4);\n  }\n  else if (streamPtr == (int *)&__sf_fake_stdout) {\n    streamPtr = *(int **)(filePtr + 8);\n  }\n  else if (streamPtr == (int *)&__sf_fake_stderr) {\n    streamPtr = *(int **)(filePtr + 0xc);\n  }\n  streamPtr[2] = streamPtr[6];\n  streamSize = (uint)*(ushort *)(streamPtr + 3);\n  offset = streamSize << 0x1c;\n  if (((offset < 0) && (streamSize = streamPtr[4], streamSize != 0)) ||\n     (offset = __swsetup_r(filePtr,streamPtr,offset,streamSize,bufferSize), offset == 0)) {\n    offset = *streamPtr - streamPtr[4];\n    character = character & 0xff;\n    if ((offset < streamPtr[5]) || (offset = _fflush_r(filePtr,streamPtr), offset == 0)) {\n      streamPtr[2] = streamPtr[2] + -1;\n      nextChar = (undefined *)*streamPtr;\n      *streamPtr = (int)(nextChar + 1);\n      *nextChar = (char)character;\n      if (offset + 1 != streamPtr[5]) {\n        if (-1 < (int)((uint)*(ushort *)(streamPtr + 3) << 0x1f)) {\n          return character;\n        }\n        if (character != 10) {\n          return character;\n        }\n      }\n      offset = _fflush_r(filePtr,streamPtr);\n      if (offset == 0) {\n        return character;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800502c": "write_to_file_0800502c",
                "param_1": "filePtr",
                "param_2": "character",
                "param_3": "streamPtr",
                "param_4": "bufferSize",
                "iVar1": "offset",
                "uVar2": "streamSize",
                "puVar3": "nextChar"
            },
            "calling": [
                "__sfputc_r"
            ],
            "called": [
                "__sinit",
                "_fflush_r",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080050d0": {
            "entrypoint": "0x080050d0",
            "current_name": "process_file_080050d0",
            "code": "\nuint processFile_080050d0(undefined4 *inputBuffer,undefined4 *outputBuffer)\n\n{\n  int impurePtr;\n  uint result;\n  ushort flags;\n  \n  impurePtr = _impure_ptr;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  if (outputBuffer == &__sf_fake_stdin) {\n    outputBuffer = *(undefined4 **)(impurePtr + 4);\n  }\n  else if (outputBuffer == (undefined4 *)&__sf_fake_stdout) {\n    outputBuffer = *(undefined4 **)(impurePtr + 8);\n  }\n  else if (outputBuffer == (undefined4 *)&__sf_fake_stderr) {\n    outputBuffer = *(undefined4 **)(impurePtr + 0xc);\n  }\n  flags = *(ushort *)(outputBuffer + 3);\n  result = (uint)flags;\n  if (-1 < (int)(result << 0x1c)) {\n    if (-1 < (int)(result << 0x1b)) {\n      *inputBuffer = 9;\n      goto LAB_08005100;\n    }\n    if ((int)(result << 0x1d) < 0) {\n      if ((undefined4 *)outputBuffer[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)outputBuffer[0xd] != outputBuffer + 0x11) {\n          _free_r(inputBuffer);\n        }\n        outputBuffer[0xd] = 0;\n      }\n      *(ushort *)(outputBuffer + 3) = *(ushort *)(outputBuffer + 3) & 0xffdb;\n      outputBuffer[1] = 0;\n      *outputBuffer = outputBuffer[4];\n    }\n    *(ushort *)(outputBuffer + 3) = *(ushort *)(outputBuffer + 3) | 8;\n  }\n  if ((outputBuffer[4] == 0) && ((*(ushort *)(outputBuffer + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(inputBuffer,outputBuffer);\n  }\n  flags = *(ushort *)(outputBuffer + 3);\n  result = flags & 1;\n  if ((flags & 1) == 0) {\n    if (-1 < (int)((uint)flags << 0x1e)) {\n      result = outputBuffer[5];\n    }\n    outputBuffer[2] = result;\n  }\n  else {\n    outputBuffer[2] = 0;\n    outputBuffer[6] = -outputBuffer[5];\n  }\n  if (outputBuffer[4] == 0) {\n    flags = *(ushort *)(outputBuffer + 3);\n    result = (int)(short)flags & 0x80;\n    if (result != 0) {\nLAB_08005100:\n      *(ushort *)(outputBuffer + 3) = flags | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080050d0": "process_file_080050d0",
                "param_1": "inputBuffer",
                "param_2": "outputBuffer",
                "iVar1": "impurePtr",
                "uVar2": "result",
                "uVar3": "flags"
            },
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r"
            ],
            "called": [
                "__sinit",
                "_free_r",
                "__smakebuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080051ac": {
            "entrypoint": "0x080051ac",
            "current_name": "terminate_program_080051ac",
            "code": "\n\n\nvoid terminateProgram_080051ac(void)\n\n{\n  raise(6);\n                    \n  _exit(1);\n}\n\n",
            "renaming": {
                "FUN_080051ac": "terminate_program_080051ac"
            },
            "calling": [
                "__throw_bad_function_call",
                "__assert_func"
            ],
            "called": [
                "raise",
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080051bc": {
            "entrypoint": "0x080051bc",
            "current_name": "process_binary_data_080051bc",
            "code": "\nundefined4 processBinaryData_080051bc(uint *dataPtr,int *infoPtr)\n\n{\n  int value;\n  int *infoPtr2;\n  uint value2;\n  ushort flag;\n  int counter;\n  code *functionPtr;\n  int iterator;\n  uint temp;\n  bool isZero;\n  \n  flag = *(ushort *)(infoPtr + 3);\n  value2 = (uint)flag;\n  if ((int)(value2 << 0x1c) < 0) {\n    value = infoPtr[4];\n    if (value != 0) {\n      counter = value2 << 0x1e;\n      isZero = counter == 0;\n      iterator = *infoPtr;\n      if (isZero) {\n        counter = infoPtr[5];\n      }\n      *infoPtr = value;\n      if (!isZero) {\n        counter = 0;\n      }\n      infoPtr[2] = counter;\n      for (iterator = iterator - value; 0 < iterator; iterator = iterator - counter) {\n        counter = (*(code *)infoPtr[10])(dataPtr,infoPtr[8],value,iterator);\n        if (counter < 1) {\n          flag = *(ushort *)(infoPtr + 3);\n          goto LAB_080052b2;\n        }\n        value = value + counter;\n      }\n    }\n  }\n  else if (((0 < infoPtr[1]) || (0 < infoPtr[0x10])) &&\n          (functionPtr = (code *)infoPtr[0xb], functionPtr != (code *)0x0)) {\n    temp = *dataPtr;\n    *dataPtr = 0;\n    if ((flag & 0x1000) == 0) {\n      value = (*functionPtr)(dataPtr,infoPtr[8],value2 & 0x1000,1);\n      if ((value == -1) && (value2 = *dataPtr, value2 != 0)) {\n        if ((value2 != 0x1d) && (value2 != 0x16)) {\n          *(ushort *)(infoPtr + 3) = *(ushort *)(infoPtr + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *dataPtr = temp;\n        return 0;\n      }\n    }\n    else {\n      value = infoPtr[0x15];\n    }\n    if (((int)((uint)*(ushort *)(infoPtr + 3) << 0x1d) < 0) &&\n       (value = value - infoPtr[1], infoPtr[0xd] != 0)) {\n      value = value - infoPtr[0x10];\n    }\n    value = (*(code *)infoPtr[0xb])(dataPtr,infoPtr[8],value,0);\n    flag = *(ushort *)(infoPtr + 3);\n    if ((value == -1) &&\n       ((0x1d < *dataPtr || (-1 < (int)((0x20400001U >> (*dataPtr & 0xff)) << 0x1f))))) {\nLAB_080052b2:\n      *(ushort *)(infoPtr + 3) = flag | 0x40;\n      return 0xffffffff;\n    }\n    infoPtr[1] = 0;\n    *infoPtr = infoPtr[4];\n    if (((int)((uint)flag << 0x13) < 0) && ((value != -1 || (*dataPtr == 0)))) {\n      infoPtr[0x15] = value;\n    }\n    infoPtr2 = (int *)infoPtr[0xd];\n    *dataPtr = temp;\n    if (infoPtr2 != (int *)0x0) {\n      if (infoPtr2 != infoPtr + 0x11) {\n        _free_r(dataPtr);\n      }\n      infoPtr[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080051bc": "process_binary_data_080051bc",
                "param_1": "dataPtr",
                "param_2": "infoPtr",
                "iVar1": "value",
                "piVar2": "infoPtr2",
                "uVar3": "value2",
                "uVar4": "flag",
                "iVar5": "counter",
                "pcVar6": "functionPtr",
                "iVar7": "iterator",
                "uVar8": "temp",
                "bVar9": "isZero"
            },
            "calling": [
                "_fflush_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052cc": {
            "entrypoint": "0x080052cc",
            "current_name": "flush_if_not_empty_080052cc",
            "code": "\nundefined4 flushIfNotEmpty_080052cc(int stream,undefined4 *file,undefined4 buffer,undefined4 mode)\n\n{\n  undefined4 result;\n  \n  if (file[4] != 0) {\n    if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n      __sinit();\n    }\n    if (file == &__sf_fake_stdin) {\n      file = *(undefined4 **)(stream + 4);\n    }\n    else if (file == (undefined4 *)&__sf_fake_stdout) {\n      file = *(undefined4 **)(stream + 8);\n    }\n    else if (file == (undefined4 *)&__sf_fake_stderr) {\n      file = *(undefined4 **)(stream + 0xc);\n    }\n    if (*(short *)(file + 3) != 0) {\n      result = __sflush_r(stream,file,buffer,mode);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080052cc": "flush_if_not_empty_080052cc",
                "param_1": "stream",
                "param_2": "file",
                "param_3": "buffer",
                "param_4": "mode",
                "uVar1": "result"
            },
            "calling": [
                "__swbuf_r"
            ],
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005320": {
            "entrypoint": "0x08005320",
            "current_name": "execute_fwalk_reent_08005320",
            "code": "\nvoid execute_fwalk_reent_08005320(undefined4 reentrancy)\n\n{\n  execute_fwalk_reent_08005320rancy(reentrancy,0x80052cd);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005320": "execute_fwalk_reent_08005320",
                "param_1": "reentrancy",
                "_fwalk_reent": "execute_fwalk_reentrancy"
            },
            "calling": [],
            "called": [
                "_fwalk_reent"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800532c": {
            "entrypoint": "0x0800532c",
            "current_name": "initialize_data_0800532c",
            "code": "\nvoid initializeData_0800532c(undefined4 *data,undefined2 value2,undefined2 value3)\n\n{\n  *data = 0;\n  data[1] = 0;\n  data[2] = 0;\n  *(undefined2 *)(data + 3) = value2;\n  data[25] = 0;\n  *(undefined2 *)((int)data + 0xe) = value3;\n  data[4] = 0;\n  data[5] = 0;\n  data[6] = 0;\n  memset(data + 0x17,0,8);\n  data[9] = 0x8005609;\n  data[10] = 0x800562b;\n  data[11] = 0x8005663;\n  data[8] = data;\n  data[12] = 0x8005687;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800532c": "initialize_data_0800532c",
                "param_1": "data",
                "param_2": "value2",
                "param_3": "value3",
                "param_1[1]": "data[1]",
                "param_1[2]": "data[2]",
                "param_1[0x19]": "data[25]",
                "param_1[4]": "data[4]",
                "param_1[5]": "data[5]",
                "param_1[6]": "data[6]",
                "param_1[9]": "data[9]",
                "param_1[10]": "data[10]",
                "param_1[0xb]": "data[11]",
                "param_1[8]": "data[8]",
                "param_1[0xc]": "data[12]"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005374": {
            "entrypoint": "0x08005374",
            "current_name": "allocate_memory_08005374",
            "code": "\nundefined4 * allocate_memory_08005374(undefined4 size_of_element,int number_of_elements)\n\n{\n  undefined4 *allocated_memory;\n  int total_size;\n  \n  total_size = (number_of_elements + -1) * 0x68;\n  allocated_memory = (undefined4 *)_malloc_r(size_of_element,total_size + 0x74);\n  if (allocated_memory != (undefined4 *)0x0) {\n    *allocated_memory = 0;\n    allocated_memory[1] = number_of_elements;\n    allocated_memory[2] = allocated_memory + 3;\n    memset(allocated_memory + 3,0,total_size + 0x68);\n  }\n  return allocated_memory;\n}\n\n",
            "renaming": {
                "FUN_08005374": "allocate_memory_08005374",
                "param_1": "size_of_element",
                "param_2": "number_of_elements",
                "puVar1": "allocated_memory",
                "iVar2": "total_size"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "_malloc_r",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053a0": {
            "entrypoint": "0x080053a0",
            "current_name": "initialize_function_080053a0",
            "code": "\nvoid initializeFunction_080053a0(undefined1 *functionData)\n\n{\n  undefined4 returnValue;\n  undefined1 *dataPtr;\n  \n  if (*(int *)(functionData + 0x18) == 0) {\n    *(undefined4 *)(functionData + 0x48) = 0;\n    *(undefined4 *)(functionData + 0x4c) = 0;\n    *(undefined4 *)(functionData + 0x50) = 0;\n    dataPtr = &globalData;\n    *(undefined4 *)(functionData + 0x28) = 0x8005321;\n    if (functionData == &globalData) {\n      dataPtr = (undefined1 *)0x1;\n    }\n    if (functionData == &globalData) {\n      *(undefined1 **)(functionData + 0x18) = dataPtr;\n    }\n    returnValue = __sfp();\n    *(undefined4 *)(functionData + 4) = returnValue;\n    returnValue = __sfp(functionData);\n    *(undefined4 *)(functionData + 8) = returnValue;\n    returnValue = __sfp(functionData);\n    *(undefined4 *)(functionData + 0xc) = returnValue;\n    std_isra_0(*(undefined4 *)(functionData + 4),4,0);\n    std_isra_0(*(undefined4 *)(functionData + 8),9,1);\n    std_isra_0(*(undefined4 *)(functionData + 0xc),0x12,2);\n    *(undefined4 *)(functionData + 0x18) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053a0": "initialize_function_080053a0",
                "param_1": "functionData",
                "uVar1": "returnValue",
                "puVar2": "dataPtr",
                "impure_data": "globalData"
            },
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r",
                "iprintf",
                "_fflush_r",
                "__swsetup_r",
                "__sfp"
            ],
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005400": {
            "entrypoint": "0x08005400",
            "current_name": "initialize_data_08005400",
            "code": "\nint * initializeData_08005400(undefined4 *result)\n\n{\n  int *currentPtr;\n  int *startPtr;\n  int **dataPtr;\n  \n  if (DAT_200000bc == 0) {\n    __sinit(impureData);\n  }\n  dataPtr = (int **)&DAT_200000ec;\n  do {\n    startPtr = dataPtr[2];\n    currentPtr = dataPtr[1];\n    while (currentPtr = (int *)((int)currentPtr + -1), -1 < (int)currentPtr) {\n      if (*(shortValue *)(startPtr + 3) == 0) {\n        *(undefined2 *)((int)startPtr + 0xe) = 0xffff;\n        *(undefined2 *)(startPtr + 3) = 1;\n        startPtr[0x19] = 0;\n        *startPtr = 0;\n        startPtr[2] = 0;\n        startPtr[1] = 0;\n        startPtr[4] = 0;\n        startPtr[5] = 0;\n        startPtr[6] = 0;\n        setMemory(startPtr + 0x17,0,8);\n        startPtr[0xd] = 0;\n        startPtr[0xe] = 0;\n        startPtr[0x12] = 0;\n        startPtr[0x13] = 0;\n        return startPtr;\n      }\n      startPtr = startPtr + 0x1a;\n    }\n    if (*dataPtr == (int *)0x0) {\n      currentPtr = (int *)allocateMemory(result,4);\n      *dataPtr = currentPtr;\n      if (currentPtr == (int *)0x0) {\n        *result = 0xc;\n        return (int *)0x0;\n      }\n    }\n    dataPtr = (int **)*dataPtr;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005400": "initialize_data_08005400",
                "param_1": "result",
                "piVar1": "currentPtr",
                "piVar2": "startPtr",
                "ppiVar3": "dataPtr",
                "&impure_data": "impureData",
                "short": "shortValue",
                "memset": "setMemory",
                "__sfmoreglue": "allocateMemory"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__sfmoreglue",
                "__sinit",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005478": {
            "entrypoint": "0x08005478",
            "current_name": "process_data_08005478",
            "code": "\nuint processData_08005478(int dataOffset,code *callback,undefined4 paramA,undefined4 paramB)\n\n{\n  uint result;\n  int updatedValue;\n  int *currentEntry;\n  int entryValue;\n  uint combinedResult;\n  int count;\n  \n  combinedResult = 0;\n  for (currentEntry = (int *)(dataOffset + 0x48); currentEntry != (int *)0x0; currentEntry = (int *)*currentEntry) {\n    entryValue = currentEntry[2];\n    count = currentEntry[1];\n    while (count = count + -1, -1 < count) {\n      if ((1 < *(ushort *)(entryValue + 0xc)) && (updatedValue = *(short *)(entryValue + 0xe) + 1, updatedValue != 0)) {\n        result = (*callback)(dataOffset,entryValue,paramA,updatedValue,paramB);\n        combinedResult = combinedResult | result;\n      }\n      entryValue = entryValue + 0x68;\n    }\n  }\n  return combinedResult;\n}\n\n",
            "renaming": {
                "FUN_08005478": "process_data_08005478",
                "param_1": "dataOffset",
                "param_2": "callback",
                "param_3": "paramA",
                "param_4": "paramB",
                "piVar3": "currentEntry",
                "iVar4": "entryValue",
                "iVar6": "count",
                "uVar1": "result",
                "uVar5": "combinedResult",
                "iVar2": "updatedValue"
            },
            "calling": [
                "_cleanup_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054b4": {
            "entrypoint": "0x080054b4",
            "current_name": "check_file_permissions_080054b4",
            "code": "\nundefined4 checkFilePermissions_080054b4(undefined4 fileDescriptor,int fileInfo,undefined4 *outputPermission,uint *outputFlags)\n\n{\n  int result;\n  undefined4 permissionFlag;\n  undefined stackVariable [4];\n  uint fileMode;\n  \n  if ((*(short *)(fileInfo + 0xe) < 0) ||\n     (result = _fstat_r(fileDescriptor,(int)*(short *)(fileInfo + 0xe),stackVariable), result < 0)) {\n    *outputFlags = 0;\n    if ((int)((uint)*(ushort *)(fileInfo + 0xc) << 0x18) < 0) {\n      permissionFlag = 0x40;\n      goto LAB_080054f4;\n    }\n  }\n  else {\n    *outputFlags = (uint)((fileMode & 0xf000) == 0x2000);\n  }\n  permissionFlag = 0x400;\nLAB_080054f4:\n  *outputPermission = permissionFlag;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080054b4": "check_file_permissions_080054b4",
                "param_1": "fileDescriptor",
                "param_2": "fileInfo",
                "param_3": "outputPermission",
                "param_4": "outputFlags",
                "iVar1": "result",
                "uVar2": "permissionFlag",
                "auStack_4c": "stackVariable",
                "local_48": "fileMode"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054fc": {
            "entrypoint": "0x080054fc",
            "current_name": "allocate_and_initialize_buffer_080054fc",
            "code": "\nvoid allocateAndInitializeBuffer_080054fc(int bufferSize,int *buffer)\n\n{\n  ushort flags;\n  int allocatedBuffer;\n  int bufferSizeCopy;\n  int *bufferCopy;\n  \n  if (-1 < (int)((uint)*(ushort *)(buffer + 3) << 0x1e)) {\n    bufferSizeCopy = bufferSize;\n    bufferCopy = buffer;\n    flags = __swhatbuf_r(bufferSize,buffer,&bufferSizeCopy,&bufferCopy);\n    allocatedBuffer = _malloc_r(bufferSize,bufferSizeCopy);\n    if (allocatedBuffer != 0) {\n      *(undefined4 *)(bufferSize + 0x28) = 0x8005321;\n      *buffer = allocatedBuffer;\n      *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) | 0x80;\n      buffer[5] = bufferSizeCopy;\n      buffer[4] = allocatedBuffer;\n      if ((bufferCopy != (int *)0x0) &&\n         (allocatedBuffer = _isatty_r(bufferSize,(int)*(short *)((int)buffer + 0xe)), allocatedBuffer != 0)) {\n        *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(buffer + 3) = flags | *(ushort *)(buffer + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(buffer + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) & 0xfffc | 2;\n  }\n  *buffer = (int)buffer + 0x47;\n  buffer[4] = (int)buffer + 0x47;\n  buffer[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080054fc": "allocate_and_initialize_buffer_080054fc",
                "param_1": "bufferSize",
                "param_2": "buffer",
                "uVar1": "flags",
                "iVar2": "allocatedBuffer",
                "local_18": "bufferSizeCopy",
                "local_14": "bufferCopy"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "_isatty_r",
                "__swhatbuf_r",
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800557c": {
            "entrypoint": "0x0800557c",
            "current_name": "FUNC_0800557c",
            "code": "\nvoid FUNC_0800557c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800557c": "FUNC_0800557c"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800557e": {
            "entrypoint": "0x0800557e",
            "current_name": "FUNC_0800557e",
            "code": "\nvoid FUNC_0800557e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800557e": "FUNC_0800557e"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005580": {
            "entrypoint": "0x08005580",
            "current_name": "execute_task_08005580",
            "code": "\nundefined4 execute_task_08005580(undefined4 *status,uint task_id,undefined4 param_3,undefined4 param_4)\n\n{\n  __pid_t process_id;\n  undefined4 result;\n  int task_array;\n  code *task_function;\n  \n  if (0x1f < task_id) {\n    *status = 0x16;\n    return 0xffffffff;\n  }\n  task_array = status[0x11];\n  if ((task_array != 0) && (task_function = *(code **)(task_array + task_id * 4), task_function != (code *)0x0)) {\n    if (task_function != (code *)0x1) {\n      if (task_function == (code *)0xffffffff) {\n        *status = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(task_array + task_id * 4) = 0;\n      (*task_function)(task_id);\n    }\n    return 0;\n  }\n  process_id = _getpid_r();\n  result = _kill_r(status,process_id,task_id,param_4);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005580": "execute_task_08005580",
                "param_1": "status",
                "param_2": "task_id",
                "_Var1": "process_id",
                "uVar2": "result",
                "iVar3": "task_array",
                "pcVar4": "task_function"
            },
            "calling": [
                "raise"
            ],
            "called": [
                "_getpid_r",
                "_kill_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055d0": {
            "entrypoint": "0x080055d0",
            "current_name": "raise_signal_080055d0",
            "code": "\nint raise_signal_080055d0(int signal_number)\n\n{\n  int result;\n  \n  result = _raise_r(_impure_ptr,signal_number);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080055d0": "raise_signal_080055d0",
                "__sig": "signal_number",
                "iVar1": "result"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "_raise_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055e0": {
            "entrypoint": "0x080055e0",
            "current_name": "kill_process_and_update_errno_080055e0",
            "code": "\nvoid kill_process_and_update_errno_080055e0(int *error_code,__pid_t process_id,int signal)\n\n{\n  int kill_result;\n  \n  errno = 0;\n  kill_result = _kill(process_id,signal);\n  if ((kill_result == -1) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055e0": "kill_process_and_update_errno_080055e0",
                "param_1": "error_code",
                "param_2": "process_id",
                "param_3": "signal",
                "iVar1": "kill_result"
            },
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_kill"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005604": {
            "entrypoint": "0x08005604",
            "current_name": "FUN_08005604",
            "code": "\n\n\n__pid_t _getpid(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {},
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_getpid"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005608": {
            "entrypoint": "0x08005608",
            "current_name": "update_data_08005608",
            "code": "\nvoid updateData_08005608(undefined4 fileName,int dataAddress)\n\n{\n  int readResult;\n  uint updatedValue;\n  bool isSuccess;\n  \n  readResult = _read_r(fileName,(int)*(short *)(dataAddress + 0xe));\n  isSuccess = -1 < readResult;\n  if (isSuccess) {\n    updatedValue = *(int *)(dataAddress + 0x54) + readResult;\n  }\n  else {\n    updatedValue = *(ushort *)(dataAddress + 0xc) & 0xffffefff;\n  }\n  if (isSuccess) {\n    *(uint *)(dataAddress + 0x54) = updatedValue;\n  }\n  if (!isSuccess) {\n    *(short *)(dataAddress + 0xc) = (short)updatedValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005608": "update_data_08005608",
                "param_1": "fileName",
                "param_2": "dataAddress",
                "iVar1": "readResult",
                "uVar2": "updatedValue",
                "bVar3": "isSuccess"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800562a": {
            "entrypoint": "0x0800562a",
            "current_name": "write_to_offset_0800562a",
            "code": "\nvoid writeToOffset_0800562a(undefined4 fileDescriptor,int bufferOffset,undefined4 data,undefined4 numBytes)\n\n{\n  if ((int)((uint)*(unsignedShort *)(bufferOffset + 0xc) << 0x17) < 0) {\n    repositionFilePointer(fileDescriptor,(int)*(short *)(bufferOffset + 0xe),0,2);\n  }\n  *(unsignedShort *)(bufferOffset + 0xc) = *(unsignedShort *)(bufferOffset + 0xc) & 0xefff;\n  writeToFile(fileDescriptor,(int)*(short *)(bufferOffset + 0xe),data,numBytes);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800562a": "write_to_offset_0800562a",
                "param_1": "fileDescriptor",
                "param_2": "bufferOffset",
                "param_3": "data",
                "param_4": "numBytes",
                "ushort": "unsignedShort",
                "_lseek_r": "repositionFilePointer",
                "_write_r": "writeToFile"
            },
            "calling": [],
            "called": [
                "_lseek_r",
                "_write_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005662": {
            "entrypoint": "0x08005662",
            "current_name": "update_file_status_08005662",
            "code": "\nvoid updateFileStatus_08005662(undefined4 fileDescriptor,int dataPointer)\n\n{\n  int seekResult;\n  ushort updatedStatus;\n  bool seekFailed;\n  \n  seekResult = _lseek_r(fileDescriptor,(int)*(short *)(dataPointer + 0xe));\n  seekFailed = seekResult == -1;\n  if (seekFailed) {\n    updatedStatus = *(ushort *)(dataPointer + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(dataPointer + 0x54) = seekResult;\n    updatedStatus = *(ushort *)(dataPointer + 0xc) | 0x1000;\n  }\n  if (seekFailed) {\n    *(ushort *)(dataPointer + 0xc) = updatedStatus;\n  }\n  if (!seekFailed) {\n    *(ushort *)(dataPointer + 0xc) = updatedStatus;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005662": "update_file_status_08005662",
                "param_1": "fileDescriptor",
                "param_2": "dataPointer",
                "iVar1": "seekResult",
                "uVar2": "updatedStatus",
                "bVar3": "seekFailed"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005686": {
            "entrypoint": "0x08005686",
            "current_name": "close_file_08005686",
            "code": "\nvoid closeFile_08005686(undefined4 fileDescriptorParam,int fileInfoParam)\n\n{\n  _close_r(fileDescriptorParam,(int)*(short *)(fileInfoParam + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005686": "close_file_08005686",
                "param_1": "fileDescriptorParam",
                "param_2": "fileInfoParam"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005690": {
            "entrypoint": "0x08005690",
            "current_name": "write_data_to_stream_08005690",
            "code": "\nvoid writeDataToStream_08005690(int *errorPointer,int streamDescriptor,char *data,int length)\n\n{\n  int writeResult;\n  \n  errno = 0;\n  writeResult = _write(streamDescriptor,data,length);\n  if ((writeResult == -1) && (errno != 0)) {\n    *errorPointer = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005690": "write_data_to_stream_08005690",
                "param_1": "errorPointer",
                "param_2": "streamDescriptor",
                "param_3": "data",
                "param_4": "length",
                "iVar1": "writeResult"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056b4": {
            "entrypoint": "0x080056b4",
            "current_name": "close_file_080056b4",
            "code": "\nvoid closeFile_080056b4(int *errorFlag,int fileDescriptor)\n\n{\n  int closeResult;\n  \n  errno = 0;\n  closeResult = _close(fileDescriptor);\n  if ((closeResult == -1) && (errno != 0)) {\n    *errorFlag = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056b4": "close_file_080056b4",
                "param_1": "errorFlag",
                "param_2": "fileDescriptor",
                "iVar1": "closeResult"
            },
            "calling": [
                "__sclose"
            ],
            "called": [
                "_close"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056d4": {
            "entrypoint": "0x080056d4",
            "current_name": "get_file_status_080056d4",
            "code": "\nvoid get_file_status_080056d4(int *error_code_ptr,int file_descriptor,stat *file_status_struct)\n\n{\n  int status_check_result;\n  \n  errno = 0;\n  status_check_result = _fstat(file_descriptor,file_status_struct);\n  if ((status_check_result == -1) && (errno != 0)) {\n    *error_code_ptr = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056d4": "get_file_status_080056d4",
                "param_1": "error_code_ptr",
                "param_2": "file_descriptor",
                "param_3": "file_status_struct",
                "iVar1": "status_check_result"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056f8": {
            "entrypoint": "0x080056f8",
            "current_name": "check_and_set_errno_080056f8",
            "code": "\nvoid checkAndSetErrno_080056f8(int *errorMessage,int fileDescriptor)\n\n{\n  int isTerminal;\n  \n  errno = 0;\n  isTerminal = _isatty(fileDescriptor);\n  if ((isTerminal == -1) && (errno != 0)) {\n    *errorMessage = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056f8": "check_and_set_errno_080056f8",
                "param_1": "errorMessage",
                "param_2": "fileDescriptor",
                "iVar1": "isTerminal"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005718": {
            "entrypoint": "0x08005718",
            "current_name": "seek_file_position_08005718",
            "code": "\nvoid seek_file_position_08005718(int *error_pointer,int file_descriptor,__off_t offset,int origin)\n\n{\n  __off_t seek_result;\n  \n  errno = 0;\n  seek_result = _lseek(file_descriptor,offset,origin);\n  if ((seek_result == -1) && (errno != 0)) {\n    *error_pointer = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005718": "seek_file_position_08005718",
                "param_1": "error_pointer",
                "param_2": "file_descriptor",
                "param_3": "offset",
                "param_4": "origin",
                "_Var1": "seek_result"
            },
            "calling": [
                "__swrite",
                "__sseek"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800573c": {
            "entrypoint": "0x0800573c",
            "current_name": "read_into_buffer_0800573c",
            "code": "\nvoid readIntoBuffer_0800573c(int *error,int fileDescriptor,char *buffer,int count)\n\n{\n  int bytesRead;\n  \n  errno = 0;\n  bytesRead = _read(fileDescriptor,buffer,count);\n  if ((bytesRead == -1) && (errno != 0)) {\n    *error = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800573c": "read_into_buffer_0800573c",
                "param_1": "error",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "count",
                "iVar1": "bytesRead"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005760": {
            "entrypoint": "0x08005760",
            "current_name": "abort_function_08005760",
            "code": "\n\n/* std::__throw_bad_function_call() */\n\nvoid std::abort_function_08005760(void)\n\n{\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_08005760": "abort_function_08005760"
            },
            "calling": [
                "operator()"
            ],
            "called": [
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005768": {
            "entrypoint": "0x08005768",
            "current_name": "initialize_c_type_by_name_08005768",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeCTypeByName_08005768(void)\n\n{\n  if (-1 < moneypunct<char,false>::id << 0x1f) {\n    moneypunct<char,false>::id = 1;\n  }\n  if (-1 < moneypunct<char,true>::id << 0x1f) {\n    moneypunct<char,true>::id = 1;\n  }\n  if (-1 < money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < numpunct<char>::id << 0x1f) {\n    numpunct<char>::id = 1;\n  }\n  if (-1 < num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __timepunct<char>::id << 0x1f) {\n    __timepunct<char>::id = 1;\n  }\n  if (-1 < time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < messages<char>::id << 0x1f) {\n    messages<char>::id = 1;\n  }\n  if (-1 < collate<char>::id << 0x1f) {\n    collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005768": "initialize_c_type_by_name_08005768"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800582c": {
            "entrypoint": "0x0800582c",
            "current_name": "initialize_c_type_byname_0800582c",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeCTypeByname_0800582c(void)\n\n{\n  if (-1 < moneypunct<wchar_t,false>::id << 0x1f) {\n    moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < moneypunct<wchar_t,true>::id << 0x1f) {\n    moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < numpunct<wchar_t>::id << 0x1f) {\n    numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __timepunct<wchar_t>::id << 0x1f) {\n    __timepunct<wchar_t>::id = 1;\n  }\n  if (-1 < time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < messages<wchar_t>::id << 0x1f) {\n    messages<wchar_t>::id = 1;\n  }\n  if (-1 < collate<wchar_t>::id << 0x1f) {\n    collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800582c": "initialize_c_type_byname_0800582c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058f0": {
            "entrypoint": "0x080058f0",
            "current_name": "set_default_ids_080058f0",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::setDefaultIds_080058f0(void)\n\n{\n  if (-1 < __cxx11::moneypunct<wchar_t,false>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<wchar_t,true>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<wchar_t>::id << 0x1f) {\n    __cxx11::numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<wchar_t>::id << 0x1f) {\n    __cxx11::messages<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::collate<wchar_t>::id << 0x1f) {\n    __cxx11::collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080058f0": "set_default_ids_080058f0"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005974": {
            "entrypoint": "0x08005974",
            "current_name": "initialize_locale_data_08005974",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeLocaleData_08005974(void)\n\n{\n  if (-1 < __cxx11::moneypunct<char,false>::id << 0x1f) {\n    __cxx11::moneypunct<char,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<char,true>::id << 0x1f) {\n    __cxx11::moneypunct<char,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<char>::id << 0x1f) {\n    __cxx11::numpunct<char>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f\n     ) {\n    __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<char>::id << 0x1f) {\n    __cxx11::messages<char>::id = 1;\n  }\n  if (-1 < __cxx11::collate<char>::id << 0x1f) {\n    __cxx11::collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005974": "initialize_locale_data_08005974"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f8": {
            "entrypoint": "0x080059f8",
            "current_name": "FUNC_080059f8",
            "code": "\nvoid FUNC_080059f8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080059f8": "FUNC_080059f8"
            },
            "calling": [
                "__do_global_dtors_aux",
                "__libc_init_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005a04": {
            "entrypoint": "0x08005a04",
            "current_name": "FUNC_08005a04",
            "code": "\nvoid FUNC_08005a04(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a04": "FUNC_08005a04"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 143236,
    "layers": [
        [
            "FUN_080001ac",
            "FUN_08000218",
            "FUN_08000230",
            "FUN_080002d0",
            "FUN_08000300",
            "FUN_080005e0",
            "FUN_080005e4",
            "FUN_08000600",
            "FUN_0800066c",
            "FUN_08000682",
            "FUN_08000690",
            "FUN_080006b4",
            "FUN_08000728",
            "FUN_0800076c",
            "FUN_080007f0",
            "FUN_080008cc",
            "FUN_080008e2",
            "FUN_08000998",
            "FUN_08000a00",
            "FUN_08000a4e",
            "FUN_08000a7a",
            "FUN_08000b04",
            "FUN_08000b54",
            "FUN_08000c4c",
            "FUN_08000c64",
            "FUN_08000c7c",
            "FUN_08000c8c",
            "FUN_08000d3c",
            "FUN_08000d8c",
            "FUN_08000d8e",
            "FUN_08000d98",
            "FUN_08000de4",
            "FUN_08000e18",
            "FUN_08000e30",
            "FUN_08000e3c",
            "FUN_08000e60",
            "FUN_08000ec4",
            "FUN_08000ee0",
            "FUN_08000f0c",
            "FUN_08000f2c",
            "FUN_08000f4e",
            "FUN_08000f56",
            "FUN_08000f72",
            "FUN_08000f8c",
            "FUN_08000fb4",
            "FUN_08001198",
            "FUN_080011a4",
            "FUN_080011c0",
            "FUN_0800124a",
            "FUN_08001256",
            "FUN_08001420",
            "FUN_08001440",
            "FUN_08001460",
            "FUN_080014ec",
            "FUN_08001578",
            "FUN_080015bc",
            "FUN_0800160e",
            "FUN_0800165a",
            "FUN_08001684",
            "FUN_0800171a",
            "FUN_08001864",
            "FUN_08001904",
            "FUN_080019a0",
            "FUN_08001ab0",
            "FUN_08001bfc",
            "FUN_08001d00",
            "FUN_08001e68",
            "FUN_08001f3c",
            "FUN_08001f9c",
            "FUN_0800201c",
            "FUN_080023b4",
            "FUN_08002488",
            "FUN_080025e0",
            "FUN_080025ec",
            "FUN_0800260c",
            "FUN_0800262c",
            "FUN_0800268e",
            "FUN_080026ce",
            "FUN_08002848",
            "FUN_08002864",
            "FUN_080028d4",
            "FUN_080028f0",
            "FUN_08002940",
            "FUN_0800295c",
            "FUN_080029c8",
            "FUN_08002d0c",
            "FUN_08002d72",
            "FUN_08002dd0",
            "FUN_08002eb2",
            "FUN_08002efa",
            "FUN_08002f4c",
            "FUN_08002f66",
            "FUN_08002ffc",
            "FUN_0800311c",
            "FUN_0800312c",
            "FUN_08003138",
            "FUN_0800314e",
            "FUN_0800316c",
            "FUN_0800318c",
            "FUN_080031fc",
            "FUN_08003380",
            "FUN_0800339c",
            "FUN_080033c8",
            "FUN_080033d8",
            "FUN_0800340c",
            "FUN_08003414",
            "FUN_0800346c",
            "FUN_08003476",
            "FUN_08003486",
            "FUN_080034b6",
            "FUN_080034ce",
            "FUN_080034da",
            "FUN_080034f4",
            "FUN_08003506",
            "FUN_0800351e",
            "FUN_0800352e",
            "FUN_0800354a",
            "FUN_0800355e",
            "FUN_08003582",
            "FUN_08003594",
            "FUN_080035ac",
            "FUN_080035bc",
            "FUN_080035fc",
            "FUN_08003750",
            "FUN_08003754",
            "FUN_0800376e",
            "FUN_0800377c",
            "FUN_08003798",
            "FUN_080037ac",
            "FUN_080037c0",
            "FUN_080037d4",
            "FUN_080037e8",
            "FUN_080037fc",
            "FUN_08003810",
            "FUN_0800382c",
            "FUN_08003840",
            "FUN_08003854",
            "FUN_08003868",
            "FUN_0800387c",
            "FUN_08003880",
            "FUN_080038d0",
            "FUN_08003900",
            "FUN_08003918",
            "FUN_08003928",
            "FUN_08003938",
            "FUN_08003948",
            "FUN_08003958",
            "FUN_08003968",
            "FUN_08003978",
            "FUN_08003cc8",
            "FUN_08003d18",
            "FUN_08003dd0",
            "FUN_08003df4",
            "FUN_08003e18",
            "FUN_08003e54",
            "FUN_08003eac",
            "FUN_08003f00",
            "FUN_08003f24",
            "FUN_08003f48",
            "FUN_08003f94",
            "FUN_08003fd4",
            "FUN_08003fec",
            "FUN_08004004",
            "FUN_0800401c",
            "FUN_08004034",
            "FUN_0800404c",
            "FUN_08004064",
            "FUN_0800407c",
            "FUN_08004094",
            "FUN_080040d0",
            "FUN_080040d6",
            "FUN_080040e0",
            "FUN_080040e4",
            "FUN_080040e8",
            "FUN_080040ec",
            "FUN_080040f8",
            "FUN_080040fc",
            "FUN_0800410c",
            "FUN_08004110",
            "FUN_080041bc",
            "FUN_08004204",
            "FUN_0800420c",
            "FUN_08004240",
            "FUN_08004254",
            "FUN_08004270",
            "FUN_08004298",
            "FUN_080042ac",
            "FUN_080042e8",
            "FUN_08004364",
            "FUN_08004388",
            "FUN_08004444",
            "FUN_08004460",
            "FUN_0800447c",
            "FUN_080044d8",
            "FUN_080044fc",
            "FUN_0800450a",
            "FUN_08004544",
            "FUN_08004560",
            "FUN_0800458c",
            "FUN_0800459a",
            "FUN_080045be",
            "FUN_080045c8",
            "FUN_08004622",
            "FUN_08004638",
            "FUN_08004640",
            "FUN_08004648",
            "FUN_08004658",
            "FUN_08004678",
            "FUN_0800468c",
            "FUN_080046b4",
            "FUN_08004760",
            "FUN_0800476a",
            "FUN_08004774",
            "FUN_0800477e",
            "FUN_08004788",
            "FUN_08004792",
            "FUN_080047a8",
            "FUN_080047c0",
            "FUN_080047d0",
            "FUN_080047f0",
            "FUN_080047fe",
            "FUN_08004808",
            "FUN_08004844",
            "FUN_08004860",
            "FUN_08004884",
            "FUN_080048cc",
            "FUN_080048dc",
            "FUN_08004978",
            "FUN_08004a34",
            "FUN_08004a60",
            "FUN_08004a84",
            "FUN_08004cb0",
            "FUN_08004d9c",
            "FUN_08004fdc",
            "FUN_0800500c",
            "FUN_0800502c",
            "FUN_080050d0",
            "FUN_080051ac",
            "FUN_080051bc",
            "FUN_080052cc",
            "FUN_08005320",
            "FUN_0800532c",
            "FUN_08005374",
            "FUN_080053a0",
            "FUN_08005400",
            "FUN_08005478",
            "FUN_080054b4",
            "FUN_080054fc",
            "FUN_08005580",
            "FUN_080055d0",
            "FUN_080055e0",
            "FUN_08005608",
            "FUN_0800562a",
            "FUN_08005662",
            "FUN_08005686",
            "FUN_08005690",
            "FUN_080056b4",
            "FUN_080056d4",
            "FUN_080056f8",
            "FUN_08005718",
            "FUN_0800573c",
            "FUN_08005760",
            "FUN_08005768",
            "FUN_0800582c",
            "FUN_080058f0",
            "FUN_08005974"
        ]
    ],
    "locked_functions": []
}