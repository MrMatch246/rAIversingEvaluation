{
    "functions": {
        "FUN_08000110": {
            "entrypoint": "0x08000110",
            "current_name": "initialize_flag_if_needed_08000110",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800011c) */\n\nundefined4 initializeFlagIfNeeded_08000110(undefined4 inputValue)\n\n{\n  if ((char)DAT_200009c8 == '\\0') {\n    DAT_200009c8._0_1_ = '\\x01';\n  }\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_08000110": "initialize_flag_if_needed_08000110",
                "param_1": "inputValue"
            },
            "calling": [],
            "called": [
                "FUN_08009e68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000134": {
            "entrypoint": "0x08000134",
            "current_name": "concatenate_params_08000134",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800013a) */\n\nundefined8 concatenate_params_08000134(undefined4 first_parameter,undefined4 second_parameter)\n\n{\n  return CONCAT44(second_parameter,first_parameter);\n}\n\n",
            "renaming": {
                "FUN_08000134": "concatenate_params_08000134",
                "param_1": "first_parameter",
                "param_2": "second_parameter"
            },
            "calling": [
                "FUN_08005d20"
            ],
            "called": [
                "FUN_08009e68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000158": {
            "entrypoint": "0x08000158",
            "current_name": "reverse_func_08000158",
            "code": "\nulonglong reverseFunc_08000158(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int index1;\n  byte tempByte;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  int index2;\n  uint result1;\n  uint result2;\n  uint result3;\n  uint result4;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  \n  temp4 = input4 ^ 0x80000000;\n  result1 = input2 << 1;\n  input4 = input4 << 1;\n  flag1 = ((input2 ^ temp4) & 0x7fffffff) == 0;\n  flag2 = flag1 && input1 == input3;\n  if (!flag1 || input1 != input3) {\n    flag2 = (result1 | input1) == 0;\n  }\n  if (!flag2) {\n    flag2 = (input4 | input3) == 0;\n  }\n  index2 = (int)result1 >> 0x15;\n  if (!flag2) {\n    flag2 = index2 == -1;\n  }\n  index1 = (int)input4 >> 0x15;\n  if (!flag2) {\n    flag2 = index1 == -1;\n  }\n  if (flag2) {\n    if (index2 == -1 || index1 == -1) {\n      result1 = temp4;\n      result3 = input3;\n      if (index2 == -1) {\n        result1 = input2;\n        result3 = input1;\n      }\n      if (index2 != -1 || index1 != -1) {\n        input3 = result3;\n        temp4 = result1;\n      }\n      flag2 = (result3 | result1 << 0xc) == 0;\n      if (flag2) {\n        flag2 = (input3 | temp4 << 0xc) == 0;\n      }\n      if (flag2) {\n        flag2 = result1 == temp4;\n      }\n      if (!flag2) {\n        result1 = result1 | 0x80000;\n      }\n      return CONCAT44(result1,result3);\n    }\n    if (((input2 ^ temp4) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((result1 | input1) == 0) {\n        input1 = input3;\n        input2 = temp4;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != temp4) {\n      return 0;\n    }\n    if (result1 >> 0x15 == 0) {\n      flag2 = (input1 & 0x80000000) != 0;\n      temp4 = input2 * 2 + (uint)flag2;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)flag2)) {\n        temp4 = temp4 | 0x80000000;\n      }\n      return CONCAT44(temp4,input1 << 1);\n    }\n    if (result1 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  result1 = result1 >> 0x15;\n  input4 = input4 >> 0x15;\n  result3 = input4 - result1;\n  flag2 = result3 != 0;\n  if (input4 < result1) {\n    result3 = -result3;\n  }\n  result2 = input1;\n  temp5 = input2;\n  if (flag2 && result1 <= input4) {\n    result1 = result1 + result3;\n    result2 = input3;\n    temp5 = temp4;\n    input3 = input1;\n    temp4 = input2;\n  }\n  if (0x36 < result3) {\n    return CONCAT44(temp5,result2);\n  }\n  temp2 = temp5 & 0xfffff | 0x100000;\n  if ((temp5 & 0x80000000) != 0) {\n    flag2 = result2 != 0;\n    result2 = -result2;\n    temp2 = -temp2 - (uint)flag2;\n  }\n  temp5 = temp4 & 0xfffff | 0x100000;\n  if ((temp4 & 0x80000000) != 0) {\n    flag2 = input3 != 0;\n    input3 = -input3;\n    temp5 = -temp5 - (uint)flag2;\n  }\n  if (result1 == result3) {\n    temp5 = temp5 ^ 0x100000;\n    if (result1 == 0) {\n      temp2 = temp2 ^ 0x100000;\n      result1 = 1;\n    }\n    else {\n      result3 = result3 - 1;\n    }\n  }\n  temp4 = -result3 + 0x20;\n  if ((int)result3 < 0x21) {\n    result4 = input3 << (temp4 & 0xff);\n    input3 = input3 >> (result3 & 0xff);\n    temp1 = result2 + input3;\n    temp3 = temp5 << (temp4 & 0xff);\n    temp4 = temp1 + temp3;\n    temp2 = temp2 + CARRY4(result2,input3) + ((int)temp5 >> (result3 & 0xff)) +\n            (uint)CARRY4(temp1,temp3);\n  }\n  else {\n    result4 = temp5 << (-result3 + 0x40 & 0xff);\n    if (input3 != 0) {\n      result4 = result4 | 2;\n    }\n    temp5 = (int)temp5 >> (result3 - 0x20 & 0xff);\n    temp4 = result2 + temp5;\n    temp2 = temp2 + ((int)temp5 >> 0x1f) + (uint)CARRY4(result2,temp5);\n  }\n  input2 = temp2 & 0x80000000;\n  result3 = temp2;\n  if ((int)temp2 < 0) {\n    flag2 = result4 == 0;\n    result4 = -result4;\n    result3 = -temp4;\n    temp4 = -(uint)!flag2 - temp4;\n    result3 = -(uint)(flag2 <= result3) - temp2;\n  }\n  if (0xfffff < result3) {\n    result2 = result1 - 1;\n    if (0x1fffff < result3) {\n      result2 = result3 & 1;\n      result3 = result3 >> 1;\n      tempByte = (byte)temp4;\n      temp4 = (uint)(result2 != 0) << 0x1f | temp4 >> 1;\n      result4 = (uint)(tempByte & 1) << 0x1f | result4 >> 1;\n      result2 = result1;\n      if (0xffbfffff < result1 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    flag2 = 0x7fffffff < result4;\n    if (result4 == 0x80000000) {\n      flag2 = (temp4 & 1) != 0;\n    }\n    return CONCAT44(result3 + result2 * 0x100000 + (uint)CARRY4(temp4,(uint)flag2) | input2,\n                    temp4 + flag2);\n  }\n  flag1 = (result4 & 0x80000000) != 0;\n  result4 = result4 << 1;\n  result2 = temp4 * 2;\n  flag2 = CARRY4(temp4,temp4);\n  temp4 = temp4 * 2 + (uint)flag1;\n  result3 = result3 * 2 + (uint)(flag2 || CARRY4(result2,(uint)flag1));\n  result2 = result1 - 2;\n  if ((result3 & 0x100000) != 0) goto LAB_08000268;\n  temp5 = temp4;\n  result1 = result3;\n  if (result3 == 0) {\n    temp5 = 0;\n    result1 = temp4;\n  }\n  index2 = LZCOUNT(result1);\n  if (result3 == 0) {\n    index2 = index2 + 0x20;\n  }\n  result3 = index2 - 0xb;\n  flag3 = SBORROW4(result3,0x20);\n  temp4 = index2 - 0x2b;\n  flag2 = (int)temp4 < 0;\n  flag1 = temp4 == 0;\n  if ((int)result3 < 0x20) {\n    flag3 = SCARRY4(temp4,0xc);\n    index2 = index2 + -0x1f;\n    flag2 = index2 < 0;\n    flag1 = index2 == 0;\n    temp4 = result3;\n    if (!flag1 && flag2 == flag3) {\n      temp5 = result1 << (result3 & 0xff);\n      result1 = result1 >> (0xcU - index2 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (flag1 || flag2 != flag3) {\n    result4 = 0x20 - temp4;\n  }\n  result1 = result1 << (temp4 & 0xff);\n  if (flag1 || flag2 != flag3) {\n    result1 = result1 | temp5 >> (result4 & 0xff);\n  }\n  if (flag1 || flag2 != flag3) {\n    temp5 = temp5 << (temp4 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)result3 <= (int)result2) {\n    return CONCAT44(result1 + (result2 - result3) * 0x100000 | input2,temp5);\n  }\n  temp4 = ~(result2 - result3);\n  if ((int)temp4 < 0x1f) {\n    index2 = temp4 - 0x13;\n    if (index2 != 0 && index2 < 0 == SCARRY4(temp4 - 0x1f,0xc)) {\n      return CONCAT44(temp2,temp5 >> (0x20 - (0xcU - index2) & 0xff) | result1 << (0xcU - index2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    temp4 = temp4 + 1;\n    return CONCAT44(input2 | result1 >> (temp4 & 0xff),\n                    temp5 >> (temp4 & 0xff) | result1 << (0x20 - temp4 & 0xff));\n  }\n  return CONCAT44(temp2,result1 >> (temp4 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000158": "reverse_func_08000158",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "index1",
                "bVar2": "tempByte",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "uVar6": "temp4",
                "uVar7": "temp5",
                "iVar8": "index2",
                "uVar9": "result1",
                "uVar10": "result2",
                "uVar11": "result3",
                "uVar12": "result4",
                "bVar13": "flag1",
                "bVar14": "flag2",
                "bVar15": "flag3"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8",
                "FUN_08005838",
                "FUN_080059f0",
                "FUN_08004bd8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800015c": {
            "entrypoint": "0x0800015c",
            "current_name": "calculate_sum_0800015c",
            "code": "\nulonglong calculate_sum_0800015c(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  int shift_amount_1;\n  byte carry_1;\n  uint sum_1;\n  uint sum_2;\n  uint product_1;\n  int shift_amount_2;\n  uint shifted_input_2;\n  uint shifted_input_1;\n  uint shifted_product_1;\n  uint shifted_product_2;\n  uint carry_2;\n  uint result;\n  bool condition_1;\n  bool condition_2;\n  bool condition_3;\n  \n  shifted_input_2 = input_2 << 1;\n  shifted_product_1 = input_4 << 1;\n  condition_1 = ((input_2 ^ input_4) & 0x7fffffff) == 0;\n  condition_2 = condition_1 && input_1 == input_3;\n  if (!condition_1 || input_1 != input_3) {\n    condition_2 = (shifted_input_2 | input_1) == 0;\n  }\n  if (!condition_2) {\n    condition_2 = (shifted_product_1 | input_3) == 0;\n  }\n  shift_amount_2 = (int)shifted_input_2 >> 0x15;\n  if (!condition_2) {\n    condition_2 = shift_amount_2 == -1;\n  }\n  shift_amount_1 = (int)shifted_product_1 >> 0x15;\n  if (!condition_2) {\n    condition_2 = shift_amount_1 == -1;\n  }\n  if (condition_2) {\n    if (shift_amount_2 == -1 || shift_amount_1 == -1) {\n      shifted_product_1 = input_4;\n      shifted_input_2 = input_3;\n      if (shift_amount_2 == -1) {\n        shifted_product_1 = input_2;\n        shifted_input_2 = input_1;\n      }\n      if (shift_amount_2 != -1 || shift_amount_1 != -1) {\n        input_3 = shifted_input_2;\n        input_4 = shifted_product_1;\n      }\n      condition_2 = (shifted_input_2 | shifted_product_1 << 0xc) == 0;\n      if (condition_2) {\n        condition_2 = (input_3 | input_4 << 0xc) == 0;\n      }\n      if (condition_2) {\n        condition_2 = shifted_product_1 == input_4;\n      }\n      if (!condition_2) {\n        shifted_product_1 = shifted_product_1 | 0x80000;\n      }\n      return CONCAT44(shifted_product_1,shifted_input_2);\n    }\n    if (((input_2 ^ input_4) & 0x7fffffff) != 0 || input_1 != input_3) {\n      if ((shifted_input_2 | input_1) == 0) {\n        input_1 = input_3;\n        input_2 = input_4;\n      }\n      return CONCAT44(input_2,input_1);\n    }\n    if (input_2 != input_4) {\n      return 0;\n    }\n    if (shifted_input_2 >> 0x15 == 0) {\n      condition_2 = (input_1 & 0x80000000) != 0;\n      shifted_product_1 = input_2 * 2 + (uint)condition_2;\n      if (CARRY4(input_2,input_2) || CARRY4(input_2 * 2,(uint)condition_2)) {\n        shifted_product_1 = shifted_product_1 | 0x80000000;\n      }\n      return CONCAT44(shifted_product_1,input_1 << 1);\n    }\n    if (shifted_input_2 < 0xffc00000) {\n      return CONCAT44(input_2 + 0x100000,input_1);\n    }\n    input_2 = input_2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(input_2 | 0x7ff00000) << 0x20;\n  }\n  shifted_input_2 = shifted_input_2 >> 0x15;\n  shifted_product_1 = shifted_product_1 >> 0x15;\n  shifted_product_2 = shifted_product_1 - shifted_input_2;\n  condition_2 = shifted_product_2 != 0;\n  if (shifted_product_1 < shifted_input_2) {\n    shifted_product_2 = -shifted_product_2;\n  }\n  shifted_input_1 = input_1;\n  product_1 = input_2;\n  if (condition_2 && shifted_input_2 <= shifted_product_1) {\n    shifted_input_2 = shifted_input_2 + shifted_product_2;\n    shifted_input_1 = input_3;\n    product_1 = input_4;\n    input_3 = input_1;\n    input_4 = input_2;\n  }\n  if (0x36 < shifted_product_2) {\n    return CONCAT44(product_1,shifted_input_1);\n  }\n  shifted_product_1 = product_1 & 0xfffff | 0x100000;\n  if ((product_1 & 0x80000000) != 0) {\n    condition_2 = shifted_input_1 != 0;\n    shifted_input_1 = -shifted_input_1;\n    shifted_product_1 = -shifted_product_1 - (uint)condition_2;\n  }\n  product_1 = input_4 & 0xfffff | 0x100000;\n  if ((input_4 & 0x80000000) != 0) {\n    condition_2 = input_3 != 0;\n    input_3 = -input_3;\n    product_1 = -product_1 - (uint)condition_2;\n  }\n  if (shifted_input_2 == shifted_product_2) {\n    product_1 = product_1 ^ 0x100000;\n    if (shifted_input_2 == 0) {\n      shifted_product_1 = shifted_product_1 ^ 0x100000;\n      shifted_input_2 = 1;\n    }\n    else {\n      shifted_product_2 = shifted_product_2 - 1;\n    }\n  }\n  result = -shifted_product_2 + 0x20;\n  if ((int)shifted_product_2 < 0x21) {\n    carry_2 = input_3 << (result & 0xff);\n    input_3 = input_3 >> (shifted_product_2 & 0xff);\n    sum_1 = shifted_input_1 + input_3;\n    sum_2 = product_1 << (result & 0xff);\n    result = sum_1 + sum_2;\n    shifted_product_1 = shifted_product_1 + CARRY4(shifted_input_1,input_3) + ((int)product_1 >> (shifted_product_2 & 0xff)) +\n            (uint)CARRY4(sum_1,sum_2);\n  }\n  else {\n    carry_2 = product_1 << (-shifted_product_2 + 0x40 & 0xff);\n    if (input_3 != 0) {\n      carry_2 = carry_2 | 2;\n    }\n    product_1 = (int)product_1 >> (shifted_product_2 - 0x20 & 0xff);\n    result = shifted_input_1 + product_1;\n    shifted_product_1 = shifted_product_1 + ((int)product_1 >> 0x1f) + (uint)CARRY4(shifted_input_1,product_1);\n  }\n  input_2 = shifted_product_1 & 0x80000000;\n  shifted_product_2 = shifted_product_1;\n  if ((int)shifted_product_1 < 0) {\n    condition_2 = carry_2 == 0;\n    carry_2 = -carry_2;\n    shifted_product_2 = -result;\n    result = -(uint)!condition_2 - result;\n    shifted_product_2 = -(uint)(condition_2 <= shifted_product_2) - shifted_product_1;\n  }\n  if (0xfffff < shifted_product_2) {\n    shifted_input_1 = shifted_input_2 - 1;\n    if (0x1fffff < shifted_product_2) {\n      shifted_product_1 = shifted_product_2 & 1;\n      shifted_product_2 = shifted_product_2 >> 1;\n      carry_1 = (byte)result;\n      result = (uint)(shifted_product_1 != 0) << 0x1f | result >> 1;\n      carry_2 = (uint)(carry_1 & 1) << 0x1f | carry_2 >> 1;\n      shifted_input_1 = shifted_input_2;\n      if (0xffbfffff < shifted_input_2 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    condition_2 = 0x7fffffff < carry_2;\n    if (carry_2 == 0x80000000) {\n      condition_2 = (result & 1) != 0;\n    }\n    return CONCAT44(shifted_product_2 + shifted_input_1 * 0x100000 + (uint)CARRY4(result,(uint)condition_2) | input_2,\n                    result + condition_2);\n  }\n  condition_1 = (carry_2 & 0x80000000) != 0;\n  carry_2 = carry_2 << 1;\n  shifted_input_1 = result * 2;\n  condition_2 = CARRY4(result,result);\n  result = result * 2 + (uint)condition_1;\n  shifted_product_2 = shifted_product_2 * 2 + (uint)(condition_2 || CARRY4(shifted_input_1,(uint)condition_1));\n  shifted_input_1 = shifted_input_2 - 2;\n  if ((shifted_product_2 & 0x100000) != 0) goto LAB_08000268;\n  product_1 = result;\n  shifted_input_2 = shifted_product_2;\n  if (shifted_product_2 == 0) {\n    product_1 = 0;\n    shifted_input_2 = result;\n  }\n  shift_amount_2 = LZCOUNT(shifted_input_2);\n  if (shifted_product_2 == 0) {\n    shift_amount_2 = shift_amount_2 + 0x20;\n  }\n  result = shift_amount_2 - 0xb;\n  condition_3 = SBORROW4(result,0x20);\n  shifted_product_2 = shift_amount_2 - 0x2b;\n  condition_2 = (int)shifted_product_2 < 0;\n  condition_1 = shifted_product_2 == 0;\n  if ((int)result < 0x20) {\n    condition_3 = SCARRY4(shifted_product_2,0xc);\n    shift_amount_2 = shift_amount_2 + -0x1f;\n    condition_2 = shift_amount_2 < 0;\n    condition_1 = shift_amount_2 == 0;\n    shifted_product_2 = result;\n    if (!condition_1 && condition_2 == condition_3) {\n      product_1 = shifted_input_2 << (result & 0xff);\n      shifted_input_2 = shifted_input_2 >> (0xcU - shift_amount_2 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (condition_1 || condition_2 != condition_3) {\n    carry_2 = 0x20 - shifted_product_2;\n  }\n  shifted_input_2 = shifted_input_2 << (shifted_product_2 & 0xff);\n  if (condition_1 || condition_2 != condition_3) {\n    shifted_input_2 = shifted_input_2 | product_1 >> (carry_2 & 0xff);\n  }\n  if (condition_1 || condition_2 != condition_3) {\n    product_1 = product_1 << (shifted_product_2 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)result <= (int)shifted_input_1) {\n    return CONCAT44(shifted_input_2 + (shifted_input_1 - result) * 0x100000 | input_2,product_1);\n  }\n  shifted_product_2 = ~(shifted_input_1 - result);\n  if ((int)shifted_product_2 < 0x1f) {\n    shift_amount_2 = shifted_product_2 - 0x13;\n    if (shift_amount_2 != 0 && shift_amount_2 < 0 == SCARRY4(shifted_product_2 - 0x1f,0xc)) {\n      return CONCAT44(shifted_product_1,product_1 >> (0x20 - (0xcU - shift_amount_2) & 0xff) | shifted_input_2 << (0xcU - shift_amount_2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    shifted_product_2 = shifted_product_2 + 1;\n    return CONCAT44(input_2 | shifted_input_2 >> (shifted_product_2 & 0xff),\n                    product_1 >> (shifted_product_2 & 0xff) | shifted_input_2 << (0x20 - shifted_product_2 & 0xff));\n  }\n  return CONCAT44(shifted_product_1,shifted_input_2 >> (shifted_product_2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800015c": "calculate_sum_0800015c",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "iVar1": "shift_amount_1",
                "bVar2": "carry_1",
                "uVar3": "sum_1",
                "uVar4": "sum_2",
                "uVar5": "product_1",
                "iVar6": "shift_amount_2",
                "uVar7": "shifted_input_2",
                "uVar8": "shifted_input_1",
                "uVar9": "shifted_product_1",
                "uVar10": "shifted_product_2",
                "uVar11": "carry_2",
                "uVar12": "result",
                "bVar13": "condition_1",
                "bVar14": "condition_2",
                "bVar15": "condition_3"
            },
            "calling": [
                "FUN_080079e8",
                "FUN_08005838",
                "FUN_080059f0",
                "FUN_08004bd8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003d4": {
            "entrypoint": "0x080003d4",
            "current_name": "reverse_bits_080003d4",
            "code": "\nulonglong reverseBits_080003d4(uint input)\n\n{\n  uint result;\n  uint shiftCount;\n  int bitCount;\n  uint temp;\n  uint mask;\n  bool isNegative;\n  bool isZero;\n  bool isCarry;\n  \n  if (input == 0) {\n    return 0;\n  }\n  result = 0;\n  bitCount = LZCOUNT(input);\n  temp = bitCount + 0x15;\n  isCarry = SBORROW4(temp,0x20);\n  shiftCount = bitCount - 0xb;\n  isNegative = (int)shiftCount < 0;\n  isZero = shiftCount == 0;\n  if (temp < 0x20) {\n    isCarry = SCARRY4(shiftCount,0xc);\n    isNegative = false;\n    isZero = bitCount + 1 == 0;\n    shiftCount = temp;\n    if (!isZero && isCarry == false) {\n      result = input << temp;\n      input = input >> (0xcU - (bitCount + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isZero || isNegative != isCarry) {\n    mask = 0x20 - shiftCount;\n  }\n  input = input << (shiftCount & 0xff);\n  if (isZero || isNegative != isCarry) {\n    input = input | 0U >> (mask & 0xff);\n  }\n  if (isZero || isNegative != isCarry) {\n    result = 0 << (shiftCount & 0xff);\n  }\nLAB_080002e0:\n  if (temp < 0x433) {\n    return CONCAT44(input + (0x432 - temp) * 0x100000,result);\n  }\n  shiftCount = ~(0x432 - temp);\n  if (0x1e < (int)shiftCount) {\n    return (ulonglong)(input >> (shiftCount - 0x1f & 0xff));\n  }\n  bitCount = shiftCount - 0x13;\n  if (bitCount == 0 || bitCount < 0 != SCARRY4(shiftCount - 0x1f,0xc)) {\n    shiftCount = shiftCount + 1;\n    return CONCAT44(input >> (shiftCount & 0xff),\n                    result >> (shiftCount & 0xff) | input << (0x20 - shiftCount & 0xff));\n  }\n  return (ulonglong)(result >> (0x20 - (0xcU - bitCount) & 0xff) | input << (0xcU - bitCount & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080003d4": "reverse_bits_080003d4",
                "param_1": "input",
                "uVar1": "result",
                "uVar2": "shiftCount",
                "iVar3": "bitCount",
                "uVar4": "temp",
                "in_r12": "mask",
                "bVar5": "isNegative",
                "bVar6": "isZero",
                "bVar7": "isCarry"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003f4": {
            "entrypoint": "0x080003f4",
            "current_name": "calculate_shift_and_concat_080003f4",
            "code": "\nulonglong calculate_shift_and_concat_080003f4(uint input_value)\n\n{\n  uint shifted_value;\n  uint absolute_value;\n  uint shift_amount;\n  int leading_zeros;\n  uint adjusted_shift;\n  uint sign;\n  uint remaining_bits;\n  bool leading_zero_flag;\n  bool zero_shift_flag;\n  bool carry_flag;\n  \n  if (input_value == 0) {\n    return 0;\n  }\n  sign = input_value & 0x80000000;\n  absolute_value = input_value;\n  if ((int)sign < 0) {\n    absolute_value = -input_value;\n  }\n  shifted_value = 0;\n  leading_zeros = count_leading_zeros(absolute_value);\n  adjusted_shift = leading_zeros + 0x15;\n  carry_flag = SBORROW4(adjusted_shift,0x20);\n  shift_amount = leading_zeros - 0xb;\n  leading_zero_flag = (int)shift_amount < 0;\n  zero_shift_flag = shift_amount == 0;\n  if (adjusted_shift < 0x20) {\n    carry_flag = subtract_carry_4(shift_amount,0xc);\n    leading_zero_flag = false;\n    zero_shift_flag = leading_zeros + 1 == 0;\n    shift_amount = adjusted_shift;\n    if (!zero_shift_flag && carry_flag == false) {\n      shifted_value = absolute_value << adjusted_shift;\n      absolute_value = absolute_value >> (0xcU - (leading_zeros + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (zero_shift_flag || leading_zero_flag != carry_flag) {\n    remaining_bits = 0x20 - shift_amount;\n  }\n  absolute_value = absolute_value << (shift_amount & 0xff);\n  if (zero_shift_flag || leading_zero_flag != carry_flag) {\n    absolute_value = absolute_value | 0U >> (remaining_bits & 0xff);\n  }\n  if (zero_shift_flag || leading_zero_flag != carry_flag) {\n    shifted_value = 0 << (shift_amount & 0xff);\n  }\nLAB_080002e0:\n  if (adjusted_shift < 0x433) {\n    return CONCAT44(absolute_value + (0x432 - adjusted_shift) * 0x100000 | sign,shifted_value);\n  }\n  shift_amount = ~(0x432 - adjusted_shift);\n  if (0x1e < (int)shift_amount) {\n    return CONCAT44(input_value,absolute_value >> (shift_amount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leading_zeros = shift_amount - 0x13;\n  if (leading_zeros == 0 || leading_zeros < 0 != subtract_carry_4(shift_amount - 0x1f,0xc)) {\n    shift_amount = shift_amount + 1;\n    return CONCAT44(sign | absolute_value >> (shift_amount & 0xff),\n                    shifted_value >> (shift_amount & 0xff) | absolute_value << (0x20 - shift_amount & 0xff));\n  }\n  return CONCAT44(input_value,shifted_value >> (0x20 - (0xcU - leading_zeros) & 0xff) | absolute_value << (0xcU - leading_zeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_080003f4": "calculate_shift_and_concat_080003f4",
                "param_1": "input_value",
                "uVar1": "shifted_value",
                "uVar2": "absolute_value",
                "uVar3": "shift_amount",
                "iVar4": "leading_zeros",
                "uVar5": "adjusted_shift",
                "uVar6": "sign",
                "in_r12": "remaining_bits",
                "bVar7": "leading_zero_flag",
                "bVar8": "zero_shift_flag",
                "bVar9": "carry_flag",
                "LZCOUNT": "count_leading_zeros",
                "SCARRY4": "subtract_carry_4"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000418": {
            "entrypoint": "0x08000418",
            "current_name": "reverse_bits_08000418",
            "code": "\nulonglong reverseBits_08000418(uint input,undefined4 reserved,undefined4 reserved2,uint flags)\n\n{\n  uint highBit;\n  uint inputCopy;\n  uint result;\n  uint shiftedInput;\n  uint shiftedInputCopy;\n  int shiftDistance;\n  uint numShiftBits;\n  uint remainingBits;\n  bool isZeroShift;\n  bool isZeroShiftCopy;\n  bool carryFlag;\n  \n  shiftedInputCopy = input << 1;\n  isZeroShiftCopy = shiftedInputCopy == 0;\n  highBit = (uint)((input & 0x80000000) != 0) << 0x1f;\n  shiftedInput = (uint)((int)shiftedInputCopy >> 3) >> 1;\n  result = highBit | shiftedInput;\n  input = input << 0x1d;\n  if (!isZeroShiftCopy) {\n    flags = shiftedInputCopy & 0xff000000;\n    isZeroShiftCopy = flags == 0;\n  }\n  if (!isZeroShiftCopy) {\n    isZeroShiftCopy = flags == 0xff000000;\n  }\n  if (!isZeroShiftCopy) {\n    return CONCAT44(result,input) ^ 0x3800000000000000;\n  }\n  if ((shiftedInputCopy & 0xffffff) == 0) {\n    return CONCAT44(result,input);\n  }\n  if (flags == 0xff000000) {\n    return CONCAT44(result,input) | 0x8000000000000;\n  }\n  inputCopy = input;\n  shiftedInputCopy = shiftedInput;\n  if (shiftedInput == 0) {\n    inputCopy = 0;\n    shiftedInputCopy = input;\n  }\n  shiftDistance = LZCOUNT(shiftedInputCopy);\n  if (shiftedInput == 0) {\n    shiftDistance = shiftDistance + 0x20;\n  }\n  numShiftBits = shiftDistance - 0xb;\n  carryFlag = SBORROW4(numShiftBits,0x20);\n  shiftedInput = shiftDistance - 0x2b;\n  isZeroShiftCopy = (int)shiftedInput < 0;\n  isZeroShift = shiftedInput == 0;\n  if ((int)numShiftBits < 0x20) {\n    carryFlag = SCARRY4(shiftedInput,0xc);\n    shiftDistance = shiftDistance + -0x1f;\n    isZeroShiftCopy = shiftDistance < 0;\n    isZeroShift = shiftDistance == 0;\n    shiftedInput = numShiftBits;\n    if (!isZeroShift && isZeroShiftCopy == carryFlag) {\n      inputCopy = shiftedInputCopy << (numShiftBits & 0xff);\n      shiftedInputCopy = shiftedInputCopy >> (0xcU - shiftDistance & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isZeroShift || isZeroShiftCopy != carryFlag) {\n    remainingBits = 0x20 - shiftedInput;\n  }\n  shiftedInputCopy = shiftedInputCopy << (shiftedInput & 0xff);\n  if (isZeroShift || isZeroShiftCopy != carryFlag) {\n    shiftedInputCopy = shiftedInputCopy | inputCopy >> (remainingBits & 0xff);\n  }\n  if (isZeroShift || isZeroShiftCopy != carryFlag) {\n    inputCopy = inputCopy << (shiftedInput & 0xff);\n  }\nLAB_080002e0:\n  if ((int)numShiftBits < 0x381) {\n    return CONCAT44(shiftedInputCopy + (0x380 - numShiftBits) * 0x100000 | highBit,inputCopy);\n  }\n  shiftedInput = ~(0x380 - numShiftBits);\n  if (0x1e < (int)shiftedInput) {\n    return CONCAT44(result,shiftedInputCopy >> (shiftedInput - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  shiftDistance = shiftedInput - 0x13;\n  if (shiftDistance == 0 || shiftDistance < 0 != SCARRY4(shiftedInput - 0x1f,0xc)) {\n    shiftedInput = shiftedInput + 1;\n    return CONCAT44(highBit | shiftedInputCopy >> (shiftedInput & 0xff),\n                    inputCopy >> (shiftedInput & 0xff) | shiftedInputCopy << (0x20 - shiftedInput & 0xff));\n  }\n  return CONCAT44(result,inputCopy >> (0x20 - (0xcU - shiftDistance) & 0xff) | shiftedInputCopy << (0xcU - shiftDistance & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000418": "reverse_bits_08000418",
                "param_1": "input",
                "param_2": "reserved",
                "param_3": "reserved2",
                "param_4": "flags",
                "uVar1": "highBit",
                "uVar2": "inputCopy",
                "uVar3": "result",
                "uVar4": "shiftedInput",
                "uVar5": "shiftedInputCopy",
                "uVar7": "numShiftBits",
                "in_r12": "remainingBits",
                "bVar8": "isZeroShift",
                "bVar9": "isZeroShiftCopy",
                "bVar10": "carryFlag",
                "iVar6": "shiftDistance"
            },
            "calling": [
                "FUN_08004d78",
                "FUN_08004f78",
                "FUN_08004bd8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004c8": {
            "entrypoint": "0x080004c8",
            "current_name": "calculate_floating_point_value_080004c8",
            "code": "\nulonglong calculateFloatingPointValue_080004c8(undefined4 sign,uint exponent,uint mantissa1,uint mantissa2)\n\n{\n  ulonglong uVar1;\n  longlong product2;\n  uint temp1;\n  uint temp2;\n  int temp3;\n  uint uVar6;\n  uint unaff_r5;\n  uint uVar7;\n  uint uVar8;\n  bool bVar9;\n  bool bVar10;\n  bool bVar11;\n  ulonglong uVar12;\n  \n  uVar12 = CONCAT44(exponent,sign);\n  uVar7 = 0x7ff;\n  temp2 = exponent >> 0x14 & 0x7ff;\n  bVar9 = temp2 == 0;\n  if (!bVar9) {\n    unaff_r5 = mantissa2 >> 0x14 & 0x7ff;\n    bVar9 = unaff_r5 == 0;\n  }\n  if (!bVar9) {\n    bVar9 = temp2 == 0x7ff;\n  }\n  if (!bVar9) {\n    bVar9 = unaff_r5 == 0x7ff;\n  }\n  if (bVar9) {\n    uVar12 = FUN_080006a4();\n  }\n  temp1 = (uint)(uVar12 >> 0x20);\n  temp3 = temp2 + unaff_r5;\n  temp2 = temp1 ^ mantissa2;\n  temp1 = temp1 & ~(uVar7 << 0x15);\n  mantissa2 = mantissa2 & ~(uVar7 << 0x15);\n  bVar9 = ((uint)uVar12 | temp1 << 0xc) == 0;\n  if (!bVar9) {\n    bVar9 = (mantissa1 | mantissa2 << 0xc) == 0;\n  }\n  temp1 = temp1 | 0x100000;\n  mantissa2 = mantissa2 | 0x100000;\n  if (bVar9) {\n    mantissa1 = (uint)uVar12 | mantissa1;\n    mantissa2 = (temp2 & 0x80000000 | temp1) ^ mantissa2;\n    temp2 = uVar7 >> 1;\n    bVar11 = SBORROW4(temp3,temp2);\n    uVar6 = temp3 - temp2;\n    bVar9 = uVar6 == 0;\n    temp1 = uVar6;\n    if (!bVar9 && (int)temp2 <= temp3) {\n      bVar11 = SBORROW4(uVar7,uVar6);\n      temp1 = uVar7 - uVar6;\n      bVar9 = uVar7 == uVar6;\n    }\n    if (!bVar9 && (int)temp1 < 0 == bVar11) {\n      mantissa2 = mantissa2 | uVar6 * 0x100000;\n    }\n    if (!bVar9 && (int)temp1 < 0 == bVar11) {\n      return CONCAT44(mantissa2,mantissa1);\n    }\n    mantissa2 = mantissa2 | 0x100000;\n    uVar7 = 0;\n    bVar11 = SBORROW4(uVar6,1);\n    uVar6 = uVar6 - 1;\n    bVar9 = uVar6 == 0;\n    temp2 = uVar6;\n  }\n  else {\n    uVar1 = (uVar12 & 0xffffffff) * (ulonglong)mantissa1;\n    uVar12 = (uVar12 & 0xffffffff) * (ulonglong)mantissa2 +\n             (ulonglong)temp1 * (ulonglong)mantissa1 + (uVar1 >> 0x20);\n    uVar8 = (uint)uVar12;\n    product2 = (ulonglong)temp1 * (ulonglong)mantissa2 + (uVar12 >> 0x20);\n    uVar7 = (uint)product2;\n    temp1 = (uint)((ulonglong)product2 >> 0x20);\n    if ((int)uVar1 != 0) {\n      uVar8 = uVar8 | 1;\n    }\n    uVar6 = (temp3 + -0x3ff) - (uint)(temp1 < 0x200);\n    if (temp1 < 0x200) {\n      bVar9 = (uVar8 & 0x80000000) != 0;\n      uVar8 = uVar8 << 1;\n      product2 = CONCAT44(temp1 * 2 + (uint)(CARRY4(uVar7,uVar7) || CARRY4(uVar7 * 2,(uint)bVar9)),\n                       uVar7 * 2 + (uint)bVar9);\n    }\n    mantissa2 = temp2 & 0x80000000 | (int)((ulonglong)product2 >> 0x20) << 0xb | (uint)product2 >> 0x15;\n    mantissa1 = (uint)product2 << 0xb | uVar8 >> 0x15;\n    uVar7 = uVar8 * 0x800;\n    bVar10 = 0xfc < uVar6;\n    bVar11 = SBORROW4(uVar6,0xfd);\n    temp1 = uVar6 - 0xfd;\n    bVar9 = temp1 == 0;\n    temp2 = temp1;\n    if (bVar10 && !bVar9) {\n      bVar10 = 0x6ff < temp1;\n      bVar11 = SBORROW4(temp1,0x700);\n      temp2 = uVar6 - 0x7fd;\n      bVar9 = temp1 == 0x700;\n    }\n    if (!bVar10 || bVar9) {\n      bVar9 = 0x7fffffff < uVar7;\n      if (uVar7 == 0x80000000) {\n        bVar9 = (uVar8 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(mantissa2 + uVar6 * 0x100000 + (uint)CARRY4(mantissa1,(uint)bVar9),mantissa1 + bVar9\n                     );\n    }\n  }\n  if (!bVar9 && (int)temp2 < 0 == bVar11) {\n    return (ulonglong)(mantissa2 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  bVar10 = SCARRY4(uVar6,0x36);\n  bVar9 = (int)(uVar6 + 0x36) < 0;\n  bVar11 = uVar6 == 0xffffffca;\n  if (bVar11 || bVar9 != bVar10) {\n    mantissa1 = 0;\n  }\n  if (bVar11 || bVar9 != bVar10) {\n    mantissa2 = mantissa2 & 0x80000000;\n  }\n  if (bVar11 || bVar9 != bVar10) {\n    return CONCAT44(mantissa2,mantissa1);\n  }\n  temp2 = -uVar6;\n  temp1 = temp2 - 0x20;\n  if (0x1f < (int)temp2) {\n    uVar6 = mantissa1 >> (temp1 & 0xff) | mantissa2 << (0x20 - temp1 & 0xff);\n    temp2 = (mantissa2 >> (temp1 & 0xff) & ~((mantissa2 & 0x80000000) >> (temp1 & 0xff))) -\n            ((int)uVar6 >> 0x1f);\n    if ((uVar7 | mantissa1 << (0x20 - temp1 & 0xff) | uVar6 << 1) == 0) {\n      temp2 = temp2 & ~(uVar6 >> 0x1f);\n    }\n    return CONCAT44(mantissa2,temp2) & 0x80000000ffffffff;\n  }\n  temp3 = temp2 - 0x14;\n  if (temp3 == 0 || temp3 < 0 != SCARRY4(temp1,0xc)) {\n    uVar8 = mantissa1 << (uVar6 + 0x20 & 0xff);\n    temp1 = mantissa1 >> (temp2 & 0xff) | mantissa2 << (uVar6 + 0x20 & 0xff);\n    uVar6 = temp1 + -((int)uVar8 >> 0x1f);\n    if ((uVar7 | uVar8 << 1) == 0) {\n      uVar6 = uVar6 & ~(uVar8 >> 0x1f);\n    }\n    return CONCAT44((mantissa2 & 0x80000000) +\n                    ((mantissa2 & 0x7fffffff) >> (temp2 & 0xff)) +\n                    (uint)CARRY4(temp1,-((int)uVar8 >> 0x1f)),uVar6);\n  }\n  temp2 = 0xc - temp3;\n  uVar6 = mantissa1 << (temp2 & 0xff);\n  temp2 = mantissa1 >> (0x20 - temp2 & 0xff) | mantissa2 << (temp2 & 0xff);\n  temp1 = temp2 + -((int)uVar6 >> 0x1f);\n  if ((uVar7 | uVar6 << 1) == 0) {\n    temp1 = temp1 & ~(uVar6 >> 0x1f);\n  }\n  return CONCAT44((mantissa2 & 0x80000000) + (uint)CARRY4(temp2,-((int)uVar6 >> 0x1f)),temp1);\n}\n\n",
            "renaming": {
                "FUN_080004c8": "calculate_floating_point_value_080004c8",
                "param_1": "sign",
                "param_2": "exponent",
                "param_3": "mantissa1",
                "param_4": "mantissa2",
                "lVar2": "product2",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "iVar5": "temp3"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8",
                "FUN_08004d78",
                "FUN_080059f0",
                "FUN_080096e0",
                "FUN_08004bd8"
            ],
            "called": [
                "FUN_080006a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006a4": {
            "entrypoint": "0x080006a4",
            "current_name": "compute_bitwise_operation_080006a4",
            "code": "\nulonglong compute_bitwise_operation_080006a4(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint bit_1;\n  uint bit_2;\n  uint bit_3;\n  uint bit_4;\n  uint bit_5;\n  bool is_zero;\n  \n  bit_3 = bit_5 & input_4 >> 0x14;\n  if (bit_2 != bit_5 && bit_3 != bit_5) {\n    is_zero = (input_1 | input_2 << 1) == 0;\n    if (!is_zero) {\n      is_zero = (input_3 | input_4 << 1) == 0;\n    }\n    if (is_zero) {\n      return (ulonglong)((input_2 ^ input_4) & 0x80000000) << 0x20;\n    }\n    if (bit_2 == 0) {\n      bit_4 = input_2 & 0x80000000;\n      do {\n        bit_1 = input_1 & 0x80000000;\n        input_1 = input_1 << 1;\n        input_2 = input_2 * 2 + (uint)(bit_1 != 0);\n      } while ((input_2 & 0x100000) == 0);\n      input_2 = input_2 | bit_4;\n      if (bit_3 != 0) {\n        return CONCAT44(input_2,input_1);\n      }\n    }\n    do {\n      bit_3 = input_3 & 0x80000000;\n      input_3 = input_3 << 1;\n      input_4 = input_4 * 2 + (uint)(bit_3 != 0);\n    } while ((input_4 & 0x100000) == 0);\n    return CONCAT44(input_2,input_1);\n  }\n  is_zero = (input_1 | input_2 << 1) == 0;\n  if (is_zero) {\n    input_2 = input_4;\n    input_1 = input_3;\n  }\n  if (!is_zero) {\n    is_zero = (input_3 | input_4 << 1) == 0;\n  }\n  bit_4 = input_2;\n  if (((!is_zero) && ((bit_2 != bit_5 || ((input_1 | input_2 << 0xc) == 0)))) &&\n     ((bit_3 != bit_5 || (input_1 = input_3, bit_4 = input_4, (input_3 | input_4 << 0xc) == 0)))) {\n    return (ulonglong)((input_2 ^ input_4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(bit_4,input_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006a4": "compute_bitwise_operation_080006a4",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "bit_1",
                "unaff_r4": "bit_2",
                "uVar2": "bit_3",
                "uVar3": "bit_4",
                "in_r12": "bit_5",
                "bVar4": "is_zero"
            },
            "calling": [
                "FUN_080004c8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800071c": {
            "entrypoint": "0x0800071c",
            "current_name": "calculate_float_0800071c",
            "code": "\nulonglong calculateFloat_0800071c(undefined4 float1,uint float2,uint float3,uint float4)\n\n{\n  uint shift1;\n  uint shift2;\n  uint shift3;\n  uint shift4;\n  uint remainder1;\n  uint remainder2;\n  uint exponent1;\n  int exponentDifference;\n  uint bits;\n  uint exponent2;\n  uint fraction1;\n  uint fraction2;\n  uint temp1;\n  uint temp2;\n  bool isZero1;\n  bool isZero2;\n  bool isNegative;\n  undefined8 shift17;\n  \n  shift17 = CONCAT44(float2,float1);\n  temp2 = 0x7ff;\n  exponent1 = float2 >> 0x14 & 0x7ff;\n  isZero1 = exponent1 == 0;\n  if (!isZero1) {\n    exponent2 = float4 >> 0x14 & 0x7ff;\n    isZero1 = exponent2 == 0;\n  }\n  if (!isZero1) {\n    isZero1 = exponent1 == 0x7ff;\n  }\n  if (!isZero1) {\n    isZero1 = exponent2 == 0x7ff;\n  }\n  if (isZero1) {\n    shift17 = FUN_0800088a();\n  }\n  bits = (uint)((ulonglong)shift17 >> 0x20);\n  fraction2 = (uint)shift17;\n  exponentDifference = exponent1 - exponent2;\n  if ((float3 | float4 << 0xc) == 0) {\n    exponent1 = (bits ^ float4) & 0x80000000 | bits & 0xfffff;\n    isNegative = SCARRY4(exponentDifference,temp2 >> 1);\n    bits = exponentDifference + (temp2 >> 1);\n    isZero1 = (int)bits < 0;\n    isZero2 = bits == 0;\n    if (!isZero2 && isZero1 == isNegative) {\n      isNegative = SBORROW4(temp2,bits);\n      isZero1 = (int)(temp2 - bits) < 0;\n      isZero2 = temp2 == bits;\n    }\n    if (!isZero2 && isZero1 == isNegative) {\n      exponent1 = exponent1 | bits * 0x100000;\n    }\n    if (!isZero2 && isZero1 == isNegative) {\n      return CONCAT44(exponent1,fraction2);\n    }\n    exponent1 = exponent1 | 0x100000;\n    temp2 = 0;\n    isZero2 = SBORROW4(bits,1);\n    bits = bits - 1;\n    isZero1 = bits == 0;\n    shift3 = bits;\n  }\n  else {\n    shift3 = (float4 << 0xc) >> 4 | 0x10000000 | float3 >> 0x18;\n    temp2 = float3 << 8;\n    fraction1 = (bits << 0xc) >> 4 | 0x10000000 | fraction2 >> 0x18;\n    fraction2 = fraction2 * 0x100;\n    exponent1 = (bits ^ float4) & 0x80000000;\n    isZero1 = shift3 <= fraction1;\n    if (fraction1 == shift3) {\n      isZero1 = temp2 <= fraction2;\n    }\n    exponentDifference = exponentDifference + (uint)isZero1;\n    bits = exponentDifference + 0x3fd;\n    if (isZero1 == false) {\n      shift3 = shift3 >> 1;\n      temp2 = (uint)((float3 >> 0x18 & 1) != 0) << 0x1f | temp2 >> 1;\n    }\n    temp1 = fraction2 - temp2;\n    fraction1 = (fraction1 - shift3) - (uint)(fraction2 < temp2);\n    shift4 = shift3 >> 1;\n    shift1 = (uint)((shift3 & 1) != 0) << 0x1f | temp2 >> 1;\n    fraction2 = 0x100000;\n    shift3 = 0x80000;\n    while( true ) {\n      isZero1 = shift1 <= temp1;\n      if (shift4 < fraction1 || fraction1 - shift4 < (uint)isZero1) {\n        temp1 = temp1 - shift1;\n        fraction2 = fraction2 | shift3;\n        fraction1 = (fraction1 - shift4) - (uint)!isZero1;\n      }\n      remainder1 = shift4 >> 1;\n      shift1 = (uint)((shift4 & 1) != 0) << 0x1f | shift1 >> 1;\n      isZero2 = shift1 <= temp1;\n      isZero1 = fraction1 - remainder1 < (uint)isZero2;\n      temp2 = fraction1;\n      if (remainder1 < fraction1 || isZero1) {\n        temp1 = temp1 - shift1;\n        temp2 = (fraction1 - remainder1) - (uint)!isZero2;\n      }\n      if (remainder1 < fraction1 || isZero1) {\n        fraction2 = fraction2 | shift3 >> 1;\n      }\n      fraction1 = shift4 >> 2;\n      shift2 = (uint)((remainder1 & 1) != 0) << 0x1f | shift1 >> 1;\n      isZero2 = shift2 <= temp1;\n      isZero1 = temp2 - fraction1 < (uint)isZero2;\n      remainder1 = temp2;\n      if (fraction1 < temp2 || isZero1) {\n        temp1 = temp1 - shift2;\n        remainder1 = (temp2 - fraction1) - (uint)!isZero2;\n      }\n      if (fraction1 < temp2 || isZero1) {\n        fraction2 = fraction2 | shift3 >> 2;\n      }\n      remainder2 = shift4 >> 3;\n      shift1 = (uint)((fraction1 & 1) != 0) << 0x1f | shift2 >> 1;\n      isZero2 = shift1 <= temp1;\n      isZero1 = remainder1 - remainder2 < (uint)isZero2;\n      fraction1 = remainder1;\n      if (remainder2 < remainder1 || isZero1) {\n        temp1 = temp1 - shift1;\n        fraction1 = (remainder1 - remainder2) - (uint)!isZero2;\n      }\n      if (remainder2 < remainder1 || isZero1) {\n        fraction2 = fraction2 | shift3 >> 3;\n      }\n      temp2 = fraction1 | temp1;\n      if (temp2 == 0) break;\n      fraction1 = fraction1 << 4 | temp1 >> 0x1c;\n      temp1 = temp1 << 4;\n      shift4 = shift4 & 0xfffffff8 | shift1 >> 0x1d;\n      shift1 = (shift2 >> 1) << 3;\n      shift3 = shift3 >> 4;\n      if (shift3 == 0) {\n        remainder2 = shift4;\n        if ((exponent1 & 0x100000) != 0) goto LAB_0800083a;\n        exponent1 = exponent1 | fraction2;\n        fraction2 = 0;\n        shift3 = 0x80000000;\n      }\n    }\n    if ((exponent1 & 0x100000) == 0) {\n      exponent1 = exponent1 | fraction2;\n      fraction2 = 0;\n    }\nLAB_0800083a:\n    isNegative = 0xfc < bits;\n    isZero2 = SBORROW4(bits,0xfd);\n    shift4 = exponentDifference + 0x300;\n    isZero1 = shift4 == 0;\n    shift3 = shift4;\n    if (isNegative && !isZero1) {\n      isNegative = 0x6ff < shift4;\n      isZero2 = SBORROW4(shift4,0x700);\n      shift3 = exponentDifference - 0x400;\n      isZero1 = shift4 == 0x700;\n    }\n    if (!isNegative || isZero1) {\n      isZero1 = remainder2 <= fraction1;\n      if (fraction1 == remainder2) {\n        isZero1 = shift1 <= temp1;\n      }\n      if (fraction1 == remainder2 && temp1 == shift1) {\n        isZero1 = (fraction2 & 1) != 0;\n      }\n      return CONCAT44(exponent1 + bits * 0x100000 + (uint)CARRY4(fraction2,(uint)isZero1),fraction2 + isZero1);\n    }\n  }\n  if (!isZero1 && (int)shift3 < 0 == isZero2) {\n    return (ulonglong)(exponent1 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  isNegative = SCARRY4(bits,0x36);\n  isZero1 = (int)(bits + 0x36) < 0;\n  isZero2 = bits == 0xffffffca;\n  if (isZero2 || isZero1 != isNegative) {\n    fraction2 = 0;\n  }\n  if (isZero2 || isZero1 != isNegative) {\n    exponent1 = exponent1 & 0x80000000;\n  }\n  if (isZero2 || isZero1 != isNegative) {\n    return CONCAT44(exponent1,fraction2);\n  }\n  shift3 = -bits;\n  fraction1 = shift3 - 0x20;\n  if (0x1f < (int)shift3) {\n    shift3 = fraction2 >> (fraction1 & 0xff) | exponent1 << (0x20 - fraction1 & 0xff);\n    bits = (exponent1 >> (fraction1 & 0xff) & ~((exponent1 & 0x80000000) >> (fraction1 & 0xff))) -\n            ((int)shift3 >> 0x1f);\n    if ((temp2 | fraction2 << (0x20 - fraction1 & 0xff) | shift3 << 1) == 0) {\n      bits = bits & ~(shift3 >> 0x1f);\n    }\n    return CONCAT44(exponent1,bits) & 0x80000000ffffffff;\n  }\n  exponentDifference = shift3 - 0x14;\n  if (exponentDifference != 0 && exponentDifference < 0 == SCARRY4(fraction1,0xc)) {\n    bits = 0xc - exponentDifference;\n    shift3 = fraction2 << (bits & 0xff);\n    fraction2 = fraction2 >> (0x20 - bits & 0xff) | exponent1 << (bits & 0xff);\n    bits = fraction2 + -((int)shift3 >> 0x1f);\n    if ((temp2 | shift3 << 1) == 0) {\n      bits = bits & ~(shift3 >> 0x1f);\n    }\n    return CONCAT44((exponent1 & 0x80000000) + (uint)CARRY4(fraction2,-((int)shift3 >> 0x1f)),bits);\n  }\n  fraction1 = fraction2 << (bits + 0x20 & 0xff);\n  fraction2 = fraction2 >> (shift3 & 0xff) | exponent1 << (bits + 0x20 & 0xff);\n  bits = fraction2 + -((int)fraction1 >> 0x1f);\n  if ((temp2 | fraction1 << 1) == 0) {\n    bits = bits & ~(fraction1 >> 0x1f);\n  }\n  return CONCAT44((exponent1 & 0x80000000) +\n                  ((exponent1 & 0x7fffffff) >> (shift3 & 0xff)) +\n                  (uint)CARRY4(fraction2,-((int)fraction1 >> 0x1f)),bits);\n}\n\n",
            "renaming": {
                "FUN_0800071c": "calculate_float_0800071c",
                "param_1": "float1",
                "param_2": "float2",
                "param_3": "float3",
                "param_4": "float4",
                "uVar1": "shift1",
                "uVar2": "shift2",
                "uVar3": "shift3",
                "uVar4": "shift4",
                "uVar5": "remainder1",
                "uVar6": "remainder2",
                "uVar7": "exponent1",
                "iVar8": "exponentDifference",
                "uVar9": "bits",
                "unaff_r5": "exponent2",
                "uVar10": "fraction1",
                "uVar11": "fraction2",
                "uVar12": "temp1",
                "uVar13": "temp2",
                "bVar14": "isZero1",
                "bVar15": "isZero2",
                "bVar16": "isNegative"
            },
            "calling": [
                "FUN_080079e8",
                "FUN_08004d78",
                "FUN_08005838",
                "FUN_080059f0",
                "FUN_08004bd8"
            ],
            "called": [
                "FUN_0800088a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800088a": {
            "entrypoint": "0x0800088a",
            "current_name": "decode_and_convert_0800088a",
            "code": "\nulonglong decode_and_convert_0800088a(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint bit1;\n  uint unused;\n  uint shifted_part;\n  uint converted_input2;\n  uint constant;\n  bool check_result;\n  \n  shifted_part = constant & input4 >> 0x14;\n  converted_input2 = input2;\n  if (unused != constant || shifted_part != constant) {\n    if (unused == constant) {\n      if (((input1 | input2 << 0xc) == 0) && (input1 = input3, converted_input2 = input4, shifted_part != constant)\n         ) {\nLAB_080006fc:\n        return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (shifted_part == constant) {\n      input1 = input3;\n      converted_input2 = input4;\n      if ((input3 | input4 << 0xc) == 0) {\nLAB_080006c0:\n        return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      check_result = (input1 | input2 << 1) == 0;\n      if (!check_result) {\n        check_result = (input3 | input4 << 1) == 0;\n      }\n      if (!check_result) {\n        if (unused == 0) {\n          converted_input2 = input2 & 0x80000000;\n          do {\n            bit1 = input1 & 0x80000000;\n            input1 = input1 << 1;\n            input2 = input2 * 2 + (uint)(bit1 != 0);\n          } while ((input2 & 0x100000) == 0);\n          input2 = input2 | converted_input2;\n          if (shifted_part != 0) {\n            return CONCAT44(input2,input1);\n          }\n        }\n        do {\n          converted_input2 = input3 & 0x80000000;\n          input3 = input3 << 1;\n          input4 = input4 * 2 + (uint)(converted_input2 != 0);\n        } while ((input4 & 0x100000) == 0);\n        return CONCAT44(input2,input1);\n      }\n      if ((input1 | input2 << 1) != 0) goto LAB_080006fc;\n      if ((input3 | input4 << 1) != 0) goto LAB_080006c0;\n    }\n  }\n  return CONCAT44(converted_input2,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_0800088a": "decode_and_convert_0800088a",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "bit1",
                "unaff_r4": "unused",
                "uVar2": "shifted_part",
                "uVar3": "converted_input2",
                "in_r12": "constant",
                "bVar4": "check_result"
            },
            "calling": [
                "FUN_0800071c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008fc": {
            "entrypoint": "0x080008fc",
            "current_name": "check_parameters_080008fc",
            "code": "\nuint check_parameters_080008fc(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint result;\n  bool isZero;\n  bool isGreater;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (value1 | value2 << 1) == 0;\n  if (isZero) {\n    isZero = (value3 | value4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = value2 == value4;\n  }\n  if (isZero) {\n    isZero = value1 == value3;\n  }\n  if (!isZero) {\n    result = value2 ^ value4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = value2 == value4;\n    }\n    isGreater = -1 < (int)result && value4 <= value2;\n    if (isZero) {\n      isGreater = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!isGreater) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008fc": "check_parameters_080008fc",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isGreater"
            },
            "calling": [
                "FUN_08000988"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000978": {
            "entrypoint": "0x08000978",
            "current_name": "execute_function_08000978",
            "code": "\nvoid execute_function_08000978(undefined4 arg1,undefined4 arg2,undefined4 arg3,undefined4 arg4)\n\n{\n  FUN_08000988(arg3,arg4,arg1,arg2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000978": "execute_function_08000978",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4"
            },
            "calling": [
                "FUN_080009d4",
                "FUN_080009e8"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000988": {
            "entrypoint": "0x08000988",
            "current_name": "initialize_08000988",
            "code": "\nundefined4 initialize_08000988(undefined4 input_value)\n\n{\n  FUN_080008fc();\n  return input_value;\n}\n\n",
            "renaming": {
                "FUN_08000988": "initialize_08000988",
                "param_1": "input_value"
            },
            "calling": [
                "FUN_080009ac",
                "FUN_08000998",
                "FUN_08000978",
                "FUN_080009c0"
            ],
            "called": [
                "FUN_080008fc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "check_if_null_char_present_08000998",
            "code": "\nbool check_if_null_char_present_08000998(void)\n\n{\n  char input_char;\n  \n  FUN_08000988();\n  return input_char != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000998": "check_if_null_char_present_08000998",
                "in_ZR": "input_char"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009ac": {
            "entrypoint": "0x080009ac",
            "current_name": "check_if_input_is_null_terminated_080009ac",
            "code": "\nbool checkIfInputIsNullTerminated_080009ac(void)\n\n{\n  char inputCharacter;\n  \n  FUN_08000988();\n  return inputCharacter == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009ac": "check_if_input_is_null_terminated_080009ac",
                "in_CY": "inputCharacter"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c0": {
            "entrypoint": "0x080009c0",
            "current_name": "check_input_conditions_080009c0",
            "code": "\nbool check_input_conditions_080009c0(void)\n\n{\n  undefined zero_flag;\n  undefined carry_flag;\n  \n  FUN_08000988();\n  return !(bool)carry_flag || (bool)zero_flag;\n}\n\n",
            "renaming": {
                "FUN_080009c0": "check_input_conditions_080009c0",
                "in_ZR": "zero_flag",
                "in_CY": "carry_flag"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009d4": {
            "entrypoint": "0x080009d4",
            "current_name": "check_zero_flags_080009d4",
            "code": "\nbool check_zero_flags_080009d4(void)\n\n{\n  undefined zero_flag;\n  undefined carry_flag;\n  \n  FUN_08000978();\n  return !(bool)carry_flag || (bool)zero_flag;\n}\n\n",
            "renaming": {
                "FUN_080009d4": "check_zero_flags_080009d4",
                "in_ZR": "zero_flag",
                "in_CY": "carry_flag"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08000978"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009e8": {
            "entrypoint": "0x080009e8",
            "current_name": "check_if_string_is_empty_080009e8",
            "code": "\nbool check_if_string_is_empty_080009e8(void)\n\n{\n  char input_char;\n  \n  FUN_08000978();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009e8": "check_if_string_is_empty_080009e8",
                "in_CY": "input_char"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8",
                "FUN_080059f0"
            ],
            "called": [
                "FUN_08000978"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009fc": {
            "entrypoint": "0x080009fc",
            "current_name": "calculate_inverse_080009fc",
            "code": "\nuint calculateInverse_080009fc(uint inputValue,uint multiplier)\n\n{\n  uint result;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  bool isZero;\n  bool isLessThan;\n  \n  temp1 = multiplier * 2;\n  isLessThan = temp1 < 0x70000000;\n  temp2 = temp1 + 0x90000000;\n  result = temp2;\n  if (!isLessThan) {\n    temp3 = temp1 + 0x8fe00000;\n    result = temp3;\n  }\n  isZero = result == 0;\n  if (!isLessThan && temp2 >= 0x200000) {\n    isZero = temp3 == 0x1fc00000;\n  }\n  if (((isLessThan || temp2 < 0x200000) || 0x1fc00000 < temp3) || isZero) {\n    if ((multiplier & 0x40000000) != 0) {\n      if (((int)temp1 >> 0x15 == -1) && ((inputValue | multiplier << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return multiplier & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(temp1 + 0x92e00000) < 0 != isSubtractCarry(temp2,0x2e00000)) {\n      return multiplier & 0x80000000;\n    }\n    temp1 = 0x18 - (temp1 + 0x92e00000 >> 0x15);\n    result = inputValue >> (temp1 & 0xff);\n    if (inputValue << (0x20 - temp1 & 0xff) != 0) {\n      result = result | 1;\n    }\n    temp2 = multiplier & 0x1fffff | 0x100000;\n    inputValue = result | temp2 << (0x20 - temp1 & 0xff);\n    temp2 = (temp2 >> (temp1 & 0xff)) << 1;\n  }\n  result = (multiplier & 0x80000000 | inputValue >> 0x1d) + temp2 * 4 + (uint)(0x7fffffff < inputValue * 8);\n  if (inputValue * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080009fc": "calculate_inverse_080009fc",
                "param_1": "inputValue",
                "param_2": "multiplier",
                "uVar1": "result",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "in_r12": "temp3",
                "bVar4": "isZero",
                "bVar5": "isLessThan",
                "SCARRY4": "isSubtractCarry"
            },
            "calling": [
                "FUN_08004d78",
                "FUN_08004bd8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa4": {
            "entrypoint": "0x08000aa4",
            "current_name": "calculate_float_08000aa4",
            "code": "\nuint calculateFloat_08000aa4(uint input1,uint input2,undefined4 input3,uint input4)\n\n{\n  int shiftAmount1;\n  int shiftAmount2;\n  uint bitwiseXorResult;\n  uint tempVar1;\n  uint shiftedInput1;\n  uint shiftedInput2;\n  uint difference;\n  bool flag;\n  \n  bitwiseXorResult = input2 ^ 0x80000000;\n  shiftedInput1 = input1 << 1;\n  flag = shiftedInput1 == 0;\n  if (!flag) {\n    input4 = input2 << 1;\n    flag = input4 == 0;\n  }\n  if (!flag) {\n    flag = shiftedInput1 == input4;\n  }\n  shiftAmount1 = (int)shiftedInput1 >> 0x18;\n  if (!flag) {\n    flag = shiftAmount1 == -1;\n  }\n  if (!flag) {\n    flag = (int)input4 >> 0x18 == -1;\n  }\n  if (flag) {\n    shiftAmount2 = (int)(input2 << 1) >> 0x18;\n    if (shiftAmount1 == -1 || shiftAmount2 == -1) {\n      shiftedInput1 = bitwiseXorResult;\n      if (shiftAmount1 == -1) {\n        shiftedInput1 = input1;\n      }\n      if (shiftAmount1 != -1 || shiftAmount2 != -1) {\n        bitwiseXorResult = shiftedInput1;\n      }\n      flag = (shiftedInput1 & 0x7fffff) == 0;\n      if (flag) {\n        flag = (bitwiseXorResult & 0x7fffff) == 0;\n      }\n      if (flag) {\n        flag = shiftedInput1 == bitwiseXorResult;\n      }\n      if (!flag) {\n        shiftedInput1 = shiftedInput1 | 0x400000;\n      }\n      return shiftedInput1;\n    }\n    if (((input1 ^ bitwiseXorResult) & 0x7fffffff) != 0) {\n      if (shiftedInput1 == 0) {\n        input1 = bitwiseXorResult;\n      }\n      return input1;\n    }\n    if (input1 != bitwiseXorResult) {\n      return 0;\n    }\n    if ((shiftedInput1 & 0xff000000) == 0) {\n      bitwiseXorResult = input1 << 1;\n      if ((input1 & 0x80000000) != 0) {\n        bitwiseXorResult = bitwiseXorResult | 0x80000000;\n      }\n      return bitwiseXorResult;\n    }\n    if (shiftedInput1 < 0xfe000000) {\n      return input1 + 0x800000;\n    }\n    input1 = input1 & 0x80000000;\nLAB_08000bde:\n    return input1 | 0x7f800000;\n  }\n  shiftedInput1 = shiftedInput1 >> 0x18;\n  input4 = input4 >> 0x18;\n  difference = input4 - shiftedInput1;\n  flag = difference != 0;\n  shiftedInput2 = shiftedInput1;\n  if (flag && shiftedInput1 <= input4) {\n    shiftedInput2 = shiftedInput1 + difference;\n  }\n  if (flag && shiftedInput1 <= input4) {\n    bitwiseXorResult = bitwiseXorResult ^ input1;\n  }\n  if (flag && shiftedInput1 <= input4) {\n    input1 = input1 ^ bitwiseXorResult;\n  }\n  if (flag && shiftedInput1 <= input4) {\n    bitwiseXorResult = bitwiseXorResult ^ input1;\n  }\n  if (input4 < shiftedInput1) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return input1;\n  }\n  shiftedInput1 = input1 & 0xffffff | 0x800000;\n  if ((input1 & 0x80000000) != 0) {\n    shiftedInput1 = -shiftedInput1;\n  }\n  tempVar1 = bitwiseXorResult & 0xffffff | 0x800000;\n  if ((bitwiseXorResult & 0x80000000) != 0) {\n    tempVar1 = -tempVar1;\n  }\n  if (shiftedInput2 == difference) {\n    tempVar1 = tempVar1 ^ 0x800000;\n    if (shiftedInput2 == 0) {\n      shiftedInput1 = shiftedInput1 ^ 0x800000;\n      shiftedInput2 = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  shiftedInput1 = shiftedInput1 + ((int)tempVar1 >> (difference & 0xff));\n  tempVar1 = tempVar1 << (0x20 - difference & 0xff);\n  input1 = shiftedInput1 & 0x80000000;\n  if ((int)shiftedInput1 < 0) {\n    flag = tempVar1 != 0;\n    tempVar1 = -tempVar1;\n    shiftedInput1 = -shiftedInput1 - (uint)flag;\n  }\n  if (shiftedInput1 < 0x800000) {\n    bitwiseXorResult = tempVar1 & 0x80000000;\n    tempVar1 = tempVar1 << 1;\n    shiftedInput1 = shiftedInput1 * 2 + (uint)(bitwiseXorResult != 0);\n    bitwiseXorResult = shiftedInput2 - 2;\n    if ((shiftedInput1 & 0x800000) == 0) {\n      difference = LZCOUNT(shiftedInput1) - 8;\n      shiftedInput1 = shiftedInput1 << (difference & 0xff);\n      if ((int)bitwiseXorResult < (int)difference) {\n        shiftedInput1 = shiftedInput1 >> (-(bitwiseXorResult - difference) & 0xff);\n      }\n      else {\n        shiftedInput1 = shiftedInput1 + (bitwiseXorResult - difference) * 0x800000;\n      }\n      return shiftedInput1 | input1;\n    }\n  }\n  else {\n    bitwiseXorResult = shiftedInput2 - 1;\n    if (0xffffff < shiftedInput1) {\n      bitwiseXorResult = shiftedInput1 & 1;\n      shiftedInput1 = shiftedInput1 >> 1;\n      tempVar1 = (uint)(bitwiseXorResult != 0) << 0x1f | tempVar1 >> 1;\n      bitwiseXorResult = shiftedInput2;\n      if (0xfd < shiftedInput2) goto LAB_08000bde;\n    }\n  }\n  shiftedInput1 = shiftedInput1 + bitwiseXorResult * 0x800000 + (uint)(0x7fffffff < tempVar1);\n  if (tempVar1 == 0x80000000) {\n    shiftedInput1 = shiftedInput1 & 0xfffffffe;\n  }\n  return shiftedInput1 | input1;\n}\n\n",
            "renaming": {
                "FUN_08000aa4": "calculate_float_08000aa4",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shiftAmount1",
                "iVar2": "shiftAmount2",
                "uVar3": "bitwiseXorResult",
                "uVar4": "tempVar1",
                "uVar5": "shiftedInput1",
                "uVar6": "shiftedInput2",
                "uVar7": "difference",
                "bVar8": "flag"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_08004bd8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa8": {
            "entrypoint": "0x08000aa8",
            "current_name": "calculate_floating_point_08000aa8",
            "code": "\nuint calculateFloatingPoint_08000aa8(uint input1,uint input2,undefined4 variable1,uint variable2)\n\n{\n  int iVar1;\n  int iVar2;\n  uint output1;\n  uint output2;\n  uint output3;\n  uint output4;\n  bool isZero;\n  \n  output2 = input1 << 1;\n  isZero = output2 == 0;\n  if (!isZero) {\n    variable2 = input2 << 1;\n    isZero = variable2 == 0;\n  }\n  if (!isZero) {\n    isZero = output2 == variable2;\n  }\n  iVar1 = (int)output2 >> 0x18;\n  if (!isZero) {\n    isZero = iVar1 == -1;\n  }\n  if (!isZero) {\n    isZero = (int)variable2 >> 0x18 == -1;\n  }\n  if (isZero) {\n    iVar2 = (int)(input2 << 1) >> 0x18;\n    if (iVar1 == -1 || iVar2 == -1) {\n      output2 = input2;\n      if (iVar1 == -1) {\n        output2 = input1;\n      }\n      if (iVar1 != -1 || iVar2 != -1) {\n        input2 = output2;\n      }\n      isZero = (output2 & 0x7fffff) == 0;\n      if (isZero) {\n        isZero = (input2 & 0x7fffff) == 0;\n      }\n      if (isZero) {\n        isZero = output2 == input2;\n      }\n      if (!isZero) {\n        output2 = output2 | 0x400000;\n      }\n      return output2;\n    }\n    if (((input1 ^ input2) & 0x7fffffff) != 0) {\n      if (output2 == 0) {\n        input1 = input2;\n      }\n      return input1;\n    }\n    if (input1 != input2) {\n      return 0;\n    }\n    if ((output2 & 0xff000000) == 0) {\n      output2 = input1 << 1;\n      if ((input1 & 0x80000000) != 0) {\n        output2 = output2 | 0x80000000;\n      }\n      return output2;\n    }\n    if (output2 < 0xfe000000) {\n      return input1 + 0x800000;\n    }\n    input1 = input1 & 0x80000000;\nLAB_08000bde:\n    return input1 | 0x7f800000;\n  }\n  output2 = output2 >> 0x18;\n  variable2 = variable2 >> 0x18;\n  output4 = variable2 - output2;\n  isZero = output4 != 0;\n  output3 = output2;\n  if (isZero && output2 <= variable2) {\n    output3 = output2 + output4;\n  }\n  if (isZero && output2 <= variable2) {\n    input2 = input2 ^ input1;\n  }\n  if (isZero && output2 <= variable2) {\n    input1 = input1 ^ input2;\n  }\n  if (isZero && output2 <= variable2) {\n    input2 = input2 ^ input1;\n  }\n  if (variable2 < output2) {\n    output4 = -output4;\n  }\n  if (0x19 < output4) {\n    return input1;\n  }\n  output2 = input1 & 0xffffff | 0x800000;\n  if ((input1 & 0x80000000) != 0) {\n    output2 = -output2;\n  }\n  output1 = input2 & 0xffffff | 0x800000;\n  if ((input2 & 0x80000000) != 0) {\n    output1 = -output1;\n  }\n  if (output3 == output4) {\n    output1 = output1 ^ 0x800000;\n    if (output3 == 0) {\n      output2 = output2 ^ 0x800000;\n      output3 = 1;\n    }\n    else {\n      output4 = output4 - 1;\n    }\n  }\n  output2 = output2 + ((int)output1 >> (output4 & 0xff));\n  output1 = output1 << (0x20 - output4 & 0xff);\n  input1 = output2 & 0x80000000;\n  if ((int)output2 < 0) {\n    isZero = output1 != 0;\n    output1 = -output1;\n    output2 = -output2 - (uint)isZero;\n  }\n  if (output2 < 0x800000) {\n    output4 = output1 & 0x80000000;\n    output1 = output1 << 1;\n    output2 = output2 * 2 + (uint)(output4 != 0);\n    output4 = output3 - 2;\n    if ((output2 & 0x800000) == 0) {\n      output3 = LZCOUNT(output2) - 8;\n      output2 = output2 << (output3 & 0xff);\n      if ((int)output4 < (int)output3) {\n        output2 = output2 >> (-(output4 - output3) & 0xff);\n      }\n      else {\n        output2 = output2 + (output4 - output3) * 0x800000;\n      }\n      return output2 | input1;\n    }\n  }\n  else {\n    output4 = output3 - 1;\n    if (0xffffff < output2) {\n      output4 = output2 & 1;\n      output2 = output2 >> 1;\n      output1 = (uint)(output4 != 0) << 0x1f | output1 >> 1;\n      output4 = output3;\n      if (0xfd < output3) goto LAB_08000bde;\n    }\n  }\n  output2 = output2 + output4 * 0x800000 + (uint)(0x7fffffff < output1);\n  if (output1 == 0x80000000) {\n    output2 = output2 & 0xfffffffe;\n  }\n  return output2 | input1;\n}\n\n",
            "renaming": {
                "FUN_08000aa8": "calculate_floating_point_08000aa8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "variable1",
                "param_4": "variable2",
                "uVar3": "output1",
                "uVar4": "output2",
                "uVar5": "output3",
                "uVar6": "output4",
                "bVar7": "isZero"
            },
            "calling": [
                "FUN_080049cc",
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c08": {
            "entrypoint": "0x08000c08",
            "current_name": "calculate_result_08000c08",
            "code": "\nuint calculateResult_08000c08(uint input)\n\n{\n  uint leadingZeros;\n  uint shiftAmount;\n  int tempValue;\n  uint maskValue;\n  \n  if (input == 0) {\n    return 0;\n  }\n  leadingZeros = LZCOUNT(input);\n  shiftAmount = leadingZeros - 8;\n  tempValue = shiftAmount * -0x800000 + 0x4a800000;\n  if (7 < leadingZeros) {\n    maskValue = 0 << (shiftAmount & 0xff);\n    leadingZeros = tempValue + (input << (shiftAmount & 0xff)) +\n            (0U >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < maskValue);\n    if (maskValue == 0x80000000) {\n      leadingZeros = leadingZeros & 0xfffffffe;\n    }\n    return leadingZeros;\n  }\n  shiftAmount = input << leadingZeros + 0x18;\n  leadingZeros = tempValue + ((input >> (0x20 - (leadingZeros + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n  if ((shiftAmount & 0x7fffffff) == 0) {\n    leadingZeros = leadingZeros & ~(shiftAmount >> 0x1f);\n  }\n  return leadingZeros;\n}\n\n",
            "renaming": {
                "FUN_08000c08": "calculate_result_08000c08",
                "param_1": "input",
                "uVar1": "leadingZeros",
                "uVar2": "shiftAmount",
                "iVar3": "tempValue",
                "uVar4": "maskValue"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c10": {
            "entrypoint": "0x08000c10",
            "current_name": "count_leading_zeros_08000c10",
            "code": "\nuint countLeadingZeros_08000c10(uint input)\n\n{\n  uint leadingZeros;\n  uint shiftedValue;\n  uint signBit;\n  int result;\n  \n  signBit = input & 0x80000000;\n  if ((int)signBit < 0) {\n    input = -input;\n  }\n  if (input == 0) {\n    return 0;\n  }\n  leadingZeros = LZCOUNT(input);\n  shiftedValue = leadingZeros - 8;\n  result = ((signBit | 0x4b000000) - 0x800000) + shiftedValue * -0x800000;\n  if (7 < leadingZeros) {\n    leadingZeros = 0 << (shiftedValue & 0xff);\n    signBit = result + (input << (shiftedValue & 0xff)) +\n            (0U >> (0x20 - shiftedValue & 0xff)) + (uint)(0x7fffffff < leadingZeros);\n    if (leadingZeros == 0x80000000) {\n      signBit = signBit & 0xfffffffe;\n    }\n    return signBit;\n  }\n  shiftedValue = input << leadingZeros + 0x18;\n  signBit = result + ((input >> (0x20 - (leadingZeros + 0x18) & 0xff)) - ((int)shiftedValue >> 0x1f));\n  if ((shiftedValue & 0x7fffffff) == 0) {\n    signBit = signBit & ~(shiftedValue >> 0x1f);\n  }\n  return signBit;\n}\n\n",
            "renaming": {
                "FUN_08000c10": "count_leading_zeros_08000c10",
                "param_1": "input",
                "uVar1": "leadingZeros",
                "uVar2": "shiftedValue",
                "uVar3": "signBit",
                "iVar4": "result"
            },
            "calling": [
                "FUN_080049cc",
                "FUN_08004ae0",
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cb8": {
            "entrypoint": "0x08000cb8",
            "current_name": "calculate_floating_point_08000cb8",
            "code": "\nuint calculateFloatingPoint_08000cb8(uint input1,uint input2,undefined4 param3,uint param4)\n\n{\n  longlong lVar1;\n  uint result;\n  uint shiftCount1;\n  int sumShiftCounts;\n  int additionalShift;\n  uint tempResult;\n  int remainingShifts;\n  uint modifiedInput1;\n  bool isZero1;\n  bool isNegative1;\n  \n  shiftCount1 = input1 >> 0x17 & 0xff;\n  isZero1 = shiftCount1 == 0;\n  if (!isZero1) {\n    param4 = input2 >> 0x17 & 0xff;\n    isZero1 = param4 == 0;\n  }\n  if (!isZero1) {\n    isZero1 = shiftCount1 == 0xff;\n  }\n  if (!isZero1) {\n    isZero1 = param4 == 0xff;\n  }\n  if (isZero1) {\n    param4 = input2 >> 0x17 & 0xff;\n    if (shiftCount1 == 0xff || param4 == 0xff) {\n      isZero1 = input1 == 0 || input1 == 0x80000000;\n      result = input2;\n      if (input1 != 0 && input1 != 0x80000000) {\n        isZero1 = input2 == 0;\n        result = input1;\n      }\n      if (!isZero1) {\n        isZero1 = input2 == 0x80000000;\n      }\n      modifiedInput1 = result;\n      if (((isZero1) || ((shiftCount1 == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((param4 == 0xff && (modifiedInput1 = input2, (input2 & 0x7fffff) != 0)))) {\n        return modifiedInput1 | 0x7fc00000;\n      }\n      result = result ^ input2;\n      goto LAB_08000e08;\n    }\n    isZero1 = (input1 & 0x7fffffff) == 0;\n    if (!isZero1) {\n      isZero1 = (input2 & 0x7fffffff) == 0;\n    }\n    if (isZero1) {\n      return (input1 ^ input2) & 0x80000000;\n    }\n    isZero1 = shiftCount1 == 0;\n    result = input1 & 0x80000000;\n    while( true ) {\n      if (isZero1) {\n        input1 = input1 << 1;\n        isZero1 = (input1 & 0x800000) == 0;\n      }\n      if (!isZero1) break;\n      shiftCount1 = shiftCount1 - 1;\n    }\n    input1 = input1 | result;\n    isZero1 = param4 == 0;\n    result = input2 & 0x80000000;\n    while( true ) {\n      if (isZero1) {\n        input2 = input2 << 1;\n        isZero1 = (input2 & 0x800000) == 0;\n      }\n      if (!isZero1) break;\n      param4 = param4 - 1;\n    }\n    input2 = input2 | result;\n  }\n  sumShiftCounts = shiftCount1 + param4;\n  modifiedInput1 = input1 ^ input2;\n  shiftCount1 = input1 << 9;\n  isZero1 = shiftCount1 == 0;\n  if (!isZero1) {\n    input2 = input2 << 9;\n    isZero1 = input2 == 0;\n  }\n  if (isZero1) {\n    if (shiftCount1 == 0) {\n      input2 = input2 << 9;\n    }\n    result = modifiedInput1 & 0x80000000 | input1 & 0x7fffff | input2 >> 9;\n    isNegative1 = SBORROW4(sumShiftCounts,0x7f);\n    additionalShift = sumShiftCounts + -0x7f;\n    isZero1 = additionalShift == 0;\n    remainingShifts = additionalShift;\n    if (!isZero1 && 0x7e < sumShiftCounts) {\n      isNegative1 = SBORROW4(0xff,additionalShift);\n      remainingShifts = 0xff - additionalShift;\n      isZero1 = additionalShift == 0xff;\n    }\n    if (!isZero1 && remainingShifts < 0 == isNegative1) {\n      result = result | additionalShift * 0x800000;\n    }\n    if (!isZero1 && remainingShifts < 0 == isNegative1) {\n      return result;\n    }\n    result = result | 0x800000;\n    tempResult = 0;\n    isNegative1 = SBORROW4(additionalShift,1);\n    modifiedInput1 = sumShiftCounts - 0x80;\n    isZero1 = modifiedInput1 == 0;\n    shiftCount1 = modifiedInput1;\n  }\n  else {\n    lVar1 = (ulonglong)(shiftCount1 >> 5 | 0x8000000) * (ulonglong)(input2 >> 5 | 0x8000000);\n    tempResult = (uint)lVar1;\n    result = (uint)((ulonglong)lVar1 >> 0x20);\n    isZero1 = result < 0x800000;\n    if (isZero1) {\n      result = result << 1;\n    }\n    if (isZero1) {\n      result = result | tempResult >> 0x1f;\n      tempResult = tempResult << 1;\n    }\n    result = modifiedInput1 & 0x80000000 | result;\n    modifiedInput1 = (sumShiftCounts + -0x7f) - (uint)isZero1;\n    isNegative1 = SBORROW4(modifiedInput1,0xfd);\n    isZero1 = modifiedInput1 == 0xfd;\n    shiftCount1 = modifiedInput1 - 0xfd;\n    if (modifiedInput1 < 0xfe) {\n      result = result + modifiedInput1 * 0x800000 + (uint)(0x7fffffff < tempResult);\n      if (tempResult == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (isZero1 || (int)shiftCount1 < 0 != isNegative1) {\n    isZero1 = (int)(modifiedInput1 + 0x19) < 0;\n    if (modifiedInput1 == 0xffffffe7 || isZero1 != SCARRY4(modifiedInput1,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (modifiedInput1 != 0xffffffe7 && isZero1 == SCARRY4(modifiedInput1,0x19)) {\n      shiftCount1 = (result << 1) >> (-modifiedInput1 & 0xff);\n      modifiedInput1 = result << (modifiedInput1 + 0x20 & 0xff);\n      shiftCount1 = ((uint)((result & 0x80000000) != 0) << 0x1f | shiftCount1 >> 1) + (uint)((byte)shiftCount1 & 1);\n      if ((tempResult | modifiedInput1 << 1) == 0) {\n        shiftCount1 = shiftCount1 & ~(modifiedInput1 >> 0x1f);\n      }\n      return shiftCount1;\n    }\n    return result;\n  }\nLAB_08000e08:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000cb8": "calculate_floating_point_08000cb8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar2": "result",
                "uVar3": "shiftCount1",
                "iVar4": "sumShiftCounts",
                "iVar5": "additionalShift",
                "uVar6": "tempResult",
                "iVar7": "remainingShifts",
                "uVar8": "modifiedInput1",
                "bVar9": "isZero1",
                "bVar10": "isNegative1"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e20": {
            "entrypoint": "0x08000e20",
            "current_name": "floating_point_operation_08000e20",
            "code": "\nuint floatingPointOperation_08000e20(uint input1,uint input2,undefined4 undefined,uint input3)\n\n{\n  uint result1;\n  uint temp1;\n  int temp2;\n  uint temp3;\n  int temp4;\n  uint temp5;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  \n  temp1 = input1 >> 0x17 & 0xff;\n  flag1 = temp1 == 0;\n  if (!flag1) {\n    input3 = input2 >> 0x17 & 0xff;\n    flag1 = input3 == 0;\n  }\n  if (!flag1) {\n    flag1 = temp1 == 0xff;\n  }\n  if (!flag1) {\n    flag1 = input3 == 0xff;\n  }\n  if (flag1) {\n    input3 = input2 >> 0x17 & 0xff;\n    temp5 = input1;\n    if (temp1 == 0xff) {\n      if (((input1 & 0x7fffff) != 0) || (temp5 = input2, input3 == 0xff)) {\nLAB_08000e16:\n        return temp5 | 0x7fc00000;\n      }\n    }\n    else {\n      if (input3 == 0xff) {\n        temp5 = input2;\n        if ((input2 & 0x7fffff) == 0) {\nLAB_08000dcc:\n          return (input1 ^ input2) & 0x80000000;\n        }\n        goto LAB_08000e16;\n      }\n      flag1 = (input1 & 0x7fffffff) == 0;\n      if (!flag1) {\n        flag1 = (input2 & 0x7fffffff) == 0;\n      }\n      if (!flag1) {\n        flag1 = temp1 == 0;\n        temp5 = input1 & 0x80000000;\n        while( true ) {\n          if (flag1) {\n            input1 = input1 << 1;\n            flag1 = (input1 & 0x800000) == 0;\n          }\n          if (!flag1) break;\n          temp1 = temp1 - 1;\n        }\n        input1 = input1 | temp5;\n        flag1 = input3 == 0;\n        temp5 = input2 & 0x80000000;\n        while( true ) {\n          if (flag1) {\n            input2 = input2 << 1;\n            flag1 = (input2 & 0x800000) == 0;\n          }\n          if (!flag1) break;\n          input3 = input3 - 1;\n        }\n        input2 = input2 | temp5;\n        goto LAB_08000e38;\n      }\n      if ((input1 & 0x7fffffff) == 0) {\n        if ((input2 & 0x7fffffff) != 0) goto LAB_08000dcc;\n        goto LAB_08000e16;\n      }\n    }\n    input1 = input1 ^ input2;\n  }\n  else {\nLAB_08000e38:\n    temp2 = temp1 - input3;\n    if (input2 << 9 == 0) {\n      input1 = (input1 ^ input2) & 0x80000000 | input1 & 0x7fffff;\n      flag3 = SCARRY4(temp2,0x7f);\n      temp4 = temp2 + 0x7f;\n      flag1 = temp4 < 0;\n      flag2 = temp4 == 0;\n      if (!flag2 && flag1 == flag3) {\n        flag3 = SBORROW4(0xff,temp4);\n        flag1 = 0xff - temp4 < 0;\n        flag2 = temp4 == 0xff;\n      }\n      if (!flag2 && flag1 == flag3) {\n        input1 = input1 | temp4 * 0x800000;\n      }\n      if (!flag2 && flag1 == flag3) {\n        return input1;\n      }\n      input1 = input1 | 0x800000;\n      temp1 = 0;\n      flag2 = SBORROW4(temp4,1);\n      temp3 = temp2 + 0x7e;\n      flag1 = temp3 == 0;\n      temp5 = temp3;\n    }\n    else {\n      result1 = (input2 << 9) >> 4 | 0x10000000;\n      temp1 = (input1 << 9) >> 4 | 0x10000000;\n      input1 = (input1 ^ input2) & 0x80000000;\n      flag1 = result1 <= temp1;\n      if (!flag1) {\n        temp1 = temp1 << 1;\n      }\n      temp3 = temp2 + 0x7d + (uint)flag1;\n      temp5 = 0x800000;\n      do {\n        if (result1 <= temp1) {\n          temp1 = temp1 - result1;\n          input1 = input1 | temp5;\n        }\n        flag1 = result1 >> 1 <= temp1;\n        if (flag1) {\n          temp1 = temp1 - (result1 >> 1);\n        }\n        if (flag1) {\n          input1 = input1 | temp5 >> 1;\n        }\n        flag1 = result1 >> 2 <= temp1;\n        if (flag1) {\n          temp1 = temp1 - (result1 >> 2);\n        }\n        if (flag1) {\n          input1 = input1 | temp5 >> 2;\n        }\n        flag1 = result1 >> 3 <= temp1;\n        if (flag1) {\n          temp1 = temp1 - (result1 >> 3);\n        }\n        if (flag1) {\n          input1 = input1 | temp5 >> 3;\n        }\n        temp1 = temp1 * 0x10;\n        flag1 = temp1 == 0;\n        if (!flag1) {\n          temp5 = temp5 >> 4;\n          flag1 = temp5 == 0;\n        }\n      } while (!flag1);\n      flag2 = SBORROW4(temp3,0xfd);\n      flag1 = temp3 == 0xfd;\n      temp5 = temp3 - 0xfd;\n      if (temp3 < 0xfe) {\n        input1 = input1 + temp3 * 0x800000 + (uint)(result1 <= temp1);\n        if (temp1 - result1 == 0) {\n          input1 = input1 & 0xfffffffe;\n        }\n        return input1;\n      }\n    }\n    if (flag1 || (int)temp5 < 0 != flag2) {\n      flag1 = (int)(temp3 + 0x19) < 0;\n      if (temp3 == 0xffffffe7 || flag1 != SCARRY4(temp3,0x19)) {\n        input1 = input1 & 0x80000000;\n      }\n      if (temp3 == 0xffffffe7 || flag1 != SCARRY4(temp3,0x19)) {\n        return input1;\n      }\n      temp5 = (input1 << 1) >> (-temp3 & 0xff);\n      temp3 = input1 << (temp3 + 0x20 & 0xff);\n      temp5 = ((uint)((input1 & 0x80000000) != 0) << 0x1f | temp5 >> 1) + (uint)((byte)temp5 & 1);\n      if ((temp1 | temp3 << 1) == 0) {\n        temp5 = temp5 & ~(temp3 >> 0x1f);\n      }\n      return temp5;\n    }\n  }\n  return input1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000e20": "floating_point_operation_08000e20",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "undefined",
                "param_4": "input3",
                "uVar1": "result1",
                "uVar2": "temp1",
                "iVar3": "temp2",
                "uVar4": "temp3",
                "iVar5": "temp4",
                "uVar6": "temp5",
                "bVar7": "flag1",
                "bVar8": "flag2",
                "bVar9": "flag3"
            },
            "calling": [
                "FUN_080049cc",
                "FUN_08004d78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f68": {
            "entrypoint": "0x08000f68",
            "current_name": "check_overflow_and_combine_08000f68",
            "code": "\nuint check_overflow_and_combine_08000f68(uint input_value_1,uint input_value_2)\n\n{\n  bool overflow;\n  uint doubled_value_1;\n  uint doubled_value_2;\n  uint combined_value;\n  bool is_zero;\n  \n  doubled_value_1 = input_value_1 * 2;\n  doubled_value_2 = input_value_2 * 2;\n  if (((int)doubled_value_1 >> 0x18 == -1 || (int)doubled_value_2 >> 0x18 == -1) &&\n     ((((int)doubled_value_1 >> 0x18 == -1 && ((input_value_1 & 0x7fffff) != 0)) ||\n      (((int)doubled_value_2 >> 0x18 == -1 && ((input_value_2 & 0x7fffff) != 0)))))) {\n    result 1;\n  }\n  combined_value = doubled_value_1 | input_value_2 & 0x7fffffff;\n  is_zero = combined_value == 0;\n  if (!is_zero) {\n    combined_value = input_value_1 ^ input_value_2;\n    is_zero = combined_value == 0;\n  }\n  overflow = -1 < (int)combined_value;\n  if (overflow) {\n    input_value_1 = doubled_value_1 + input_value_2 * -2;\n    is_zero = input_value_1 == 0;\n  }\n  if ((overflow && doubled_value_2 <= doubled_value_1) && !is_zero) {\n    input_value_1 = (int)input_value_2 >> 0x1f;\n  }\n  if (!overflow || doubled_value_2 > doubled_value_1) {\n    input_value_1 = ~((int)input_value_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_value_1 = input_value_1 | 1;\n  }\n  result input_value_1;\n}\n\n",
            "renaming": {
                "FUN_08000f68": "check_overflow_and_combine_08000f68",
                "param_1": "input_value_1",
                "param_2": "input_value_2",
                "bVar1": "overflow",
                "uVar2": "doubled_value_1",
                "uVar3": "doubled_value_2",
                "uVar4": "combined_value",
                "bVar5": "is_zero",
                "return": "result"
            },
            "calling": [
                "FUN_08000fd0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fc8": {
            "entrypoint": "0x08000fc8",
            "current_name": "execute_function_08000fc8",
            "code": "\nvoid executeFunction_08000fc8(undefined4 inputArgument,undefined4 outputArgument)\n\n{\n  FUN_08000fd0(outputArgument,inputArgument);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fc8": "execute_function_08000fc8",
                "param_1": "inputArgument",
                "param_2": "outputArgument"
            },
            "calling": [
                "FUN_08001030"
            ],
            "called": [
                "FUN_08000fd0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fd0": {
            "entrypoint": "0x08000fd0",
            "current_name": "concatenate_param_08000fd0",
            "code": "\nundefined8 concatenate_param_08000fd0(undefined4 param_1_arg,undefined4 param_2_arg)\n\n{\n  FUN_08000f68();\n  return CONCAT44(param_2_arg,param_1_arg);\n}\n\n",
            "renaming": {
                "FUN_08000fd0": "concatenate_param_08000fd0",
                "param_1": "param_1_arg",
                "param_2": "param_2_arg"
            },
            "calling": [
                "FUN_08000ff4",
                "FUN_08000fc8"
            ],
            "called": [
                "FUN_08000f68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ff4": {
            "entrypoint": "0x08000ff4",
            "current_name": "check_if_null_byte_present_08000ff4",
            "code": "\nbool check_if_null_byte_present_08000ff4(void)\n\n{\n  char byte_to_check;\n  \n  FUN_08000fd0();\n  return byte_to_check == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000ff4": "check_if_null_byte_present_08000ff4",
                "in_CY": "byte_to_check"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08000fd0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001030": {
            "entrypoint": "0x08001030",
            "current_name": "is_null_terminated_08001030",
            "code": "\nbool is_null_terminated_08001030(void)\n\n{\n  char input_char;\n  \n  FUN_08000fc8();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001030": "is_null_terminated_08001030",
                "in_CY": "input_char"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08000fc8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001044": {
            "entrypoint": "0x08001044",
            "current_name": "validate_number_range_08001044",
            "code": "\nuint validateNumberRange_08001044(uint inputNumber)\n\n{\n  uint shiftedValue;\n  \n  if (((inputNumber bitwiseAnd 0x80000000) != 0) || (inputNumber << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shiftedValue = 0x9e - ((inputNumber << 1) >> 0x18);\n  if (-1 < (int)shiftedValue) {\n    return (inputNumber << 8 | 0x80000000) >> (shiftedValue bitwiseAnd 0xff);\n  }\n  if ((shiftedValue == 0xffffff9f) bitwiseAndbitwiseAnd ((inputNumber bitwiseAnd 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08001044": "validate_number_range_08001044",
                "param_1": "inputNumber",
                "uVar1": "shiftedValue",
                "&": "bitwiseAnd"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001084": {
            "entrypoint": "0x08001084",
            "current_name": "copy_memory_08001084",
            "code": "\nword * copyMemory_08001084(word *destination,word *source,uint size)\n\n{\n  word *destPtr;\n  word *srcPtr;\n  word *tempPtr;\n  uint remainingSize;\n  uint copySize;\n  bool isRemaining;\n  \n  srcPtr = destination;\n  if ((((uint)source | (uint)destination) & 3) != 0) {\n    if (size < 8) {\n      copySize = size - 4;\n      if (3 < size) {\n        do {\n          destPtr = source;\n          tempPtr = srcPtr;\n          isRemaining = copySize != 0;\n          copySize = copySize - 1;\n          *(byte *)tempPtr = *(byte *)destPtr;\n          srcPtr = (word *)((int)tempPtr + 1);\n          source = (word *)((int)destPtr + 1);\n        } while (isRemaining);\n        *(byte *)(word *)((int)tempPtr + 1) =\n             *(byte *)(word *)((int)destPtr + 1);\n        *(byte *)((int)tempPtr + 2) = *(byte *)((int)destPtr + 2);\n        *(byte *)((int)tempPtr + 3) = *(byte *)((int)destPtr + 3);\n        return destination;\n      }\n      goto LAB_08001108;\n    }\n    if ((((uint)source & 3) != 0) && (((uint)destination & 3) != 0)) {\n      copySize = 4 - ((uint)destination & 3);\n      size = size - copySize;\n      destPtr = destination;\n      tempPtr = source;\n      if (((uint)destination & 1) != 0) {\n        tempPtr = (word *)((int)source + 1);\n        destPtr = (word *)((int)destination + 1);\n        *(byte *)destination = *(byte *)source;\n      }\n      srcPtr = destPtr;\n      source = tempPtr;\n      if ((copySize & 2) != 0) {\n        source = (word *)((int)tempPtr + 2);\n        srcPtr = (word *)((int)destPtr + 2);\n        *(halfword *)destPtr = *(halfword *)tempPtr;\n      }\n    }\n  }\n  while (0x3f < size) {\n    *srcPtr = *source;\n    srcPtr[1] = source[1];\n    srcPtr[2] = source[2];\n    srcPtr[3] = source[3];\n    srcPtr[4] = source[4];\n    srcPtr[5] = source[5];\n    srcPtr[6] = source[6];\n    srcPtr[7] = source[7];\n    srcPtr[8] = source[8];\n    srcPtr[9] = source[9];\n    srcPtr[10] = source[10];\n    srcPtr[0xb] = source[0xb];\n    srcPtr[0xc] = source[0xc];\n    srcPtr[0xd] = source[0xd];\n    srcPtr[0xe] = source[0xe];\n    srcPtr[0xf] = source[0xf];\n    srcPtr = srcPtr + 0x10;\n    source = source + 0x10;\n    size = size - 0x40;\n  }\n  remainingSize = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n      *srcPtr = *source;\n      srcPtr[1] = source[1];\n      srcPtr[2] = source[2];\n      srcPtr[3] = source[3];\n      srcPtr = srcPtr + 4;\n      source = source + 4;\n      isRemaining = 0xf < remainingSize;\n      remainingSize = remainingSize - 0x10;\n    } while (isRemaining);\n  }\n  copySize = remainingSize + 0xc;\n  tempPtr = srcPtr;\n  destPtr = source;\n  if (0xfffffff3 < remainingSize) {\n    do {\n      source = destPtr + 1;\n      *tempPtr = *destPtr;\n      isRemaining = 3 < copySize;\n      copySize = copySize - 4;\n      srcPtr = tempPtr + 1;\n      tempPtr = tempPtr + 1;\n      destPtr = source;\n    } while (isRemaining);\n  }\nLAB_08001108:\n  if (copySize + 4 != 0) {\n    destPtr = srcPtr;\n    tempPtr = source;\n    if ((copySize & 1) != 0) {\n      tempPtr = (word *)((int)source + 1);\n      destPtr = (word *)((int)srcPtr + 1);\n      *(byte *)srcPtr = *(byte *)source;\n    }\n    if ((copySize + 4 & 2) != 0) {\n      *(halfword *)destPtr = *(halfword *)tempPtr;\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08001084": "copy_memory_08001084",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "size",
                "puVar1": "destPtr",
                "puVar2": "srcPtr",
                "puVar3": "tempPtr",
                "uVar4": "remainingSize",
                "uVar5": "copySize",
                "bVar6": "isRemaining",
                "undefined": "byte",
                "undefined2": "halfword",
                "undefined4": "word"
            },
            "calling": [
                "FUN_080097cc",
                "FUN_080079e8",
                "FUN_08009120"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001170": {
            "entrypoint": "0x08001170",
            "current_name": "check_input_validity_08001170",
            "code": "\nundefined4 check_input_validity_08001170(uint input_1,int input_2,uint input_3,int input_4)\n\n{\n  if ((((input_2 << 1) >> 0x15 != -1) || ((input_1 | input_2 << 0xc) == 0)) &&\n     (((input_4 << 1) >> 0x15 != -1 || ((input_3 | input_4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08001170": "check_input_validity_08001170",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800119c": {
            "entrypoint": "0x0800119c",
            "current_name": "calculate_result_0800119c",
            "code": "\nuint calculate_result_0800119c(uint input_value_1,uint input_value_2)\n\n{\n  uint final_result;\n  int temp_var;\n  uint difference;\n  \n  temp_var = input_value_2 * 2 + 0x200000;\n  if (input_value_2 * 2 < 0xffe00000) {\n    if (-1 < temp_var) {\n      return 0;\n    }\n    final_result = temp_var >> 0x15;\n    difference = -final_result - 0x3e1;\n    if (final_result < 0xfffffc20 && difference != 0) {\n      final_result = (input_value_2 << 0xb | 0x80000000 | input_value_1 >> 0x15) >> (difference & 0xff);\n      if ((input_value_2 & 0x80000000) != 0) {\n        final_result = -final_result;\n      }\n      return final_result;\n    }\n  }\n  else if ((input_value_1 | input_value_2 << 0xc) != 0) {\n    return 0;\n  }\n  input_value_2 = input_value_2 & 0x80000000;\n  if (input_value_2 == 0) {\n    input_value_2 = 0x7fffffff;\n  }\n  return input_value_2;\n}\n\n",
            "renaming": {
                "FUN_0800119c": "calculate_result_0800119c",
                "param_1": "input_value_1",
                "param_2": "input_value_2",
                "uVar1": "final_result",
                "iVar2": "temp_var",
                "uVar3": "difference"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011ec": {
            "entrypoint": "0x080011ec",
            "current_name": "check_params_and_return_concatenated_080011ec",
            "code": "\nundefined8 checkParamsAndReturnConcatenated_080011ec(int firstParam,int secondParam,int thirdParam,int fourthParam)\n\n{\n  undefined8 result;\n  \n  if ((fourthParam == 0) && (thirdParam == 0)) {\n    if (secondParam != 0 || firstParam != 0) {\n      secondParam = -1;\n      firstParam = -1;\n    }\n    return CONCAT44(secondParam,firstParam);\n  }\n  result = FUN_0800121c();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080011ec": "check_params_and_return_concatenated_080011ec",
                "param_1": "firstParam",
                "param_2": "secondParam",
                "param_3": "thirdParam",
                "param_4": "fourthParam",
                "uVar1": "result"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_0800121c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800121c": {
            "entrypoint": "0x0800121c",
            "current_name": "calculate_quotient_and_remainder_0800121c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080014b2) */\n\nundefined8 calculateQuotientAndRemainder_0800121c(uint dividend,uint divisor,uint quotient,uint remainder,uint *result)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  ulonglong temp;\n  uint divisor_quotient;\n  uint divisor_rem;\n  uint quotient_temp;\n  int shift;\n  uint dividend_quotient;\n  uint dividend_rem;\n  uint temp;\n  uint *pointer;\n  uint quotient_temp;\n  uint divisor_quotient;\n  uint quotient_temp;\n  bool is_carry;\n  undefined8 result;\n  \n  if (remainder == 0) {\n    if (divisor < quotient) {\n      shift = LZCOUNT(quotient);\n      dividend_rem = quotient;\n      if (shift != 0) {\n        dividend_rem = quotient << shift;\n        divisor = dividend >> (0x20U - shift & 0xff) | divisor << shift;\n        dividend = dividend << shift;\n      }\n      divisor_quotient = dividend_rem >> 0x10;\n      temp = divisor / divisor_quotient;\n      quotient_temp = temp * (dividend_rem & 0xffff);\n      dividend_quotient = dividend >> 0x10 | (divisor - divisor_quotient * temp) * 0x10000;\n      divisor_rem = temp;\n      if (dividend_quotient <= quotient_temp && quotient_temp - dividend_quotient != 0) {\n        is_carry = CARRY4(dividend_rem,dividend_quotient);\n        dividend_quotient = dividend_rem + dividend_quotient;\n        divisor_rem = temp - 1;\n        if ((is_carry == false) && (dividend_quotient <= quotient_temp && quotient_temp - dividend_quotient != 0)) {\n          divisor_rem = temp - 2;\n          dividend_quotient = dividend_quotient + dividend_rem;\n        }\n      }\n      divisor_quotient = (dividend_quotient - quotient_temp) / divisor_quotient;\n      quotient_temp = divisor_quotient * (dividend_rem & 0xffff);\n      temp = dividend & 0xffff | ((dividend_quotient - quotient_temp) - divisor_quotient * divisor_quotient) * 0x10000;\n      dividend_quotient = divisor_quotient;\n      if (temp <= quotient_temp && quotient_temp - temp != 0) {\n        is_carry = CARRY4(dividend_rem,temp);\n        temp = dividend_rem + temp;\n        dividend_quotient = divisor_quotient - 1;\n        if ((is_carry == false) && (temp <= quotient_temp && quotient_temp - temp != 0)) {\n          dividend_quotient = divisor_quotient - 2;\n          temp = temp + dividend_rem;\n        }\n      }\n      dividend_quotient = dividend_quotient | divisor_rem << 0x10;\n      pointer = (uint *)0x0;\n      temp = temp - quotient_temp;\n    }\n    else {\n      if (quotient == 0) {\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x8001302);\n        result = (*UNRECOVERED_JUMPTABLE)();\n        return result;\n      }\n      shift = LZCOUNT(quotient);\n      if (shift == 0) {\n        pointer = (uint *)0x1;\n        divisor = divisor - quotient;\n        divisor_quotient = quotient >> 0x10;\n        divisor_quotient = quotient & 0xffff;\n        dividend_rem = quotient;\n      }\n      else {\n        dividend_rem = quotient << shift;\n        dividend_quotient = divisor >> (0x20U - shift & 0xff);\n        divisor_quotient = dividend_rem >> 0x10;\n        quotient_temp = dividend_quotient / divisor_quotient;\n        divisor_quotient = dividend_rem & 0xffff;\n        quotient_temp = quotient_temp * divisor_quotient;\n        temp = dividend >> (0x20U - shift & 0xff) | divisor << shift;\n        divisor_rem = temp >> 0x10 | (dividend_quotient - divisor_quotient * quotient_temp) * 0x10000;\n        dividend = dividend << shift;\n        dividend_quotient = quotient_temp;\n        if (divisor_rem <= quotient_temp && quotient_temp - divisor_rem != 0) {\n          is_carry = CARRY4(dividend_rem,divisor_rem);\n          divisor_rem = dividend_rem + divisor_rem;\n          dividend_quotient = quotient_temp - 1;\n          if ((is_carry == false) && (divisor_rem <= quotient_temp && quotient_temp - divisor_rem != 0)) {\n            dividend_quotient = quotient_temp - 2;\n            divisor_rem = divisor_rem + dividend_rem;\n          }\n        }\n        quotient_temp = (divisor_rem - quotient_temp) / divisor_quotient;\n        quotient_temp = quotient_temp * divisor_quotient;\n        divisor = temp & 0xffff | ((divisor_rem - quotient_temp) - divisor_quotient * quotient_temp) * 0x10000;\n        divisor_rem = quotient_temp;\n        if (divisor <= quotient_temp && quotient_temp - divisor != 0) {\n          is_carry = CARRY4(dividend_rem,divisor);\n          divisor = dividend_rem + divisor;\n          divisor_rem = quotient_temp - 1;\n          if ((is_carry == false) && (divisor <= quotient_temp && quotient_temp - divisor != 0)) {\n            divisor_rem = quotient_temp - 2;\n            divisor = divisor + dividend_rem;\n          }\n        }\n        divisor = divisor - quotient_temp;\n        pointer = (uint *)(divisor_rem | dividend_quotient << 0x10);\n      }\n      quotient_temp = divisor / divisor_quotient;\n      dividend_quotient = divisor_quotient * quotient_temp;\n      temp = dividend >> 0x10 | (divisor - divisor_quotient * quotient_temp) * 0x10000;\n      divisor_rem = quotient_temp;\n      if (temp <= dividend_quotient && dividend_quotient - temp != 0) {\n        is_carry = CARRY4(dividend_rem,temp);\n        temp = dividend_rem + temp;\n        divisor_rem = quotient_temp - 1;\n        if ((is_carry == false) && (temp <= dividend_quotient && dividend_quotient - temp != 0)) {\n          divisor_rem = quotient_temp - 2;\n          temp = temp + dividend_rem;\n        }\n      }\n      quotient_temp = (temp - dividend_quotient) / divisor_quotient;\n      divisor_quotient = divisor_quotient * quotient_temp;\n      temp = dividend & 0xffff | ((temp - dividend_quotient) - divisor_quotient * quotient_temp) * 0x10000;\n      dividend_quotient = quotient_temp;\n      if (temp <= divisor_quotient && divisor_quotient - temp != 0) {\n        is_carry = CARRY4(dividend_rem,temp);\n        temp = dividend_rem + temp;\n        dividend_quotient = quotient_temp - 1;\n        if ((is_carry == false) && (temp <= divisor_quotient && divisor_quotient - temp != 0)) {\n          dividend_quotient = quotient_temp - 2;\n          temp = temp + dividend_rem;\n        }\n      }\n      temp = temp - divisor_quotient;\n      dividend_quotient = dividend_quotient | divisor_rem << 0x10;\n    }\n    if (result != (uint *)0x0) {\n      *result = temp >> LZCOUNT(quotient);\n      result[1] = 0;\n    }\n  }\n  else {\n    pointer = result;\n    if (divisor < remainder) {\n      if (result != (uint *)0x0) {\n        *result = dividend;\n        result[1] = divisor;\n        return 0;\n      }\n      dividend_quotient = 0;\n    }\n    else {\n      shift = LZCOUNT(remainder);\n      if (shift == 0) {\n        if ((remainder < divisor) || (quotient <= dividend)) {\n          is_carry = dividend < quotient;\n          dividend = dividend - quotient;\n          divisor = (divisor - remainder) - (uint)is_carry;\n          dividend_quotient = 1;\n        }\n        else {\n          dividend_quotient = 0;\n        }\n        pointer = (uint *)0x0;\n        if (result != (uint *)0x0) {\n          *result = dividend;\n          result[1] = divisor;\n        }\n      }\n      else {\n        temp = 0x20 - shift;\n        divisor_quotient = quotient >> (temp & 0xff) | remainder << shift;\n        dividend_rem = divisor >> (temp & 0xff);\n        quotient_temp = divisor_quotient >> 0x10;\n        quotient_temp = dividend_rem / quotient_temp;\n        divisor_quotient = quotient_temp * (divisor_quotient & 0xffff);\n        dividend_quotient = divisor << shift | dividend >> (temp & 0xff);\n        divisor_rem = dividend_quotient >> 0x10 | (dividend_rem - quotient_temp * quotient_temp) * 0x10000;\n        dividend = dividend << shift;\n        dividend_rem = quotient_temp;\n        if (divisor_rem <= divisor_quotient && divisor_quotient - divisor_rem != 0) {\n          is_carry = CARRY4(divisor_quotient,divisor_rem);\n          divisor_rem = divisor_quotient + divisor_rem;\n          dividend_rem = quotient_temp - 1;\n          if ((is_carry == false) && (divisor_rem <= divisor_quotient && divisor_quotient - divisor_rem != 0)) {\n            dividend_rem = quotient_temp - 2;\n            divisor_rem = divisor_rem + divisor_quotient;\n          }\n        }\n        quotient_temp = (divisor_rem - divisor_quotient) / quotient_temp;\n        quotient_temp = quotient_temp * (divisor_quotient & 0xffff);\n        divisor_rem = dividend_quotient & 0xffff | ((divisor_rem - divisor_quotient) - quotient_temp * quotient_temp) * 0x10000;\n        dividend_quotient = quotient_temp;\n        if (divisor_rem <= quotient_temp && quotient_temp - divisor_rem != 0) {\n          is_carry = CARRY4(divisor_quotient,divisor_rem);\n          divisor_rem = divisor_quotient + divisor_rem;\n          dividend_quotient = quotient_temp - 1;\n          if ((is_carry == false) && (divisor_rem <= quotient_temp && quotient_temp - divisor_rem != 0)) {\n            dividend_quotient = quotient_temp - 2;\n            divisor_rem = divisor_rem + divisor_quotient;\n          }\n        }\n        dividend_quotient = dividend_quotient | dividend_rem << 0x10;\n        temp = (ulonglong)dividend_quotient * (ulonglong)(quotient << shift);\n        if (CONCAT44(divisor_rem - quotient_temp,dividend) < temp) {\n          dividend_quotient = dividend_quotient - 1;\n          temp = temp - CONCAT44(divisor_quotient,quotient << shift);\n        }\n        if (result != (uint *)0x0) {\n          dividend_rem = ((divisor_rem - quotient_temp) - (int)(temp >> 0x20)) - (uint)(dividend < (uint)temp);\n          *result = dividend_rem << (temp & 0xff) | dividend - (uint)temp >> shift;\n          result[1] = dividend_rem >> shift;\n          pointer = (uint *)0x0;\n        }\n      }\n    }\n  }\n  return CONCAT44(pointer,dividend_quotient);\n}\n\n",
            "renaming": {
                "FUN_0800121c": "calculate_quotient_and_remainder_0800121c",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "param_5": "result",
                "uVar1": "temp",
                "uVar2": "divisor_quotient",
                "uVar3": "divisor_rem",
                "uVar4": "quotient_temp",
                "iVar5": "shift",
                "uVar6": "dividend_quotient",
                "uVar7": "dividend_rem",
                "uVar8": "temp",
                "puVar9": "pointer",
                "uVar10": "quotient_temp",
                "uVar11": "divisor_quotient",
                "uVar12": "quotient_temp",
                "bVar13": "is_carry",
                "uVar14": "result"
            },
            "calling": [
                "FUN_080011ec"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014f0": {
            "entrypoint": "0x080014f0",
            "current_name": "FUNC_080014f0",
            "code": "\n\n\nundefined4 FUNC_080014f0(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  FUN_08001714(3);\n  FUN_0800151c(0xf);\n  FUNC_08002d8a();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080014f0": "FUNC_080014f0"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08001714",
                "FUN_08002d8a",
                "FUN_0800151c"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800151c": {
            "entrypoint": "0x0800151c",
            "current_name": "check_and_update_threshold_0800151c",
            "code": "\nundefined4 checkAndUpdateThreshold_0800151c(uint threshold)\n\n{\n  int result;\n  undefined4 success;\n  \n  result = FUN_08001762((int)((ulonglong)DAT_20000018 / (1000 / (ulonglong)DAT_20000004)));\n  if (result == 0) {\n    if (threshold < 0x10) {\n      FUN_0800172a(0xffffffff,threshold,0);\n      success = 0;\n      DAT_20000000 = threshold;\n    }\n    else {\n      success = 1;\n    }\n  }\n  else {\n    success = 1;\n  }\n  return success;\n}\n\n",
            "renaming": {
                "FUN_0800151c": "check_and_update_threshold_0800151c",
                "param_1": "threshold",
                "iVar1": "result",
                "uVar2": "success"
            },
            "calling": [
                "FUN_08003260",
                "FUN_080014f0"
            ],
            "called": [
                "FUN_08001762",
                "FUN_0800172a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800157c": {
            "entrypoint": "0x0800157c",
            "current_name": "update_data_0800157c",
            "code": "\nvoid updateData_0800157c(void)\n\n{\n  DAT_20000a48 = DAT_20000a48 + (uint)DAT_20000004;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800157c": "update_data_0800157c"
            },
            "calling": [
                "FUN_08005704"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015a0": {
            "entrypoint": "0x080015a0",
            "current_name": "get_global_value_080015a0",
            "code": "\nundefined4 get_global_value_080015a0(void)\n\n{\n  return DAT_20000a48;\n}\n\n",
            "renaming": {
                "FUN_080015a0": "get_global_value_080015a0"
            },
            "calling": [
                "FUN_08002ca8",
                "FUN_08004436",
                "FUN_08003260",
                "FUN_08002bb4",
                "FUN_08002ad8",
                "FUN_08001ccc",
                "FUN_080027f4",
                "FUN_08002d98",
                "FUN_08002c2e",
                "FUN_08001f6c",
                "FUN_08002640",
                "FUN_08004f2c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b4": {
            "entrypoint": "0x080015b4",
            "current_name": "configure_hardware_080015b4",
            "code": "\n\n\nvoid configureHardware_080015b4(uint configuration)\n\n{\n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | (configuration & 7) << 8 | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b4": "configure_hardware_080015b4",
                "param_1": "configuration"
            },
            "calling": [
                "FUN_08001714"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015fc": {
            "entrypoint": "0x080015fc",
            "current_name": "get_shifted_bits_080015fc",
            "code": "\n\n\nuint get_shifted_bits_080015fc(void)\n\n{\n  return _DAT_e000ed0c >> 8 & 7;\n}\n\n",
            "renaming": {
                "FUN_080015fc": "get_shifted_bits_080015fc"
            },
            "calling": [
                "FUN_0800172a"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001618": {
            "entrypoint": "0x08001618",
            "current_name": "write_data_to_memory_08001618",
            "code": "\nvoid writeDataToMemory_08001618(byte dataByte,uint value)\n\n{\n  if ((char)dataByte < '\\0') {\n    *(char *)((dataByte & 0xf) + 0xe000ed14) = (char)((value & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)dataByte + -0x1fff1c00) = (char)((value & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001618": "write_data_to_memory_08001618",
                "param_1": "dataByte",
                "param_2": "value"
            },
            "calling": [
                "FUN_080016d0",
                "FUN_0800172a"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800166c": {
            "entrypoint": "0x0800166c",
            "current_name": "bitwise_operation_0800166c",
            "code": "\nuint bitwiseOperation_0800166c(uint bitPosition,uint firstNumber,uint secondNumber)\n\n{\n  uint shiftAmount;\n  \n  bitPosition = bitPosition & 7;\n  shiftAmount = 7 - bitPosition;\n  if (3 < shiftAmount) {\n    shiftAmount = 4;\n  }\n  if (bitPosition + 4 < 7) {\n    bitPosition = 0;\n  }\n  else {\n    bitPosition = bitPosition - 3;\n  }\n  return secondNumber & ~(-1 << (bitPosition & 0xff)) |\n         (~(-1 << (shiftAmount & 0xff)) & firstNumber) << (bitPosition & 0xff);\n}\n\n",
            "renaming": {
                "FUN_0800166c": "bitwise_operation_0800166c",
                "param_1": "bitPosition",
                "param_2": "firstNumber",
                "param_3": "secondNumber",
                "uVar1": "shiftAmount"
            },
            "calling": [
                "FUN_0800172a"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016d0": {
            "entrypoint": "0x080016d0",
            "current_name": "check_and_set_080016d0",
            "code": "\n\n\nbool checkAndSet_080016d0(int inputValue)\n\n{\n  bool isInRange;\n  \n  isInRange = inputValue - 1U < 0x1000000;\n  if (isInRange) {\n    _DAT_e000e014 = inputValue + -1;\n    FUN_08001618(0xffffffff,0xf);\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n  }\n  return !isInRange;\n}\n\n",
            "renaming": {
                "FUN_080016d0": "check_and_set_080016d0",
                "param_1": "inputValue",
                "bVar1": "isInRange"
            },
            "calling": [
                "FUN_08001762"
            ],
            "called": [
                "FUN_08001618"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001714": {
            "entrypoint": "0x08001714",
            "current_name": "execute_recursive_function_08001714",
            "code": "\nvoid execute_recursive_function_08001714(undefined4 parameter)\n\n{\n  FUN_080015b4(parameter);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001714": "execute_recursive_function_08001714",
                "param_1": "parameter"
            },
            "calling": [
                "FUN_080014f0"
            ],
            "called": [
                "FUN_080015b4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800172a": {
            "entrypoint": "0x0800172a",
            "current_name": "process_data_0800172a",
            "code": "\nvoid processData_0800172a(char data,undefined4 arg1,undefined4 arg2)\n\n{\n  undefined4 result;\n  \n  result = FUN_080015fc();\n  result = FUN_0800166c(result,arg1,arg2);\n  FUN_08001618((int)data,result);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800172a": "process_data_0800172a",
                "param_1": "data",
                "param_2": "arg1",
                "param_3": "arg2",
                "uVar1": "result"
            },
            "calling": [
                "FUN_080052a0",
                "FUN_0800151c"
            ],
            "called": [
                "FUN_08001618",
                "FUN_0800166c",
                "FUN_080015fc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001762": {
            "entrypoint": "0x08001762",
            "current_name": "execute_function_08001762",
            "code": "\nundefined4 executeFunction_08001762(undefined4 inputParameter)\n\n{\n  undefined4 returnValue;\n  \n  returnValue = FUN_080016d0(inputParameter);\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08001762": "execute_function_08001762",
                "param_1": "inputParameter",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_080052a0",
                "FUN_0800151c"
            ],
            "called": [
                "FUN_080016d0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800177c": {
            "entrypoint": "0x0800177c",
            "current_name": "update_flag_0800177c",
            "code": "\n\n\nvoid updateFlag_0800177c(int inputValue)\n\n{\n  if (inputValue == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800177c": "update_flag_0800177c",
                "param_1": "inputValue"
            },
            "calling": [
                "FUN_080052a0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017b4": {
            "entrypoint": "0x080017b4",
            "current_name": "initialize_system_080017b4",
            "code": "\nvoid initializeSystem_080017b4(void)\n\n{\n  FUN_08004f78(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080017b4": "initialize_system_080017b4"
            },
            "calling": [
                "FUN_08005704"
            ],
            "called": [
                "FUN_08004f78"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017c4": {
            "entrypoint": "0x080017c4",
            "current_name": "update_bits_080017c4",
            "code": "\n\n\nvoid updateBits_080017c4(uint *bitsToUpdate,uint *mask)\n\n{\n  uint bitMask;\n  uint bitValue;\n  uint opcode;\n  uint *output;\n  int registerIndex;\n  uint newValue;\n  uint bitPosition;\n  \n  newValue = 0;\n  bitPosition = 0;\n  do {\n    if (0xf < bitPosition) {\n      return;\n    }\n    bitMask = 1 << (bitPosition & 0xff);\n    bitValue = *mask & bitMask;\n    if (bitValue == bitMask) {\n      opcode = mask[1];\n      if (opcode == 0x12) {\n        newValue = mask[3] + 0xc;\n      }\n      else if (opcode < 0x13) {\n        if (opcode == 2) {\n          newValue = mask[3] + 8;\n        }\n        else if (opcode < 3) {\n          if (opcode == 0) goto LAB_08001882;\n          if (opcode == 1) {\n            newValue = mask[3];\n          }\n        }\n        else if (opcode == 3) {\n          newValue = 0;\n        }\n        else if (opcode == 0x11) {\n          newValue = mask[3] + 4;\n        }\n      }\n      else if (opcode == 0x10210000) {\nLAB_08001882:\n        if (mask[2] == 0) {\n          newValue = 4;\n        }\n        else if (mask[2] == 1) {\n          newValue = 8;\n          bitsToUpdate[4] = bitMask;\n        }\n        else {\n          newValue = 8;\n          bitsToUpdate[5] = bitMask;\n        }\n      }\n      else if (opcode < 0x10210001) {\n        if ((opcode == 0x10110000) || (opcode == 0x10120000)) goto LAB_08001882;\n      }\n      else if (((opcode == 0x10310000) || (opcode == 0x10320000)) || (opcode == 0x10220000))\n      goto LAB_08001882;\n      if (bitValue < 0x100) {\n        bitMask = bitPosition << 2;\n        output = bitsToUpdate;\n      }\n      else {\n        output = bitsToUpdate + 1;\n        bitMask = (bitPosition - 8) * 4;\n      }\n      *output = *output & ~(0xf << (bitMask & 0xff)) | newValue << (bitMask & 0xff);\n      if ((mask[1] & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        if (bitsToUpdate == (uint *)0x40010800) {\n          registerIndex = 0;\n        }\n        else if (bitsToUpdate == (uint *)0x40010c00) {\n          registerIndex = 1;\n        }\n        else if (bitsToUpdate == (uint *)0x40011000) {\n          registerIndex = 2;\n        }\n        else if (bitsToUpdate == (uint *)0x40011400) {\n          registerIndex = 3;\n        }\n        else {\n          registerIndex = 4;\n        }\n        *(uint *)(((bitPosition >> 2) + 2) * 4 + 0x40010000) =\n             registerIndex << ((bitPosition & 3) << 2) |\n             ~(0xf << ((bitPosition & 3) << 2)) & *(uint *)(((bitPosition >> 2) + 2) * 4 + 0x40010000);\n        if ((mask[1] & 0x10000) == 0) {\n          _DAT_40010400 = ~bitValue & _DAT_40010400;\n        }\n        else {\n          _DAT_40010400 = bitValue | _DAT_40010400;\n        }\n        if ((mask[1] & 0x20000) == 0) {\n          _DAT_40010404 = ~bitValue & _DAT_40010404;\n        }\n        else {\n          _DAT_40010404 = bitValue | _DAT_40010404;\n        }\n        if ((mask[1] & 0x100000) == 0) {\n          _DAT_40010408 = ~bitValue & _DAT_40010408;\n        }\n        else {\n          _DAT_40010408 = bitValue | _DAT_40010408;\n        }\n        if ((mask[1] & 0x200000) == 0) {\n          _DAT_4001040c = ~bitValue & _DAT_4001040c;\n        }\n        else {\n          _DAT_4001040c = bitValue | _DAT_4001040c;\n        }\n      }\n    }\n    bitPosition = bitPosition + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080017c4": "update_bits_080017c4",
                "param_1": "bitsToUpdate",
                "param_2": "mask",
                "uVar1": "bitMask",
                "uVar2": "bitValue",
                "uVar3": "opcode",
                "puVar4": "output",
                "iVar5": "registerIndex",
                "local_10": "newValue",
                "local_c": "bitPosition"
            },
            "calling": [
                "FUN_08005680",
                "FUN_080055f4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a80": {
            "entrypoint": "0x08001a80",
            "current_name": "set_param_value_08001a80",
            "code": "\nvoid setParamValue_08001a80(int pointer,ushort value,char flag)\n\n{\n  if (flag == '\\0') {\n    *(uint *)(pointer + 0x10) = (uint)value << 0x10;\n  }\n  else {\n    *(uint *)(pointer + 0x10) = (uint)value;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a80": "set_param_value_08001a80",
                "param_1": "pointer",
                "param_2": "value",
                "param_3": "flag"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_080055f4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "calculate_parameters_08001ab0",
            "code": "\nundefined4 calculateParameters_08001ab0(uint **parameters)\n\n{\n  uint temp1;\n  char flag;\n  undefined4 result;\n  uint temp2;\n  bool isZero;\n  \n  if (parameters == (uint **)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)parameters + 0x3d) == '\\0') {\n      *(undefined *)(parameters + 0xf) = 0;\n      FUNC_08001cb8(parameters);\n    }\n    *(undefined *)((int)parameters + 0x3d) = 0x24;\n    **parameters = **parameters & 0xfffffffe;\n    temp1 = FUN_08003518();\n    if (parameters[1] < (uint *)0x186a1) {\n      temp2 = temp1;\n      if (temp1 < 2000000) {\n        temp2 = 1;\n      }\n      flag = (char)temp2;\n      if (1999999 < temp1) {\n        flag = '\\0';\n      }\n    }\n    else {\n      temp2 = temp1;\n      if (temp1 < 4000000) {\n        temp2 = 1;\n      }\n      flag = (char)temp2;\n      if (3999999 < temp1) {\n        flag = '\\0';\n      }\n    }\n    if (flag == '\\0') {\n      temp2 = temp1 / 1000000;\n      (*parameters)[1] = temp2;\n      if ((uint *)0x186a0 < parameters[1]) {\n        temp2 = (temp2 * 300) / 1000;\n      }\n      (*parameters)[8] = temp2 + 1;\n      if (parameters[1] < (uint *)0x186a1) {\n        temp1 = (temp1 - 1) / (uint)((int)parameters[1] << 1) + 1 & 0xfff;\n        if (temp1 < 4) {\n          temp1 = 4;\n        }\n      }\n      else {\n        if (parameters[2] == (uint *)0x0) {\n          temp2 = (temp1 - 1) / (uint)((int)parameters[1] * 3) + 1 & 0xfff;\n          isZero = temp2 == 0;\n          if (isZero) {\n            temp2 = 1;\n          }\n          flag = (char)temp2;\n          if (!isZero) {\n            flag = '\\0';\n          }\n        }\n        else {\n          temp2 = (temp1 - 1) / (uint)((int)parameters[1] * 0x19) + 1 & 0xfff;\n          isZero = temp2 == 0;\n          if (isZero) {\n            temp2 = 1;\n          }\n          flag = (char)temp2;\n          if (!isZero) {\n            flag = '\\0';\n          }\n        }\n        if (flag == '\\0') {\n          if (parameters[2] == (uint *)0x0) {\n            temp1 = (temp1 - 1) / (uint)((int)parameters[1] * 3) + 1 & 0xfff | 0x8000;\n          }\n          else {\n            temp1 = (temp1 - 1) / (uint)((int)parameters[1] * 0x19) + 1 & 0xfff | 0xc000;\n          }\n        }\n        else {\n          temp1 = 1;\n        }\n      }\n      (*parameters)[7] = temp1;\n      **parameters = (uint)parameters[8] | (uint)parameters[7];\n      (*parameters)[2] = (uint)parameters[3] | (uint)parameters[4];\n      (*parameters)[3] = (uint)parameters[6] | (uint)parameters[5];\n      **parameters = **parameters | 1;\n      parameters[0x10] = (uint *)0x0;\n      *(undefined *)((int)parameters + 0x3d) = 0x20;\n      parameters[0xc] = (uint *)0x0;\n      *(undefined *)((int)parameters + 0x3e) = 0;\n      result = 0;\n    }\n    else {\n      result = 1;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "calculate_parameters_08001ab0",
                "param_1": "parameters",
                "uVar1": "temp1",
                "cVar2": "flag",
                "uVar3": "result",
                "uVar4": "temp2",
                "bVar5": "isZero"
            },
            "calling": [
                "FUN_08005348"
            ],
            "called": [
                "FUN_08003518",
                "FUN_08001cb8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cb8": {
            "entrypoint": "0x08001cb8",
            "current_name": "FUNC_08001cb8",
            "code": "\nvoid FUNC_08001cb8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cb8": "FUNC_08001cb8"
            },
            "calling": [
                "FUN_08001ab0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001ccc": {
            "entrypoint": "0x08001ccc",
            "current_name": "process_data_08001ccc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001d5e) */\n/* WARNING: Removing unreachable block (ram,0x08001d70) */\n/* WARNING: Removing unreachable block (ram,0x08001d72) */\n/* WARNING: Removing unreachable block (ram,0x08001d74) */\n\nundefined4\nprocessData_08001ccc(uint **data,undefined2 param2,undefined2 param3,undefined2 param4,uint *param5,\n            undefined2 param6,undefined4 param7)\n\n{\n  int result1;\n  int result2;\n  undefined4 result3;\n  uint *ptrVar;\n  \n  result1 = FUN_080015a0();\n  if (*(char *)((int)data + 0x3d) == ' ') {\n    do {\n      if ((~(*data)[6] & 2) != 0) {\n        result2 = 0;\n        goto LAB_08001d9c;\n      }\n      result2 = FUN_080015a0();\n    } while ((uint)(result2 - result1) < 0x1a);\n    data[0xc] = (uint *)0x0;\n    *(undefined *)((int)data + 0x3d) = 0x20;\n    *(undefined *)((int)data + 0x3e) = 0;\n    *(undefined *)(data + 0xf) = 0;\n    result2 = 3;\nLAB_08001d9c:\n    if (result2 == 0) {\n      if (*(char *)(data + 0xf) == '\\x01') {\n        result3 = 2;\n      }\n      else {\n        *(undefined *)(data + 0xf) = 1;\n        if ((**data & 1) != 1) {\n          **data = **data | 1;\n        }\n        **data = **data & 0xfffff7ff;\n        *(undefined *)((int)data + 0x3d) = 0x21;\n        *(undefined *)((int)data + 0x3e) = 0x40;\n        data[0x10] = (uint *)0x0;\n        data[9] = param5;\n        *(undefined2 *)((int)data + 0x2a) = param6;\n        data[0xb] = (uint *)0xffff0000;\n        *(undefined2 *)(data + 10) = *(undefined2 *)((int)data + 0x2a);\n        result2 = FUN_08002640(data,param2,param3,param4,param7,result1);\n        if (result2 == 0) {\n          while (*(short *)(data + 10) != 0) {\n            result2 = FUN_08002bb4(data,param7,result1);\n            if (result2 != 0) {\n              if (data[0x10] == (uint *)0x4) {\n                **data = **data | 0x200;\n                return 1;\n              }\n              return 3;\n            }\n            ptrVar = data[9];\n            data[9] = (uint *)((int)ptrVar + 1);\n            (*data)[4] = (uint)*(byte *)ptrVar;\n            *(short *)(data + 10) = *(short *)(data + 10) + -1;\n            *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n            if ((((*data)[5] & 4) == 4) && (*(short *)(data + 10) != 0)) {\n              ptrVar = data[9];\n              data[9] = (uint *)((int)ptrVar + 1);\n              (*data)[4] = (uint)*(byte *)ptrVar;\n              *(short *)(data + 10) = *(short *)(data + 10) + -1;\n              *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n            }\n          }\n          result1 = FUN_08002c2e(data,param7,result1);\n          if (result1 == 0) {\n            **data = **data | 0x200;\n            *(undefined *)((int)data + 0x3d) = 0x20;\n            *(undefined *)((int)data + 0x3e) = 0;\n            *(undefined *)(data + 0xf) = 0;\n            result3 = 0;\n          }\n          else if (data[0x10] == (uint *)0x4) {\n            **data = **data | 0x200;\n            result3 = 1;\n          }\n          else {\n            result3 = 3;\n          }\n        }\n        else if (data[0x10] == (uint *)0x4) {\n          *(undefined *)(data + 0xf) = 0;\n          result3 = 1;\n        }\n        else {\n          *(undefined *)(data + 0xf) = 0;\n          result3 = 3;\n        }\n      }\n    }\n    else {\n      result3 = 2;\n    }\n  }\n  else {\n    result3 = 2;\n  }\n  return result3;\n}\n\n",
            "renaming": {
                "FUN_08001ccc": "process_data_08001ccc",
                "param_1": "data",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6",
                "param_7": "param7",
                "iVar1": "result1",
                "iVar2": "result2",
                "uVar3": "result3",
                "puVar4": "ptrVar"
            },
            "calling": [
                "FUN_08004ea4"
            ],
            "called": [
                "FUN_08002bb4",
                "FUN_080015a0",
                "FUN_08002c2e",
                "FUN_08002640"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f6c": {
            "entrypoint": "0x08001f6c",
            "current_name": "process_data_08001f6c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080024e6) */\n/* WARNING: Removing unreachable block (ram,0x080024f8) */\n/* WARNING: Removing unreachable block (ram,0x080024fa) */\n/* WARNING: Removing unreachable block (ram,0x080024fc) */\n/* WARNING: Removing unreachable block (ram,0x08002000) */\n/* WARNING: Removing unreachable block (ram,0x08002012) */\n/* WARNING: Removing unreachable block (ram,0x08002014) */\n/* WARNING: Removing unreachable block (ram,0x08002016) */\n/* WARNING: Removing unreachable block (ram,0x080023f4) */\n/* WARNING: Removing unreachable block (ram,0x08002406) */\n/* WARNING: Removing unreachable block (ram,0x08002408) */\n/* WARNING: Removing unreachable block (ram,0x0800240a) */\n/* WARNING: Removing unreachable block (ram,0x080022d6) */\n/* WARNING: Removing unreachable block (ram,0x080022e8) */\n/* WARNING: Removing unreachable block (ram,0x080022ea) */\n/* WARNING: Removing unreachable block (ram,0x080022ec) */\n\nundefined4\nprocessData_08001f6c(uint **inputData,undefined2 param2,undefined2 param3,undefined2 param4,uint *outputData,\n            undefined2 param6,uint param7)\n\n{\n  int someVar;\n  uint tempVar;\n  int loopVar;\n  undefined4 returnValue;\n  uint *ptrVar;\n  \n  someVar = FUN_080015a0();\n  if (*(char *)((int)inputData + 0x3d) == ' ') {\n    do {\n      if ((~(*inputData)[6] & 2) != 0) {\n        loopVar = 0;\n        goto LAB_08002040;\n      }\n      loopVar = FUN_080015a0();\n    } while ((uint)(loopVar - someVar) < 0x1a);\n    inputData[0xc] = (uint *)0x0;\n    *(undefined *)((int)inputData + 0x3d) = 0x20;\n    *(undefined *)((int)inputData + 0x3e) = 0;\n    *(undefined *)(inputData + 0xf) = 0;\n    loopVar = 3;\nLAB_08002040:\n    if (loopVar == 0) {\n      if (*(char *)(inputData + 0xf) == '\\x01') {\n        returnValue = 2;\n      }\n      else {\n        *(undefined *)(inputData + 0xf) = 1;\n        if ((**inputData & 1) != 1) {\n          **inputData = **inputData | 1;\n        }\n        **inputData = **inputData & 0xfffff7ff;\n        *(undefined *)((int)inputData + 0x3d) = 0x22;\n        *(undefined *)((int)inputData + 0x3e) = 0x40;\n        inputData[0x10] = (uint *)0x0;\n        inputData[9] = outputData;\n        *(undefined2 *)((int)inputData + 0x2a) = param6;\n        inputData[0xb] = (uint *)0xffff0000;\n        *(undefined2 *)(inputData + 10) = *(undefined2 *)((int)inputData + 0x2a);\n        loopVar = FUN_080027f4(inputData,param2,param3,param4,param7,someVar);\n        if (loopVar == 0) {\n          if (*(short *)(inputData + 10) == 0) {\n            **inputData = **inputData | 0x200;\n          }\n          else if (*(short *)(inputData + 10) == 1) {\n            **inputData = **inputData & 0xfffffbff;\n            disableIRQinterrupts();\n            **inputData = **inputData | 0x200;\n            enableIRQinterrupts();\n          }\n          else if (*(short *)(inputData + 10) == 2) {\n            **inputData = **inputData | 0x800;\n            disableIRQinterrupts();\n            **inputData = **inputData & 0xfffffbff;\n            enableIRQinterrupts();\n          }\n          else {\n            **inputData = **inputData | 0x400;\n          }\n          while (*(short *)(inputData + 10) != 0) {\n            if (*(ushort *)(inputData + 10) < 4) {\n              if (*(short *)(inputData + 10) == 1) {\n                loopVar = FUN_08002ca8(inputData,param7,someVar);\n                if (loopVar != 0) {\n                  if (inputData[0x10] == (uint *)0x20) {\n                    return 3;\n                  }\n                  return 1;\n                }\n                tempVar = (*inputData)[4];\n                ptrVar = inputData[9];\n                inputData[9] = (uint *)((int)ptrVar + 1);\n                *(char *)ptrVar = (char)tempVar;\n                *(short *)(inputData + 10) = *(short *)(inputData + 10) + -1;\n                *(short *)((int)inputData + 0x2a) = *(short *)((int)inputData + 0x2a) + -1;\n              }\n              else if (*(short *)(inputData + 10) == 2) {\n                do {\n                  if ((~(*inputData)[5] & 4) == 0) {\n                    loopVar = 0;\n                    goto LAB_080022fa;\n                  }\n                } while ((param7 == 0xffffffff) ||\n                        ((param7 != 0 && (loopVar = FUN_080015a0(), (uint)(loopVar - someVar) <= param7)\n                         )));\n                inputData[0xc] = (uint *)0x0;\n                *(undefined *)((int)inputData + 0x3d) = 0x20;\n                *(undefined *)((int)inputData + 0x3e) = 0;\n                *(undefined *)(inputData + 0xf) = 0;\n                loopVar = 3;\nLAB_080022fa:\n                if (loopVar != 0) {\n                  return 3;\n                }\n                disableIRQinterrupts();\n                **inputData = **inputData | 0x200;\n                tempVar = (*inputData)[4];\n                ptrVar = inputData[9];\n                inputData[9] = (uint *)((int)ptrVar + 1);\n                *(char *)ptrVar = (char)tempVar;\n                *(short *)(inputData + 10) = *(short *)(inputData + 10) + -1;\n                *(short *)((int)inputData + 0x2a) = *(short *)((int)inputData + 0x2a) + -1;\n                enableIRQinterrupts();\n                tempVar = (*inputData)[4];\n                ptrVar = inputData[9];\n                inputData[9] = (uint *)((int)ptrVar + 1);\n                *(char *)ptrVar = (char)tempVar;\n                *(short *)(inputData + 10) = *(short *)(inputData + 10) + -1;\n                *(short *)((int)inputData + 0x2a) = *(short *)((int)inputData + 0x2a) + -1;\n              }\n              else {\n                do {\n                  if ((~(*inputData)[5] & 4) == 0) {\n                    loopVar = 0;\n                    goto LAB_08002418;\n                  }\n                } while ((param7 == 0xffffffff) ||\n                        ((param7 != 0 && (loopVar = FUN_080015a0(), (uint)(loopVar - someVar) <= param7)\n                         )));\n                inputData[0xc] = (uint *)0x0;\n                *(undefined *)((int)inputData + 0x3d) = 0x20;\n                *(undefined *)((int)inputData + 0x3e) = 0;\n                *(undefined *)(inputData + 0xf) = 0;\n                loopVar = 3;\nLAB_08002418:\n                if (loopVar != 0) {\n                  return 3;\n                }\n                **inputData = **inputData & 0xfffffbff;\n                disableIRQinterrupts();\n                tempVar = (*inputData)[4];\n                ptrVar = inputData[9];\n                inputData[9] = (uint *)((int)ptrVar + 1);\n                *(char *)ptrVar = (char)tempVar;\n                *(short *)(inputData + 10) = *(short *)(inputData + 10) + -1;\n                *(short *)((int)inputData + 0x2a) = *(short *)((int)inputData + 0x2a) + -1;\n                do {\n                  if ((~(*inputData)[5] & 4) == 0) {\n                    loopVar = 0;\n                    goto LAB_0800250a;\n                  }\n                } while ((param7 == 0xffffffff) ||\n                        ((param7 != 0 && (loopVar = FUN_080015a0(), (uint)(loopVar - someVar) <= param7)\n                         )));\n                inputData[0xc] = (uint *)0x0;\n                *(undefined *)((int)inputData + 0x3d) = 0x20;\n                *(undefined *)((int)inputData + 0x3e) = 0;\n                *(undefined *)(inputData + 0xf) = 0;\n                loopVar = 3;\nLAB_0800250a:\n                if (loopVar != 0) {\n                  return 3;\n                }\n                **inputData = **inputData | 0x200;\n                tempVar = (*inputData)[4];\n                ptrVar = inputData[9];\n                inputData[9] = (uint *)((int)ptrVar + 1);\n                *(char *)ptrVar = (char)tempVar;\n                *(short *)(inputData + 10) = *(short *)(inputData + 10) + -1;\n                *(short *)((int)inputData + 0x2a) = *(short *)((int)inputData + 0x2a) + -1;\n                enableIRQinterrupts();\n                tempVar = (*inputData)[4];\n                ptrVar = inputData[9];\n                inputData[9] = (uint *)((int)ptrVar + 1);\n                *(char *)ptrVar = (char)tempVar;\n                *(short *)(inputData + 10) = *(short *)(inputData + 10) + -1;\n                *(short *)((int)inputData + 0x2a) = *(short *)((int)inputData + 0x2a) + -1;\n              }\n            }\n            else {\n              loopVar = FUN_08002ca8(inputData,param7,someVar);\n              if (loopVar != 0) {\n                if (inputData[0x10] == (uint *)0x20) {\n                  return 3;\n                }\n                return 1;\n              }\n              tempVar = (*inputData)[4];\n              ptrVar = inputData[9];\n              inputData[9] = (uint *)((int)ptrVar + 1);\n              *(char *)ptrVar = (char)tempVar;\n              *(short *)(inputData + 10) = *(short *)(inputData + 10) + -1;\n              *(short *)((int)inputData + 0x2a) = *(short *)((int)inputData + 0x2a) + -1;\n              if (((*inputData)[5] & 4) == 4) {\n                tempVar = (*inputData)[4];\n                ptrVar = inputData[9];\n                inputData[9] = (uint *)((int)ptrVar + 1);\n                *(char *)ptrVar = (char)tempVar;\n                *(short *)(inputData + 10) = *(short *)(inputData + 10) + -1;\n                *(short *)((int)inputData + 0x2a) = *(short *)((int)inputData + 0x2a) + -1;\n              }\n            }\n          }\n          *(undefined *)((int)inputData + 0x3d) = 0x20;\n          *(undefined *)((int)inputData + 0x3e) = 0;\n          *(undefined *)(inputData + 0xf) = 0;\n          returnValue = 0;\n        }\n        else if (inputData[0x10] == (uint *)0x4) {\n          *(undefined *)(inputData + 0xf) = 0;\n          returnValue = 1;\n        }\n        else {\n          *(undefined *)(inputData + 0xf) = 0;\n          returnValue = 3;\n        }\n      }\n    }\n    else {\n      returnValue = 2;\n    }\n  }\n  else {\n    returnValue = 2;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08001f6c": "process_data_08001f6c",
                "param_1": "inputData",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "outputData",
                "param_6": "param6",
                "param_7": "param7",
                "iVar1": "someVar",
                "uVar2": "tempVar",
                "iVar3": "loopVar",
                "uVar4": "returnValue",
                "puVar5": "ptrVar"
            },
            "calling": [
                "FUN_08004ee8"
            ],
            "called": [
                "FUN_08002ca8",
                "FUN_080015a0",
                "FUN_080027f4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002640": {
            "entrypoint": "0x08002640",
            "current_name": "process_data_08002640",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080026e8) */\n/* WARNING: Removing unreachable block (ram,0x080026fa) */\n/* WARNING: Removing unreachable block (ram,0x080026fc) */\n/* WARNING: Removing unreachable block (ram,0x080026fe) */\n\nundefined4\nprocessData_08002640(uint **data,byte flag,undefined2 value1,short value2,uint limit,int threshold)\n\n{\n  int result;\n  undefined4 returnValue;\n  \n  **data = **data | 0x100;\n  do {\n    if ((~(*data)[5] & 1) == 0) {\n      result = 0;\n      goto LAB_0800270a;\n    }\n  } while ((limit == 0xffffffff) ||\n          ((limit != 0 && (result = FUN_080015a0(), (uint)(result - threshold) <= limit))));\n  data[0xc] = (uint *)0x0;\n  *(undefined *)((int)data + 0x3d) = 0x20;\n  *(undefined *)((int)data + 0x3e) = 0;\n  *(undefined *)(data + 0xf) = 0;\n  result = 3;\nLAB_0800270a:\n  if (result == 0) {\n    (*data)[4] = flag & 0xfe;\n    result = FUN_08002ad8(data,0x10002,limit,threshold);\n    if (result == 0) {\n      result = FUN_08002bb4(data,limit,threshold,(*data)[6]);\n      if (result == 0) {\n        if (value2 == 1) {\n          (*data)[4] = (uint)(byte)value1;\n        }\n        else {\n          (*data)[4] = (uint)(byte)((ushort)value1 >> 8);\n          result = FUN_08002bb4(data,limit,threshold);\n          if (result != 0) {\n            if (data[0x10] == (uint *)0x4) {\n              **data = **data | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*data)[4] = (uint)(byte)value1;\n        }\n        returnValue = 0;\n      }\n      else if (data[0x10] == (uint *)0x4) {\n        **data = **data | 0x200;\n        returnValue = 1;\n      }\n      else {\n        returnValue = 3;\n      }\n    }\n    else if (data[0x10] == (uint *)0x4) {\n      returnValue = 1;\n    }\n    else {\n      returnValue = 3;\n    }\n  }\n  else {\n    returnValue = 3;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08002640": "process_data_08002640",
                "param_1": "data",
                "param_2": "flag",
                "param_3": "value1",
                "param_4": "value2",
                "param_5": "limit",
                "param_6": "threshold",
                "iVar1": "result",
                "uVar2": "returnValue"
            },
            "calling": [
                "FUN_08001ccc"
            ],
            "called": [
                "FUN_08002bb4",
                "FUN_08002ad8",
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080027f4": {
            "entrypoint": "0x080027f4",
            "current_name": "process_data_080027f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080028ae) */\n/* WARNING: Removing unreachable block (ram,0x080028c0) */\n/* WARNING: Removing unreachable block (ram,0x080028c2) */\n/* WARNING: Removing unreachable block (ram,0x080028c4) */\n/* WARNING: Removing unreachable block (ram,0x08002a6c) */\n/* WARNING: Removing unreachable block (ram,0x08002a7e) */\n/* WARNING: Removing unreachable block (ram,0x08002a80) */\n/* WARNING: Removing unreachable block (ram,0x08002a82) */\n\nundefined4\nprocessData_080027f4(uint **data,byte byteValue,undefined2 shortValue,short condition,uint limit,int comparisonValue)\n\n{\n  int result;\n  undefined4 returnValue;\n  \n  **data = **data | 0x400;\n  **data = **data | 0x100;\n  do {\n    if ((~(*data)[5] & 1) == 0) {\n      result = 0;\n      goto LAB_080028d2;\n    }\n  } while ((limit == 0xffffffff) ||\n          ((limit != 0 && (result = FUN_080015a0(), (uint)(result - comparisonValue) <= limit))));\n  data[0xc] = (uint *)0x0;\n  *(undefined *)((int)data + 0x3d) = 0x20;\n  *(undefined *)((int)data + 0x3e) = 0;\n  *(undefined *)(data + 0xf) = 0;\n  result = 3;\nLAB_080028d2:\n  if (result == 0) {\n    (*data)[4] = byteValue & 0xfe;\n    result = FUN_08002ad8(data,0x10002,limit,comparisonValue);\n    if (result == 0) {\n      result = FUN_08002bb4(data,limit,comparisonValue,(*data)[6]);\n      if (result == 0) {\n        if (condition == 1) {\n          (*data)[4] = (uint)(byte)shortValue;\n        }\n        else {\n          (*data)[4] = (uint)(byte)((ushort)shortValue >> 8);\n          result = FUN_08002bb4(data,limit,comparisonValue);\n          if (result != 0) {\n            if (data[0x10] == (uint *)0x4) {\n              **data = **data | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*data)[4] = (uint)(byte)shortValue;\n        }\n        result = FUN_08002bb4(data,limit,comparisonValue);\n        if (result == 0) {\n          **data = **data | 0x100;\n          do {\n            if ((~(*data)[5] & 1) == 0) {\n              result = 0;\n              goto LAB_08002a90;\n            }\n          } while ((limit == 0xffffffff) ||\n                  ((limit != 0 && (result = FUN_080015a0(), (uint)(result - comparisonValue) <= limit))));\n          data[0xc] = (uint *)0x0;\n          *(undefined *)((int)data + 0x3d) = 0x20;\n          *(undefined *)((int)data + 0x3e) = 0;\n          *(undefined *)(data + 0xf) = 0;\n          result = 3;\nLAB_08002a90:\n          if (result == 0) {\n            (*data)[4] = (uint)(byteValue | 1);\n            result = FUN_08002ad8(data,0x10002,limit,comparisonValue);\n            if (result == 0) {\n              returnValue = 0;\n            }\n            else if (data[0x10] == (uint *)0x4) {\n              returnValue = 1;\n            }\n            else {\n              returnValue = 3;\n            }\n          }\n          else {\n            returnValue = 3;\n          }\n        }\n        else if (data[0x10] == (uint *)0x4) {\n          **data = **data | 0x200;\n          returnValue = 1;\n        }\n        else {\n          returnValue = 3;\n        }\n      }\n      else if (data[0x10] == (uint *)0x4) {\n        **data = **data | 0x200;\n        returnValue = 1;\n      }\n      else {\n        returnValue = 3;\n      }\n    }\n    else if (data[0x10] == (uint *)0x4) {\n      returnValue = 1;\n    }\n    else {\n      returnValue = 3;\n    }\n  }\n  else {\n    returnValue = 3;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080027f4": "process_data_080027f4",
                "param_1": "data",
                "param_2": "byteValue",
                "param_3": "shortValue",
                "param_4": "condition",
                "param_5": "limit",
                "param_6": "comparisonValue",
                "iVar1": "result",
                "uVar2": "returnValue"
            },
            "calling": [
                "FUN_08001f6c"
            ],
            "called": [
                "FUN_08002bb4",
                "FUN_08002ad8",
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad8": {
            "entrypoint": "0x08002ad8",
            "current_name": "validate_input_08002ad8",
            "code": "\nundefined4 validate_input_08002ad8(uint **input_array,uint input_value,uint condition_value,int comparison_value)\n\n{\n  int comparison_result;\n  char result;\n  uint modified_value;\n  bool isModified;\n  \n  do {\n    if ((input_value >> 0x10 & 0xff) == 1) {\n      modified_value = input_value & ~(*input_array)[5] & 0xffff;\n      isModified = modified_value != 0;\n      if (isModified) {\n        modified_value = 1;\n      }\n      result = (char)modified_value;\n      if (!isModified) {\n        result = '\\0';\n      }\n    }\n    else {\n      modified_value = input_value & ~(*input_array)[6] & 0xffff;\n      isModified = modified_value != 0;\n      if (isModified) {\n        modified_value = 1;\n      }\n      result = (char)modified_value;\n      if (!isModified) {\n        result = '\\0';\n      }\n    }\n    if (result == '\\0') {\n      return 0;\n    }\n    if (((*input_array)[5] & 0x400) == 0x400) {\n      **input_array = **input_array | 0x200;\n      (*input_array)[5] = 0xfffffbff;\n      input_array[0x10] = (uint *)0x4;\n      input_array[0xc] = (uint *)0x0;\n      *(undefined *)((int)input_array + 0x3d) = 0x20;\n      *(undefined *)(input_array + 0xf) = 0;\n      return 1;\n    }\n  } while ((condition_value == 0xffffffff) ||\n          ((condition_value != 0 && (comparison_result = FUN_080015a0(), (uint)(comparison_result - comparison_value) <= condition_value))));\n  input_array[0xc] = (uint *)0x0;\n  *(undefined *)((int)input_array + 0x3d) = 0x20;\n  *(undefined *)(input_array + 0xf) = 0;\n  return 3;\n}\n\n",
            "renaming": {
                "FUN_08002ad8": "validate_input_08002ad8",
                "param_1": "input_array",
                "param_2": "input_value",
                "param_3": "condition_value",
                "param_4": "comparison_value",
                "uVar3": "modified_value",
                "bVar4": "isModified",
                "cVar2": "result",
                "iVar1": "comparison_result"
            },
            "calling": [
                "FUN_080027f4",
                "FUN_08002640"
            ],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002bb4": {
            "entrypoint": "0x08002bb4",
            "current_name": "check_conditions_08002bb4",
            "code": "\nundefined4 checkConditions_08002bb4(int *inputData,uint size,int offset)\n\n{\n  int result;\n  \n  while( true ) {\n    if ((*(uint *)(*inputData + 0x14) & 0x80) == 0x80) {\n      return 0;\n    }\n    result = FUN_08002d3c(inputData);\n    if (result != 0) break;\n    if ((size != 0xffffffff) &&\n       ((size == 0 || (result = FUN_080015a0(), size < (uint)(result - offset))))) {\n      inputData[0x10] = inputData[0x10] | 0x20;\n      inputData[0xc] = 0;\n      *(undefined *)((int)inputData + 0x3d) = 0x20;\n      *(undefined *)(inputData + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002bb4": "check_conditions_08002bb4",
                "param_1": "inputData",
                "param_2": "size",
                "param_3": "offset",
                "iVar1": "result"
            },
            "calling": [
                "FUN_08001ccc",
                "FUN_080027f4",
                "FUN_08002640"
            ],
            "called": [
                "FUN_080015a0",
                "FUN_08002d3c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c2e": {
            "entrypoint": "0x08002c2e",
            "current_name": "check_and_modify_status_08002c2e",
            "code": "\nundefined4 checkAndModifyStatus_08002c2e(int *ptr,uint length,int startIndex)\n\n{\n  int result;\n  \n  while( true ) {\n    if ((*(uint *)(*ptr + 0x14) & 4) == 4) {\n      return 0;\n    }\n    result = FUN_08002d3c(ptr);\n    if (result != 0) break;\n    if ((length != 0xffffffff) &&\n       ((length == 0 || (result = FUN_080015a0(), length < (uint)(result - startIndex))))) {\n      flag = flag | 0x20;\n      counter = 0;\n      *(undefined *)((int)ptr + 0x3d) = 0x20;\n      *(undefined *)(ptr + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002c2e": "check_and_modify_status_08002c2e",
                "param_1": "ptr",
                "param_2": "length",
                "param_3": "startIndex",
                "iVar1": "result",
                "param_1[0x10]": "flag",
                "param_1[0xc]": "counter"
            },
            "calling": [
                "FUN_08001ccc"
            ],
            "called": [
                "FUN_080015a0",
                "FUN_08002d3c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca8": {
            "entrypoint": "0x08002ca8",
            "current_name": "check_and_process_08002ca8",
            "code": "\nundefined4 checkAndProcess_08002ca8(int *data,uint size,int offset)\n\n{\n  int difference;\n  \n  while( true ) {\n    if ((*(uint *)(*data + 0x14) & 0x40) == 0x40) {\n      return 0;\n    }\n    if ((*(uint *)(*data + 0x14) & 0x10) == 0x10) break;\n    if ((size == 0) || (difference = FUN_080015a0(), size < (uint)(difference - offset))) {\n      data[0x10] = data[0x10] | 0x20;\n      *(undefined *)((int)data + 0x3d) = 0x20;\n      *(undefined *)(data + 0xf) = 0;\n      return 3;\n    }\n  }\n  *(undefined4 *)(*data + 0x14) = 0xffffffef;\n  data[0x10] = 0;\n  data[0xc] = 0;\n  *(undefined *)((int)data + 0x3d) = 0x20;\n  *(undefined *)(data + 0xf) = 0;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002ca8": "check_and_process_08002ca8",
                "param_1": "data",
                "param_2": "size",
                "param_3": "offset",
                "iVar1": "difference"
            },
            "calling": [
                "FUN_08001f6c"
            ],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d3c": {
            "entrypoint": "0x08002d3c",
            "current_name": "check_flag_status_08002d3c",
            "code": "\nbool checkFlagStatus_08002d3c(int *flagPointer)\n\n{\n  bool isFlagSet;\n  \n  isFlagSet = (*(uint *)(*flagPointer + 0x14) & 0x400) == 0x400;\n  if (isFlagSet) {\n    *(undefined4 *)(*flagPointer + 0x14) = 0xfffffbff;\n    errorCode = 4;\n    counter = 0;\n    *(undefined *)((int)flagPointer + 0x3d) = 0x20;\n    *(undefined *)(flagPointer + 0xf) = 0;\n  }\n  return isFlagSet;\n}\n\n",
            "renaming": {
                "FUN_08002d3c": "check_flag_status_08002d3c",
                "param_1": "flagPointer",
                "bVar1": "isFlagSet",
                "param_1[0x10]": "errorCode",
                "param_1[0xc]": "counter"
            },
            "calling": [
                "FUN_08002bb4",
                "FUN_08002c2e"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d8a": {
            "entrypoint": "0x08002d8a",
            "current_name": "FUNC_08002d8a",
            "code": "\nvoid FUNC_08002d8a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d8a": "FUNC_08002d8a"
            },
            "calling": [
                "FUN_080014f0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d98": {
            "entrypoint": "0x08002d98",
            "current_name": "check_flags_08002d98",
            "code": "\n\n\nundefined4 checkFlags_08002d98(uint *flags)\n\n{\n  int startTime;\n  int currentTime;\n  undefined4 result;\n  bool isConditionTrue;\n  \n  if ((*flags & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0x10000)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (flags[1] == 0)) {\n        return 1;\n      }\n    }\n    else {\n      if (flags[1] == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (flags[1] == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (flags[1] == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (flags[1] == 0) {\n        startTime = FUN_080015a0();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          currentTime = FUN_080015a0();\n          if (100 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n      }\n      else {\n        startTime = FUN_080015a0();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          currentTime = FUN_080015a0();\n          if (100 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n      }\n    }\n  }\n  if ((*flags & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (flags[4] != 1)) {\n        return 1;\n      }\n      _DAT_40021000 = flags[5] << 3 | _DAT_40021000 & 0xffffff07;\n    }\n    else if (flags[4] == 0) {\n      _DAT_42420000 = 0;\n      startTime = FUN_080015a0();\n      while ((_DAT_40021000 & 2) != 0) {\n        currentTime = FUN_080015a0();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      startTime = FUN_080015a0();\n      while ((_DAT_40021000 & 2) == 0) {\n        currentTime = FUN_080015a0();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n      _DAT_40021000 = flags[5] << 3 | _DAT_40021000 & 0xffffff07;\n    }\n  }\n  if ((*flags & 8) != 0) {\n    if (flags[6] == 0) {\n      _DAT_42420480 = 0;\n      startTime = FUN_080015a0();\n      while ((_DAT_40021024 & 2) != 0) {\n        currentTime = FUN_080015a0();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      startTime = FUN_080015a0();\n      while ((_DAT_40021024 & 2) == 0) {\n        currentTime = FUN_080015a0();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n      FUN_08003568(1);\n    }\n  }\n  if ((*flags & 4) != 0) {\n    isConditionTrue = (_DAT_4002101c & 0x10000000) == 0;\n    if (isConditionTrue) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTime = FUN_080015a0();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTime = FUN_080015a0();\n        if (100 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    if (flags[3] == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (flags[3] == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (flags[3] == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (flags[3] == 0) {\n      startTime = FUN_080015a0();\n      while ((_DAT_40021020 & 2) != 0) {\n        currentTime = FUN_080015a0();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      startTime = FUN_080015a0();\n      while ((_DAT_40021020 & 2) == 0) {\n        currentTime = FUN_080015a0();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    if (isConditionTrue) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if (flags[7] == 0) {\nLAB_0800324a:\n    result = 0;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    result = 1;\n  }\n  else if (flags[7] == 2) {\n    _DAT_42420060 = 0;\n    startTime = FUN_080015a0();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if (flags[8] == 0x10000) {\n          _DAT_40021004 = flags[2] | _DAT_40021004 & 0xfffdffff;\n        }\n        _DAT_40021004 = flags[9] | flags[8] | _DAT_40021004 & 0xffc2ffff;\n        _DAT_42420060 = 1;\n        startTime = FUN_080015a0();\n        while ((_DAT_40021000 & 0x2000000) == 0) {\n          currentTime = FUN_080015a0();\n          if (2 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n        goto LAB_0800324a;\n      }\n      currentTime = FUN_080015a0();\n    } while ((uint)(currentTime - startTime) < 3);\n    result = 3;\n  }\n  else {\n    _DAT_42420060 = 0;\n    startTime = FUN_080015a0();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) goto LAB_0800324a;\n      currentTime = FUN_080015a0();\n    } while ((uint)(currentTime - startTime) < 3);\n    result = 3;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002d98": "check_flags_08002d98",
                "param_1": "flags",
                "iVar1": "startTime",
                "iVar2": "currentTime",
                "uVar3": "result",
                "bVar4": "isConditionTrue"
            },
            "calling": [
                "FUN_080052a0"
            ],
            "called": [
                "FUN_080015a0",
                "FUN_08003568"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003260": {
            "entrypoint": "0x08003260",
            "current_name": "process_memory_08003260",
            "code": "\n\n\nundefined4 processMemory_08003260(uint *paramArray,uint paramSize)\n\n{\n  int iVar1;\n  int iVar2;\n  uint result;\n  undefined4 returnStatus;\n  \n  if (((_DAT_40022000 & 7) < paramSize) &&\n     (_DAT_40022000 = paramSize | _DAT_40022000 & 0xfffffff8, paramSize != (paramSize & 7))) {\n    returnStatus = 1;\n  }\n  else {\n    if ((*paramArray & 2) != 0) {\n      _DAT_40021004 = paramArray[2] | _DAT_40021004 & 0xffffff0f;\n    }\n    if ((*paramArray & 1) == 0) {\nLAB_08003394:\n      if ((paramSize < (_DAT_40022000 & 7)) &&\n         (_DAT_40022000 = paramSize | _DAT_40022000 & 0xfffffff8, paramSize != (paramSize & 7))) {\n        returnStatus = 1;\n      }\n      else {\n        if ((*paramArray & 4) != 0) {\n          _DAT_40021004 = paramArray[3] | _DAT_40021004 & 0xfffff8ff;\n        }\n        if ((*paramArray & 8) != 0) {\n          _DAT_40021004 = paramArray[4] << 3 | _DAT_40021004 & 0xffffc7ff;\n        }\n        result = FUN_08003440();\n        DAT_20000018 = result >> (&DAT_08009eb0)[_DAT_40021004 >> 4 & 0xf];\n        FUN_0800151c(0xf);\n        returnStatus = 0;\n      }\n    }\n    else {\n      if (paramArray[1] == 1) {\n        if ((_DAT_40021000 & 0x20000) == 0) {\n          return 1;\n        }\n      }\n      else if ((paramArray[1] != 2) && ((_DAT_40021000 & 2) == 0)) {\n        return 1;\n      }\n      _DAT_40021004 = paramArray[1] | _DAT_40021004 & 0xfffffffc;\n      iVar1 = FUN_080015a0();\n      if (paramArray[1] == 1) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 4) goto LAB_08003394;\n          iVar2 = FUN_080015a0();\n        } while ((uint)(iVar2 - iVar1) < 0x1389);\n        returnStatus = 3;\n      }\n      else if (paramArray[1] == 2) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 8) goto LAB_08003394;\n          iVar2 = FUN_080015a0();\n        } while ((uint)(iVar2 - iVar1) < 0x1389);\n        returnStatus = 3;\n      }\n      else {\n        do {\n          if ((_DAT_40021004 & 0xc) == 0) goto LAB_08003394;\n          iVar2 = FUN_080015a0();\n        } while ((uint)(iVar2 - iVar1) < 0x1389);\n        returnStatus = 3;\n      }\n    }\n  }\n  return returnStatus;\n}\n\n",
            "renaming": {
                "FUN_08003260": "process_memory_08003260",
                "param_1": "paramArray",
                "param_2": "paramSize",
                "uVar3": "result",
                "uVar4": "returnStatus"
            },
            "calling": [
                "FUN_080052a0"
            ],
            "called": [
                "FUN_080015a0",
                "FUN_0800151c",
                "FUN_08003440"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003440": {
            "entrypoint": "0x08003440",
            "current_name": "calculate_execution_time_08003440",
            "code": "\n\n\nuint calculateExecutionTime_08003440(void)\n\n{\n  undefined2 timeoutValue;\n  undefined4 constantValue1;\n  undefined4 constantValue2;\n  undefined4 constantValue3;\n  undefined4 constantValue4;\n  uint tempValue1;\n  undefined4 tempValue2;\n  uint local_14;\n  uint executionTime;\n  uint tempValue3;\n  \n  constantValue1 = 0x5040302;\n  constantValue2 = 0x9080706;\n  constantValue3 = 0xd0c0b0a;\n  constantValue4 = 0x10100f0e;\n  timeoutValue = 0x201;\n  tempValue2 = 0;\n  tempValue3 = 0;\n  tempValue1 = 0;\n  executionTime = 0;\n  local_14 = _DAT_40021004;\n  if ((_DAT_40021004 & 0xc) == 4) {\n    executionTime = 8000000;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    tempValue1 = (uint)*(byte *)((int)&constantValue1 + (_DAT_40021004 >> 0x12 & 0xf));\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      tempValue3 = tempValue1 * 4000000;\n    }\n    else {\n      tempValue3 = (tempValue1 * 8000000) / (uint)*(byte *)((int)&timeoutValue + (_DAT_40021004 >> 0x11 & 1))\n      ;\n    }\n    executionTime = tempValue3;\n  }\n  else {\n    executionTime = 8000000;\n  }\n  return executionTime;\n}\n\n",
            "renaming": {
                "FUN_08003440": "calculate_execution_time_08003440",
                "local_30": "timeoutValue",
                "local_2c": "constantValue1",
                "uStack_28": "constantValue2",
                "uStack_24": "constantValue3",
                "uStack_20": "constantValue4",
                "local_1c": "tempValue1",
                "local_18": "tempValue2",
                "local_10": "executionTime",
                "local_c": "tempValue3"
            },
            "calling": [
                "FUN_08003260"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003504": {
            "entrypoint": "0x08003504",
            "current_name": "get_dat_value_08003504",
            "code": "\nundefined4 get_dat_value_08003504(void)\n\n{\n  return DAT_20000018;\n}\n\n",
            "renaming": {
                "FUN_08003504": "get_dat_value_08003504"
            },
            "calling": [
                "FUN_080052a0",
                "FUN_08003540",
                "FUN_08003518"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003518": {
            "entrypoint": "0x08003518",
            "current_name": "shift_value_by_offset_08003518",
            "code": "\n\n\nuint shiftValueByOffset_08003518(void)\n\n{\n  uint functionResult;\n  \n  functionResult = FUN_08003504();\n  return functionResult >> *(sbyte *)((int)&DAT_08009ec0 + (_DAT_40021004 >> 8 & 7));\n}\n\n",
            "renaming": {
                "FUN_08003518": "shift_value_by_offset_08003518",
                "uVar1": "functionResult"
            },
            "calling": [
                "FUN_08001ab0",
                "FUN_080046ec"
            ],
            "called": [
                "FUN_08003504"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003540": {
            "entrypoint": "0x08003540",
            "current_name": "get_shifted_value_08003540",
            "code": "\n\n\nuint get_shifted_value_08003540(void)\n\n{\n  uint result;\n  \n  result = FUN_08003504();\n  return result >> *(sbyte *)((int)&DAT_08009ec0 + (_DAT_40021004 >> 0xb & 7));\n}\n\n",
            "renaming": {
                "FUN_08003540": "get_shifted_value_08003540",
                "uVar1": "result"
            },
            "calling": [
                "FUN_080046ec"
            ],
            "called": [
                "FUN_08003504"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003568": {
            "entrypoint": "0x08003568",
            "current_name": "wait_function_08003568",
            "code": "\nvoid waitFunction_08003568(int inputValue)\n\n{\n  bool bVar1;\n  int iterations;\n  \n  iterations = inputValue * (DAT_20000018 / 8000);\n  do {\n    bVar1 = iterations != 0;\n    iterations = iterations + -1;\n  } while (bVar1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003568": "wait_function_08003568",
                "param_1": "inputValue",
                "local_c": "iterations"
            },
            "calling": [
                "FUN_08002d98"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035a4": {
            "entrypoint": "0x080035a4",
            "current_name": "check_and_update_data_080035a4",
            "code": "\nundefined4 checkAndUpdateData_080035a4(undefined4 *dataPtr)\n\n{\n  undefined4 returnValue;\n  \n  if (dataPtr == (undefined4 *)0x0) {\n    returnValue = 1;\n  }\n  else {\n    if (*(char *)((int)dataPtr + 0x3d) == '\\0') {\n      *(undefined *)(dataPtr + 0xf) = 0;\n      FUNC_080035fa(dataPtr);\n    }\n    *(undefined *)((int)dataPtr + 0x3d) = 2;\n    FUN_08003c94(*dataPtr,dataPtr + 1);\n    *(undefined *)((int)dataPtr + 0x3d) = 1;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080035a4": "check_and_update_data_080035a4",
                "param_1": "dataPtr",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "called": [
                "FUN_08003c94",
                "FUN_080035fa"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fa": {
            "entrypoint": "0x080035fa",
            "current_name": "FUNC_080035fa",
            "code": "\nvoid FUNC_080035fa(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fa": "FUNC_080035fa"
            },
            "calling": [
                "FUN_080035a4"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800360c": {
            "entrypoint": "0x0800360c",
            "current_name": "set_flags_0800360c",
            "code": "\nundefined4 setFlags_0800360c(uint **flags)\n\n{\n  (*flags)[3] = (*flags)[3] | 1;\n  **flags = **flags | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800360c": "set_flags_0800360c",
                "param_1": "flags"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003640": {
            "entrypoint": "0x08003640",
            "current_name": "validate_and_process_08003640",
            "code": "\nundefined4 validate_and_process_08003640(undefined4 *data)\n\n{\n  undefined4 result;\n  \n  if (data == (undefined4 *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)data + 0x3d) == '\\0') {\n      *(undefined *)(data + 0xf) = 0;\n      FUNC_08003696(data);\n    }\n    *(undefined *)((int)data + 0x3d) = 2;\n    FUN_08003c94(*data,data + 1);\n    *(undefined *)((int)data + 0x3d) = 1;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003640": "validate_and_process_08003640",
                "param_1": "data",
                "uVar1": "result"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [
                "FUN_08003c94",
                "FUN_08003696"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003696": {
            "entrypoint": "0x08003696",
            "current_name": "FUNC_08003696",
            "code": "\nvoid FUNC_08003696(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003696": "FUNC_08003696"
            },
            "calling": [
                "FUN_08003640"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080036a8": {
            "entrypoint": "0x080036a8",
            "current_name": "set_flags_080036a8",
            "code": "\nundefined4 setFlags_080036a8(uint **ptr_ptr,undefined4 value)\n\n{\n  FUN_080041ea(*ptr_ptr,value,1);\n  if (*ptr_ptr == (uint *)0x40012c00) {\n    (*ptr_ptr)[0x11] = (*ptr_ptr)[0x11] | 0x8000;\n  }\n  **ptr_ptr = **ptr_ptr | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080036a8": "set_flags_080036a8",
                "param_1": "ptr_ptr",
                "param_2": "value"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_080041ea"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036f8": {
            "entrypoint": "0x080036f8",
            "current_name": "process_data_080036f8",
            "code": "\nvoid processData_080036f8(int *dataPtr)\n\n{\n  if (((*(uint *)(*dataPtr + 0x10) & 2) == 2) && ((*(uint *)(*dataPtr + 0xc) & 2) == 2)) {\n    *(undefined4 *)(*dataPtr + 0x10) = 0xfffffffd;\n    *(undefined *)(dataPtr + 7) = 1;\n    if ((*(uint *)(*dataPtr + 0x18) & 3) == 0) {\n      FUNC_08003c4a(dataPtr);\n      FUNC_08003c6e(dataPtr);\n    }\n    else {\n      FUNC_08003c5c(dataPtr);\n    }\n    *(undefined *)(dataPtr + 7) = 0;\n  }\n  if (((*(uint *)(*dataPtr + 0x10) & 4) == 4) && ((*(uint *)(*dataPtr + 0xc) & 4) == 4)) {\n    *(undefined4 *)(*dataPtr + 0x10) = 0xfffffffb;\n    *(undefined *)(dataPtr + 7) = 2;\n    if ((*(uint *)(*dataPtr + 0x18) & 0x300) == 0) {\n      FUNC_08003c4a(dataPtr);\n      FUNC_08003c6e(dataPtr);\n    }\n    else {\n      FUNC_08003c5c(dataPtr);\n    }\n    *(undefined *)(dataPtr + 7) = 0;\n  }\n  if (((*(uint *)(*dataPtr + 0x10) & 8) == 8) && ((*(uint *)(*dataPtr + 0xc) & 8) == 8)) {\n    *(undefined4 *)(*dataPtr + 0x10) = 0xfffffff7;\n    *(undefined *)(dataPtr + 7) = 4;\n    if ((*(uint *)(*dataPtr + 0x1c) & 3) == 0) {\n      FUNC_08003c4a(dataPtr);\n      FUNC_08003c6e(dataPtr);\n    }\n    else {\n      FUNC_08003c5c(dataPtr);\n    }\n    *(undefined *)(dataPtr + 7) = 0;\n  }\n  if (((*(uint *)(*dataPtr + 0x10) & 0x10) == 0x10) && ((*(uint *)(*dataPtr + 0xc) & 0x10) == 0x10))\n  {\n    *(undefined4 *)(*dataPtr + 0x10) = 0xffffffef;\n    *(undefined *)(dataPtr + 7) = 8;\n    if ((*(uint *)(*dataPtr + 0x1c) & 0x300) == 0) {\n      FUNC_08003c4a(dataPtr);\n      FUNC_08003c6e(dataPtr);\n    }\n    else {\n      FUNC_08003c5c(dataPtr);\n    }\n    *(undefined *)(dataPtr + 7) = 0;\n  }\n  if (((*(uint *)(*dataPtr + 0x10) & 1) == 1) && ((*(uint *)(*dataPtr + 0xc) & 1) == 1)) {\n    *(undefined4 *)(*dataPtr + 0x10) = 0xfffffffe;\n    FUN_08004f78(dataPtr);\n  }\n  if (((*(uint *)(*dataPtr + 0x10) & 0x80) == 0x80) && ((*(uint *)(*dataPtr + 0xc) & 0x80) == 0x80))\n  {\n    *(undefined4 *)(*dataPtr + 0x10) = 0xffffff7f;\n    FUNC_08004378(dataPtr);\n  }\n  if (((*(uint *)(*dataPtr + 0x10) & 0x40) == 0x40) && ((*(uint *)(*dataPtr + 0xc) & 0x40) == 0x40))\n  {\n    *(undefined4 *)(*dataPtr + 0x10) = 0xffffffbf;\n    FUNC_08003c80(dataPtr);\n  }\n  if (((*(uint *)(*dataPtr + 0x10) & 0x20) == 0x20) && ((*(uint *)(*dataPtr + 0xc) & 0x20) == 0x20))\n  {\n    *(undefined4 *)(*dataPtr + 0x10) = 0xffffffdf;\n    FUNC_08004366(dataPtr);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080036f8": "process_data_080036f8",
                "param_1": "dataPtr"
            },
            "calling": [
                "FUN_08005714"
            ],
            "called": [
                "FUN_08004366",
                "FUN_08004378",
                "FUN_08004f78",
                "FUN_08003c5c",
                "FUN_08003c4a",
                "FUN_08003c6e",
                "FUN_08003c80"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003908": {
            "entrypoint": "0x08003908",
            "current_name": "validate_and_update_data_08003908",
            "code": "\nundefined4 validateAndUpdateData_08003908(int *dataPointer,int paramValue,undefined4 caseValue)\n\n{\n  undefined4 returnValue;\n  \n  if (*(char *)(dataPointer + 0xf) == '\\x01') {\n    returnValue = 2;\n  }\n  else {\n    *(undefined *)(dataPointer + 0xf) = 1;\n    *(undefined *)((int)dataPointer + 0x3d) = 2;\n    switch(caseValue) {\n    case 0:\n      FUN_08003d60(*dataPointer,paramValue);\n      *(uint *)(*dataPointer + 0x18) = *(uint *)(*dataPointer + 0x18) | 8;\n      *(uint *)(*dataPointer + 0x18) = *(uint *)(*dataPointer + 0x18) & 0xfffffffb;\n      *(uint *)(*dataPointer + 0x18) = *(uint *)(paramValue + 0x10) | *(uint *)(*dataPointer + 0x18);\n      break;\n    case 4:\n      FUN_08003e38(*dataPointer,paramValue);\n      *(uint *)(*dataPointer + 0x18) = *(uint *)(*dataPointer + 0x18) | 0x800;\n      *(uint *)(*dataPointer + 0x18) = *(uint *)(*dataPointer + 0x18) & 0xfffffbff;\n      *(uint *)(*dataPointer + 0x18) = *(int *)(paramValue + 0x10) << 8 | *(uint *)(*dataPointer + 0x18);\n      break;\n    case 8:\n      FUN_08003f18(*dataPointer,paramValue);\n      *(uint *)(*dataPointer + 0x1c) = *(uint *)(*dataPointer + 0x1c) | 8;\n      *(uint *)(*dataPointer + 0x1c) = *(uint *)(*dataPointer + 0x1c) & 0xfffffffb;\n      *(uint *)(*dataPointer + 0x1c) = *(uint *)(paramValue + 0x10) | *(uint *)(*dataPointer + 0x1c);\n      break;\n    case 0xc:\n      FUN_08003ff8(*dataPointer,paramValue);\n      *(uint *)(*dataPointer + 0x1c) = *(uint *)(*dataPointer + 0x1c) | 0x800;\n      *(uint *)(*dataPointer + 0x1c) = *(uint *)(*dataPointer + 0x1c) & 0xfffffbff;\n      *(uint *)(*dataPointer + 0x1c) = *(int *)(paramValue + 0x10) << 8 | *(uint *)(*dataPointer + 0x1c);\n    }\n    *(undefined *)((int)dataPointer + 0x3d) = 1;\n    *(undefined *)(dataPointer + 0xf) = 0;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08003908": "validate_and_update_data_08003908",
                "param_1": "dataPointer",
                "param_2": "paramValue",
                "param_3": "caseValue",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [
                "FUN_08003ff8",
                "FUN_08003e38",
                "FUN_08003f18",
                "FUN_08003d60"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a94": {
            "entrypoint": "0x08003a94",
            "current_name": "update_config_08003a94",
            "code": "\nundefined4 updateConfig_08003a94(int *config,uint *values)\n\n{\n  undefined4 result;\n  uint value;\n  \n  if (*(char *)(config + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(config + 0xf) = 1;\n    *(undefined *)((int)config + 0x3d) = 2;\n    *(uint *)(*config + 8) = *(uint *)(*config + 8) & 0xffff0088;\n    value = *values;\n    if (value == 0x40) {\n      FUN_080040a0(*config,values[1],values[3]);\n      FUN_0800416a(*config,0x40);\n    }\n    else if (value < 0x41) {\n      if (value == 0x10) {\n        FUN_0800416a(*config,0x10);\n      }\n      else if (value < 0x11) {\n        if (value == 0) {\n          FUN_0800416a(*config,0);\n        }\n      }\n      else if (value == 0x20) {\n        FUN_0800416a(*config,0x20);\n      }\n      else if (value == 0x30) {\n        FUN_0800416a(*config,0x30);\n      }\n    }\n    else if (value == 0x70) {\n      FUN_080041a8(*config,values[2],values[1],values[3]);\n      *(uint *)(*config + 8) = *(uint *)(*config + 8) & 0xffffff88 | 0x77;\n    }\n    else if (value < 0x71) {\n      if (value == 0x50) {\n        FUN_080040a0(*config,values[1],values[3]);\n        FUN_0800416a(*config,0x50);\n      }\n      else if (value == 0x60) {\n        FUN_08004104(*config,values[1],values[3]);\n        FUN_0800416a(*config,0x60);\n      }\n    }\n    else if (value == 0x1000) {\n      *(uint *)(*config + 8) = *(uint *)(*config + 8) & 0xfffffff8;\n    }\n    else if (value == 0x2000) {\n      FUN_080041a8(*config,values[2],values[1],values[3]);\n      *(uint *)(*config + 8) = *(uint *)(*config + 8) | 0x4000;\n    }\n    *(undefined *)((int)config + 0x3d) = 1;\n    *(undefined *)(config + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003a94": "update_config_08003a94",
                "param_1": "config",
                "param_2": "values",
                "uVar1": "result",
                "uVar2": "value"
            },
            "calling": [
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "called": [
                "FUN_08004104",
                "FUN_080040a0",
                "FUN_0800416a",
                "FUN_080041a8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c4a": {
            "entrypoint": "0x08003c4a",
            "current_name": "FUNC_08003c4a",
            "code": "\nvoid FUNC_08003c4a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c4a": "FUNC_08003c4a"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c5c": {
            "entrypoint": "0x08003c5c",
            "current_name": "FUNC_08003c5c",
            "code": "\nvoid FUNC_08003c5c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c5c": "FUNC_08003c5c"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c6e": {
            "entrypoint": "0x08003c6e",
            "current_name": "FUNC_08003c6e",
            "code": "\nvoid FUNC_08003c6e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c6e": "FUNC_08003c6e"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c80": {
            "entrypoint": "0x08003c80",
            "current_name": "FUNC_08003c80",
            "code": "\nvoid FUNC_08003c80(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c80": "FUNC_08003c80"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c94": {
            "entrypoint": "0x08003c94",
            "current_name": "configure_memory_08003c94",
            "code": "\nvoid configureMemory_08003c94(uint *targetMemory,uint *sourceMemory)\n\n{\n  uint modifiedValue;\n  \n  modifiedValue = *targetMemory;\n  if ((((targetMemory == (uint *)0x40012c00) || (targetMemory == (uint *)0x40000000)) ||\n      (targetMemory == (uint *)0x40000400)) || (targetMemory == (uint *)0x40000800)) {\n    modifiedValue = sourceMemory[1] | modifiedValue & 0xffffff8f;\n  }\n  if (((targetMemory == (uint *)0x40012c00) || (targetMemory == (uint *)0x40000000)) ||\n     ((targetMemory == (uint *)0x40000400 || (targetMemory == (uint *)0x40000800)))) {\n    modifiedValue = sourceMemory[3] | modifiedValue & 0xfffffcff;\n  }\n  *targetMemory = sourceMemory[5] | modifiedValue & 0xffffff7f;\n  targetMemory[0xb] = sourceMemory[2];\n  targetMemory[10] = *sourceMemory;\n  if (targetMemory == (uint *)0x40012c00) {\n    specialValue = sourceMemory[4];\n  }\n  targetMemory[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c94": "configure_memory_08003c94",
                "param_1": "targetMemory",
                "param_2": "sourceMemory",
                "local_c": "modifiedValue",
                "uRam40012c30": "specialValue"
            },
            "calling": [
                "FUN_08003640",
                "FUN_080035a4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d60": {
            "entrypoint": "0x08003d60",
            "current_name": "update_param_08003d60",
            "code": "\nvoid updateParam_08003d60(int baseAddress,uint *data)\n\n{\n  uint firstValue;\n  uint secondValue;\n  uint localValue;\n  \n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & 0xfffffffe;\n  localValue = *(uint *)(baseAddress + 4);\n  firstValue = *data;\n  secondValue = data[2] | *(uint *)(baseAddress + 0x20) & 0xfffffffd;\n  if (baseAddress == 0x40012c00) {\n    secondValue = (data[3] | secondValue & 0xfffffff7) & 0xfffffffb;\n    localValue = data[6] | data[5] | localValue & 0xfffffcff;\n  }\n  *(uint *)(baseAddress + 4) = localValue;\n  *(uint *)(baseAddress + 0x18) = firstValue | *(uint *)(baseAddress + 0x18) & 0xffffff8c;\n  *(uint *)(baseAddress + 0x34) = data[1];\n  *(uint *)(baseAddress + 0x20) = secondValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003d60": "update_param_08003d60",
                "param_1": "baseAddress",
                "param_2": "data",
                "uVar1": "firstValue",
                "uVar2": "secondValue",
                "local_10": "localValue"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e38": {
            "entrypoint": "0x08003e38",
            "current_name": "update_param_08003e38",
            "code": "\nvoid updateParam_08003e38(int address,int *paramArray)\n\n{\n  int arrayValue;\n  uint updatedValue;\n  uint value;\n  \n  *(uint *)(address + 0x20) = *(uint *)(address + 0x20) & 0xffffffef;\n  value = *(uint *)(address + 4);\n  arrayValue = *paramArray;\n  updatedValue = paramArray[2] << 4 | *(uint *)(address + 0x20) & 0xffffffdf;\n  if (address == 0x40012c00) {\n    updatedValue = (paramArray[3] << 4 | updatedValue & 0xffffff7f) & 0xffffffbf;\n    value = paramArray[6] << 2 | paramArray[5] << 2 | value & 0xfffff3ff;\n  }\n  *(uint *)(address + 4) = value;\n  *(uint *)(address + 0x18) = arrayValue << 8 | *(uint *)(address + 0x18) & 0xffff8cff;\n  *(int *)(address + 0x38) = paramArray[1];\n  *(uint *)(address + 0x20) = updatedValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e38": "update_param_08003e38",
                "param_1": "address",
                "param_2": "paramArray",
                "iVar1": "arrayValue",
                "uVar2": "updatedValue",
                "local_10": "value"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f18": {
            "entrypoint": "0x08003f18",
            "current_name": "update_control_registers_08003f18",
            "code": "\nvoid updateControlRegisters_08003f18(int regBaseAddress,uint *registerValues)\n\n{\n  uint value1;\n  uint value2;\n  uint localValue;\n  \n  *(uint *)(regBaseAddress + 0x20) = *(uint *)(regBaseAddress + 0x20) & 0xfffffeff;\n  localValue = *(uint *)(regBaseAddress + 4);\n  value1 = *registerValues;\n  value2 = registerValues[2] << 8 | *(uint *)(regBaseAddress + 0x20) & 0xfffffdff;\n  if (regBaseAddress == 0x40012c00) {\n    value2 = (registerValues[3] << 8 | value2 & 0xfffff7ff) & 0xfffffbff;\n    localValue = registerValues[6] << 4 | registerValues[5] << 4 | localValue & 0xffffcfff;\n  }\n  *(uint *)(regBaseAddress + 4) = localValue;\n  *(uint *)(regBaseAddress + 0x1c) = value1 | *(uint *)(regBaseAddress + 0x1c) & 0xffffff8c;\n  *(uint *)(regBaseAddress + 0x3c) = registerValues[1];\n  *(uint *)(regBaseAddress + 0x20) = value2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f18": "update_control_registers_08003f18",
                "param_1": "regBaseAddress",
                "param_2": "registerValues",
                "uVar1": "value1",
                "uVar2": "value2",
                "local_10": "localValue"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ff8": {
            "entrypoint": "0x08003ff8",
            "current_name": "update_parameters_08003ff8",
            "code": "\nvoid updateParameters_08003ff8(int baseAddress,int *parameters)\n\n{\n  int value1;\n  int value2;\n  uint localValue;\n  \n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & 0xffffefff;\n  localValue = *(uint *)(baseAddress + 4);\n  value1 = *parameters;\n  value2 = parameters[2];\n  if (baseAddress == 0x40012c00) {\n    localValue = parameters[5] << 6 | localValue & 0xffffbfff;\n  }\n  *(uint *)(baseAddress + 4) = localValue;\n  *(uint *)(baseAddress + 0x1c) = value1 << 8 | *(uint *)(baseAddress + 0x1c) & 0xffff8cff;\n  *(int *)(baseAddress + 0x40) = parameters[1];\n  *(uint *)(baseAddress + 0x20) = value2 << 0xc | *(uint *)(baseAddress + 0x20) & 0xffffdfff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ff8": "update_parameters_08003ff8",
                "param_1": "baseAddress",
                "param_2": "parameters",
                "iVar1": "value1",
                "iVar2": "value2",
                "local_c": "localValue"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040a0": {
            "entrypoint": "0x080040a0",
            "current_name": "update_param_values_080040a0",
            "code": "\nvoid updateParamValues_080040a0(int input,uint value,int shiftAmount)\n\n{\n  uint previousValue;\n  \n  previousValue = *(uint *)(input + 0x20);\n  *(uint *)(input + 0x20) = *(uint *)(input + 0x20) & 0xfffffffe;\n  *(uint *)(input + 0x18) = shiftAmount << 4 | *(uint *)(input + 0x18) & 0xffffff0f;\n  *(uint *)(input + 0x20) = value | previousValue & 0xfffffff5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040a0": "update_param_values_080040a0",
                "param_1": "input",
                "param_2": "value",
                "param_3": "shiftAmount",
                "uVar1": "previousValue"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004104": {
            "entrypoint": "0x08004104",
            "current_name": "update_flags_and_values_08004104",
            "code": "\nvoid updateFlagsAndValues_08004104(int baseAddress,int value1,int value2)\n\n{\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & 0xffffffef;\n  *(uint *)(baseAddress + 0x18) = value2 << 0xc | *(uint *)(baseAddress + 0x18) & 0xffff0fff;\n  *(uint *)(baseAddress + 0x20) = value1 << 4 | *(uint *)(baseAddress + 0x20) & 0xffffff5f;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004104": "update_flags_and_values_08004104",
                "param_1": "baseAddress",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800416a": {
            "entrypoint": "0x0800416a",
            "current_name": "update_parameter_bits_0800416a",
            "code": "\nvoid updateParameterBits_0800416a(int ptr,ushort value)\n\n{\n  *(uint *)(ptr + 8) = *(uint *)(ptr + 8) & 0xffffff8f | (uint)(value | 7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800416a": "update_parameter_bits_0800416a",
                "param_1": "ptr",
                "param_2": "value"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041a8": {
            "entrypoint": "0x080041a8",
            "current_name": "update_parameter_value_080041a8",
            "code": "\nvoid updateParameterValue_080041a8(int memoryLocation,uint value1,uint value2,int value3)\n\n{\n  *(uint *)(memoryLocation + 8) = value1 | value3 << 8 | value2 | *(uint *)(memoryLocation + 8) & 0xffff00ff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041a8": "update_parameter_value_080041a8",
                "param_1": "memoryLocation",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041ea": {
            "entrypoint": "0x080041ea",
            "current_name": "update_bitwise_value_080041ea",
            "code": "\nvoid updateBitwiseValue_080041ea(int baseAddress,unsignedInt bitPosition,int bitValue)\n\n{\n  *(unsignedInt *)(baseAddress + 0x20) = *(unsignedInt *)(baseAddress + 0x20) & ~(1 << (bitPosition & 0xff));\n  *(unsignedInt *)(baseAddress + 0x20) = *(unsignedInt *)(baseAddress + 0x20) | bitValue << (bitPosition & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041ea": "update_bitwise_value_080041ea",
                "param_1": "baseAddress",
                "param_2": "bitPosition",
                "param_3": "bitValue",
                "uint": "unsignedInt"
            },
            "calling": [
                "FUN_080036a8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800422e": {
            "entrypoint": "0x0800422e",
            "current_name": "update_parameter_0800422e",
            "code": "\nundefined4 updateParameter_0800422e(int *parameterList,uint *dataList)\n\n{\n  undefined4 returnValue;\n  \n  if (*(char *)(parameterList + 0xf) == '\\x01') {\n    returnValue = 2;\n  }\n  else {\n    *(undefined *)(parameterList + 0xf) = 1;\n    *(uint *)(*parameterList + 0x44) =\n         dataList[6] |\n         (dataList[6] |\n         (dataList[5] |\n         (dataList[4] |\n         (*dataList | (dataList[1] | (dataList[2] | dataList[3] & 0xfffffcff) & 0xfffffbff) & 0xfffff7ff\n         ) & 0xffffefff) & 0xffffdfff) & 0xffffbfff) & 0xffff7fff;\n    *(undefined *)(parameterList + 0xf) = 0;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_0800422e": "update_parameter_0800422e",
                "param_1": "parameterList",
                "param_2": "dataList",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042de": {
            "entrypoint": "0x080042de",
            "current_name": "check_and_update_flags_080042de",
            "code": "\nundefined4 checkAndUpdateFlags_080042de(int *data,uint *flags)\n\n{\n  undefined4 result;\n  \n  if (*(char *)(data + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(data + 0xf) = 1;\n    *(undefined *)((int)data + 0x3d) = 2;\n    *(uint *)(*data + 4) = *(uint *)(*data + 4) & 0xffffff8f;\n    *(uint *)(*data + 4) = *flags | *(uint *)(*data + 4);\n    *(uint *)(*data + 8) = *(uint *)(*data + 8) & 0xffffff7f;\n    *(uint *)(*data + 8) = flags[1] | *(uint *)(*data + 8);\n    *(undefined *)((int)data + 0x3d) = 1;\n    *(undefined *)(data + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080042de": "check_and_update_flags_080042de",
                "param_1": "data",
                "param_2": "flags",
                "uVar1": "result"
            },
            "calling": [
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004366": {
            "entrypoint": "0x08004366",
            "current_name": "FUNC_08004366",
            "code": "\nvoid FUNC_08004366(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004366": "FUNC_08004366"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004378": {
            "entrypoint": "0x08004378",
            "current_name": "FUNC_08004378",
            "code": "\nvoid FUNC_08004378(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004378": "FUNC_08004378"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800438a": {
            "entrypoint": "0x0800438a",
            "current_name": "initialize_data_0800438a",
            "code": "\nundefined4 initializeData_0800438a(int *dataPointer)\n\n{\n  undefined4 returnValue;\n  \n  if (dataPointer == (int *)0x0) {\n    returnValue = 1;\n  }\n  else {\n    if (*(char *)((int)dataPointer + 0x39) == '\\0') {\n      *(undefined *)(dataPointer + 0xe) = 0;\n      FUNC_08004424(dataPointer);\n    }\n    *(undefined *)((int)dataPointer + 0x39) = 0x24;\n    *(uint *)(*dataPointer + 0xc) = *(uint *)(*dataPointer + 0xc) & 0xffffdfff;\n    FUN_080046ec(dataPointer);\n    *(uint *)(*dataPointer + 0x10) = *(uint *)(*dataPointer + 0x10) & 0xffffb7ff;\n    *(uint *)(*dataPointer + 0x14) = *(uint *)(*dataPointer + 0x14) & 0xffffffd5;\n    *(uint *)(*dataPointer + 0xc) = *(uint *)(*dataPointer + 0xc) | 0x2000;\n    dataValue = 0;\n    *(undefined *)((int)dataPointer + 0x39) = 0x20;\n    *(undefined *)((int)dataPointer + 0x3a) = 0x20;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_0800438a": "initialize_data_0800438a",
                "param_1": "dataPointer",
                "uVar1": "returnValue",
                "param_1[0xf]": "dataValue"
            },
            "calling": [
                "FUN_08005598"
            ],
            "called": [
                "FUN_080046ec",
                "FUN_08004424"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004424": {
            "entrypoint": "0x08004424",
            "current_name": "FUNC_08004424",
            "code": "\nvoid FUNC_08004424(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004424": "FUNC_08004424"
            },
            "calling": [
                "FUN_0800438a"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004436": {
            "entrypoint": "0x08004436",
            "current_name": "process_data_08004436",
            "code": "\nundefined4 process_data_08004436(uint **data_array,ushort *input_array,short input_length,uint timeout)\n\n{\n  int result;\n  int temp_result;\n  undefined4 return_value;\n  ushort *current_input;\n  \n  if (*(char *)((int)data_array + 0x39) == ' ') {\n    if ((input_array == (ushort *)0x0) || (input_length == 0)) {\n      return_value = 1;\n    }\n    else if (*(char *)(data_array + 0xe) == '\\x01') {\n      return_value = 2;\n    }\n    else {\n      *(undefined *)(data_array + 0xe) = 1;\n      data_array[0xf] = (uint *)0x0;\n      *(undefined *)((int)data_array + 0x39) = 0x21;\n      result = FUN_080015a0();\n      *(short *)(data_array + 9) = input_length;\n      *(short *)((int)data_array + 0x26) = input_length;\n      current_input = input_array;\n      while (*(short *)((int)data_array + 0x26) != 0) {\n        *(short *)((int)data_array + 0x26) = *(short *)((int)data_array + 0x26) + -1;\n        if (data_array[2] == (uint *)0x1000) {\n          do {\n            if ((**data_array & 0x80) == 0x80) {\n              temp_result = 0;\n              goto LAB_0800454c;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (temp_result = FUN_080015a0(), (uint)(temp_result - result) <= timeout))));\n          (*data_array)[3] = (*data_array)[3] & 0xfffffe5f;\n          (*data_array)[5] = (*data_array)[5] & 0xfffffffe;\n          *(undefined *)((int)data_array + 0x39) = 0x20;\n          *(undefined *)((int)data_array + 0x3a) = 0x20;\n          *(undefined *)(data_array + 0xe) = 0;\n          temp_result = 3;\nLAB_0800454c:\n          if (temp_result != 0) {\n            return 3;\n          }\n          (*data_array)[1] = *current_input & 0x1ff;\n          if (data_array[4] == (uint *)0x0) {\n            current_input = current_input + 1;\n          }\n          else {\n            current_input = (ushort *)((int)current_input + 1);\n          }\n        }\n        else {\n          do {\n            if ((**data_array & 0x80) == 0x80) {\n              temp_result = 0;\n              goto LAB_08004614;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (temp_result = FUN_080015a0(), (uint)(temp_result - result) <= timeout))));\n          (*data_array)[3] = (*data_array)[3] & 0xfffffe5f;\n          (*data_array)[5] = (*data_array)[5] & 0xfffffffe;\n          *(undefined *)((int)data_array + 0x39) = 0x20;\n          *(undefined *)((int)data_array + 0x3a) = 0x20;\n          *(undefined *)(data_array + 0xe) = 0;\n          temp_result = 3;\nLAB_08004614:\n          if (temp_result != 0) {\n            return 3;\n          }\n          (*data_array)[1] = (uint)*(byte *)current_input;\n          current_input = (ushort *)((int)current_input + 1);\n        }\n      }\n      do {\n        if ((**data_array & 0x40) == 0x40) {\n          result = 0;\n          goto LAB_080046c6;\n        }\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (temp_result = FUN_080015a0(), (uint)(temp_result - result) <= timeout))));\n      (*data_array)[3] = (*data_array)[3] & 0xfffffe5f;\n      (*data_array)[5] = (*data_array)[5] & 0xfffffffe;\n      *(undefined *)((int)data_array + 0x39) = 0x20;\n      *(undefined *)((int)data_array + 0x3a) = 0x20;\n      *(undefined *)(data_array + 0xe) = 0;\n      result = 3;\nLAB_080046c6:\n      if (result == 0) {\n        *(undefined *)((int)data_array + 0x39) = 0x20;\n        *(undefined *)(data_array + 0xe) = 0;\n        return_value = 0;\n      }\n      else {\n        return_value = 3;\n      }\n    }\n  }\n  else {\n    return_value = 2;\n  }\n  return return_value;\n}\n\n",
            "renaming": {
                "FUN_08004436": "process_data_08004436",
                "param_1": "data_array",
                "param_2": "input_array",
                "param_3": "input_length",
                "param_4": "timeout",
                "iVar1": "result",
                "iVar2": "temp_result",
                "uVar3": "return_value",
                "local_58": "current_input"
            },
            "calling": [
                "FUN_08004f3c"
            ],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046ec": {
            "entrypoint": "0x080046ec",
            "current_name": "update_configuration_080046ec",
            "code": "\nvoid updateConfiguration_080046ec(int *config)\n\n{\n  ulonglong temp1;\n  int temp2;\n  int temp3;\n  uint temp4;\n  int temp5;\n  undefined8 temp6;\n  \n  *(uint *)(*config + 0x10) = config[3] | *(uint *)(*config + 0x10) & 0xffffcfff;\n  *(uint *)(*config + 0xc) =\n       *(uint *)(*config + 0xc) & 0xffffe9f3 | config[5] | config[2] | config[4];\n  *(uint *)(*config + 0x14) = config[6] | *(uint *)(*config + 0x14) & 0xfffffcff;\n  if (*config == 0x40013800) {\n    temp6 = FUN_08003540();\n    temp1 = (ulonglong)(uint)((int)temp6 * 0x19) / (ulonglong)(uint)(config[1] << 2);\n    temp2 = FUN_08003540((int)temp6,(int)((ulonglong)temp6 >> 0x20),(int)(temp1 * 0x51eb851f));\n    temp3 = config[1];\n    temp6 = FUN_08003540();\n    temp4 = ((uint)(temp2 * 0x19) / (uint)(temp3 << 2) +\n            (int)(((ulonglong)(uint)((int)temp6 * 0x19) / (ulonglong)(uint)(config[1] << 2)) / 100)\n            * -100) * 0x10 + 0x32;\n    temp2 = FUN_08003540((int)temp6,(int)((ulonglong)temp6 >> 0x20),temp4 * 0x51eb851f);\n    temp5 = config[1];\n    temp3 = FUN_08003540();\n    *(uint *)(*config + 8) =\n         ((((uint)(temp2 * 0x19) / (uint)(temp5 << 2) +\n           (int)(((ulonglong)(uint)(temp3 * 0x19) / (ulonglong)(uint)(config[1] << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) + (int)(temp1 / 100) * 0x10 + (temp4 / 100 & 0xf0);\n  }\n  else {\n    temp6 = FUN_08003518();\n    temp1 = (ulonglong)(uint)((int)temp6 * 0x19) / (ulonglong)(uint)(config[1] << 2);\n    temp2 = FUN_08003518((int)temp6,(int)((ulonglong)temp6 >> 0x20),(int)(temp1 * 0x51eb851f));\n    temp3 = config[1];\n    temp6 = FUN_08003518();\n    temp4 = ((uint)(temp2 * 0x19) / (uint)(temp3 << 2) +\n            (int)(((ulonglong)(uint)((int)temp6 * 0x19) / (ulonglong)(uint)(config[1] << 2)) / 100)\n            * -100) * 0x10 + 0x32;\n    temp2 = FUN_08003518((int)temp6,(int)((ulonglong)temp6 >> 0x20),temp4 * 0x51eb851f);\n    temp5 = config[1];\n    temp3 = FUN_08003518();\n    *(uint *)(*config + 8) =\n         ((((uint)(temp2 * 0x19) / (uint)(temp5 << 2) +\n           (int)(((ulonglong)(uint)(temp3 * 0x19) / (ulonglong)(uint)(config[1] << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) + (int)(temp1 / 100) * 0x10 + (temp4 / 100 & 0xf0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046ec": "update_configuration_080046ec",
                "param_1": "config",
                "uVar1": "temp1",
                "iVar2": "temp2",
                "iVar3": "temp3",
                "uVar4": "temp4",
                "iVar5": "temp5",
                "uVar6": "temp6"
            },
            "calling": [
                "FUN_0800438a"
            ],
            "called": [
                "FUN_08003540",
                "FUN_08003518"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800491c": {
            "entrypoint": "0x0800491c",
            "current_name": "initialize_data_0800491c",
            "code": "\nvoid initialize_data_0800491c(undefined4 *data_array)\n\n{\n  undefined byte_zero;\n  undefined byte_sixteen;\n  undefined byte_array [5];\n  \n  byte_zero = 0;\n  (*DAT_20000a54)(0xd0,0x6b,&byte_zero,1);\n  byte_sixteen = 0x10;\n  (*DAT_20000a54)(0xd0,0x1c,&byte_sixteen,1);\n  byte_array[0] = 8;\n  (*DAT_20000a54)(0xd0,0x1b,byte_array,1);\n  *data_array = 0;\n  data_array[1] = 0;\n  data_array[2] = 0;\n  data_array[3] = 0;\n  data_array[4] = 0;\n  data_array[5] = 0;\n  data_array[6] = 0;\n  data_array[7] = 0;\n  data_array[8] = 0;\n  data_array[9] = 0;\n  data_array[10] = 0;\n  FUN_080049cc(data_array);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800491c": "initialize_data_0800491c",
                "param_1": "data_array",
                "local_13": "byte_zero",
                "local_12": "byte_sixteen",
                "local_11": "byte_array"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_080049cc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049cc": {
            "entrypoint": "0x080049cc",
            "current_name": "calculate_sums_080049cc",
            "code": "\nvoid calculate_sums_080049cc(int input)\n\n{\n  undefined4 uVar1;\n  undefined4 temp_data_2;\n  undefined4 temp_data_1;\n  undefined4 getCurrentTime;\n  int iteration_count;\n  int iteration;\n  undefined4 temp_sum_2;\n  undefined4 temp_sum_1;\n  undefined4 sum_2;\n  undefined4 sum_1;\n  \n  iteration_count = 1;\n  sum_1 = 0;\n  sum_2 = 0;\n  temp_sum_1 = 0;\n  temp_sum_2 = 0;\n  getCurrentTime = (*DAT_20000a50)();\n  iteration = 0;\n  while( true ) {\n    if (iteration_count <= iteration) break;\n    temp_data_1 = 0;\n    temp_data_2 = 0;\n    FUN_08004ae0(input);\n    FUN_08004d78(input,&temp_data_1,&temp_data_2);\n    temp_sum_1 = FUN_08000aa8(temp_sum_1,temp_data_1);\n    temp_sum_2 = FUN_08000aa8(temp_sum_2,temp_data_2);\n    sum_1 = FUN_08000aa8(sum_1,*(undefined4 *)(input + 0x10));\n    sum_2 = FUN_08000aa8(sum_2,*(undefined4 *)(input + 0x14));\n    getCurrentTime = (*DAT_20000a50)();\n    iteration = iteration + 1;\n  }\n  uVar1 = FUN_08000c10(iteration_count);\n  uVar1 = FUN_08000e20(sum_1,uVar1);\n  *(undefined4 *)(input + 0x1c) = uVar1;\n  uVar1 = FUN_08000c10(iteration_count);\n  uVar1 = FUN_08000e20(sum_2,uVar1);\n  *(undefined4 *)(input + 0x20) = uVar1;\n  uVar1 = FUN_08000c10(iteration_count);\n  uVar1 = FUN_08000e20(temp_sum_1,uVar1);\n  *(undefined4 *)(input + 0x24) = uVar1;\n  uVar1 = FUN_08000c10(iteration_count);\n  uVar1 = FUN_08000e20(temp_sum_2,uVar1);\n  *(undefined4 *)(input + 0x28) = uVar1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080049cc": "calculate_sums_080049cc",
                "param_1": "input",
                "local_20": "iteration_count",
                "local_c": "sum_1",
                "local_10": "sum_2",
                "local_14": "temp_sum_1",
                "local_18": "temp_sum_2",
                "local_24": "getCurrentTime",
                "local_1c": "iteration",
                "local_28": "temp_data_1",
                "local_2c": "temp_data_2"
            },
            "calling": [
                "FUN_0800491c"
            ],
            "called": [
                "FUN_08004d78",
                "FUN_08000e20",
                "FUN_08004ae0",
                "FUN_08000aa8",
                "FUN_08000c10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ae0": {
            "entrypoint": "0x08004ae0",
            "current_name": "copy_data_to_param_08004ae0",
            "code": "\nvoid copy_data_to_param_08004ae0(undefined4 *output_data)\n\n{\n  undefined4 result;\n  undefined byte_1;\n  undefined byte_2;\n  undefined byte_3;\n  undefined byte_4;\n  undefined byte_5;\n  undefined byte_6;\n  undefined byte_7;\n  undefined byte_8;\n  undefined byte_9;\n  undefined byte_10;\n  undefined byte_11;\n  undefined byte_12;\n  undefined byte_13;\n  undefined byte_14;\n  short short_1;\n  short short_2;\n  short short_3;\n  short short_4;\n  short short_5;\n  short short_6;\n  \n  (*DAT_20000a4c)(0xd0,0x3b,&byte_1,0xe);\n  short_6 = CONCAT11(byte_3,byte_4);\n  short_5 = CONCAT11(byte_5,byte_6);\n  short_4 = CONCAT11(byte_7,byte_8);\n  short_3 = CONCAT11(byte_9,byte_10);\n  short_2 = CONCAT11(byte_11,byte_12);\n  short_1 = CONCAT11(byte_13,byte_14);\n  result = FUN_08000c10((int)CONCAT11(byte_1,byte_2));\n  *output_data = result;\n  result = FUN_08000c10((int)short_6);\n  output_data[1] = result;\n  result = FUN_08000c10((int)short_5);\n  output_data[2] = result;\n  result = FUN_08000c10((int)short_4);\n  output_data[3] = result;\n  result = FUN_08000c10((int)short_3);\n  output_data[4] = result;\n  result = FUN_08000c10((int)short_2);\n  output_data[5] = result;\n  result = FUN_08000c10((int)short_1);\n  output_data[6] = result;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ae0": "copy_data_to_param_08004ae0",
                "param_1": "output_data",
                "local_2c": "byte_1",
                "local_2b": "byte_2",
                "local_2a": "byte_3",
                "local_29": "byte_4",
                "local_28": "byte_5",
                "local_27": "byte_6",
                "local_26": "byte_7",
                "local_25": "byte_8",
                "local_24": "byte_9",
                "local_23": "byte_10",
                "local_22": "byte_11",
                "local_21": "byte_12",
                "local_20": "byte_13",
                "local_1f": "byte_14",
                "local_1e": "short_1",
                "local_1c": "short_2",
                "local_1a": "short_3",
                "local_18": "short_4",
                "local_16": "short_5",
                "local_14": "short_6",
                "uVar1": "result"
            },
            "calling": [
                "FUN_080049cc",
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08000c10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bd8": {
            "entrypoint": "0x08004bd8",
            "current_name": "calculate_result_08004bd8",
            "code": "\nvoid calculateResult_08004bd8(int inputArray,undefined4 *outputValue)\n\n{\n  undefined4 result1;\n  undefined8 result2;\n  undefined8 result3;\n  \n  result1 = FUN_08000aa4(*(undefined4 *)(inputArray + 0x10),*(undefined4 *)(inputArray + 0x1c));\n  result2 = FUN_08000418(DAT_200009e4);\n  result3 = FUN_08000418(result1);\n  result3 = FUN_080004c8((int)result3,(int)((ulonglong)result3 >> 0x20),0x83f5c366,0x3f340215);\n  result2 = FUN_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result3,\n                       (int)((ulonglong)result3 >> 0x20));\n  DAT_200009e4 = FUN_080009fc((int)result2,(int)((ulonglong)result2 >> 0x20));\n  result2 = FUN_08000418(*(undefined4 *)(inputArray + 4));\n  result2 = FUN_0800071c((int)result2,(int)((ulonglong)result2 >> 0x20),0,0x40b00000);\n  result3 = FUN_08000418(*(undefined4 *)(inputArray + 8));\n  result3 = FUN_0800071c((int)result3,(int)((ulonglong)result3 >> 0x20),0,0x40b00000);\n  result2 = thunk_FUN_08005838((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result3,\n                             (int)((ulonglong)result3 >> 0x20));\n  result2 = FUN_080004c8((int)result2,(int)((ulonglong)result2 >> 0x20),0,0x40668000);\n  result2 = FUN_0800071c((int)result2,(int)((ulonglong)result2 >> 0x20),0x54442d18,0x400921fb);\n  result3 = FUN_08000418(*(undefined4 *)(inputArray + 0x24));\n  result2 = FUN_08000158((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result3,\n                       (int)((ulonglong)result3 >> 0x20));\n  result2 = FUN_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),0,0x40568000);\n  result1 = FUN_080009fc((int)result2,(int)((ulonglong)result2 >> 0x20));\n  if (DAT_20000005 == '\\0') {\n    result2 = FUN_08000418(DAT_200009e4);\n    result2 = FUN_080004c8((int)result2,(int)((ulonglong)result2 >> 0x20),0x9999999a,0x3fe99999);\n    result3 = FUN_08000418(result1);\n    result3 = FUN_080004c8((int)result3,(int)((ulonglong)result3 >> 0x20),0x9999999a,0x3fc99999);\n    result2 = FUN_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result3,\n                         (int)((ulonglong)result3 >> 0x20));\n    DAT_200009e4 = FUN_080009fc((int)result2,(int)((ulonglong)result2 >> 0x20));\n  }\n  else {\n    DAT_20000005 = '\\0';\n    DAT_200009e4 = result1;\n  }\n  *outputValue = DAT_200009e4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bd8": "calculate_result_08004bd8",
                "param_1": "inputArray",
                "param_2": "outputValue",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "result3"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08000aa4",
                "thunk_FUN_08005838",
                "FUN_0800015c",
                "FUN_080004c8",
                "FUN_080009fc",
                "FUN_08000418",
                "FUN_0800071c",
                "FUN_08000158"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d78": {
            "entrypoint": "0x08004d78",
            "current_name": "calculate_values_08004d78",
            "code": "\nvoid calculateValues_08004d78(undefined4 *inputArray,undefined4 *outputValue1,undefined4 *outputValue2)\n\n{\n  undefined4 result1;\n  undefined4 result2;\n  undefined4 result3;\n  undefined8 tempValue1;\n  undefined8 tempValue2;\n  \n  result1 = FUN_08000e20(*inputArray,0x45800000);\n  result2 = FUN_08000e20(inputArray[1],0x45800000);\n  result3 = FUN_08000e20(inputArray[2],0x45800000);\n  tempValue1 = FUN_08000418(result2);\n  tempValue2 = FUN_08000418(result3);\n  tempValue1 = thunk_FUN_08005838((int)tempValue1,(int)((ulonglong)tempValue1 >> 0x20),(int)tempValue2,\n                             (int)((ulonglong)tempValue2 >> 0x20));\n  tempValue1 = FUN_080004c8((int)tempValue1,(int)((ulonglong)tempValue1 >> 0x20),0,0x40668000);\n  tempValue1 = FUN_0800071c((int)tempValue1,(int)((ulonglong)tempValue1 >> 0x20),0x54442d18,0x400921fb);\n  result2 = FUN_080009fc((int)tempValue1,(int)((ulonglong)tempValue1 >> 0x20));\n  tempValue1 = FUN_08000418(result1);\n  tempValue2 = FUN_08000418(result3);\n  tempValue1 = thunk_FUN_08005838((int)tempValue1,(int)((ulonglong)tempValue1 >> 0x20),(int)tempValue2,\n                             (int)((ulonglong)tempValue2 >> 0x20));\n  tempValue1 = FUN_080004c8((int)tempValue1,(int)((ulonglong)tempValue1 >> 0x20),0,0x40668000);\n  tempValue1 = FUN_0800071c((int)tempValue1,(int)((ulonglong)tempValue1 >> 0x20),0x54442d18,0x400921fb);\n  result1 = FUN_080009fc((int)tempValue1,(int)((ulonglong)tempValue1 >> 0x20));\n  *outputValue1 = result2;\n  *outputValue2 = result1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d78": "calculate_values_08004d78",
                "param_1": "inputArray",
                "param_2": "outputValue1",
                "param_3": "outputValue2",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "result3",
                "uVar4": "tempValue1",
                "uVar5": "tempValue2"
            },
            "calling": [
                "FUN_080049cc"
            ],
            "called": [
                "FUN_08000e20",
                "thunk_FUN_08005838",
                "FUN_080004c8",
                "FUN_080009fc",
                "FUN_08000418",
                "FUN_0800071c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e6c": {
            "entrypoint": "0x08004e6c",
            "current_name": "invoke_system_interrupt_08004e6c",
            "code": "\nvoid invoke_system_interrupt_08004e6c(void)\n\n{\n  software_interrupt(0x3f);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e6c": "invoke_system_interrupt_08004e6c"
            },
            "calling": [
                "FUN_08004e74"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e74": {
            "entrypoint": "0x08004e74",
            "current_name": "initialize_data_if_needed_08004e74",
            "code": "\nundefined4 initializeDataIfNeeded_08004e74(undefined4 inputData)\n\n{\n  undefined4 returnValue;\n  \n  if (DAT_200009f0 == 0) {\n    returnValue = FUN_08004e6c(1,inputData,0);\n  }\n  else {\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08004e74": "initialize_data_if_needed_08004e74",
                "param_1": "inputData",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08004e6c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ea4": {
            "entrypoint": "0x08004ea4",
            "current_name": "initialize_data_08004ea4",
            "code": "\nvoid initializeData_08004ea4(undefined dataPointer,undefined dataType,undefined4 length,undefined2 options)\n\n{\n  FUN_08001ccc(&DAT_20000a88,dataPointer,dataType,1,length,options,DAT_20000008);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ea4": "initialize_data_08004ea4",
                "param_1": "dataPointer",
                "param_2": "dataType",
                "param_3": "length",
                "param_4": "options"
            },
            "calling": [],
            "called": [
                "FUN_08001ccc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee8": {
            "entrypoint": "0x08004ee8",
            "current_name": "execute_data_transmission_08004ee8",
            "code": "\nvoid executeDataTransmission_08004ee8(undefined dataBuffer,undefined dataLength,undefined4 transmitType,undefined2 transmitFlag)\n\n{\n  FUN_08001f6c(&DAT_20000a88,dataBuffer,dataLength,1,transmitType,transmitFlag,DAT_20000008);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ee8": "execute_data_transmission_08004ee8",
                "param_1": "dataBuffer",
                "param_2": "dataLength",
                "param_3": "transmitType",
                "param_4": "transmitFlag"
            },
            "calling": [],
            "called": [
                "FUN_08001f6c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f2c": {
            "entrypoint": "0x08004f2c",
            "current_name": "get_return_value_08004f2c",
            "code": "\nundefined4 getReturnValue_08004f2c(void)\n\n{\n  undefined4 returnValue;\n  \n  returnValue = FUN_080015a0();\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08004f2c": "get_return_value_08004f2c",
                "uVar1": "returnValue"
            },
            "calling": [],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "initialize_data_08004f3c",
            "code": "\nvoid initializeData_08004f3c(undefined4 dataPointer,undefined2 dataSize)\n\n{\n  FUN_08004436(&DAT_20000adc,dataPointer,dataSize,0x32);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "initialize_data_08004f3c",
                "param_1": "dataPointer",
                "param_2": "dataSize"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08004436"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f60": {
            "entrypoint": "0x08004f60",
            "current_name": "initialize_data_08004f60",
            "code": "\nvoid initializeData_08004f60(void)\n\n{\n  FUN_08005d68(&DAT_20000ba8,0,0x40);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f60": "initialize_data_08004f60"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08005d68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f78": {
            "entrypoint": "0x08004f78",
            "current_name": "calculate_pitch_08004f78",
            "code": "\nvoid calculatePitch_08004f78(void)\n\n{\n  undefined4 result1;\n  int returnValue;\n  undefined4 result2;\n  uint xorValue;\n  undefined8 pitchValue;\n  byte pitchLevel;\n  \n  FUN_08004ae0(&DAT_20000a5c);\n  FUN_08004bd8(&DAT_20000a5c,&DAT_20000ba0);\n  FUN_08004f60();\n  pitchValue = FUN_08000418(DAT_20000ba0);\n  FUN_08005dfc(&DAT_20000ba8,\"Pitch: %f\\n\",(int)pitchValue,(int)((ulonglong)pitchValue >> 0x20));\n  result1 = FUN_08005e40(&DAT_20000ba8);\n  FUN_08004f3c(&DAT_20000ba8,result1);\n  DAT_200009f8 = FUN_08000aa4(DAT_20000014,DAT_20000ba0);\n  DAT_20000be8 = FUN_08000cb8(DAT_20000a00,DAT_200009f8);\n  result1 = FUN_08000cb8(DAT_20000a04,DAT_200009f8);\n  DAT_20000b5c = FUN_08000aa8(result1,DAT_20000b5c);\n  result1 = FUN_08000c10(DAT_20000010);\n  returnValue = FUN_08000ff4(result1,DAT_20000b5c);\n  if (returnValue == 0) {\n    result1 = FUN_08000c10(DAT_200009f4);\n    returnValue = FUN_08001030(result1,DAT_20000b5c);\n    if (returnValue != 0) {\n      DAT_20000b5c = FUN_08000c08(DAT_200009f4);\n    }\n  }\n  else {\n    DAT_20000b5c = FUN_08000c08(DAT_20000010);\n  }\n  xorValue = DAT_20000a08 ^ 0x80000000;\n  result1 = FUN_08000aa4(DAT_200009f8,DAT_200009fc);\n  DAT_20000a58 = FUN_08000cb8(xorValue,result1);\n  result1 = FUN_08000aa8(DAT_20000be8,DAT_20000b5c);\n  result1 = FUN_08000aa8(result1,DAT_20000a58);\n  result2 = FUN_08000c10(DAT_20000010);\n  returnValue = FUN_08001030(result1,result2);\n  if (returnValue == 0) {\n    result2 = FUN_08000c10(DAT_200009f4);\n    returnValue = FUN_08000ff4(result1,result2);\n    if (returnValue == 0) {\n      pitchLevel = FUN_08001044(result1);\n    }\n    else {\n      pitchLevel = DAT_200009f4;\n    }\n  }\n  else {\n    pitchLevel = DAT_20000010;\n  }\n  DAT_200009fc = DAT_200009f8;\n  returnValue = FUN_08001030(DAT_200009f8,0);\n  FUN_08001a80(0x40010800,2,returnValue != 0);\n  returnValue = FUN_08001030(DAT_200009f8,0);\n  FUN_08001a80(0x40010800,4,returnValue == 0);\n  returnValue = FUN_08001030(DAT_200009f8,0);\n  FUN_08001a80(0x40010800,8,returnValue != 0);\n  returnValue = FUN_08001030(DAT_200009f8,0);\n  FUN_08001a80(0x40010800,0x10,returnValue == 0);\n  *(uint *)(DAT_20000b1c + 0x34) = (uint)pitchLevel;\n  *(uint *)(DAT_20000b1c + 0x40) = (uint)pitchLevel;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f78": "calculate_pitch_08004f78",
                "uVar1": "result1",
                "iVar2": "returnValue",
                "uVar3": "result2",
                "uVar4": "xorValue",
                "uVar5": "pitchValue",
                "local_11": "pitchLevel"
            },
            "calling": [
                "FUN_080036f8",
                "FUN_080017b4"
            ],
            "called": [
                "FUN_08001044",
                "FUN_08004f60",
                "FUN_08005dfc",
                "FUN_08000cb8",
                "FUN_08001a80",
                "FUN_08004bd8",
                "FUN_08005e40",
                "FUN_08000c08",
                "FUN_08000aa4",
                "FUN_08000aa8",
                "FUN_08004ae0",
                "FUN_08000ff4",
                "FUN_08004f3c",
                "FUN_08000c10",
                "FUN_08001030",
                "FUN_08000418"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005224": {
            "entrypoint": "0x08005224",
            "current_name": "initialize_program_08005224",
            "code": "\nvoid initializeProgram_08005224(void)\n\n{\n  FUN_080014f0();\n  FUN_080052a0();\n  FUN_080055f4();\n  FUN_08005348();\n  FUN_08005598();\n  FUN_08005500();\n  FUN_080053b0();\n  DAT_20000a54 = 0x8004ea5;\n  DAT_20000a4c = 0x8004ee9;\n  DAT_20000a50 = 0x8004f2d;\n  FUN_080036a8(&DAT_20000b1c,0);\n  FUN_080036a8(&DAT_20000b1c,0xc);\n  FUN_0800491c(&DAT_20000a5c);\n  FUN_0800360c(&DAT_20000b60);\n  FUN_08004e74(0);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005224": "initialize_program_08005224"
            },
            "calling": [
                "entry"
            ],
            "called": [
                "FUN_08005348",
                "FUN_0800360c",
                "FUN_08005598",
                "FUN_080052a0",
                "FUN_08004e74",
                "FUN_080036a8",
                "FUN_080055f4",
                "FUN_0800491c",
                "FUN_080014f0",
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052a0": {
            "entrypoint": "0x080052a0",
            "current_name": "initialize_application_080052a0",
            "code": "\nvoid initializeApplication_080052a0(void)\n\n{\n  int returnValue;\n  undefined8 timestamp;\n  undefined4 pattern;\n  undefined4 count;\n  undefined4 blockSize;\n  undefined4 flag3;\n  undefined4 flag4;\n  undefined4 isInitialized;\n  undefined4 memoryAllocation;\n  undefined4 counter;\n  undefined4 flag1;\n  undefined4 flag2;\n  undefined4 bufferSize;\n  undefined4 dataBlock;\n  \n  isInitialized = 1;\n  memoryAllocation = 0x10000;\n  counter = 0;\n  flag1 = 1;\n  flag2 = 2;\n  bufferSize = 0x10000;\n  dataBlock = 0x1c0000;\n  returnValue = FUN_08002d98(&isInitialized);\n  if (returnValue != 0) {\n    FUN_08005674(\"../src/main.c\",0x151);\n  }\n  pattern = 0xf;\n  count = 2;\n  blockSize = 0x80;\n  flag3 = 0;\n  flag4 = 0;\n  returnValue = FUN_08003260(&pattern,2);\n  if (returnValue != 0) {\n    FUN_08005674(\"../src/main.c\",0x15e);\n  }\n  timestamp = FUN_08003504();\n  FUN_08001762((uint)timestamp / 1000,(int)((ulonglong)timestamp >> 0x20),(uint)timestamp * 0x10624dd3);\n  FUN_0800177c(4);\n  FUN_0800172a(0xffffffff,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052a0": "initialize_application_080052a0",
                "local_30": "isInitialized",
                "local_2c": "memoryAllocation",
                "local_28": "counter",
                "local_20": "flag1",
                "local_14": "flag2",
                "local_10": "bufferSize",
                "local_c": "dataBlock",
                "iVar1": "returnValue",
                "local_44": "pattern",
                "local_40": "count",
                "local_3c": "blockSize",
                "local_38": "flag3",
                "local_34": "flag4",
                "uVar2": "timestamp"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_0800177c",
                "FUN_08003260",
                "FUN_08005674",
                "FUN_08001762",
                "FUN_0800172a",
                "FUN_08003504",
                "FUN_08002d98"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005348": {
            "entrypoint": "0x08005348",
            "current_name": "initialize_data_08005348",
            "code": "\nvoid initializeData_08005348(void)\n\n{\n  int errorCode;\n  \n  DAT_20000a88 = 0x40005400;\n  DAT_20000a8c = 400000;\n  DAT_20000a90 = 0;\n  DAT_20000a94 = 0;\n  DAT_20000a98 = 0x4000;\n  DAT_20000a9c = 0;\n  DAT_20000aa0 = 0;\n  DAT_20000aa4 = 0;\n  DAT_20000aa8 = 0;\n  errorCode = FUN_08001ab0(&DAT_20000a88);\n  if (errorCode != 0) {\n    FUN_08005674(\"../src/main.c\",0x17a);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005348": "initialize_data_08005348",
                "iVar1": "errorCode"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08001ab0",
                "FUN_08005674"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053b0": {
            "entrypoint": "0x080053b0",
            "current_name": "initialize_program_080053b0",
            "code": "\nvoid initializeProgram_080053b0(void)\n\n{\n  int iVar1;\n  undefined4 countA;\n  undefined4 countB;\n  undefined4 countC;\n  undefined4 countD;\n  undefined4 countE;\n  undefined4 bufferSize;\n  undefined4 countF;\n  undefined4 countG;\n  undefined4 countH;\n  undefined4 countI;\n  undefined4 countJ;\n  undefined4 countK;\n  undefined4 countL;\n  undefined4 countM;\n  undefined4 countN;\n  undefined4 countO;\n  undefined4 countArray [4];\n  \n  DAT_20000b1c = 0x40012c00;\n  DAT_20000b20 = 0x708;\n  DAT_20000b24 = 0;\n  DAT_20000b28 = 100;\n  DAT_20000b2c = 0;\n  DAT_20000b30 = 0;\n  DAT_20000b34 = 0;\n  iVar1 = FUN_080035a4(&DAT_20000b1c);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",399);\n  }\n  countArray[0] = 0x1000;\n  iVar1 = FUN_08003a94(&DAT_20000b1c,countArray);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",0x194);\n  }\n  iVar1 = FUN_08003640(&DAT_20000b1c);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",0x198);\n  }\n  countN = 0;\n  countO = 0;\n  iVar1 = FUN_080042de(&DAT_20000b1c,&countN);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",0x19f);\n  }\n  countG = 0x60;\n  countH = 0;\n  countI = 0;\n  countJ = 0;\n  countK = 0;\n  countL = 0;\n  countM = 0;\n  iVar1 = FUN_08003908(&DAT_20000b1c,&countG,0);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",0x1ab);\n  }\n  iVar1 = FUN_08003908(&DAT_20000b1c,&countG,0xc);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",0x1b0);\n  }\n  countA = 0;\n  countB = 0;\n  countC = 0;\n  countD = 0;\n  countE = 0;\n  bufferSize = 0x2000;\n  countF = 0;\n  iVar1 = FUN_0800422e(&DAT_20000b1c,&countA);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",0x1bc);\n  }\n  FUN_08005680(&DAT_20000b1c);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053b0": "initialize_program_080053b0",
                "local_58": "countA",
                "local_54": "countB",
                "local_50": "countC",
                "local_4c": "countD",
                "local_48": "countE",
                "local_44": "bufferSize",
                "local_40": "countF",
                "local_3c": "countG",
                "local_38": "countH",
                "local_34": "countI",
                "local_30": "countJ",
                "local_2c": "countK",
                "local_28": "countL",
                "local_24": "countM",
                "local_20": "countN",
                "local_1c": "countO",
                "local_18": "countArray"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08003640",
                "FUN_08003908",
                "FUN_08005674",
                "FUN_0800422e",
                "FUN_08005680",
                "FUN_080035a4",
                "FUN_080042de",
                "FUN_08003a94"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005500": {
            "entrypoint": "0x08005500",
            "current_name": "initialize_data_08005500",
            "code": "\nvoid initializeData_08005500(void)\n\n{\n  int iVar1;\n  undefined4 blockSize;\n  undefined4 blockCount;\n  undefined4 blockSizes [4];\n  \n  DAT_20000b60 = 0x40000000;\n  DAT_20000b64 = 36000;\n  DAT_20000b68 = 0;\n  DAT_20000b6c = 0x14;\n  DAT_20000b70 = 0;\n  DAT_20000b78 = 0;\n  iVar1 = FUN_080035a4(&DAT_20000b60);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",0x1d0);\n  }\n  blockSizes[0] = 0x1000;\n  iVar1 = FUN_08003a94(&DAT_20000b60,blockSizes);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",0x1d5);\n  }\n  blockSize = 0x20;\n  blockCount = 0;\n  iVar1 = FUN_080042de(&DAT_20000b60,&blockSize);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",0x1dc);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005500": "initialize_data_08005500",
                "local_20": "blockSize",
                "local_1c": "blockCount",
                "local_18": "blockSizes"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08005674",
                "FUN_080035a4",
                "FUN_080042de",
                "FUN_08003a94"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005598": {
            "entrypoint": "0x08005598",
            "current_name": "initialize_data_08005598",
            "code": "\nvoid initializeData_08005598(void)\n\n{\n  int iVar1;\n  \n  DAT_20000adc = 0x40013800;\n  DAT_20000ae0 = 0x1c200;\n  DAT_20000ae4 = 0;\n  DAT_20000ae8 = 0;\n  DAT_20000aec = 0;\n  DAT_20000af0 = 0xc;\n  DAT_20000af4 = 0;\n  DAT_20000af8 = 0;\n  iVar1 = FUN_0800438a(&DAT_20000adc);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",0x1ed);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005598": "initialize_data_08005598"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08005674",
                "FUN_0800438a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055f4": {
            "entrypoint": "0x080055f4",
            "current_name": "initialize_hardware_080055f4",
            "code": "\n\n\nvoid initializeHardware_080055f4(void)\n\n{\n  undefined4 bufferLength;\n  undefined4 flag1;\n  undefined4 flag2;\n  \n  _DAT_40021018 = _DAT_40021018 | 0x2c;\n  FUN_08001a80(0x40010800,0x1e,0,_DAT_40021018 & 8);\n  bufferLength = 0x1e;\n  flag1 = 1;\n  flag2 = 2;\n  FUN_080017c4(0x40010800,&bufferLength);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055f4": "initialize_hardware_080055f4",
                "local_18": "bufferLength",
                "local_14": "flag1",
                "local_c": "flag2"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_080017c4",
                "FUN_08001a80"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005674": {
            "entrypoint": "0x08005674",
            "current_name": "infinite_loop_08005674",
            "code": "\nvoid infiniteLoop_08005674(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005674": "infinite_loop_08005674"
            },
            "calling": [
                "FUN_08005348",
                "FUN_080052a0",
                "FUN_08005598",
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005680": {
            "entrypoint": "0x08005680",
            "current_name": "initialize_variables_08005680",
            "code": "\nvoid initializeVariables_08005680(int *inputPtr)\n\n{\n  undefined4 outputValue;\n  undefined4 count;\n  undefined4 increment;\n  \n  if (*inputPtr == 0x40012c00) {\n    outputValue = 0x900;\n    count = 2;\n    increment = 2;\n    FUN_080017c4(0x40010800,&outputValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005680": "initialize_variables_08005680",
                "param_1": "inputPtr",
                "local_18": "outputValue",
                "local_14": "count",
                "local_c": "increment"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [
                "FUN_080017c4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005704": {
            "entrypoint": "0x08005704",
            "current_name": "initialize_system_08005704",
            "code": "\nvoid initializeSystem_08005704(void)\n\n{\n  FUN_0800157c();\n  FUN_080017b4();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005704": "initialize_system_08005704"
            },
            "calling": [],
            "called": [
                "FUN_0800157c",
                "FUN_080017b4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "initialize_data_08005714",
            "code": "\nvoid initializeData_08005714(void)\n\n{\n  FUN_080036f8(&DAT_20000b60);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005714": "initialize_data_08005714"
            },
            "calling": [],
            "called": [
                "FUN_080036f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005728": {
            "entrypoint": "0x08005728",
            "current_name": "allocate_memory_08005728",
            "code": "\nundefined * allocate_memory_08005728(int size)\n\n{\n  undefined4 *result;\n  undefined *allocated_memory;\n  undefined temp_buffer [4];\n  int remaining_size;\n  undefined *current_memory;\n  \n  if (DAT_20000a10 == (undefined *)0x0) {\n    DAT_20000a10 = &DAT_20000c18;\n  }\n  current_memory = DAT_20000a10;\n  if (temp_buffer < DAT_20000a10 + size) {\n    remaining_size = size;\n    result = (undefined4 *)FUN_08005d14();\n    *result = 0xc;\n    allocated_memory = (undefined *)0xffffffff;\n  }\n  else {\n    allocated_memory = DAT_20000a10;\n    DAT_20000a10 = DAT_20000a10 + size;\n  }\n  return allocated_memory;\n}\n\n",
            "renaming": {
                "FUN_08005728": "allocate_memory_08005728",
                "param_1": "size",
                "puVar1": "result",
                "puVar2": "allocated_memory",
                "auStack_18": "temp_buffer",
                "local_14": "remaining_size",
                "local_c": "current_memory"
            },
            "calling": [
                "FUN_08009744"
            ],
            "called": [
                "FUN_08005d14"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005780": {
            "entrypoint": "0x08005780",
            "current_name": "initialize_system_08005780",
            "code": "\n\n\nvoid initializeSystem_08005780(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005780": "initialize_system_08005780"
            },
            "calling": [
                "entry"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "entry": {
            "entrypoint": "0x080057e8",
            "current_name": "entry",
            "code": "\nvoid entry(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  code *UNRECOVERED_JUMPTABLE;\n  \n  for (iVar1 = 0; (undefined4 *)(iVar1 + 0x20000000) < &DAT_200009c8; iVar1 = iVar1 + 4) {\n    *(undefined4 *)(iVar1 + 0x20000000) = *(undefined4 *)(iVar1 + 0x800a1a4);\n  }\n  for (puVar2 = &DAT_200009c8; puVar2 < &DAT_20000c14; puVar2 = puVar2 + 1) {\n    *puVar2 = 0;\n  }\n  FUN_08005780();\n  FUN_08005d20();\n  UNRECOVERED_JUMPTABLE = (code *)0x800581a;\n  FUN_08005224();\n                    /* WARNING: Could not recover jumptable at 0x0800581a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "FUN_08005224",
                "FUN_08005d20",
                "FUN_08005780"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_08005838": {
            "entrypoint": "0x08005834",
            "current_name": "calculate_result_thunk_08005838",
            "code": "\nuint calculate_result_thunk_08005838(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int temp1;\n  undefined4 temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  undefined8 temp6;\n  \n  temp4 = input4 & 0x7fffffff;\n  if ((0x7ff00000 < (temp4 | (-input3 | input3) >> 0x1f)) ||\n     (temp5 = input2 & 0x7fffffff, 0x7ff00000 < (temp5 | (-input1 | input1) >> 0x1f))) {\n    temp4 = FUN_0800015c(input3,input4,input1,input2);\n    return temp4;\n  }\n  if ((input4 + 0xc0100000 | input3) == 0) {\n    temp4 = FUN_080059f0();\n    return temp4;\n  }\n  temp3 = (int)input4 >> 0x1e & 2U | input2 >> 0x1f;\n  if ((temp5 | input1) == 0) {\n    if (temp3 == 2) {\n      return 0x54442d18;\n    }\n    if (temp3 != 3) {\n      return input1;\n    }\n  }\n  else if ((temp4 | input3) != 0) {\n    if (temp4 == 0x7ff00000) {\n      if (temp5 == 0x7ff00000) {\n        if (temp3 == 2) {\n          return 0x7f3321d2;\n        }\n        if (temp3 == 3) {\n          return 0x7f3321d2;\n        }\n        if (temp3 == 1) {\n          return 0x54442d18;\n        }\n        return 0x54442d18;\n      }\n      if (temp3 == 2) {\n        return 0x54442d18;\n      }\n      if (temp3 != 3) {\n        if (temp3 != 1) {\n          return 0;\n        }\n        return 0;\n      }\n    }\n    else if (temp5 != 0x7ff00000) {\n      temp1 = (int)(temp5 - temp4) >> 0x14;\n      if (temp1 < 0x3d) {\n        if (((int)input4 < 0) && (temp1 + 0x3c < 0 != SCARRY4(temp1,0x3c))) {\n          temp6 = 0;\n        }\n        else {\n          FUN_0800071c(input1,input2,input3,input4,input4);\n          FUNC_08005d0c();\n          temp6 = FUN_080059f0();\n        }\n      }\n      else {\n        temp6 = 0x3ff921fb54442d18;\n      }\n      temp2 = (undefined4)((ulonglong)temp6 >> 0x20);\n      temp4 = (uint)temp6;\n      if (temp3 == 1) {\n        return temp4;\n      }\n      if (temp3 == 2) {\n        temp6 = FUN_08000158(temp4,temp2,0x33145c07,0x3ca1a626);\n        temp4 = FUN_08000158(0x54442d18,0x400921fb,(int)temp6,(int)((ulonglong)temp6 >> 0x20));\n        return temp4;\n      }\n      if (temp3 != 0) {\n        temp6 = FUN_08000158(temp4,temp2,0x33145c07,0x3ca1a626);\n        temp4 = FUN_08000158((int)temp6,(int)((ulonglong)temp6 >> 0x20),0x54442d18,0x400921fb);\n        return temp4;\n      }\n      return temp4;\n    }\n  }\n  return 0x54442d18;\n}\n\n",
            "renaming": {
                "thunk_FUN_08005838": "calculate_result_thunk_08005838",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "uVar6": "temp6"
            },
            "calling": [
                "FUN_08004d78",
                "FUN_08004bd8"
            ],
            "called": [
                "FUN_08005838"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005838": {
            "entrypoint": "0x08005838",
            "current_name": "calculate_result_08005838",
            "code": "\nuint calculateResult_08005838(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int tempVar1;\n  undefined4 tempVar2;\n  uint tempVar3;\n  uint tempVar4;\n  uint tempVar5;\n  undefined8 tempVar6;\n  \n  tempVar4 = input4 & 0x7fffffff;\n  if ((0x7ff00000 < (tempVar4 | (-input3 | input3) >> 0x1f)) ||\n     (tempVar5 = input2 & 0x7fffffff, 0x7ff00000 < (tempVar5 | (-input1 | input1) >> 0x1f))) {\n    tempVar4 = FUN_0800015c(input3,input4,input1,input2);\n    return tempVar4;\n  }\n  if ((input4 + 0xc0100000 | input3) == 0) {\n    tempVar4 = FUN_080059f0();\n    return tempVar4;\n  }\n  tempVar3 = (int)input4 >> 0x1e & 2U | input2 >> 0x1f;\n  if ((tempVar5 | input1) == 0) {\n    if (tempVar3 == 2) {\n      return 0x54442d18;\n    }\n    if (tempVar3 != 3) {\n      return input1;\n    }\n  }\n  else if ((tempVar4 | input3) != 0) {\n    if (tempVar4 == 0x7ff00000) {\n      if (tempVar5 == 0x7ff00000) {\n        if (tempVar3 == 2) {\n          return 0x7f3321d2;\n        }\n        if (tempVar3 == 3) {\n          return 0x7f3321d2;\n        }\n        if (tempVar3 == 1) {\n          return 0x54442d18;\n        }\n        return 0x54442d18;\n      }\n      if (tempVar3 == 2) {\n        return 0x54442d18;\n      }\n      if (tempVar3 != 3) {\n        if (tempVar3 != 1) {\n          return 0;\n        }\n        return 0;\n      }\n    }\n    else if (tempVar5 != 0x7ff00000) {\n      tempVar1 = (int)(tempVar5 - tempVar4) >> 0x14;\n      if (tempVar1 < 0x3d) {\n        if (((int)input4 < 0) && (tempVar1 + 0x3c < 0 != SCARRY4(tempVar1,0x3c))) {\n          tempVar6 = 0;\n        }\n        else {\n          FUN_0800071c(input1,input2,input3,input4,input4);\n          FUNC_08005d0c();\n          tempVar6 = FUN_080059f0();\n        }\n      }\n      else {\n        tempVar6 = 0x3ff921fb54442d18;\n      }\n      tempVar2 = (undefined4)((ulonglong)tempVar6 >> 0x20);\n      tempVar4 = (uint)tempVar6;\n      if (tempVar3 == 1) {\n        return tempVar4;\n      }\n      if (tempVar3 == 2) {\n        tempVar6 = FUN_08000158(tempVar4,tempVar2,0x33145c07,0x3ca1a626);\n        tempVar4 = FUN_08000158(0x54442d18,0x400921fb,(int)tempVar6,(int)((ulonglong)tempVar6 >> 0x20));\n        return tempVar4;\n      }\n      if (tempVar3 != 0) {\n        tempVar6 = FUN_08000158(tempVar4,tempVar2,0x33145c07,0x3ca1a626);\n        tempVar4 = FUN_08000158((int)tempVar6,(int)((ulonglong)tempVar6 >> 0x20),0x54442d18,0x400921fb);\n        return tempVar4;\n      }\n      return tempVar4;\n    }\n  }\n  return 0x54442d18;\n}\n\n",
            "renaming": {
                "FUN_08005838": "calculate_result_08005838",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "tempVar1",
                "uVar2": "tempVar2",
                "uVar3": "tempVar3",
                "uVar4": "tempVar4",
                "uVar5": "tempVar5",
                "uVar6": "tempVar6"
            },
            "calling": [
                "thunk_FUN_08005838"
            ],
            "called": [
                "FUN_08005d0c",
                "FUN_0800015c",
                "FUN_080059f0",
                "FUN_0800071c",
                "FUN_08000158"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f0": {
            "entrypoint": "0x080059f0",
            "current_name": "calculate_result_080059f0",
            "code": "\nundefined8 calculateResult_080059f0(int input1,uint input2,undefined4 value1,undefined4 dummy)\n\n{\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined4 temp3;\n  undefined4 temp4;\n  undefined4 temp5;\n  undefined4 temp6;\n  uint temp7;\n  int temp8;\n  undefined8 result1;\n  undefined8 result2;\n  \n  result2 = CONCAT44(input2,input1);\n  temp7 = input2 & 0x7fffffff;\n  if (temp7 < 0x44100000) {\n    if (temp7 < 0x3fdc0000) {\n      if (temp7 < 0x3e200000) {\n        result1 = FUN_0800015c(input1,input2,0x8800759c,0x7e37e43c,dummy);\n        temp8 = FUN_080009e8((int)result1,(int)((ulonglong)result1 >> 0x20),0,0x3ff00000);\n        if (temp8 != 0) {\n          return CONCAT44(input2,input1);\n        }\n      }\n      temp8 = -1;\n    }\n    else {\n      result2 = FUNC_08005d0c();\n      temp4 = (undefined4)((ulonglong)result2 >> 0x20);\n      temp1 = (undefined4)result2;\n      if (temp7 < 0x3ff30000) {\n        if (temp7 < 0x3fe60000) {\n          result2 = FUN_0800015c(temp1,temp4,temp1,temp4);\n          result2 = FUN_08000158((int)result2,(int)((ulonglong)result2 >> 0x20),0,0x3ff00000);\n          result1 = FUN_0800015c(temp1,temp4,0,0x40000000);\n          result2 = FUN_0800071c((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result1,\n                                (int)((ulonglong)result1 >> 0x20));\n          temp8 = 0;\n        }\n        else {\n          result2 = FUN_08000158(temp1,temp4,0,0x3ff00000);\n          result1 = FUN_0800015c(temp1,temp4,0,0x3ff00000);\n          result2 = FUN_0800071c((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result1,\n                                (int)((ulonglong)result1 >> 0x20));\n          temp8 = 1;\n        }\n      }\n      else if (temp7 < 0x40038000) {\n        result2 = FUN_08000158(temp1,temp4,0,0x3ff80000);\n        result1 = FUN_080004c8(temp1,temp4,0,0x3ff80000);\n        result1 = FUN_0800015c((int)result1,(int)((ulonglong)result1 >> 0x20),0,0x3ff00000);\n        result2 = FUN_0800071c((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result1,\n                              (int)((ulonglong)result1 >> 0x20));\n        temp8 = 2;\n      }\n      else {\n        result2 = FUN_0800071c(0,0xbff00000,temp1,temp4);\n        temp8 = 3;\n      }\n    }\n    temp6 = (undefined4)((ulonglong)result2 >> 0x20);\n    temp5 = (undefined4)result2;\n    result2 = FUN_080004c8(temp5,temp6,temp5,temp6);\n    temp2 = (undefined4)((ulonglong)result2 >> 0x20);\n    temp1 = (undefined4)result2;\n    result2 = FUN_080004c8(temp1,temp2,temp1,temp2);\n    temp3 = (undefined4)((ulonglong)result2 >> 0x20);\n    temp4 = (undefined4)result2;\n    result2 = FUN_080004c8(temp4,temp3,0xe322da11,0x3f90ad3a);\n    result2 = FUN_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),0x24760deb,0x3fa97b4b);\n    result2 = FUN_080004c8((int)result2,(int)((ulonglong)result2 >> 0x20),temp4,temp3);\n    result2 = FUN_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),0xa0d03d51,0x3fb10d66);\n    result2 = FUN_080004c8((int)result2,(int)((ulonglong)result2 >> 0x20),temp4,temp3);\n    result2 = FUN_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),0xc54c206e,0x3fb745cd);\n    result2 = FUN_080004c8((int)result2,(int)((ulonglong)result2 >> 0x20),temp4,temp3);\n    result2 = FUN_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),0x920083ff,0x3fc24924);\n    result2 = FUN_080004c8((int)result2,(int)((ulonglong)result2 >> 0x20),temp4,temp3);\n    result2 = FUN_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),0x5555550d,0x3fd55555);\n    result2 = FUN_080004c8((int)result2,(int)((ulonglong)result2 >> 0x20),temp1,temp2);\n    result1 = FUN_080004c8(temp4,temp3,0x2c6a6c2f,0xbfa2b444);\n    result1 = FUN_08000158((int)result1,(int)((ulonglong)result1 >> 0x20),0x52defd9a,0x3fadde2d);\n    result1 = FUN_080004c8((int)result1,(int)((ulonglong)result1 >> 0x20),temp4,temp3);\n    result1 = FUN_08000158((int)result1,(int)((ulonglong)result1 >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    result1 = FUN_080004c8((int)result1,(int)((ulonglong)result1 >> 0x20),temp4,temp3);\n    result1 = FUN_08000158((int)result1,(int)((ulonglong)result1 >> 0x20),0xfe231671,0x3fbc71c6);\n    result1 = FUN_080004c8((int)result1,(int)((ulonglong)result1 >> 0x20),temp4,temp3);\n    result1 = FUN_08000158((int)result1,(int)((ulonglong)result1 >> 0x20),0x9998ebc4,0x3fc99999);\n    result1 = FUN_080004c8((int)result1,(int)((ulonglong)result1 >> 0x20),temp4,temp3);\n    result2 = FUN_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result1,\n                          (int)((ulonglong)result1 >> 0x20));\n    result2 = FUN_080004c8((int)result2,(int)((ulonglong)result2 >> 0x20),temp5,temp6);\n    temp1 = (undefined4)((ulonglong)result2 >> 0x20);\n    if (temp8 == -1) {\n      result2 = FUN_08000158(temp5,temp6,(int)result2,temp1);\n      return result2;\n    }\n    temp8 = temp8 * 8;\n    result2 = FUN_08000158((int)result2,temp1,*(undefined4 *)(&UNK_08009ee8 + temp8),\n                          *(undefined4 *)(&UNK_08009eec + temp8));\n    result2 = FUN_08000158((int)result2,(int)((ulonglong)result2 >> 0x20),temp5,temp6);\n    result2 = FUN_08000158(*(undefined4 *)(&UNK_08009ec8 + temp8),\n                          *(undefined4 *)(&UNK_08009ecc + temp8),(int)result2,\n                          (int)((ulonglong)result2 >> 0x20));\n    if ((int)input2 < 0) {\n      return CONCAT44((int)((ulonglong)result2 >> 0x20) + -0x80000000,(int)result2);\n    }\n  }\n  else {\n    if ((temp7 < 0x7ff00001) && ((temp7 != 0x7ff00000 || (input1 == 0)))) {\n      temp1 = 0xbff921fb;\n      if (0 < (int)input2) {\n        temp1 = 0x3ff921fb;\n      }\n      return CONCAT44(temp1,0x54442d18);\n    }\n    result2 = FUN_0800015c(input1,input2,input1,input2,dummy);\n  }\n  return result2;\n}\n\n",
            "renaming": {
                "FUN_080059f0": "calculate_result_080059f0",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "value1",
                "param_4": "dummy",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "uVar6": "temp6",
                "uVar7": "temp7",
                "iVar8": "temp8",
                "uVar9": "result1",
                "uVar10": "result2"
            },
            "calling": [
                "FUN_08005838"
            ],
            "called": [
                "FUN_08005d0c",
                "FUN_080009e8",
                "FUN_0800015c",
                "FUN_080004c8",
                "FUN_0800071c",
                "FUN_08000158"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d0c": {
            "entrypoint": "0x08005d0c",
            "current_name": "FUNC_08005d0c",
            "code": "\nvoid FUNC_08005d0c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d0c": "FUNC_08005d0c"
            },
            "calling": [
                "FUN_08005838",
                "FUN_080059f0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005d14": {
            "entrypoint": "0x08005d14",
            "current_name": "get_global_variable_value_08005d14",
            "code": "\nundefined4 getGlobalVariableValue_08005d14(void)\n\n{\n  return DAT_2000001c;\n}\n\n",
            "renaming": {
                "FUN_08005d14": "get_global_variable_value_08005d14"
            },
            "calling": [
                "FUN_08005728"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d20": {
            "entrypoint": "0x08005d20",
            "current_name": "execute_nested_functions_08005d20",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005d2c) */\n/* WARNING: Removing unreachable block (ram,0x08005d2e) */\n\nvoid executeNestedFunctions_08005d20(void)\n\n{\n  int counter;\n  code **functionArray;\n  \n  FUNC_08009e68();\n  counter = 0;\n  functionArray = (code **)&DAT_0800a198;\n  do {\n    counter = counter + 1;\n    (**functionArray)();\n    functionArray = functionArray + 1;\n  } while (counter != 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d20": "execute_nested_functions_08005d20",
                "iVar1": "counter",
                "ppcVar2": "functionArray"
            },
            "calling": [
                "entry"
            ],
            "called": [
                "FUN_08009e68",
                "FUN_080078a0",
                "FUN_08000134"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d68": {
            "entrypoint": "0x08005d68",
            "current_name": "fill_memory_with_byte_08005d68",
            "code": "\nvoid fillMemoryWithByte_08005d68(undefined4 *destination,undefined value,uint length)\n\n{\n  undefined4 *destPtr;\n  undefined4 *nextDestPtr;\n  uint remainingLength;\n  undefined4 wordValue;\n  bool isZeroLength;\n  \n  if (((uint)destination & 3) != 0) {\n    remainingLength = length - 1;\n    destPtr = destination;\n    if (length == 0) {\n      return;\n    }\n    while( true ) {\n      destination = (undefined4 *)((int)destPtr + 1);\n      *(undefined *)destPtr = value;\n      length = remainingLength;\n      if (((uint)destination & 3) == 0) break;\n      isZeroLength = remainingLength == 0;\n      remainingLength = remainingLength - 1;\n      destPtr = destination;\n      if (isZeroLength) {\n        return;\n      }\n    }\n  }\n  if (3 < length) {\n    wordValue = CONCAT22(CONCAT11(value,value),CONCAT11(value,value));\n    remainingLength = length;\n    destPtr = destination;\n    if (0xf < length) {\n      remainingLength = length - 0x10;\n      destPtr = destination + 4;\n      do {\n        destPtr[-4] = wordValue;\n        destPtr[-3] = wordValue;\n        destPtr[-2] = wordValue;\n        destPtr[-1] = wordValue;\n        destPtr = destPtr + 4;\n      } while (destPtr != (undefined4 *)((int)destination + (remainingLength & 0xfffffff0) + 0x20));\n      length = length & 0xf;\n      destination = destination + ((remainingLength >> 4) + 1) * 4;\n      remainingLength = length;\n      destPtr = destination;\n      if (length < 4) goto LAB_08005de4;\n    }\n    do {\n      length = length - 4;\n      *destination = wordValue;\n      destination = destination + 1;\n    } while (3 < length);\n    destination = (undefined4 *)((int)destPtr + (remainingLength - 4 & 0xfffffffc) + 4);\n    length = remainingLength & 3;\n  }\nLAB_08005de4:\n  if (length != 0) {\n    destPtr = destination;\n    do {\n      nextDestPtr = (undefined4 *)((int)destPtr + 1);\n      *(undefined *)destPtr = value;\n      destPtr = nextDestPtr;\n    } while ((undefined4 *)(length + (int)destination) != nextDestPtr);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d68": "fill_memory_with_byte_08005d68",
                "param_1": "destination",
                "param_2": "value",
                "param_3": "length",
                "puVar1": "destPtr",
                "puVar2": "nextDestPtr",
                "uVar3": "remainingLength",
                "uVar4": "wordValue",
                "bVar5": "isZeroLength"
            },
            "calling": [
                "FUN_08004f60",
                "FUN_08009980"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005dfc": {
            "entrypoint": "0x08005dfc",
            "current_name": "initialize_param_08005dfc",
            "code": "\nvoid initializeParam_08005dfc(undefined *param,undefined4 value1,undefined4 value2,undefined4 value3)\n\n{\n  undefined *array [2];\n  undefined4 maxValue1;\n  undefined4 minValue;\n  undefined *currentParam;\n  undefined4 maxValue2;\n  undefined4 value2;\n  undefined4 value3;\n  \n  maxValue2 = 0x7fffffff;\n  maxValue1 = 0x7fffffff;\n  minValue = 0xffff0208;\n  array[0] = param;\n  currentParam = param;\n  value2 = value2;\n  value3 = value3;\n  FUNC_08005e9c(DAT_2000001c,array,value1,&value2);\n  *array[0] = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005dfc": "initialize_param_08005dfc",
                "param_1": "param",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3",
                "local_80": "array",
                "local_78": "maxValue1",
                "uStack_74": "minValue",
                "local_70": "currentParam",
                "local_6c": "maxValue2",
                "uStack_8": "value2",
                "uStack_4": "value3"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08005e9c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e40": {
            "entrypoint": "0x08005e40",
            "current_name": "calculate_leading_zeroes_count_08005e40",
            "code": "\nint calculateLeadingZeroesCount_08005e40(uint input)\n\n{\n  int leadingZeroes;\n  uint *dataPointer;\n  uint value;\n  \n  dataPointer = (uint *)(input & 0xfffffffc);\n  leadingZeroes = -(input & 3);\n  value = *dataPointer;\n  if ((input & 3) != 0) {\n    value = value | 0xffffffffU >> ((leadingZeroes + 4U & 0x1f) << 3);\n  }\n  while( true ) {\n    dataPointer = dataPointer + 1;\n    value = value + 0xfefefeff & ~value & 0x80808080;\n    if (value != 0) break;\n    value = *dataPointer;\n    leadingZeroes = leadingZeroes + 4;\n  }\n  return leadingZeroes + (0x1fU - countLeadingZeros(value & -value) >> 3);\n}\n\n",
            "renaming": {
                "FUN_08005e40": "calculate_leading_zeroes_count_08005e40",
                "param_1": "input",
                "iVar1": "leadingZeroes",
                "puVar2": "dataPointer",
                "uVar3": "value",
                "LZCOUNT": "countLeadingZeros"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e9c": {
            "entrypoint": "0x08005e9c",
            "current_name": "FUNC_08005e9c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nbyte * FUNC_08005e9c(undefined4 *param_1,int *param_2,int *param_3,int **param_4)\n\n{\n  byte bVar1;\n  int **ppiVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char cVar6;\n  byte bVar7;\n  int iVar8;\n  int *piVar9;\n  undefined4 uVar10;\n  int **ppiVar11;\n  undefined uVar12;\n  ushort uVar13;\n  int **ppiVar14;\n  byte **ppbVar15;\n  int *piVar16;\n  int **ppiVar17;\n  char *pcVar18;\n  uint uVar19;\n  undefined *puVar20;\n  int *piVar21;\n  int *piVar22;\n  int *piVar23;\n  int *piVar24;\n  int *piVar25;\n  byte *pbVar26;\n  int *piVar27;\n  int *piVar28;\n  undefined4 *puVar29;\n  byte *pbVar30;\n  bool bVar31;\n  longlong lVar32;\n  undefined8 uVar33;\n  undefined8 uVar34;\n  undefined4 local_188;\n  int *piStack_184;\n  int **local_180;\n  undefined *puStack_17c;\n  int **local_178;\n  undefined4 *local_16c;\n  int *local_168;\n  byte *local_164;\n  int *local_160;\n  int *local_15c;\n  char *local_158;\n  int **local_154;\n  undefined8 local_150;\n  int *local_148;\n  int *local_144;\n  int *local_140;\n  int **local_13c;\n  int *local_138;\n  int *local_134;\n  int *local_130;\n  uint local_12c;\n  undefined4 local_128;\n  undefined4 local_124;\n  undefined4 local_120;\n  char *local_11c;\n  int *local_118;\n  int *local_114;\n  int *local_110;\n  int *local_10c;\n  byte *local_108;\n  int *local_104;\n  int *local_100;\n  int *local_fc;\n  byte local_f5;\n  undefined2 local_f4;\n  int *local_f0;\n  undefined auStack_ec [4];\n  char local_e8;\n  undefined local_e7;\n  char local_e6 [6];\n  int *local_e0;\n  byte abStack_dc [4];\n  int **local_d8;\n  int *local_d4;\n  int *local_d0;\n  int *local_cc [16];\n  undefined local_8c;\n  byte bStack_2a;\n  undefined local_29;\n  int iStack_28;\n  \n  local_16c = param_1;\n  local_160 = param_2;\n  local_154 = param_4;\n  ppiVar2 = (int **)FUN_08008ad4();\n  local_114 = *ppiVar2;\n  local_118 = (int *)FUN_08005e40(local_114);\n  if (((int)((uint)*(ushort *)(param_2 + 3) << 0x18) < 0) && (param_2[4] == 0)) {\n    iVar3 = FUN_08008af8(local_16c,0x40);\n    *local_160 = iVar3;\n    local_160[4] = iVar3;\n    if (iVar3 == 0) {\n      *local_16c = 0xc;\n      return (byte *)0xffffffff;\n    }\n    local_160[5] = 0x40;\n  }\n  local_128 = 0;\n  local_138 = (int *)0x0;\n  local_12c = 0;\n  local_d4 = (int *)0x0;\n  local_d0 = (int *)0x0;\n  local_11c = (char *)0x0;\n  local_10c = (int *)0x0;\n  local_108 = (byte *)0x0;\n  local_104 = (int *)0x0;\n  local_110 = (int *)0x0;\n  local_164 = (byte *)0x0;\n  local_124 = 0;\n  local_120 = 0;\n  ppiVar2 = local_cc;\n  bVar1 = *(byte *)param_3;\n  local_d8 = ppiVar2;\njoined_r0x08005ef2:\n  if (bVar1 != 0) {\n    piVar28 = param_3;\n    if (bVar1 != 0x25) {\n      do {\n        piVar28 = (int *)((int)piVar28 + 1);\n        if (*(byte *)piVar28 == 0) break;\n      } while (*(byte *)piVar28 != 0x25);\n      piVar27 = (int *)((int)piVar28 - (int)param_3);\n      if (piVar27 != (int *)0x0) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)piVar27);\n        *ppiVar2 = param_3;\n        *(int **)((int)ppiVar2 + 4) = piVar27;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = (int **)((int)ppiVar2 + 8);\n        }\n        else {\n          iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800604a;\n          ppiVar2 = local_cc;\n        }\n        local_164 = local_164 + (int)piVar27;\n      }\n      if (*(byte *)piVar28 == 0) goto LAB_08006216;\n    }\n    piVar27 = (int *)0xffffffff;\n    piVar25 = (int *)0x0;\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    local_15c = (int *)0x0;\n    local_f5 = 0;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4a:\n    puVar29 = local_16c;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4e:\n    switch(piVar24) {\n    case (int *)0x20:\n      goto switchD_08005f58_caseD_20;\n    default:\n      if (piVar24 == (int *)0x0) goto LAB_08006216;\n      piVar16 = (int *)0x0;\n      local_168 = (int *)0x1;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_158 = (char *)0x1;\n      piVar23 = (int *)&local_8c;\n      piVar22 = piVar16;\n      local_8c = (char)piVar24;\n      goto LAB_08006298;\n    case (int *)0x23:\n      piVar25 = (int *)((uint)piVar25 | 1);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x27:\n      iVar3 = FUN_08008ad4(local_16c);\n      local_110 = *(int **)(iVar3 + 4);\n      piVar24 = (int *)FUN_08005e40(local_110);\n      local_104 = piVar24;\n      iVar3 = FUN_08008ad4(puVar29);\n      local_108 = *(byte **)(iVar3 + 8);\n      if (piVar24 == (int *)0x0) goto switchD_08005f58_caseD_74;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if ((local_108 != (byte *)0x0) && (*local_108 != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 0x400);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2a:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      local_15c = *local_154;\n      local_154 = local_154 + 1;\n      if ((int)local_15c < 0) {\n        local_15c = (int *)-(int)local_15c;\n        goto LAB_08006602;\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2b:\n      local_f5 = 0x2b;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x2d:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\nLAB_08006602:\n      piVar25 = (int *)((uint)piVar25 | 4);\n      goto LAB_08005f4a;\n    case (int *)0x2e:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x2a) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar27 = (int *)((uint)*local_154 | (int)*local_154 >> 0x1f);\n        local_154 = local_154 + 1;\n        piVar28 = (int *)((int)piVar28 + 1);\n        goto LAB_08005f4a;\n      }\n      piVar27 = (int *)0x0;\n      piVar28 = (int *)((int)piVar28 + 1);\n      while (piVar24 + -0xc < (int *)0xa) {\n        piVar27 = (int *)((int)(piVar24 + -0xc) + (int)piVar27 * 10);\n        piVar24 = (int *)(uint)*(byte *)piVar28;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      goto LAB_08005f4e;\n    case (int *)0x30:\n      piVar25 = (int *)((uint)piVar25 | 0x80);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x31:\n    case (int *)0x32:\n    case (int *)0x33:\n    case (int *)0x34:\n    case (int *)0x35:\n    case (int *)0x36:\n    case (int *)0x37:\n    case (int *)0x38:\n    case (int *)0x39:\n      goto switchD_08005f58_caseD_31;\n    case (int *)0x41:\n    case (int *)0x45:\n    case (int *)0x46:\n    case (int *)0x47:\n    case (int *)0x61:\n    case (int *)0x65:\n    case (int *)0x66:\n    case (int *)0x67:\n      puVar29 = (undefined4 *)((int)local_154 + 7U & 0xfffffff8);\n      uVar10 = *puVar29;\n      local_12c = puVar29[1];\n      local_168 = (int *)(local_12c & 0x7fffffff);\n      local_154 = (int **)(puVar29 + 2);\n      local_128 = uVar10;\n      iVar3 = FUN_08001170(uVar10,local_168,0xffffffff,0x7fefffff);\n      if ((iVar3 == 0) && (iVar3 = FUN_080009c0(uVar10,local_168,0xffffffff,0x7fefffff), iVar3 == 0)\n         ) {\n        iVar3 = FUN_080009ac(local_128,local_12c,local_124,local_120);\n        if (iVar3 == 0) {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        else {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        piVar23 = (int *)&UNK_08009f10;\n        piVar27 = (int *)&UNK_08009f0c;\nLAB_08006524:\n        local_148 = (int *)0x0;\n        local_168 = (int *)0x3;\n        if (piVar24 < (int *)0x48) {\n          piVar23 = piVar27;\n        }\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar25 = (int *)((uint)piVar25 & 0xffffff7f);\n        local_158 = (char *)0x3;\n        local_13c = (int **)0x0;\n        piVar22 = (int *)0x0;\n        goto LAB_08006538;\n      }\n      iVar3 = FUN_08001170(local_128,local_12c,local_128,local_12c);\n      if (iVar3 != 0) {\n        if ((int)local_12c < 0) {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        else {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        piVar23 = (int *)&UNK_08009f18;\n        piVar27 = (int *)&UNK_08009f14;\n        goto LAB_08006524;\n      }\n      if (piVar24 == (int *)0x61) {\n        uVar12 = 0x78;\nLAB_08007224:\n        local_f4 = CONCAT11(uVar12,0x30);\n        if ((int)piVar27 < 100) {\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          local_148 = (int *)0x0;\n          param_3 = (int *)&local_8c;\n          piVar25 = (int *)((uint)piVar25 | 2);\n        }\n        else {\n          param_3 = (int *)FUN_08008af8(local_16c,(byte *)((int)piVar27 + 1));\n          if (param_3 == (int *)0x0) {\n            uVar13 = *(ushort *)(local_160 + 3) | 0x40;\n            *(ushort *)(local_160 + 3) = uVar13;\n            goto LAB_0800604e;\n          }\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          piVar25 = (int *)((uint)piVar25 | 2);\n          local_148 = param_3;\n        }\nLAB_0800724a:\n        if ((int)local_12c < 0) {\nLAB_08007414:\n          local_144 = (int *)0x2d;\n          uVar19 = local_12c + 0x80000000;\n        }\n        else {\n          local_144 = (int *)0x0;\n          uVar19 = local_12c;\n        }\n        local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n        piVar22 = piVar27;\n        local_158 = (char *)local_128;\n        if (piVar24 == (int *)0x61) {\n          uVar33 = FUN_080096e0(local_128,uVar19,&local_f0);\n          local_150 = FUN_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = FUN_08000998((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                               local_120);\n          if (iVar3 != 0) {\n            local_f0 = (int *)0x1;\n          }\n          local_158 = \"0123456789abcdef\";\n          local_13c = ppiVar2;\n          local_138 = piVar28;\n          local_134 = piVar24;\n          local_130 = piVar27;\n          local_100 = piVar25;\n          local_fc = param_3;\n          pcVar18 = local_158;\n          uVar33 = local_150;\n          goto LAB_080072ba;\n        }\n        if (piVar24 == (int *)0x41) {\n          uVar33 = FUN_080096e0(local_128,uVar19,&local_f0);\n          local_150 = FUN_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = FUN_08000998((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                               local_120);\n          if (iVar3 == 0) {\n            local_158 = \"0123456789ABCDEF\";\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar27;\n            local_100 = piVar25;\n            local_fc = param_3;\n            pcVar18 = local_158;\n            uVar33 = local_150;\n          }\n          else {\n            local_f0 = (int *)0x1;\n            local_158 = \"0123456789ABCDEF\";\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar27;\n            local_100 = piVar25;\n            local_fc = param_3;\n            pcVar18 = local_158;\n            uVar33 = local_150;\n          }\n          goto LAB_080072ba;\n        }\n      }\n      else {\n        if (piVar24 == (int *)0x41) {\n          uVar12 = 0x58;\n          goto LAB_08007224;\n        }\n        local_140 = (int *)((uint)piVar25 | 0x100);\n        local_148 = (int *)0x0;\n        if (piVar27 == (int *)0xffffffff) {\n          piVar27 = (int *)0x6;\n          goto LAB_0800724a;\n        }\n        if (((uint)piVar24 & 0xffffffdf) == 0x47) {\n          if (piVar27 == (int *)0x0) {\n            piVar27 = (int *)0x1;\n            local_148 = (int *)0x0;\n          }\n          goto LAB_0800724a;\n        }\n        if ((int)local_12c < 0) goto LAB_08007414;\n        local_144 = (int *)0x0;\n        uVar19 = local_12c;\n      }\n      local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n      piStack_184 = piVar27;\n      local_158 = (char *)local_128;\n      if (piVar24 == (int *)0x66) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)FUN_080079e8(local_16c,local_180,local_128,uVar19);\n        piVar22 = (int *)((int)piVar23 + (int)piVar27);\n        local_150._0_4_ = piVar27;\nLAB_0800764c:\n        if ((*(byte *)piVar23 == 0x30) &&\n           (iVar3 = FUN_08000998(local_158,uVar19,local_124,local_120), iVar3 == 0)) {\n          local_f0 = (int *)(1 - (int)(int *)local_150);\n        }\n        piVar22 = (int *)((int)piVar22 + (int)local_f0);\n      }\n      else if (piVar24 == (int *)0x46) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)FUN_080079e8(local_16c,local_180,local_128,uVar19);\n        local_150._0_4_ = piVar27;\nLAB_08007760:\n        piVar22 = (int *)((int)piVar23 + (int)(int *)local_150);\n        if (piVar24 == (int *)0x46) goto LAB_0800764c;\n      }\n      else {\n        local_178 = &local_e0;\n        local_150._0_4_ = piVar27;\n        if (local_168 == (int *)0x45) {\n          local_150._0_4_ = (int *)((int)piVar27 + 1);\n        }\n        local_188 = 2;\n        piStack_184 = (int *)local_150;\n        local_180 = &local_f0;\n        puStack_17c = auStack_ec;\n        piVar23 = (int *)FUN_080079e8(local_16c,local_180,local_128,uVar19);\n        piVar16 = local_e0;\n        if (piVar24 == (int *)0x67) {\n          if (((uint)piVar25 & 1) == 0) goto LAB_08006ca6;\n        }\n        else if (piVar24 == (int *)0x47) {\n          if (((uint)piVar25 & 1) != 0) goto LAB_08007760;\n          goto LAB_08006ca6;\n        }\n        piVar22 = (int *)((int)(int *)local_150 + (int)piVar23);\n      }\n      iVar3 = FUN_08000998(local_158,uVar19,local_124,local_120);\n      piVar16 = piVar22;\n      if (iVar3 == 0) {\n        for (; piVar16 = local_e0, local_e0 < piVar22; local_e0 = (int *)((int)local_e0 + 1)) {\n          *(byte *)local_e0 = 0x30;\n        }\n      }\nLAB_08006ca6:\n      local_138 = (int *)((int)piVar16 - (int)piVar23);\n      goto LAB_08006cb0;\n    case (int *)0x43:\n    case (int *)0x63:\n      piVar16 = (int *)0x0;\n      piVar27 = *local_154;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      piVar22 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_154 = local_154 + 1;\n      local_168 = (int *)0x1;\n      local_158 = (char *)0x1;\n      local_8c = SUB41(piVar27,0);\n      piVar23 = (int *)&local_8c;\n      goto LAB_08006298;\n    case (int *)0x44:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080065a8;\nLAB_080060ec:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_08006102;\n    case (int *)0x4c:\n      piVar25 = (int *)((uint)piVar25 | 8);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x4f:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n    case (int *)0x6f:\n      if (((uint)piVar25 & 0x20) == 0) {\n        ppiVar14 = local_154 + 1;\n        if (((uint)piVar25 & 0x10) == 0) {\n          if (((uint)piVar25 & 0x40) == 0) {\n            if (((uint)piVar25 & 0x200) == 0) goto LAB_08006be2;\n            piVar22 = (int *)(uint)*(byte *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n          else {\n            piVar22 = (int *)(uint)*(ushort *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n        }\n        else {\nLAB_08006be2:\n          piVar22 = *local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\n        ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n        piVar22 = *ppiVar14;\n        piVar16 = ppiVar14[1];\n        local_154 = ppiVar14 + 2;\n      }\n      iVar3 = 0;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n      break;\n    case (int *)0x53:\n    case (int *)0x73:\n      local_f5 = 0;\n      piVar23 = *local_154;\n      ppiVar14 = local_154 + 1;\n      if (piVar23 == (int *)0x0) {\n        if ((int *)0x5 < piVar27) {\n          piVar27 = (int *)0x6;\n        }\n        piVar23 = (int *)&UNK_08009f44;\n        piVar16 = (int *)0x0;\n        local_148 = (int *)0x0;\n        local_13c = (int **)0x0;\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar22 = (int *)0x0;\n        local_168 = piVar27;\n        local_158 = (char *)piVar27;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (piVar27 == (int *)0xffffffff) {\n          local_158 = (char *)FUN_08005e40(piVar23);\n        }\n        else {\n          iVar3 = FUN_0800901c(piVar23,0,piVar27);\n          if (iVar3 == 0) {\n            piVar16 = (int *)(uint)local_f5;\n            local_148 = (int *)0x0;\n            local_13c = (int **)0x0;\n            local_134 = (int *)0x0;\n            local_130 = (int *)0x0;\n            piVar22 = (int *)0x0;\n            local_168 = piVar27;\n            local_158 = (char *)piVar27;\n            local_154 = ppiVar14;\n            goto LAB_08006538;\n          }\n          local_158 = (char *)(iVar3 - (int)piVar23);\n        }\n        local_148 = (int *)0x0;\n        local_13c = (int **)0x0;\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar16 = (int *)(uint)local_f5;\n        piVar22 = (int *)0x0;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        local_154 = ppiVar14;\n      }\n      goto LAB_08006538;\n    case (int *)0x55:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080066c0;\nLAB_0800618a:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      iVar3 = 1;\n      local_154 = ppiVar14 + 2;\n      break;\n    case (int *)0x58:\n      local_11c = \"0123456789ABCDEF\";\n      if (((uint)piVar25 & 0x20) == 0) goto LAB_08006696;\nLAB_080061ac:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_080061be;\n    case (int *)0x64:\n    case (int *)0x69:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_080060ec;\nLAB_080065a8:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bcc:\n        piVar22 = *local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(int)*(short *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bcc;\n        piVar22 = (int *)(int)*(char *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\nLAB_08006102:\n      if ((int)piVar16 < 0) {\n        bVar31 = piVar22 != (int *)0x0;\n        piVar22 = (int *)-(int)piVar22;\n        piVar16 = (int *)(-(int)piVar16 - (uint)bVar31);\n        local_f5 = 0x2d;\n      }\n      if (piVar27 != (int *)0xffffffff) {\n        iVar3 = 1;\n        iVar8 = 1;\n        piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n        if (((uint)piVar22 | (uint)piVar16) == 0) goto LAB_080060a4;\n        goto LAB_08006130;\n      }\n      piVar21 = piVar25;\n      if (piVar16 != (int *)0x0 || (int *)0x9 < piVar22) goto LAB_08006f16;\n      goto LAB_0800698a;\n    case (int *)0x68:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x68) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar25 = (int *)((uint)piVar25 | 0x200);\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      else {\n        piVar25 = (int *)((uint)piVar25 | 0x40);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x6a:\n    case (int *)0x71:\n      piVar25 = (int *)((uint)piVar25 | 0x20);\n    case (int *)0x74:\n    case (int *)0x7a:\nswitchD_08005f58_caseD_74:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x6c:\n      goto switchD_08005f58_caseD_6c;\n    case (int *)0x6e:\n      ppiVar14 = local_154 + 1;\n      ppbVar15 = (byte **)*local_154;\n      local_154 = ppiVar14;\n      if (((uint)piVar25 & 0x20) != 0) {\n        *ppbVar15 = local_164;\n        ppbVar15[1] = (byte *)((int)local_164 >> 0x1f);\n        goto LAB_0800620e;\n      }\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) != 0) {\n          *(short *)ppbVar15 = (short)local_164;\n          goto LAB_0800620e;\n        }\n        if (((uint)piVar25 & 0x200) != 0) {\n          *(char *)ppbVar15 = (char)local_164;\n          goto LAB_0800620e;\n        }\n      }\n      *ppbVar15 = local_164;\n      goto LAB_0800620e;\n    case (int *)0x70:\n      local_f4 = 0x7830;\n      piVar22 = *local_154;\n      local_11c = \"0123456789abcdef\";\n      piVar25 = (int *)((uint)piVar25 | 2);\n      piVar16 = (int *)0x0;\n      iVar3 = 2;\n      piVar24 = (int *)0x78;\n      local_154 = local_154 + 1;\n      break;\n    case (int *)0x75:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_0800618a;\nLAB_080066c0:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bf2:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(uint)*(ushort *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bf2;\n        piVar22 = (int *)(uint)*(byte *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      break;\n    case (int *)0x78:\n      local_11c = \"0123456789abcdef\";\n      if (((uint)piVar25 & 0x20) != 0) goto LAB_080061ac;\nLAB_08006696:\n      ppiVar14 = local_154 + 1;\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) == 0) {\n          if (((uint)piVar25 & 0x200) == 0) goto LAB_08006bbc;\n          piVar22 = (int *)(uint)*(byte *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n        else {\n          piVar22 = (int *)(uint)*(ushort *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\nLAB_08006bbc:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        local_154 = ppiVar14;\n      }\nLAB_080061be:\n      if ((((uint)piVar25 & 1) != 0) && (((uint)piVar22 | (uint)piVar16) != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 2);\n        local_f4 = CONCAT11((char)piVar24,0x30);\n      }\n      iVar3 = 2;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n    }\n    local_f5 = 0;\n    if (piVar27 == (int *)0xffffffff) {\n      if (iVar3 != 1) goto LAB_08006136;\nLAB_08006980:\n      piVar21 = piVar25;\n      if (piVar16 == (int *)0x0 && piVar22 < (int *)0xa) goto LAB_0800698a;\nLAB_08006f16:\n      lVar32 = CONCAT44(piVar16,piVar22);\n      piVar23 = (int *)(&bStack_2a + 2);\n      piVar22 = (int *)0x0;\n      pbVar26 = local_108;\n      local_168 = piVar23;\n      local_158 = (char *)ppiVar2;\n      local_150._0_4_ = piVar25;\n      local_148 = piVar24;\n      do {\n        iVar3 = (int)((ulonglong)lVar32 >> 0x20);\n        uVar19 = (uint)lVar32;\n        cVar6 = '\\n';\n        FUN_080011ec(uVar19,iVar3,10,0);\n        *(byte *)((int)piVar23 + -1) = cVar6 + 0x30;\n        piVar22 = (int *)((int)piVar22 + 1);\n        piVar23 = (int *)((int)piVar23 + -1);\n        if ((((((uint)piVar25 & 0x400) != 0) && (piVar22 == (int *)(uint)*pbVar26)) &&\n            (piVar22 != (int *)0xff)) && (iVar3 != 0 || 9 < uVar19)) {\n          piVar23 = (int *)((int)piVar23 - (int)local_104);\n          FUN_08009768(piVar23,local_110,local_104);\n          if (pbVar26[1] == 0) {\n            piVar22 = (int *)0x0;\n          }\n          else {\n            pbVar26 = pbVar26 + 1;\n            piVar22 = (int *)0x0;\n          }\n        }\n        lVar32 = FUN_080011ec(uVar19,iVar3,10,0);\n      } while (lVar32 != 0);\n      piVar24 = local_148;\n      piVar25 = (int *)local_150;\n      ppiVar2 = (int **)local_158;\n      local_158 = (char *)((int)local_168 - (int)piVar23);\n      local_138 = piVar22;\n      local_108 = pbVar26;\n    }\n    else {\n      piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n      iVar8 = iVar3;\n      if (((uint)piVar22 | (uint)piVar16) == 0) {\nLAB_080060a4:\n        if (piVar27 == (int *)0x0) {\n          if (iVar3 == 0) {\n            local_158 = (char *)((uint)piVar25 & 1);\n            if ((int *)local_158 == (int *)0x0) {\n              piVar23 = (int *)(&bStack_2a + 2);\n              piVar25 = piVar21;\n            }\n            else {\n              piVar23 = (int *)(&bStack_2a + 1);\n              local_29 = '0';\n              piVar25 = piVar21;\n            }\n          }\n          else {\n            piVar23 = (int *)(&bStack_2a + 2);\n            piVar25 = piVar21;\n            local_158 = (char *)piVar27;\n          }\n        }\n        else {\n          piVar25 = piVar21;\n          if (iVar3 != 1) goto LAB_08006136;\nLAB_0800698a:\n          local_29 = (char)piVar22 + '0';\n          piVar23 = (int *)(&bStack_2a + 1);\n          local_158 = (char *)0x1;\n          piVar25 = piVar21;\n        }\n      }\n      else {\nLAB_08006130:\n        iVar3 = iVar8;\n        piVar25 = piVar21;\n        if (iVar8 == 1) goto LAB_08006980;\nLAB_08006136:\n        if (iVar3 == 2) {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = (int *)((uint)piVar22 >> 4 | (int)piVar16 << 0x1c);\n            piVar16 = (int *)((uint)piVar16 >> 4);\n            piVar23 = (int *)((int)piVar23 + -1);\n            *(char *)piVar23 = local_11c[(uint)piVar22 & 0xf];\n            piVar22 = piVar21;\n          } while (((uint)piVar21 | (uint)piVar16) != 0);\n        }\n        else {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = piVar23;\n            piVar9 = (int *)((uint)piVar22 >> 3 | (int)piVar16 << 0x1d);\n            piVar16 = (int *)((uint)piVar16 >> 3);\n            iVar3 = ((uint)piVar22 & 7) + 0x30;\n            *(byte *)((int)piVar21 + -1) = (byte)iVar3;\n            piVar23 = (int *)((int)piVar21 + -1);\n            piVar22 = piVar9;\n          } while (((uint)piVar9 | (uint)piVar16) != 0);\n          if ((((uint)piVar25 & 1) != 0) && (iVar3 != 0x30)) {\n            piVar23 = (int *)((int)piVar21 + -2);\n            *(byte *)((int)piVar21 + -2) = 0x30;\n            local_158 = (char *)(&bStack_2a + (2 - (int)piVar23));\n            goto LAB_0800675a;\n          }\n        }\n        local_158 = (char *)(&bStack_2a + (2 - (int)piVar23));\n      }\n    }\nLAB_0800675a:\n    local_148 = (int *)0x0;\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = piVar27;\n    local_168 = (int *)local_158;\n    if ((int)local_158 < (int)piVar27) {\n      local_168 = piVar27;\n    }\n    goto LAB_08006538;\n  }\nLAB_08006216:\n  piVar28 = local_160;\n  if (local_d0 == (int *)0x0) {\nLAB_0800604a:\n    uVar13 = *(ushort *)(local_160 + 3);\n  }\n  else {\n    FUN_080097cc(local_16c,local_160,&local_d8);\n    uVar13 = *(ushort *)(piVar28 + 3);\n  }\nLAB_0800604e:\n  if ((uVar13 & 0x40) != 0) {\n    local_164 = (byte *)0xffffffff;\n  }\n  return local_164;\nswitchD_08005f58_caseD_6c:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (piVar24 == (int *)0x6c) {\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    piVar25 = (int *)((uint)piVar25 | 0x20);\n    piVar28 = (int *)((int)piVar28 + 1);\n  }\n  else {\n    piVar25 = (int *)((uint)piVar25 | 0x10);\n  }\n  goto LAB_08005f4a;\n  while( true ) {\n    iVar8 = FUN_08000998((int)uVar33,uVar10,local_124,local_120);\n    if (iVar8 != 0) break;\nLAB_080072ba:\n    piVar16 = param_3;\n    piVar22 = (int *)((int)piVar22 + -1);\n    uVar33 = FUN_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x40300000);\n    iVar3 = FUN_0800119c();\n    uVar34 = FUN_080003f4();\n    uVar33 = FUN_08000158((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),(int)uVar34,\n                          (int)((ulonglong)uVar34 >> 0x20));\n    uVar10 = (undefined4)((ulonglong)uVar33 >> 0x20);\n    param_3 = (int *)((int)piVar16 + 1);\n    *(char *)piVar16 = pcVar18[iVar3];\n    if (piVar22 == (int *)0xffffffff) break;\n  }\n  piVar23 = local_fc;\n  piVar25 = local_100;\n  piVar27 = local_130;\n  piVar24 = local_134;\n  piVar28 = local_138;\n  ppiVar2 = local_13c;\n  local_13c = (int **)piVar22;\n  local_134 = piVar16;\n  local_150 = uVar33;\n  iVar8 = FUN_080009e8((int)uVar33,uVar10,0,0x3fe00000);\n  if (iVar8 == 0) {\n    iVar8 = FUN_08000998((int *)local_150,local_150._4_4_,0,0x3fe00000);\n    if ((iVar8 != 0) && (iVar3 << 0x1f < 0)) goto LAB_0800748a;\n    if (-1 < (int)local_13c) {\n      piVar16 = (int *)((byte *)((int)local_13c + 1) + (int)param_3);\n      piVar22 = param_3;\n      do {\n        param_3 = (int *)((int)piVar22 + 1);\n        *(byte *)piVar22 = 0x30;\n        piVar22 = param_3;\n      } while (piVar16 != param_3);\n    }\n  }\n  else {\nLAB_0800748a:\n    bVar1 = local_158[0xf];\n    bVar7 = *(byte *)piVar16;\n    piVar22 = param_3;\n    local_e0 = local_134;\n    while (bVar1 == bVar7) {\n      *(byte *)((int)piVar22 + -1) = 0x30;\n      bVar7 = *(byte *)((int)local_e0 + -1);\n      piVar22 = local_e0;\n      local_e0 = (int *)((int)local_e0 + -1);\n    }\n    if (bVar7 == 0x39) {\n      bVar7 = local_158[10];\n    }\n    else {\n      bVar7 = bVar7 + 1;\n    }\n    *(byte *)((int)piVar22 + -1) = bVar7;\n  }\n  local_138 = (int *)((int)param_3 - (int)piVar23);\nLAB_08006cb0:\n  local_134 = local_f0;\n  if (local_168 == (int *)0x47) {\n    if (((int)((int)local_f0 + 3) < 0 == SCARRY4((int)local_f0,3)) &&\n       ((int)local_f0 <= (int)piVar27)) {\n      if ((int)local_f0 < (int)local_138) {\n        local_158 = (char *)((int)local_138 + (int)local_118);\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074f8;\n        }\n        local_158 = (char *)((int)local_158 + (1 - (int)local_f0));\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        piVar24 = (int *)0x67;\n      }\n      else {\n        if ((int)piVar25 << 0x1f < 0) {\n          local_158 = (char *)((int)local_f0 + (int)local_118);\n        }\n        else {\n          local_158 = (char *)local_f0;\n        }\n        if (-1 < (int)piVar25 << 0x15) {\n          piVar24 = (int *)0x67;\n          goto LAB_0800754a;\n        }\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074fc;\n        }\n        piVar24 = (int *)0x67;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_080073d6;\n    }\n    piVar24 = (int *)((int)piVar24 + -2);\n    local_168 = (int *)((uint)piVar24 & 0xffffffdf);\nLAB_08006cc4:\n    local_e8 = (char)piVar24;\n    if (local_168 == (int *)0x41) {\n      local_e8 = local_e8 + '\\x0f';\n    }\n    piVar27 = (int *)((int)local_f0 + -1);\n    if ((int)piVar27 < 0) {\n      local_e7 = 0x2d;\n      local_f0 = (int *)(1 - (int)local_f0);\n    }\n    else {\n      local_e7 = 0x2b;\n      local_f0 = piVar27;\n    }\n    if ((int)local_f0 < 10) {\n      if (local_168 == (int *)0x41) {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n      else {\n        local_e6[0] = 0x30;\n        pcVar18 = (char *)((int)&local_e8 + 3);\n      }\n      *pcVar18 = (char)local_f0 + '0';\n      pcVar18 = pcVar18 + 1;\n    }\n    else {\n      pbVar30 = abStack_dc + 3;\n      pbVar26 = pbVar30;\n      do {\n        pbVar5 = pbVar26;\n        piVar22 = (int *)((uint)local_f0 / 10);\n        pbVar5[-1] = (char)local_f0 + (char)piVar22 * -10 + 0x30;\n        pbVar26 = pbVar5 + -1;\n        local_f0 = piVar22;\n      } while ((int *)0x9 < piVar22);\n      uVar19 = (uint)(piVar22 + 0xc) & 0xff;\n      pbVar5[-2] = (byte)uVar19;\n      if (pbVar5 + -2 < pbVar30) {\n        pbVar5 = pbVar26;\n        puVar20 = (undefined *)((int)&local_e8 + 2);\n        while( true ) {\n          *puVar20 = (char)uVar19;\n          if (pbVar30 == pbVar5) break;\n          uVar19 = (uint)*pbVar5;\n          pbVar5 = pbVar5 + 1;\n          puVar20 = puVar20 + 1;\n        }\n        pcVar18 = (char *)(((int)&local_188 * 2 - (int)pbVar26) + 0x152);\n      }\n      else {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n    }\n    local_10c = (int *)(pcVar18 + -(int)&local_e8);\n    local_158 = (char *)((int)local_10c + (int)local_138);\n    if ((1 < (int)local_138) || ((int)piVar25 << 0x1f < 0)) {\n      local_158 = (char *)((int)local_158 + (int)local_118);\n    }\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    piVar25 = (int *)((uint)piVar25 & 0xfffffbff | 0x100);\n    local_f0 = piVar27;\n  }\n  else {\n    if (local_168 != (int *)0x46) goto LAB_08006cc4;\n    if ((int)local_f0 < 1) {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_168 = (int *)0x1;\n        local_158 = (char *)0x1;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)((byte *)((int)local_118 + 1) + (int)piVar27);\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\nLAB_080073d6:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      piVar25 = local_140;\n    }\n    else {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)local_f0;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)((byte *)((int)local_f0 + (int)local_118) + (int)piVar27);\n      }\nLAB_080074f8:\n      if (-1 < (int)piVar25 << 0x15) {\nLAB_0800754a:\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        goto LAB_080073d6;\n      }\nLAB_080074fc:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      uVar19 = (uint)*local_108;\n      while (uVar19 != 0xff) {\n        while( true ) {\n          if ((int)local_134 <= (int)uVar19) goto LAB_08007524;\n          uVar4 = (uint)local_108[1];\n          local_134 = (int *)((int)local_134 - uVar19);\n          if (uVar4 == 0) break;\n          local_108 = local_108 + 1;\n          local_130 = (int *)((int)local_130 + 1);\n          uVar19 = uVar4;\n          if (uVar4 == 0xff) goto LAB_08007524;\n        }\n        local_13c = (int **)((int)local_13c + 1);\n      }\nLAB_08007524:\n      local_158 = (char *)((int)local_158 + (int)local_104 * ((int)local_130 + (int)local_13c));\n      local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      piVar25 = local_140;\n    }\n  }\n  if (local_144 == (int *)0x0) {\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = (int *)0x0;\nLAB_08006538:\n    if (piVar16 != (int *)0x0) goto LAB_0800653e;\n  }\n  else {\n    piVar16 = (int *)0x2d;\n    piVar22 = (int *)0x0;\n    local_f5 = 0x2d;\nLAB_0800653e:\n    local_168 = (int *)((int)local_168 + 1);\n  }\nLAB_08006298:\n  piVar27 = local_160;\n  puVar29 = local_16c;\n  local_150._0_4_ = (int *)((uint)piVar25 & 2);\n  if ((int *)local_150 != (int *)0x0) {\n    local_168 = (int *)((int)local_168 + 2);\n  }\n  local_144 = (int *)((uint)piVar25 & 0x84);\n  if ((local_144 == (int *)0x0) &&\n     (piVar21 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar21)) {\n    if (0x10 < (int)piVar21) {\n      piVar16 = (int *)0x10;\n      local_100 = piVar24;\n      do {\n        piVar9 = piVar21;\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = piVar16;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n          piVar24 = local_100;\n        }\n        else {\n          local_140 = piVar16;\n          iVar3 = FUN_080097cc(puVar29,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = local_140;\n          piVar24 = local_100;\n        }\n        piVar21 = piVar9 + -4;\n        local_100 = piVar24;\n      } while (0x10 < (int)piVar21);\n      piVar21 = piVar9 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar21);\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar21;\n    if ((int)local_d4 < 8) {\n      piVar16 = (int *)(uint)local_f5;\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar16 = (int *)(uint)local_f5;\n    }\n  }\n  if (piVar16 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 1);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f5;\n    ppiVar2[1] = (int *)0x1;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  if ((int *)local_150 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 2);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f4;\n    ppiVar2[1] = (int *)0x2;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  if ((local_144 == (int *)0x80) &&\n     (piVar16 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar16)) {\n    if (0x10 < (int)piVar16) {\n      do {\n        while( true ) {\n          piVar21 = piVar16;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = FUN_080097cc(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = piVar21 + -4;\n          if ((int)(piVar21 + -4) < 0x11) goto LAB_08006882;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar16 = piVar21 + -4;\n      } while (0x10 < (int)(piVar21 + -4));\nLAB_08006882:\n      piVar16 = piVar21 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar16);\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar16;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  piVar22 = (int *)((int)piVar22 - (int)local_158);\n  if (0 < (int)piVar22) {\n    if (0x10 < (int)piVar22) {\n      do {\n        while( true ) {\n          piVar16 = piVar22;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = FUN_080097cc(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar22 = piVar16 + -4;\n          if ((int)(piVar16 + -4) < 0x11) goto LAB_080063d2;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar22 = piVar16 + -4;\n      } while (0x10 < (int)(piVar16 + -4));\nLAB_080063d2:\n      piVar22 = piVar16 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar22);\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar22;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_d0;\n  if (((uint)piVar25 & 0x100) == 0) {\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)local_158);\n    *ppiVar2 = piVar23;\n    ppiVar2[1] = (int *)local_158;\n    if ((int)local_d4 < 8) {\nLAB_0800640e:\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\n    else {\nLAB_08006a20:\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else if ((int)piVar24 < 0x66) {\n    local_158 = (char *)((int)local_d0 + 1);\n    piVar27 = (int *)((int)local_d4 + 1);\n    ppiVar14 = ppiVar2 + 2;\n    local_d0 = (int *)local_158;\n    if (((int)local_138 < 2) && (((uint)piVar25 & 1) == 0)) {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)piVar27 < 8) {\n        local_150._0_4_ = (int *)((int)local_d4 + 2);\n        ppiVar2 = ppiVar2 + 4;\n      }\n      else {\n        local_d4 = piVar27;\n        iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        local_150._0_4_ = (int *)((int)local_d4 + 1);\n        ppiVar14 = local_cc;\n        local_158 = (char *)local_d0;\n        ppiVar2 = local_cc + 2;\n      }\n    }\n    else {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      local_d4 = piVar27;\n      if (7 < (int)piVar27) {\n        iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar14 = local_cc;\n        local_158 = (char *)local_d0;\n      }\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_158 = (char *)((int)local_158 + (int)local_118);\n      *ppiVar14 = local_114;\n      ppiVar14[1] = local_118;\n      local_d0 = (int *)local_158;\n      if ((int)local_d4 < 8) {\n        ppiVar17 = ppiVar14 + 2;\n      }\n      else {\n        iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar17 = local_cc;\n      }\n      piVar24 = local_d4;\n      local_150._0_4_ = (int *)((int)local_d4 + 1);\n      piVar22 = (int *)((int)local_138 + -1);\n      ppiVar11 = ppiVar17 + 2;\n      local_158 = (char *)local_d0;\n      local_144 = (int *)local_150;\n      iVar3 = FUN_08000998(local_128,local_12c,local_124,local_120);\n      piVar27 = local_160;\n      puVar29 = local_16c;\n      if (iVar3 == 0) {\n        local_158 = (char *)((int)local_158 + (int)piVar22);\n        *ppiVar17 = (int *)((int)piVar23 + 1);\n        ppiVar17[1] = piVar22;\n        local_d0 = (int *)local_158;\n        if ((int)(int *)local_150 < 8) {\n          local_150._0_4_ = (int *)((int)piVar24 + 2);\n          ppiVar14 = ppiVar11;\n          ppiVar2 = ppiVar17 + 4;\n        }\n        else {\nLAB_08006d9c:\n          local_158 = (char *)local_d0;\n          local_d4 = (int *)local_150;\n          iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          local_150._0_4_ = (int *)((int)local_d4 + 1);\n          local_158 = (char *)local_d0;\n          ppiVar14 = local_cc;\n          ppiVar2 = local_cc + 2;\n        }\n      }\n      else {\n        ppiVar14 = ppiVar17;\n        ppiVar2 = ppiVar11;\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)local_158;\n          local_d4 = local_144;\n          if (0x10 < (int)piVar22) {\n            while( true ) {\n              local_d0 = local_d0 + 4;\n              *ppiVar17 = (int *)0x8009f60;\n              ppiVar17[1] = (int *)0x10;\n              if ((int)local_d4 < 8) {\n                ppiVar17 = ppiVar17 + 2;\n              }\n              else {\n                iVar3 = FUN_080097cc(puVar29,piVar27,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar17 = local_cc;\n              }\n              piVar22 = piVar22 + -4;\n              if ((int)piVar22 < 0x11) break;\n              local_d4 = (int *)((int)local_d4 + 1);\n            }\n            local_150._0_4_ = (int *)((int)local_d4 + 1);\n            ppiVar11 = ppiVar17 + 2;\n            local_158 = (char *)local_d0;\n          }\n          *ppiVar17 = (int *)0x8009f60;\n          ppiVar17[1] = piVar22;\n          local_158 = (char *)((int)local_158 + (int)piVar22);\n          local_d0 = (int *)local_158;\n          if (7 < (int)(int *)local_150) goto LAB_08006d9c;\n          local_150._0_4_ = (int *)((int)(int *)local_150 + 1);\n          ppiVar2 = ppiVar11 + 2;\n          ppiVar14 = ppiVar11;\n        }\n      }\n    }\n    ppiVar14[1] = local_10c;\n    local_d0 = (int *)((int)local_158 + (int)local_10c);\n    local_d4 = (int *)local_150;\n    *ppiVar14 = (int *)&local_e8;\n    piVar27 = local_d0;\n    if (7 < (int)(int *)local_150) {\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else {\n    iVar3 = FUN_08000998(local_128,local_12c,local_124,local_120);\n    if (iVar3 == 0) {\n      if ((int)local_f0 < 1) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)piVar27 + 1);\n        *ppiVar2 = (int *)&DAT_08009f4c;\n        ppiVar2[1] = (int *)0x1;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        if (((local_f0 != (int *)0x0) || (local_138 != (int *)0x0)) ||\n           (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)local_d0 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n          }\n          puVar29 = local_16c;\n          if ((int)local_f0 < 0) {\n            piVar27 = (int *)-(int)local_f0;\n            if ((int)(local_f0 + 4) < 0 != SCARRY4((int)local_f0,0x10)) {\n              do {\n                local_d4 = (int *)((int)local_d4 + 1);\n                local_d0 = local_d0 + 4;\n                *ppiVar2 = (int *)0x8009f60;\n                ppiVar2[1] = (int *)0x10;\n                if ((int)local_d4 < 8) {\n                  ppiVar2 = ppiVar2 + 2;\n                }\n                else {\n                  iVar3 = FUN_080097cc(puVar29,local_160,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  ppiVar2 = local_cc;\n                }\n                piVar27 = piVar27 + -4;\n              } while (0x10 < (int)piVar27);\n            }\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)local_d0 + (int)piVar27);\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = piVar27;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\n          local_d0 = (int *)((int)local_d0 + (int)local_138);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = local_138;\n          goto joined_r0x08006a1c;\n        }\n      }\n      else {\n        piVar24 = local_134;\n        if ((int)local_138 <= (int)local_134) {\n          piVar24 = local_138;\n        }\n        if (0 < (int)piVar24) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar24);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = piVar24;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        piVar22 = local_134;\n        if (-1 < (int)piVar24) {\n          piVar22 = (int *)((int)local_134 - (int)piVar24);\n        }\n        if (0 < (int)piVar22) {\n          for (; 0x10 < (int)piVar22; piVar22 = piVar22 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = piVar27 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = FUN_080097cc(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n          }\n          local_d4 = (int *)((int)local_d4 + 1);\n          piVar27 = (int *)((int)piVar27 + (int)piVar22);\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar22;\n          local_d0 = piVar27;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar22 = local_104;\n        piVar24 = local_160;\n        puVar29 = local_16c;\n        piVar16 = (int *)((int)local_134 + (int)piVar23);\n        if (((uint)piVar25 & 0x400) != 0) {\n          local_158 = (char *)((int)piVar23 + (int)local_138);\n          pbVar26 = local_108;\n          local_150._0_4_ = piVar28;\n          local_144 = piVar25;\n          local_140 = piVar23;\n          if (local_130 == (int *)0x0) goto LAB_08007176;\nLAB_080070ba:\n          if (local_13c != (int **)0x0) goto LAB_0800717e;\n          pbVar26 = pbVar26 + -1;\n          local_130 = (int *)((int)local_130 + -1);\n          do {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)piVar27 + (int)piVar22);\n            *ppiVar2 = local_110;\n            ppiVar2[1] = piVar22;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = FUN_080097cc(puVar29,piVar24,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = (int *)(uint)*pbVar26;\n            piVar28 = (int *)((int)local_158 - (int)piVar16);\n            if ((int)piVar27 <= (int)(int *)((int)local_158 - (int)piVar16)) {\n              piVar28 = piVar27;\n            }\n            if (0 < (int)piVar28) {\n              local_d0 = (int *)((int)local_d0 + (int)piVar28);\n              local_d4 = (int *)((int)local_d4 + 1);\n              *ppiVar2 = piVar16;\n              ppiVar2[1] = piVar28;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = FUN_080097cc(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar2 = local_cc;\n                piVar27 = (int *)(uint)*pbVar26;\n              }\n            }\n            piVar25 = piVar27;\n            if (-1 < (int)piVar28) {\n              piVar25 = (int *)((int)piVar27 - (int)piVar28);\n            }\n            if (0 < (int)piVar25) {\n              for (; 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n                while( true ) {\n                  local_d4 = (int *)((int)local_d4 + 1);\n                  local_d0 = local_d0 + 4;\n                  *ppiVar2 = (int *)0x8009f60;\n                  ppiVar2[1] = (int *)0x10;\n                  if ((int)local_d4 < 8) break;\n                  iVar3 = FUN_080097cc(puVar29,piVar24,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  piVar25 = piVar25 + -4;\n                  ppiVar2 = local_cc;\n                  if ((int)piVar25 < 0x11) goto LAB_08007156;\n                }\n                ppiVar2 = ppiVar2 + 2;\n              }\nLAB_08007156:\n              local_d4 = (int *)((int)local_d4 + 1);\n              local_d0 = (int *)((int)local_d0 + (int)piVar25);\n              *ppiVar2 = (int *)0x8009f60;\n              ppiVar2[1] = piVar25;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = FUN_080097cc(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = local_cc;\n              }\n            }\n            piVar16 = (int *)((int)piVar16 + (int)piVar27);\n            piVar27 = local_d0;\n            if (local_130 != (int *)0x0) goto LAB_080070ba;\nLAB_08007176:\n            if (local_13c == (int **)0x0) {\n              piVar23 = local_140;\n              piVar25 = local_144;\n              piVar28 = (int *)local_150;\n              local_108 = pbVar26;\n              if ((int *)((int)local_140 + (int)local_138) <= piVar16) {\n                piVar16 = (int *)((int)local_140 + (int)local_138);\n              }\n              break;\n            }\nLAB_0800717e:\n            local_13c = (int **)((int)local_13c + -1);\n          } while( true );\n        }\n        if (((int)local_f0 < (int)local_138) || (((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)piVar27 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar24 = (int *)((int)local_138 - (int)local_f0);\n        piVar22 = (int *)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16);\n        if ((int)piVar24 <= (int)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16)) {\n          piVar22 = piVar24;\n        }\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar22);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar16;\n          ppiVar2[1] = piVar22;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar24 = (int *)((int)local_138 - (int)local_f0);\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        if (-1 < (int)piVar22) {\n          piVar24 = (int *)((int)piVar24 - (int)piVar22);\n        }\n        if (0 < (int)piVar24) {\n          for (; local_d0 = piVar27, 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = FUN_080097cc(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n          }\n          goto LAB_08007014;\n        }\n      }\n    }\n    else {\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_d0 = (int *)((int)piVar27 + 1);\n      *ppiVar2 = (int *)&DAT_08009f4c;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)local_d4 < 8) {\n        ppiVar2 = ppiVar2 + 2;\n      }\n      else {\n        iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar2 = local_cc;\n      }\n      if (((int)local_f0 < (int)local_138) || (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)local_118);\n        *ppiVar2 = local_114;\n        ppiVar2[1] = local_118;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        piVar22 = local_160;\n        puVar29 = local_16c;\n        piVar24 = (int *)((int)local_138 + -1);\n        piVar27 = local_d0;\n        if (0 < (int)piVar24) {\n          for (; 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = FUN_080097cc(puVar29,piVar22,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\nLAB_08007014:\n          local_d0 = (int *)((int)local_d0 + (int)piVar24);\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar24;\njoined_r0x08006a1c:\n          local_d4 = (int *)((int)local_d4 + 1);\n          if (7 < (int)local_d4) goto LAB_08006a20;\n          goto LAB_0800640e;\n        }\n      }\n    }\n  }\n  piVar24 = local_160;\n  puVar29 = local_16c;\n  if ((((uint)piVar25 & 4) != 0) &&\n     (piVar25 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar25)) {\n    for (; local_d0 = piVar27, 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n      while( true ) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = (int *)0x10;\n        if ((int)local_d4 < 8) break;\n        iVar3 = FUN_080097cc(puVar29,piVar24,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        piVar25 = piVar25 + -4;\n        ppiVar2 = local_cc;\n        if ((int)piVar25 < 0x11) goto LAB_0800647a;\n      }\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\nLAB_0800647a:\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar25);\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar25;\n    piVar27 = local_d0;\n    if ((7 < (int)local_d4) &&\n       (iVar3 = FUN_080097cc(local_16c,local_160,&local_d8), piVar27 = local_d0, iVar3 != 0))\n    goto LAB_0800603e;\n  }\n  piVar24 = local_15c;\n  if ((int)local_15c < (int)local_168) {\n    piVar24 = local_168;\n  }\n  local_164 = local_164 + (int)piVar24;\n  if ((piVar27 == (int *)0x0) || (iVar3 = FUN_080097cc(local_16c,local_160,&local_d8), iVar3 == 0))\n  {\n    local_d4 = (int *)0x0;\n    if (local_148 != (int *)0x0) {\n      FUN_080088ec(local_16c,local_148);\n    }\n    ppiVar2 = local_cc;\nLAB_0800620e:\n    bVar1 = *(byte *)piVar28;\n    param_3 = piVar28;\n    goto joined_r0x08005ef2;\n  }\nLAB_0800603e:\n  if (local_148 != (int *)0x0) {\n    FUN_080088ec(local_16c,local_148);\n  }\n  goto LAB_0800604a;\nswitchD_08005f58_caseD_31:\n  local_15c = (int *)0x0;\n  piVar16 = piVar24 + -0xc;\n  piVar22 = piVar28;\n  do {\n    piVar28 = (int *)((int)piVar22 + 1);\n    piVar24 = (int *)(uint)*(byte *)piVar22;\n    local_15c = (int *)((int)piVar16 + (int)local_15c * 10);\n    piVar16 = piVar24 + -0xc;\n    piVar22 = piVar28;\n  } while (piVar16 < (int *)0xa);\n  goto LAB_08005f4e;\nswitchD_08005f58_caseD_20:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (local_f5 == 0) {\n    local_f5 = 0x20;\n  }\n  goto LAB_08005f4a;\n}\n\n",
            "renaming": {
                "FUN_08005e9c": "FUNC_08005e9c"
            },
            "calling": [
                "FUN_08005dfc"
            ],
            "called": [
                "FUN_080097cc",
                "FUN_080079e8",
                "FUN_0800901c",
                "FUN_080011ec",
                "FUN_080009e8",
                "FUN_08001170",
                "FUN_08005e40",
                "FUN_080003f4",
                "FUN_0800119c",
                "FUN_080009ac",
                "FUN_08008ad4",
                "FUN_080088ec",
                "FUN_08000998",
                "FUN_080004c8",
                "FUN_080009c0",
                "FUN_08009768",
                "FUN_080096e0",
                "FUN_08008af8",
                "FUN_08000158"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078a0": {
            "entrypoint": "0x080078a0",
            "current_name": "FUNC_080078a0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080078a4) */\n\nvoid FUNC_080078a0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080078a0": "FUNC_080078a0"
            },
            "calling": [
                "FUN_08005d20"
            ],
            "called": [
                "FUN_080098c0"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078c0": {
            "entrypoint": "0x080078c0",
            "current_name": "calculate_dividend_080078c0",
            "code": "\nuint calculateDividend_080078c0(int dividend,int divisor)\n\n{\n  uint quotient;\n  uint *dividendPtr;\n  int carry;\n  int divisorLength;\n  int dividendLength;\n  uint quotientFactor;\n  uint *divisorPtr;\n  uint *dividendPtrCopy;\n  uint *divisorPtrEnd;\n  uint carry2;\n  uint *divisorPtrCopy;\n  uint *divisorPtrNext;\n  \n  divisorLength = *(int *)(divisor + 0x10);\n  if (*(int *)(dividend + 0x10) < divisorLength) {\n    return 0;\n  }\n  dividendLength = divisorLength + -1;\n  divisorPtr = (uint *)(divisor + 0x14);\n  dividendPtrCopy = (uint *)(dividend + 0x14);\n  quotientFactor = dividendPtrCopy[dividendLength] / (divisorPtr[dividendLength] + 1);\n  divisorPtrEnd = divisorPtr + dividendLength;\n  if (quotientFactor != 0) {\n    quotient = 0;\n    carry = 0;\n    dividendPtr = dividendPtrCopy;\n    divisorPtrCopy = divisorPtr;\n    do {\n      divisorPtrNext = divisorPtrCopy + 1;\n      quotient = quotientFactor * (*divisorPtrCopy & 0xffff) + quotient;\n      carry2 = quotientFactor * (*divisorPtrCopy >> 0x10) + (quotient >> 0x10);\n      quotient = (carry - (quotient & 0xffff)) + (*dividendPtr & 0xffff);\n      carry = ((*dividendPtr >> 0x10) - (carry2 & 0xffff)) + ((int)quotient >> 0x10);\n      *dividendPtr = quotient & 0xffff | carry * 0x10000;\n      carry = carry >> 0x10;\n      quotient = carry2 >> 0x10;\n      dividendPtr = dividendPtr + 1;\n      divisorPtrCopy = divisorPtrNext;\n    } while (divisorPtrNext <= divisorPtrEnd);\n    if (dividendPtrCopy[dividendLength] == 0) {\n      if ((dividendPtrCopy < dividendPtrCopy + divisorLength + -2) && (dividendPtrCopy[divisorLength + -2] == 0)) {\n        dividendPtr = dividendPtrCopy + divisorLength + -3;\n        do {\n          dividendLength = dividendLength + -1;\n          if (dividendPtr <= dividendPtrCopy) break;\n          quotient = *dividendPtr;\n          dividendPtr = dividendPtr + -1;\n        } while (quotient == 0);\n      }\n      *(int *)(dividend + 0x10) = dividendLength;\n    }\n  }\n  divisorLength = FUN_080094f8();\n  if (-1 < divisorLength) {\n    divisorLength = 0;\n    quotientFactor = quotientFactor + 1;\n    dividendPtr = dividendPtrCopy;\n    do {\n      divisorPtrCopy = divisorPtr + 1;\n      quotient = (divisorLength - (*divisorPtr & 0xffff)) + (*dividendPtr & 0xffff);\n      divisorLength = ((*dividendPtr >> 0x10) - (*divisorPtr >> 0x10)) + ((int)quotient >> 0x10);\n      *dividendPtr = quotient & 0xffff | divisorLength * 0x10000;\n      divisorLength = divisorLength >> 0x10;\n      dividendPtr = dividendPtr + 1;\n      divisorPtr = divisorPtrCopy;\n    } while (divisorPtrCopy <= divisorPtrEnd);\n    if (dividendPtrCopy[dividendLength] == 0) {\n      if ((dividendPtrCopy < dividendPtrCopy + dividendLength + -1) && (dividendPtrCopy[dividendLength + -1] == 0)) {\n        divisorPtr = dividendPtrCopy + dividendLength + -2;\n        do {\n          dividendLength = dividendLength + -1;\n          if (divisorPtr <= dividendPtrCopy) break;\n          quotient = *divisorPtr;\n          divisorPtr = divisorPtr + -1;\n        } while (quotient == 0);\n      }\n      *(int *)(dividend + 0x10) = dividendLength;\n    }\n  }\n  return quotientFactor;\n}\n\n",
            "renaming": {
                "FUN_080078c0": "calculate_dividend_080078c0",
                "param_1": "dividend",
                "param_2": "divisor",
                "uVar1": "quotient",
                "puVar2": "dividendPtr",
                "iVar3": "carry",
                "iVar4": "divisorLength",
                "iVar5": "dividendLength",
                "uVar6": "quotientFactor",
                "puVar7": "divisorPtr",
                "puVar8": "dividendPtrCopy",
                "puVar9": "divisorPtrEnd",
                "uVar10": "carry2",
                "puVar11": "divisorPtrCopy",
                "puVar12": "divisorPtrNext"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080094f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080079e8": {
            "entrypoint": "0x080079e8",
            "current_name": "convert_float_to_string_080079e8",
            "code": "\nchar * convertFloatToString_080079e8(int floatValue,undefined4 param2,uint integerPart,uint fractionalPart,uint numDigits,\n                   uint numDecimalDigits,int *errorCode,uint *isNegative,char **outputString)\n\n{\n  bool isInfinity;\n  bool isZero;\n  bool useExponentialNotation;\n  char digit;\n  byte carry;\n  undefined4 temp;\n  int i;\n  int j;\n  int k;\n  char *pcVar10;\n  uint uVar11;\n  undefined4 uVar12;\n  undefined4 uVar13;\n  int index;\n  int numTrailingZeros;\n  undefined4 uVar16;\n  uint uVar17;\n  uint uVar18;\n  int numLeadingZeros;\n  char *pcVar20;\n  char *pcVar21;\n  undefined4 *puVar22;\n  undefined4 uVar23;\n  int digitValue;\n  bool isZero5;\n  undefined8 uVar26;\n  undefined8 uVar27;\n  undefined8 uVar28;\n  uint integerDigit;\n  uint fractionalDigit;\n  uint exponentWidth;\n  int fractionalLen;\n  uint exponentOffset;\n  int integerLen;\n  int zeroPrefix;\n  uint numLeadingZeros;\n  uint digitOffset;\n  uint stack;\n  uint mask;\n  uint temp2;\n  int loopVar;\n  int array [2];\n  \n  index = *(int *)(floatValue + 0x40);\n  if (index != 0) {\n    uVar18 = *(uint *)(floatValue + 0x44);\n    *(uint *)(index + 4) = uVar18;\n    *(int *)(index + 8) = 1 << (uVar18 & 0xff);\n    FUN_0800910c(floatValue,index);\n    *(undefined4 *)(floatValue + 0x40) = 0;\n  }\n  isZero5 = (int)fractionalPart < 0;\n  uVar18 = fractionalPart;\n  if (isZero5) {\n    uVar18 = fractionalPart & 0x7fffffff;\n  }\n  *isNegative = (uint)isZero5;\n  fractionalDigit = fractionalPart;\n  if (isZero5) {\n    fractionalDigit = uVar18;\n  }\n  uVar17 = fractionalDigit;\n  if ((~uVar18 & 0x7ff00000) == 0) {\n    *errorCode = 9999;\n    if ((integerPart == 0) && ((uVar18 & 0xfffff) == 0)) {\n      pcVar10 = \"Infinity\";\n      if (outputString == (char **)0x0) {\n        return pcVar10;\n      }\n      pcVar21 = \"\";\n    }\n    else {\n      pcVar10 = \"NaN\";\n      if (outputString == (char **)0x0) {\n        return pcVar10;\n      }\n      pcVar21 = \"\";\n    }\n    *outputString = pcVar21;\n    return pcVar10;\n  }\n  uVar26 = FUN_08000998(integerPart,fractionalDigit,0,0);\n  if ((int)uVar26 != 0) {\n    *errorCode = 1;\n    if (outputString != (char **)0x0) {\n      *outputString = \"\";\n      return \"0\";\n    }\n    return \"0\";\n  }\n  temp = FUN_08009630(floatValue,(int)((ulonglong)uVar26 >> 0x20),integerPart,fractionalDigit,array,&loopVar)\n  ;\n  index = loopVar;\n  if (uVar18 >> 0x14 == 0) {\n    numLeadingZeros = array[0] + loopVar;\n    numTrailingZeros = numLeadingZeros + 0x432;\n    if (numTrailingZeros < 0x21) {\n      uVar18 = integerPart << (0x20U - numTrailingZeros & 0xff);\n    }\n    else {\n      uVar18 = integerPart >> (numLeadingZeros + 0x412U & 0xff) | uVar18 << (0x40U - numTrailingZeros & 0xff);\n    }\n    uVar26 = FUN_080003d4(uVar18);\n    numLeadingZeros = numLeadingZeros + -1;\n    isZero5 = true;\n    uVar11 = (int)((ulonglong)uVar26 >> 0x20) + 0xfe100000;\n    uVar18 = (uint)uVar26;\n  }\n  else {\n    numLeadingZeros = (uVar18 >> 0x14) - 0x3ff;\n    uVar11 = fractionalDigit & 0xfffff | 0x3ff00000;\n    isZero5 = false;\n    uVar18 = integerPart;\n  }\n  uVar26 = FUN_08000158(uVar18,uVar11,0,0x3ff80000);\n  uVar26 = FUN_080004c8((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0x636f4361,0x3fd287a7);\n  uVar26 = FUN_0800015c((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0x8b60c8b3,0x3fc68a28);\n  uVar27 = FUN_080003f4(numLeadingZeros);\n  uVar27 = FUN_080004c8((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),0x509f79fb,0x3fd34413);\n  uVar26 = FUN_0800015c((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),(int)uVar27,\n                        (int)((ulonglong)uVar27 >> 0x20));\n  uVar13 = (undefined4)((ulonglong)uVar26 >> 0x20);\n  exponentWidth = FUN_0800119c();\n  numTrailingZeros = FUN_080009ac((int)uVar26,uVar13,0,0);\n  if (numTrailingZeros != 0) {\n    uVar27 = FUN_080003f4(exponentWidth);\n    numTrailingZeros = FUN_08000998((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,uVar13);\n    if (numTrailingZeros == 0) {\n      exponentWidth = exponentWidth - 1;\n    }\n  }\n  if (exponentWidth < 0x17) {\n    numTrailingZeros = FUN_080009e8(*(undefined4 *)(&DAT_08009fa8 + exponentWidth * 8),\n                          *(undefined4 *)(&DAT_08009fac + exponentWidth * 8),integerPart,fractionalDigit);\n    if (numTrailingZeros == 0) {\n      isZero = false;\n    }\n    else {\n      exponentWidth = exponentWidth - 1;\n      isZero = false;\n    }\n  }\n  else {\n    isZero = true;\n  }\n  numTrailingZeros = (index - numLeadingZeros) + -1;\n  if (numTrailingZeros < 0) {\n    fractionalLen = 1 - (index - numLeadingZeros);\n    numTrailingZeros = 0;\n  }\n  else {\n    fractionalLen = 0;\n  }\n  if ((int)exponentWidth < 0) {\n    numLeadingZeros = 0;\n    fractionalLen = fractionalLen - exponentWidth;\n    zeroPrefix = -exponentWidth;\n  }\n  else {\n    numTrailingZeros = numTrailingZeros + exponentWidth;\n    numLeadingZeros = exponentWidth;\n    zeroPrefix = 0;\n  }\n  if (9 < numDigits) {\n    mask = 0xffffffff;\n    isInfinity = true;\n    exponentOffset = 0xffffffff;\n    useExponentialNotation = true;\n    numDigits = 0;\n    numDecimalDigits = 0;\n    goto LAB_08007c24;\n  }\n  isInfinity = (int)numDigits < 6;\n  if (!isInfinity) {\n    numDigits = numDigits - 4;\n  }\n  switch(numDigits) {\n  case 2:\n    useExponentialNotation = false;\n    break;\n  case 3:\n    useExponentialNotation = false;\n    goto LAB_08008300;\n  case 4:\n    useExponentialNotation = true;\n    break;\n  case 5:\n    useExponentialNotation = true;\nLAB_08008300:\n    mask = exponentWidth + numDecimalDigits;\n    exponentOffset = mask + 1;\n    uVar18 = exponentOffset;\n    if ((int)exponentOffset < 1) {\n      uVar18 = 1;\n    }\n    goto LAB_08008314;\n  default:\n    *(undefined4 *)(floatValue + 0x44) = 0;\n    pcVar10 = (char *)FUN_080090c0(floatValue,0);\n    mask = 0xffffffff;\n    exponentOffset = 0xffffffff;\n    numDecimalDigits = 0;\n    *(char **)(floatValue + 0x40) = pcVar10;\n    useExponentialNotation = true;\n    goto LAB_08007e36;\n  }\n  if ((int)numDecimalDigits < 1) {\n    mask = 1;\n    numDecimalDigits = 1;\n    exponentOffset = 1;\nLAB_08007c24:\n    *(undefined4 *)(floatValue + 0x44) = 0;\n    uVar11 = mask;\n  }\n  else {\n    mask = numDecimalDigits;\n    exponentOffset = numDecimalDigits;\n    uVar18 = numDecimalDigits;\nLAB_08008314:\n    *(undefined4 *)(floatValue + 0x44) = 0;\n    uVar11 = exponentOffset;\n    if (0x17 < (int)uVar18) {\n      numLeadingZeros = 4;\n      index = 1;\n      do {\n        i = index;\n        numLeadingZeros = numLeadingZeros * 2;\n        index = i + 1;\n      } while (numLeadingZeros + 0x14U <= uVar18);\n      *(int *)(floatValue + 0x44) = i;\n    }\n  }\n  pcVar10 = (char *)FUN_080090c0(floatValue);\n  *(char **)(floatValue + 0x40) = pcVar10;\n  if ((uVar11 < 0xf) && (isInfinity)) {\n    if ((int)exponentWidth < 1) {\n      if (exponentWidth == 0) {\n        index = 2;\n        integerDigit = integerPart;\n      }\n      else {\n        index = (-exponentWidth & 0xf) * 8;\n        uVar26 = FUN_080004c8(integerPart,fractionalDigit,*(undefined4 *)(&DAT_08009fa8 + index),\n                              *(undefined4 *)(&DAT_08009fac + index));\n        fractionalDigit = (uint)((ulonglong)uVar26 >> 0x20);\n        integerDigit = (uint)uVar26;\n        numLeadingZeros = (int)-exponentWidth >> 4;\n        if (numLeadingZeros == 0) {\n          index = 2;\n        }\n        else {\n          isInfinity = false;\n          index = 2;\n          puVar22 = &DAT_08009f80;\n          do {\n            if (numLeadingZeros << 0x1f < 0) {\n              uVar26 = FUN_080004c8((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),*puVar22,puVar22[1]\n                                   );\n              isInfinity = true;\n              index = index + 1;\n            }\n            numLeadingZeros = numLeadingZeros >> 1;\n            puVar22 = puVar22 + 2;\n          } while (numLeadingZeros != 0);\n          if (isInfinity) {\n            integerDigit = (uint)uVar26;\n            fractionalDigit = (uint)((ulonglong)uVar26 >> 0x20);\n          }\n        }\n      }\n    }\n    else {\n      uVar18 = (int)exponentWidth >> 4;\n      uVar27 = *(undefined8 *)(&DAT_08009fa8 + (exponentWidth & 0xf) * 8);\n      uVar26 = *(undefined8 *)(&DAT_08009fa8 + (exponentWidth & 0xf) * 8);\n      if ((int)(uVar18 << 0x1b) < 0) {\n        uVar28 = FUN_0800071c(integerPart,fractionalDigit,0x7f73bf3c,0x75154fdd);\n        stack = (uint)((ulonglong)uVar28 >> 0x20);\n        digitOffset = (uint)uVar28;\n        index = 3;\n        uVar18 = uVar18 & 0xf;\n      }\n      else {\n        index = 2;\n        stack = fractionalDigit;\n        digitOffset = integerPart;\n      }\n      if (uVar18 != 0) {\n        puVar22 = &DAT_08009f80;\n        do {\n          if ((int)(uVar18 << 0x1f) < 0) {\n            uVar26 = FUN_080004c8((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),*puVar22,puVar22[1]);\n            index = index + 1;\n          }\n          uVar18 = (int)uVar18 >> 1;\n          puVar22 = puVar22 + 2;\n          uVar27 = uVar26;\n        } while (uVar18 != 0);\n      }\n      fractionalDigit = (uint)((ulonglong)uVar27 >> 0x20);\n      integerDigit = (uint)uVar27;\n      uVar26 = FUN_0800071c(digitOffset,stack,integerDigit,fractionalDigit);\n      integerDigit = (uint)uVar26;\n      fractionalDigit = (uint)((ulonglong)uVar26 >> 0x20);\n    }\n    uVar26 = CONCAT44(fractionalDigit,integerDigit);\n    if ((isZero) && (numLeadingZeros = FUN_080009ac(integerDigit,fractionalDigit,0,0x3ff00000), numLeadingZeros != 0)) {\n      if (exponentOffset == 0) {\n        uVar26 = FUN_080003f4(index);\n        uVar26 = FUN_080004c8((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),integerDigit,fractionalDigit);\n        uVar26 = FUN_0800015c((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0x401c0000);\n        uVar13 = (undefined4)uVar26;\n        index = (int)((ulonglong)uVar26 >> 0x20) + -0x3400000;\n        goto LAB_0800852e;\n      }\n      if (0 < (int)mask) {\n        uVar26 = FUN_080004c8(integerDigit,fractionalDigit,0,0x40240000);\n        uVar27 = FUN_080003f4(index + 1);\n        uVar27 = FUN_080004c8((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,\n                              (int)((ulonglong)uVar26 >> 0x20));\n        uVar27 = FUN_0800015c((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),0,0x401c0000);\n        uVar13 = (undefined4)uVar27;\n        digitOffset = mask;\n        temp2 = exponentWidth - 1;\n        index = (int)((ulonglong)uVar27 >> 0x20) + -0x3400000;\n        goto LAB_08007cfa;\n      }\n      goto LAB_08007e36;\n    }\n    uVar27 = FUN_080003f4(index);\n    uVar27 = FUN_080004c8((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),integerDigit,fractionalDigit);\n    uVar27 = FUN_0800015c((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),0,0x401c0000);\n    uVar13 = (undefined4)uVar27;\n    index = (int)((ulonglong)uVar27 >> 0x20) + -0x3400000;\n    if (exponentOffset != 0) {\n      temp2 = exponentWidth;\n      digitOffset = exponentOffset;\nLAB_08007cfa:\n      fractionalDigit = (uint)((ulonglong)uVar26 >> 0x20);\n      integerDigit = (uint)uVar26;\n      digit = FUN_0800119c(integerDigit,fractionalDigit);\n      digit = digit + '0';\n      uVar16 = (&DAT_08009fa0)[digitOffset * 2];\n      uVar12 = (&DAT_08009fa4)[digitOffset * 2];\n      uVar26 = FUN_080003f4();\n      uVar26 = FUN_08000158(integerDigit,fractionalDigit,(int)uVar26,(int)((ulonglong)uVar26 >> 0x20));\n      uVar23 = (undefined4)((ulonglong)uVar26 >> 0x20);\n      pcVar21 = pcVar10 + 1;\n      if (useExponentialNotation) {\n        uVar27 = FUN_0800071c(0,0x3fe00000,uVar16,uVar12);\n        uVar27 = FUN_08000158((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),uVar13,index);\n        uVar13 = (undefined4)((ulonglong)uVar27 >> 0x20);\n        *pcVar10 = digit;\n        index = FUN_080009e8((int)uVar27,uVar13,(int)uVar26,uVar23);\n        if (index != 0) {\nLAB_08008784:\n          exponentWidth = temp2;\n          goto LAB_08008294;\n        }\n        uVar28 = FUN_08000158(0,0x3ff00000,(int)uVar26,uVar23);\n        index = FUN_080009e8((int)uVar27,uVar13,(int)uVar28,(int)((ulonglong)uVar28 >> 0x20));\n        if (index == 0) {\n          if (digitOffset != 1) {\n            pcVar20 = pcVar21;\n            do {\n              uVar27 = FUN_080004c8((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),0,0x40240000);\n              uVar13 = (undefined4)((ulonglong)uVar27 >> 0x20);\n              uVar26 = FUN_080004c8((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0x40240000);\n              digit = FUN_0800119c();\n              uVar28 = FUN_080003f4();\n              uVar26 = FUN_08000158((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),(int)uVar28,\n                                    (int)((ulonglong)uVar28 >> 0x20));\n              uVar16 = (undefined4)((ulonglong)uVar26 >> 0x20);\n              digit = digit + '0';\n              pcVar21 = pcVar20 + 1;\n              *pcVar20 = digit;\n              index = FUN_080009ac((int)uVar26,uVar16,(int)uVar27,uVar13);\n              if (index != 0) {\n                exponentWidth = temp2;\n                goto LAB_08008294;\n              }\n              uVar28 = FUN_08000158(0,0x3ff00000,(int)uVar26,uVar16);\n              index = FUN_080009ac((int)uVar28,(int)((ulonglong)uVar28 >> 0x20),(int)uVar27,uVar13)\n              ;\n              if (index != 0) goto LAB_08008798;\n              pcVar20 = pcVar21;\n            } while (pcVar21 != pcVar10 + digitOffset);\n          }\n          goto LAB_08007e36;\n        }\nLAB_08008798:\n        exponentWidth = temp2;\n      }\n      else {\n        uVar27 = FUN_080004c8(uVar13,index,uVar16,uVar12);\n        uVar13 = (undefined4)((ulonglong)uVar27 >> 0x20);\n        *pcVar10 = digit;\n        if (digitOffset != 1) {\n          pcVar20 = pcVar21;\n          do {\n            uVar26 = FUN_080004c8((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0x40240000);\n            digit = FUN_0800119c();\n            uVar28 = FUN_080003f4();\n            uVar26 = FUN_08000158((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),(int)uVar28,\n                                  (int)((ulonglong)uVar28 >> 0x20));\n            pcVar21 = pcVar20 + 1;\n            *pcVar20 = digit + '0';\n            pcVar20 = pcVar21;\n          } while (pcVar21 != pcVar10 + digitOffset);\n        }\n        uVar16 = (undefined4)((ulonglong)uVar26 >> 0x20);\n        uVar28 = FUN_0800015c((int)uVar27,uVar13,0,0x3fe00000);\n        index = FUN_080009ac((int)uVar28,(int)((ulonglong)uVar28 >> 0x20),(int)uVar26,uVar16);\n        if (index == 0) {\n          uVar27 = FUN_08000158(0,0x3fe00000,(int)uVar27,uVar13);\n          index = FUN_080009e8((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,uVar16);\n          pcVar20 = pcVar21;\n          if (index == 0) goto LAB_08007e36;\n          do {\n            pcVar21 = pcVar20;\n            pcVar20 = pcVar21 + -1;\n          } while (pcVar21[-1] == '0');\n          goto LAB_08008784;\n        }\n        exponentWidth = temp2;\n        digit = pcVar21[-1];\n      }\n      goto LAB_08007f7c;\n    }\nLAB_0800852e:\n    uVar26 = FUN_08000158(integerDigit,fractionalDigit,0,0x40140000);\n    uVar16 = (undefined4)((ulonglong)uVar26 >> 0x20);\n    numLeadingZeros = FUN_080009e8((int)uVar26,uVar16,uVar13,index);\n    if (numLeadingZeros == 0) {\n      index = FUN_080009ac((int)uVar26,uVar16,uVar13,index + -0x80000000);\n      if (index == 0) goto LAB_08007e36;\n      numLeadingZeros = 0;\n      index = 0;\n      pcVar21 = pcVar10;\n      goto LAB_080084f0;\n    }\n    numTrailingZeros = 0;\n    i = 0;\nLAB_08008406:\n    *pcVar10 = '1';\n    exponentWidth = exponentWidth + 1;\n    pcVar21 = pcVar10 + 1;\n    numLeadingZeros = i;\n    index = numTrailingZeros;\nLAB_08008416:\n    FUN_0800910c(floatValue,index);\n    if (numLeadingZeros == 0) goto LAB_08008294;\n  }\n  else {\nLAB_08007e36:\n    pcVar21 = pcVar10;\n    if ((-1 < array[0]) && ((int)exponentWidth < 0xf)) {\n      uVar13 = *(undefined4 *)(&DAT_08009fa8 + exponentWidth * 8);\n      uVar16 = *(undefined4 *)(&DAT_08009fac + exponentWidth * 8);\n      if ((-1 < (int)numDecimalDigits) || (0 < (int)exponentOffset)) {\n        FUN_0800071c(integerPart,uVar17,uVar13,uVar16);\n        carry = FUN_0800119c();\n        uVar26 = FUN_080003f4();\n        uVar26 = FUN_080004c8((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),uVar13,uVar16);\n        uVar26 = FUN_08000158(integerPart,uVar17,(int)uVar26,(int)((ulonglong)uVar26 >> 0x20));\n        *pcVar10 = carry + 0x30;\n        pcVar21 = pcVar10 + 1;\n        if (exponentOffset != 1) {\n          uVar26 = FUN_080004c8((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0x40240000);\n          index = FUN_08000998((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0);\n          while (index == 0) {\n            uVar23 = (undefined4)((ulonglong)uVar26 >> 0x20);\n            FUN_0800071c((int)uVar26,uVar23,uVar13,uVar16);\n            carry = FUN_0800119c();\n            uVar27 = FUN_080003f4();\n            uVar27 = FUN_080004c8((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),uVar13,uVar16);\n            uVar26 = FUN_08000158((int)uVar26,uVar23,(int)uVar27,(int)((ulonglong)uVar27 >> 0x20));\n            pcVar20 = pcVar21 + 1;\n            *pcVar21 = carry + 0x30;\n            pcVar21 = pcVar20;\n            if (exponentOffset == (int)pcVar20 - (int)pcVar10) goto LAB_08007f3a;\n            uVar26 = FUN_080004c8((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0x40240000);\n            index = FUN_08000998((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0);\n          }\n          goto LAB_08008294;\n        }\nLAB_08007f3a:\n        uVar26 = FUN_0800015c((int)uVar26,(int)((ulonglong)uVar26 >> 0x20));\n        uVar23 = (undefined4)((ulonglong)uVar26 >> 0x20);\n        index = FUN_080009e8((int)uVar26,uVar23,uVar13,uVar16);\n        if ((index == 0) &&\n           ((index = FUN_08000998((int)uVar26,uVar23,uVar13,uVar16), index == 0 ||\n            ((carry & 1) == 0)))) goto LAB_08008294;\n        digit = pcVar21[-1];\nLAB_08007f7c:\n        while (pcVar20 = pcVar21 + -1, digit == '9') {\n          if (pcVar10 == pcVar20) {\n            *pcVar10 = '0';\n            digit = pcVar21[-1];\n            exponentWidth = exponentWidth + 1;\n            pcVar20 = pcVar10;\n            break;\n          }\n          digit = pcVar21[-2];\n          pcVar21 = pcVar20;\n        }\n        *pcVar20 = digit + '\\x01';\n        goto LAB_08008294;\n      }\n      if (exponentOffset == 0) {\n        uVar26 = FUN_080004c8(uVar13,uVar16,0,0x40140000);\n        k = FUN_080009d4((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),integerPart,uVar17);\n        numLeadingZeros = 0;\n        numTrailingZeros = 0;\n        i = 0;\n        index = 0;\n        if (k == 0) goto LAB_08008406;\n      }\n      else {\n        numLeadingZeros = 0;\n        index = 0;\n      }\nLAB_080084f0:\n      exponentWidth = ~numDecimalDigits;\n      pcVar10 = pcVar21;\n      goto LAB_08008416;\n    }\n    index = zeroPrefix;\n    if (useExponentialNotation) {\n      if ((int)numDigits < 2) {\n        if (isZero5) {\n          integerLen = fractionalLen;\n          fractionalLen = fractionalLen + array[0] + 0x433;\n          numTrailingZeros = numTrailingZeros + array[0] + 0x433;\n        }\n        else {\n          integerLen = fractionalLen;\n          fractionalLen = fractionalLen + (0x36 - loopVar);\n          numTrailingZeros = numTrailingZeros + (0x36 - loopVar);\n        }\n      }\n      else {\n        numLeadingZeros = exponentOffset - 1;\n        if (zeroPrefix < numLeadingZeros) {\n          numLeadingZeros = numLeadingZeros + (numLeadingZeros - zeroPrefix);\n          index = 0;\n          zeroPrefix = numLeadingZeros;\n        }\n        else {\n          index = zeroPrefix - numLeadingZeros;\n        }\n        if ((int)exponentOffset < 0) {\n          integerLen = fractionalLen - exponentOffset;\n        }\n        else {\n          numTrailingZeros = numTrailingZeros + exponentOffset;\n          integerLen = fractionalLen;\n          fractionalLen = fractionalLen + exponentOffset;\n        }\n      }\n      numLeadingZeros = FUN_08009244(floatValue,1);\n    }\n    else {\n      integerLen = fractionalLen;\n      numLeadingZeros = 0;\n    }\n    if ((0 < integerLen) && (0 < numTrailingZeros)) {\n      i = integerLen;\n      if (numTrailingZeros <= integerLen) {\n        i = numTrailingZeros;\n      }\n      numTrailingZeros = numTrailingZeros - i;\n      fractionalLen = fractionalLen - i;\n      integerLen = integerLen - i;\n    }\n    if (zeroPrefix != 0) {\n      if (useExponentialNotation) {\n        uVar13 = temp;\n        if (index != 0) {\n          numLeadingZeros = FUN_080093a4(floatValue,numLeadingZeros,index);\n          uVar13 = FUN_08009258(floatValue,numLeadingZeros,temp);\n          FUN_0800910c(floatValue,temp);\n          temp = uVar13;\n          if (zeroPrefix - index == 0) goto LAB_08008062;\n        }\n        temp = FUN_080093a4(floatValue,uVar13,zeroPrefix - index);\n      }\n      else {\n        temp = FUN_080093a4(floatValue,temp,zeroPrefix);\n      }\n    }\nLAB_08008062:\n    index = FUN_08009244(floatValue,1);\n    if (numLeadingZeros == 0) {\n      if (((int)numDigits < 2) && (integerPart == 0)) {\nLAB_0800835a:\n        if ((uVar17 & 0xfffff) == 0) {\n          uVar17 = uVar17 & 0x7ff00000;\n          if (uVar17 != 0) {\n            numTrailingZeros = numTrailingZeros + 1;\n            fractionalLen = fractionalLen + 1;\n            uVar17 = 1;\n          }\n        }\n        else {\n          uVar17 = 0;\n        }\n        isZero5 = numLeadingZeros != 0;\n        uVar18 = integerPart;\n        numLeadingZeros = uVar17;\n        if (isZero5) goto LAB_080082d4;\n      }\n      i = 1;\n    }\n    else {\n      uVar26 = FUN_080093a4(floatValue,index);\n      index = (int)uVar26;\n      if (((int)numDigits < 2) && (integerPart == 0)) goto LAB_0800835a;\n      numLeadingZeros = 0;\n      uVar18 = (uint)((ulonglong)uVar26 >> 0x20);\nLAB_080082d4:\n      i = FUN_080091a4(*(undefined4 *)(index + *(int *)(index + 0x10) * 4 + 0x10),uVar18);\n      i = 0x20 - i;\n    }\n    uVar18 = i + numTrailingZeros & 0x1f;\n    if (uVar18 == 0) {\n      i = 0x1c;\nLAB_08008096:\n      numTrailingZeros = numTrailingZeros + i;\n      fractionalLen = fractionalLen + i;\n      integerLen = integerLen + i;\n    }\n    else {\n      if (4 < (int)(0x20 - uVar18)) {\n        i = 0x1c - uVar18;\n        goto LAB_08008096;\n      }\n      if (0x20 - uVar18 != 4) {\n        i = 0x3c - uVar18;\n        goto LAB_08008096;\n      }\n    }\n    if (0 < fractionalLen) {\n      temp = FUN_08009444(floatValue,temp,fractionalLen);\n    }\n    if (0 < numTrailingZeros) {\n      index = FUN_08009444(floatValue,index,numTrailingZeros);\n    }\n    pcVar20 = pcVar10;\n    if ((isZero) && (numTrailingZeros = FUN_080094f8(temp,index), numTrailingZeros < 0)) {\n      exponentWidth = exponentWidth - 1;\n      temp = FUN_08009120(floatValue,temp,10,0);\n      if (useExponentialNotation) {\n        numLeadingZeros = FUN_08009120(floatValue,numLeadingZeros,10,0);\n        if ((0 < (int)mask) || ((int)numDigits < 3)) {\n          exponentOffset = mask;\n          goto LAB_080080de;\n        }\n      }\n      else if ((0 < (int)mask) || ((int)numDigits < 3)) {\n        exponentOffset = mask;\n        goto LAB_0800820a;\n      }\n      exponentOffset = mask;\nLAB_080084e8:\n      if (exponentOffset == 0) {\n        numTrailingZeros = FUN_08009120(floatValue,index,5);\n        k = FUN_080094f8(temp,numTrailingZeros);\n        i = numLeadingZeros;\n        index = numTrailingZeros;\n        if (0 < k) goto LAB_08008406;\n      }\n      goto LAB_080084f0;\n    }\n    if (((int)exponentOffset < 1) && (2 < (int)numDigits)) goto LAB_080084e8;\n    if (useExponentialNotation) {\nLAB_080080de:\n      integerDigit = numLeadingZeros;\n      if (0 < integerLen) {\n        integerDigit = FUN_08009444(floatValue,numLeadingZeros,integerLen);\n      }\n      numLeadingZeros = integerDigit;\n      if (numLeadingZeros != 0) {\n        numLeadingZeros = FUN_080090c0(floatValue,*(undefined4 *)(integerDigit + 4));\n        FUN_08001084(numLeadingZeros + 0xc,integerDigit + 0xc,(*(int *)(integerDigit + 0x10) + 2) * 4);\n        numLeadingZeros = FUN_08009444(floatValue,numLeadingZeros,1);\n      }\nLAB_08008108:\n      numTrailingZeros = FUN_080078c0(temp,index);\n      i = FUN_080094f8(temp,integerDigit);\n      k = FUN_08009530(floatValue,index,numLeadingZeros);\n      digitValue = numTrailingZeros + 0x30;\n      if (*(int *)(k + 0xc) == 0) {\n        j = FUN_080094f8(temp);\n        FUN_0800910c(floatValue,k);\n        if ((j != 0) || (numDigits != 0)) goto LAB_0800815a;\n        if ((integerPart & 1) != 0) {\n          j = 0;\n          goto LAB_0800815a;\n        }\n        if (digitValue != 0x39) {\n          if (0 < i) goto LAB_0800874c;\n          goto LAB_080085a4;\n        }\nLAB_08008752:\n        pcVar21 = pcVar20 + 1;\n        digit = '9';\n        *pcVar20 = '9';\n        goto LAB_08008268;\n      }\n      FUN_0800910c(floatValue,k);\n      j = 1;\nLAB_0800815a:\n      if ((i < 0) || (((i == 0 && (numDigits == 0)) && ((integerPart & 1) == 0)))) {\n        if (0 < j) {\n          temp = FUN_08009444(floatValue,temp,1);\n          i = FUN_080094f8(temp,index);\n          if ((0 < i) || ((i == 0 && (numTrailingZeros << 0x1f < 0)))) {\n            if (digitValue == 0x39) goto LAB_08008752;\nLAB_0800874c:\n            digitValue = numTrailingZeros + 0x31;\n          }\n        }\nLAB_080085a4:\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)digitValue;\n        goto LAB_08008274;\n      }\n      pcVar21 = pcVar20 + 1;\n      if (0 < j) {\n        if (digitValue == 0x39) goto LAB_08008752;\n        *pcVar20 = (char)numTrailingZeros + '1';\n        goto LAB_08008274;\n      }\n      *pcVar20 = (char)digitValue;\n      if (pcVar10 + (exponentOffset - 1) != pcVar20) {\n        temp = FUN_08009120(floatValue,temp,10,0);\n        pcVar20 = pcVar21;\n        if (integerDigit == numLeadingZeros) {\n          integerDigit = FUN_08009120(floatValue,integerDigit,10,0);\n          numLeadingZeros = integerDigit;\n        }\n        else {\n          integerDigit = FUN_08009120(floatValue,integerDigit,10,0);\n          numLeadingZeros = FUN_08009120(floatValue,numLeadingZeros,10,0);\n        }\n        goto LAB_08008108;\n      }\n    }\n    else {\nLAB_0800820a:\n      while( true ) {\n        digitValue = FUN_080078c0(temp,index);\n        digitValue = digitValue + 0x30;\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)digitValue;\n        if ((int)exponentOffset <= (int)pcVar21 - (int)pcVar10) break;\n        temp = FUN_08009120(floatValue,temp,10,0);\n        pcVar20 = pcVar21;\n      }\n      integerDigit = 0;\n    }\n    temp = FUN_08009444(floatValue,temp,1);\n    numTrailingZeros = FUN_080094f8(temp,index);\n    digit = pcVar21[-1];\n    if ((0 < numTrailingZeros) || ((numTrailingZeros == 0 && (digitValue << 0x1f < 0)))) {\nLAB_08008268:\n      do {\n        pcVar20 = pcVar21 + -1;\n        if (digit != '9') goto code_r0x08008270;\n        if (pcVar10 == pcVar20) {\n          *pcVar10 = '1';\n          exponentWidth = exponentWidth + 1;\n          goto LAB_08008274;\n        }\n        digit = pcVar21[-2];\n        pcVar21 = pcVar20;\n      } while( true );\n    }\n    while (digit == '0') {\n      digit = pcVar21[-2];\n      pcVar21 = pcVar21 + -1;\n    }\nLAB_08008274:\n    FUN_0800910c(floatValue,index);\n    if (numLeadingZeros == 0) goto LAB_08008294;\n    if ((integerDigit != 0) && (integerDigit != numLeadingZeros)) {\n      FUN_0800910c(floatValue);\n    }\n  }\n  FUN_0800910c(floatValue,numLeadingZeros);\nLAB_08008294:\n  FUN_0800910c(floatValue,temp);\n  *pcVar21 = '\\0';\n  *errorCode = exponentWidth + 1;\n  if (outputString == (char **)0x0) {\n    return pcVar10;\n  }\n  *outputString = pcVar21;\n  return pcVar10;\ncode_r0x08008270:\n  *pcVar20 = digit + '\\x01';\n  goto LAB_08008274;\n}\n\n",
            "renaming": {
                "FUN_080079e8": "convert_float_to_string_080079e8",
                "param_1": "floatValue",
                "param_2": "param2",
                "param_3": "integerPart",
                "param_4": "fractionalPart",
                "param_5": "numDigits",
                "param_6": "numDecimalDigits",
                "param_7": "errorCode",
                "param_8": "isNegative",
                "param_9": "outputString",
                "bVar1": "isInfinity",
                "bVar2": "isZero",
                "bVar3": "useExponentialNotation",
                "cVar4": "digit",
                "bVar5": "carry",
                "uVar6": "temp",
                "iVar7": "i",
                "iVar8": "j",
                "iVar9": "k",
                "iVar14": "index",
                "iVar15": "numTrailingZeros",
                "iVar19": "numLeadingZeros",
                "iVar24": "digitValue",
                "local_80": "integerDigit",
                "local_7c": "fractionalDigit",
                "local_74": "exponentWidth",
                "local_70": "fractionalLen",
                "local_68": "exponentOffset",
                "local_60": "integerLen",
                "local_5c": "zeroPrefix",
                "local_58": "numLeadingZeros",
                "local_48": "digitOffset",
                "uStack_44": "stack",
                "local_38": "mask",
                "local_34": "temp2",
                "local_30": "loopVar",
                "local_2c": "array"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_08001084",
                "FUN_08009258",
                "FUN_080078c0",
                "FUN_080003d4",
                "FUN_08009244",
                "FUN_080009e8",
                "FUN_080091a4",
                "FUN_0800910c",
                "FUN_0800015c",
                "FUN_080094f8",
                "FUN_08009120",
                "FUN_080003f4",
                "FUN_08009630",
                "FUN_08009444",
                "FUN_0800119c",
                "FUN_080090c0",
                "FUN_080009d4",
                "FUN_080009ac",
                "FUN_08000998",
                "FUN_08009530",
                "FUN_080093a4",
                "FUN_080004c8",
                "FUN_0800071c",
                "FUN_08000158"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800884c": {
            "entrypoint": "0x0800884c",
            "current_name": "allocate_memory_0800884c",
            "code": "\nundefined4 allocate_memory_0800884c(undefined4 memory_control_block,int size)\n\n{\n  int result;\n  int aligned_address;\n  uint masked_size;\n  \n  FUN_080090a8();\n  masked_size = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  aligned_address = ((0xfef - size) + masked_size & 0xfffff000) - 0x1000;\n  if (0xfff < aligned_address) {\n    result = FUN_08009744(memory_control_block,0);\n    if (result == DAT_20000454 + masked_size) {\n      result = FUN_08009744(memory_control_block,-aligned_address);\n      if (result != -1) {\n        DAT_20000a14 = DAT_20000a14 - aligned_address;\n        *(uint *)(DAT_20000454 + 4) = masked_size - aligned_address | 1;\n        FUN_080090b4(memory_control_block);\n        return 1;\n      }\n      aligned_address = FUN_08009744(memory_control_block,0);\n      if (0xf < aligned_address - DAT_20000454) {\n        DAT_20000a14 = aligned_address - DAT_20000854;\n        *(uint *)(DAT_20000454 + 4) = aligned_address - DAT_20000454 | 1;\n      }\n    }\n  }\n  FUN_080090b4(memory_control_block);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800884c": "allocate_memory_0800884c",
                "param_1": "memory_control_block",
                "param_2": "size",
                "iVar1": "result",
                "iVar2": "aligned_address",
                "uVar3": "masked_size"
            },
            "calling": [
                "FUN_080088ec"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_080090b4",
                "FUN_08009744"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080088ec": {
            "entrypoint": "0x080088ec",
            "current_name": "deallocate_memory_block_080088ec",
            "code": "\nvoid deallocateMemoryBlock_080088ec(undefined4 param_1,int memoryBlock,undefined4 param_3,undefined4 param_4)\n\n{\n  int index;\n  uint *currentBlock;\n  uint *nextBlock;\n  undefined *previousBlock;\n  uint blockSize;\n  uint blockHeaderSize;\n  undefined *headerAddress;\n  undefined *footerAddress;\n  undefined4 *tempBlock;\n  int blockIndex;\n  uint previousBlockStatus;\n  uint nextBlockFooterValue;\n  \n  if (memoryBlock == 0) {\n    return;\n  }\n  FUN_080090a8();\n  previousBlockStatus = *(uint *)(memoryBlock + -4);\n  currentBlock = (uint *)(memoryBlock + -8);\n  blockSize = previousBlockStatus & 0xfffffffe;\n  nextBlock = (uint *)((int)currentBlock + blockSize);\n  blockHeaderSize = nextBlock[1] & 0xfffffffc;\n  if (DAT_20000454 == nextBlock) {\n    blockSize = blockSize + blockHeaderSize;\n    if ((previousBlockStatus & 1) == 0) {\n      currentBlock = (uint *)((int)currentBlock - *(int *)(memoryBlock + -8));\n      blockHeaderSize = currentBlock[2];\n      previousBlockStatus = currentBlock[3];\n      blockSize = blockSize + *(int *)(memoryBlock + -8);\n      *(uint *)(blockHeaderSize + 0xc) = previousBlockStatus;\n      *(uint *)(previousBlockStatus + 8) = blockHeaderSize;\n    }\n    blockHeaderSize = DAT_20000858;\n    currentBlock[1] = blockSize | 1;\n    DAT_20000454 = currentBlock;\n    if (blockHeaderSize <= blockSize) {\n      FUN_0800884c(param_1,DAT_20000a44);\n    }\nLAB_080089f0:\n    FUN_080090b4(param_1);\n    return;\n  }\n  nextBlock[1] = blockHeaderSize;\n  if ((previousBlockStatus & 1) == 0) {\n    currentBlock = (uint *)((int)currentBlock - *(int *)(memoryBlock + -8));\n    tempBlock = (undefined4 *)currentBlock[2];\n    blockSize = blockSize + *(int *)(memoryBlock + -8);\n    previousBlockStatus = *(uint *)((int)nextBlock + blockHeaderSize + 4) & 1;\n    if ((uint **)tempBlock == &DAT_20000454) {\n      if (previousBlockStatus == 0) {\n        previousBlockStatus = nextBlock[2];\n        nextBlockFooterValue = nextBlock[3];\n        blockSize = blockSize + blockHeaderSize;\n        *(uint *)(previousBlockStatus + 0xc) = nextBlockFooterValue;\n        *(uint *)(nextBlockFooterValue + 8) = previousBlockStatus;\n        currentBlock[1] = blockSize | 1;\n        *(uint *)((int)currentBlock + blockSize) = blockSize;\n      }\n      else {\n        currentBlock[1] = blockSize | 1;\n        *nextBlock = blockSize;\n      }\n      goto LAB_080089f0;\n    }\n    nextBlockFooterValue = currentBlock[3];\n    tempBlock[3] = nextBlockFooterValue;\n    *(undefined4 **)(nextBlockFooterValue + 8) = tempBlock;\n  }\n  else {\n    previousBlockStatus = *(uint *)((int)nextBlock + blockHeaderSize + 4) & 1;\n  }\n  if (previousBlockStatus == 0) {\n    tempBlock = (undefined4 *)nextBlock[2];\n    blockSize = blockSize + blockHeaderSize;\n    if ((uint **)tempBlock == &DAT_20000454) {\n      DAT_2000045c = currentBlock;\n      DAT_20000460 = currentBlock;\n      currentBlock[2] = (uint)&DAT_20000454;\n      currentBlock[3] = (uint)&DAT_20000454;\n      currentBlock[1] = blockSize | 1;\n      *(uint *)((int)currentBlock + blockSize) = blockSize;\n      goto LAB_080089f0;\n    }\n    blockHeaderSize = nextBlock[3];\n    tempBlock[3] = blockHeaderSize;\n    *(undefined4 **)(blockHeaderSize + 8) = tempBlock;\n    currentBlock[1] = blockSize | 1;\n    *(uint *)((int)currentBlock + blockSize) = blockSize;\n  }\n  else {\n    currentBlock[1] = blockSize | 1;\n    *(uint *)((int)currentBlock + blockSize) = blockSize;\n  }\n  if (blockSize < 0x200) {\n    blockIndex = (blockSize >> 3) + 1;\n    blockSize = 1 << ((int)(blockSize >> 3) >> 2 & 0xffU) | (uint)DAT_20000450;\n    blockHeaderSize = *(uint *)(&DAT_2000044c + blockIndex * 8);\n    currentBlock[2] = blockHeaderSize;\n    currentBlock[3] = (uint)(&DAT_20000444 + blockIndex * 8);\n    DAT_20000450 = (undefined *)blockSize;\n    *(uint **)(&DAT_2000044c + blockIndex * 8) = currentBlock;\n    *(uint **)(blockHeaderSize + 0xc) = currentBlock;\n    FUN_080090b4(param_1,currentBlock,blockSize,param_4);\n    return;\n  }\n  blockHeaderSize = blockSize >> 9;\n  if (blockHeaderSize < 5) {\n    blockIndex = ((blockSize >> 6) + 0x39) * 8;\n    index = (blockSize >> 6) + 0x38;\n  }\n  else if (blockHeaderSize < 0x15) {\n    blockIndex = (blockHeaderSize + 0x5c) * 8;\n    index = blockHeaderSize + 0x5b;\n  }\n  else if (blockHeaderSize < 0x55) {\n    blockIndex = ((blockSize >> 0xc) + 0x6f) * 8;\n    index = (blockSize >> 0xc) + 0x6e;\n  }\n  else if (blockHeaderSize < 0x155) {\n    blockIndex = ((blockSize >> 0xf) + 0x78) * 8;\n    index = (blockSize >> 0xf) + 0x77;\n  }\n  else if (blockHeaderSize < 0x555) {\n    blockIndex = ((blockSize >> 0x12) + 0x7d) * 8;\n    index = (blockSize >> 0x12) + 0x7c;\n  }\n  else {\n    blockIndex = 0x3f8;\n    index = 0x7e;\n  }\n  previousBlock = *(undefined **)(&DAT_2000044c + blockIndex);\n  headerAddress = &DAT_20000444 + blockIndex;\n  if (headerAddress == previousBlock) {\n    previousBlock = (undefined *)(1 << (index >> 2 & 0xffU) | (uint)DAT_20000450);\n    footerAddress = headerAddress;\n    DAT_20000450 = previousBlock;\n  }\n  else {\n    do {\n      footerAddress = previousBlock;\n      if ((*(uint *)(previousBlock + 4) & 0xfffffffc) <= blockSize) break;\n      previousBlock = *(undefined **)(previousBlock + 8);\n      footerAddress = headerAddress;\n    } while (headerAddress != previousBlock);\n    headerAddress = *(undefined **)(footerAddress + 0xc);\n  }\n  currentBlock[2] = (uint)footerAddress;\n  currentBlock[3] = (uint)headerAddress;\n  *(uint **)(headerAddress + 8) = currentBlock;\n  *(uint **)(footerAddress + 0xc) = currentBlock;\n  FUN_080090b4(param_1,currentBlock,previousBlock,param_4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080088ec": "deallocate_memory_block_080088ec",
                "param_2": "memoryBlock",
                "iVar1": "index",
                "puVar2": "currentBlock",
                "puVar3": "nextBlock",
                "puVar4": "previousBlock",
                "uVar5": "blockSize",
                "uVar6": "blockHeaderSize",
                "puVar7": "headerAddress",
                "puVar8": "footerAddress",
                "puVar9": "tempBlock",
                "iVar10": "blockIndex",
                "uVar11": "previousBlockStatus",
                "uVar12": "nextBlockFooterValue"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080097cc",
                "FUN_08009adc",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_0800884c",
                "FUN_080090b4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ad4": {
            "entrypoint": "0x08008ad4",
            "current_name": "get_modified_value_08008ad4",
            "code": "\nint getModifiedValue_08008ad4(void)\n\n{\n  int value;\n  \n  value = *(int *)(DAT_2000001c + 0x34);\n  if (value == 0) {\n    value = 0x2000085c;\n  }\n  return value + 0xf0;\n}\n\n",
            "renaming": {
                "FUN_08008ad4": "get_modified_value_08008ad4",
                "iVar1": "value"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008af0": {
            "entrypoint": "0x08008af0",
            "current_name": "FUNC_08008af0",
            "code": "\nvoid FUNC_08008af0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af0": "FUNC_08008af0"
            },
            "calling": [
                "FUN_080090a8",
                "FUN_080098c0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af4": {
            "entrypoint": "0x08008af4",
            "current_name": "FUNC_08008af4",
            "code": "\nvoid FUNC_08008af4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af4": "FUNC_08008af4"
            },
            "calling": [
                "FUN_080090b4",
                "FUN_080098c0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af8": {
            "entrypoint": "0x08008af8",
            "current_name": "allocate_memory_08008af8",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocate_memory_08008af8(undefined4 *result_ptr,uint size)\n\n{\n  undefined *ptr1;\n  uint temp1;\n  uint temp2;\n  int index;\n  undefined *ptr2;\n  uint counter1;\n  uint counter2;\n  undefined4 *temp_ptr1;\n  undefined *temp_ptr2;\n  undefined *ptr3;\n  int *result;\n  uint adjusted_size;\n  uint aligned_size;\n  int index2;\n  undefined4 *metadata_ptr1;\n  undefined4 *metadata_ptr2;\n  \n  adjusted_size = size + 0xb;\n  if (adjusted_size < 0x17) {\n    if (0x10 < size) goto LAB_08008c7a;\n    FUN_080090a8();\n    aligned_size = 0x10;\n    index = 0x18;\n    adjusted_size = 2;\nLAB_08008b18:\n    ptr3 = *(undefined **)((int)&DAT_20000450 + index);\n    if ((ptr3 != &DAT_20000444 + index) ||\n       (ptr3 = *(undefined **)((int)&DAT_20000458 + index), &DAT_2000044c + index != ptr3)) {\n      index = *(int *)(ptr3 + 0xc);\n      ptr2 = ptr3 + (*(uint *)(ptr3 + 4) & 0xfffffffc);\n      adjusted_size = *(uint *)(ptr2 + 4);\nLAB_08008b34:\n      index2 = *(int *)(ptr3 + 8);\n      *(int *)(index2 + 0xc) = index;\n      *(int *)(index + 8) = index2;\n      *(uint *)(ptr2 + 4) = adjusted_size | 1;\n      FUN_080090b4(result_ptr);\n      return (int *)(ptr3 + 8);\n    }\n    adjusted_size = adjusted_size + 2;\n  }\n  else {\n    aligned_size = adjusted_size & 0xfffffff8;\n    if (((int)aligned_size < 0) || (aligned_size < size)) {\nLAB_08008c7a:\n      *result_ptr = 0xc;\n      return (int *)0x0;\n    }\n    FUN_080090a8();\n    if (aligned_size < 0x1f8) {\n      adjusted_size = adjusted_size >> 3;\n      index = aligned_size + 8;\n      goto LAB_08008b18;\n    }\n    temp1 = adjusted_size >> 9;\n    if (temp1 == 0) {\n      index = 0x200;\n      counter1 = 0x40;\n      temp1 = 0x3f;\n    }\n    else if (temp1 < 5) {\n      counter1 = (adjusted_size >> 6) + 0x39;\n      temp1 = (adjusted_size >> 6) + 0x38;\n      index = counter1 * 8;\n    }\n    else if (temp1 < 0x15) {\n      counter1 = temp1 + 0x5c;\n      temp1 = temp1 + 0x5b;\n      index = counter1 * 8;\n    }\n    else if (temp1 < 0x55) {\n      counter1 = (adjusted_size >> 0xc) + 0x6f;\n      temp1 = (adjusted_size >> 0xc) + 0x6e;\n      index = counter1 * 8;\n    }\n    else if (temp1 < 0x155) {\n      counter1 = (adjusted_size >> 0xf) + 0x78;\n      temp1 = (adjusted_size >> 0xf) + 0x77;\n      index = counter1 * 8;\n    }\n    else if (temp1 < 0x555) {\n      counter1 = (adjusted_size >> 0x12) + 0x7d;\n      temp1 = (adjusted_size >> 0x12) + 0x7c;\n      index = counter1 * 8;\n    }\n    else {\n      index = 0x3f8;\n      counter1 = 0x7f;\n      temp1 = 0x7e;\n    }\n    for (ptr3 = *(undefined **)((int)&DAT_20000450 + index); adjusted_size = counter1,\n        &DAT_20000444 + index != ptr3; ptr3 = *(undefined **)(ptr3 + 0xc)) {\n      index2 = (*(uint *)(ptr3 + 4) & 0xfffffffc) - aligned_size;\n      adjusted_size = temp1;\n      if (0xf < index2) break;\n      if (-1 < index2) {\n        ptr2 = ptr3 + (*(uint *)(ptr3 + 4) & 0xfffffffc);\n        adjusted_size = *(uint *)(ptr2 + 4);\n        index = *(int *)(ptr3 + 0xc);\n        goto LAB_08008b34;\n      }\n    }\n  }\n  metadata_ptr1 = DAT_2000045c;\n  if ((undefined **)DAT_2000045c == &DAT_20000454) {\n    counter1 = 1 << ((int)adjusted_size >> 2 & 0xffU);\n    temp1 = DAT_20000450;\n    if (counter1 <= DAT_20000450) goto LAB_08008c06;\n  }\n  else {\n    counter1 = DAT_2000045c[1];\n    counter2 = counter1 & 0xfffffffc;\n    temp1 = counter2 - aligned_size;\n    if (0xf < (int)temp1) {\n      metadata_ptr2 = (undefined4 *)(aligned_size + (int)DAT_2000045c);\n      DAT_2000045c[1] = aligned_size | 1;\n      DAT_2000045c = metadata_ptr2;\n      DAT_20000460 = metadata_ptr2;\n      metadata_ptr2[2] = &DAT_20000454;\n      metadata_ptr2[3] = &DAT_20000454;\n      metadata_ptr2[1] = temp1 | 1;\n      *(uint *)((int)metadata_ptr1 + counter2) = temp1;\n      FUN_080090b4(result_ptr);\n      return metadata_ptr1 + 2;\n    }\n    DAT_2000045c = &DAT_20000454;\n    DAT_20000460 = &DAT_20000454;\n    if (-1 < (int)temp1) {\n      *(uint *)((int)metadata_ptr1 + counter2 + 4) = *(uint *)((int)metadata_ptr1 + counter2 + 4) | 1;\n      FUN_080090b4(result_ptr);\n      return metadata_ptr1 + 2;\n    }\n    if (counter2 < 0x200) {\n      index = (counter1 >> 3) + 1;\n      index2 = *(int *)(&DAT_2000044c + index * 8);\n      temp1 = 1 << ((int)(counter1 >> 3) >> 2 & 0xffU) | DAT_20000450;\n      metadata_ptr1[2] = index2;\n      metadata_ptr1[3] = &DAT_20000444 + index * 8;\n      DAT_20000450 = temp1;\n      *(undefined4 **)(&DAT_2000044c + index * 8) = metadata_ptr1;\n      *(undefined4 **)(index2 + 0xc) = metadata_ptr1;\n    }\n    else {\n      temp1 = counter1 >> 9;\n      if (temp1 < 5) {\n        index = ((counter1 >> 6) + 0x39) * 8;\n        index2 = (counter1 >> 6) + 0x38;\n      }\n      else if (temp1 < 0x15) {\n        index = (temp1 + 0x5c) * 8;\n        index2 = temp1 + 0x5b;\n      }\n      else if (temp1 < 0x55) {\n        index = ((counter1 >> 0xc) + 0x6f) * 8;\n        index2 = (counter1 >> 0xc) + 0x6e;\n      }\n      else if (temp1 < 0x155) {\n        index = ((counter1 >> 0xf) + 0x78) * 8;\n        index2 = (counter1 >> 0xf) + 0x77;\n      }\n      else if (temp1 < 0x555) {\n        index = ((counter1 >> 0x12) + 0x7d) * 8;\n        index2 = (counter1 >> 0x12) + 0x7c;\n      }\n      else {\n        index = 0x3f8;\n        index2 = 0x7e;\n      }\n      ptr3 = *(undefined **)(&DAT_2000044c + index);\n      ptr2 = &DAT_20000444 + index;\n      if (ptr2 == ptr3) {\n        DAT_20000450 = 1 << (index2 >> 2 & 0xffU) | DAT_20000450;\n      }\n      else {\n        do {\n          if ((*(uint *)(ptr3 + 4) & 0xfffffffc) <= counter2) break;\n          ptr3 = *(undefined **)(ptr3 + 8);\n        } while (ptr2 != ptr3);\n        ptr2 = *(undefined **)(ptr3 + 0xc);\n      }\n      temp1 = DAT_20000450;\n      metadata_ptr1[2] = ptr3;\n      metadata_ptr1[3] = ptr2;\n      *(undefined4 **)(ptr2 + 8) = metadata_ptr1;\n      *(undefined4 **)(ptr3 + 0xc) = metadata_ptr1;\n    }\n    counter1 = 1 << ((int)adjusted_size >> 2 & 0xffU);\n    if (counter1 <= temp1) {\nLAB_08008c06:\n      if ((counter1 & temp1) == 0) {\n        adjusted_size = adjusted_size & 0xfffffffc;\n        do {\n          counter1 = counter1 << 1;\n          adjusted_size = adjusted_size + 4;\n        } while ((counter1 & temp1) == 0);\n      }\n      do {\n        metadata_ptr2 = (undefined4 *)(&DAT_2000044c + adjusted_size * 8);\n        temp1 = adjusted_size;\n        metadata_ptr1 = metadata_ptr2;\n        do {\n          for (temp_ptr1 = (undefined4 *)metadata_ptr1[3]; metadata_ptr1 != temp_ptr1;\n              temp_ptr1 = (undefined4 *)temp_ptr1[3]) {\n            counter2 = temp_ptr1[1] & 0xfffffffc;\n            temp2 = counter2 - aligned_size;\n            if (0xf < (int)temp2) {\n              index2 = temp_ptr1[2];\n              index = temp_ptr1[3];\n              metadata_ptr1 = (undefined4 *)(aligned_size + (int)temp_ptr1);\n              temp_ptr1[1] = aligned_size | 1;\n              *(int *)(index2 + 0xc) = index;\n              *(int *)(index + 8) = index2;\n              DAT_2000045c = metadata_ptr1;\n              DAT_20000460 = metadata_ptr1;\n              metadata_ptr1[2] = &DAT_20000454;\n              metadata_ptr1[3] = &DAT_20000454;\n              metadata_ptr1[1] = temp2 | 1;\n              *(uint *)((int)temp_ptr1 + counter2) = temp2;\n              FUN_080090b4(result_ptr);\n              return temp_ptr1 + 2;\n            }\n            if (-1 < (int)temp2) {\n              index = temp_ptr1[3];\n              index2 = temp_ptr1[2];\n              *(uint *)((int)temp_ptr1 + counter2 + 4) = *(uint *)((int)temp_ptr1 + counter2 + 4) | 1;\n              *(int *)(index2 + 0xc) = index;\n              *(int *)(index + 8) = index2;\n              FUN_080090b4(result_ptr);\n              return temp_ptr1 + 2;\n            }\n          }\n          temp1 = temp1 + 1;\n          metadata_ptr1 = metadata_ptr1 + 2;\n        } while ((temp1 & 3) != 0);\n        do {\n          counter2 = adjusted_size & 3;\n          metadata_ptr1 = metadata_ptr2 + -2;\n          adjusted_size = adjusted_size - 1;\n          if (counter2 == 0) {\n            DAT_20000450 = DAT_20000450 & ~counter1;\n            break;\n          }\n          metadata_ptr2 = (undefined4 *)*metadata_ptr2;\n        } while (metadata_ptr2 == metadata_ptr1);\n        counter1 = counter1 * 2;\n        if ((DAT_20000450 <= counter1 && counter1 - DAT_20000450 != 0) || (adjusted_size = temp1, counter1 == 0))\n        break;\n        for (; (counter1 & DAT_20000450) == 0; counter1 = counter1 << 1) {\n          adjusted_size = adjusted_size + 4;\n        }\n      } while( true );\n    }\n  }\n  ptr3 = DAT_20000454;\n  adjusted_size = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  if ((aligned_size <= adjusted_size) && (temp1 = adjusted_size - aligned_size, 0xf < (int)temp1)) goto LAB_08008dac;\n  if (DAT_20000854 == (undefined *)0xffffffff) {\n    temp1 = aligned_size + DAT_20000a44 + 0x10;\n  }\n  else {\n    temp1 = aligned_size + DAT_20000a44 + 0x100f & 0xfffff000;\n  }\n  ptr2 = (undefined *)FUN_08009744(result_ptr,temp1);\n  if (ptr2 == (undefined *)0xffffffff) {\nLAB_08008ed8:\n    adjusted_size = *(uint *)(DAT_20000454 + 4);\n  }\n  else {\n    ptr1 = ptr3 + adjusted_size;\n    if (ptr1 < ptr2 || ptr1 == ptr2) {\n      temp_ptr2 = DAT_20000a14 + temp1;\n      if ((ptr1 != ptr2) || (((uint)ptr1 & 0xfff) != 0)) goto LAB_08008d02;\n      DAT_20000a14 = temp_ptr2;\n      *(uint *)(DAT_20000454 + 4) = adjusted_size + temp1 | 1;\n    }\n    else {\n      if (ptr3 != &DAT_2000044c) goto LAB_08008ed8;\nLAB_08008d02:\n      DAT_20000a14 = DAT_20000a14 + temp1;\n      temp_ptr2 = ptr2;\n      if (DAT_20000854 != (undefined *)0xffffffff) {\n        DAT_20000a14 = DAT_20000a14 + ((int)ptr2 - (int)ptr1);\n        temp_ptr2 = DAT_20000854;\n      }\n      DAT_20000854 = temp_ptr2;\n      counter1 = (uint)ptr2 & 7;\n      if (counter1 == 0) {\n        index = 0x1000;\n      }\n      else {\n        ptr2 = ptr2 + (8 - counter1);\n        index = 0x1008 - counter1;\n      }\n      index = index - ((uint)(ptr2 + temp1) & 0xfff);\n      index2 = FUN_08009744(result_ptr,index);\n      if (index2 == -1) {\n        temp1 = 1;\n        index = 0;\n      }\n      else {\n        temp1 = (index2 - (int)ptr2) + index | 1;\n      }\n      temp_ptr2 = DAT_20000a14 + index;\n      DAT_20000454 = ptr2;\n      DAT_20000a14 = temp_ptr2;\n      *(uint *)(ptr2 + 4) = temp1;\n      if (ptr3 != &DAT_2000044c) {\n        if (adjusted_size < 0x10) {\n          *(undefined4 *)(ptr2 + 4) = 1;\n          goto LAB_08008eee;\n        }\n        adjusted_size = adjusted_size - 0xc & 0xfffffff8;\n        *(uint *)(ptr3 + 4) = *(uint *)(ptr3 + 4) & 1 | adjusted_size;\n        *(undefined4 *)(ptr3 + adjusted_size + 4) = 5;\n        *(undefined4 *)(ptr3 + adjusted_size + 8) = 5;\n        if (0xf < adjusted_size) {\n          FUN_080088ec(result_ptr,ptr3 + 8);\n          temp_ptr2 = DAT_20000a14;\n        }\n      }\n    }\n    if (DAT_20000a3c < temp_ptr2) {\n      DAT_20000a3c = temp_ptr2;\n    }\n    adjusted_size = *(uint *)(DAT_20000454 + 4);\n    if (DAT_20000a40 < temp_ptr2) {\n      DAT_20000a40 = temp_ptr2;\n    }\n  }\n  temp1 = (adjusted_size & 0xfffffffc) - aligned_size;\n  if ((aligned_size <= (adjusted_size & 0xfffffffc)) && (0xf < (int)temp1)) {\nLAB_08008dac:\n    ptr3 = DAT_20000454 + aligned_size;\n    *(uint *)(DAT_20000454 + 4) = aligned_size | 1;\n    result = (int *)(DAT_20000454 + 8);\n    DAT_20000454 = ptr3;\n    *(uint *)(ptr3 + 4) = temp1 | 1;\n    FUN_080090b4(result_ptr);\n    return result;\n  }\nLAB_08008eee:\n  FUN_080090b4(result_ptr);\n  return (int *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08008af8": "allocate_memory_08008af8",
                "param_1": "result_ptr",
                "param_2": "size",
                "puVar1": "ptr1",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "iVar4": "index",
                "puVar5": "ptr2",
                "uVar6": "counter1",
                "uVar7": "counter2",
                "puVar8": "temp_ptr1",
                "puVar9": "temp_ptr2",
                "puVar10": "ptr3",
                "piVar11": "result",
                "uVar12": "adjusted_size",
                "uVar13": "aligned_size",
                "iVar14": "index2",
                "puVar15": "metadata_ptr1",
                "puVar16": "metadata_ptr2"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080097cc",
                "FUN_08009adc",
                "FUN_08009980"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_080090b4",
                "FUN_080088ec",
                "FUN_08009744"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800901c": {
            "entrypoint": "0x0800901c",
            "current_name": "find_target_value_0800901c",
            "code": "\nuint * find_target_value_0800901c(uint *input_array,uint search_value,uint array_length)\n\n{\n  uint temp;\n  uint combined_value;\n  uint *current_element;\n  uint final_search_value;\n  bool is_array_empty;\n  \n  final_search_value = search_value & 0xff;\n  if (((uint)input_array & 3) == 0) {\nLAB_0800904a:\n    if (3 < array_length) {\n      combined_value = (search_value & 0xff) << 8 | final_search_value;\n      current_element = input_array;\n      do {\n        temp = *current_element ^ (combined_value | combined_value << 0x10);\n        input_array = current_element + 1;\n        if ((temp + 0xfefefeff & ~temp & 0x80808080) != 0) goto LAB_08009050;\n        array_length = array_length - 4;\n        current_element = input_array;\n      } while (3 < array_length);\n    }\n    current_element = input_array;\n    if (array_length == 0) {\n      input_array = (uint *)0x0;\n    }\n    else {\nLAB_08009050:\n      input_array = current_element;\n      if (*(byte *)input_array != final_search_value) {\n        current_element = (uint *)(array_length + (int)input_array);\n        do {\n          input_array = (uint *)((int)input_array + 1);\n          if (current_element == input_array) goto LAB_0800906c;\n        } while (*(byte *)input_array != final_search_value);\n      }\n    }\n  }\n  else {\n    combined_value = array_length - 1;\n    if (array_length == 0) {\nLAB_0800906c:\n      input_array = (uint *)0x0;\n    }\n    else if (*(byte *)input_array != final_search_value) {\n      current_element = (uint *)((int)input_array + 1);\n      do {\n        input_array = current_element;\n        array_length = combined_value;\n        if (((uint)input_array & 3) == 0) goto LAB_0800904a;\n        is_array_empty = combined_value == 0;\n        combined_value = combined_value - 1;\n        if (is_array_empty) goto LAB_0800906c;\n        current_element = (uint *)((int)input_array + 1);\n      } while (*(byte *)input_array != final_search_value);\n    }\n  }\n  return input_array;\n}\n\n",
            "renaming": {
                "FUN_0800901c": "find_target_value_0800901c",
                "param_1": "input_array",
                "param_2": "search_value",
                "param_3": "array_length",
                "uVar1": "temp",
                "uVar2": "combined_value",
                "puVar3": "current_element",
                "uVar4": "final_search_value",
                "bVar5": "is_array_empty"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090a8": {
            "entrypoint": "0x080090a8",
            "current_name": "initialize_data_080090a8",
            "code": "\nvoid initializeData_080090a8(void)\n\n{\n  FUNC_08008af0(&DAT_20000bfc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090a8": "initialize_data_080090a8"
            },
            "calling": [
                "FUN_0800884c",
                "FUN_080088ec",
                "FUN_08009adc",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_08008af0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090b4": {
            "entrypoint": "0x080090b4",
            "current_name": "initialize_data_080090b4",
            "code": "\nvoid initialize_data_080090b4(void)\n\n{\n  FUNC_08008af4(&DAT_20000bfc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090b4": "initialize_data_080090b4"
            },
            "calling": [
                "FUN_0800884c",
                "FUN_080088ec",
                "FUN_08009adc",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_08008af4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090c0": {
            "entrypoint": "0x080090c0",
            "current_name": "find_or_create_entry_080090c0",
            "code": "\nundefined4 * findOrCreateEntry_080090c0(int entryPtr,uint index)\n\n{\n  undefined4 *entry;\n  int entryIndex;\n  \n  entryIndex = *(int *)(entryPtr + 0x4c);\n  if (entryIndex == 0) {\n    entryIndex = FUN_08009980(entryPtr,4,0x21);\n    *(int *)(entryPtr + 0x4c) = entryIndex;\n    if (entryIndex == 0) {\n      return (undefined4 *)0x0;\n    }\n  }\n  entry = *(undefined4 **)(entryIndex + index * 4);\n  if (entry == (undefined4 *)0x0) {\n    entryIndex = 1 << (index & 0xff);\n    entry = (undefined4 *)FUN_08009980(entryPtr,1,(entryIndex + 5) * 4);\n    if (entry == (undefined4 *)0x0) {\n      return (undefined4 *)0x0;\n    }\n    entry[1] = index;\n    entry[2] = entryIndex;\n  }\n  else {\n    *(undefined4 *)(entryIndex + index * 4) = *entry;\n  }\n  entry[3] = 0;\n  entry[4] = 0;\n  return entry;\n}\n\n",
            "renaming": {
                "FUN_080090c0": "find_or_create_entry_080090c0",
                "param_1": "entryPtr",
                "param_2": "index",
                "puVar1": "entry",
                "iVar2": "entryIndex"
            },
            "calling": [
                "FUN_08009444",
                "FUN_08009258",
                "FUN_080079e8",
                "FUN_08009244",
                "FUN_08009530",
                "FUN_080093a4",
                "FUN_08009120",
                "FUN_08009630"
            ],
            "called": [
                "FUN_08009980"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800910c": {
            "entrypoint": "0x0800910c",
            "current_name": "update_and_store_value_0800910c",
            "code": "\nvoid updateAndStoreValue_0800910c(int dataOffset,undefined4 *resultAddress)\n\n{\n  int dataPtr;\n  \n  if (resultAddress != (undefined4 *)0x0) {\n    dataPtr = *(int *)(dataOffset + 0x4c);\n    *resultAddress = *(undefined4 *)(dataPtr + resultAddress[1] * 4);\n    *(undefined4 **)(dataPtr + resultAddress[1] * 4) = resultAddress;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800910c": "update_and_store_value_0800910c",
                "param_1": "dataOffset",
                "param_2": "resultAddress",
                "iVar1": "dataPtr"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009120": {
            "entrypoint": "0x08009120",
            "current_name": "reverse_and_update_08009120",
            "code": "\nundefined4 * reverse_and_update_08009120(int input_size,undefined4 *array,int multiplier,uint carry)\n\n{\n  undefined4 *updated_array;\n  uint carry_extended;\n  int array_size;\n  uint *current_element;\n  int counter;\n  \n  counter = 0;\n  array_size = array[4];\n  current_element = array + 5;\n  do {\n    counter = counter + 1;\n    carry = multiplier * (*current_element & 0xffff) + carry;\n    carry_extended = multiplier * (*current_element >> 0x10) + (carry >> 0x10);\n    *current_element = (carry & 0xffff) + carry_extended * 0x10000;\n    carry = carry_extended >> 0x10;\n    current_element = current_element + 1;\n  } while (counter < array_size);\n  updated_array = array;\n  if (carry != 0) {\n    if ((int)array[2] <= array_size) {\n      updated_array = (undefined4 *)FUN_080090c0(input_size,array[1] + 1);\n      FUN_08001084(updated_array + 3,array + 3,(array[4] + 2) * 4);\n      counter = *(int *)(input_size + 0x4c);\n      *array = *(undefined4 *)(counter + array[1] * 4);\n      *(undefined4 **)(counter + array[1] * 4) = array;\n    }\n    updated_array[array_size + 5] = carry;\n    updated_array[4] = array_size + 1;\n  }\n  return updated_array;\n}\n\n",
            "renaming": {
                "FUN_08009120": "reverse_and_update_08009120",
                "param_1": "input_size",
                "param_2": "array",
                "param_3": "multiplier",
                "param_4": "carry",
                "puVar1": "updated_array",
                "uVar2": "carry_extended",
                "iVar3": "array_size",
                "puVar4": "current_element",
                "iVar5": "counter"
            },
            "calling": [
                "FUN_080079e8",
                "FUN_080093a4"
            ],
            "called": [
                "FUN_08001084",
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091a4": {
            "entrypoint": "0x080091a4",
            "current_name": "count_leading_zeros_080091a4",
            "code": "\nint countLeadingZeros_080091a4(uint input)\n\n{\n  int leadingZeros;\n  \n  if ((input & 0xffff0000) == 0) {\n    input = input << 0x10;\n    leadingZeros = 0x10;\n  }\n  else {\n    leadingZeros = 0;\n  }\n  if ((input & 0xff000000) == 0) {\n    input = input << 8;\n    leadingZeros = leadingZeros + 8;\n  }\n  if ((input & 0xf0000000) == 0) {\n    input = input << 4;\n    leadingZeros = leadingZeros + 4;\n  }\n  if ((input & 0xc0000000) == 0) {\n    input = input << 2;\n    leadingZeros = leadingZeros + 2;\n  }\n  if (-1 < (int)input) {\n    if ((int)(input << 1) < 0) {\n      return leadingZeros + 1;\n    }\n    leadingZeros = 0x20;\n  }\n  return leadingZeros;\n}\n\n",
            "renaming": {
                "FUN_080091a4": "count_leading_zeros_080091a4",
                "param_1": "input",
                "iVar1": "leadingZeros"
            },
            "calling": [
                "FUN_080079e8",
                "FUN_08009630"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091e4": {
            "entrypoint": "0x080091e4",
            "current_name": "find_leading_zeros_080091e4",
            "code": "\nint findLeadingZeros_080091e4(uint *num)\n\n{\n  int leadingZeros;\n  uint value;\n  \n  value = *num;\n  if ((value & 7) == 0) {\n    if ((value & 0xffff) == 0) {\n      value = value >> 0x10;\n      leadingZeros = 0x10;\n    }\n    else {\n      leadingZeros = 0;\n    }\n    if ((value & 0xff) == 0) {\n      value = value >> 8;\n      leadingZeros = leadingZeros + 8;\n    }\n    if ((value & 0xf) == 0) {\n      value = value >> 4;\n      leadingZeros = leadingZeros + 4;\n    }\n    if ((value & 3) == 0) {\n      value = value >> 2;\n      leadingZeros = leadingZeros + 2;\n    }\n    if (-1 < (int)(value << 0x1f)) {\n      value = value >> 1;\n      if (value == 0) {\n        return 0x20;\n      }\n      leadingZeros = leadingZeros + 1;\n    }\n    *num = value;\n    return leadingZeros;\n  }\n  if ((int)(value << 0x1f) < 0) {\n    return 0;\n  }\n  if (-1 < (int)(value << 0x1e)) {\n    *num = value >> 2;\n    return 2;\n  }\n  *num = value >> 1;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080091e4": "find_leading_zeros_080091e4",
                "param_1": "num",
                "iVar1": "leadingZeros",
                "uVar2": "value"
            },
            "calling": [
                "FUN_08009630"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009244": {
            "entrypoint": "0x08009244",
            "current_name": "initialize_data_08009244",
            "code": "\nvoid initializeData_08009244(undefined4 input1,undefined4 input2)\n\n{\n  int result;\n  \n  result = FUN_080090c0(input1,1);\n  *(undefined4 *)(result + 0x10) = 1;\n  *(undefined4 *)(result + 0x14) = input2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009244": "initialize_data_08009244",
                "param_1": "input1",
                "param_2": "input2",
                "iVar1": "result"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009258": {
            "entrypoint": "0x08009258",
            "current_name": "initialize_matrix_08009258",
            "code": "\nvoid initializeMatrix_08009258(undefined4 param1,int array1,int array2)\n\n{\n  uint *ptr1;\n  uint *ptr2;\n  int array1Length;\n  uint tempVar1;\n  uint *array1Pointer;\n  uint tempVar2;\n  uint *ptr3;\n  uint uVar8;\n  int array2Length;\n  int tempVar3;\n  uint tempVar4;\n  int tempVar5;\n  int tempVar6;\n  uint *ptr4;\n  uint *ptr5;\n  uint *ptr6;\n  uint *ptr7;\n  uint *ptr8;\n  \n  tempVar5 = *(int *)(array1 + 0x10);\n  array2Length = *(int *)(array2 + 0x10);\n  tempVar3 = array2Length;\n  tempVar6 = array1;\n  if (tempVar5 < array2Length) {\n    tempVar3 = tempVar5;\n    tempVar5 = array2Length;\n    tempVar6 = array2;\n    array2 = array1;\n  }\n  array2Length = tempVar5 + tempVar3;\n  array1Length = *(int *)(tempVar6 + 4);\n  if (*(int *)(tempVar6 + 8) < array2Length) {\n    array1Length = array1Length + 1;\n  }\n  array1Length = FUN_080090c0(param1,array1Length);\n  ptr8 = (uint *)(array1Length + 0x14);\n  ptr7 = ptr8 + array2Length;\n  for (array1Pointer = ptr8; array1Pointer < ptr7; array1Pointer = array1Pointer + 1) {\n    *array1Pointer = 0;\n  }\n  tempVar2 = array2 + 0x14;\n  tempVar4 = tempVar2 + tempVar3 * 4;\n  array1Pointer = (uint *)(tempVar6 + 0x14);\n  if (tempVar2 < tempVar4) {\n    ptr3 = (uint *)(tempVar2 + ((tempVar4 - array2) - 0x15 & 0xfffffffc));\n    ptr6 = (uint *)(array2 + 0x10);\n    do {\n      while( true ) {\n        ptr6 = ptr6 + 1;\n        tempVar2 = *ptr6 & 0xffff;\n        if (tempVar2 != 0) break;\n        tempVar2 = *ptr6 >> 0x10;\n        if (tempVar2 == 0) goto LAB_080092d2;\nLAB_0800932c:\n        uVar8 = *ptr8;\n        tempVar1 = 0;\n        ptr1 = array1Pointer;\n        ptr4 = ptr8;\n        tempVar4 = uVar8;\n        do {\n          ptr5 = ptr4;\n          tempVar1 = tempVar1 + tempVar2 * *(ushort *)ptr1 + (tempVar4 >> 0x10);\n          *ptr5 = uVar8 & 0xffff | tempVar1 * 0x10000;\n          ptr2 = ptr1 + 1;\n          tempVar4 = ptr5[1];\n          uVar8 = tempVar2 * (*ptr1 >> 0x10) + (tempVar4 & 0xffff) + (tempVar1 >> 0x10);\n          tempVar1 = uVar8 >> 0x10;\n          ptr1 = ptr2;\n          ptr4 = ptr5 + 1;\n        } while (ptr2 < array1Pointer + tempVar5);\n        ptr5[1] = uVar8;\n        ptr8 = ptr8 + 1;\n        if (ptr3 == ptr6) goto LAB_0800937a;\n      }\n      tempVar4 = 0;\n      ptr1 = ptr8;\n      ptr4 = array1Pointer;\n      do {\n        ptr2 = ptr1;\n        ptr5 = ptr4 + 1;\n        uVar8 = tempVar2 * (*ptr4 & 0xffff) + (*ptr2 & 0xffff) + tempVar4;\n        tempVar1 = tempVar2 * (*ptr4 >> 0x10) + (*ptr2 >> 0x10) + (uVar8 >> 0x10);\n        tempVar4 = tempVar1 >> 0x10;\n        *ptr2 = uVar8 & 0xffff | tempVar1 * 0x10000;\n        ptr1 = ptr2 + 1;\n        ptr4 = ptr5;\n      } while (ptr5 < array1Pointer + tempVar5);\n      ptr2[1] = tempVar4;\n      tempVar2 = *ptr6 >> 0x10;\n      if (tempVar2 != 0) goto LAB_0800932c;\nLAB_080092d2:\n      ptr8 = ptr8 + 1;\n    } while (ptr3 != ptr6);\n  }\nLAB_0800937a:\n  if (0 < array2Length) {\n    tempVar2 = ptr7[-1];\n    ptr7 = ptr7 + -1;\n    while ((tempVar2 == 0 && (array2Length = array2Length + -1, array2Length != 0))) {\n      ptr7 = ptr7 + -1;\n      tempVar2 = *ptr7;\n    }\n  }\n  *(int *)(array1Length + 0x10) = array2Length;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009258": "initialize_matrix_08009258",
                "param_1": "param1",
                "param_2": "array1",
                "param_3": "array2",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "iVar3": "array1Length",
                "uVar4": "tempVar1",
                "puVar5": "array1Pointer",
                "uVar6": "tempVar2",
                "puVar7": "ptr3",
                "puVar14": "ptr4",
                "puVar15": "ptr5",
                "puVar16": "ptr6",
                "puVar17": "ptr7",
                "puVar18": "ptr8",
                "iVar9": "array2Length",
                "iVar10": "tempVar3",
                "uVar11": "tempVar4",
                "iVar12": "tempVar5",
                "iVar13": "tempVar6"
            },
            "calling": [
                "FUN_080079e8",
                "FUN_080093a4"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080093a4": {
            "entrypoint": "0x080093a4",
            "current_name": "process_data_080093a4",
            "code": "\nundefined4 * processData_080093a4(int dataSize,undefined4 *data,uint flags)\n\n{\n  int index;\n  int numIterations;\n  undefined4 *currentData;\n  undefined4 *newData;\n  \n  if ((flags & 3) != 0) {\n    data = (undefined4 *)\n              FUN_08009120(dataSize,data,*(undefined4 *)(&DAT_0800a070 + ((flags & 3) - 1) * 4),\n                           0);\n  }\n  numIterations = (int)flags >> 2;\n  if (numIterations != 0) {\n    newData = *(undefined4 **)(dataSize + 0x48);\n    if (newData == (undefined4 *)0x0) {\n      newData = (undefined4 *)FUN_080090c0(dataSize,1);\n      newData[4] = 1;\n      newData[5] = 0x271;\n      *(undefined4 **)(dataSize + 0x48) = newData;\n      *newData = 0;\n    }\n    currentData = data;\n    if (numIterations << 0x1f < 0) goto LAB_080093d2;\nLAB_080093c4:\n    numIterations = numIterations >> 1;\n    currentData = newData;\n    if (numIterations != 0) {\n      while( true ) {\n        newData = (undefined4 *)*currentData;\n        if (newData == (undefined4 *)0x0) {\n          newData = (undefined4 *)FUN_08009258(dataSize,currentData,currentData);\n          *currentData = newData;\n          *newData = 0;\n        }\n        currentData = data;\n        if (-1 < numIterations << 0x1f) break;\nLAB_080093d2:\n        data = (undefined4 *)FUN_08009258(dataSize,currentData,newData);\n        if (currentData == (undefined4 *)0x0) break;\n        index = *(int *)(dataSize + 0x4c);\n        numIterations = numIterations >> 1;\n        *currentData = *(undefined4 *)(index + currentData[1] * 4);\n        *(undefined4 **)(index + currentData[1] * 4) = currentData;\n        currentData = newData;\n        if (numIterations == 0) {\n          return data;\n        }\n      }\n      goto LAB_080093c4;\n    }\n  }\n  return data;\n}\n\n",
            "renaming": {
                "FUN_080093a4": "process_data_080093a4",
                "param_1": "dataSize",
                "param_2": "data",
                "param_3": "flags",
                "iVar1": "index",
                "iVar2": "numIterations",
                "puVar3": "currentData",
                "puVar4": "newData"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08009258",
                "FUN_080090c0",
                "FUN_08009120"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009444": {
            "entrypoint": "0x08009444",
            "current_name": "transform_data_08009444",
            "code": "\nvoid transformData_08009444(int inputData,undefined4 *outputData,uint dataSize)\n\n{\n  int tempVar1;\n  int tempVar2;\n  int tempVar3;\n  undefined4 tempVar4;\n  int tempVar5;\n  int tempVar6;\n  uint *ptrVar1;\n  uint *ptrVar2;\n  uint *ptrVar4;\n  uint *ptrVar5;\n  int shiftValue;\n  int updatedSize;\n  uint shiftedValue;\n  uint *ptrVar3;\n  \n  tempVar5 = outputData[4];\n  shiftValue = (int)dataSize >> 5;\n  updatedSize = shiftValue + tempVar5 + 1;\n  tempVar3 = outputData[1];\n  tempVar2 = outputData[2];\n  if ((int)outputData[2] < updatedSize) {\n    do {\n      tempVar6 = tempVar2 * 2;\n      tempVar1 = tempVar2 * -2;\n      tempVar3 = tempVar3 + 1;\n      tempVar2 = tempVar6;\n    } while (updatedSize != tempVar6 && updatedSize + tempVar1 < 0 == SBORROW4(updatedSize,tempVar6));\n  }\n  tempVar2 = FUN_080090c0(inputData,tempVar3);\n  ptrVar1 = (uint *)(tempVar2 + 0x14);\n  if (0 < shiftValue) {\n    ptrVar5 = ptrVar1 + shiftValue;\n    ptrVar2 = ptrVar1;\n    do {\n      ptrVar3 = ptrVar2 + 1;\n      *ptrVar2 = 0;\n      ptrVar1 = ptrVar5;\n      ptrVar2 = ptrVar3;\n    } while (ptrVar3 != ptrVar5);\n  }\n  tempVar3 = outputData[4];\n  ptrVar2 = outputData + 5;\n  dataSize = dataSize & 0x1f;\n  if (dataSize == 0) {\n    ptrVar1 = ptrVar1 + -1;\n    ptrVar5 = ptrVar2;\n    do {\n      ptrVar3 = ptrVar5 + 1;\n      ptrVar1 = ptrVar1 + 1;\n      *ptrVar1 = *ptrVar5;\n      ptrVar5 = ptrVar3;\n    } while (ptrVar3 < ptrVar2 + tempVar3);\n  }\n  else {\n    shiftedValue = 0;\n    ptrVar5 = ptrVar2;\n    do {\n      ptrVar3 = ptrVar1;\n      *ptrVar3 = *ptrVar5 << dataSize | shiftedValue;\n      ptrVar4 = ptrVar5 + 1;\n      shiftedValue = *ptrVar5 >> (0x20 - dataSize & 0xff);\n      ptrVar1 = ptrVar3 + 1;\n      ptrVar5 = ptrVar4;\n    } while (ptrVar4 < ptrVar2 + tempVar3);\n    ptrVar3[1] = shiftedValue;\n    if (shiftedValue != 0) {\n      updatedSize = shiftValue + tempVar5 + 2;\n    }\n  }\n  tempVar5 = *(int *)(inputData + 0x4c);\n  tempVar3 = outputData[1];\n  tempVar4 = *(undefined4 *)(tempVar5 + tempVar3 * 4);\n  *(int *)(tempVar2 + 0x10) = updatedSize + -1;\n  *outputData = tempVar4;\n  *(undefined4 **)(tempVar5 + tempVar3 * 4) = outputData;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009444": "transform_data_08009444",
                "param_1": "inputData",
                "param_2": "outputData",
                "param_3": "dataSize",
                "iVar1": "tempVar1",
                "iVar2": "tempVar2",
                "iVar3": "tempVar3",
                "uVar4": "tempVar4",
                "iVar5": "tempVar5",
                "iVar6": "tempVar6",
                "puVar7": "ptrVar1",
                "puVar8": "ptrVar2",
                "puVar9": "ptrVar3",
                "puVar10": "ptrVar4",
                "puVar11": "ptrVar5",
                "iVar12": "shiftValue",
                "iVar13": "updatedSize",
                "uVar14": "shiftedValue"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080094f8": {
            "entrypoint": "0x080094f8",
            "current_name": "compare_arrays_080094f8",
            "code": "\nint compare_arrays_080094f8(int array1,int array2)\n\n{\n  int difference;\n  uint *ptr_array2;\n  int offset;\n  uint *ptr_array1;\n  \n  offset = *(int *)(array2 + 0x10);\n  difference = *(int *)(array1 + 0x10) - offset;\n  if (difference == 0) {\n    ptr_array2 = (uint *)(array2 + 0x14 + offset * 4);\n    ptr_array1 = (uint *)(array1 + 0x14) + offset;\n    do {\n      ptr_array1 = ptr_array1 + -1;\n      ptr_array2 = ptr_array2 + -1;\n      if (*ptr_array1 != *ptr_array2) {\n        if (*ptr_array2 <= *ptr_array1) {\n          return 1;\n        }\n        return -1;\n      }\n    } while ((uint *)(array1 + 0x14) < ptr_array1);\n  }\n  return difference;\n}\n\n",
            "renaming": {
                "FUN_080094f8": "compare_arrays_080094f8",
                "param_1": "array1",
                "param_2": "array2",
                "iVar1": "difference",
                "puVar2": "ptr_array2",
                "iVar3": "offset",
                "puVar4": "ptr_array1"
            },
            "calling": [
                "FUN_080079e8",
                "FUN_080078c0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009530": {
            "entrypoint": "0x08009530",
            "current_name": "verify_checksum_08009530",
            "code": "\nvoid verifyChecksum_08009530(undefined4 addr,uint *data1,uint *data2,undefined4 param)\n\n{\n  int result;\n  uint *ptr1;\n  uint u1;\n  uint u2;\n  undefined4 flag;\n  uint *ptr2;\n  uint *ptr3;\n  uint *ptr4;\n  uint *ptr5;\n  uint *ptr6;\n  int sum;\n  uint *ptr7;\n  uint len;\n  uint *puVar8;\n  \n  ptr1 = (uint *)data2[4];\n  ptr6 = data1 + 5;\n  ptr7 = data2 + 5;\n  ptr3 = ptr6;\n  ptr4 = data1;\n  if ((uint *)data1[4] == ptr1) {\n    ptr2 = ptr6 + (int)ptr1;\n    ptr1 = ptr7 + (int)ptr1;\n    while( true ) {\n      ptr2 = ptr2 + -1;\n      ptr1 = ptr1 + -1;\n      if (*ptr2 != *ptr1) break;\n      if (ptr2 <= ptr6) {\n        sum = FUN_080090c0(addr,0,ptr2,ptr1,param);\n        *(undefined4 *)(sum + 0x10) = 1;\n        *(undefined4 *)(sum + 0x14) = 0;\n        return;\n      }\n    }\n    flag = 0;\n    if (*ptr1 <= *ptr2) goto LAB_08009578;\n  }\n  else if (-1 < (int)(uint *)data1[4] - (int)ptr1) {\n    flag = 0;\n    ptr2 = data2;\n    goto LAB_08009578;\n  }\n  flag = 1;\n  ptr2 = ptr6;\n  ptr1 = data1;\n  ptr3 = ptr7;\n  ptr4 = data2;\n  data2 = data1;\n  ptr7 = ptr6;\nLAB_08009578:\n  result = FUN_080090c0(addr,ptr4[1],ptr2,ptr1,param);\n  sum = 0;\n  len = ptr4[4];\n  u1 = data2[4];\n  *(undefined4 *)(result + 0xc) = flag;\n  ptr6 = ptr3 + len;\n  ptr1 = (uint *)(result + 0x14);\n  ptr4 = ptr7;\n  do {\n    puVar8 = ptr3 + 1;\n    ptr5 = ptr4 + 1;\n    u2 = ((*ptr3 & 0xffff) + sum) - (*ptr4 & 0xffff);\n    sum = ((*ptr3 >> 0x10) - (*ptr4 >> 0x10)) + ((int)u2 >> 0x10);\n    u2 = u2 & 0xffff | sum * 0x10000;\n    ptr2 = ptr1 + 1;\n    *ptr1 = u2;\n    sum = sum >> 0x10;\n    ptr1 = ptr2;\n    ptr3 = puVar8;\n    ptr4 = ptr5;\n  } while (ptr5 < ptr7 + u1);\n  ptr1 = puVar8;\n  ptr3 = ptr2;\n  if (puVar8 < ptr6) {\n    do {\n      ptr4 = ptr1 + 1;\n      u1 = (*ptr1 & 0xffff) + sum;\n      sum = ((int)u1 >> 0x10) + (*ptr1 >> 0x10);\n      u2 = u1 & 0xffff | sum * 0x10000;\n      *ptr3 = u2;\n      sum = sum >> 0x10;\n      ptr1 = ptr4;\n      ptr3 = ptr3 + 1;\n    } while (ptr4 < ptr6);\n    ptr2 = (uint *)((int)ptr2 + ((int)ptr6 + ~(uint)puVar8 & 0xfffffffc) + 4);\n  }\n  ptr2 = ptr2 + -1;\n  while (u2 == 0) {\n    ptr2 = ptr2 + -1;\n    len = len - 1;\n    u2 = *ptr2;\n  }\n  *(uint *)(result + 0x10) = len;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009530": "verify_checksum_08009530",
                "param_1": "addr",
                "param_2": "data1",
                "param_3": "data2",
                "param_4": "param",
                "iVar1": "result",
                "puVar2": "ptr1",
                "uVar3": "u1",
                "uVar4": "u2",
                "uVar5": "flag",
                "puVar6": "ptr2",
                "puVar7": "ptr3",
                "puVar9": "ptr4",
                "puVar10": "ptr5",
                "puVar11": "ptr6",
                "iVar12": "sum",
                "puVar13": "ptr7",
                "uVar14": "len"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009630": {
            "entrypoint": "0x08009630",
            "current_name": "extract_data_08009630",
            "code": "\nint extractData_08009630(undefined4 input1,undefined4 input2,uint flag1,uint flag2,int *result1,\n                int *result2)\n\n{\n  int result;\n  uint calculatedValue;\n  int tmpVar1;\n  int tmpVar2;\n  uint shiftedValue;\n  uint shiftAmount;\n  undefined8 returnValue;\n  uint localFlagVal1;\n  uint localFlagVal2;\n  \n  result = FUN_080090c0(input1,1);\n  shiftAmount = (flag2 << 1) >> 0x15;\n  localFlagVal2 = flag2 & 0xfffff;\n  if (shiftAmount != 0) {\n    localFlagVal2 = localFlagVal2 | 0x100000;\n  }\n  if (flag1 == 0) {\n    tmpVar1 = FUN_080091e4(&localFlagVal2);\n    tmpVar2 = 1;\n    calculatedValue = tmpVar1 + 0x20;\n    *(undefined4 *)(result + 0x10) = 1;\n    *(uint *)(result + 0x14) = localFlagVal2;\n  }\n  else {\n    localFlagVal1 = flag1;\n    calculatedValue = FUN_080091e4(&localFlagVal1);\n    if (calculatedValue == 0) {\n      *(uint *)(result + 0x14) = localFlagVal1;\n    }\n    else {\n      shiftedValue = localFlagVal2 << (0x20 - calculatedValue & 0xff);\n      localFlagVal2 = localFlagVal2 >> (calculatedValue & 0xff);\n      *(uint *)(result + 0x14) = shiftedValue | localFlagVal1;\n    }\n    if (localFlagVal2 == 0) {\n      tmpVar2 = 1;\n    }\n    else {\n      tmpVar2 = 2;\n    }\n    *(uint *)(result + 0x18) = localFlagVal2;\n    *(int *)(result + 0x10) = tmpVar2;\n  }\n  if (shiftAmount == 0) {\n    *result1 = calculatedValue - 0x432;\n    returnValue = FUN_080091a4(*(undefined4 *)(result + tmpVar2 * 4 + 0x10));\n    *result2 = (int)((ulonglong)returnValue >> 0x20) * 0x20 - (int)returnValue;\n    return result;\n  }\n  *result1 = (shiftAmount - 0x433) + calculatedValue;\n  *result2 = 0x35 - calculatedValue;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009630": "extract_data_08009630",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "flag1",
                "param_4": "flag2",
                "param_5": "result1",
                "param_6": "result2",
                "iVar1": "result",
                "uVar2": "calculatedValue",
                "iVar3": "tmpVar1",
                "iVar4": "tmpVar2",
                "uVar5": "shiftedValue",
                "uVar6": "shiftAmount",
                "uVar7": "returnValue",
                "local_20": "localFlagVal1",
                "local_1c": "localFlagVal2"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080091e4",
                "FUN_080090c0",
                "FUN_080091a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080096e0": {
            "entrypoint": "0x080096e0",
            "current_name": "decode_and_update_080096e0",
            "code": "\nundefined8 decode_and_update_080096e0(uint input_1,uint input_2,int *output_ptr,undefined4 param_4)\n\n{\n  int counter;\n  uint input_2_cleared;\n  undefined8 result;\n  \n  result = CONCAT44(input_2,input_1);\n  counter = 0;\n  input_2_cleared = input_2 & 0x7fffffff;\n  *output_ptr = 0;\n  if ((input_2_cleared < 0x7ff00000) && ((input_2_cleared | input_1) != 0)) {\n    if (input_2_cleared < 0x100000) {\n      result = FUN_080004c8(input_1,input_2,0,0x43500000,param_4);\n      counter = -0x36;\n      input_2_cleared = (uint)((ulonglong)result >> 0x20) & 0x7fffffff;\n    }\n    input_1 = (uint)result;\n    input_2 = (uint)((ulonglong)result >> 0x20) & 0x800fffff | 0x3fe00000;\n    *output_ptr = ((int)input_2_cleared >> 0x14) + -0x3fe + counter;\n  }\n  return CONCAT44(input_2,input_1);\n}\n\n",
            "renaming": {
                "FUN_080096e0": "decode_and_update_080096e0",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "output_ptr",
                "iVar1": "counter",
                "uVar2": "input_2_cleared",
                "uVar3": "result"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_080004c8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009744": {
            "entrypoint": "0x08009744",
            "current_name": "check_return_value_08009744",
            "code": "\nvoid checkReturnValue_08009744(int *outputPointer,undefined4 inputValue)\n\n{\n  int returnValue;\n  \n  DAT_20000c10 = 0;\n  returnValue = FUN_08005728(inputValue);\n  if ((returnValue == -1) && (DAT_20000c10 != 0)) {\n    *outputPointer = DAT_20000c10;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009744": "check_return_value_08009744",
                "param_1": "outputPointer",
                "param_2": "inputValue",
                "iVar1": "returnValue"
            },
            "calling": [
                "FUN_0800884c",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_08005728"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009768": {
            "entrypoint": "0x08009768",
            "current_name": "copy_string_with_null_08009768",
            "code": "\nvoid copyStringWithNull_08009768(uint *destination,uint *source,uint length)\n\n{\n  char currentChar;\n  uint *currentSrc;\n  uint *currentDest;\n  uint currentValue;\n  \n  if (((((uint)destination | (uint)source) & 3) == 0) &&\n     (currentDest = destination, currentSrc = source, 3 < length)) {\n    do {\n      source = currentSrc + 1;\n      currentValue = *currentSrc;\n      destination = currentDest;\n      if ((currentValue + 0xfefefeff & ~currentValue & 0x80808080) != 0) goto LAB_0800979c;\n      length = length - 4;\n      destination = currentDest + 1;\n      *currentDest = currentValue;\n      currentDest = destination;\n      currentSrc = source;\n    } while (3 < length);\n  }\n  currentSrc = source;\n  if (length != 0) {\nLAB_0800979c:\n    currentChar = *(char *)currentSrc;\n    *(char *)destination = currentChar;\n    while( true ) {\n      destination = (uint *)((int)destination + 1);\n      length = length - 1;\n      if (currentChar == '\\0') break;\n      if (length == 0) {\n        return;\n      }\n      currentSrc = (uint *)((int)currentSrc + 1);\n      currentChar = *(char *)currentSrc;\n      *(char *)destination = currentChar;\n    }\n    if (length != 0) {\n      currentSrc = destination;\n      do {\n        currentDest = (uint *)((int)currentSrc + 1);\n        *(char *)currentSrc = '\\0';\n        currentSrc = currentDest;\n      } while (currentDest != (uint *)(length + (int)destination));\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009768": "copy_string_with_null_08009768",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "length",
                "cVar1": "currentChar",
                "puVar2": "currentSrc",
                "puVar3": "currentDest",
                "uVar4": "currentValue"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080097cc": {
            "entrypoint": "0x080097cc",
            "current_name": "process_data_080097cc",
            "code": "\nundefined4 process_data_080097cc(undefined4 *result,int *data_ptr,int *info_ptr)\n\n{\n  int current_value;\n  uint current_index;\n  int new_value;\n  int offset;\n  uint max_index;\n  uint index;\n  undefined4 *current_ptr;\n  undefined4 *next_ptr;\n  undefined4 current_data;\n  \n  if (info_ptr[2] != 0) {\n    current_value = *data_ptr;\n    max_index = data_ptr[2];\n    next_ptr = (undefined4 *)*info_ptr;\n    do {\n      do {\n        current_ptr = next_ptr + 2;\n        current_data = *next_ptr;\n        index = next_ptr[1];\n        next_ptr = current_ptr;\n      } while (index == 0);\n      current_index = index;\n      if ((max_index <= index) && (current_index = max_index, (*(ushort *)(data_ptr + 3) & 0x480) != 0)) {\n        offset = current_value - data_ptr[4];\n        max_index = (data_ptr[5] * 3) / 2;\n        current_index = index + 1 + offset;\n        if (max_index < current_index) {\n          max_index = current_index;\n        }\n        if ((int)((uint)*(ushort *)(data_ptr + 3) << 0x15) < 0) {\n          new_value = FUN_08008af8(result,max_index);\n          if (new_value == 0) {\nerror_handling:\n            *result = 0xc;\n            *(ushort *)(data_ptr + 3) = *(ushort *)(data_ptr + 3) | 0x40;\n            info_ptr[1] = 0;\n            info_ptr[2] = 0;\n            return 0xffffffff;\n          }\n          FUN_08001084(new_value,data_ptr[4],offset);\n          *(ushort *)(data_ptr + 3) = *(ushort *)(data_ptr + 3) & 0xfb7f | 0x80;\n        }\n        else {\n          new_value = FUN_08009adc(result);\n          if (new_value == 0) {\n            FUN_080088ec(result,data_ptr[4]);\n            goto error_handling;\n          }\n        }\n        current_value = new_value + offset;\n        data_ptr[5] = max_index;\n        data_ptr[4] = new_value;\n        *data_ptr = current_value;\n        data_ptr[2] = max_index - offset;\n        current_index = index;\n      }\n      FUN_08009a18(current_value,current_data,current_index);\n      offset = info_ptr[2];\n      max_index = data_ptr[2] - current_index;\n      current_value = *data_ptr + current_index;\n      data_ptr[2] = max_index;\n      *data_ptr = current_value;\n      info_ptr[2] = offset - index;\n    } while (offset - index != 0);\n  }\n  info_ptr[1] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080097cc": "process_data_080097cc",
                "param_1": "result",
                "param_2": "data_ptr",
                "param_3": "info_ptr",
                "iVar1": "current_value",
                "uVar2": "current_index",
                "iVar3": "new_value",
                "iVar4": "offset",
                "uVar5": "max_index",
                "uVar6": "index",
                "puVar7": "current_ptr",
                "puVar8": "next_ptr",
                "uVar9": "current_data",
                "LAB_08009896": "error_handling"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_08001084",
                "FUN_080088ec",
                "FUN_08009adc",
                "FUN_08009a18",
                "FUN_08008af8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080098c0": {
            "entrypoint": "0x080098c0",
            "current_name": "update_data_entry_080098c0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08009906) */\n/* WARNING: Removing unreachable block (ram,0x08009912) */\n\nundefined4 updateDataEntry_080098c0(int entryType,undefined4 data,undefined4 value1,undefined4 value2)\n\n{\n  undefined *dataEntry;\n  undefined4 returnValue;\n  uint bitMask;\n  uint entryCount;\n  \n  FUNC_08008af0(DAT_20000448);\n  if (DAT_20000168 == (undefined *)0x0) {\n    DAT_20000168 = &DAT_2000016c;\n  }\n  dataEntry = DAT_20000168;\n  entryCount = *(uint *)(DAT_20000168 + 4);\n  if ((int)entryCount < 0x20) {\n    if (entryType != 0) {\n      *(undefined4 *)(DAT_20000168 + entryCount * 4 + 0x88) = value1;\n      bitMask = 1 << (entryCount & 0xff);\n      *(uint *)(dataEntry + 0x188) = *(uint *)(dataEntry + 0x188) | bitMask;\n      *(undefined4 *)(dataEntry + entryCount * 4 + 0x108) = value2;\n      if (entryType == 2) {\n        *(uint *)(dataEntry + 0x18c) = bitMask | *(uint *)(dataEntry + 0x18c);\n      }\n    }\n    *(uint *)(dataEntry + 4) = entryCount + 1;\n    returnValue = DAT_20000448;\n    *(undefined4 *)(dataEntry + (entryCount + 2) * 4) = data;\n    FUNC_08008af4(returnValue);\n    returnValue = 0;\n  }\n  else {\n    FUNC_08008af4(DAT_20000448);\n    returnValue = 0xffffffff;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080098c0": "update_data_entry_080098c0",
                "param_1": "entryType",
                "param_2": "data",
                "param_3": "value1",
                "param_4": "value2",
                "puVar1": "dataEntry",
                "uVar2": "returnValue",
                "uVar3": "bitMask",
                "uVar4": "entryCount"
            },
            "calling": [
                "FUN_080078a0"
            ],
            "called": [
                "FUN_08008af4",
                "FUN_08008af0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009980": {
            "entrypoint": "0x08009980",
            "current_name": "initialize_memory_08009980",
            "code": "\nundefined4 * initializeMemory_08009980(undefined4 ptr,int length,int size)\n\n{\n  undefined4 *memory;\n  uint adjustedLength;\n  undefined4 *returnValue;\n  \n  memory = (undefined4 *)FUN_08008af8(ptr,size * length);\n  if (memory == (undefined4 *)0x0) {\n    return (undefined4 *)0x0;\n  }\n  adjustedLength = (memory[-1] & 0xfffffffc) - 4;\n  if (adjustedLength < 0x25) {\n    returnValue = memory;\n    if (0x13 < adjustedLength) {\n      *memory = 0;\n      memory[1] = 0;\n      if (0x1b < adjustedLength) {\n        memory[2] = 0;\n        memory[3] = 0;\n        if (adjustedLength == 0x24) {\n          memory[4] = 0;\n          memory[5] = 0;\n          returnValue = memory + 6;\n        }\n        else {\n          returnValue = memory + 4;\n        }\n        *returnValue = 0;\n        returnValue[1] = 0;\n        returnValue[2] = 0;\n        return memory;\n      }\n      returnValue = memory + 2;\n    }\n    *returnValue = 0;\n    returnValue[1] = 0;\n    returnValue[2] = 0;\n    return memory;\n  }\n  FUN_08005d68(memory,0);\n  return memory;\n}\n\n",
            "renaming": {
                "FUN_08009980": "initialize_memory_08009980",
                "param_1": "ptr",
                "param_2": "length",
                "param_3": "size",
                "puVar1": "memory",
                "uVar2": "adjustedLength",
                "puVar3": "returnValue"
            },
            "calling": [
                "FUN_080090c0"
            ],
            "called": [
                "FUN_08005d68",
                "FUN_08008af8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009a18": {
            "entrypoint": "0x08009a18",
            "current_name": "reverse_copy_memory_08009a18",
            "code": "\nvoid reverseCopyMemory_08009a18(undefined4 *dest,undefined4 *src,uint size)\n\n{\n  undefined4 *destPtr;\n  undefined4 *srcPtr;\n  int count;\n  undefined *destBytePtr;\n  undefined4 *srcBytePtr;\n  uint remainingSize;\n  uint remainingSize2;\n  \n  if ((src < dest) && (srcPtr = (undefined4 *)((int)src + size), dest < srcPtr)) {\n    destBytePtr = (undefined *)((int)dest + size);\n    if (size != 0) {\n      do {\n        srcPtr = (undefined4 *)((int)srcPtr + -1);\n        destBytePtr = destBytePtr + -1;\n        *destBytePtr = *(undefined *)srcPtr;\n      } while (src != srcPtr);\n    }\n  }\n  else {\n    remainingSize2 = size;\n    if (0xf < size) {\n      if ((((uint)dest | (uint)src) & 3) != 0) goto LAB_08009abc;\n      srcPtr = src + 4;\n      destPtr = dest + 4;\n      do {\n        srcBytePtr = srcPtr + 4;\n        destPtr[-4] = srcPtr[-4];\n        destPtr[-3] = srcPtr[-3];\n        destPtr[-2] = srcPtr[-2];\n        destPtr[-1] = srcPtr[-1];\n        srcPtr = srcBytePtr;\n        destPtr = destPtr + 4;\n      } while (srcBytePtr != (undefined4 *)((int)src + (size - 0x10 & 0xfffffff0) + 0x20));\n      count = (size - 0x10 >> 4) + 1;\n      remainingSize2 = size & 0xf;\n      src = src + count * 4;\n      dest = dest + count * 4;\n      if (3 < remainingSize2) {\n        srcPtr = dest + -1;\n        remainingSize = remainingSize2;\n        destPtr = src;\n        do {\n          remainingSize = remainingSize - 4;\n          srcPtr = srcPtr + 1;\n          *srcPtr = *destPtr;\n          destPtr = destPtr + 1;\n        } while (3 < remainingSize);\n        count = (remainingSize2 - 4 & 0xfffffffc) + 4;\n        dest = (undefined4 *)((int)dest + count);\n        src = (undefined4 *)((int)src + count);\n        remainingSize2 = size & 3;\n      }\n    }\n    size = remainingSize2;\n    if (remainingSize2 != 0) {\nLAB_08009abc:\n      destBytePtr = (undefined *)((int)dest + -1);\n      srcPtr = src;\n      do {\n        destPtr = (undefined4 *)((int)srcPtr + 1);\n        destBytePtr = destBytePtr + 1;\n        *destBytePtr = *(undefined *)srcPtr;\n        srcPtr = destPtr;\n      } while (destPtr != (undefined4 *)(size + (int)src));\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009a18": "reverse_copy_memory_08009a18",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "size",
                "puVar1": "destPtr",
                "puVar2": "srcPtr",
                "iVar3": "count",
                "puVar4": "destBytePtr",
                "puVar5": "srcBytePtr",
                "uVar6": "remainingSize",
                "uVar7": "remainingSize2"
            },
            "calling": [
                "FUN_080097cc",
                "FUN_08009adc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009adc": {
            "entrypoint": "0x08009adc",
            "current_name": "allocate_memory_08009adc",
            "code": "\nint * allocate_memory_08009adc(undefined4 *ptr_to_buffer,int *ptr_to_allocated_memory,uint size_to_allocate)\n\n{\n  int *current_ptr;\n  int temp_var;\n  int *allocated_memory_ptr;\n  uint temp_var_2;\n  int temp_var_3;\n  uint temp_var_4;\n  int *temp_ptr;\n  uint allocated_size;\n  uint temp_var_5;\n  uint temp_var_6;\n  int end_ptr;\n  \n  if (ptr_to_allocated_memory == (int *)0x0) {\n    allocated_memory_ptr = (int *)FUN_08008af8(ptr_to_buffer,size_to_allocate);\n    return allocated_memory_ptr;\n  }\n  FUN_080090a8();\n  temp_var_4 = ptr_to_allocated_memory[-1];\n  temp_var_5 = temp_var_4 & 0xfffffffc;\n  allocated_memory_ptr = ptr_to_allocated_memory + -2;\n  if (size_to_allocate + 0xb < 0x17) {\n    allocated_size = 0x10;\n  }\n  else {\n    allocated_size = size_to_allocate + 0xb & 0xfffffff8;\n    if ((int)allocated_size < 0) goto LAB_08009b8e;\n  }\n  if (allocated_size < size_to_allocate) {\nLAB_08009b8e:\n    *ptr_to_buffer = 0xc;\n    return (int *)0x0;\n  }\n  end_ptr = (int)allocated_memory_ptr + temp_var_5;\n  temp_var_6 = temp_var_5;\n  if ((int)temp_var_5 < (int)allocated_size) {\n    if (DAT_20000454 == end_ptr) {\n      end_ptr = (*(uint *)(DAT_20000454 + 4) & 0xfffffffc) + temp_var_5;\n      if ((int)(allocated_size + 0x10) <= end_ptr) {\n        DAT_20000454 = (int)allocated_memory_ptr + allocated_size;\n        *(uint *)(DAT_20000454 + 4) = end_ptr - allocated_size | 1;\n        ptr_to_allocated_memory[-1] = allocated_size | ptr_to_allocated_memory[-1] & 1U;\n        FUN_080090b4(ptr_to_buffer);\n        return ptr_to_allocated_memory;\n      }\n      if (-1 < (int)(temp_var_4 << 0x1f)) {\n        current_ptr = (int *)((int)allocated_memory_ptr - ptr_to_allocated_memory[-2]);\n        temp_var_4 = current_ptr[1] & 0xfffffffc;\n        if ((int)(allocated_size + 0x10) <= (int)(end_ptr + temp_var_4)) {\n          temp_var_3 = current_ptr[3];\n          allocated_memory_ptr = current_ptr + 2;\n          temp_var = *allocated_memory_ptr;\n          temp_var_5 = temp_var_5 - 4;\n          *(int *)(temp_var + 0xc) = temp_var_3;\n          *(int *)(temp_var_3 + 8) = temp_var;\n          if (temp_var_5 < 0x25) {\n            temp_var = *ptr_to_allocated_memory;\n            temp_ptr = allocated_memory_ptr;\n            if (0x13 < temp_var_5) {\n              current_ptr[2] = temp_var;\n              current_ptr[3] = ptr_to_allocated_memory[1];\n              temp_var = ptr_to_allocated_memory[2];\n              if (temp_var_5 < 0x1c) {\n                ptr_to_allocated_memory = ptr_to_allocated_memory + 2;\n                temp_ptr = current_ptr + 4;\n              }\n              else {\n                current_ptr[4] = temp_var;\n                current_ptr[5] = ptr_to_allocated_memory[3];\n                temp_var = ptr_to_allocated_memory[4];\n                if (temp_var_5 == 0x24) {\n                  current_ptr[6] = temp_var;\n                  current_ptr[7] = ptr_to_allocated_memory[5];\n                  temp_var = ptr_to_allocated_memory[6];\n                  ptr_to_allocated_memory = ptr_to_allocated_memory + 6;\n                  temp_ptr = current_ptr + 8;\n                }\n                else {\n                  ptr_to_allocated_memory = ptr_to_allocated_memory + 4;\n                  temp_ptr = current_ptr + 6;\n                }\n              }\n            }\n            *temp_ptr = temp_var;\n            temp_ptr[1] = ptr_to_allocated_memory[1];\n            temp_ptr[2] = ptr_to_allocated_memory[2];\n          }\n          else {\n            FUN_08009a18(allocated_memory_ptr,ptr_to_allocated_memory);\n          }\n          DAT_20000454 = (int)current_ptr + allocated_size;\n          *(uint *)(DAT_20000454 + 4) = (end_ptr + temp_var_4) - allocated_size | 1;\n          current_ptr[1] = allocated_size | current_ptr[1] & 1U;\n          FUN_080090b4(ptr_to_buffer);\n          return allocated_memory_ptr;\n        }\nLAB_08009bb0:\n        temp_var_6 = temp_var_5 + temp_var_4;\n        if ((int)allocated_size <= (int)temp_var_6) {\n          temp_var_3 = current_ptr[3];\n          temp_ptr = current_ptr + 2;\n          temp_var = *temp_ptr;\n          *(int *)(temp_var + 0xc) = temp_var_3;\n          end_ptr = (int)current_ptr + temp_var_6;\n          *(int *)(temp_var_3 + 8) = temp_var;\n          allocated_memory_ptr = current_ptr;\n          if (temp_var_5 - 4 < 0x25) goto LAB_08009bd0;\nLAB_08009d4c:\n          FUN_08009a18(temp_ptr,ptr_to_allocated_memory);\n          ptr_to_allocated_memory = temp_ptr;\n          goto LAB_08009c00;\n        }\n      }\n    }\n    else {\n      if (-1 < *(int *)((*(uint *)(end_ptr + 4) & 0xfffffffe) + end_ptr + 4) << 0x1f) {\n        temp_var_2 = *(uint *)(end_ptr + 4) & 0xfffffffc;\n        temp_var_6 = temp_var_5 + temp_var_2;\n        if ((int)temp_var_6 < (int)allocated_size) {\n          if ((int)(temp_var_4 << 0x1f) < 0) goto LAB_08009b36;\n          current_ptr = (int *)((int)allocated_memory_ptr - ptr_to_allocated_memory[-2]);\n          temp_var_4 = current_ptr[1] & 0xfffffffc;\n          temp_var_6 = temp_var_2 + temp_var_4 + temp_var_5;\n          if ((int)temp_var_6 < (int)allocated_size) goto LAB_08009bb0;\n          temp_var = *(int *)(end_ptr + 8);\n          end_ptr = *(int *)(end_ptr + 0xc);\n          *(int *)(temp_var + 0xc) = end_ptr;\n          *(int *)(end_ptr + 8) = temp_var;\n          temp_ptr = current_ptr + 2;\n          temp_var = *temp_ptr;\n          temp_var_3 = current_ptr[3];\n          *(int *)(temp_var + 0xc) = temp_var_3;\n          end_ptr = (int)current_ptr + temp_var_6;\n          *(int *)(temp_var_3 + 8) = temp_var;\n          allocated_memory_ptr = current_ptr;\n          if (0x24 < temp_var_5 - 4) goto LAB_08009d4c;\nLAB_08009bd0:\n          temp_var_5 = temp_var_5 - 4;\n          temp_var = *ptr_to_allocated_memory;\n          current_ptr = temp_ptr;\n          if (0x13 < temp_var_5) {\n            allocated_memory_ptr[2] = temp_var;\n            allocated_memory_ptr[3] = ptr_to_allocated_memory[1];\n            temp_var = ptr_to_allocated_memory[2];\n            if (temp_var_5 < 0x1c) {\n              ptr_to_allocated_memory = ptr_to_allocated_memory + 2;\n              current_ptr = allocated_memory_ptr + 4;\n            }\n            else {\n              allocated_memory_ptr[4] = temp_var;\n              allocated_memory_ptr[5] = ptr_to_allocated_memory[3];\n              temp_var = ptr_to_allocated_memory[4];\n              if (temp_var_5 == 0x24) {\n                allocated_memory_ptr[6] = temp_var;\n                allocated_memory_ptr[7] = ptr_to_allocated_memory[5];\n                temp_var = ptr_to_allocated_memory[6];\n                ptr_to_allocated_memory = ptr_to_allocated_memory + 6;\n                current_ptr = allocated_memory_ptr + 8;\n              }\n              else {\n                ptr_to_allocated_memory = ptr_to_allocated_memory + 4;\n                current_ptr = allocated_memory_ptr + 6;\n              }\n            }\n          }\n          *current_ptr = temp_var;\n          current_ptr[1] = ptr_to_allocated_memory[1];\n          current_ptr[2] = ptr_to_allocated_memory[2];\n          ptr_to_allocated_memory = temp_ptr;\n        }\n        else {\n          temp_var = *(int *)(end_ptr + 8);\n          temp_var_3 = *(int *)(end_ptr + 0xc);\n          *(int *)(temp_var + 0xc) = temp_var_3;\n          end_ptr = (int)allocated_memory_ptr + temp_var_6;\n          *(int *)(temp_var_3 + 8) = temp_var;\n        }\n        goto LAB_08009c00;\n      }\n      if (-1 < (int)(temp_var_4 << 0x1f)) {\n        current_ptr = (int *)((int)allocated_memory_ptr - ptr_to_allocated_memory[-2]);\n        temp_var_4 = current_ptr[1] & 0xfffffffc;\n        goto LAB_08009bb0;\n      }\n    }\nLAB_08009b36:\n    current_ptr = (int *)FUN_08008af8(ptr_to_buffer,size_to_allocate);\n    if (current_ptr != (int *)0x0) {\n      if ((int *)((ptr_to_allocated_memory[-1] & 0xfffffffeU) + (int)allocated_memory_ptr) == current_ptr + -2) {\n        temp_var_6 = temp_var_5 + (current_ptr[-1] & 0xfffffffcU);\n        end_ptr = (int)allocated_memory_ptr + temp_var_6;\n        goto LAB_08009c00;\n      }\n      temp_var_5 = temp_var_5 - 4;\n      if (temp_var_5 < 0x25) {\n        end_ptr = *ptr_to_allocated_memory;\n        allocated_memory_ptr = ptr_to_allocated_memory;\n        temp_ptr = current_ptr;\n        if (0x13 < temp_var_5) {\n          *current_ptr = end_ptr;\n          current_ptr[1] = ptr_to_allocated_memory[1];\n          if (temp_var_5 < 0x1c) {\n            end_ptr = ptr_to_allocated_memory[2];\n            allocated_memory_ptr = ptr_to_allocated_memory + 2;\n            temp_ptr = current_ptr + 2;\n          }\n          else {\n            current_ptr[2] = ptr_to_allocated_memory[2];\n            current_ptr[3] = ptr_to_allocated_memory[3];\n            if (temp_var_5 == 0x24) {\n              current_ptr[4] = ptr_to_allocated_memory[4];\n              current_ptr[5] = ptr_to_allocated_memory[5];\n              end_ptr = ptr_to_allocated_memory[6];\n              allocated_memory_ptr = ptr_to_allocated_memory + 6;\n              temp_ptr = current_ptr + 6;\n            }\n            else {\n              end_ptr = ptr_to_allocated_memory[4];\n              allocated_memory_ptr = ptr_to_allocated_memory + 4;\n              temp_ptr = current_ptr + 4;\n            }\n          }\n        }\n        *temp_ptr = end_ptr;\n        temp_ptr[1] = allocated_memory_ptr[1];\n        temp_ptr[2] = allocated_memory_ptr[2];\n      }\n      else {\n        FUN_08009a18(current_ptr,ptr_to_allocated_memory);\n      }\n      FUN_080088ec(ptr_to_buffer,ptr_to_allocated_memory);\n    }\n    FUN_080090b4(ptr_to_buffer);\n    ptr_to_allocated_memory = current_ptr;\n  }\n  else {\nLAB_08009c00:\n    if (temp_var_6 - allocated_size < 0x10) {\n      allocated_memory_ptr[1] = allocated_memory_ptr[1] & 1U | temp_var_6;\n      *(uint *)(end_ptr + 4) = *(uint *)(end_ptr + 4) | 1;\n    }\n    else {\n      allocated_memory_ptr[1] = allocated_memory_ptr[1] & 1U | allocated_size;\n      *(uint *)((int)allocated_memory_ptr + allocated_size + 4) = temp_var_6 - allocated_size | 1;\n      *(uint *)(end_ptr + 4) = *(uint *)(end_ptr + 4) | 1;\n      FUN_080088ec(ptr_to_buffer,(int)allocated_memory_ptr + allocated_size + 8);\n    }\n    FUN_080090b4(ptr_to_buffer);\n  }\n  return ptr_to_allocated_memory;\n}\n\n",
            "renaming": {
                "FUN_08009adc": "allocate_memory_08009adc",
                "param_1": "ptr_to_buffer",
                "param_2": "ptr_to_allocated_memory",
                "param_3": "size_to_allocate",
                "piVar1": "current_ptr",
                "iVar2": "temp_var",
                "piVar3": "allocated_memory_ptr",
                "uVar4": "temp_var_2",
                "iVar5": "temp_var_3",
                "uVar6": "temp_var_4",
                "piVar7": "temp_ptr",
                "uVar8": "allocated_size",
                "uVar9": "temp_var_5",
                "uVar10": "temp_var_6",
                "iVar11": "end_ptr"
            },
            "calling": [
                "FUN_080097cc"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_080090b4",
                "FUN_080088ec",
                "FUN_08009a18",
                "FUN_08008af8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e68": {
            "entrypoint": "0x08009e68",
            "current_name": "FUNC_08009e68",
            "code": "\nvoid FUNC_08009e68(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e68": "FUNC_08009e68"
            },
            "calling": [
                "FUN_08005d20",
                "FUN_08000110",
                "FUN_08000134"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08009e74": {
            "entrypoint": "0x08009e74",
            "current_name": "FUNC_08009e74",
            "code": "\nvoid FUNC_08009e74(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e74": "FUNC_08009e74"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 159653,
    "layers": [
        [
            "FUN_08000110",
            "FUN_08000134",
            "FUN_08000158",
            "FUN_0800015c",
            "FUN_080003d4",
            "FUN_080003f4",
            "FUN_08000418",
            "FUN_080004c8",
            "FUN_080006a4",
            "FUN_0800071c",
            "FUN_0800088a",
            "FUN_080008fc",
            "FUN_08000978",
            "FUN_08000988",
            "FUN_08000998",
            "FUN_080009ac",
            "FUN_080009c0",
            "FUN_080009d4",
            "FUN_080009e8",
            "FUN_080009fc",
            "FUN_08000aa4",
            "FUN_08000aa8",
            "FUN_08000c08",
            "FUN_08000c10",
            "FUN_08000cb8",
            "FUN_08000e20",
            "FUN_08000f68",
            "FUN_08000fc8",
            "FUN_08000fd0",
            "FUN_08000ff4",
            "FUN_08001030",
            "FUN_08001044",
            "FUN_08001084",
            "FUN_08001170",
            "FUN_0800119c",
            "FUN_080011ec",
            "FUN_0800121c",
            "FUN_080014f0",
            "FUN_0800151c",
            "FUN_0800157c",
            "FUN_080015a0",
            "FUN_080015b4",
            "FUN_080015fc",
            "FUN_08001618",
            "FUN_0800166c",
            "FUN_080016d0",
            "FUN_08001714",
            "FUN_0800172a",
            "FUN_08001762",
            "FUN_0800177c",
            "FUN_080017b4",
            "FUN_080017c4",
            "FUN_08001a80",
            "FUN_08001ab0",
            "FUN_08001ccc",
            "FUN_08001f6c",
            "FUN_08002640",
            "FUN_080027f4",
            "FUN_08002ad8",
            "FUN_08002bb4",
            "FUN_08002c2e",
            "FUN_08002ca8",
            "FUN_08002d3c",
            "FUN_08002d98",
            "FUN_08003260",
            "FUN_08003440",
            "FUN_08003504",
            "FUN_08003518",
            "FUN_08003540",
            "FUN_08003568",
            "FUN_080035a4",
            "FUN_0800360c",
            "FUN_08003640",
            "FUN_080036a8",
            "FUN_080036f8",
            "FUN_08003908",
            "FUN_08003a94",
            "FUN_08003c94",
            "FUN_08003d60",
            "FUN_08003e38",
            "FUN_08003f18",
            "FUN_08003ff8",
            "FUN_080040a0",
            "FUN_08004104",
            "FUN_0800416a",
            "FUN_080041a8",
            "FUN_080041ea",
            "FUN_0800422e",
            "FUN_080042de",
            "FUN_0800438a",
            "FUN_08004436",
            "FUN_080046ec",
            "FUN_0800491c",
            "FUN_080049cc",
            "FUN_08004ae0",
            "FUN_08004bd8",
            "FUN_08004d78",
            "FUN_08004e6c",
            "FUN_08004e74",
            "FUN_08004ea4",
            "FUN_08004ee8",
            "FUN_08004f2c",
            "FUN_08004f3c",
            "FUN_08004f60",
            "FUN_08004f78",
            "FUN_08005224",
            "FUN_080052a0",
            "FUN_08005348",
            "FUN_080053b0",
            "FUN_08005500",
            "FUN_08005598",
            "FUN_080055f4",
            "FUN_08005674",
            "FUN_08005680",
            "FUN_08005704",
            "FUN_08005714",
            "FUN_08005728",
            "FUN_08005780",
            "thunk_FUN_08005838",
            "FUN_08005838",
            "FUN_080059f0",
            "FUN_08005d14",
            "FUN_08005d20",
            "FUN_08005d68",
            "FUN_08005dfc",
            "FUN_08005e40",
            "FUN_080078c0",
            "FUN_080079e8",
            "FUN_0800884c",
            "FUN_080088ec",
            "FUN_08008ad4",
            "FUN_08008af8",
            "FUN_0800901c",
            "FUN_080090a8",
            "FUN_080090b4",
            "FUN_080090c0",
            "FUN_0800910c",
            "FUN_08009120",
            "FUN_080091a4",
            "FUN_080091e4",
            "FUN_08009244",
            "FUN_08009258",
            "FUN_080093a4",
            "FUN_08009444",
            "FUN_080094f8",
            "FUN_08009530",
            "FUN_08009630",
            "FUN_080096e0",
            "FUN_08009744",
            "FUN_08009768",
            "FUN_080097cc",
            "FUN_080098c0",
            "FUN_08009980",
            "FUN_08009a18",
            "FUN_08009adc"
        ]
    ],
    "locked_functions": []
}