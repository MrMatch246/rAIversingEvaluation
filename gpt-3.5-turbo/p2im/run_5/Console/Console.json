{
    "functions": {
        "FUN_000026c0": {
            "renaming": {
                "FUN_000026c0": "clear_flags_and_reset_values_000026c0",
                "PTR_DAT_000026d4": "pointer_to_data",
                "clearFlagsAndValues_00002910": "clear_all_flags"
            },
            "code": "void clear_flags_and_reset_values_000026c0(void)\n{\n  clear_all_flags();\n  *(int *)PTR_DAT_000026d4 = 0;\n  return;\n}",
            "called": [
                "FUN_00002910"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": true,
            "current_name": "clear_flags_and_reset_values_000026c0"
        },
        "FUN_00004bd0": {
            "renaming": {
                "iVar4": "alignment_adjustment",
                "PTR_DAT_00004c80": "new_block_list_pointer",
                "puVar3": "previous_block_address",
                "FUN_00004bd0": "allocate_memory_block_00004bd0",
                "puVar6": "current_block_address",
                "*param_1": "*block_address",
                "PTR_DAT_00004c7c": "current_block_list_pointer",
                "param_2": "requested_size",
                "param_3": "filler_value",
                "param_4": "unused_parameter",
                "puVar1": "unused_pointer",
                "uVar2": "new_block_address",
                "uVar5": "block_size_difference",
                "uVar7": "block_size"
            },
            "code": "uint allocate_memory_block_00004bd0(uint *block_address, uint requested_size, uint filler_value, uint unused_parameter)\n{\n  uint *current_block_address;\n  uint block_size;\n  uint previous_block_size;\n  uint alignment_adjustment;\n  \n  block_size = (requested_size + 3 & 0xfffffffc) + 8;\n  if (block_size < 0xc) {\n    block_size = 0xc;\n  }\n  if (((int)block_size < 0) || (block_size < requested_size)) {\n    *block_address = 0xc;\n  }\n  else {\n    do_nothing_with_pointer_data_00005790();\n    current_block_address = *(uint **)PTR_DAT_00004c7c;\n    previous_block_size = 0;\n    while (current_block_address != (uint *)0x0) {\n      alignment_adjustment = *current_block_address - block_size;\n      if (-1 < (int)alignment_adjustment) {\n        if (0xb < alignment_adjustment) {\n          *current_block_address = alignment_adjustment;\n          current_block_address = (uint *)((int)current_block_address + alignment_adjustment);\n          goto LAB_00004c34;\n        }\n        previous_block_size = current_block_address[1];\n        if (*(uint **)PTR_DAT_00004c7c == current_block_address) {\n          *(uint **)PTR_DAT_00004c7c = (uint *)previous_block_size;\n        }\n        if (*(uint **)PTR_DAT_00004c7c != current_block_address) {\n          *(uint *)(current_block_address + 1) = previous_block_size;\n        }\n        goto LAB_00004c42;\n      }\n      previous_block_size = (uint)current_block_address;\n      current_block_address = (uint *)current_block_address[1];\n    }\n    if (*(int *)PTR_DAT_00004c80 == 0) {\n      uint new_block_address = calculate_local_address_00000428(block_address, 0, previous_block_size, 0, unused_parameter);\n      *(uint *)PTR_DAT_00004c80 = new_block_address;\n    }\n    current_block_address = (uint *)calculate_local_address_00000428(block_address, block_size);\n    if ((current_block_address != (uint *)0xffffffff) &&\n       ((alignment_adjustment = (uint *)((int)current_block_address + 3U & 0xfffffffc), current_block_address == alignment_adjustment ||\n        (previous_block_size = calculate_local_address_00000428(block_address, (int)alignment_adjustment - (int)current_block_address), previous_block_size != -1)))) {\nLAB_00004c34:\n      *alignment_adjustment = block_size;\nLAB_00004c42:\n      do_nothing_with_pointer_0000579c(block_address);\n      block_size = (int)alignment_adjustment + 0xbU & 0xfffffff8;\n      previous_block_size = block_size - (int)(alignment_adjustment + 1);\n      if (previous_block_size != 0) {\n        *(uint *)((int)alignment_adjustment + previous_block_size) = (int)(alignment_adjustment + 1) - block_size;\n      }\n      return block_size;\n    }\n    *block_address = 0xc;\n    do_nothing_with_pointer_0000579c(block_address);\n  }\n  return 0;\n}",
            "called": [
                "FUN_00005790",
                "FUN_00000428",
                "FUN_0000579c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004bd0",
            "calling": [
                "FUN_00004248",
                "FUN_000060cc",
                "FUN_00005700",
                "FUN_00005100",
                "FUN_000068f0"
            ],
            "imported": true,
            "current_name": "allocate_memory_block_00004bd0"
        },
        "FUN_00000794": {
            "renaming": {
                "piStack_14": "stack_ptr",
                "iVar1": "index",
                "iStack_1c": "i",
                "puVar2": "current_ptr",
                "FUN_00000794": "create_linked_list_00000794",
                "iStack_18": "i",
                "uVar3": "current_address",
                "extraout_r1": "return_value"
            },
            "code": "int * create_linked_list_00000794(void)\n{\n  int extraout_r1;\n  int index;\n  undefined4 *current_ptr;\n  uint current_address;\n  int *stack_ptr;\n  is_interrupts_enabled_in_privileged_mode();\n  *(undefined4 *)(iRam000007d0 + *psRam000007cc * 4) = 0;\n  *piRam000007d4 = *piRam000007d4 - 1;\n  update_linked_list_00000698(*puRam000007d8,0);\n  current_ptr = puRam000007d8;\n  index = 0;\n  *puRam000007d8 = 0;\n  wait_for_interrupt();\n  current_address = (int)current_ptr + index & 0xfffffffc;\n  stack_ptr = (int *)(current_address - 4);\n  *stack_ptr = 0x77777777;\n  if (((uint)stack_ptr & 7) != 0) {\n    stack_ptr = (int *)(current_address - 8);\n    *stack_ptr = 0x88888888;\n  }\n  stack_ptr[-1] = 0x1000000;\n  stack_ptr[-2] = index << 0xd;\n  stack_ptr[-3] = DAT_000008b4;\n  stack_ptr = stack_ptr - 4;\n  *stack_ptr = 0;\n  for (int i = 3; 0 < i; i--) {\n    stack_ptr = stack_ptr - 1;\n    *stack_ptr = i;\n  }\n  stack_ptr = stack_ptr - 1;\n  *stack_ptr = extraout_r1;\n  for (int i = 0xb; 3 < i; i--) {\n    stack_ptr = stack_ptr - 1;\n    *stack_ptr = i;\n  }\n  stack_ptr[-1] = -3;\n  return stack_ptr - 1;\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000930",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000794",
            "calling": [],
            "imported": true,
            "current_name": "create_linked_list_00000794"
        },
        "FUN_000064bc": {
            "renaming": {
                "iVar2": "callback_flag",
                "iVar7": "callback_count",
                "ppbVar4": "current_buffer",
                "param_1": "data",
                "pbVar5": "last_byte",
                "FUN_000064bc": "process_data_000064bc",
                "pbVar6": "current_byte",
                "unaff_r6": "current_byte",
                "param_2": "flags",
                "param_3": "buffer",
                "param_4": "callback_result",
                "puVar1": "current_byte",
                "uVar3": "current_flag"
            },
            "code": "int process_data_000064bc(int data, uint *flags, byte **buffer, int *callback_result) {\n  byte *current_byte;\n  byte *last_byte;\n  byte **current_buffer;\n  uint current_flag;\n  uint callback_flag;\n  int byte_count;\n  int callback_count;\n  if (flags[2] == 0) {\n    if (flags[6] == 0) {\n      current_flag = 1;\n    }\n    else {\n      current_flag = 0xffffffff;\n    }\n    flags[2] = current_flag;\n  }\n  current_buffer = buffer;\n  callback_count = 0;\n  do {\n    current_flag = flags[6];\n    if (current_flag != 0) {\n      if (current_flag == 1) {\n        if (*(char *)(flags[5] + (uint)**current_buffer) == '\\0') {\n          if (callback_count == 0) {\n            return 1;\n          }\n          if (((*flags & 0x10) == 0) && (flags[3] = flags[3] + 1, flags[6] != 0)) {\n            *current_byte = 0;\n          }\n          flags[4] = callback_count + flags[4];\n          return 0;\n        }\n      }\n      else if ((current_flag != 2) || ((int)((uint)(byte)*current_byte << 0x1c) < 0)) {\n        if (callback_count == 0) {\n          return 1;\n        }\n        if (((*flags & 0x10) == 0) && (flags[3] = flags[3] + 1, flags[6] != 0)) {\n          *current_byte = 0;\n        }\n        flags[4] = callback_count + flags[4];\n        return 0;\n      }\n    }\n    current_byte = *current_buffer;\n    if (-1 < (int)(flags[0] << 0x1b)) {\n      current_byte = current_byte + 1;\n      *current_byte = **current_buffer;\n    }\n    last_byte = (*current_buffer)[1];\n    *current_buffer = *current_buffer + 1;\n    current_flag = flags[2] - 1;\n    (*current_buffer)[1] = last_byte + -1;\n    callback_count = callback_count + 1;\n    flags[2] = current_flag;\n  } while ((current_flag != 0) && (((int)(last_byte + -1) < 1 && (callback_result = (*(code *)flags[0x60])(data,current_buffer,current_flag,(code *)flags[0x60],callback_result), callback_result != 0))));\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000064bc",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": true,
            "current_name": "process_data_000064bc"
        },
        "FUN_00002970": {
            "renaming": {
                "DAT_00002990": "offset_from_DAT_00002990",
                "uint": "unsigned_integer",
                "FUN_00002970": "clear_bit_in_uint_at_offset_from_DAT_00002990_00002970",
                "uint_ptr": "pointer_to_unsigned_integer",
                "masked_uint": "unsigned_integer_with_mask_applied"
            },
            "code": "void clear_bit_in_uint_at_offset_from_DAT_00002990_00002970(void)\n{\n  uint* uint_ptr = (uint *)(DAT_00002990 + 0x14);\n  uint masked_uint = *uint_ptr & 0xffffffef;\n  *uint_ptr = masked_uint;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002970",
            "calling": [
                "FUN_000026e4"
            ],
            "imported": true,
            "current_name": "clear_bit_in_uint_at_offset_from_DAT_00002990_00002970"
        },
        "FUN_00000dc0": {
            "renaming": {
                "check_interrupts_and_return_status_00000cc0": "check_interrupts_and_return_status",
                "FUN_00000dc0": "check_and_return_interrupt_status_00000dc0"
            },
            "code": "void check_and_return_interrupt_status_00000dc0(void)\n{\n  check_interrupts_and_return_status();\n  return;\n}",
            "called": [
                "FUN_00000cc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dc0",
            "calling": [],
            "imported": true,
            "current_name": "check_and_return_interrupt_status_00000dc0"
        },
        "FUN_00000d0c": {
            "renaming": {
                "bVar1": "is_privileged",
                "param_1": "mode_bit",
                "FUN_00000d0c": "enable_interrupts_if_privileged_00000d0c"
            },
            "code": "void enable_interrupts_if_privileged_00000d0c(uint mode_bit) {\n  bool is_privileged = (bool)isCurrentModePrivileged();\n  if (is_privileged) {\n    enableIRQinterrupts((mode_bit & 1) == 1);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d0c",
            "calling": [
                "FUN_000010d4",
                "FUN_00001c84",
                "FUN_000024bc",
                "FUN_00000428",
                "FUN_00002434"
            ],
            "imported": true,
            "current_name": "enable_interrupts_if_privileged_00000d0c"
        },
        "FUN_00003d94": {
            "renaming": {
                "uVar1": "result",
                "param_1": "function_ptr",
                "param_2": "input",
                "FUN_00003d94": "execute_function_00003d94"
            },
            "code": "int execute_function_00003d94(int function_ptr, int input){\n  int result;\n  if (function_ptr == 0) {\n    result = -19;\n  }\n  else {\n    result = (**(function_ptr + 0xc))(*(int *)(function_ptr + 4), input);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d94",
            "calling": [
                "FUN_0000305c"
            ],
            "imported": true,
            "current_name": "execute_function_00003d94"
        },
        "FUN_0000579c": {
            "renaming": {
                "PTR_DAT_000057a4": "PTR_data",
                "FUN_0000579c": "do_nothing_with_pointer_0000579c"
            },
            "code": "void do_nothing_with_pointer_0000579c(void)\n{\n  do_nothing(PTR_DAT_000057a4);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000579c",
            "calling": [
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "imported": true,
            "current_name": "do_nothing_with_pointer_0000579c"
        },
        "FUN_000015d0": {
            "renaming": {
                "iVar1": "memory_address",
                "local_c": "i",
                "param_1": "array_index",
                "param_2": "data_index",
                "param_3": "data_length",
                "FUN_000015d0": "copy_data_to_memory_000015d0"
            },
            "code": "void copy_data_to_memory_000015d0(int array_index, int data_index, uint data_length)\n{\n  int memory_address = *(int *)(PTR_DAT_00001624 + array_index * 0x20);\n  for (uint i = 0; i < data_length; i++) {\n    do {\n    } while (-1 < *(char *)(memory_address + 4));\n    *(undefined *)(memory_address + 7) = *(undefined *)(i + data_index);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000015d0",
            "calling": [
                "FUN_00000e38"
            ],
            "imported": true,
            "current_name": "copy_data_to_memory_000015d0"
        },
        "FUN_00005e68": {
            "renaming": {
                "FUN_00005e68": "process_data_00005e68",
                "local_72": "negative_one",
                "local_70": "data_size",
                "local_80": "data_size_ptr",
                "local_4c": "zero",
                "local_5c": "string_data",
                "local_6c": "result_size_ptr",
                "uStack_8": "data_buffer_ptr",
                "param_1": "data_size",
                "local_7c": "string_end_index",
                "uStack_4": "result_buffer_ptr",
                "local_38": "negative_one",
                "param_2": "data_buffer",
                "param_3": "result_buffer",
                "param_4": "result_size",
                "local_74": "zero"
            },
            "code": "void process_data_00005e68(int data_size, int *data_buffer, int *result_buffer, int result_size)\n{\n  int string_end_index = find_end_of_string();\n  char *string_data = PTR_LAB_00004dea_1_00005eb4;\n  int zero = 0;\n  int negative_one = -1;\n  int *data_size_ptr = &data_size;\n  int *result_size_ptr = &result_size;\n  int *data_buffer_ptr = data_buffer;\n  int *result_buffer_ptr = result_buffer;\n  FUNC_000061cc(*DAT_00005eb8,data_size_ptr,data_buffer_ptr,result_buffer_ptr);\n  return;\n}",
            "called": [
                "FUN_000061cc",
                "FUN_00005ecc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e68",
            "calling": [
                "FUN_00005100"
            ],
            "imported": true,
            "current_name": "process_data_00005e68"
        },
        "FUN_00000dcc": {
            "renaming": {
                "DAT_00000df0": "data_ptr",
                "FUN_00000dcc": "set_data_values_00000dcc"
            },
            "code": "void set_data_values_00000dcc(void)\n{\n  int* DAT_00000df0 = DAT_00000df0;\n  DAT_00000df0[7] = 0xc520;\n  DAT_00000df0[7] = 0xd928;\n  *DAT_00000df0 = 0xd2;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dcc",
            "calling": [
                "FUN_00000db0"
            ],
            "imported": true,
            "current_name": "set_data_values_00000dcc"
        },
        "FUN_0000285c": {
            "renaming": {
                "FUN_0000285c": "set_flag_and_save_data_0000285c",
                "param_1": "data",
                "puVar1": "data_ptr"
            },
            "code": "void set_flag_and_save_data_0000285c(int data) {\n  int* data_ptr = DAT_00002890;\n  data_ptr[5] &= 0xffffffef;\n  *data_ptr = data;\n  data_ptr[5] |= 0x10;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000285c",
            "calling": [
                "FUN_00002600"
            ],
            "imported": true,
            "current_name": "set_flag_and_save_data_0000285c"
        },
        "FUN_00000e58": {
            "renaming": {
                "is_interrupts_enabled_in_privileged_mode_00000cd0": "isInterruptsEnabledInPrivilegedMode",
                "FUN_00000e58": "waitForInterrupts_00000e58",
                "interrupts_enabled": "interruptsEnabled"
            },
            "code": "void waitForInterrupts_00000e58(void)\n{\n  bool interrupts_enabled = is_interrupts_enabled_in_privileged_mode_00000cd0();\n  do {\n    // Do nothing, wait for interrupts\n  } while(interrupts_enabled);\n}",
            "called": [
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e58",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": true,
            "current_name": "waitForInterrupts_00000e58"
        },
        "FUN_00001778": {
            "renaming": {
                "DAT_000017d8": "offset",
                "FUN_00001778": "set_offset_and_flag_00001778",
                "DAT_000017d0": "data"
            },
            "code": "void set_offset_and_flag_00001778(byte* DAT_000017d0, byte* DAT_000017d8, byte flag) {\n  *(DAT_000017d0 + 1) = *(DAT_000017d0 + 1) & 0xCF | flag;\n  set_DAT_000017d8_to_zero(DAT_000017d8, 2);\n  return;\n}",
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001778",
            "calling": [
                "FUN_0000191c",
                "FUN_000019c0"
            ],
            "imported": true,
            "current_name": "set_offset_and_flag_00001778"
        },
        "FUN_000026d8": {
            "renaming": {
                "FUN_000026d8": "set_data_access_flag_and_return_000026d8",
                "set_flag_for_data_access_0000294c": "set_data_access_flag"
            },
            "code": "void set_data_access_flag_and_return_000026d8(void)\n{\n  set_data_access_flag();\n  return;\n}",
            "called": [
                "FUN_0000294c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026d8",
            "calling": [
                "FUN_00003524"
            ],
            "imported": true,
            "current_name": "set_data_access_flag_and_return_000026d8"
        },
        "FUN_00000566": {
            "renaming": {
                "bVar2": "b2",
                "bVar1": "b1",
                "bVar4": "b4",
                "bVar3": "b3",
                "FUN_00000566": "count_leading_zeroes_of_int_00000566",
                "param_1": "num",
                "uVar5": "result"
            },
            "code": "uint32_t count_leading_zeroes_of_int_00000566(uint32_t num) {\n  uint8_t b1 = (uint8_t)num;\n  uint8_t b2 = (uint8_t)(num >> 8);\n  uint8_t b3 = (uint8_t)(num >> 16);\n  uint8_t b4 = (uint8_t)(num >> 24);\n  uint32_t result = count_leading_zeroes((uint32_t)(((((b1 & 1) << 1 | b1 >> 1 & 1) << 1 | b1 >> 2 & 1) << 1 | b1 >> 3 & 1) << 1 | b1 >> 4 & 1) << 1 | b1 >> 5 & 1) << 1 | b1 >> 6 & 1) << 1 | b1 >> 7 & 1) << 24 | count_leading_zeroes((uint32_t)(((((b2 & 1) << 1 | b2 >> 1 & 1) << 1 | b2 >> 2 & 1) << 1 | b2 >> 3 & 1) << 1 | b2 >> 4 & 1) << 1 | b2 >> 5 & 1) << 1 | b2 >> 6 & 1) << 1 | b2 >> 7 & 1) << 16 | count_leading_zeroes((uint32_t)(((((b3 & 1) << 1 | b3 >> 1 & 1) << 1 | b3 >> 2 & 1) << 1 | b3 >> 3 & 1) << 1 | b3 >> 4 & 1) << 1 | b3 >> 5 & 1) << 1 | b3 >> 6 & 1) << 1 | b3 >> 7 & 1) << 8 | count_leading_zeroes((uint32_t)(((((b4 & 1) << 1 | b4 >> 1 & 1) << 1 | b4 >> 2 & 1) << 1 | b4 >> 3 & 1) << 1 | b4 >> 4 & 1) << 1 | b4 >> 5 & 1) << 1 | b4 >> 6 & 1) << 1 | b4 >> 7 & 1);\n  if (num == 0) {\n    result = 0xffffffff;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000566",
            "calling": [
                "FUN_00000610"
            ],
            "imported": true,
            "current_name": "count_leading_zeroes_of_int_00000566"
        },
        "FUN_00001d08": {
            "renaming": {
                "FUN_00001d08": "calculate_result_00001d08",
                "param_1": "input_value",
                "param_2": "multiplier",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "int calculate_result_00001d08(uint input_value, int multiplier){\n    int shifted_input = (input_value & 0xfffff) << 5;\n    int masked_input = (input_value & 0xf0000000);\n    int constant = 0x2000000;\n    return (multiplier * 4) + masked_input + shifted_input + constant;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d08",
            "calling": [
                "FUN_00001d3a"
            ],
            "imported": true,
            "current_name": "calculate_result_00001d08"
        },
        "FUN_000031fc": {
            "renaming": {
                "bVar1": "clamped_range_byte",
                "iVar2": "clamped_range",
                "clamped_value": "clamped_value",
                "FUN_000031fc": "calculate_value_000031fc",
                "param_1": "value",
                "result": "result",
                "param_2": "range",
                "param_3": "offset"
            },
            "code": "int calculate_value_000031fc(int value, int range, int offset)\n{\n  int clamped_range = range < 3 ? 1 : range > 2 ? 0 : range;\n  int clamped_value = value - clamped_range;\n  if (clamped_value < 0) {\n    clamped_value += 3;\n  }\n  int result = ((clamped_value >> 2) + value) - ((long long)DAT_00003280 * (long long)value >> 37) + ((long long)DAT_00003280 * (long long)value >> 39) + *(int *)(DAT_00003284 + (range - 1) * 4) + offset;\n  return result + ((((long long)DAT_00003288 * (long long)result >> 32) + result) >> 2) - (result >> 31) * 7;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031fc",
            "calling": [
                "FUN_0000328c"
            ],
            "imported": true,
            "current_name": "calculate_value_000031fc"
        },
        "FUN_000016ec": {
            "renaming": {
                "param_1": "base_address",
                "FUN_000016ec": "set_offset_to_one_000016ec",
                "param_2": "offset_value",
                "puVar1": "offset_address"
            },
            "code": "void set_offset_to_one_000016ec(int base_address, char offset_value)\n{\n  char *offset_address = (char *) calculate_offset(base_address, offset_value);\n  *offset_address = 1;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016ec",
            "calling": [
                "FUN_00001a3c",
                "FUN_00001778",
                "FUN_00001a18",
                "FUN_00001a60",
                "FUN_0000182c"
            ],
            "imported": true,
            "current_name": "set_offset_to_one_000016ec"
        },
        "FUN_00005100": {
            "renaming": {
                "FUN_00005100": "FUNC_00005100"
            },
            "code": "\nvoid FUNC_00005100(void)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined4 *puVar3;\n  undefined4 uVar4;\n  int iVar5;\n  char *pcVar6;\n  int iVar7;\n  int iVar8;\n  char cVar9;\n  char *pcVar10;\n  bool bVar11;\n  ushort *puVar12;\n  int *piVar13;\n  ushort *puVar14;\n  int *piVar15;\n  ushort local_3c;\n  ushort local_3a;\n  ushort local_38;\n  ushort local_36;\n  ushort local_34;\n  ushort local_32;\n  int local_30;\n  char *local_2c [2];\n  \n  uVar4 = *DAT_00005108;\n  iVar5 = get_data_000056b0();\n  puVar1 = PTR_DAT_000053d8;\n  pcVar6 = (char *)find_matching_string_000056a0(uVar4,PTR_DAT_000053d4);\n  puVar2 = PTR_DAT_000053e0;\n  if (pcVar6 == (char *)0x0) {\n    *(undefined4 *)PTR_DAT_000053dc = 0;\n    *(undefined4 *)PTR_DAT_000053e4 = 0;\n    puVar3 = DAT_000053e8;\n    uVar4 = *(undefined4 *)puVar1;\n    *DAT_000053e8 = puVar2;\n    puVar3[1] = puVar2;\n    insert_element_to_data_array_00005780(uVar4);\n    *(undefined4 *)puVar1 = 0;\n  }\n  else if ((*(int *)puVar1 == 0) || (iVar7 = compare_bytes_00004e52(), iVar7 != 0)) {\n    insert_element_to_data_array_00005780(*(undefined4 *)puVar1);\n    iVar7 = find_end_of_string_00005ecc(pcVar6);\n    iVar7 = allocate_memory_block_00004bd0(uVar4,iVar7 + 1);\n    *(int *)puVar1 = iVar7;\n    if (iVar7 != 0) {\n      copy_string_00005ebc(iVar7,pcVar6);\n    }\n    if (*pcVar6 == ':') {\n      pcVar6 = pcVar6 + 1;\n    }\n    iVar7 = process_data_00005e68(pcVar6,PTR_s__10__0_9_____n_000053f0,PTR_DAT_000053ec,&local_30);\n    if (0 < iVar7) {\n      pcVar10 = pcVar6 + local_30;\n      if (pcVar6[local_30] == '-') {\n        pcVar10 = pcVar10 + 1;\n        iVar7 = -1;\n      }\n      else {\n        if (pcVar6[local_30] == '+') {\n          pcVar10 = pcVar10 + 1;\n        }\n        iVar7 = 1;\n      }\n      local_3a = 0;\n      local_38 = 0;\n      puVar12 = &local_3a;\n      piVar13 = &local_30;\n      puVar14 = &local_38;\n      piVar15 = &local_30;\n      iVar8 = process_data_00005e68(pcVar10,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a,\n                           &local_30,&local_38,&local_30);\n      puVar1 = PTR_DAT_00005400;\n      if (0 < iVar8) {\n        *(uint *)(iVar5 + 0x28) =\n             ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar7;\n        puVar3 = DAT_000053e8;\n        *DAT_000053e8 = PTR_DAT_000053ec;\n        pcVar10 = pcVar10 + local_30;\n        iVar7 = process_data_00005e68(pcVar10,PTR_s__10__0_9_____n_000053f0,puVar1,&local_30,puVar12,piVar13,\n                             puVar14,piVar15);\n        if (iVar7 < 1) {\n          puVar3[1] = *puVar3;\n          *(undefined4 *)PTR_DAT_000053dc = *(undefined4 *)(iVar5 + 0x28);\n          *(undefined4 *)PTR_DAT_000053e4 = 0;\n        }\n        else {\n          puVar3[1] = puVar1;\n          pcVar6 = pcVar10 + local_30;\n          if (pcVar10[local_30] == '-') {\n            pcVar6 = pcVar6 + 1;\n            iVar7 = -1;\n          }\n          else {\n            if (pcVar10[local_30] == '+') {\n              pcVar6 = pcVar6 + 1;\n            }\n            iVar7 = 1;\n          }\n          local_3c = 0;\n          local_3a = 0;\n          local_38 = 0;\n          local_30 = 0;\n          iVar8 = process_data_00005e68(pcVar6,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a\n                               ,&local_30,&local_38,&local_30);\n          if (iVar8 < 1) {\n            iVar7 = *(int *)(iVar5 + 0x28) + -0xe10;\n          }\n          else {\n            iVar7 = ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar7;\n          }\n          *(int *)(iVar5 + 0x50) = iVar7;\n          pcVar6 = pcVar6 + local_30;\n          bVar11 = false;\n          iVar7 = iVar5;\n          while( true ) {\n            if (*pcVar6 == ',') {\n              pcVar6 = pcVar6 + 1;\n            }\n            cVar9 = *pcVar6;\n            if (cVar9 == 'M') {\n              iVar8 = process_data_00005e68(pcVar6,PTR_s_M_hu_n__hu_n__hu_n_000053f8,&local_36,&local_30,\n                                   &local_34,&local_30,&local_32,&local_30);\n              if (iVar8 != 3) {\n                return;\n              }\n              if (0xb < local_36 - 1) {\n                return;\n              }\n              if (4 < local_34 - 1) {\n                return;\n              }\n              if (6 < local_32) {\n                return;\n              }\n              *(uint *)(iVar7 + 0xc) = (uint)local_36;\n              *(uint *)(iVar7 + 0x10) = (uint)local_34;\n              *(undefined *)(iVar7 + 8) = 0x4d;\n              *(uint *)(iVar7 + 0x14) = (uint)local_32;\n              pcVar10 = pcVar6 + local_30;\n            }\n            else {\n              if (cVar9 == 'J') {\n                pcVar6 = pcVar6 + 1;\n              }\n              else {\n                cVar9 = 'D';\n              }\n              local_32 = parse_uint_from_string_wrapper_00005fd8(pcVar6,local_2c,10);\n              pcVar10 = local_2c[0];\n              if (local_2c[0] == pcVar6) {\n                if (bVar11) {\n                  *(undefined *)(iVar5 + 0x30) = 0x4d;\n                  *(undefined4 *)(iVar5 + 0x34) = 0xb;\n                  *(undefined4 *)(iVar5 + 0x38) = 1;\n                  *(undefined4 *)(iVar5 + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(iVar5 + 8) = 0x4d;\n                  *(undefined4 *)(iVar5 + 0xc) = 3;\n                  *(undefined4 *)(iVar5 + 0x10) = 2;\n                  *(undefined4 *)(iVar5 + 0x14) = 0;\n                }\n              }\n              else {\n                *(char *)(iVar7 + 8) = cVar9;\n                *(uint *)(iVar7 + 0x14) = (uint)local_32;\n              }\n            }\n            local_3c = 2;\n            local_3a = 0;\n            local_38 = 0;\n            local_30 = 0;\n            if (*pcVar10 == '/') {\n              process_data_00005e68(pcVar10,PTR_DAT_000053fc,&local_3c,&local_30,&local_3a,&local_30,\n                           &local_38,&local_30);\n            }\n            *(uint *)(iVar7 + 0x18) =\n                 (uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38;\n            iVar7 = iVar7 + 0x28;\n            pcVar6 = pcVar10 + local_30;\n            if (bVar11) break;\n            bVar11 = true;\n          }\n          calculate_day_of_week_00004f98(*(undefined4 *)(iVar5 + 4));\n          iVar7 = *(int *)(iVar5 + 0x28);\n          *(int *)PTR_DAT_000053dc = iVar7;\n          iVar7 = *(int *)(iVar5 + 0x50) - iVar7;\n          if (iVar7 != 0) {\n            iVar7 = 1;\n          }\n          *(int *)PTR_DAT_000053e4 = iVar7;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00005ebc",
                "FUN_00004bd0",
                "FUN_00005e68",
                "FUN_00005ecc",
                "FUN_000056b0",
                "FUN_00004f98",
                "FUN_000056a0",
                "FUN_00005780",
                "FUN_00004e52",
                "FUN_00005fd8"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00005100",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "FUNC_00005100"
        },
        "FUN_00005584": {
            "renaming": {
                "uVar1": "remainder",
                "param_1": "result",
                "FUN_00005584": "divide_and_remainder_00005584",
                "param_2": "dividend",
                "param_3": "divisor",
                "uVar2": "quotient"
            },
            "code": "void divide_and_remainder_00005584(uint *result, uint dividend, uint divisor)\n{\n  uint quotient;\n  uint remainder;\n  quotient = dividend / divisor;\n  remainder = dividend % divisor;\n  if (dividend < 0) {\n    if (remainder > 0) {\n      quotient--;\n      remainder += divisor;\n    }\n  }\n  else if (remainder < 0) {\n    quotient++;\n    remainder -= divisor;\n  }\n  *result = quotient;\n  result[1] = remainder;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005584",
            "calling": [
                "FUN_00004634"
            ],
            "imported": true,
            "current_name": "divide_and_remainder_00005584"
        },
        "FUN_00004248": {
            "renaming": {
                "iVar2": "struct_array_size",
                "param_1": "base_address",
                "FUN_00004248": "allocate_and_initialize_array_of_structs_00004248",
                "param_2": "num_structs",
                "puVar1": "struct_array"
            },
            "code": "undefined4 * allocate_and_initialize_array_of_structs_00004248(undefined4 base_address,int num_structs)\n{\n  undefined4 *struct_array;\n  int struct_array_size;\n  \n  struct_array_size = (num_structs - 1) * sizeof(struct my_struct);\n  struct_array = (undefined4 *)allocate_memory_block_00004bd0(base_address,struct_array_size + sizeof(int) + sizeof(undefined4 *));\n  if (struct_array != (undefined4 *)0x0) {\n    *struct_array = 0;\n    struct_array[1] = num_structs;\n    struct_array[2] = struct_array + 3;\n    fill_array_with_value_00004622(struct_array + 3,0,struct_array_size);\n  }\n  return struct_array;\n}",
            "called": [
                "FUN_00004bd0",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004248",
            "calling": [
                "FUN_00004314"
            ],
            "imported": true,
            "current_name": "allocate_and_initialize_array_of_structs_00004248"
        },
        "FUN_00001da2": {
            "renaming": {
                "param_1": "value",
                "FUN_00001da2": "get_bits_from_value_00001da2",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "ushort get_bits_from_value_00001da2(ushort value)\n{\n    ushort bits = value >> 6 & 7;\n    return bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001da2",
            "calling": [
                "FUN_00001ddc",
                "FUN_00001f80"
            ],
            "imported": true,
            "current_name": "get_bits_from_value_00001da2"
        },
        "FUN_00001ec4": {
            "renaming": {
                "uVar1": "bitValue",
                "param_1": "bitfield",
                "update_bits_at_position_00001e44": "updateBitsAtPosition",
                "get_bitfield_value_00001e0c": "getBitfieldValue",
                "param_2": "position",
                "FUN_00001ec4": "updateBitsAtPositionAndGetValue_00001ec4"
            },
            "code": "void updateBitsAtPositionAndGetValue_00001ec4(unsigned int bitfield, unsigned int position)\n{\n  unsigned int bitValue = getBitfieldValue(bitfield, position);\n  updateBitsAtPosition(bitfield, position, bitValue);\n  return;\n}",
            "called": [
                "FUN_00001e44",
                "FUN_00001e0c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ec4",
            "calling": [
                "FUN_00001f80"
            ],
            "imported": true,
            "current_name": "updateBitsAtPositionAndGetValue_00001ec4"
        },
        "FUN_00002744": {
            "renaming": {
                "DAT_00002790": "data_ptr_1",
                "param_1": "data",
                "DAT_00002794": "data_ptr_2",
                "param_2": "value",
                "FUN_00002744": "save_data_00002744"
            },
            "code": "void save_data_00002744(byte data, uint value) {\n  if (data < 0) {\n    *(char *)((data & 0xf) + DAT_00002790 + 0x14) = (char)((value & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)data + DAT_00002794 + 0x300) = (char)((value & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002744",
            "calling": [
                "FUN_00002894"
            ],
            "imported": true,
            "current_name": "save_data_00002744"
        },
        "FUN_00002624": {
            "renaming": {
                "find_first_match_0000281c": "find_first_match",
                "param_1": "timestamp",
                "uStack_c": "result",
                "FUN_00002624": "process_timestamp_to_date_00002624",
                "local_10": "first_match",
                "calculate_date_from_timestamp_0000443c": "calculate_date_from_timestamp"
            },
            "code": "int process_timestamp_to_date_00002624(int timestamp)\n{\n  int first_match = find_first_match();\n  int result = 0;\n  calculate_date_from_timestamp(&first_match, timestamp);\n  return result;\n}",
            "called": [
                "FUN_0000443c",
                "FUN_0000281c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002624",
            "calling": [
                "FUN_00003444"
            ],
            "imported": true,
            "current_name": "process_timestamp_to_date_00002624"
        },
        "FUN_00001e0c": {
            "renaming": {
                "param_1": "index",
                "PTR_DAT_00001e40": "ptr",
                "param_2": "bitfield",
                "FUN_00001e0c": "get_bitfield_value_00001e0c"
            },
            "code": "uint get_bitfield_value_00001e0c(int index, uint bitfield) {\n    uint* PTR_DAT_00001e40 = PTR_DAT_00001e40 + (((int)bitfield >> 3) + index * 4) * 4;\n    uint shifted_value = *PTR_DAT_00001e40 >> ((bitfield & 7) << 2);\n    uint masked_value = shifted_value & 0xf;\n    return masked_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e0c",
            "calling": [
                "FUN_00002028",
                "FUN_00001ec4"
            ],
            "imported": true,
            "current_name": "get_bitfield_value_00001e0c"
        },
        "FUN_00000ef8": {
            "renaming": {
                "FUN_00000ef8": "do_nothing_00000ef8"
            },
            "code": "\nvoid do_nothing_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ef8",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": true,
            "current_name": "do_nothing_00000ef8"
        },
        "FUN_000041d0": {
            "renaming": {
                "iVar2": "data_structure",
                "iVar4": "increment",
                "pcVar1": "function_pointer",
                "iVar6": "sub_data_structure_2",
                "piVar5": "sub_data_structure",
                "iVar8": "sub_data_structure_1",
                "param_1": "mode",
                "puVar9": "pointer",
                "param_2": "arg2",
                "param_3": "arg3",
                "FUN_000041d0": "process_data_000041d0",
                "uVar3": "function_result",
                "uVar7": "result"
            },
            "code": "uint process_data_000041d0(int mode, uint arg2, uint arg3)\n{\n  code *function_pointer = DAT_000041ec;\n  if (mode == 0) {\n    int data_structure = *(int *)PTR_DAT_000041e8;\n    int *sub_data_structure = (int *)(data_structure + 0x48);\n    uint result = 0;\n    undefined *pointer = PTR_DAT_000041e8;\n    do {\n      int sub_data_structure_1 = sub_data_structure[1];\n      int sub_data_structure_2 = sub_data_structure[2];\n      while (sub_data_structure_1 = sub_data_structure_1 + -1, -1 < sub_data_structure_1) {\n        if ((1 < *(ushort *)(sub_data_structure_2 + 0xc)) && (*(short *)(sub_data_structure_2 + 0xe) + 1 != 0)) {\n          uint function_result = (*function_pointer)(data_structure, sub_data_structure_2, arg3, *(short *)(sub_data_structure_2 + 0xe) + 1, pointer);\n          result |= function_result;\n        }\n        sub_data_structure_2 = sub_data_structure_2 + 0x68;\n      }\n      sub_data_structure = (int *)*sub_data_structure;\n    } while (sub_data_structure != (int *)0x0);\n    return result;\n  }\n  uint data = process_data_000041d0_00004158(*DAT_000041f0, mode);\n  return data;\n}",
            "called": [
                "FUN_00004158"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041d0",
            "calling": [
                "FUN_00002e48"
            ],
            "imported": true,
            "current_name": "process_data_000041d0"
        },
        "FUN_0000459c": {
            "renaming": {
                "ppcVar4": "function_ptrs",
                "iVar3": "num_functions",
                "iVar5": "i",
                "puVar2": "end_function_ptr",
                "puVar1": "current_function_ptr",
                "FUN_0000459c": "process_and_execute_functions_0000459c"
            },
            "code": "void process_and_execute_functions_0000459c(void)\n{\n  int num_functions = (int)PTR_DAT_000045d8 - (int)PTR_DAT_000045d4;\n  code **function_ptrs = (code **)PTR_DAT_000045d4;\n  for (int i = 0; i < num_functions; i++) {\n    (**function_ptrs)();\n    function_ptrs++;\n  }\n  process_input_and_return_status_00000410();\n  function_ptrs = (code **)PTR_DAT_000045dc;\n  num_functions = (int)PTR_DAT_000045e0 - (int)PTR_DAT_000045dc;\n  for (int i = 0; i < num_functions; i++) {\n    (**function_ptrs)();\n    function_ptrs++;\n  }\n  return;\n}",
            "called": [
                "FUN_00000410"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000459c",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": true,
            "current_name": "process_and_execute_functions_0000459c"
        },
        "FUN_000014c4": {
            "renaming": {
                "param_1": "index",
                "pbVar1": "data",
                "param_2": "divisor",
                "uVar3": "quotient",
                "uVar2": "data_2",
                "FUN_000014c4": "set_bits_000014c4"
            },
            "code": "void set_bits_000014c4(int index, uint divisor)\n{\n  byte *data = *(byte **)(PTR_DAT_000015cc + index * 0x20);\n  uint data_2 = *(uint *)(PTR_DAT_000015cc + index * 0x20 + 4);\n  data[3] &= 0xf3;\n  data[2] = PTR_DAT_000015cc[index * 0x20 + 0x1d];\n  uint quotient = data_2 / (divisor << 4);\n  *data = (byte)(quotient >> 8) & 0x1f;\n  data[1] = (byte)quotient;\n  data[10] = (byte)(((data_2 << 2) / divisor) + 1 >> 1) & 0x1f;\n  data[0x10] |= 0x88;\n  if ((data[0x10] & 0x70) == 0) {\n    data[0x13] = 0;\n  }\n  else {\n    data[0x13] = (char)(2 << (data[0x10] >> 4 & 7)) - 1;\n  }\n  data[0x15] = 1;\n  data[0x11] = 0xc0;\n  data[3] |= 0x2c;\n  set_bit_in_array_00001318((int)(char)PTR_DAT_000015cc[index * 0x20 + 0x14]);\n  return;\n}",
            "called": [
                "FUN_00001318"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000014c4",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": true,
            "current_name": "set_bits_000014c4"
        },
        "FUN_00004b34": {
            "renaming": {
                "piVar2": "temp_ptr",
                "param_1": "list_start",
                "ppiVar6": "list_ptr",
                "param_2": "element",
                "param_3": "list_size",
                "param_4": "error_code",
                "puVar1": "pointer_data",
                "extraout_r1": "prev_ptr",
                "ppiVar3": "prev_ptr",
                "FUN_00004b34": "insert_element_00004b34",
                "ppiVar4": "curr_ptr",
                "ppiVar5": "list_head",
                "bVar7": "is_head"
            },
            "code": "void insert_element_00004b34(int *list_start, int element, int list_size, int *error_code) {\n  int **list_ptr = (int **)(list_size + -4);\n  if (*list_ptr < 0) {\n    list_ptr = (int **)((int)list_ptr + **list_ptr);\n  }\n  do_nothing_with_pointer_data();\n  int **list_head = *PTR_DAT_00004bcc;\n  if (list_head == NULL) {\n    list_ptr[1] = NULL;\n    *PTR_DAT_00004bcc = list_ptr;\n    int **prev_ptr = (int **)extraout_r1;\n    int **curr_ptr = (int **)PTR_DAT_00004bcc;\n  }\n  else if (list_ptr < list_head) {\n    int **prev_ptr = *list_ptr;\n    int **curr_ptr = (int **)((int)list_ptr + (int)prev_ptr);\n    bool is_head = list_head == curr_ptr;\n    if (is_head) {\n      curr_ptr = (int **)*list_head;\n      list_head = (int **)list_head[1];\n    }\n    list_ptr[1] = (int *)list_head;\n    if (is_head) {\n      curr_ptr = (int **)((int)curr_ptr + (int)prev_ptr);\n      *list_ptr = (int *)curr_ptr;\n    }\n    *PTR_DAT_00004bcc = list_ptr;\n  }\n  else {\n    int **prev_ptr = list_head;\n    int **curr_ptr = (int **)list_head[1];\n    while (curr_ptr != NULL && curr_ptr <= list_ptr) {\n      prev_ptr = curr_ptr;\n      curr_ptr = (int **)curr_ptr[1];\n    }\n    int **prev_data_ptr = *prev_ptr;\n    if ((int **)((int)prev_ptr + (int)prev_data_ptr) == list_ptr) {\n      prev_data_ptr = (int **)((int)prev_data_ptr + (int)*list_ptr);\n      *prev_ptr = (int *)prev_data_ptr;\n      if (curr_ptr == (int **)((int)prev_ptr + (int)prev_data_ptr)) {\n        int *next_data_ptr = *curr_ptr;\n        prev_ptr[1] = curr_ptr[1];\n        prev_data_ptr = (int **)((int)prev_data_ptr + (int)next_data_ptr);\n        *prev_ptr = (int *)prev_data_ptr;\n      }\n    }\n    else if (list_ptr < (int **)((int)prev_ptr + (int)prev_data_ptr)) {\n      *error_code = 0xc;\n    }\n    else {\n      int **next_data_ptr = (int **)((int)list_ptr + (int)*list_ptr);\n      bool is_head = curr_ptr == next_data_ptr;\n      if (is_head) {\n        next_data_ptr = (int **)*curr_ptr;\n        curr_ptr = (int **)curr_ptr[1];\n      }\n      list_ptr[1] = (int *)curr_ptr;\n      if (is_head) {\n        next_data_ptr = (int **)((int)next_data_ptr + (int)*list_ptr);\n        *list_ptr = (int *)next_data_ptr;\n      }\n      prev_ptr[1] = (int *)list_ptr;\n    }\n  }\n  do_nothing_with_pointer(error_code, prev_ptr, curr_ptr, *PTR_DAT_00004be0);\n  return;\n}",
            "called": [
                "FUN_00005790",
                "FUN_0000579c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004b34",
            "calling": [
                "FUN_000054a8",
                "FUN_000060cc",
                "FUN_00006768",
                "FUN_00005780",
                "FUN_00006192",
                "FUN_0000404c"
            ],
            "imported": true,
            "current_name": "insert_element_00004b34"
        },
        "FUN_000004f2": {
            "renaming": {
                "*param_1": "*param",
                "FUN_000004f2": "set_param_to_19_000004f2"
            },
            "code": "void set_param_to_19_000004f2(int *param)\n{\n  *param = 19;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004f2",
            "calling": [
                "FUN_00004e26",
                "FUN_00004dee"
            ],
            "imported": true,
            "current_name": "set_param_to_19_000004f2"
        },
        "FUN_00004e66": {
            "renaming": {
                "FUN_00004e66": "compare_strings_00004e66",
                "param_1": "input_string",
                "pbVar1": "input_string_ptr",
                "pbVar2": "comparison_string",
                "param_2": "input_length",
                "param_3": "comparison_length",
                "uVar3": "current_char"
            },
            "code": "int compare_strings_00004e66(byte *input_string, int input_length, int comparison_length) {\n  byte *comparison_string;\n  byte *input_string_ptr;\n  uint current_char;\n  if (comparison_length != 0) {\n    comparison_string = (byte *)(input_length + -1);\n    input_string_ptr = input_string;\n    do {\n      current_char = (uint)*input_string_ptr;\n      comparison_string = comparison_string + 1;\n      if ((current_char != *comparison_string) || (input_string_ptr + 1 == input_string + comparison_length)) break;\n      input_string_ptr = input_string_ptr + 1;\n    } while (current_char != 0);\n    comparison_length = current_char - *comparison_string;\n  }\n  return comparison_length;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e66",
            "calling": [
                "FUN_00003524",
                "FUN_0000562c"
            ],
            "imported": true,
            "current_name": "compare_strings_00004e66"
        },
        "FUN_00005ecc": {
            "renaming": {
                "FUN_00005ecc": "find_end_of_string_00005ecc",
                "pcVar2": "next_char",
                "pcVar3": "current_char",
                "param_1": "str",
                "cVar1": "current_char_value"
            },
            "code": "char* find_end_of_string_00005ecc(char* str) {\n  char* current_char = str;\n  while (*current_char != '\\0') {\n    current_char++;\n  }\n  return current_char;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ecc",
            "calling": [
                "FUN_00005e68",
                "FUN_00005100"
            ],
            "imported": true,
            "current_name": "find_end_of_string_00005ecc"
        },
        "FUN_0000129c": {
            "renaming": {
                "FUN_0000129c": "add_node_to_linked_list_0000129c",
                "param_1": "new_node_value",
                "1": "position"
            },
            "code": "void add_node_to_linked_list_0000129c(int new_node_value, int position) {\n  add_node_to_linked_list_0000129c_00002434(new_node_value, position);\n  return;\n}",
            "called": [
                "FUN_00002434"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000129c",
            "calling": [
                "FUN_000012e2"
            ],
            "imported": true,
            "current_name": "add_node_to_linked_list_0000129c"
        },
        "FUN_00001628": {
            "renaming": {
                "(**(code **)(PTR_DAT_00001684 + param_1 * 8))": "func_ptr",
                "FUN_00001628": "check_and_call_function_00001628",
                "(*(byte *)(*(int *)(PTR_DAT_00001680 + param_1 * 0x20) + 4) & 0x20)": "(flag & 0x20)",
                "param_1": "index",
                "*(undefined4 *)(PTR_DAT_00001684 + param_1 * 8 + 4)": "arg1",
                "PTR_DAT_00001680": "ptr1",
                "*(byte *)(*(int *)(PTR_DAT_00001680 + param_1 * 0x20) + 4)": "flag",
                "*(undefined *)(*(int *)(PTR_DAT_00001680 + param_1 * 0x20) + 7)": "arg2",
                "*(int *)(PTR_DAT_00001684 + param_1 * 8)": "*ptr2",
                "PTR_DAT_00001684": "ptr2"
            },
            "code": "void check_and_call_function_00001628(int index)\n{\n    int* PTR_DAT_00001680 = (int*)(PTR_DAT_00001680 + index * 0x20);\n    int* PTR_DAT_00001684 = (int*)(PTR_DAT_00001684 + index * 8);\n\n    byte *(byte *)(*(int *)(PTR_DAT_00001680 + param_1 * 0x20) + 4) = *(byte*)(PTR_DAT_00001680 + 1);\n    if ((*(byte *)(*(int *)(PTR_DAT_00001680 + param_1 * 0x20) + 4) & 0x20) && (*(int *)(PTR_DAT_00001684 + param_1 * 8) != 0)) {\n        code* (**(code **)(PTR_DAT_00001684 + param_1 * 8)) = *(code**)(PTR_DAT_00001684);\n        int *(undefined4 *)(PTR_DAT_00001684 + param_1 * 8 + 4) = *(int*)(PTR_DAT_00001684 + 1);\n        undefined *(undefined *)(*(int *)(PTR_DAT_00001680 + param_1 * 0x20) + 7) = *(undefined*)(PTR_DAT_00001680 + 7);\n        (**(code **)(PTR_DAT_00001684 + param_1 * 8))(*(undefined4 *)(PTR_DAT_00001684 + param_1 * 8 + 4), *(undefined *)(*(int *)(PTR_DAT_00001680 + param_1 * 0x20) + 7));\n    }\n\n    checkFlagAndSetIfTrue_00001348();\n    return;\n}",
            "called": [
                "FUN_00001348"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001628",
            "calling": [
                "FUN_00001688"
            ],
            "imported": true,
            "current_name": "check_and_call_function_00001628"
        },
        "FUN_00001748": {
            "renaming": {
                "FUN_00001748": "set_param_00001748",
                "byte": "byte",
                "param_1": "new_param",
                "DAT_00001774": "PTR_data",
                "* (byte *) (PTR_data + 3)": "param_ptr",
                "*(byte *)(PTR_data + 3) & 0x1f": "old_param"
            },
            "code": "void set_param_00001748(byte new_param){\n  byte* * (byte *) (DAT_00001774 + 3) = (byte*)(DAT_00001774 + 3);\n  byte *(byte *)(DAT_00001774 + 3) & 0x1f = ** (byte *) (DAT_00001774 + 3);\n  ** (byte *) (DAT_00001774 + 3) = (new_param | (*(byte *)(DAT_00001774 + 3) & 0x1f & 0x1f));\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001748",
            "calling": [
                "FUN_0000191c",
                "FUN_000018bc",
                "FUN_00001bb8",
                "FUN_000019c0",
                "FUN_00001960"
            ],
            "imported": true,
            "current_name": "set_param_00001748"
        },
        "FUN_0000294c": {
            "renaming": {
                "FUN_0000294c": "set_flag_for_data_access_0000294c",
                "DAT_0000296c": "data_start_pointer"
            },
            "code": "void set_flag_for_data_access_0000294c(void)\n{\n  uint32_t* data_pointer = (uint32_t*)(DAT_0000296c + 0x14);\n  uint32_t flag = 0x10;\n  *data_pointer |= flag;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000294c",
            "calling": [
                "FUN_000027b0",
                "FUN_000026d8"
            ],
            "imported": true,
            "current_name": "set_flag_for_data_access_0000294c"
        },
        "FUN_00005790": {
            "renaming": {
                "FUN_00005790": "do_nothing_with_pointer_data_00005790",
                "PTR_DAT_00005798": "PTR_DATA"
            },
            "code": "void do_nothing_with_pointer_data_00005790(void)\n{\n  do_nothing(PTR_DAT_00005798);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005790",
            "calling": [
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "imported": true,
            "current_name": "do_nothing_with_pointer_data_00005790"
        },
        "FUN_00000534": {
            "renaming": {
                "uVar1": "is_valid",
                "FUN_00000534": "is_valid_input_00000534",
                "param_1": "input",
                "param_2": "input_length"
            },
            "code": "int is_valid_input_00000534(int *input, int input_length)\n{\n  int is_valid = 0;\n  if (((input_length == 0) || (input_length == 1)) || (input_length == 2)) {\n    is_valid = 1;\n  }\n  return is_valid;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000534",
            "calling": [
                "FUN_00005700"
            ],
            "imported": true,
            "current_name": "is_valid_input_00000534"
        },
        "FUN_000017dc": {
            "renaming": {
                "PTR_DAT_00001828": "pointer_to_data",
                "set_offset_to_one_000016c8": "set_offset_to_one",
                "FUN_000017dc": "set_offset_and_enable_flag_000017dc",
                "DAT_00001820": "data_pointer_1",
                "DAT_00001824": "data_pointer_2"
            },
            "code": "void set_offset_and_enable_flag_000017dc(void)\n{\n  set_offset_to_one(DAT_00001820, 0x1d);\n  if ((*(uint *)(DAT_00001824 + 0x10) & 0x100) == 0) {\n    *(undefined4 *)(DAT_00001824 + 0x10) = 0x104;\n  }\n  *PTR_DAT_00001828 = (*PTR_DAT_00001828 & 0xfff3ffff) | 0x80000;\n  return;\n}",
            "called": [
                "FUN_000016c8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000017dc",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": true,
            "current_name": "set_offset_and_enable_flag_000017dc"
        },
        "FUN_00000410": {
            "renaming": {
                "FUN_00000410": "process_input_and_return_status_00000410"
            },
            "code": "void process_input_and_return_status_00000410(void)\n{\n  process_input_and_return_status_00000410_00000df4();\n  return;\n}",
            "called": [
                "FUN_00000df4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000410",
            "calling": [
                "FUN_0000459c"
            ],
            "imported": true,
            "current_name": "process_input_and_return_status_00000410"
        },
        "FUN_000005ca": {
            "renaming": {
                "param_1": "head_ptr",
                "FUN_000005ca": "reverse_linked_list_000005ca",
                "puVar1": "next_node_ptr"
            },
            "code": "undefined4 * reverse_linked_list_000005ca(int *head_ptr)\n{\n  undefined4 *next_node_ptr;\n  if (*head_ptr == 0) {\n    next_node_ptr = (undefined4 *)0x0;\n  }\n  else {\n    next_node_ptr = *(undefined4 **)*head_ptr;\n    if (next_node_ptr == (undefined4 *)*head_ptr) {\n      *head_ptr = 0;\n    }\n    else {\n      *(undefined4 *)*head_ptr = *next_node_ptr;\n    }\n  }\n  return next_node_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000005ca",
            "calling": [
                "FUN_00000698"
            ],
            "imported": true,
            "current_name": "reverse_linked_list_000005ca"
        },
        "FUN_00005ff8": {
            "renaming": {
                "DAT_00006000": "data_pointer",
                "FUN_00005ff8": "do_nothing_and_return_00005ff8",
                "do_nothing_000045ec": "do_nothing"
            },
            "code": "void do_nothing_and_return_00005ff8(void)\n{\n  do_nothing(DAT_00006000);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ff8",
            "calling": [
                "FUN_0000562c"
            ],
            "imported": true,
            "current_name": "do_nothing_and_return_00005ff8"
        },
        "FUN_00002714": {
            "renaming": {
                "param_1": "bit_position",
                "DAT_00002740": "array",
                "FUN_00002714": "set_bit_in_array_00002714"
            },
            "code": "void set_bit_in_array_00002714(uint8_t bit_position, uint32_t* DAT_00002740){\n  uint8_t DAT_00002740_index = bit_position >> 5;\n  uint8_t bit_offset = bit_position & 0x1f;\n  uint32_t* target_word = (uint32_t*)(DAT_00002740 + DAT_00002740_index);\n  *target_word |= (1 << bit_offset);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002714",
            "calling": [
                "FUN_00002894"
            ],
            "imported": true,
            "current_name": "set_bit_in_array_00002714"
        },
        "FUN_000020e0": {
            "renaming": {
                "process_flags_00002028": "process_flags",
                "DAT_000020f0": "PTR_FLAGS_DATA",
                "FUN_000020e0": "process_flags_and_return_000020e0"
            },
            "code": "void process_flags_and_return_000020e0(void)\n{\n  int flags = 2;\n  process_flags(DAT_000020f0, flags);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020e0",
            "calling": [],
            "imported": true,
            "current_name": "process_flags_and_return_000020e0"
        },
        "FUN_00005fec": {
            "renaming": {
                "do_nothing_000045e8": "do_nothing",
                "DAT_00005ff4": "DAT_data",
                "FUN_00005fec": "do_nothing_with_data_00005fec"
            },
            "code": "void do_nothing_with_data_00005fec(void)\n{\n  do_nothing(DAT_00005ff4);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fec",
            "calling": [
                "FUN_0000562c"
            ],
            "imported": true,
            "current_name": "do_nothing_with_data_00005fec"
        },
        "FUN_00004f84": {
            "renaming": {
                "uVar1": "result",
                "iVar5": "divisor",
                "pbVar9": "inputString",
                "param_1": "inputString",
                "pbVar8": "currentChar",
                "param_2": "nextChar",
                "param_3": "base",
                "uVar3": "charFlag",
                "uVar2": "digitChar",
                "uVar5": "compareResult",
                "uVar4": "digitValue",
                "uVar7": "maxDivisor",
                "uVar6": "maxUint",
                "FUN_00004f84": "convertStringToNumber_00004f84"
            },
            "code": "uint convertStringToNumber_00004f84(byte *inputString, byte **nextChar, uint base)\\\n{\\n\\\n  uint result = 0;\\\n  uint sign = 0;\\\n  uint digitValue;\\\n  byte currentChar;\\\n  uint maxUint = 0x7fffffff;\\\n  int compareResult;\\\n  uint maxDivisor;\\\n  uint divisor;\\\n  while (isspace(*inputString))\\\n  {\\\n    inputString++;\\\n  }\\\n  currentChar = *inputString;\\\n  if (currentChar == \"-\")\\\n  {\\\n    sign = 1;\\\n    inputString++;\\\n  }\\\n  else if (currentChar == \"+\")\\\n  {\\\n    inputString++;\\\n  }\\\n  if (base == 0)\\\n  {\\\n    if (*inputString != \"0\")\\\n    {\\\n      base = 10;\\\n      goto baseDetermined;\\\n    }\\\n  }\\\n  else if (base != 16 || *inputString != \"0\")\\\n  {\\\n    goto baseDetermined;\\\n  }\\\n  inputString++;\\\n  if ((*inputString & 0xdf) == \"X\")\\\n  {\\\n    base = 16;\\\n    inputString++;\\\n  }\\\n  else\\\n  {\\\n    base = 8;\\\n  }\\\nbaseDetermined:\\\n  maxDivisor = maxUint / base;\\\n  divisor = 0;\\\n  while (currentChar)\\\n  {\\\n    if (isdigit(currentChar))\\\n    {\\\n      digitValue = currentChar - \"0\";\\\n    }\\\n    else if (isupper(currentChar))\\\n    {\\\n      digitValue = currentChar - \"A\" + 10;\\\n    }\\\n    else if (islower(currentChar))\\\n    {\\\n      digitValue = currentChar - \"a\" + 10;\\\n    }\\\n    else\\\n    {\\\n      break;\\\n    }\\\n    if (digitValue >= base)\\\n    {\\\n      break;\\\n    }\\\n    if (divisor != -1)\\\n    {\\\n      compareResult = (maxDivisor < result) || ((maxDivisor == result && (maxUint - base * maxDivisor) < digitValue));\\\n      if (compareResult)\\\n      {\\\n        divisor = -1;\\\n      }\\\n      else\\\n      {\\\n        result = result * base + digitValue;\\\n        divisor = 1;\\\n      }\\\n    }\\\n    currentChar = *(++inputString);\\\n  }\\\n  if (divisor == -1)\\\n  {\\\n    *nextChar = inputString - 1;\\\n    return maxUint;\\\n  }\\\n  else\\\n  {\\\n    if (sign)\\\n    {\\\n      result = -result;\\\n    }\\\n    *nextChar = inputString;\\\n    return result;\\\n  }\\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f84",
            "calling": [
                "FUN_0000328c",
                "FUN_00004042"
            ],
            "imported": true,
            "current_name": "convertStringToNumber_00004f84"
        },
        "FUN_000028f0": {
            "renaming": {
                "FUN_000028f0": "get_dat_value_and_increment_000028f0",
                "DAT_0000290c": "DAT_offset"
            },
            "code": "int get_dat_value_and_increment_000028f0(void)\n{\n    int* ptr_dat = (int *)(DAT_0000290c + 8);\n    int dat_value = *ptr_dat;\n    int incremented_value = dat_value + 1;\n    return incremented_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000028f0",
            "calling": [
                "FUN_00002690"
            ],
            "imported": true,
            "current_name": "get_dat_value_and_increment_000028f0"
        },
        "FUN_00004f98": {
            "renaming": {
                "FUN_00004f98": "calculate_day_of_week_00004f98",
                "uVar10": "leap_years",
                "iVar4": "is_leap_year",
                "iVar6": "days_since_1900",
                "iVar8": "i",
                "param_1": "year",
                "puVar5": "calendar_data_ptr",
                "iVar9": "days_until_weekday",
                "puVar1": "calendar_data",
                "uVar3": "month",
                "uVar2": "result",
                "uVar7": "leap_years"
            },
            "code": "uint32_t calculate_day_of_week_00004f98(uint32_t year)\n{\n  uint32_t *calendar_data = (uint32_t *)get_data_000056b0();\n  if ((int)year < 0x7b2) {\n    return 0;\n  }\n  else {\n    uint32_t leap_years = count_leading_zeroes(year % 400);\n    int32_t days_since_1900 = (year - 0x7b2) * 0x16d + ((int)(year - 0x7b1) >> 2) + (year - 0x76d) / 0xffffff9c + (year - 0x641) / 400;\n    calendar_data[1] = year;\n    uint32_t *calendar_data_ptr = calendar_data;\n    do {\n      uint32_t month = calendar_data_ptr[5];\n      if (*(char *)(calendar_data_ptr + 2) == 'J') {\n        if ((((year & 3) == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n          if ((int)month < 0x3c) {\n            month = 0;\n          }\n          else {\n            month = 1;\n          }\n        }\n        else {\n          month = 0;\n        }\n        month = month + days_since_1900 + month + -1;\n      }\n      else if (*(char *)(calendar_data_ptr + 2) == 'D') {\n        month = days_since_1900 + month;\n      }\n      else {\n        uint32_t leap_year_index = leap_years >> 5;\n        if (((year & 3) == 0) && (year % 100 != 0)) {\n          leap_year_index = 1;\n        }\n        int32_t days_since_new_year = 0;\n        month = days_since_1900;\n        for (int i = 1; i <= calendar_data_ptr[3]; i++) {\n          days_since_new_year += *(int *)(PTR_DAT_000050e4 + i * 4 + leap_year_index * 0x30 + -4);\n          if (month <= days_since_new_year) {\n            month = days_since_1900 + days_since_new_year - (*(int *)(PTR_DAT_000050e4 + i * 4 + leap_year_index * 0x30 + -4) - 7);\n            break;\n          }\n        }\n      }\n      uint32_t days_since_1900_2 = calendar_data_ptr[10] + DAT_000050e0 * month + calendar_data_ptr[6];\n      calendar_data_ptr[8] = days_since_1900_2;\n      calendar_data_ptr[9] = (int)days_since_1900_2 >> 0x1f;\n      calendar_data_ptr = calendar_data_ptr + 10;\n    } while (calendar_data + 0x14 != calendar_data_ptr);\n    uint32_t days_since_1900_3 = calendar_data[9];\n    uint32_t days_since_1900_4 = calendar_data[0x13];\n    *calendar_data = (uint32_t)((int)((days_since_1900_3 - days_since_1900_4) - (uint32_t)(calendar_data[8] < calendar_data[0x12])) < 0 != (SBORROW4(days_since_1900_3,days_since_1900_4) != SBORROW4(days_since_1900_3 - days_since_1900_4,(uint32_t)(calendar_data[8] < calendar_data[0x12]))));\n    return 1;\n  }\n}",
            "called": [
                "FUN_000056b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f98",
            "calling": [
                "FUN_000047e4",
                "FUN_00005100"
            ],
            "imported": true,
            "current_name": "calculate_day_of_week_00004f98"
        },
        "FUN_00004dee": {
            "renaming": {
                "FUN_00004dee": "extract_data_00004dee",
                "uVar1": "result",
                "param_1": "output_buffer",
                "param_2": "input_buffer",
                "param_3": "data_start",
                "param_4": "data_size"
            },
            "code": "int16_t extract_data_00004dee(uint32_t output_buffer, int32_t input_buffer, uint32_t data_start, uint32_t data_size)\n{\n  int16_t result = 0;\n  if ((int32_t)((uint32_t)*(uint16_t *)(input_buffer + 0xc) << 0x17) < 0) {\n    set_data_to_19_000004f2(output_buffer, (int16_t)*(int16_t *)(input_buffer + 0xe), 0, 2);\n  }\n  *(uint16_t *)(input_buffer + 0xc) = *(uint16_t *)(input_buffer + 0xc) & 0xefff;\n  result = copy_data_to_memory_00000e38(data_start, data_size);\n  return result;\n}",
            "called": [
                "FUN_000004f2",
                "FUN_00000e38"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dee",
            "calling": [],
            "imported": true,
            "current_name": "extract_data_00004dee"
        },
        "FUN_00000fec": {
            "renaming": {
                "param_1[2]": "output[2]",
                "FUN_00000fec": "validate_power_of_two_00000fec",
                "param_1": "output",
                "param_1[1]": "output[1]",
                "*param_1": "output[0]",
                "PTR_s_FAILED_ASSERTION__00001030": "PTR_s_FAILED_ASSERTION__00001030",
                "param_2": "input"
            },
            "code": "void validate_power_of_two_00000fec(uint32_t *output, uint32_t input) {\n  if ((input & (input - 1)) != 0) {\n    process_input(3, PTR_s_FAILED_ASSERTION__00001030);\n  }\n  output[0] = 0;\n  output[1] = 0;\n  output[2] = input - 1;\n  return;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000fec",
            "calling": [
                "FUN_000010d4"
            ],
            "imported": true,
            "current_name": "validate_power_of_two_00000fec"
        },
        "FUN_00000428": {
            "renaming": {
                "local_c": "local_address",
                "FUN_00000428": "calculate_local_address_00000428",
                "uVar1": "interrupts_enabled",
                "param_1": "result",
                "param_2": "size"
            },
            "code": "int calculate_local_address_00000428(uint32_t *result, int size)\n{\n  uint32_t interrupts_enabled = is_interrupts_enabled_in_privileged_mode_00000cd0();\n  uint32_t local_address = *(uint32_t *)PTR_Elf32_Rel_ARRAY_00000484;\n  if ((DAT_00000488 < (size + *(int *)PTR_Elf32_Rel_ARRAY_00000484)) || ((size + *(int *)PTR_Elf32_Rel_ARRAY_00000484) < DAT_0000048c)) {\n    *result = 0xc;\n    local_address = 0xffffffff;\n  }\n  else {\n    *(int *)PTR_Elf32_Rel_ARRAY_00000484 = size + *(int *)PTR_Elf32_Rel_ARRAY_00000484;\n  }\n  enable_interrupts_if_privileged_00000d0c(interrupts_enabled);\n  return local_address;\n}",
            "called": [
                "FUN_00000cd0",
                "FUN_00000d0c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000428",
            "calling": [
                "FUN_00004bd0"
            ],
            "imported": true,
            "current_name": "calculate_local_address_00000428"
        },
        "FUN_000039e8": {
            "renaming": {
                "FUN_000039e8": "get_class_by_character_000039e8",
                "param_1": "character",
                "puVar1": "class_ptr"
            },
            "code": "char* get_class_by_character_000039e8(char character) {\n  char* class_ptr = PTR_s_CLASS_UNKNOWN_00003d20;\n  switch(character) {\n    case '\\0':\n      class_ptr = DAT_00003cc0;\n      break;\n    case '@':\n      class_ptr = DAT_00003cc4;\n      break;\n    case 'B':\n      class_ptr = DAT_00003cc8;\n      break;\n    case 'C':\n      class_ptr = PTR_s_ACT_SERVO_00003ccc;\n      break;\n    case 'D':\n      class_ptr = PTR_s_ACT_MOTOR_00003cd0;\n      break;\n    case 'E':\n      class_ptr = PTR_s_ACT_SWITCH_00003cd4;\n      break;\n    case 'F':\n      class_ptr = PTR_s_ACT_DIMMER_00003cd8;\n      break;\n    case -0x80:\n      class_ptr = PTR_s_SENSE_ANY_00003cdc;\n      break;\n    case -0x7f:\n      class_ptr = PTR_s_SENSE_BTN_00003ce0;\n      break;\n    case -0x7e:\n      class_ptr = PTR_s_SENSE_TEMP_00003ce4;\n      break;\n    case -0x7d:\n      class_ptr = PTR_s_SENSE_HUM_00003ce8;\n      break;\n    case -0x7c:\n      class_ptr = PTR_s_SENSE_LIGHT_00003cec;\n      break;\n    case -0x7b:\n      class_ptr = PTR_s_SENSE_ACCEL_00003cf0;\n      break;\n    case -0x7a:\n      class_ptr = PTR_s_SENSE_MAG_00003cf4;\n      break;\n    case -0x79:\n      class_ptr = PTR_s_SENSE_GYRO_00003cf8;\n      break;\n    case -0x78:\n      class_ptr = PTR_s_SENSE_COLOR_00003cfc;\n      break;\n    case -0x77:\n      class_ptr = PTR_s_SENSE_PRESS_00003d00;\n      break;\n    case -0x76:\n      class_ptr = PTR_s_SENSE_ANALOG_00003d04;\n      break;\n    case -0x75:\n      class_ptr = PTR_s_SENSE_UV_00003d08;\n      break;\n    case -0x74:\n      class_ptr = PTR_s_SENSE_OBJTEMP_00003d0c;\n      break;\n    case -0x73:\n      class_ptr = PTR_s_SENSE_PULSE_COUNT_00003d10;\n      break;\n    case -0x72:\n      class_ptr = PTR_s_SENSE_DISTANCE_00003d14;\n      break;\n    case -0x71:\n      class_ptr = PTR_s_SENSE_CO2_00003d18;\n      break;\n    case '\\x01' ... '\\x7f':\n      break;\n    default:\n      if (character == -1) {\n        return PTR_s_CLASS_ANY_00003d1c;\n      }\n  }\n  return class_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000039e8",
            "calling": [
                "FUN_00002f74",
                "FUN_00002ecc"
            ],
            "imported": true,
            "current_name": "get_class_by_character_000039e8"
        },
        "FUN_00000e38": {
            "renaming": {
                "FUN_00000e38": "copy_data_to_memory_00000e38",
                "param_1": "destination_address",
                "copy_data_to_memory_000015d0": "memcpy",
                "param_2": "source_address",
                "return": "source_address"
            },
            "code": "int copy_data_to_memory_00000e38(int destination_address, int source_address, int num_bytes) {\n    memcpy(destination_address, source_address, num_bytes);\n    return source_address;\n}",
            "called": [
                "FUN_000015d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e38",
            "calling": [
                "FUN_00004dee"
            ],
            "imported": true,
            "current_name": "copy_data_to_memory_00000e38"
        },
        "FUN_00002294": {
            "renaming": {
                "bVar3": "is_equal",
                "iVar2": "difference",
                "*(int *)(param_1 + 0xc)": "third_param",
                "uVar1": "is_equal",
                "*(int *)(param_1 + 4)": "expected_difference",
                "FUN_00002294": "is_difference_equal_to_third_param_00002294",
                "param_1": "input_ptr",
                "*(int *)(param_1 + 8)": "second_param"
            },
            "code": "bool is_difference_equal_to_third_param_00002294(int param_1)\n{\n  int difference = *(int *)(param_1 + 0xc) - *(int *)(param_1 + 8);\n  int expected_difference = *(int *)(param_1 + 4);\n  bool is_equal = difference == expected_difference;\n  return is_equal;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002294",
            "calling": [
                "FUN_00002364"
            ],
            "imported": true,
            "current_name": "is_difference_equal_to_third_param_00002294"
        },
        "FUN_00003e9e": {
            "renaming": {
                "uVar1": "num_of_digits",
                "param_1": "num",
                "FUN_00003e9e": "count_digits_and_convert_to_string_00003e9e",
                "param_2": "base",
                "param_3": "string_ptr"
            },
            "code": "int count_digits_and_convert_to_string_00003e9e(int num, short base, int string_ptr)\n{\n  int num_of_digits = convert_integer_to_string_and_count_digits(num, (int)base, string_ptr);\n  return num_of_digits;\n}",
            "called": [
                "FUN_00003ec4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e9e",
            "calling": [
                "FUN_00003694"
            ],
            "imported": true,
            "current_name": "count_digits_and_convert_to_string_00003e9e"
        },
        "FUN_00003378": {
            "renaming": {
                "ptr_s": "ptr_s",
                "param_1": "param_1",
                "PTR_s__04i__02i__02i__02i__02i__02i_000033bc": "PTR_s",
                "*param_1": "*parameters",
                "FUN_00003378": "perform_calculation_00003378",
                "ptr_data": "ptr_data",
                "param_2": "param_2",
                "param_3": "param_3",
                "param_4": "param_4",
                "param_5": "param_5"
            },
            "code": "int perform_calculation_00003378(int *parameters)\n{\n    int result = 0;\n    int param_1 = parameters[0];\n    int param_2 = parameters[1];\n    int param_3 = parameters[2];\n    int param_4 = parameters[3];\n    int param_5 = parameters[4];\n    int ptr_data = param_5 + 0x76c;\n    int ptr_s = param_4 + 1;\n    process_input_and_call_function_00004c84(PTR_s__04i__02i__02i__02i__02i__02i_000033bc__04i__02i__02i__02i__02i__02i_000033bc, ptr_data, ptr_s, param_3, param_2, param_1, *parameters);\n    return result;\n}",
            "called": [
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003378",
            "calling": [
                "FUN_000033c0",
                "FUN_00003444"
            ],
            "imported": true,
            "current_name": "perform_calculation_00003378",
            "code_backup": "\nundefined4 FUN_00003378(undefined4 *param_1)\n\n{\n  FUNC_00004c84(PTR_s__04i__02i__02i__02i__02i__02i_000033bc,param_1[5] + 0x76c,param_1[4] + 1,\n               param_1[3],param_1[2],param_1[1],*param_1);\n  return 0;\n}\n\n"
        },
        "FUN_00006768": {
            "renaming": {
                "iVar2": "result",
                "uVar1": "data_size",
                "flag2": "flag2",
                "flag1": "flag1",
                "param_1": "struct_ptr",
                "FUN_00006768": "process_data_00006768",
                "param_2": "data_ptr",
                "param_3": "data_length",
                "param_4": "param_4",
                "uVar3": "unused",
                "uVar2": "flag3",
                "uVar4": "unused"
            },
            "code": "int process_data_00006768(uint32_t *struct_ptr, uint32_t *data_ptr, uint32_t data_length, uint32_t param_4)\n{\n  uint16_t flag1;\n  int result;\n  uint16_t flag2;\n  uint32_t uVar1;\n  uint32_t uVar2;\n  \n  if ((struct_ptr != NULL) && (struct_ptr[6] == 0)) {\n    initialize_struct_array();\n  }\n  if (data_ptr == (uint32_t *)data_ptr[0x16]) {\n    data_ptr = (uint32_t *)struct_ptr[1];\n  }\n  else if (data_ptr == (uint32_t *)data_ptr[0x1a]) {\n    data_ptr = (uint32_t *)struct_ptr[2];\n  }\n  else if (data_ptr == (uint32_t *)data_ptr[0x1e]) {\n    data_ptr = (uint32_t *)struct_ptr[3];\n  }\n  flag1 = *(uint16_t *)(data_ptr + 3);\n  data_ptr[1] = 0;\n  uVar2 = (uint32_t)*(uint16_t *)(data_ptr + 3);\n  if ((int)(uVar2 << 0x1a) < 0) {\n    return -1;\n  }\n  if ((int)(uVar2 << 0x1d) < 0) {\n    if ((uint32_t *)data_ptr[0xd] != NULL) {\n      if ((uint32_t *)data_ptr[0xd] != data_ptr + 0x11) {\n        insert_element(struct_ptr);\n      }\n      data_ptr[1] = data_ptr[0x10];\n      data_ptr[0xd] = 0;\n      if (data_ptr[0x10] != 0) {\n        *data_ptr = data_ptr[0xf];\n        return 0;\n      }\n    }\n  }\n  else {\n    if (-1 < (int)(uVar2 << 0x1b)) {\n      *struct_ptr = 9;\n      flag1 = flag1 | 0x40;\n      goto LAB_000067b8;\n    }\n    if ((int)(uVar2 << 0x1c) < 0) {\n      result = process_data_00006768_00004158(struct_ptr, data_ptr, uVar2 << 0x1c, uVar2, param_4);\n      if (result != 0) {\n        return -1;\n      }\n      data_ptr[2] = 0;\n      *(uint16_t *)(data_ptr + 3) = *(uint16_t *)(data_ptr + 3) & 0xfff7;\n      data_ptr[6] = 0;\n    }\n    *(uint16_t *)(data_ptr + 3) = *(uint16_t *)(data_ptr + 3) | 4;\n  }\n  if (data_ptr[4] == 0) {\n    allocate_memory(struct_ptr, data_ptr);\n  }\n  flag1 = *(uint16_t *)(data_ptr + 3);\n  uVar1 = data_ptr[4];\n  *data_ptr = uVar1;\n  result = (*(code *)data_ptr[9])(struct_ptr, data_ptr[8], uVar1, data_ptr[5]);\n  data_ptr[1] = result;\n  if (0 < result) {\n    return 0;\n  }\n  flag2 = *(uint16_t *)(data_ptr + 3);\n  if (result != 0) {\n    uVar1 = -1;\n  }\n  else {\n    flag2 = flag2 | 0x20;\n  }\n  if (result != 0) {\n    data_ptr[1] = uVar1;\n    flag1 = flag1 | 0x40;\n  }\nLAB_000067b8:\n  *(uint16_t *)(data_ptr + 3) = flag1;\n  return -1;\n}\n",
            "called": [
                "FUN_000043a0",
                "FUN_00005700",
                "FUN_00004b34",
                "FUN_000042a4",
                "FUN_0000404c",
                "FUN_00004158"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006768",
            "calling": [
                "FUN_00005e10"
            ],
            "imported": true,
            "current_name": "process_data_00006768"
        },
        "FUN_00000db0": {
            "renaming": {
                "clear_memory_00000d9c": "clear_memory",
                "set_data_values_00000dcc": "set_data_values",
                "FUN_00000db0": "initialize_data_and_clear_memory_00000db0"
            },
            "code": "void initialize_data_and_clear_memory_00000db0(void)\n{\n  set_data_values();\n  clear_memory();\n  return;\n}",
            "called": [
                "FUN_00000d9c",
                "FUN_00000dcc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000db0",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": true,
            "current_name": "initialize_data_and_clear_memory_00000db0"
        },
        "FUN_00002600": {
            "renaming": {
                "set_flag_and_save_data_0000285c": "set_processed_data_flag",
                "uVar1": "processed_data",
                "FUNC_000047e4": "apply_data_processing",
                "param_1": "data",
                "FUN_00002600": "process_data_00002600"
            },
            "code": "int process_data_00002600(int data)\n{\n  int processed_data = apply_data_processing(data);\n  set_processed_data_flag(processed_data);\n  return 0;\n}",
            "called": [
                "FUN_000047e4",
                "FUN_0000285c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002600",
            "calling": [
                "FUN_00003478"
            ],
            "imported": true,
            "current_name": "process_data_00002600"
        },
        "FUN_00003810": {
            "renaming": {
                "param_1": "label_id",
                "FUN_00003810": "get_label_00003810",
                "puVar1": "label"
            },
            "code": "char* get_label_00003810(int label_id) {\n    char* label = PTR_LAB_00003914;\n    switch(label_id) {\n        case 2:\n            label = PTR_LAB_000038cc;\n            break;\n        case 3:\n            label = PTR_LAB_000038d0;\n            break;\n        case 4:\n            label = PTR_LAB_000038d4;\n            break;\n        case 5:\n            label = PTR_LAB_000038d8;\n            break;\n        case 6:\n            label = PTR_LAB_000038dc;\n            break;\n        case 7:\n            label = PTR_LAB_000038e0;\n            break;\n        case 8:\n            label = PTR_LAB_000038e4;\n            break;\n        case 9:\n            label = PTR_LAB_000038e8;\n            break;\n        case 10:\n            label = PTR_LAB_000038ec;\n            break;\n        case 11:\n            label = PTR_LAB_000038f0;\n            break;\n        case 12:\n            label = PTR_LAB_000038f4;\n            break;\n        case 13:\n            label = PTR_LAB_000038f8;\n            break;\n        case 14:\n            label = PTR_LAB_000038fc;\n            break;\n        case 15:\n            label = PTR_LAB_00003900;\n            break;\n        case 16:\n            label = PTR_LAB_00003904;\n            break;\n        case 17:\n            label = PTR_LAB_0000390c;\n            break;\n        case 19:\n            label = PTR_LAB_00003910;\n            break;\n        case 21:\n            label = PTR_LAB_00003908;\n            break;\n    }\n    return label;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003810",
            "calling": [
                "FUN_00003694"
            ],
            "imported": true,
            "current_name": "get_label_00003810"
        },
        "FUN_00000ed8": {
            "renaming": {
                "FUNC_00004c84": "function_with_pointer",
                "FUN_00000ed8": "call_function_with_pointer_and_link_register_00000ed8",
                "PTR_DAT_00000ef4": "PTR_DATA",
                "in_lr": "link_register"
            },
            "code": "void call_function_with_pointer_and_link_register_00000ed8(void)\n{\n  undefined4 link_register;\n  function_with_pointer(PTR_DAT_00000ef4,function_with_pointer);\n  return;\n}",
            "called": [
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ed8",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": true,
            "current_name": "call_function_with_pointer_and_link_register_00000ed8",
            "code_backup": "\nvoid FUN_00000ed8(void)\n\n{\n  undefined4 in_lr;\n  \n  FUNC_00004c84(PTR_DAT_00000ef4,in_lr);\n  return;\n}\n\n"
        },
        "FUN_000031e0": {
            "renaming": {
                "FUNC_00004db8": "triggerAlarm",
                "FUN_000031e0": "alarmRangNotification_000031e0"
            },
            "code": "void alarmRangNotification_000031e0(void)\n{\n  triggerAlarm(PTR_s_The_alarm_rang_000031f8);\n  return;\n}",
            "called": [
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031e0",
            "calling": [],
            "imported": true,
            "current_name": "alarmRangNotification_000031e0",
            "code_backup": "\nvoid FUN_000031e0(void)\n\n{\n  FUNC_00004db8(PTR_s_The_alarm_rang_000031f8);\n  return;\n}\n\n"
        },
        "FUN_000020f4": {
            "renaming": {
                "DAT_00002104": "PTR_FLAGS",
                "process_flags_00002028": "process_flags",
                "STATUS_OK": "status",
                "FUN_000020f4": "process_flags_and_set_status_000020f4"
            },
            "code": "void process_flags_and_set_status_000020f4(void)\n{\n  int flags = DAT_00002104;\n  int status = STATUS_OK;\n  process_flags(flags, 3);\n  set_status(status);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020f4",
            "calling": [],
            "imported": true,
            "current_name": "process_flags_and_set_status_000020f4"
        },
        "FUN_0000687c": {
            "renaming": {
                "iVar3": "i",
                "param_1": "size",
                "pbVar1": "result",
                "param_2": "data",
                "uVar2": "endChar",
                "uVar5": "currentChar",
                "uVar4": "nextChar",
                "FUN_0000687c": "reverseAndToggle_0000687c",
                "uVar6": "endChar",
                "bVar7": "toggleFlag"
            },
            "code": "byte * reverseAndToggle_0000687c(int size, byte *data) {\n  byte *result;\n  uint currentChar;\n  bool toggleFlag = false;\n  uint nextChar = (uint)*data;\n  if (nextChar == 0x5e) {\n    nextChar = (uint)data[1];\n    data += 2;\n  }\n  else {\n    data++;\n  }\n  int i = size - 1;\n  do {\n    i++;\n    *(bool *)i = toggleFlag;\n  } while (i != size + 0xff);\n  if (nextChar == 0) {\n    result = data - 1;\n  }\n  else {\n    do {\n      currentChar = nextChar;\n      *(bool *)(size + currentChar) = !toggleFlag;\n      data++;\n      while (true) {\n        nextChar = (uint)data[-1];\n        if (nextChar != 0x2d) break;\n        uint endChar = (uint)*data;\n        if ((endChar == 0x5d) || (currentChar > endChar)) goto LAB_000068aa;\n        do {\n          currentChar++;\n          *(bool *)(size + currentChar) = !toggleFlag;\n        } while (currentChar < endChar);\n        int diff = ~(int)currentChar + endChar;\n        if (endChar <= currentChar) {\n          diff = 0;\n        }\n        currentChar = currentChar + 1 + diff;\n        data += 2;\n      }\n      result = data - 1;\n    } while ((nextChar != 0x5d) && (result = data - 1, nextChar != 0));\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000687c",
            "calling": [
                "FUN_000061cc",
                "FUN_0000656c"
            ],
            "imported": true,
            "current_name": "reverseAndToggle_0000687c"
        },
        "FUN_00005edc": {
            "renaming": {
                "bVar3": "is_negative",
                "uVar1": "digit_value",
                "iVar4": "digit_value",
                "param_1": "result",
                "pbVar7": "current_char",
                "pbVar8": "start_char",
                "param_2": "str",
                "param_3": "endptr",
                "param_4": "base",
                "uVar2": "digit",
                "uVar5": "value",
                "FUN_00005edc": "parse_uint_from_string_00005edc",
                "uVar6": "carry_limit"
            },
            "code": "uint parse_uint_from_string_00005edc(undefined4 *result, byte *str, byte **endptr, uint base) {\n  uint digit_value, carry_limit, digit, value = 0;\n  byte *current_char, *start_char;\n  bool is_negative = false;\n\n  // Skip leading whitespace\n  current_char = str;\n  while ((*current_char == ' ') || (*current_char == '\\t')) {\n    current_char++;\n  }\n\n  // Check for sign\n  if (*current_char == '-') {\n    is_negative = true;\n    current_char++;\n  } else if (*current_char == '+') {\n    current_char++;\n  }\n\n  // Determine base if not specified\n  if (base == 0) {\n    if (*current_char != '0') {\n      base = 10;\n    } else if ((*(current_char + 1) & 0xdf) == 'X') {\n      base = 16;\n      current_char += 2;\n    } else {\n      base = 8;\n    }\n  }\n\n  // Parse digits\n  start_char = current_char;\n  carry_limit = 0xffffffff / base;\n  while (true) {\n    digit = *current_char - '0';\n    if (digit > 9) {\n      digit = (*current_char & 0xdf) - 'A' + 10;\n      if (digit > 15) {\n        break;\n      }\n    }\n    if (digit >= base) {\n      break;\n    }\n    if (((digit_value < 0) || (carry_limit < value)) || ((carry_limit == value && ((int)~(base * carry_limit) < (int)digit)))) {\n      digit_value = 0xffffffff;\n      break;\n    } else {\n      value = value * base + digit;\n      digit_value = 1;\n    }\n    current_char++;\n  }\n\n  // Handle errors and return result\n  if (digit_value == 0) {\n    if (endptr != NULL) {\n      *endptr = start_char;\n    }\n    return 0;\n  } else if (is_negative) {\n    value = -value;\n  }\n  if (endptr != NULL) {\n    *endptr = current_char;\n  }\n  *result = (int)value;\n  return digit_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005edc",
            "calling": [
                "FUN_00005fd8"
            ],
            "imported": true,
            "current_name": "parse_uint_from_string_00005edc"
        },
        "FUN_00001eea": {
            "renaming": {
                "FUN_00001eea": "set_flag_value_and_update_bits_00001eea",
                "iVar2": "flag_value_ptr",
                "iVar3": "combined_and_shifted_value",
                "uVar1": "last_six_bits",
                "param_1": "flag_value",
                "param_2": "bit_value"
            },
            "code": "int set_flag_value_and_update_bits_00001eea(uint16_t flag_value, byte bit_value) {\n  update_bits_and_get_value(flag_value, 0);\n  if ((char)bit_value < 0) {\n    uint8_t last_six_bits = get_last_six_bits(flag_value);\n    int flag_value_ptr = get_flag_value_pointer(flag_value);\n    *(uint *)(flag_value_ptr + 0x14) = *(uint *)(flag_value_ptr + 0x14) | 1 << (last_six_bits & 0xff);\n  }\n  else {\n    uint8_t last_six_bits = get_last_six_bits(flag_value);\n    int flag_value_ptr = get_flag_value_pointer(flag_value);\n    *(uint *)(flag_value_ptr + 0x14) = *(uint *)(flag_value_ptr + 0x14) & ~(1 << (last_six_bits & 0xff));\n  }\n  int combined_and_shifted_value = combine_and_shift(flag_value);\n  uint8_t last_six_bits = get_last_six_bits(flag_value);\n  *(uint *)(combined_and_shifted_value + last_six_bits * 4) = bit_value & 0x23 | 0x100;\n  return 0;\n}",
            "called": [
                "FUN_00001d5e",
                "FUN_00001d80",
                "FUN_00001dc0",
                "FUN_00001f80"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001eea",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": true,
            "current_name": "set_flag_value_and_update_bits_00001eea"
        },
        "FUN_000023a4": {
            "renaming": {
                "FUN_000023a4": "processAndExecuteCommands_000023a4",
                "FUNC_00004db8": "initializeMemory",
                "uVar1": "result",
                "auStack_88": "inputBuffer",
                "process_input_and_execute_commands_00002e6c": "processInputAndExecuteCommands"
            },
            "code": "undefined4 processAndExecuteCommands_000023a4(void)\n{\n  undefined4 result;\n  undefined inputBuffer[128];\n  performInterruptCallIfNotDone(0);\n  initializeMemory(uRam000023c4);\n  result = processInputAndExecuteCommands(0, inputBuffer, 0x80);\n  softwareInterrupt(0x3f);\n  return result;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_000023d0",
                "FUN_00002e6c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023a4",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": true,
            "current_name": "processAndExecuteCommands_000023a4"
        },
        "FUN_0000240c": {
            "renaming": {
                "FUN_0000240c": "getNextElementInList_0000240c",
                "param_1": "currentElementPtr",
                "puVar1": "nextElementPtr"
            },
            "code": "undefined4* getNextElementInList_0000240c(undefined4* currentElementPtr)\n{\n  undefined4* nextElementPtr;\n  nextElementPtr = (undefined4*)*currentElementPtr;\n  if (nextElementPtr != (undefined4*)0x0) {\n    *currentElementPtr = *nextElementPtr;\n  }\n  return nextElementPtr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000240c",
            "calling": [
                "FUN_000024bc"
            ],
            "imported": true,
            "current_name": "getNextElementInList_0000240c"
        },
        "FUN_00004280": {
            "renaming": {
                "FUN_00004280": "do_nothing_with_pointer_00004280",
                "PTR_DAT_00004288": "PTR_data"
            },
            "code": "void do_nothing_with_pointer_00004280(void)\n{\n  do_nothing(PTR_DAT_00004288);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004280",
            "calling": [
                "FUN_00004314"
            ],
            "imported": true,
            "current_name": "do_nothing_with_pointer_00004280"
        },
        "FUN_00001448": {
            "renaming": {
                "FUN_00001448": "update_bits_if_not_negative_00001448",
                "param_1": "index",
                "PTR_DAT_000014c0": "data_pointer",
                "update_bits_and_get_value_00001f80": "update_bits_and_get_value",
                "second_value": "short_value_2",
                "short": "short_value",
                "first_value": "short_value_1"
            },
            "code": "void update_bits_if_not_negative_00001448(int index){\n  short first_value = *(short *)(PTR_DAT_000014c0 + index * 0x20 + 8);\n  short second_value = *(short *)(PTR_DAT_000014c0 + index * 0x20 + 10);\n  if (first_value != -1) {\n    update_bits_and_get_value_00001f80(*(undefined2 *)(PTR_DAT_000014c0 + index * 0x20 + 8), *(undefined4 *)(PTR_DAT_000014c0 + index * 0x20 + 0xc));\n  }\n  if (second_value != -1) {\n    update_bits_and_get_value_00001f80(*(undefined2 *)(PTR_DAT_000014c0 + index * 0x20 + 10), *(undefined4 *)(PTR_DAT_000014c0 + index * 0x20 + 0x10));\n  }\n  return;\n}",
            "called": [
                "FUN_00001f80"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001448",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": true,
            "current_name": "update_bits_if_not_negative_00001448"
        },
        "FUN_00001688": {
            "renaming": {
                "FUN_00001688": "call_check_function_00001688",
                "check_and_call_function_00001628": "check_and_call_function"
            },
            "code": "void call_check_function_00001688(void)\n{\n  check_and_call_function(0);\n  return;\n}",
            "called": [
                "FUN_00001628"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001688",
            "calling": [],
            "imported": true,
            "current_name": "call_check_function_00001688"
        },
        "FUN_00004042": {
            "renaming": {
                "FUN_00004042": "convertStringToNumber_00004042",
                "param_1": "string"
            },
            "code": "void convertStringToNumber_00004042(char* string, int startIndex, int endIndex)\n{\n  convertStringToNumber_00004042(string, startIndex, endIndex);\n  return;\n}",
            "called": [
                "FUN_00004f84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004042",
            "calling": [
                "FUN_00002fe0",
                "FUN_0000305c"
            ],
            "imported": true,
            "current_name": "convertStringToNumber_00004042"
        },
        "FUN_00000cf0": {
            "renaming": {
                "bVar1": "is_privileged_mode",
                "FUN_00000cf0": "is_interrupt_enabled_in_privileged_mode_00000cf0",
                "uVar2": "is_interrupt_enabled"
            },
            "code": "bool is_interrupt_enabled_in_privileged_mode_00000cf0(void)\n{\n  bool is_privileged_mode = isCurrentModePrivileged();\n  bool is_interrupt_enabled = false;\n  if (is_privileged_mode) {\n    is_interrupt_enabled = isIRQinterruptsEnabled();\n  }\n  return is_interrupt_enabled;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cf0",
            "calling": [
                "FUN_00000930"
            ],
            "imported": true,
            "current_name": "is_interrupt_enabled_in_privileged_mode_00000cf0"
        },
        "FUN_00000f8c": {
            "renaming": {
                "uRam00000fe8": "memory_pointer_6",
                "uRam00000fd8": "memory_pointer_5",
                "uVar1": "interrupt_status",
                "wait_for_interrupt_00000930": "wait_for_interrupt",
                "puVar2": "interrupt_descriptor",
                "process_input_00000f04": "process_input",
                "uRam00000fdc": "memory_pointer_3",
                "local_18": "memory_pointer_3",
                "FUN_00000f8c": "initialize_interrupt_handling_00000f8c",
                "PTR_s_FAILED_ASSERTION__00001030": "FAILED_ASSERTION_MESSAGE",
                "iStack_24": "stack_var_1",
                "allocate_memory_000010d4": "allocate_memory",
                "uVar3": "interrupt_mask",
                "uStack_1c": "stack_var_3",
                "local_10": "memory_pointer_1",
                "uRam00000fe0": "memory_pointer_4",
                "piStack_20": "stack_var_2",
                "local_14": "memory_pointer_2",
                "uRam00000fe4": "memory_pointer_5",
                "uRam00000fd4": "memory_pointer_4"
            },
            "code": "void initialize_interrupt_handling_00000f8c(void)\n{\n  uint interrupt_status;\n  undefined4 *interrupt_descriptor;\n  uint interrupt_mask;\n  int stack_var_1;\n  int *stack_var_2;\n  undefined4 stack_var_3;\n  undefined4 local_var_1;\n  undefined4 local_var_2;\n  undefined4 local_var_3;\n  is_interrupts_enabled_in_privileged_mode();\n  local_var_3 = *memory_pointer_1;\n  local_var_2 = 0;\n  local_var_1 = memory_pointer_2;\n  allocate_memory(memory_pointer_3, 0x100, 0xf, 0xc);\n  local_var_3 = *memory_pointer_4;\n  local_var_2 = 0;\n  local_var_1 = memory_pointer_5;\n  interrupt_mask = 0xc;\n  allocate_memory(memory_pointer_6, 0x600, 7);\n  stack_var_3 = 0xfd3;\n  interrupt_status = wait_for_interrupt();\n  interrupt_status = interrupt_status >> 0x1e;\n  interrupt_descriptor = (undefined4 *)(interrupt_mask * 0x100);\n  stack_var_1 = (interrupt_mask >> 0x1d) << 0x11;\n  stack_var_2 = &stack_var_1;\n  if ((interrupt_status & interrupt_status - 1) != 0) {\n    process_input(3, PTR_s_FAILED_ASSERTION__00001030);\n  }\n  *interrupt_descriptor = 0;\n  interrupt_descriptor[1] = 0;\n  interrupt_descriptor[2] = interrupt_status - 1;\n  return;\n}",
            "called": [
                "FUN_000010d4",
                "FUN_00000930",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f8c",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": true,
            "current_name": "initialize_interrupt_handling_00000f8c"
        },
        "FUN_00002894": {
            "renaming": {
                "iVar1": "data_ptr",
                "DAT_000028e8": "global_data_ptr",
                "param_1": "index",
                "FUN_00002894": "update_data_00002894",
                "param_2": "value1",
                "param_3": "value2",
                "PTR_DAT_000028ec": "global_ptr"
            },
            "code": "void update_data_00002894(int index, uint32_t value1, uint32_t value2)\n{\n  int data_ptr = DAT_000028e8;\n  uint32_t mask = 0xfffffffb;\n  *(uint32_t *)(data_ptr + 0x1c) = *(uint32_t *)(data_ptr + 0x1c) & mask;\n  *(int *)(data_ptr + 8) = index - 1;\n  *(uint32_t *)PTR_DAT_000028ec = value1;\n  *(uint32_t *)(PTR_DAT_000028ec + 4) = value2;\n  *(uint32_t *)(data_ptr + 0x1c) = *(uint32_t *)(data_ptr + 0x1c) | 4;\n  save_data(0x2e, 10);\n  set_bit_in_array(0x2e);\n  return;\n}",
            "called": [
                "FUN_00002744",
                "FUN_00002714"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002894",
            "calling": [
                "FUN_00002654"
            ],
            "imported": true,
            "current_name": "update_data_00002894"
        },
        "FUN_00004158": {
            "renaming": {
                "PTR_DAT_000041c4": "PTR_DAT_000041c4",
                "do_nothing_000045e8": "do_nothing_000045e8",
                "uVar1": "result",
                "FUNC_000042a4": "call_func_000042a4",
                "param_1": "data_size",
                "PTR_DAT_000041c8": "PTR_DAT_000041c8",
                "PTR_DAT_000041cc": "PTR_DAT_000041cc",
                "FUN_00004158": "process_data_00004158",
                "param_2": "data_buffer",
                "decode_0000404c": "decode_data"
            },
            "code": "int process_data_00004158(int data_size, undefined *data_buffer)\n{\n  int result;\n  if (*(int *)(data_buffer + 0x10) != 0) {\n    if ((data_size != 0) && (*(int *)(data_size + 0x18) == 0)) {\n      call_func_000042a4();\n    }\n    if (data_buffer == PTR_DAT_000041c4) {\n      data_buffer = *(undefined **)(data_size + 4);\n    }\n    else if (data_buffer == PTR_DAT_000041c8) {\n      data_buffer = *(undefined **)(data_size + 8);\n    }\n    else if (data_buffer == PTR_DAT_000041cc) {\n      data_buffer = *(undefined **)(data_size + 0xc);\n    }\n    if (*(short *)(data_buffer + 0xc) != 0) {\n      if ((*(int *)(data_buffer + 100) << 0x1f) >= 0 && (*(short *)(data_buffer + 0xc) << 0x16) >= 0) {\n        do_nothing_000045e8(*(undefined4 *)(data_buffer + 0x58));\n      }\n      result = decode_data(data_size, data_buffer);\n      if (*(int *)(data_buffer + 100) << 0x1f >= 0 && (*(ushort *)(data_buffer + 0xc) << 0x16) >= 0) {\n        do_nothing_000045ec(*(undefined4 *)(data_buffer + 0x58));\n        return result;\n      }\n      return result;\n    }\n  }\n  return 0;\n}",
            "called": [
                "FUN_000045ec",
                "FUN_000045e8",
                "FUN_000042a4",
                "FUN_0000404c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004158",
            "calling": [
                "FUN_000041d0",
                "FUN_00006768",
                "FUN_00005404"
            ],
            "imported": true,
            "current_name": "process_data_00004158",
            "code_backup": "\nundefined4 FUN_00004158(int param_1,undefined *param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (*(int *)(param_2 + 0x10) != 0) {\n    if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n      FUNC_000042a4();\n    }\n    if (param_2 == PTR_DAT_000041c4) {\n      param_2 = *(undefined **)(param_1 + 4);\n    }\n    else if (param_2 == PTR_DAT_000041c8) {\n      param_2 = *(undefined **)(param_1 + 8);\n    }\n    else if (param_2 == PTR_DAT_000041cc) {\n      param_2 = *(undefined **)(param_1 + 0xc);\n    }\n    if (*(short *)(param_2 + 0xc) != 0) {\n      if ((-1 < *(int *)(param_2 + 100) << 0x1f) && (-1 < (int)*(short *)(param_2 + 0xc) << 0x16)) {\n        do_nothing_000045e8(*(undefined4 *)(param_2 + 0x58));\n      }\n      uVar1 = decode_0000404c(param_1,param_2);\n      if (*(int *)(param_2 + 100) << 0x1f < 0) {\n        return uVar1;\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x16) < 0) {\n        return uVar1;\n      }\n      do_nothing_000045ec(*(undefined4 *)(param_2 + 0x58));\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n"
        },
        "FUN_00002654": {
            "renaming": {
                "uVar1": "result",
                "param_1": "param1",
                "FUN_00002654": "execute_function_and_update_data_00002654",
                "param_2": "param2",
                "param_3": "param3"
            },
            "code": "int execute_function_and_update_data_00002654(int param1, int param2, int param3)\n{\n  int result = FUNC_000047e4(param1);\n  *(int *)PTR_DAT_00002688 = param2;\n  update_data_00002894(result, PTR_execute_function_if_not_null_000026f0_1_0000268c, param3);\n  return 0;\n}",
            "called": [
                "FUN_000047e4",
                "FUN_00002894"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002654",
            "calling": [
                "FUN_000033f4"
            ],
            "imported": true,
            "current_name": "execute_function_and_update_data_00002654"
        },
        "FUN_00002538": {
            "renaming": {
                "DAT_00002584": "data_array_ptr",
                "param_1": "data_index",
                "DAT_00002588": "data_array_ptr",
                "param_2": "data_value",
                "FUN_00002538": "save_data_00002538"
            },
            "code": "void save_data_00002538(byte data_index, uint8_t data_value) {\n  if (data_index < 0) {\n    char* data_ptr = (char*)((data_index & 0xf) + DAT_00002584 + 0x14);\n    *data_ptr = (char)((data_value & 0xff) << 4);\n  }\n  else {\n    char* data_ptr = (char*)(data_index + DAT_00002584 + 0x300);\n    *data_ptr = (char)((data_value & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002538",
            "calling": [
                "FUN_0000258c"
            ],
            "imported": true,
            "current_name": "save_data_00002538"
        },
        "FUN_00004c84": {
            "renaming": {
                "iVar1": "ptr_i",
                "FUNC_000042a4": "cleanup",
                "uStack_8": "param3",
                "FUNC_000057f8": "call_function",
                "param_1": "input1",
                "DAT_00004cb0": "PTR_DAT_00004cb0",
                "uStack_4": "param4",
                "uStack_c": "param2",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar2": "param1",
                "FUN_00004c84": "process_input_and_call_function_00004c84"
            },
            "code": "void process_input_and_call_function_00004c84(undefined4 input1, undefined4 input2, undefined4 input3, undefined4 input4) {\n  int* ptr_i = *DAT_00004cb0;\n  undefined4 param1 = input1;\n  undefined4 param2 = input2;\n  undefined4 param3 = input3;\n  undefined4 param4 = input4;\n  if ((ptr_i != 0) && (*(int *)(ptr_i + 0x18) == 0)) {\n    cleanup(ptr_i);\n  }\n  call_function(ptr_i, *(undefined4 *)(ptr_i + 8), input1, &param2, param1, &param2);\n  return;\n}",
            "called": [
                "FUN_000057f8",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004c84",
            "calling": [
                "FUN_00002f74",
                "FUN_00003524",
                "FUN_00003378",
                "FUN_00000ed8",
                "FUN_00003694",
                "FUN_00002b10",
                "FUN_0000316c",
                "FUN_00000f04",
                "FUN_0000211c",
                "FUN_00002ecc",
                "FUN_00002fe0",
                "FUN_00002a88",
                "FUN_0000305c"
            ],
            "imported": true,
            "current_name": "process_input_and_call_function_00004c84",
            "code_backup": "\nvoid FUN_00004c84(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  iVar1 = *DAT_00004cb0;\n  uVar2 = param_1;\n  uStack_c = param_2;\n  uStack_8 = param_3;\n  uStack_4 = param_4;\n  if ((iVar1 != 0) && (*(int *)(iVar1 + 0x18) == 0)) {\n    FUNC_000042a4(iVar1);\n  }\n  FUNC_000057f8(iVar1,*(undefined4 *)(iVar1 + 8),param_1,&uStack_c,uVar2,&uStack_c);\n  return;\n}\n\n"
        },
        "FUN_0000305c": {
            "renaming": {
                "uVar1": "argValue",
                "param_1": "numArgs",
                "local_18": "numDataElements",
                "auStack_20": "dataArray",
                "param_2": "args",
                "local_10": "deviceValue",
                "FUN_0000305c": "writeDataToDevice_0000305c",
                "local_14": "deviceIndex"
            },
            "code": "void writeDataToDevice_0000305c(int numArgs, undefined4 *args)\n{\n  undefined2 argValue;\n  undefined2 dataArray[4];\n  uint numDataElements;\n  int deviceIndex;\n  undefined4 deviceValue;\n\n  if (numArgs < 4) {\n    processInputAndCallFunction(PTR_s_usage___s__s__device_id___value_0_00003154, *args, args[1]);\n  }\n  else {\n    deviceValue = convertStringToNumber(args[2]);\n    deviceIndex = getIndexForDevice(deviceValue);\n    if (deviceIndex == 0) {\n      FUNC_00004db8(PTR_s_error__undefined_device_given_00003158);\n    }\n    else {\n      fillArrayWithValue(dataArray, 0, 8);\n      if (numArgs > 5) {\n        numArgs = 6;\n      }\n      numDataElements = numArgs - 3;\n      for (int i = 0; i < (int)numDataElements; i = i + 1) {\n        argValue = convertStringToNumber(args[i + 3]);\n        dataArray[i] = argValue;\n      }\n      processInputAndCallFunction(PTR_s_Writing_to_device___i____s_0000315c, deviceValue, *(undefined4 *)(deviceIndex + 8));\n      displayDataObject(dataArray, numDataElements & 0xff);\n      numDataElements = executeFunction(deviceIndex, dataArray);\n      if ((int)numDataElements < 1) {\n        if (numDataElements == -0x86) {\n          processInputAndCallFunction(PTR_s_error__device___i_is_not_writabl_00003160, deviceValue);\n        }\n        else {\n          processInputAndCallFunction(PTR_s_error__failure_to_write_to_devic_00003164, deviceValue);\n        }\n      }\n      else {\n        processInputAndCallFunction(PTR_s_data_successfully_written_to_dev_00003168, deviceValue);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00003694",
                "FUN_00003d24",
                "FUN_00004622",
                "FUN_00003d94",
                "FUN_00004c84",
                "FUN_00004042"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000305c",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": true,
            "current_name": "writeDataToDevice_0000305c"
        },
        "FUN_000012b4": {
            "renaming": {
                "check_difference_and_increment_00002364": "check_difference_and_increment",
                "uVar1": "difference",
                "param_1": "list_ptr",
                "update_list_and_check_exception_threshold_000024bc": "update_list_and_check_exception_threshold",
                "param_2": "exception_threshold",
                "FUN_000012b4": "check_and_increment_difference_000012b4"
            },
            "code": "uint32_t check_and_increment_difference_000012b4(int list_ptr, uint8_t exception_threshold) {\n  uint32_t difference = check_difference_and_increment(list_ptr + 4, exception_threshold);\n  update_list_and_check_exception_threshold(list_ptr);\n  return difference;\n}",
            "called": [
                "FUN_000024bc",
                "FUN_00002364"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012b4",
            "calling": [],
            "imported": true,
            "current_name": "check_and_increment_difference_000012b4"
        },
        "FUN_00005b34": {
            "renaming": {
                "FUN_00005b34": "FUNC_00005b34"
            },
            "code": "\ncode * FUNC_00005b34(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5\n                   )\n\n{\n  bool bVar1;\n  byte bVar2;\n  undefined *puVar3;\n  int iVar4;\n  code *pcVar5;\n  int iVar6;\n  undefined *puVar7;\n  uint uVar8;\n  uint *puVar9;\n  uint uVar10;\n  uint **ppuVar11;\n  uint uVar12;\n  undefined *puVar13;\n  code *local_24;\n  \n  puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n  bVar2 = *(byte *)(param_2 + 6);\n  puVar7 = (undefined *)((int)param_2 + 0x43);\n  local_24 = param_4;\n  if (0x78 < bVar2) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)param_2 + 0x42) = bVar2;\nLAB_00005bdc:\n    puVar7 = (undefined *)((int)param_2 + 0x42);\n    uVar8 = 1;\nLAB_00005d28:\n    param_2[4] = uVar8;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (bVar2 < 99) {\n    if (bVar2 == 0) goto LAB_00005d06;\n    if (bVar2 == 0x58) {\n      *(undefined *)((int)param_2 + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(bVar2) {\n  case 99:\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    *(char *)((int)param_2 + 0x42) = (char)uVar8;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    uVar10 = *param_2;\n    puVar9 = *param_5;\n    if ((int)(uVar10 << 0x18) < 0) {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n    }\n    else {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n      if ((uVar10 & 0x40) != 0) {\n        uVar8 = (uint)(short)uVar8;\n      }\n    }\n    if ((int)uVar8 < 0) {\n      uVar8 = -uVar8;\n      *(undefined *)((int)param_2 + 0x43) = 0x2d;\n    }\n    uVar10 = 10;\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    ppuVar11 = (uint **)*param_5;\n    uVar10 = *param_2;\n    uVar8 = param_2[5];\n    *param_5 = (uint *)(ppuVar11 + 1);\n    puVar9 = *ppuVar11;\n    if (((int)(uVar10 << 0x18) < 0) || (-1 < (int)(uVar10 << 0x19))) {\n      *puVar9 = uVar8;\n    }\n    else {\n      *(short *)puVar9 = (short)uVar8;\n    }\nLAB_00005d06:\n    param_2[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    puVar9 = *param_5;\n    uVar8 = *param_2;\n    *param_5 = puVar9 + 1;\n    if (((int)(uVar8 << 0x18) < 0) || (-1 < (int)(uVar8 << 0x19))) {\n      uVar8 = *puVar9;\n    }\n    else {\n      uVar8 = (uint)*(ushort *)puVar9;\n    }\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    if (bVar2 == 0x6f) {\n      uVar10 = 8;\n    }\n    else {\n      uVar10 = 10;\n    }\n    break;\n  case 0x70:\n    *param_2 = *param_2 | 0x20;\n  case 0x78:\n    puVar3 = PTR_s_0123456789abcdef_00005d7c;\n    *(undefined *)((int)param_2 + 0x45) = 0x78;\nLAB_00005ca8:\n    uVar10 = *param_2;\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    if ((-1 < (int)(uVar10 << 0x18)) && ((int)(uVar10 << 0x19) < 0)) {\n      uVar8 = uVar8 & 0xffff;\n    }\n    if ((int)(uVar10 << 0x1f) < 0) {\n      *param_2 = uVar10 | 0x20;\n    }\n    if (uVar8 == 0) {\n      *param_2 = *param_2 & 0xffffffdf;\n    }\n    uVar10 = 0x10;\n    break;\n  case 0x73:\n    puVar9 = *param_5;\n    *param_5 = puVar9 + 1;\n    puVar7 = (undefined *)*puVar9;\n    iVar4 = find_byte_sequence_00006010(puVar7,0,param_2[1],puVar9,param_1,param_2,param_3);\n    if (iVar4 != 0) {\n      param_2[1] = iVar4 - (int)puVar7;\n    }\n    uVar8 = param_2[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)param_2 + 0x43) = 0;\nLAB_00005c36:\n  uVar12 = param_2[1];\n  param_2[2] = uVar12;\n  if (-1 < (int)uVar12) {\n    *param_2 = *param_2 & 0xfffffffb;\n  }\n  puVar13 = puVar7;\n  if ((uVar8 != 0) || (uVar12 != 0)) {\n    do {\n      puVar13 = puVar13 + -1;\n      *puVar13 = puVar3[uVar8 - uVar10 * (uVar8 / uVar10)];\n      bVar1 = uVar10 <= uVar8;\n      uVar8 = uVar8 / uVar10;\n    } while (bVar1);\n  }\n  if (((uVar10 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4])) {\n    puVar13[-1] = 0x30;\n    puVar13 = puVar13 + -1;\n  }\n  param_2[4] = (int)puVar7 - (int)puVar13;\n  puVar7 = puVar13;\nLAB_00005c84:\n  iVar4 = processData_00005a58(param_1,param_2,&local_24,param_3,param_4);\n  if ((iVar4 == -1) || (iVar4 = (*param_4)(param_1,param_3,puVar7,param_2[4]), iVar4 == -1)) {\nLAB_00005c98:\n    pcVar5 = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar4 = 0; iVar4 < (int)(param_2[3] - (int)local_24); iVar4 = iVar4 + 1) {\n        iVar6 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar6 == -1) goto LAB_00005c98;\n      }\n    }\n    pcVar5 = (code *)param_2[3];\n    if ((int)(code *)param_2[3] < (int)local_24) {\n      pcVar5 = local_24;\n    }\n  }\n  return pcVar5;\n}\n\n",
            "called": [
                "FUN_00006010",
                "FUN_00005a58"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00005b34",
            "calling": [
                "FUN_000057f8"
            ],
            "imported": false,
            "current_name": "FUNC_00005b34"
        },
        "FUN_0000058e": {
            "renaming": {
                "param_1": "pointer_to_update",
                "*param_1": "*pointer_to_update",
                "*param_2": "*new_pointer",
                "param_2": "new_pointer",
                "FUN_0000058e": "update_pointer_0000058e"
            },
            "code": "void update_pointer_0000058e(int *pointer_to_update, undefined4 *new_pointer) {\n  if (*pointer_to_update == 0) {\n    *new_pointer = new_pointer;\n  }\n  else {\n    *new_pointer = *(undefined4 *)*pointer_to_update;\n    *(undefined4 **)*pointer_to_update = new_pointer;\n  }\n  *pointer_to_update = (int)new_pointer;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000058e",
            "calling": [
                "FUN_00000698"
            ],
            "imported": true,
            "current_name": "update_pointer_0000058e"
        },
        "FUN_0000656c": {
            "renaming": {
                "FUN_0000656c": "FUNC_0000656c"
            },
            "code": "\nundefined4 FUNC_0000656c(undefined4 param_1,uint *param_2,byte **param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  code *pcVar3;\n  uint uVar4;\n  byte *pbVar5;\n  uint uVar6;\n  undefined4 *puVar7;\n  uint *puVar8;\n  uint *puVar9;\n  uint *puVar10;\n  int unaff_r9;\n  int iVar11;\n  undefined4 local_34 [4];\n  \n  local_34[0] = *(undefined4 *)PTR_PTR_DAT_00006744;\n  local_34[1] = *(undefined4 *)(PTR_PTR_DAT_00006744 + 4);\n  local_34[2] = *(undefined4 *)(PTR_PTR_DAT_00006744 + 8);\n  pcVar3 = (code *)PTR_LAB_00004f80_1_0000674c;\n  if (param_2[6] != 3) {\n    pcVar3 = (code *)PTR_LAB_00005fd4_1_00006748;\n  }\n  uVar6 = param_2[2];\n  uVar4 = uVar6 - 1;\n  if (0x15c < uVar4) {\n    unaff_r9 = uVar6 - 0x15d;\n    uVar6 = 0x15d;\n  }\n  if (0x15c < uVar4) {\n    param_2[2] = uVar6;\n  }\n  puVar10 = param_2 + 7;\n  if (uVar4 < 0x15d) {\n    unaff_r9 = 0;\n  }\n  *param_2 = *param_2 | 0xd00;\n  iVar11 = 0;\n  puVar9 = puVar10;\n  do {\n    iVar1 = find_byte_sequence_00006010(local_34[iVar11],**param_3,2);\n    if (iVar1 != 0) {\n      if (iVar11 == 1) {\n        if (param_2[1] == 0) {\n          param_2[1] = 8;\n          *param_2 = *param_2 | 0x200;\n        }\n        uVar4 = *param_2 & 0xfffffaff;\nLAB_000065f4:\n        *param_2 = uVar4;\n      }\n      else if (iVar11 == 2) {\n        if ((*param_2 & 0x600) != 0x200) goto LAB_00006624;\n        param_2[1] = 0x10;\n        uVar4 = *param_2 | 0x100;\n        goto LAB_000065f4;\n      }\n      uVar4 = param_2[2];\n      param_2[2] = uVar4 - 1;\n      if (uVar4 != 0) {\n        pbVar5 = *param_3;\n        *param_3 = pbVar5 + 1;\n        puVar8 = (uint *)((int)puVar9 + 1);\n        *(byte *)puVar9 = *pbVar5;\n        pbVar5 = param_3[1];\n        param_3[1] = pbVar5 + -1;\n        puVar9 = puVar8;\n        if (((int)(pbVar5 + -1) < 1) &&\n           (iVar1 = (*(code *)param_2[0x60])(param_1,param_3), iVar1 != 0)) {\n          iVar11 = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    iVar11 = iVar11 + 1;\n  } while (iVar11 != 3);\n  if (param_2[1] == 0) {\n    param_2[1] = 10;\n  }\n  reverseAndToggle_0000687c(param_2[5],(int)PTR_DAT_00006750 - param_2[1]);\n  iVar11 = 0;\n  while( true ) {\n    puVar8 = puVar9;\n    if (param_2[2] == 0) break;\n    pbVar5 = *param_3;\n    uVar4 = (uint)*pbVar5;\n    if (*(char *)(param_2[5] + uVar4) == '\\0') break;\n    if ((uVar4 == 0x30) && ((int)(*param_2 << 0x14) < 0)) {\n      iVar11 = iVar11 + 1;\n      if (unaff_r9 != 0) {\n        unaff_r9 = unaff_r9 + -1;\n        param_2[2] = param_2[2] + 1;\n      }\n    }\n    else {\n      *param_2 = *param_2 & 0xfffff6ff;\n      puVar8 = (uint *)((int)puVar9 + 1);\n      *(byte *)puVar9 = *pbVar5;\n    }\n    pbVar5 = param_3[1];\n    param_3[1] = pbVar5 + -1;\n    if ((int)(pbVar5 + -1) < 1) {\n      iVar1 = (*(code *)param_2[0x60])(param_1,param_3);\n      if (iVar1 != 0) break;\n    }\n    else {\n      *param_3 = *param_3 + 1;\n    }\n    param_2[2] = param_2[2] - 1;\n    puVar9 = puVar8;\n  }\nLAB_000066ca:\n  if ((int)(*param_2 << 0x17) < 0) {\n    if (puVar10 < puVar8) {\n      (*(code *)param_2[0x5f])(param_1,*(byte *)((int)puVar8 + -1),param_3);\n      puVar8 = (uint *)((int)puVar8 + -1);\n    }\n    if (puVar8 == puVar10) {\n      return 1;\n    }\n  }\n  if ((*param_2 & 0x10) == 0) {\n    *(byte *)puVar8 = 0;\n    uVar2 = (*pcVar3)(param_1,puVar10,0,param_2[1]);\n    puVar7 = (undefined4 *)*param_4;\n    uVar4 = *param_2;\n    *param_4 = puVar7 + 1;\n    puVar7 = (undefined4 *)*puVar7;\n    if ((uVar4 & 0x20) == 0) {\n      if ((int)(uVar4 << 0x1f) < 0) {\n        *(short *)puVar7 = (short)uVar2;\n      }\n      else {\n        *puVar7 = uVar2;\n      }\n    }\n    else {\n      *puVar7 = uVar2;\n    }\n    param_2[3] = param_2[3] + 1;\n  }\n  param_2[4] = (uint)((int)puVar8 + param_2[4] + (iVar11 - (int)puVar10));\n  return 0;\n}\n\n",
            "called": [
                "FUN_0000687c",
                "FUN_00006010"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0000656c",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "FUNC_0000656c"
        },
        "FUN_000025f4": {
            "renaming": {
                "FUN_000025f4": "initialize_data_access_flags_000025f4"
            },
            "code": "void initialize_data_access_flags_000025f4(void)\n{\n  //initialize data access flags\n  return;\n}",
            "called": [
                "FUN_000027b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000025f4",
            "calling": [
                "FUN_00002396"
            ],
            "imported": true,
            "current_name": "initialize_data_access_flags_000025f4"
        },
        "FUN_00001ddc": {
            "renaming": {
                "FUN_00001ddc": "calculate_result_from_param_value_00001ddc",
                "DAT_00001e08": "result",
                "param_1": "param_value",
                "cVar1": "bits"
            },
            "code": "void calculate_result_from_param_value_00001ddc(undefined2 param_value) {\n  char bits = get_bits_from_value(param_value);\n  char DAT_00001e08 = bits + 9;\n  set_calculated_DAT_00001e08_to_one(DAT_00001e08);\n  return;\n}",
            "called": [
                "FUN_00001d3a",
                "FUN_00001da2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ddc",
            "calling": [
                "FUN_00001f80"
            ],
            "imported": true,
            "current_name": "calculate_result_from_param_value_00001ddc"
        },
        "FUN_00002ecc": {
            "renaming": {
                "FUN_00002ecc": "read_data_from_device_and_display_00002ecc",
                "uVar1": "data_object_type",
                "auStack_1c": "data_buffer",
                "param_1": "data_object_handle",
                "param_2": "device_handle",
                "uVar2": "data_object_id",
                "local_14": "data_length"
            },
            "code": "void read_data_from_device_and_display_00002ecc(int device_handle, int data_object_handle)\n{\n  uint8_t data_buffer[256];\n  uint8_t data_length = read_data_from_device(device_handle, data_buffer);\n  if (data_length < 1) {\n    display_error_message(PTR_s_error__failed_to_read_from_devic_00002f28, data_object_handle);\n  }\n  else {\n    uint32_t data_object_id = *(uint32_t *)(data_object_handle + 8);\n    uint8_t data_object_type = get_data_object_type(*(uint8_t *)(*(int *)(data_object_handle + 12) + 8));\n    display_data_object(data_buffer, data_length & 0xff);\n    display_reading_message(PTR_s_Reading_from___i___s__s__00002f2c, data_object_handle, data_object_id, data_object_type);\n  }\n  return;\n}",
            "called": [
                "FUN_00003d64",
                "FUN_00003694",
                "FUN_000039e8",
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002ecc",
            "calling": [
                "FUN_00002f30",
                "FUN_00002fe0"
            ],
            "imported": true,
            "current_name": "read_data_from_device_and_display_00002ecc"
        },
        "FUN_00000d76": {
            "renaming": {
                "FUN_00000d76": "clear_memory_at_address_offset_00000d76",
                "param_1": "base_address",
                "param_2": "offset",
                "puVar1": "address_to_clear"
            },
            "code": "void clear_memory_at_address_offset_00000d76(void* base_address, unsigned int offset) {\n  unsigned int* address_to_clear = (unsigned int*)calculate_address_offset(base_address, offset);\n  *address_to_clear = 0;\n  return;\n}",
            "called": [
                "FUN_00000d44"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d76",
            "calling": [
                "FUN_00000d9c"
            ],
            "imported": true,
            "current_name": "clear_memory_at_address_offset_00000d76"
        },
        "FUN_000057a8": {
            "renaming": {
                "iVar1": "buffer_index",
                "FUN_000057a8": "process_input_000057a8",
                "puVar2": "buffer_ptr",
                "param_1": "input_length",
                "param_2": "input_char",
                "param_3": "input_buffer"
            },
            "code": "int process_input_000057a8(int input_length, int input_char, int *input_buffer) {\n  int buffer_index = input_buffer[2] - 1;\n  input_buffer[2] = buffer_index;\n  if ((buffer_index < 0) && ((buffer_index < (int)input_buffer[6] || (input_char == 10)))) {\n    int result = process_input_000057a8_00005404();\n    return result;\n  }\n  undefined *buffer_ptr = (undefined *)*input_buffer;\n  *input_buffer = buffer_ptr + 1;\n  *buffer_ptr = (char)input_char;\n  return input_char;\n}",
            "called": [
                "FUN_00005404"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057a8",
            "calling": [
                "FUN_000057d2"
            ],
            "imported": true,
            "current_name": "process_input_000057a8"
        },
        "FUN_00001696": {
            "renaming": {
                "param_1": "address",
                "FUN_00001696": "calculate_offset_00001696",
                "param_2": "index",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "int calculate_offset_00001696(uint32_t address, int index) {\n    uint32_t high_bits = address & 0xf0000000;\n    uint32_t low_bits = address & 0xfffff;\n    int offset = (low_bits << 5) + high_bits + 0x2000000 + (index * 4);\n    return offset;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001696",
            "calling": [
                "FUN_000016ec",
                "FUN_00001710",
                "FUN_000016c8"
            ],
            "imported": true,
            "current_name": "calculate_offset_00001696"
        },
        "FUN_000008b8": {
            "renaming": {
                "local_c": "relocation_ptr",
                "DAT_000008f8": "relocation_type",
                "PTR_DAT_000008f4": "relocation_array_start",
                "PTR_Elf32_Rel_ARRAY_000008fc": "relocation_array_end",
                "FUN_000008b8": "count_elf32_relocations_000008b8"
            },
            "code": "int count_elf32_relocations_000008b8(void)\n{\n  int *relocation_ptr;\n  for (relocation_ptr = (int *)PTR_DAT_000008f4; (*relocation_ptr == DAT_000008f8 && relocation_ptr < PTR_Elf32_Rel_ARRAY_000008fc); relocation_ptr++)\n  {\n  }\n  return ((int)PTR_Elf32_Rel_ARRAY_000008fc - (int)relocation_ptr) / sizeof(int);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000008b8",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": true,
            "current_name": "count_elf32_relocations_000008b8"
        },
        "FUN_000024bc": {
            "renaming": {
                "is_interrupts_enabled_in_privileged_mode_00000cd0": "is_interrupts_enabled_in_privileged_mode_00000cd0",
                "iVar3": "current_element_ptr",
                "uVar1": "interrupts_enabled",
                "update_linked_list_00000698": "update_linked_list_00000698",
                "param_1": "list_ptr",
                "FUN_000024bc": "update_list_and_check_exception_threshold_000024bc",
                "check_exception_threshold_00000738": "check_exception_threshold_00000738",
                "enable_interrupts_if_privileged_00000d0c": "enable_interrupts_if_privileged_00000d0c",
                "uVar2": "interrupt_status",
                "getNextElementInList_0000240c": "get_next_element_in_list_0000240c"
            },
            "code": "void update_list_and_check_exception_threshold_000024bc(int *list_ptr)\n{\n  undefined interrupts_enabled;\n  undefined4 interrupt_status;\n  int current_element_ptr;\n  \n  interrupt_status = is_interrupts_enabled_in_privileged_mode_00000cd0();\n  if (*list_ptr == 0) {\n    enable_interrupts_if_privileged_00000d0c(interrupt_status);\n  }\n  else if (*list_ptr == -1) {\n    *list_ptr = 0;\n    enable_interrupts_if_privileged_00000d0c(interrupt_status);\n  }\n  else {\n    current_element_ptr = get_next_element_in_list_0000240c(list_ptr);\n    update_linked_list_00000698(current_element_ptr - 8,10);\n    if (*list_ptr == 0) {\n      *list_ptr = -1;\n    }\n    interrupts_enabled = *(undefined *)(current_element_ptr - 3);\n    enable_interrupts_if_privileged_00000d0c(interrupt_status);\n    check_exception_threshold_00000738(interrupts_enabled);\n  }\n  return;\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000738",
                "FUN_00000cd0",
                "FUN_00000d0c",
                "FUN_0000240c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000024bc",
            "calling": [
                "FUN_000012b4"
            ],
            "imported": true,
            "current_name": "update_list_and_check_exception_threshold_000024bc"
        },
        "FUN_00000490": {
            "renaming": {
                "uVar1": "result",
                "param_1": "data_pointer",
                "FUNC_00000e14": "perform_action",
                "FUN_00000490": "perform_action_on_data_00000490",
                "param_2": "data_size",
                "param_3": "action_pointer",
                "param_4": "action_size"
            },
            "code": "int perform_action_on_data_00000490(int data_pointer, int data_size, int action_pointer, int action_size)\n{\n  int result = perform_action(action_pointer, action_size, data_pointer, data_size);\n  return result;\n}",
            "called": [
                "FUN_00000e14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000490",
            "calling": [
                "FUN_00004dc8"
            ],
            "imported": true,
            "current_name": "perform_action_on_data_00000490"
        },
        "FUN_0000091c": {
            "renaming": {
                "FUN_0000091c": "get_data_pointer_0000091c",
                "PTR_DAT_0000092c": "data_pointer"
            },
            "code": "void* get_data_pointer_0000091c() {\n  return PTR_DAT_0000092c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000091c",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": true,
            "current_name": "get_data_pointer_0000091c"
        },
        "FUN_00001f80": {
            "renaming": {
                "iVar1": "combined_and_shifted",
                "iVar2": "last_six_bits",
                "param_1": "param_value",
                "param_2": "new_value",
                "uVar3": "bits_from_value",
                "uVar5": "current_value",
                "uVar4": "bits_position",
                "FUN_00001f80": "update_bits_and_get_value_00001f80"
            },
            "code": "void update_bits_and_get_value_00001f80(uint16_t param_value, uint32_t new_value) {\n  int combined_and_shifted = combine_and_shift(param_value);\n  int last_six_bits = get_last_six_bits(param_value);\n  uint32_t current_value = *(uint32_t *)(combined_and_shifted + last_six_bits * 4);\n  *(uint32_t *)(combined_and_shifted + last_six_bits * 4) = new_value;\n  if ((current_value & 0xf0000) != 0) {\n    uint16_t bits_from_value = get_bits_from_value(param_value);\n    uint32_t last_six_bits = get_last_six_bits(param_value);\n    update_bits_at_position_and_get_value(bits_from_value, last_six_bits);\n  }\n  return;\n}",
            "called": [
                "FUN_00001d5e",
                "FUN_00001ddc",
                "FUN_00001dc0",
                "FUN_00001da2",
                "FUN_00001ec4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001f80",
            "calling": [
                "FUN_00001eea",
                "FUN_00001448"
            ],
            "imported": true,
            "current_name": "update_bits_and_get_value_00001f80"
        },
        "FUN_00000e64": {
            "renaming": {
                "FUN_00000e64": "initialize_game_and_set_flags_00000e64",
                "DAT_00000ed4": "dat_2_ptr",
                "DAT_00000ed0": "dat_ptr",
                "insert_node_at_position_00001034": "insert_node_position_ptr",
                "setFlagBit_00001ff6": "setFlagBit",
                "set_flag_value_and_update_bits_00001eea": "set_flag_value_and_update_bits"
            },
            "code": "void initialize_game_and_set_flags_00000e64(void)\n{\n  uint32_t* insert_node_position_ptr = insert_node_at_position_00001034;\n  uint32_t* DAT_00000ed0 = DAT_00000ed0;\n  uint32_t* DAT_00000ed4 = DAT_00000ed4;\n  *(uint32_t *)(insert_node_position_ptr + *DAT_00000ed0 + 4) |= 0x200;\n  *(uint32_t *)(DAT_00000ed4 + 0x48) &= 0xfefff8ff;\n  initialize_game_00001274();\n  set_flag_value_and_update_bits_00001eea(0x2056,0x80);\n  set_flag_value_and_update_bits_00001eea(0x511a,0x80);\n  set_flag_value_and_update_bits_00001eea(0x2055,0x80);\n  setFlagBit_00001ff6(0x2056);\n  setFlagBit_00001ff6(0x511a);\n  setFlagBit_00001ff6(0x2055);\n  return;\n}",
            "called": [
                "FUN_00001eea",
                "FUN_00001274",
                "FUN_00001ff6"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e64",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": true,
            "current_name": "initialize_game_and_set_flags_00000e64"
        },
        "FUN_000026e4": {
            "renaming": {
                "FUN_000026e4": "clear_bit_in_uint_at_offset_from_data_000026e4",
                "DAT_00002990_00002970": "data"
            },
            "code": "void clear_bit_in_uint_at_offset_from_data_000026e4(void)\n{\n  clear_bit_in_uint_at_offset_from_data_000026e4();\n  return;\n}",
            "called": [
                "FUN_00002970"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026e4",
            "calling": [
                "FUN_00003524"
            ],
            "imported": true,
            "current_name": "clear_bit_in_uint_at_offset_from_data_000026e4"
        },
        "FUN_00000d44": {
            "renaming": {
                "FUN_00000d44": "calculate_address_offset_00000d44",
                "param_1": "address",
                "param_2": "offset"
            },
            "code": "int calculate_address_offset_00000d44(uint address, int offset) {\n    int masked_address = address & 0xf0000000;\n    int lower_bits = address & 0xfffff;\n    int shifted_bits = lower_bits << 5;\n    int result = (offset * 4) + masked_address + shifted_bits + 0x2000000;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d44",
            "calling": [
                "FUN_00000d76"
            ],
            "imported": true,
            "current_name": "calculate_address_offset_00000d44"
        },
        "FUN_00000698": {
            "renaming": {
                "PTR_DAT_00000734": "linked_list_mask",
                "FUN_00000698": "update_linked_list_00000698",
                "param_1": "index",
                "param_2": "value",
                "PTR_DAT_00000730": "linked_list_data"
            },
            "code": "void update_linked_list_00000698(int index, uint value)\n{\n    uint bitmask = 1 << index;\n    if (value < 9) {\n        byte current_value = *(byte *)(PTR_DAT_00000730 + 4 + index);\n        if (current_value > 8) {\n            reverse_linked_list_000005ca(PTR_DAT_00000730 + *(byte *)(PTR_DAT_00000730 + 5 + index) * 4);\n            if (*(int *)(PTR_DAT_00000730 + *(byte *)(PTR_DAT_00000730 + 5 + index) * 4) == 0) {\n                *(uint *)PTR_DAT_00000734 = *(uint *)PTR_DAT_00000734 & ~bitmask;\n            }\n        }\n    }\n    else {\n        byte current_value = *(byte *)(PTR_DAT_00000730 + 4 + index);\n        if (current_value < 9) {\n            update_pointer_0000058e(PTR_DAT_00000730 + *(byte *)(PTR_DAT_00000730 + 5 + index) * 4, PTR_DAT_00000730 + 8 + index);\n            *(uint *)PTR_DAT_00000734 = *(uint *)PTR_DAT_00000734 | bitmask;\n        }\n    }\n    *(byte *)(PTR_DAT_00000730 + 4 + index) = (byte)value;\n}",
            "called": [
                "FUN_000005ca",
                "FUN_0000058e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000698",
            "calling": [
                "FUN_000010d4",
                "FUN_00000794",
                "FUN_000024bc",
                "FUN_00002434"
            ],
            "imported": true,
            "current_name": "update_linked_list_00000698"
        },
        "FUN_00000cd0": {
            "renaming": {
                "bVar1": "is_privileged_mode",
                "FUN_00000cd0": "is_interrupts_enabled_in_privileged_mode_00000cd0",
                "uVar2": "are_interrupts_enabled"
            },
            "code": "bool is_interrupts_enabled_in_privileged_mode_00000cd0(void)\n{\n  bool is_privileged_mode = isCurrentModePrivileged();\n  bool are_interrupts_enabled = false;\n  if (is_privileged_mode) {\n    are_interrupts_enabled = isIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return are_interrupts_enabled;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cd0",
            "calling": [
                "FUN_000010d4",
                "FUN_00000794",
                "FUN_00001c84",
                "FUN_000024bc",
                "FUN_00000428",
                "FUN_00000f8c",
                "FUN_00000f04",
                "FUN_00000e58",
                "FUN_00002434"
            ],
            "imported": true,
            "current_name": "is_interrupts_enabled_in_privileged_mode_00000cd0"
        },
        "FUN_00000cc0": {
            "renaming": {
                "bVar1": "is_privileged_mode",
                "disableIRQinterrupts": "disableIRQinterrupts",
                "uRam00000ccc": "input_buffer",
                "FUN_00000cc0": "check_interrupts_and_return_status_00000cc0",
                "isIRQinterruptsEnabled": "isIRQinterruptsEnabled",
                "uVar2": "interrupt_status",
                "isCurrentModePrivileged": "isCurrentModePrivileged"
            },
            "code": "int check_interrupts_and_return_status_00000cc0(void)\n{\n  bool is_privileged_mode;\n  int interrupt_status = 0;\n  \n  process_input(10, input_buffer);\n  is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    interrupt_status = isIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return interrupt_status;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cc0",
            "calling": [
                "FUN_00000dc0"
            ],
            "imported": true,
            "current_name": "check_interrupts_and_return_status_00000cc0"
        },
        "FUN_00002994": {
            "renaming": {
                "DAT_000029f8": "data",
                "FUN_00002994": "check_and_call_functions_00002994"
            },
            "code": "void check_and_call_functions_00002994(void)\n{\n  int DAT_000029f8 = DAT_000029f8;\n  if (((*(uint *)(DAT_000029f8 + 0x14) & 4) != 0) && (*(int *)PTR_DAT_000029fc != 0)) {\n    *(uint *)(DAT_000029f8 + 0x1c) = *(uint *)(DAT_000029f8 + 0x1c) & 0xfffffffb;\n    (**(code **)PTR_DAT_000029fc)(*(undefined4 *)(PTR_DAT_000029fc + 4));\n  }\n  if (((*(uint *)(DAT_000029f8 + 0x14) & 2) != 0) && (*(int *)(PTR_DAT_000029fc + 8) != 0)) {\n    (**(code **)(PTR_DAT_000029fc + 8))(*(undefined4 *)(PTR_DAT_000029fc + 0xc));\n  }\n  checkFlag_00002798();\n  return;\n}",
            "called": [
                "FUN_00002798"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002994",
            "calling": [],
            "imported": true,
            "current_name": "check_and_call_functions_00002994"
        },
        "FUN_00000d2a": {
            "renaming": {
                "bVar1": "is_privileged_mode",
                "FUN_00000d2a": "get_current_exception_number_if_privileged_mode_00000d2a",
                "uVar2": "current_exception_number"
            },
            "code": "uint get_current_exception_number_if_privileged_mode_00000d2a(void)\n{\n  bool is_privileged_mode = (bool)isCurrentModePrivileged();\n  uint current_exception_number = 0;\n  if (is_privileged_mode) {\n    current_exception_number = getCurrentExceptionNumber();\n    current_exception_number &= 0x1f;\n  }\n  return current_exception_number;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d2a",
            "calling": [
                "FUN_00000738"
            ],
            "imported": true,
            "current_name": "get_current_exception_number_if_privileged_mode_00000d2a"
        },
        "FUN_00001ff6": {
            "renaming": {
                "iVar2": "flagAddress",
                "uVar1": "lastSixBits",
                "param_1": "flagValue",
                "FUN_00001ff6": "setFlagBit_00001ff6"
            },
            "code": "void setFlagBit_00001ff6(uint16_t flagValue)\n{\n  uint8_t lastSixBits = getLastSixBits(flagValue);\n  int flagAddress = getFlagAddress(flagValue);\n  *(int *)(flagAddress + 4) = 1 << (lastSixBits & 0xff);\n  return;\n}",
            "called": [
                "FUN_00001d80",
                "FUN_00001dc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ff6",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": true,
            "current_name": "setFlagBit_00001ff6"
        },
        "FUN_000013b8": {
            "renaming": {
                "uVar1": "status",
                "update_bits_if_not_negative_00001448": "update_bits_if_not_negative",
                "param_1": "index",
                "param_2": "value",
                "set_result_to_one_and_return_00001392": "set_result_to_one_and_return",
                "param_3": "mask",
                "param_4": "flag",
                "set_bits_000014c4": "set_bits",
                "FUN_000013b8": "process_input_and_return_status_000013b8",
                "PTR_s_FAILED_ASSERTION__0000143c": "\"Failed assertion\"",
                "PTR_DAT_00001444": "table",
                "PTR_DAT_00001440": "data"
            },
            "code": "int process_input_and_return_status_000013b8(int index, int value, int mask, int flag)\n{\n  int status;\n\n  if (index != 0) {\n    process_input(3, PTR_s_FAILED_ASSERTION__0000143c);\n  }\n  *(int *)(PTR_DAT_00001440 + index * 8) = value;\n  *(int *)(PTR_DAT_00001440 + index * 8 + 4) = mask;\n  update_bits_if_not_negative(index);\n  status = set_result_to_one_and_return(*(int *)(PTR_DAT_00001444 + index * 0x20 + 0x18),\n               PTR_DAT_00001444[index * 0x20 + 0x1c]);\n  if (PTR_DAT_00001444[index * 0x20 + 0x1e] == '\\0') {\n    set_bits(index, flag);\n    status = 0;\n  }\n  else {\n    status = -1;\n  }\n  return status;\n}",
            "called": [
                "FUN_00001448",
                "FUN_00001392",
                "FUN_00000f04",
                "FUN_000014c4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000013b8",
            "calling": [
                "FUN_00000df4"
            ],
            "imported": true,
            "current_name": "process_input_and_return_status_000013b8"
        },
        "FUN_00002a88": {
            "renaming": {
                "PTR_PTR_s_reboot_00002b0c": "reboot_command",
                "PTR_s_Description_00002afc": "description_format",
                "FUNC_00004c84": "print_formatted_line",
                "local_c": "description",
                "param_1": "command_list",
                "local_18": "command_array",
                "PTR_s___20s__s_00002b04": "header_format",
                "PTR_s__________________________________00002b08": "separator_format",
                "local_10": "command_index",
                "PTR_s_Command_00002b00": "command_format",
                "FUN_00002a88": "print_command_descriptions_00002a88"
            },
            "code": "void print_command_descriptions_00002a88(int *command_list)\n{\n  int *current_command;\n  uint command_index;\n  int *description;\n\n  print_header(\"    %20s %s\\n\", \"Command\", \"Description\");\n  print_separator();\n\n  current_command = command_list;\n  for (command_index = 0; command_index < 2; command_index++) {\n    description = current_command;\n    if (description != NULL) {\n      while (*description != 0) {\n        print_command_description(*description, *(description + 1));\n        description += 3;\n      }\n    }\n    current_command++;\n  }\n  return;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a88",
            "calling": [
                "FUN_00002b10"
            ],
            "imported": true,
            "current_name": "print_command_descriptions_00002a88",
            "code_backup": "\nvoid FUN_00002a88(int *param_1)\n\n{\n  int *local_18 [2];\n  uint local_10;\n  int *local_c;\n  \n  FUNC_00004c84(PTR_s___20s__s_00002b04,PTR_s_Command_00002b00,PTR_s_Description_00002afc);\n  FUNC_00004db8(PTR_s__________________________________00002b08);\n  local_18[0] = param_1;\n  local_18[1] = (int *)PTR_PTR_s_reboot_00002b0c;\n  for (local_10 = 0; local_10 < 2; local_10 = local_10 + 1) {\n    local_c = local_18[local_10];\n    if (local_c != (int *)0x0) {\n      for (; *local_c != 0; local_c = local_c + 3) {\n        FUNC_00004c84(PTR_s___20s__s_00002b04,*local_c,local_c[1]);\n      }\n    }\n  }\n  return;\n}\n\n"
        },
        "FUN_00002f30": {
            "renaming": {
                "FUN_00002f30": "display_data_from_devices_00002f30",
                "PTR_DAT_00002f70": "PTR_DAT_function_data",
                "local_c": "device_data_ptr",
                "FUNC_00004db8": "call_function_with_data",
                "undefined4": "device_data_type",
                "read_data_from_device_and_display_00002ecc": "read_and_display_device_data",
                "local_10": "device_index",
                "PTR_DAT_00002f6c": "PTR_DAT_device_data"
            },
            "code": "void display_data_from_devices_00002f30(void)\n{\n  int device_index = 0;\n  undefined4 *device_data_ptr = *(undefined4 **)PTR_DAT_00002f6c;\n  while (device_data_ptr != (undefined4 *)0x0) {\n    read_and_display_device_data(device_index,device_data_ptr);\n    call_function_with_data(PTR_DAT_00002f70);\n    device_index++;\n    device_data_ptr = (undefined4 *)*device_data_ptr;\n  }\n  return;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00002ecc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f30",
            "calling": [
                "FUN_00002fe0"
            ],
            "imported": true,
            "current_name": "display_data_from_devices_00002f30"
        },
        "FUN_00001e44": {
            "renaming": {
                "iVar1": "byte_offset",
                "FUN_00001e44": "update_bits_at_position_00001e44",
                "param_1": "byte_index",
                "*target_byte": "target_byte_value",
                "param_2": "bit_position",
                "param_3": "new_value",
                "PTR_DAT_00001ec0": "target_array",
                "mask": "bit_mask"
            },
            "code": "void update_bits_at_position_00001e44(int byte_index, uint32_t bit_position, int new_value)\n{\n  int byte_offset = (int)bit_position >> 3;\n  uint32_t* target_byte = (uint32_t*)(PTR_DAT_00001ec0 + (byte_offset + byte_index * 4) * 4);\n  uint32_t mask = ~(0xf << ((bit_position & 7) << 2));\n  *target_byte = (*target_byte & mask) | new_value << ((bit_position & 7) << 2);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e44",
            "calling": [
                "FUN_00001ec4"
            ],
            "imported": true,
            "current_name": "update_bits_at_position_00001e44"
        },
        "FUN_00001318": {
            "renaming": {
                "FUN_00001318": "set_bit_in_array_00001318",
                "param_1": "bit_index",
                "DAT_00001344": "array_start_address"
            },
            "code": "void set_bit_in_array_00001318(uint8_t bit_index){\n    uint32_t* array_ptr = (uint32_t*)(DAT_00001344 + (bit_index >> 5) * 4);\n    uint8_t bit_position = bit_index & 0x1f;\n    uint32_t bit_mask = 1 << bit_position;\n    *array_ptr = bit_mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001318",
            "calling": [
                "FUN_000014c4"
            ],
            "imported": true,
            "current_name": "set_bit_in_array_00001318"
        },
        "FUN_00000900": {
            "renaming": {
                "FUN_00000900": "get_main_stack_pointer_00000900",
                "uVar1": "main_stack_pointer"
            },
            "code": "uint32_t get_main_stack_pointer_00000900(void)\n{\n  uint32_t main_stack_pointer = 0;\n  main_stack_pointer = getMainStackPointer();\n  return main_stack_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000900",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": true,
            "current_name": "get_main_stack_pointer_00000900"
        },
        "FUN_00004274": {
            "renaming": {
                "PTR_DAT_0000427c": "PTR_DATA",
                "FUN_00004274": "do_nothing_with_pointer_00004274"
            },
            "code": "void do_nothing_with_pointer_00004274(void)\n{\n  do_nothing(PTR_DAT_0000427c);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004274",
            "calling": [
                "FUN_00004314"
            ],
            "imported": true,
            "current_name": "do_nothing_with_pointer_00004274"
        },
        "FUN_00002fe0": {
            "renaming": {
                "compare_bytes_00004e52": "compare_device_id_bytes",
                "get_value_at_index_00003d24": "get_device_index",
                "PTR_s_error__undefined_device_id_given_00003058": "undefined_device_id_error",
                "PTR_s_usage___s__s__device_id__all_00003050": "usage_string",
                "iVar1": "index",
                "FUNC_00004db8": "report_error",
                "param_1": "device_count",
                "convertStringToNumber_00004042": "convert_string_to_number",
                "FUN_00002fe0": "process_input_00002fe0",
                "read_data_from_device_and_display_00002ecc": "read_and_display_device_data",
                "display_data_from_devices_00002f30": "display_device_data",
                "PTR_DAT_00003054": "device_id_bytes",
                "param_2": "device_ids",
                "uVar2": "device_id"
            },
            "code": "void process_input_00002fe0(int device_count, undefined4 *device_ids)\n{\n  int index;\n  undefined4 device_id;\n  if (device_count < 3) {\n    process_input_00002fe0_and_call_function_00004c84(PTR_s_usage___s__s__device_id__all_00003050, *device_ids, device_ids[1]);\n  }\n  else {\n    index = compare_PTR_DAT_00003054(device_ids[2], PTR_DAT_00003054);\n    if (index == 0) {\n      display_data_from_devices_00002f30();\n    }\n    else {\n      device_id = convertStringToNumber_00004042(device_ids[2]);\n      index = get_device_index(device_id);\n      if (index == 0) {\n        report_error(PTR_s_error__undefined_device_id_given_00003058);\n      }\n      else {\n        read_and_display_device_data(device_id, index);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00002f30",
                "FUN_00003d24",
                "FUN_00002ecc",
                "FUN_00004e52",
                "FUN_00004c84",
                "FUN_00004042"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002fe0",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": true,
            "current_name": "process_input_00002fe0"
        },
        "FUN_00001dc0": {
            "renaming": {
                "param_1": "value",
                "FUN_00001dc0": "get_last_six_bits_00001dc0"
            },
            "code": "ushort get_last_six_bits_00001dc0(ushort value)\n{\n  ushort last_six_bits = value & 0x3f;\n  return last_six_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001dc0",
            "calling": [
                "FUN_00001eea",
                "FUN_00001f80",
                "FUN_00001ff6"
            ],
            "imported": true,
            "current_name": "get_last_six_bits_00001dc0"
        },
        "FUN_00000df4": {
            "renaming": {
                "PTR_check_and_increment_difference_000012b4_1_00000e10": "PTR_check_and_increment_difference_000012b4_1_00000e10",
                "process_input_and_return_status_000013b8": "process_input_and_return_status_000013b8",
                "input": "input",
                "FUN_00000df4": "process_input_and_return_status_00000df4",
                "DAT_00000e0c": "DAT_00000e0c",
                "difference": "difference",
                "status": "status"
            },
            "code": "void process_input_and_return_status_00000df4(void)\n{\n  int input = 0;\n  int status = 0x1c200;\n  int difference = 0;\n  process_input_and_return_status_00000df4_000013b8(input, status, PTR_check_and_increment_difference_000012b4_1_00000e10, DAT_00000e0c);\n  return;\n}",
            "called": [
                "FUN_000013b8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000df4",
            "calling": [
                "FUN_00000410"
            ],
            "imported": true,
            "current_name": "process_input_and_return_status_00000df4"
        },
        "FUN_00002400": {
            "renaming": {
                "FUN_00002400": "do_nothing_00002400"
            },
            "code": "\nvoid do_nothing_00002400(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002400",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": true,
            "current_name": "do_nothing_00002400"
        },
        "FUN_00002eb4": {
            "renaming": {
                "process_data_0000211c": "process_data",
                "FUN_00002eb4": "process_data_and_return_success_00002eb4"
            },
            "code": "undefined4 process_data_and_return_success_00002eb4(void)\n{\n  process_data();\n  return 0;\n}",
            "called": [
                "FUN_0000211c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002eb4",
            "calling": [],
            "imported": true,
            "current_name": "process_data_and_return_success_00002eb4"
        },
        "FUN_0000328c": {
            "renaming": {
                "DAT_00004fc4": "index",
                "local_a": "value",
                "param_1": "values",
                "DAT_00004fc0": "base",
                "param_2": "values",
                "local_10": "offset",
                "FUN_0000328c": "calculate_value_0000328c",
                "convertStringToNumber_00004f84": "convertStringToNumber"
            },
            "code": "int calculate_value_0000328c(int* values)\n{\n  int DAT_00004fc0 = 10;\n  int offset = 1;\n  int DAT_00004fc4 = 0;\n  int value = convertStringToNumber(values[DAT_00004fc4], &offset, DAT_00004fc0);\n  values[5] = value - 1892;\n  value = convertStringToNumber(values[DAT_00004fc4] + offset, &offset, DAT_00004fc0);\n  values[4] = value - 1;\n  value = convertStringToNumber(values[DAT_00004fc4] + offset, &offset, DAT_00004fc0);\n  values[3] = value;\n  value = convertStringToNumber(values[DAT_00004fc4 + 1], &offset, DAT_00004fc0);\n  values[2] = value;\n  value = convertStringToNumber(values[DAT_00004fc4 + 1] + offset, &offset, DAT_00004fc0);\n  values[1] = value;\n  value = convertStringToNumber(values[DAT_00004fc4 + 1] + offset, &offset, DAT_00004fc0);\n  values[0] = value;\n  int result = calculate_value_0000328c_000031fc(values[5] + 1892, values[4] + 1, values[3]);\n  values[6] = result;\n  values[8] = -1;\n  return 0;\n}",
            "called": [
                "FUN_000031fc",
                "FUN_00004f84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000328c",
            "calling": [
                "FUN_00003478",
                "FUN_000033f4"
            ],
            "imported": true,
            "current_name": "calculate_value_0000328c"
        },
        "FUN_000041f4": {
            "renaming": {
                "param_1": "data_buffer",
                "param_2": "initial_value_1",
                "param_3": "initial_value_2",
                "puVar1": "pointer_var_1",
                "FUN_000041f4": "initialize_data_000041f4"
            },
            "code": "void initialize_data_000041f4(undefined4 *data_buffer, undefined2 initial_value_1, undefined2 initial_value_2) {\n  data_buffer[0] = 0;\n  data_buffer[1] = 0;\n  data_buffer[2] = 0;\n  data_buffer[3] = initial_value_1;\n  data_buffer[4] = 0;\n  data_buffer[5] = 0;\n  data_buffer[6] = 0;\n  data_buffer[7] = 0;\n  data_buffer[8] = data_buffer;\n  data_buffer[9] = PTR_process_data_00004dc8_1_0000422c;\n  data_buffer[10] = DAT_00004230;\n  data_buffer[11] = PTR_set_param_to_19_00004e26_1_00004234;\n  data_buffer[12] = PTR_LAB_00004e4a_1_00004238;\n  data_buffer[25] = 0;\n  data_buffer[26] = 0;\n}\n",
            "called": [
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041f4",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": true,
            "current_name": "initialize_data_000041f4"
        },
        "FUN_0000316c": {
            "renaming": {
                "compare_bytes_00004e52": "compare_bytes",
                "PTR_DAT_000031d4": "PTR_DAT_000031d4",
                "iVar1": "comparison_result",
                "writeDataToDevice_0000305c": "write_data_to_device",
                "PTR_s_usage___s_read_write_000031dc": "PTR_s_usage___s_read_write_000031dc",
                "PTR_s_write_000031d8": "PTR_s_write_000031d8",
                "param_1": "num_params",
                "process_input_00002fe0": "process_input",
                "param_2": "params",
                "print_device_info_00002f74": "print_device_info",
                "process_input_and_call_function_00004c84": "process_input_and_call_function",
                "FUN_0000316c": "process_input_and_call_function_0000316c"
            },
            "code": "int process_input_and_call_function_0000316c(int num_params, char **params) {\n  int comparison_result;\n  if (num_params < 2) {\n    print_device_info();\n  }\n  else {\n    comparison_result = compare_bytes(params[1], PTR_DAT_000031d4);\n    if (comparison_result == 0) {\n      process_input(num_params, params);\n    }\n    else {\n      comparison_result = compare_bytes(params[1], PTR_s_write_000031d8);\n      if (comparison_result == 0) {\n        write_data_to_device(num_params, params);\n      }\n      else {\n        process_input_and_call_function_0000316c(PTR_s_usage___s_read_write_000031dc, *params);\n      }\n    }\n  }\n  return 0;\n}",
            "called": [
                "FUN_00002f74",
                "FUN_00002fe0",
                "FUN_00004e52",
                "FUN_00004c84",
                "FUN_0000305c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000316c",
            "calling": [],
            "imported": true,
            "current_name": "process_input_and_call_function_0000316c"
        },
        "FUN_000026f0": {
            "renaming": {
                "code": "code_ptr",
                "param_1": "param",
                "PTR_DAT_00002710": "ptr",
                "FUN_000026f0": "execute_function_if_not_null_000026f0"
            },
            "code": "void execute_function_if_not_null_000026f0(int param){\n  int* PTR_DAT_00002710 = (int*)PTR_DAT_00002710;\n  if (*PTR_DAT_00002710 != 0) {\n    code* func_PTR_DAT_00002710 = *(code**)PTR_DAT_00002710;\n    func_PTR_DAT_00002710(param);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026f0",
            "calling": [],
            "imported": true,
            "current_name": "execute_function_if_not_null_000026f0"
        },
        "FUN_000057d2": {
            "renaming": {
                "FUN_000057d2": "process_input_000057d2",
                "iVar1": "result",
                "iVar3": "iteration_count",
                "puVar2": "end_ptr",
                "param_1": "input_param1",
                "param_2": "input_param2",
                "param_3": "input_array",
                "param_4": "input_array_len"
            },
            "code": "int process_input_000057d2(int input_param1, int input_param2, char* input_array, int input_array_len) {\n  int iteration_count = 0;\n  char* current_ptr = input_array;\n  while (iteration_count != input_array_len) {\n    if (current_ptr == input_array + input_array_len) {\n      return 0;\n    }\n    int result = process_input_000057d2_000057a8(input_param1, *current_ptr, input_param2, input_array_len, iteration_count);\n    iteration_count = result + 1;\n    current_ptr++;\n  }\n  return result;\n}",
            "called": [
                "FUN_000057a8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057d2",
            "calling": [
                "FUN_000057f8"
            ],
            "imported": true,
            "current_name": "process_input_000057d2"
        },
        "FUN_000056b8": {
            "renaming": {
                "iVar1": "status",
                "FUN_000056b8": "check_value_and_set_flag_000056b8",
                "param_1": "value",
                "param_2": "offset",
                "param_3": "flag",
                "param_4": "result",
                "auStack_68": "val",
                "uVar2": "mask",
                "local_64": "check"
            },
            "code": "int check_value_and_set_flag_000056b8(int value, int offset, int* flag, uint* result) {\n  int status;\n  uint mask = 0x400;\n  uint check = *(ushort *)(offset + 0xc);\n  int val = *(short *)(offset + 0xe);\n  if (val < 0 || set_value_and_return_negative_one(value, val, flag) < 0) {\n    *result = 0;\n    if ((int)(check << 0x18) < 0) {\n      mask = 0x40;\n    }\n  } else {\n    *result = ((mask & 0xf000) == 0x2000);\n  }\n  *flag = mask;\n  return 0;\n}",
            "called": [
                "FUN_00000514"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b8",
            "calling": [
                "FUN_00005700"
            ],
            "imported": true,
            "current_name": "check_value_and_set_flag_000056b8"
        },
        "FUN_00001a18": {
            "renaming": {
                "FUN_00001a18": "set_offset_and_value_for_array_00001a18",
                "PTR_DAT_00001a38": "ptr_array_value",
                "set_offset_to_zero_for_six_elements_00001734": "set_offset_to_zero_for_six_elements",
                "DAT_00001a34": "array",
                "set_offset_to_one_000016ec": "set_offset_to_one"
            },
            "code": "void set_offset_and_value_for_array_00001a18(void)\n{\n  set_offset_to_one(DAT_00001a34, 1);\n  set_offset_to_zero_for_six_elements();\n  *PTR_DAT_00001a38 = 4;\n  return;\n}",
            "called": [
                "FUN_000016ec",
                "FUN_00001734"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a18",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": true,
            "current_name": "set_offset_and_value_for_array_00001a18"
        },
        "FUN_00000d9c": {
            "renaming": {
                "clear_memory_at_address_offset_00000d76": "clear_memory_at_address_offset",
                "FUN_00000d9c": "clear_memory_00000d9c",
                "DAT_00000dac": "PTR_memory_address"
            },
            "code": "void clear_memory_00000d9c(void)\n{\n  clear_memory_00000d9c_at_address_offset(DAT_00000dac,0);\n  return;\n}",
            "called": [
                "FUN_00000d76"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d9c",
            "calling": [
                "FUN_00000db0"
            ],
            "imported": true,
            "current_name": "clear_memory_00000d9c"
        },
        "FUN_00003ff4": {
            "renaming": {
                "fill_array_with_value_00004622": "fill_array_with_value",
                "uVar1": "new_destination",
                "param_1": "destination_start",
                "FUN_00003ff4": "copy_and_fill_00003ff4",
                "param_2": "source_start",
                "param_3": "source_end",
                "param_4": "fill_value",
                "reverse_copy_range_000045ee": "reverse_copy_range"
            },
            "code": "uint copy_and_fill_00003ff4(uint destination_start, uint source_start, uint source_end, undefined fill_value)\n{\n  uint new_destination = source_start;\n  if ((source_start < source_end) && (destination_start != 0)) {\n    reverse_copy_range((source_end - source_start) + destination_start, destination_start, source_start);\n    fill_array_with_value(destination_start, fill_value, source_end - source_start);\n  }\n  return new_destination;\n}",
            "called": [
                "FUN_00004622",
                "FUN_000045ee"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ff4",
            "calling": [
                "FUN_00003ec4"
            ],
            "imported": true,
            "current_name": "copy_and_fill_00003ff4"
        },
        "FUN_00004634": {
            "renaming": {
                "FUN_00004634": "FUNC_00004634"
            },
            "code": "\nvoid FUNC_00004634(uint *param_1,uint param_2,undefined4 param_3)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  bool bVar6;\n  uint *local_20;\n  uint local_1c;\n  undefined4 uStack_18;\n  \n  local_20 = param_1;\n  local_1c = param_2;\n  uStack_18 = param_3;\n  if (0x3b < *param_1) {\n    divide_and_remainder_00005584(&local_20,*param_1,0x3c);\n    uVar3 = param_1[1] + (int)local_20;\n    param_1[1] = uVar3;\n    if ((int)local_1c < 0) {\n      uVar3 = uVar3 - 1;\n      *param_1 = local_1c + 0x3c;\n    }\n    else {\n      *param_1 = local_1c;\n    }\n    if ((int)local_1c < 0) {\n      param_1[1] = uVar3;\n    }\n  }\n  if (0x3b < param_1[1]) {\n    divide_and_remainder_00005584(&local_20,param_1[1],0x3c);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[2] + (int)local_20;\n    param_1[2] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x3c;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar4;\n    }\n  }\n  if (0x17 < param_1[2]) {\n    divide_and_remainder_00005584(&local_20,param_1[2],0x18);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[3] + (int)local_20;\n    param_1[3] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x18;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[3] = uVar4;\n    }\n  }\n  if (0xb < param_1[4]) {\n    divide_and_remainder_00005584(&local_20,param_1[4],0xc);\n    bVar6 = (int)local_1c < 0;\n    uVar3 = param_1[5] + (int)local_20;\n    param_1[5] = uVar3;\n    if (bVar6) {\n      local_1c = local_1c + 0xc;\n      uVar3 = uVar3 - 1;\n    }\n    if (!bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[5] = uVar3;\n    }\n  }\n  puVar1 = PTR_DAT_000047e0;\n  uVar3 = param_1[5];\n  if ((uVar3 & 3) == 0) {\n    if (uVar3 == (uVar3 / 100) * 100) {\n      if ((uVar3 + 0x76c) % 400 == 0) {\n        iVar5 = 0x1d;\n      }\n      else {\n        iVar5 = 0x1c;\n      }\n    }\n    else {\n      iVar5 = 0x1d;\n    }\n  }\n  else {\n    iVar5 = 0x1c;\n  }\n  if ((int)param_1[3] < 1) {\n    while ((int)param_1[3] < 1) {\n      uVar3 = param_1[4];\n      param_1[4] = uVar3 - 1;\n      if (uVar3 - 1 == 0xffffffff) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 - 1;\n        param_1[4] = 0xb;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 == (uVar3 / 100) * 100) {\n            if ((uVar4 + 0x76b) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n      iVar2 = iVar5;\n      if (param_1[4] != 1) {\n        iVar2 = *(int *)(puVar1 + param_1[4] * 4);\n      }\n      param_1[3] = iVar2 + param_1[3];\n    }\n  }\n  else {\n    while( true ) {\n      uVar3 = param_1[4];\n      iVar2 = iVar5;\n      if (uVar3 != 1) {\n        iVar2 = *(int *)(puVar1 + uVar3 * 4);\n      }\n      if ((int)param_1[3] <= iVar2) break;\n      param_1[3] = param_1[3] - iVar2;\n      param_1[4] = uVar3 + 1;\n      if (uVar3 + 1 == 0xc) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 + 1;\n        param_1[4] = 0;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 % 100 == 0) {\n            if ((uVar4 + 0x76d) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00005584"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00004634",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "FUNC_00004634"
        },
        "FUN_00001d5e": {
            "renaming": {
                "param_1": "inputParam",
                "FUN_00001d5e": "combineAndShift_00001d5e",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "uint combineAndShift_00001d5e(ushort inputParam)\n{\n    uint mask = 0x7000;\n    uint result = inputParam & mask;\n    uint constant = 0x40048000;\n    return result | constant;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d5e",
            "calling": [
                "FUN_00001eea",
                "FUN_00001f80"
            ],
            "imported": true,
            "current_name": "combineAndShift_00001d5e"
        },
        "FUN_0000191c": {
            "renaming": {
                "set_param_00001748": "set_parameter",
                "FUN_0000191c": "set_flag_and_wait_until_ready_0000191c",
                "*PTR_DAT_0000195c": "*status",
                "*DAT_00001958": "*flag",
                "set_offset_and_flag_00001778": "set_offset_and_flag"
            },
            "code": "void set_flag_and_wait_until_ready_0000191c(void)\n{\n  set_offset_and_flag();\n  set_parameter(64);\n  *DAT_00001958 = *DAT_00001958 & 0x3b;\n  do {\n  } while ((*DAT_00001958 & 0xc) != 0);\n  *PTR_DAT_0000195c = 1;\n  return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001778"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000191c",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": true,
            "current_name": "set_flag_and_wait_until_ready_0000191c"
        },
        "FUN_000050f4": {
            "renaming": {
                "PTR_DAT_000050fc": "data_pointer",
                "FUN_000050f4": "get_data_pointer_000050f4"
            },
            "code": "void * get_data_pointer_000050f4(void) {\n  return PTR_DAT_000050fc;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050f4",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": true,
            "current_name": "get_data_pointer_000050f4"
        },
        "FUN_00005a58": {
            "renaming": {
                "iVar1": "res",
                "param_1": "data",
                "param_2": "start",
                "param_3": "end",
                "param_4": "param",
                "param_5": "func",
                "uVar3": "length",
                "uVar2": "status",
                "uVar4": "j",
                "FUN_00005a58": "processData_00005a58",
                "bVar5": "flag2"
            },
            "code": "int processData_00005a58(uint32_t data, uint32_t *start, uint32_t *end, uint32_t param, code *func) {\\n  int status = 0;\\n  uint32_t length = start[4];\\n  if (length < start[2]) {\\n    length = start[2];\\n  }\\n  *end = length;\\n  if (*(char *)((int)start + 0x43) != \"\\0\") {\\n    *end = length + 1;\\n  }\\n  if ((int)(*start << 0x1a) < 0) {\\n    *end = *end + 2;\\n  }\\n  uint32_t i = *start & 6;\\n  if (i == 0) {\\n    for (; (int)i < (int)(start[3] - *end); i++) {\\n      int res = (*func)(data, param, (int)start + 0x19, 1);\\n      if (res == -1) {\\n        goto LAB_00005afc;\\n      }\\n    }\\n  }\\n  uint32_t flag = (uint32_t)*(byte *)((int)start + 0x43);\\n  if (flag != 0) {\\n    flag = 1;\\n  }\\n  if ((int)(*start << 0x1a) < 0) {\\n    *(undefined *)((int)start + flag + 0x43) = 0x30;\\n    *(undefined *)((int)start + flag + 0x44) = *(undefined *)((int)start + 0x45);\\n    flag += 2;\\n  }\\n  int res = (*func)(data, param, (int)start + 0x43, flag);\\n  if (res == -1) {\\n    goto LAB_00005afc;\\n  }\\n  length = start[3];\\n  bool flag2 = (*start & 6) == 4;\\n  if (flag2) {\\n    length = length - *end;\\n  }\\n  if (flag2) {\\n    length &= ~((int)length >> 0x1f);\\n  }\\n  else {\\n    length = 0;\\n  }\\n  if (start[4] < start[2]) {\\n    length += start[2] - start[4];\\n  }\\n  for (uint32_t j = 0; j != length; j++) {\\n    int res = (*func)(data, param, (int)start + 0x1a, 1);\\n    if (res == -1) {\\n      goto LAB_00005afc;\\n    }\\n  }\\n  status = 0;\\n  goto LAB_00005afe;\\nLAB_00005afc:\\n  status = -1;\\nLAB_00005afe:\\n  return status;\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005a58",
            "calling": [
                "FUN_00005b34"
            ],
            "imported": true,
            "current_name": "processData_00005a58"
        },
        "FUN_000056b0": {
            "renaming": {
                "DAT_000056b4": "data",
                "FUN_000056b0": "get_data_000056b0"
            },
            "code": "int get_data_000056b0(void)\n{\n  return DAT_000056b4;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b0",
            "calling": [
                "FUN_000047e4",
                "FUN_00004f98",
                "FUN_00005100"
            ],
            "imported": true,
            "current_name": "get_data_000056b0"
        },
        "FUN_00003d24": {
            "renaming": {
                "FUN_00003d24": "get_value_at_index_00003d24",
                "local_c": "current_value",
                "param_1": "index",
                "local_10": "count"
            },
            "code": "undefined4 * get_value_at_index_00003d24(int index)\n{\n  int count = 0;\n  undefined4 *current_value = *(undefined4 **)PTR_DAT_00003d60;\n  \n  while (count < index && current_value != (undefined4 *)0x0) {\n    current_value = (undefined4 *)*current_value;\n    count++;\n  }\n  \n  return current_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d24",
            "calling": [
                "FUN_00002fe0",
                "FUN_0000305c"
            ],
            "imported": true,
            "current_name": "get_value_at_index_00003d24"
        },
        "FUN_000060cc": {
            "renaming": {
                "insert_element_00004b34": "insert_element_at_end",
                "uVar1": "allocated_block_position",
                "FUN_000060cc": "allocate_block_if_needed_000060cc",
                "param_1": "memory_address",
                "calculate_new_position_00006964": "calculate_new_position",
                "allocate_memory_block_00004bd0": "allocate_memory_block",
                "param_2": "start_position",
                "param_3": "end_position",
                "param_4": "extra_param",
                "copy_string_000060b0": "copy_string",
                "uVar2": "new_position"
            },
            "code": "uint allocate_block_if_needed_000060cc(undefined4 memory_address, uint start_position, uint end_position, undefined4 extra_param)\n{\n  uint allocated_block_position;\n  uint new_position;\n  \n  if (start_position != 0) {\n    if (end_position == 0) {\n      insert_element_at_end();\n      allocated_block_position = end_position;\n    }\n    else {\n      new_position = calculate_new_position();\n      allocated_block_position = start_position;\n      if ((new_position < end_position) && (allocated_block_position = allocate_memory_block(memory_address, end_position), allocated_block_position != 0)) {\n        copy_string(allocated_block_position, start_position, end_position);\n        insert_element_at_end(memory_address, start_position);\n      }\n    }\n    return allocated_block_position;\n  }\n  allocated_block_position = allocate_memory_block(memory_address, end_position, end_position, extra_param);\n  return allocated_block_position;\n}",
            "called": [
                "FUN_00004bd0",
                "FUN_00006964",
                "FUN_000060b0",
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060cc",
            "calling": [
                "FUN_000068f0"
            ],
            "imported": true,
            "current_name": "allocate_block_if_needed_000060cc"
        },
        "FUN_00003dc4": {
            "renaming": {
                "local_c": "result",
                "param_1": "input_number",
                "FUN_00003dc4": "calculate_digits_00003dc4",
                "param_2": "multiplier",
                "local_10": "digit_count",
                "local_20": "multiplier_copy",
                "local_14": "current_char"
            },
            "code": "int calculate_digits_00003dc4(int input_number, uint multiplier) {\n  uint multiplier_copy;\n  char *current_char;\n  uint digit_count;\n  int result;\n  result = 1;\n  if (DAT_00003e50 < multiplier) {\n    result = 10;\n  }\n  else {\n    for (digit_count = 10; digit_count <= multiplier; digit_count = digit_count * 10) {\n      result = result + 1;\n    }\n  }\n  if (input_number != 0) {\n    current_char = (char *)(result + input_number);\n    multiplier_copy = multiplier;\n    do {\n      current_char = current_char + -1;\n      *current_char = (char)multiplier_copy + (char)(uint)((ulonglong)DAT_00003e54 * (ulonglong)multiplier_copy >> 0x23) * -10 + '0';\n      multiplier_copy = (uint)((ulonglong)DAT_00003e54 * (ulonglong)multiplier_copy >> 0x23);\n    } while (multiplier_copy != 0);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003dc4",
            "calling": [
                "FUN_00003e58"
            ],
            "imported": true,
            "current_name": "calculate_digits_00003dc4"
        },
        "FUN_000022be": {
            "renaming": {
                "address": "address",
                "offset": "offset",
                "uVar1": "index",
                "param_1": "array",
                "FUN_000022be": "increment_and_store_value_at_address_000022be",
                "param_2": "value"
            },
            "code": "void increment_and_store_value_at_address_000022be(int *array, undefined value) {\n  uint index = array[3];\n  array[3] = index + 1;\n  uint offset = index & (array[1] - 1U);\n  uint address = offset + *array;\n  *(undefined *)(address) = value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022be",
            "calling": [
                "FUN_00002364"
            ],
            "imported": true,
            "current_name": "increment_and_store_value_at_address_000022be"
        },
        "FUN_00002108": {
            "renaming": {
                "DAT_00002118": "flags",
                "process_flags_00002028": "set_flags",
                "FUN_00002108": "process_flags_00002108"
            },
            "code": "void process_flags_00002108(void)\n{\n  int DAT_00002118 = get_DAT_00002118();\n  set_DAT_00002118(DAT_00002118, 4);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002108",
            "calling": [],
            "imported": true,
            "current_name": "process_flags_00002108"
        },
        "FUN_00001d80": {
            "renaming": {
                "param_1": "flag",
                "FUN_00001d80": "getFlagValue_00001d80"
            },
            "code": "uint getFlagValue_00001d80(ushort flag) {\n  uint mask = flag & 0x1c0;\n  uint value = 0x400ff000;\n  return mask | value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d80",
            "calling": [
                "FUN_00001eea",
                "FUN_00001ff6"
            ],
            "imported": true,
            "current_name": "getFlagValue_00001d80"
        },
        "FUN_000033c0": {
            "renaming": {
                "iVar1": "date",
                "auStack_2c": "alarm_info",
                "FUN_000033c0": "check_alarm_and_calculate_000033c0"
            },
            "code": "bool check_alarm_and_calculate_000033c0(void)\n{\n  int date;\n  undefined alarm_info [36];\n  date = calculate_date_from_timestamp_and_increment_00002690(alarm_info);\n  if (date != 0) {\n    FUNC_00004db8(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else {\n    perform_calculation_00003378(alarm_info);\n  }\n  return date != 0;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00002690",
                "FUN_00003378"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": true,
            "current_name": "check_alarm_and_calculate_000033c0",
            "code_backup": "\nbool FUN_000033c0(void)\n\n{\n  int iVar1;\n  undefined auStack_2c [36];\n  \n  iVar1 = calculate_date_from_timestamp_and_increment_00002690(auStack_2c);\n  if (iVar1 != 0) {\n    FUNC_00004db8(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else {\n    perform_calculation_00003378(auStack_2c);\n  }\n  return iVar1 != 0;\n}\n\n"
        },
        "FUN_00002b10": {
            "renaming": {
                "FUNC_00004db8": "exit_shell",
                "param_1": "command_id",
                "MAX_ARGS": "MAX_COMMAND_ARGS",
                "FUNC_00004e52": "compare_bytes",
                "local_2d": "quote_type",
                "local_2c": "c",
                "PTR_s_shell__command_not_found___s_00002d90": "COMMAND_NOT_FOUND_MSG",
                "local_28": "current_char",
                "local_48": "args",
                "local_20": "i",
                "local_24": "args",
                "FUNC_00004c84": "process_input_and_call_function",
                "FUNC_print_command_descriptions": "print_command_descriptions",
                "local_1c": "escape_count",
                "FUNC_find_matching_function": "find_matching_function",
                "local_3c": "matching_function",
                "local_18": "arg_count",
                "PTR_DAT_00002d8c": "COMMAND_LIST",
                "local_38": "current_arg",
                "DAT_00002d88": "SHELL_ERROR_MSG",
                "param_2": "command_string",
                "local_14": "current_char",
                "local_34": "arg_count",
                "FUN_00002b10": "parse_and_execute_command_00002b10",
                "PTR_COMMAND_NOT_FOUND": "COMMAND_NOT_FOUND_MSG"
            },
            "code": "void parse_and_execute_command_00002b10(uint32_t command_id, char* command_string)\n{\n  uint32_t arg_count = 0;\n  uint32_t escape_count = 0;\n  char* current_char;\n  char** args;\n  char** current_arg;\n  code* matching_function;\n  int32_t compare_result;\n\n  // Initialize variables\n  args = (char**)malloc(MAX_ARGS * sizeof(char*));\n  current_arg = args;\n\n  // Parse command string and split arguments\n  current_char = command_string;\n  while (*current_char != \"\\0\") {\n    if (*current_char > 0x20) {\n      // Start of new argument\n      if (*current_char == \"\\\"\" || *current_char == \"\\\"\") {\n        char quote_type = *current_char;\n        current_char++;\n        while (*current_char != \"\\0\") {\n          if (*current_char == \"\\\") {\n            escape_count++;\n            current_char++;\n          }\n          else if (*current_char == quote_type) {\n            current_char++;\n            break;\n          }\n          current_char++;\n        }\n        if (*current_char > 0x20 && *current_char != \"\\0\") {\n          FUNC_command_not_found();\n          free(args);\n          return;\n        }\n      }\n      else {\n        // Parse regular argument\n        *current_arg = current_char;\n        arg_count++;\n        current_arg++;\n        while (*current_char != \"\\0\" && *current_char > 0x20 && *current_char != \"\\\"\" && *current_char != \"\\\"\") {\n          if (*current_char == \"\\\") {\n            escape_count++;\n            current_char++;\n          }\n          current_char++;\n        }\n        if (*current_char == \"\\\"\" || *current_char == \"\\\"\") {\n          FUNC_command_not_found();\n          free(args);\n          return;\n        }\n        *current_char = \"\\0\";\n      }\n    }\n    current_char++;\n  }\n\n  // Remove escape characters from arguments\n  current_arg = args;\n  while (escape_count > 0 && *current_arg != NULL) {\n    char* current_char = *current_arg;\n    while (*current_char != \"\\0\") {\n      if (*current_char == \"\\\") {\n        escape_count--;\n        for (char* c = current_char; *c != \"\\0\"; c++) {\n          *c = *(c + 1);\n        }\n      }\n      current_char++;\n    }\n    current_arg++;\n  }\n\n  // Find matching function and execute\n  *current_arg = NULL;\n  matching_function = FUNC_find_matching_function(command_id, args);\n  if (matching_function == NULL) {\n    compare_result = FUNC_compare_strings(PTR_COMMAND_NOT_FOUND, args);\n    if (compare_result == 0) {\n      FUNC_print_command_descriptions(command_id);\n    }\n    else {\n      FUNC_command_not_found();\n    }\n  }\n  else {\n    (*matching_function)(arg_count, args);\n  }\n\n  // Clean up\n  free(args);\n  return;\n}",
            "called": [
                "FUN_00002a18",
                "FUN_00004db8",
                "FUN_00004e52",
                "FUN_00004c84",
                "FUN_00002a88"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002b10",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": true,
            "current_name": "parse_and_execute_command_00002b10"
        },
        "FUN_00001b10": {
            "renaming": {
                "FUN_00001b10": "perform_device_operations_00001b10",
                "set_offset_and_value_for_array_00001a18": "set_offset_and_value_for_array",
                "uVar1": "result",
                "set_flag_and_offset_000019c0": "set_flag_and_offset",
                "reset_data_00001ad4": "reset_data",
                "set_flag_and_wait_until_ready_0000191c": "set_flag_and_wait_until_ready",
                "initializeDevice_00001960": "initialize_device_2",
                "param_1": "operation_count",
                "set_offset_and_value_00001a3c": "set_offset_and_value",
                "initialize_device_000018bc": "initialize_device",
                "initialize_data_00001a60": "initialize_data",
                "PTR_DAT_00001bb4": "operation_type_table",
                "PTR_DAT_00001bb0": "operation_count_address"
            },
            "code": "int perform_device_operations_00001b10(byte operation_count) {\n  int result;\n  if (operation_count >= 8) {\n    result = -1;\n  }\n  else {\n    uint8_t current_operation_index = 0;\n    do {\n      uint8_t operation_type = *(uint8_t*)(PTR_DAT_00001bb4 + current_operation_index + *(uint8_t*)PTR_DAT_00001bb0 * 8);\n      switch (operation_type) {\n        case 0:\n          initialize_device();\n          break;\n        case 1:\n          set_flag_and_wait_until_ready();\n          break;\n        case 2:\n          initialize_device_2();\n          break;\n        case 3:\n          set_flag_and_offset();\n          break;\n        case 4:\n          set_offset_and_value_for_array();\n          break;\n        case 5:\n          set_offset_and_value();\n          break;\n        case 6:\n          initialize_data();\n          break;\n        case 7:\n          reset_data();\n          break;\n        default:\n          return -1;\n      }\n      current_operation_index += 1;\n    } while (current_operation_index != *(uint8_t*)PTR_DAT_00001bb0);\n    result = 0;\n  }\n  return result;\n}",
            "called": [
                "FUN_00001a3c",
                "FUN_0000191c",
                "FUN_00001ad4",
                "FUN_00001a18",
                "FUN_000018bc",
                "FUN_000019c0",
                "FUN_00001a60",
                "FUN_00001960"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001b10",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": true,
            "current_name": "perform_device_operations_00001b10"
        },
        "FUN_000047e4": {
            "renaming": {
                "FUN_000047e4": "FUNC_000047e4"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\nundefined8 FUNC_000047e4(int *param_1)\n\n{\n  longlong lVar1;\n  longlong lVar2;\n  int *piVar3;\n  uint uVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  int iVar11;\n  uint uVar12;\n  uint uVar13;\n  uint uVar14;\n  uint uVar15;\n  bool bVar16;\n  \n  piVar3 = (int *)get_data_000056b0();\n  FUNC_00004634(param_1);\n  uVar12 = param_1[5];\n  iVar11 = param_1[3] + -1 + *(int *)(PTR_DAT_00004adc + param_1[4] * 4);\n  if (((1 < param_1[4]) && ((uVar12 & 3) == 0)) &&\n     ((uVar12 != (uVar12 / 100) * 100 || (uVar12 + 0x76c == ((uVar12 + 0x76c) / 400) * 400)))) {\n    iVar11 = iVar11 + 1;\n  }\n  param_1[7] = iVar11;\n  if (20000 < (int)&PTR_DAT_00002710 + uVar12) {\n    iVar7 = -1;\n    iVar5 = -1;\n    goto LAB_00004aba;\n  }\n  if ((int)uVar12 < 0x47) {\n    if (uVar12 != 0x46) {\n      for (uVar9 = 0x45; (int)uVar12 < (int)uVar9; uVar9 = uVar9 - 1) {\n        if ((uVar9 & 3) == 0) {\n          if (uVar9 == (uVar9 / 100) * 100) {\n            if ((uVar9 + 0x76c) % 400 == 0) {\n              iVar7 = 0x16e;\n            }\n            else {\n              iVar7 = 0x16d;\n            }\n          }\n          else {\n            iVar7 = 0x16e;\n          }\n        }\n        else {\n          iVar7 = 0x16d;\n        }\n        iVar11 = iVar11 - iVar7;\n      }\n      if ((uVar9 & 3) == 0) {\n        if (uVar12 == (uVar12 / 100) * 100) {\n          iVar7 = 0x16d;\n          if ((uVar12 + 0x76c) % 400 == 0) {\n            iVar7 = 0x16e;\n          }\n        }\n        else {\n          iVar7 = 0x16e;\n        }\n      }\n      else {\n        iVar7 = 0x16d;\n      }\n      iVar11 = iVar11 - iVar7;\n    }\n  }\n  else {\n    uVar9 = 0x46;\n    do {\n      if ((uVar9 & 3) == 0) {\n        if (uVar9 % 100 == 0) {\n          if ((uVar9 + 0x76c) % 400 == 0) {\n            iVar7 = 0x16e;\n          }\n          else {\n            iVar7 = 0x16d;\n          }\n        }\n        else {\n          iVar7 = 0x16e;\n        }\n      }\n      else {\n        iVar7 = 0x16d;\n      }\n      uVar9 = uVar9 + 1;\n      iVar11 = iVar11 + iVar7;\n    } while (uVar12 != uVar9);\n  }\n  lVar1 = (longlong)DAT_00004ae0 * (longlong)iVar11 +\n          (longlong)(param_1[2] * 0xe10 + param_1[1] * 0x3c + *param_1);\n  uVar15 = (uint)lVar1;\n  iVar7 = (int)((ulonglong)lVar1 >> 0x20);\n  get_pointer_to_data_000050e8();\n  FUNC_00005100();\n  uVar9 = *(uint *)PTR_DAT_00004ae4;\n  if (*(uint *)PTR_DAT_00004ae4 == 0) {\nLAB_00004934:\n    uVar12 = piVar3[10];\n    iVar7 = (uint)lVar1 + uVar12;\n    iVar5 = (int)((ulonglong)lVar1 >> 0x20) +\n            ((int)uVar12 >> 0x1f) + (uint)CARRY4((uint)lVar1,uVar12);\n  }\n  else {\n    uVar14 = param_1[8];\n    uVar13 = uVar14;\n    if (0 < (int)uVar14) {\n      uVar13 = 1;\n    }\n    if ((piVar3[1] == param_1[5] + 0x76c) || (iVar5 = calculate_day_of_week_00004f98(), iVar5 != 0)) {\n      uVar10 = piVar3[0x14];\n      uVar4 = piVar3[0x12];\n      uVar8 = piVar3[10];\n      uVar9 = uVar4 - uVar8;\n      iVar5 = (piVar3[0x13] - ((int)uVar8 >> 0x1f)) - (uint)(uVar4 < uVar8);\n      if (((int)((iVar7 - iVar5) - (uint)(uVar15 < uVar9)) < 0 ==\n           (SBORROW4(iVar7,iVar5) != SBORROW4(iVar7 - iVar5,(uint)(uVar15 < uVar9)))) &&\n         (iVar6 = (piVar3[0x13] - ((int)uVar10 >> 0x1f)) - (uint)(uVar4 < uVar10),\n         bVar16 = uVar15 < uVar4 - uVar10,\n         (int)((iVar7 - iVar6) - (uint)bVar16) < 0 !=\n         (SBORROW4(iVar7,iVar6) != SBORROW4(iVar7 - iVar6,(uint)bVar16)))) goto LAB_00004a88;\n      uVar4 = piVar3[8] - uVar10;\n      iVar6 = (piVar3[9] - ((int)uVar10 >> 0x1f)) - (uint)((uint)piVar3[8] < uVar10);\n      if (*piVar3 != 0) {\n        if ((int)((iVar7 - iVar6) - (uint)(uVar15 < uVar4)) < 0 ==\n            (SBORROW4(iVar7,iVar6) != SBORROW4(iVar7 - iVar6,(uint)(uVar15 < uVar4))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        uVar9 = 0;\n        if ((int)uVar14 < 0) goto LAB_00004934;\nLAB_00004a14:\n        uVar15 = uVar13 ^ uVar9;\n        uVar13 = uVar9;\n        if (uVar15 == 1) {\n          if (uVar9 == 0) {\n            iVar7 = uVar10 - uVar8;\n          }\n          else {\n            iVar7 = uVar8 - uVar10;\n          }\n          iVar5 = param_1[3];\n          *param_1 = *param_1 + iVar7;\n          lVar2 = lVar1 + iVar7;\n          FUNC_00004634(param_1);\n          iVar5 = param_1[3] - iVar5;\n          lVar1 = lVar1 + iVar7;\n          if (iVar5 != 0) {\n            if (iVar5 < 2) {\n              if (iVar5 == -2 || iVar5 + 2 < 0 != SCARRY4(iVar5,2)) {\n                iVar5 = 1;\n              }\n            }\n            else {\n              iVar5 = -1;\n            }\n            iVar7 = iVar5 + param_1[7];\n            iVar11 = iVar11 + iVar5;\n            if (iVar7 < 0) {\n              uVar9 = uVar12 - 1;\n              if ((uVar9 & 3) == 0) {\n                if (uVar9 == (uVar9 / 100) * 100) {\n                  iVar7 = 0x16d;\n                  if ((uVar12 + 0x76b) % 400 != 0) {\n                    iVar7 = 0x16c;\n                  }\n                }\n                else {\n                  iVar7 = 0x16d;\n                }\n              }\n              else {\n                iVar7 = 0x16c;\n              }\n            }\n            else {\n              if ((uVar12 & 3) == 0) {\n                if (uVar12 == (uVar12 / 100) * 100) {\n                  iVar5 = 0x16d;\n                  if ((uVar12 + 0x76c) % 400 == 0) {\n                    iVar5 = 0x16e;\n                  }\n                }\n                else {\n                  iVar5 = 0x16e;\n                }\n              }\n              else {\n                iVar5 = 0x16d;\n              }\n              if (iVar5 <= iVar7) {\n                iVar7 = iVar7 - iVar5;\n              }\n            }\n            param_1[7] = iVar7;\n            lVar1 = lVar2;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((iVar7 - iVar6) - (uint)(uVar15 < uVar4)) < 0 !=\n          (SBORROW4(iVar7,iVar6) != SBORROW4(iVar7 - iVar6,(uint)(uVar15 < uVar4)))) {\nLAB_0000491e:\n        if ((int)((iVar7 - iVar5) - (uint)(uVar15 < uVar9)) < 0 ==\n            (SBORROW4(iVar7,iVar5) != SBORROW4(iVar7 - iVar5,(uint)(uVar15 < uVar9))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)uVar14) {\n        uVar9 = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      uVar9 = uVar13;\n      if (uVar13 != 1) goto LAB_00004934;\n    }\n    uVar12 = piVar3[0x14];\n    iVar7 = (uint)lVar1 + uVar12;\n    iVar5 = (int)((ulonglong)lVar1 >> 0x20) +\n            ((int)uVar12 >> 0x1f) + (uint)CARRY4((uint)lVar1,uVar12);\n    uVar9 = 1;\n  }\n  get_data_pointer_000050f4();\n  param_1[8] = uVar9;\n  param_1[6] = (iVar11 + 4U) % 7;\nLAB_00004aba:\n  return CONCAT44(iVar5,iVar7);\n}\n\n",
            "called": [
                "FUN_00004634",
                "FUN_00004f98",
                "FUN_000056b0",
                "FUN_000050e8",
                "FUN_000050f4",
                "FUN_00005100"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000047e4",
            "calling": [
                "FUN_00002600",
                "FUN_00002654"
            ],
            "imported": false,
            "current_name": "FUNC_000047e4"
        },
        "FUN_000023c8": {
            "renaming": {
                "FUN_000023c8": "interruptSoftwareCall_000023c8"
            },
            "code": "void interruptSoftwareCall_000023c8(void)\n{\n  software_interrupt(0x3f);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023c8",
            "calling": [
                "FUN_000023d0"
            ],
            "imported": true,
            "current_name": "interruptSoftwareCall_000023c8"
        },
        "FUN_00002e48": {
            "renaming": {
                "PTR_00002e68": "data_ptr",
                "FUN_00002e48": "process_input_and_data_00002e48",
                "DAT_00002e68": "data_array",
                "process_data_000041d0": "process_data",
                "process_input_wrapper_00002a00": "process_input"
            },
            "code": "void process_input_and_data_00002e48(void)\n{\n  int input1 = 0x3e;\n  int input2 = 0x20;\n  int* PTR_00002e68 = *DAT_00002e68;\n  int data = *(PTR_00002e68 + 2);\n  process_input_wrapper_00002a00(input1);\n  process_input_wrapper_00002a00(input2);\n  process_data_000041d0(data);\n  return;\n}",
            "called": [
                "FUN_000041d0",
                "FUN_00002a00"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e48",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": true,
            "current_name": "process_input_and_data_00002e48"
        },
        "FUN_00000930": {
            "renaming": {
                "software_interrupt": "trigger_interrupt",
                "FUN_00000930": "wait_for_interrupt_00000930",
                "PTR_": "PTR_",
                "DAT_": "DAT_",
                "is_interrupt_enabled_in_privileged_mode_00000cf0": "is_interrupt_enabled"
            },
            "code": "void wait_for_interrupt_00000930(void)\n{\n  bool interrupt_enabled = is_interrupt_enabled_in_privileged_mode_00000cf0();\n  software_interrupt(1);\n  while(interrupt_enabled) {\n    // Wait for interrupt\n  }\n}",
            "called": [
                "FUN_00000cf0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000930",
            "calling": [
                "FUN_00000794",
                "FUN_00000f8c"
            ],
            "imported": true,
            "current_name": "wait_for_interrupt_00000930"
        },
        "FUN_00001348": {
            "renaming": {
                "set_flag_bit_0000093c": "setFlagBit",
                "FUN_00001348": "checkFlagAndSetIfTrue_00001348",
                "PTR_DAT_0000135c": "flagPtr"
            },
            "code": "void checkFlagAndSetIfTrue_00001348(void)\n{\n  int* PTR_DAT_0000135c = (int*)PTR_DAT_0000135c;\n  if (*PTR_DAT_0000135c != 0) {\n    set_flag_bit_0000093c();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001348",
            "calling": [
                "FUN_00001628"
            ],
            "imported": true,
            "current_name": "checkFlagAndSetIfTrue_00001348"
        },
        "FUN_00001d3a": {
            "renaming": {
                "param_1": "input_value",
                "FUN_00001d3a": "set_calculated_result_to_one_00001d3a",
                "param_2": "flag",
                "puVar1": "result_pointer",
                "calculate_result_00001d08": "calculate_result"
            },
            "code": "void set_calculated_result_to_one_00001d3a(int input_value, unsigned char flag)\n{\n  int* result_pointer;\n  result_pointer = (int*)calculate_result(input_value, flag);\n  *result_pointer = 1;\n  return;\n}",
            "called": [
                "FUN_00001d08"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d3a",
            "calling": [
                "FUN_00001ddc"
            ],
            "imported": true,
            "current_name": "set_calculated_result_to_one_00001d3a"
        },
        "FUN_00002434": {
            "renaming": {
                "iVar2": "tail",
                "uVar1": "interrupts_enabled",
                "param_1": "head",
                "FUN_00002434": "add_node_to_linked_list_00002434",
                "param_2": "data"
            },
            "code": "int add_node_to_linked_list_00002434(int *head, int data)\n{\n  bool interrupts_enabled = is_interrupts_enabled_in_privileged_mode_00000cd0();\n  if (*head == 0) {\n    *head = -1;\n    enable_interrupts_if_privileged_00000d0c(interrupts_enabled);\n    return 1;\n  }\n  else if (data == 0) {\n    enable_interrupts_if_privileged_00000d0c(interrupts_enabled);\n    return 0;\n  }\n  else {\n    int tail = *(int *)PTR_DAT_000024b8;\n    update_linked_list_00000698(tail, 2);\n    if (*head == -1) {\n      *head = tail + 8;\n      *(int *)*head = 0;\n    }\n    else {\n      insert_node_at_position_00001034(head, tail);\n    }\n    enable_interrupts_if_privileged_00000d0c(interrupts_enabled);\n    set_flag_bit_0000093c();\n    return 1;\n  }\n}",
            "called": [
                "FUN_00000698",
                "FUN_0000093c",
                "FUN_00001034",
                "FUN_00000cd0",
                "FUN_00000d0c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002434",
            "calling": [
                "FUN_0000129c"
            ],
            "imported": true,
            "current_name": "add_node_to_linked_list_00002434"
        },
        "FUN_00005700": {
            "renaming": {
                "uVar1": "flag",
                "check_value_and_set_flag_000056b8": "check_and_set_flag",
                "param_1": "mem_size",
                "allocate_memory_block_00004bd0": "allocate_block",
                "local_18": "size",
                "FUN_00005700": "allocate_memory_00005700",
                "param_2": "mem_block_ptr",
                "is_valid_input_00000534": "is_valid_input",
                "local_14": "ptr"
            },
            "code": "void allocate_memory_00005700(int mem_size, int *mem_block_ptr)\n{\n  ushort flag;\n  int size;\n  int *ptr;\n  \n  if ((int)((uint)*(ushort *)(mem_block_ptr + 3) << 0x1e) >= 0) {\n    size = mem_size;\n    ptr = mem_block_ptr;\n    flag = check_and_set_flag(size, ptr, &size, &ptr);\n    int mem_block = allocate_block(size);\n    if (mem_block != 0) {\n      *(undefined **)(mem_size + 0x28) = PTR_DAT_0000577c;\n      *mem_block_ptr = mem_block;\n      *(ushort *)(mem_block_ptr + 3) = *(ushort *)(mem_block_ptr + 3) | 0x80;\n      mem_block_ptr[5] = size;\n      mem_block_ptr[4] = mem_block;\n      if ((ptr != (int *)0x0) && (is_valid_input(mem_size, (int)*(short *)((int)mem_block_ptr + 0xe)))) {\n        *(ushort *)(mem_block_ptr + 3) = *(ushort *)(mem_block_ptr + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(mem_block_ptr + 3) = flag | *(ushort *)(mem_block_ptr + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(mem_block_ptr + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(mem_block_ptr + 3) = *(ushort *)(mem_block_ptr + 3) & 0xfffc | 2;\n  }\n  *mem_block_ptr = (int)mem_block_ptr + 0x47;\n  mem_block_ptr[4] = (int)mem_block_ptr + 0x47;\n  mem_block_ptr[5] = 1;\n  return;\n}",
            "called": [
                "FUN_000056b8",
                "FUN_00004bd0",
                "FUN_00000534"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005700",
            "calling": [
                "FUN_000054a8",
                "FUN_00006768"
            ],
            "imported": true,
            "current_name": "allocate_memory_00005700"
        },
        "FUN_00002798": {
            "renaming": {
                "set_flag_bit_0000093c": "setFlagBit",
                "PTR_DAT_000027ac": "flag",
                "FUN_00002798": "checkFlag_00002798"
            },
            "code": "void checkFlag_00002798(void)\n{\n  int* PTR_DAT_000027ac = (int*)PTR_DAT_000027ac;\n  if (*PTR_DAT_000027ac != 0)\n  {\n    set_PTR_DAT_000027ac_bit_0000093c();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002798",
            "calling": [
                "FUN_00002994"
            ],
            "imported": true,
            "current_name": "checkFlag_00002798"
        },
        "FUN_00003524": {
            "renaming": {
                "initialize_rtc_commands_000034c0": "initialize_rtc_commands",
                "clear_flags_and_reset_values_000026c0": "clear_flags_and_reset_values",
                "PTR_s_clearalarm_00003640": "PTR_s_clearalarm",
                "PTR_s_unknown_command_or_missing_param_00003654": "PTR_s_unknown_command_or_missing_param",
                "PTR_s_gettime_0000364c": "PTR_s_gettime",
                "param_1": "num_params",
                "check_alarm_and_calculate_000033c0": "check_alarm_and_calculate",
                "PTR_s_poweroff_0000363c": "PTR_s_poweroff",
                "compare_strings_00004e66": "compare_strings",
                "FUN_00003524": "process_rtc_command_00003524",
                "param_2": "command",
                "set_data_access_flag_and_return_000026d8": "set_data_access_flag_and_return",
                "process_input_and_call_function_00004c84": "process_input_and_call_function",
                "PTR_s_setalarm_00003648": "PTR_s_setalarm",
                "clear_bit_in_uint_at_offset_from_data_000026e4": "clear_bit_in_uint_at_offset_from_data",
                "set_time_and_process_data_00003478": "set_time_and_process_data",
                "PTR_s_getalarm_00003644": "PTR_s_getalarm",
                "PTR_s_settime_00003650": "PTR_s_settime",
                "PTR_s_poweron_00003638": "PTR_s_poweron",
                "set_alarm_if_value_valid_000033f4": "set_alarm_if_value_valid",
                "is_timestamp_to_date_conversion_successful_00003444": "is_timestamp_to_date_conversion_successful"
            },
            "code": "int process_rtc_command_00003524(int num_params, int command)\n{\n  int comparison_result;\n  int return_value;\n  if (num_params < 2) {\n    initialize_rtc_commands();\n    return_value = 1;\n  }\n  else {\n    comparison_result = compare_strings(command + 4, PTR_s_poweron_00003638_00003638, 7);\n    if (comparison_result == 0) {\n      set_data_access_flag_and_return();\n    }\n    else {\n      comparison_result = compare_strings(command + 4, PTR_s_poweroff_0000363c_0000363c, 8);\n      if (comparison_result == 0) {\n        clear_bit_in_uint_at_offset_from_data();\n      }\n      else {\n        comparison_result = compare_strings(command + 4, PTR_s_clearalarm_00003640_00003640, 8);\n        if (comparison_result == 0) {\n          clear_flags_and_reset_values();\n        }\n        else {\n          comparison_result = compare_strings(command + 4, PTR_s_getalarm_00003644_00003644, 8);\n          if (comparison_result == 0) {\n            check_alarm_and_calculate();\n          }\n          else {\n            comparison_result = compare_strings(command + 4, PTR_s_setalarm_00003648_00003648, 8);\n            if ((comparison_result == 0) && (num_params == 4)) {\n              set_alarm_if_value_valid(command + 8);\n            }\n            else {\n              comparison_result = compare_strings(command + 4, PTR_s_gettime_0000364c_0000364c, 7);\n              if (comparison_result == 0) {\n                is_timestamp_to_date_conversion_successful();\n              }\n              else {\n                comparison_result = compare_strings(command + 4, PTR_s_settime_00003650_00003650, 7);\n                if ((comparison_result != 0) || (num_params != 4)) {\n                  process_input_and_call_function(PTR_s_unknown_command_or_missing_param_00003654_00003654, command + 4);\n                  initialize_rtc_commands();\n                  return_value = 1;\n                }\n                else {\n                  set_time_and_process_data(command + 8);\n                }\n              }\n            }\n          }\n        }\n      }\n      return_value = 0;\n    }\n  }\n  return return_value;\n}",
            "called": [
                "FUN_000033c0",
                "FUN_000026e4",
                "FUN_000026c0",
                "FUN_000026d8",
                "FUN_000034c0",
                "FUN_00003478",
                "FUN_00004e66",
                "FUN_000033f4",
                "FUN_00004c84",
                "FUN_00003444"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003524",
            "calling": [],
            "imported": true,
            "current_name": "process_rtc_command_00003524"
        },
        "FUN_00001bb8": {
            "renaming": {
                "DAT_00001c7c": "offset6",
                "PTR_DAT_00001c80": "result",
                "DAT_00001c74": "controlBits",
                "FUN_00001bb8": "resetDevice_00001bb8",
                "DAT_00001c78": "offset1"
            },
            "code": "void resetDevice_00001bb8(void)\n{\n  if ((DAT_00001c74[1] & 2) != 0) {\n    resetOffset(DAT_00001c74[2],1);\n  }\n  if ((DAT_00001c74[5] & 0x40) != 0) {\n    if ((*DAT_00001c74 & 0xc0) == 0) {\n      *DAT_00001c74 = *DAT_00001c74 & 0x3f | 0x80;\n      while ((DAT_00001c74[6] & 0xc) != 8);\n    }\n    resetOffset(DAT_00001c74[7],6);\n    while ((DAT_00001c74[6] & 0x20) != 0);\n  }\n  setParameter(0);\n  *DAT_00001c74 = *DAT_00001c74 & 0x3b | 4;\n  while ((DAT_00001c74[6] & 0x10) == 0);\n  while ((DAT_00001c74[6] & 0xc) != 0);\n  *PTR_DAT_00001c80 = 0;\n  return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001bb8",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": true,
            "current_name": "resetDevice_00001bb8"
        },
        "FUN_0000428c": {
            "renaming": {
                "do_nothing_000045e8": "do_nothing",
                "DAT_00004294": "DAT_data",
                "FUN_0000428c": "do_nothing_with_data_0000428c"
            },
            "code": "void do_nothing_with_data_0000428c(void)\n{\n  do_nothing(DAT_00004294);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000428c",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": true,
            "current_name": "do_nothing_with_data_0000428c"
        },
        "FUN_0000404c": {
            "renaming": {
                "iVar1": "decode_result",
                "iVar5": "decode_step_size",
                "iVar7": "decode_offset",
                "piVar2": "ptr_decode_buffer",
                "param_1": "input_buffer",
                "param_2": "decode_buffer",
                "uVar3": "decode_length",
                "pcVar6": "decode_function",
                "bVar9": "decode_is_offset_zero",
                "FUN_0000404c": "decode_0000404c",
                "uVar4": "decode_flags",
                "uVar8": "decode_is_error"
            },
            "code": "int decode_0000404c(uint *input_buffer, int *decode_0000404c_buffer) {\n  int decode_0000404c_result;\n  int *ptr_decode_0000404c_buffer;\n  uint decode_0000404c_length;\n  ushort decode_0000404c_flags;\n  int decode_0000404c_offset;\n  code *decode_0000404c_function;\n  int decode_0000404c_step_size;\n  uint decode_0000404c_is_error;\n  bool decode_0000404c_is_offset_zero;\n  \n  decode_0000404c_flags = *(ushort *)(decode_0000404c_buffer + 3);\n  decode_0000404c_length = (uint)decode_0000404c_flags;\n  if ((int)(decode_0000404c_length << 0x1c) < 0) {\n    decode_0000404c_offset = decode_0000404c_buffer[4];\n    if (decode_0000404c_offset != 0) {\n      decode_0000404c_step_size = decode_0000404c_length << 0x1e;\n      decode_0000404c_is_offset_zero = decode_0000404c_step_size == 0;\n      decode_0000404c_function = *(code **)(decode_0000404c_buffer + 10);\n      if (decode_0000404c_is_offset_zero) {\n        decode_0000404c_step_size = decode_0000404c_buffer[5];\n      }\n      *decode_0000404c_buffer = decode_0000404c_offset;\n      if (!decode_0000404c_is_offset_zero) {\n        decode_0000404c_step_size = 0;\n      }\n      decode_0000404c_buffer[2] = decode_0000404c_step_size;\n      for (decode_0000404c_offset = decode_0000404c_buffer[0] - decode_0000404c_offset; decode_0000404c_offset > 0; decode_0000404c_offset = decode_0000404c_offset - decode_0000404c_step_size) {\n        decode_0000404c_step_size = (*decode_0000404c_function)(input_buffer, decode_0000404c_buffer[8], decode_0000404c_buffer[4], decode_0000404c_offset);\n        if (decode_0000404c_step_size < 1) {\n          *(ushort *)(decode_0000404c_buffer + 3) = *(ushort *)(decode_0000404c_buffer + 3) | 0x40;\n          return -1;\n        }\n        decode_0000404c_buffer[4] = decode_0000404c_buffer[4] + decode_0000404c_step_size;\n      }\n    }\n  }\n  else {\n    if ((decode_0000404c_buffer[1] < 1) && (decode_0000404c_buffer[0x10] < 1)) {\n      return 0;\n    }\n    decode_0000404c_function = *(code **)(decode_0000404c_buffer + 0xb);\n    if (decode_0000404c_function == (code *)0x0) {\n      return 0;\n    }\n    decode_0000404c_is_error = *input_buffer;\n    *input_buffer = 0;\n    if ((decode_0000404c_flags & 0x1000) == 0) {\n      decode_0000404c_step_size = (*decode_0000404c_function)(input_buffer, decode_0000404c_buffer[8], decode_0000404c_flags & 0x1000, 1);\n      if ((decode_0000404c_step_size == -1) && (decode_0000404c_is_error = *input_buffer, decode_0000404c_is_error != 0)) {\n        if ((decode_0000404c_is_error == 0x1d) || (decode_0000404c_is_error == 0x16)) {\n          *input_buffer = decode_0000404c_is_error;\n          return 0;\n        }\n        decode_0000404c_flags = *(ushort *)(decode_0000404c_buffer + 3);\n        goto LAB_00004104;\n      }\n    }\n    else {\n      decode_0000404c_step_size = decode_0000404c_buffer[0x15];\n    }\n    if (((int)((uint)*(ushort *)(decode_0000404c_buffer + 3) << 0x1d) < 0) &&\n       (decode_0000404c_step_size = decode_0000404c_step_size - decode_0000404c_buffer[1], decode_0000404c_buffer[0xd] != 0)) {\n      decode_0000404c_step_size = decode_0000404c_step_size - decode_0000404c_buffer[0x10];\n    }\n    decode_0000404c_step_size = (*decode_0000404c_function)(input_buffer, decode_0000404c_buffer[8], decode_0000404c_step_size, 0);\n    decode_0000404c_flags = *(ushort *)(decode_0000404c_buffer + 3);\n    if ((decode_0000404c_step_size == -1) &&\n       ((0x1d < *input_buffer || (-1 < (int)((DAT_00004154 >> (*input_buffer & 0xff)) << 0x1f))))) {\nLAB_00004104:\n      *(ushort *)(decode_0000404c_buffer + 3) = decode_0000404c_flags | 0x40;\n      return decode_0000404c_step_size;\n    }\n    decode_0000404c_buffer[1] = 0;\n    *decode_0000404c_buffer = decode_0000404c_buffer[4];\n    if (((int)((uint)decode_0000404c_flags << 0x13) < 0) && ((decode_0000404c_step_size != -1 || (*input_buffer == 0)))) {\n      decode_0000404c_buffer[0x15] = decode_0000404c_step_size;\n    }\n    ptr_decode_0000404c_buffer = (int *)decode_0000404c_buffer[0xd];\n    *input_buffer = decode_0000404c_is_error;\n    if (ptr_decode_0000404c_buffer != (int *)0x0) {\n      if (ptr_decode_0000404c_buffer != decode_0000404c_buffer + 0x11) {\n        insert_element_00004b34(input_buffer);\n      }\n      decode_0000404c_buffer[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000404c",
            "calling": [
                "FUN_00006768",
                "FUN_00004158"
            ],
            "imported": true,
            "current_name": "decode_0000404c"
        },
        "FUN_00002f74": {
            "renaming": {
                "FUN_00002f74": "print_device_info_00002f74",
                "PTR_s_ID_Class_Name_00002fd4": "device_info_message",
                "uVar1": "device_address",
                "PTR_s_No_devices_found_00002fd8": "no_device_error_message",
                "local_18": "device_count",
                "PTR_s___i__s__s_00002fdc": "device_info_line_format_string",
                "print_message": "print_message",
                "get_class_by_character_000039e8": "get_device_class",
                "print_error_message": "print_error_message",
                "local_14": "device_list",
                "print_device_info_line": "print_device_info_line",
                "PTR_DAT_00002fd0": "device_list_pointer"
            },
            "code": "void print_device_info_00002f74(void)\n{\n  undefined4 device_address;\n  int device_count = 0;\n  undefined4 *device_list = *(undefined4 **)PTR_DAT_00002fd0;\n  \n  if (device_list == (undefined4 *)0x0) {\n    print_error_message(PTR_s_No_devices_found_00002fd8);\n  }\n  else {\n    print_message(PTR_s_ID_Class_Name_00002fd4);\n  }\n  \n  for (; device_list != (undefined4 *)0x0; device_list = (undefined4 *)*device_list) {\n    device_address = get_class_by_character_000039e8(*(undefined *)(device_list[3] + 8));\n    print_device_info_00002f74_line(PTR_s___i__s__s_00002fdc, device_count, device_address, device_list[2]);\n    device_count++;\n  }\n  return;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_000039e8",
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f74",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": true,
            "current_name": "print_device_info_00002f74",
            "code_backup": "\nvoid FUN_00002f74(void)\n\n{\n  undefined4 uVar1;\n  int local_18;\n  undefined4 *local_14;\n  \n  local_14 = *(undefined4 **)PTR_DAT_00002fd0;\n  local_18 = 0;\n  if (local_14 == (undefined4 *)0x0) {\n    FUNC_00004db8(PTR_s_No_devices_found_00002fd8);\n  }\n  else {\n    FUNC_00004db8(PTR_s_ID_Class_Name_00002fd4);\n  }\n  for (; local_14 != (undefined4 *)0x0; local_14 = (undefined4 *)*local_14) {\n    uVar1 = get_class_by_character_000039e8(*(undefined *)(local_14[3] + 8));\n    FUNC_00004c84(PTR_s___i__s__s_00002fdc,local_18,uVar1,local_14[2]);\n    local_18 = local_18 + 1;\n  }\n  return;\n}\n\n"
        },
        "FUN_000010a0": {
            "renaming": {
                "FUN_000010a0": "calculate_offset_000010a0",
                "local_c": "current_element",
                "param_1": "input_array"
            },
            "code": "int calculate_offset_000010a0(int *input_array)\n{\n  int *current_element;\n  for (current_element = input_array; (int *)*current_element == current_element; current_element++) {\n  }\n  return (int)current_element - (int)input_array;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010a0",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": true,
            "current_name": "calculate_offset_000010a0"
        },
        "FUN_000012e2": {
            "renaming": {
                "FUN_000012e2": "copy_linked_list_000012e2",
                "iVar1": "copy_result",
                "copy_memory_0000231c": "copy_memory",
                "add_node_to_linked_list_0000129c": "add_node_to_linked_list",
                "param_1": "node_address",
                "param_2": "data_address",
                "param_3": "data_size"
            },
            "code": "int copy_linked_list_000012e2(int node_address, undefined4 data_address, undefined4 data_size)\n{\n  int copy_result;\n  while (true) {\n    copy_result = copy_memory(node_address + 4, data_address, data_size);\n    if (copy_result != 0) break;\n    add_node_to_linked_list(node_address);\n  }\n  return copy_result;\n}",
            "called": [
                "FUN_0000231c",
                "FUN_0000129c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012e2",
            "calling": [
                "FUN_00000e14"
            ],
            "imported": true,
            "current_name": "copy_linked_list_000012e2"
        },
        "FUN_000056a0": {
            "renaming": {
                "FUN_000056a0": "find_matching_string_000056a0",
                "uStack_8": "current_search_end",
                "param_1": "string",
                "uStack_c": "current_search_start",
                "param_2": "search_start",
                "param_3": "search_end",
                "param_4": "match"
            },
            "code": "void find_matching_string_000056a0(void* string, void* search_start, void* search_end, void* match){\n  void* current_search_start = search_start;\n  void* current_search_end = search_end;\n  find_matching_string_000056a0_0000562c(string, search_start, &current_search_start, match, string);\n  return;\n}",
            "called": [
                "FUN_0000562c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056a0",
            "calling": [
                "FUN_00005100"
            ],
            "imported": true,
            "current_name": "find_matching_string_000056a0"
        },
        "FUN_0000231c": {
            "renaming": {
                "FUN_0000231c": "copy_memory_0000231c",
                "iVar2": "pointer_equality",
                "uVar1": "value",
                "param_1": "starting_address",
                "param_2": "destination",
                "param_3": "length",
                "local_20": "current_destination",
                "local_14": "counter"
            },
            "code": "int copy_memory_0000231c(int starting_address, void *destination, int length)\n{\n  undefined value;\n  int counter;\n  void *current_destination;\n  \n  current_destination = destination;\n  counter = length;\n  while ((counter != 0 && (is_equal_pointer(starting_address) == 0))) {\n    value = increment_value_at_address(starting_address);\n    *current_destination = value;\n    counter = counter - 1;\n    current_destination = current_destination + 1;\n  }\n  return length - counter;\n}",
            "called": [
                "FUN_00002270",
                "FUN_000022f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000231c",
            "calling": [
                "FUN_000012e2"
            ],
            "imported": true,
            "current_name": "copy_memory_0000231c"
        },
        "FUN_000061cc": {
            "renaming": {
                "FUN_000061cc": "FUNC_000061cc"
            },
            "code": "\nint FUNC_000061cc(int param_1,byte **param_2,byte *param_3,int **param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  uint uVar6;\n  int **local_2b0;\n  undefined auStack_2ac [256];\n  uint local_1ac;\n  undefined4 local_1a8;\n  uint local_1a4;\n  int local_1a0;\n  int local_19c;\n  undefined *local_198;\n  int local_194;\n  undefined *local_30;\n  code *local_2c;\n  \n  puVar2 = PTR_DAT_000064b4;\n  puVar1 = PTR_DAT_000064b0;\n  local_1a0 = 0;\n  local_19c = 0;\n  local_30 = PTR_LAB_00006118_1_000064a8;\n  local_2c = DAT_000064ac;\n  local_2b0 = param_4;\n  local_198 = auStack_2ac;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      uVar6 = (uint)*param_3;\n      if (uVar6 == 0) {\n        return local_1a0;\n      }\n      uVar4 = (byte)puVar1[uVar6] & 8;\n      pbVar5 = param_3 + 1;\n      if ((puVar1[uVar6] & 8) == 0) break;\n      while (((param_3 = pbVar5, 0 < (int)param_2[1] ||\n              (iVar3 = (*local_2c)(param_1,param_2), iVar3 == 0)) &&\n             ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0))) {\n        local_19c = local_19c + 1;\n        param_2[1] = param_2[1] + -1;\n        *param_2 = *param_2 + 1;\n      }\n    }\n    if (uVar6 == 0x25) break;\nLAB_00006352:\n    if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n    goto LAB_00006380;\n    if (**param_2 != uVar6) {\n      return local_1a0;\n    }\n    *param_2 = *param_2 + 1;\n    local_19c = local_19c + 1;\n    param_2[1] = param_2[1] + -1;\n    param_3 = pbVar5;\n  }\n  local_1a4 = uVar4;\n  local_1ac = uVar4;\n  if (param_3[1] == 0x2a) {\n    pbVar5 = param_3 + 2;\n    local_1ac = 0x10;\n  }\n  while( true ) {\n    uVar4 = (uint)*pbVar5;\n    if (9 < uVar4 - 0x30) break;\n    pbVar5 = pbVar5 + 1;\n    local_1a4 = (local_1a4 * 10 + uVar4) - 0x30;\n  }\n  iVar3 = find_byte_sequence_00006010(PTR_DAT_000064b4,uVar4,3);\n  if (iVar3 != 0) {\n    local_1ac = 1 << (iVar3 - (int)puVar2 & 0xffU) | local_1ac;\n    pbVar5 = pbVar5 + 1;\n  }\n  param_3 = pbVar5 + 1;\n  uVar4 = (uint)*pbVar5;\n  if (uVar4 < 0x79) {\n    if (0x57 < uVar4) {\n      switch(uVar4) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        param_3 = (byte *)reverseAndToggle_0000687c(auStack_2ac,param_3);\n        local_1ac = local_1ac | 0x40;\n        local_194 = 1;\n        break;\n      case 99:\n        local_1ac = local_1ac | 0x40;\n        local_194 = 0;\n        break;\n      case 100:\n      case 0x75:\n        local_1a8 = 10;\nLAB_000063a0:\n        if (uVar4 < 0x6f) {\n          local_194 = 3;\n        }\n        else {\n          local_194 = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        local_194 = 5;\n        break;\n      case 0x69:\n        local_1a8 = 0;\n        local_194 = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(local_1ac << 0x1b)) {\n          if ((int)(local_1ac << 0x1f) < 0) {\n            *(short *)*local_2b0 = (short)local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n          else {\n            **local_2b0 = local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        local_1a8 = 8;\n        local_194 = 4;\n        break;\n      case 0x70:\n        local_1ac = local_1ac | 0x20;\n      case 0x58:\n      case 0x78:\n        local_1ac = local_1ac | 0x200;\n        local_1a8 = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        local_194 = 2;\n      }\nLAB_000063ac:\n      if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(local_1ac << 0x19)) {\n        while ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0) {\n          local_19c = local_19c + 1;\n          pbVar5 = param_2[1];\n          param_2[1] = pbVar5 + -1;\n          if ((int)(pbVar5 + -1) < 1) {\n            iVar3 = (*local_2c)(param_1,param_2);\n            if (iVar3 != 0) goto LAB_00006380;\n          }\n          else {\n            *param_2 = *param_2 + 1;\n          }\n        }\n      }\n      if (local_194 < 3) {\n        iVar3 = process_data_000064bc(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else if (local_194 < 5) {\n        iVar3 = FUNC_0000656c(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else {\n        iVar3 = param_1;\n        if (DAT_000064b8 == 0) goto LAB_000061f6;\n      }\n      if (iVar3 == 1) {\n        return local_1a0;\n      }\n      if (iVar3 == 2) {\nLAB_00006380:\n        if (local_1a0 == 0) {\nLAB_00006388:\n          local_1a0 = -1;\n        }\n        else if ((*(ushort *)(param_2 + 3) & 0x40) != 0) {\n          local_1a0 = -1;\n        }\n        return local_1a0;\n      }\n      goto LAB_000061f6;\n    }\n    pbVar5 = param_3;\n    if (uVar4 == 0x25) goto LAB_00006352;\n    if (uVar4 < 0x26) {\n      if (uVar4 != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (uVar4 - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  local_194 = 3;\n  local_1a8 = 10;\n  goto LAB_000063ac;\n}\n\n",
            "called": [
                "FUN_000064bc",
                "FUN_0000656c",
                "FUN_0000687c",
                "FUN_00006010",
                "FUN_00006192"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000061cc",
            "calling": [
                "FUN_00005e68"
            ],
            "imported": false,
            "current_name": "FUNC_000061cc"
        },
        "FUN_00002690": {
            "renaming": {
                "FUN_00002690": "calculate_date_from_timestamp_and_increment_00002690",
                "param_1": "timestamp",
                "uStack_c": "stack_var",
                "get_dat_value_and_increment_000028f0": "get_dat_value_and_increment",
                "local_10": "dat_value",
                "calculate_date_from_timestamp_0000443c": "calculate_date_from_timestamp"
            },
            "code": "undefined4 calculate_date_from_timestamp_and_increment_00002690(undefined4 timestamp)\n{\n  undefined4 dat_value = get_dat_value_and_increment();\n  undefined4 stack_var = 0;\n  calculate_date_from_timestamp(&dat_value, timestamp);\n  return 0;\n}",
            "called": [
                "FUN_000028f0",
                "FUN_0000443c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002690",
            "calling": [
                "FUN_000033c0"
            ],
            "imported": true,
            "current_name": "calculate_date_from_timestamp_and_increment_00002690"
        },
        "FUN_00006010": {
            "renaming": {
                "bVar1": "current_byte",
                "uVar10": "data_length_aligned",
                "uVar11": "compare_result",
                "uVar12": "compare_result_mask",
                "bVar13": "compare_byte_0",
                "cVar5": "byte_3",
                "FUN_00006010": "find_byte_sequence_00006010",
                "param_1": "data",
                "cVar4": "byte_2",
                "bVar14": "compare_byte_1",
                "pbVar6": "current_ptr",
                "puVar7": "current_uint_ptr",
                "bVar15": "compare_byte_2",
                "bVar16": "compare_byte_3",
                "pbVar8": "result_ptr",
                "param_2": "search_byte",
                "cVar3": "byte_1",
                "param_3": "data_length",
                "cVar2": "byte_0",
                "uVar9": "data_offset"
            },
            "code": "byte * find_byte_sequence_00006010(uint *data, uint search_byte, uint data_length)\n{\n  byte *result = NULL;\n  uint search_word = (search_byte & 0xFF) | ((search_byte & 0xFF) << 8) | ((search_byte & 0xFF) << 16) | ((search_byte & 0xFF) << 24);\n  uint data_length_aligned = data_length & ~7;\n  uint i = 0;\n  while (i < data_length_aligned && *(uint *)(data + i) != search_word) {\n    i++;\n  }\n  if (i < data_length_aligned) {\n    result = (byte *)(data + i) + 3;\n  }\n  else {\n    i = data_length_aligned;\n  }\n  while (i < data_length && *(byte *)(data + i) != search_byte) {\n    i++;\n  }\n  if (i < data_length) {\n    result = (byte *)(data + i);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006010",
            "calling": [
                "FUN_000061cc",
                "FUN_000057f8",
                "FUN_00005b34",
                "FUN_0000656c"
            ],
            "imported": true,
            "current_name": "find_byte_sequence_00006010"
        },
        "FUN_00001cf0": {
            "renaming": {
                "set_flag_bit_0000093c": "setFlagBit",
                "FUN_00001cf0": "checkIfFlagIsSet_00001cf0",
                "PTR_DAT_00001d04": "flag"
            },
            "code": "void checkIfFlagIsSet_00001cf0(void)\n{\n  int* PTR_DAT_00001d04 = (int*)PTR_DAT_00001d04;\n  if (*PTR_DAT_00001d04 != 0) {\n    setFlagBit();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001cf0",
            "calling": [
                "FUN_00002028"
            ],
            "imported": true,
            "current_name": "checkIfFlagIsSet_00001cf0"
        },
        "FUN_00003ec4": {
            "renaming": {
                "iVar1": "quotient_digits",
                "local_c": "digit_count",
                "param_1": "output_string",
                "FUN_00003ec4": "convert_integer_to_string_and_count_digits_00003ec4",
                "param_2": "input_integer",
                "param_3": "decimal_places",
                "uVar3": "quotient",
                "local_10": "remainder",
                "uVar2": "remainder_digits"
            },
            "code": "int convert_integer_to_string_and_count_digits_00003ec4(undefined *output_string, uint input_integer, int decimal_places) {\n  int digit_count = 0;\n  if (decimal_places + 7 < 0 != SCARRY4(decimal_places,7)) {\n    process_input(3,PTR_s_FAILED_ASSERTION__00003fec);\n  }\n  if (decimal_places == 0) {\n    digit_count = convert_integer_to_string_and_count_digits_00003ec4_00003e58(output_string, input_integer);\n  }\n  else if (decimal_places < 1) {\n    uint divisor = *(uint *)(PTR_DAT_00003ff0 + decimal_places * -4);\n    uint quotient = input_integer / divisor;\n    uint remainder = input_integer - divisor * quotient;\n    if (remainder < 0) {\n      remainder = -remainder;\n    }\n    if ((quotient == 0) && ((int)input_integer < 0)) {\n      if (output_string != (undefined *)0x0) {\n        *output_string = 0x2d;\n      }\n      digit_count = 1;\n    }\n    if (output_string == (undefined *)0x0) {\n      int quotient_digits = convert_integer_to_string_and_count_digits_00003ec4_00003e58(0, quotient);\n      digit_count = quotient_digits + 1 + digit_count;\n    }\n    else {\n      int quotient_digits = convert_integer_to_string_and_count_digits_00003ec4_00003e58(output_string + digit_count, quotient);\n      digit_count = digit_count + quotient_digits + 1;\n      output_string[digit_count - 1] = 0x2e;\n      int remainder_digits = convert_integer_to_string_and_count_digits_00003ec4_00003e58(output_string + digit_count, remainder);\n      copy_and_fill(output_string + digit_count, remainder_digits, -decimal_places, 0x30);\n    }\n    digit_count = -decimal_places + digit_count;\n  }\n  else {\n    digit_count = convert_integer_to_string_and_count_digits_00003ec4_00003e58(output_string, input_integer);\n    if (output_string != (undefined *)0x0) {\n      fill_array_with_value(output_string + digit_count, 0x30, decimal_places);\n    }\n    digit_count = decimal_places + digit_count;\n  }\n  return digit_count;\n}",
            "called": [
                "FUN_00003e58",
                "FUN_00004622",
                "FUN_00000f04",
                "FUN_00003ff4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ec4",
            "calling": [
                "FUN_00003e9e"
            ],
            "imported": true,
            "current_name": "convert_integer_to_string_and_count_digits_00003ec4"
        },
        "FUN_00001360": {
            "renaming": {
                "param_1": "input_value",
                "FUN_00001360": "calculate_result_00001360",
                "param_2": "multiplier"
            },
            "code": "int calculate_result_00001360(uint input_value, int multiplier) {\n    int shifted_value = (input_value & 0xfffff) << 5;\n    int masked_value = (input_value & 0xf0000000);\n    int constant_value = 0x2000000;\n    return (multiplier * 4) + shifted_value + masked_value + constant_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001360",
            "calling": [
                "FUN_00001392"
            ],
            "imported": true,
            "current_name": "calculate_result_00001360"
        },
        "FUN_00004622": {
            "renaming": {
                "param_1": "array",
                "FUN_00004622": "fill_array_with_value_00004622",
                "param_2": "value",
                "param_3": "length",
                "puVar1": "end_of_array"
            },
            "code": "void fill_array_with_value_00004622(unsigned char *array, unsigned char value, int length) {\n  unsigned char *end_of_array = array + length;\n  for (; array != end_of_array; array = array + 1) {\n    *array = value;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004622",
            "calling": [
                "FUN_000041f4",
                "FUN_00004248",
                "FUN_00004314",
                "FUN_00003ec4",
                "FUN_00003ff4",
                "FUN_0000305c"
            ],
            "imported": true,
            "current_name": "fill_array_with_value_00004622"
        },
        "FUN_0000093c": {
            "renaming": {
                "PTR_": "ptr_",
                "FUN_0000093c": "set_flag_bit_0000093c",
                "DAT_00000954": "flag_address",
                "DAT_": "data_"
            },
            "code": "void set_flag_bit_0000093c(void)\n{\n  uint32_t* flag_ptr = (uint32_t *)(DAT_00000954 + 4);\n  *flag_ptr |= 0x10000000;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000093c",
            "calling": [
                "FUN_00001348",
                "FUN_00000738",
                "FUN_00001cf0",
                "FUN_00002434",
                "FUN_00002798"
            ],
            "imported": true,
            "current_name": "set_flag_bit_0000093c"
        },
        "FUN_00003658": {
            "renaming": {
                "DAT_00003680": "dataPtr",
                "DAT_00003684": "dataValue",
                "PTR_": "ptr",
                "FUN_00003658": "synchronizeData_00003658"
            },
            "code": "void synchronizeData_00003658(void)\n{\n  DataSynchronizationBarrier(0xf);\n  uint* PTR_ = (uint *)(DAT_00003680 + 0xc);\n  *PTR_ = DAT_00003684 | (*PTR_ & 0x700);\n  DataSynchronizationBarrier(0xf);\n  while(true){}\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003658",
            "calling": [
                "FUN_00003688"
            ],
            "imported": true,
            "current_name": "synchronizeData_00003658"
        },
        "FUN_000019c0": {
            "renaming": {
                "*DAT_00001a10": "data_array_pointer",
                "PTR_DAT_00001a14": "pointer_to_data",
                "set_param_00001748": "set_parameter",
                "DAT_00001a0c": "data_array",
                "set_offset_to_zero_00001710": "set_offset_to_zero",
                "set_offset_to_zero_for_six_elements_00001734": "set_offset_to_zero_for_six_elements",
                "FUN_000019c0": "set_flag_and_offset_000019c0",
                "set_offset_and_flag_00001778": "set_offset_and_flag"
            },
            "code": "void set_flag_and_offset_000019c0() {\n  set_offset_and_flag();\n  set_parameter(64);\n  set_offset_to_zero(DAT_00001a0c, 1);\n  *DAT_00001a10 = (*DAT_00001a10 & 0x3b) | 0x80;\n  while ((DAT_00001a10[6] & 0xc) != 8);\n  set_offset_to_zero_for_six_elements();\n  *PTR_DAT_00001a14 = 3;\n  return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001778",
                "FUN_00001710",
                "FUN_00001734"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000019c0",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": true,
            "current_name": "set_flag_and_offset_000019c0"
        },
        "FUN_000060b0": {
            "renaming": {
                "puVar2": "src_end",
                "puVar3": "dest_start",
                "param_1": "dest_offset",
                "param_2": "dest",
                "param_3": "length",
                "puVar1": "next_src",
                "FUN_000060b0": "copy_string_000060b0"
            },
            "code": "void copy_string_000060b0(int dest_offset, char *dest, char *src, int length)\n{\n  char *src_end = src + length;\n  char *dest_start = dest + dest_offset - 1;\n  if (src != src_end) {\n    do {\n      char *next_src = src + 1;\n      dest_start = dest_start + 1;\n      *dest_start = *src;\n      src = next_src;\n    } while (src != src_end);\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060b0",
            "calling": [
                "FUN_000060cc",
                "FUN_000068f0"
            ],
            "imported": true,
            "current_name": "copy_string_000060b0"
        },
        "FUN_00006a14": {
            "renaming": {
                "FUN_00006a14": "FUNC_00006a14"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong FUNC_00006a14(uint param_1,uint param_2,uint param_3,uint param_4,uint *param_5)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  uint uVar1;\n  uint *puVar2;\n  uint *puVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  bool bVar11;\n  ulonglong uVar12;\n  \n  if (param_4 == 0) {\n    if (param_2 < param_3) {\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 != 0) {\n        param_3 = param_3 << (uVar4 & 0xff);\n        param_2 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        param_1 = param_1 << (uVar4 & 0xff);\n      }\n      uVar7 = param_3 >> 0x10;\n      uVar9 = param_2 / uVar7;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar7 * uVar9) * 0x10000;\n      uVar1 = uVar9 * (param_3 & 0xffff);\n      uVar6 = uVar9;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar9 = (uVar5 - uVar1) / uVar7;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar7 * uVar9) * 0x10000;\n      uVar7 = uVar9 * (param_3 & 0xffff);\n      uVar1 = uVar9;\n      if (uVar5 <= uVar7 && uVar7 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar7 && uVar7 - uVar5 != 0)) {\n          uVar1 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar7;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n      puVar3 = (uint *)0x0;\n    }\n    else {\n      if (param_3 == 0) {\n                    /* WARNING: Could not recover jumptable at 0x00006abc. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x6abc);\n        uVar12 = (*UNRECOVERED_JUMPTABLE)();\n        return uVar12;\n      }\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 == 0) {\n        param_2 = param_2 - param_3;\n        uVar10 = param_3 >> 0x10;\n        uVar8 = param_3 & 0xffff;\n        puVar3 = (uint *)0x1;\n      }\n      else {\n        param_3 = param_3 << (uVar4 & 0xff);\n        uVar10 = param_3 >> 0x10;\n        uVar6 = param_2 >> (0x20 - uVar4 & 0xff);\n        uVar1 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        uVar5 = uVar6 / uVar10;\n        uVar8 = param_3 & 0xffff;\n        uVar9 = uVar1 >> 0x10 | (uVar6 - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        param_1 = param_1 << (uVar4 & 0xff);\n        uVar6 = uVar5;\n        if (uVar9 <= uVar7 && uVar7 - uVar9 != 0) {\n          bVar11 = CARRY4(param_3,uVar9);\n          uVar9 = param_3 + uVar9;\n          uVar6 = uVar5 - 1;\n          if ((bVar11 == false) && (uVar9 <= uVar7 && uVar7 - uVar9 != 0)) {\n            uVar6 = uVar5 - 2;\n            uVar9 = uVar9 + param_3;\n          }\n        }\n        uVar5 = (uVar9 - uVar7) / uVar10;\n        param_2 = uVar1 & 0xffff | ((uVar9 - uVar7) - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        uVar1 = uVar5;\n        if (param_2 <= uVar7 && uVar7 - param_2 != 0) {\n          bVar11 = CARRY4(param_3,param_2);\n          param_2 = param_3 + param_2;\n          uVar1 = uVar5 - 1;\n          if ((bVar11 == false) && (param_2 <= uVar7 && uVar7 - param_2 != 0)) {\n            uVar1 = uVar5 - 2;\n            param_2 = param_2 + param_3;\n          }\n        }\n        param_2 = param_2 - uVar7;\n        puVar3 = (uint *)(uVar1 | uVar6 << 0x10);\n      }\n      uVar7 = param_2 / uVar10;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar10 * uVar7) * 0x10000;\n      uVar1 = uVar8 * uVar7;\n      uVar6 = uVar7;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar7 = (uVar5 - uVar1) / uVar10;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar10 * uVar7) * 0x10000;\n      uVar8 = uVar8 * uVar7;\n      uVar1 = uVar7;\n      if (uVar5 <= uVar8 && uVar8 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar8 && uVar8 - uVar5 != 0)) {\n          uVar1 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar8;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = uVar5 >> (uVar4 & 0xff);\n      param_5[1] = 0;\n    }\n  }\n  else if (param_2 < param_4) {\n    puVar2 = param_5;\n    puVar3 = param_5;\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n      return 0;\n    }\n  }\n  else {\n    puVar3 = (uint *)count_leading_zeroes(param_4);\n    if (puVar3 != (uint *)0x0) {\n      uVar8 = 0x20 - (int)puVar3;\n      uVar5 = param_3 >> (uVar8 & 0xff) | param_4 << ((uint)puVar3 & 0xff);\n      uVar10 = uVar5 >> 0x10;\n      uVar4 = param_2 >> (uVar8 & 0xff);\n      uVar6 = param_1 >> (uVar8 & 0xff) | param_2 << ((uint)puVar3 & 0xff);\n      uVar7 = uVar4 / uVar10;\n      uVar1 = uVar6 >> 0x10 | (uVar4 - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      param_3 = param_3 << ((uint)puVar3 & 0xff);\n      param_1 = param_1 << ((uint)puVar3 & 0xff);\n      uVar4 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar4 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar4 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar7 = (uVar1 - uVar9) / uVar10;\n      uVar1 = uVar6 & 0xffff | ((uVar1 - uVar9) - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      uVar6 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar6 = uVar6 | uVar4 << 0x10;\n      uVar12 = (ulonglong)uVar6 * (ulonglong)param_3;\n      if (CONCAT44(uVar1 - uVar9,param_1) < uVar12) {\n        uVar12 = uVar12 - CONCAT44(uVar5,param_3);\n        uVar6 = uVar6 - 1;\n      }\n      if (param_5 != (uint *)0x0) {\n        uVar4 = ((uVar1 - uVar9) - (int)(uVar12 >> 0x20)) - (uint)(param_1 < (uint)uVar12);\n        *param_5 = uVar4 << (uVar8 & 0xff) | param_1 - (uint)uVar12 >> ((uint)puVar3 & 0xff);\n        param_5[1] = uVar4 >> ((uint)puVar3 & 0xff);\n      }\n      return (ulonglong)uVar6;\n    }\n    if ((param_4 < param_2) || (puVar2 = puVar3, param_3 <= param_1)) {\n      bVar11 = param_1 < param_3;\n      param_1 = param_1 - param_3;\n      param_2 = (param_2 - param_4) - (uint)bVar11;\n      puVar2 = (uint *)0x1;\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n    }\n  }\n  return CONCAT44(puVar3,puVar2);\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00006a14",
            "calling": [
                "FUN_00006974"
            ],
            "imported": false,
            "current_name": "FUNC_00006a14"
        },
        "FUN_000023d0": {
            "renaming": {
                "uVar1": "result",
                "param_1": "input_value",
                "FUN_000023d0": "perform_interrupt_call_if_not_done_000023d0"
            },
            "code": "int perform_interrupt_call_if_not_done_000023d0(int input_value)\n{\n  int result;\n  if (*(int *)PTR_DAT_000023fc == 0)\n  {\n    result = interruptSoftwareCall_000023c8(1, input_value, 0);\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}",
            "called": [
                "FUN_000023c8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023d0",
            "calling": [
                "FUN_000023a4"
            ],
            "imported": true,
            "current_name": "perform_interrupt_call_if_not_done_000023d0"
        },
        "FUN_00000a30": {
            "renaming": {
                "in_r3": "register_value",
                "PTR_DAT_00000a60": "PTR_DAT_00000a60",
                "process_input_00000f04": "process_input",
                "auStack_20": "stack_buffer",
                "FUN_00000a30": "calculate_stack_pointer_00000a30"
            },
            "code": "char* calculate_stack_pointer_00000a30(void)\n{\n  int register_value;\n  char stack_buffer[24];\n  process_input(4, stack_buffer);\n  return stack_buffer + (-(int)PTR_DAT_00000a60 - *(int *)(register_value + 0x4c));\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a30",
            "calling": [],
            "imported": true,
            "current_name": "calculate_stack_pointer_00000a30"
        },
        "FUN_000034c0": {
            "renaming": {
                "FUNC_00004db8": "initialize_command",
                "FUN_000034c0": "initialize_rtc_commands_000034c0"
            },
            "code": "int initialize_rtc_commands_000034c0(void)\n{\n  initialize_command(PTR_s_usage__rtc__command___arguments__00003500);\n  initialize_command(PTR_s_commands__00003504);\n  initialize_command(PTR_s__poweron_power_the_interface_on_00003508);\n  initialize_command(PTR_s__poweroff_power_the_interface_of_0000350c);\n  initialize_command(PTR_s__clearalarm_deactivate_the_curre_00003510);\n  initialize_command(PTR_s__getalarm_print_the_currently_al_00003514);\n  initialize_command(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n  initialize_command(PTR_s__gettime_print_the_current_time_0000351c);\n  initialize_command(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n  return 0;\n}",
            "called": [
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000034c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": true,
            "current_name": "initialize_rtc_commands_000034c0",
            "code_backup": "\nundefined4 FUN_000034c0(void)\n\n{\n  FUNC_00004db8(PTR_s_usage__rtc__command___arguments__00003500);\n  FUNC_00004db8(PTR_s_commands__00003504);\n  FUNC_00004db8(PTR_s__poweron_power_the_interface_on_00003508);\n  FUNC_00004db8(PTR_s__poweroff_power_the_interface_of_0000350c);\n  FUNC_00004db8(PTR_s__clearalarm_deactivate_the_curre_00003510);\n  FUNC_00004db8(PTR_s__getalarm_print_the_currently_al_00003514);\n  FUNC_00004db8(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n  FUNC_00004db8(PTR_s__gettime_print_the_current_time_0000351c);\n  FUNC_00004db8(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n  return 0;\n}\n\n"
        },
        "FUN_000050e8": {
            "renaming": {
                "PTR_DAT_000050f0": "pointer_to_data",
                "FUN_000050e8": "get_pointer_to_data_000050e8"
            },
            "code": "const char* get_pointer_to_data_000050e8() {\n  return PTR_DAT_000050f0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050e8",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": true,
            "current_name": "get_pointer_to_data_000050e8"
        },
        "FUN_000042a4": {
            "renaming": {
                "FUN_000042a4": "initialize_struct_array_000042a4",
                "bVar3": "is_ptr_equal_to_struct_ptr",
                "iVar2": "ptr",
                "uVar1": "initialized_struct_array",
                "param_1": "struct_ptr"
            },
            "code": "void initialize_struct_array_000042a4(int struct_ptr)\n{\n  do_nothing_with_data();\n  if (*(int *)(struct_ptr + 0x18) == 0) {\n    *(int *)(struct_ptr + 0x48) = 0;\n    *(int *)(struct_ptr + 0x4c) = 0;\n    *(int *)(struct_ptr + 0x50) = 0;\n    int ptr = *(int *)PTR_DAT_0000430c;\n    *(undefined **)(struct_ptr + 0x28) = PTR_DAT_00004310;\n    bool is_ptr_equal_to_struct_ptr = ptr == struct_ptr;\n    if (is_ptr_equal_to_struct_ptr) {\n      ptr = 1;\n    }\n    if (is_ptr_equal_to_struct_ptr) {\n      *(int *)(struct_ptr + 0x18) = ptr;\n    }\n    int initialized_struct_array = get_initialized_struct_array(struct_ptr);\n    *(int *)(struct_ptr + 4) = initialized_struct_array;\n    initialized_struct_array = get_initialized_struct_array(struct_ptr);\n    *(int *)(struct_ptr + 8) = initialized_struct_array;\n    initialized_struct_array = get_initialized_struct_array(struct_ptr);\n    *(int *)(struct_ptr + 0xc) = initialized_struct_array;\n    initialize_data(*(int *)(struct_ptr + 4), 4, 0);\n    initialize_data(*(int *)(struct_ptr + 8), 9, 1);\n    initialize_data(*(int *)(struct_ptr + 0xc), 0x12, 2);\n    *(int *)(struct_ptr + 0x18) = 1;\n  }\n  do_nothing(DAT_000042a0);\n  return;\n}",
            "called": [
                "FUN_0000428c",
                "FUN_000045ec",
                "FUN_000041f4",
                "FUN_00004314"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000042a4",
            "calling": [
                "FUN_00004db8",
                "FUN_000054a8",
                "FUN_00005e10",
                "FUN_000057f8",
                "FUN_00004314",
                "FUN_00006768",
                "FUN_00004cb4",
                "FUN_00004418",
                "FUN_00005404",
                "FUN_00004158",
                "FUN_00004c84"
            ],
            "imported": true,
            "current_name": "initialize_struct_array_000042a4"
        },
        "FUN_00000514": {
            "renaming": {
                "FUN_00000514": "set_value_and_return_negative_one_00000514",
                "param_1": "value",
                "*param_1": "*value"
            },
            "code": "int set_value_and_return_negative_one_00000514(int *value)\n{\n  *value = 19;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000514",
            "calling": [
                "FUN_000056b8"
            ],
            "imported": true,
            "current_name": "set_value_and_return_negative_one_00000514"
        },
        "FUN_00002e9c": {
            "renaming": {
                "FUN_00002e9c": "synchronize_data_and_return_zero_00002e9c"
            },
            "code": "undefined4 synchronize_data_and_return_zero_00002e9c(void)\n{\n  synchronize_data();\n  return 0;\n}",
            "called": [
                "FUN_00003688"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e9c",
            "calling": [],
            "imported": true,
            "current_name": "synchronize_data_and_return_zero_00002e9c"
        },
        "FUN_00001960": {
            "renaming": {
                "DAT_000019b4": "deviceData",
                "PTR_DAT_000019bc": "deviceDataPtr",
                "set_param_00001748": "setDeviceParam",
                "FUN_00001960": "initializeDevice_00001960",
                "set_offset_to_zero_00001710": "setOffsetToZero",
                "*DAT_000019b8": "*deviceDataFlags"
            },
            "code": "void initializeDevice_00001960(void)\n{\n  setDeviceParam(160);\n  setOffsetToZero(DAT_000019b4, 1);\n  *DAT_000019b8 = (*DAT_000019b8 & 59) | 68;\n  while ((DAT_000019b4Flags[6] & 12) != 4);\n  while ((DAT_000019b4Flags[6] & 16) == 0);\n  *PTR_DAT_000019bc = 2;\n  return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001960",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": true,
            "current_name": "initializeDevice_00001960"
        },
        "FUN_00000990": {
            "renaming": {
                "FUN_00000990": "do_nothing_00000990"
            },
            "code": "\nvoid do_nothing_00000990(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000990",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": true,
            "current_name": "do_nothing_00000990"
        },
        "FUN_00001a3c": {
            "renaming": {
                "FUN_00001a3c": "set_offset_and_value_00001a3c",
                "PTR_DAT_00001a5c": "data",
                "DAT_00001a58": "data"
            },
            "code": "void set_offset_and_value_00001a3c(int* DAT_00001a58, int offset, int value){\n  set_offset_to_one(DAT_00001a58, offset);\n  set_offset_to_zero_for_six_elements(DAT_00001a58);\n  *DAT_00001a58 = value;\n  return;\n}",
            "called": [
                "FUN_000016ec",
                "FUN_00001734"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a3c",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": true,
            "current_name": "set_offset_and_value_00001a3c"
        },
        "FUN_000045ee": {
            "renaming": {
                "puVar2": "source_end",
                "param_1": "start",
                "FUN_000045ee": "reverse_copy_range_000045ee",
                "param_2": "end",
                "param_3": "size",
                "puVar1": "destination_end"
            },
            "code": "void reverse_copy_range_000045ee(unsigned char *start, unsigned char *end, size_t size) {\n  unsigned char *source_end = end + size;\n  if ((end < start) && (start < source_end)) {\n    unsigned char *destination_end = start + size;\n    while (destination_end != start) {\n      source_end--;\n      destination_end--;\n      *destination_end = *source_end;\n    }\n  }\n  else {\n    start--;\n    for (; end != source_end; end++) {\n      start++;\n      *start = *end;\n    }\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ee",
            "calling": [
                "FUN_00003ff4"
            ],
            "imported": true,
            "current_name": "reverse_copy_range_000045ee"
        },
        "FUN_00005404": {
            "renaming": {
                "iVar1": "array_index",
                "puVar3": "byte_pointer",
                "param_1": "input_length",
                "FUN_00005404": "process_input_00005404",
                "param_2": "input_value",
                "param_3": "input_array",
                "param_4": "input_4",
                "uVar2": "array_value"
            },
            "code": "uint process_input_00005404(int input_length, uint input_value, int *input_array, undefined4 input_4)\n{\n  int array_index;\n  uint array_value;\n  undefined *byte_pointer;\n  \n  if ((input_length != 0) && (*(int *)(input_length + 0x18) == 0)) {\n    initialize_struct_array();\n  }\n  if (input_array == (int *)PTR_DAT_0000549c) {\n    input_array = *(int **)(input_length + 4);\n  }\n  else if (input_array == (int *)PTR_DAT_000054a0) {\n    input_array = *(int **)(input_length + 8);\n  }\n  else if (input_array == (int *)PTR_DAT_000054a4) {\n    input_array = *(int **)(input_length + 0xc);\n  }\n  input_array[2] = input_array[6];\n  array_value = (uint)*(ushort *)(input_array + 3);\n  array_index = array_value << 0x1c;\n  if (((array_index < 0) && (array_value = input_array[4], array_value != 0)) ||\n     (array_index = process_input_00005404_data(input_length,input_array,array_index,array_value,input_4), array_index == 0)) {\n    array_index = *input_array - input_array[4];\n    input_value = input_value & 0xff;\n    if ((array_index < input_array[5]) || (array_index = process_input_00005404_data_2(input_length,input_array), array_index == 0)) {\n      input_array[2] = input_array[2] + -1;\n      byte_pointer = (undefined *)*input_array;\n      *input_array = (int)(byte_pointer + 1);\n      *byte_pointer = (char)input_value;\n      if (input_array[5] != array_index + 1) {\n        if (-1 < (int)((uint)*(ushort *)(input_array + 3) << 0x1f)) {\n          return input_value;\n        }\n        if (input_value != 10) {\n          return input_value;\n        }\n      }\n      array_index = process_input_00005404_data_2(input_length,input_array);\n      if (array_index == 0) {\n        return input_value;\n      }\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "FUN_000054a8",
                "FUN_000042a4",
                "FUN_00004158"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005404",
            "calling": [
                "FUN_00004db8",
                "FUN_00004cb4",
                "FUN_000057a8"
            ],
            "imported": true,
            "current_name": "process_input_00005404"
        },
        "FUN_00006974": {
            "renaming": {
                "iVar1": "quotient_high",
                "param_1": "dividend_high",
                "local_8": "local_array",
                "FUN_00006974": "calculate_result_00006974",
                "param_2": "dividend_low",
                "param_3": "divisor_high",
                "param_4": "divisor_low",
                "uVar2": "result"
            },
            "code": "undefined8 calculate_result_00006974(int dividend_high, int dividend_low, int divisor_high, int divisor_low)\n{\n  int quotient_high;\n  int quotient_low;\n  undefined8 result;\n  if ((divisor_low == 0) && (divisor_high == 0)) {\n    if (dividend_low < 0) {\n      dividend_high = 0;\n      dividend_low = -0x80000000;\n    }\n    else if (dividend_low != 0 || dividend_high != 0) {\n      dividend_high = 0x7fffffff;\n      dividend_low = -1;\n    }\n    return CONCAT44(dividend_high, dividend_low);\n  }\n  if (dividend_low < 0) {\n    quotient_high = -dividend_low - (uint)(dividend_high != 0);\n    if (divisor_high < 0) {\n      result = FUNC_00006a14(-dividend_high, quotient_high, -divisor_low, -divisor_high - (uint)(-divisor_low != 0), local_8);\n      return result;\n    }\n    result = FUNC_00006a14(-dividend_high, quotient_high, divisor_low, divisor_high, local_8);\n    return CONCAT44(-(int)((ulonglong)result >> 0x20) - (uint)((int)result != 0), -(int)result);\n  }\n  if (divisor_high < 0) {\n    result = FUNC_00006a14(dividend_high, dividend_low, -divisor_low, -divisor_high - (uint)(-divisor_low != 0), local_8);\n    return CONCAT44(-(int)((ulonglong)result >> 0x20) - (uint)((int)result != 0), -(int)result);\n  }\n  result = FUNC_00006a14(dividend_high, dividend_low, divisor_low, divisor_high, local_8);\n  return result;\n}",
            "called": [
                "FUN_00006a14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006974",
            "calling": [
                "FUN_0000443c"
            ],
            "imported": true,
            "current_name": "calculate_result_00006974"
        },
        "FUN_00004314": {
            "renaming": {
                "iVar3": "struct_array_ptr",
                "piVar2": "first_struct_ptr",
                "param_1": "error_code",
                "piVar1": "current_struct_ptr",
                "FUN_00004314": "get_initialized_struct_array_00004314",
                "ppiVar4": "next_struct_array_ptr_ptr"
            },
            "code": "int* get_initialized_struct_array_00004314(undefined4 *error_code){\n  int *current_struct_ptr;\n  int *first_struct_ptr;\n  int struct_array_ptr;\n  int **next_struct_array_ptr_ptr;\n  do_nothing_with_pointer();\n  struct_array_ptr = *(int*)PTR_DAT_00004398;\n  if (*(int*)(struct_array_ptr + 0x18) == 0) {\n    initialize_struct_array(struct_array_ptr);\n  }\n  next_struct_array_ptr_ptr = (int**)(struct_array_ptr + 0x48);\n  while (true) {\n    current_struct_ptr = next_struct_array_ptr_ptr[1];\n    first_struct_ptr = next_struct_array_ptr_ptr[2];\n    while (current_struct_ptr = (int*)((int)current_struct_ptr - 1), -1 < (int)current_struct_ptr) {\n      if (*(short*)(first_struct_ptr + 3) == 0) {\n        first_struct_ptr[3] = DAT_0000439c;\n        first_struct_ptr[0x19] = 0;\n        do_nothing_000045e4(first_struct_ptr + 0x16);\n        do_nothing_with_pointer();\n        first_struct_ptr[1] = 0;\n        first_struct_ptr[2] = 0;\n        first_struct_ptr[4] = 0;\n        first_struct_ptr[5] = 0;\n        *first_struct_ptr = 0;\n        first_struct_ptr[6] = 0;\n        fill_array_with_value(first_struct_ptr + 0x17, 0, 8);\n        first_struct_ptr[0xd] = 0;\n        first_struct_ptr[0xe] = 0;\n        first_struct_ptr[0x12] = 0;\n        first_struct_ptr[0x13] = 0;\n        return first_struct_ptr;\n      }\n      first_struct_ptr = first_struct_ptr + 0x1a;\n    }\n    if (*next_struct_array_ptr_ptr == (int*)0x0) {\n      current_struct_ptr = (int*)initialize_and_allocate_struct_array(error_code, 4);\n      *next_struct_array_ptr_ptr = current_struct_ptr;\n      if (current_struct_ptr == (int*)0x0) {\n        do_nothing_with_pointer();\n        *error_code = 0xc;\n        return (int*)0x0;\n      }\n    }\n    next_struct_array_ptr_ptr = (int**)*next_struct_array_ptr_ptr;\n  }\n}",
            "called": [
                "FUN_00004248",
                "FUN_00004274",
                "FUN_00004622",
                "FUN_000042a4",
                "FUN_00004280",
                "FUN_000045e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004314",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": true,
            "current_name": "get_initialized_struct_array_00004314",
            "code_backup": "\nint * FUN_00004314(undefined4 *param_1)\n\n{\n  int *piVar1;\n  int *piVar2;\n  int iVar3;\n  int **ppiVar4;\n  \n  do_nothing_with_pointer_00004274();\n  iVar3 = *(int *)PTR_DAT_00004398;\n  if (*(int *)(iVar3 + 0x18) == 0) {\n    FUNC_000042a4(iVar3);\n  }\n  ppiVar4 = (int **)(iVar3 + 0x48);\n  do {\n    piVar1 = ppiVar4[1];\n    piVar2 = ppiVar4[2];\n    while (piVar1 = (int *)((int)piVar1 + -1), -1 < (int)piVar1) {\n      if (*(short *)(piVar2 + 3) == 0) {\n        piVar2[3] = DAT_0000439c;\n        piVar2[0x19] = 0;\n        do_nothing_000045e4(piVar2 + 0x16);\n        do_nothing_with_pointer_00004280();\n        piVar2[1] = 0;\n        piVar2[2] = 0;\n        piVar2[4] = 0;\n        piVar2[5] = 0;\n        *piVar2 = 0;\n        piVar2[6] = 0;\n        fill_array_with_value_00004622(piVar2 + 0x17,0,8);\n        piVar2[0xd] = 0;\n        piVar2[0xe] = 0;\n        piVar2[0x12] = 0;\n        piVar2[0x13] = 0;\n        return piVar2;\n      }\n      piVar2 = piVar2 + 0x1a;\n    }\n    if (*ppiVar4 == (int *)0x0) {\n      piVar1 = (int *)allocate_and_initialize_array_of_structs_00004248(param_1,4);\n      *ppiVar4 = piVar1;\n      if (piVar1 == (int *)0x0) {\n        do_nothing_with_pointer_00004280();\n        *param_1 = 0xc;\n        return (int *)0x0;\n      }\n    }\n    ppiVar4 = (int **)*ppiVar4;\n  } while( true );\n}\n\n"
        },
        "FUN_00004dc8": {
            "renaming": {
                "iVar1": "action_result",
                "bVar3": "action_successful",
                "param_1": "data",
                "FUN_00004dc8": "process_data_00004dc8",
                "param_2": "metadata",
                "uVar2": "updated_value"
            },
            "code": "void process_data_00004dc8(int data, int metadata) {\n  int action_result = perform_action_on_data(data, (int)*(short *)(metadata + 0xe));\n  bool action_successful = action_result >= 0;\n  uint updated_value;\n  if (action_successful) {\n    updated_value = *(int *)(metadata + 0x54) + action_result;\n  }\n  else {\n    updated_value = *(ushort *)(metadata + 0xc) & 0xffffefff;\n  }\n  if (action_successful) {\n    *(uint *)(metadata + 0x54) = updated_value;\n  }\n  if (!action_successful) {\n    *(short *)(metadata + 0xc) = (short)updated_value;\n  }\n  return;\n}",
            "called": [
                "FUN_00000490"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dc8",
            "calling": [],
            "imported": true,
            "current_name": "process_data_00004dc8"
        },
        "FUN_00005fd8": {
            "renaming": {
                "param_1": "out_val",
                "param_2": "min_val",
                "param_3": "max_val",
                "FUN_00005fd8": "parse_uint_from_string_wrapper_00005fd8",
                "parse_uint_from_string_00005edc": "parse_uint_from_string",
                "*DAT_00005fe8": "str"
            },
            "code": "void parse_uint_from_string_wrapper_00005fd8(char* *DAT_00005fe8, int* out_val, int min_val, int max_val)\n{\n  parse_uint_from_*DAT_00005fe8ing(*DAT_00005fe8, out_val, min_val, max_val);\n  return;\n}",
            "called": [
                "FUN_00005edc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd8",
            "calling": [
                "FUN_00005100"
            ],
            "imported": true,
            "current_name": "parse_uint_from_string_wrapper_00005fd8"
        },
        "FUN_00005e10": {
            "renaming": {
                "iVar1": "result",
                "param_1": "data_ptr",
                "pbVar3": "data_byte_ptr",
                "param_2": "data_array_ptr",
                "uVar2": "extracted_byte",
                "FUN_00005e10": "extract_byte_from_data_00005e10"
            },
            "code": "uint extract_byte_from_data_00005e10(int data_ptr, byte **data_array_ptr)\n{\n  int struct_ptr = *(int *)(data_ptr + 0x18);\n  uint extracted_byte = 0xffffffff;\n\n  if ((data_ptr != 0) && (struct_ptr == 0)) {\n    initialize_struct_array();\n  }\n\n  if (data_array_ptr == (byte **)&PTR_DAT_00005e5c) {\n    data_array_ptr = (byte **)*(int *)(data_ptr + 4);\n  }\n  else if (data_array_ptr == (byte **)&PTR_DAT_00005e60) {\n    data_array_ptr = (byte **)*(int *)(data_ptr + 8);\n  }\n  else if (data_array_ptr == (byte **)&PTR_DAT_00005e64) {\n    data_array_ptr = (byte **)*(int *)(data_ptr + 0xc);\n  }\n\n  int result = process_data(data_ptr, data_array_ptr);\n\n  if (result == 0) {\n    (*data_array_ptr)[1]--;\n    byte *data_byte_ptr = *data_array_ptr;\n    *data_array_ptr = data_byte_ptr + 1;\n    extracted_byte = (uint)*data_byte_ptr;\n  }\n\n  return extracted_byte;\n}",
            "called": [
                "FUN_00006768",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e10",
            "calling": [
                "FUN_00004418"
            ],
            "imported": true,
            "current_name": "extract_byte_from_data_00005e10"
        },
        "FUN_000033f4": {
            "renaming": {
                "iVar1": "calculate_result",
                "FUNC_00004db8": "print_error",
                "auStack_2c": "alarm_data",
                "execute_function_and_update_data_00002654": "execute_function_and_update_data",
                "param_1": "value",
                "PTR_FUN_000031e0_1_0000343c": "PTR_fun_ptr",
                "calculate_value_0000328c": "calculate_value",
                "uVar2": "return_value",
                "PTR_s_rtc__error_setting_alarm_00003440": "PTR_error_msg",
                "FUN_000033f4": "set_alarm_if_value_valid_000033f4"
            },
            "code": "int set_alarm_if_value_valid_000033f4(int value)\n{\n  int calculate_result;\n  undefined4 alarm_data[9];\n  \n  calculate_result = calculate_value(value, alarm_data);\n  if (calculate_result == 0) {\n    int execute_result = execute_function_and_update_data(alarm_data, PTR_FUN_000031e0_1_0000343c, 0);\n    if (execute_result == -1) {\n      print_error(PTR_s_rtc__error_setting_alarm_00003440);\n      return 1;\n    }\n    else {\n      return 0;\n    }\n  }\n  else {\n    return 1;\n  }\n}",
            "called": [
                "FUN_00004db8",
                "FUN_0000328c",
                "FUN_00002654"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033f4",
            "calling": [
                "FUN_00003524"
            ],
            "imported": true,
            "current_name": "set_alarm_if_value_valid_000033f4",
            "code_backup": "\nundefined4 FUN_000033f4(undefined4 param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_2c [36];\n  \n  iVar1 = calculate_value_0000328c(param_1,auStack_2c);\n  if (iVar1 == 0) {\n    iVar1 = execute_function_and_update_data_00002654(auStack_2c,PTR_FUN_000031e0_1_0000343c,0);\n    if (iVar1 == -1) {\n      FUNC_00004db8(PTR_s_rtc__error_setting_alarm_00003440);\n      uVar2 = 1;\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n"
        },
        "FUN_0000443c": {
            "renaming": {
                "FUN_0000443c": "calculate_date_from_timestamp_0000443c",
                "uVar11": "total_seconds_since_sunday",
                "iVar1": "days_since_epoch",
                "uVar12": "day_of_month",
                "uVar13": "month",
                "param_1": "timestamp",
                "iVar10": "year",
                "param_2": "date",
                "uVar3": "DAT_0000458c",
                "uVar2": "seconds_in_day",
                "bVar9": "is_negative",
                "uVar5": "total_seconds",
                "uVar4": "day_of_week",
                "uVar7": "DAT_00004590",
                "uVar6": "DAT_00004594",
                "uVar8": "total_minutes"
            },
            "code": "uint * calculate_date_from_timestamp_0000443c(uint32_t *timestamp, uint32_t *date) {\n    int days_since_epoch = calculate_days_since_epoch(timestamp[0], timestamp[1], DAT_0000458c, 0);\n    uint32_t seconds_in_day = DAT_0000458c;\n    calculate_days_since_epoch(timestamp[0], timestamp[1], DAT_0000458c, 0);\n    bool is_negative = (int)seconds_in_day < 0;\n    if (is_negative) {\n        seconds_in_day += 0x15180;\n    }\n    uint32_t day_of_week = (days_since_epoch + 3) % 7;\n    seconds_in_day = seconds_in_day < 0 ? seconds_in_day - 0x23ab0 : seconds_in_day;\n    uint32_t total_seconds = DAT_00004594 * (seconds_in_day / DAT_00004590) + seconds_in_day;\n    uint32_t total_minutes = ((total_seconds / 0x8eac + total_seconds) - total_seconds / 0x5b4) - total_seconds / DAT_00004598;\n    uint32_t total_days = total_minutes / 0x16d;\n    total_seconds = (total_days / 100 - total_minutes / 0x5b4) + total_seconds + total_days * -0x16d;\n    uint32_t total_seconds_since_sunday = total_seconds * 5 + 2;\n    uint32_t day_of_month = total_seconds_since_sunday / 0x99;\n    int32_t year = (seconds_in_day / DAT_00004590) * 400 + total_days;\n    if (day_of_month < 2) {\n        year += 1;\n    }\n    uint32_t month, day;\n    if (total_seconds < 0x132) {\n        if (((total_days % 4) == 0) && (total_days != (total_days / 100) * 100)) {\n            month = 1;\n        }\n        else {\n            month = count_leading_zeroes(total_days % 400) >> 5;\n        }\n        day = total_seconds + 0x3b + month;\n    }\n    else {\n        day = total_seconds - 0x132;\n    }\n    date[7] = day;\n    date[3] = (total_seconds + 1) - (day_of_month * 0x99 + 2) / 5;\n    date[4] = day_of_month < 0x5fa ? 2 : -10;\n    date[5] = year - 0x76c;\n    date[8] = 0;\n    return date;\n}",
            "called": [
                "FUN_00006974"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000443c",
            "calling": [
                "FUN_00002624",
                "FUN_00002690"
            ],
            "imported": true,
            "current_name": "calculate_date_from_timestamp_0000443c"
        },
        "FUN_000027b0": {
            "renaming": {
                "FUN_000027b0": "initialize_data_access_flags_000027b0",
                "DAT_00002818": "data_access_flags_base_address",
                "set_flag_for_data_access_0000294c": "set_flag_for_data_access",
                "DAT_00002814": "data_access_flags",
                "puVar1": "data_access_flags"
            },
            "code": "void initialize_data_access_flags_000027b0(void)\n{\n  uint32_t* DAT_00002814 = DAT_00002814;\n  uint32_t* DAT_00002818 = DAT_00002818;\n  uint32_t* DAT_00002814_register = DAT_00002818 + 0x103c;\n  *DAT_00002814_register |= 0x20000000;\n  DAT_00002814[4] = 1;\n  DAT_00002814[4] = 0;\n  if ((DAT_00002814[5] & 1) != 0) {\n    *DAT_00002814 = 0;\n  }\n  DAT_00002814[4] = 0x104;\n  DAT_00002814[2] = 0xffffff42;\n  DAT_00002814[7] = 0;\n  set_flag_for_data_access_0000294c();\n  return;\n}",
            "called": [
                "FUN_0000294c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000027b0",
            "calling": [
                "FUN_000025f4"
            ],
            "imported": true,
            "current_name": "initialize_data_access_flags_000027b0"
        },
        "FUN_00005ebc": {
            "renaming": {
                "FUN_00005ebc": "copy_string_00005ebc",
                "param_1": "destination",
                "param_2": "source",
                "cVar1": "current_character"
            },
            "code": "void copy_string_00005ebc(char *destination, char *source)\n{\n  char current_character;\n  do {\n    current_character = *source;\n    *destination = current_character;\n    source = source + 1;\n    destination = destination + 1;\n  } while (current_character != '\\0');\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ebc",
            "calling": [
                "FUN_00005100"
            ],
            "imported": true,
            "current_name": "copy_string_00005ebc"
        },
        "FUN_00006192": {
            "renaming": {
                "param_2[0xd]": "buffer[13]",
                "param_2[1]": "buffer[1]",
                "param_2[0xf]": "buffer[15]",
                "param_2 + 0x11": "buffer + 17",
                "FUN_00006192": "process_data_00006192",
                "param_2[0x10]": "buffer[16]",
                "param_1": "data",
                "param_2": "buffer"
            },
            "code": "int process_data_00006192(int data, int* buffer) {\n  int* pointer_d = (int*)buffer[13];\n  if (pointer_d != NULL) {\n    if (pointer_d != buffer + 17) {\n      insert_element();\n    }\n    buffer[1] = buffer[16];\n    buffer[13] = NULL;\n    if (buffer[16] != 0) {\n      *buffer = buffer[15];\n      return 0;\n    }\n  }\n  *buffer = buffer[4];\n  buffer[1] = 0;\n  *(unsigned short*)(buffer + 3) = *(unsigned short*)(buffer + 3) | 0x20;\n  return -1;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006192",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": true,
            "current_name": "process_data_00006192"
        },
        "FUN_00001734": {
            "renaming": {
                "FUN_00001734": "set_offset_to_zero_for_six_elements_00001734",
                "DAT_00001744": "PTR_array_of_six_elements",
                "set_offset_to_zero_00001710": "set_offset_to_zero"
            },
            "code": "void set_offset_to_zero_for_six_elements_00001734(void)\n{\n  set_offset_to_zero(DAT_00001744, 6);\n  return;\n}",
            "called": [
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001734",
            "calling": [
                "FUN_00001a3c",
                "FUN_00001a18",
                "FUN_000019c0"
            ],
            "imported": true,
            "current_name": "set_offset_to_zero_for_six_elements_00001734"
        },
        "FUN_00000e14": {
            "renaming": {
                "FUN_00000e14": "FUNC_00000e14"
            },
            "code": "\nundefined4 FUNC_00000e14(undefined4 param_1,undefined4 param_2)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 = copy_linked_list_000012e2(DAT_00000e34,param_1,param_2);\n  return uVar1;\n}\n\n",
            "called": [
                "FUN_000012e2"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00000e14",
            "calling": [
                "FUN_00000490"
            ],
            "imported": false,
            "current_name": "FUNC_00000e14"
        },
        "FUN_0000281c": {
            "renaming": {
                "local_c": "current_value",
                "FUN_0000281c": "find_first_match_0000281c",
                "local_10": "match_count"
            },
            "code": "int find_first_match_0000281c(void)\n{\n  int match_count = 0;\n  int current_value;\n  while ((match_count < 3 && (current_value = *DAT_00002858, current_value != *DAT_00002858))) {\n    match_count++;\n  }\n  return current_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000281c",
            "calling": [
                "FUN_00002624"
            ],
            "imported": true,
            "current_name": "find_first_match_0000281c"
        },
        "FUN_00002270": {
            "renaming": {
                "bVar3": "is_equal",
                "iVar2": "pointer_value",
                "uVar1": "is_equal",
                "FUN_00002270": "is_pointer_equal_00002270",
                "param_1": "pointer_address"
            },
            "code": "bool is_pointer_equal_00002270(int pointer_address) {\n  int pointer_value = *(int *)(pointer_address + 0xc);\n  bool is_equal = *(int *)(pointer_address + 8) == pointer_value;\n  if (is_equal) {\n    return true;\n  }\n  else {\n    return false;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002270",
            "calling": [
                "FUN_0000231c"
            ],
            "imported": true,
            "current_name": "is_pointer_equal_00002270"
        },
        "FUN_00005780": {
            "renaming": {
                "FUN_00005780": "insert_element_to_data_array_00005780",
                "param_1": "new_element",
                "*DAT_0000578c": "data_array"
            },
            "code": "void insert_element_to_data_array_00005780(int* *DAT_0000578c, int new_element){\n  insert_element_to_array(*DAT_0000578c, new_element);\n  return;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005780",
            "calling": [
                "FUN_00005100"
            ],
            "imported": true,
            "current_name": "insert_element_to_data_array_00005780"
        },
        "FUN_000020cc": {
            "renaming": {
                "DAT_000020dc": "data",
                "FUN_000020cc": "process_flags_000020cc",
                "process_flags_00002028": "update_flags"
            },
            "code": "void process_flags_000020cc(int* DAT_000020dc, int flag) {\n  update_flags(DAT_000020dc, flag);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020cc",
            "calling": [],
            "imported": true,
            "current_name": "process_flags_000020cc"
        },
        "FUN_00002396": {
            "renaming": {
                "FUN_00002396": "initialize_data_access_flags_00002396"
            },
            "code": "void initialize_data_access_flags_00002396(void)\n{\n  set_data_access_flags();\n  return;\n}",
            "called": [
                "FUN_000025f4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002396",
            "calling": [
                "FUN_00001274"
            ],
            "imported": true,
            "current_name": "initialize_data_access_flags_00002396"
        },
        "FUN_00004cb4": {
            "renaming": {
                "iVar4": "struct_array_ptr",
                "puVar3": "current_char_ptr",
                "param_1": "input_char",
                "FUN_00004cb4": "process_input_00004cb4",
                "unaff_r5": "N/A",
                "unaff_r4": "N/A",
                "puVar1": "current_struct_ptr",
                "uVar2": "current_count"
            },
            "code": "uint process_input_00004cb4(uint input_char)\n{\n  int struct_array_ptr = *DAT_00004cd8;\n  if ((struct_array_ptr != 0) && (*(int *)(struct_array_ptr + 0x18) == 0)) {\n    initialize_struct_array(struct_array_ptr);\n  }\n  uint *current_struct_ptr = *(uint **)(struct_array_ptr + 8);\n  if ((struct_array_ptr != 0) && (*(int *)(struct_array_ptr + 0x18) == 0)) {\n    initialize_struct_array(struct_array_ptr);\n  }\n  if (current_struct_ptr == (uint *)PTR_DAT_00005e04) {\n    current_struct_ptr = *(uint **)(struct_array_ptr + 4);\n  }\n  else if (current_struct_ptr == (uint *)PTR_DAT_00005e08) {\n    current_struct_ptr = *(uint **)(struct_array_ptr + 8);\n  }\n  else if (current_struct_ptr == (uint *)PTR_DAT_00005e0c) {\n    current_struct_ptr = *(uint **)(struct_array_ptr + 0xc);\n  }\n  if ((-1 < (int)(current_struct_ptr[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(current_struct_ptr + 3) << 0x16))) {\n    do_nothing(current_struct_ptr[0x16]);\n  }\n  uint current_count = current_struct_ptr[2] - 1;\n  current_struct_ptr[2] = current_count;\n  if (((int)current_count < 0) && (((int)current_count < (int)current_struct_ptr[6] || (current_count = input_char & 0xff, current_count == 10))))\n  {\n    input_char = process_input_00004cb4_helper(struct_array_ptr,input_char,current_struct_ptr,current_count);\n  }\n  else {\n    undefined *current_char_ptr = (undefined *)*current_struct_ptr;\n    *current_struct_ptr = current_char_ptr + 1;\n    *current_char_ptr = (char)input_char;\n    input_char = input_char & 0xff;\n  }\n  if ((-1 < (int)(current_struct_ptr[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(current_struct_ptr + 3) << 0x16))) {\n    do_nothing(current_struct_ptr[0x16]);\n  }\n  return input_char;\n}",
            "called": [
                "FUN_000045ec",
                "FUN_000045e8",
                "FUN_000042a4",
                "FUN_00005404"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cb4",
            "calling": [
                "FUN_00002a00"
            ],
            "imported": true,
            "current_name": "process_input_00004cb4"
        },
        "FUN_00003478": {
            "renaming": {
                "iVar1": "calculate_value_result",
                "FUNC_00004db8": "log_error",
                "auStack_2c": "data_buffer",
                "param_1": "time_value",
                "FUN_00003478": "set_time_and_process_data_00003478",
                "calculate_value_0000328c": "calculate_value",
                "process_data_00002600": "process_data",
                "uVar2": "set_time_and_process_data_result",
                "PTR_s_rtc__error_setting_time_000034bc": "PTR_s_rtc__error_setting_time_000034bc"
            },
            "code": "int set_time_and_process_data_00003478(undefined4 time_value)\n{\n  int calculate_value_result;\n  undefined4 data_buffer[9];\n  \n  calculate_value_result = calculate_value(time_value, data_buffer);\n  if (calculate_value_result == 0) {\n    int process_data_result = process_data(data_buffer);\n    if (process_data_result == -1) {\n      log_error(PTR_s_rtc__error_setting_time_000034bc);\n      return 1;\n    }\n    else {\n      return 0;\n    }\n  }\n  else {\n    return 1;\n  }\n}",
            "called": [
                "FUN_00004db8",
                "FUN_0000328c",
                "FUN_00002600"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003478",
            "calling": [
                "FUN_00003524"
            ],
            "imported": true,
            "current_name": "set_time_and_process_data_00003478",
            "code_backup": "\nundefined4 FUN_00003478(undefined4 param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_2c [36];\n  \n  iVar1 = calculate_value_0000328c(param_1,auStack_2c);\n  if (iVar1 == 0) {\n    iVar1 = process_data_00002600(auStack_2c);\n    if (iVar1 == -1) {\n      FUNC_00004db8(PTR_s_rtc__error_setting_time_000034bc);\n      uVar2 = 1;\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n"
        },
        "FUN_00002028": {
            "renaming": {
                "iVar1": "bitfield_value",
                "local_c": "current_flag",
                "param_1": "flags_ptr",
                "FUN_00002028": "process_flags_00002028",
                "param_2": "param_2",
                "uVar2": "flag_value"
            },
            "code": "void process_flags_00002028(int flags_ptr, uint32_t param_2)\n{\n  int bitfield_value;\n  uint32_t flag_value;\n  uint32_t current_flag;\n  flag_value = *(uint32_t *)(flags_ptr + 0xa0);\n  for (current_flag = 0; (int)current_flag < 0x20; current_flag++) {\n    if (((flag_value & 1 << (current_flag & 0xff)) != 0) &&\n       ((*(uint32_t *)(flags_ptr + current_flag * 4) & 0xf0000) != 0)) {\n      *(uint32_t *)(flags_ptr + 0xa0) = 1 << (current_flag & 0xff);\n      bitfield_value = get_bitfield_value(param_2, current_flag);\n      (**(void (**)(void))(PTR_DAT_000020b4 + bitfield_value * 0xc))\n                (*(uint32_t *)(PTR_DAT_000020b4 + bitfield_value * 0xc + 4));\n    }\n  }\n  checkIfFlagIsSet_00001cf0();\n  return;\n}",
            "called": [
                "FUN_00001cf0",
                "FUN_00001e0c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002028",
            "calling": [
                "FUN_000020f4",
                "FUN_000020b8",
                "FUN_00002108",
                "FUN_000020e0",
                "FUN_000020cc"
            ],
            "imported": true,
            "current_name": "process_flags_00002028"
        },
        "FUN_000016c8": {
            "renaming": {
                "param_1": "base_address",
                "calculate_offset_00001696": "calculate_offset",
                "param_2": "offset",
                "FUN_000016c8": "set_offset_to_one_000016c8",
                "puVar1": "offset_value"
            },
            "code": "void set_offset_to_one_000016c8(void* base_address, unsigned char offset) {\n  void* offset_address = calculate_offset(base_address, offset);\n  int* offset_value = (int*)offset_address;\n  *offset_value = 1;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016c8",
            "calling": [
                "FUN_000017dc"
            ],
            "imported": true,
            "current_name": "set_offset_to_one_000016c8"
        },
        "FUN_00001a60": {
            "renaming": {
                "DAT_00001ac8": "data_offset_2",
                "DAT_00001ac4": "data_offset_1",
                "FUN_00001a60": "initialize_data_00001a60",
                "DAT_00001acc": "data_offset_3"
            },
            "code": "void initialize_data_00001a60(void)\n{\n  set_offset_to_zero(DAT_00001ac4,1);\n  *DAT_00001ac8 = *DAT_00001ac8 & 0x3f | 0x80;\n  while ((DAT_00001ac8[6] & 0xc) != 8);\n  set_offset_to_one(DAT_00001acc,6);\n  while ((DAT_00001ac8[6] & 0x20) == 0);\n  while ((DAT_00001ac8[6] & 0x40) == 0);\n  *PTR_DAT_00001ad0 = 6;\n  return;\n}",
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a60",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": true,
            "current_name": "initialize_data_00001a60"
        },
        "FUN_0000099c": {
            "renaming": {
                "PTR_Elf32_Rel_ARRAY_00000a20": "relocation_array_pointer",
                "local_c": "memory_pointer_3",
                "PTR_DAT_00000a24": "original_array_pointer_end",
                "DAT_00000a1c": "original_array_value",
                "DAT_00000a2c": "interrupt_handling_pointer_end",
                "uStack_18": "memory_clear_value",
                "PTR_DAT_00000a28": "interrupt_handling_pointer",
                "local_10": "memory_pointer_2",
                "DAT_00000a14": "original_data_array_pointer",
                "FUN_0000099c": "initialize_game_0000099c",
                "local_14": "memory_pointer_1"
            },
            "code": "void initialize_game_0000099c() {\n  undefined4 memory_clear_value;\n  undefined4 *memory_pointer_1;\n  undefined4 *memory_pointer_2;\n  undefined4 *memory_pointer_3;\n  memory_pointer_1 = &memory_clear_value;\n  memory_pointer_2 = DAT_00000a14;\n  initialize_data_and_clear_memory();\n  memory_pointer_3 = (undefined4 *)original_array_pointer;\n  while (memory_pointer_3 < &memory_clear_value) {\n    *memory_pointer_3 = DAT_00000a1c;\n    memory_pointer_3++;\n  }\n  memory_pointer_3 = (undefined4 *)PTR_Elf32_Rel_ARRAY_00000a20;\n  while (memory_pointer_3 < PTR_DAT_00000a24) {\n    *memory_pointer_3 = *memory_pointer_2;\n    memory_pointer_2++;\n    memory_pointer_3++;\n  }\n  memory_pointer_3 = (undefined4 *)PTR_DAT_00000a28;\n  while( true ) {\n    if (DAT_00000a2c <= memory_pointer_3) break;\n    *memory_pointer_3 = 0;\n    memory_pointer_3++;\n  }\n  do_nothing();\n  initialize_game_0000099c_and_set_flags();\n  process_and_execute_functions();\n  initialize_interrupt_handling();\n  return;\n}",
            "called": [
                "FUN_00000e64",
                "FUN_00000990",
                "FUN_00000f8c",
                "FUN_00000db0",
                "FUN_0000459c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000099c",
            "calling": [],
            "imported": true,
            "current_name": "initialize_game_0000099c"
        },
        "FUN_00002d94": {
            "renaming": {
                "bVar2": "current_byte",
                "iVar1": "extracted_byte",
                "bVar3": "is_start_of_buffer",
                "local_c": "current_position",
                "param_1": "input_buffer",
                "param_2": "buffer_size",
                "FUN_00002d94": "process_input_00002d94"
            },
            "code": "uint process_input_00002d94(undefined *input_buffer, int buffer_size)\n{\n  int extracted_byte;\n  byte current_byte;\n  bool is_start_of_buffer;\n  undefined *current_position;\n  \n  current_position = input_buffer;\n  while( true ) {\n    if (buffer_size + -1 <= (int)current_position - (int)input_buffer) {\n      return 0xffffffff;\n    }\n    extracted_byte = extract_byte_from_data_00004418();\n    if (extracted_byte < 0) break;\n    if ((extracted_byte == 0xd) || (extracted_byte == 10)) {\n      *current_position = 0;\n      process_input_00002d94_wrapper_00002a00(0xd);\n      process_input_00002d94_wrapper_00002a00(10);\n      is_start_of_buffer = current_position == input_buffer;\n      if (is_start_of_buffer) {\n        input_buffer = (undefined *)0x1;\n      }\n      current_byte = (byte)input_buffer;\n      if (!is_start_of_buffer) {\n        current_byte = 0;\n      }\n      return (uint)current_byte;\n    }\n    if ((extracted_byte == 8) || (extracted_byte == 0x7f)) {\n      if (current_position != input_buffer) {\n        current_position = current_position + -1;\n        *current_position = 0;\n        process_input_00002d94_wrapper_00002a00(8);\n        process_input_00002d94_wrapper_00002a00(0x20);\n        process_input_00002d94_wrapper_00002a00(8);\n      }\n    }\n    else {\n      *current_position = (char)extracted_byte;\n      process_input_00002d94_wrapper_00002a00(extracted_byte);\n      current_position = current_position + 1;\n    }\n  }\n  return 1;\n}",
            "called": [
                "FUN_00002a00",
                "FUN_00004418"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002d94",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": true,
            "current_name": "process_input_00002d94"
        },
        "FUN_00003918": {
            "renaming": {
                "uVar1": "ascii_code",
                "param_1": "input",
                "FUN_00003918": "get_ascii_code_00003918"
            },
            "code": "int get_ascii_code_00003918(int input) {\n    int ascii_code;\n    switch(input) {\n        case 2:\n            ascii_code = 104;\n            break;\n        case 3:\n            ascii_code = 107;\n            break;\n        case 6:\n            ascii_code = 77;\n            break;\n        case 9:\n            ascii_code = 71;\n            break;\n        case 12:\n            ascii_code = 84;\n            break;\n        case 15:\n            ascii_code = 80;\n            break;\n        case 241:\n            ascii_code = 102;\n            break;\n        case 244:\n            ascii_code = 112;\n            break;\n        case 247:\n            ascii_code = 110;\n            break;\n        case 250:\n            ascii_code = 117;\n            break;\n        case 253:\n            ascii_code = 109;\n            break;\n        default:\n            ascii_code = 0;\n            break;\n    }\n    return ascii_code;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003918",
            "calling": [
                "FUN_00003694"
            ],
            "imported": true,
            "current_name": "get_ascii_code_00003918"
        },
        "FUN_00003d64": {
            "renaming": {
                "uVar1": "result",
                "param_1": "function_ptr",
                "param_2": "arg1",
                "FUN_00003d64": "execute_function_00003d64"
            },
            "code": "int execute_function_00003d64(int function_ptr, int arg1) {\n  int result;\n  if (function_ptr == 0) {\n    result = -19;\n  }\n  else {\n    result = (***(int ***)(function_ptr + 12))(*(int *)(function_ptr + 4), arg1);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d64",
            "calling": [
                "FUN_00002ecc"
            ],
            "imported": true,
            "current_name": "execute_function_00003d64"
        },
        "FUN_00004e52": {
            "renaming": {
                "bVar1": "second_byte",
                "bVar3": "match",
                "param_1": "first_array",
                "param_2": "second_array",
                "uVar2": "index",
                "FUN_00004e52": "compare_bytes_00004e52"
            },
            "code": "int compare_bytes_00004e52(byte* first_array, byte* second_array)\n{\n  byte first_byte;\n  byte second_byte;\n  uint index = 0;\n  bool match = true;\n  do {\n    first_byte = *first_array;\n    second_byte = *second_array;\n    if (first_byte != 0 && first_byte != second_byte) {\n      match = false;\n    }\n    first_array++;\n    second_array++;\n    index++;\n  } while (match && first_byte != 0);\n  return first_byte - second_byte;\n}",
            "called": [
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e52",
            "calling": [
                "FUN_00002a18",
                "FUN_00002b10",
                "FUN_0000316c",
                "FUN_00004e52",
                "FUN_00002fe0",
                "FUN_00005100"
            ],
            "imported": true,
            "current_name": "compare_bytes_00004e52"
        },
        "FUN_000010d4": {
            "renaming": {
                "FUN_000010d4": "allocate_memory_000010d4",
                "PTR_DAT_0000126c": "block_list_start",
                "local_c": "block_id",
                "iVar3": "result",
                "uVar1": "temp_1",
                "local_a": "free_block_id",
                "param_1": "start_address",
                "puVar5": "memory_block_end",
                "local_2c": "aligned_start_address",
                "param_6": "arg2",
                "param_7": "arg3",
                "param_2": "size",
                "param_3": "flags",
                "param_4": "alignment",
                "PTR_DAT_00001270": "block_count_ptr",
                "param_5": "arg1",
                "local_10": "i",
                "uVar2": "temp_2",
                "local_30": "size_mod_4"
            },
            "code": "int allocate_memory_000010d4(uint start_address, int size, byte flags, uint alignment, undefined4 arg1, undefined4 arg2, undefined4 arg3)\n{\n  undefined4 temp_1;\n  undefined4 temp_2;\n  int result;\n  uint aligned_start_address;\n  int size_mod_4;\n  undefined4 *memory_block_end;\n  int free_block_index;\n  uint i;\n  short free_block_id;\n  short block_id;\n  if (flags < 16) {\n    aligned_start_address = start_address;\n    size_mod_4 = size;\n    if ((start_address & 3) != 0) {\n      size_mod_4 = 4 - (start_address & 3);\n      aligned_start_address = size_mod_4 + start_address;\n      size_mod_4 = size - size_mod_4;\n    }\n    size_mod_4 = size_mod_4 - 48 & 0xfffffffc;\n    memory_block_end = (undefined4 *)(size_mod_4 + aligned_start_address);\n    if ((flags & 8) == 0) {\n      *(uint *)aligned_start_address = aligned_start_address;\n    }\n    else {\n      for (i = aligned_start_address; i < size_mod_4 + aligned_start_address; i = i + 4) {\n        *(uint *)i = i;\n      }\n    }\n    temp_1 = is_interrupts_enabled_in_privileged_mode_00000cd0();\n    free_block_id = 0;\n    for (block_id = 1; block_id < 33; block_id = block_id + 1) {\n      if (*(int *)(PTR_DAT_0000126c + block_id * 4) == 0) {\n        free_block_id = block_id;\n        break;\n      }\n    }\n    if (free_block_id == 0) {\n      enable_interrupts_if_privileged_00000d0c(temp_1);\n      result = -139;\n    }\n    else {\n      *(undefined4 **)(PTR_DAT_0000126c + free_block_id * 4) = memory_block_end;\n      *(short *)((int)memory_block_end + 6) = free_block_id;\n      temp_2 = allocate_memory_000010d4_000007dc(arg1, arg2, aligned_start_address, size_mod_4);\n      *memory_block_end = temp_2;\n      memory_block_end[9] = aligned_start_address;\n      memory_block_end[0xb] = size;\n      memory_block_end[10] = arg3;\n      *(byte *)((int)memory_block_end + 5) = flags;\n      *(undefined *)(memory_block_end + 1) = 0;\n      memory_block_end[2] = 0;\n      memory_block_end[3] = 0;\n      memory_block_end[4] = 0;\n      validate_power_of_two_00000fec(memory_block_end + 5,0);\n      memory_block_end[8] = 0;\n      *(int *)PTR_DAT_00001270 = *(int *)PTR_DAT_00001270 + 1;\n      if ((flags & 1) == 0) {\n        update_linked_list_00000698(memory_block_end,10);\n        if ((flags & 4) == 0) {\n          enable_interrupts_if_privileged_00000d0c(temp_1);\n          check_exception_threshold_00000738(flags);\n          return (int)free_block_id;\n        }\n      }\n      else {\n        update_linked_list_00000698(memory_block_end,1);\n      }\n      enable_interrupts_if_privileged_00000d0c(temp_1);\n      result = (int)free_block_id;\n    }\n  }\n  else {\n    result = -22;\n  }\n  return result;\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000fec",
                "FUN_00000738",
                "FUN_00000cd0",
                "FUN_00000d0c",
                "FUN_000007dc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010d4",
            "calling": [
                "FUN_00000f8c"
            ],
            "imported": true,
            "current_name": "allocate_memory_000010d4"
        },
        "FUN_000045e4": {
            "renaming": {
                "FUN_000045e4": "do_nothing_000045e4"
            },
            "code": "\nvoid do_nothing_000045e4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e4",
            "calling": [
                "FUN_00004314"
            ],
            "imported": true,
            "current_name": "do_nothing_000045e4"
        },
        "FUN_00000738": {
            "renaming": {
                "set_flag_bit_0000093c": "set_flag_bit",
                "FUN_00000738": "check_exception_threshold_00000738",
                "iVar1": "current_exception_number",
                "*(undefined4 *)PTR_DAT_00000790": "exception_flag",
                "param_1": "exception_count",
                "PTR_DAT_0000078c": "ptr_dat_78c",
                "get_current_exception_number_if_privileged_mode_00000d2a": "get_current_exception_number",
                "*(byte *)(*(int *)PTR_DAT_0000078c + 5)": "count",
                "*(byte *)(*(int *)PTR_DAT_0000078c + 4)": "threshold"
            },
            "code": "void check_exception_threshold_00000738(byte *)(*(int *)PTR_DAT_0000078c + 4)(ushort exception_*(byte *)(*(int *)PTR_DAT_0000078c + 5)) {\n  int current_exception_number;\n  int* PTR_DAT_0000078c = (int*) PTR_DAT_0000078c;\n  byte *(byte *)(*(int *)PTR_DAT_0000078c + 4) = *(byte*)(PTR_DAT_0000078c + 4);\n  byte *(byte *)(*(int *)PTR_DAT_0000078c + 5) = *(byte*)(PTR_DAT_0000078c + 5);\n  if (*(byte *)(*(int *)PTR_DAT_0000078c + 4) < 9 || exception_*(byte *)(*(int *)PTR_DAT_0000078c + 5) < *(byte *)(*(int *)PTR_DAT_0000078c + 5)) {\n    current_exception_number = get_current_exception_number_if_privileged_mode_00000d2a();\n    if (current_exception_number == 0) {\n      set_flag_bit_0000093c();\n    }\n    else {\n      *(undefined4*) PTR_DAT_00000790 = 1;\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c",
                "FUN_00000d2a"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000738",
            "calling": [
                "FUN_000010d4",
                "FUN_000024bc"
            ],
            "imported": true,
            "current_name": "check_exception_threshold_00000738"
        },
        "FUN_00003e58": {
            "renaming": {
                "iVar1": "num_digits",
                "FUN_00003e58": "convert_integer_to_string_and_count_digits_00003e58",
                "param_1": "string",
                "local_18": "digit_count",
                "param_2": "number",
                "calculate_digits_00003dc4": "count_digits",
                "local_14": "current_char"
            },
            "code": "int convert_integer_to_string_and_count_digits_00003e58(unsigned char *string, int number)\n{\n  int digit_count;\n  int is_negative;\n  unsigned char *current_char;\n  \n  digit_count = number;\n  current_char = string;\n  \n  is_negative = -(number >> 0x1f);\n  if (is_negative != 0) {\n    if (string != (unsigned char *)0x0) {\n      current_char = string + 1;\n      *string = '-';\n    }\n    digit_count = -number;\n  }\n  \n  int num_digits = count_digits(digit_count);\n  return is_negative + num_digits;\n}",
            "called": [
                "FUN_00003dc4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e58",
            "calling": [
                "FUN_00003ec4"
            ],
            "imported": true,
            "current_name": "convert_integer_to_string_and_count_digits_00003e58"
        },
        "FUN_00004e26": {
            "renaming": {
                "iVar1": "set_param_result",
                "bVar3": "set_param_failed",
                "FUN_00004e26": "set_param_to_19_00004e26",
                "param_1": "param_value",
                "param_2": "param_address",
                "uVar2": "modified_param"
            },
            "code": "void set_param_to_19_00004e26(int param_value, int param_address)\n{\n  int set_param_result = set_param_to_19_00004e26_000004f2(param_value, (int)*(short *)(param_address + 0xe));\n  bool set_param_failed = set_param_result == -1;\n  ushort modified_param = *(ushort *)(param_address + 0xc);\n  if (set_param_failed) {\n    modified_param &= 0xefff;\n  }\n  else {\n    *(int *)(param_address + 0x54) = set_param_result;\n    modified_param |= 0x1000;\n  }\n  *(ushort *)(param_address + 0xc) = modified_param;\n}\n",
            "called": [
                "FUN_000004f2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e26",
            "calling": [],
            "imported": true,
            "current_name": "set_param_to_19_00004e26"
        },
        "FUN_000045e8": {
            "renaming": {
                "FUN_000045e8": "do_nothing_000045e8"
            },
            "code": "\nvoid do_nothing_000045e8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e8",
            "calling": [
                "FUN_0000428c",
                "FUN_00004db8",
                "FUN_000057f8",
                "FUN_00005790",
                "FUN_00005fec",
                "FUN_00004274",
                "FUN_00004cb4",
                "FUN_00004418",
                "FUN_00004158"
            ],
            "imported": true,
            "current_name": "do_nothing_000045e8"
        },
        "FUN_000057f8": {
            "renaming": {
                "FUN_000057f8": "FUNC_000057f8"
            },
            "code": "\nint FUNC_000057f8(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  int iVar4;\n  int *piVar5;\n  bool bVar6;\n  byte *pbVar7;\n  int unaff_r7;\n  byte *pbVar8;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 uStack_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    initialize_struct_array_000042a4();\n  }\n  if (param_2 == PTR_DAT_00005a38) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR_DAT_00005a3c) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR_DAT_00005a40) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n     (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n    do_nothing_000045e8(*(undefined4 *)(param_2 + 0x58));\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar3 = process_data_000054a8(param_1,param_2), iVar3 != 0)) {\n    if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n       (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n      do_nothing_000045ec(*(undefined4 *)(param_2 + 0x58));\n    }\n    return -1;\n  }\n  puVar1 = PTR_s___0__00005a44;\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar8 = param_3;\n  local_8c = param_4;\nLAB_0000588e:\n  pbVar7 = pbVar8;\n  if (*pbVar7 != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  pbVar8 = pbVar7 + 1;\n  if (*pbVar7 != 0x25) goto LAB_0000588e;\nLAB_0000589a:\n  iVar3 = (int)pbVar7 - (int)param_3;\n  if (iVar3 != 0) {\n    iVar4 = process_input_000057d2(param_1,param_2,param_3,iVar3);\n    if (iVar4 == -1) {\nLAB_00005a06:\n      if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n         (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n        do_nothing_000045ec(*(undefined4 *)(param_2 + 0x58));\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar3;\n  }\n  if (*pbVar7 == 0) goto LAB_00005a06;\n  local_84 = -1;\n  uStack_80 = 0;\n  local_88 = 0;\n  local_7c = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar8 = pbVar7 + 1;\n  while( true ) {\n    pbVar7 = pbVar8 + 1;\n    iVar3 = find_byte_sequence_00006010(PTR_s___0__00005a44,*pbVar8,5);\n    puVar2 = PTR_DAT_00005a54;\n    if (iVar3 == 0) break;\n    local_88 = 1 << (iVar3 - (int)puVar1 & 0xffU) | local_88;\n    pbVar8 = pbVar7;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar8 == 0x2a) {\n    piVar5 = local_8c + 1;\n    local_7c = *local_8c;\n    local_8c = piVar5;\n    if (local_7c < 0) {\n      local_7c = -local_7c;\n      local_88 = local_88 | 2;\n    }\n  }\n  else {\n    bVar6 = false;\n    iVar3 = local_7c;\n    pbVar7 = pbVar8;\n    while( true ) {\n      if (9 < *pbVar7 - 0x30) break;\n      iVar3 = iVar3 * 10 + (*pbVar7 - 0x30);\n      bVar6 = true;\n      pbVar7 = pbVar7 + 1;\n    }\n    if (bVar6) {\n      local_7c = iVar3;\n    }\n  }\n  if (*pbVar7 == 0x2e) {\n    if (pbVar7[1] == 0x2a) {\n      local_84 = *local_8c;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n      pbVar7 = pbVar7 + 2;\n      local_8c = local_8c + 1;\n    }\n    else {\n      bVar6 = false;\n      local_84 = 0;\n      iVar3 = 0;\n      while( true ) {\n        pbVar7 = pbVar7 + 1;\n        if (9 < *pbVar7 - 0x30) break;\n        iVar3 = iVar3 * 10 + (*pbVar7 - 0x30);\n        bVar6 = true;\n      }\n      if (bVar6) {\n        local_84 = iVar3;\n      }\n    }\n  }\n  iVar3 = find_byte_sequence_00006010(PTR_DAT_00005a54,*pbVar7,3);\n  if (iVar3 != 0) {\n    local_88 = local_88 | 0x40 << (iVar3 - (int)puVar2 & 0xffU);\n    pbVar7 = pbVar7 + 1;\n  }\n  param_3 = pbVar7 + 1;\n  local_70 = *pbVar7;\n  iVar3 = find_byte_sequence_00006010(PTR_s_efgEFG_00005a48,local_70,6);\n  if (iVar3 == 0) {\n    iVar3 = FUNC_00005b34(param_1,&local_88,param_2,DAT_00005a50,&local_8c);\n  }\n  else {\n    iVar3 = param_1;\n    if (DAT_00005a4c == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar3 = unaff_r7;\n      goto LAB_000059b4;\n    }\n  }\n  if (iVar3 == -1) goto LAB_00005a06;\nLAB_000059b4:\n  local_74 = local_74 + iVar3;\n  pbVar8 = param_3;\n  unaff_r7 = iVar3;\n  goto LAB_0000588e;\n}\n\n",
            "called": [
                "FUN_000045ec",
                "FUN_000054a8",
                "FUN_00005b34",
                "FUN_000045e8",
                "FUN_00006010",
                "FUN_000057d2",
                "FUN_000042a4"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000057f8",
            "calling": [
                "FUN_00004c84"
            ],
            "imported": false,
            "current_name": "FUNC_000057f8"
        },
        "FUN_000018bc": {
            "renaming": {
                "FUN_000018bc": "initialize_device_000018bc",
                "DAT_00001910": "status_register",
                "set_param_00001748": "set_device_param",
                "PTR_DAT_00001918": "result_pointer",
                "set_offset_to_zero_00001710": "set_offset_to_zero",
                "DAT_00001914": "data_register"
            },
            "code": "void initialize_device_000018bc(void)\n{\n  set_device_param(160);\n  *DAT_00001910 = (*DAT_00001910 & 59) | 4;\n  set_offset_to_zero(DAT_00001914, 1);\n  do {\n  } while ((DAT_00001914[6] & 16) == 0);\n  do {\n  } while ((DAT_00001914[6] & 12) != 0);\n  *PTR_DAT_00001918 = 0;\n  return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000018bc",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": true,
            "current_name": "initialize_device_000018bc"
        },
        "FUN_00000f04": {
            "renaming": {
                "is_interrupts_enabled_in_privileged_mode_00000cd0": "is_interrupt_enabled_in_privileged_mode",
                "piRam00000f4c": "interrupt_flag",
                "FUN_00000f04": "process_input_00000f04",
                "uRam00000f50": "input_buffer_1",
                "param_1": "input",
                "call_function_with_pointer_and_link_register_00000ed8": "call_interrupt_handler",
                "local_9": "local_input",
                "uRam00000f54": "input_buffer_2",
                "UNRECOVERED_JUMPTABLE": "jump_table",
                "uRam00000f58": "input_buffer_3",
                "do_nothing_00000ef8": "do_nothing",
                "param_2": "param2",
                "uStack_18": "stack_pointer",
                "process_input_and_call_function_00004c84": "process_input_and_call_function",
                "local_10": "local_param2",
                "PTR_s_main____This_is_RIOT___Version__2_00000f7c": "PTR_s_main____This_is_RIOT___Version__2",
                "waitForInterrupts_00000e58": "wait_for_interrupt",
                "processAndExecuteCommands_000023a4": "process_and_execute_commands"
            },
            "code": "void process_input_00000f04(char input, unsigned int param2)\n{\n  unsigned int interrupt_enabled;\n  code *jump_table;\n  unsigned int local_param2;\n  char local_input;\n  \n  local_param2 = param2;\n  local_input = input;\n  if (*interrupt_flag == 0) {\n    *interrupt_flag = 1;\n    if (input == INTERRUPT_SIGNAL) {\n      call_interrupt_handler();\n    }\n    process_input_00000f04_and_call_function_00004c84(input_buffer_1, local_param2);\n    process_data();\n    process_input_00000f04_and_call_function_00004c84(input_buffer_2);\n    process_input_00000f04_and_call_function_00004c84(input_buffer_3);\n  }\n  interrupt_enabled = is_interrupt_enabled_in_privileged_mode();\n  do_nothing();\n  jump_table = (code *)0xf4d;\n  wait_for_interrupt();\n  uStack_18 = (int)&uStack_18 + 1;\n  do_nothing();\n  process_input_00000f04_and_call_function_00004c84(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n  process_and_execute_commands();\n  (*jump_table)(0);\n  return;\n}",
            "called": [
                "FUN_00000ed8",
                "FUN_00002400",
                "FUN_000023a4",
                "FUN_00000cd0",
                "FUN_0000211c",
                "FUN_00000e58",
                "FUN_00000ef8",
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f04",
            "calling": [
                "FUN_00000fec",
                "FUN_00001034",
                "FUN_000013b8",
                "FUN_00000cc0",
                "FUN_00003ec4",
                "FUN_00000a30"
            ],
            "imported": true,
            "current_name": "process_input_00000f04"
        },
        "FUN_00000610": {
            "renaming": {
                "iVar1": "leading_zero_count",
                "iVar2": "current_value",
                "FUN_00000610": "check_if_value_is_not_equal_to_current_value_00000610",
                "PTR_DAT_0000068c": "pointer_to_input_value",
                "PTR_DAT_00000690": "pointer_to_table",
                "uVar3": "result",
                "PTR_DAT_00000688": "pointer_to_current_value",
                "PTR_DAT_00000684": "pointer_to_result"
            },
            "code": "undefined4 check_if_value_is_not_equal_to_current_value_00000610(void)\n{\n  int current_value = *(int *)PTR_DAT_00000688;\n  int leading_zero_count = count_leading_zeroes_of_int_00000566(*(undefined4 *)PTR_DAT_0000068c);\n  int new_value = **(int **)(PTR_DAT_00000690 + leading_zero_count * 4);\n  if (current_value == new_value + -8) {\n    return 0;\n  }\n  else {\n    if ((current_value != 0) && (*(char *)(current_value + 4) == '\t')) {\n      *(undefined *)(current_value + 4) = 10;\n    }\n    *(undefined *)(new_value + -4) = 9;\n    *(undefined2 *)PTR_DAT_00000694 = *(undefined2 *)(new_value + -2);\n    *(int *)PTR_DAT_00000688 = new_value + -8;\n    return 1;\n  }\n}",
            "called": [
                "FUN_00000566"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000610",
            "calling": [],
            "imported": true,
            "current_name": "check_if_value_is_not_equal_to_current_value_00000610"
        },
        "FUN_00003694": {
            "renaming": {
                "bVar4": "bit_set",
                "uVar1": "label",
                "local_a": "ascii_code",
                "auStack_18": "stack_buffer",
                "param_1": "data_object_address",
                "FUN_00003694": "display_data_object_00003694",
                "local_9": "data_object_index",
                "param_2": "data_object_size",
                "cVar2": "bit_value",
                "uVar3": "bit_mask",
                "local_10": "digit_count"
            },
            "code": "void display_data_object_00003694(int data_object_address, byte data_object_size) {\n  undefined4 uVar1;\n  char bit_value;\n  uint bit_mask;\n  bool bit_set;\n  undefined stack_buffer [8];\n  int digit_count;\n  char ascii_code;\n  byte data_object_index;\n  if ((data_object_address == 0) || (data_object_size > 3)) {\n    display_error_message(\"Unable to display data object.\");\n  }\n  else {\n    process_input_and_call_function(\"Data:\");\n    for (data_object_index = 0; data_object_index < data_object_size; data_object_index++) {\n      if (*(byte *)(data_object_address + 6) < 0x14) {\n        bit_mask = DAT_000037ec & 1 << (uint)*(byte *)(data_object_address + 6);\n        bit_set = bit_mask != 0;\n        if (bit_set) {\n          bit_mask = 1;\n        }\n        bit_value = (char)bit_mask;\n        if (!bit_set) {\n          bit_value = '\\0';\n        }\n        if (bit_value == '\\0') goto LAB_000036ee;\n        ascii_code = '\\0';\n      }\n      else {\nLAB_000036ee:\n        ascii_code = get_ascii_code((int)*(char *)(data_object_address + 7));\n      }\n      process_input_and_call_function(\" \");\n      if (data_object_size < 2) {\n        process_input_and_call_function(\"--\");\n      }\n      else {\n        process_input_and_call_function(\"[%u]\", data_object_index);\n      }\n      if (ascii_code == '\\0') {\n        if (*(char *)(data_object_address + 7) == '\\0') {\n          process_input_and_call_function(\" %d\", (int)*(short *)(data_object_address + (uint)data_object_index * 2));\n        }\n        else if ((*(char *)(data_object_address + 7) + 4 < 0 == SCARRY4((int)*(char *)(data_object_address + 7),4)) &&\n                (*(char *)(data_object_address + 7) < '\\0')) {\n          digit_count = count_digits_and_convert_to_string(stack_buffer, (int)*(short *)(data_object_address + (uint)data_object_index * 2),\n                                  (int)*(char *)(data_object_address + 7));\n          stack_buffer[digit_count] = 0;\n          process_input_and_call_function(\" %s\", stack_buffer);\n        }\n        else {\n          process_input_and_call_function(\" (%d,%d)\", (int)*(short *)(data_object_address + (uint)data_object_index * 2),\n                       (int)*(char *)(data_object_address + 7));\n        }\n      }\n      else {\n        process_input_and_call_function(\" %d '%c'\", (int)*(short *)(data_object_address + (uint)data_object_index * 2), ascii_code);\n      }\n      uVar1 = get_label(*(undefined *)(data_object_address + 6));\n      process_input_and_call_function(\" [%s]\", uVar1);\n    }\n  }\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00003810",
                "FUN_00003918",
                "FUN_00003e9e",
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003694",
            "calling": [
                "FUN_00002ecc",
                "FUN_0000305c"
            ],
            "imported": true,
            "current_name": "display_data_object_00003694"
        },
        "FUN_00002364": {
            "renaming": {
                "iVar1": "is_equal",
                "param_1": "array_ptr",
                "FUN_00002364": "check_difference_and_increment_00002364",
                "param_2": "value",
                "uVar2": "return_val"
            },
            "code": "int check_difference_and_increment_00002364(int* array_ptr, int value){\n    int is_equal = is_difference_equal_to_third_param_00002294(array_ptr);\n    if (is_equal == 0) {\n        increment_and_store_value_at_address_000022be(array_ptr, value);\n        return 0;\n    }\n    else {\n        return -1;\n    }\n}",
            "called": [
                "FUN_000022be",
                "FUN_00002294"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002364",
            "calling": [
                "FUN_000012b4"
            ],
            "imported": true,
            "current_name": "check_difference_and_increment_00002364"
        },
        "FUN_00001ad4": {
            "renaming": {
                "DAT_00001b08": "data_ptr",
                "FUN_00001ad4": "reset_data_00001ad4",
                "PTR_DAT_00001b0c": "ptr_data_ptr"
            },
            "code": "void reset_data_00001ad4(void)\n{\n  int* DAT_00001b08 = DAT_00001b08;\n  *DAT_00001b08 = *DAT_00001b08 & 0x3f;\n  while ((DAT_00001b08[6] & 0xc) != 0xc);\n  int* PTR_DAT_00001b0c = PTR_DAT_00001b0c;\n  *PTR_DAT_00001b0c = 7;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ad4",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": true,
            "current_name": "reset_data_00001ad4"
        },
        "FUN_00001274": {
            "renaming": {
                "initialize_data_access_flags_00002396": "initialize_data_access_flags",
                "save_game_data_0000258c": "save_game_data",
                "DAT_00001298": "game_flags",
                "FUN_00001274": "initialize_game_00001274",
                "initialize_device_00001c84": "initialize_device"
            },
            "code": "void initialize_game_00001274() {\n  save_game_data();\n  *DAT_00001298 |= 0x28;\n  initialize_device();\n  initialize_data_access_flags();\n  return;\n}",
            "called": [
                "FUN_00001c84",
                "FUN_0000258c",
                "FUN_00002396"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001274",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": true,
            "current_name": "initialize_game_00001274"
        },
        "FUN_00002e6c": {
            "renaming": {
                "iVar1": "input_status",
                "process_input_00002d94": "process_input",
                "param_1": "input_ptr",
                "FUN_00002e6c": "process_input_and_execute_commands_00002e6c",
                "process_input_and_data_00002e48": "process_input_and_data",
                "parse_and_execute_command_00002b10": "execute_command",
                "param_2": "data_ptr",
                "param_3": "command_ptr"
            },
            "code": "void process_input_and_execute_commands_00002e6c(void *input_ptr, void *data_ptr, void *command_ptr)\n{\n  int input_status;\n  \n  process_input_and_data(input_ptr, data_ptr);\n  do {\n    input_status = process_input(input_ptr, data_ptr);\n    if (input_status == 0) {\n      execute_command(command_ptr, input_ptr);\n    }\n    process_input_and_data(input_ptr, data_ptr);\n  } while( true );\n}",
            "called": [
                "FUN_00002b10",
                "FUN_00002e48",
                "FUN_00002d94"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e6c",
            "calling": [
                "FUN_000023a4"
            ],
            "imported": true,
            "current_name": "process_input_and_execute_commands_00002e6c"
        },
        "FUN_00003444": {
            "renaming": {
                "iVar1": "conversion_status",
                "FUNC_00004db8": "log_error",
                "auStack_2c": "date_time_buffer",
                "perform_calculation_00003378": "perform_calculation",
                "FUN_00003444": "is_timestamp_to_date_conversion_successful_00003444",
                "process_timestamp_to_date_00002624": "convert_timestamp_to_date"
            },
            "code": "bool is_timestamp_to_date_conversion_successful_00003444(void)\n{\n  int conversion_status;\n  undefined date_time_buffer [36];\n  \n  conversion_status = convert_timestamp_to_date(date_time_buffer);\n  if (conversion_status != 0) {\n    log_error(PTR_s_rtc__error_getting_time_00003474);\n  }\n  else {\n    perform_calculation(date_time_buffer);\n  }\n  return conversion_status != 0;\n}",
            "called": [
                "FUN_00002624",
                "FUN_00004db8",
                "FUN_00003378"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003444",
            "calling": [
                "FUN_00003524"
            ],
            "imported": true,
            "current_name": "is_timestamp_to_date_conversion_successful_00003444",
            "code_backup": "\nbool FUN_00003444(void)\n\n{\n  int iVar1;\n  undefined auStack_2c [36];\n  \n  iVar1 = process_timestamp_to_date_00002624(auStack_2c);\n  if (iVar1 != 0) {\n    FUNC_00004db8(PTR_s_rtc__error_getting_time_00003474);\n  }\n  else {\n    perform_calculation_00003378(auStack_2c);\n  }\n  return iVar1 != 0;\n}\n\n"
        },
        "FUN_00003688": {
            "renaming": {
                "synchronizeData_00003658": "synchronize_data_helper",
                "FUN_00003688": "synchronize_data_00003688"
            },
            "code": "void synchronize_data_00003688(){\n  synchronize_data_00003688_helper();\n  return;\n}",
            "called": [
                "FUN_00003658"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003688",
            "calling": [
                "FUN_00002e9c"
            ],
            "imported": true,
            "current_name": "synchronize_data_00003688"
        },
        "FUN_00001392": {
            "renaming": {
                "*puVar1": "*result_pointer",
                "param_1": "input_value",
                "FUN_00001392": "set_result_to_one_and_return_00001392",
                "param_2": "unused_parameter",
                "puVar1": "result_pointer",
                "calculate_result_00001360": "calculate_result"
            },
            "code": "void set_result_to_one_and_return_00001392(void* result_address, int input_value) {\n    int* result_pointer = (int*)calculate_result(input_value);\n    *result_pointer = 1;\n    return;\n}",
            "called": [
                "FUN_00001360"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001392",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": true,
            "current_name": "set_result_to_one_and_return_00001392"
        },
        "FUN_00002910": {
            "renaming": {
                "*(undefined4 *)(iVar1 + 8)": "*(undefined4*)(dataAddress + 8)",
                "PTR_DAT_00002948": "pointerAddress",
                "iVar1": "dataAddress",
                "DAT_00002944": "dataAddress",
                "*(uint *)(DAT_00002944 + 0x1c)": "*flagAddress",
                "FUN_00002910": "clearFlagsAndValues_00002910"
            },
            "code": "void clearFlagsAndValues_00002910(void)\n{\n  int DAT_00002944 = DAT_00002944;\n  uint* flagAddress = (uint*)(DAT_00002944 + 0x1c);\n  *(uint *)(DAT_00002944 + 0x1c) &= 0xfffffffb;\n  *(undefined4*)(DAT_00002944 + 8) = 0;\n  *(undefined4*)PTR_DAT_00002948 = 0;\n  *(undefined4*)(PTR_DAT_00002948 + 4) = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002910",
            "calling": [
                "FUN_000026c0"
            ],
            "imported": true,
            "current_name": "clearFlagsAndValues_00002910"
        },
        "FUN_00004418": {
            "renaming": {
                "uVar1": "extracted_byte",
                "iVar4": "struct_array_pointer",
                "PTR_DAT_00005628": "data_array_pointer_address_3",
                "ppbVar2": "data_array_pointer",
                "*DAT_00004438": "struct_array_pointer_address",
                "pbVar3": "data_pointer",
                "FUN_00004418": "extract_byte_from_data_00004418",
                "PTR_DAT_00005624": "data_array_pointer_address_2",
                "PTR_DAT_00005620": "data_array_pointer_address_1"
            },
            "code": "uint extract_byte_from_data_00004418(void)\n{\n  uint extracted_byte;\n  byte **data_array_pointer;\n  byte *data_pointer;\n  int struct_array_pointer;\n  \n  struct_array_pointer = **DAT_00004438;\n  if ((struct_array_pointer != 0) && (*(int *)(struct_array_pointer + 0x18) == 0)) {\n    initialize_struct_array(struct_array_pointer);\n  }\n  data_array_pointer = *(byte ***)(struct_array_pointer + 4);\n  if ((struct_array_pointer != 0) && (*(int *)(struct_array_pointer + 0x18) == 0)) {\n    initialize_struct_array(struct_array_pointer);\n  }\n  if (data_array_pointer == (byte **)PTR_DAT_00005620) {\n    data_array_pointer = *(byte ***)(struct_array_pointer + 4);\n  }\n  else if (data_array_pointer == (byte **)PTR_DAT_00005624) {\n    data_array_pointer = *(byte ***)(struct_array_pointer + 8);\n  }\n  else if (data_array_pointer == (byte **)PTR_DAT_00005628) {\n    data_array_pointer = *(byte ***)(struct_array_pointer + 0xc);\n  }\n  if ((-1 < (int)data_array_pointer[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(data_array_pointer + 3) << 0x16))) {\n    do_nothing(data_array_pointer[0x16]);\n  }\n  data_pointer = data_array_pointer[1];\n  data_array_pointer[1] = data_pointer + -1;\n  if ((int)(data_pointer + -1) < 0) {\n    extracted_byte = extract_byte_from_data_00004418(struct_array_pointer, data_array_pointer);\n  }\n  else {\n    data_pointer = *data_array_pointer;\n    *data_array_pointer = data_pointer + 1;\n    extracted_byte = (uint)*data_pointer;\n  }\n  if ((-1 < (int)data_array_pointer[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(data_array_pointer + 3) << 0x16))) {\n    do_nothing(data_array_pointer[0x16]);\n  }\n  return extracted_byte;\n}",
            "called": [
                "FUN_000045ec",
                "FUN_00005e10",
                "FUN_000045e8",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004418",
            "calling": [
                "FUN_00002d94"
            ],
            "imported": true,
            "current_name": "extract_byte_from_data_00004418"
        },
        "FUN_0000258c": {
            "renaming": {
                "local_c": "index",
                "DAT_000025ec": "PTR_game_data",
                "DAT_000025f0": "PTR_game_data_2",
                "save_data_00002538": "save_data",
                "FUN_0000258c": "save_game_data_0000258c"
            },
            "code": "void save_game_data_0000258c(void)\n{\n  uint32_t index;\n  *(uint32_t *)(DAT_000025ec + 8) = DAT_000025f0;\n  save_data_00002538(0xfffffffe, 1);\n  save_data_00002538(0xfffffffb, 1);\n  for (index = 0; index < 0x66; index++) {\n    save_data_00002538((int32_t)(char)index, 1);\n  }\n  *(uint32_t *)(DAT_000025ec + 0x10) |= 0x10;\n  *(uint32_t *)(DAT_000025ec + 0x14) |= 0x200;\n  return;\n}",
            "called": [
                "FUN_00002538"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000258c",
            "calling": [
                "FUN_00001274"
            ],
            "imported": true,
            "current_name": "save_game_data_0000258c"
        },
        "FUN_00002a00": {
            "renaming": {
                "param_1": "input",
                "process_input_00004cb4": "process_input",
                "FUN_00002a00": "process_input_wrapper_00002a00"
            },
            "code": "void process_input_wrapper_00002a00(undefined4 input)\n{\n  process_input(input);\n  return;\n}",
            "called": [
                "FUN_00004cb4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a00",
            "calling": [
                "FUN_00002e48",
                "FUN_00002d94"
            ],
            "imported": true,
            "current_name": "process_input_wrapper_00002a00"
        },
        "FUN_000043a0": {
            "renaming": {
                "iVar3": "inner_data_ptr",
                "uVar1": "processed_data_flag",
                "iVar5": "inner_data_size",
                "piVar2": "data_ptr",
                "param_1": "data_size",
                "param_2": "data_processor",
                "uVar4": "processed_data_flags",
                "FUN_000043a0": "process_data_000043a0"
            },
            "code": "uint process_data_000043a0(int data_size, code *data_processor)\n{\n  uint processed_data_flags = 0;\n  int *data_ptr = (int *)(data_size + 0x48);\n  do {\n    int inner_data_size = data_ptr[1];\n    int inner_data_ptr = data_ptr[2];\n    while (inner_data_size-- > 0) {\n      if ((1 < *(ushort *)(inner_data_ptr + 0xc)) && (*(short *)(inner_data_ptr + 0xe) != -1)) {\n        uint processed_data_flag = (*data_processor)(inner_data_ptr);\n        processed_data_flags = processed_data_flags | processed_data_flag;\n      }\n      inner_data_ptr += 0x68;\n    }\n    data_ptr = (int *)*data_ptr;\n  } while (data_ptr != (int *)0x0);\n  return processed_data_flags;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043a0",
            "calling": [
                "FUN_00006768"
            ],
            "imported": true,
            "current_name": "process_data_000043a0"
        },
        "FUN_0000211c": {
            "renaming": {
                "FUN_0000211c": "process_data_0000211c",
                "local_2c": "relocation_data",
                "local_3c": "relocation_data_size",
                "local_1a": "i",
                "local_18": "total_data_size",
                "local_28": "main_stack_pointer",
                "local_38": "relocation_offset",
                "local_20": "relocation_count",
                "local_30": "relocation_index",
                "local_40": "relocation_offset",
                "local_14": "isr_stack_offset",
                "local_24": "data_pointer",
                "local_34": "relocation_type"
            },
            "code": "void process_data_0000211c(void)\n{\n  int relocation_count = 0;\n  int total_relocation_offset = 0;\n  int total_data_size = 0;\n  uint8_t relocation_index = 0;\n  uint32_t *relocation_data = NULL;\n  uint32_t *data_pointer = NULL;\n  uint32_t *main_stack_pointer = NULL;\n  uint32_t isr_stack_size = 0x200;\n  uint32_t isr_stack_offset = 0;\n  uint32_t relocation_offset = 0;\n  uint32_t relocation_type = 0;\n  uint32_t relocation_address = 0;\n  uint32_t relocation_value = 0;\n  uint32_t relocation_data_size = 0;\n  uint32_t relocation_data_offset = 0;\n  uint32_t relocation_symbol_index = 0;\n  uint32_t relocation_symbol_address = 0;\n  uint32_t relocation_symbol_size = 0;\n  uint32_t relocation_symbol_name_offset = 0;\n  uint32_t relocation_symbol_name = 0;\n  uint32_t relocation_symbol_value = 0;\n  int i = 0;\n\n  relocation_count = count_elf32_relocations_000008b8();\n  data_pointer = get_data_pointer_0000091c();\n  main_stack_pointer = get_main_stack_pointer_00000900();\n\n  process_input_and_call_function_00004c84(PTR_s__pid_____21s____9sQ___pri___stac_00002250,PTR_DAT_0000224c,PTR_s_state_00002248);\n\n  process_input_and_call_function_00004c84(PTR_s______isr_stack______________6i___00002254,isr_stack_size,relocation_count,data_pointer,main_stack_pointer);\n\n  isr_stack_offset += isr_stack_size;\n\n  if (relocation_count > 0) {\n    total_relocation_offset += relocation_count;\n  }\n\n  for (i = 1; i < 0x21; i++) {\n    relocation_data = *(uint32_t **)(PTR_DAT_00002258 + i * 4);\n    if (relocation_data != NULL) {\n      relocation_index = *(uint8_t *)(relocation_data + 1);\n      relocation_type = *(uint32_t *)(DAT_0000225c + relocation_index * 4);\n      relocation_offset = (uint32_t)&isr_stack_size + (uint32_t)(8 < relocation_index);\n      relocation_data_size = relocation_data[0xb];\n      isr_stack_offset += relocation_data_size;\n      relocation_value = calculate_offset_000010a0(relocation_data[9]);\n      relocation_data_offset = relocation_data_size - relocation_value;\n      total_data_size += relocation_data_offset;\n      process_input_and_call_function_00004c84(PTR_s___3hi_____20s_____8s___1s____3i___00002260,(int)*(short *)((int)relocation_data + 6),relocation_data[10],relocation_type,relocation_offset,*(uint8_t *)((int)relocation_data + 5),relocation_data[0xb],relocation_data_offset,relocation_data[9],*relocation_data);\n    }\n  }\n\n  process_input_and_call_function_00004c84(PTR_s___5s___21s__13s_6s__6i___5i__0000226c,PTR_DAT_00002264,PTR_DAT_00002268,PTR_DAT_00002264,PTR_DAT_00002264,isr_stack_offset,total_data_size);\n  return;\n}",
            "called": [
                "FUN_000010a0",
                "FUN_0000091c",
                "FUN_00000900",
                "FUN_00004c84",
                "FUN_000008b8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000211c",
            "calling": [
                "FUN_00002eb4",
                "FUN_00000f04"
            ],
            "imported": true,
            "current_name": "process_data_0000211c",
            "code_backup": "\nvoid FUN_0000211c(void)\n\n{\n  int iVar1;\n  undefined2 local_40;\n  int local_3c;\n  int local_38;\n  undefined4 local_34;\n  uint local_30;\n  undefined4 *local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  int local_20;\n  short local_1a;\n  int local_18;\n  int local_14;\n  \n  local_40 = 0x515f;\n  local_14 = 0;\n  local_18 = 0;\n  FUNC_00004c84(PTR_s__pid_____21s____9sQ___pri___stac_00002250,PTR_DAT_0000224c,PTR_s_state_00002248\n              );\n  local_20 = count_elf32_relocations_000008b8();\n  local_24 = get_data_pointer_0000091c();\n  local_28 = get_main_stack_pointer_00000900();\n  FUNC_00004c84(PTR_s______isr_stack______________6i___00002254,0x200,local_20,local_24,local_28);\n  local_14 = local_14 + 0x200;\n  if (0 < local_20) {\n    local_18 = local_20 + local_18;\n  }\n  for (local_1a = 1; local_1a < 0x21; local_1a = local_1a + 1) {\n    local_2c = *(undefined4 **)(PTR_DAT_00002258 + local_1a * 4);\n    if (local_2c != (undefined4 *)0x0) {\n      local_30 = (uint)*(byte *)(local_2c + 1);\n      local_34 = *(undefined4 *)(DAT_0000225c + local_30 * 4);\n      local_38 = (int)&local_40 + (uint)(8 < local_30);\n      local_3c = local_2c[0xb];\n      local_14 = local_3c + local_14;\n      iVar1 = calculate_offset_000010a0(local_2c[9]);\n      local_3c = local_3c - iVar1;\n      local_18 = local_3c + local_18;\n      FUNC_00004c84(PTR_s___3hi_____20s_____8s___1s____3i___00002260,\n                   (int)*(short *)((int)local_2c + 6),local_2c[10],local_34,local_38,\n                   *(undefined *)((int)local_2c + 5),local_2c[0xb],local_3c,local_2c[9],*local_2c);\n    }\n  }\n  FUNC_00004c84(PTR_s___5s___21s__13s_6s__6i___5i__0000226c,PTR_DAT_00002264,PTR_DAT_00002268,\n               PTR_DAT_00002264,PTR_DAT_00002264,local_14,local_18);\n  return;\n}\n\n"
        },
        "FUN_0000562c": {
            "renaming": {
                "FUN_0000562c": "find_matching_string_0000562c",
                "iVar4": "comparison_result",
                "piVar6": "current_substring",
                "iVar7": "string_index",
                "param_1": "param",
                "piVar3": "current_string",
                "param_2": "search_string",
                "param_3": "result_index",
                "cVar1": "current_char",
                "pcVar5": "string_to_compare",
                "ppiVar2": "string_array"
            },
            "code": "int find_matching_string_0000562c(int param, char *search_string, int *result_index)\n{\n  char current_char;\n  int **string_array;\n  int *current_string;\n  int string_index;\n  char *string_to_compare;\n  int *current_substring;\n  int comparison_result;\n  int array_index;\n  \n  do_nothing_with_data();\n  string_array = DAT_0000569c;\n  string_to_compare = search_string;\n  if (*DAT_0000569c != (int *)0x0) {\n    do {\n      current_char = *string_to_compare;\n      if (current_char == '\\0') {\n        string_index = (int)string_to_compare - (int)search_string;\n        current_string = *DAT_0000569c;\n        while(true) {\n          current_substring = current_string;\n          if (*current_substring == 0) break;\n          comparison_result = compare_strings(*current_substring, search_string, string_index);\n          current_string = current_substring + 1;\n          if ((comparison_result == 0) && (comparison_result = *current_substring, *(char *)(comparison_result + string_index) == '=')) {\n            *result_index = (int)current_substring - (int)*string_array >> 2;\n            do_nothing_and_return(param);\n            return comparison_result + string_index + 1;\n          }\n        }\n        break;\n      }\n      string_to_compare = string_to_compare + 1;\n    } while (current_char != '=');\n  }\n  do_nothing_and_return(param);\n  return 0;\n}",
            "called": [
                "FUN_00005fec",
                "FUN_00005ff8",
                "FUN_00004e66"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000562c",
            "calling": [
                "FUN_000056a0"
            ],
            "imported": true,
            "current_name": "find_matching_string_0000562c"
        },
        "FUN_000020b8": {
            "renaming": {
                "FUN_000020b8": "process_flags_000020b8",
                "process_flags_00002028": "update_flags",
                "DAT_000020c8": "flags"
            },
            "code": "void process_flags_000020b8(void)\n{\n  int* DAT_000020c8_ptr = &DAT_000020c8;\n  int start_index = 0;\n  update_DAT_000020c8(DAT_000020c8_ptr, start_index);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020b8",
            "calling": [],
            "imported": true,
            "current_name": "process_flags_000020b8"
        },
        "FUN_00002a18": {
            "renaming": {
                "compare_bytes_00004e52": "compare_bytes",
                "local_c": "current_array_element",
                "FUN_00002a18": "find_matching_value_in_array_00002a18",
                "param_1": "array",
                "local_18": "array_and_constant_pointer",
                "param_2": "value_to_match",
                "local_10": "array_size",
                "PTR_PTR_s_reboot_00002a84": "PTR_PTR_s_reboot_00002a84"
            },
            "code": "int find_matching_value_in_array_00002a18(int *array, uint array_size, uint value_to_match) {\n  int compare_result;\n  int *current_array_element;\n  for (uint i = 0; i < array_size; i++) {\n    current_array_element = array[i];\n    if (current_array_element != NULL) {\n      for (; *current_array_element != 0; current_array_element += 3) {\n        compare_result = compare_bytes(*current_array_element, value_to_match);\n        if (compare_result == 0) {\n          return current_array_element[2];\n        }\n      }\n    }\n  }\n  return 0;\n}",
            "called": [
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a18",
            "calling": [
                "FUN_00002b10"
            ],
            "imported": true,
            "current_name": "find_matching_value_in_array_00002a18"
        },
        "FUN_000054a8": {
            "renaming": {
                "PTR_DAT_0000557c": "global_ptr2",
                "uVar1": "value1",
                "FUN_000054a8": "process_data_000054a8",
                "iVar5": "temp_var",
                "param_1": "result",
                "DAT_00005574": "global_var",
                "param_2": "data",
                "PTR_DAT_00005580": "global_ptr3",
                "uVar3": "temp_value1",
                "uVar2": "value2",
                "uVar4": "temp_value2",
                "PTR_DAT_00005578": "global_ptr1"
            },
            "code": "uint process_data_000054a8(uint *result, uint *data){\n  ushort value1;\n  ushort value2;\n  uint temp_value1;\n  uint temp_value2;\n  int temp_var;\n  \n  temp_var = *DAT_00005574;\n  if ((temp_var != 0) && (*(int *)(temp_var + 0x18) == 0)) {\n    clear_memory(temp_var);\n  }\n  if (data == (uint *)PTR_DAT_00005578) {\n    data = *(uint **)(temp_var + 4);\n  }\n  else if (data == (uint *)PTR_DAT_0000557c) {\n    data = *(uint **)(temp_var + 8);\n  }\n  else if (data == (uint *)PTR_DAT_00005580) {\n    data = *(uint **)(temp_var + 0xc);\n  }\n  temp_value1 = (uint)*(ushort *)(data + 3);\n  value1 = *(ushort *)(data + 3);\n  if (-1 < (int)(temp_value1 << 0x1c)) {\n    if (-1 < (int)(temp_value1 << 0x1b)) {\n      *result = 9;\n      goto LABEL_000054d8;\n    }\n    if ((uint)(temp_value1 << 0x1d) < 0) {\n      if ((uint *)data[0xd] != (uint *)0x0) {\n        if ((uint *)data[0xd] != data + 0x11) {\n          insert_element(result);\n        }\n        data[0xd] = 0;\n      }\n      *(ushort *)(data + 3) = *(ushort *)(data + 3) & 0xffdb;\n      data[1] = 0;\n      *data = data[4];\n    }\n    *(ushort *)(data + 3) = *(ushort *)(data + 3) | 8;\n  }\n  if ((data[4] == 0) && ((*(ushort *)(data + 3) & 0x280) != 0x200)) {\n    allocate_memory(result, data);\n  }\n  value2 = *(ushort *)(data + 3);\n  temp_value1 = (uint)value2;\n  value1 = *(ushort *)(data + 3);\n  temp_value2 = temp_value1 & 1;\n  if ((value2 & 1) == 0) {\n    if (-1 < (int)(temp_value1 << 0x1e)) {\n      temp_value2 = data[5];\n    }\n    data[2] = temp_value2;\n  }\n  else {\n    data[2] = 0;\n    data[6] = -data[5];\n  }\n  if (data[4] != 0) {\n    return 0;\n  }\n  if ((value2 & 0x80) == 0) {\n    return temp_value1 & 0x80;\n  }\nLABEL_000054d8:\n  *(ushort *)(data + 3) = value1 | 0x40;\n  return 0xffffffff;\n}",
            "called": [
                "FUN_00005700",
                "FUN_00004b34",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000054a8",
            "calling": [
                "FUN_00004db8",
                "FUN_000057f8",
                "FUN_00005404"
            ],
            "imported": true,
            "current_name": "process_data_000054a8",
            "code_backup": "\nuint FUN_000054a8(undefined4 *param_1,undefined4 *param_2)\n\n{\n  ushort uVar1;\n  ushort uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  \n  iVar5 = *DAT_00005574;\n  if ((iVar5 != 0) && (*(int *)(iVar5 + 0x18) == 0)) {\n    FUNC_000042a4(iVar5);\n  }\n  if (param_2 == (undefined4 *)PTR_DAT_00005578) {\n    param_2 = *(undefined4 **)(iVar5 + 4);\n  }\n  else if (param_2 == (undefined4 *)PTR_DAT_0000557c) {\n    param_2 = *(undefined4 **)(iVar5 + 8);\n  }\n  else if (param_2 == (undefined4 *)PTR_DAT_00005580) {\n    param_2 = *(undefined4 **)(iVar5 + 0xc);\n  }\n  uVar3 = (uint)*(ushort *)(param_2 + 3);\n  uVar2 = *(ushort *)(param_2 + 3);\n  if (-1 < (int)(uVar3 << 0x1c)) {\n    if (-1 < (int)(uVar3 << 0x1b)) {\n      *param_1 = 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(uVar3 << 0x1d) < 0) {\n      if ((undefined4 *)param_2[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)param_2[0xd] != param_2 + 0x11) {\n          insert_element_00004b34(param_1);\n        }\n        param_2[0xd] = 0;\n      }\n      *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xffdb;\n      param_2[1] = 0;\n      *param_2 = param_2[4];\n    }\n    *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 8;\n  }\n  if ((param_2[4] == 0) && ((*(ushort *)(param_2 + 3) & 0x280) != 0x200)) {\n    allocate_memory_00005700(param_1,param_2);\n  }\n  uVar1 = *(ushort *)(param_2 + 3);\n  uVar3 = (uint)uVar1;\n  uVar2 = *(ushort *)(param_2 + 3);\n  uVar4 = uVar3 & 1;\n  if ((uVar1 & 1) == 0) {\n    if (-1 < (int)(uVar3 << 0x1e)) {\n      uVar4 = param_2[5];\n    }\n    param_2[2] = uVar4;\n  }\n  else {\n    param_2[2] = 0;\n    param_2[6] = -param_2[5];\n  }\n  if (param_2[4] != 0) {\n    return 0;\n  }\n  if ((uVar1 & 0x80) == 0) {\n    return uVar3 & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(param_2 + 3) = uVar2 | 0x40;\n  return 0xffffffff;\n}\n\n"
        },
        "FUN_000007dc": {
            "renaming": {
                "local_c": "memory_ptr",
                "uVar1": "aligned_size",
                "FUN_000007dc": "allocate_memory_000007dc",
                "param_1": "size",
                "param_2": "param_2",
                "param_3": "param_3",
                "param_4": "param_4",
                "local_10": "i",
                "local_14": "i"
            },
            "code": "int* allocate_memory_000007dc(uint32_t size, int param_2, int param_3, int param_4) {\n  uint32_t aligned_size = (param_4 + param_3) & 0xfffffffc;\n  int* memory_ptr = (int*)(aligned_size - 4);\n  *memory_ptr = 0x77777777;\n  if (((uint32_t)memory_ptr & 7) != 0) {\n    memory_ptr = (int*)(aligned_size - 8);\n    *memory_ptr = 0x88888888;\n  }\n  memory_ptr[-1] = 0x1000000;\n  memory_ptr[-2] = size;\n  memory_ptr[-3] = DAT_000008b4;\n  memory_ptr = memory_ptr - 4;\n  *memory_ptr = 0;\n  for (int i = 3; i > 0; i--) {\n    memory_ptr--;\n    *memory_ptr = i;\n  }\n  memory_ptr--;\n  *memory_ptr = param_2;\n  for (int i = 0xb; i > 3; i--) {\n    memory_ptr--;\n    *memory_ptr = i;\n  }\n  memory_ptr[-1] = -3;\n  return memory_ptr - 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000007dc",
            "calling": [
                "FUN_000010d4"
            ],
            "imported": true,
            "current_name": "allocate_memory_000007dc"
        },
        "FUN_00001710": {
            "renaming": {
                "FUN_00001710": "set_offset_to_zero_00001710",
                "param_1": "offset",
                "calculate_offset_00001696": "calculate_offset",
                "param_2": "value",
                "puVar1": "offset_pointer"
            },
            "code": "void set_offset_to_zero_00001710(undefined4 offset, undefined value) {\n  undefined* offset_pointer;\n  offset_pointer = (undefined*)calculate_offset(offset, value);\n  *offset_pointer = 0;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001710",
            "calling": [
                "FUN_000018bc",
                "FUN_00001778",
                "FUN_00001bb8",
                "FUN_000019c0",
                "FUN_00001960",
                "FUN_00001a60",
                "FUN_0000182c",
                "FUN_00001734"
            ],
            "imported": true,
            "current_name": "set_offset_to_zero_00001710"
        },
        "FUN_000045ec": {
            "renaming": {
                "FUN_000045ec": "do_nothing_000045ec"
            },
            "code": "\nvoid do_nothing_000045ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ec",
            "calling": [
                "FUN_00004db8",
                "FUN_000057f8",
                "FUN_00005ff8",
                "FUN_00004cb4",
                "FUN_000042a4",
                "FUN_00004280",
                "FUN_00004418",
                "FUN_00004158",
                "FUN_0000579c"
            ],
            "imported": true,
            "current_name": "do_nothing_000045ec"
        },
        "FUN_00001034": {
            "renaming": {
                "param_1": "linked_list",
                "local_1c": "current_node",
                "FUN_00001034": "insert_node_at_position_00001034",
                "param_2": "position"
            },
            "code": "void insert_node_at_position_00001034(int **linked_list, int position) {\n  int **current_node;\n  if (position > *(byte *)(param_2 + 4)) {\n    process_input_00000f04(3, PTR_s_FAILED_ASSERTION__0000109c);\n  }\n  for (current_node = linked_list;\n      (*current_node != (int *)0x0 && (*(byte *)((int)*current_node + -3) <= *(byte *)(position + 5)));\n      current_node = (int **)*current_node) {\n  }\n  *(int **)(position + 8) = *current_node;\n  *current_node = (int *)(int **)(position + 8);\n  return;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001034",
            "calling": [
                "FUN_00002434"
            ],
            "imported": true,
            "current_name": "insert_node_at_position_00001034"
        },
        "FUN_00006964": {
            "renaming": {
                "iVar1": "offset",
                "param_1": "current_position",
                "*(int *)(param_2 + -4)": "data[current_position - 1]",
                "*(int *)(param_2 + iVar1)": "data[current_position + offset - 1]",
                "FUN_00006964": "calculate_new_position_00006964",
                "param_2": "data"
            },
            "code": "int calculate_new_position_00006964(int current_position, int* data)\n{\n  int offset = data[current_position - 1] - 4;\n  if (data[current_position - 1] < 0) {\n    offset += data[current_position + offset - 1];\n  }\n  return offset;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006964",
            "calling": [
                "FUN_000060cc"
            ],
            "imported": true,
            "current_name": "calculate_new_position_00006964"
        },
        "FUN_0000182c": {
            "renaming": {
                "DAT_000018b8": "byte_array_2",
                "DAT_000018b4": "byte_array",
                "byte": "byte_type",
                "set_offset_to_zero_00001710": "set_offset_to_zero",
                "FUN_0000182c": "set_offsets_and_mask_byte_0000182c",
                "byte_ptr_1": "byte_pointer",
                "set_offset_to_one_000016ec": "set_offset_to_one"
            },
            "code": "void set_offsets_and_mask_byte_0000182c(void)\n{\n  byte *byte_ptr_1 = DAT_000018b4 + 8;\n  *byte_ptr_1 = *byte_ptr_1 & 0xd0;\n  set_offset_to_one(DAT_000018b8);\n  set_offset_to_zero(DAT_000018b4);\n  set_offset_to_zero(DAT_000018b4);\n  return;\n}",
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000182c",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": true,
            "current_name": "set_offsets_and_mask_byte_0000182c"
        },
        "FUN_00004db8": {
            "renaming": {
                "FUN_00004db8": "FUNC_00004db8"
            },
            "code": "\nundefined4 FUNC_00004db8(int param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  int iVar3;\n  char *pcVar4;\n  char **ppcVar5;\n  undefined4 uVar6;\n  char *pcVar7;\n  \n  iVar3 = *DAT_00004dc4;\n  if ((iVar3 != 0) && (*(int *)(iVar3 + 0x18) == 0)) {\n    initialize_struct_array_000042a4();\n  }\n  ppcVar5 = *(char ***)(iVar3 + 8);\n  if (*(int *)(iVar3 + 0x18) == 0) {\n    initialize_struct_array_000042a4(iVar3);\n  }\n  if (ppcVar5 == (char **)PTR_DAT_00004dac) {\n    ppcVar5 = *(char ***)(iVar3 + 4);\n  }\n  else if (ppcVar5 == (char **)PTR_DAT_00004db0) {\n    ppcVar5 = *(char ***)(iVar3 + 8);\n  }\n  else if (ppcVar5 == (char **)PTR_DAT_00004db4) {\n    ppcVar5 = *(char ***)(iVar3 + 0xc);\n  }\n  if ((-1 < (int)ppcVar5[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(ppcVar5 + 3) << 0x16))) {\n    do_nothing_000045e8(ppcVar5[0x16]);\n  }\n  if ((((int)((uint)*(ushort *)(ppcVar5 + 3) << 0x1c) < 0) && (ppcVar5[4] != (char *)0x0)) ||\n     (iVar2 = process_data_000054a8(iVar3,ppcVar5), iVar2 == 0)) {\n    pcVar7 = (char *)(param_1 + -1);\n    do {\n      while( true ) {\n        pcVar7 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar4 = ppcVar5[2] + -1;\n        ppcVar5[2] = pcVar4;\n        if (cVar1 == '\\0') {\n          if (-1 < (int)pcVar4) {\n            pcVar7 = *ppcVar5;\n            uVar6 = 10;\n            *ppcVar5 = pcVar7 + 1;\n            *pcVar7 = '\\n';\n            goto LAB_00004d64;\n          }\n          iVar3 = process_input_00005404(iVar3,10,ppcVar5);\n          if (iVar3 != -1) {\n            uVar6 = 10;\n            goto LAB_00004d64;\n          }\n          goto LAB_00004d60;\n        }\n        if (((int)pcVar4 < 0) && (((int)pcVar4 < (int)ppcVar5[6] || (cVar1 == '\\n')))) break;\n        pcVar4 = *ppcVar5;\n        *ppcVar5 = pcVar4 + 1;\n        *pcVar4 = cVar1;\n      }\n      iVar2 = process_input_00005404(iVar3,cVar1,ppcVar5);\n    } while (iVar2 != -1);\n  }\nLAB_00004d60:\n  uVar6 = 0xffffffff;\nLAB_00004d64:\n  if ((-1 < (int)ppcVar5[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(ppcVar5 + 3) << 0x16))) {\n    do_nothing_000045ec(ppcVar5[0x16]);\n  }\n  return uVar6;\n}\n\n",
            "called": [
                "FUN_000054a8",
                "FUN_000045ec",
                "FUN_000045e8",
                "FUN_000042a4",
                "FUN_00005404"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00004db8",
            "calling": [
                "FUN_000033c0",
                "FUN_00002f30",
                "FUN_000023a4",
                "FUN_00002f74",
                "FUN_000034c0",
                "FUN_00003478",
                "FUN_00003444",
                "FUN_00003694",
                "FUN_00002b10",
                "FUN_000031e0",
                "FUN_000033f4",
                "FUN_00002fe0",
                "FUN_00002a88",
                "FUN_0000305c"
            ],
            "imported": false,
            "current_name": "FUNC_00004db8"
        },
        "FUN_000022f0": {
            "renaming": {
                "uVar1": "current_value",
                "param_1": "base_address",
                "undefined": "void",
                "PTR_": "base_address",
                "DAT_": "mask",
                "FUN_000022f0": "increment_value_at_address_000022f0"
            },
            "code": "undefined increment_value_at_address_000022f0(uint *PTR_, uint offset, uint DAT_)\n{\n  uint current_value = PTR_[2];\n  PTR_[2] = current_value + 1;\n  uint DAT_ed_offset = current_value & (DAT_ - 1U);\n  return *(undefined *)(DAT_ed_offset + PTR_[offset]);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022f0",
            "calling": [
                "FUN_0000231c"
            ],
            "imported": true,
            "current_name": "increment_value_at_address_000022f0"
        },
        "FUN_00001c84": {
            "renaming": {
                "is_interrupts_enabled_in_privileged_mode_00000cd0": "is_interrupts_enabled_in_privileged_mode",
                "uVar1": "interrupts_enabled",
                "set_offsets_and_mask_byte_0000182c": "set_offsets_and_mask_byte",
                "set_offset_and_enable_flag_000017dc": "set_offset_and_enable_flag",
                "DAT_00001ce8": "device_settings",
                "resetDevice_00001bb8": "reset_device",
                "perform_device_operations_00001b10": "perform_device_operations",
                "enable_interrupts_if_privileged_00000d0c": "enable_interrupts_if_privileged",
                "FUN_00001c84": "initialize_device_00001c84",
                "DAT_00001cec": "device_flags"
            },
            "code": "void initialize_device_00001c84(void)\n{\n  bool interrupts_enabled = is_interrupts_enabled_in_privileged_mode();\n  reset_device();\n  *(uint32_t *)(DAT_00001ce8 + 0x1044) = 0x220000;\n  DAT_00001ce8[0xc] = 0;\n  *DAT_00001ce8 = *DAT_00001ce8 & 199 | 0x38;\n  DAT_00001ce8[4] = 0x13;\n  DAT_00001ce8[5] = 0;\n  set_offsets_and_mask_byte();\n  set_offset_and_enable_flag();\n  perform_device_operations(7);\n  enable_interrupts_if_privileged(interrupts_enabled);\n  return;\n}",
            "called": [
                "FUN_00001bb8",
                "FUN_00000cd0",
                "FUN_00000d0c",
                "FUN_00001b10",
                "FUN_0000182c",
                "FUN_000017dc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001c84",
            "calling": [
                "FUN_00001274"
            ],
            "imported": true,
            "current_name": "initialize_device_00001c84"
        },
        "FUN_000068f0": {
            "renaming": {
                "iVar1": "new_block_ptr",
                "iVar2": "current_size",
                "param_1": "requested_size",
                "param_2": "memory_block",
                "block_ptr": "block_pointer",
                "FUN_000068f0": "allocate_or_expand_memory_block_000068f0"
            },
            "code": "int allocate_or_expand_memory_block_000068f0(int requested_size, int *memory_block)\n{\n  int current_size = memory_block[0xe];\n  int *block_ptr = (int *)memory_block[0xd];\n  \n  if (block_ptr == memory_block + 0x11) {\n    int new_block_ptr = allocate_memory_block(requested_size);\n    if (new_block_ptr != 0) {\n      memory_block[0xe] = requested_size;\n      memory_block[0xd] = new_block_ptr;\n      *(char *)(new_block_ptr + 0x3ff) = *(char *)((int)memory_block + 0x46);\n      *(char *)(new_block_ptr + 0x3fe) = *(char *)((int)memory_block + 0x45);\n      *(int *)(new_block_ptr + 0x3fd) = *(int *)(memory_block + 0x11);\n      *memory_block = new_block_ptr + 0x3fd;\n      return 0;\n    }\n  }\n  else {\n    int new_block_ptr = allocate_block_if_needed(block_ptr, current_size << 1);\n    if (new_block_ptr != 0) {\n      copy_string(new_block_ptr + current_size,new_block_ptr,current_size);\n      memory_block[0xd] = new_block_ptr;\n      memory_block[0xe] = current_size << 1;\n      *memory_block = new_block_ptr + current_size;\n      return 0;\n    }\n  }\n  return -1;\n}",
            "called": [
                "FUN_00004bd0",
                "FUN_000060b0",
                "FUN_000060cc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000068f0",
            "calling": [],
            "imported": true,
            "current_name": "allocate_or_expand_memory_block_000068f0"
        }
    },
    "used_tokens": 163808,
    "layers": [
        [
            "FUN_000064bc",
            "FUN_00002970",
            "FUN_00000d0c",
            "FUN_00003d94",
            "FUN_0000579c",
            "FUN_000015d0",
            "FUN_00000dcc",
            "FUN_0000285c",
            "FUN_00000566",
            "FUN_00001d08",
            "FUN_000031fc",
            "FUN_00005584",
            "FUN_00001da2",
            "FUN_00002744",
            "FUN_00001e0c",
            "FUN_000004f2",
            "FUN_00004e66",
            "FUN_00005ecc",
            "FUN_00001748",
            "FUN_0000294c",
            "FUN_00005790",
            "FUN_00000534",
            "FUN_000005ca",
            "FUN_00005ff8",
            "FUN_00002714",
            "FUN_00005fec",
            "FUN_00004f84",
            "FUN_000028f0",
            "FUN_000039e8",
            "FUN_00002294",
            "FUN_00003810",
            "FUN_0000687c",
            "FUN_00005edc",
            "FUN_0000240c",
            "FUN_00004280",
            "FUN_00000cf0",
            "FUN_00002538",
            "FUN_0000058e",
            "FUN_00001696",
            "FUN_000008b8",
            "FUN_0000091c",
            "FUN_00000d44",
            "FUN_00000cd0",
            "FUN_00000d2a",
            "FUN_00001e44",
            "FUN_00001318",
            "FUN_00000900",
            "FUN_00004274",
            "FUN_00001dc0",
            "FUN_000026f0",
            "FUN_00001d5e",
            "FUN_000050f4",
            "FUN_00005a58",
            "FUN_000056b0",
            "FUN_00003d24",
            "FUN_00003dc4",
            "FUN_000022be",
            "FUN_00001d80",
            "FUN_000023c8",
            "FUN_0000428c",
            "FUN_000010a0",
            "FUN_00006010",
            "FUN_00001360",
            "FUN_00004622",
            "FUN_0000093c",
            "FUN_00003658",
            "FUN_000060b0",
            "FUN_000050e8",
            "FUN_00000514",
            "FUN_000045ee",
            "FUN_00006974",
            "FUN_00005ebc",
            "FUN_0000281c",
            "FUN_00002270",
            "FUN_00003918",
            "FUN_00003d64",
            "FUN_00004e52",
            "FUN_00001ad4",
            "FUN_00002910",
            "FUN_000043a0",
            "FUN_000007dc",
            "FUN_00006964",
            "FUN_000022f0"
        ],
        [
            "FUN_000026c0",
            "FUN_00005e68",
            "FUN_00000e58",
            "FUN_000026d8",
            "FUN_000016ec",
            "FUN_00001ec4",
            "FUN_000014c4",
            "FUN_00004b34",
            "FUN_00004f98",
            "FUN_00000428",
            "FUN_00000e38",
            "FUN_00002600",
            "FUN_00004042",
            "FUN_00002894",
            "FUN_00000d76",
            "FUN_000026e4",
            "FUN_00000698",
            "FUN_00001ff6",
            "FUN_0000328c",
            "FUN_000041f4",
            "FUN_000056b8",
            "FUN_00003ff4",
            "FUN_00000930",
            "FUN_00001348",
            "FUN_00001d3a",
            "FUN_00002798",
            "FUN_0000231c",
            "FUN_00001cf0",
            "FUN_000023d0",
            "FUN_00005fd8",
            "FUN_0000443c",
            "FUN_000027b0",
            "FUN_000016c8",
            "FUN_00000738",
            "FUN_00003e58",
            "FUN_00004e26",
            "FUN_00000610",
            "FUN_00002364",
            "FUN_00003688",
            "FUN_00001392",
            "FUN_0000258c",
            "FUN_0000562c",
            "FUN_00002a18",
            "FUN_00001710"
        ],
        [
            "FUN_00004bd0",
            "FUN_00000794",
            "FUN_00001778",
            "FUN_00002624",
            "FUN_00001628",
            "FUN_000017dc",
            "FUN_00004dee",
            "FUN_00002654",
            "FUN_000025f4",
            "FUN_00001ddc",
            "FUN_000024bc",
            "FUN_00002994",
            "FUN_00000d9c",
            "FUN_00001bb8",
            "FUN_0000404c",
            "FUN_000056a0",
            "FUN_00002690",
            "FUN_00002e9c",
            "FUN_00001960",
            "FUN_00006192",
            "FUN_00001734",
            "FUN_00005780",
            "FUN_00002028",
            "FUN_00001a60",
            "FUN_000018bc",
            "FUN_0000182c"
        ],
        [
            "FUN_00004248",
            "FUN_000020e0",
            "FUN_00000db0",
            "FUN_000020f4",
            "FUN_00001688",
            "FUN_000012b4",
            "FUN_00001f80",
            "FUN_00001a18",
            "FUN_0000191c",
            "FUN_000060cc",
            "FUN_00002108",
            "FUN_00005700",
            "FUN_000019c0",
            "FUN_00001a3c",
            "FUN_000020cc",
            "FUN_00002396",
            "FUN_000020b8"
        ],
        [
            "FUN_00001eea",
            "FUN_00001448",
            "FUN_00001b10",
            "FUN_000068f0"
        ],
        [
            "FUN_00001c84"
        ],
        [
            "FUN_00001274"
        ],
        [
            "FUN_000031e0",
            "FUN_000034c0",
            "FUN_000033f4",
            "FUN_00003478"
        ],
        [
            "FUN_00003378",
            "FUN_00000ed8",
            "FUN_0000211c"
        ],
        [
            "FUN_00002eb4"
        ],
        [
            "FUN_00002a88",
            "FUN_000033c0",
            "FUN_00002f74",
            "FUN_00003444"
        ],
        [
            "FUN_00004158",
            "FUN_00004c84",
            "FUN_00004314",
            "FUN_000054a8"
        ],
        [
            "FUN_000041d0",
            "FUN_00002b10",
            "FUN_00003524",
            "FUN_000042a4"
        ],
        [
            "FUN_00006768",
            "FUN_00005404"
        ],
        [
            "FUN_000057a8",
            "FUN_00005e10",
            "FUN_00004cb4"
        ],
        [
            "FUN_000057d2",
            "FUN_00004418",
            "FUN_00002a00"
        ],
        [
            "FUN_00002e48",
            "FUN_00002d94"
        ],
        [
            "FUN_00002e6c"
        ],
        [
            "FUN_000023a4"
        ],
        [
            "FUN_00000f04"
        ],
        [
            "FUN_00000fec",
            "FUN_00000cc0",
            "FUN_000013b8",
            "FUN_00003ec4",
            "FUN_00000a30",
            "FUN_00001034"
        ],
        [
            "FUN_00000dc0",
            "FUN_00003e9e",
            "FUN_00000e64",
            "FUN_00000df4",
            "FUN_00002434",
            "FUN_000010d4"
        ],
        [
            "FUN_0000129c",
            "FUN_00000410",
            "FUN_00000f8c",
            "FUN_00003694"
        ],
        [
            "FUN_0000459c",
            "FUN_0000305c",
            "FUN_00002ecc",
            "FUN_000012e2"
        ],
        [
            "FUN_00002f30",
            "FUN_00000e14",
            "FUN_0000099c"
        ],
        [
            "FUN_00000490",
            "FUN_00002fe0"
        ],
        [
            "FUN_0000316c",
            "FUN_00004dc8"
        ]
    ],
    "locked_functions": []
}