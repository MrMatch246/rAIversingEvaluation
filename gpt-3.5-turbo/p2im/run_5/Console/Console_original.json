{
    "functions": {
        "cortexm_init": {
            "renaming": {}, 
            "code": "\nvoid cortexm_init(void)\n\n{\n  uint i;\n  \n  *(undefined4 *)(DAT_000025ec + 8) = DAT_000025f0;\n  NVIC_SetPriority(PendSV_IRQn,1);\n  NVIC_SetPriority(SVCall_IRQn,1);\n  for (i = 0; i < 0x66; i = i + 1) {\n    NVIC_SetPriority((IRQn_Type)i,1);\n  }\n  *(uint *)(DAT_000025ec + 0x10) = *(uint *)(DAT_000025ec + 0x10) | 0x10;\n  *(uint *)(DAT_000025ec + 0x14) = *(uint *)(DAT_000025ec + 0x14) | 0x200;\n  return;\n}\n\n", 
            "called": [
                "NVIC_SetPriority"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000258c", 
            "calling": [
                "cpu_init"
            ], 
            "imported": false, 
            "current_name": "cortexm_init"
        }, 
        "ps": {
            "renaming": {}, 
            "code": "\nvoid ps(void)\n\n{\n  byte bVar1;\n  int iVar2;\n  void *pvVar3;\n  void *pvVar4;\n  uintptr_t uVar5;\n  undefined4 *puVar6;\n  undefined4 uVar7;\n  char queued_name [2];\n  int stacksz;\n  char *queued;\n  char *sname;\n  int state;\n  thread_t *p;\n  void *isr_sp;\n  void *isr_start;\n  int isr_usage;\n  kernel_pid_t i;\n  int overall_used;\n  int overall_stacksz;\n  \n  queued_name = (char  [2])0x515f;\n  overall_used = 0;\n  iprintf(PTR_s__pid_____21s____9sQ___pri___stac_00002250,PTR_DAT_0000224c,PTR_s_state_00002248);\n  iVar2 = thread_isr_stack_usage();\n  pvVar3 = thread_isr_stack_start();\n  pvVar4 = thread_isr_stack_pointer();\n  iprintf(PTR_s______isr_stack______________6i___00002254,0x200,iVar2,pvVar3,pvVar4);\n  overall_stacksz = 0x200;\n  if (0 < iVar2) {\n    overall_used = iVar2;\n  }\n  for (i = 1; i < 0x21; i = i + 1) {\n    puVar6 = *(undefined4 **)(PTR_sched_threads_00002258 + i * 4);\n    if (puVar6 != (undefined4 *)0x0) {\n      bVar1 = *(byte *)(puVar6 + 1);\n      uVar7 = *(undefined4 *)(PTR_state_names_0000225c + (uint)bVar1 * 4);\n      iVar2 = puVar6[0xb];\n      overall_stacksz = iVar2 + overall_stacksz;\n      uVar5 = thread_measure_stack_free((char *)puVar6[9]);\n      iVar2 = iVar2 - uVar5;\n      overall_used = iVar2 + overall_used;\n      iprintf(PTR_s___3hi_____20s_____8s___1s____3i___00002260,(int)*(short *)((int)puVar6 + 6),\n              puVar6[10],uVar7,queued_name + (8 < bVar1),(uint)*(byte *)((int)puVar6 + 5),\n              puVar6[0xb],iVar2,puVar6[9],*puVar6);\n    }\n  }\n  iprintf(PTR_s___5s___21s__13s_6s__6i___5i__0000226c,PTR_DAT_00002264,PTR_DAT_00002268,\n          PTR_DAT_00002264,PTR_DAT_00002264,overall_stacksz,overall_used);\n  return;\n}\n\n", 
            "called": [
                "thread_isr_stack_pointer", 
                "thread_measure_stack_free", 
                "iprintf", 
                "thread_isr_stack_usage", 
                "thread_isr_stack_start"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000211c", 
            "calling": [
                "core_panic", 
                "_ps_handler"
            ], 
            "imported": false, 
            "current_name": "ps"
        }, 
        "lflush": {
            "renaming": {}, 
            "code": "\nint lflush(FILE *param_1)\n\n{\n  int iVar1;\n  \n  if ((*(ushort *)&param_1->_IO_read_base & 9) == 9) {\n    iVar1 = fflush(param_1);\n    return iVar1;\n  }\n  return 0;\n}\n\n", 
            "called": [
                "fflush"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00006754", 
            "calling": [], 
            "imported": false, 
            "current_name": "lflush"
        }, 
        "fmt_u32_dec": {
            "renaming": {}, 
            "code": "\nsize_t fmt_u32_dec(char *out,uint32_t val)\n\n{\n  uint32_t local_20;\n  char *ptr;\n  uint32_t tmp;\n  size_t len;\n  \n  len = 1;\n  if (DAT_00003e50 < val) {\n    len = 10;\n  }\n  else {\n    for (tmp = 10; tmp <= val; tmp = tmp * 10) {\n      len = len + 1;\n    }\n  }\n  if (out != (char *)0x0) {\n    ptr = out + len;\n    local_20 = val;\n    do {\n      ptr = ptr + -1;\n      *ptr = (char)local_20 +\n             (char)(uint)((ulonglong)DAT_00003e54 * (ulonglong)local_20 >> 0x23) * -10 + '0';\n      local_20 = (uint32_t)((ulonglong)DAT_00003e54 * (ulonglong)local_20 >> 0x23);\n    } while (local_20 != 0);\n  }\n  return len;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00003dc4", 
            "calling": [
                "fmt_s32_dec"
            ], 
            "imported": false, 
            "current_name": "fmt_u32_dec"
        }, 
        "fmt_lpad": {
            "renaming": {}, 
            "code": "\nsize_t fmt_lpad(char *out,size_t in_len,size_t pad_len,char pad_char)\n\n{\n  size_t sVar1;\n  size_t n;\n  \n  sVar1 = in_len;\n  if ((in_len < pad_len) && (sVar1 = pad_len, out != (char *)0x0)) {\n    memmove(out + (pad_len - in_len),out,in_len);\n    memset(out,(uint)(byte)pad_char,pad_len - in_len);\n  }\n  return sVar1;\n}\n\n", 
            "called": [
                "memset", 
                "memmove"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00003ff4", 
            "calling": [
                "fmt_s32_dfp"
            ], 
            "imported": false, 
            "current_name": "fmt_lpad"
        }, 
        "debug_mon_default": {
            "renaming": {}, 
            "code": "\nvoid debug_mon_default(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  core_panic(PANIC_DEBUG_MON,PTR_s_DEBUG_MON_HANDLER_00000cbc);\n}\n\n", 
            "called": [
                "core_panic"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000cb0", 
            "calling": [], 
            "imported": false, 
            "current_name": "debug_mon_default"
        }, 
        "NVIC_SetPriority": {
            "renaming": {}, 
            "code": "\nvoid NVIC_SetPriority(IRQn_Type IRQn,uint32_t priority)\n\n{\n  if (IRQn < DMA0_IRQn) {\n    *(char *)(((byte)IRQn & 0xf) + DAT_00002790 + 0x14) = (char)((priority & 0xff) << 4);\n  }\n  else {\n    *(char *)(IRQn + DAT_00002794 + 0x300) = (char)((priority & 0xff) << 4);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002744", 
            "calling": [
                "rtt_set_alarm"
            ], 
            "imported": false, 
            "current_name": "NVIC_SetPriority"
        }, 
        "thread_stack_init": {
            "renaming": {}, 
            "code": "\nchar * thread_stack_init(thread_task_func_t task_func,void *arg,void *stack_start,int stack_size)\n\n{\n  uint uVar1;\n  int i_1;\n  int i;\n  uint32_t *stk;\n  \n  uVar1 = stack_size + (int)stack_start & 0xfffffffc;\n  stk = (uint32_t *)(uVar1 - 4);\n  *stk = 0x77777777;\n  if (((uint)stk & 7) != 0) {\n    stk = (uint32_t *)(uVar1 - 8);\n    *stk = 0x88888888;\n  }\n  stk[-1] = 0x1000000;\n  stk[-2] = (uint32_t)task_func;\n  stk[-3] = DAT_000008b4;\n  stk = stk + -4;\n  *stk = 0;\n  for (i = 3; 0 < i; i = i + -1) {\n    stk = stk + -1;\n    *stk = i;\n  }\n  stk = stk + -1;\n  *stk = (uint32_t)arg;\n  for (i_1 = 0xb; 3 < i_1; i_1 = i_1 + -1) {\n    stk = stk + -1;\n    *stk = i_1;\n  }\n  stk[-1] = 0xfffffffd;\n  return (char *)(stk + -1);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000007dc", 
            "calling": [
                "thread_create"
            ], 
            "imported": false, 
            "current_name": "thread_stack_init"
        }, 
        "thread_isr_stack_usage": {
            "renaming": {}, 
            "code": "\nint thread_isr_stack_usage(void)\n\n{\n  ptrdiff_t num_used_words;\n  uint32_t *ptr;\n  \n  for (ptr = (uint32_t *)PTR_isr_stack_000008f4;\n      (*ptr == DAT_000008f8 && (ptr < PTR_heap_top_000008fc)); ptr = ptr + 1) {\n  }\n  return ((int)PTR_heap_top_000008fc - (int)ptr >> 2) << 2;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000008b8", 
            "calling": [
                "ps"
            ], 
            "imported": false, 
            "current_name": "thread_isr_stack_usage"
        }, 
        "bit_set8": {
            "renaming": {}, 
            "code": "\nvoid bit_set8(uint8_t *ptr,uint8_t bit)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = (undefined *)bitband_addr(ptr,(uint)bit);\n  *puVar1 = 1;\n  return;\n}\n\n", 
            "called": [
                "bitband_addr"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000016ec", 
            "calling": [
                "kinetis_mcg_set_blpe", 
                "kinetis_mcg_set_blpi", 
                "kinetis_mcg_init_mcgirclk", 
                "kinetis_mcg_set_pbe", 
                "kinetis_mcg_enable_osc"
            ], 
            "imported": false, 
            "current_name": "bit_set8"
        }, 
        "rtt_set_counter": {
            "renaming": {}, 
            "code": "\nvoid rtt_set_counter(uint32_t counter)\n\n{\n  uint32_t *puVar1;\n  RTC_Type *rtt;\n  \n  puVar1 = DAT_00002890;\n  DAT_00002890[5] = DAT_00002890[5] & 0xffffffef;\n  *puVar1 = counter;\n  puVar1[5] = puVar1[5] | 0x10;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000285c", 
            "calling": [
                "rtc_set_time"
            ], 
            "imported": false, 
            "current_name": "rtt_set_counter"
        }, 
        "_malloc_usable_size_r": {
            "renaming": {}, 
            "code": "\nint _malloc_usable_size_r(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = *(int *)(param_2 + -4) + -4;\n  if (*(int *)(param_2 + -4) < 0) {\n    iVar1 = iVar1 + *(int *)(param_2 + iVar1);\n  }\n  return iVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00006964", 
            "calling": [
                "_realloc_r"
            ], 
            "imported": false, 
            "current_name": "_malloc_usable_size_r"
        }, 
        "bit_set32": {
            "renaming": {}, 
            "code": "\nvoid bit_set32(uint32_t *ptr,uint8_t bit)\n\n{\n  undefined4 *puVar1;\n  \n  puVar1 = (undefined4 *)bitband_addr(ptr,(uint)bit);\n  *puVar1 = 1;\n  return;\n}\n\n", 
            "called": [
                "bitband_addr"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001d3a", 
            "calling": [
                "clk_en"
            ], 
            "imported": false, 
            "current_name": "bit_set32"
        }, 
        "_reboot_handler": {
            "renaming": {}, 
            "code": "\nint _reboot_handler(int argc,char **argv)\n\n{\n  pm_reboot();\n  return 0;\n}\n\n", 
            "called": [
                "pm_reboot"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002e9c", 
            "calling": [], 
            "imported": false, 
            "current_name": "_reboot_handler"
        }, 
        "isr_uart0_rx_tx": {
            "renaming": {}, 
            "code": "\nvoid isr_uart0_rx_tx(void)\n\n{\n  irq_handler_uart(0);\n  return;\n}\n\n", 
            "called": [
                "irq_handler_uart"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001688", 
            "calling": [], 
            "imported": false, 
            "current_name": "isr_uart0_rx_tx"
        }, 
        "uart_stdio_write": {
            "renaming": {}, 
            "code": "\nint uart_stdio_write(char *buffer,int len)\n\n{\n  uart_write(0,(uint8_t *)buffer,len);\n  return len;\n}\n\n", 
            "called": [
                "uart_write"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000e38", 
            "calling": [
                "_write_r"
            ], 
            "imported": false, 
            "current_name": "uart_stdio_write"
        }, 
        "kinetis_mcg_set_mode": {
            "renaming": {}, 
            "code": "\nint kinetis_mcg_set_mode(kinetis_mcg_mode_t mode)\n\n{\n  int iVar1;\n  \n  if (mode < KINETIS_MCG_MODE_NUMOF) {\n    do {\n      switch(PTR_mcg_mode_routing_00001bb4[(uint)mode + (uint)(byte)*PTR_current_mode_00001bb0 * 8])\n      {\n      case 0:\n        kinetis_mcg_set_fei();\n        break;\n      case 1:\n        kinetis_mcg_set_fee();\n        break;\n      case 2:\n        kinetis_mcg_set_fbi();\n        break;\n      case 3:\n        kinetis_mcg_set_fbe();\n        break;\n      case 4:\n        kinetis_mcg_set_blpi();\n        break;\n      case 5:\n        kinetis_mcg_set_blpe();\n        break;\n      case 6:\n        kinetis_mcg_set_pbe();\n        break;\n      case 7:\n        kinetis_mcg_set_pee();\n        break;\n      default:\n        return -1;\n      }\n    } while (mode != *PTR_current_mode_00001bb0);\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = -1;\n  }\n  return iVar1;\n}\n\n", 
            "called": [
                "kinetis_mcg_set_blpe", 
                "kinetis_mcg_set_fbe", 
                "kinetis_mcg_set_fei", 
                "kinetis_mcg_set_blpi", 
                "kinetis_mcg_set_fee", 
                "kinetis_mcg_set_pbe", 
                "kinetis_mcg_set_fbi", 
                "kinetis_mcg_set_pee"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001b10", 
            "calling": [
                "kinetis_mcg_init"
            ], 
            "imported": false, 
            "current_name": "kinetis_mcg_set_mode"
        }, 
        "strncmp": {
            "renaming": {}, 
            "code": "\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n  byte *pbVar1;\n  byte *pbVar2;\n  uint uVar3;\n  \n  if (__n != 0) {\n    pbVar2 = (byte *)(__s2 + -1);\n    pbVar1 = (byte *)__s1;\n    do {\n      uVar3 = (uint)*pbVar1;\n      pbVar2 = pbVar2 + 1;\n      if ((uVar3 != *pbVar2) || (pbVar1 + 1 == (byte *)(__s1 + __n))) break;\n      pbVar1 = pbVar1 + 1;\n    } while (uVar3 != 0);\n    __n = uVar3 - *pbVar2;\n  }\n  return __n;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004e66", 
            "calling": [
                "_rtc_handler", 
                "_findenv_r"
            ], 
            "imported": false, 
            "current_name": "strncmp"
        }, 
        "_parse_time": {
            "renaming": {}, 
            "code": "\nint _parse_time(char **argv,tm *time)\n\n{\n  long lVar1;\n  int iVar2;\n  char *end;\n  short i;\n  \n  lVar1 = strtol(*argv,&end,10);\n  i = (short)lVar1;\n  time->tm_year = i + -0x76c;\n  lVar1 = strtol(end + 1,&end,10);\n  i = (short)lVar1;\n  time->tm_mon = i + -1;\n  lVar1 = strtol(end + 1,&end,10);\n  i = (short)lVar1;\n  time->tm_mday = (int)i;\n  lVar1 = strtol(argv[1],&end,10);\n  i = (short)lVar1;\n  time->tm_hour = (int)i;\n  lVar1 = strtol(end + 1,&end,10);\n  i = (short)lVar1;\n  time->tm_min = (int)i;\n  lVar1 = strtol(end + 1,&end,10);\n  i = (short)lVar1;\n  time->tm_sec = (int)i;\n  iVar2 = dow(time->tm_year + 0x76c,time->tm_mon + 1,time->tm_mday);\n  time->tm_wday = iVar2;\n  time->tm_isdst = -1;\n  return 0;\n}\n\n", 
            "called": [
                "strtol", 
                "dow"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000328c", 
            "calling": [
                "_rtc_setalarm", 
                "_rtc_settime"
            ], 
            "imported": false, 
            "current_name": "_parse_time"
        }, 
        "_sungetc_r": {
            "renaming": {}, 
            "code": "\nuint _sungetc_r(undefined4 param_1,uint param_2,uint *param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  \n  if (param_2 == 0xffffffff) {\nLAB_00006120:\n    param_2 = 0xffffffff;\n  }\n  else {\n    *(ushort *)(param_3 + 3) = *(ushort *)(param_3 + 3) & 0xffdf;\n    uVar2 = param_3[1];\n    param_2 = param_2 & 0xff;\n    if (param_3[0xd] == 0) {\n      uVar3 = *param_3;\n      if (((param_3[4] != 0) && (param_3[4] < uVar3)) && (*(byte *)(uVar3 - 1) == param_2)) {\n        *param_3 = uVar3 - 1;\n        param_3[1] = uVar2 + 1;\n        return param_2;\n      }\n      param_3[0xf] = uVar3;\n      param_3[0x10] = uVar2;\n      param_3[0xd] = (uint)(param_3 + 0x11);\n      param_3[0xe] = 3;\n      *(undefined *)((int)param_3 + 0x46) = (char)param_2;\n      *param_3 = (uint)(undefined *)((int)param_3 + 0x46);\n      uVar2 = 1;\n    }\n    else {\n      if (((int)param_3[0xe] <= (int)uVar2) &&\n         (iVar1 = __submore(param_1,param_3,uVar2,param_3[0xe],param_4), iVar1 != 0))\n      goto LAB_00006120;\n      uVar2 = *param_3;\n      *param_3 = uVar2 - 1;\n      *(char *)(uVar2 - 1) = (char)param_2;\n      uVar2 = param_3[1] + 1;\n    }\n    param_3[1] = uVar2;\n  }\n  return param_2;\n}\n\n", 
            "called": [
                "__submore"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00006118", 
            "calling": [], 
            "imported": false, 
            "current_name": "_sungetc_r"
        }, 
        "putchar": {
            "renaming": {}, 
            "code": "\nint putchar(int __c)\n\n{\n  undefined4 in_r3;\n  int iVar1;\n  \n  iVar1 = *(int *)PTR__impure_ptr_00004cd8;\n  if ((iVar1 != 0) && (*(int *)(iVar1 + 0x18) == 0)) {\n    __sinit(iVar1);\n  }\n  iVar1 = _putc_r(iVar1,__c,*(undefined4 *)(iVar1 + 8),in_r3);\n  return iVar1;\n}\n\n", 
            "called": [
                "__sinit", 
                "_putc_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004cb4", 
            "calling": [
                "_putchar"
            ], 
            "imported": false, 
            "current_name": "putchar"
        }, 
        "ctx_clear": {
            "renaming": {}, 
            "code": "\nvoid ctx_clear(int port,int pin)\n\n{\n  int ctx_00;\n  int ctx;\n  \n  ctx_00 = get_ctx(port,pin);\n  write_map(port,pin,ctx_00);\n  return;\n}\n\n", 
            "called": [
                "write_map", 
                "get_ctx"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001ec4", 
            "calling": [
                "gpio_init_port"
            ], 
            "imported": false, 
            "current_name": "ctx_clear"
        }, 
        "cpu_print_last_instruction": {
            "renaming": {}, 
            "code": "\nvoid cpu_print_last_instruction(void)\n\n{\n  undefined4 in_lr;\n  uint32_t *lr_ptr;\n  \n  iprintf(PTR_DAT_00000ef4,in_lr);\n  return;\n}\n\n", 
            "called": [
                "iprintf"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000ed8", 
            "calling": [
                "core_panic"
            ], 
            "imported": false, 
            "current_name": "cpu_print_last_instruction"
        }, 
        "_strtol_l.isra.0": {
            "renaming": {}, 
            "code": "\nuint _strtol_l_isra_0(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint uVar7;\n  byte *pbVar8;\n  byte *pbVar9;\n  \n  pbVar9 = param_2;\n  do {\n    pbVar8 = pbVar9;\n    pbVar9 = pbVar8 + 1;\n    uVar2 = (uint)*pbVar8;\n    uVar3 = (byte)PTR_DAT_00004f7c[uVar2] & 8;\n  } while ((PTR_DAT_00004f7c[uVar2] & 8) != 0);\n  if (uVar2 == 0x2d) {\n    uVar2 = (uint)*pbVar9;\n    uVar3 = 1;\n    pbVar9 = pbVar8 + 2;\n  }\n  else if (uVar2 == 0x2b) {\n    uVar2 = (uint)*pbVar9;\n    pbVar9 = pbVar8 + 2;\n  }\n  if (param_4 == 0) {\n    if (uVar2 != 0x30) {\n      param_4 = 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((param_4 != 0x10) || (uVar2 != 0x30)) goto LAB_00004ed6;\n  if ((*pbVar9 & 0xdf) == 0x58) {\n    uVar2 = (uint)pbVar9[1];\n    param_4 = 0x10;\n    pbVar9 = pbVar9 + 2;\n  }\n  else {\n    uVar2 = 0x30;\n    if (param_4 == 0) {\n      param_4 = 8;\n    }\n  }\nLAB_00004ed6:\n  uVar6 = uVar3 + 0x7fffffff;\n  iVar5 = 0;\n  uVar7 = uVar6 / param_4;\n  uVar1 = 0;\n  do {\n    uVar4 = uVar2 - 0x30;\n    if (9 < uVar4) {\n      if (uVar2 - 0x41 < 0x1a) {\n        uVar4 = uVar2 - 0x37;\n      }\n      else {\n        if (0x19 < uVar2 - 0x61) break;\n        uVar4 = uVar2 - 0x57;\n      }\n    }\n    if ((int)param_4 <= (int)uVar4) break;\n    if (iVar5 != -1) {\n      if ((uVar7 < uVar1) || ((uVar7 == uVar1 && ((int)(uVar6 - param_4 * uVar7) < (int)uVar4)))) {\n        iVar5 = -1;\n      }\n      else {\n        uVar1 = uVar1 * param_4 + uVar4;\n        iVar5 = 1;\n      }\n    }\n    uVar2 = (uint)*pbVar9;\n    pbVar9 = pbVar9 + 1;\n  } while( true );\n  if (iVar5 == -1) {\n    *param_1 = 0x22;\n    uVar1 = uVar6;\n    if (param_3 == (byte **)0x0) {\n      return uVar6;\n    }\n  }\n  else {\n    if (uVar3 != 0) {\n      uVar1 = -uVar1;\n    }\n    if (param_3 == (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar5 == 0) goto LAB_00004f64;\n  }\n  param_2 = pbVar9 + -1;\nLAB_00004f64:\n  *param_3 = param_2;\n  return uVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004e8c", 
            "calling": [
                "strtol", 
                "_strtol_r"
            ], 
            "imported": false, 
            "current_name": "_strtol_l.isra.0"
        }, 
        "saul_reg_find_nth": {
            "renaming": {}, 
            "code": "\nsaul_reg_t * saul_reg_find_nth(int pos)\n\n{\n  int i;\n  saul_reg_t *tmp;\n  \n  tmp = *(saul_reg_t **)PTR_saul_reg_00003d60;\n  i = 0;\n  for (; (i < pos && (tmp != (saul_reg_t *)0x0)); tmp = tmp->next) {\n    i = i + 1;\n  }\n  return tmp;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00003d24", 
            "calling": [
                "write", 
                "read"
            ], 
            "imported": false, 
            "current_name": "saul_reg_find_nth"
        }, 
        "saul_reg_write": {
            "renaming": {}, 
            "code": "\nint saul_reg_write(saul_reg_t *dev,phydat_t *data)\n\n{\n  int iVar1;\n  \n  if (dev == (saul_reg_t *)0x0) {\n    iVar1 = -0x13;\n  }\n  else {\n    iVar1 = (*dev->driver->write)(dev->dev,data);\n  }\n  return iVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00003d94", 
            "calling": [
                "write"
            ], 
            "imported": false, 
            "current_name": "saul_reg_write"
        }, 
        "getchar": {
            "renaming": {}, 
            "code": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint getchar(void)\n\n{\n  int iVar1;\n  \n  iVar1 = *(int *)PTR__impure_ptr_00004438;\n  if ((iVar1 != 0) && (*(int *)(iVar1 + 0x18) == 0)) {\n    __sinit(iVar1);\n  }\n  iVar1 = _getc_r(iVar1,*(undefined4 *)(iVar1 + 4));\n  return iVar1;\n}\n\n", 
            "called": [
                "_getc_r", 
                "__sinit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004418", 
            "calling": [
                "readline"
            ], 
            "imported": false, 
            "current_name": "getchar"
        }, 
        "__sfp_lock_release": {
            "renaming": {}, 
            "code": "\nvoid __sfp_lock_release(void)\n\n{\n  __retarget_lock_release_recursive(PTR___lock___sfp_recursive_mutex_00004288);\n  return;\n}\n\n", 
            "called": [
                "__retarget_lock_release_recursive"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004280", 
            "calling": [
                "__sfp"
            ], 
            "imported": false, 
            "current_name": "__sfp_lock_release"
        }, 
        "std": {
            "renaming": {}, 
            "code": "\nvoid std(undefined4 *param_1,undefined2 param_2,undefined2 param_3)\n\n{\n  undefined4 uVar1;\n  \n  *param_1 = 0;\n  param_1[1] = 0;\n  param_1[4] = 0;\n  param_1[5] = 0;\n  param_1[2] = 0;\n  *(undefined2 *)(param_1 + 3) = param_2;\n  param_1[0x19] = 0;\n  *(undefined2 *)((int)param_1 + 0xe) = param_3;\n  param_1[6] = 0;\n  memset(param_1 + 0x17,0,8);\n  param_1[9] = DAT_0000422c;\n  param_1[10] = DAT_00004230;\n  param_1[0xb] = DAT_00004234;\n  uVar1 = DAT_00004238;\n  param_1[8] = param_1;\n  param_1[0xc] = uVar1;\n  return;\n}\n\n", 
            "called": [
                "memset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000041f4", 
            "calling": [
                "__sinit"
            ], 
            "imported": false, 
            "current_name": "std"
        }, 
        "_putchar": {
            "renaming": {}, 
            "code": "\nvoid _putchar(int c)\n\n{\n  putchar(c);\n  return;\n}\n\n", 
            "called": [
                "putchar"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002a00", 
            "calling": [
                "readline", 
                "print_prompt"
            ], 
            "imported": false, 
            "current_name": "_putchar"
        }, 
        "kinetis_mcg_init": {
            "renaming": {}, 
            "code": "\nvoid kinetis_mcg_init(void)\n\n{\n  uint state;\n  uint mask;\n  \n  state = irq_disable();\n  kinetis_mcg_set_safe_mode();\n  *(undefined4 *)(DAT_00001ce8 + 0x1044) = 0x220000;\n  DAT_00001cec[0xc] = 0;\n  *DAT_00001cec = *DAT_00001cec & 199 | 0x38;\n  DAT_00001cec[4] = 0x13;\n  DAT_00001cec[5] = 0;\n  kinetis_mcg_init_mcgirclk();\n  kinetis_mcg_init_erclk32k();\n  kinetis_mcg_set_mode(KINETIS_MCG_MODE_PEE);\n  irq_restore(state);\n  return;\n}\n\n", 
            "called": [
                "irq_disable", 
                "kinetis_mcg_init_erclk32k", 
                "kinetis_mcg_set_mode", 
                "kinetis_mcg_init_mcgirclk", 
                "kinetis_mcg_set_safe_mode", 
                "irq_restore"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001c84", 
            "calling": [
                "cpu_init"
            ], 
            "imported": false, 
            "current_name": "kinetis_mcg_init"
        }, 
        "rtc_get_alarm": {
            "renaming": {}, 
            "code": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nint rtc_get_alarm(tm *time)\n\n{\n  time_t t;\n  \n  t._0_4_ = rtt_get_alarm();\n  t._4_4_ = 0;\n  gmtime_r((time_t *)&t,(tm *)time);\n  return 0;\n}\n\n", 
            "called": [
                "gmtime_r", 
                "rtt_get_alarm"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002690", 
            "calling": [
                "_rtc_getalarm"
            ], 
            "imported": false, 
            "current_name": "rtc_get_alarm"
        }, 
        "kinetis_mcg_set_fll_factor": {
            "renaming": {}, 
            "code": "\nvoid kinetis_mcg_set_fll_factor(kinetis_mcg_fll_t factor)\n\n{\n  *(kinetis_mcg_fll_t *)(DAT_00001774 + 3) =\n       factor | *(kinetis_mcg_fll_t *)(DAT_00001774 + 3) & ~KINETIS_MCG_FLL_FACTOR_2929;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001748", 
            "calling": [
                "kinetis_mcg_set_fei", 
                "kinetis_mcg_set_fbe", 
                "kinetis_mcg_set_fee", 
                "kinetis_mcg_set_safe_mode", 
                "kinetis_mcg_set_fbi"
            ], 
            "imported": false, 
            "current_name": "kinetis_mcg_set_fll_factor"
        }, 
        "_strtol_r": {
            "renaming": {}, 
            "code": "\nuint _strtol_r(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint uVar7;\n  byte *pbVar8;\n  byte *pbVar9;\n  \n  pbVar9 = param_2;\n  do {\n    pbVar8 = pbVar9;\n    pbVar9 = pbVar8 + 1;\n    uVar2 = (uint)*pbVar8;\n    uVar3 = (byte)PTR_DAT_00004f7c[uVar2] & 8;\n  } while ((PTR_DAT_00004f7c[uVar2] & 8) != 0);\n  if (uVar2 == 0x2d) {\n    uVar2 = (uint)*pbVar9;\n    uVar3 = 1;\n    pbVar9 = pbVar8 + 2;\n  }\n  else if (uVar2 == 0x2b) {\n    uVar2 = (uint)*pbVar9;\n    pbVar9 = pbVar8 + 2;\n  }\n  if (param_4 == 0) {\n    if (uVar2 != 0x30) {\n      param_4 = 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((param_4 != 0x10) || (uVar2 != 0x30)) goto LAB_00004ed6;\n  if ((*pbVar9 & 0xdf) == 0x58) {\n    uVar2 = (uint)pbVar9[1];\n    param_4 = 0x10;\n    pbVar9 = pbVar9 + 2;\n  }\n  else {\n    uVar2 = 0x30;\n    if (param_4 == 0) {\n      param_4 = 8;\n    }\n  }\nLAB_00004ed6:\n  uVar6 = uVar3 + 0x7fffffff;\n  iVar5 = 0;\n  uVar7 = uVar6 / param_4;\n  uVar1 = 0;\n  do {\n    uVar4 = uVar2 - 0x30;\n    if (9 < uVar4) {\n      if (uVar2 - 0x41 < 0x1a) {\n        uVar4 = uVar2 - 0x37;\n      }\n      else {\n        if (0x19 < uVar2 - 0x61) break;\n        uVar4 = uVar2 - 0x57;\n      }\n    }\n    if ((int)param_4 <= (int)uVar4) break;\n    if (iVar5 != -1) {\n      if ((uVar7 < uVar1) || ((uVar7 == uVar1 && ((int)(uVar6 - param_4 * uVar7) < (int)uVar4)))) {\n        iVar5 = -1;\n      }\n      else {\n        uVar1 = uVar1 * param_4 + uVar4;\n        iVar5 = 1;\n      }\n    }\n    uVar2 = (uint)*pbVar9;\n    pbVar9 = pbVar9 + 1;\n  } while( true );\n  if (iVar5 == -1) {\n    *param_1 = 0x22;\n    uVar1 = uVar6;\n    if (param_3 == (byte **)0x0) {\n      return uVar6;\n    }\n  }\n  else {\n    if (uVar3 != 0) {\n      uVar1 = -uVar1;\n    }\n    if (param_3 == (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar5 == 0) goto LAB_00004f64;\n  }\n  param_2 = pbVar9 + -1;\nLAB_00004f64:\n  *param_3 = param_2;\n  return uVar1;\n}\n\n", 
            "called": [
                "_strtol_l.isra.0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004f80", 
            "calling": [], 
            "imported": false, 
            "current_name": "_strtol_r"
        }, 
        "startForkserver": {
            "renaming": {}, 
            "code": "\nint startForkserver(int ticks)\n\n{\n  uint32_t uVar1;\n  \n  if (*(int *)PTR_noHyperCall_000023fc == 0) {\n    uVar1 = aflCall(1,ticks,0);\n  }\n  else {\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n", 
            "called": [
                "aflCall"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000023d0", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "startForkserver"
        }, 
        "__sinit": {
            "renaming": {}, 
            "code": "\nvoid __sinit(int param_1)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  bool bVar3;\n  \n  __sinit_lock_acquire();\n  if (*(int *)(param_1 + 0x18) == 0) {\n    *(undefined4 *)(param_1 + 0x48) = 0;\n    *(undefined4 *)(param_1 + 0x4c) = 0;\n    *(undefined4 *)(param_1 + 0x50) = 0;\n    iVar2 = *(int *)PTR__global_impure_ptr_0000430c;\n    *(undefined4 *)(param_1 + 0x28) = DAT_00004310;\n    bVar3 = iVar2 == param_1;\n    if (bVar3) {\n      iVar2 = 1;\n    }\n    if (bVar3) {\n      *(int *)(param_1 + 0x18) = iVar2;\n    }\n    uVar1 = __sfp(param_1);\n    *(undefined4 *)(param_1 + 4) = uVar1;\n    uVar1 = __sfp(param_1);\n    *(undefined4 *)(param_1 + 8) = uVar1;\n    uVar1 = __sfp(param_1);\n    *(undefined4 *)(param_1 + 0xc) = uVar1;\n    std(*(undefined4 *)(param_1 + 4),4,0);\n    std(*(undefined4 *)(param_1 + 8),9,1);\n    std(*(undefined4 *)(param_1 + 0xc),0x12,2);\n    *(undefined4 *)(param_1 + 0x18) = 1;\n  }\n  __sinit_lock_release();\n  return;\n}\n\n", 
            "called": [
                "__sfp", 
                "__sinit_lock_acquire", 
                "std", 
                "__sinit_lock_release"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000042a4", 
            "calling": [
                "__sfp", 
                "__srefill_r", 
                "_fflush_r", 
                "_getc_r", 
                "iprintf", 
                "_putc_r", 
                "__swbuf_r", 
                "_puts_r", 
                "__swsetup_r", 
                "__srget_r", 
                "_vfprintf_r", 
                "putchar", 
                "getchar"
            ], 
            "imported": false, 
            "current_name": "__sinit"
        }, 
        "get_ctx": {
            "renaming": {}, 
            "code": "\nint get_ctx(int port,int pin)\n\n{\n  return *(uint *)(PTR_isr_map_00001e40 + ((pin >> 3) + port * 4) * 4) >> ((pin & 7U) << 2) & 0xf;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001e0c", 
            "calling": [
                "ctx_clear", 
                "irq_handler"
            ], 
            "imported": false, 
            "current_name": "get_ctx"
        }, 
        "irq_enable": {
            "renaming": {}, 
            "code": "\nuint irq_enable(void)\n\n{\n  bool bVar1;\n  uint uVar2;\n  uint32_t result;\n  \n  enableIRQinterrupts();\n  uVar2 = 0;\n  bVar1 = (bool)isCurrentModePrivileged();\n  if (bVar1) {\n    uVar2 = isIRQinterruptsEnabled();\n  }\n  return uVar2;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000cf0", 
            "calling": [
                "cpu_switch_context_exit"
            ], 
            "imported": false, 
            "current_name": "irq_enable"
        }, 
        "tsrb_add_one": {
            "renaming": {}, 
            "code": "\nint tsrb_add_one(tsrb_t *rb,char c)\n\n{\n  int iVar1;\n  \n  iVar1 = tsrb_full(rb);\n  if (iVar1 == 0) {\n    _push(rb,c);\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = -1;\n  }\n  return iVar1;\n}\n\n", 
            "called": [
                "_push", 
                "tsrb_full"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002364", 
            "calling": [
                "isrpipe_write_one"
            ], 
            "imported": false, 
            "current_name": "tsrb_add_one"
        }, 
        "gpio_set": {
            "renaming": {}, 
            "code": "\nvoid gpio_set(gpio_t pin)\n\n{\n  uint uVar1;\n  GPIO_Type *pGVar2;\n  \n  uVar1 = pin_num(pin);\n  pGVar2 = gpio(pin);\n  pGVar2->PSOR = 1 << (uVar1 & 0xff);\n  return;\n}\n\n", 
            "called": [
                "pin_num", 
                "gpio"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001ff6", 
            "calling": [
                "board_init"
            ], 
            "imported": false, 
            "current_name": "gpio_set"
        }, 
        "kinetis_mcg_set_fbi": {
            "renaming": {}, 
            "code": "\nvoid kinetis_mcg_set_fbi(void)\n\n{\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_1464);\n  bit_clear8(DAT_000019b4,'\\x01');\n  *DAT_000019b8 = *DAT_000019b8 & 0x3b | 0x44;\n  do {\n  } while ((DAT_000019b8[6] & 0xc) != 4);\n  do {\n  } while ((DAT_000019b8[6] & 0x10) == 0);\n  *PTR_current_mode_000019bc = 2;\n  return;\n}\n\n", 
            "called": [
                "bit_clear8", 
                "kinetis_mcg_set_fll_factor"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001960", 
            "calling": [
                "kinetis_mcg_set_mode"
            ], 
            "imported": false, 
            "current_name": "kinetis_mcg_set_fbi"
        }, 
        "__srefill_r": {
            "renaming": {}, 
            "code": "\nundefined4\n__srefill_r(undefined4 *param_1,undefined4 *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined2 uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  ushort uVar4;\n  uint uVar5;\n  \n  if ((param_1 != (undefined4 *)0x0) && (param_1[6] == 0)) {\n    __sinit();\n  }\n  if (param_2 == (undefined4 *)PTR___sf_fake_stdin_00006868) {\n    param_2 = (undefined4 *)param_1[1];\n  }\n  else if (param_2 == (undefined4 *)PTR___sf_fake_stdout_0000686c) {\n    param_2 = (undefined4 *)param_1[2];\n  }\n  else if (param_2 == (undefined4 *)PTR___sf_fake_stderr_00006870) {\n    param_2 = (undefined4 *)param_1[3];\n  }\n  uVar4 = *(ushort *)(param_2 + 3);\n  param_2[1] = 0;\n  uVar5 = (uint)*(ushort *)(param_2 + 3);\n  if ((int)(uVar5 << 0x1a) < 0) {\n    return 0xffffffff;\n  }\n  if ((int)(uVar5 << 0x1d) < 0) {\n    if ((undefined4 *)param_2[0xd] != (undefined4 *)0x0) {\n      if ((undefined4 *)param_2[0xd] != param_2 + 0x11) {\n        _free_r(param_1);\n      }\n      param_2[1] = param_2[0x10];\n      param_2[0xd] = 0;\n      if (param_2[0x10] != 0) {\n        *param_2 = param_2[0xf];\n        return 0;\n      }\n    }\n  }\n  else {\n    if (-1 < (int)(uVar5 << 0x1b)) {\n      *param_1 = 9;\n      uVar4 = uVar4 | 0x40;\n      goto LAB_000067b8;\n    }\n    if ((int)(uVar5 << 0x1c) < 0) {\n      iVar2 = _fflush_r(param_1,param_2,uVar5 << 0x1c,uVar5,param_4);\n      if (iVar2 != 0) {\n        return 0xffffffff;\n      }\n      param_2[2] = 0;\n      *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xfff7;\n      param_2[6] = 0;\n    }\n    *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 4;\n  }\n  if (param_2[4] == 0) {\n    __smakebuf_r(param_1,param_2);\n  }\n  uVar4 = *(ushort *)(param_2 + 3);\n  uVar1 = *(undefined2 *)(param_2 + 3);\n  if ((uVar4 & 3) != 0) {\n    *(undefined2 *)(param_2 + 3) = 1;\n    _fwalk(*(undefined4 *)PTR__global_impure_ptr_00006874,DAT_00006878);\n    *(undefined2 *)(param_2 + 3) = uVar1;\n    if ((uVar4 & 9) == 9) {\n      __sflush_r(param_1,param_2);\n    }\n  }\n  uVar3 = param_2[4];\n  *param_2 = uVar3;\n  iVar2 = (*(code *)param_2[9])(param_1,param_2[8],uVar3,param_2[5]);\n  param_2[1] = iVar2;\n  if (0 < iVar2) {\n    return 0;\n  }\n  uVar4 = *(ushort *)(param_2 + 3);\n  if (iVar2 != 0) {\n    uVar3 = 0;\n  }\n  else {\n    uVar4 = uVar4 | 0x20;\n  }\n  if (iVar2 != 0) {\n    param_2[1] = uVar3;\n    uVar4 = uVar4 | 0x40;\n  }\nLAB_000067b8:\n  *(ushort *)(param_2 + 3) = uVar4;\n  return 0xffffffff;\n}\n\n", 
            "called": [
                "_fflush_r", 
                "_fwalk", 
                "__sflush_r", 
                "_free_r", 
                "__sinit", 
                "__smakebuf_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00006768", 
            "calling": [
                "__srget_r"
            ], 
            "imported": false, 
            "current_name": "__srefill_r"
        }, 
        "kinetis_mcg_set_fbe": {
            "renaming": {}, 
            "code": "\nvoid kinetis_mcg_set_fbe(void)\n\n{\n  kinetis_mcg_enable_osc();\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_1920);\n  bit_clear8(DAT_00001a0c,'\\x01');\n  *DAT_00001a10 = *DAT_00001a10 & 0x3b | 0x80;\n  do {\n  } while ((DAT_00001a10[6] & 0xc) != 8);\n  kinetis_mcg_disable_pll();\n  *PTR_current_mode_00001a14 = 3;\n  return;\n}\n\n", 
            "called": [
                "kinetis_mcg_disable_pll", 
                "bit_clear8", 
                "kinetis_mcg_set_fll_factor", 
                "kinetis_mcg_enable_osc"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000019c0", 
            "calling": [
                "kinetis_mcg_set_mode"
            ], 
            "imported": false, 
            "current_name": "kinetis_mcg_set_fbe"
        }, 
        "rtc_set_time": {
            "renaming": {}, 
            "code": "\nint rtc_set_time(tm *time)\n\n{\n  uint32_t counter;\n  time_t t;\n  \n  counter = mktime((tm *)time);\n  rtt_set_counter(counter);\n  return 0;\n}\n\n", 
            "called": [
                "mktime", 
                "rtt_set_counter"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002600", 
            "calling": [
                "_rtc_settime"
            ], 
            "imported": false, 
            "current_name": "rtc_set_time"
        }, 
        "__seofread": {
            "renaming": {}, 
            "code": "\nundefined4 __seofread(void)\n\n{\n  return 0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004dea", 
            "calling": [], 
            "imported": false, 
            "current_name": "__seofread"
        }, 
        "__aeabi_idiv0": {
            "renaming": {}, 
            "code": "\nvoid __aeabi_idiv0(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00006cd4", 
            "calling": [
                "__aeabi_ldivmod"
            ], 
            "imported": false, 
            "current_name": "__aeabi_idiv0"
        }, 
        "__ssrefill_r": {
            "renaming": {}, 
            "code": "\nundefined4 __ssrefill_r(undefined4 param_1,undefined4 *param_2)\n\n{\n  if ((undefined4 *)param_2[0xd] != (undefined4 *)0x0) {\n    if ((undefined4 *)param_2[0xd] != param_2 + 0x11) {\n      _free_r();\n    }\n    param_2[1] = param_2[0x10];\n    param_2[0xd] = 0;\n    if (param_2[0x10] != 0) {\n      *param_2 = param_2[0xf];\n      return 0;\n    }\n  }\n  *param_2 = param_2[4];\n  param_2[1] = 0;\n  *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 0x20;\n  return 0xffffffff;\n}\n\n", 
            "called": [
                "_free_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00006192", 
            "calling": [
                "__ssvfiscanf_r"
            ], 
            "imported": false, 
            "current_name": "__ssrefill_r"
        }, 
        "cortexm_isr_end": {
            "renaming": {}, 
            "code": "\nvoid cortexm_isr_end(void)\n\n{\n  if (*(int *)PTR_sched_context_switch_request_000027ac != 0) {\n    thread_yield_higher();\n  }\n  return;\n}\n\n", 
            "called": [
                "thread_yield_higher"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002798", 
            "calling": [
                "isr_rtc"
            ], 
            "imported": false, 
            "current_name": "cortexm_isr_end"
        }, 
        "sched_set_status": {
            "renaming": {}, 
            "code": "\nvoid sched_set_status(thread_t *process,uint status)\n\n{\n  if (status < 9) {\n    if ((8 < process->status) &&\n       (clist_lpop((clist_node_t *)(PTR_sched_runqueues_00000730 + (uint)process->priority * 4)),\n       *(int *)(PTR_sched_runqueues_00000730 + (uint)process->priority * 4) == 0)) {\n      *(uint *)PTR_runqueue_bitcache_00000734 =\n           *(uint *)PTR_runqueue_bitcache_00000734 & ~(1 << process->priority);\n    }\n  }\n  else if (process->status < 9) {\n    clist_rpush((clist_node_t *)(PTR_sched_runqueues_00000730 + (uint)process->priority * 4),\n                &process->rq_entry);\n    *(uint *)PTR_runqueue_bitcache_00000734 =\n         *(uint *)PTR_runqueue_bitcache_00000734 | 1 << process->priority;\n  }\n  process->status = (uint8_t)status;\n  return;\n}\n\n", 
            "called": [
                "clist_lpop", 
                "clist_rpush"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000698", 
            "calling": [
                "sched_task_exit", 
                "thread_create", 
                "_mutex_lock", 
                "mutex_unlock"
            ], 
            "imported": false, 
            "current_name": "sched_set_status"
        }, 
        "bit_clear8": {
            "renaming": {}, 
            "code": "\nvoid bit_clear8(uint8_t *ptr,uint8_t bit)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = (undefined *)bitband_addr(ptr,(uint)bit);\n  *puVar1 = 0;\n  return;\n}\n\n", 
            "called": [
                "bitband_addr"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001710", 
            "calling": [
                "kinetis_mcg_disable_pll", 
                "kinetis_mcg_set_fei", 
                "kinetis_mcg_set_fbe", 
                "kinetis_mcg_init_mcgirclk", 
                "kinetis_mcg_set_pbe", 
                "kinetis_mcg_set_safe_mode", 
                "kinetis_mcg_set_fbi", 
                "kinetis_mcg_enable_osc"
            ], 
            "imported": false, 
            "current_name": "bit_clear8"
        }, 
        "_tzset_unlocked_r": {
            "renaming": {}, 
            "code": "\nvoid _tzset_unlocked_r(undefined4 param_1)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  int iVar4;\n  char *pcVar5;\n  void *__ptr;\n  size_t sVar6;\n  char *pcVar7;\n  int iVar8;\n  int iVar9;\n  ulong uVar10;\n  char cVar11;\n  bool bVar12;\n  ushort *puVar13;\n  int *piVar14;\n  ushort *puVar15;\n  int *piVar16;\n  ushort local_3c;\n  ushort local_3a;\n  ushort local_38;\n  ushort local_36;\n  ushort local_34;\n  ushort local_32;\n  int local_30;\n  char *local_2c [2];\n  \n  iVar4 = __gettzinfo();\n  puVar1 = PTR_prev_tzenv_000053d8;\n  pcVar5 = (char *)_getenv_r(param_1,PTR_DAT_000053d4);\n  puVar2 = PTR_LAB_00007a5e_1_000053e0;\n  if (pcVar5 == (char *)0x0) {\n    *(undefined4 *)PTR__timezone_000053dc = 0;\n    *(undefined4 *)PTR__daylight_000053e4 = 0;\n    puVar3 = PTR__tzname_000053e8;\n    __ptr = *(void **)puVar1;\n    *(undefined **)PTR__tzname_000053e8 = puVar2;\n    *(undefined **)(puVar3 + 4) = puVar2;\n    free(__ptr);\n    *(undefined4 *)puVar1 = 0;\n  }\n  else if ((*(char **)puVar1 == (char *)0x0) ||\n          (iVar8 = strcmp(pcVar5,*(char **)puVar1), iVar8 != 0)) {\n    free(*(void **)puVar1);\n    sVar6 = strlen(pcVar5);\n    pcVar7 = (char *)_malloc_r(param_1,sVar6 + 1);\n    *(char **)puVar1 = pcVar7;\n    if (pcVar7 != (char *)0x0) {\n      strcpy(pcVar7,pcVar5);\n    }\n    if (*pcVar5 == ':') {\n      pcVar5 = pcVar5 + 1;\n    }\n    iVar8 = siscanf(pcVar5,PTR_s__10__0_9_____n_000053f0,PTR___tzname_std_000053ec,&local_30);\n    if (0 < iVar8) {\n      pcVar7 = pcVar5 + local_30;\n      if (pcVar5[local_30] == '-') {\n        pcVar7 = pcVar7 + 1;\n        iVar8 = -1;\n      }\n      else {\n        if (pcVar5[local_30] == '+') {\n          pcVar7 = pcVar7 + 1;\n        }\n        iVar8 = 1;\n      }\n      local_3a = 0;\n      local_38 = 0;\n      puVar13 = &local_3a;\n      piVar14 = &local_30;\n      puVar15 = &local_38;\n      piVar16 = &local_30;\n      iVar9 = siscanf(pcVar7,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a,\n                      &local_30,&local_38,&local_30);\n      puVar1 = PTR___tzname_dst_00005400;\n      if (0 < iVar9) {\n        *(uint *)(iVar4 + 0x28) =\n             ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar8;\n        puVar2 = PTR__tzname_000053e8;\n        *(undefined **)PTR__tzname_000053e8 = PTR___tzname_std_000053ec;\n        pcVar7 = pcVar7 + local_30;\n        iVar8 = siscanf(pcVar7,PTR_s__10__0_9_____n_000053f0,puVar1,&local_30,puVar13,piVar14,\n                        puVar15,piVar16);\n        if (iVar8 < 1) {\n          *(undefined4 *)(puVar2 + 4) = *(undefined4 *)puVar2;\n          *(undefined4 *)PTR__timezone_000053dc = *(undefined4 *)(iVar4 + 0x28);\n          *(undefined4 *)PTR__daylight_000053e4 = 0;\n        }\n        else {\n          *(undefined **)(puVar2 + 4) = puVar1;\n          pcVar5 = pcVar7 + local_30;\n          if (pcVar7[local_30] == '-') {\n            pcVar5 = pcVar5 + 1;\n            iVar8 = -1;\n          }\n          else {\n            if (pcVar7[local_30] == '+') {\n              pcVar5 = pcVar5 + 1;\n            }\n            iVar8 = 1;\n          }\n          local_3c = 0;\n          local_3a = 0;\n          local_38 = 0;\n          local_30 = 0;\n          iVar9 = siscanf(pcVar5,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a,\n                          &local_30,&local_38,&local_30);\n          if (iVar9 < 1) {\n            iVar8 = *(int *)(iVar4 + 0x28) + -0xe10;\n          }\n          else {\n            iVar8 = ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar8;\n          }\n          *(int *)(iVar4 + 0x50) = iVar8;\n          pcVar5 = pcVar5 + local_30;\n          bVar12 = false;\n          iVar8 = iVar4;\n          while( true ) {\n            if (*pcVar5 == ',') {\n              pcVar5 = pcVar5 + 1;\n            }\n            cVar11 = *pcVar5;\n            if (cVar11 == 'M') {\n              iVar9 = siscanf(pcVar5,PTR_s_M_hu_n__hu_n__hu_n_000053f8,&local_36,&local_30,&local_34\n                              ,&local_30,&local_32,&local_30);\n              if (iVar9 != 3) {\n                return;\n              }\n              if (0xb < local_36 - 1) {\n                return;\n              }\n              if (4 < local_34 - 1) {\n                return;\n              }\n              if (6 < local_32) {\n                return;\n              }\n              *(uint *)(iVar8 + 0xc) = (uint)local_36;\n              *(uint *)(iVar8 + 0x10) = (uint)local_34;\n              *(undefined *)(iVar8 + 8) = 0x4d;\n              *(uint *)(iVar8 + 0x14) = (uint)local_32;\n              pcVar7 = pcVar5 + local_30;\n            }\n            else {\n              if (cVar11 == 'J') {\n                pcVar5 = pcVar5 + 1;\n              }\n              else {\n                cVar11 = 'D';\n              }\n              uVar10 = strtoul(pcVar5,local_2c,10);\n              local_32 = (ushort)uVar10;\n              pcVar7 = local_2c[0];\n              if (local_2c[0] == pcVar5) {\n                if (bVar12) {\n                  *(undefined *)(iVar4 + 0x30) = 0x4d;\n                  *(undefined4 *)(iVar4 + 0x34) = 0xb;\n                  *(undefined4 *)(iVar4 + 0x38) = 1;\n                  *(undefined4 *)(iVar4 + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(iVar4 + 8) = 0x4d;\n                  *(undefined4 *)(iVar4 + 0xc) = 3;\n                  *(undefined4 *)(iVar4 + 0x10) = 2;\n                  *(undefined4 *)(iVar4 + 0x14) = 0;\n                }\n              }\n              else {\n                *(char *)(iVar8 + 8) = cVar11;\n                *(ulong *)(iVar8 + 0x14) = uVar10 & 0xffff;\n              }\n            }\n            local_3c = 2;\n            local_3a = 0;\n            local_38 = 0;\n            local_30 = 0;\n            if (*pcVar7 == '/') {\n              siscanf(pcVar7,PTR_DAT_000053fc,&local_3c,&local_30,&local_3a,&local_30,&local_38,\n                      &local_30);\n            }\n            *(uint *)(iVar8 + 0x18) =\n                 (uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38;\n            iVar8 = iVar8 + 0x28;\n            pcVar5 = pcVar7 + local_30;\n            if (bVar12) break;\n            bVar12 = true;\n          }\n          __tzcalc_limits(*(undefined4 *)(iVar4 + 4));\n          iVar8 = *(int *)(iVar4 + 0x28);\n          *(int *)PTR__timezone_000053dc = iVar8;\n          iVar8 = *(int *)(iVar4 + 0x50) - iVar8;\n          if (iVar8 != 0) {\n            iVar8 = 1;\n          }\n          *(int *)PTR__daylight_000053e4 = iVar8;\n        }\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "_malloc_r", 
                "free", 
                "__gettzinfo", 
                "strtoul", 
                "_getenv_r", 
                "strlen", 
                "strcpy", 
                "strcmp", 
                "siscanf", 
                "__tzcalc_limits"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000510c", 
            "calling": [
                "_tzset_unlocked"
            ], 
            "imported": false, 
            "current_name": "_tzset_unlocked_r"
        }, 
        "idle_thread": {
            "renaming": {}, 
            "code": "\nvoid * idle_thread(void *arg)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000f80", 
            "calling": [], 
            "imported": false, 
            "current_name": "idle_thread"
        }, 
        "mutex_unlock": {
            "renaming": {}, 
            "code": "\nvoid mutex_unlock(mutex_t *mutex)\n\n{\n  byte bVar1;\n  uint state;\n  list_node_t *plVar2;\n  uint16_t process_priority;\n  uint irqstate;\n  clist_node_t *__m____;\n  list_node_t *next;\n  thread_t *process;\n  \n  state = irq_disable();\n  if ((mutex->queue).next == (list_node *)0x0) {\n    irq_restore(state);\n  }\n  else if ((mutex->queue).next == (list_node *)0xffffffff) {\n    (mutex->queue).next = (list_node *)0x0;\n    irq_restore(state);\n  }\n  else {\n    plVar2 = list_remove_head(&mutex->queue);\n    sched_set_status((thread_t *)(plVar2 + -2),10);\n    if ((mutex->queue).next == (list_node *)0x0) {\n      (mutex->queue).next = (list_node *)0xffffffff;\n    }\n    bVar1 = *(byte *)((int)&plVar2[-1].next + 1);\n    irq_restore(state);\n    sched_switch((ushort)bVar1);\n  }\n  return;\n}\n\n", 
            "called": [
                "irq_disable", 
                "sched_set_status", 
                "sched_switch", 
                "list_remove_head", 
                "irq_restore"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000024bc", 
            "calling": [
                "isrpipe_write_one"
            ], 
            "imported": false, 
            "current_name": "mutex_unlock"
        }, 
        "__sfputc_r": {
            "renaming": {}, 
            "code": "\nint __sfputc_r(undefined4 param_1,int param_2,undefined4 *param_3)\n\n{\n  int iVar1;\n  undefined *puVar2;\n  \n  iVar1 = param_3[2] + -1;\n  param_3[2] = iVar1;\n  if ((iVar1 < 0) && ((iVar1 < (int)param_3[6] || (param_2 == 10)))) {\n    iVar1 = __swbuf_r();\n    return iVar1;\n  }\n  puVar2 = (undefined *)*param_3;\n  *param_3 = puVar2 + 1;\n  *puVar2 = (char)param_2;\n  return param_2;\n}\n\n", 
            "called": [
                "__swbuf_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000057a8", 
            "calling": [
                "__sfputs_r"
            ], 
            "imported": false, 
            "current_name": "__sfputc_r"
        }, 
        "kinetis_mcg_set_pee": {
            "renaming": {}, 
            "code": "\nvoid kinetis_mcg_set_pee(void)\n\n{\n  *DAT_00001b08 = *DAT_00001b08 & 0x3f;\n  do {\n  } while ((DAT_00001b08[6] & 0xc) != 0xc);\n  *PTR_current_mode_00001b0c = 7;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001ad4", 
            "calling": [
                "kinetis_mcg_set_mode"
            ], 
            "imported": false, 
            "current_name": "kinetis_mcg_set_pee"
        }, 
        "thread_measure_stack_free": {
            "renaming": {}, 
            "code": "\nuintptr_t thread_measure_stack_free(char *stack)\n\n{\n  uintptr_t space_free;\n  uintptr_t *stackp;\n  \n  for (stackp = (uintptr_t *)stack; (uintptr_t *)*stackp == stackp; stackp = stackp + 1) {\n  }\n  return (int)stackp - (int)stack;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000010a0", 
            "calling": [
                "ps"
            ], 
            "imported": false, 
            "current_name": "thread_measure_stack_free"
        }, 
        "free": {
            "renaming": {}, 
            "code": "\nvoid free(void *__ptr)\n\n{\n  _free_r(*(undefined4 *)PTR__impure_ptr_0000578c,__ptr);\n  return;\n}\n\n", 
            "called": [
                "_free_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00005780", 
            "calling": [
                "_tzset_unlocked_r"
            ], 
            "imported": false, 
            "current_name": "free"
        }, 
        "_puts_r": {
            "renaming": {}, 
            "code": "\nundefined4 _puts_r(int param_1,int param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char **ppcVar4;\n  undefined4 uVar5;\n  char *pcVar6;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  ppcVar4 = *(char ***)(param_1 + 8);\n  if (*(int *)(param_1 + 0x18) == 0) {\n    __sinit(param_1);\n  }\n  if (ppcVar4 == (char **)PTR___sf_fake_stdin_00004dac) {\n    ppcVar4 = *(char ***)(param_1 + 4);\n  }\n  else if (ppcVar4 == (char **)PTR___sf_fake_stdout_00004db0) {\n    ppcVar4 = *(char ***)(param_1 + 8);\n  }\n  else if (ppcVar4 == (char **)PTR___sf_fake_stderr_00004db4) {\n    ppcVar4 = *(char ***)(param_1 + 0xc);\n  }\n  if ((-1 < (int)ppcVar4[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(ppcVar4 + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(ppcVar4[0x16]);\n  }\n  if ((((int)((uint)*(ushort *)(ppcVar4 + 3) << 0x1c) < 0) && (ppcVar4[4] != (char *)0x0)) ||\n     (iVar2 = __swsetup_r(param_1,ppcVar4), iVar2 == 0)) {\n    pcVar6 = (char *)(param_2 + -1);\n    do {\n      while( true ) {\n        pcVar6 = pcVar6 + 1;\n        cVar1 = *pcVar6;\n        pcVar3 = ppcVar4[2] + -1;\n        ppcVar4[2] = pcVar3;\n        if (cVar1 == '\\0') {\n          if (-1 < (int)pcVar3) {\n            pcVar6 = *ppcVar4;\n            uVar5 = 10;\n            *ppcVar4 = pcVar6 + 1;\n            *pcVar6 = '\\n';\n            goto LAB_00004d64;\n          }\n          iVar2 = __swbuf_r(param_1,10,ppcVar4);\n          if (iVar2 != -1) {\n            uVar5 = 10;\n            goto LAB_00004d64;\n          }\n          goto LAB_00004d60;\n        }\n        if (((int)pcVar3 < 0) && (((int)pcVar3 < (int)ppcVar4[6] || (cVar1 == '\\n')))) break;\n        pcVar3 = *ppcVar4;\n        *ppcVar4 = pcVar3 + 1;\n        *pcVar3 = cVar1;\n      }\n      iVar2 = __swbuf_r(param_1,cVar1,ppcVar4);\n    } while (iVar2 != -1);\n  }\nLAB_00004d60:\n  uVar5 = 0xffffffff;\nLAB_00004d64:\n  if ((-1 < (int)ppcVar4[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(ppcVar4 + 3) << 0x16))) {\n    __retarget_lock_release_recursive(ppcVar4[0x16]);\n  }\n  return uVar5;\n}\n\n", 
            "called": [
                "__swbuf_r", 
                "__retarget_lock_acquire_recursive", 
                "__swsetup_r", 
                "__retarget_lock_release_recursive", 
                "__sinit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004cdc", 
            "calling": [
                "puts"
            ], 
            "imported": false, 
            "current_name": "_puts_r"
        }, 
        "__sfputs_r": {
            "renaming": {}, 
            "code": "\nint __sfputs_r(undefined4 param_1,undefined4 param_2,undefined *param_3,int param_4)\n\n{\n  int iVar1;\n  undefined *puVar2;\n  int iVar3;\n  \n  puVar2 = param_3 + param_4;\n  iVar3 = param_4;\n  do {\n    if (param_3 == puVar2) {\n      return 0;\n    }\n    iVar1 = __sfputc_r(param_1,*param_3,param_2,param_4,iVar3);\n    param_4 = iVar1 + 1;\n    param_3 = param_3 + 1;\n  } while (param_4 != 0);\n  return iVar1;\n}\n\n", 
            "called": [
                "__sfputc_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000057d2", 
            "calling": [
                "_vfprintf_r"
            ], 
            "imported": false, 
            "current_name": "__sfputs_r"
        }, 
        "__retarget_lock_acquire_recursive": {
            "renaming": {}, 
            "code": "\nvoid __retarget_lock_acquire_recursive(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000045e8", 
            "calling": [
                "__sinit_lock_acquire", 
                "_puts_r", 
                "_fflush_r", 
                "__env_lock", 
                "_getc_r", 
                "__malloc_lock", 
                "__sfp_lock_acquire", 
                "_vfprintf_r", 
                "_putc_r"
            ], 
            "imported": false, 
            "current_name": "__retarget_lock_acquire_recursive"
        }, 
        "gmtime_r": {
            "renaming": {}, 
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000044a8) */\n\ntm * gmtime_r(time_t *__timer,tm *__tp)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  time_t tVar7;\n  time_t tVar8;\n  uint uVar9;\n  bool bVar10;\n  \n  tVar7 = *__timer;\n  tVar8 = __timer[1];\n  iVar1 = __aeabi_ldivmod(tVar7,tVar8,DAT_0000458c,0);\n  uVar3 = DAT_0000458c;\n  __aeabi_ldivmod(tVar7,tVar8,DAT_0000458c,0);\n  bVar10 = (int)uVar3 < 0;\n  if (bVar10) {\n    uVar3 = uVar3 + 0x15180;\n  }\n  if (bVar10) {\n    uVar2 = iVar1 + 0xafa6b;\n  }\n  else {\n    uVar2 = iVar1 + 0xafa6c;\n  }\n  __tp->tm_hour = uVar3 / 0xe10;\n  __tp->tm_min = (uVar3 % 0xe10) / 0x3c;\n  __tp->tm_sec = (uVar3 % 0xe10) % 0x3c;\n  __tp->tm_wday = (uVar2 + 3) % 7;\n  uVar3 = uVar2;\n  if ((int)uVar2 < 0) {\n    uVar3 = uVar2 - 0x23ab0;\n  }\n  uVar2 = DAT_00004594 * (uVar3 / DAT_00004590) + uVar2;\n  uVar4 = ((uVar2 / 0x8eac + uVar2) - uVar2 / 0x5b4) - uVar2 / DAT_00004598;\n  uVar6 = uVar4 / 0x16d;\n  uVar2 = (uVar6 / 100 - uVar4 / 0x5b4) + uVar2 + uVar6 * -0x16d;\n  uVar9 = uVar2 * 5 + 2;\n  uVar4 = uVar9 / 0x99;\n  if (uVar9 < 0x5fa) {\n    iVar1 = 2;\n  }\n  else {\n    iVar1 = -10;\n  }\n  uVar9 = uVar4 + iVar1;\n  iVar1 = (uVar3 / DAT_00004590) * 400 + uVar6;\n  if (uVar9 < 2) {\n    iVar1 = iVar1 + 1;\n  }\n  if (uVar2 < 0x132) {\n    if (((uVar6 & 3) == 0) && (uVar6 != (uVar6 / 100) * 100)) {\n      uVar3 = 1;\n    }\n    else {\n      uVar3 = count_leading_zeroes(uVar6 % 400);\n      uVar3 = uVar3 >> 5;\n    }\n    iVar5 = uVar2 + 0x3b + uVar3;\n  }\n  else {\n    iVar5 = uVar2 - 0x132;\n  }\n  __tp->tm_yday = iVar5;\n  __tp->tm_mday = (uVar2 + 1) - (uVar4 * 0x99 + 2) / 5;\n  __tp->tm_mon = uVar9;\n  __tp->tm_year = iVar1 + -0x76c;\n  __tp->tm_isdst = 0;\n  return __tp;\n}\n\n", 
            "called": [
                "__aeabi_ldivmod"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000443c", 
            "calling": [
                "rtc_get_alarm", 
                "rtc_get_time"
            ], 
            "imported": false, 
            "current_name": "gmtime_r"
        }, 
        "rtc_get_time": {
            "renaming": {}, 
            "code": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nint rtc_get_time(tm *time)\n\n{\n  time_t t;\n  \n  t._0_4_ = rtt_get_counter();\n  t._4_4_ = 0;\n  gmtime_r((time_t *)&t,(tm *)time);\n  return 0;\n}\n\n", 
            "called": [
                "gmtime_r", 
                "rtt_get_counter"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002624", 
            "calling": [
                "_rtc_gettime"
            ], 
            "imported": false, 
            "current_name": "rtc_get_time"
        }, 
        "_putc_r": {
            "renaming": {}, 
            "code": "\nuint _putc_r(int param_1,uint param_2,undefined4 *param_3)\n\n{\n  int iVar1;\n  undefined *puVar2;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_3 == (undefined4 *)PTR___sf_fake_stdin_00005e04) {\n    param_3 = *(undefined4 **)(param_1 + 4);\n  }\n  else if (param_3 == (undefined4 *)PTR___sf_fake_stdout_00005e08) {\n    param_3 = *(undefined4 **)(param_1 + 8);\n  }\n  else if (param_3 == (undefined4 *)PTR___sf_fake_stderr_00005e0c) {\n    param_3 = *(undefined4 **)(param_1 + 0xc);\n  }\n  if ((-1 < (int)(param_3[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(param_3 + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(param_3[0x16]);\n  }\n  iVar1 = param_3[2] + -1;\n  param_3[2] = iVar1;\n  if ((iVar1 < 0) && ((iVar1 < (int)param_3[6] || ((param_2 & 0xff) == 10)))) {\n    param_2 = __swbuf_r(param_1,param_2,param_3);\n  }\n  else {\n    puVar2 = (undefined *)*param_3;\n    *param_3 = puVar2 + 1;\n    *puVar2 = (char)param_2;\n    param_2 = param_2 & 0xff;\n  }\n  if ((-1 < (int)(param_3[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(param_3 + 3) << 0x16))) {\n    __retarget_lock_release_recursive(param_3[0x16]);\n  }\n  return param_2;\n}\n\n", 
            "called": [
                "__swbuf_r", 
                "__retarget_lock_acquire_recursive", 
                "__retarget_lock_release_recursive", 
                "__sinit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00005d80", 
            "calling": [
                "putchar"
            ], 
            "imported": false, 
            "current_name": "_putc_r"
        }, 
        "__ssvfiscanf_r": {
            "renaming": {}, 
            "code": "\nint __ssvfiscanf_r(int param_1,byte **param_2,byte *param_3,int **param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  void *pvVar4;\n  uint uVar5;\n  byte *pbVar6;\n  uint uVar7;\n  int **local_2b0;\n  undefined auStack_2ac [256];\n  uint local_1ac;\n  undefined4 local_1a8;\n  uint local_1a4;\n  int local_1a0;\n  int local_19c;\n  undefined *local_198;\n  int local_194;\n  undefined4 local_30;\n  code *local_2c;\n  \n  puVar2 = PTR_DAT_000064b4;\n  puVar1 = PTR_DAT_000064b0;\n  local_1a0 = 0;\n  local_19c = 0;\n  local_30 = DAT_000064a8;\n  local_2c = DAT_000064ac;\n  local_2b0 = param_4;\n  local_198 = auStack_2ac;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      uVar7 = (uint)*param_3;\n      if (uVar7 == 0) {\n        return local_1a0;\n      }\n      uVar5 = (byte)puVar1[uVar7] & 8;\n      pbVar6 = param_3 + 1;\n      if ((puVar1[uVar7] & 8) == 0) break;\n      while (((param_3 = pbVar6, 0 < (int)param_2[1] ||\n              (iVar3 = (*local_2c)(param_1,param_2), iVar3 == 0)) &&\n             ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0))) {\n        local_19c = local_19c + 1;\n        param_2[1] = param_2[1] + -1;\n        *param_2 = *param_2 + 1;\n      }\n    }\n    if (uVar7 == 0x25) break;\nLAB_00006352:\n    if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n    goto LAB_00006380;\n    if (**param_2 != uVar7) {\n      return local_1a0;\n    }\n    *param_2 = *param_2 + 1;\n    local_19c = local_19c + 1;\n    param_2[1] = param_2[1] + -1;\n    param_3 = pbVar6;\n  }\n  local_1a4 = uVar5;\n  local_1ac = uVar5;\n  if (param_3[1] == 0x2a) {\n    pbVar6 = param_3 + 2;\n    local_1ac = 0x10;\n  }\n  while( true ) {\n    uVar5 = (uint)*pbVar6;\n    if (9 < uVar5 - 0x30) break;\n    pbVar6 = pbVar6 + 1;\n    local_1a4 = (local_1a4 * 10 + uVar5) - 0x30;\n  }\n  pvVar4 = memchr(PTR_DAT_000064b4,uVar5,3);\n  if (pvVar4 != (void *)0x0) {\n    local_1ac = 1 << ((int)pvVar4 - (int)puVar2 & 0xffU) | local_1ac;\n    pbVar6 = pbVar6 + 1;\n  }\n  param_3 = pbVar6 + 1;\n  uVar5 = (uint)*pbVar6;\n  if (uVar5 < 0x79) {\n    if (0x57 < uVar5) {\n      switch(uVar5) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        param_3 = (byte *)__sccl(auStack_2ac,param_3);\n        local_1ac = local_1ac | 0x40;\n        local_194 = 1;\n        break;\n      case 99:\n        local_1ac = local_1ac | 0x40;\n        local_194 = 0;\n        break;\n      case 100:\n      case 0x75:\n        local_1a8 = 10;\nLAB_000063a0:\n        if (uVar5 < 0x6f) {\n          local_194 = 3;\n        }\n        else {\n          local_194 = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        local_194 = 5;\n        break;\n      case 0x69:\n        local_1a8 = 0;\n        local_194 = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(local_1ac << 0x1b)) {\n          if ((int)(local_1ac << 0x1f) < 0) {\n            *(short *)*local_2b0 = (short)local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n          else {\n            **local_2b0 = local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        local_1a8 = 8;\n        local_194 = 4;\n        break;\n      case 0x70:\n        local_1ac = local_1ac | 0x20;\n      case 0x58:\n      case 0x78:\n        local_1ac = local_1ac | 0x200;\n        local_1a8 = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        local_194 = 2;\n      }\nLAB_000063ac:\n      if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(local_1ac << 0x19)) {\n        while ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0) {\n          local_19c = local_19c + 1;\n          pbVar6 = param_2[1];\n          param_2[1] = pbVar6 + -1;\n          if ((int)(pbVar6 + -1) < 1) {\n            iVar3 = (*local_2c)(param_1,param_2);\n            if (iVar3 != 0) goto LAB_00006380;\n          }\n          else {\n            *param_2 = *param_2 + 1;\n          }\n        }\n      }\n      if (local_194 < 3) {\n        iVar3 = _scanf_chars(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else if (local_194 < 5) {\n        iVar3 = _scanf_i(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else {\n        iVar3 = param_1;\n        if (DAT_000064b8 == 0) goto LAB_000061f6;\n      }\n      if (iVar3 == 1) {\n        return local_1a0;\n      }\n      if (iVar3 == 2) {\nLAB_00006380:\n        if (local_1a0 == 0) {\nLAB_00006388:\n          local_1a0 = -1;\n        }\n        else if ((*(ushort *)(param_2 + 3) & 0x40) != 0) {\n          local_1a0 = -1;\n        }\n        return local_1a0;\n      }\n      goto LAB_000061f6;\n    }\n    pbVar6 = param_3;\n    if (uVar5 == 0x25) goto LAB_00006352;\n    if (uVar5 < 0x26) {\n      if (uVar5 != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (uVar5 - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  local_194 = 3;\n  local_1a8 = 10;\n  goto LAB_000063ac;\n}\n\n", 
            "called": [
                "__ssrefill_r", 
                "__sccl", 
                "memchr", 
                "_scanf_chars", 
                "_scanf_i"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000061cc", 
            "calling": [
                "siscanf"
            ], 
            "imported": false, 
            "current_name": "__ssvfiscanf_r"
        }, 
        "bit_clear32": {
            "renaming": {}, 
            "code": "\nvoid bit_clear32(uint32_t *ptr,uint8_t bit)\n\n{\n  undefined4 *puVar1;\n  \n  puVar1 = (undefined4 *)bitband_addr(ptr,(uint)bit);\n  *puVar1 = 0;\n  return;\n}\n\n", 
            "called": [
                "bitband_addr"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000d76", 
            "calling": [
                "cpu_errata_fixes"
            ], 
            "imported": false, 
            "current_name": "bit_clear32"
        }, 
        "core_panic": {
            "renaming": {}, 
            "code": "\nvoid core_panic(core_panic_t crash_code,char *message)\n\n{\n  undefined4 uStack_18;\n  undefined4 uStack_14;\n  char *local_10;\n  core_panic_t local_9;\n  \n  local_10 = message;\n  local_9 = crash_code;\n  if (*(int *)PTR_crashed_00000f4c == 0) {\n    *(undefined4 *)PTR_crashed_00000f4c = 1;\n    if (crash_code == PANIC_ASSERT_FAIL) {\n      cpu_print_last_instruction();\n    }\n    iprintf(PTR_s_____RIOT_kernel_panic___s_00000f50,local_10);\n    ps();\n    iprintf(PTR_DAT_00000f54);\n    iprintf(PTR_s_____halted__00000f58);\n  }\n  irq_disable();\n  panic_arch();\n  uStack_14 = 0xf4d;\n  pm_off();\n  uStack_18 = (int)&uStack_18 + 1;\n  auto_init();\n  iprintf(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n  main();\n  return;\n}\n\n", 
            "called": [
                "panic_arch", 
                "irq_disable", 
                "pm_off", 
                "cpu_print_last_instruction", 
                "ps", 
                "iprintf"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000f04", 
            "calling": [
                "cib_init", 
                "mem_manage_default", 
                "dummy_handler_default", 
                "uart_init", 
                "hard_fault_handler", 
                "usage_fault_default", 
                "fmt_s32_dfp", 
                "debug_mon_default", 
                "nmi_default", 
                "bus_fault_default", 
                "thread_add_to_list"
            ], 
            "imported": false, 
            "current_name": "core_panic"
        }, 
        "memcpy": {
            "renaming": {}, 
            "code": "\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  \n  puVar2 = (undefined *)(__n + (int)__src);\n  puVar3 = (undefined *)((int)__dest + -1);\n  if ((undefined *)__src != puVar2) {\n    do {\n                    /* WARNING: Load size is inaccurate */\n      puVar1 = (undefined *)((int)__src + 1);\n      puVar3 = puVar3 + 1;\n      *puVar3 = *__src;\n      __src = puVar1;\n    } while (puVar1 != puVar2);\n    return __dest;\n  }\n  return __dest;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000060b0", 
            "calling": [
                "__submore", 
                "_realloc_r"
            ], 
            "imported": false, 
            "current_name": "memcpy"
        }, 
        "wdog_disable": {
            "renaming": {}, 
            "code": "\nvoid wdog_disable(void)\n\n{\n  DAT_00000df0[7] = 0xc520;\n  DAT_00000df0[7] = 0xd928;\n  *DAT_00000df0 = 0xd2;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000dcc", 
            "calling": [
                "pre_startup"
            ], 
            "imported": false, 
            "current_name": "wdog_disable"
        }, 
        "mutex_lock": {
            "renaming": {}, 
            "code": "\nvoid mutex_lock(mutex_t *mutex)\n\n{\n  _mutex_lock(mutex,1);\n  return;\n}\n\n", 
            "called": [
                "_mutex_lock"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000129c", 
            "calling": [
                "isrpipe_read"
            ], 
            "imported": false, 
            "current_name": "mutex_lock"
        }, 
        "__sinit_lock_release": {
            "renaming": {}, 
            "code": "\nvoid __sinit_lock_release(void)\n\n{\n  __retarget_lock_release_recursive(PTR___lock___sinit_recursive_mutex_000042a0);\n  return;\n}\n\n", 
            "called": [
                "__retarget_lock_release_recursive"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004298", 
            "calling": [
                "__sinit"
            ], 
            "imported": false, 
            "current_name": "__sinit_lock_release"
        }, 
        "board_init": {
            "renaming": {}, 
            "code": "\nvoid board_init(void)\n\n{\n  *(uint *)(thread_add_to_list + DAT_00000ed0 + 4) =\n       *(uint *)(thread_add_to_list + DAT_00000ed0 + 4) | 0x200;\n  *(uint *)(DAT_00000ed4 + 0x48) = *(uint *)(DAT_00000ed4 + 0x48) & 0xfefff8ff;\n  cpu_init();\n  gpio_init(0x2056,GPIO_OUT);\n  gpio_init(0x511a,GPIO_OUT);\n  gpio_init(0x2055,GPIO_OUT);\n  gpio_set(0x2056);\n  gpio_set(0x511a);\n  gpio_set(0x2055);\n  return;\n}\n\n", 
            "called": [
                "gpio_init", 
                "cpu_init", 
                "gpio_set"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000e64", 
            "calling": [
                "reset_handler_default"
            ], 
            "imported": false, 
            "current_name": "board_init"
        }, 
        "find_handler": {
            "renaming": {}, 
            "code": "\nshell_command_handler_t find_handler(shell_command_t *command_list,char *command)\n\n{\n  int iVar1;\n  shell_command_t *command_lists [2];\n  uint i;\n  shell_command_t *entry;\n  \n  command_lists[0] = command_list;\n  command_lists[1] = (shell_command_t *)PTR__shell_command_list_00002a84;\n  i = 0;\n  do {\n    if (1 < i) {\n      return (shell_command_handler_t)0x0;\n    }\n    entry = command_lists[i];\n    if (entry != (shell_command_t *)0x0) {\n      for (; entry->name != (char *)0x0; entry = entry + 1) {\n        iVar1 = strcmp(entry->name,command);\n        if (iVar1 == 0) {\n          return entry->handler;\n        }\n      }\n    }\n    i = i + 1;\n  } while( true );\n}\n\n", 
            "called": [
                "strcmp"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002a18", 
            "calling": [
                "handle_input_line"
            ], 
            "imported": false, 
            "current_name": "find_handler"
        }, 
        "__tz_lock": {
            "renaming": {}, 
            "code": "\nvoid __tz_lock(void)\n\n{\n  __retarget_lock_acquire(PTR___lock___tz_mutex_000050f0);\n  return;\n}\n\n", 
            "called": [
                "__retarget_lock_acquire"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000050e8", 
            "calling": [
                "mktime"
            ], 
            "imported": false, 
            "current_name": "__tz_lock"
        }, 
        "_init": {
            "renaming": {}, 
            "code": "\nint _init(EVP_PKEY_CTX *ctx)\n\n{\n  uart_stdio_init();\n  return (int)ctx;\n}\n\n", 
            "called": [
                "uart_stdio_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000410", 
            "calling": [
                "__libc_init_array"
            ], 
            "imported": false, 
            "current_name": "_init"
        }, 
        "dummy_handler": {
            "renaming": {}, 
            "code": "\nvoid dummy_handler(void)\n\n{\n  dummy_handler_default();\n  return;\n}\n\n", 
            "called": [
                "dummy_handler_default"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000dc0", 
            "calling": [], 
            "imported": false, 
            "current_name": "dummy_handler"
        }, 
        "__swsetup_r": {
            "renaming": {}, 
            "code": "\nuint __swsetup_r(undefined4 *param_1,undefined4 *param_2)\n\n{\n  ushort uVar1;\n  ushort uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  \n  iVar5 = *(int *)PTR__impure_ptr_00005574;\n  if ((iVar5 != 0) && (*(int *)(iVar5 + 0x18) == 0)) {\n    __sinit(iVar5);\n  }\n  if (param_2 == (undefined4 *)PTR___sf_fake_stdin_00005578) {\n    param_2 = *(undefined4 **)(iVar5 + 4);\n  }\n  else if (param_2 == (undefined4 *)PTR___sf_fake_stdout_0000557c) {\n    param_2 = *(undefined4 **)(iVar5 + 8);\n  }\n  else if (param_2 == (undefined4 *)PTR___sf_fake_stderr_00005580) {\n    param_2 = *(undefined4 **)(iVar5 + 0xc);\n  }\n  uVar3 = (uint)*(ushort *)(param_2 + 3);\n  uVar2 = *(ushort *)(param_2 + 3);\n  if (-1 < (int)(uVar3 << 0x1c)) {\n    if (-1 < (int)(uVar3 << 0x1b)) {\n      *param_1 = 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(uVar3 << 0x1d) < 0) {\n      if ((undefined4 *)param_2[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)param_2[0xd] != param_2 + 0x11) {\n          _free_r(param_1);\n        }\n        param_2[0xd] = 0;\n      }\n      *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xffdb;\n      param_2[1] = 0;\n      *param_2 = param_2[4];\n    }\n    *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 8;\n  }\n  if ((param_2[4] == 0) && ((*(ushort *)(param_2 + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(param_1,param_2);\n  }\n  uVar1 = *(ushort *)(param_2 + 3);\n  uVar3 = (uint)uVar1;\n  uVar2 = *(ushort *)(param_2 + 3);\n  uVar4 = uVar3 & 1;\n  if ((uVar1 & 1) == 0) {\n    if (-1 < (int)(uVar3 << 0x1e)) {\n      uVar4 = param_2[5];\n    }\n    param_2[2] = uVar4;\n  }\n  else {\n    param_2[2] = 0;\n    param_2[6] = -param_2[5];\n  }\n  if (param_2[4] != 0) {\n    return 0;\n  }\n  if ((uVar1 & 0x80) == 0) {\n    return uVar3 & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(param_2 + 3) = uVar2 | 0x40;\n  return 0xffffffff;\n}\n\n", 
            "called": [
                "_free_r", 
                "__sinit", 
                "__smakebuf_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000054a8", 
            "calling": [
                "__swbuf_r", 
                "_puts_r", 
                "_vfprintf_r"
            ], 
            "imported": false, 
            "current_name": "__swsetup_r"
        }, 
        "panic_arch": {
            "renaming": {}, 
            "code": "\nvoid panic_arch(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000ef8", 
            "calling": [
                "core_panic"
            ], 
            "imported": false, 
            "current_name": "panic_arch"
        }, 
        "validate_structure": {
            "renaming": {}, 
            "code": "\nvoid validate_structure(uint *param_1,uint param_2,undefined4 param_3)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  bool bVar6;\n  uint *local_20;\n  uint local_1c;\n  undefined4 uStack_18;\n  \n  local_20 = param_1;\n  local_1c = param_2;\n  uStack_18 = param_3;\n  if (0x3b < *param_1) {\n    div((int)&local_20,*param_1);\n    uVar3 = param_1[1] + (int)local_20;\n    param_1[1] = uVar3;\n    if ((int)local_1c < 0) {\n      uVar3 = uVar3 - 1;\n      *param_1 = local_1c + 0x3c;\n    }\n    else {\n      *param_1 = local_1c;\n    }\n    if ((int)local_1c < 0) {\n      param_1[1] = uVar3;\n    }\n  }\n  if (0x3b < param_1[1]) {\n    div((int)&local_20,param_1[1]);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[2] + (int)local_20;\n    param_1[2] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x3c;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar4;\n    }\n  }\n  if (0x17 < param_1[2]) {\n    div((int)&local_20,param_1[2]);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[3] + (int)local_20;\n    param_1[3] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x18;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[3] = uVar4;\n    }\n  }\n  if (0xb < param_1[4]) {\n    div((int)&local_20,param_1[4]);\n    bVar6 = (int)local_1c < 0;\n    uVar3 = param_1[5] + (int)local_20;\n    param_1[5] = uVar3;\n    if (bVar6) {\n      local_1c = local_1c + 0xc;\n      uVar3 = uVar3 - 1;\n    }\n    if (!bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[5] = uVar3;\n    }\n  }\n  puVar1 = PTR_DAYS_IN_MONTH_000047e0;\n  uVar3 = param_1[5];\n  if ((uVar3 & 3) == 0) {\n    if (uVar3 == (uVar3 / 100) * 100) {\n      if ((uVar3 + 0x76c) % 400 == 0) {\n        iVar5 = 0x1d;\n      }\n      else {\n        iVar5 = 0x1c;\n      }\n    }\n    else {\n      iVar5 = 0x1d;\n    }\n  }\n  else {\n    iVar5 = 0x1c;\n  }\n  if ((int)param_1[3] < 1) {\n    while ((int)param_1[3] < 1) {\n      uVar3 = param_1[4];\n      param_1[4] = uVar3 - 1;\n      if (uVar3 - 1 == 0xffffffff) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 - 1;\n        param_1[4] = 0xb;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 == (uVar3 / 100) * 100) {\n            if ((uVar4 + 0x76b) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n      iVar2 = iVar5;\n      if (param_1[4] != 1) {\n        iVar2 = *(int *)(puVar1 + param_1[4] * 4);\n      }\n      param_1[3] = iVar2 + param_1[3];\n    }\n  }\n  else {\n    while( true ) {\n      uVar3 = param_1[4];\n      iVar2 = iVar5;\n      if (uVar3 != 1) {\n        iVar2 = *(int *)(puVar1 + uVar3 * 4);\n      }\n      if ((int)param_1[3] <= iVar2) break;\n      param_1[3] = param_1[3] - iVar2;\n      param_1[4] = uVar3 + 1;\n      if (uVar3 + 1 == 0xc) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 + 1;\n        param_1[4] = 0;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 % 100 == 0) {\n            if ((uVar4 + 0x76d) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "div"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004634", 
            "calling": [
                "mktime"
            ], 
            "imported": false, 
            "current_name": "validate_structure"
        }, 
        "context_restore": {
            "renaming": {}, 
            "code": "\nvoid context_restore(void)\n\n{\n  bool bVar1;\n  code *UNRECOVERED_JUMPTABLE;\n  code **ppcVar2;\n  \n  UNRECOVERED_JUMPTABLE = *(code **)**(undefined4 **)PTR_sched_active_thread_0000098c;\n  ppcVar2 = (code **)**(undefined4 **)PTR_sched_active_thread_0000098c + 9;\n  bVar1 = (bool)isCurrentModePrivileged();\n  if (bVar1) {\n    setProcessStackPointer(ppcVar2);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)(UNRECOVERED_JUMPTABLE,ppcVar2);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000978", 
            "calling": [], 
            "imported": false, 
            "current_name": "context_restore"
        }, 
        "shell_run": {
            "renaming": {}, 
            "code": "\nvoid shell_run(shell_command_t *shell_commands,char *line_buf,int len)\n\n{\n  int iVar1;\n  int res;\n  \n  print_prompt();\n  do {\n    iVar1 = readline(line_buf,len);\n    if (iVar1 == 0) {\n      handle_input_line(shell_commands,line_buf);\n    }\n    print_prompt();\n  } while( true );\n}\n\n", 
            "called": [
                "handle_input_line", 
                "readline", 
                "print_prompt"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002e6c", 
            "calling": [
                "main"
            ], 
            "imported": false, 
            "current_name": "shell_run"
        }, 
        "_rtc_setalarm": {
            "renaming": {}, 
            "code": "\nint _rtc_setalarm(char **argv)\n\n{\n  int iVar1;\n  tm now;\n  \n  iVar1 = _parse_time(argv,&now);\n  if (iVar1 == 0) {\n    iVar1 = rtc_set_alarm(&now,DAT_0000343c,(void *)0x0);\n    if (iVar1 == -1) {\n      puts(PTR_s_rtc__error_setting_alarm_00003440);\n      iVar1 = 1;\n    }\n    else {\n      iVar1 = 0;\n    }\n  }\n  else {\n    iVar1 = 1;\n  }\n  return iVar1;\n}\n\n", 
            "called": [
                "puts", 
                "rtc_set_alarm", 
                "_parse_time"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000033f4", 
            "calling": [
                "_rtc_handler"
            ], 
            "imported": false, 
            "current_name": "_rtc_setalarm"
        }, 
        "__malloc_lock": {
            "renaming": {}, 
            "code": "\nvoid __malloc_lock(void)\n\n{\n  __retarget_lock_acquire_recursive(PTR___lock___malloc_recursive_mutex_00005798);\n  return;\n}\n\n", 
            "called": [
                "__retarget_lock_acquire_recursive"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00005790", 
            "calling": [
                "_malloc_r", 
                "_free_r"
            ], 
            "imported": false, 
            "current_name": "__malloc_lock"
        }, 
        "NVIC_EnableIRQ": {
            "renaming": {}, 
            "code": "\nvoid NVIC_EnableIRQ(IRQn_Type IRQn)\n\n{\n  *(int *)(DAT_00002740 + ((uint)(int)IRQn >> 5) * 4) = 1 << (IRQn & 0x1fU);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002714", 
            "calling": [
                "rtt_set_alarm"
            ], 
            "imported": false, 
            "current_name": "NVIC_EnableIRQ"
        }, 
        "dummy_handler_default": {
            "renaming": {}, 
            "code": "\nvoid dummy_handler_default(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  core_panic(PANIC_DUMMY_HANDLER,PTR_s_DUMMY_HANDLER_00000ccc);\n}\n\n", 
            "called": [
                "core_panic"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000cc0", 
            "calling": [
                "dummy_handler"
            ], 
            "imported": false, 
            "current_name": "dummy_handler_default"
        }, 
        "div": {
            "renaming": {}, 
            "code": "\ndiv_t div(int __numer,int __denom)\n\n{\n  uint in_r2;\n  int iVar1;\n  uint uVar2;\n  \n  uVar2 = (uint)__denom / in_r2;\n  iVar1 = __denom - in_r2 * uVar2;\n  if (__denom < 0) {\n    if (0 < iVar1) {\n      uVar2 = uVar2 - 1;\n      iVar1 = iVar1 + in_r2;\n    }\n  }\n  else if (iVar1 < 0) {\n    uVar2 = uVar2 + 1;\n    iVar1 = iVar1 - in_r2;\n  }\n  *(uint *)__numer = uVar2;\n  *(int *)(__numer + 4) = iVar1;\n  return (div_t)CONCAT44(__denom,__numer);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00005584", 
            "calling": [
                "validate_structure"
            ], 
            "imported": false, 
            "current_name": "div"
        }, 
        "strlen": {
            "renaming": {}, 
            "code": "\nsize_t strlen(char *__s)\n\n{\n  char cVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  pcVar3 = __s;\n  do {\n    pcVar2 = pcVar3 + 1;\n    cVar1 = *pcVar3;\n    pcVar3 = pcVar2;\n  } while (cVar1 != '\\0');\n  return (size_t)(pcVar2 + (-1 - (int)__s));\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00005ecc", 
            "calling": [
                "_tzset_unlocked_r", 
                "siscanf"
            ], 
            "imported": false, 
            "current_name": "strlen"
        }, 
        "phydat_unit_to_str": {
            "renaming": {}, 
            "code": "\nchar * phydat_unit_to_str(uint8_t unit)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = PTR_DAT_00003914;\n  switch(unit) {\n  case '\\x02':\n    pcVar1 = PTR_DAT_000038cc;\n    break;\n  case '\\x03':\n    pcVar1 = PTR_DAT_000038d0;\n    break;\n  case '\\x04':\n    pcVar1 = PTR_DAT_000038d4;\n    break;\n  case '\\x05':\n    pcVar1 = PTR_PTR_s_R_000038d8;\n    break;\n  case '\\x06':\n    pcVar1 = PTR_DAT_000038dc;\n    break;\n  case '\\a':\n    pcVar1 = PTR_DAT_000038e0;\n    break;\n  case '\\b':\n    pcVar1 = PTR_DAT_000038e4;\n    break;\n  case '\\t':\n    pcVar1 = PTR_DAT_000038e8;\n    break;\n  case '\\n':\n    pcVar1 = PTR_DAT_000038ec;\n    break;\n  case '\\v':\n    pcVar1 = PTR_DAT_000038f0;\n    break;\n  case '\\f':\n    pcVar1 = PTR_DAT_000038f4;\n    break;\n  case '\\r':\n    pcVar1 = PTR_DAT_000038f8;\n    break;\n  case '\\x0e':\n    pcVar1 = PTR_DAT_000038fc;\n    break;\n  case '\\x0f':\n    pcVar1 = PTR_DAT_00003900;\n    break;\n  case '\\x10':\n    pcVar1 = PTR_DAT_00003904;\n    break;\n  case '\\x11':\n    pcVar1 = PTR_DAT_0000390c;\n    break;\n  case '\\x13':\n    pcVar1 = PTR_DAT_00003910;\n    break;\n  case '\\x15':\n    pcVar1 = PTR_DAT_00003908;\n  }\n  return pcVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00003810", 
            "calling": [
                "phydat_dump"
            ], 
            "imported": false, 
            "current_name": "phydat_unit_to_str"
        }, 
        "_push": {
            "renaming": {}, 
            "code": "\nvoid _push(tsrb_t *rb,char c)\n\n{\n  uint uVar1;\n  \n  uVar1 = rb->writes;\n  rb->writes = uVar1 + 1;\n  rb->buf[uVar1 & rb->size - 1] = c;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000022be", 
            "calling": [
                "tsrb_add_one"
            ], 
            "imported": false, 
            "current_name": "_push"
        }, 
        "_close_r": {
            "renaming": {}, 
            "code": "\nint _close_r(_reent *r,int fd)\n\n{\n  r->_errno = 0x13;\n  return -1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000004d4", 
            "calling": [
                "__sclose"
            ], 
            "imported": false, 
            "current_name": "_close_r"
        }, 
        "_sbrk_r": {
            "renaming": {}, 
            "code": "\nvoid * _sbrk_r(_reent *r,ptrdiff_t incr)\n\n{\n  uint state_00;\n  uint state;\n  void *res;\n  \n  state_00 = irq_disable();\n  res = *(void **)PTR_heap_top_00000484;\n  if ((PTR__eram_00000488 < (undefined *)(incr + *(int *)PTR_heap_top_00000484)) ||\n     ((undefined *)(incr + *(int *)PTR_heap_top_00000484) < PTR__sheap_0000048c)) {\n    r->_errno = 0xc;\n    res = (void *)0xffffffff;\n  }\n  else {\n    *(ptrdiff_t *)PTR_heap_top_00000484 = incr + *(int *)PTR_heap_top_00000484;\n  }\n  irq_restore(state_00);\n  return res;\n}\n\n", 
            "called": [
                "irq_disable", 
                "irq_restore"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000428", 
            "calling": [
                "_malloc_r"
            ], 
            "imported": false, 
            "current_name": "_sbrk_r"
        }, 
        "_read_r": {
            "renaming": {}, 
            "code": "\n_ssize_t _read_r(_reent *r,int fd,void *buffer,size_t count)\n\n{\n  int iVar1;\n  \n  iVar1 = uart_stdio_read((char *)buffer,count);\n  return iVar1;\n}\n\n", 
            "called": [
                "uart_stdio_read"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000490", 
            "calling": [
                "__sread"
            ], 
            "imported": false, 
            "current_name": "_read_r"
        }, 
        "bus_fault_default": {
            "renaming": {}, 
            "code": "\nvoid bus_fault_default(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  core_panic(PANIC_BUS_FAULT,PTR_s_BUS_FAULT_HANDLER_00000c9c);\n}\n\n", 
            "called": [
                "core_panic"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000c90", 
            "calling": [], 
            "imported": false, 
            "current_name": "bus_fault_default"
        }, 
        "auto_init": {
            "renaming": {}, 
            "code": "\nvoid auto_init(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002400", 
            "calling": [
                "main_trampoline"
            ], 
            "imported": false, 
            "current_name": "auto_init"
        }, 
        "__libc_init_array": {
            "renaming": {}, 
            "code": "\nvoid __libc_init_array(EVP_PKEY_CTX *param_1)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  code **ppcVar4;\n  int iVar5;\n  \n  iVar3 = (int)PTR___fini_array_end_000045d8 - (int)PTR___fini_array_end_000045d4;\n  ppcVar4 = (code **)PTR___fini_array_end_000045d4;\n  for (iVar5 = 0; puVar2 = PTR___fini_array_end_000045e0, puVar1 = PTR___fini_array_end_000045dc,\n      iVar5 != iVar3 >> 2; iVar5 = iVar5 + 1) {\n    param_1 = (EVP_PKEY_CTX *)(**ppcVar4)();\n    ppcVar4 = ppcVar4 + 1;\n  }\n  _init(param_1);\n  ppcVar4 = (code **)puVar1;\n  for (iVar3 = 0; iVar3 != (int)puVar2 - (int)puVar1 >> 2; iVar3 = iVar3 + 1) {\n    (**ppcVar4)();\n    ppcVar4 = ppcVar4 + 1;\n  }\n  return;\n}\n\n", 
            "called": [
                "_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000459c", 
            "calling": [
                "reset_handler_default"
            ], 
            "imported": false, 
            "current_name": "__libc_init_array"
        }, 
        "pm_reboot": {
            "renaming": {}, 
            "code": "\nvoid pm_reboot(void)\n\n{\n  NVIC_SystemReset();\n  return;\n}\n\n", 
            "called": [
                "NVIC_SystemReset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00003688", 
            "calling": [
                "_reboot_handler"
            ], 
            "imported": false, 
            "current_name": "pm_reboot"
        }, 
        "kinetis_mcg_set_pbe": {
            "renaming": {}, 
            "code": "\nvoid kinetis_mcg_set_pbe(void)\n\n{\n  bit_clear8(DAT_00001ac4,'\\x01');\n  *DAT_00001ac8 = *DAT_00001ac8 & 0x3f | 0x80;\n  do {\n  } while ((DAT_00001ac8[6] & 0xc) != 8);\n  bit_set8(DAT_00001acc,'\\x06');\n  do {\n  } while ((DAT_00001ac8[6] & 0x20) == 0);\n  do {\n  } while ((DAT_00001ac8[6] & 0x40) == 0);\n  *PTR_current_mode_00001ad0 = 6;\n  return;\n}\n\n", 
            "called": [
                "bit_set8", 
                "bit_clear8"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001a60", 
            "calling": [
                "kinetis_mcg_set_mode"
            ], 
            "imported": false, 
            "current_name": "kinetis_mcg_set_pbe"
        }, 
        "cpu_init": {
            "renaming": {}, 
            "code": "\nvoid cpu_init(void)\n\n{\n  cortexm_init();\n  *DAT_00001298 = *DAT_00001298 | 0x28;\n  kinetis_mcg_init();\n  periph_init();\n  return;\n}\n\n", 
            "called": [
                "cortexm_init", 
                "periph_init", 
                "kinetis_mcg_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001274", 
            "calling": [
                "board_init"
            ], 
            "imported": false, 
            "current_name": "cpu_init"
        }, 
        "__sclose": {
            "renaming": {}, 
            "code": "\nvoid __sclose(_reent *param_1,int param_2)\n\n{\n  _close_r(param_1,(int)*(short *)(param_2 + 0xe));\n  return;\n}\n\n", 
            "called": [
                "_close_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004e4a", 
            "calling": [], 
            "imported": false, 
            "current_name": "__sclose"
        }, 
        "kinetis_mcg_enable_osc": {
            "renaming": {}, 
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0000179c) */\n/* WARNING: Removing unreachable block (ram,0x000017b2) */\n/* WARNING: Removing unreachable block (ram,0x000017c0) */\n\nvoid kinetis_mcg_enable_osc(void)\n\n{\n  *(byte *)(DAT_000017d0 + 1) = *(byte *)(DAT_000017d0 + 1) & 0xcf | 0x20;\n  bit_clear8(DAT_000017d8,'\\x02');\n  return;\n}\n\n", 
            "called": [
                "bit_set8", 
                "bit_clear8"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001778", 
            "calling": [
                "kinetis_mcg_set_fbe", 
                "kinetis_mcg_set_fee"
            ], 
            "imported": false, 
            "current_name": "kinetis_mcg_enable_osc"
        }, 
        "NVIC_SystemReset": {
            "renaming": {}, 
            "code": "\nvoid NVIC_SystemReset(void)\n\n{\n  DataSynchronizationBarrier(0xf);\n  *(uint *)(DAT_00003680 + 0xc) = DAT_00003684 | *(uint *)(DAT_00003680 + 0xc) & 0x700;\n  DataSynchronizationBarrier(0xf);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00003658", 
            "calling": [
                "pm_reboot"
            ], 
            "imported": false, 
            "current_name": "NVIC_SystemReset"
        }, 
        "list": {
            "renaming": {}, 
            "code": "\nvoid list(void)\n\n{\n  char *pcVar1;\n  int i;\n  saul_reg_t *dev;\n  \n  dev = *(saul_reg_t **)PTR_saul_reg_00002fd0;\n  i = 0;\n  if (dev == (saul_reg_t *)0x0) {\n    puts(PTR_s_No_devices_found_00002fd8);\n  }\n  else {\n    puts(PTR_s_ID_Class_Name_00002fd4);\n  }\n  for (; dev != (saul_reg_t *)0x0; dev = dev->next) {\n    pcVar1 = saul_class_to_str(dev->driver->type);\n    iprintf(PTR_s___i__s__s_00002fdc,i,pcVar1,dev->name);\n    i = i + 1;\n  }\n  return;\n}\n\n", 
            "called": [
                "puts", 
                "iprintf", 
                "saul_class_to_str"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002f74", 
            "calling": [
                "_saul"
            ], 
            "imported": false, 
            "current_name": "list"
        }, 
        "isr_porta": {
            "renaming": {}, 
            "code": "\nvoid isr_porta(void)\n\n{\n  irq_handler(DAT_000020c8,0);\n  return;\n}\n\n", 
            "called": [
                "irq_handler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000020b8", 
            "calling": [], 
            "imported": false, 
            "current_name": "isr_porta"
        }, 
        "isr_portc": {
            "renaming": {}, 
            "code": "\nvoid isr_portc(void)\n\n{\n  irq_handler(DAT_000020f0,2);\n  return;\n}\n\n", 
            "called": [
                "irq_handler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000020e0", 
            "calling": [], 
            "imported": false, 
            "current_name": "isr_portc"
        }, 
        "isr_portb": {
            "renaming": {}, 
            "code": "\nvoid isr_portb(void)\n\n{\n  irq_handler(DAT_000020dc,1);\n  return;\n}\n\n", 
            "called": [
                "irq_handler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000020cc", 
            "calling": [], 
            "imported": false, 
            "current_name": "isr_portb"
        }, 
        "isr_porte": {
            "renaming": {}, 
            "code": "\nvoid isr_porte(void)\n\n{\n  irq_handler(DAT_00002118,4);\n  return;\n}\n\n", 
            "called": [
                "irq_handler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002108", 
            "calling": [], 
            "imported": false, 
            "current_name": "isr_porte"
        }, 
        "port": {
            "renaming": {}, 
            "code": "\nPORT_Type * port(gpio_t pin)\n\n{\n  return (PORT_Type *)(pin & 0x7000 | 0x40048000);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001d5e", 
            "calling": [
                "gpio_init", 
                "gpio_init_port"
            ], 
            "imported": false, 
            "current_name": "port"
        }, 
        "isr_portd": {
            "renaming": {}, 
            "code": "\nvoid isr_portd(void)\n\n{\n  irq_handler(DAT_00002104,3);\n  return;\n}\n\n", 
            "called": [
                "irq_handler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000020f4", 
            "calling": [], 
            "imported": false, 
            "current_name": "isr_portd"
        }, 
        "_stack_size_left": {
            "renaming": {}, 
            "code": "\nint _stack_size_left(uint32_t required)\n\n{\n  undefined auStack_18 [12];\n  uint32_t *sp;\n  \n  return (int)(auStack_18 + (-(int)PTR_isr_stack_00000a60 - required));\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000a40", 
            "calling": [
                "hard_fault_handler"
            ], 
            "imported": false, 
            "current_name": "_stack_size_left"
        }, 
        "_isatty_r": {
            "renaming": {}, 
            "code": "\nint _isatty_r(_reent *r,int fd)\n\n{\n  int iVar1;\n  \n  r->_errno = 0;\n  if (((fd == 0) || (fd == 1)) || (fd == 2)) {\n    iVar1 = 1;\n  }\n  else {\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000534", 
            "calling": [
                "__smakebuf_r"
            ], 
            "imported": false, 
            "current_name": "_isatty_r"
        }, 
        "aflCall": {
            "renaming": {}, 
            "code": "\nuint32_t aflCall(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000023c8", 
            "calling": [
                "startForkserver"
            ], 
            "imported": false, 
            "current_name": "aflCall"
        }, 
        "uart_init_pins": {
            "renaming": {}, 
            "code": "\nvoid uart_init_pins(uart_t uart)\n\n{\n  if (*(short *)(PTR_uart_config_000014c0 + uart * 0x20 + 8) != -1) {\n    gpio_init_port(*(gpio_t *)(PTR_uart_config_000014c0 + uart * 0x20 + 8),\n                   *(uint32_t *)(PTR_uart_config_000014c0 + uart * 0x20 + 0xc));\n  }\n  if (*(short *)(PTR_uart_config_000014c0 + uart * 0x20 + 10) != -1) {\n    gpio_init_port(*(gpio_t *)(PTR_uart_config_000014c0 + uart * 0x20 + 10),\n                   *(uint32_t *)(PTR_uart_config_000014c0 + uart * 0x20 + 0x10));\n  }\n  return;\n}\n\n", 
            "called": [
                "gpio_init_port"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001448", 
            "calling": [
                "uart_init"
            ], 
            "imported": false, 
            "current_name": "uart_init_pins"
        }, 
        "__sread": {
            "renaming": {}, 
            "code": "\nvoid __sread(_reent *param_1,int param_2,void *param_3,size_t param_4)\n\n{\n  _ssize_t _Var1;\n  uint uVar2;\n  bool bVar3;\n  \n  _Var1 = _read_r(param_1,(int)*(short *)(param_2 + 0xe),param_3,param_4);\n  bVar3 = -1 < _Var1;\n  if (bVar3) {\n    uVar2 = *(int *)(param_2 + 0x54) + _Var1;\n  }\n  else {\n    uVar2 = *(ushort *)(param_2 + 0xc) & 0xffffefff;\n  }\n  if (bVar3) {\n    *(uint *)(param_2 + 0x54) = uVar2;\n  }\n  if (!bVar3) {\n    *(short *)(param_2 + 0xc) = (short)uVar2;\n  }\n  return;\n}\n\n", 
            "called": [
                "_read_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004dc8", 
            "calling": [], 
            "imported": false, 
            "current_name": "__sread"
        }, 
        "clist_rpush": {
            "renaming": {}, 
            "code": "\nvoid clist_rpush(clist_node_t *list,clist_node_t *new_node)\n\n{\n  if (list->next == (list_node *)0x0) {\n    new_node->next = new_node;\n  }\n  else {\n    new_node->next = list->next->next;\n    list->next->next = new_node;\n  }\n  list->next = new_node;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000058e", 
            "calling": [
                "sched_set_status"
            ], 
            "imported": false, 
            "current_name": "clist_rpush"
        }, 
        "rtc_set_alarm": {
            "renaming": {}, 
            "code": "\nint rtc_set_alarm(tm *time,rtc_alarm_cb_t cb,void *arg)\n\n{\n  uint32_t alarm;\n  time_t t;\n  \n  alarm = mktime((tm *)time);\n  *(rtc_alarm_cb_t *)PTR_rtc_callback_00002688 = cb;\n  rtt_set_alarm(alarm,DAT_0000268c,arg);\n  return 0;\n}\n\n", 
            "called": [
                "mktime", 
                "rtt_set_alarm"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002654", 
            "calling": [
                "_rtc_setalarm"
            ], 
            "imported": false, 
            "current_name": "rtc_set_alarm"
        }, 
        "rtc_poweron": {
            "renaming": {}, 
            "code": "\nvoid rtc_poweron(void)\n\n{\n  rtt_poweron();\n  return;\n}\n\n", 
            "called": [
                "rtt_poweron"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000026d8", 
            "calling": [
                "_rtc_handler"
            ], 
            "imported": false, 
            "current_name": "rtc_poweron"
        }, 
        "_write_r": {
            "renaming": {}, 
            "code": "\n_ssize_t _write_r(_reent *r,int fd,void *data,size_t count)\n\n{\n  int iVar1;\n  \n  iVar1 = uart_stdio_write((char *)data,count);\n  return iVar1;\n}\n\n", 
            "called": [
                "uart_stdio_write"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000004b2", 
            "calling": [
                "__swrite"
            ], 
            "imported": false, 
            "current_name": "_write_r"
        }, 
        "uart_init_uart": {
            "renaming": {}, 
            "code": "\nvoid uart_init_uart(uart_t uart,uint32_t baudrate)\n\n{\n  byte *pbVar1;\n  uint uVar2;\n  uint uVar3;\n  uint8_t txfifo_size;\n  uint8_t brfa;\n  uint16_t ubd;\n  uint32_t clk;\n  UART_Type *dev;\n  \n  pbVar1 = *(byte **)(PTR_uart_config_000015cc + uart * 0x20);\n  uVar2 = *(uint *)(PTR_uart_config_000015cc + uart * 0x20 + 4);\n  pbVar1[3] = pbVar1[3] & 0xf3;\n  pbVar1[2] = PTR_uart_config_000015cc[uart * 0x20 + 0x1d];\n  uVar3 = uVar2 / (baudrate << 4);\n  *pbVar1 = (byte)(uVar3 >> 8) & 0x1f;\n  pbVar1[1] = (byte)uVar3;\n  pbVar1[10] = (byte)((uVar2 << 2) / baudrate + 1 >> 1) & 0x1f;\n  pbVar1[0x10] = pbVar1[0x10] | 0x88;\n  if ((pbVar1[0x10] & 0x70) == 0) {\n    pbVar1[0x13] = 0;\n  }\n  else {\n    pbVar1[0x13] = (char)(2 << (pbVar1[0x10] >> 4 & 7)) - 1;\n  }\n  pbVar1[0x15] = 1;\n  pbVar1[0x11] = 0xc0;\n  pbVar1[3] = pbVar1[3] | 0x2c;\n  NVIC_EnableIRQ(PTR_uart_config_000015cc[uart * 0x20 + 0x14]);\n  return;\n}\n\n", 
            "called": [
                "NVIC_EnableIRQ"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000014c4", 
            "calling": [
                "uart_init"
            ], 
            "imported": false, 
            "current_name": "uart_init_uart"
        }, 
        "write_map": {
            "renaming": {}, 
            "code": "\nvoid write_map(int port,int pin,int ctx)\n\n{\n  int iVar1;\n  \n  iVar1 = pin >> 3;\n  *(uint *)(PTR_isr_map_00001ec0 + (iVar1 + port * 4) * 4) =\n       *(uint *)(PTR_isr_map_00001ec0 + (iVar1 + port * 4) * 4) & ~(0xf << ((pin & 7U) << 2));\n  *(uint *)(PTR_isr_map_00001ec0 + (iVar1 + port * 4) * 4) =\n       *(uint *)(PTR_isr_map_00001ec0 + (iVar1 + port * 4) * 4) | ctx << ((pin & 7U) << 2);\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001e44", 
            "calling": [
                "ctx_clear"
            ], 
            "imported": false, 
            "current_name": "write_map"
        }, 
        "gpio_init": {
            "renaming": {}, 
            "code": "\nint gpio_init(gpio_t pin,gpio_mode_t mode)\n\n{\n  uint uVar1;\n  GPIO_Type *pGVar2;\n  PORT_Type *pPVar3;\n  int iVar4;\n  \n  gpio_init_port(pin,0);\n  if (mode < GPIO_IN) {\n    uVar1 = pin_num(pin);\n    pGVar2 = gpio(pin);\n    pGVar2->PDDR = pGVar2->PDDR | 1 << (uVar1 & 0xff);\n  }\n  else {\n    uVar1 = pin_num(pin);\n    pGVar2 = gpio(pin);\n    pGVar2->PDDR = pGVar2->PDDR & ~(1 << (uVar1 & 0xff));\n  }\n  pPVar3 = port(pin);\n  iVar4 = pin_num(pin);\n  pPVar3->PCR[iVar4] = (byte)mode & 0x23 | 0x100;\n  return 0;\n}\n\n", 
            "called": [
                "port", 
                "gpio_init_port", 
                "pin_num", 
                "gpio"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001eea", 
            "calling": [
                "board_init"
            ], 
            "imported": false, 
            "current_name": "gpio_init"
        }, 
        "isr_pendsv": {
            "renaming": {}, 
            "code": "\nvoid isr_pendsv(void)\n\n{\n  bool bVar1;\n  int iVar2;\n  code *UNRECOVERED_JUMPTABLE;\n  undefined4 unaff_r4;\n  undefined4 unaff_r5;\n  undefined4 unaff_r6;\n  undefined4 unaff_r7;\n  undefined4 unaff_r8;\n  undefined4 unaff_r9;\n  undefined4 unaff_r10;\n  undefined4 unaff_r11;\n  undefined4 in_lr;\n  code **ppcVar3;\n  \n  iVar2 = getProcessStackPointer();\n  *(undefined4 *)(iVar2 + -4) = unaff_r11;\n  *(undefined4 *)(iVar2 + -8) = unaff_r10;\n  *(undefined4 *)(iVar2 + -0xc) = unaff_r9;\n  *(undefined4 *)(iVar2 + -0x10) = unaff_r8;\n  *(undefined4 *)(iVar2 + -0x14) = unaff_r7;\n  *(undefined4 *)(iVar2 + -0x18) = unaff_r6;\n  *(undefined4 *)(iVar2 + -0x1c) = unaff_r5;\n  *(undefined4 *)(iVar2 + -0x20) = unaff_r4;\n  *(undefined4 *)(iVar2 + -0x24) = in_lr;\n  **(int **)PTR_sched_active_thread_00000970 = (int)(undefined4 *)(iVar2 + -0x24);\n  isr_svc();\n  sched_run();\n  UNRECOVERED_JUMPTABLE = *(code **)**(undefined4 **)PTR_sched_active_thread_0000098c;\n  ppcVar3 = (code **)**(undefined4 **)PTR_sched_active_thread_0000098c + 9;\n  bVar1 = (bool)isCurrentModePrivileged();\n  if (bVar1) {\n    setProcessStackPointer(ppcVar3);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)(UNRECOVERED_JUMPTABLE,ppcVar3);\n  return;\n}\n\n", 
            "called": [
                "isr_svc"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000958", 
            "calling": [], 
            "imported": false, 
            "current_name": "isr_pendsv"
        }, 
        "phydat_dump": {
            "renaming": {}, 
            "code": "\nvoid phydat_dump(phydat_t *data,uint8_t dim)\n\n{\n  size_t sVar1;\n  char *pcVar2;\n  char cVar3;\n  uint uVar4;\n  bool bVar5;\n  char num [8];\n  size_t len;\n  char scale_prefix;\n  uint8_t i;\n  \n  if ((data == (phydat_t *)0x0) || (3 < dim)) {\n    puts(PTR_s_Unable_to_display_data_object_000037e4);\n  }\n  else {\n    iprintf(PTR_s_Data__000037e8);\n    for (i = '\\0'; i < dim; i = i + '\\x01') {\n      if (data->unit < 0x14) {\n        uVar4 = DAT_000037ec & 1 << (uint)data->unit;\n        bVar5 = uVar4 != 0;\n        if (bVar5) {\n          uVar4 = 1;\n        }\n        cVar3 = (char)uVar4;\n        if (!bVar5) {\n          cVar3 = '\\0';\n        }\n        if (cVar3 == '\\0') goto LAB_000036ee;\n        scale_prefix = '\\0';\n      }\n      else {\nLAB_000036ee:\n        scale_prefix = phydat_prefix_from_scale(data->scale);\n      }\n      iprintf(PTR_DAT_000037f0);\n      if (dim < 2) {\n        iprintf(PTR_s__000037f8);\n      }\n      else {\n        iprintf(PTR_s___u__000037f4,(uint)i);\n      }\n      if (scale_prefix == '\\0') {\n        if (data->scale == '\\0') {\n          iprintf(PTR_DAT_00003800,(int)data->val[i]);\n        }\n        else if ((data->scale + 4 < 0 == SCARRY4((int)data->scale,4)) && (data->scale < '\\0')) {\n          sVar1 = fmt_s16_dfp(num,data->val[i],(int)data->scale);\n          num[sVar1] = '\\0';\n          iprintf(PTR_PTR_DAT_00003804,num);\n        }\n        else {\n          iprintf(PTR_s__iE_i_00003808,(int)data->val[i],(int)data->scale);\n        }\n      }\n      else {\n        iprintf(PTR_s__6d__c_000037fc,(int)data->val[i],(uint)(byte)scale_prefix);\n      }\n      pcVar2 = phydat_unit_to_str(data->unit);\n      iprintf(PTR_DAT_0000380c,pcVar2);\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "puts", 
                "phydat_prefix_from_scale", 
                "fmt_s16_dfp", 
                "phydat_unit_to_str", 
                "iprintf"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00003694", 
            "calling": [
                "write", 
                "probe"
            ], 
            "imported": false, 
            "current_name": "phydat_dump"
        }, 
        "uart_write": {
            "renaming": {}, 
            "code": "\nvoid uart_write(uart_t uart,uint8_t *data,size_t len)\n\n{\n  int iVar1;\n  UART_Type *dev;\n  size_t i;\n  \n  iVar1 = *(int *)(PTR_uart_config_00001624 + uart * 0x20);\n  for (i = 0; i < len; i = i + 1) {\n    do {\n    } while (-1 < *(char *)(iVar1 + 4));\n    *(uint8_t *)(iVar1 + 7) = data[i];\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000015d0", 
            "calling": [
                "uart_stdio_write"
            ], 
            "imported": false, 
            "current_name": "uart_write"
        }, 
        "rtc_init": {
            "renaming": {}, 
            "code": "\nvoid rtc_init(void)\n\n{\n  rtt_init();\n  return;\n}\n\n", 
            "called": [
                "rtt_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000025f4", 
            "calling": [
                "periph_init"
            ], 
            "imported": false, 
            "current_name": "rtc_init"
        }, 
        "readline": {
            "renaming": {}, 
            "code": "\nint readline(char *buf,size_t size)\n\n{\n  int c_00;\n  byte bVar1;\n  bool bVar2;\n  int c;\n  char *line_buf_ptr;\n  \n  line_buf_ptr = buf;\n  while( true ) {\n    if ((int)(size - 1) <= (int)line_buf_ptr - (int)buf) {\n      return -1;\n    }\n    c_00 = getchar();\n    if (c_00 < 0) break;\n    if ((c_00 == 0xd) || (c_00 == 10)) {\n      *line_buf_ptr = '\\0';\n      _putchar(0xd);\n      _putchar(10);\n      bVar2 = line_buf_ptr == buf;\n      if (bVar2) {\n        buf = (char *)0x1;\n      }\n      bVar1 = (byte)buf;\n      if (!bVar2) {\n        bVar1 = 0;\n      }\n      return (uint)bVar1;\n    }\n    if ((c_00 == 8) || (c_00 == 0x7f)) {\n      if (line_buf_ptr != buf) {\n        line_buf_ptr = line_buf_ptr + -1;\n        *line_buf_ptr = '\\0';\n        _putchar(8);\n        _putchar(0x20);\n        _putchar(8);\n      }\n    }\n    else {\n      *line_buf_ptr = (char)c_00;\n      _putchar(c_00);\n      line_buf_ptr = line_buf_ptr + 1;\n    }\n  }\n  return 1;\n}\n\n", 
            "called": [
                "_putchar", 
                "getchar"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002d94", 
            "calling": [
                "shell_run"
            ], 
            "imported": false, 
            "current_name": "readline"
        }, 
        "rtt_set_alarm": {
            "renaming": {}, 
            "code": "\nvoid rtt_set_alarm(uint32_t alarm,rtt_cb_t cb,void *arg)\n\n{\n  int iVar1;\n  RTC_Type *rtt;\n  \n  iVar1 = DAT_000028e8;\n  *(uint *)(DAT_000028e8 + 0x1c) = *(uint *)(DAT_000028e8 + 0x1c) & 0xfffffffb;\n  *(uint32_t *)(iVar1 + 8) = alarm - 1;\n  *(rtt_cb_t *)PTR_rtt_callback_000028ec = cb;\n  *(void **)(PTR_rtt_callback_000028ec + 4) = arg;\n  *(uint *)(iVar1 + 0x1c) = *(uint *)(iVar1 + 0x1c) | 4;\n  NVIC_SetPriority(RTC_IRQn,10);\n  NVIC_EnableIRQ(RTC_IRQn);\n  return;\n}\n\n", 
            "called": [
                "NVIC_EnableIRQ", 
                "NVIC_SetPriority"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002894", 
            "calling": [
                "rtc_set_alarm"
            ], 
            "imported": false, 
            "current_name": "rtt_set_alarm"
        }, 
        "_fwalk_reent": {
            "renaming": {}, 
            "code": "\nuint _fwalk_reent(int param_1,code *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  uint uVar1;\n  int iVar2;\n  int *piVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  \n  piVar3 = (int *)(param_1 + 0x48);\n  uVar5 = 0;\n  do {\n    iVar6 = piVar3[1];\n    iVar4 = piVar3[2];\n    while (iVar6 = iVar6 + -1, -1 < iVar6) {\n      if ((1 < *(ushort *)(iVar4 + 0xc)) && (iVar2 = *(short *)(iVar4 + 0xe) + 1, iVar2 != 0)) {\n        uVar1 = (*param_2)(param_1,iVar4,param_3,iVar2,param_4);\n        uVar5 = uVar5 | uVar1;\n      }\n      iVar4 = iVar4 + 0x68;\n    }\n    piVar3 = (int *)*piVar3;\n  } while (piVar3 != (int *)0x0);\n  return uVar5;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000043da", 
            "calling": [
                "_cleanup_r", 
                "fflush"
            ], 
            "imported": false, 
            "current_name": "_fwalk_reent"
        }, 
        "_getenv_r": {
            "renaming": {}, 
            "code": "\nvoid _getenv_r(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  \n  uStack_c = param_2;\n  uStack_8 = param_3;\n  _findenv_r(param_1,param_2,&uStack_c,param_4,param_1);\n  return;\n}\n\n", 
            "called": [
                "_findenv_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000056a0", 
            "calling": [
                "_tzset_unlocked_r"
            ], 
            "imported": false, 
            "current_name": "_getenv_r"
        }, 
        "irq_handler": {
            "renaming": {}, 
            "code": "\nvoid irq_handler(PORT_Type *port,int port_num)\n\n{\n  int iVar1;\n  uint uVar2;\n  int ctx;\n  uint32_t status;\n  int i;\n  \n  uVar2 = port->ISFR;\n  for (i = 0; i < 0x20; i = i + 1) {\n    if (((uVar2 & 1 << (i & 0xffU)) != 0) && ((port->PCR[i] & 0xf0000) != 0)) {\n      port->ISFR = 1 << (i & 0xffU);\n      iVar1 = get_ctx(port_num,i);\n      (**(code **)(PTR_isr_ctx_000020b4 + iVar1 * 0xc))\n                (*(undefined4 *)(PTR_isr_ctx_000020b4 + iVar1 * 0xc + 4));\n    }\n  }\n  cortexm_isr_end();\n  return;\n}\n\n", 
            "called": [
                "get_ctx", 
                "cortexm_isr_end"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002028", 
            "calling": [
                "isr_portd", 
                "isr_portb", 
                "isr_portc", 
                "isr_porta", 
                "isr_porte"
            ], 
            "imported": false, 
            "current_name": "irq_handler"
        }, 
        "isrpipe_read": {
            "renaming": {}, 
            "code": "\nint isrpipe_read(isrpipe_t *isrpipe,char *buffer,size_t count)\n\n{\n  int iVar1;\n  int res;\n  \n  while( true ) {\n    iVar1 = tsrb_get(&isrpipe->tsrb,buffer,count);\n    if (iVar1 != 0) break;\n    mutex_lock(&isrpipe->mutex);\n  }\n  return iVar1;\n}\n\n", 
            "called": [
                "mutex_lock", 
                "tsrb_get"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000012e2", 
            "calling": [
                "uart_stdio_read"
            ], 
            "imported": false, 
            "current_name": "isrpipe_read"
        }, 
        "irq_handler_uart": {
            "renaming": {}, 
            "code": "\nvoid irq_handler_uart(uart_t uart)\n\n{\n  uint8_t data;\n  UART_Type *dev;\n  \n  if (((*(byte *)(*(int *)(PTR_uart_config_00001680 + uart * 0x20) + 4) & 0x20) != 0) &&\n     (*(int *)(PTR_config_00001684 + uart * 8) != 0)) {\n    (**(code **)(PTR_config_00001684 + uart * 8))\n              (*(undefined4 *)(PTR_config_00001684 + uart * 8 + 4),\n               *(undefined *)(*(int *)(PTR_uart_config_00001680 + uart * 0x20) + 7));\n  }\n  cortexm_isr_end();\n  return;\n}\n\n", 
            "called": [
                "cortexm_isr_end"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001628", 
            "calling": [
                "isr_uart0_rx_tx"
            ], 
            "imported": false, 
            "current_name": "irq_handler_uart"
        }, 
        "periph_init": {
            "renaming": {}, 
            "code": "\nvoid periph_init(void)\n\n{\n  rtc_init();\n  return;\n}\n\n", 
            "called": [
                "rtc_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002396", 
            "calling": [
                "cpu_init"
            ], 
            "imported": false, 
            "current_name": "periph_init"
        }, 
        "__retarget_lock_init_recursive": {
            "renaming": {}, 
            "code": "\nvoid __retarget_lock_init_recursive(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000045e4", 
            "calling": [
                "__sfp"
            ], 
            "imported": false, 
            "current_name": "__retarget_lock_init_recursive"
        }, 
        "__swhatbuf_r": {
            "renaming": {}, 
            "code": "\nundefined4 __swhatbuf_r(_reent *param_1,int param_2,undefined4 *param_3,uint *param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  stat sStack_68;\n  \n  if ((*(short *)(param_2 + 0xe) < 0) ||\n     (iVar1 = _fstat_r(param_1,(int)*(short *)(param_2 + 0xe),&sStack_68), iVar1 < 0)) {\n    *param_4 = 0;\n    if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x18) < 0) {\n      uVar2 = 0x40;\n      goto LAB_000056f8;\n    }\n  }\n  else {\n    *param_4 = (uint)((sStack_68.st_mode & 0xf000) == 0x2000);\n  }\n  uVar2 = 0x400;\nLAB_000056f8:\n  *param_3 = uVar2;\n  return 0;\n}\n\n", 
            "called": [
                "_fstat_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000056b8", 
            "calling": [
                "__smakebuf_r"
            ], 
            "imported": false, 
            "current_name": "__swhatbuf_r"
        }, 
        "irq_disable": {
            "renaming": {}, 
            "code": "\nuint irq_disable(void)\n\n{\n  bool bVar1;\n  uint uVar2;\n  uint32_t result;\n  uint32_t mask;\n  \n  uVar2 = 0;\n  bVar1 = (bool)isCurrentModePrivileged();\n  if (bVar1) {\n    uVar2 = isIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return uVar2;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000cd0", 
            "calling": [
                "_sbrk_r", 
                "core_panic", 
                "sched_task_exit", 
                "kinetis_mcg_init", 
                "kernel_init", 
                "thread_create", 
                "pm_off", 
                "_mutex_lock", 
                "mutex_unlock"
            ], 
            "imported": false, 
            "current_name": "irq_disable"
        }, 
        "__tz_unlock": {
            "renaming": {}, 
            "code": "\nvoid __tz_unlock(void)\n\n{\n  __retarget_lock_release(PTR___lock___tz_mutex_000050fc);\n  return;\n}\n\n", 
            "called": [
                "__retarget_lock_release"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000050f4", 
            "calling": [
                "mktime"
            ], 
            "imported": false, 
            "current_name": "__tz_unlock"
        }, 
        "_fstat_r": {
            "renaming": {}, 
            "code": "\nint _fstat_r(_reent *r,int fd,stat *st)\n\n{\n  r->_errno = 0x13;\n  return -1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000514", 
            "calling": [
                "__swhatbuf_r"
            ], 
            "imported": false, 
            "current_name": "_fstat_r"
        }, 
        "rtt_clear_alarm": {
            "renaming": {}, 
            "code": "\nvoid rtt_clear_alarm(void)\n\n{\n  int iVar1;\n  RTC_Type *rtt;\n  \n  iVar1 = DAT_00002944;\n  *(uint *)(DAT_00002944 + 0x1c) = *(uint *)(DAT_00002944 + 0x1c) & 0xfffffffb;\n  *(undefined4 *)(iVar1 + 8) = 0;\n  *(undefined4 *)PTR_rtt_callback_00002948 = 0;\n  *(undefined4 *)(PTR_rtt_callback_00002948 + 4) = 0;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002910", 
            "calling": [
                "rtc_clear_alarm"
            ], 
            "imported": false, 
            "current_name": "rtt_clear_alarm"
        }, 
        "__malloc_unlock": {
            "renaming": {}, 
            "code": "\nvoid __malloc_unlock(void)\n\n{\n  __retarget_lock_release_recursive(PTR___lock___malloc_recursive_mutex_000057a4);\n  return;\n}\n\n", 
            "called": [
                "__retarget_lock_release_recursive"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000579c", 
            "calling": [
                "_malloc_r", 
                "_free_r"
            ], 
            "imported": false, 
            "current_name": "__malloc_unlock"
        }, 
        "mem_manage_default": {
            "renaming": {}, 
            "code": "\nvoid mem_manage_default(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  core_panic(PANIC_MEM_MANAGE,PTR_s_MEM_MANAGE_HANDLER_00000c8c);\n}\n\n", 
            "called": [
                "core_panic"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000c80", 
            "calling": [], 
            "imported": false, 
            "current_name": "mem_manage_default"
        }, 
        "irq_restore": {
            "renaming": {}, 
            "code": "\nvoid irq_restore(uint state)\n\n{\n  bool bVar1;\n  \n  bVar1 = (bool)isCurrentModePrivileged();\n  if (bVar1) {\n    enableIRQinterrupts((state & 1) == 1);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000d0c", 
            "calling": [
                "_sbrk_r", 
                "kinetis_mcg_init", 
                "thread_create", 
                "_mutex_lock", 
                "mutex_unlock"
            ], 
            "imported": false, 
            "current_name": "irq_restore"
        }, 
        "iprintf": {
            "renaming": {}, 
            "code": "\nint iprintf(char *__format,...)\n\n{\n  undefined4 in_r1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  int iVar1;\n  char *pcVar2;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  iVar1 = *(int *)PTR__impure_ptr_00004cb0;\n  pcVar2 = __format;\n  uStack_c = in_r1;\n  uStack_8 = in_r2;\n  uStack_4 = in_r3;\n  if ((iVar1 != 0) && (*(int *)(iVar1 + 0x18) == 0)) {\n    __sinit(iVar1);\n  }\n  iVar1 = _vfprintf_r(iVar1,*(undefined4 *)(iVar1 + 8),__format,&uStack_c,pcVar2,&uStack_c);\n  return iVar1;\n}\n\n", 
            "called": [
                "_vfprintf_r", 
                "__sinit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004c84", 
            "calling": [
                "_rtc_handler", 
                "handle_input_line", 
                "cpu_print_last_instruction", 
                "ps", 
                "print_help", 
                "phydat_dump", 
                "_print_time", 
                "probe", 
                "read", 
                "write", 
                "core_panic", 
                "hard_fault_handler", 
                "list", 
                "main_trampoline", 
                "_saul"
            ], 
            "imported": false, 
            "current_name": "iprintf"
        }, 
        "clist_lpop": {
            "renaming": {}, 
            "code": "\nclist_node_t * clist_lpop(clist_node_t *list)\n\n{\n  list_node *plVar1;\n  clist_node_t *first;\n  \n  if (list->next == (list_node *)0x0) {\n    plVar1 = (list_node *)0x0;\n  }\n  else {\n    plVar1 = list->next->next;\n    if (plVar1 == list->next) {\n      list->next = (list_node *)0x0;\n    }\n    else {\n      list->next->next = plVar1->next;\n    }\n  }\n  return plVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000005ca", 
            "calling": [
                "sched_set_status"
            ], 
            "imported": false, 
            "current_name": "clist_lpop"
        }, 
        "strcpy": {
            "renaming": {}, 
            "code": "\nchar * strcpy(char *__dest,char *__src)\n\n{\n  char cVar1;\n  char *pcVar2;\n  \n  pcVar2 = __dest;\n  do {\n    cVar1 = *__src;\n    *pcVar2 = cVar1;\n    __src = __src + 1;\n    pcVar2 = pcVar2 + 1;\n  } while (cVar1 != '\\0');\n  return __dest;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00005ebc", 
            "calling": [
                "_tzset_unlocked_r"
            ], 
            "imported": false, 
            "current_name": "strcpy"
        }, 
        "_printf_common": {
            "renaming": {}, 
            "code": "\nundefined4\n_printf_common(undefined4 param_1,uint *param_2,uint *param_3,undefined4 param_4,code *param_5)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  uint uVar4;\n  bool bVar5;\n  \n  uVar3 = param_2[4];\n  if ((int)param_2[4] < (int)param_2[2]) {\n    uVar3 = param_2[2];\n  }\n  *param_3 = uVar3;\n  if (*(char *)((int)param_2 + 0x43) != '\\0') {\n    *param_3 = uVar3 + 1;\n  }\n  if ((int)(*param_2 << 0x1a) < 0) {\n    *param_3 = *param_3 + 2;\n  }\n  uVar3 = *param_2 & 6;\n  if (uVar3 == 0) {\n    for (; (int)uVar3 < (int)(param_2[3] - *param_3); uVar3 = uVar3 + 1) {\n      iVar1 = (*param_5)(param_1,param_4,(int)param_2 + 0x19,1);\n      if (iVar1 == -1) goto LAB_00005afc;\n    }\n  }\n  uVar3 = (uint)*(byte *)((int)param_2 + 0x43);\n  if (uVar3 != 0) {\n    uVar3 = 1;\n  }\n  if ((int)(*param_2 << 0x1a) < 0) {\n    *(undefined *)((int)param_2 + uVar3 + 0x43) = 0x30;\n    *(undefined *)((int)param_2 + uVar3 + 0x44) = *(undefined *)((int)param_2 + 0x45);\n    uVar3 = uVar3 + 2;\n  }\n  iVar1 = (*param_5)(param_1,param_4,(int)param_2 + 0x43,uVar3);\n  if (iVar1 == -1) {\nLAB_00005afc:\n    uVar2 = 0xffffffff;\n  }\n  else {\n    uVar3 = param_2[3];\n    bVar5 = (*param_2 & 6) == 4;\n    if (bVar5) {\n      uVar3 = uVar3 - *param_3;\n    }\n    if (bVar5) {\n      uVar3 = uVar3 & ~((int)uVar3 >> 0x1f);\n    }\n    else {\n      uVar3 = 0;\n    }\n    if ((int)param_2[4] < (int)param_2[2]) {\n      uVar3 = uVar3 + (param_2[2] - param_2[4]);\n    }\n    for (uVar4 = 0; uVar3 != uVar4; uVar4 = uVar4 + 1) {\n      iVar1 = (*param_5)(param_1,param_4,(int)param_2 + 0x1a,1);\n      if (iVar1 == -1) goto LAB_00005afc;\n    }\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00005a58", 
            "calling": [
                "_printf_i"
            ], 
            "imported": false, 
            "current_name": "_printf_common"
        }, 
        "__retarget_lock_release_recursive": {
            "renaming": {}, 
            "code": "\nvoid __retarget_lock_release_recursive(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000045ec", 
            "calling": [
                "__malloc_unlock", 
                "_puts_r", 
                "_fflush_r", 
                "_getc_r", 
                "__sfp_lock_release", 
                "__env_unlock", 
                "_vfprintf_r", 
                "_putc_r", 
                "__sinit_lock_release"
            ], 
            "imported": false, 
            "current_name": "__retarget_lock_release_recursive"
        }, 
        "__sccl": {
            "renaming": {}, 
            "code": "\nbyte * __sccl(int param_1,byte *param_2)\n\n{\n  byte *pbVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  bool bVar7;\n  \n  uVar4 = (uint)*param_2;\n  bVar7 = uVar4 == 0x5e;\n  if (bVar7) {\n    uVar4 = (uint)param_2[1];\n    param_2 = param_2 + 2;\n  }\n  else {\n    param_2 = param_2 + 1;\n  }\n  iVar3 = param_1 + -1;\n  do {\n    iVar3 = iVar3 + 1;\n    *(bool *)iVar3 = bVar7;\n  } while (iVar3 != param_1 + 0xff);\n  if (uVar4 == 0) {\n    pbVar1 = param_2 + -1;\n  }\n  else {\nLAB_000068aa:\n    do {\n      uVar5 = uVar4;\n      *(bool *)(param_1 + uVar5) = !bVar7;\n      param_2 = param_2 + 1;\n      while( true ) {\n        uVar4 = (uint)param_2[-1];\n        if (uVar4 != 0x2d) break;\n        uVar6 = (uint)*param_2;\n        if ((uVar6 == 0x5d) || (uVar2 = uVar5, (int)uVar6 < (int)uVar5)) goto LAB_000068aa;\n        do {\n          uVar2 = uVar2 + 1;\n          *(bool *)(param_1 + uVar2) = !bVar7;\n        } while ((int)uVar2 < (int)uVar6);\n        iVar3 = ~uVar5 + uVar6;\n        if ((int)uVar6 <= (int)uVar5) {\n          iVar3 = 0;\n        }\n        uVar5 = uVar5 + 1 + iVar3;\n        param_2 = param_2 + 2;\n      }\n      pbVar1 = param_2;\n    } while ((uVar4 != 0x5d) && (pbVar1 = param_2 + -1, uVar4 != 0));\n  }\n  return pbVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000687c", 
            "calling": [
                "__ssvfiscanf_r", 
                "_scanf_i"
            ], 
            "imported": false, 
            "current_name": "__sccl"
        }, 
        "__submore": {
            "renaming": {}, 
            "code": "\nundefined4 __submore(undefined4 param_1,void **param_2)\n\n{\n  void *pvVar1;\n  void *__n;\n  \n  if ((void **)param_2[0xd] == param_2 + 0x11) {\n    pvVar1 = (void *)_malloc_r(param_1,0x400);\n    if (pvVar1 != (void *)0x0) {\n      param_2[0xe] = flash_configuration_field;\n      param_2[0xd] = pvVar1;\n      *(undefined *)((int)pvVar1 + 0x3ff) = *(undefined *)((int)param_2 + 0x46);\n      *(undefined *)((int)pvVar1 + 0x3fe) = *(undefined *)((int)param_2 + 0x45);\n      *(undefined *)((int)pvVar1 + 0x3fd) = *(undefined *)(param_2 + 0x11);\n      *param_2 = (void *)((int)pvVar1 + 0x3fd);\n      return 0;\n    }\n  }\n  else {\n    __n = param_2[0xe];\n    pvVar1 = (void *)_realloc_r(param_1,param_2[0xd],(void *)((int)__n << 1));\n    if (pvVar1 != (void *)0x0) {\n      memcpy((void *)((int)pvVar1 + (int)__n),pvVar1,(size_t)__n);\n      param_2[0xd] = pvVar1;\n      param_2[0xe] = (void *)((int)__n << 1);\n      *param_2 = (void *)((int)pvVar1 + (int)__n);\n      return 0;\n    }\n  }\n  return 0xffffffff;\n}\n\n", 
            "called": [
                "_malloc_r", 
                "memcpy", 
                "_realloc_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000068f0", 
            "calling": [
                "_sungetc_r"
            ], 
            "imported": false, 
            "current_name": "__submore"
        }, 
        "_strtoul_l.isra.0": {
            "renaming": {}, 
            "code": "\nuint _strtoul_l_isra_0(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  byte bVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  byte *pbVar7;\n  byte *pbVar8;\n  \n  pbVar8 = param_2;\n  do {\n    pbVar7 = pbVar8;\n    pbVar8 = pbVar7 + 1;\n    uVar2 = (uint)*pbVar7;\n    bVar3 = PTR_DAT_00005fd0[uVar2] & 8;\n  } while ((PTR_DAT_00005fd0[uVar2] & 8) != 0);\n  if (uVar2 == 0x2d) {\n    uVar2 = (uint)*pbVar8;\n    bVar3 = 1;\n    pbVar8 = pbVar7 + 2;\n  }\n  else if (uVar2 == 0x2b) {\n    uVar2 = (uint)*pbVar8;\n    pbVar8 = pbVar7 + 2;\n  }\n  if (param_4 == 0) {\n    if (uVar2 != 0x30) {\n      param_4 = 10;\n      goto LAB_00005f26;\n    }\n  }\n  else if ((param_4 != 0x10) || (uVar2 != 0x30)) goto LAB_00005f26;\n  if ((*pbVar8 & 0xdf) == 0x58) {\n    uVar2 = (uint)pbVar8[1];\n    param_4 = 0x10;\n    pbVar8 = pbVar8 + 2;\n  }\n  else {\n    uVar2 = 0x30;\n    if (param_4 == 0) {\n      param_4 = 8;\n    }\n  }\nLAB_00005f26:\n  iVar4 = 0;\n  uVar6 = 0xffffffff / param_4;\n  uVar1 = 0;\n  do {\n    uVar5 = uVar2 - 0x30;\n    if (9 < uVar5) {\n      if (uVar2 - 0x41 < 0x1a) {\n        uVar5 = uVar2 - 0x37;\n      }\n      else {\n        if (0x19 < uVar2 - 0x61) break;\n        uVar5 = uVar2 - 0x57;\n      }\n    }\n    if ((int)param_4 <= (int)uVar5) break;\n    if (((iVar4 < 0) || (uVar6 < uVar1)) ||\n       ((uVar6 == uVar1 && ((int)~(param_4 * uVar6) < (int)uVar5)))) {\n      iVar4 = -1;\n    }\n    else {\n      uVar1 = uVar1 * param_4 + uVar5;\n      iVar4 = 1;\n    }\n    uVar2 = (uint)*pbVar8;\n    pbVar8 = pbVar8 + 1;\n  } while( true );\n  if (iVar4 < 0) {\n    *param_1 = 0x22;\n    uVar1 = 0xffffffff;\n    if (param_3 == (byte **)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (bVar3 != 0) {\n      uVar1 = -uVar1;\n    }\n    if (param_3 == (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar4 == 0) goto LAB_00005fb8;\n  }\n  param_2 = pbVar8 + -1;\nLAB_00005fb8:\n  *param_3 = param_2;\n  return uVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00005edc", 
            "calling": [
                "strtoul", 
                "_strtoul_r"
            ], 
            "imported": false, 
            "current_name": "_strtoul_l.isra.0"
        }, 
        "thread_add_to_list": {
            "renaming": {}, 
            "code": "\nvoid thread_add_to_list(list_node_t *list,thread_t *thread)\n\n{\n  list_node_t *local_1c;\n  thread_t *list_entry;\n  clist_node_t *__m____;\n  list_node_t *new_node;\n  uint16_t my_prio;\n  \n  if (thread->status < 9) {\n    local_1c = list;\n    while ((local_1c->next != (list_node *)0x0 &&\n           (*(byte *)((int)&local_1c->next[-1].next + 1) <= thread->priority))) {\n      local_1c = local_1c->next;\n    }\n    (thread->rq_entry).next = local_1c->next;\n    local_1c->next = &thread->rq_entry;\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  core_panic(PANIC_ASSERT_FAIL,PTR_assert_crash_message_0000109c);\n}\n\n", 
            "called": [
                "core_panic"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001034", 
            "calling": [
                "_mutex_lock"
            ], 
            "imported": false, 
            "current_name": "thread_add_to_list"
        }, 
        "write": {
            "renaming": {}, 
            "code": "\nvoid write(int argc,char **argv)\n\n{\n  int iVar1;\n  phydat_t data;\n  int dim;\n  saul_reg_t *dev;\n  int num;\n  int i;\n  \n  if (argc < 4) {\n    iprintf(PTR_s_usage___s__s__device_id___value_0_00003154,*argv,argv[1]);\n  }\n  else {\n    num = atoi(argv[2]);\n    dev = saul_reg_find_nth(num);\n    if (dev == (saul_reg_t *)0x0) {\n      puts(PTR_s_error__undefined_device_given_00003158);\n    }\n    else {\n      memset(&data,0,8);\n      if (5 < argc) {\n        argc = 6;\n      }\n      dim = argc + -3;\n      for (i = 0; i < dim; i = i + 1) {\n        iVar1 = atoi(argv[i + 3]);\n        data.val[i] = (int16_t)iVar1;\n      }\n      iprintf(PTR_s_Writing_to_device___i____s_0000315c,num,dev->name);\n      phydat_dump(&data,(uint8_t)dim);\n      iVar1 = saul_reg_write(dev,&data);\n      if (iVar1 < 1) {\n        if (iVar1 == -0x86) {\n          iprintf(PTR_s_error__device___i_is_not_writabl_00003160,num);\n        }\n        else {\n          iprintf(PTR_s_error__failure_to_write_to_devic_00003164,num);\n        }\n      }\n      else {\n        iprintf(PTR_s_data_successfully_written_to_dev_00003168,num);\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "puts", 
                "atoi", 
                "memset", 
                "saul_reg_write", 
                "saul_reg_find_nth", 
                "phydat_dump", 
                "iprintf"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000305c", 
            "calling": [
                "_saul"
            ], 
            "imported": false, 
            "current_name": "write"
        }, 
        "print_prompt": {
            "renaming": {}, 
            "code": "\nvoid print_prompt(void)\n\n{\n  _putchar(0x3e);\n  _putchar(0x20);\n  fflush(*(FILE **)(*(int *)PTR__impure_ptr_00002e68 + 8));\n  return;\n}\n\n", 
            "called": [
                "_putchar", 
                "fflush"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002e48", 
            "calling": [
                "shell_run"
            ], 
            "imported": false, 
            "current_name": "print_prompt"
        }, 
        "cpu_errata_fixes": {
            "renaming": {}, 
            "code": "\nvoid cpu_errata_fixes(void)\n\n{\n  bit_clear32(DAT_00000dac,'\\0');\n  return;\n}\n\n", 
            "called": [
                "bit_clear32"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000d9c", 
            "calling": [
                "pre_startup"
            ], 
            "imported": false, 
            "current_name": "cpu_errata_fixes"
        }, 
        "_rtc_gettime": {
            "renaming": {}, 
            "code": "\nint _rtc_gettime(void)\n\n{\n  int iVar1;\n  tm t;\n  \n  iVar1 = rtc_get_time(&t);\n  if (iVar1 != 0) {\n    puts(PTR_s_rtc__error_getting_time_00003474);\n  }\n  else {\n    _print_time(&t);\n  }\n  return (uint)(iVar1 != 0);\n}\n\n", 
            "called": [
                "puts", 
                "rtc_get_time", 
                "_print_time"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00003444", 
            "calling": [
                "_rtc_handler"
            ], 
            "imported": false, 
            "current_name": "_rtc_gettime"
        }, 
        "cpu_switch_context_exit": {
            "renaming": {}, 
            "code": "\nvoid cpu_switch_context_exit(void)\n\n{\n  irq_enable();\n  software_interrupt(1);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
            "called": [
                "irq_enable"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000930", 
            "calling": [
                "sched_task_exit", 
                "kernel_init"
            ], 
            "imported": false, 
            "current_name": "cpu_switch_context_exit"
        }, 
        "__smakebuf_r": {
            "renaming": {}, 
            "code": "\nvoid __smakebuf_r(_reent *param_1,int *param_2)\n\n{\n  ushort uVar1;\n  int iVar2;\n  _reent *local_18;\n  int *local_14;\n  \n  if (-1 < (int)((uint)*(ushort *)(param_2 + 3) << 0x1e)) {\n    local_18 = param_1;\n    local_14 = param_2;\n    uVar1 = __swhatbuf_r(param_1,param_2,&local_18,&local_14);\n    iVar2 = _malloc_r(param_1,local_18);\n    if (iVar2 != 0) {\n      param_1->__cleanup = DAT_0000577c;\n      *param_2 = iVar2;\n      *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 0x80;\n      param_2[5] = (int)local_18;\n      param_2[4] = iVar2;\n      if ((local_14 != (int *)0x0) &&\n         (iVar2 = _isatty_r(param_1,(int)*(short *)((int)param_2 + 0xe)), iVar2 != 0)) {\n        *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(param_2 + 3) = uVar1 | *(ushort *)(param_2 + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(param_2 + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xfffc | 2;\n  }\n  *param_2 = (int)param_2 + 0x47;\n  param_2[4] = (int)param_2 + 0x47;\n  param_2[5] = 1;\n  return;\n}\n\n", 
            "called": [
                "__swhatbuf_r", 
                "_malloc_r", 
                "_isatty_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00005700", 
            "calling": [
                "__srefill_r", 
                "__swsetup_r"
            ], 
            "imported": false, 
            "current_name": "__smakebuf_r"
        }, 
        "__sfp_lock_acquire": {
            "renaming": {}, 
            "code": "\nvoid __sfp_lock_acquire(void)\n\n{\n  __retarget_lock_acquire_recursive(PTR___lock___sfp_recursive_mutex_0000427c);\n  return;\n}\n\n", 
            "called": [
                "__retarget_lock_acquire_recursive"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004274", 
            "calling": [
                "__sfp"
            ], 
            "imported": false, 
            "current_name": "__sfp_lock_acquire"
        }, 
        "bitarithm_lsb": {
            "renaming": {}, 
            "code": "\nuint bitarithm_lsb(uint v)\n\n{\n  byte bVar1;\n  byte bVar2;\n  byte bVar3;\n  byte bVar4;\n  uint uVar5;\n  \n  bVar2 = (byte)v;\n  bVar3 = (byte)(v >> 8);\n  bVar4 = (byte)(v >> 0x10);\n  bVar1 = (byte)(v >> 0x18);\n  uVar5 = count_leading_zeroes\n                    ((uint)(byte)((((((((bVar2 & 1) << 1 | bVar2 >> 1 & 1) << 1 | bVar2 >> 2 & 1) <<\n                                      1 | bVar2 >> 3 & 1) << 1 | bVar2 >> 4 & 1) << 1 |\n                                   bVar2 >> 5 & 1) << 1 | bVar2 >> 6 & 1) << 1 | bVar2 >> 7) << 0x18\n                     | (uint)(byte)((((((((bVar3 & 1) << 1 | bVar3 >> 1 & 1) << 1 | bVar3 >> 2 & 1)\n                                        << 1 | bVar3 >> 3 & 1) << 1 | bVar3 >> 4 & 1) << 1 |\n                                     bVar3 >> 5 & 1) << 1 | bVar3 >> 6 & 1) << 1 | bVar3 >> 7) <<\n                       0x10 | (uint)(byte)((((((((bVar4 & 1) << 1 | bVar4 >> 1 & 1) << 1 |\n                                               bVar4 >> 2 & 1) << 1 | bVar4 >> 3 & 1) << 1 |\n                                             bVar4 >> 4 & 1) << 1 | bVar4 >> 5 & 1) << 1 |\n                                           bVar4 >> 6 & 1) << 1 | bVar4 >> 7) << 8 |\n                     (uint)(byte)((((((((bVar1 & 1) << 1 | bVar1 >> 1 & 1) << 1 | bVar1 >> 2 & 1) <<\n                                      1 | bVar1 >> 3 & 1) << 1 | bVar1 >> 4 & 1) << 1 |\n                                   bVar1 >> 5 & 1) << 1 | bVar1 >> 6 & 1) << 1 | bVar1 >> 7));\n  if (v == 0) {\n    uVar5 = 0xffffffff;\n  }\n  return uVar5;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000566", 
            "calling": [
                "sched_run"
            ], 
            "imported": false, 
            "current_name": "bitarithm_lsb"
        }, 
        "_vfprintf_r": {
            "renaming": {}, 
            "code": "\nint _vfprintf_r(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  bool bVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  int iVar4;\n  int iVar5;\n  void *pvVar6;\n  int *piVar7;\n  byte *pbVar8;\n  int unaff_r7;\n  byte *pbVar9;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 uStack_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_2 == PTR___sf_fake_stdin_00005a38) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR___sf_fake_stdout_00005a3c) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR___sf_fake_stderr_00005a40) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n     (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n    __retarget_lock_acquire_recursive(*(undefined4 *)(param_2 + 0x58));\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar4 = __swsetup_r(param_1,param_2), iVar4 != 0)) {\n    if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n       (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n      __retarget_lock_release_recursive(*(undefined4 *)(param_2 + 0x58));\n    }\n    return -1;\n  }\n  puVar2 = PTR_s___0__00005a44;\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar9 = param_3;\n  local_8c = param_4;\nLAB_0000588e:\n  pbVar8 = pbVar9;\n  if (*pbVar8 != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  pbVar9 = pbVar8 + 1;\n  if (*pbVar8 != 0x25) goto LAB_0000588e;\nLAB_0000589a:\n  iVar4 = (int)pbVar8 - (int)param_3;\n  if (iVar4 != 0) {\n    iVar5 = __sfputs_r(param_1,param_2,param_3,iVar4);\n    if (iVar5 == -1) {\nLAB_00005a06:\n      if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n         (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n        __retarget_lock_release_recursive(*(undefined4 *)(param_2 + 0x58));\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar4;\n  }\n  if (*pbVar8 == 0) goto LAB_00005a06;\n  local_84 = -1;\n  uStack_80 = 0;\n  local_88 = 0;\n  local_7c = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar9 = pbVar8 + 1;\n  while( true ) {\n    pbVar8 = pbVar9 + 1;\n    pvVar6 = memchr(PTR_s___0__00005a44,(uint)*pbVar9,5);\n    puVar3 = PTR_DAT_00005a54;\n    if (pvVar6 == (void *)0x0) break;\n    local_88 = 1 << ((int)pvVar6 - (int)puVar2 & 0xffU) | local_88;\n    pbVar9 = pbVar8;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar9 == 0x2a) {\n    piVar7 = local_8c + 1;\n    local_7c = *local_8c;\n    local_8c = piVar7;\n    if (local_7c < 0) {\n      local_7c = -local_7c;\n      local_88 = local_88 | 2;\n    }\n  }\n  else {\n    bVar1 = false;\n    iVar4 = local_7c;\n    pbVar8 = pbVar9;\n    while( true ) {\n      if (9 < *pbVar8 - 0x30) break;\n      iVar4 = iVar4 * 10 + (*pbVar8 - 0x30);\n      bVar1 = true;\n      pbVar8 = pbVar8 + 1;\n    }\n    if (bVar1) {\n      local_7c = iVar4;\n    }\n  }\n  if (*pbVar8 == 0x2e) {\n    if (pbVar8[1] == 0x2a) {\n      local_84 = *local_8c;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n      pbVar8 = pbVar8 + 2;\n      local_8c = local_8c + 1;\n    }\n    else {\n      bVar1 = false;\n      local_84 = 0;\n      iVar4 = 0;\n      while( true ) {\n        pbVar8 = pbVar8 + 1;\n        if (9 < *pbVar8 - 0x30) break;\n        iVar4 = iVar4 * 10 + (*pbVar8 - 0x30);\n        bVar1 = true;\n      }\n      if (bVar1) {\n        local_84 = iVar4;\n      }\n    }\n  }\n  pvVar6 = memchr(PTR_DAT_00005a54,(uint)*pbVar8,3);\n  if (pvVar6 != (void *)0x0) {\n    local_88 = local_88 | 0x40 << ((int)pvVar6 - (int)puVar3 & 0xffU);\n    pbVar8 = pbVar8 + 1;\n  }\n  param_3 = pbVar8 + 1;\n  local_70 = *pbVar8;\n  pvVar6 = memchr(PTR_s_efgEFG_00005a48,(uint)local_70,6);\n  if (pvVar6 == (void *)0x0) {\n    iVar4 = _printf_i(param_1,&local_88,param_2,DAT_00005a50,&local_8c);\n  }\n  else {\n    iVar4 = param_1;\n    if (DAT_00005a4c == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar4 = unaff_r7;\n      goto LAB_000059b4;\n    }\n  }\n  if (iVar4 == -1) goto LAB_00005a06;\nLAB_000059b4:\n  local_74 = local_74 + iVar4;\n  pbVar9 = param_3;\n  unaff_r7 = iVar4;\n  goto LAB_0000588e;\n}\n\n", 
            "called": [
                "__retarget_lock_acquire_recursive", 
                "_printf_i", 
                "__swsetup_r", 
                "memchr", 
                "__retarget_lock_release_recursive", 
                "__sfputs_r", 
                "__sinit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000057f8", 
            "calling": [
                "iprintf"
            ], 
            "imported": false, 
            "current_name": "_vfprintf_r"
        }, 
        "isrpipe_write_one": {
            "renaming": {}, 
            "code": "\nint isrpipe_write_one(isrpipe_t *isrpipe,char c)\n\n{\n  int iVar1;\n  int res;\n  \n  iVar1 = tsrb_add_one(&isrpipe->tsrb,c);\n  mutex_unlock(&isrpipe->mutex);\n  return iVar1;\n}\n\n", 
            "called": [
                "tsrb_add_one", 
                "mutex_unlock"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000012b4", 
            "calling": [], 
            "imported": false, 
            "current_name": "isrpipe_write_one"
        }, 
        "__env_lock": {
            "renaming": {}, 
            "code": "\nvoid __env_lock(void)\n\n{\n  __retarget_lock_acquire_recursive(PTR___lock___env_recursive_mutex_00005ff4);\n  return;\n}\n\n", 
            "called": [
                "__retarget_lock_acquire_recursive"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00005fec", 
            "calling": [
                "_findenv_r"
            ], 
            "imported": false, 
            "current_name": "__env_lock"
        }, 
        "__srget_r": {
            "renaming": {}, 
            "code": "\nuint __srget_r(int param_1,byte **param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  byte *pbVar3;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_2 == (byte **)PTR___sf_fake_stdin_00005e5c) {\n    param_2 = *(byte ***)(param_1 + 4);\n  }\n  else if (param_2 == (byte **)PTR___sf_fake_stdout_00005e60) {\n    param_2 = *(byte ***)(param_1 + 8);\n  }\n  else if (param_2 == (byte **)PTR___sf_fake_stderr_00005e64) {\n    param_2 = *(byte ***)(param_1 + 0xc);\n  }\n  iVar1 = __srefill_r(param_1,param_2);\n  if (iVar1 == 0) {\n    param_2[1] = param_2[1] + -1;\n    pbVar3 = *param_2;\n    *param_2 = pbVar3 + 1;\n    uVar2 = (uint)*pbVar3;\n  }\n  else {\n    uVar2 = 0xffffffff;\n  }\n  return uVar2;\n}\n\n", 
            "called": [
                "__srefill_r", 
                "__sinit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00005e10", 
            "calling": [
                "_getc_r"
            ], 
            "imported": false, 
            "current_name": "__srget_r"
        }, 
        "saul_class_to_str": {
            "renaming": {}, 
            "code": "\nchar * saul_class_to_str(uint8_t class_id)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = PTR_s_CLASS_UNKNOWN_00003d20;\n  switch(class_id) {\n  case '\\0':\n    pcVar1 = PTR_s_CLASS_UNDEF_00003cc0;\n    break;\n  case '\\x01':\n  case '\\x02':\n  case '\\x03':\n  case '\\x04':\n  case '\\x05':\n  case '\\x06':\n  case '\\a':\n  case '\\b':\n  case '\\t':\n  case '\\n':\n  case '\\v':\n  case '\\f':\n  case '\\r':\n  case '\\x0e':\n  case '\\x0f':\n  case '\\x10':\n  case '\\x11':\n  case '\\x12':\n  case '\\x13':\n  case '\\x14':\n  case '\\x15':\n  case '\\x16':\n  case '\\x17':\n  case '\\x18':\n  case '\\x19':\n  case '\\x1a':\n  case '\\x1b':\n  case '\\x1c':\n  case '\\x1d':\n  case '\\x1e':\n  case '\\x1f':\n  case ' ':\n  case '!':\n  case '\\\"':\n  case '#':\n  case '$':\n  case '%':\n  case '&':\n  case '\\'':\n  case '(':\n  case ')':\n  case '*':\n  case '+':\n  case ',':\n  case '-':\n  case '.':\n  case '/':\n  case '0':\n  case '1':\n  case '2':\n  case '3':\n  case '4':\n  case '5':\n  case '6':\n  case '7':\n  case '8':\n  case '9':\n  case ':':\n  case ';':\n  case '<':\n  case '=':\n  case '>':\n  case '?':\n  case 'A':\n  case 'G':\n  case 'H':\n  case 'I':\n  case 'J':\n  case 'K':\n  case 'L':\n  case 'M':\n  case 'N':\n  case 'O':\n  case 'P':\n  case 'Q':\n  case 'R':\n  case 'S':\n  case 'T':\n  case 'U':\n  case 'V':\n  case 'W':\n  case 'X':\n  case 'Y':\n  case 'Z':\n  case '[':\n  case '\\\\':\n  case ']':\n  case '^':\n  case '_':\n  case '`':\n  case 'a':\n  case 'b':\n  case 'c':\n  case 'd':\n  case 'e':\n  case 'f':\n  case 'g':\n  case 'h':\n  case 'i':\n  case 'j':\n  case 'k':\n  case 'l':\n  case 'm':\n  case 'n':\n  case 'o':\n  case 'p':\n  case 'q':\n  case 'r':\n  case 's':\n  case 't':\n  case 'u':\n  case 'v':\n  case 'w':\n  case 'x':\n  case 'y':\n  case 'z':\n  case '{':\n  case '|':\n  case '}':\n  case '~':\n  case '\\x7f':\n    break;\n  case '@':\n    pcVar1 = PTR_s_ACT_ANY_00003cc4;\n    break;\n  case 'B':\n    pcVar1 = PTR_s_ACT_LED_RGB_00003cc8;\n    break;\n  case 'C':\n    pcVar1 = PTR_s_ACT_SERVO_00003ccc;\n    break;\n  case 'D':\n    pcVar1 = PTR_s_ACT_MOTOR_00003cd0;\n    break;\n  case 'E':\n    pcVar1 = PTR_s_ACT_SWITCH_00003cd4;\n    break;\n  case 'F':\n    pcVar1 = PTR_s_ACT_DIMMER_00003cd8;\n    break;\n  case 0x80:\n    pcVar1 = PTR_s_SENSE_ANY_00003cdc;\n    break;\n  case 0x81:\n    pcVar1 = PTR_s_SENSE_BTN_00003ce0;\n    break;\n  case 0x82:\n    pcVar1 = PTR_s_SENSE_TEMP_00003ce4;\n    break;\n  case 0x83:\n    pcVar1 = PTR_s_SENSE_HUM_00003ce8;\n    break;\n  case 0x84:\n    pcVar1 = PTR_s_SENSE_LIGHT_00003cec;\n    break;\n  case 0x85:\n    pcVar1 = PTR_s_SENSE_ACCEL_00003cf0;\n    break;\n  case 0x86:\n    pcVar1 = PTR_s_SENSE_MAG_00003cf4;\n    break;\n  case 0x87:\n    pcVar1 = PTR_s_SENSE_GYRO_00003cf8;\n    break;\n  case 0x88:\n    pcVar1 = PTR_s_SENSE_COLOR_00003cfc;\n    break;\n  case 0x89:\n    pcVar1 = PTR_s_SENSE_PRESS_00003d00;\n    break;\n  case 0x8a:\n    pcVar1 = PTR_s_SENSE_ANALOG_00003d04;\n    break;\n  case 0x8b:\n    pcVar1 = PTR_s_SENSE_UV_00003d08;\n    break;\n  case 0x8c:\n    pcVar1 = PTR_s_SENSE_OBJTEMP_00003d0c;\n    break;\n  case 0x8d:\n    pcVar1 = PTR_s_SENSE_PULSE_COUNT_00003d10;\n    break;\n  case 0x8e:\n    pcVar1 = PTR_s_SENSE_DISTANCE_00003d14;\n    break;\n  case 0x8f:\n    pcVar1 = PTR_s_SENSE_CO2_00003d18;\n    break;\n  default:\n    if (class_id == 0xff) {\n      return PTR_s_CLASS_ANY_00003d1c;\n    }\n  }\n  return pcVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000039e8", 
            "calling": [
                "list", 
                "probe"
            ], 
            "imported": false, 
            "current_name": "saul_class_to_str"
        }, 
        "kinetis_mcg_disable_pll": {
            "renaming": {}, 
            "code": "\nvoid kinetis_mcg_disable_pll(void)\n\n{\n  bit_clear8(DAT_00001744,'\\x06');\n  return;\n}\n\n", 
            "called": [
                "bit_clear8"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001734", 
            "calling": [
                "kinetis_mcg_set_blpe", 
                "kinetis_mcg_set_fbe", 
                "kinetis_mcg_set_blpi"
            ], 
            "imported": false, 
            "current_name": "kinetis_mcg_disable_pll"
        }, 
        "_lseek_r": {
            "renaming": {}, 
            "code": "\n_off_t _lseek_r(_reent *r,int fd,_off_t pos,int dir)\n\n{\n  r->_errno = 0x13;\n  return -1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000004f2", 
            "calling": [
                "__sseek", 
                "__swrite"
            ], 
            "imported": false, 
            "current_name": "_lseek_r"
        }, 
        "isr_rtc": {
            "renaming": {}, 
            "code": "\nvoid isr_rtc(void)\n\n{\n  int iVar1;\n  RTC_Type *rtt;\n  \n  iVar1 = DAT_000029f8;\n  if (((*(uint *)(DAT_000029f8 + 0x14) & 4) != 0) && (*(int *)PTR_rtt_callback_000029fc != 0)) {\n    *(uint *)(DAT_000029f8 + 0x1c) = *(uint *)(DAT_000029f8 + 0x1c) & 0xfffffffb;\n    (**(code **)PTR_rtt_callback_000029fc)(*(undefined4 *)(PTR_rtt_callback_000029fc + 4));\n  }\n  if (((*(uint *)(iVar1 + 0x14) & 2) != 0) && (*(int *)(PTR_rtt_callback_000029fc + 8) != 0)) {\n    (**(code **)(PTR_rtt_callback_000029fc + 8))(*(undefined4 *)(PTR_rtt_callback_000029fc + 0xc));\n  }\n  cortexm_isr_end();\n  return;\n}\n\n", 
            "called": [
                "cortexm_isr_end"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002994", 
            "calling": [], 
            "imported": false, 
            "current_name": "isr_rtc"
        }, 
        "_saul": {
            "renaming": {}, 
            "code": "\nint _saul(int argc,char **argv)\n\n{\n  int iVar1;\n  \n  if (argc < 2) {\n    list();\n  }\n  else {\n    iVar1 = strcmp(argv[1],PTR_DAT_000031d4);\n    if (iVar1 == 0) {\n      read(argc,argv);\n    }\n    else {\n      iVar1 = strcmp(argv[1],PTR_s_write_000031d8);\n      if (iVar1 == 0) {\n        write(argc,argv);\n      }\n      else {\n        iprintf(PTR_s_usage___s_read_write_000031dc,*argv);\n      }\n    }\n  }\n  return 0;\n}\n\n", 
            "called": [
                "write", 
                "list", 
                "read", 
                "strcmp", 
                "iprintf"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000316c", 
            "calling": [], 
            "imported": false, 
            "current_name": "_saul"
        }, 
        "_ps_handler": {
            "renaming": {}, 
            "code": "\nint _ps_handler(int argc,char **argv)\n\n{\n  ps();\n  return 0;\n}\n\n", 
            "called": [
                "ps"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002eb4", 
            "calling": [], 
            "imported": false, 
            "current_name": "_ps_handler"
        }, 
        "__sfmoreglue": {
            "renaming": {}, 
            "code": "\nundefined4 * __sfmoreglue(undefined4 param_1,int param_2)\n\n{\n  undefined4 *puVar1;\n  int iVar2;\n  \n  iVar2 = (param_2 + -1) * 0x68;\n  puVar1 = (undefined4 *)_malloc_r(param_1,iVar2 + 0x74);\n  if (puVar1 != (undefined4 *)0x0) {\n    *puVar1 = 0;\n    puVar1[1] = param_2;\n    puVar1[2] = puVar1 + 3;\n    memset(puVar1 + 3,0,iVar2 + 0x68);\n  }\n  return puVar1;\n}\n\n", 
            "called": [
                "_malloc_r", 
                "memset"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004248", 
            "calling": [
                "__sfp"
            ], 
            "imported": false, 
            "current_name": "__sfmoreglue"
        }, 
        "__udivmoddi4": {
            "renaming": {}, 
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong __udivmoddi4(uint param_1,uint param_2,uint param_3,uint param_4,uint *param_5)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  uint uVar1;\n  uint *puVar2;\n  uint *puVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  bool bVar11;\n  ulonglong uVar12;\n  \n  if (param_4 == 0) {\n    if (param_2 < param_3) {\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 != 0) {\n        param_3 = param_3 << (uVar4 & 0xff);\n        param_2 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        param_1 = param_1 << (uVar4 & 0xff);\n      }\n      uVar7 = param_3 >> 0x10;\n      uVar9 = param_2 / uVar7;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar7 * uVar9) * 0x10000;\n      uVar1 = uVar9 * (param_3 & 0xffff);\n      uVar6 = uVar9;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar9 = (uVar5 - uVar1) / uVar7;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar7 * uVar9) * 0x10000;\n      uVar7 = uVar9 * (param_3 & 0xffff);\n      uVar1 = uVar9;\n      if (uVar5 <= uVar7 && uVar7 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar7 && uVar7 - uVar5 != 0)) {\n          uVar1 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar7;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n      puVar3 = (uint *)0x0;\n    }\n    else {\n      if (param_3 == 0) {\n                    /* WARNING: Could not recover jumptable at 0x00006abc. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x6abc);\n        uVar12 = (*UNRECOVERED_JUMPTABLE)();\n        return uVar12;\n      }\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 == 0) {\n        param_2 = param_2 - param_3;\n        uVar10 = param_3 >> 0x10;\n        uVar8 = param_3 & 0xffff;\n        puVar3 = (uint *)0x1;\n      }\n      else {\n        param_3 = param_3 << (uVar4 & 0xff);\n        uVar10 = param_3 >> 0x10;\n        uVar6 = param_2 >> (0x20 - uVar4 & 0xff);\n        uVar1 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        uVar5 = uVar6 / uVar10;\n        uVar8 = param_3 & 0xffff;\n        uVar9 = uVar1 >> 0x10 | (uVar6 - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        param_1 = param_1 << (uVar4 & 0xff);\n        uVar6 = uVar5;\n        if (uVar9 <= uVar7 && uVar7 - uVar9 != 0) {\n          bVar11 = CARRY4(param_3,uVar9);\n          uVar9 = param_3 + uVar9;\n          uVar6 = uVar5 - 1;\n          if ((bVar11 == false) && (uVar9 <= uVar7 && uVar7 - uVar9 != 0)) {\n            uVar6 = uVar5 - 2;\n            uVar9 = uVar9 + param_3;\n          }\n        }\n        uVar5 = (uVar9 - uVar7) / uVar10;\n        param_2 = uVar1 & 0xffff | ((uVar9 - uVar7) - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        uVar1 = uVar5;\n        if (param_2 <= uVar7 && uVar7 - param_2 != 0) {\n          bVar11 = CARRY4(param_3,param_2);\n          param_2 = param_3 + param_2;\n          uVar1 = uVar5 - 1;\n          if ((bVar11 == false) && (param_2 <= uVar7 && uVar7 - param_2 != 0)) {\n            uVar1 = uVar5 - 2;\n            param_2 = param_2 + param_3;\n          }\n        }\n        param_2 = param_2 - uVar7;\n        puVar3 = (uint *)(uVar1 | uVar6 << 0x10);\n      }\n      uVar7 = param_2 / uVar10;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar10 * uVar7) * 0x10000;\n      uVar1 = uVar8 * uVar7;\n      uVar6 = uVar7;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar7 = (uVar5 - uVar1) / uVar10;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar10 * uVar7) * 0x10000;\n      uVar8 = uVar8 * uVar7;\n      uVar1 = uVar7;\n      if (uVar5 <= uVar8 && uVar8 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar8 && uVar8 - uVar5 != 0)) {\n          uVar1 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar8;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = uVar5 >> (uVar4 & 0xff);\n      param_5[1] = 0;\n    }\n  }\n  else if (param_2 < param_4) {\n    puVar2 = param_5;\n    puVar3 = param_5;\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n      return 0;\n    }\n  }\n  else {\n    puVar3 = (uint *)count_leading_zeroes(param_4);\n    if (puVar3 != (uint *)0x0) {\n      uVar8 = 0x20 - (int)puVar3;\n      uVar5 = param_3 >> (uVar8 & 0xff) | param_4 << ((uint)puVar3 & 0xff);\n      uVar10 = uVar5 >> 0x10;\n      uVar4 = param_2 >> (uVar8 & 0xff);\n      uVar6 = param_1 >> (uVar8 & 0xff) | param_2 << ((uint)puVar3 & 0xff);\n      uVar7 = uVar4 / uVar10;\n      uVar1 = uVar6 >> 0x10 | (uVar4 - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      param_3 = param_3 << ((uint)puVar3 & 0xff);\n      param_1 = param_1 << ((uint)puVar3 & 0xff);\n      uVar4 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar4 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar4 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar7 = (uVar1 - uVar9) / uVar10;\n      uVar1 = uVar6 & 0xffff | ((uVar1 - uVar9) - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      uVar6 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar6 = uVar6 | uVar4 << 0x10;\n      uVar12 = (ulonglong)uVar6 * (ulonglong)param_3;\n      if (CONCAT44(uVar1 - uVar9,param_1) < uVar12) {\n        uVar12 = uVar12 - CONCAT44(uVar5,param_3);\n        uVar6 = uVar6 - 1;\n      }\n      if (param_5 != (uint *)0x0) {\n        uVar4 = ((uVar1 - uVar9) - (int)(uVar12 >> 0x20)) - (uint)(param_1 < (uint)uVar12);\n        *param_5 = uVar4 << (uVar8 & 0xff) | param_1 - (uint)uVar12 >> ((uint)puVar3 & 0xff);\n        param_5[1] = uVar4 >> ((uint)puVar3 & 0xff);\n      }\n      return (ulonglong)uVar6;\n    }\n    if ((param_4 < param_2) || (puVar2 = puVar3, param_3 <= param_1)) {\n      bVar11 = param_1 < param_3;\n      param_1 = param_1 - param_3;\n      param_2 = (param_2 - param_4) - (uint)bVar11;\n      puVar2 = (uint *)0x1;\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n    }\n  }\n  return CONCAT44(puVar3,puVar2);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00006a14", 
            "calling": [
                "__aeabi_ldivmod"
            ], 
            "imported": false, 
            "current_name": "__udivmoddi4"
        }, 
        "isr_svc": {
            "renaming": {}, 
            "code": "\nvoid isr_svc(void)\n\n{\n  bool bVar1;\n  code *UNRECOVERED_JUMPTABLE;\n  code **ppcVar2;\n  \n  sched_run();\n  UNRECOVERED_JUMPTABLE = *(code **)**(undefined4 **)PTR_sched_active_thread_0000098c;\n  ppcVar2 = (code **)**(undefined4 **)PTR_sched_active_thread_0000098c + 9;\n  bVar1 = (bool)isCurrentModePrivileged();\n  if (bVar1) {\n    setProcessStackPointer(ppcVar2);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)(UNRECOVERED_JUMPTABLE,ppcVar2);\n  return;\n}\n\n", 
            "called": [
                "sched_run"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000974", 
            "calling": [
                "isr_pendsv"
            ], 
            "imported": false, 
            "current_name": "isr_svc"
        }, 
        "phydat_prefix_from_scale": {
            "renaming": {}, 
            "code": "\nchar phydat_prefix_from_scale(int8_t scale)\n\n{\n  char cVar1;\n  \n  switch(scale) {\n  case '\\x02':\n    cVar1 = 'h';\n    break;\n  case '\\x03':\n    cVar1 = 'k';\n    break;\n  case '\\x06':\n    cVar1 = 'M';\n    break;\n  case '\\t':\n    cVar1 = 'G';\n    break;\n  case '\\f':\n    cVar1 = 'T';\n    break;\n  case '\\x0f':\n    cVar1 = 'P';\n    break;\n  case -0xf:\n    cVar1 = 'f';\n    break;\n  default:\n    cVar1 = '\\0';\n    break;\n  case -0xc:\n    cVar1 = 'p';\n    break;\n  case -9:\n    cVar1 = 'n';\n    break;\n  case -6:\n    cVar1 = 'u';\n    break;\n  case -3:\n    cVar1 = 'm';\n  }\n  return cVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00003918", 
            "calling": [
                "phydat_dump"
            ], 
            "imported": false, 
            "current_name": "phydat_prefix_from_scale"
        }, 
        "_findenv_r": {
            "renaming": {}, 
            "code": "\nchar * _findenv_r(undefined4 param_1,char *param_2,int *param_3)\n\n{\n  char cVar1;\n  undefined *puVar2;\n  char **ppcVar3;\n  int iVar4;\n  char *pcVar5;\n  char **ppcVar6;\n  size_t __n;\n  \n  __env_lock();\n  puVar2 = PTR_environ_0000569c;\n  pcVar5 = param_2;\n  if (*(char ***)PTR_environ_0000569c != (char **)0x0) {\n    do {\n      cVar1 = *pcVar5;\n      if (cVar1 == '\\0') {\n        __n = (int)pcVar5 - (int)param_2;\n        ppcVar3 = *(char ***)PTR_environ_0000569c;\n        while( true ) {\n          ppcVar6 = ppcVar3;\n          if (*ppcVar6 == (char *)0x0) break;\n          iVar4 = strncmp(*ppcVar6,param_2,__n);\n          ppcVar3 = ppcVar6 + 1;\n          if ((iVar4 == 0) && (pcVar5 = *ppcVar6, pcVar5[__n] == '=')) {\n            *param_3 = (int)ppcVar6 - *(int *)puVar2 >> 2;\n            __env_unlock(param_1);\n            return pcVar5 + __n + 1;\n          }\n        }\n        break;\n      }\n      pcVar5 = pcVar5 + 1;\n    } while (cVar1 != '=');\n  }\n  __env_unlock(param_1);\n  return (char *)0x0;\n}\n\n", 
            "called": [
                "strncmp", 
                "__env_lock", 
                "__env_unlock"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000562c", 
            "calling": [
                "_getenv_r"
            ], 
            "imported": false, 
            "current_name": "_findenv_r"
        }, 
        "__aeabi_ldivmod": {
            "renaming": {}, 
            "code": "\nint __aeabi_ldivmod(int param_1,int param_2,int param_3,int param_4)\n\n{\n  int iVar1;\n  undefined local_8 [8];\n  \n  if ((param_4 == 0) && (param_3 == 0)) {\n    if (param_2 < 0) {\n      param_1 = 0;\n      param_2 = -0x80000000;\n    }\n    else if (param_2 != 0 || param_1 != 0) {\n      param_2 = 0x7fffffff;\n      param_1 = -1;\n    }\n    iVar1 = __aeabi_idiv0(param_1,param_2);\n    return iVar1;\n  }\n  if (param_2 < 0) {\n    iVar1 = -param_2 - (uint)(param_1 != 0);\n    if (param_4 < 0) {\n      iVar1 = __udivmoddi4(-param_1,iVar1,-param_3,-param_4 - (uint)(param_3 != 0),local_8);\n      return iVar1;\n    }\n    iVar1 = __udivmoddi4(-param_1,iVar1,param_3,param_4,local_8);\n    return -iVar1;\n  }\n  if (param_4 < 0) {\n    iVar1 = __udivmoddi4(param_1,param_2,-param_3,-param_4 - (uint)(param_3 != 0),local_8);\n    return -iVar1;\n  }\n  iVar1 = __udivmoddi4();\n  return iVar1;\n}\n\n", 
            "called": [
                "__udivmoddi4", 
                "__aeabi_idiv0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00006974", 
            "calling": [
                "gmtime_r"
            ], 
            "imported": false, 
            "current_name": "__aeabi_ldivmod"
        }, 
        "rtt_poweron": {
            "renaming": {}, 
            "code": "\nvoid rtt_poweron(void)\n\n{\n  RTC_Type *rtt;\n  \n  *(uint *)(DAT_0000296c + 0x14) = *(uint *)(DAT_0000296c + 0x14) | 0x10;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000294c", 
            "calling": [
                "rtt_init", 
                "rtc_poweron"
            ], 
            "imported": false, 
            "current_name": "rtt_poweron"
        }, 
        "rtt_init": {
            "renaming": {}, 
            "code": "\nvoid rtt_init(void)\n\n{\n  undefined4 *puVar1;\n  RTC_Type *rtt;\n  \n  puVar1 = DAT_00002814;\n  *(uint *)(DAT_00002818 + 0x103c) = *(uint *)(DAT_00002818 + 0x103c) | 0x20000000;\n  puVar1[4] = 1;\n  puVar1[4] = 0;\n  if ((puVar1[5] & 1) != 0) {\n    *puVar1 = 0;\n  }\n  puVar1[4] = 0x104;\n  puVar1[2] = 0xffffff42;\n  puVar1[7] = 0;\n  rtt_poweron();\n  return;\n}\n\n", 
            "called": [
                "rtt_poweron"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000027b0", 
            "calling": [
                "rtc_init"
            ], 
            "imported": false, 
            "current_name": "rtt_init"
        }, 
        "_rtc_usage": {
            "renaming": {}, 
            "code": "\nint _rtc_usage(void)\n\n{\n  puts(PTR_s_usage__rtc__command___arguments__00003500);\n  puts(PTR_s_commands__00003504);\n  puts(PTR_s__poweron_power_the_interface_on_00003508);\n  puts(PTR_s__poweroff_power_the_interface_of_0000350c);\n  puts(PTR_s__clearalarm_deactivate_the_curre_00003510);\n  puts(PTR_s__getalarm_print_the_currently_al_00003514);\n  puts(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n  puts(PTR_s__gettime_print_the_current_time_0000351c);\n  puts(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n  return 0;\n}\n\n", 
            "called": [
                "puts"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000034c0", 
            "calling": [
                "_rtc_handler"
            ], 
            "imported": false, 
            "current_name": "_rtc_usage"
        }, 
        "dow": {
            "renaming": {}, 
            "code": "\nint dow(int year,int month,int day)\n\n{\n  byte bVar1;\n  int iVar2;\n  int iVar3;\n  \n  iVar2 = month;\n  if (month < 3) {\n    iVar2 = 1;\n  }\n  bVar1 = (byte)iVar2;\n  if (2 < month) {\n    bVar1 = 0;\n  }\n  iVar3 = year - (uint)bVar1;\n  iVar2 = iVar3;\n  if (iVar3 < 0) {\n    iVar2 = iVar3 + 3;\n  }\n  iVar2 = (((iVar2 >> 2) + iVar3) - (int)((longlong)DAT_00003280 * (longlong)iVar3 >> 0x25)) +\n          (int)((longlong)DAT_00003280 * (longlong)iVar3 >> 0x27) +\n          *(int *)(PTR_t_00003284 + (month + -1) * 4) + day;\n  return iVar2 + (((int)((ulonglong)((longlong)DAT_00003288 * (longlong)iVar2) >> 0x20) + iVar2 >> 2\n                  ) - (iVar2 >> 0x1f)) * -7;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000031fc", 
            "calling": [
                "_parse_time"
            ], 
            "imported": false, 
            "current_name": "dow"
        }, 
        "_cleanup_r": {
            "renaming": {}, 
            "code": "\nvoid _cleanup_r(undefined4 param_1)\n\n{\n  _fwalk_reent(param_1,DAT_00004244);\n  return;\n}\n\n", 
            "called": [
                "_fwalk_reent"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000423c", 
            "calling": [], 
            "imported": false, 
            "current_name": "_cleanup_r"
        }, 
        "kinetis_mcg_init_erclk32k": {
            "renaming": {}, 
            "code": "\nvoid kinetis_mcg_init_erclk32k(void)\n\n{\n  bit_set32(DAT_00001820,'\\x1d');\n  if ((*(uint *)(DAT_00001824 + 0x10) & 0x100) == 0) {\n    *(undefined4 *)(DAT_00001824 + 0x10) = 0x104;\n  }\n  *DAT_00001828 = *DAT_00001828 & 0xfff3ffff | 0x80000;\n  return;\n}\n\n", 
            "called": [
                "bit_set32"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000017dc", 
            "calling": [
                "kinetis_mcg_init"
            ], 
            "imported": false, 
            "current_name": "kinetis_mcg_init_erclk32k"
        }, 
        "strtol": {
            "renaming": {}, 
            "code": "\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n  long lVar1;\n  \n  lVar1 = _strtol_l_isra_0(*(undefined4 *)PTR__impure_ptr_00004f94,__nptr,__endptr,__base);\n  return lVar1;\n}\n\n", 
            "called": [
                "_strtol_l.isra.0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004f84", 
            "calling": [
                "atoi", 
                "_parse_time"
            ], 
            "imported": false, 
            "current_name": "strtol"
        }, 
        "uart_stdio_init": {
            "renaming": {}, 
            "code": "\nvoid uart_stdio_init(void)\n\n{\n  uart_init(0,0x1c200,DAT_00000e10,PTR_uart_stdio_isrpipe_00000e0c);\n  return;\n}\n\n", 
            "called": [
                "uart_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000df4", 
            "calling": [
                "_init"
            ], 
            "imported": false, 
            "current_name": "uart_stdio_init"
        }, 
        "thread_yield_higher": {
            "renaming": {}, 
            "code": "\nvoid thread_yield_higher(void)\n\n{\n  *(uint *)(DAT_00000954 + 4) = *(uint *)(DAT_00000954 + 4) | 0x10000000;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000093c", 
            "calling": [
                "cortexm_isr_end", 
                "sched_switch", 
                "cortexm_isr_end", 
                "cortexm_isr_end", 
                "_mutex_lock"
            ], 
            "imported": false, 
            "current_name": "thread_yield_higher"
        }, 
        "atoi": {
            "renaming": {}, 
            "code": "\nint atoi(char *__nptr)\n\n{\n  long lVar1;\n  \n  lVar1 = strtol(__nptr,(char **)0x0,10);\n  return lVar1;\n}\n\n", 
            "called": [
                "strtol"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004042", 
            "calling": [
                "write", 
                "read"
            ], 
            "imported": false, 
            "current_name": "atoi"
        }, 
        "sched_run": {
            "renaming": {}, 
            "code": "\nint sched_run(void)\n\n{\n  uint uVar1;\n  int iVar2;\n  int iVar3;\n  thread_t *active_thread;\n  int nextrq;\n  clist_node_t *__m____;\n  thread_t *next_thread;\n  \n  *(undefined4 *)PTR_sched_context_switch_request_00000684 = 0;\n  iVar2 = *(int *)PTR_sched_active_thread_00000688;\n  uVar1 = bitarithm_lsb(*(uint *)PTR_runqueue_bitcache_0000068c);\n  iVar3 = **(int **)(PTR_sched_runqueues_00000690 + uVar1 * 4);\n  if (iVar2 == iVar3 + -8) {\n    iVar2 = 0;\n  }\n  else {\n    if ((iVar2 != 0) && (*(char *)(iVar2 + 4) == '\\t')) {\n      *(undefined *)(iVar2 + 4) = 10;\n    }\n    *(undefined *)(iVar3 + -4) = 9;\n    *(undefined2 *)PTR_sched_active_pid_00000694 = *(undefined2 *)(iVar3 + -2);\n    *(int *)PTR_sched_active_thread_00000688 = iVar3 + -8;\n    iVar2 = 1;\n  }\n  return iVar2;\n}\n\n", 
            "called": [
                "bitarithm_lsb"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000610", 
            "calling": [
                "isr_svc"
            ], 
            "imported": false, 
            "current_name": "sched_run"
        }, 
        "_alarm_handler": {
            "renaming": {}, 
            "code": "\nvoid _alarm_handler(void *arg)\n\n{\n  puts(PTR_s_The_alarm_rang_000031f8);\n  return;\n}\n\n", 
            "called": [
                "puts"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000031e0", 
            "calling": [], 
            "imported": false, 
            "current_name": "_alarm_handler"
        }, 
        "_strtoul_r": {
            "renaming": {}, 
            "code": "\nuint _strtoul_r(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  byte bVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  byte *pbVar7;\n  byte *pbVar8;\n  \n  pbVar8 = param_2;\n  do {\n    pbVar7 = pbVar8;\n    pbVar8 = pbVar7 + 1;\n    uVar2 = (uint)*pbVar7;\n    bVar3 = PTR_DAT_00005fd0[uVar2] & 8;\n  } while ((PTR_DAT_00005fd0[uVar2] & 8) != 0);\n  if (uVar2 == 0x2d) {\n    uVar2 = (uint)*pbVar8;\n    bVar3 = 1;\n    pbVar8 = pbVar7 + 2;\n  }\n  else if (uVar2 == 0x2b) {\n    uVar2 = (uint)*pbVar8;\n    pbVar8 = pbVar7 + 2;\n  }\n  if (param_4 == 0) {\n    if (uVar2 != 0x30) {\n      param_4 = 10;\n      goto LAB_00005f26;\n    }\n  }\n  else if ((param_4 != 0x10) || (uVar2 != 0x30)) goto LAB_00005f26;\n  if ((*pbVar8 & 0xdf) == 0x58) {\n    uVar2 = (uint)pbVar8[1];\n    param_4 = 0x10;\n    pbVar8 = pbVar8 + 2;\n  }\n  else {\n    uVar2 = 0x30;\n    if (param_4 == 0) {\n      param_4 = 8;\n    }\n  }\nLAB_00005f26:\n  iVar4 = 0;\n  uVar6 = 0xffffffff / param_4;\n  uVar1 = 0;\n  do {\n    uVar5 = uVar2 - 0x30;\n    if (9 < uVar5) {\n      if (uVar2 - 0x41 < 0x1a) {\n        uVar5 = uVar2 - 0x37;\n      }\n      else {\n        if (0x19 < uVar2 - 0x61) break;\n        uVar5 = uVar2 - 0x57;\n      }\n    }\n    if ((int)param_4 <= (int)uVar5) break;\n    if (((iVar4 < 0) || (uVar6 < uVar1)) ||\n       ((uVar6 == uVar1 && ((int)~(param_4 * uVar6) < (int)uVar5)))) {\n      iVar4 = -1;\n    }\n    else {\n      uVar1 = uVar1 * param_4 + uVar5;\n      iVar4 = 1;\n    }\n    uVar2 = (uint)*pbVar8;\n    pbVar8 = pbVar8 + 1;\n  } while( true );\n  if (iVar4 < 0) {\n    *param_1 = 0x22;\n    uVar1 = 0xffffffff;\n    if (param_3 == (byte **)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (bVar3 != 0) {\n      uVar1 = -uVar1;\n    }\n    if (param_3 == (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar4 == 0) goto LAB_00005fb8;\n  }\n  param_2 = pbVar8 + -1;\nLAB_00005fb8:\n  *param_3 = param_2;\n  return uVar1;\n}\n\n", 
            "called": [
                "_strtoul_l.isra.0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00005fd4", 
            "calling": [], 
            "imported": false, 
            "current_name": "_strtoul_r"
        }, 
        "pm_off": {
            "renaming": {}, 
            "code": "\nvoid pm_off(void)\n\n{\n  irq_disable();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
            "called": [
                "irq_disable"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000e58", 
            "calling": [
                "core_panic"
            ], 
            "imported": false, 
            "current_name": "pm_off"
        }, 
        "_getc_r": {
            "renaming": {}, 
            "code": "\nuint _getc_r(int param_1,byte **param_2)\n\n{\n  uint uVar1;\n  byte *pbVar2;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_2 == (byte **)PTR___sf_fake_stdin_00005620) {\n    param_2 = *(byte ***)(param_1 + 4);\n  }\n  else if (param_2 == (byte **)PTR___sf_fake_stdout_00005624) {\n    param_2 = *(byte ***)(param_1 + 8);\n  }\n  else if (param_2 == (byte **)PTR___sf_fake_stderr_00005628) {\n    param_2 = *(byte ***)(param_1 + 0xc);\n  }\n  if ((-1 < (int)param_2[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(param_2 + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(param_2[0x16]);\n  }\n  pbVar2 = param_2[1];\n  param_2[1] = pbVar2 + -1;\n  if ((int)(pbVar2 + -1) < 0) {\n    uVar1 = __srget_r(param_1,param_2);\n  }\n  else {\n    pbVar2 = *param_2;\n    *param_2 = pbVar2 + 1;\n    uVar1 = (uint)*pbVar2;\n  }\n  if ((-1 < (int)param_2[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(param_2 + 3) << 0x16))) {\n    __retarget_lock_release_recursive(param_2[0x16]);\n  }\n  return uVar1;\n}\n\n", 
            "called": [
                "__retarget_lock_acquire_recursive", 
                "__srget_r", 
                "__retarget_lock_release_recursive", 
                "__sinit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000055ac", 
            "calling": [
                "getchar"
            ], 
            "imported": false, 
            "current_name": "_getc_r"
        }, 
        "list_remove_head": {
            "renaming": {}, 
            "code": "\nlist_node_t * list_remove_head(list_node_t *list)\n\n{\n  list_node *plVar1;\n  list_node_t *head;\n  \n  plVar1 = list->next;\n  if (plVar1 != (list_node *)0x0) {\n    list->next = plVar1->next;\n  }\n  return plVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000240c", 
            "calling": [
                "mutex_unlock"
            ], 
            "imported": false, 
            "current_name": "list_remove_head"
        }, 
        "puts": {
            "renaming": {}, 
            "code": "\nint puts(char *__s)\n\n{\n  int iVar1;\n  \n  iVar1 = _puts_r(*(undefined4 *)PTR__impure_ptr_00004dc4,__s);\n  return iVar1;\n}\n\n", 
            "called": [
                "_puts_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004db8", 
            "calling": [
                "probe_all", 
                "handle_input_line", 
                "_rtc_getalarm", 
                "main", 
                "print_help", 
                "phydat_dump", 
                "read", 
                "_rtc_settime", 
                "write", 
                "hard_fault_handler", 
                "_rtc_setalarm", 
                "_rtc_usage", 
                "_rtc_gettime", 
                "_alarm_handler", 
                "list"
            ], 
            "imported": false, 
            "current_name": "puts"
        }, 
        "mktime": {
            "renaming": {}, 
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\ntime_t mktime(tm *__tp)\n\n{\n  longlong lVar1;\n  int *piVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  int iVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  uint uVar14;\n  time_t tVar15;\n  bool bVar16;\n  \n  piVar2 = (int *)__gettzinfo();\n  validate_structure(__tp);\n  uVar11 = __tp->tm_year;\n  iVar10 = __tp->tm_mday + -1 + *(int *)(PTR__DAYS_BEFORE_MONTH_00004adc + __tp->tm_mon * 4);\n  if (((1 < __tp->tm_mon) && ((uVar11 & 3) == 0)) &&\n     ((uVar11 != (uVar11 / 100) * 100 || (uVar11 + 0x76c == ((uVar11 + 0x76c) / 400) * 400)))) {\n    iVar10 = iVar10 + 1;\n  }\n  __tp->tm_yday = iVar10;\n  if (20000 < (int)&PTR_rtc_callback_00002710 + uVar11) {\n    return -1;\n  }\n  if ((int)uVar11 < 0x47) {\n    if (uVar11 != 0x46) {\n      for (uVar8 = 0x45; (int)uVar11 < (int)uVar8; uVar8 = uVar8 - 1) {\n        if ((uVar8 & 3) == 0) {\n          if (uVar8 == (uVar8 / 100) * 100) {\n            if ((uVar8 + 0x76c) % 400 == 0) {\n              iVar6 = 0x16e;\n            }\n            else {\n              iVar6 = 0x16d;\n            }\n          }\n          else {\n            iVar6 = 0x16e;\n          }\n        }\n        else {\n          iVar6 = 0x16d;\n        }\n        iVar10 = iVar10 - iVar6;\n      }\n      if ((uVar8 & 3) == 0) {\n        if (uVar11 == (uVar11 / 100) * 100) {\n          iVar6 = 0x16d;\n          if ((uVar11 + 0x76c) % 400 == 0) {\n            iVar6 = 0x16e;\n          }\n        }\n        else {\n          iVar6 = 0x16e;\n        }\n      }\n      else {\n        iVar6 = 0x16d;\n      }\n      iVar10 = iVar10 - iVar6;\n    }\n  }\n  else {\n    uVar8 = 0x46;\n    do {\n      if ((uVar8 & 3) == 0) {\n        if (uVar8 % 100 == 0) {\n          if ((uVar8 + 0x76c) % 400 == 0) {\n            iVar6 = 0x16e;\n          }\n          else {\n            iVar6 = 0x16d;\n          }\n        }\n        else {\n          iVar6 = 0x16e;\n        }\n      }\n      else {\n        iVar6 = 0x16d;\n      }\n      uVar8 = uVar8 + 1;\n      iVar10 = iVar10 + iVar6;\n    } while (uVar11 != uVar8);\n  }\n  lVar1 = (longlong)DAT_00004ae0 * (longlong)iVar10 +\n          (longlong)(__tp->tm_hour * 0xe10 + __tp->tm_min * 0x3c + __tp->tm_sec);\n  uVar14 = (uint)lVar1;\n  iVar6 = (int)((ulonglong)lVar1 >> 0x20);\n  __tz_lock();\n  _tzset_unlocked();\n  uVar8 = *(uint *)PTR__daylight_00004ae4;\n  if (*(uint *)PTR__daylight_00004ae4 == 0) {\nLAB_00004934:\n    tVar15 = uVar14 + piVar2[10];\n  }\n  else {\n    uVar13 = __tp->tm_isdst;\n    uVar12 = uVar13;\n    if (0 < (int)uVar13) {\n      uVar12 = 1;\n    }\n    if ((piVar2[1] == __tp->tm_year + 0x76c) || (iVar4 = __tzcalc_limits(), iVar4 != 0)) {\n      uVar9 = piVar2[0x14];\n      uVar3 = piVar2[0x12];\n      uVar7 = piVar2[10];\n      uVar8 = uVar3 - uVar7;\n      iVar4 = (piVar2[0x13] - ((int)uVar7 >> 0x1f)) - (uint)(uVar3 < uVar7);\n      if (((int)((iVar6 - iVar4) - (uint)(uVar14 < uVar8)) < 0 ==\n           (SBORROW4(iVar6,iVar4) != SBORROW4(iVar6 - iVar4,(uint)(uVar14 < uVar8)))) &&\n         (iVar5 = (piVar2[0x13] - ((int)uVar9 >> 0x1f)) - (uint)(uVar3 < uVar9),\n         bVar16 = uVar14 < uVar3 - uVar9,\n         (int)((iVar6 - iVar5) - (uint)bVar16) < 0 !=\n         (SBORROW4(iVar6,iVar5) != SBORROW4(iVar6 - iVar5,(uint)bVar16)))) goto LAB_00004a88;\n      uVar3 = piVar2[8] - uVar9;\n      iVar5 = (piVar2[9] - ((int)uVar9 >> 0x1f)) - (uint)((uint)piVar2[8] < uVar9);\n      if (*piVar2 != 0) {\n        if ((int)((iVar6 - iVar5) - (uint)(uVar14 < uVar3)) < 0 ==\n            (SBORROW4(iVar6,iVar5) != SBORROW4(iVar6 - iVar5,(uint)(uVar14 < uVar3))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        uVar8 = 0;\n        if ((int)uVar13 < 0) goto LAB_00004934;\nLAB_00004a14:\n        uVar13 = uVar12 ^ uVar8;\n        uVar12 = uVar8;\n        if (uVar13 == 1) {\n          if (uVar8 == 0) {\n            iVar6 = uVar9 - uVar7;\n          }\n          else {\n            iVar6 = uVar7 - uVar9;\n          }\n          iVar4 = __tp->tm_mday;\n          uVar14 = uVar14 + iVar6;\n          __tp->tm_sec = __tp->tm_sec + iVar6;\n          validate_structure(__tp);\n          iVar4 = __tp->tm_mday - iVar4;\n          if (iVar4 != 0) {\n            if (iVar4 < 2) {\n              if (iVar4 == -2 || iVar4 + 2 < 0 != SCARRY4(iVar4,2)) {\n                iVar4 = 1;\n              }\n            }\n            else {\n              iVar4 = -1;\n            }\n            iVar6 = iVar4 + __tp->tm_yday;\n            iVar10 = iVar10 + iVar4;\n            if (iVar6 < 0) {\n              uVar8 = uVar11 - 1;\n              if ((uVar8 & 3) == 0) {\n                if (uVar8 == (uVar8 / 100) * 100) {\n                  iVar6 = 0x16d;\n                  if ((uVar11 + 0x76b) % 400 != 0) {\n                    iVar6 = 0x16c;\n                  }\n                }\n                else {\n                  iVar6 = 0x16d;\n                }\n              }\n              else {\n                iVar6 = 0x16c;\n              }\n            }\n            else {\n              if ((uVar11 & 3) == 0) {\n                if (uVar11 == (uVar11 / 100) * 100) {\n                  iVar4 = 0x16d;\n                  if ((uVar11 + 0x76c) % 400 == 0) {\n                    iVar4 = 0x16e;\n                  }\n                }\n                else {\n                  iVar4 = 0x16e;\n                }\n              }\n              else {\n                iVar4 = 0x16d;\n              }\n              if (iVar4 <= iVar6) {\n                iVar6 = iVar6 - iVar4;\n              }\n            }\n            __tp->tm_yday = iVar6;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((iVar6 - iVar5) - (uint)(uVar14 < uVar3)) < 0 !=\n          (SBORROW4(iVar6,iVar5) != SBORROW4(iVar6 - iVar5,(uint)(uVar14 < uVar3)))) {\nLAB_0000491e:\n        if ((int)((iVar6 - iVar4) - (uint)(uVar14 < uVar8)) < 0 ==\n            (SBORROW4(iVar6,iVar4) != SBORROW4(iVar6 - iVar4,(uint)(uVar14 < uVar8))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)uVar13) {\n        uVar8 = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      uVar8 = uVar12;\n      if (uVar12 != 1) goto LAB_00004934;\n    }\n    tVar15 = uVar14 + piVar2[0x14];\n    uVar8 = 1;\n  }\n  __tz_unlock();\n  __tp->tm_isdst = uVar8;\n  __tp->tm_wday = (iVar10 + 4U) % 7;\n  return tVar15;\n}\n\n", 
            "called": [
                "validate_structure", 
                "__tz_unlock", 
                "_tzset_unlocked", 
                "__gettzinfo", 
                "__tz_lock", 
                "__tzcalc_limits"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000047e4", 
            "calling": [
                "rtc_set_alarm", 
                "rtc_set_time"
            ], 
            "imported": false, 
            "current_name": "mktime"
        }, 
        "kinetis_mcg_init_mcgirclk": {
            "renaming": {}, 
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0000187c) */\n/* WARNING: Removing unreachable block (ram,0x0000186a) */\n/* WARNING: Removing unreachable block (ram,0x00001898) */\n\nvoid kinetis_mcg_init_mcgirclk(void)\n\n{\n  uint8_t tmp;\n  \n  DAT_000018b4[8] = DAT_000018b4[8] & 0xd0;\n  bit_set8(DAT_000018b8,'\\0');\n  bit_clear8(DAT_000018b4,'\\x01');\n  bit_clear8(DAT_000018b4,'\\0');\n  return;\n}\n\n", 
            "called": [
                "bit_set8", 
                "bit_clear8"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000182c", 
            "calling": [
                "kinetis_mcg_init"
            ], 
            "imported": false, 
            "current_name": "kinetis_mcg_init_mcgirclk"
        }, 
        "memchr": {
            "renaming": {}, 
            "code": "\nvoid * memchr(void *__s,int __c,size_t __n)\n\n{\n  byte bVar1;\n  char cVar2;\n  char cVar3;\n  char cVar4;\n  char cVar5;\n  byte *pbVar6;\n  uint *puVar7;\n  byte *pbVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  bool bVar14;\n  bool bVar15;\n  bool bVar16;\n  bool bVar17;\n  \n  uVar9 = __c & 0xff;\n  if ((int)__n < 0x10) {\njoined_r0x00006070:\n    do {\n      if (__n == 0) {\n        return (void *)0x0;\n      }\n                    /* WARNING: Load size is inaccurate */\n      puVar7 = (uint *)((int)__s + 1);\n      bVar1 = *__s;\n      __n = __n - 1;\n      __s = puVar7;\n    } while (bVar1 != uVar9);\n  }\n  else {\n    uVar10 = (uint)__s & 7;\n    while( true ) {\n      if (uVar10 == 0) {\n        uVar10 = uVar9 | uVar9 << 8;\n        uVar10 = uVar10 | uVar10 << 0x10;\n        uVar11 = __n & 0xfffffff8;\n        do {\n          puVar7 = (uint *)((int)__s + 8);\n                    /* WARNING: Load size is inaccurate */\n          uVar11 = uVar11 - 8;\n          uVar12 = *__s ^ uVar10;\n          uVar13 = *(uint *)((int)__s + 4) ^ uVar10;\n          cVar2 = -((char)uVar12 == '\\0');\n          cVar3 = -((char)(uVar12 >> 8) == '\\0');\n          cVar4 = -((char)(uVar12 >> 0x10) == '\\0');\n          cVar5 = -((char)(uVar12 >> 0x18) == '\\0');\n          uVar12 = CONCAT13(cVar5,CONCAT12(cVar4,CONCAT11(cVar3,cVar2)));\n          bVar14 = (char)uVar13 != '\\0';\n          bVar15 = (char)(uVar13 >> 8) != '\\0';\n          bVar16 = (char)(uVar13 >> 0x10) != '\\0';\n          bVar17 = (char)(uVar13 >> 0x18) != '\\0';\n          uVar13 = CONCAT13(bVar17 * cVar5 - !bVar17,\n                            CONCAT12(bVar16 * cVar4 - !bVar16,\n                                     CONCAT11(bVar15 * cVar3 - !bVar15,bVar14 * cVar2 - !bVar14)));\n          if (uVar13 != 0) {\n            if (uVar12 == 0) {\n              pbVar8 = (byte *)((int)__s + 5);\n              uVar12 = uVar13;\n            }\n            else {\n              pbVar8 = (byte *)((int)__s + 1);\n            }\n            if ((uVar12 & 1) == 0) {\n              bVar14 = (uVar12 & 0x100) == 0;\n              pbVar6 = pbVar8 + 1;\n              if (bVar14) {\n                bVar14 = (uVar12 & 0x18000) == 0;\n                pbVar6 = pbVar8 + 2;\n              }\n              pbVar8 = pbVar6;\n              if (bVar14) {\n                pbVar8 = pbVar8 + 1;\n              }\n            }\n            return pbVar8 + -1;\n          }\n          __s = puVar7;\n        } while (uVar11 != 0);\n        __n = __n & 7;\n        goto joined_r0x00006070;\n      }\n                    /* WARNING: Load size is inaccurate */\n      puVar7 = (uint *)((int)__s + 1);\n      __n = __n - 1;\n      if (*__s == uVar9) break;\n      uVar10 = (uint)puVar7 & 7;\n      __s = puVar7;\n      if (__n == 0) {\n        return (void *)0x0;\n      }\n    }\n  }\n  return (byte *)((int)puVar7 + -1);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00006010", 
            "calling": [
                "__ssvfiscanf_r", 
                "_printf_i", 
                "_vfprintf_r", 
                "_scanf_i"
            ], 
            "imported": false, 
            "current_name": "memchr"
        }, 
        "__retarget_lock_acquire": {
            "renaming": {}, 
            "code": "\nvoid __retarget_lock_acquire(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000045e6", 
            "calling": [
                "__tz_lock"
            ], 
            "imported": false, 
            "current_name": "__retarget_lock_acquire"
        }, 
        "__sflush_r": {
            "renaming": {}, 
            "code": "\nint __sflush_r(uint *param_1,int *param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  uint uVar3;\n  ushort uVar4;\n  int iVar5;\n  code *pcVar6;\n  int iVar7;\n  uint uVar8;\n  bool bVar9;\n  \n  uVar4 = *(ushort *)(param_2 + 3);\n  uVar3 = (uint)uVar4;\n  if ((int)(uVar3 << 0x1c) < 0) {\n    iVar1 = param_2[4];\n    if (iVar1 != 0) {\n      iVar5 = uVar3 << 0x1e;\n      bVar9 = iVar5 == 0;\n      iVar7 = *param_2;\n      if (bVar9) {\n        iVar5 = param_2[5];\n      }\n      *param_2 = iVar1;\n      if (!bVar9) {\n        iVar5 = 0;\n      }\n      param_2[2] = iVar5;\n      for (iVar7 = iVar7 - iVar1; 0 < iVar7; iVar7 = iVar7 - iVar5) {\n        iVar5 = (*(code *)param_2[10])(param_1,param_2[8],iVar1,iVar7);\n        if (iVar5 < 1) {\n          *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 0x40;\n          return -1;\n        }\n        iVar1 = iVar1 + iVar5;\n      }\n    }\n  }\n  else {\n    if ((param_2[1] < 1) && (param_2[0x10] < 1)) {\n      return 0;\n    }\n    pcVar6 = (code *)param_2[0xb];\n    if (pcVar6 == (code *)0x0) {\n      return 0;\n    }\n    uVar8 = *param_1;\n    *param_1 = 0;\n    if ((uVar4 & 0x1000) == 0) {\n      iVar1 = (*pcVar6)(param_1,param_2[8],uVar3 & 0x1000,1);\n      if ((iVar1 == -1) && (uVar3 = *param_1, uVar3 != 0)) {\n        if ((uVar3 == 0x1d) || (uVar3 == 0x16)) {\n          *param_1 = uVar8;\n          return 0;\n        }\n        uVar4 = *(ushort *)(param_2 + 3);\n        goto LAB_00004104;\n      }\n    }\n    else {\n      iVar1 = param_2[0x15];\n    }\n    if (((int)((uint)*(ushort *)(param_2 + 3) << 0x1d) < 0) &&\n       (iVar1 = iVar1 - param_2[1], param_2[0xd] != 0)) {\n      iVar1 = iVar1 - param_2[0x10];\n    }\n    iVar1 = (*(code *)param_2[0xb])(param_1,param_2[8],iVar1,0);\n    uVar4 = *(ushort *)(param_2 + 3);\n    if ((iVar1 == -1) &&\n       ((0x1d < *param_1 || (-1 < (int)((DAT_00004154 >> (*param_1 & 0xff)) << 0x1f))))) {\nLAB_00004104:\n      *(ushort *)(param_2 + 3) = uVar4 | 0x40;\n      return iVar1;\n    }\n    param_2[1] = 0;\n    *param_2 = param_2[4];\n    if (((int)((uint)uVar4 << 0x13) < 0) && ((iVar1 != -1 || (*param_1 == 0)))) {\n      param_2[0x15] = iVar1;\n    }\n    piVar2 = (int *)param_2[0xd];\n    *param_1 = uVar8;\n    if (piVar2 != (int *)0x0) {\n      if (piVar2 != param_2 + 0x11) {\n        _free_r(param_1);\n      }\n      param_2[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n", 
            "called": [
                "_free_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000404c", 
            "calling": [
                "__srefill_r", 
                "_fflush_r"
            ], 
            "imported": false, 
            "current_name": "__sflush_r"
        }, 
        "fflush": {
            "renaming": {}, 
            "code": "\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  if (__stream == (FILE *)0x0) {\n    iVar1 = _fwalk_reent(*(undefined4 *)PTR__global_impure_ptr_000041e8,DAT_000041ec);\n    return iVar1;\n  }\n  iVar1 = _fflush_r(*(undefined4 *)PTR__impure_ptr_000041f0,__stream);\n  return iVar1;\n}\n\n", 
            "called": [
                "_fflush_r", 
                "_fwalk_reent"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000041d0", 
            "calling": [
                "lflush", 
                "print_prompt"
            ], 
            "imported": false, 
            "current_name": "fflush"
        }, 
        "post_startup": {
            "renaming": {}, 
            "code": "\nvoid post_startup(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000990", 
            "calling": [
                "reset_handler_default"
            ], 
            "imported": false, 
            "current_name": "post_startup"
        }, 
        "_printf_i": {
            "renaming": {}, 
            "code": "\ncode * _printf_i(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  bool bVar1;\n  byte bVar2;\n  undefined *puVar3;\n  int iVar4;\n  code *pcVar5;\n  void *pvVar6;\n  int iVar7;\n  undefined *__s;\n  uint uVar8;\n  uint *puVar9;\n  uint uVar10;\n  uint **ppuVar11;\n  uint uVar12;\n  undefined *puVar13;\n  uint *puVar14;\n  undefined4 uVar15;\n  code *local_24;\n  \n  puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n  bVar2 = *(byte *)(param_2 + 6);\n  __s = (undefined *)((int)param_2 + 0x43);\n  puVar14 = param_2;\n  uVar15 = param_3;\n  local_24 = param_4;\n  if (0x78 < bVar2) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)param_2 + 0x42) = bVar2;\nLAB_00005bdc:\n    __s = (undefined *)((int)param_2 + 0x42);\n    uVar8 = 1;\nLAB_00005d28:\n    param_2[4] = uVar8;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (bVar2 < 99) {\n    if (bVar2 == 0) goto LAB_00005d06;\n    if (bVar2 == 0x58) {\n      *(undefined *)((int)param_2 + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(bVar2) {\n  case 99:\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    *(char *)((int)param_2 + 0x42) = (char)uVar8;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    uVar10 = *param_2;\n    puVar9 = *param_5;\n    if ((int)(uVar10 << 0x18) < 0) {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n    }\n    else {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n      if ((uVar10 & 0x40) != 0) {\n        uVar8 = (uint)(short)uVar8;\n      }\n    }\n    if ((int)uVar8 < 0) {\n      uVar8 = -uVar8;\n      *(undefined *)((int)param_2 + 0x43) = 0x2d;\n    }\n    uVar10 = 10;\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    ppuVar11 = (uint **)*param_5;\n    uVar10 = *param_2;\n    uVar8 = param_2[5];\n    *param_5 = (uint *)(ppuVar11 + 1);\n    puVar9 = *ppuVar11;\n    if (((int)(uVar10 << 0x18) < 0) || (-1 < (int)(uVar10 << 0x19))) {\n      *puVar9 = uVar8;\n    }\n    else {\n      *(short *)puVar9 = (short)uVar8;\n    }\nLAB_00005d06:\n    param_2[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    puVar9 = *param_5;\n    uVar8 = *param_2;\n    *param_5 = puVar9 + 1;\n    if (((int)(uVar8 << 0x18) < 0) || (-1 < (int)(uVar8 << 0x19))) {\n      uVar8 = *puVar9;\n    }\n    else {\n      uVar8 = (uint)*(ushort *)puVar9;\n    }\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    if (bVar2 == 0x6f) {\n      uVar10 = 8;\n    }\n    else {\n      uVar10 = 10;\n    }\n    break;\n  case 0x70:\n    *param_2 = *param_2 | 0x20;\n  case 0x78:\n    puVar3 = PTR_s_0123456789abcdef_00005d7c;\n    *(undefined *)((int)param_2 + 0x45) = 0x78;\nLAB_00005ca8:\n    uVar10 = *param_2;\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    if ((-1 < (int)(uVar10 << 0x18)) && ((int)(uVar10 << 0x19) < 0)) {\n      uVar8 = uVar8 & 0xffff;\n    }\n    if ((int)(uVar10 << 0x1f) < 0) {\n      *param_2 = uVar10 | 0x20;\n    }\n    if (uVar8 == 0) {\n      *param_2 = *param_2 & 0xffffffdf;\n    }\n    uVar10 = 0x10;\n    break;\n  case 0x73:\n    puVar9 = *param_5;\n    *param_5 = puVar9 + 1;\n    __s = (undefined *)*puVar9;\n    pvVar6 = memchr(__s,0,param_2[1]);\n    if (pvVar6 != (void *)0x0) {\n      param_2[1] = (int)pvVar6 - (int)__s;\n    }\n    uVar8 = param_2[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)param_2 + 0x43) = 0;\nLAB_00005c36:\n  uVar12 = param_2[1];\n  param_2[2] = uVar12;\n  if (-1 < (int)uVar12) {\n    *param_2 = *param_2 & 0xfffffffb;\n  }\n  puVar13 = __s;\n  if ((uVar8 != 0) || (uVar12 != 0)) {\n    do {\n      puVar13 = puVar13 + -1;\n      *puVar13 = puVar3[uVar8 - uVar10 * (uVar8 / uVar10)];\n      bVar1 = uVar10 <= uVar8;\n      uVar8 = uVar8 / uVar10;\n    } while (bVar1);\n  }\n  if (((uVar10 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4])) {\n    puVar13[-1] = 0x30;\n    puVar13 = puVar13 + -1;\n  }\n  param_2[4] = (int)__s - (int)puVar13;\n  __s = puVar13;\nLAB_00005c84:\n  iVar4 = _printf_common(param_1,param_2,&local_24,param_3,param_4,puVar14,uVar15);\n  if ((iVar4 == -1) || (iVar4 = (*param_4)(param_1,param_3,__s,param_2[4]), iVar4 == -1)) {\nLAB_00005c98:\n    pcVar5 = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar4 = 0; iVar4 < (int)(param_2[3] - (int)local_24); iVar4 = iVar4 + 1) {\n        iVar7 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar7 == -1) goto LAB_00005c98;\n      }\n    }\n    pcVar5 = (code *)param_2[3];\n    if ((int)(code *)param_2[3] < (int)local_24) {\n      pcVar5 = local_24;\n    }\n  }\n  return pcVar5;\n}\n\n", 
            "called": [
                "memchr", 
                "_printf_common"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00005b34", 
            "calling": [
                "_vfprintf_r"
            ], 
            "imported": false, 
            "current_name": "_printf_i"
        }, 
        "_scanf_i": {
            "renaming": {}, 
            "code": "\nundefined4 _scanf_i(undefined4 param_1,uint *param_2,byte **param_3,undefined4 *param_4)\n\n{\n  void *pvVar1;\n  int iVar2;\n  undefined4 uVar3;\n  code *pcVar4;\n  uint uVar5;\n  byte *pbVar6;\n  uint uVar7;\n  undefined4 *puVar8;\n  uint *puVar9;\n  uint *puVar10;\n  uint *puVar11;\n  int unaff_r9;\n  int iVar12;\n  void *local_34 [4];\n  \n  local_34[0] = *(void **)PTR_PTR_DAT_00006744;\n  local_34[1] = (void *)*(undefined4 *)(PTR_PTR_DAT_00006744 + 4);\n  local_34[2] = (void *)*(undefined4 *)(PTR_PTR_DAT_00006744 + 8);\n  pcVar4 = DAT_0000674c;\n  if (param_2[6] != 3) {\n    pcVar4 = DAT_00006748;\n  }\n  uVar7 = param_2[2];\n  uVar5 = uVar7 - 1;\n  if (0x15c < uVar5) {\n    unaff_r9 = uVar7 - 0x15d;\n    uVar7 = 0x15d;\n  }\n  if (0x15c < uVar5) {\n    param_2[2] = uVar7;\n  }\n  puVar11 = param_2 + 7;\n  if (uVar5 < 0x15d) {\n    unaff_r9 = 0;\n  }\n  *param_2 = *param_2 | 0xd00;\n  iVar12 = 0;\n  puVar10 = puVar11;\n  do {\n    pvVar1 = memchr(local_34[iVar12],(uint)**param_3,2);\n    if (pvVar1 != (void *)0x0) {\n      if (iVar12 == 1) {\n        if (param_2[1] == 0) {\n          param_2[1] = 8;\n          *param_2 = *param_2 | 0x200;\n        }\n        uVar5 = *param_2 & 0xfffffaff;\nLAB_000065f4:\n        *param_2 = uVar5;\n      }\n      else if (iVar12 == 2) {\n        if ((*param_2 & 0x600) != 0x200) goto LAB_00006624;\n        param_2[1] = 0x10;\n        uVar5 = *param_2 | 0x100;\n        goto LAB_000065f4;\n      }\n      uVar5 = param_2[2];\n      param_2[2] = uVar5 - 1;\n      if (uVar5 != 0) {\n        pbVar6 = *param_3;\n        *param_3 = pbVar6 + 1;\n        puVar9 = (uint *)((int)puVar10 + 1);\n        *(byte *)puVar10 = *pbVar6;\n        pbVar6 = param_3[1];\n        param_3[1] = pbVar6 + -1;\n        puVar10 = puVar9;\n        if (((int)(pbVar6 + -1) < 1) &&\n           (iVar2 = (*(code *)param_2[0x60])(param_1,param_3), iVar2 != 0)) {\n          iVar12 = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    iVar12 = iVar12 + 1;\n  } while (iVar12 != 3);\n  if (param_2[1] == 0) {\n    param_2[1] = 10;\n  }\n  __sccl(param_2[5],(int)PTR_DAT_00006750 - param_2[1]);\n  iVar12 = 0;\n  while( true ) {\n    puVar9 = puVar10;\n    if (param_2[2] == 0) break;\n    pbVar6 = *param_3;\n    uVar5 = (uint)*pbVar6;\n    if (*(char *)(param_2[5] + uVar5) == '\\0') break;\n    if ((uVar5 == 0x30) && ((int)(*param_2 << 0x14) < 0)) {\n      iVar12 = iVar12 + 1;\n      if (unaff_r9 != 0) {\n        unaff_r9 = unaff_r9 + -1;\n        param_2[2] = param_2[2] + 1;\n      }\n    }\n    else {\n      *param_2 = *param_2 & 0xfffff6ff;\n      puVar9 = (uint *)((int)puVar10 + 1);\n      *(byte *)puVar10 = *pbVar6;\n    }\n    pbVar6 = param_3[1];\n    param_3[1] = pbVar6 + -1;\n    if ((int)(pbVar6 + -1) < 1) {\n      iVar2 = (*(code *)param_2[0x60])(param_1,param_3);\n      if (iVar2 != 0) break;\n    }\n    else {\n      *param_3 = *param_3 + 1;\n    }\n    param_2[2] = param_2[2] - 1;\n    puVar10 = puVar9;\n  }\nLAB_000066ca:\n  if ((int)(*param_2 << 0x17) < 0) {\n    if (puVar11 < puVar9) {\n      (*(code *)param_2[0x5f])(param_1,*(byte *)((int)puVar9 + -1),param_3);\n      puVar9 = (uint *)((int)puVar9 + -1);\n    }\n    if (puVar9 == puVar11) {\n      return 1;\n    }\n  }\n  if ((*param_2 & 0x10) == 0) {\n    *(byte *)puVar9 = 0;\n    uVar3 = (*pcVar4)(param_1,puVar11,0,param_2[1]);\n    puVar8 = (undefined4 *)*param_4;\n    uVar5 = *param_2;\n    *param_4 = puVar8 + 1;\n    puVar8 = (undefined4 *)*puVar8;\n    if ((uVar5 & 0x20) == 0) {\n      if ((int)(uVar5 << 0x1f) < 0) {\n        *(short *)puVar8 = (short)uVar3;\n      }\n      else {\n        *puVar8 = uVar3;\n      }\n    }\n    else {\n      *puVar8 = uVar3;\n    }\n    param_2[3] = param_2[3] + 1;\n  }\n  param_2[4] = (uint)((int)puVar9 + param_2[4] + (iVar12 - (int)puVar11));\n  return 0;\n}\n\n", 
            "called": [
                "__sccl", 
                "memchr"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000656c", 
            "calling": [
                "__ssvfiscanf_r"
            ], 
            "imported": false, 
            "current_name": "_scanf_i"
        }, 
        "kernel_init": {
            "renaming": {}, 
            "code": "\nvoid kernel_init(void)\n\n{\n  irq_disable();\n  thread_create(PTR_idle_stack_00000fdc,0x100,'\\x0f',0xc,DAT_00000fd8,(void *)0x0,\n                *(char **)PTR_idle_name_00000fd4);\n  thread_create(PTR_main_stack_00000fe8,0x600,'\\a',0xc,DAT_00000fe4,(void *)0x0,\n                *(char **)PTR_main_name_00000fe0);\n                    /* WARNING: Subroutine does not return */\n  cpu_switch_context_exit();\n}\n\n", 
            "called": [
                "irq_disable", 
                "thread_create", 
                "cpu_switch_context_exit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000f8c", 
            "calling": [
                "reset_handler_default"
            ], 
            "imported": false, 
            "current_name": "kernel_init"
        }, 
        "__gettzinfo": {
            "renaming": {}, 
            "code": "\nundefined * __gettzinfo(void)\n\n{\n  return PTR_tzinfo_000056b4;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000056b0", 
            "calling": [
                "_tzset_unlocked_r", 
                "mktime", 
                "__tzcalc_limits"
            ], 
            "imported": false, 
            "current_name": "__gettzinfo"
        }, 
        "kinetis_mcg_set_safe_mode": {
            "renaming": {}, 
            "code": "\nvoid kinetis_mcg_set_safe_mode(void)\n\n{\n  if ((DAT_00001c74[1] & 2) != 0) {\n    bit_clear8(DAT_00001c78,'\\x01');\n  }\n  if ((DAT_00001c74[5] & 0x40) != 0) {\n    if ((*DAT_00001c74 & 0xc0) == 0) {\n      *DAT_00001c74 = *DAT_00001c74 & 0x3f | 0x80;\n      do {\n      } while ((DAT_00001c74[6] & 0xc) != 8);\n    }\n    bit_clear8(DAT_00001c7c,'\\x06');\n    do {\n    } while ((DAT_00001c74[6] & 0x20) != 0);\n  }\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_640);\n  *DAT_00001c74 = *DAT_00001c74 & 0x3b | 4;\n  do {\n  } while ((DAT_00001c74[6] & 0x10) == 0);\n  do {\n  } while ((DAT_00001c74[6] & 0xc) != 0);\n  *PTR_current_mode_00001c80 = 0;\n  return;\n}\n\n", 
            "called": [
                "bit_clear8", 
                "kinetis_mcg_set_fll_factor"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001bb8", 
            "calling": [
                "kinetis_mcg_init"
            ], 
            "imported": false, 
            "current_name": "kinetis_mcg_set_safe_mode"
        }, 
        "tsrb_get": {
            "renaming": {}, 
            "code": "\nint tsrb_get(tsrb_t *rb,char *dst,size_t n)\n\n{\n  char cVar1;\n  int iVar2;\n  char *local_20;\n  size_t tmp;\n  \n  local_20 = dst;\n  tmp = n;\n  while ((tmp != 0 && (iVar2 = tsrb_empty(rb), iVar2 == 0))) {\n    cVar1 = _pop(rb);\n    *local_20 = cVar1;\n    tmp = tmp - 1;\n    local_20 = local_20 + 1;\n  }\n  return n - tmp;\n}\n\n", 
            "called": [
                "_pop", 
                "tsrb_empty"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000231c", 
            "calling": [
                "isrpipe_read"
            ], 
            "imported": false, 
            "current_name": "tsrb_get"
        }, 
        "tsrb_full": {
            "renaming": {}, 
            "code": "\nint tsrb_full(tsrb_t *rb)\n\n{\n  byte bVar1;\n  uint uVar2;\n  bool bVar3;\n  \n  uVar2 = rb->size;\n  bVar3 = rb->writes - rb->reads == uVar2;\n  if (bVar3) {\n    uVar2 = 1;\n  }\n  bVar1 = (byte)uVar2;\n  if (!bVar3) {\n    bVar1 = 0;\n  }\n  return (uint)bVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002294", 
            "calling": [
                "tsrb_add_one"
            ], 
            "imported": false, 
            "current_name": "tsrb_full"
        }, 
        "main": {
            "renaming": {}, 
            "code": "\nint main(void)\n\n{\n  char line_buf [128];\n  \n  startForkserver(0);\n  puts(PTR_s_Welcome_to_RIOT__000023c4);\n                    /* WARNING: Subroutine does not return */\n  shell_run((shell_command_t *)0x0,line_buf,0x80);\n}\n\n", 
            "called": [
                "shell_run", 
                "puts", 
                "startForkserver"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000023a4", 
            "calling": [
                "main_trampoline"
            ], 
            "imported": false, 
            "current_name": "main"
        }, 
        "rtt_get_alarm": {
            "renaming": {}, 
            "code": "\nuint32_t rtt_get_alarm(void)\n\n{\n  RTC_Type *rtt;\n  \n  return *(int *)(DAT_0000290c + 8) + 1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000028f0", 
            "calling": [
                "rtc_get_alarm"
            ], 
            "imported": false, 
            "current_name": "rtt_get_alarm"
        }, 
        "_free_r": {
            "renaming": {}, 
            "code": "\nvoid _free_r(undefined4 *param_1,int param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined *puVar1;\n  int *piVar2;\n  int *extraout_r1;\n  int **ppiVar3;\n  int **ppiVar4;\n  int **ppiVar5;\n  int **ppiVar6;\n  bool bVar7;\n  \n  if (param_2 == 0) {\n    return;\n  }\n  ppiVar6 = (int **)(param_2 + -4);\n  if (*(int *)(param_2 + -4) < 0) {\n    ppiVar6 = (int **)((int)ppiVar6 + *(int *)(param_2 + -4));\n  }\n  __malloc_lock();\n  puVar1 = PTR___malloc_free_list_00004bcc;\n  ppiVar5 = *(int ***)PTR___malloc_free_list_00004bcc;\n  if (ppiVar5 == (int **)0x0) {\n    ppiVar6[1] = (int *)0x0;\n    *(int ***)puVar1 = ppiVar6;\n    ppiVar3 = (int **)extraout_r1;\n    ppiVar4 = (int **)puVar1;\n  }\n  else if (ppiVar6 < ppiVar5) {\n    ppiVar3 = (int **)*ppiVar6;\n    ppiVar4 = (int **)((int)ppiVar6 + (int)ppiVar3);\n    bVar7 = ppiVar5 == ppiVar4;\n    if (bVar7) {\n      ppiVar4 = (int **)*ppiVar5;\n      ppiVar5 = (int **)ppiVar5[1];\n    }\n    ppiVar6[1] = (int *)ppiVar5;\n    if (bVar7) {\n      ppiVar4 = (int **)((int)ppiVar4 + (int)ppiVar3);\n      *ppiVar6 = (int *)ppiVar4;\n    }\n    *(int ***)puVar1 = ppiVar6;\n  }\n  else {\n    do {\n      ppiVar4 = ppiVar5;\n      ppiVar5 = (int **)ppiVar4[1];\n      if (ppiVar5 == (int **)0x0) break;\n    } while (ppiVar5 <= ppiVar6);\n    ppiVar3 = (int **)*ppiVar4;\n    if ((int **)((int)ppiVar4 + (int)ppiVar3) == ppiVar6) {\n      ppiVar3 = (int **)((int)ppiVar3 + (int)*ppiVar6);\n      *ppiVar4 = (int *)ppiVar3;\n      if (ppiVar5 == (int **)((int)ppiVar4 + (int)ppiVar3)) {\n        piVar2 = *ppiVar5;\n        ppiVar4[1] = ppiVar5[1];\n        ppiVar3 = (int **)((int)ppiVar3 + (int)piVar2);\n        *ppiVar4 = (int *)ppiVar3;\n      }\n    }\n    else if (ppiVar6 < (int **)((int)ppiVar4 + (int)ppiVar3)) {\n      *param_1 = 0xc;\n    }\n    else {\n      ppiVar3 = (int **)((int)ppiVar6 + (int)*ppiVar6);\n      bVar7 = ppiVar5 == ppiVar3;\n      if (bVar7) {\n        ppiVar3 = (int **)*ppiVar5;\n        ppiVar5 = (int **)ppiVar5[1];\n      }\n      ppiVar6[1] = (int *)ppiVar5;\n      if (bVar7) {\n        ppiVar3 = (int **)((int)ppiVar3 + (int)*ppiVar6);\n        *ppiVar6 = (int *)ppiVar3;\n      }\n      ppiVar4[1] = (int *)ppiVar6;\n    }\n  }\n  __malloc_unlock(param_1,ppiVar3,ppiVar4,param_4);\n  return;\n}\n\n", 
            "called": [
                "__malloc_unlock", 
                "__malloc_lock"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004b34", 
            "calling": [
                "__ssrefill_r", 
                "free", 
                "__srefill_r", 
                "_realloc_r", 
                "__swsetup_r", 
                "__sflush_r"
            ], 
            "imported": false, 
            "current_name": "_free_r"
        }, 
        "main_trampoline": {
            "renaming": {}, 
            "code": "\nvoid * main_trampoline(void *arg)\n\n{\n  auto_init();\n  iprintf(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n  main();\n  return (void *)0x0;\n}\n\n", 
            "called": [
                "auto_init", 
                "main", 
                "iprintf"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000f5c", 
            "calling": [], 
            "imported": false, 
            "current_name": "main_trampoline"
        }, 
        "probe_all": {
            "renaming": {}, 
            "code": "\nvoid probe_all(void)\n\n{\n  int i;\n  saul_reg_t *dev;\n  \n  dev = *(saul_reg_t **)PTR_saul_reg_00002f6c;\n  i = 0;\n  for (; dev != (saul_reg_t *)0x0; dev = dev->next) {\n    probe(i,dev);\n    puts(PTR_DAT_00002f70);\n    i = i + 1;\n  }\n  return;\n}\n\n", 
            "called": [
                "puts", 
                "probe"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002f30", 
            "calling": [
                "read"
            ], 
            "imported": false, 
            "current_name": "probe_all"
        }, 
        "hard_fault_default": {
            "renaming": {}, 
            "code": "\nvoid hard_fault_default(void)\n\n{\n  uint32_t *sp;\n  uint32_t corrupted;\n  uint32_t unaff_r4;\n  undefined4 unaff_r5;\n  undefined4 unaff_r6;\n  undefined4 unaff_r7;\n  undefined4 unaff_r8;\n  undefined4 unaff_r9;\n  undefined4 unaff_r10;\n  undefined4 unaff_r11;\n  uint in_lr;\n  \n  if ((PTR__eram_00000aa0 < &stack0x00000000) || (&stack0x00000000 <= DAT_00000a9c)) {\n    corrupted = 1;\n    register0x00000054 = (BADSPACEBASE *)PTR_heap_top_00000aa4;\n  }\n  else {\n    corrupted = 0;\n  }\n  if ((in_lr & 4) == 0) {\n    sp = (uint32_t *)getMainStackPointer();\n  }\n  else {\n    sp = (uint32_t *)getProcessStackPointer();\n  }\n  *(undefined4 *)((int)register0x00000054 + -4) = unaff_r11;\n  *(undefined4 *)((int)register0x00000054 + -8) = unaff_r10;\n  *(undefined4 *)((int)register0x00000054 + -0xc) = unaff_r9;\n  *(undefined4 *)((int)register0x00000054 + -0x10) = unaff_r8;\n  *(undefined4 *)((int)register0x00000054 + -0x14) = unaff_r7;\n  *(undefined4 *)((int)register0x00000054 + -0x18) = unaff_r6;\n  *(undefined4 *)((int)register0x00000054 + -0x1c) = unaff_r5;\n  *(uint32_t *)((int)register0x00000054 + -0x20) = unaff_r4;\n                    /* WARNING: Subroutine does not return */\n  hard_fault_handler(sp,corrupted,in_lr,(uint32_t *)((int)register0x00000054 + -0x20));\n}\n\n", 
            "called": [
                "hard_fault_handler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000a64", 
            "calling": [], 
            "imported": false, 
            "current_name": "hard_fault_default"
        }, 
        "gpio_init_port": {
            "renaming": {}, 
            "code": "\nvoid gpio_init_port(gpio_t pin,uint32_t pcr)\n\n{\n  PORT_Type *pPVar1;\n  int iVar2;\n  int pin_00;\n  uint uVar3;\n  uint32_t isr_state;\n  \n  clk_en(pin);\n  pPVar1 = port(pin);\n  iVar2 = pin_num(pin);\n  uVar3 = pPVar1->PCR[iVar2];\n  pPVar1 = port(pin);\n  iVar2 = pin_num(pin);\n  pPVar1->PCR[iVar2] = pcr;\n  if ((uVar3 & 0xf0000) != 0) {\n    iVar2 = port_num(pin);\n    pin_00 = pin_num(pin);\n    ctx_clear(iVar2,pin_00);\n  }\n  return;\n}\n\n", 
            "called": [
                "ctx_clear", 
                "port_num", 
                "port", 
                "clk_en", 
                "pin_num"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001f80", 
            "calling": [
                "gpio_init", 
                "uart_init_pins"
            ], 
            "imported": false, 
            "current_name": "gpio_init_port"
        }, 
        "fmt_s32_dfp": {
            "renaming": {}, 
            "code": "\nsize_t fmt_s32_dfp(char *out,int32_t val,int fp_digits)\n\n{\n  size_t sVar1;\n  uint val_00;\n  int iVar2;\n  uint div_len;\n  int32_t abs;\n  uint32_t e;\n  int32_t div;\n  uint pos;\n  \n  if (fp_digits + 7 < 0 != SCARRY4(fp_digits,7)) {\n                    /* WARNING: Subroutine does not return */\n    core_panic(PANIC_ASSERT_FAIL,PTR_assert_crash_message_00003fec);\n  }\n  pos = 0;\n  if (fp_digits == 0) {\n    pos = fmt_s32_dec(out,val);\n  }\n  else if (fp_digits < 1) {\n    val_00 = (uint)val / *(uint *)(PTR__tenmap_00003ff0 + fp_digits * -4);\n    div = val - *(uint *)(PTR__tenmap_00003ff0 + fp_digits * -4) * val_00;\n    if (div < 0) {\n      div = -div;\n    }\n    if ((val_00 == 0) && (val < 0)) {\n      if (out != (char *)0x0) {\n        *out = '-';\n      }\n      pos = 1;\n    }\n    if (out == (char *)0x0) {\n      sVar1 = fmt_s32_dec((char *)0x0,val_00);\n      pos = sVar1 + 1 + pos;\n    }\n    else {\n      sVar1 = fmt_s32_dec(out + pos,val_00);\n      iVar2 = pos + sVar1;\n      pos = iVar2 + 1;\n      out[iVar2] = '.';\n      sVar1 = fmt_s32_dec(out + pos,div);\n      fmt_lpad(out + pos,sVar1,-fp_digits,'0');\n    }\n    pos = -fp_digits + pos;\n  }\n  else {\n    sVar1 = fmt_s32_dec(out,val);\n    if (out != (char *)0x0) {\n      memset(out + sVar1,0x30,fp_digits);\n    }\n    pos = fp_digits + sVar1;\n  }\n  return pos;\n}\n\n", 
            "called": [
                "core_panic", 
                "fmt_lpad", 
                "memset", 
                "fmt_s32_dec"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00003ec4", 
            "calling": [
                "fmt_s16_dfp"
            ], 
            "imported": false, 
            "current_name": "fmt_s32_dfp"
        }, 
        "cib_init": {
            "renaming": {}, 
            "code": "\nvoid cib_init(cib_t *cib,uint size)\n\n{\n  cib_t c;\n  \n  if ((size & size - 1) != 0) {\n                    /* WARNING: Subroutine does not return */\n    core_panic(PANIC_ASSERT_FAIL,PTR_assert_crash_message_00001030);\n  }\n  cib->read_count = 0;\n  cib->write_count = 0;\n  cib->mask = size - 1;\n  return;\n}\n\n", 
            "called": [
                "core_panic"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000fec", 
            "calling": [
                "thread_create"
            ], 
            "imported": false, 
            "current_name": "cib_init"
        }, 
        "_print_time": {
            "renaming": {}, 
            "code": "\nint _print_time(tm *time)\n\n{\n  iprintf(PTR_s__04i__02i__02i__02i__02i__02i_000033bc,time->tm_year + 0x76c,time->tm_mon + 1,\n          time->tm_mday,time->tm_hour,time->tm_min,time->tm_sec);\n  return 0;\n}\n\n", 
            "called": [
                "iprintf"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00003378", 
            "calling": [
                "_rtc_getalarm", 
                "_rtc_gettime"
            ], 
            "imported": false, 
            "current_name": "_print_time"
        }, 
        "saul_reg_read": {
            "renaming": {}, 
            "code": "\nint saul_reg_read(saul_reg_t *dev,phydat_t *res)\n\n{\n  int iVar1;\n  \n  if (dev == (saul_reg_t *)0x0) {\n    iVar1 = -0x13;\n  }\n  else {\n    iVar1 = (*dev->driver->read)(dev->dev,res);\n  }\n  return iVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00003d64", 
            "calling": [
                "probe"
            ], 
            "imported": false, 
            "current_name": "saul_reg_read"
        }, 
        "uart_init": {
            "renaming": {}, 
            "code": "\nint uart_init(uart_t uart,uint32_t baudrate,uart_rx_cb_t rx_cb,void *arg)\n\n{\n  int iVar1;\n  \n  if (uart != 0) {\n                    /* WARNING: Subroutine does not return */\n    core_panic(PANIC_ASSERT_FAIL,PTR_assert_crash_message_0000143c);\n  }\n  *(uart_rx_cb_t *)PTR_config_00001440 = rx_cb;\n  *(void **)(PTR_config_00001440 + 4) = arg;\n  uart_init_pins(0);\n  bit_set32(*(uint32_t **)(PTR_uart_config_00001444 + 0x18),PTR_uart_config_00001444[0x1c]);\n  if (PTR_uart_config_00001444[0x1e] == '\\0') {\n    uart_init_uart(0,baudrate);\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = -1;\n  }\n  return iVar1;\n}\n\n", 
            "called": [
                "uart_init_uart", 
                "core_panic", 
                "uart_init_pins", 
                "bit_set32"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000013b8", 
            "calling": [
                "uart_stdio_init"
            ], 
            "imported": false, 
            "current_name": "uart_init"
        }, 
        "__sseek": {
            "renaming": {}, 
            "code": "\nvoid __sseek(_reent *param_1,int param_2,_off_t param_3,int param_4)\n\n{\n  _off_t _Var1;\n  ushort uVar2;\n  bool bVar3;\n  \n  _Var1 = _lseek_r(param_1,(int)*(short *)(param_2 + 0xe),param_3,param_4);\n  bVar3 = _Var1 == -1;\n  if (bVar3) {\n    uVar2 = *(ushort *)(param_2 + 0xc) & 0xefff;\n  }\n  else {\n    *(_off_t *)(param_2 + 0x54) = _Var1;\n    uVar2 = *(ushort *)(param_2 + 0xc) | 0x1000;\n  }\n  if (bVar3) {\n    *(ushort *)(param_2 + 0xc) = uVar2;\n  }\n  if (!bVar3) {\n    *(ushort *)(param_2 + 0xc) = uVar2;\n  }\n  return;\n}\n\n", 
            "called": [
                "_lseek_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004e26", 
            "calling": [], 
            "imported": false, 
            "current_name": "__sseek"
        }, 
        "strcmp": {
            "renaming": {}, 
            "code": "\nint strcmp(char *__s1,char *__s2)\n\n{\n  byte bVar1;\n  uint uVar2;\n  bool bVar3;\n  \n  do {\n    uVar2 = (uint)(byte)*__s1;\n    bVar1 = *__s2;\n    bVar3 = uVar2 == 1;\n    if (uVar2 != 0) {\n      bVar3 = uVar2 == bVar1;\n    }\n    __s1 = (char *)((byte *)__s1 + 1);\n    __s2 = (char *)((byte *)__s2 + 1);\n  } while (bVar3);\n  return uVar2 - bVar1;\n}\n\n", 
            "called": [
                "strcmp"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004e52", 
            "calling": [
                "_tzset_unlocked_r", 
                "handle_input_line", 
                "read", 
                "strcmp", 
                "find_handler", 
                "_saul"
            ], 
            "imported": false, 
            "current_name": "strcmp"
        }, 
        "read": {
            "renaming": {}, 
            "code": "\nvoid read(int argc,char **argv)\n\n{\n  int iVar1;\n  saul_reg_t *dev_00;\n  saul_reg_t *dev;\n  int num;\n  \n  if (argc < 3) {\n    iprintf(PTR_s_usage___s__s__device_id__all_00003050,*argv,argv[1]);\n  }\n  else {\n    iVar1 = strcmp(argv[2],PTR_DAT_00003054);\n    if (iVar1 == 0) {\n      probe_all();\n    }\n    else {\n      iVar1 = atoi(argv[2]);\n      dev_00 = saul_reg_find_nth(iVar1);\n      if (dev_00 == (saul_reg_t *)0x0) {\n        puts(PTR_s_error__undefined_device_id_given_00003058);\n      }\n      else {\n        probe(iVar1,dev_00);\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "probe_all", 
                "puts", 
                "atoi", 
                "saul_reg_find_nth", 
                "probe", 
                "strcmp", 
                "iprintf"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002fe0", 
            "calling": [
                "_saul"
            ], 
            "imported": false, 
            "current_name": "read"
        }, 
        "hard_fault_handler": {
            "renaming": {}, 
            "code": "\nvoid hard_fault_handler(uint32_t *sp,uint32_t corrupted,uint32_t exc_return,\n                       uint32_t *r4_to_r11_stack)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  uint uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  uint32_t uVar8;\n  uint32_t uVar9;\n  uint32_t uVar10;\n  uint32_t uVar11;\n  uint32_t uVar12;\n  int stack_left;\n  uint32_t psr;\n  uint32_t lr;\n  uint32_t r12;\n  uint32_t r3;\n  uint32_t r2;\n  uint32_t r1;\n  uint32_t r0;\n  uint32_t afsr;\n  uint32_t dfsr;\n  uint32_t hfsr;\n  uint32_t cfsr;\n  uint32_t mmfar;\n  uint32_t bfar;\n  uint32_t *orig_sp;\n  uint32_t pc;\n  \n  uVar2 = *(undefined4 *)(DAT_00000c24 + 0x38);\n  uVar3 = *(undefined4 *)(DAT_00000c24 + 0x34);\n  uVar4 = *(uint *)(DAT_00000c24 + 0x28);\n  uVar5 = *(undefined4 *)(DAT_00000c24 + 0x2c);\n  uVar6 = *(undefined4 *)(DAT_00000c24 + 0x30);\n  uVar7 = *(undefined4 *)(DAT_00000c24 + 0x3c);\n  pc = 0;\n  if (*(int *)PTR_isr_stack_00000c28 != DAT_00000c2c) {\n    puts(PTR_s__ISR_stack_overflowed_00000c30);\n  }\n  if (corrupted == 0) {\n    uVar8 = *sp;\n    uVar9 = sp[1];\n    uVar10 = sp[2];\n    uVar11 = sp[4];\n    uVar12 = sp[5];\n    pc = sp[6];\n    puts(PTR_s__Context_before_hardfault__00000c38);\n    iprintf(PTR_s__r0__0x_08lx_r1__0x_08lx_r2__0x__00000c3c,uVar8,uVar9,uVar10);\n    iprintf(PTR_s__r12__0x_08lx_lr__0x_08lx_pc__0x_00000c40,uVar11,uVar12,pc);\n  }\n  else {\n    puts(PTR_s_Stack_pointer_corrupted__reset_t_00000c34);\n  }\n  puts(PTR_s_FSR_FAR__00000c44);\n  iprintf(PTR_s__CFSR__0x_08lx_00000c48,uVar4);\n  iprintf(PTR_s__HFSR__0x_08lx_00000c4c,uVar5);\n  iprintf(PTR_s__DFSR__0x_08lx_00000c50,uVar6);\n  iprintf(PTR_s__AFSR__0x_08lx_00000c54,uVar7);\n  if ((uVar4 & *(uint *)PTR_BFARVALID_MASK_00000c58) != 0) {\n    iprintf(PTR_s__BFAR__0x_08lx_00000c5c,uVar2);\n  }\n  if ((uVar4 & *(uint *)PTR_MMARVALID_MASK_00000c60) != 0) {\n    iprintf(PTR_s_MMFAR__0x_08lx_00000c64,uVar3);\n  }\n  puts(PTR_DAT_00000c68);\n  iprintf(PTR_s_EXC_RET__0x_08lx_00000c6c,exc_return);\n  if (corrupted == 0) {\n    puts(PTR_s_Attempting_to_reconstruct_state_f_00000c70);\n    iprintf(PTR_s_In_GDB__set__pc_0x_lx_frame_0_bt_00000c74,pc);\n    iVar1 = _stack_size_left(0x158);\n    if (iVar1 < 0) {\n      iprintf(PTR_s__ISR_stack_overflowed_by_at_leas_00000c78,-iVar1);\n    }\n  }\n  software_bkpt(1);\n                    /* WARNING: Subroutine does not return */\n  core_panic(PANIC_HARD_FAULT,PTR_s_HARD_FAULT_HANDLER_00000c7c);\n}\n\n", 
            "called": [
                "_stack_size_left", 
                "core_panic", 
                "puts", 
                "iprintf"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000aa8", 
            "calling": [
                "hard_fault_default"
            ], 
            "imported": false, 
            "current_name": "hard_fault_handler"
        }, 
        "port_num": {
            "renaming": {}, 
            "code": "\nint port_num(gpio_t pin)\n\n{\n  return pin >> 6 & 7;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001da2", 
            "calling": [
                "clk_en", 
                "gpio_init_port"
            ], 
            "imported": false, 
            "current_name": "port_num"
        }, 
        "_rtc_getalarm": {
            "renaming": {}, 
            "code": "\nint _rtc_getalarm(void)\n\n{\n  int iVar1;\n  tm t;\n  \n  iVar1 = rtc_get_alarm(&t);\n  if (iVar1 != 0) {\n    puts(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else {\n    _print_time(&t);\n  }\n  return (uint)(iVar1 != 0);\n}\n\n", 
            "called": [
                "puts", 
                "rtc_get_alarm", 
                "_print_time"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000033c0", 
            "calling": [
                "_rtc_handler"
            ], 
            "imported": false, 
            "current_name": "_rtc_getalarm"
        }, 
        "__tzcalc_limits": {
            "renaming": {}, 
            "code": "\nundefined4 __tzcalc_limits(uint param_1)\n\n{\n  uint *puVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  int iVar4;\n  uint *puVar5;\n  int iVar6;\n  uint uVar7;\n  int iVar8;\n  int iVar9;\n  uint uVar10;\n  \n  puVar1 = (uint *)__gettzinfo();\n  if ((int)param_1 < 0x7b2) {\n    uVar2 = 0;\n  }\n  else {\n    uVar10 = count_leading_zeroes(param_1 % 400);\n    iVar6 = (param_1 - 0x7b2) * 0x16d + ((int)(param_1 - 0x7b1) >> 2) +\n            (param_1 - 0x76d) / 0xffffff9c + (param_1 - 0x641) / 400;\n    puVar1[1] = param_1;\n    puVar5 = puVar1;\n    do {\n      uVar3 = puVar5[5];\n      if (*(char *)(puVar5 + 2) == 'J') {\n        if ((((param_1 & 3) == 0) && (param_1 % 100 != 0)) || (param_1 % 400 == 0)) {\n          if ((int)uVar3 < 0x3c) {\n            iVar4 = 0;\n          }\n          else {\n            iVar4 = 1;\n          }\n        }\n        else {\n          iVar4 = 0;\n        }\n        iVar4 = iVar4 + iVar6 + uVar3 + -1;\n      }\n      else if (*(char *)(puVar5 + 2) == 'D') {\n        iVar4 = iVar6 + uVar3;\n      }\n      else {\n        uVar7 = uVar10 >> 5;\n        if (((param_1 & 3) == 0) && (param_1 % 100 != 0)) {\n          uVar7 = 1;\n        }\n        iVar8 = 0;\n        iVar4 = iVar6;\n        while( true ) {\n          iVar8 = iVar8 + 1;\n          if ((int)puVar5[3] <= iVar8) break;\n          iVar4 = iVar4 + *(int *)(PTR___month_lengths_000050e4 + iVar8 * 4 + uVar7 * 0x30 + -4);\n        }\n        iVar9 = uVar3 - (iVar4 + 4U) % 7;\n        if (iVar9 < 0) {\n          iVar9 = iVar9 + 7;\n        }\n        for (iVar9 = (puVar5[4] - 1) * 7 + iVar9;\n            *(int *)(PTR___month_lengths_000050e4 + iVar8 * 4 + uVar7 * 0x30 + -4) <= iVar9;\n            iVar9 = iVar9 + -7) {\n        }\n        iVar4 = iVar4 + iVar9;\n      }\n      uVar3 = puVar5[10] + DAT_000050e0 * iVar4 + puVar5[6];\n      puVar5[8] = uVar3;\n      puVar5[9] = (int)uVar3 >> 0x1f;\n      puVar5 = puVar5 + 10;\n    } while (puVar1 + 0x14 != puVar5);\n    uVar3 = puVar1[9];\n    uVar10 = puVar1[0x13];\n    *puVar1 = (uint)((int)((uVar3 - uVar10) - (uint)(puVar1[8] < puVar1[0x12])) < 0 !=\n                    (SBORROW4(uVar3,uVar10) !=\n                    SBORROW4(uVar3 - uVar10,(uint)(puVar1[8] < puVar1[0x12]))));\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n", 
            "called": [
                "__gettzinfo"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004f98", 
            "calling": [
                "_tzset_unlocked_r", 
                "mktime"
            ], 
            "imported": false, 
            "current_name": "__tzcalc_limits"
        }, 
        "memset": {
            "renaming": {}, 
            "code": "\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  undefined *puVar1;\n  \n  for (puVar1 = (undefined *)__s; puVar1 != (undefined *)(__n + (int)__s); puVar1 = puVar1 + 1) {\n    *puVar1 = (char)__c;\n  }\n  return __s;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004622", 
            "calling": [
                "write", 
                "__sfp", 
                "fmt_lpad", 
                "std", 
                "__sfmoreglue", 
                "fmt_s32_dfp"
            ], 
            "imported": false, 
            "current_name": "memset"
        }, 
        "tsrb_empty": {
            "renaming": {}, 
            "code": "\nint tsrb_empty(tsrb_t *rb)\n\n{\n  byte bVar1;\n  uint uVar2;\n  bool bVar3;\n  \n  uVar2 = rb->writes;\n  bVar3 = rb->reads == uVar2;\n  if (bVar3) {\n    uVar2 = 1;\n  }\n  bVar1 = (byte)uVar2;\n  if (!bVar3) {\n    bVar1 = 0;\n  }\n  return (uint)bVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002270", 
            "calling": [
                "tsrb_get"
            ], 
            "imported": false, 
            "current_name": "tsrb_empty"
        }, 
        "nmi_default": {
            "renaming": {}, 
            "code": "\nvoid nmi_default(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  core_panic(PANIC_NMI_HANDLER,PTR_s_NMI_HANDLER_00000a3c);\n}\n\n", 
            "called": [
                "core_panic"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000a30", 
            "calling": [], 
            "imported": false, 
            "current_name": "nmi_default"
        }, 
        "fmt_s16_dfp": {
            "renaming": {}, 
            "code": "\nsize_t fmt_s16_dfp(char *out,int16_t val,int fp_digits)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fmt_s32_dfp(out,(int)val,fp_digits);\n  return sVar1;\n}\n\n", 
            "called": [
                "fmt_s32_dfp"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00003e9e", 
            "calling": [
                "phydat_dump"
            ], 
            "imported": false, 
            "current_name": "fmt_s16_dfp"
        }, 
        "memmove": {
            "renaming": {}, 
            "code": "\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  \n  puVar2 = (undefined *)((int)__src + __n);\n  if ((__src < __dest) && (__dest < puVar2)) {\n    puVar1 = (undefined *)(__n + (int)__dest);\n    while (puVar1 != (undefined *)__dest) {\n      puVar2 = puVar2 + -1;\n      puVar1 = puVar1 + -1;\n      *puVar1 = *puVar2;\n    }\n  }\n  else {\n    puVar1 = (undefined *)((int)__dest + -1);\n    for (; (undefined *)__src != puVar2; __src = (void *)((int)__src + 1)) {\n      puVar1 = puVar1 + 1;\n      *puVar1 = *__src;\n                    /* WARNING: Load size is inaccurate */\n    }\n  }\n  return __dest;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000045ee", 
            "calling": [
                "fmt_lpad"
            ], 
            "imported": false, 
            "current_name": "memmove"
        }, 
        "thread_isr_stack_pointer": {
            "renaming": {}, 
            "code": "\nvoid * thread_isr_stack_pointer(void)\n\n{\n  void *pvVar1;\n  uint32_t result;\n  void *msp;\n  \n  pvVar1 = (void *)getMainStackPointer();\n  return pvVar1;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000900", 
            "calling": [
                "ps"
            ], 
            "imported": false, 
            "current_name": "thread_isr_stack_pointer"
        }, 
        "rtc_clear_alarm": {
            "renaming": {}, 
            "code": "\nvoid rtc_clear_alarm(void)\n\n{\n  rtt_clear_alarm();\n  *(undefined4 *)PTR_rtc_callback_000026d4 = 0;\n  return;\n}\n\n", 
            "called": [
                "rtt_clear_alarm"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000026c0", 
            "calling": [
                "_rtc_handler"
            ], 
            "imported": false, 
            "current_name": "rtc_clear_alarm"
        }, 
        "_tzset_unlocked": {
            "renaming": {}, 
            "code": "\nvoid _tzset_unlocked(void)\n\n{\n  _tzset_unlocked_r(*(undefined4 *)PTR__impure_ptr_00005108);\n  return;\n}\n\n", 
            "called": [
                "_tzset_unlocked_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00005100", 
            "calling": [
                "mktime"
            ], 
            "imported": false, 
            "current_name": "_tzset_unlocked"
        }, 
        "_pop": {
            "renaming": {}, 
            "code": "\nchar _pop(tsrb_t *rb)\n\n{\n  uint uVar1;\n  \n  uVar1 = rb->reads;\n  rb->reads = uVar1 + 1;\n  return rb->buf[uVar1 & rb->size - 1];\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000022f0", 
            "calling": [
                "tsrb_get"
            ], 
            "imported": false, 
            "current_name": "_pop"
        }, 
        "_fwalk": {
            "renaming": {}, 
            "code": "\nuint _fwalk(int param_1,code *param_2)\n\n{\n  uint uVar1;\n  int *piVar2;\n  int iVar3;\n  uint uVar4;\n  int iVar5;\n  \n  piVar2 = (int *)(param_1 + 0x48);\n  uVar4 = 0;\n  do {\n    iVar5 = piVar2[1];\n    iVar3 = piVar2[2];\n    while (iVar5 = iVar5 + -1, -1 < iVar5) {\n      if ((1 < *(ushort *)(iVar3 + 0xc)) && (*(short *)(iVar3 + 0xe) != -1)) {\n        uVar1 = (*param_2)(iVar3);\n        uVar4 = uVar4 | uVar1;\n      }\n      iVar3 = iVar3 + 0x68;\n    }\n    piVar2 = (int *)*piVar2;\n  } while (piVar2 != (int *)0x0);\n  return uVar4;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000043a0", 
            "calling": [
                "__srefill_r"
            ], 
            "imported": false, 
            "current_name": "_fwalk"
        }, 
        "__retarget_lock_release": {
            "renaming": {}, 
            "code": "\nvoid __retarget_lock_release(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000045ea", 
            "calling": [
                "__tz_unlock"
            ], 
            "imported": false, 
            "current_name": "__retarget_lock_release"
        }, 
        "reset_handler_default": {
            "renaming": {}, 
            "code": "\nvoid reset_handler_default(void)\n\n{\n  uint32_t uStack_18;\n  uint32_t *top;\n  uint32_t *src;\n  uint32_t *dst;\n  \n  top = &uStack_18;\n  src = (uint32_t *)PTR__etext_00000a14;\n  pre_startup();\n  dst = (uint32_t *)PTR_isr_stack_00000a18;\n  while (dst < &uStack_18) {\n    *dst = DAT_00000a1c;\n    dst = dst + 1;\n  }\n  dst = (uint32_t *)PTR_heap_top_00000a20;\n  while (dst < PTR_sched_num_threads_00000a24) {\n    *dst = *src;\n    src = src + 1;\n    dst = dst + 1;\n  }\n  dst = (uint32_t *)PTR_sched_num_threads_00000a28;\n  while (dst < PTR__sheap_00000a2c) {\n    *dst = 0;\n    dst = dst + 1;\n  }\n  post_startup();\n  board_init();\n  __libc_init_array();\n  kernel_init();\n  return;\n}\n\n", 
            "called": [
                "post_startup", 
                "pre_startup", 
                "kernel_init", 
                "__libc_init_array", 
                "board_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000099c", 
            "calling": [], 
            "imported": false, 
            "current_name": "reset_handler_default"
        }, 
        "thread_create": {
            "renaming": {}, 
            "code": "\nkernel_pid_t\nthread_create(char *stack,int stacksize,char priority,int flags,thread_task_func_t function,\n             void *arg,char *name)\n\n{\n  uint state_00;\n  char *pcVar1;\n  uint stack_size;\n  thread_t *process;\n  int local_30;\n  uintptr_t *local_2c;\n  uint state;\n  uintptr_t *stackmax;\n  thread_t *cb;\n  uintptr_t misalignment;\n  int total_stacksize;\n  uintptr_t *stackp;\n  kernel_pid_t i;\n  kernel_pid_t pid;\n  \n  if ((byte)priority < 0x10) {\n    local_30 = stacksize;\n    local_2c = (uintptr_t *)stack;\n    if (((uint)stack & 3) != 0) {\n      local_30 = 4 - ((uint)stack & 3);\n      local_2c = (uintptr_t *)(stack + local_30);\n      local_30 = stacksize - local_30;\n    }\n    stack_size = local_30 - 0x30U & 0xfffffffc;\n    process = (thread_t *)(stack_size + (int)local_2c);\n    if ((flags & 8U) == 0) {\n      *local_2c = (uintptr_t)local_2c;\n    }\n    else {\n      for (stackp = local_2c; stackp < (uintptr_t *)(stack_size + (int)local_2c);\n          stackp = stackp + 1) {\n        *stackp = (uintptr_t)stackp;\n      }\n    }\n    state_00 = irq_disable();\n    pid = 0;\n    for (i = 1; i < 0x21; i = i + 1) {\n      if (*(int *)(PTR_sched_threads_0000126c + i * 4) == 0) {\n        pid = i;\n        break;\n      }\n    }\n    if (pid == 0) {\n      irq_restore(state_00);\n      pid = -0x8b;\n    }\n    else {\n      *(thread_t **)(PTR_sched_threads_0000126c + pid * 4) = process;\n      process->pid = pid;\n      pcVar1 = thread_stack_init(function,arg,local_2c,stack_size);\n      process->sp = pcVar1;\n      process->stack_start = (char *)local_2c;\n      process->stack_size = stacksize;\n      process->name = name;\n      process->priority = priority;\n      process->status = '\\0';\n      (process->rq_entry).next = (list_node *)0x0;\n      process->wait_data = (void *)0x0;\n      (process->msg_waiters).next = (list_node *)0x0;\n      cib_init(&process->msg_queue,0);\n      process->msg_array = (msg_t *)0x0;\n      *(int *)PTR_sched_num_threads_00001270 = *(int *)PTR_sched_num_threads_00001270 + 1;\n      if ((flags & 1U) == 0) {\n        sched_set_status(process,10);\n        if ((flags & 4U) == 0) {\n          irq_restore(state_00);\n          sched_switch((ushort)(byte)priority);\n          return pid;\n        }\n      }\n      else {\n        sched_set_status(process,1);\n      }\n      irq_restore(state_00);\n    }\n  }\n  else {\n    pid = -0x16;\n  }\n  return pid;\n}\n\n", 
            "called": [
                "cib_init", 
                "irq_disable", 
                "sched_set_status", 
                "sched_switch", 
                "irq_restore", 
                "thread_stack_init"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000010d4", 
            "calling": [
                "kernel_init"
            ], 
            "imported": false, 
            "current_name": "thread_create"
        }, 
        "sched_switch": {
            "renaming": {}, 
            "code": "\nvoid sched_switch(uint16_t other_prio)\n\n{\n  int iVar1;\n  uint16_t current_prio;\n  thread_t *active_thread;\n  int on_runqueue;\n  \n  if ((*(byte *)(*(int *)PTR_sched_active_thread_0000078c + 4) < 9) ||\n     (other_prio < *(byte *)(*(int *)PTR_sched_active_thread_0000078c + 5))) {\n    iVar1 = irq_is_in();\n    if (iVar1 == 0) {\n      thread_yield_higher();\n    }\n    else {\n      *(undefined4 *)PTR_sched_context_switch_request_00000790 = 1;\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "thread_yield_higher", 
                "irq_is_in"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000738", 
            "calling": [
                "thread_create", 
                "mutex_unlock"
            ], 
            "imported": false, 
            "current_name": "sched_switch"
        }, 
        "_malloc_r": {
            "renaming": {}, 
            "code": "\nuint _malloc_r(_reent *param_1,uint param_2)\n\n{\n  undefined *puVar1;\n  void *pvVar2;\n  uint *puVar3;\n  int iVar4;\n  uint uVar5;\n  uint *puVar6;\n  uint uVar7;\n  \n  uVar7 = (param_2 + 3 & 0xfffffffc) + 8;\n  if (uVar7 < 0xc) {\n    uVar7 = 0xc;\n  }\n  if (((int)uVar7 < 0) || (uVar7 < param_2)) {\n    param_1->_errno = 0xc;\n  }\n  else {\n    __malloc_lock();\n    puVar1 = PTR___malloc_sbrk_start_00004c80;\n    puVar3 = *(uint **)PTR___malloc_free_list_00004c7c;\n    for (puVar6 = *(uint **)PTR___malloc_free_list_00004c7c; puVar6 != (uint *)0x0;\n        puVar6 = (uint *)puVar6[1]) {\n      uVar5 = *puVar6 - uVar7;\n      if (-1 < (int)uVar5) {\n        if (0xb < uVar5) {\n          *puVar6 = uVar5;\n          puVar6 = (uint *)((int)puVar6 + uVar5);\n          goto LAB_00004c34;\n        }\n        uVar7 = puVar6[1];\n        if (puVar3 == puVar6) {\n          *(uint *)PTR___malloc_free_list_00004c7c = uVar7;\n        }\n        if (puVar3 != puVar6) {\n          puVar3[1] = uVar7;\n        }\n        goto LAB_00004c42;\n      }\n      puVar3 = puVar6;\n    }\n    if (*(int *)PTR___malloc_sbrk_start_00004c80 == 0) {\n      pvVar2 = _sbrk_r(param_1,0);\n      *(void **)puVar1 = pvVar2;\n    }\n    puVar3 = (uint *)_sbrk_r(param_1,uVar7);\n    if ((puVar3 != (uint *)0xffffffff) &&\n       ((puVar6 = (uint *)((int)puVar3 + 3U & 0xfffffffc), puVar3 == puVar6 ||\n        (pvVar2 = _sbrk_r(param_1,(int)puVar6 - (int)puVar3), pvVar2 != (void *)0xffffffff)))) {\nLAB_00004c34:\n      *puVar6 = uVar7;\nLAB_00004c42:\n      __malloc_unlock(param_1);\n      uVar7 = (int)puVar6 + 0xbU & 0xfffffff8;\n      iVar4 = uVar7 - (int)(puVar6 + 1);\n      if (iVar4 == 0) {\n        return uVar7;\n      }\n      *(uint *)((int)puVar6 + iVar4) = (int)(puVar6 + 1) - uVar7;\n      return uVar7;\n    }\n    param_1->_errno = 0xc;\n    __malloc_unlock(param_1);\n  }\n  return 0;\n}\n\n", 
            "called": [
                "_sbrk_r", 
                "__malloc_unlock", 
                "__malloc_lock"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004bd0", 
            "calling": [
                "_tzset_unlocked_r", 
                "__submore", 
                "_realloc_r", 
                "__sfmoreglue", 
                "__smakebuf_r"
            ], 
            "imported": false, 
            "current_name": "_malloc_r"
        }, 
        "handle_input_line": {
            "renaming": {}, 
            "code": "\nvoid handle_input_line(shell_command_t *command_list,char *line)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *local_48;\n  shell_command_t *local_44;\n  shell_command_handler_t handler;\n  char___0_ *argv;\n  uint local_34;\n  char quote_char;\n  char *d;\n  char *c;\n  char **arg;\n  uint i;\n  int contains_esc_seq;\n  uint argc;\n  char *pos;\n  \n  local_44 = command_list;\n  local_48 = line;\n  argc = 0;\n  contains_esc_seq = 0;\n  pos = line;\n  while( true ) {\n    if (0x20 < (byte)*pos) {\n      if ((*pos == '\\\"') || (*pos == '\\'')) {\n        quote_char = *pos;\n        do {\n          pcVar2 = pos + 1;\n          if (*pcVar2 == '\\0') {\n            pos = pcVar2;\n            puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\n            return;\n          }\n          if (*pcVar2 == '\\\\') {\n            contains_esc_seq = contains_esc_seq + 1;\n            pos = pos + 2;\n            pcVar2 = pos;\n            if (*pos == '\\0') {\n              puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\n              return;\n            }\n          }\n          pos = pcVar2;\n        } while (quote_char != *pos);\n        if (0x20 < (byte)pos[1]) {\n          puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\n          return;\n        }\n      }\n      else {\n        do {\n          if (*pos == '\\\\') {\n            contains_esc_seq = contains_esc_seq + 1;\n            pos = pos + 1;\n            if (*pos == '\\0') {\n              puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\n              return;\n            }\n          }\n          pos = pos + 1;\n          if (*pos == 0x22) {\n            puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\n            return;\n          }\n        } while (0x20 < (byte)*pos);\n      }\n      argc = argc + 1;\n    }\n    if (*pos == '\\0') break;\n    *pos = '\\0';\n    pos = pos + 1;\n  }\n  if (argc != 0) {\n    local_34 = argc;\n    argv = (char___0_ *)((int)&local_48 - ((argc + 1) * 4 + 7 & 0xfffffff8));\n    *(char **)((int)argv + argc * 4) = (char *)0x0;\n    pos = line;\n    for (i = 0; i < argc; i = i + 1) {\n      for (; *pos == '\\0'; pos = pos + 1) {\n      }\n      if ((*pos == '\\\"') || (*pos == '\\'')) {\n        pos = pos + 1;\n      }\n      *(char **)((int)argv + i * 4) = pos;\n      for (; *pos != '\\0'; pos = pos + 1) {\n      }\n    }\n    for (arg = (char **)argv; (contains_esc_seq != 0 && (*arg != (char *)0x0)); arg = arg + 1) {\n      for (c = *arg; *c != '\\0'; c = c + 1) {\n        if (*c == '\\\\') {\n          for (d = c; *d != '\\0'; d = d + 1) {\n            *d = d[1];\n          }\n          contains_esc_seq = contains_esc_seq + -1;\n          if (contains_esc_seq == 0) break;\n        }\n      }\n    }\n    handler = find_handler(command_list,*(char **)argv);\n    if (handler == (shell_command_handler_t)0x0) {\n      iVar1 = strcmp(PTR_DAT_00002d8c,*(char **)argv);\n      if (iVar1 == 0) {\n        print_help(local_44);\n      }\n      else {\n        iprintf(PTR_s_shell__command_not_found___s_00002d90,*(undefined4 *)argv);\n      }\n    }\n    else {\n      (*handler)(argc,(char **)argv);\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "puts", 
                "print_help", 
                "strcmp", 
                "iprintf", 
                "find_handler"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002b10", 
            "calling": [
                "shell_run"
            ], 
            "imported": false, 
            "current_name": "handle_input_line"
        }, 
        "__sinit_lock_acquire": {
            "renaming": {}, 
            "code": "\nvoid __sinit_lock_acquire(void)\n\n{\n  __retarget_lock_acquire_recursive(PTR___lock___sinit_recursive_mutex_00004294);\n  return;\n}\n\n", 
            "called": [
                "__retarget_lock_acquire_recursive"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000428c", 
            "calling": [
                "__sinit"
            ], 
            "imported": false, 
            "current_name": "__sinit_lock_acquire"
        }, 
        "irq_is_in": {
            "renaming": {}, 
            "code": "\nint irq_is_in(void)\n\n{\n  bool bVar1;\n  uint uVar2;\n  uint32_t result;\n  \n  uVar2 = 0;\n  bVar1 = (bool)isCurrentModePrivileged();\n  if (bVar1) {\n    uVar2 = getCurrentExceptionNumber();\n    uVar2 = uVar2 & 0x1f;\n  }\n  return uVar2;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000d2a", 
            "calling": [
                "sched_switch"
            ], 
            "imported": false, 
            "current_name": "irq_is_in"
        }, 
        "kinetis_mcg_set_fee": {
            "renaming": {}, 
            "code": "\nvoid kinetis_mcg_set_fee(void)\n\n{\n  kinetis_mcg_enable_osc();\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_1920);\n  *DAT_00001958 = *DAT_00001958 & 0x3b;\n  do {\n  } while ((DAT_00001958[6] & 0xc) != 0);\n  *PTR_current_mode_0000195c = 1;\n  return;\n}\n\n", 
            "called": [
                "kinetis_mcg_set_fll_factor", 
                "kinetis_mcg_enable_osc"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000191c", 
            "calling": [
                "kinetis_mcg_set_mode"
            ], 
            "imported": false, 
            "current_name": "kinetis_mcg_set_fee"
        }, 
        "print_help": {
            "renaming": {}, 
            "code": "\nvoid print_help(shell_command_t *command_list)\n\n{\n  shell_command_t *command_lists [2];\n  uint i;\n  shell_command_t *entry;\n  \n  iprintf(PTR_s___20s__s_00002b04,PTR_s_Command_00002b00,PTR_s_Description_00002afc);\n  puts(PTR_s__________________________________00002b08);\n  command_lists[0] = command_list;\n  command_lists[1] = (shell_command_t *)PTR__shell_command_list_00002b0c;\n  for (i = 0; i < 2; i = i + 1) {\n    entry = command_lists[i];\n    if (entry != (shell_command_t *)0x0) {\n      for (; entry->name != (char *)0x0; entry = entry + 1) {\n        iprintf(PTR_s___20s__s_00002b04,entry->name,entry->desc);\n      }\n    }\n  }\n  return;\n}\n\n", 
            "called": [
                "puts", 
                "iprintf"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002a88", 
            "calling": [
                "handle_input_line"
            ], 
            "imported": false, 
            "current_name": "print_help"
        }, 
        "_scanf_chars": {
            "renaming": {}, 
            "code": "\nundefined4 _scanf_chars(undefined4 param_1,uint *param_2,byte **param_3,undefined4 *param_4)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  uint uVar3;\n  byte **ppbVar4;\n  byte *pbVar5;\n  byte *unaff_r6;\n  byte *pbVar6;\n  int iVar7;\n  \n  if (param_2[2] == 0) {\n    if (param_2[6] == 0) {\n      uVar3 = 1;\n    }\n    else {\n      uVar3 = 0xffffffff;\n    }\n    param_2[2] = uVar3;\n  }\n  puVar1 = PTR_DAT_00006568;\n  if (-1 < (int)(*param_2 << 0x1b)) {\n    ppbVar4 = (byte **)*param_4;\n    *param_4 = ppbVar4 + 1;\n    unaff_r6 = *ppbVar4;\n  }\n  iVar7 = 0;\n  do {\n    uVar3 = param_2[6];\n    if (uVar3 != 0) {\n      if (uVar3 == 1) {\n        if (*(char *)(param_2[5] + (uint)**param_3) == '\\0') {\n          if (iVar7 == 0) {\n            return 1;\n          }\nLAB_0000654a:\n          if (((*param_2 & 0x10) == 0) && (param_2[3] = param_2[3] + 1, param_2[6] != 0)) {\n            *unaff_r6 = 0;\n          }\n          param_2[4] = iVar7 + param_2[4];\n          return 0;\n        }\n      }\n      else if ((uVar3 != 2) || ((int)((uint)(byte)puVar1[**param_3] << 0x1c) < 0))\n      goto LAB_0000654a;\n    }\n    pbVar6 = unaff_r6;\n    if (-1 < (int)(*param_2 << 0x1b)) {\n      pbVar6 = unaff_r6 + 1;\n      *unaff_r6 = **param_3;\n    }\n    pbVar5 = param_3[1];\n    *param_3 = *param_3 + 1;\n    uVar3 = param_2[2] - 1;\n    param_3[1] = pbVar5 + -1;\n    iVar7 = iVar7 + 1;\n    param_2[2] = uVar3;\n    unaff_r6 = pbVar6;\n    if ((uVar3 == 0) ||\n       (((int)(pbVar5 + -1) < 1 &&\n        (iVar2 = (*(code *)param_2[0x60])(param_1,param_3,uVar3,(code *)param_2[0x60],param_4),\n        iVar2 != 0)))) goto LAB_0000654a;\n  } while( true );\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000064bc", 
            "calling": [
                "__ssvfiscanf_r"
            ], 
            "imported": false, 
            "current_name": "_scanf_chars"
        }, 
        "__swrite": {
            "renaming": {}, 
            "code": "\nvoid __swrite(_reent *param_1,int param_2,void *param_3,size_t param_4)\n\n{\n  if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x17) < 0) {\n    _lseek_r(param_1,(int)*(short *)(param_2 + 0xe),0,2);\n  }\n  *(ushort *)(param_2 + 0xc) = *(ushort *)(param_2 + 0xc) & 0xefff;\n  _write_r(param_1,(int)*(short *)(param_2 + 0xe),param_3,param_4);\n  return;\n}\n\n", 
            "called": [
                "_lseek_r", 
                "_write_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004dee", 
            "calling": [], 
            "imported": false, 
            "current_name": "__swrite"
        }, 
        "uart_stdio_read": {
            "renaming": {}, 
            "code": "\nint uart_stdio_read(char *buffer,int count)\n\n{\n  int iVar1;\n  \n  iVar1 = isrpipe_read((isrpipe_t *)PTR_uart_stdio_isrpipe_00000e34,buffer,count);\n  return iVar1;\n}\n\n", 
            "called": [
                "isrpipe_read"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000e14", 
            "calling": [
                "_read_r"
            ], 
            "imported": false, 
            "current_name": "uart_stdio_read"
        }, 
        "strtoul": {
            "renaming": {}, 
            "code": "\nulong strtoul(char *__nptr,char **__endptr,int __base)\n\n{\n  ulong uVar1;\n  \n  uVar1 = _strtoul_l_isra_0(*(undefined4 *)PTR__impure_ptr_00005fe8,__nptr,__endptr,__base);\n  return uVar1;\n}\n\n", 
            "called": [
                "_strtoul_l.isra.0"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00005fd8", 
            "calling": [
                "_tzset_unlocked_r"
            ], 
            "imported": false, 
            "current_name": "strtoul"
        }, 
        "bitband_addr": {
            "renaming": {}, 
            "code": "\nvoid * bitband_addr(void *ptr,uintptr_t bit)\n\n{\n  return (void *)(bit * 4 + ((uint)ptr & 0xf0000000 | ((uint)ptr & 0xfffff) << 5) + 0x2000000);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001d08", 
            "calling": [
                "bit_set32"
            ], 
            "imported": false, 
            "current_name": "bitband_addr"
        }, 
        "pre_startup": {
            "renaming": {}, 
            "code": "\nvoid pre_startup(void)\n\n{\n  wdog_disable();\n  cpu_errata_fixes();\n  return;\n}\n\n", 
            "called": [
                "wdog_disable", 
                "cpu_errata_fixes"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000db0", 
            "calling": [
                "reset_handler_default"
            ], 
            "imported": false, 
            "current_name": "pre_startup"
        }, 
        "rtc_poweroff": {
            "renaming": {}, 
            "code": "\nvoid rtc_poweroff(void)\n\n{\n  rtt_poweroff();\n  return;\n}\n\n", 
            "called": [
                "rtt_poweroff"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000026e4", 
            "calling": [
                "_rtc_handler"
            ], 
            "imported": false, 
            "current_name": "rtc_poweroff"
        }, 
        "kinetis_mcg_set_fei": {
            "renaming": {}, 
            "code": "\nvoid kinetis_mcg_set_fei(void)\n\n{\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_1464);\n  *DAT_00001910 = *DAT_00001910 & 0x3b | 4;\n  bit_clear8(DAT_00001914,'\\x01');\n  do {\n  } while ((DAT_00001910[6] & 0x10) == 0);\n  do {\n  } while ((DAT_00001910[6] & 0xc) != 0);\n  *PTR_current_mode_00001918 = 0;\n  return;\n}\n\n", 
            "called": [
                "bit_clear8", 
                "kinetis_mcg_set_fll_factor"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000018bc", 
            "calling": [
                "kinetis_mcg_set_mode"
            ], 
            "imported": false, 
            "current_name": "kinetis_mcg_set_fei"
        }, 
        "rtt_get_counter": {
            "renaming": {}, 
            "code": "\nuint32_t rtt_get_counter(void)\n\n{\n  RTC_Type *rtt;\n  int i;\n  uint32_t t;\n  \n  i = 0;\n  while ((i < 3 && (t = *DAT_00002858, t != *DAT_00002858))) {\n    i = i + 1;\n  }\n  return t;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000281c", 
            "calling": [
                "rtc_get_time"
            ], 
            "imported": false, 
            "current_name": "rtt_get_counter"
        }, 
        "rtt_poweroff": {
            "renaming": {}, 
            "code": "\nvoid rtt_poweroff(void)\n\n{\n  RTC_Type *rtt;\n  \n  *(uint *)(DAT_00002990 + 0x14) = *(uint *)(DAT_00002990 + 0x14) & 0xffffffef;\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002970", 
            "calling": [
                "rtc_poweroff"
            ], 
            "imported": false, 
            "current_name": "rtt_poweroff"
        }, 
        "_rtc_settime": {
            "renaming": {}, 
            "code": "\nint _rtc_settime(char **argv)\n\n{\n  int iVar1;\n  tm now;\n  \n  iVar1 = _parse_time(argv,&now);\n  if (iVar1 == 0) {\n    iVar1 = rtc_set_time(&now);\n    if (iVar1 == -1) {\n      puts(PTR_s_rtc__error_setting_time_000034bc);\n      iVar1 = 1;\n    }\n    else {\n      iVar1 = 0;\n    }\n  }\n  else {\n    iVar1 = 1;\n  }\n  return iVar1;\n}\n\n", 
            "called": [
                "puts", 
                "rtc_set_time", 
                "_parse_time"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00003478", 
            "calling": [
                "_rtc_handler"
            ], 
            "imported": false, 
            "current_name": "_rtc_settime"
        }, 
        "rtc_cb": {
            "renaming": {}, 
            "code": "\nvoid rtc_cb(void *arg)\n\n{\n  if (*(int *)PTR_rtc_callback_00002710 != 0) {\n    (**(code **)PTR_rtc_callback_00002710)(arg);\n  }\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000026f0", 
            "calling": [], 
            "imported": false, 
            "current_name": "rtc_cb"
        }, 
        "_realloc_r": {
            "renaming": {}, 
            "code": "\nvoid * _realloc_r(undefined4 param_1,void *param_2,void *param_3,undefined4 param_4)\n\n{\n  void *pvVar1;\n  void *pvVar2;\n  \n  if (param_2 != (void *)0x0) {\n    if (param_3 == (void *)0x0) {\n      _free_r();\n      pvVar1 = param_3;\n    }\n    else {\n      pvVar2 = (void *)_malloc_usable_size_r();\n      pvVar1 = param_2;\n      if ((pvVar2 < param_3) && (pvVar1 = (void *)_malloc_r(param_1,param_3), pvVar1 != (void *)0x0)\n         ) {\n        memcpy(pvVar1,param_2,(size_t)param_3);\n        _free_r(param_1,param_2);\n      }\n    }\n    return pvVar1;\n  }\n  pvVar1 = (void *)_malloc_r(param_1,param_3,param_3,param_4);\n  return pvVar1;\n}\n\n", 
            "called": [
                "_malloc_r", 
                "_malloc_usable_size_r", 
                "memcpy", 
                "_free_r"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x000060cc", 
            "calling": [
                "__submore"
            ], 
            "imported": false, 
            "current_name": "_realloc_r"
        }, 
        "thread_isr_stack_start": {
            "renaming": {}, 
            "code": "\nvoid * thread_isr_stack_start(void)\n\n{\n  return PTR_isr_stack_0000092c;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000091c", 
            "calling": [
                "ps"
            ], 
            "imported": false, 
            "current_name": "thread_isr_stack_start"
        }, 
        "sched_task_exit": {
            "renaming": {}, 
            "code": "\nvoid sched_task_exit(void)\n\n{\n  irq_disable();\n  *(undefined4 *)(PTR_sched_threads_000007d0 + *(short *)PTR_sched_active_pid_000007cc * 4) = 0;\n  *(int *)PTR_sched_num_threads_000007d4 = *(int *)PTR_sched_num_threads_000007d4 + -1;\n  sched_set_status(*(thread_t **)PTR_sched_active_thread_000007d8,0);\n  *(undefined4 *)PTR_sched_active_thread_000007d8 = 0;\n                    /* WARNING: Subroutine does not return */\n  cpu_switch_context_exit();\n}\n\n", 
            "called": [
                "irq_disable", 
                "sched_set_status", 
                "cpu_switch_context_exit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000794", 
            "calling": [], 
            "imported": false, 
            "current_name": "sched_task_exit"
        }, 
        "probe": {
            "renaming": {}, 
            "code": "\nvoid probe(int num,saul_reg_t *dev)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  phydat_t res;\n  int dim;\n  \n  iVar1 = saul_reg_read(dev,&res);\n  if (iVar1 < 1) {\n    iprintf(PTR_s_error__failed_to_read_from_devic_00002f28,num);\n  }\n  else {\n    pcVar3 = dev->name;\n    pcVar2 = saul_class_to_str(dev->driver->type);\n    iprintf(PTR_s_Reading_from___i___s__s__00002f2c,num,pcVar3,pcVar2);\n    phydat_dump(&res,(uint8_t)iVar1);\n  }\n  return;\n}\n\n", 
            "called": [
                "saul_reg_read", 
                "phydat_dump", 
                "iprintf", 
                "saul_class_to_str"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002ecc", 
            "calling": [
                "probe_all", 
                "read"
            ], 
            "imported": false, 
            "current_name": "probe"
        }, 
        "__swbuf_r": {
            "renaming": {}, 
            "code": "\nuint __swbuf_r(int param_1,uint param_2,int *param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined *puVar3;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_3 == (int *)PTR___sf_fake_stdin_0000549c) {\n    param_3 = *(int **)(param_1 + 4);\n  }\n  else if (param_3 == (int *)PTR___sf_fake_stdout_000054a0) {\n    param_3 = *(int **)(param_1 + 8);\n  }\n  else if (param_3 == (int *)PTR___sf_fake_stderr_000054a4) {\n    param_3 = *(int **)(param_1 + 0xc);\n  }\n  param_3[2] = param_3[6];\n  uVar2 = (uint)*(ushort *)(param_3 + 3);\n  iVar1 = uVar2 << 0x1c;\n  if (((iVar1 < 0) && (uVar2 = param_3[4], uVar2 != 0)) ||\n     (iVar1 = __swsetup_r(param_1,param_3,iVar1,uVar2,param_4), iVar1 == 0)) {\n    iVar1 = *param_3 - param_3[4];\n    param_2 = param_2 & 0xff;\n    if ((iVar1 < param_3[5]) || (iVar1 = _fflush_r(param_1,param_3), iVar1 == 0)) {\n      param_3[2] = param_3[2] + -1;\n      puVar3 = (undefined *)*param_3;\n      *param_3 = (int)(puVar3 + 1);\n      *puVar3 = (char)param_2;\n      if (param_3[5] != iVar1 + 1) {\n        if (-1 < (int)((uint)*(ushort *)(param_3 + 3) << 0x1f)) {\n          return param_2;\n        }\n        if (param_2 != 10) {\n          return param_2;\n        }\n      }\n      iVar1 = _fflush_r(param_1,param_3);\n      if (iVar1 == 0) {\n        return param_2;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n", 
            "called": [
                "_fflush_r", 
                "__swsetup_r", 
                "__sinit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00005404", 
            "calling": [
                "__sfputc_r", 
                "_puts_r", 
                "_putc_r"
            ], 
            "imported": false, 
            "current_name": "__swbuf_r"
        }, 
        "siscanf": {
            "renaming": {}, 
            "code": "\nint siscanf(char *__s,char *__format,...)\n\n{\n  int iVar1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *local_80;\n  size_t local_7c;\n  undefined2 local_74;\n  undefined2 local_72;\n  char *local_70;\n  size_t local_6c;\n  undefined4 local_5c;\n  undefined4 local_4c;\n  undefined4 local_38;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  local_74 = 0x204;\n  local_80 = __s;\n  local_70 = __s;\n  uStack_8 = in_r2;\n  uStack_4 = in_r3;\n  local_7c = strlen(__s);\n  local_5c = DAT_00005eb4;\n  local_4c = 0;\n  local_38 = 0;\n  local_72 = 0xffff;\n  local_6c = local_7c;\n  iVar1 = __ssvfiscanf_r(*(undefined4 *)PTR__impure_ptr_00005eb8,&local_80,__format,&uStack_8);\n  return iVar1;\n}\n\n", 
            "called": [
                "__ssvfiscanf_r", 
                "strlen"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00005e68", 
            "calling": [
                "_tzset_unlocked_r"
            ], 
            "imported": false, 
            "current_name": "siscanf"
        }, 
        "kinetis_mcg_set_blpe": {
            "renaming": {}, 
            "code": "\nvoid kinetis_mcg_set_blpe(void)\n\n{\n  bit_set8(DAT_00001a58,'\\x01');\n  kinetis_mcg_disable_pll();\n  *PTR_current_mode_00001a5c = 5;\n  return;\n}\n\n", 
            "called": [
                "bit_set8", 
                "kinetis_mcg_disable_pll"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001a3c", 
            "calling": [
                "kinetis_mcg_set_mode"
            ], 
            "imported": false, 
            "current_name": "kinetis_mcg_set_blpe"
        }, 
        "_mutex_lock": {
            "renaming": {}, 
            "code": "\nint _mutex_lock(mutex_t *mutex,int blocking)\n\n{\n  uint state;\n  int iVar1;\n  thread_t *process;\n  uint irqstate;\n  thread_t *me;\n  \n  state = irq_disable();\n  if ((mutex->queue).next == (list_node *)0x0) {\n    (mutex->queue).next = (list_node *)0xffffffff;\n    irq_restore(state);\n    iVar1 = 1;\n  }\n  else if (blocking == 0) {\n    irq_restore(state);\n    iVar1 = 0;\n  }\n  else {\n    process = *(thread_t **)PTR_sched_active_thread_000024b8;\n    sched_set_status(process,2);\n    if ((mutex->queue).next == (list_node *)0xffffffff) {\n      (mutex->queue).next = &process->rq_entry;\n      ((mutex->queue).next)->next = (list_node *)0x0;\n    }\n    else {\n      thread_add_to_list(&mutex->queue,process);\n    }\n    irq_restore(state);\n    thread_yield_higher();\n    iVar1 = 1;\n  }\n  return iVar1;\n}\n\n", 
            "called": [
                "irq_disable", 
                "thread_yield_higher", 
                "sched_set_status", 
                "irq_restore", 
                "thread_add_to_list"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00002434", 
            "calling": [
                "mutex_lock"
            ], 
            "imported": false, 
            "current_name": "_mutex_lock"
        }, 
        "_rtc_handler": {
            "renaming": {}, 
            "code": "\nint _rtc_handler(int argc,char **argv)\n\n{\n  int iVar1;\n  \n  if (argc < 2) {\n    _rtc_usage();\n    iVar1 = 1;\n  }\n  else {\n    iVar1 = strncmp(argv[1],PTR_s_poweron_00003638,7);\n    if (iVar1 == 0) {\n      rtc_poweron();\n    }\n    else {\n      iVar1 = strncmp(argv[1],PTR_s_poweroff_0000363c,8);\n      if (iVar1 == 0) {\n        rtc_poweroff();\n      }\n      else {\n        iVar1 = strncmp(argv[1],PTR_s_clearalarm_00003640,8);\n        if (iVar1 == 0) {\n          rtc_clear_alarm();\n        }\n        else {\n          iVar1 = strncmp(argv[1],PTR_s_getalarm_00003644,8);\n          if (iVar1 == 0) {\n            _rtc_getalarm();\n          }\n          else {\n            iVar1 = strncmp(argv[1],PTR_s_setalarm_00003648,8);\n            if ((iVar1 == 0) && (argc == 4)) {\n              _rtc_setalarm(argv + 2);\n            }\n            else {\n              iVar1 = strncmp(argv[1],PTR_s_gettime_0000364c,7);\n              if (iVar1 == 0) {\n                _rtc_gettime();\n              }\n              else {\n                iVar1 = strncmp(argv[1],PTR_s_settime_00003650,7);\n                if ((iVar1 != 0) || (argc != 4)) {\n                  iprintf(PTR_s_unknown_command_or_missing_param_00003654,argv[1]);\n                  _rtc_usage();\n                  return 1;\n                }\n                _rtc_settime(argv + 2);\n              }\n            }\n          }\n        }\n      }\n    }\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n", 
            "called": [
                "strncmp", 
                "rtc_poweroff", 
                "rtc_clear_alarm", 
                "_rtc_getalarm", 
                "_rtc_setalarm", 
                "_rtc_usage", 
                "_rtc_gettime", 
                "rtc_poweron", 
                "iprintf", 
                "_rtc_settime"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00003524", 
            "calling": [], 
            "imported": false, 
            "current_name": "_rtc_handler"
        }, 
        "kinetis_mcg_set_blpi": {
            "renaming": {}, 
            "code": "\nvoid kinetis_mcg_set_blpi(void)\n\n{\n  bit_set8(DAT_00001a34,'\\x01');\n  kinetis_mcg_disable_pll();\n  *PTR_current_mode_00001a38 = 4;\n  return;\n}\n\n", 
            "called": [
                "bit_set8", 
                "kinetis_mcg_disable_pll"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001a18", 
            "calling": [
                "kinetis_mcg_set_mode"
            ], 
            "imported": false, 
            "current_name": "kinetis_mcg_set_blpi"
        }, 
        "fmt_s32_dec": {
            "renaming": {}, 
            "code": "\nsize_t fmt_s32_dec(char *out,int32_t val)\n\n{\n  size_t sVar1;\n  uint32_t local_18;\n  char *local_14;\n  uint negative;\n  \n  local_18 = val;\n  local_14 = out;\n  if (-(val >> 0x1f) != 0) {\n    if (out != (char *)0x0) {\n      local_14 = out + 1;\n      *out = '-';\n    }\n    local_18 = -val;\n  }\n  sVar1 = fmt_u32_dec(local_14,local_18);\n  return -(val >> 0x1f) + sVar1;\n}\n\n", 
            "called": [
                "fmt_u32_dec"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00003e58", 
            "calling": [
                "fmt_s32_dfp"
            ], 
            "imported": false, 
            "current_name": "fmt_s32_dec"
        }, 
        "clk_en": {
            "renaming": {}, 
            "code": "\nvoid clk_en(gpio_t pin)\n\n{\n  int iVar1;\n  \n  iVar1 = port_num(pin);\n  bit_set32(DAT_00001e08,(char)iVar1 + '\\t');\n  return;\n}\n\n", 
            "called": [
                "port_num", 
                "bit_set32"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001ddc", 
            "calling": [
                "gpio_init_port"
            ], 
            "imported": false, 
            "current_name": "clk_en"
        }, 
        "_fini": {
            "renaming": {}, 
            "code": "\nvoid _fini(void)\n\n{\n  return;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x0000041c", 
            "calling": [], 
            "imported": false, 
            "current_name": "_fini"
        }, 
        "usage_fault_default": {
            "renaming": {}, 
            "code": "\nvoid usage_fault_default(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  core_panic(PANIC_USAGE_FAULT,PTR_s_USAGE_FAULT_HANDLER_00000cac);\n}\n\n", 
            "called": [
                "core_panic"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00000ca0", 
            "calling": [], 
            "imported": false, 
            "current_name": "usage_fault_default"
        }, 
        "__env_unlock": {
            "renaming": {}, 
            "code": "\nvoid __env_unlock(void)\n\n{\n  __retarget_lock_release_recursive(PTR___lock___env_recursive_mutex_00006000);\n  return;\n}\n\n", 
            "called": [
                "__retarget_lock_release_recursive"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00005ff8", 
            "calling": [
                "_findenv_r"
            ], 
            "imported": false, 
            "current_name": "__env_unlock"
        }, 
        "_fflush_r": {
            "renaming": {}, 
            "code": "\nundefined4 _fflush_r(int param_1,undefined *param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (*(int *)(param_2 + 0x10) != 0) {\n    if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n      __sinit();\n    }\n    if (param_2 == PTR___sf_fake_stdin_000041c4) {\n      param_2 = *(undefined **)(param_1 + 4);\n    }\n    else if (param_2 == PTR___sf_fake_stdout_000041c8) {\n      param_2 = *(undefined **)(param_1 + 8);\n    }\n    else if (param_2 == PTR___sf_fake_stderr_000041cc) {\n      param_2 = *(undefined **)(param_1 + 0xc);\n    }\n    if (*(short *)(param_2 + 0xc) != 0) {\n      if ((-1 < *(int *)(param_2 + 100) << 0x1f) && (-1 < (int)*(short *)(param_2 + 0xc) << 0x16)) {\n        __retarget_lock_acquire_recursive(*(undefined4 *)(param_2 + 0x58));\n      }\n      uVar1 = __sflush_r(param_1,param_2);\n      if (*(int *)(param_2 + 100) << 0x1f < 0) {\n        return uVar1;\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x16) < 0) {\n        return uVar1;\n      }\n      __retarget_lock_release_recursive(*(undefined4 *)(param_2 + 0x58));\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n", 
            "called": [
                "__retarget_lock_acquire_recursive", 
                "__sflush_r", 
                "__retarget_lock_release_recursive", 
                "__sinit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004158", 
            "calling": [
                "__swbuf_r", 
                "__srefill_r", 
                "fflush"
            ], 
            "imported": false, 
            "current_name": "_fflush_r"
        }, 
        "__sfp": {
            "renaming": {}, 
            "code": "\nint * __sfp(undefined4 *param_1)\n\n{\n  int *piVar1;\n  int *piVar2;\n  int iVar3;\n  int **ppiVar4;\n  \n  __sfp_lock_acquire();\n  iVar3 = *(int *)PTR__global_impure_ptr_00004398;\n  if (*(int *)(iVar3 + 0x18) == 0) {\n    __sinit(iVar3);\n  }\n  ppiVar4 = (int **)(iVar3 + 0x48);\n  do {\n    piVar1 = ppiVar4[1];\n    piVar2 = ppiVar4[2];\n    while (piVar1 = (int *)((int)piVar1 + -1), -1 < (int)piVar1) {\n      if (*(short *)(piVar2 + 3) == 0) {\n        piVar2[3] = DAT_0000439c;\n        piVar2[0x19] = 0;\n        __retarget_lock_init_recursive(piVar2 + 0x16);\n        __sfp_lock_release();\n        piVar2[1] = 0;\n        piVar2[2] = 0;\n        piVar2[4] = 0;\n        piVar2[5] = 0;\n        *piVar2 = 0;\n        piVar2[6] = 0;\n        memset(piVar2 + 0x17,0,8);\n        piVar2[0xd] = 0;\n        piVar2[0xe] = 0;\n        piVar2[0x12] = 0;\n        piVar2[0x13] = 0;\n        return piVar2;\n      }\n      piVar2 = piVar2 + 0x1a;\n    }\n    if (*ppiVar4 == (int *)0x0) {\n      piVar1 = (int *)__sfmoreglue(param_1,4);\n      *ppiVar4 = piVar1;\n      if (piVar1 == (int *)0x0) {\n        __sfp_lock_release();\n        *param_1 = 0xc;\n        return (int *)0x0;\n      }\n    }\n    ppiVar4 = (int **)*ppiVar4;\n  } while( true );\n}\n\n", 
            "called": [
                "__sfp_lock_release", 
                "memset", 
                "__sfp_lock_acquire", 
                "__sfmoreglue", 
                "__retarget_lock_init_recursive", 
                "__sinit"
            ], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00004314", 
            "calling": [
                "__sinit"
            ], 
            "imported": false, 
            "current_name": "__sfp"
        }, 
        "pin_num": {
            "renaming": {}, 
            "code": "\nint pin_num(gpio_t pin)\n\n{\n  return pin & 0x3f;\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001dc0", 
            "calling": [
                "gpio_init", 
                "gpio_set", 
                "gpio_init_port"
            ], 
            "imported": false, 
            "current_name": "pin_num"
        }, 
        "gpio": {
            "renaming": {}, 
            "code": "\nGPIO_Type * gpio(gpio_t pin)\n\n{\n  return (GPIO_Type *)(pin & 0x1c0 | 0x400ff000);\n}\n\n", 
            "called": [], 
            "skipped": false, 
            "tags": [], 
            "improved": true, 
            "entrypoint": "0x00001d80", 
            "calling": [
                "gpio_init", 
                "gpio_set"
            ], 
            "imported": false, 
            "current_name": "gpio"
        }
    }, 
    "locked_functions": [], 
    "used_tokens": 0, 
    "layers": []
}