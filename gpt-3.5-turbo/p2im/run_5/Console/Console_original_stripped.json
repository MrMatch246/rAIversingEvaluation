{
    "functions": {
        "FUN_00000410": {
            "entrypoint": "0x00000410",
            "current_name": "initialize_uart_stdio_00000410",
            "code": "\nint initialize_uart_stdio_00000410(EVP_PKEY_CTX *ctx_pointer)\n\n{\n  uart_stdio_init();\n  return (int)ctx_pointer;\n}\n\n",
            "renaming": {
                "FUN_00000410": "initialize_uart_stdio_00000410",
                "ctx": "ctx_pointer"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "uart_stdio_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000041c": {
            "entrypoint": "0x0000041c",
            "current_name": "FUNC_0000041c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0000041c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000041c": "FUNC_0000041c"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00000428": {
            "entrypoint": "0x00000428",
            "current_name": "allocate_memory_00000428",
            "code": "\nvoid * allocate_memory_00000428(_reent_structeent *reent_struct,ptreent_structdiff_t increment)\n\n{\n  uint state_disabled;\n  ptreent_structdiff_t increment_local;\n  _reent_structeent *reent_struct_local;\n  uint state;\n  void *result;\n  \n  state_disabled = ireent_structq_disable();\n  result = heap_top;\n  if ((&_ereent_structam < heap_top + increment) || (heap_top + increment < &_sheap)) {\n    reent_struct->_ereent_structreent_structno = 0xc;\n    result = (void *)0xffffffff;\n  }\n  else {\n    heap_top = heap_top + increment;\n  }\n  ireent_structq_resulttoreent_structe(state_disabled);\n  reent_structetureent_structn result;\n}\n\n",
            "renaming": {
                "FUN_00000428": "allocate_memory_00000428",
                "r": "reent_struct",
                "incr": "increment",
                "state_00": "state_disabled",
                "incr_local": "increment_local",
                "r_local": "reent_struct_local",
                "res": "result"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "irq_restore",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000490": {
            "entrypoint": "0x00000490",
            "current_name": "read_from_uart_00000490",
            "code": "\n_ssize_t read_from_uart_00000490(_reenteent *reent,int fd,void *output_buffer,size_t buffer_size)\n\n{\n  int read_result;\n  size_t local_buffer_size;\n  void *local_output_buffer;\n  int local_file_descriptor;\n  _reenteent *local_reent;\n  \n  read_result = uareentt_stdio_reentead((chareent *)output_buffer,buffer_size);\n  reentetureentn read_result;\n}\n\n",
            "renaming": {
                "FUN_00000490": "read_from_uart_00000490",
                "r": "reent",
                "buffer": "output_buffer",
                "count": "buffer_size",
                "count_local": "local_buffer_size",
                "buffer_local": "local_output_buffer",
                "fd_local": "local_file_descriptor",
                "r_local": "local_reent",
                "iVar1": "read_result"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "uart_stdio_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000004b2": {
            "entrypoint": "0x000004b2",
            "current_name": "write_to_uart_000004b2",
            "code": "\n_ssize_t write_to_uart_000004b2(_reent_structeent *reent_struct,int fd,void *buffer,size_t buffer_length)\n\n{\n  int result;\n  size_t local_buffer_length;\n  void *local_buffer;\n  int local_file_descriptor;\n  _reent_structeent *local_reent_struct;\n  \n  result = uareent_structt_stdio_wreent_structite((chareent_struct *)buffer,buffer_length);\n  reent_structetureent_structn result;\n}\n\n",
            "renaming": {
                "FUN_000004b2": "write_to_uart_000004b2",
                "r": "reent_struct",
                "data": "buffer",
                "count": "buffer_length",
                "count_local": "local_buffer_length",
                "data_local": "local_buffer",
                "fd_local": "local_file_descriptor",
                "r_local": "local_reent_struct",
                "iVar1": "result"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "uart_stdio_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000004d4": {
            "entrypoint": "0x000004d4",
            "current_name": "set_error_code_000004d4",
            "code": "\nint setErrorCode_000004d4(_reentPtreent *reentPtr,int fd)\n\n{\n  int localFileDescriptor;\n  _reentPtreent *localReentPtr;\n  \n  reentPtr->_ereentPtrreentPtrno = 0x13;\n  reentPtretureentPtrn -1;\n}\n\n",
            "renaming": {
                "FUN_000004d4": "set_error_code_000004d4",
                "r": "reentPtr",
                "fd_local": "localFileDescriptor",
                "r_local": "localReentPtr"
            },
            "calling": [
                "__sclose"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000004f2": {
            "entrypoint": "0x000004f2",
            "current_name": "set_file_position_error_000004f2",
            "code": "\n_off_t setFilePositionError_000004f2(reentrant *reent,int fd,_off_t position,int direction)\n\n{\n  int localDirection;\n  _off_t localPosition;\n  int localFileDescriptor;\n  reentrant *localReent;\n  \n  reent->_ereentreentno = 0x13;\n  reentetureentn -1;\n}\n\n",
            "renaming": {
                "_reent": "reentrant",
                "FUN_000004f2": "set_file_position_error_000004f2",
                "r": "reent",
                "pos": "position",
                "dir": "direction",
                "dir_local": "localDirection",
                "pos_local": "localPosition",
                "fd_local": "localFileDescriptor",
                "r_local": "localReent"
            },
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000514": {
            "entrypoint": "0x00000514",
            "current_name": "set_error_flag_and_return_negative_00000514",
            "code": "\nint setErrorFlagAndReturnNegative_00000514(_reentranceeent *reentrance,int fd,fileStatusat *fileStatus)\n\n{\n  fileStatusat *localFileStatus;\n  int localFileDescriptor;\n  _reentranceeent *localReentrance;\n  \n  reentrance->_ereentrancereentranceno = 0x13;\n  reentranceetureentrancen -1;\n}\n\n",
            "renaming": {
                "FUN_00000514": "set_error_flag_and_return_negative_00000514",
                "r": "reentrance",
                "st": "fileStatus",
                "st_local": "localFileStatus",
                "fd_local": "localFileDescriptor",
                "r_local": "localReentrance"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000534": {
            "entrypoint": "0x00000534",
            "current_name": "check_std_file_descriptor_00000534",
            "code": "\nint checkStdFileDescriptor_00000534(_reentrantPointereent *reentrantPointer,int fd)\n\n{\n  int isStdFileDescriptor;\n  int fd_local;\n  _reentrantPointereent *reentrantPointer_local;\n  \n  reentrantPointer->_ereentrantPointerreentrantPointerno = 0;\n  if (((fd == 0) || (fd == 1)) || (fd == 2)) {\n    isStdFileDescriptor = 1;\n  }\n  else {\n    isStdFileDescriptor = 0;\n  }\n  reentrantPointeretureentrantPointern isStdFileDescriptor;\n}\n\n",
            "renaming": {
                "FUN_00000534": "check_std_file_descriptor_00000534",
                "r": "reentrantPointer",
                "iVar1": "isStdFileDescriptor"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000566": {
            "entrypoint": "0x00000566",
            "current_name": "convert_to_little_endian_00000566",
            "code": "\nuint convertToLittleEndian_00000566(uint number)\n\n{\n  byte byte1;\n  byte byte2;\n  byte byte3;\n  byte byte4;\n  uint convertedValue;\n  uint localNumber;\n  \n  byte2 = (byte)number;\n  byte3 = (byte)(number >> 8);\n  byte4 = (byte)(number >> 0x10);\n  byte1 = (byte)(number >> 0x18);\n  convertedValue = LZCOUNT((uint)(byte)((((((((byte2 & 1) << 1 | byte2 >> 1 & 1) << 1 | byte2 >> 2 & 1) << 1\n                                  | byte2 >> 3 & 1) << 1 | byte2 >> 4 & 1) << 1 | byte2 >> 5 & 1) <<\n                                1 | byte2 >> 6 & 1) << 1 | byte2 >> 7) << 0x18 |\n                  (uint)(byte)((((((((byte3 & 1) << 1 | byte3 >> 1 & 1) << 1 | byte3 >> 2 & 1) << 1\n                                  | byte3 >> 3 & 1) << 1 | byte3 >> 4 & 1) << 1 | byte3 >> 5 & 1) <<\n                                1 | byte3 >> 6 & 1) << 1 | byte3 >> 7) << 0x10 |\n                  (uint)(byte)((((((((byte4 & 1) << 1 | byte4 >> 1 & 1) << 1 | byte4 >> 2 & 1) << 1\n                                  | byte4 >> 3 & 1) << 1 | byte4 >> 4 & 1) << 1 | byte4 >> 5 & 1) <<\n                                1 | byte4 >> 6 & 1) << 1 | byte4 >> 7) << 8 |\n                  (uint)(byte)((((((((byte1 & 1) << 1 | byte1 >> 1 & 1) << 1 | byte1 >> 2 & 1) << 1\n                                  | byte1 >> 3 & 1) << 1 | byte1 >> 4 & 1) << 1 | byte1 >> 5 & 1) <<\n                                1 | byte1 >> 6 & 1) << 1 | byte1 >> 7));\n  if (number == 0) {\n    convertedValue = 0xffffffff;\n  }\n  return convertedValue;\n}\n\n",
            "renaming": {
                "FUN_00000566": "convert_to_little_endian_00000566",
                "v": "number",
                "bVar1": "byte1",
                "bVar2": "byte2",
                "bVar3": "byte3",
                "bVar4": "byte4",
                "uVar5": "convertedValue",
                "v_local": "localNumber"
            },
            "calling": [
                "sched_run"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000058e": {
            "entrypoint": "0x0000058e",
            "current_name": "insert_node_at_end_0000058e",
            "code": "\nvoid insertNodeAtEnd_0000058e(chead_node_t *head,chead_node_t *nodeToInsert)\n\n{\n  chead_node_t *newNodeLocal;\n  chead_node_t *headLocal;\n  \n  if (head->next == (head_node *)0x0) {\n    nodeToInsert->next = nodeToInsert;\n  }\n  else {\n    nodeToInsert->next = head->next->next;\n    head->next->next = nodeToInsert;\n  }\n  head->next = nodeToInsert;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000058e": "insert_node_at_end_0000058e",
                "list": "head",
                "new_node": "nodeToInsert",
                "new_node_local": "newNodeLocal",
                "list_local": "headLocal"
            },
            "calling": [
                "sched_set_status"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000005ca": {
            "entrypoint": "0x000005ca",
            "current_name": "remove_next_node_000005ca",
            "code": "\nchead_node_t * removeNextNode_000005ca(chead_node_t *head)\n\n{\n  head_node *removedNode;\n  chead_node_t *currentNode;\n  chead_node_t *firstNode;\n  \n  if (head->next == (head_node *)0x0) {\n    removedNode = (head_node *)0x0;\n  }\n  else {\n    removedNode = head->next->next;\n    if (removedNode == head->next) {\n      head->next = (head_node *)0x0;\n    }\n    else {\n      head->next->next = removedNode->next;\n    }\n  }\n  return removedNode;\n}\n\n",
            "renaming": {
                "FUN_000005ca": "remove_next_node_000005ca",
                "list": "head",
                "plVar1": "removedNode",
                "list_local": "currentNode",
                "first": "firstNode"
            },
            "calling": [
                "sched_set_status"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000610": {
            "entrypoint": "0x00000610",
            "current_name": "context_switch_00000610",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint contextSwitch_00000610(void)\n\n{\n  thread_t *currentThread;\n  uint LSBIndex;\n  list_node *nextNode;\n  int result;\n  thread_t *activeThread;\n  int nextRunqueue;\n  clist_node_t *unused;\n  thread_t *nextThread;\n  \n  currentThread = activeThread;\n  contextSwitch_00000610Request = 0;\n  LSBIndex = bitarithm_lsb(bitcache);\n  nextNode = (currentRunqueue)->next;\n  if (currentThread == (thread_t *)(nextNode + -2)) {\n    result = 0;\n  }\n  else {\n    if ((currentThread != (thread_t *)0x0) && (currentThread->status == '\\t')) {\n      currentThread->status = '\\n';\n    }\n    *(undefined *)&nextNode[-1].next = 9;\n    activePID = *(kernel_pid_t *)((int)&nextNode[-1].next + 2);\n    result = 1;\n    activeThread = (thread_t *)(nextNode + -2);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00000610": "context_switch_00000610",
                "ptVar1": "currentThread",
                "uVar2": "LSBIndex",
                "plVar3": "nextNode",
                "iVar4": "result",
                "active_thread": "activeThread",
                "nextrq": "nextRunqueue",
                "__m____": "unused",
                "next_thread": "nextThread",
                "sched_active_thread": "activeThread",
                "sched_context_switch_request": "contextSwitchRequest",
                "runqueue_bitcache": "bitcache",
                "sched_runqueues[uVar2].next": "currentRunqueue",
                "sched_active_pid": "activePID"
            },
            "calling": [
                "isr_svc"
            ],
            "called": [
                "bitarithm_lsb"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000698": {
            "entrypoint": "0x00000698",
            "current_name": "update_process_status_00000698",
            "code": "\nvoid updateProcessStatus_00000698(thread_t *targetProcess,uint newStatus)\n\n{\n  uint localStatus;\n  thread_t *localProcess;\n  \n  if (newStatus < 9) {\n    if ((8 < targetProcess->newStatus) &&\n       (clist_lpop(runqueues + targetProcess->priority),\n       runqueues[targetProcess->priority].next == (list_node *)0x0)) {\n      bitcache = bitcache & ~(1 << targetProcess->priority);\n    }\n  }\n  else if (targetProcess->newStatus < 9) {\n    clist_rpush(runqueues + targetProcess->priority,&targetProcess->rq_entry);\n    bitcache = bitcache | 1 << targetProcess->priority;\n  }\n  targetProcess->newStatus = (uint8_t)newStatus;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000698": "update_process_status_00000698",
                "process": "targetProcess",
                "status": "newStatus",
                "status_local": "localStatus",
                "process_local": "localProcess",
                "sched_runqueues": "runqueues",
                "runqueue_bitcache": "bitcache"
            },
            "calling": [
                "mutex_unlock",
                "thread_create",
                "_mutex_lock",
                "sched_task_exit"
            ],
            "called": [
                "clist_rpush",
                "clist_lpop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000738": {
            "entrypoint": "0x00000738",
            "current_name": "check_and_handle_thread_priority_00000738",
            "code": "\nvoid check_and_handle_thread_priority_00000738(uint16_t incoming_priority)\n\n{\n  int iVar1;\n  uint16_t local_priority;\n  uint16_t current_priority;\n  thread_t *current_thread;\n  int is_on_runqueue;\n  \n  if ((sched_current_thread->status < 9) || (incoming_priority < sched_current_thread->priority)) {\n    iVar1 = irq_is_in();\n    if (iVar1 == 0) {\n      thread_yield_higher();\n    }\n    else {\n      sched_context_switch_request = 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000738": "check_and_handle_thread_priority_00000738",
                "other_prio": "incoming_priority",
                "other_prio_local": "local_priority",
                "current_prio": "current_priority",
                "active_thread": "current_thread",
                "on_runqueue": "is_on_runqueue"
            },
            "calling": [
                "mutex_unlock",
                "thread_create"
            ],
            "called": [
                "thread_yield_higher",
                "irq_is_in"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000794": {
            "entrypoint": "0x00000794",
            "current_name": "cleanup_and_exit_00000794",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid cleanupAndExit_00000794(void)\n\n{\n  disableInterrupts();\n  threadList[activeProcessID] = (ThreadStruct *)0x0;\n  numThreads = numThreads + -1;\n  setStatus(activeThread,0);\n  activeThread = (ThreadStruct *)0x0;\n                    \n  switchContextAndExit();\n}\n\n",
            "renaming": {
                "FUN_00000794": "cleanup_and_exit_00000794",
                "irq_disable": "disableInterrupts",
                "sched_threads": "threadList",
                "sched_active_pid": "activeProcessID",
                "thread_t": "ThreadStruct",
                "sched_num_threads": "numThreads",
                "sched_set_status": "setStatus",
                "sched_active_thread": "activeThread",
                "cpu_switch_context_exit": "switchContextAndExit"
            },
            "calling": [],
            "called": [
                "sched_set_status",
                "cpu_switch_context_exit",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000007dc": {
            "entrypoint": "0x000007dc",
            "current_name": "initialize_thread_000007dc",
            "code": "\nchar * initializeThread_000007dc(thread_threadTaskFunction_t threadTaskFunction,voinnerLoopCounterd *functionArgument,voinnerLoopCounterd *stackStartAddress,innerLoopCounternt stackSize)\n\n{\n  uinnerLoopCounternt alignmentAdjustedSize;\n  innerLoopCounternt localStackSize;\n  voinnerLoopCounterd *localStackStart;\n  voinnerLoopCounterd *localArgument;\n  thread_threadTaskFunction_t localTaskFunction;\n  innerLoopCounternt outerLoopCounter;\n  innerLoopCounternt innerLoopCounter;\n  uinnerLoopCounternt32_t *stackPointer;\n  \n  alignmentAdjustedSize = stackSize + (innerLoopCounternt)stackStartAddress & 0xfffffffc;\n  stackPointer = (uinnerLoopCounternt32_t *)(alignmentAdjustedSize - 4);\n  *stackPointer = 0x77777777;\n  innerLoopCounterf (((uinnerLoopCounternt)stackPointer & 7) != 0) {\n    stackPointer = (uinnerLoopCounternt32_t *)(alignmentAdjustedSize - 8);\n    *stackPointer = 0x88888888;\n  }\n  stackPointer[-1] = 0x1000000;\n  stackPointer[-2] = (uinnerLoopCounternt32_t)threadTaskFunction;\n  stackPointer[-3] = 0x795;\n  stackPointer = stackPointer + -4;\n  *stackPointer = 0;\n  for (innerLoopCounter = 3; 0 < innerLoopCounter; innerLoopCounter = innerLoopCounter + -1) {\n    stackPointer = stackPointer + -1;\n    *stackPointer = innerLoopCounter;\n  }\n  stackPointer = stackPointer + -1;\n  *stackPointer = (uinnerLoopCounternt32_t)functionArgument;\n  for (outerLoopCounter = 0xb; 3 < outerLoopCounter; outerLoopCounter = outerLoopCounter + -1) {\n    stackPointer = stackPointer + -1;\n    *stackPointer = outerLoopCounter;\n  }\n  stackPointer[-1] = 0xfffffffd;\n  return (char *)(stackPointer + -1);\n}\n\n",
            "renaming": {
                "FUN_000007dc": "initialize_thread_000007dc",
                "task_func": "threadTaskFunction",
                "arg": "functionArgument",
                "stack_start": "stackStartAddress",
                "stack_size": "stackSize",
                "uVar1": "alignmentAdjustedSize",
                "stack_size_local": "localStackSize",
                "stack_start_local": "localStackStart",
                "arg_local": "localArgument",
                "task_func_local": "localTaskFunction",
                "i_1": "outerLoopCounter",
                "i": "innerLoopCounter",
                "stk": "stackPointer"
            },
            "calling": [
                "thread_create"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000008b8": {
            "entrypoint": "0x000008b8",
            "current_name": "count_unused_words_000008b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint countUnusedWords_000008b8(void)\n\n{\n  currentWordPtrdiff_t unusedWordsCount;\n  uint32_t *currentWordPtr;\n  \n  for (currentWordPtr = (uint32_t *)isr_stack; (*currentWordPtr == 0xe7fee7fe && (currentWordPtr < &heap_top)); currentWordPtr = currentWordPtr + 1) {\n  }\n  return ((int)&heap_top - (int)currentWordPtr >> 2) << 2;\n}\n\n",
            "renaming": {
                "FUN_000008b8": "count_unused_words_000008b8",
                "num_used_words": "unusedWordsCount",
                "ptr": "currentWordPtr"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000900": {
            "entrypoint": "0x00000900",
            "current_name": "get_main_stack_pointer_00000900",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * getMainStackPointer_00000900(void)\n\n{\n  void *mainStackPointer;\n  uint32_t returnValue;\n  void *mainStackPointer;\n  \n  mainStackPointer = (void *)getMainStackPointer_00000900();\n  return mainStackPointer;\n}\n\n",
            "renaming": {
                "FUN_00000900": "get_main_stack_pointer_00000900",
                "pvVar1": "mainStackPointer",
                "result": "returnValue",
                "msp": "mainStackPointer"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000091c": {
            "entrypoint": "0x0000091c",
            "current_name": "get_isr_stack_0000091c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * get_isr_stack_0000091c(void)\n\n{\n  return interrupt_service_routine_stack;\n}\n\n",
            "renaming": {
                "FUN_0000091c": "get_isr_stack_0000091c",
                "isr_stack": "interrupt_service_routine_stack"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000930": {
            "entrypoint": "0x00000930",
            "current_name": "execute_interrupt_00000930",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid execute_interrupt_00000930(void)\n\n{\n  enable_interrupts();\n  trigger_interrupt(1);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00000930": "execute_interrupt_00000930",
                "irq_enable": "enable_interrupts",
                "software_interrupt": "trigger_interrupt"
            },
            "calling": [
                "kernel_init",
                "sched_task_exit"
            ],
            "called": [
                "irq_enable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000093c": {
            "entrypoint": "0x0000093c",
            "current_name": "set_flag_0000093c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid set_flag_0000093c(void)\n\n{\n  _DAT_e000ed04 = _DAT_e000ed04 | 0x10000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000093c": "set_flag_0000093c"
            },
            "calling": [
                "sched_switch",
                "cortexm_isr_end",
                "cortexm_isr_end",
                "_mutex_lock",
                "cortexm_isr_end"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000958": {
            "entrypoint": "0x00000958",
            "current_name": "execute_interrupt_handler_00000958",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid executeInterruptHandler_00000958(void)\n\n{\n  bool isPrivilegedMode;\n  int iVar2;\n  code *jumpTable;\n  undefined4 param1;\n  undefined4 param2;\n  undefined4 param3;\n  undefined4 param4;\n  undefined4 param5;\n  undefined4 param6;\n  undefined4 param7;\n  undefined4 param8;\n  undefined4 param9;\n  code **stackPointer;\n  \n  iVar2 = getProcessStackPointer();\n  *(undefined4 *)(iVar2 + -4) = param8;\n  *(undefined4 *)(iVar2 + -8) = param7;\n  *(undefined4 *)(iVar2 + -0xc) = param6;\n  *(undefined4 *)(iVar2 + -0x10) = param5;\n  *(undefined4 *)(iVar2 + -0x14) = param4;\n  *(undefined4 *)(iVar2 + -0x18) = param3;\n  *(undefined4 *)(iVar2 + -0x1c) = param2;\n  *(undefined4 *)(iVar2 + -0x20) = param1;\n  *(undefined4 *)(iVar2 + -0x24) = param9;\n  sched_active_thread->sp = (char *)(undefined4 *)(iVar2 + -0x24);\n  isr_svc();\n  sched_run();\n  jumpTable = *(code **)sched_active_thread->sp;\n  stackPointer = (code **)((int)sched_active_thread->sp + 0x24);\n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    setProcessStackPointer(stackPointer);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)(jumpTable,stackPointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000958": "execute_interrupt_handler_00000958",
                "unaff_r4": "param1",
                "unaff_r5": "param2",
                "unaff_r6": "param3",
                "unaff_r7": "param4",
                "unaff_r8": "param5",
                "unaff_r9": "param6",
                "unaff_r10": "param7",
                "unaff_r11": "param8",
                "in_lr": "param9",
                "ppcVar3": "stackPointer",
                "bVar1": "isPrivilegedMode",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "isr_svc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000974": {
            "entrypoint": "0x00000974",
            "current_name": "execute_scheduler_00000974",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid executeScheduler_00000974(void)\n\n{\n  bool isPrivilegedMode;\n  code *jumpTable;\n  code **stackPointer;\n  \n  runScheduler();\n  jumpTable = *(code **)activeThread->sp;\n  stackPointer = (code **)((int)activeThread->sp + 0x24);\n  isPrivilegedMode = (bool)checkPrivilegedMode();\n  if (isPrivilegedMode) {\n    setStackPointer(stackPointer);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)(jumpTable,stackPointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000974": "execute_scheduler_00000974",
                "UNRECOVERED_JUMPTABLE": "jumpTable",
                "ppcVar2": "stackPointer",
                "bVar1": "isPrivilegedMode",
                "sched_run": "runScheduler",
                "sched_active_thread": "activeThread",
                "isCurrentModePrivileged": "checkPrivilegedMode",
                "setProcessStackPointer": "setStackPointer"
            },
            "calling": [
                "isr_pendsv"
            ],
            "called": [
                "sched_run"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000978": {
            "entrypoint": "0x00000978",
            "current_name": "execute_function_and_set_stack_00000978",
            "code": "\nvoid executeFunctionAndSetStack_00000978(void)\n\n{\n  bool isPrivilegedMode;\n  code *jumpTable;\n  code **savedStackPointer;\n  \n  jumpTable = *(code **)activeThread->sp;\n  savedStackPointer = (code **)((int)activeThread->sp + 0x24);\n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    setProcessStackPointer(savedStackPointer);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)(jumpTable,savedStackPointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000978": "execute_function_and_set_stack_00000978",
                "UNRECOVERED_JUMPTABLE": "jumpTable",
                "ppcVar2": "savedStackPointer",
                "bVar1": "isPrivilegedMode",
                "sched_active_thread": "activeThread"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000990": {
            "entrypoint": "0x00000990",
            "current_name": "FUNC_00000990",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00000990(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000990": "FUNC_00000990"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0000099c": {
            "entrypoint": "0x0000099c",
            "current_name": "initialize_system_0000099c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_0000099c(void)\n\n{\n  uint32_t topOfStack;\n  uint32_t *topPointer;\n  uint32_t *sourcePointer;\n  uint32_t *destinationPointer;\n  \n  topPointer = &topOfStack;\n  sourcePointer = (uint32_t *)&_etext;\n  pre_startup();\n  destinationPointer = (uint32_t *)isr_stack;\n  while (destinationPointer < &topOfStack) {\n    *destinationPointer = 0xe7fee7fe;\n    destinationPointer = destinationPointer + 1;\n  }\n  destinationPointer = (uint32_t *)&heap_topPointer;\n  while (destinationPointer < &sched_num_threads) {\n    *destinationPointer = *sourcePointer;\n    sourcePointer = sourcePointer + 1;\n    destinationPointer = destinationPointer + 1;\n  }\n  destinationPointer = (uint32_t *)&sched_num_threads;\n  while (destinationPointer < &_sheap) {\n    *destinationPointer = 0;\n    destinationPointer = destinationPointer + 1;\n  }\n  post_startup();\n  board_init();\n  __libc_init_array();\n  kernel_init();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000099c": "initialize_system_0000099c",
                "uStack_18": "topOfStack",
                "top": "topPointer",
                "src": "sourcePointer",
                "dst": "destinationPointer"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "post_startup",
                "pre_startup",
                "kernel_init",
                "board_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000a30": {
            "entrypoint": "0x00000a30",
            "current_name": "handle_nmi_00000a30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_nmi_00000a30(void)\n\n{\n                    \n  trigger_panic(nmi_reason,\"NMI HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000a30": "handle_nmi_00000a30",
                "PANIC_NMI_HANDLER": "nmi_reason",
                "core_panic": "trigger_panic"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000a40": {
            "entrypoint": "0x00000a40",
            "current_name": "calculate_stack_offset_00000a40",
            "code": "\nint calculateStackOffset_00000a40(uint32_t offset)\n\n{\n  uint32_t localOffset;\n  uint32_t *stackPointer;\n  \n  return (int)(&stack0xe000ffe8 + -offset);\n}\n\n",
            "renaming": {
                "FUN_00000a40": "calculate_stack_offset_00000a40",
                "required": "offset",
                "required_local": "localOffset",
                "sp": "stackPointer"
            },
            "calling": [
                "hard_fault_handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000a64": {
            "entrypoint": "0x00000a64",
            "current_name": "handle_memory_corruption_00000a64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleMemoryCorruption_00000a64(void)\n\n{\n  uint32_t *stackPointer;\n  uint32_t isCorrupted;\n  uint32_t registerParam4;\n  undefined4 registerParam5;\n  undefined4 registerParam6;\n  undefined4 registerParam7;\n  undefined4 registerParam8;\n  undefined4 registerParam9;\n  undefined4 registerParam10;\n  undefined4 registerParam11;\n  uint linkRegister;\n  \n  if ((&_eram < &stack0x00000000) || (&stack0x00000000 < isr_stack + 0x159)) {\n    isCorrupted = 1;\n    register0x00000054 = (BADSPACEBASE *)&heap_top;\n  }\n  else {\n    isCorrupted = 0;\n  }\n  if ((linkRegister & 4) == 0) {\n    stackPointer = (uint32_t *)getMainStackPointer();\n  }\n  else {\n    stackPointer = (uint32_t *)getProcessStackPointer();\n  }\n  *(undefined4 *)((int)register0x00000054 + -4) = registerParam11;\n  *(undefined4 *)((int)register0x00000054 + -8) = registerParam10;\n  *(undefined4 *)((int)register0x00000054 + -0xc) = registerParam9;\n  *(undefined4 *)((int)register0x00000054 + -0x10) = registerParam8;\n  *(undefined4 *)((int)register0x00000054 + -0x14) = registerParam7;\n  *(undefined4 *)((int)register0x00000054 + -0x18) = registerParam6;\n  *(undefined4 *)((int)register0x00000054 + -0x1c) = registerParam5;\n  *(uint32_t *)((int)register0x00000054 + -0x20) = registerParam4;\n                    \n  hard_fault_handler(stackPointer,isCorrupted,linkRegister,(uint32_t *)((int)register0x00000054 + -0x20));\n}\n\n",
            "renaming": {
                "FUN_00000a64": "handle_memory_corruption_00000a64",
                "sp": "stackPointer",
                "corrupted": "isCorrupted",
                "unaff_r4": "registerParam4",
                "unaff_r5": "registerParam5",
                "unaff_r6": "registerParam6",
                "unaff_r7": "registerParam7",
                "unaff_r8": "registerParam8",
                "unaff_r9": "registerParam9",
                "unaff_r10": "registerParam10",
                "unaff_r11": "registerParam11",
                "in_lr": "linkRegister"
            },
            "calling": [],
            "called": [
                "hard_fault_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000aa8": {
            "entrypoint": "0x00000aa8",
            "current_name": "handle_hard_fault_00000aa8",
            "code": "\n\n\nvoid handleHardFault_00000aa8(uint32_t *stackPointer,uint32_t isCorrupted,uint32_t exceptionReturn,uint32_t *r4ToR11Stack)\n\n{\n  uint CFSR;\n  undefined4 HFSR;\n  undefined4 DFSR;\n  undefined4 AFSR;\n  undefined4 BFAR;\n  undefined4 MMFAR;\n  int stackSizeLeft;\n  uint32_t r0;\n  uint32_t r1;\n  uint32_t r2;\n  uint32_t r3;\n  uint32_t r12;\n  uint32_t *r4ToR11StackLocal;\n  uint32_t exceptionReturnLocal;\n  uint32_t isCorruptedLocal;\n  uint32_t *stackPointerLocal;\n  int stackLeft;\n  uint32_t psr;\n  uint32_t lr;\n  uint32_t r12;\n  uint32_t r3;\n  uint32_t r2;\n  uint32_t r1;\n  uint32_t r0;\n  uint32_t afsr;\n  uint32_t dfsr;\n  uint32_t hfsr;\n  uint32_t cfsr;\n  uint32_t mmfar;\n  uint32_t bfar;\n  uint32_t *original_sp;\n  uint32_t programCounter;\n  \n  MMFAR = _DAT_e000ed3c;\n  BFAR = _DAT_e000ed38;\n  AFSR = _DAT_e000ed34;\n  DFSR = _DAT_e000ed30;\n  HFSR = _DAT_e000ed2c;\n  CFSR = _DAT_e000ed28;\n  programCounter = 0;\n  if (isr_stack._0_4_ != -0x18011802) {\n    puts(\"\\nISR stack overflowed\");\n  }\n  if (isCorrupted == 0) {\n    r0 = *stackPointer;\n    r1 = stackPointer[1];\n    r2 = stackPointer[2];\n    r3 = stackPointer[4];\n    r12 = stackPointer[5];\n    programCounter = stackPointer[6];\n    puts(\"\\nContext before hardfault:\");\n    iprintf(\"   r0: 0x%08lx\\n   r1: 0x%08lx\\n   r2: 0x%08lx\\n   r3: 0x%08lx\\n\",r0,r1,r2);\n    iprintf(\"  r12: 0x%08lx\\n   lr: 0x%08lx\\n   programCounter: 0x%08lx\\n  psr: 0x%08lx\\n\\n\",r3,r12,programCounter);\n  }\n  else {\n    puts(\"Stack pointer isCorrupted, reset to top of stack\");\n  }\n  puts(\"FSR/FAR:\");\n  iprintf(\" CFSR: 0x%08lx\\n\",CFSR);\n  iprintf(\" HFSR: 0x%08lx\\n\",HFSR);\n  iprintf(\" DFSR: 0x%08lx\\n\",DFSR);\n  iprintf(\" AFSR: 0x%08lx\\n\",MMFAR);\n  if ((CFSR & 0x8000) != 0) {\n    iprintf(\" BFAR: 0x%08lx\\n\",BFAR);\n  }\n  if ((CFSR & 0x80) != 0) {\n    iprintf(\"MMFAR: 0x%08lx\\n\",AFSR);\n  }\n  puts(\"Misc\");\n  iprintf(\"EXC_RET: 0x%08lx\\n\",exceptionReturn);\n  if (isCorrupted == 0) {\n    puts(\"Attempting to reconstruct state for debugging...\");\n    iprintf(\"In GDB:\\n  set $programCounter=0x%lx\\n  frame 0\\n  bt\\n\",programCounter);\n    stackSizeLeft = _stack_size_left(0x158);\n    if (stackSizeLeft < 0) {\n      iprintf(\"\\nISR stack overflowed by at least %d bytes.\\n\",-stackSizeLeft);\n    }\n  }\n  software_bkpt(1);\n                    \n  core_panic(PANIC_HARD_FAULT,\"HARD FAULT HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000aa8": "handle_hard_fault_00000aa8",
                "sp": "stackPointer",
                "corrupted": "isCorrupted",
                "exc_return": "exceptionReturn",
                "r4_to_r11_stack": "r4ToR11Stack",
                "uVar1": "CFSR",
                "uVar2": "HFSR",
                "uVar3": "DFSR",
                "uVar4": "AFSR",
                "uVar5": "BFAR",
                "uVar6": "MMFAR",
                "iVar7": "stackSizeLeft",
                "uVar8": "r0",
                "uVar9": "r1",
                "uVar10": "r2",
                "uVar11": "r3",
                "uVar12": "r12",
                "r4_to_r11_stack_local": "r4ToR11StackLocal",
                "exc_return_local": "exceptionReturnLocal",
                "corrupted_local": "isCorruptedLocal",
                "sp_local": "stackPointerLocal",
                "stack_left": "stackLeft",
                "orig_sp": "original_sp",
                "pc": "programCounter"
            },
            "calling": [
                "hard_fault_default"
            ],
            "called": [
                "core_panic",
                "iprintf",
                "puts",
                "_stack_size_left"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000c80": {
            "entrypoint": "0x00000c80",
            "current_name": "handle_memory_error_00000c80",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleMemoryError_00000c80(void)\n\n{\n                    \n  core_panic(memoryErrorMessage,\"MEM MANAGE HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000c80": "handle_memory_error_00000c80",
                "PANIC_MEM_MANAGE": "memoryErrorMessage"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000c90": {
            "entrypoint": "0x00000c90",
            "current_name": "handle_bus_fault_00000c90",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_bus_fault_00000c90(void)\n\n{\n                    \n  panic(bus_fault_panic,\"BUS FAULT HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000c90": "handle_bus_fault_00000c90",
                "PANIC_BUS_FAULT": "bus_fault_panic",
                "core_panic": "panic"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000ca0": {
            "entrypoint": "0x00000ca0",
            "current_name": "handle_usage_fault_00000ca0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleUsageFault_00000ca0(void)\n\n{\n                    \n  panic(usageFault,\"USAGE FAULT HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000ca0": "handle_usage_fault_00000ca0",
                "PANIC_USAGE_FAULT": "usageFault",
                "core_panic": "panic"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cb0": {
            "entrypoint": "0x00000cb0",
            "current_name": "handle_debug_mon_00000cb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleDebugMon_00000cb0(void)\n\n{\n                    \n  core_panic(debugMonErrorCode,\"DEBUG MON HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000cb0": "handle_debug_mon_00000cb0",
                "PANIC_DEBUG_MON": "debugMonErrorCode"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cc0": {
            "entrypoint": "0x00000cc0",
            "current_name": "handle_dummy_00000cc0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleDummy_00000cc0(void)\n\n{\n                    \n  core_panic(dummyErrorMessage,\"DUMMY HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000cc0": "handle_dummy_00000cc0",
                "PANIC_DUMMY_HANDLER": "dummyErrorMessage"
            },
            "calling": [
                "dummy_handler"
            ],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cd0": {
            "entrypoint": "0x00000cd0",
            "current_name": "check_interrupts_enabled_00000cd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint checkInterruptsEnabled_00000cd0(void)\n\n{\n  bool isPrivileged;\n  uint interruptsEnabled;\n  uint32_t result;\n  uint32_t mask;\n  \n  interruptsEnabled = 0;\n  isPrivileged = (bool)checkCurrentModePrivileged();\n  if (isPrivileged) {\n    interruptsEnabled = checkIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return interruptsEnabled;\n}\n\n",
            "renaming": {
                "FUN_00000cd0": "check_interrupts_enabled_00000cd0",
                "isCurrentModePrivileged": "checkCurrentModePrivileged",
                "isIRQinterruptsEnabled": "checkIRQinterruptsEnabled",
                "uVar2": "interruptsEnabled",
                "bVar1": "isPrivileged"
            },
            "calling": [
                "pm_off",
                "core_panic",
                "mutex_unlock",
                "kernel_init",
                "kinetis_mcg_init",
                "thread_create",
                "_sbrk_r",
                "_mutex_lock",
                "sched_task_exit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cf0": {
            "entrypoint": "0x00000cf0",
            "current_name": "check_ir_qinterrupts_status_00000cf0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint checkIRQinterruptsStatus_00000cf0(void)\n\n{\n  bool isPrivilegedMode;\n  uint interruptsEnabled;\n  uint32_t interruptsStatus;\n  \n  enableIRQinterrupts();\n  interruptsEnabled = 0;\n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    interruptsEnabled = isIRQinterruptsEnabled();\n  }\n  return interruptsEnabled;\n}\n\n",
            "renaming": {
                "FUN_00000cf0": "check_ir_qinterrupts_status_00000cf0",
                "bVar1": "isPrivilegedMode",
                "uVar2": "interruptsEnabled",
                "result": "interruptsStatus"
            },
            "calling": [
                "cpu_switch_context_exit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d0c": {
            "entrypoint": "0x00000d0c",
            "current_name": "enable_interrupts_00000d0c",
            "code": "\nvoid enableInterrupts_00000d0c(uint inputState)\n\n{\n  bool privilegedMode;\n  uint localState;\n  \n  privilegedMode = (bool)isCurrentModePrivileged();\n  if (privilegedMode) {\n    enableIRQinterrupts((inputState & 1) == 1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000d0c": "enable_interrupts_00000d0c",
                "state": "inputState",
                "bVar1": "privilegedMode",
                "state_local": "localState"
            },
            "calling": [
                "mutex_unlock",
                "kinetis_mcg_init",
                "thread_create",
                "_sbrk_r",
                "_mutex_lock"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d2a": {
            "entrypoint": "0x00000d2a",
            "current_name": "get_exception_number_00000d2a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint getExceptionNumber_00000d2a(void)\n\n{\n  bool isPrivilegedMode;\n  uint exceptionNumber;\n  uint32_t result;\n  \n  exceptionNumber = 0;\n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    exceptionNumber = getCurrentExceptionNumber();\n    exceptionNumber = exceptionNumber & 0x1f;\n  }\n  return exceptionNumber;\n}\n\n",
            "renaming": {
                "FUN_00000d2a": "get_exception_number_00000d2a",
                "bVar1": "isPrivilegedMode",
                "uVar2": "exceptionNumber"
            },
            "calling": [
                "sched_switch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d44": {
            "entrypoint": "0x00000d44",
            "current_name": "calculate_offset_00000d44",
            "code": "\nvoid * calculateOffset_00000d44(void *originalPointer,uintoriginalPointer_t bitValue)\n\n{\n  uintoriginalPointer_t localBitValue;\n  void *localPointer;\n  \n  return (void *)(bitValue * 4 + ((uint)originalPointer & 0xf0000000 | ((uint)originalPointer & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00000d44": "calculate_offset_00000d44",
                "ptr": "originalPointer",
                "bit": "bitValue",
                "bit_local": "localBitValue",
                "ptr_local": "localPointer"
            },
            "calling": [
                "bit_clear32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d76": {
            "entrypoint": "0x00000d76",
            "current_name": "reset_bit_00000d76",
            "code": "\nvoid resetBit_00000d76(uint32_t *ptr,uint8_t bit)\n\n{\n  undefined4 *bitAddress;\n  uint8_t localBit;\n  uint32_t *localPtr;\n  \n  bitAddress = (undefined4 *)bitband_addr(ptr,(uint)bit);\n  *bitAddress = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000d76": "reset_bit_00000d76",
                "bit_local": "localBit",
                "ptr_local": "localPtr",
                "puVar1": "bitAddress"
            },
            "calling": [
                "cpu_errata_fixes"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d9c": {
            "entrypoint": "0x00000d9c",
            "current_name": "clear_peripheral_bit_00000d9c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearPeripheralBit_00000d9c(void)\n\n{\n  bit_clear32((uint32_t *)0x40048040,'\\0');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000d9c": "clear_peripheral_bit_00000d9c"
            },
            "calling": [
                "pre_startup"
            ],
            "called": [
                "bit_clear32"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000db0": {
            "entrypoint": "0x00000db0",
            "current_name": "disable_watchdog_and_fix_errors_00000db0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_watchdog_and_fix_errors_00000db0(void)\n\n{\n  disable_watchdog();\n  fix_cpu_errata();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000db0": "disable_watchdog_and_fix_errors_00000db0",
                "wdog_disable": "disable_watchdog",
                "cpu_errata_fixes": "fix_cpu_errata"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "wdog_disable",
                "cpu_errata_fixes"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000dc0": {
            "entrypoint": "0x00000dc0",
            "current_name": "initialize_default_handler_00000dc0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_default_handler_00000dc0(void)\n\n{\n  handle_default();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000dc0": "initialize_default_handler_00000dc0",
                "dummy_handler_default": "handle_default"
            },
            "calling": [],
            "called": [
                "dummy_handler_default"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000dcc": {
            "entrypoint": "0x00000dcc",
            "current_name": "initialize_memory_00000dcc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeMemory_00000dcc(void)\n\n{\n  _DAT_4005200e = 0xd928;\n  _DAT_40052000 = 0xd2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000dcc": "initialize_memory_00000dcc"
            },
            "calling": [
                "pre_startup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000df4": {
            "entrypoint": "0x00000df4",
            "current_name": "initialize_uart_00000df4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_uart_00000df4(void)\n\n{\n  initialize_uart_00000df4_module(0,0x1c200,uart_isrpipe_write_one + 1,&uart_standard_io_isrpipe);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000df4": "initialize_uart_00000df4",
                "uart_init": "initialize_uart_module",
                "isrpipe_write_one": "uart_isrpipe_write_one",
                "uart_stdio_isrpipe": "uart_standard_io_isrpipe"
            },
            "calling": [
                "_init"
            ],
            "called": [
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e14": {
            "entrypoint": "0x00000e14",
            "current_name": "read_from_uart_00000e14",
            "code": "\nint readFromUART_00000e14(char *inputBuffer,int bufferSize)\n\n{\n  int readCount;\n  int localBufferSize;\n  char *localBuffer;\n  \n  readCount = isrpipe_read(&uart_stdio_isrpipe,inputBuffer,bufferSize);\n  return readCount;\n}\n\n",
            "renaming": {
                "FUN_00000e14": "read_from_uart_00000e14",
                "buffer": "inputBuffer",
                "count": "bufferSize",
                "iVar1": "readCount",
                "count_local": "localBufferSize",
                "buffer_local": "localBuffer"
            },
            "calling": [
                "_read_r"
            ],
            "called": [
                "isrpipe_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e38": {
            "entrypoint": "0x00000e38",
            "current_name": "write_buffer_to_uart_00000e38",
            "code": "\nint writeBufferToUART_00000e38(char *data,int length)\n\n{\n  int localLength;\n  char *localBuffer;\n  \n  uart_write(0,(uint8_t *)data,length);\n  return length;\n}\n\n",
            "renaming": {
                "FUN_00000e38": "write_buffer_to_uart_00000e38",
                "buffer": "data",
                "len": "length",
                "len_local": "localLength",
                "buffer_local": "localBuffer"
            },
            "calling": [
                "_write_r"
            ],
            "called": [
                "uart_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e58": {
            "entrypoint": "0x00000e58",
            "current_name": "disable_interrupts_00000e58",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_interrupts_00000e58(void)\n\n{\n  irq_disable();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00000e58": "disable_interrupts_00000e58"
            },
            "calling": [
                "core_panic"
            ],
            "called": [
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e64": {
            "entrypoint": "0x00000e64",
            "current_name": "initialize_and_configure_00000e64",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_and_configure_00000e64(void)\n\n{\n  _DAT_40048038 = _DAT_40048038 | 0x200;\n  _DAT_40049048 = _DAT_40049048 & 0xfefff8ff;\n  cpu_init();\n  gpio_init(0x2056,GPIO_OUT);\n  gpio_init(0x511a,GPIO_OUT);\n  gpio_init(0x2055,GPIO_OUT);\n  gpio_set(0x2056);\n  gpio_set(0x511a);\n  gpio_set(0x2055);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000e64": "initialize_and_configure_00000e64"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "gpio_set",
                "cpu_init",
                "gpio_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000ed8": {
            "entrypoint": "0x00000ed8",
            "current_name": "print_lr_address_00000ed8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid printLRAddress_00000ed8(void)\n\n{\n  undefined4 lrAddress;\n  uint32_t *lrPointer;\n  \n  iprintf(\"%p\\n\",lrAddress);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000ed8": "print_lr_address_00000ed8",
                "in_lr": "lrAddress",
                "lr_ptr": "lrPointer"
            },
            "calling": [
                "core_panic"
            ],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000ef8": {
            "entrypoint": "0x00000ef8",
            "current_name": "FUNC_00000ef8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000ef8": "FUNC_00000ef8"
            },
            "calling": [
                "core_panic"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00000f04": {
            "entrypoint": "0x00000f04",
            "current_name": "handle_kernel_panic_00000f04",
            "code": "\nvoid handleKernelPanic_00000f04(core_panic_t panicCode,char *errorMessage)\n\n{\n  undefined4 stackUsage_18;\n  undefined4 stackUsage_14;\n  char *localErrorMessage;\n  core_panic_t localPanicCode;\n  \n  localErrorMessage = errorMessage;\n  localPanicCode = panicCode;\n  if (crashed == 0) {\n    crashed = 1;\n    if (panicCode == PANIC_ASSERT_FAIL) {\n      cpu_print_last_instruction();\n    }\n    iprintf(\"*** RIOT kernel panic:\\n%s\\n\\n\",localErrorMessage);\n    ps();\n    iprintf(\"\\n\");\n    iprintf(\"*** halted.\\n\\n\");\n  }\n  irq_disable();\n  panic_arch();\n  stackUsage_14 = 0xf4d;\n  pm_off();\n  stackUsage_18 = (int)&stackUsage_18 + 1;\n  auto_init();\n  iprintf(\"main(): This is RIOT! (Version: 2018.04-vm-HEAD)\\n\");\n  main();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000f04": "handle_kernel_panic_00000f04",
                "crash_code": "panicCode",
                "message": "errorMessage",
                "crash_code_local": "localPanicCode",
                "message_local": "localErrorMessage",
                "uStack_18": "stackUsage_18",
                "uStack_14": "stackUsage_14"
            },
            "calling": [
                "debug_mon_default",
                "uart_init",
                "hard_fault_handler",
                "thread_add_to_list",
                "usage_fault_default",
                "bus_fault_default",
                "fmt_s32_dfp",
                "nmi_default",
                "mem_manage_default",
                "cib_init",
                "dummy_handler_default"
            ],
            "called": [
                "pm_off",
                "ps",
                "panic_arch",
                "cpu_print_last_instruction",
                "iprintf",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000f5c": {
            "entrypoint": "0x00000f5c",
            "current_name": "initialize_and_print_00000f5c",
            "code": "\nvoid * initialize_and_print_00000f5c(void *input_arg)\n\n{\n  void *local_arg;\n  \n  initialize();\n  print_formatted(\"execute_main(): This is RIOT! (Version: 2018.04-vm-HEAD)\\n\");\n  execute_main();\n  return (void *)0x0;\n}\n\n",
            "renaming": {
                "FUN_00000f5c": "initialize_and_print_00000f5c",
                "arg": "input_arg",
                "arg_local": "local_arg",
                "auto_init": "initialize",
                "iprintf": "print_formatted",
                "main": "execute_main"
            },
            "calling": [],
            "called": [
                "auto_init",
                "iprintf",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000f80": {
            "entrypoint": "0x00000f80",
            "current_name": "infinite_loop_00000f80",
            "code": "\nvoid * infiniteLoop_00000f80(void *arg_local)\n\n{\n  void *arg_local_local;\n  \n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00000f80": "infinite_loop_00000f80",
                "arg": "arg_local"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000f8c": {
            "entrypoint": "0x00000f8c",
            "current_name": "initialize_system_00000f8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_system_00000f8c(void)\n\n{\n  disable_interrupts();\n  create_thread(idle_stack_pointer,0x100,'\\x0f',0xc,idle_thread_function + 1,(void *)0x0,idle_name);\n  create_thread(main_stack_pointer,0x600,'\\a',0xc,main_trampoline_function + 1,(void *)0x0,main_name);\n                    \n  exit_cpu_context();\n}\n\n",
            "renaming": {
                "FUN_00000f8c": "initialize_system_00000f8c",
                "idle_stack": "idle_stack_pointer",
                "main_stack": "main_stack_pointer",
                "idle_thread": "idle_thread_function",
                "main_trampoline": "main_trampoline_function",
                "irq_disable": "disable_interrupts",
                "thread_create": "create_thread",
                "cpu_switch_context_exit": "exit_cpu_context"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "cpu_switch_context_exit",
                "thread_create",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000fec": {
            "entrypoint": "0x00000fec",
            "current_name": "initialize_circular_buffer_00000fec",
            "code": "\nvoid initializeCircularBuffer_00000fec(buffer_t *buffer,uint bufferSize)\n\n{\n  uint localSize;\n  buffer_t *localBuffer;\n  buffer_t c;\n  \n  if ((bufferSize & bufferSize - 1) != 0) {\n                    \n    core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n  }\n  buffer->read_count = 0;\n  buffer->write_count = 0;\n  buffer->mask = bufferSize - 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000fec": "initialize_circular_buffer_00000fec",
                "cib": "buffer",
                "size": "bufferSize",
                "size_local": "localSize",
                "cib_local": "localBuffer"
            },
            "calling": [
                "thread_create"
            ],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001034": {
            "entrypoint": "0x00001034",
            "current_name": "insert_thread_into_list_00001034",
            "code": "\nvoid insertThreadIntoList_00001034(threadList_node_t *threadList,newThread_t *newThread)\n\n{\n  newThread_t *currentThread;\n  threadList_node_t *currentList;\n  newThread_t *entryInList;\n  cthreadList_node_t *tempCListNode;\n  threadList_node_t *newListNode;\n  uint16_t threadPriority;\n  \n  if (newThread->status < 9) {\n    currentList = threadList;\n    while ((currentList->next != (threadList_node *)0x0 &&\n           (*(byte *)((int)&currentList->next[-1].next + 1) <= newThread->priority))) {\n      currentList = currentList->next;\n    }\n    (newThread->rq_entry).next = currentList->next;\n    currentList->next = &newThread->rq_entry;\n    return;\n  }\n                    \n  core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n}\n\n",
            "renaming": {
                "FUN_00001034": "insert_thread_into_list_00001034",
                "list": "threadList",
                "thread": "newThread",
                "thread_local": "currentThread",
                "list_local": "currentList",
                "list_entry": "entryInList",
                "__m____": "tempCListNode",
                "new_node": "newListNode",
                "my_prio": "threadPriority"
            },
            "calling": [
                "_mutex_lock"
            ],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000010a0": {
            "entrypoint": "0x000010a0",
            "current_name": "calculate_stack_usage_000010a0",
            "code": "\nuintptr_t calculateStackUsage_000010a0(char *stackPointer)\n\n{\n  char *localStackPointer;\n  uintptr_t freeSpace;\n  uintptr_t *currentPtr;\n  \n  for (currentPtr = (uintptr_t *)stackPointer; (uintptr_t *)*currentPtr == currentPtr; currentPtr = currentPtr + 1) {\n  }\n  return (int)currentPtr - (int)stackPointer;\n}\n\n",
            "renaming": {
                "FUN_000010a0": "calculate_stack_usage_000010a0",
                "stack": "stackPointer",
                "stack_local": "localStackPointer",
                "space_free": "freeSpace",
                "stackp": "currentPtr"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000010d4": {
            "entrypoint": "0x000010d4",
            "current_name": "create_thread_000010d4",
            "code": "\nkernel_newPid_t\ncreateThread_000010d4(char *stackBuffer,threadIndexnt stackBufferSize,char threadPriority,threadIndexnt threadFlags,ThreadStructask_func_t threadFunction,vothreadIndexd *threadArgument\n            ,char *threadName)\n\n{\n  uthreadIndexnt savedIrqState;\n  char *pointerVar1;\n  threadIndexnt intVar2;\n  uthreadIndexnt adjustedStackSize;\n  ThreadStruct *newThread;\n  threadIndexnt localFlags;\n  char localPriority;\n  threadIndexnt localStackSize;\n  char *adjustedStack;\n  uthreadIndexnt irqState;\n  uthreadIndexntptr_t *stackMax;\n  ThreadStruct *cb;\n  uthreadIndexntptr_t stackMisalignment;\n  threadIndexnt totalAdjustedStackSize;\n  uthreadIndexntptr_t *stackPointer;\n  kernel_newPid_t threadIndex;\n  kernel_newPid_t newPid;\n  \n  threadIndexf ((byte)threadPriority < 0x10) {\n    localStackSize = stackBufferSize;\n    adjustedStack = stackBuffer;\n    threadIndexf (((uthreadIndexnt)stackBuffer & 3) != 0) {\n      intVar2 = 4 - ((uthreadIndexnt)stackBuffer & 3);\n      adjustedStack = stackBuffer + intVar2;\n      localStackSize = stackBufferSize - intVar2;\n    }\n    adjustedStackSize = localStackSize - 0x30U & 0xfffffffc;\n    newThread = (ThreadStruct *)(adjustedStack + adjustedStackSize);\n    threadIndexf ((threadFlags & 8U) == 0) {\n      *(char **)adjustedStack = adjustedStack;\n    }\n    else {\n      for (stackPointer = (uthreadIndexntptr_t *)adjustedStack; stackPointer < adjustedStack + adjustedStackSize; stackPointer = stackPointer + 1\n          ) {\n        *stackPointer = (uthreadIndexntptr_t)stackPointer;\n      }\n    }\n    savedIrqState = threadIndexrq_dthreadIndexsable();\n    newPid = 0;\n    for (threadIndex = 1; threadIndex < 0x21; threadIndex = threadIndex + 1) {\n      threadIndexf (threadTable[threadIndex] == (ThreadStruct *)0x0) {\n        newPid = threadIndex;\n        break;\n      }\n    }\n    threadIndexf (newPid == 0) {\n      threadIndexrq_restore(savedIrqState);\n      newPid = -0x8b;\n    }\n    else {\n      threadTable[newPid] = newThread;\n      newThread->newPid = newPid;\n      pointerVar1 = thread_stackBuffer_threadIndexnthreadIndext(threadFunction,threadArgument,adjustedStack,adjustedStackSize);\n      newThread->sp = pointerVar1;\n      newThread->stackBuffer_start = adjustedStack;\n      newThread->adjustedStackSize = stackBufferSize;\n      newThread->threadName = threadName;\n      newThread->threadPriority = threadPriority;\n      newThread->status = '\\0';\n      (newThread->rq_entry).next = (ListNodeStruct *)0x0;\n      newThread->wathreadIndext_data = (vothreadIndexd *)0x0;\n      (newThread->msg_wathreadIndexters).next = (ListNodeStruct *)0x0;\n      cthreadIndexb_threadIndexnthreadIndext(&newThread->msg_queue,0);\n      newThread->msg_array = (MessageStruct *)0x0;\n      numberOfThreads = numberOfThreads + 1;\n      threadIndexf ((threadFlags & 1U) == 0) {\n        sched_set_status(newThread,10);\n        threadIndexf ((threadFlags & 4U) == 0) {\n          threadIndexrq_restore(savedIrqState);\n          sched_swthreadIndextch((ushort)(byte)threadPriority);\n          return newPid;\n        }\n      }\n      else {\n        sched_set_status(newThread,1);\n      }\n      threadIndexrq_restore(savedIrqState);\n    }\n  }\n  else {\n    newPid = -0x16;\n  }\n  return newPid;\n}\n\n",
            "renaming": {
                "FUN_000010d4": "create_thread_000010d4",
                "stack": "stackBuffer",
                "stacksize": "stackBufferSize",
                "priority": "threadPriority",
                "flags": "threadFlags",
                "function": "threadFunction",
                "arg": "threadArgument",
                "name": "threadName",
                "state_00": "savedIrqState",
                "pcVar1": "pointerVar1",
                "iVar2": "intVar2",
                "stack_size": "adjustedStackSize",
                "process": "newThread",
                "flags_local": "localFlags",
                "priority_local": "localPriority",
                "stacksize_local": "localStackSize",
                "stack_local": "adjustedStack",
                "state": "irqState",
                "stackmax": "stackMax",
                "misalignment": "stackMisalignment",
                "total_stacksize": "totalAdjustedStackSize",
                "stackp": "stackPointer",
                "i": "threadIndex",
                "pid": "newPid",
                "sched_threads": "threadTable",
                "sched_num_threads": "numberOfThreads",
                "thread_t": "ThreadStruct",
                "list_node": "ListNodeStruct",
                "msg_t": "MessageStruct"
            },
            "calling": [
                "kernel_init"
            ],
            "called": [
                "irq_restore",
                "sched_set_status",
                "sched_switch",
                "cib_init",
                "irq_disable",
                "thread_stack_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001274": {
            "entrypoint": "0x00001274",
            "current_name": "initialize_system_00001274",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_system_00001274(void)\n\n{\n  initialize_cortexm();\n  DAT_4007e000 = DAT_4007e000 | 0x28;\n  initialize_kinetis_mcg();\n  initialize_peripherals();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001274": "initialize_system_00001274",
                "cortexm_init": "initialize_cortexm",
                "kinetis_mcg_init": "initialize_kinetis_mcg",
                "periph_init": "initialize_peripherals"
            },
            "calling": [
                "board_init"
            ],
            "called": [
                "kinetis_mcg_init",
                "periph_init",
                "cortexm_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000129c": {
            "entrypoint": "0x0000129c",
            "current_name": "lock_mutex_0000129c",
            "code": "\nvoid lockMutex_0000129c(mutex_t *mutex)\n\n{\n  mutex_t *mutex_local;\n  \n  _mutex_lock(mutex,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000129c": "lock_mutex_0000129c"
            },
            "calling": [
                "isrpipe_read"
            ],
            "called": [
                "_mutex_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000012b4": {
            "entrypoint": "0x000012b4",
            "current_name": "add_character_to_isr_pipe_000012b4",
            "code": "\nint addCharacterToISRPipe_000012b4(pipe_t *pipe,char c)\n\n{\n  int result_code;\n  char local_character;\n  pipe_t *local_pipe;\n  int result;\n  \n  result_code = tsrb_add_one(&pipe->tsrb,c);\n  mutex_unlock(&pipe->mutex);\n  return result_code;\n}\n\n",
            "renaming": {
                "FUN_000012b4": "add_character_to_isr_pipe_000012b4",
                "isrpipe": "pipe",
                "c_local": "local_character",
                "isrpipe_local": "local_pipe",
                "res": "result",
                "iVar1": "result_code"
            },
            "calling": [],
            "called": [
                "mutex_unlock",
                "tsrb_add_one"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000012e2": {
            "entrypoint": "0x000012e2",
            "current_name": "read_from_isr_pipe_000012e2",
            "code": "\nint readFromISRPipe_000012e2(pipe_t *pipe,char *outputBuffer,size_t bufferSize)\n\n{\n  int iVar1;\n  size_t localBufferSize;\n  char *localOutputBuffer;\n  pipe_t *localPipe;\n  int result;\n  \n  while( true ) {\n    iVar1 = tsrb_get(&pipe->tsrb,outputBuffer,bufferSize);\n    if (iVar1 != 0) break;\n    mutex_lock(&pipe->mutex);\n  }\n  return iVar1;\n}\n\n",
            "renaming": {
                "FUN_000012e2": "read_from_isr_pipe_000012e2",
                "isrpipe": "pipe",
                "buffer": "outputBuffer",
                "count": "bufferSize",
                "count_local": "localBufferSize",
                "buffer_local": "localOutputBuffer",
                "isrpipe_local": "localPipe",
                "res": "result"
            },
            "calling": [
                "uart_stdio_read"
            ],
            "called": [
                "tsrb_get",
                "mutex_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001318": {
            "entrypoint": "0x00001318",
            "current_name": "set_irq_bit_00001318",
            "code": "\nvoid set_irq_bit_00001318(interrupt_number_Type interrupt_number)\n\n{\n  interrupt_number_Type local_interrupt_number;\n  \n  *(int *)(((uint)(int)interrupt_number >> 5) * 4 + -0x1fff1f00) = 1 << (interrupt_number & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001318": "set_irq_bit_00001318",
                "IRQn": "interrupt_number",
                "IRQn_local": "local_interrupt_number"
            },
            "calling": [
                "uart_init_uart"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001348": {
            "entrypoint": "0x00001348",
            "current_name": "check_and_yield_00001348",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid check_and_yield_00001348(void)\n\n{\n  if (sched_context_switch_request != 0) {\n    thread_yield_higher();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001348": "check_and_yield_00001348"
            },
            "calling": [
                "irq_handler_uart"
            ],
            "called": [
                "thread_yield_higher"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001360": {
            "entrypoint": "0x00001360",
            "current_name": "calculate_new_address_00001360",
            "code": "\nvoid * calculateNewAddress_00001360(void *originalPointer,uintoriginalPointer_t bitValue)\n\n{\n  uintoriginalPointer_t localBitValue;\n  void *localOriginalPointer;\n  \n  return (void *)(bitValue * 4 + ((uint)originalPointer & 0xf0000000 | ((uint)originalPointer & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00001360": "calculate_new_address_00001360",
                "ptr": "originalPointer",
                "bit": "bitValue",
                "bit_local": "localBitValue",
                "ptr_local": "localOriginalPointer"
            },
            "calling": [
                "bit_set32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001392": {
            "entrypoint": "0x00001392",
            "current_name": "set_bit_in_ptr_00001392",
            "code": "\nvoid setBitInPtr_00001392(uint32_t *ptr,uint8_t bit)\n\n{\n  undefined4 *puVar1;\n  uint8_t bit_local;\n  uint32_t *ptr_local;\n  \n  puVar1 = (undefined4 *)bitband_addr(ptr,(uint)bit);\n  *puVar1 = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001392": "set_bit_in_ptr_00001392"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000013b8": {
            "entrypoint": "0x000013b8",
            "current_name": "initialize_uart_000013b8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0000142e) */\n\nint initialize_uart_000013b8(uart_device_t uart_device,uint32_t baud_rate,uart_device_receive_callback_t receive_callback,void *callback_argument)\n\n{\n  void *local_argument;\n  uart_device_receive_callback_t local_receive_callback;\n  uint32_t local_baud_rate;\n  uart_device_t local_uart;\n  \n  if (uart_device == 0) {\n    config[0].receive_callback = receive_callback;\n    config[0].callback_argument = callback_argument;\n    uart_device_init_pins(0);\n    bit_set32((uint32_t *)&DAT_40048034,'\\n');\n    uart_device_init_uart_device(0,baud_rate);\n    return 0;\n  }\n                    \n  core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n}\n\n",
            "renaming": {
                "FUN_000013b8": "initialize_uart_000013b8",
                "uart": "uart_device",
                "baudrate": "baud_rate",
                "rx_cb": "receive_callback",
                "arg": "callback_argument",
                "arg_local": "local_argument",
                "rx_cb_local": "local_receive_callback",
                "baudrate_local": "local_baud_rate",
                "uart_local": "local_uart"
            },
            "calling": [
                "uart_stdio_init"
            ],
            "called": [
                "uart_init_uart",
                "core_panic",
                "uart_init_pins",
                "bit_set32"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001448": {
            "entrypoint": "0x00001448",
            "current_name": "initialize_uart_00001448",
            "code": "\nvoid initializeUART_00001448(selectedUART_t selectedUART)\n\n{\n  selectedUART_t localUART;\n  \n  if (configuration[selectedUART].receivePin != 0xffff) {\n    gpio_init_port(configuration[selectedUART].receivePin,configuration[selectedUART].receivePortConfiguration);\n  }\n  if (configuration[selectedUART].transmitPin != 0xffff) {\n    gpio_init_port(configuration[selectedUART].transmitPin,configuration[selectedUART].transmitPortConfiguration);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001448": "initialize_uart_00001448",
                "uart": "selectedUART",
                "uart_local": "localUART",
                "uart_config": "configuration",
                "pin_rx": "receivePin",
                "pcr_rx": "receivePortConfiguration",
                "pin_tx": "transmitPin",
                "pcr_tx": "transmitPortConfiguration"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "gpio_init_port"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000014c4": {
            "entrypoint": "0x000014c4",
            "current_name": "configure_uart_000014c4",
            "code": "\nvoid configureUART_000014c4(uartPort_t uartPort,uint32_t baudrate)\n\n{\n  byte *uartDev;\n  uint uartFrequency;\n  uint divider;\n  uint32_t baudrateLocal;\n  uartPort_t uartPortLocal;\n  uint8_t txFifoSize;\n  uint8_t brfa;\n  uint16_t ubd;\n  uint32_t clock;\n  UART_Type *device;\n  \n  uartDev = (byte *)uartPort_config[uartPort].device;\n  uartFrequency = uartPort_config[uartPort].freq;\n  uartDev[3] = uartDev[3] & 0xf3;\n  uartDev[2] = uartPort_config[uartPort].mode;\n  divider = uartFrequency / (baudrate << 4);\n  *uartDev = (byte)(divider >> 8) & 0x1f;\n  uartDev[1] = (byte)divider;\n  uartDev[10] = (byte)((uartFrequency << 2) / baudrate + 1 >> 1) & 0x1f;\n  uartDev[0x10] = uartDev[0x10] | 0x88;\n  if ((uartDev[0x10] & 0x70) == 0) {\n    uartDev[0x13] = 0;\n  }\n  else {\n    uartDev[0x13] = (char)(2 << (uartDev[0x10] >> 4 & 7)) - 1;\n  }\n  uartDev[0x15] = 1;\n  uartDev[0x11] = 0xc0;\n  uartDev[3] = uartDev[3] | 0x2c;\n  NVIC_EnableIRQ(uartPort_config[uartPort].irqn);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000014c4": "configure_uart_000014c4",
                "uart": "uartPort",
                "pbVar1": "uartDev",
                "uVar2": "uartFrequency",
                "uVar3": "divider",
                "baudrate_local": "baudrateLocal",
                "uart_local": "uartPortLocal",
                "txfifo_size": "txFifoSize",
                "clk": "clock",
                "dev": "device"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "NVIC_EnableIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000015d0": {
            "entrypoint": "0x000015d0",
            "current_name": "send_data_via_uart_000015d0",
            "code": "\nvoindexd sendDataViaUart_000015d0(uartPort_t uartPort,uindexnt8_t *dataBuffer,sindexze_t dataLength)\n\n{\n  voindexd *pvVar1;\n  sindexze_t localDataLength;\n  uindexnt8_t *localDataBuffer;\n  uartPort_t localUartPort;\n  UART_Type *uartDevice;\n  sindexze_t index;\n  \n  pvVar1 = uartPort_confindexg[uartPort].uartDevice;\n  for (index = 0; index < dataLength; index = index + 1) {\n    do {\n    } whindexle (-1 < *(char *)((indexnt)pvVar1 + 4));\n    *(uindexnt8_t *)((indexnt)pvVar1 + 7) = dataBuffer[index];\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000015d0": "send_data_via_uart_000015d0",
                "uart": "uartPort",
                "data": "dataBuffer",
                "len": "dataLength",
                "len_local": "localDataLength",
                "data_local": "localDataBuffer",
                "uart_local": "localUartPort",
                "dev": "uartDevice",
                "i": "index"
            },
            "calling": [
                "uart_stdio_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001628": {
            "entrypoint": "0x00001628",
            "current_name": "handle_uart_event_00001628",
            "code": "\nvoid handle_uart_event_00001628(uart_id_t uart_id)\n\n{\n  uart_id_t local_uart;\n  uint8_t received_data;\n  UART_Type *uart_device;\n  \n  if (((*(byte *)((int)uart_id_config[uart_id].uart_device + 4) & 0x20) != 0) &&\n     (config[uart_id].rx_cb != (uart_id_rx_cb_t)0x0)) {\n    (*config[uart_id].rx_cb)(config[uart_id].arg,*(uint8_t *)((int)uart_id_config[uart_id].uart_device + 7));\n  }\n  cortexm_isr_end();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001628": "handle_uart_event_00001628",
                "uart": "uart_id",
                "uart_local": "local_uart",
                "data": "received_data",
                "dev": "uart_device"
            },
            "calling": [
                "isr_uart0_rx_tx"
            ],
            "called": [
                "cortexm_isr_end"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001688": {
            "entrypoint": "0x00001688",
            "current_name": "initialize_uart_irq_handler_00001688",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_uart_irq_handler_00001688(void)\n\n{\n  handle_uart_irq(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001688": "initialize_uart_irq_handler_00001688",
                "irq_handler_uart": "handle_uart_irq"
            },
            "calling": [],
            "called": [
                "irq_handler_uart"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001696": {
            "entrypoint": "0x00001696",
            "current_name": "calculate_offset_00001696",
            "code": "\nvoid * calculateOffset_00001696(void *inputPtr,uintinputPtr_t offsetBit)\n\n{\n  uintinputPtr_t localOffsetBit;\n  void *localInputPtr;\n  \n  return (void *)(offsetBit * 4 + ((uint)inputPtr & 0xf0000000 | ((uint)inputPtr & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00001696": "calculate_offset_00001696",
                "ptr": "inputPtr",
                "bit": "offsetBit",
                "bit_local": "localOffsetBit",
                "ptr_local": "localInputPtr"
            },
            "calling": [
                "bit_clear8",
                "bit_set8",
                "bit_set32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000016c8": {
            "entrypoint": "0x000016c8",
            "current_name": "set_bit_000016c8",
            "code": "\nvoid setBit_000016c8(uint32_t *ptr,uint8_t bit)\n\n{\n  undefined4 *bitPointer;\n  uint8_t local_bit;\n  uint32_t *local_ptr;\n  \n  bitPointer = (undefined4 *)bitband_addr(ptr,(uint)bit);\n  *bitPointer = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000016c8": "set_bit_000016c8",
                "bit_local": "local_bit",
                "ptr_local": "local_ptr",
                "puVar1": "bitPointer"
            },
            "calling": [
                "kinetis_mcg_init_erclk32k"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000016ec": {
            "entrypoint": "0x000016ec",
            "current_name": "set_bit_value_000016ec",
            "code": "\nvoid setBitValue_000016ec(uint8_t *ptr,uint8_t bit)\n\n{\n  undefined *bitPointer;\n  uint8_t localBit;\n  uint8_t *localPtr;\n  \n  bitPointer = (undefined *)bitband_addr(ptr,(uint)bit);\n  *bitPointer = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000016ec": "set_bit_value_000016ec",
                "bit_local": "localBit",
                "ptr_local": "localPtr",
                "puVar1": "bitPointer"
            },
            "calling": [
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_blpi",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_blpe"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001710": {
            "entrypoint": "0x00001710",
            "current_name": "clear_bit_in_memory_00001710",
            "code": "\nvoid clearBitInMemory_00001710(uint8_t *ptr,uint8_t bit)\n\n{\n  undefined *puVar1;\n  uint8_t bit_local;\n  uint8_t *ptr_local;\n  \n  puVar1 = (undefined *)bitband_addr(ptr,(uint)bit);\n  *puVar1 = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001710": "clear_bit_in_memory_00001710"
            },
            "calling": [
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_disable_pll"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001734": {
            "entrypoint": "0x00001734",
            "current_name": "clear_bit_8_00001734",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clear_bit_8_00001734(void)\n\n{\n  bit_clear8(&DAT_40064005,'\\x06');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001734": "clear_bit_8_00001734"
            },
            "calling": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_blpi",
                "kinetis_mcg_set_blpe"
            ],
            "called": [
                "bit_clear8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001748": {
            "entrypoint": "0x00001748",
            "current_name": "update_mcgfll_factor_00001748",
            "code": "\nvoid updateMCGFLLFactor_00001748(kinetis_mcg_fll_t newFactor)\n\n{\n  kinetis_mcg_fll_t localFactor;\n  \n  DAT_40064003 = newFactor | DAT_40064003 & ~KINETIS_MCG_FLL_FACTOR_2929;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001748": "update_mcgfll_factor_00001748",
                "factor": "newFactor",
                "factor_local": "localFactor"
            },
            "calling": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_safe_mode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001778": {
            "entrypoint": "0x00001778",
            "current_name": "clear_flags_00001778",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0000179c) */\n/* WARNING: Removing unreachable block (ram,0x000017b2) */\n/* WARNING: Removing unreachable block (ram,0x000017c0) */\n/* WARNING: Unknown calling convention */\n\nvoid clearFlags_00001778(void)\n\n{\n  DAT_40064001 = DAT_40064001 & 0xcf | 0x20;\n  bit_clear8(&DAT_40064001,'\\x02');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001778": "clear_flags_00001778"
            },
            "calling": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fee"
            ],
            "called": [
                "bit_clear8",
                "bit_set8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000017dc": {
            "entrypoint": "0x000017dc",
            "current_name": "initialize_system_000017dc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_000017dc(void)\n\n{\n  bit_set32((uint32_t *)&DAT_4004803c,'\\x1d');\n  if ((_DAT_4003d010 & 0x100) == 0) {\n    _DAT_4003d010 = 0x104;\n  }\n  _DAT_40047000 = _DAT_40047000 & 0xfff3ffff | 0x80000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000017dc": "initialize_system_000017dc"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "bit_set32"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000182c": {
            "entrypoint": "0x0000182c",
            "current_name": "clear_data_registers_0000182c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0000187c) */\n/* WARNING: Removing unreachable block (ram,0x0000186a) */\n/* WARNING: Removing unreachable block (ram,0x00001898) */\n/* WARNING: Unknown calling convention */\n\nvoid clearDataRegisters_0000182c(void)\n\n{\n  uint8_t temporaryVariable;\n  \n  DAT_40064008 = DAT_40064008 & 0xd0;\n  bit_set8(&DAT_40064001,'\\0');\n  bit_clear8(&DAT_40064000,'\\x01');\n  bit_clear8(&DAT_40064000,'\\0');\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000182c": "clear_data_registers_0000182c",
                "tmp": "temporaryVariable"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "bit_clear8",
                "bit_set8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000018bc": {
            "entrypoint": "0x000018bc",
            "current_name": "initialize_fll_000018bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeFLL_000018bc(void)\n\n{\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_1464);\n  DAT_40064000 = DAT_40064000 & 0x3b | 4;\n  bit_clear8(&DAT_40064001,'\\x01');\n  do {\n  } while ((DAT_40064006 & 0x10) == 0);\n  do {\n  } while ((DAT_40064006 & 0xc) != 0);\n  mcgMode = KINETIS_MCG_MODE_FEI;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000018bc": "initialize_fll_000018bc",
                "current_mode": "mcgMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000191c": {
            "entrypoint": "0x0000191c",
            "current_name": "enable_fll_and_set_mode_fee_0000191c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableFLLAndSetModeFEE_0000191c(void)\n\n{\n  enableOscillator();\n  setFllFactor(FLLFactor_1920);\n  DAT_40064000 = DAT_40064000 & 0x3b;\n  do {\n  } while ((DAT_40064006 & 0xc) != 0);\n  currentMode = KINETIS_MCG_MODE_FEE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000191c": "enable_fll_and_set_mode_fee_0000191c",
                "kinetis_mcg_enable_osc": "enableOscillator",
                "kinetis_mcg_set_fll_factor": "setFllFactor",
                "KINETIS_MCG_FLL_FACTOR_1920": "FLLFactor_1920",
                "current_mode": "currentMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001960": {
            "entrypoint": "0x00001960",
            "current_name": "initialize_mcg_00001960",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeMCG_00001960(void)\n\n{\n  kinetis_mcg_set_fll_factor(FLL_FACTOR_1464);\n  bit_clear8(&DAT_40064001,'\\x01');\n  DAT_40064000 = DAT_40064000 & 0x3b | 0x44;\n  do {\n  } while ((DAT_40064006 & 0xc) != 4);\n  do {\n  } while ((DAT_40064006 & 0x10) == 0);\n  currentMode = MODE_FBI;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001960": "initialize_mcg_00001960",
                "KINETIS_MCG_FLL_FACTOR_1464": "FLL_FACTOR_1464",
                "KINETIS_MCG_MODE_FBI": "MODE_FBI",
                "current_mode": "currentMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000019c0": {
            "entrypoint": "0x000019c0",
            "current_name": "initialize_clock_system_000019c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeClockSystem_000019c0(void)\n\n{\n  enableOscillator();\n  setFllFactor(KINETIS_MCG_FLL_FACTOR_1920);\n  clearBit8(&DAT_40064001,'\\x01');\n  DAT_40064000 = DAT_40064000 & 0x3b | 0x80;\n  do {\n  } while ((DAT_40064006 & 0xc) != 8);\n  disablePll();\n  currentMode = modeFBE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000019c0": "initialize_clock_system_000019c0",
                "kinetis_mcg_enable_osc": "enableOscillator",
                "kinetis_mcg_set_fll_factor": "setFllFactor",
                "bit_clear8": "clearBit8",
                "kinetis_mcg_disable_pll": "disablePll",
                "current_mode": "currentMode",
                "KINETIS_MCG_MODE_FBE": "modeFBE"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_fll_factor",
                "kinetis_mcg_disable_pll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001a18": {
            "entrypoint": "0x00001a18",
            "current_name": "initialize_blpi_mode_00001a18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_blpi_mode_00001a18(void)\n\n{\n  bit_set8(&DAT_40064001,'\\x01');\n  disable_pll();\n  mcg_current_mode = KINETIS_MCG_MODE_BLPI;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001a18": "initialize_blpi_mode_00001a18",
                "kinetis_mcg_disable_pll": "disable_pll",
                "current_mode": "mcg_current_mode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001a3c": {
            "entrypoint": "0x00001a3c",
            "current_name": "set_power_mode_to_blpe_00001a3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_power_mode_to_BLPE_00001a3c(void)\n\n{\n  bit_set8(&DAT_40064001,'\\x01');\n  disable_pll();\n  mcg_current_mode = KINETIS_MCG_MODE_BLPE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001a3c": "set_power_mode_to_blpe_00001a3c",
                "kinetis_mcg_disable_pll": "disable_pll",
                "current_mode": "mcg_current_mode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001a60": {
            "entrypoint": "0x00001a60",
            "current_name": "initialize_mcg_00001a60",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_MCG_00001a60(void)\n\n{\n  clear_bit_8(&DAT_40064001,'\\x01');\n  DAT_40064000 = DAT_40064000 & 0x3f | 0x80;\n  do {\n  } while ((DAT_40064006 & 0xc) != 8);\n  set_bit_8(&DAT_40064005,'\\x06');\n  do {\n  } while ((DAT_40064006 & 0x20) == 0);\n  do {\n  } while ((DAT_40064006 & 0x40) == 0);\n  MCG_current_mode = power_backward_external;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001a60": "initialize_mcg_00001a60",
                "current_mode": "MCG_current_mode",
                "bit_clear8": "clear_bit_8",
                "bit_set8": "set_bit_8",
                "KINETIS_MCG_MODE_PBE": "power_backward_external"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "bit_set8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ad4": {
            "entrypoint": "0x00001ad4",
            "current_name": "initialize_system_00001ad4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_00001ad4(void)\n\n{\n  DAT_40064000 = DAT_40064000 & 0x3f;\n  do {\n  } while ((DAT_40064006 & 0xc) != 0xc);\n  mcgMode = KINETIS_MCG_MODE_PEE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ad4": "initialize_system_00001ad4",
                "current_mode": "mcgMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001b10": {
            "entrypoint": "0x00001b10",
            "current_name": "set_mcg_mode_00001b10",
            "code": "\nint setMCGMode_00001b10(kinetis_mcg_inputMode_t inputMode)\n\n{\n  int result;\n  kinetis_mcg_inputMode_t currentMode;\n  \n  if (inputMode < KINETIS_MCG_MODE_NUMOF) {\n    do {\n      switch(mcg_inputMode_routing[current_inputMode][inputMode]) {\n      case '\\0':\n        kinetis_mcg_set_fei();\n        break;\n      case '\\x01':\n        kinetis_mcg_set_fee();\n        break;\n      case '\\x02':\n        kinetis_mcg_set_fbi();\n        break;\n      case '\\x03':\n        kinetis_mcg_set_fbe();\n        break;\n      case '\\x04':\n        kinetis_mcg_set_blpi();\n        break;\n      case '\\x05':\n        kinetis_mcg_set_blpe();\n        break;\n      case '\\x06':\n        kinetis_mcg_set_pbe();\n        break;\n      case '\\a':\n        kinetis_mcg_set_pee();\n        break;\n      default:\n        return -1;\n      }\n    } while (inputMode != current_inputMode);\n    result = 0;\n  }\n  else {\n    result = -1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00001b10": "set_mcg_mode_00001b10",
                "mode": "inputMode",
                "mode_local": "currentMode",
                "iVar1": "result"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_blpi",
                "kinetis_mcg_set_pee",
                "kinetis_mcg_set_blpe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001bb8": {
            "entrypoint": "0x00001bb8",
            "current_name": "initialize_mcg_00001bb8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeMCG_00001bb8(void)\n\n{\n  if ((DAT_40064001 & 2) != 0) {\n    bit_clear8(&DAT_40064001,'\\x01');\n  }\n  if ((DAT_40064005 & 0x40) != 0) {\n    if ((DAT_40064000 & 0xc0) == 0) {\n      DAT_40064000 = DAT_40064000 & 0x3f | 0x80;\n      do {\n      } while ((DAT_40064006 & 0xc) != 8);\n    }\n    bit_clear8(&DAT_40064005,'\\x06');\n    do {\n    } while ((DAT_40064006 & 0x20) != 0);\n  }\n  setFLLFactor(FLLFactor_640);\n  DAT_40064000 = DAT_40064000 & 0x3b | 4;\n  do {\n  } while ((DAT_40064006 & 0x10) == 0);\n  do {\n  } while ((DAT_40064006 & 0xc) != 0);\n  currentMode = KINETIS_MCG_MODE_FEI;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001bb8": "initialize_mcg_00001bb8",
                "kinetis_mcg_set_fll_factor": "setFLLFactor",
                "KINETIS_MCG_FLL_FACTOR_640": "FLLFactor_640",
                "current_mode": "currentMode"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001c84": {
            "entrypoint": "0x00001c84",
            "current_name": "initialize_system_00001c84",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_00001c84(void)\n\n{\n  uint currentInterruptState;\n  uint maskValue;\n  \n  currentInterruptState = irq_disable();\n  kinetis_mcg_set_safe_mode();\n  _DAT_40048044 = 0x220000;\n  DAT_4006400c = 0;\n  DAT_40064000 = DAT_40064000 & 199 | 0x38;\n  DAT_40064004 = 0x13;\n  DAT_40064005 = 0;\n  kinetis_mcg_init_mcgirclk();\n  kinetis_mcg_init_erclk32k();\n  kinetis_mcg_set_mode(KINETIS_MCG_MODE_PEE);\n  irq_restore(currentInterruptState);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001c84": "initialize_system_00001c84",
                "state": "currentInterruptState",
                "mask": "maskValue"
            },
            "calling": [
                "cpu_init"
            ],
            "called": [
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_init_erclk32k",
                "irq_restore",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_set_mode",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001cf0": {
            "entrypoint": "0x00001cf0",
            "current_name": "handle_context_switch_request_00001cf0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_context_switch_request_00001cf0(void)\n\n{\n  if (sched_context_switch_request != 0) {\n    thread_yield_higher();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001cf0": "handle_context_switch_request_00001cf0"
            },
            "calling": [
                "irq_handler"
            ],
            "called": [
                "thread_yield_higher"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d08": {
            "entrypoint": "0x00001d08",
            "current_name": "calculate_pointer_offset_00001d08",
            "code": "\nvoid * calculatePointerOffset_00001d08(void *originalPointer,uintoriginalPointer_t bitValue)\n\n{\n  uintoriginalPointer_t localBitValue;\n  void *localPointer;\n  \n  return (void *)(bitValue * 4 + ((uint)originalPointer & 0xf0000000 | ((uint)originalPointer & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00001d08": "calculate_pointer_offset_00001d08",
                "ptr": "originalPointer",
                "bit": "bitValue",
                "bit_local": "localBitValue",
                "ptr_local": "localPointer"
            },
            "calling": [
                "bit_set32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d3a": {
            "entrypoint": "0x00001d3a",
            "current_name": "set_bit_00001d3a",
            "code": "\nvoid setBit_00001d3a(uint32_t *ptr,uint8_t bit)\n\n{\n  undefined4 *puVar1;\n  uint8_t bit_local;\n  uint32_t *ptr_local;\n  \n  puVar1 = (undefined4 *)bitband_addr(ptr,(uint)bit);\n  *puVar1 = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001d3a": "set_bit_00001d3a"
            },
            "calling": [
                "clk_en"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d5e": {
            "entrypoint": "0x00001d5e",
            "current_name": "get_port_from_pin_00001d5e",
            "code": "\nPORT_Type * getPortFromPin_00001d5e(gpio_t pin)\n\n{\n  gpio_t localPin;\n  \n  return (PORT_Type *)(pin & 0x7000 | 0x40048000);\n}\n\n",
            "renaming": {
                "FUN_00001d5e": "get_port_from_pin_00001d5e",
                "pin_local": "localPin"
            },
            "calling": [
                "gpio_init_port",
                "gpio_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d80": {
            "entrypoint": "0x00001d80",
            "current_name": "initialize_gpio_00001d80",
            "code": "\nGPIO_Type * initializeGPIO_00001d80(gpio_t gpioPin)\n\n{\n  gpio_t localPin;\n  \n  return (GPIO_Type *)(gpioPin & 0x1c0 | 0x400ff000);\n}\n\n",
            "renaming": {
                "FUN_00001d80": "initialize_gpio_00001d80",
                "pin": "gpioPin",
                "pin_local": "localPin"
            },
            "calling": [
                "gpio_set",
                "gpio_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001da2": {
            "entrypoint": "0x00001da2",
            "current_name": "extract_bits_00001da2",
            "code": "\nint extract_bits_00001da2(gpio_t input_pin)\n\n{\n  gpio_t local_pin;\n  \n  return input_pin >> 6 & 7;\n}\n\n",
            "renaming": {
                "FUN_00001da2": "extract_bits_00001da2",
                "pin": "input_pin",
                "pin_local": "local_pin"
            },
            "calling": [
                "gpio_init_port",
                "clk_en"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001dc0": {
            "entrypoint": "0x00001dc0",
            "current_name": "extract_pin_number_00001dc0",
            "code": "\nint extractPinNumber_00001dc0(gpio_t gpioPin)\n\n{\n  gpio_t localPin;\n  \n  return gpioPin & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_00001dc0": "extract_pin_number_00001dc0",
                "pin": "gpioPin",
                "pin_local": "localPin"
            },
            "calling": [
                "gpio_init_port",
                "gpio_set",
                "gpio_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ddc": {
            "entrypoint": "0x00001ddc",
            "current_name": "set_pin_value_00001ddc",
            "code": "\nvoid setPinValue_00001ddc(gpio_t pin)\n\n{\n  int portNumber;\n  gpio_t localPin;\n  \n  portNumber = port_num(pin);\n  bit_set32((uint32_t *)&DAT_40048038,(char)portNumber + '\\t');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ddc": "set_pin_value_00001ddc",
                "iVar1": "portNumber",
                "pin_local": "localPin"
            },
            "calling": [
                "gpio_init_port"
            ],
            "called": [
                "bit_set32",
                "port_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001e0c": {
            "entrypoint": "0x00001e0c",
            "current_name": "get_pin_value_00001e0c",
            "code": "\nint getPinValue_00001e0c(int portNumber,int pinNumber)\n\n{\n  int localPin;\n  int localPort;\n  \n  return isr_map[(pinNumber >> 3) + portNumber * 4] >> ((pinNumber & 7U) << 2) & 0xf;\n}\n\n",
            "renaming": {
                "FUN_00001e0c": "get_pin_value_00001e0c",
                "port": "portNumber",
                "pin": "pinNumber",
                "pin_local": "localPin",
                "port_local": "localPort"
            },
            "calling": [
                "ctx_clear",
                "irq_handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001e44": {
            "entrypoint": "0x00001e44",
            "current_name": "update_interrupt_handler_00001e44",
            "code": "\nvoid updateInterruptHandler_00001e44(int portNumber,int pinNumber,int context)\n\n{\n  int shiftedPin;\n  int localContext;\n  int localPin;\n  int localPort;\n  \n  shiftedPin = pinNumber >> 3;\n  isr_map[shiftedPin + portNumber * 4] = isr_map[shiftedPin + portNumber * 4] & ~(0xf << ((pinNumber & 7U) << 2));\n  isr_map[shiftedPin + portNumber * 4] = isr_map[shiftedPin + portNumber * 4] | context << ((pinNumber & 7U) << 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001e44": "update_interrupt_handler_00001e44",
                "port": "portNumber",
                "pin": "pinNumber",
                "ctx": "context",
                "iVar1": "shiftedPin",
                "ctx_local": "localContext",
                "pin_local": "localPin",
                "port_local": "localPort"
            },
            "calling": [
                "ctx_clear"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ec4": {
            "entrypoint": "0x00001ec4",
            "current_name": "write_ctx_to_map_00001ec4",
            "code": "\nvoid write_ctx_to_map_00001ec4(int input_port,int input_pin)\n\n{\n  int context;\n  int local_pin;\n  int local_port;\n  int temporary_context;\n  \n  context = get_temporary_context(input_port,input_pin);\n  write_map(input_port,input_pin,context);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ec4": "write_ctx_to_map_00001ec4",
                "port": "input_port",
                "pin": "input_pin",
                "ctx_00": "context",
                "pin_local": "local_pin",
                "port_local": "local_port",
                "ctx": "temporary_context"
            },
            "calling": [
                "gpio_init_port"
            ],
            "called": [
                "get_ctx",
                "write_map"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001eea": {
            "entrypoint": "0x00001eea",
            "current_name": "configure_gpio_00001eea",
            "code": "\nint configureGPIO_00001eea(gpio_t gpioPin,gpio_gpioMode_t gpioMode)\n\n{\n  uint pinNumber;\n  GPIO_Type *gpioPointer;\n  PORT_Type *portPointer;\n  int pinNumberLocal;\n  gpio_gpioMode_t localGpioMode;\n  gpio_t localGpioPin;\n  \n  gpio_init_port(gpioPin,0);\n  if ((char)gpioMode < '\\0') {\n    pinNumber = gpioPin_num(gpioPin);\n    gpioPointer = gpio(gpioPin);\n    gpioPointer->PDDR = gpioPointer->PDDR | 1 << (pinNumber & 0xff);\n  }\n  else {\n    pinNumber = gpioPin_num(gpioPin);\n    gpioPointer = gpio(gpioPin);\n    gpioPointer->PDDR = gpioPointer->PDDR & ~(1 << (pinNumber & 0xff));\n  }\n  portPointer = port(gpioPin);\n  pinNumberLocal = gpioPin_num(gpioPin);\n  portPointer->PCR[pinNumberLocal] = gpioMode & 0x23 | 0x100;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00001eea": "configure_gpio_00001eea",
                "pin": "gpioPin",
                "mode": "gpioMode",
                "uVar1": "pinNumber",
                "pGVar2": "gpioPointer",
                "pPVar3": "portPointer",
                "iVar4": "pinNumberLocal",
                "mode_local": "localGpioMode",
                "pin_local": "localGpioPin"
            },
            "calling": [
                "board_init"
            ],
            "called": [
                "gpio_init_port",
                "gpio",
                "port",
                "pin_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001f80": {
            "entrypoint": "0x00001f80",
            "current_name": "configure_pin_00001f80",
            "code": "\nvoid configurePin_00001f80(gpio_t gpioPin,uint32_t pinConfiguration)\n\n{\n  PORT_Type *portPointer;\n  int pinIndex;\n  int pinIndex;\n  uint previousPcr;\n  uint32_t localPinConfiguration;\n  gpio_t localGpioPin;\n  uint32_t interruptState;\n  \n  clk_en(gpioPin);\n  portPointer = port(gpioPin);\n  pinIndex = gpioPin_num(gpioPin);\n  previousPcr = portPointer->PCR[pinIndex];\n  portPointer = port(gpioPin);\n  pinIndex = gpioPin_num(gpioPin);\n  portPointer->PCR[pinIndex] = pinConfiguration;\n  if ((previousPcr & 0xf0000) != 0) {\n    pinIndex = port_num(gpioPin);\n    pinIndex = gpioPin_num(gpioPin);\n    ctx_clear(pinIndex,pinIndex);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001f80": "configure_pin_00001f80",
                "pin": "gpioPin",
                "pcr": "pinConfiguration",
                "pPVar1": "portPointer",
                "iVar2": "pinIndex",
                "pin_00": "pinIndex",
                "uVar3": "previousPcr",
                "pcr_local": "localPinConfiguration",
                "pin_local": "localGpioPin",
                "isr_state": "interruptState"
            },
            "calling": [
                "uart_init_pins",
                "gpio_init"
            ],
            "called": [
                "port",
                "pin_num",
                "ctx_clear",
                "clk_en",
                "port_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ff6": {
            "entrypoint": "0x00001ff6",
            "current_name": "set_pin_high_00001ff6",
            "code": "\nvoid setPinHigh_00001ff6(gpio_t pin)\n\n{\n  uint pinNumber;\n  GPIO_Type *gpioPtr;\n  gpio_t localPin;\n  \n  pinNumber = pin_num(pin);\n  gpioPtr = gpio(pin);\n  gpioPtr->PSOR = 1 << (pinNumber & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ff6": "set_pin_high_00001ff6",
                "uVar1": "pinNumber",
                "pGVar2": "gpioPtr",
                "pin_local": "localPin"
            },
            "calling": [
                "board_init"
            ],
            "called": [
                "gpio",
                "pin_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002028": {
            "entrypoint": "0x00002028",
            "current_name": "process_port_interrupts_00002028",
            "code": "\nvocounterd processPortInterrupts_00002028(PORT_Type *portStruct,counternt portNumber)\n\n{\n  counternt index;\n  ucounternt isfr;\n  counternt localPortNumber;\n  PORT_Type *localPortStruct;\n  counternt context;\n  ucounternt32_t portStatus;\n  counternt counter;\n  \n  isfr = portStruct->ISFR;\n  for (counter = 0; counter < 0x20; counter = counter + 1) {\n    counterf (((isfr & 1 << (counter & 0xffU)) != 0) && ((portStruct->PCR[counter] & 0xf0000) != 0)) {\n      portStruct->ISFR = 1 << (counter & 0xffU);\n      index = get_context(portNumber,counter);\n      (*countersr_context[index].cb)(countersr_context[index].arg);\n    }\n  }\n  cortexm_countersr_end();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002028": "process_port_interrupts_00002028",
                "port": "portStruct",
                "port_num": "portNumber",
                "iVar1": "index",
                "uVar2": "isfr",
                "port_num_local": "localPortNumber",
                "port_local": "localPortStruct",
                "ctx": "context",
                "status": "portStatus",
                "i": "counter"
            },
            "calling": [
                "isr_portc",
                "isr_portd",
                "isr_porte",
                "isr_portb",
                "isr_porta"
            ],
            "called": [
                "get_ctx",
                "cortexm_isr_end"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020b8": {
            "entrypoint": "0x000020b8",
            "current_name": "initialize_irq_handler_000020b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_IRQ_handler_000020b8(void)\n\n{\n  irq_handler((port *)0x40049000,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020b8": "initialize_irq_handler_000020b8",
                "PORT_Type": "port"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020cc": {
            "entrypoint": "0x000020cc",
            "current_name": "initialize_irq_handler_000020cc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIRQHandler_000020cc(void)\n\n{\n  irq_handler((PORT_Type *)0x4004a000,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020cc": "initialize_irq_handler_000020cc"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020e0": {
            "entrypoint": "0x000020e0",
            "current_name": "initialize_interrupt_000020e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeInterrupt_000020e0(void)\n\n{\n  handleInterrupt((PORT_Type *)0x4004b000,2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020e0": "initialize_interrupt_000020e0",
                "irq_handler": "handleInterrupt"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020f4": {
            "entrypoint": "0x000020f4",
            "current_name": "initialize_irq_handler_000020f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIRQHandler_000020f4(void)\n\n{\n  irq_handler((port *)0x4004c000,3);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020f4": "initialize_irq_handler_000020f4",
                "PORT_Type": "port"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002108": {
            "entrypoint": "0x00002108",
            "current_name": "initialize_hardware_interrupt_00002108",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeHardwareInterrupt_00002108(void)\n\n{\n  irq_handler((PORT_Type *)0x4004d000,4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002108": "initialize_hardware_interrupt_00002108"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000211c": {
            "entrypoint": "0x0000211c",
            "current_name": "print_thread_information_0000211c",
            "code": "\n/* WARNING: Unknown callthreadIndexng conventthreadIndexon */\n\nvothreadIndexd printThreadInformation_0000211c(vothreadIndexd)\n\n{\n  byte status;\n  threadIndexnt stackSize;\n  vothreadIndexd *currentThreadvVar3;\n  vothreadIndexd *currentThreadvVar4;\n  uthreadIndexntcurrentThreadtr_t stackFreeSpace;\n  thread_t *currentThread;\n  char *currentState;\n  char queuedName [2];\n  threadIndexnt stackSize;\n  char *queued;\n  char *stateName;\n  threadIndexnt state;\n  thread_t *currentThread;\n  vothreadIndexd *isrStackPointer;\n  vothreadIndexd *isrStackStart;\n  threadIndexnt isrStackUsage;\n  kernel_currentThreadthreadIndexd_t threadIndex;\n  threadIndexnt totalUsedStackSize;\n  threadIndexnt totalStackSizes;\n  \n  queuedName[0] = '_';\n  queuedName[1] = 'Q';\n  totalUsedStackSize = 0;\n  threadIndexcurrentThreadrthreadIndexntf(\"\\tcurrentThreadthreadIndexd | %-21s| %-9sQ | currentThreadrthreadIndex | stack  ( used) | base addr  | current     \\n\",&DAT_000070b8,\n          \"state\");\n  stackSize = thread_threadIndexsr_stack_usage();\n  currentThreadvVar3 = thread_threadIndexsr_stack_start();\n  currentThreadvVar4 = thread_threadIndexsr_stack_currentThreadothreadIndexnter();\n  threadIndexcurrentThreadrthreadIndexntf(\"\\t  - | threadIndexsr_stack            | -        - |   - | %6threadIndex (%5threadIndex) | %10currentThread | %10currentThread\\n\",0x200,stackSize,\n          currentThreadvVar3,currentThreadvVar4);\n  totalStackSizes = 0x200;\n  threadIndexf (0 < stackSize) {\n    totalUsedStackSize = stackSize;\n  }\n  for (threadIndex = 1; threadIndex < 0x21; threadIndex = threadIndex + 1) {\n    currentThread = sched_threads[threadIndex];\n    threadIndexf (currentThread != (thread_t *)0x0) {\n      status = currentThread->status;\n      currentState = state_names[status];\n      stackSize = currentThread->stack_sthreadIndexze;\n      totalStackSizes = stackSize + totalStackSizes;\n      stackFreeSpace = thread_measure_stack_free(currentThread->stack_start);\n      stackSize = stackSize - stackFreeSpace;\n      totalUsedStackSize = stackSize + totalUsedStackSize;\n      threadIndexcurrentThreadrthreadIndexntf(\"\\t%3hthreadIndex | %-20s | %-8s %.1s | %3threadIndex | %6threadIndex (%5threadIndex) | %10currentThread | %10currentThread \\n\",(threadIndexnt)currentThread->currentThreadthreadIndexd,\n              currentThread->name,currentState,queuedName + (8 < status),(uthreadIndexnt)currentThread->currentThreadrthreadIndexorthreadIndexty,\n              currentThread->stack_sthreadIndexze,stackSize,currentThread->stack_start,currentThread->scurrentThread);\n    }\n  }\n  threadIndexcurrentThreadrthreadIndexntf(\"\\t%5s %-21s|%13s%6s %6threadIndex (%5threadIndex)\\n\",&DAT_00007190,&DAT_00007194,&DAT_00007190,&DAT_00007190,\n          totalStackSizes,totalUsedStackSize);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000211c": "print_thread_information_0000211c",
                "queued_name": "queuedName",
                "stacksz": "stackSize",
                "sname": "stateName",
                "p": "currentThread",
                "isr_sp": "isrStackPointer",
                "isr_start": "isrStackStart",
                "isr_usage": "isrStackUsage",
                "i": "threadIndex",
                "overall_used": "totalUsedStackSize",
                "overall_stacksz": "totalStackSizes",
                "bVar1": "status",
                "iVar2": "stackSize",
                "ptVar6": "currentThread",
                "pcVar7": "currentState",
                "uVar5": "stackFreeSpace"
            },
            "calling": [
                "core_panic",
                "_ps_handler"
            ],
            "called": [
                "thread_isr_stack_start",
                "thread_isr_stack_usage",
                "iprintf",
                "thread_isr_stack_pointer",
                "thread_measure_stack_free"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002270": {
            "entrypoint": "0x00002270",
            "current_name": "check_write_count_00002270",
            "code": "\nint checkWriteCount_00002270(tsringBuffer_t *ringBuffer)\n\n{\n  byte isWriteSuccessful;\n  uint writeCount;\n  bool readsEqualsWrites;\n  tsringBuffer_t *localRingBuffer;\n  \n  writeCount = ringBuffer->writes;\n  readsEqualsWrites = ringBuffer->reads == writeCount;\n  if (readsEqualsWrites) {\n    writeCount = 1;\n  }\n  isWriteSuccessful = (byte)writeCount;\n  if (!readsEqualsWrites) {\n    isWriteSuccessful = 0;\n  }\n  return (uint)isWriteSuccessful;\n}\n\n",
            "renaming": {
                "FUN_00002270": "check_write_count_00002270",
                "rb": "ringBuffer",
                "uVar2": "writeCount",
                "bVar3": "readsEqualsWrites",
                "rb_local": "localRingBuffer",
                "bVar1": "isWriteSuccessful"
            },
            "calling": [
                "tsrb_get"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002294": {
            "entrypoint": "0x00002294",
            "current_name": "check_fullness_00002294",
            "code": "\nint checkFullness_00002294(tsringBuffer_t *ringBuffer)\n\n{\n  byte isFull;\n  uint ringBufferSize;\n  bool isBufferFull;\n  tsringBuffer_t *localRingBuffer;\n  \n  ringBufferSize = ringBuffer->size;\n  isBufferFull = ringBuffer->writes - ringBuffer->reads == ringBufferSize;\n  if (isBufferFull) {\n    ringBufferSize = 1;\n  }\n  isFull = (byte)ringBufferSize;\n  if (!isBufferFull) {\n    isFull = 0;\n  }\n  return (uint)isFull;\n}\n\n",
            "renaming": {
                "FUN_00002294": "check_fullness_00002294",
                "rb": "ringBuffer",
                "bVar1": "isFull",
                "uVar2": "ringBufferSize",
                "bVar3": "isBufferFull",
                "rb_local": "localRingBuffer"
            },
            "calling": [
                "tsrb_add_one"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000022be": {
            "entrypoint": "0x000022be",
            "current_name": "append_char_to_circular_buffer_000022be",
            "code": "\nvoid appendCharToCircularBuffer_000022be(tsringBuffer_t *ringBuffer,char c)\n\n{\n  uint writeIndex;\n  char localCharacter;\n  tsringBuffer_t *localRingBuffer;\n  \n  writeIndex = ringBuffer->writes;\n  ringBuffer->writes = writeIndex + 1;\n  ringBuffer->buf[writeIndex & ringBuffer->size - 1] = c;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000022be": "append_char_to_circular_buffer_000022be",
                "rb": "ringBuffer",
                "uVar1": "writeIndex",
                "c_local": "localCharacter",
                "rb_local": "localRingBuffer"
            },
            "calling": [
                "tsrb_add_one"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000022f0": {
            "entrypoint": "0x000022f0",
            "current_name": "read_next_char_000022f0",
            "code": "\nchar readNextChar_000022f0(tsringBuffer_t *ringBuffer)\n\n{\n  uint reads;\n  tsringBuffer_t *localBuffer;\n  \n  reads = ringBuffer->reads;\n  ringBuffer->reads = reads + 1;\n  return ringBuffer->buf[reads & ringBuffer->size - 1];\n}\n\n",
            "renaming": {
                "FUN_000022f0": "read_next_char_000022f0",
                "rb": "ringBuffer",
                "uVar1": "reads",
                "rb_local": "localBuffer"
            },
            "calling": [
                "tsrb_get"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000231c": {
            "entrypoint": "0x0000231c",
            "current_name": "copy_from_rb_0000231c",
            "code": "\nilengtht copy_from_rb_0000231c(tsring_buffer_t *ring_buffer,char *destination,size_t length)\n\n{\n  char popped_element;\n  ilengtht is_empty;\n  size_t remaining_length;\n  char *current_destination;\n  tsring_buffer_t *local_ring_buffer;\n  size_t remaining_elements;\n  \n  current_destination = destination;\n  remaining_elements = length;\n  while ((remaining_elements != 0 && (is_empty = tsring_buffer_empty(ring_buffer), is_empty == 0))) {\n    popped_element = _pop(ring_buffer);\n    *current_destination = popped_element;\n    remaining_elements = remaining_elements - 1;\n    current_destination = current_destination + 1;\n  }\n  returlength length - remaining_elements;\n}\n\n",
            "renaming": {
                "FUN_0000231c": "copy_from_rb_0000231c",
                "rb": "ring_buffer",
                "dst": "destination",
                "n": "length",
                "cVar1": "popped_element",
                "iVar2": "is_empty",
                "n_local": "remaining_length",
                "dst_local": "current_destination",
                "rb_local": "local_ring_buffer",
                "tmp": "remaining_elements"
            },
            "calling": [
                "isrpipe_read"
            ],
            "called": [
                "tsrb_empty",
                "_pop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002364": {
            "entrypoint": "0x00002364",
            "current_name": "write_to_ring_buffer_00002364",
            "code": "\nint write_to_ring_buffer_00002364(tsring_buffer_t *ring_buffer,char c)\n\n{\n  int is_full;\n  char local_character;\n  tsring_buffer_t *local_ring_buffer;\n  \n  is_full = tsring_buffer_full(ring_buffer);\n  if (is_full == 0) {\n    _push(ring_buffer,c);\n    is_full = 0;\n  }\n  else {\n    is_full = -1;\n  }\n  return is_full;\n}\n\n",
            "renaming": {
                "FUN_00002364": "write_to_ring_buffer_00002364",
                "rb": "ring_buffer",
                "c_local": "local_character",
                "rb_local": "local_ring_buffer",
                "iVar1": "is_full"
            },
            "calling": [
                "isrpipe_write_one"
            ],
            "called": [
                "_push",
                "tsrb_full"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002396": {
            "entrypoint": "0x00002396",
            "current_name": "initialize_real_time_clock_00002396",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_real_time_clock_00002396(void)\n\n{\n  rtc_init();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002396": "initialize_real_time_clock_00002396"
            },
            "calling": [
                "cpu_init"
            ],
            "called": [
                "rtc_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000023a4": {
            "entrypoint": "0x000023a4",
            "current_name": "run_shell_command_000023a4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint runShellCommand_000023a4(void)\n\n{\n  char commandBuffer [128];\n  \n  startForkserver(0);\n  puts(\"Welcome to RIOT!\");\n                    \n  shell_run((shell_command_t *)0x0,commandBuffer,0x80);\n}\n\n",
            "renaming": {
                "FUN_000023a4": "run_shell_command_000023a4",
                "line_buf": "commandBuffer"
            },
            "calling": [
                "main_trampoline"
            ],
            "called": [
                "startForkserver",
                "puts",
                "shell_run"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000023c8": {
            "entrypoint": "0x000023c8",
            "current_name": "invoke_software_interrupt_000023c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t invoke_software_interrupt_000023c8(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_000023c8": "invoke_software_interrupt_000023c8"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000023d0": {
            "entrypoint": "0x000023d0",
            "current_name": "perform_afl_call_000023d0",
            "code": "\nint performAflCall_000023d0(int ticks)\n\n{\n  uint32_t aflReturnValue;\n  int localTicks;\n  \n  if (noHyperCall == 0) {\n    aflReturnValue = aflCall(1,ticks,0);\n  }\n  else {\n    aflReturnValue = 0;\n  }\n  return aflReturnValue;\n}\n\n",
            "renaming": {
                "FUN_000023d0": "perform_afl_call_000023d0",
                "uVar1": "aflReturnValue",
                "ticks_local": "localTicks"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002400": {
            "entrypoint": "0x00002400",
            "current_name": "FUNC_00002400",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00002400(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002400": "FUNC_00002400"
            },
            "calling": [
                "main_trampoline"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0000240c": {
            "entrypoint": "0x0000240c",
            "current_name": "remove_next_list_node_0000240c",
            "code": "\nlistHead_node_t * removeNextListNode_0000240c(listHead_node_t *listHead)\n\n{\n  listHead_node *nextNode;\n  listHead_node_t *currentNode;\n  listHead_node_t *listStart;\n  \n  nextNode = listHead->next;\n  if (nextNode != (listHead_node *)0x0) {\n    listHead->next = nextNode->next;\n  }\n  return nextNode;\n}\n\n",
            "renaming": {
                "FUN_0000240c": "remove_next_list_node_0000240c",
                "list": "listHead",
                "plVar1": "nextNode",
                "list_local": "currentNode",
                "head": "listStart"
            },
            "calling": [
                "mutex_unlock"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002434": {
            "entrypoint": "0x00002434",
            "current_name": "acquire_mutex_00002434",
            "code": "\nint acquireMutex_00002434(mutex_t *mutex,int isBlocking)\n\n{\n  currentThread_t *currentThread;\n  uint irqDisabledState;\n  int returnValue;\n  int localIsBlocking;\n  mutex_t *localMutex;\n  uint irqState;\n  currentThread_t *currentThread;\n  \n  irqDisabledState = irq_disable();\n  currentThread = activeThread;\n  if ((mutex->queue).next == (list_node *)0x0) {\n    (mutex->queue).next = (list_node *)0xffffffff;\n    irq_restore(irqDisabledState);\n    returnValue = 1;\n  }\n  else if (isBlocking == 0) {\n    irq_restore(irqDisabledState);\n    returnValue = 0;\n  }\n  else {\n    setThreadStatus(activeThread,2);\n    if ((mutex->queue).next == (list_node *)0xffffffff) {\n      (mutex->queue).next = &currentThread->rq_entry;\n      ((mutex->queue).next)->next = (list_node *)0x0;\n    }\n    else {\n      currentThread_add_to_list(&mutex->queue,currentThread);\n    }\n    irq_restore(irqDisabledState);\n    currentThread_yield_higher();\n    returnValue = 1;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00002434": "acquire_mutex_00002434",
                "blocking": "isBlocking",
                "thread": "currentThread",
                "state": "irqDisabledState",
                "iVar1": "returnValue",
                "blocking_local": "localIsBlocking",
                "mutex_local": "localMutex",
                "irqstate": "irqState",
                "me": "currentThread",
                "sched_active_thread": "activeThread",
                "sched_set_status": "setThreadStatus"
            },
            "calling": [
                "mutex_lock"
            ],
            "called": [
                "irq_restore",
                "sched_set_status",
                "thread_yield_higher",
                "thread_add_to_list",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000024bc": {
            "entrypoint": "0x000024bc",
            "current_name": "queue_mutex_000024bc",
            "code": "\nvoid queueMutex_000024bc(mutex_t *mutex)\n\n{\n  byte byteValue;\n  uint irqState;\n  list_node_t *removedNode;\n  mutex_t *localMutex;\n  uint16_t priority;\n  uint irqState;\n  clist_node_t *clistNode;\n  list_node_t *nextNode;\n  thread_t *currentThread;\n  \n  irqState = irq_disable();\n  if ((mutex->queue).nextNode == (list_node *)0x0) {\n    irq_restore(irqState);\n  }\n  else if ((mutex->queue).nextNode == (list_node *)0xffffffff) {\n    (mutex->queue).nextNode = (list_node *)0x0;\n    irq_restore(irqState);\n  }\n  else {\n    removedNode = list_remove_head(&mutex->queue);\n    sched_set_status((thread_t *)(removedNode + -2),10);\n    if ((mutex->queue).nextNode == (list_node *)0x0) {\n      (mutex->queue).nextNode = (list_node *)0xffffffff;\n    }\n    byteValue = *(byte *)((int)&removedNode[-1].nextNode + 1);\n    irq_restore(irqState);\n    sched_switch((ushort)byteValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000024bc": "queue_mutex_000024bc",
                "state": "irqState",
                "bVar1": "byteValue",
                "plVar2": "removedNode",
                "mutex_local": "localMutex",
                "process_priority": "priority",
                "irqstate": "irqState",
                "__m____": "clistNode",
                "next": "nextNode",
                "process": "currentThread"
            },
            "calling": [
                "isrpipe_write_one"
            ],
            "called": [
                "irq_restore",
                "sched_set_status",
                "sched_switch",
                "list_remove_head",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002538": {
            "entrypoint": "0x00002538",
            "current_name": "set_interrupt_priority_00002538",
            "code": "\nvoid setInterruptPriority_00002538(interruptNumber_Type interruptNumber,uint32_t newPriority)\n\n{\n  uint32_t localPriority;\n  interruptNumber_Type localInterruptNumber;\n  \n  if (interruptNumber < DMA0_interruptNumber) {\n    (&DAT_e000ed14)[(byte)interruptNumber & 0xf] = (char)((newPriority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interruptNumber + -0x1fff1c00) = (char)((newPriority & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002538": "set_interrupt_priority_00002538",
                "IRQn": "interruptNumber",
                "priority": "newPriority",
                "priority_local": "localPriority",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "cortexm_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000258c": {
            "entrypoint": "0x0000258c",
            "current_name": "initialize_interrupts_0000258c",
            "code": "\n\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd initializeInterrupts_0000258c(voindexd)\n\n{\n  uindexnt index;\n  \n  _DAT_e000ed08 = 0;\n  NVIC_SetPrindexorindexty(PendSV_Interrupt,1);\n  NVIC_SetPrindexorindexty(SVCall_Interrupt,1);\n  for (index = 0; index < 0x66; index = index + 1) {\n    NVIC_SetPrindexorindexty((InterruptType)index,1);\n  }\n  _DAT_e000ed10 = _DAT_e000ed10 | 0x10;\n  _DAT_e000ed14 = _DAT_e000ed14 | 0x200;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000258c": "initialize_interrupts_0000258c",
                "i": "index",
                "PendSV_IRQn": "PendSV_Interrupt",
                "SVCall_IRQn": "SVCall_Interrupt",
                "IRQn_Type": "InterruptType"
            },
            "calling": [
                "cpu_init"
            ],
            "called": [
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000025f4": {
            "entrypoint": "0x000025f4",
            "current_name": "initialize_rtt_000025f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_rtt_000025f4(void)\n\n{\n  initialize_real_time_trace();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000025f4": "initialize_rtt_000025f4",
                "rtt_init": "initialize_real_time_trace"
            },
            "calling": [
                "periph_init"
            ],
            "called": [
                "rtt_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002600": {
            "entrypoint": "0x00002600",
            "current_name": "set_local_time_counter_00002600",
            "code": "\ninconvertedTime setLocalTimeCounter_00002600(convertedTimem *inputTime)\n\n{\n  uinconvertedTime32_convertedTime timeCounter;\n  convertedTimem *localTime;\n  inputTime_convertedTime convertedTime;\n  \n  timeCounter = mkinputTime((convertedTimem *)inputTime);\n  rconvertedTimeconvertedTime_seconvertedTime_timeCounter(timeCounter);\n  reconvertedTimeurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002600": "set_local_time_counter_00002600",
                "time": "inputTime",
                "counter": "timeCounter",
                "time_local": "localTime",
                "t": "convertedTime"
            },
            "calling": [
                "_rtc_settime"
            ],
            "called": [
                "mktime",
                "rtt_set_counter"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002624": {
            "entrypoint": "0x00002624",
            "current_name": "initialize_local_time_00002624",
            "code": "\nincurrentTime initializeLocalTime_00002624(currentTimem *timeInfo)\n\n{\n  currentTimem *localTime;\n  timeInfo_currentTime currentTime;\n  \n  currentTime._0_4_ = rcurrentTimecurrentTime_gecurrentTime_councurrentTimeer();\n  currentTime._4_4_ = 0;\n  gmtimeInfo_r((timeInfo_currentTime *)&currentTime,(currentTimem *)timeInfo);\n  recurrentTimeurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002624": "initialize_local_time_00002624",
                "time": "timeInfo",
                "time_local": "localTime",
                "t": "currentTime"
            },
            "calling": [
                "_rtc_gettime"
            ],
            "called": [
                "rtt_get_counter",
                "gmtime_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002654": {
            "entrypoint": "0x00002654",
            "current_name": "set_alarm_00002654",
            "code": "\nintimestamp setAlarm_00002654(timestampm *timeObj,rtimestampc_alarmTime_cb_timestamp cb,void *callbackArg)\n\n{\n  uintimestamp32_timestamp alarmTime;\n  void *localArg;\n  rtimestampc_alarmTime_cb_timestamp localCallbackFunc;\n  timestampm *localTimeObj;\n  timeObj_timestamp timestamp;\n  \n  alarmTime = mktimeObj((timestampm *)timeObj);\n  rtimestampc_callback.cb = cb;\n  rtimestamptimestamp_setimestamp_alarmTime(alarmTime,rtimestampc_cb + 1,callbackArg);\n  retimestampurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002654": "set_alarm_00002654",
                "time": "timeObj",
                "arg": "callbackArg",
                "alarm": "alarmTime",
                "arg_local": "localArg",
                "cb_local": "localCallbackFunc",
                "time_local": "localTimeObj",
                "t": "timestamp"
            },
            "calling": [
                "_rtc_setalarm"
            ],
            "called": [
                "mktime",
                "rtt_set_alarm"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002690": {
            "entrypoint": "0x00002690",
            "current_name": "convert_to_time_struct_00002690",
            "code": "\ninalarmTime convertToTimeStruct_00002690(alarmTimem *inputTime)\n\n{\n  alarmTimem *convertedTime;\n  inputTime_alarmTime alarmTime;\n  \n  alarmTime._0_4_ = ralarmTimealarmTime_gealarmTime_alarm();\n  alarmTime._4_4_ = 0;\n  gminputTime_r((inputTime_alarmTime *)&alarmTime,(alarmTimem *)inputTime);\n  realarmTimeurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002690": "convert_to_time_struct_00002690",
                "time": "inputTime",
                "time_local": "convertedTime",
                "t": "alarmTime"
            },
            "calling": [
                "_rtc_getalarm"
            ],
            "called": [
                "rtt_get_alarm",
                "gmtime_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026c0": {
            "entrypoint": "0x000026c0",
            "current_name": "clear_rtt_alarm_000026c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearRttAlarm_000026c0(void)\n\n{\n  clearRttAlarm_000026c0();\n  callbackFunction.cb = (RTCAlarmCallbackType)0x0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026c0": "clear_rtt_alarm_000026c0",
                "rtc_callback": "callbackFunction",
                "rtt_clear_alarm": "clearRttAlarm",
                "rtc_alarm_cb_t": "RTCAlarmCallbackType"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtt_clear_alarm"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026d8": {
            "entrypoint": "0x000026d8",
            "current_name": "initialize_real_time_timer_000026d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeRealTimeTimer_000026d8(void)\n\n{\n  powerOnRealTimeTimer();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026d8": "initialize_real_time_timer_000026d8",
                "rtt_poweron": "powerOnRealTimeTimer"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtt_poweron"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026e4": {
            "entrypoint": "0x000026e4",
            "current_name": "power_off_000026e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid power_off_000026e4(void)\n\n{\n  power_off_000026e4();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026e4": "power_off_000026e4",
                "rtt_poweroff": "power_off"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtt_poweroff"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026f0": {
            "entrypoint": "0x000026f0",
            "current_name": "execute_alarm_callback_000026f0",
            "code": "\nvoid executeAlarmCallback_000026f0(void *data)\n\n{\n  void *localData;\n  \n  if (rtcCallback.cb != (rtc_alarm_cb_t)0x0) {\n    (*rtcCallback.cb)(data);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026f0": "execute_alarm_callback_000026f0",
                "arg": "data",
                "arg_local": "localData",
                "rtc_callback": "rtcCallback"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002714": {
            "entrypoint": "0x00002714",
            "current_name": "set_interrupt_enabled_00002714",
            "code": "\nvoid setInterruptEnabled_00002714(interruptNumber_Type interruptNumber)\n\n{\n  interruptNumber_Type localInterruptNumber;\n  \n  *(int *)(((uint)(int)interruptNumber >> 5) * 4 + -0x1fff1f00) = 1 << (interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002714": "set_interrupt_enabled_00002714",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "rtt_set_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002744": {
            "entrypoint": "0x00002744",
            "current_name": "set_interrupt_priority_00002744",
            "code": "\nvoid setInterruptPriority_00002744(interruptNumber_Type interruptNumber,uint32_t newPriority)\n\n{\n  uint32_t localPriority;\n  interruptNumber_Type localInterruptNumber;\n  \n  if (interruptNumber < DMA0_interruptNumber) {\n    (&DAT_e000ed14)[(byte)interruptNumber & 0xf] = (char)((newPriority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interruptNumber + -0x1fff1c00) = (char)((newPriority & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002744": "set_interrupt_priority_00002744",
                "IRQn": "interruptNumber",
                "priority": "newPriority",
                "priority_local": "localPriority",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "rtt_set_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002798": {
            "entrypoint": "0x00002798",
            "current_name": "check_and_yield_higher_priority_thread_00002798",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid check_and_yield_higher_priority_thread_00002798(void)\n\n{\n  if (sched_context_switch_request != 0) {\n    thread_yield_higher();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002798": "check_and_yield_higher_priority_thread_00002798"
            },
            "calling": [
                "isr_rtc"
            ],
            "called": [
                "thread_yield_higher"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000027b0": {
            "entrypoint": "0x000027b0",
            "current_name": "initialize_rtc_000027b0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeRTC_000027b0(void)\n\n{\n  RTC_Type *rtc;\n  \n  _DAT_4004803c = _DAT_4004803c | 0x20000000;\n  if ((_DAT_4003d014 & 1) != 0) {\n    _DAT_4003d000 = 0;\n  }\n  _DAT_4003d010 = 0x104;\n  _DAT_4003d008 = 0xffffff42;\n  _DAT_4003d01c = 0;\n  rtc_poweron();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000027b0": "initialize_rtc_000027b0",
                "rtt": "rtc"
            },
            "calling": [
                "rtc_init"
            ],
            "called": [
                "rtt_poweron"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000281c": {
            "entrypoint": "0x0000281c",
            "current_name": "get_rtc_value_0000281c",
            "code": "\n/* WARNING: Removindexng unreachable block (ram,0x00002840) */\n/* WARNING: Removindexng unreachable block (ram,0x0000284c) */\n\n/* WARNING: Unknown callindexng conventimeindexon */\n\nuindexntime32_time get_rtc_value_0000281c(voindexd)\n\n{\n  RTC_Type *rtc;\n  indexntime index;\n  uindexntime32_time time;\n  \n  retimeurn _DAT_4003d000;\n}\n\n",
            "renaming": {
                "FUN_0000281c": "get_rtc_value_0000281c",
                "rtt": "rtc",
                "i": "index",
                "t": "time"
            },
            "calling": [
                "rtc_get_time"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000285c": {
            "entrypoint": "0x0000285c",
            "current_name": "set_counter_0000285c",
            "code": "\n\n\nvoid setCounter_0000285c(uint32_t newCounter)\n\n{\n  uint32_t localCounter;\n  RTC_Type *realTimeClock;\n  \n  _DAT_4003d000 = newCounter;\n  _DAT_4003d014 = _DAT_4003d014 & 0xffffffef | 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000285c": "set_counter_0000285c",
                "counter": "newCounter",
                "counter_local": "localCounter",
                "rtt": "realTimeClock"
            },
            "calling": [
                "rtc_set_time"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002894": {
            "entrypoint": "0x00002894",
            "current_name": "initialize_rtt_alarm_00002894",
            "code": "\n\n\nvoid initializeRttAlarm_00002894(uint32_t initialValue,rttModule_cb_t cb,void *argument)\n\n{\n  void *localArgument;\n  rttModule_cb_t localCallbackFunction;\n  uint32_t localInitialValue;\n  RTC_Type *rttModule;\n  \n  _DAT_4003d008 = initialValue - 1;\n  _DAT_4003d01c = _DAT_4003d01c & 0xfffffffb | 4;\n  rttModule_callback.initialValue_cb = cb;\n  rttModule_callback.initialValue_argument = argument;\n  NVIC_SetPriority(RTC_IRQn,10);\n  NVIC_EnableIRQ(RTC_IRQn);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002894": "initialize_rtt_alarm_00002894",
                "alarm": "initialValue",
                "arg": "argument",
                "arg_local": "localArgument",
                "cb_local": "localCallbackFunction",
                "alarm_local": "localInitialValue",
                "rtt": "rttModule"
            },
            "calling": [
                "rtc_set_alarm"
            ],
            "called": [
                "NVIC_EnableIRQ",
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000028f0": {
            "entrypoint": "0x000028f0",
            "current_name": "get_updated_rtc_000028f0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_updated_RTC_000028f0(void)\n\n{\n  RTC_Type *rtc_pointer;\n  \n  return _DAT_4003d008 + 1;\n}\n\n",
            "renaming": {
                "FUN_000028f0": "get_updated_rtc_000028f0",
                "rtt": "rtc_pointer"
            },
            "calling": [
                "rtc_get_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002910": {
            "entrypoint": "0x00002910",
            "current_name": "initialize_rtc_00002910",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeRTC_00002910(void)\n\n{\n  RTC_Type *rtc;\n  \n  _DAT_4003d01c = _DAT_4003d01c & 0xfffffffb;\n  _DAT_4003d008 = 0;\n  alarmCallback = (rtc_cb_t)0x0;\n  alarmArgument = (void *)0x0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002910": "initialize_rtc_00002910",
                "rtt": "rtc",
                "rtt_callback.alarm_cb": "alarmCallback",
                "rtt_callback.alarm_arg": "alarmArgument"
            },
            "calling": [
                "rtc_clear_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000294c": {
            "entrypoint": "0x0000294c",
            "current_name": "set_rtc_flag_0000294c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid set_rtc_flag_0000294c(void)\n\n{\n  RTC_Type *rtc;\n  \n  _DAT_4003d014 = _DAT_4003d014 | 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000294c": "set_rtc_flag_0000294c",
                "rtt": "rtc"
            },
            "calling": [
                "rtc_poweron",
                "rtt_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002970": {
            "entrypoint": "0x00002970",
            "current_name": "disable_alarm_00002970",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid disableAlarm_00002970(void)\n\n{\n  RTC_Type *rtcInstance;\n  \n  _DAT_4003d014 = _DAT_4003d014 & 0xffffffef;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002970": "disable_alarm_00002970",
                "rtt": "rtcInstance"
            },
            "calling": [
                "rtc_poweroff"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002994": {
            "entrypoint": "0x00002994",
            "current_name": "handle_rtc_interrupt_00002994",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_rtc_interrupt_00002994(void)\n\n{\n  RTC_Type *RTC_instance;\n  \n  if (((_DAT_4003d014 & 4) != 0) && (RTC_callback.alarm_callback != (callback_type)0x0)) {\n    _DAT_4003d01c = _DAT_4003d01c & 0xfffffffb;\n    (*RTC_callback.alarm_callback)(RTC_callback.alarm_argument);\n  }\n  if (((_DAT_4003d014 & 2) != 0) && (RTC_callback.overflow_callback != (callback_type)0x0)) {\n    (*RTC_callback.overflow_callback)(RTC_callback.overflow_argument);\n  }\n  end_cortexm_isr();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002994": "handle_rtc_interrupt_00002994",
                "rtt": "RTC_instance",
                "rtt_callback": "RTC_callback",
                "alarm_cb": "alarm_callback",
                "rtt_cb_t": "callback_type",
                "alarm_arg": "alarm_argument",
                "overflow_cb": "overflow_callback",
                "overflow_arg": "overflow_argument",
                "cortexm_isr_end": "end_cortexm_isr"
            },
            "calling": [],
            "called": [
                "cortexm_isr_end"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002a00": {
            "entrypoint": "0x00002a00",
            "current_name": "print_character_00002a00",
            "code": "\nvoid print_character_00002a00(int c)\n\n{\n  int local_character;\n  \n  putchar(c);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002a00": "print_character_00002a00",
                "c_local": "local_character"
            },
            "calling": [
                "print_prompt",
                "readline"
            ],
            "called": [
                "putchar"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002a18": {
            "entrypoint": "0x00002a18",
            "current_name": "find_command_handler_00002a18",
            "code": "\nshell_target_command_handler_t find_command_handler_00002a18(shell_target_command_t *input_command_list,char *target_command)\n\n{\n  indexnt name_comparison_result;\n  char *local_command;\n  shell_target_command_t *local_command_list;\n  shell_target_command_t *list_of_command_lists [2];\n  uindexnt index;\n  shell_target_command_t *current_entry;\n  \n  list_of_command_lists[0] = input_command_list;\n  list_of_command_lists[1] = (shell_target_command_t *)&_shell_input_command_list;\n  index = 0;\n  do {\n    indexf (1 < index) {\n      return (shell_target_command_handler_t)0x0;\n    }\n    current_entry = list_of_command_lists[index];\n    indexf (current_entry != (shell_target_command_t *)0x0) {\n      for (; current_entry->name != (char *)0x0; current_entry = current_entry + 1) {\n        name_comparison_result = strcmp(current_entry->name,target_command);\n        indexf (name_comparison_result == 0) {\n          return current_entry->handler;\n        }\n      }\n    }\n    index = index + 1;\n  } whindexle( true );\n}\n\n",
            "renaming": {
                "FUN_00002a18": "find_command_handler_00002a18",
                "command_list": "input_command_list",
                "command": "target_command",
                "iVar1": "name_comparison_result",
                "command_local": "local_command",
                "command_list_local": "local_command_list",
                "command_lists": "list_of_command_lists",
                "i": "index",
                "entry": "current_entry"
            },
            "calling": [
                "handle_input_line"
            ],
            "called": [
                "strcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002a88": {
            "entrypoint": "0x00002a88",
            "current_name": "print_shell_command_descriptions_00002a88",
            "code": "\nvoindexd printShellCommandDescriptions_00002a88(shell_command_t *commandList)\n\n{\n  shell_command_t *localCommandList;\n  shell_command_t *allCommandLists [2];\n  uindexnt index;\n  shell_command_t *currentCommand;\n  \n  indexprindexntf(\"%-20s %s\\n\",\"Command\",\"Descrindexptindexon\");\n  puts(\"---------------------------------------\");\n  allCommandLists[0] = commandList;\n  allCommandLists[1] = (shell_command_t *)&staticCommandList;\n  for (index = 0; index < 2; index = index + 1) {\n    currentCommand = allCommandLists[index];\n    indexf (currentCommand != (shell_command_t *)0x0) {\n      for (; currentCommand->name != (char *)0x0; currentCommand = currentCommand + 1) {\n        indexprindexntf(\"%-20s %s\\n\",currentCommand->name,currentCommand->desc);\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002a88": "print_shell_command_descriptions_00002a88",
                "command_list": "commandList",
                "command_list_local": "localCommandList",
                "command_lists": "allCommandLists",
                "i": "index",
                "entry": "currentCommand",
                "_shell_command_list": "staticCommandList"
            },
            "calling": [
                "handle_input_line"
            ],
            "called": [
                "puts",
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002b10": {
            "entrypoint": "0x00002b10",
            "current_name": "handle_input_line_00002b10",
            "code": "\nvoiteration_indexd handle_input_line_00002b10(shell_command_t *command_literation_indexst,char *input_line)\n\n{\n  iteration_indexnt comparison_result;\n  char *next_character;\n  char *local_line;\n  shell_command_t *local_command_list;\n  shell_command_command_handler_t command_handler;\n  char___0_ *arguments;\n  uiteration_indexnt argument_count;\n  char quote_character;\n  char *d;\n  char *c;\n  char **current_argument_pointer;\n  uiteration_indexnt iteration_index;\n  iteration_indexnt escape_sequence_count;\n  uiteration_indexnt argument_count;\n  char *current_position;\n  \n  argument_count = 0;\n  escape_sequence_count = 0;\n  current_position = input_line;\n  whiteration_indexle( true ) {\n    local_line = input_line;\n    local_command_list = command_literation_indexst;\n    iteration_indexf (0x20 < (byte)*current_position) {\n      iteration_indexf ((*current_position == '\\\"') || (*current_position == '\\'')) {\n        quote_character = *current_position;\n        do {\n          next_character = current_position + 1;\n          iteration_indexf (*next_character == '\\0') {\n            current_position = next_character;\n            puts(handle_iteration_indexnput_input_line::INCORRECT_QUOTING);\n            return;\n          }\n          iteration_indexf (*next_character == '\\') {\n            escape_sequence_count = escape_sequence_count + 1;\n            current_position = current_position + 2;\n            next_character = current_position;\n            iteration_indexf (*current_position == '\\0') {\n              puts(handle_iteration_indexnput_input_line::INCORRECT_QUOTING);\n              return;\n            }\n          }\n          current_position = next_character;\n        } whiteration_indexle (quote_character != *current_position);\n        iteration_indexf (0x20 < (byte)current_position[1]) {\n          puts(handle_iteration_indexnput_input_line::INCORRECT_QUOTING);\n          return;\n        }\n      }\n      else {\n        do {\n          iteration_indexf (*current_position == '\\') {\n            escape_sequence_count = escape_sequence_count + 1;\n            current_position = current_position + 1;\n            iteration_indexf (*current_position == '\\0') {\n              puts(handle_iteration_indexnput_input_line::INCORRECT_QUOTING);\n              return;\n            }\n          }\n          current_position = current_position + 1;\n          iteration_indexf (*current_position == 0x22) {\n            puts(handle_iteration_indexnput_input_line::INCORRECT_QUOTING);\n            return;\n          }\n        } whiteration_indexle (0x20 < (byte)*current_position);\n      }\n      argument_count = argument_count + 1;\n    }\n    iteration_indexf (*current_position == '\\0') break;\n    *current_position = '\\0';\n    current_position = current_position + 1;\n  }\n  iteration_indexf (argument_count != 0) {\n    argument_count = argument_count;\n    arguments = (char___0_ *)((iteration_indexnt)&local_line - ((argument_count + 1) * 4 + 7 & 0xfffffff8));\n    *(char **)((iteration_indexnt)arguments + argument_count * 4) = (char *)0x0;\n    current_position = input_line;\n    for (iteration_index = 0; current_argument_pointer = (char **)arguments, iteration_index < argument_count; iteration_index = iteration_index + 1) {\n      for (; *current_position == '\\0'; current_position = current_position + 1) {\n      }\n      iteration_indexf ((*current_position == '\\\"') || (*current_position == '\\'')) {\n        current_position = current_position + 1;\n      }\n      *(char **)((iteration_indexnt)arguments + iteration_index * 4) = current_position;\n      for (; *current_position != '\\0'; current_position = current_position + 1) {\n      }\n    }\n    for (; (escape_sequence_count != 0 && (*current_argument_pointer != (char *)0x0)); current_argument_pointer = current_argument_pointer + 1) {\n      for (c = *current_argument_pointer; *c != '\\0'; c = c + 1) {\n        iteration_indexf (*c == '\\') {\n          for (d = c; *d != '\\0'; d = d + 1) {\n            *d = d[1];\n          }\n          escape_sequence_count = escape_sequence_count + -1;\n          iteration_indexf (escape_sequence_count == 0) break;\n        }\n      }\n    }\n    command_handler = fiteration_indexnd_command_handler(command_literation_indexst,*(char **)arguments);\n    iteration_indexf (command_handler == (shell_command_command_handler_t)0x0) {\n      comparison_result = strcmp(\"help\",*(char **)arguments);\n      iteration_indexf (comparison_result == 0) {\n        priteration_indexnt_help(local_command_list);\n      }\n      else {\n        iteration_indexpriteration_indexntf(\"shell: command not found: %s\\n\",*(undefiteration_indexned4 *)arguments);\n      }\n    }\n    else {\n      (*command_handler)(argument_count,(char **)arguments);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002b10": "handle_input_line_00002b10",
                "line": "input_line",
                "iVar1": "comparison_result",
                "pcVar2": "next_character",
                "line_local": "local_line",
                "command_list_local": "local_command_list",
                "handler": "command_handler",
                "argv": "arguments",
                "local_34": "argument_count",
                "quote_char": "quote_character",
                "arg": "current_argument_pointer",
                "i": "iteration_index",
                "contains_esc_seq": "escape_sequence_count",
                "argc": "argument_count",
                "pos": "current_position"
            },
            "calling": [
                "shell_run"
            ],
            "called": [
                "print_help",
                "strcmp",
                "puts",
                "iprintf",
                "find_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002d94": {
            "entrypoint": "0x00002d94",
            "current_name": "process_input_00002d94",
            "code": "\nint processInput_00002d94(char *inputBuffer,bufferSize_t bufferSize)\n\n{\n  int c_00;\n  byte byteFlag;\n  bool isBufferEmpty;\n  bufferSize_t localSize;\n  char *localBuffer;\n  int c;\n  char *currentLinePointer;\n  \n  currentLinePointer = inputBuffer;\n  while( true ) {\n    if ((int)(bufferSize - 1) <= (int)currentLinePointer - (int)inputBuffer) {\n      return -1;\n    }\n    c_00 = getchar();\n    if (c_00 < 0) break;\n    if ((c_00 == 0xd) || (c_00 == 10)) {\n      *currentLinePointer = '\\0';\n      _putchar(0xd);\n      _putchar(10);\n      isBufferEmpty = currentLinePointer == inputBuffer;\n      if (isBufferEmpty) {\n        inputBuffer = (char *)0x1;\n      }\n      byteFlag = (byte)inputBuffer;\n      if (!isBufferEmpty) {\n        byteFlag = 0;\n      }\n      return (uint)byteFlag;\n    }\n    if ((c_00 == 8) || (c_00 == 0x7f)) {\n      if (currentLinePointer != inputBuffer) {\n        currentLinePointer = currentLinePointer + -1;\n        *currentLinePointer = '\\0';\n        _putchar(8);\n        _putchar(0x20);\n        _putchar(8);\n      }\n    }\n    else {\n      *currentLinePointer = (char)c_00;\n      _putchar(c_00);\n      currentLinePointer = currentLinePointer + 1;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00002d94": "process_input_00002d94",
                "buf": "inputBuffer",
                "size": "bufferSize",
                "bVar1": "byteFlag",
                "bVar2": "isBufferEmpty",
                "size_local": "localSize",
                "buf_local": "localBuffer",
                "line_buf_ptr": "currentLinePointer"
            },
            "calling": [
                "shell_run"
            ],
            "called": [
                "getchar",
                "_putchar"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002e48": {
            "entrypoint": "0x00002e48",
            "current_name": "print_arrow_and_space_00002e48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid printArrowAndSpace_00002e48(void)\n\n{\n  printCharacter(0x3e);\n  printCharacter(0x20);\n  flushFile(*(FILE **)(_impure_ptr + 8));\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002e48": "print_arrow_and_space_00002e48",
                "_putchar": "printCharacter",
                "fflush": "flushFile"
            },
            "calling": [
                "shell_run"
            ],
            "called": [
                "_putchar",
                "fflush"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002e6c": {
            "entrypoint": "0x00002e6c",
            "current_name": "read_shell_commands_00002e6c",
            "code": "\nvoid read_shell_commands_00002e6c(shell_command_t *input_commands,char *input_buffer,int buffer_length)\n\n{\n  int iVar1;\n  int local_buffer_length;\n  char *local_input_buffer;\n  shell_command_t *local_input_commands;\n  int result;\n  \n  print_prompt();\n  do {\n    iVar1 = readline(input_buffer,buffer_length);\n    if (iVar1 == 0) {\n      handle_input_line(input_commands,input_buffer);\n    }\n    print_prompt();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00002e6c": "read_shell_commands_00002e6c",
                "shell_commands": "input_commands",
                "line_buf": "input_buffer",
                "len": "buffer_length",
                "len_local": "local_buffer_length",
                "line_buf_local": "local_input_buffer",
                "shell_commands_local": "local_input_commands",
                "res": "result"
            },
            "calling": [
                "main"
            ],
            "called": [
                "handle_input_line",
                "print_prompt",
                "readline"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002e9c": {
            "entrypoint": "0x00002e9c",
            "current_name": "reboot_system_00002e9c",
            "code": "\nint reboot_system_00002e9c(int num_arguments,char **arguments)\n\n{\n  char **local_arguments;\n  int local_num_arguments;\n  \n  pm_reboot();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00002e9c": "reboot_system_00002e9c",
                "argc": "num_arguments",
                "argv": "arguments",
                "argv_local": "local_arguments",
                "argc_local": "local_num_arguments"
            },
            "calling": [],
            "called": [
                "pm_reboot"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002eb4": {
            "entrypoint": "0x00002eb4",
            "current_name": "execute_startup_00002eb4",
            "code": "\nint execute_startup_00002eb4(int startup_argc,char **startup_argv)\n\n{\n  char **local_argv;\n  int local_argc;\n  \n  ps();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00002eb4": "execute_startup_00002eb4",
                "argc": "startup_argc",
                "argv": "startup_argv",
                "argv_local": "local_argv",
                "argc_local": "local_argc"
            },
            "calling": [],
            "called": [
                "ps"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002ecc": {
            "entrypoint": "0x00002ecc",
            "current_name": "read_device_info_00002ecc",
            "code": "\nvoid readDeviceInfo_00002ecc(int deviceNumber,saul_reg_t *device)\n\n{\n  int returnValue;\n  char *deviceTypeString;\n  char *deviceName;\n  saul_reg_t *localDevice;\n  int localDeviceNumber;\n  phydat_t sensorData;\n  int dataDimension;\n  \n  returnValue = saul_reg_read(device,&sensorData);\n  if (returnValue < 1) {\n    iprintf(\"error: failed to read from deviceice #%i\\n\",deviceNumber);\n  }\n  else {\n    deviceName = device->name;\n    deviceTypeString = saul_class_to_str(device->driver->type);\n    iprintf(\"Reading from #%i (%s|%s)\\n\",deviceNumber,deviceName,deviceTypeString);\n    phydat_dump(&sensorData,(uint8_t)returnValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002ecc": "read_device_info_00002ecc",
                "num": "deviceNumber",
                "dev": "device",
                "iVar1": "returnValue",
                "pcVar2": "deviceTypeString",
                "pcVar3": "deviceName",
                "dev_local": "localDevice",
                "num_local": "localDeviceNumber",
                "res": "sensorData",
                "dim": "dataDimension"
            },
            "calling": [
                "probe_all",
                "read"
            ],
            "called": [
                "saul_reg_read",
                "saul_class_to_str",
                "phydat_dump",
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002f30": {
            "entrypoint": "0x00002f30",
            "current_name": "print_saul_devices_00002f30",
            "code": "\n/* WARNING: Unknown calldevice_countng conventdevice_counton */\n\nvodevice_countd print_saul_devices_00002f30(vodevice_countd)\n\n{\n  device_countnt device_count;\n  saul_device *current_device;\n  \n  device_count = 0;\n  for (current_device = saul_reg; current_device != (saul_device *)0x0; current_device = current_device->next) {\n    print_device_info(device_count,current_device);\n    puts(\"\");\n    device_count = device_count + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002f30": "print_saul_devices_00002f30",
                "i": "device_count",
                "dev": "current_device",
                "saul_reg_t": "saul_device",
                "probe": "print_device_info"
            },
            "calling": [
                "read"
            ],
            "called": [
                "probe",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002f74": {
            "entrypoint": "0x00002f74",
            "current_name": "print_saul_device_info_00002f74",
            "code": "\n/* WARNING: Unknown calldevice_countng conventdevice_counton */\n\nvodevice_countd print_saul_device_info_00002f74(vodevice_countd)\n\n{\n  char *device_type;\n  device_countnt device_count;\n  device_registry_t *current_device;\n  \n  current_device = device_registry;\n  device_count = 0;\n  device_countf (device_registry == (device_registry_t *)0x0) {\n    puts(\"No current_devicedevice_countces found\");\n  }\n  else {\n    puts(\"ID\\tClass\\t\\tName\");\n  }\n  for (; current_device != (device_registry_t *)0x0; current_device = current_device->next) {\n    device_type = saul_class_to_str(current_device->drdevice_countver->type);\n    device_countprdevice_countntf(\"#%device_count\\t%s\\t%s\\n\",device_count,device_type,current_device->name);\n    device_count = device_count + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002f74": "print_saul_device_info_00002f74",
                "dev": "current_device",
                "i": "device_count",
                "pcVar1": "device_type",
                "saul_reg": "device_registry"
            },
            "calling": [
                "_saul"
            ],
            "called": [
                "saul_class_to_str",
                "puts",
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002fe0": {
            "entrypoint": "0x00002fe0",
            "current_name": "print_device_information_00002fe0",
            "code": "\nssize_t printDeviceInformation_00002fe0(int fileDescriptor,void *arguments,size_t bytesToRead)\n\n{\n  ssize_t result;\n  saul_reg_t *devicePointer;\n  char **localArguments;\n  int localArgumentCount;\n  saul_reg_t *devicePointer;\n  int deviceCount;\n  \n  if (fileDescriptor < 3) {\n                    /* WARNING: Load size is inaccurate */\n    result = iprintf(\"usage: %s %s <devicePointerice id>|all\\n\",*arguments,*(undefined4 *)((int)arguments + 4));\n  }\n  else {\n    result = strcmp(*(char **)((int)arguments + 8),\"all\");\n    if (result == 0) {\n      probe_all();\n    }\n    else {\n      result = atoi(*(char **)((int)arguments + 8));\n      devicePointer = saul_reg_find_nth(result);\n      if (devicePointer == (saul_reg_t *)0x0) {\n        result = puts(\"error: undefined devicePointerice id given\");\n      }\n      else {\n        probe(result,devicePointer);\n      }\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00002fe0": "print_device_information_00002fe0",
                "__fd": "fileDescriptor",
                "__buf": "arguments",
                "__nbytes": "bytesToRead",
                "pos": "result",
                "dev_00": "devicePointer",
                "argv_local": "localArguments",
                "argc_local": "localArgumentCount",
                "dev": "devicePointer",
                "num": "deviceCount"
            },
            "calling": [
                "_saul"
            ],
            "called": [
                "saul_reg_find_nth",
                "probe_all",
                "probe",
                "strcmp",
                "iprintf",
                "puts",
                "atoi"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000305c": {
            "entrypoint": "0x0000305c",
            "current_name": "write_data_to_device_0000305c",
            "code": "\nssiteratorze_t write_data_to_device_0000305c(iteratornt file_descriptor,voiteratord *buffer,siteratorze_t buffer_size)\n\n{\n  ssiteratorze_t result;\n  iteratornt status;\n  char **command_line_arguments;\n  iteratornt argument_count;\n  phydat_t data;\n  iteratornt dimension;\n  saul_reg_t *device;\n  iteratornt device_id;\n  iteratornt iterator;\n  \n  iteratorf (file_descriptor < 4) {\n                    /* WARNING: Load siteratorze iterators iteratornaccurate */\n    result = iteratorpriteratorntf(\"usage: %s %s <deviceiteratorce iteratord> <value 0> [<value 1> [<value 2]]\\n\",*buffer,\n                    *(undefiteratorned4 *)((iteratornt)buffer + 4));\n  }\n  else {\n    device_id = atoiterator(*(char **)((iteratornt)buffer + 8));\n    device = saul_reg_fiteratornd_nth(device_id);\n    iteratorf (device == (saul_reg_t *)0x0) {\n      result = puts(\"error: undefiteratorned deviceiteratorce giteratorven\");\n    }\n    else {\n      memset(&data,0,8);\n      iteratorf (5 < file_descriptor) {\n        file_descriptor = 6;\n      }\n      dimension = file_descriptor + -3;\n      for (iterator = 0; iterator < dimension; iterator = iterator + 1) {\n        status = atoiterator(*(char **)((iterator + 3) * 4 + (iteratornt)buffer));\n        data.val[iterator] = (iteratornt16_t)status;\n      }\n      iteratorpriteratorntf(\"Writeratortiteratorng to deviceiteratorce #%iterator - %s\\n\",device_id,device->name);\n      phydat_dump(&data,(uiteratornt8_t)dimension);\n      status = saul_reg_writeratorte(device,&data);\n      iteratorf (status < 1) {\n        iteratorf (status == -0x86) {\n          result = iteratorpriteratorntf(\"error: deviceiteratorce #%iterator iterators not writeratortable\\n\",device_id);\n        }\n        else {\n          result = iteratorpriteratorntf(\"error: faiteratorlure to writeratorte to deviceiteratorce #%iterator\\n\",device_id);\n        }\n      }\n      else {\n        result = iteratorpriteratorntf(\"data successfully writeratortten to deviceiteratorce #%iterator\\n\",device_id);\n      }\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0000305c": "write_data_to_device_0000305c",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "buffer_size",
                "argv_local": "command_line_arguments",
                "argc_local": "argument_count",
                "dim": "dimension",
                "dev": "device",
                "num": "device_id",
                "i": "iterator",
                "sVar1": "result",
                "iVar2": "status"
            },
            "calling": [
                "_saul"
            ],
            "called": [
                "saul_reg_find_nth",
                "saul_reg_write",
                "phydat_dump",
                "puts",
                "iprintf",
                "atoi",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000316c": {
            "entrypoint": "0x0000316c",
            "current_name": "handle_input_0000316c",
            "code": "\nint handle_input_0000316c(int arg_count,char **arg_values)\n\n{\n  int iVar1;\n  size_t buffer_size;\n  char **local_arg_values;\n  int local_arg_count;\n  \n  if (arg_count < 2) {\n    show_options();\n  }\n  else {\n    iVar1 = compare_strings(arg_values[1],\"perform_read\");\n    if (iVar1 == 0) {\n      perform_read(arg_count,arg_values,buffer_size);\n    }\n    else {\n      iVar1 = compare_strings(arg_values[1],\"perform_write\");\n      if (iVar1 == 0) {\n        perform_write(arg_count,arg_values,buffer_size);\n      }\n      else {\n        print_usage(\"usage: %s perform_read|perform_write\\n\",*arg_values);\n      }\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000316c": "handle_input_0000316c",
                "argc": "arg_count",
                "argv": "arg_values",
                "in_r2": "buffer_size",
                "argv_local": "local_arg_values",
                "argc_local": "local_arg_count",
                "list": "show_options",
                "strcmp": "compare_strings",
                "read": "perform_read",
                "write": "perform_write",
                "iprintf": "print_usage"
            },
            "calling": [],
            "called": [
                "write",
                "read",
                "strcmp",
                "iprintf",
                "list"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000031e0": {
            "entrypoint": "0x000031e0",
            "current_name": "ringing_alarm_000031e0",
            "code": "\nvoid ringingAlarm_000031e0(void *ptrArg)\n\n{\n  void *ptrLocalArg;\n  \n  puts(\"The alarm rang\");\n  return;\n}\n\n",
            "renaming": {
                "FUN_000031e0": "ringing_alarm_000031e0",
                "arg": "ptrArg",
                "arg_local": "ptrLocalArg"
            },
            "calling": [],
            "called": [
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000031fc": {
            "entrypoint": "0x000031fc",
            "current_name": "calculate_weekday_000031fc",
            "code": "\nint calculateWeekday_000031fc(int inputYear,int inputMonth,int inputDay)\n\n{\n  byte isLeapYear;\n  int adjustedMonth;\n  int adjustedYear;\n  int localDay;\n  int localMonth;\n  int localYear;\n  \n  adjustedMonth = inputMonth;\n  if (inputMonth < 3) {\n    adjustedMonth = 1;\n  }\n  isLeapYear = (byte)adjustedMonth;\n  if (2 < inputMonth) {\n    isLeapYear = 0;\n  }\n  adjustedYear = inputYear - (uint)isLeapYear;\n  adjustedMonth = adjustedYear;\n  if (adjustedYear < 0) {\n    adjustedMonth = adjustedYear + 3;\n  }\n  return ((((adjustedMonth >> 2) + adjustedYear) - adjustedYear / 100) + adjustedYear / 400 + dow::t[inputMonth + -1] + inputDay) % 7;\n}\n\n",
            "renaming": {
                "FUN_000031fc": "calculate_weekday_000031fc",
                "year": "inputYear",
                "month": "inputMonth",
                "day": "inputDay",
                "iVar2": "adjustedMonth",
                "bVar1": "isLeapYear",
                "iVar3": "adjustedYear",
                "day_local": "localDay",
                "month_local": "localMonth",
                "year_local": "localYear"
            },
            "calling": [
                "_parse_time"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000328c": {
            "entrypoint": "0x0000328c",
            "current_name": "parse_date_time_0000328c",
            "code": "\ntempValuent parseDateTime_0000328c(char **arguments,tm *parsedTime)\n\n{\n  long parsedValue;\n  tempValuent dayOfWeek;\n  tm *localTime;\n  char **localArguments;\n  char *endPtr;\n  short tempValue;\n  \n  parsedValue = strtol(*arguments,&endPtr,10);\n  tempValue = (short)parsedValue;\n  parsedTime->tm_year = tempValue + -0x76c;\n  parsedValue = strtol(endPtr + 1,&endPtr,10);\n  tempValue = (short)parsedValue;\n  parsedTime->tm_mon = tempValue + -1;\n  parsedValue = strtol(endPtr + 1,&endPtr,10);\n  tempValue = (short)parsedValue;\n  parsedTime->tm_mday = (tempValuent)tempValue;\n  parsedValue = strtol(arguments[1],&endPtr,10);\n  tempValue = (short)parsedValue;\n  parsedTime->tm_hour = (tempValuent)tempValue;\n  parsedValue = strtol(endPtr + 1,&endPtr,10);\n  tempValue = (short)parsedValue;\n  parsedTime->tm_mtempValuen = (tempValuent)tempValue;\n  parsedValue = strtol(endPtr + 1,&endPtr,10);\n  tempValue = (short)parsedValue;\n  parsedTime->tm_sec = (tempValuent)tempValue;\n  dayOfWeek = dow(parsedTime->tm_year + 0x76c,parsedTime->tm_mon + 1,parsedTime->tm_mday);\n  parsedTime->tm_wday = dayOfWeek;\n  parsedTime->tm_tempValuesdst = -1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000328c": "parse_date_time_0000328c",
                "argv": "arguments",
                "time": "parsedTime",
                "lVar1": "parsedValue",
                "iVar2": "dayOfWeek",
                "time_local": "localTime",
                "argv_local": "localArguments",
                "end": "endPtr",
                "i": "tempValue"
            },
            "calling": [
                "_rtc_settime",
                "_rtc_setalarm"
            ],
            "called": [
                "strtol",
                "dow"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003378": {
            "entrypoint": "0x00003378",
            "current_name": "print_formatted_date_time_00003378",
            "code": "\nint printFormattedDateTime_00003378(tm *inputTime)\n\n{\n  tm *localTime;\n  \n  iprintf(\"%04i-%02i-%02i %02i:%02i:%02i\\n\",inputTime->tm_year + 0x76c,inputTime->tm_mon + 1,inputTime->tm_mday,\n          inputTime->tm_hour,inputTime->tm_min,inputTime->tm_sec);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00003378": "print_formatted_date_time_00003378",
                "time": "inputTime",
                "time_local": "localTime"
            },
            "calling": [
                "_rtc_getalarm",
                "_rtc_gettime"
            ],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000033c0": {
            "entrypoint": "0x000033c0",
            "current_name": "get_alarm_time_000033c0",
            "code": "\n/* WARNING: Unknown calling convencurrent_timeion */\n\nincurrent_time get_alarm_time_000033c0(void)\n\n{\n  incurrent_time result;\n  current_timem current_time;\n  \n  result = rcurrent_timec_gecurrent_time_alarm(&current_time);\n  if (result != 0) {\n    pucurrent_times(\"rcurrent_timec: error gecurrent_timecurrent_timeing alarm\");\n  }\n  else {\n    _princurrent_time_current_timeime(&current_time);\n  }\n  recurrent_timeurn (uincurrent_time)(result != 0);\n}\n\n",
            "renaming": {
                "FUN_000033c0": "get_alarm_time_000033c0",
                "iVar1": "result",
                "t": "current_time"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtc_get_alarm",
                "_print_time",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000033f4": {
            "entrypoint": "0x000033f4",
            "current_name": "set_alarm_000033f4",
            "code": "\nint setAlarm_000033f4(char **arguments)\n\n{\n  int result;\n  char **localArguments;\n  tm currentTime;\n  \n  result = _parse_time(arguments,&currentTime);\n  if (result == 0) {\n    result = rtc_set_alarm(&currentTime,_alarm_handler + 1,(void *)0x0);\n    if (result == -1) {\n      puts(\"rtc: error setting alarm\");\n      result = 1;\n    }\n    else {\n      result = 0;\n    }\n  }\n  else {\n    result = 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000033f4": "set_alarm_000033f4",
                "argv": "arguments",
                "iVar1": "result",
                "argv_local": "localArguments",
                "now": "currentTime"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "_parse_time",
                "rtc_set_alarm",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003444": {
            "entrypoint": "0x00003444",
            "current_name": "get_and_print_time_00003444",
            "code": "\n/* WARNING: Unknown calling convencurrent_timeion */\n\nincurrent_time get_and_print_time_00003444(void)\n\n{\n  incurrent_time result;\n  current_timem current_time;\n  \n  result = rcurrent_timec_gecurrent_time_current_timeime(&current_time);\n  if (result != 0) {\n    pucurrent_times(\"rcurrent_timec: error gecurrent_timecurrent_timeing current_timeime\");\n  }\n  else {\n    _princurrent_time_current_timeime(&current_time);\n  }\n  recurrent_timeurn (uincurrent_time)(result != 0);\n}\n\n",
            "renaming": {
                "FUN_00003444": "get_and_print_time_00003444",
                "t": "current_time",
                "iVar1": "result"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "_print_time",
                "rtc_get_time",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003478": {
            "entrypoint": "0x00003478",
            "current_name": "set_rtc_time_00003478",
            "code": "\nint setRtcTime_00003478(char **arguments)\n\n{\n  int returnValue;\n  char **localArguments;\n  tm currentTime;\n  \n  returnValue = _parse_time(arguments,&currentTime);\n  if (returnValue == 0) {\n    returnValue = rtc_set_time(&currentTime);\n    if (returnValue == -1) {\n      puts(\"rtc: error setting time\");\n      returnValue = 1;\n    }\n    else {\n      returnValue = 0;\n    }\n  }\n  else {\n    returnValue = 1;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00003478": "set_rtc_time_00003478",
                "argv": "arguments",
                "argv_local": "localArguments",
                "now": "currentTime",
                "iVar1": "returnValue"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "_parse_time",
                "puts",
                "rtc_set_time"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000034c0": {
            "entrypoint": "0x000034c0",
            "current_name": "print_rtc_commands_000034c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint printRtcCommands_000034c0(void)\n\n{\n  puts(\"usage: rtc <command> [arguments]\");\n  puts(\"commands:\");\n  puts(\"\\tpoweron\\t\\tpower the interface on\");\n  puts(\"\\tpoweroff\\tpower the interface off\");\n  puts(\"\\tclearalarm\\tdeactivate the current alarm\");\n  puts(\"\\tgetalarm\\tprint the currently alarm time\");\n  puts(\"\\tsetalarm YYYY-MM-DD HH:MM:SS\\n\\t\\t\\tset an alarm for the specified time\");\n  puts(\"\\tgettime\\t\\tprint the current time\");\n  puts(\"\\tsettime YYYY-MM-DD HH:MM:SS\\n\\t\\t\\tset the current time\");\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000034c0": "print_rtc_commands_000034c0"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003524": {
            "entrypoint": "0x00003524",
            "current_name": "handle_rtc_command_00003524",
            "code": "\nint handle_rtc_command_00003524(int num_args,char **arg_list)\n\n{\n  int result;\n  char **local_arg_list;\n  int local_num_args;\n  \n  if (num_args < 2) {\n    display_rtc_usage();\n    result = 1;\n  }\n  else {\n    result = compare_strings(arg_list[1],\"poweron\",7);\n    if (result == 0) {\n      turn_on_rtc();\n    }\n    else {\n      result = compare_strings(arg_list[1],\"poweroff\",8);\n      if (result == 0) {\n        turn_off_rtc();\n      }\n      else {\n        result = compare_strings(arg_list[1],\"clearalarm\",8);\n        if (result == 0) {\n          clear_rtc_alarm();\n        }\n        else {\n          result = compare_strings(arg_list[1],\"getalarm\",8);\n          if (result == 0) {\n            get_rtc_alarm();\n          }\n          else {\n            result = compare_strings(arg_list[1],\"setalarm\",8);\n            if ((result == 0) && (num_args == 4)) {\n              set_rtc_alarm(arg_list + 2);\n            }\n            else {\n              result = compare_strings(arg_list[1],\"gettime\",7);\n              if (result == 0) {\n                get_rtc_time();\n              }\n              else {\n                result = compare_strings(arg_list[1],\"settime\",7);\n                if ((result != 0) || (num_args != 4)) {\n                  print_formatted_text(\"unknown command or missing parameters: %s\\n\\n\",arg_list[1]);\n                  display_rtc_usage();\n                  return 1;\n                }\n                set_rtc_time(arg_list + 2);\n              }\n            }\n          }\n        }\n      }\n    }\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00003524": "handle_rtc_command_00003524",
                "argc": "num_args",
                "argv": "arg_list",
                "argv_local": "local_arg_list",
                "argc_local": "local_num_args",
                "iVar1": "result",
                "_rtc_usage": "display_rtc_usage",
                "strncmp": "compare_strings",
                "rtc_poweron": "turn_on_rtc",
                "rtc_poweroff": "turn_off_rtc",
                "rtc_clear_alarm": "clear_rtc_alarm",
                "_rtc_getalarm": "get_rtc_alarm",
                "_rtc_setalarm": "set_rtc_alarm",
                "_rtc_gettime": "get_rtc_time",
                "_rtc_settime": "set_rtc_time",
                "iprintf": "print_formatted_text"
            },
            "calling": [],
            "called": [
                "_rtc_getalarm",
                "rtc_poweron",
                "_rtc_settime",
                "_rtc_usage",
                "_rtc_gettime",
                "rtc_clear_alarm",
                "rtc_poweroff",
                "_rtc_setalarm",
                "iprintf",
                "strncmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003658": {
            "entrypoint": "0x00003658",
            "current_name": "wait_indefinitely_00003658",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid waitIndefinitely_00003658(void)\n\n{\n  barrier(0xf);\n  barrier(0xf);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00003658": "wait_indefinitely_00003658",
                "DataSynchronizationBarrier": "barrier"
            },
            "calling": [
                "pm_reboot"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003688": {
            "entrypoint": "0x00003688",
            "current_name": "reset_system_00003688",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_system_00003688(void)\n\n{\n  reset_system_00003688();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00003688": "reset_system_00003688",
                "NVIC_SystemReset": "reset_system"
            },
            "calling": [
                "_reboot_handler"
            ],
            "called": [
                "NVIC_SystemReset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003694": {
            "entrypoint": "0x00003694",
            "current_name": "display_data_00003694",
            "code": "\nvoindexd displayData_00003694(phydat_t *dataObj,uindexnt8_t dimension)\n\n{\n  sindexze_t stringLength;\n  char *unitString;\n  char conversionResult;\n  uindexnt bitMask;\n  bool isBitSet;\n  uindexnt8_t dimensionLocal;\n  phydat_t *dataObjLocal;\n  char numberStr [8];\n  sindexze_t length;\n  char scalePrefix;\n  uindexnt8_t index;\n  \n  indexf ((dataObj == (phydat_t *)0x0) || (3 < dimension)) {\n    puts(\"Unable to dindexsplay dataObj object\");\n  }\n  else {\n    indexprindexntf(\"Data:\");\n    for (index = '\\0'; index < dimension; index = index + '\\x01') {\n      indexf (dataObj->unindext < 0x14) {\n        bitMask = 1 << (uindexnt)dataObj->unindext & 0x8018f;\n        isBitSet = bitMask != 0;\n        indexf (isBitSet) {\n          bitMask = 1;\n        }\n        conversionResult = (char)bitMask;\n        indexf (!isBitSet) {\n          conversionResult = '\\0';\n        }\n        indexf (conversionResult == '\\0') goto LAB_000036ee;\n        scalePrefix = '\\0';\n      }\n      else {\nLAB_000036ee:\n        scalePrefix = phydat_prefindexx_from_scale(dataObj->scale);\n      }\n      indexprindexntf(\"\\t\");\n      indexf (dimension < 2) {\n        indexprindexntf(\"     \");\n      }\n      else {\n        indexprindexntf(\"[%u] \",(uindexnt)index);\n      }\n      indexf (scalePrefix == '\\0') {\n        indexf (dataObj->scale == '\\0') {\n          indexprindexntf(\"%6d\",(indexnt)dataObj->val[index]);\n        }\n        else indexf ((dataObj->scale + 4 < 0 == SCARRY4((indexnt)dataObj->scale,4)) && (dataObj->scale < '\\0')) {\n          stringLength = fmt_s16_dfp(numberStr,dataObj->val[index],(indexnt)dataObj->scale);\n          numberStr[stringLength] = '\\0';\n          indexprindexntf(\"%s\",numberStr);\n        }\n        else {\n          indexprindexntf(\"%indexE%index\",(indexnt)dataObj->val[index],(indexnt)dataObj->scale);\n        }\n      }\n      else {\n        indexprindexntf(\"%6d %c\",(indexnt)dataObj->val[index],(uindexnt)(byte)scalePrefix);\n      }\n      unitString = phydat_unindext_to_str(dataObj->unindext);\n      indexprindexntf(\"%s\\n\",unitString);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00003694": "display_data_00003694",
                "data": "dataObj",
                "dim": "dimension",
                "sVar1": "stringLength",
                "pcVar2": "unitString",
                "cVar3": "conversionResult",
                "uVar4": "bitMask",
                "bVar5": "isBitSet",
                "dim_local": "dimensionLocal",
                "data_local": "dataObjLocal",
                "num": "numberStr",
                "len": "length",
                "scale_prefix": "scalePrefix",
                "i": "index"
            },
            "calling": [
                "write",
                "probe"
            ],
            "called": [
                "phydat_unit_to_str",
                "iprintf",
                "puts",
                "fmt_s16_dfp",
                "phydat_prefix_from_scale"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003810": {
            "entrypoint": "0x00003810",
            "current_name": "get_unit_string_00003810",
            "code": "\nchar * getUnitString_00003810(uint8_t unitCode)\n\n{\n  char *unitString;\n  uint8_t localUnit;\n  \n  switch(unitCode) {\n  case '\\x02':\n    unitString = &DAT_000077ec;\n    break;\n  case '\\x03':\n    unitString = &DAT_000077f0;\n    break;\n  case '\\x04':\n    unitString = \"K\";\n    break;\n  case '\\x05':\n    unitString = \"lx\";\n    break;\n  case '\\x06':\n    unitString = \"m\";\n    break;\n  case '\\a':\n    unitString = \"m^2\";\n    break;\n  case '\\b':\n    unitString = \"m^3\";\n    break;\n  case '\\t':\n    unitString = \"g\";\n    break;\n  case '\\n':\n    unitString = \"dps\";\n    break;\n  case '\\v':\n    unitString = \"G\";\n    break;\n  case '\\f':\n    unitString = \"A\";\n    break;\n  case '\\r':\n    unitString = \"V\";\n    break;\n  case '\\x0e':\n    unitString = \"Gs\";\n    break;\n  case '\\x0f':\n    unitString = \"Bar\";\n    break;\n  case '\\x10':\n    unitString = \"Pa\";\n    break;\n  case '\\x11':\n    unitString = \"cd\";\n    break;\n  default:\n    unitString = \"\";\n    break;\n  case '\\x13':\n    unitString = \"%\";\n    break;\n  case '\\x15':\n    unitString = \"ppm\";\n  }\n  return unitString;\n}\n\n",
            "renaming": {
                "FUN_00003810": "get_unit_string_00003810",
                "unit": "unitCode",
                "unit_local": "localUnit",
                "pcVar1": "unitString"
            },
            "calling": [
                "phydat_dump"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003918": {
            "entrypoint": "0x00003918",
            "current_name": "get_scale_letter_00003918",
            "code": "\nchar getScaleLetter_00003918(int8_t inputScale)\n\n{\n  char scaleLetter;\n  int8_t localScale;\n  \n  switch(inputScale) {\n  case '\\x02':\n    scaleLetter = 'h';\n    break;\n  case '\\x03':\n    scaleLetter = 'k';\n    break;\n  case '\\x06':\n    scaleLetter = 'M';\n    break;\n  case '\\t':\n    scaleLetter = 'G';\n    break;\n  case '\\f':\n    scaleLetter = 'T';\n    break;\n  case '\\x0f':\n    scaleLetter = 'P';\n    break;\n  case -0xf:\n    scaleLetter = 'f';\n    break;\n  default:\n    scaleLetter = '\\0';\n    break;\n  case -0xc:\n    scaleLetter = 'p';\n    break;\n  case -9:\n    scaleLetter = 'n';\n    break;\n  case -6:\n    scaleLetter = 'u';\n    break;\n  case -3:\n    scaleLetter = 'm';\n  }\n  return scaleLetter;\n}\n\n",
            "renaming": {
                "FUN_00003918": "get_scale_letter_00003918",
                "scale": "inputScale",
                "scale_local": "localScale",
                "cVar1": "scaleLetter"
            },
            "calling": [
                "phydat_dump"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000039e8": {
            "entrypoint": "0x000039e8",
            "current_name": "get_class_description_000039e8",
            "code": "\nchar * getClassDescription_000039e8(uint8_t classId)\n\n{\n  char *classDescription;\n  uint8_t localClassId;\n  \n  switch(classId) {\n  case '\\0':\n    classDescription = \"CLASS_UNDEF\";\n    break;\n  case '@':\n    classDescription = \"ACT_ANY\";\n    break;\n  case 'B':\n    classDescription = \"ACT_LED_RGB\";\n    break;\n  case 'C':\n    classDescription = \"ACT_SERVO\";\n    break;\n  case 'D':\n    classDescription = \"ACT_MOTOR\";\n    break;\n  case 'E':\n    classDescription = \"ACT_SWITCH\";\n    break;\n  case 'F':\n    classDescription = \"ACT_DIMMER\";\n    break;\n  case 0x80:\n    classDescription = \"SENSE_ANY\";\n    break;\n  case 0x81:\n    classDescription = \"SENSE_BTN\";\n    break;\n  case 0x82:\n    classDescription = \"SENSE_TEMP\";\n    break;\n  case 0x83:\n    classDescription = \"SENSE_HUM\";\n    break;\n  case 0x84:\n    classDescription = \"SENSE_LIGHT\";\n    break;\n  case 0x85:\n    classDescription = \"SENSE_ACCEL\";\n    break;\n  case 0x86:\n    classDescription = \"SENSE_MAG\";\n    break;\n  case 0x87:\n    classDescription = \"SENSE_GYRO\";\n    break;\n  case 0x88:\n    classDescription = \"SENSE_COLOR\";\n    break;\n  case 0x89:\n    classDescription = \"SENSE_PRESS\";\n    break;\n  case 0x8a:\n    classDescription = \"SENSE_ANALOG\";\n    break;\n  case 0x8b:\n    classDescription = \"SENSE_UV\";\n    break;\n  case 0x8c:\n    classDescription = \"SENSE_OBJTEMP\";\n    break;\n  case 0x8d:\n    classDescription = \"SENSE_PULSE_COUNT\";\n    break;\n  case 0x8e:\n    classDescription = \"SENSE_DISTANCE\";\n    break;\n  case 0x8f:\n    classDescription = \"SENSE_CO2\";\n    break;\n  default:\n    if (classId == 0xff) {\n      return \"CLASS_ANY\";\n    }\n  case '\\x01':\n  case '\\x02':\n  case '\\x03':\n  case '\\x04':\n  case '\\x05':\n  case '\\x06':\n  case '\\a':\n  case '\\b':\n  case '\\t':\n  case '\\n':\n  case '\\v':\n  case '\\f':\n  case '\\r':\n  case '\\x0e':\n  case '\\x0f':\n  case '\\x10':\n  case '\\x11':\n  case '\\x12':\n  case '\\x13':\n  case '\\x14':\n  case '\\x15':\n  case '\\x16':\n  case '\\x17':\n  case '\\x18':\n  case '\\x19':\n  case '\\x1a':\n  case '\\x1b':\n  case '\\x1c':\n  case '\\x1d':\n  case '\\x1e':\n  case '\\x1f':\n  case ' ':\n  case '!':\n  case '\\\"':\n  case '#':\n  case '$':\n  case '%':\n  case '&':\n  case '\\'':\n  case '(':\n  case ')':\n  case '*':\n  case '+':\n  case ',':\n  case '-':\n  case '.':\n  case '/':\n  case '0':\n  case '1':\n  case '2':\n  case '3':\n  case '4':\n  case '5':\n  case '6':\n  case '7':\n  case '8':\n  case '9':\n  case ':':\n  case ';':\n  case '<':\n  case '=':\n  case '>':\n  case '?':\n  case 'A':\n  case 'G':\n  case 'H':\n  case 'I':\n  case 'J':\n  case 'K':\n  case 'L':\n  case 'M':\n  case 'N':\n  case 'O':\n  case 'P':\n  case 'Q':\n  case 'R':\n  case 'S':\n  case 'T':\n  case 'U':\n  case 'V':\n  case 'W':\n  case 'X':\n  case 'Y':\n  case 'Z':\n  case '[':\n  case '\\':\n  case ']':\n  case '^':\n  case '_':\n  case '`':\n  case 'a':\n  case 'b':\n  case 'c':\n  case 'd':\n  case 'e':\n  case 'f':\n  case 'g':\n  case 'h':\n  case 'i':\n  case 'j':\n  case 'k':\n  case 'l':\n  case 'm':\n  case 'n':\n  case 'o':\n  case 'p':\n  case 'q':\n  case 'r':\n  case 's':\n  case 't':\n  case 'u':\n  case 'v':\n  case 'w':\n  case 'x':\n  case 'y':\n  case 'z':\n  case '{':\n  case '|':\n  case '}':\n  case '~':\n  case '\\x7f':\n    classDescription = \"CLASS_UNKNOWN\";\n  }\n  return classDescription;\n}\n\n",
            "renaming": {
                "FUN_000039e8": "get_class_description_000039e8",
                "class_id": "classId",
                "pcVar1": "classDescription",
                "class_id_local": "localClassId"
            },
            "calling": [
                "probe",
                "list"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003d24": {
            "entrypoint": "0x00003d24",
            "current_name": "get_saul_reg_by_position_00003d24",
            "code": "\nsaul_reg_t * getSaulRegByPosition_00003d24(iteratornt position)\n\n{\n  iteratornt localPosition;\n  iteratornt iterator;\n  saul_reg_t *currentSaulReg;\n  \n  iterator = 0;\n  for (currentSaulReg = saul_reg; (iterator < position && (currentSaulReg != (saul_reg_t *)0x0)); currentSaulReg = currentSaulReg->next) {\n    iterator = iterator + 1;\n  }\n  return currentSaulReg;\n}\n\n",
            "renaming": {
                "FUN_00003d24": "get_saul_reg_by_position_00003d24",
                "pos": "position",
                "pos_local": "localPosition",
                "i": "iterator",
                "tmp": "currentSaulReg"
            },
            "calling": [
                "write",
                "read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003d64": {
            "entrypoint": "0x00003d64",
            "current_name": "read_phy_data_00003d64",
            "code": "\nint read_phy_data_00003d64(saul_reg_t *sensor,phydat_t *data)\n\n{\n  int iVar1;\n  phydat_t *data_local;\n  saul_reg_t *sensor_local;\n  \n  if (sensor == (saul_reg_t *)0x0) {\n    iVar1 = -0x13;\n  }\n  else {\n    iVar1 = (*sensor->driver->read)(sensor->sensor,data);\n  }\n  return iVar1;\n}\n\n",
            "renaming": {
                "FUN_00003d64": "read_phy_data_00003d64",
                "dev": "sensor",
                "res": "data"
            },
            "calling": [
                "probe"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003d94": {
            "entrypoint": "0x00003d94",
            "current_name": "write_sensor_data_00003d94",
            "code": "\nint write_sensor_data_00003d94(saul_reg_t *sensor,phydat_t *sensor_data)\n\n{\n  int result;\n  phydat_t *local_sensor_data;\n  saul_reg_t *local_sensor;\n  \n  if (sensor == (saul_reg_t *)0x0) {\n    result = -0x13;\n  }\n  else {\n    result = (*sensor->driver->write)(sensor->sensor,sensor_data);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00003d94": "write_sensor_data_00003d94",
                "dev": "sensor",
                "data": "sensor_data",
                "iVar1": "result",
                "data_local": "local_sensor_data",
                "dev_local": "local_sensor"
            },
            "calling": [
                "write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003dc4": {
            "entrypoint": "0x00003dc4",
            "current_name": "calculate_number_length_00003dc4",
            "code": "\nsize_t calculateNumberLength_00003dc4(char *outputBuffer,uint32_t inputValue)\n\n{\n  uint32_t currentValue;\n  char *currentOutput;\n  char *currentPointer;\n  uint32_t temp;\n  size_t length;\n  \n  length = 1;\n  if (inputValue < 1000000000) {\n    for (temp = 10; temp <= inputValue; temp = temp * 10) {\n      length = length + 1;\n    }\n  }\n  else {\n    length = 10;\n  }\n  if (outputBuffer != (char *)0x0) {\n    currentPointer = outputBuffer + length;\n    currentValue = inputValue;\n    do {\n      currentPointer = currentPointer + -1;\n      *currentPointer = (char)(currentValue % 10) + '0';\n      currentValue = currentValue / 10;\n    } while (currentValue != 0);\n  }\n  return length;\n}\n\n",
            "renaming": {
                "FUN_00003dc4": "calculate_number_length_00003dc4",
                "out": "outputBuffer",
                "val": "inputValue",
                "val_local": "currentValue",
                "out_local": "currentOutput",
                "ptr": "currentPointer",
                "tmp": "temp",
                "len": "length"
            },
            "calling": [
                "fmt_s32_dec"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003e58": {
            "entrypoint": "0x00003e58",
            "current_name": "format_unsigned_integer_00003e58",
            "code": "\nsize_t format_unsigned_integer_00003e58(char *output_buffer,int32_t input_value)\n\n{\n  size_t formatted_length;\n  int32_t local_value;\n  char *local_output_buffer;\n  uint is_negative;\n  \n  local_value = input_value;\n  local_output_buffer = output_buffer;\n  if (-(input_value >> 0x1f) != 0) {\n    if (output_buffer != (char *)0x0) {\n      local_output_buffer = output_buffer + 1;\n      *output_buffer = '-';\n    }\n    local_value = -input_value;\n  }\n  formatted_length = fmt_u32_dec(local_output_buffer,local_value);\n  return -(input_value >> 0x1f) + formatted_length;\n}\n\n",
            "renaming": {
                "FUN_00003e58": "format_unsigned_integer_00003e58",
                "out": "output_buffer",
                "val": "input_value",
                "val_local": "local_value",
                "out_local": "local_output_buffer",
                "negative": "is_negative",
                "sVar1": "formatted_length"
            },
            "calling": [
                "fmt_s32_dfp"
            ],
            "called": [
                "fmt_u32_dec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003e9e": {
            "entrypoint": "0x00003e9e",
            "current_name": "format_s32_with_decimal_point_00003e9e",
            "code": "\nsize_t formatS32WithDecimalPoint_00003e9e(char *outputString,int16_t value,int decimalPointDigits)\n\n{\n  size_t formattedStringSize;\n  int decimalPointDigitsLocal;\n  int16_t valueLocal;\n  char *outputStringLocal;\n  \n  formattedStringSize = fmt_s32_dfp(outputString,(int)value,decimalPointDigits);\n  return formattedStringSize;\n}\n\n",
            "renaming": {
                "FUN_00003e9e": "format_s32_with_decimal_point_00003e9e",
                "out": "outputString",
                "val": "value",
                "fp_digits": "decimalPointDigits",
                "fp_digits_local": "decimalPointDigitsLocal",
                "val_local": "valueLocal",
                "out_local": "outputStringLocal",
                "sVar1": "formattedStringSize"
            },
            "calling": [
                "phydat_dump"
            ],
            "called": [
                "fmt_s32_dfp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003ec4": {
            "entrypoint": "0x00003ec4",
            "current_name": "format_floating_point_00003ec4",
            "code": "\nsize_t formatFloatingPoint_00003ec4(char *outputBuffer,int32_t value,int fractionalDigits)\n\n{\n  size_t sVar1;\n  uint valueDivided;\n  int posTemp;\n  int fractionalDigitsLocal;\n  int32_t valueLocal;\n  char *outputBufferLocal;\n  uint divisionLength;\n  int32_t absoluteValue;\n  uint32_t e;\n  int32_t divisionResult;\n  uint position;\n  \n  if (fractionalDigits + 7 < 0 != binaryOverflowCheck(fractionalDigits,7)) {\n                    \n    core_panic(assertionFailure,\"FAILED ASSERTION.\");\n  }\n  position = 0;\n  if (fractionalDigits == 0) {\n    position = fmt_s32_dec(outputBuffer,value);\n  }\n  else if (fractionalDigits < 1) {\n    valueDivided = (uint)value / tenMap[-fractionalDigits];\n    divisionResult = value - tenMap[-fractionalDigits] * valueDivided;\n    if (divisionResult < 0) {\n      divisionResult = -divisionResult;\n    }\n    if ((valueDivided == 0) && (value < 0)) {\n      if (outputBuffer != (char *)0x0) {\n        *outputBuffer = '-';\n      }\n      position = 1;\n    }\n    if (outputBuffer == (char *)0x0) {\n      sVar1 = fmt_s32_dec((char *)0x0,valueDivided);\n      position = sVar1 + 1 + position;\n    }\n    else {\n      sVar1 = fmt_s32_dec(outputBuffer + position,valueDivided);\n      posTemp = position + sVar1;\n      position = posTemp + 1;\n      outputBuffer[posTemp] = '.';\n      sVar1 = fmt_s32_dec(outputBuffer + position,divisionResult);\n      fmt_lpad(outputBuffer + position,sVar1,-fractionalDigits,'0');\n    }\n    position = -fractionalDigits + position;\n  }\n  else {\n    sVar1 = fmt_s32_dec(outputBuffer,value);\n    if (outputBuffer != (char *)0x0) {\n      memset(outputBuffer + sVar1,0x30,fractionalDigits);\n    }\n    position = fractionalDigits + sVar1;\n  }\n  return position;\n}\n\n",
            "renaming": {
                "FUN_00003ec4": "format_floating_point_00003ec4",
                "out": "outputBuffer",
                "val": "value",
                "fp_digits": "fractionalDigits",
                "val_00": "valueDivided",
                "iVar2": "posTemp",
                "fp_digits_local": "fractionalDigitsLocal",
                "val_local": "valueLocal",
                "out_local": "outputBufferLocal",
                "div_len": "divisionLength",
                "abs": "absoluteValue",
                "div": "divisionResult",
                "pos": "position",
                "SCARRY4": "binaryOverflowCheck",
                "_tenmap": "tenMap",
                "PANIC_ASSERT_FAIL": "assertionFailure"
            },
            "calling": [
                "fmt_s16_dfp"
            ],
            "called": [
                "core_panic",
                "fmt_s32_dec",
                "fmt_lpad",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003ff4": {
            "entrypoint": "0x00003ff4",
            "current_name": "pad_string_00003ff4",
            "code": "\nsize_t padString_00003ff4(char *output,size_t input_length,size_t padding_length,char padding_character)\n\n{\n  size_t size;\n  char local_padding_character;\n  size_t local_padding_length;\n  size_t local_input_length;\n  char *local_output;\n  size_t iterator;\n  \n  size = input_length;\n  if ((input_length < padding_length) && (size = padding_length, output != (char *)0x0)) {\n    memmove(output + (padding_length - input_length),output,input_length);\n    memset(output,(uiiteratort)(byte)padding_character,padding_length - input_length);\n  }\n  returiterator size;\n}\n\n",
            "renaming": {
                "FUN_00003ff4": "pad_string_00003ff4",
                "out": "output",
                "in_len": "input_length",
                "pad_len": "padding_length",
                "pad_char": "padding_character",
                "sVar1": "size",
                "pad_char_local": "local_padding_character",
                "pad_len_local": "local_padding_length",
                "in_len_local": "local_input_length",
                "out_local": "local_output",
                "n": "iterator"
            },
            "calling": [
                "fmt_s32_dfp"
            ],
            "called": [
                "memmove",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004042": {
            "entrypoint": "0x00004042",
            "current_name": "convert_string_to_int_00004042",
            "code": "\nint convertStringToInt_00004042(char *inputString)\n\n{\n  long result;\n  \n  result = strtol(inputString,(char **)0x0,10);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00004042": "convert_string_to_int_00004042",
                "__nptr": "inputString",
                "lVar1": "result"
            },
            "calling": [
                "write",
                "read"
            ],
            "called": [
                "strtol"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000404c": {
            "entrypoint": "0x0000404c",
            "current_name": "process_data_0000404c",
            "code": "\nundefined4 processData_0000404c(uint *dataPointer,int *infoPointer)\n\n{\n  int tempVar1;\n  int *tempVar2;\n  uint ushortValue;\n  ushort flagValue;\n  int tempVar3;\n  code *functionPointer;\n  int tempVar4;\n  uint originalValue;\n  bool isZero;\n  \n  flagValue = *(ushort *)(infoPointer + 3);\n  ushortValue = (uint)flagValue;\n  if ((int)(ushortValue << 0x1c) < 0) {\n    tempVar1 = infoPointer[4];\n    if (tempVar1 != 0) {\n      tempVar3 = ushortValue << 0x1e;\n      isZero = tempVar3 == 0;\n      tempVar4 = *infoPointer;\n      if (isZero) {\n        tempVar3 = infoPointer[5];\n      }\n      *infoPointer = tempVar1;\n      if (!isZero) {\n        tempVar3 = 0;\n      }\n      infoPointer[2] = tempVar3;\n      for (tempVar4 = tempVar4 - tempVar1; 0 < tempVar4; tempVar4 = tempVar4 - tempVar3) {\n        tempVar3 = (*(code *)infoPointer[10])(dataPointer,infoPointer[8],tempVar1,tempVar4);\n        if (tempVar3 < 1) {\n          *(ushort *)(infoPointer + 3) = *(ushort *)(infoPointer + 3) | 0x40;\n          return 0xffffffff;\n        }\n        tempVar1 = tempVar1 + tempVar3;\n      }\n    }\n  }\n  else {\n    if ((infoPointer[1] < 1) && (infoPointer[0x10] < 1)) {\n      return 0;\n    }\n    functionPointer = (code *)infoPointer[0xb];\n    if (functionPointer == (code *)0x0) {\n      return 0;\n    }\n    originalValue = *dataPointer;\n    *dataPointer = 0;\n    if ((flagValue & 0x1000) == 0) {\n      tempVar1 = (*functionPointer)(dataPointer,infoPointer[8],ushortValue & 0x1000,1);\n      if ((tempVar1 == -1) && (ushortValue = *dataPointer, ushortValue != 0)) {\n        if ((ushortValue == 0x1d) || (ushortValue == 0x16)) {\n          *dataPointer = originalValue;\n          return 0;\n        }\n        flagValue = *(ushort *)(infoPointer + 3);\n        goto LAB_00004104;\n      }\n    }\n    else {\n      tempVar1 = infoPointer[0x15];\n    }\n    if (((int)((uint)*(ushort *)(infoPointer + 3) << 0x1d) < 0) &&\n       (tempVar1 = tempVar1 - infoPointer[1], infoPointer[0xd] != 0)) {\n      tempVar1 = tempVar1 - infoPointer[0x10];\n    }\n    tempVar1 = (*(code *)infoPointer[0xb])(dataPointer,infoPointer[8],tempVar1,0);\n    flagValue = *(ushort *)(infoPointer + 3);\n    if ((tempVar1 == -1) &&\n       ((0x1d < *dataPointer || (-1 < (int)((0x20400001U >> (*dataPointer & 0xff)) << 0x1f))))) {\nLAB_00004104:\n      *(ushort *)(infoPointer + 3) = flagValue | 0x40;\n      return 0xffffffff;\n    }\n    infoPointer[1] = 0;\n    *infoPointer = infoPointer[4];\n    if (((int)((uint)flagValue << 0x13) < 0) && ((tempVar1 != -1 || (*dataPointer == 0)))) {\n      infoPointer[0x15] = tempVar1;\n    }\n    tempVar2 = (int *)infoPointer[0xd];\n    *dataPointer = originalValue;\n    if (tempVar2 != (int *)0x0) {\n      if (tempVar2 != infoPointer + 0x11) {\n        _free_r(dataPointer);\n      }\n      infoPointer[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000404c": "process_data_0000404c",
                "param_1": "dataPointer",
                "param_2": "infoPointer",
                "iVar1": "tempVar1",
                "piVar2": "tempVar2",
                "uVar3": "ushortValue",
                "uVar4": "flagValue",
                "iVar5": "tempVar3",
                "pcVar6": "functionPointer",
                "iVar7": "tempVar4",
                "uVar8": "originalValue",
                "bVar9": "isZero"
            },
            "calling": [
                "_fflush_r",
                "__srefill_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004158": {
            "entrypoint": "0x00004158",
            "current_name": "flush_and_release_lock_if_necessary_00004158",
            "code": "\nundefined4 flushAndReleaseLockIfNecessary_00004158(int inputStreamId,undefined4 *streamIndicator)\n\n{\n  undefined4 returnValue;\n  \n  if (streamIndicator[4] != 0) {\n    if ((inputStreamId != 0) && (*(int *)(inputStreamId + 0x18) == 0)) {\n      __sinit();\n    }\n    if (streamIndicator == &__sf_fake_stdin) {\n      streamIndicator = *(undefined4 **)(inputStreamId + 4);\n    }\n    else if (streamIndicator == (undefined4 *)&__sf_fake_stdout) {\n      streamIndicator = *(undefined4 **)(inputStreamId + 8);\n    }\n    else if (streamIndicator == (undefined4 *)&__sf_fake_stderr) {\n      streamIndicator = *(undefined4 **)(inputStreamId + 0xc);\n    }\n    if (*(short *)(streamIndicator + 3) != 0) {\n      if ((-1 < (int)(streamIndicator[0x19] << 0x1f)) && (-1 < (int)*(short *)(streamIndicator + 3) << 0x16)) {\n        __retarget_lock_acquire_recursive(streamIndicator[0x16]);\n      }\n      returnValue = __sflush_r(inputStreamId,streamIndicator);\n      if ((int)(streamIndicator[0x19] << 0x1f) < 0) {\n        return returnValue;\n      }\n      if ((int)((uint)*(ushort *)(streamIndicator + 3) << 0x16) < 0) {\n        return returnValue;\n      }\n      __retarget_lock_release_recursive(streamIndicator[0x16]);\n      return returnValue;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00004158": "flush_and_release_lock_if_necessary_00004158",
                "param_1": "inputStreamId",
                "param_2": "streamIndicator",
                "uVar1": "returnValue"
            },
            "calling": [
                "__swbuf_r",
                "fflush",
                "__srefill_r"
            ],
            "called": [
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__sflush_r",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000041d0": {
            "entrypoint": "0x000041d0",
            "current_name": "flush_file_000041d0",
            "code": "\nint flushFile_000041d0(FILE *file)\n\n{\n  int result;\n  \n  if (file == (FILE *)0x0) {\n    result = _fwalk_reent(&impure_data,0x4159);\n    return result;\n  }\n  result = _fflush_r(_impure_ptr,file);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000041d0": "flush_file_000041d0",
                "__stream": "file",
                "iVar1": "result"
            },
            "calling": [
                "lflush",
                "print_prompt"
            ],
            "called": [
                "_fwalk_reent",
                "_fflush_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000041f4": {
            "entrypoint": "0x000041f4",
            "current_name": "initialize_parameters_000041f4",
            "code": "\nvoid initializeParameters_000041f4(undefined4 *parameters,undefined2 value1,undefined2 value2)\n\n{\n  *parameters = 0;\n  parameters[1] = 0;\n  parameters[4] = 0;\n  parameters[5] = 0;\n  parameters[2] = 0;\n  *(undefined2 *)(parameters + 3) = value1;\n  parameters[0x19] = 0;\n  *(undefined2 *)((int)parameters + 0xe) = value2;\n  parameters[6] = 0;\n  memset(parameters + 0x17,0,8);\n  parameters[9] = 0x4dc9;\n  parameters[10] = 0x4def;\n  parameters[0xb] = 0x4e27;\n  parameters[8] = parameters;\n  parameters[0xc] = 0x4e4b;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000041f4": "initialize_parameters_000041f4",
                "param_1": "parameters",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000423c": {
            "entrypoint": "0x0000423c",
            "current_name": "execute_fwalk_reent_0000423c",
            "code": "\nvoid execute_fwalk_reent_0000423c(undefined4 input_param)\n\n{\n  call_fwalk_reent(input_param,0x4159);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000423c": "execute_fwalk_reent_0000423c",
                "param_1": "input_param",
                "_fwalk_reent": "call_fwalk_reent"
            },
            "calling": [],
            "called": [
                "_fwalk_reent"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004248": {
            "entrypoint": "0x00004248",
            "current_name": "initialize_memory_00004248",
            "code": "\nundefined4 * initializeMemory_00004248(undefined4 size,int numElements)\n\n{\n  undefined4 *memoryBlock;\n  int totalSize;\n  \n  totalSize = (numElements + -1) * 0x68;\n  memoryBlock = (undefined4 *)_malloc_r(size,totalSize + 0x74);\n  if (memoryBlock != (undefined4 *)0x0) {\n    *memoryBlock = 0;\n    memoryBlock[1] = numElements;\n    memoryBlock[2] = memoryBlock + 3;\n    memset(memoryBlock + 3,0,totalSize + 0x68);\n  }\n  return memoryBlock;\n}\n\n",
            "renaming": {
                "FUN_00004248": "initialize_memory_00004248",
                "param_1": "size",
                "param_2": "numElements",
                "puVar1": "memoryBlock",
                "iVar2": "totalSize"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "_malloc_r",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004274": {
            "entrypoint": "0x00004274",
            "current_name": "acquire_recursive_lock_00004274",
            "code": "\nvoid acquireRecursiveLock_00004274(void)\n\n{\n  __retarget_lock_acquire_recursive(&recursiveLock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004274": "acquire_recursive_lock_00004274",
                "__lock___sfp_recursive_mutex": "recursiveLock"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004280": {
            "entrypoint": "0x00004280",
            "current_name": "release_sfp_recursive_mutex_00004280",
            "code": "\nvoid releaseSfpRecursiveMutex_00004280(void)\n\n{\n  releaseRecursiveLock(&sfpRecursiveMutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004280": "release_sfp_recursive_mutex_00004280",
                "__retarget_lock_release_recursive": "releaseRecursiveLock",
                "__lock___sfp_recursive_mutex": "sfpRecursiveMutex"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000428c": {
            "entrypoint": "0x0000428c",
            "current_name": "acquire_lock_recursive_0000428c",
            "code": "\nvoid acquireLockRecursive_0000428c(void)\n\n{\n  __retarget_lock_acquire_recursive(&lock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000428c": "acquire_lock_recursive_0000428c",
                "__lock___sinit_recursive_mutex": "lock"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004298": {
            "entrypoint": "0x00004298",
            "current_name": "release_recursive_mutex_00004298",
            "code": "\nvoid releaseRecursiveMutex_00004298(void)\n\n{\n  __retarget_lock_release_recursive(&__sinit_recursive_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004298": "release_recursive_mutex_00004298",
                "__lock___sinit_recursive_mutex": "__sinit_recursive_mutex"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000042a4": {
            "entrypoint": "0x000042a4",
            "current_name": "initialize_data_000042a4",
            "code": "\nvoid initializeData_000042a4(undefined1 *data)\n\n{\n  undefined4 result;\n  undefined1 *pointer;\n  \n  acquireLock();\n  if (*(int *)(data + 0x18) == 0) {\n    *(undefined4 *)(data + 0x48) = 0;\n    *(undefined4 *)(data + 0x4c) = 0;\n    *(undefined4 *)(data + 0x50) = 0;\n    pointer = &impureData;\n    *(undefined4 *)(data + 0x28) = 0x423d;\n    if (data == &impureData) {\n      pointer = (undefined1 *)0x1;\n    }\n    if (data == &impureData) {\n      *(undefined1 **)(data + 0x18) = pointer;\n    }\n    result = getPointer(data);\n    *(undefined4 *)(data + 4) = result;\n    result = getPointer(data);\n    *(undefined4 *)(data + 8) = result;\n    result = getPointer(data);\n    *(undefined4 *)(data + 0xc) = result;\n    setPointer(*(undefined4 *)(data + 4),4,0);\n    setPointer(*(undefined4 *)(data + 8),9,1);\n    setPointer(*(undefined4 *)(data + 0xc),0x12,2);\n    *(undefined4 *)(data + 0x18) = 1;\n  }\n  releaseLock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000042a4": "initialize_data_000042a4",
                "param_1": "data",
                "uVar1": "result",
                "puVar2": "pointer",
                "__sinit_lock_acquire": "acquireLock",
                "__sinit_lock_release": "releaseLock",
                "impure_data": "impureData",
                "__sfp": "getPointer",
                "std": "setPointer"
            },
            "calling": [
                "__sfp",
                "_fflush_r",
                "_puts_r",
                "iprintf",
                "_putc_r",
                "_getc_r",
                "__srefill_r",
                "putchar",
                "__swbuf_r",
                "getchar",
                "__srget_r",
                "_vfprintf_r",
                "__swsetup_r"
            ],
            "called": [
                "__sfp",
                "std",
                "__sinit_lock_acquire",
                "__sinit_lock_release"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004314": {
            "entrypoint": "0x00004314",
            "current_name": "initialize_config_00004314",
            "code": "\nint * initializeConfig_00004314(undefined4 *configParams)\n\n{\n  int *currentEntry;\n  int *currentConfig;\n  int **configList;\n  \n  __sfp_lock_acquire();\n  if (DAT_1fff029c == 0) {\n    __sinit(&impure_data);\n  }\n  configList = (int **)&DAT_1fff02cc;\n  do {\n    currentEntry = configList[1];\n    currentConfig = configList[2];\n    while (currentEntry = (int *)((int)currentEntry + -1), -1 < (int)currentEntry) {\n      if (*(short *)(currentConfig + 3) == 0) {\n        currentConfig[3] = -0xffff;\n        currentConfig[0x19] = 0;\n        __retarget_lock_init_recursive(currentConfig + 0x16);\n        __sfp_lock_release();\n        currentConfig[1] = 0;\n        currentConfig[2] = 0;\n        currentConfig[4] = 0;\n        currentConfig[5] = 0;\n        *currentConfig = 0;\n        currentConfig[6] = 0;\n        memset(currentConfig + 0x17,0,8);\n        currentConfig[0xd] = 0;\n        currentConfig[0xe] = 0;\n        currentConfig[0x12] = 0;\n        currentConfig[0x13] = 0;\n        return currentConfig;\n      }\n      currentConfig = currentConfig + 0x1a;\n    }\n    if (*configList == (int *)0x0) {\n      currentEntry = (int *)__sfmoreglue(configParams,4);\n      *configList = currentEntry;\n      if (currentEntry == (int *)0x0) {\n        __sfp_lock_release();\n        *configParams = 0xc;\n        return (int *)0x0;\n      }\n    }\n    configList = (int **)*configList;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00004314": "initialize_config_00004314",
                "param_1": "configParams",
                "piVar1": "currentEntry",
                "piVar2": "currentConfig",
                "ppiVar3": "configList"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__sfmoreglue",
                "__sfp_lock_acquire",
                "__sinit",
                "__sfp_lock_release",
                "__retarget_lock_init_recursive",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000043a0": {
            "entrypoint": "0x000043a0",
            "current_name": "process_data_000043a0",
            "code": "\nuint processData_000043a0(int inputSize,code *callback)\n\n{\n  uint callbackResult;\n  int *dataPointer;\n  int innerCount;\n  uint result;\n  int innerIndex;\n  \n  dataPointer = (int *)(inputSize + 0x48);\n  result = 0;\n  do {\n    innerIndex = dataPointer[1];\n    innerCount = dataPointer[2];\n    while (innerIndex = innerIndex + -1, -1 < innerIndex) {\n      if ((1 < *(ushort *)(innerCount + 0xc)) && (*(short *)(innerCount + 0xe) != -1)) {\n        callbackResult = (*callback)(innerCount);\n        result = result | callbackResult;\n      }\n      innerCount = innerCount + 0x68;\n    }\n    dataPointer = (int *)*dataPointer;\n  } while (dataPointer != (int *)0x0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000043a0": "process_data_000043a0",
                "param_1": "inputSize",
                "param_2": "callback",
                "piVar2": "dataPointer",
                "iVar3": "innerCount",
                "uVar4": "result",
                "iVar5": "innerIndex",
                "uVar1": "callbackResult"
            },
            "calling": [
                "__srefill_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000043da": {
            "entrypoint": "0x000043da",
            "current_name": "process_data_000043da",
            "code": "\nuint processData_000043da(int input,code *callback,undefined4 param3,undefined4 param4)\n\n{\n  uint result;\n  int elementCount;\n  int *ptrToCurrentElement;\n  int ptrToCurrentItem;\n  uint combinedResult;\n  int remainingCount;\n  \n  ptrToCurrentElement = (int *)(input + 0x48);\n  combinedResult = 0;\n  do {\n    remainingCount = ptrToCurrentElement[1];\n    ptrToCurrentItem = ptrToCurrentElement[2];\n    while (remainingCount = remainingCount + -1, -1 < remainingCount) {\n      if ((1 < *(ushort *)(ptrToCurrentItem + 0xc)) && (elementCount = *(short *)(ptrToCurrentItem + 0xe) + 1, elementCount != 0)) {\n        result = (*callback)(input,ptrToCurrentItem,param3,elementCount,param4);\n        combinedResult = combinedResult | result;\n      }\n      ptrToCurrentItem = ptrToCurrentItem + 0x68;\n    }\n    ptrToCurrentElement = (int *)*ptrToCurrentElement;\n  } while (ptrToCurrentElement != (int *)0x0);\n  return combinedResult;\n}\n\n",
            "renaming": {
                "FUN_000043da": "process_data_000043da",
                "param_1": "input",
                "param_2": "callback",
                "param_3": "param3",
                "param_4": "param4",
                "piVar3": "ptrToCurrentElement",
                "iVar2": "elementCount",
                "iVar4": "ptrToCurrentItem",
                "uVar1": "result",
                "uVar5": "combinedResult",
                "iVar6": "remainingCount"
            },
            "calling": [
                "_cleanup_r",
                "fflush"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004418": {
            "entrypoint": "0x00004418",
            "current_name": "read_character_00004418",
            "code": "\n\n\nint readCharacter_00004418(void)\n\n{\n  int currentPointer;\n  \n  currentPointer = pointerToImpure;\n  if ((pointerToImpure != 0) && (*(int *)(pointerToImpure + 0x18) == 0)) {\n    initializeStream(pointerToImpure);\n  }\n  currentPointer = getCharFromFile(currentPointer,*(undefined4 *)(currentPointer + 4));\n  return currentPointer;\n}\n\n",
            "renaming": {
                "FUN_00004418": "read_character_00004418",
                "iVar1": "currentPointer",
                "_impure_ptr": "pointerToImpure",
                "__sinit": "initializeStream",
                "_getc_r": "getCharFromFile"
            },
            "calling": [
                "readline"
            ],
            "called": [
                "__sinit",
                "_getc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000443c": {
            "entrypoint": "0x0000443c",
            "current_name": "calculate_date_time_0000443c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000044a8) */\n\ntm * calculateDateTime_0000443c(time_t *timer,tm *dateTime)\n\n{\n  int result1;\n  uint result2;\n  uint days;\n  uint leapYearDays;\n  int yearDayOffset;\n  uint years;\n  time_t time;\n  time_t prevTime;\n  uint month;\n  bool isNegative;\n  \n  time = *timer;\n  prevTime = timer[1];\n  result1 = __aeabi_ldivmod(time,prevTime,0x15180,0);\n  days = 0x15180;\n  __aeabi_ldivmod(time,prevTime,0x15180,0);\n  isNegative = (int)days < 0;\n  if (isNegative) {\n    days = days + 0x15180;\n  }\n  if (isNegative) {\n    result2 = result1 + 0xafa6b;\n  }\n  else {\n    result2 = result1 + 0xafa6c;\n  }\n  dateTime->tm_hour = days / 0xe10;\n  dateTime->tm_min = (days % 0xe10) / 0x3c;\n  dateTime->tm_sec = (days % 0xe10) % 0x3c;\n  dateTime->tm_wday = (result2 + 3) % 7;\n  days = result2;\n  if ((int)result2 < 0) {\n    days = result2 - 0x23ab0;\n  }\n  result2 = (days / 0x23ab1) * -0x23ab1 + result2;\n  leapYearDays = ((result2 / 0x8eac + result2) - result2 / 0x5b4) - result2 / 0x23ab0;\n  years = leapYearDays / 0x16d;\n  result2 = (years / 100 - leapYearDays / 0x5b4) + result2 + years * -0x16d;\n  month = result2 * 5 + 2;\n  leapYearDays = month / 0x99;\n  if (month < 0x5fa) {\n    result1 = 2;\n  }\n  else {\n    result1 = -10;\n  }\n  month = leapYearDays + result1;\n  result1 = (days / 0x23ab1) * 400 + years;\n  if (month < 2) {\n    result1 = result1 + 1;\n  }\n  if (result2 < 0x132) {\n    if (((years & 3) == 0) && (years != (years / 100) * 100)) {\n      days = 1;\n    }\n    else {\n      days = (uint)(years % 400 == 0);\n    }\n    yearDayOffset = result2 + 0x3b + days;\n  }\n  else {\n    yearDayOffset = result2 - 0x132;\n  }\n  dateTime->tm_yday = yearDayOffset;\n  dateTime->tm_mday = (result2 + 1) - (leapYearDays * 0x99 + 2) / 5;\n  dateTime->tm_mon = month;\n  dateTime->tm_year = result1 + -0x76c;\n  dateTime->tm_isdst = 0;\n  return dateTime;\n}\n\n",
            "renaming": {
                "FUN_0000443c": "calculate_date_time_0000443c",
                "__timer": "timer",
                "__tp": "dateTime",
                "iVar1": "result1",
                "uVar2": "result2",
                "uVar3": "days",
                "uVar4": "leapYearDays",
                "iVar5": "yearDayOffset",
                "uVar6": "years",
                "tVar7": "time",
                "tVar8": "prevTime",
                "uVar9": "month",
                "bVar10": "isNegative"
            },
            "calling": [
                "rtc_get_alarm",
                "rtc_get_time"
            ],
            "called": [
                "__aeabi_ldivmod"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000459c": {
            "entrypoint": "0x0000459c",
            "current_name": "initialize_and_finalize_0000459c",
            "code": "\nvoid initialize_and_finalize_0000459c(EVP_PKEY_CTX *ctx)\n\n{\n  code **code_ptr;\n  int iterator;\n  \n  code_ptr = (code **)&__fini_array_end;\n  for (iterator = 0; iterator != 0; iterator = iterator + 1) {\n    ctx = (EVP_PKEY_CTX *)(**code_ptr)();\n    code_ptr = code_ptr + 1;\n  }\n  _init(ctx);\n  code_ptr = (code **)&__fini_array_end;\n  for (iterator = 0; iterator != 0; iterator = iterator + 1) {\n    (**code_ptr)();\n    code_ptr = code_ptr + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000459c": "initialize_and_finalize_0000459c",
                "param_1": "ctx",
                "ppcVar1": "code_ptr",
                "iVar2": "iterator"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000045e4": {
            "entrypoint": "0x000045e4",
            "current_name": "FUNC_000045e4",
            "code": "\nvoid FUNC_000045e4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045e4": "FUNC_000045e4"
            },
            "calling": [
                "__sfp"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045e6": {
            "entrypoint": "0x000045e6",
            "current_name": "FUNC_000045e6",
            "code": "\nvoid FUNC_000045e6(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045e6": "FUNC_000045e6"
            },
            "calling": [
                "__tz_lock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045e8": {
            "entrypoint": "0x000045e8",
            "current_name": "FUNC_000045e8",
            "code": "\nvoid FUNC_000045e8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045e8": "FUNC_000045e8"
            },
            "calling": [
                "__env_lock",
                "_fflush_r",
                "__sfp_lock_acquire",
                "__malloc_lock",
                "_puts_r",
                "_vfprintf_r",
                "__sinit_lock_acquire",
                "_putc_r",
                "_getc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045ea": {
            "entrypoint": "0x000045ea",
            "current_name": "FUNC_000045ea",
            "code": "\nvoid FUNC_000045ea(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045ea": "FUNC_000045ea"
            },
            "calling": [
                "__tz_unlock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045ec": {
            "entrypoint": "0x000045ec",
            "current_name": "FUNC_000045ec",
            "code": "\nvoid FUNC_000045ec(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045ec": "FUNC_000045ec"
            },
            "calling": [
                "_fflush_r",
                "_puts_r",
                "__sfp_lock_release",
                "__malloc_unlock",
                "_vfprintf_r",
                "_putc_r",
                "__env_unlock",
                "_getc_r",
                "__sinit_lock_release"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045ee": {
            "entrypoint": "0x000045ee",
            "current_name": "copy_memory_000045ee",
            "code": "\nvoid * copy_memory_000045ee(void *destination,void *source,size_t size)\n\n{\n  undefined *dest_ptr;\n  undefined *src_ptr;\n  \n  src_ptr = (undefined *)((int)source + size);\n  if ((source < destination) && (destination < src_ptr)) {\n    dest_ptr = (undefined *)(size + (int)destination);\n    while (dest_ptr != (undefined *)destination) {\n      src_ptr = src_ptr + -1;\n      dest_ptr = dest_ptr + -1;\n      *dest_ptr = *src_ptr;\n    }\n  }\n  else {\n    dest_ptr = (undefined *)((int)destination + -1);\n    for (; (undefined *)source != src_ptr; source = (void *)((int)source + 1)) {\n      dest_ptr = dest_ptr + 1;\n      *dest_ptr = *source;\n                    /* WARNING: Load size is inaccurate */\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_000045ee": "copy_memory_000045ee",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr"
            },
            "calling": [
                "fmt_lpad"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004622": {
            "entrypoint": "0x00004622",
            "current_name": "memset_00004622",
            "code": "\nvoid * memset_00004622(void *dest,int ch,size_t count)\n\n{\n  undefined *ptr;\n  \n  for (ptr = (undefined *)dest; ptr != (undefined *)(count + (int)dest); ptr = ptr + 1) {\n    *ptr = (char)ch;\n  }\n  return dest;\n}\n\n",
            "renaming": {
                "FUN_00004622": "memset_00004622",
                "__s": "dest",
                "__c": "ch",
                "__n": "count",
                "puVar1": "ptr"
            },
            "calling": [
                "__sfmoreglue",
                "__sfp",
                "std",
                "fmt_lpad",
                "write",
                "fmt_s32_dfp"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004634": {
            "entrypoint": "0x00004634",
            "current_name": "update_date_00004634",
            "code": "\nvoid updateDate_00004634(uint *date,uint daysToAdd,undefined4 isLeapYear)\n\n{\n  int daysInMonth;\n  uint day;\n  uint year;\n  int daysInYear;\n  bool isNegative;\n  uint *quotient;\n  uint remainder;\n  undefined4 leapYearFlag;\n  \n  quotient = date;\n  remainder = daysToAdd;\n  leapYearFlag = isLeapYear;\n  if (0x3b < *date) {\n    div((int)&quotient,*date);\n    day = date[1] + (int)quotient;\n    date[1] = day;\n    if ((int)remainder < 0) {\n      day = day - 1;\n      *date = remainder + 0x3c;\n    }\n    else {\n      *date = remainder;\n    }\n    if ((int)remainder < 0) {\n      date[1] = day;\n    }\n  }\n  if (0x3b < date[1]) {\n    div((int)&quotient,date[1]);\n    isNegative = (int)remainder < 0;\n    year = date[2] + (int)quotient;\n    date[2] = year;\n    day = remainder;\n    if (isNegative) {\n      day = remainder + 0x3c;\n      year = year - 1;\n    }\n    if (!isNegative) {\n      date[1] = day;\n    }\n    if (isNegative) {\n      date[1] = day;\n    }\n    if (isNegative) {\n      date[2] = year;\n    }\n  }\n  if (0x17 < date[2]) {\n    div((int)&quotient,date[2]);\n    isNegative = (int)remainder < 0;\n    year = date[3] + (int)quotient;\n    date[3] = year;\n    day = remainder;\n    if (isNegative) {\n      day = remainder + 0x18;\n      year = year - 1;\n    }\n    if (!isNegative) {\n      date[2] = day;\n    }\n    if (isNegative) {\n      date[2] = day;\n    }\n    if (isNegative) {\n      date[3] = year;\n    }\n  }\n  if (0xb < date[4]) {\n    div((int)&quotient,date[4]);\n    isNegative = (int)remainder < 0;\n    day = date[5] + (int)quotient;\n    date[5] = day;\n    if (isNegative) {\n      remainder = remainder + 0xc;\n      day = day - 1;\n    }\n    if (!isNegative) {\n      date[4] = remainder;\n    }\n    if (isNegative) {\n      date[4] = remainder;\n    }\n    if (isNegative) {\n      date[5] = day;\n    }\n  }\n  day = date[5];\n  if ((day & 3) == 0) {\n    if (day == (day / 100) * 100) {\n      if ((day + 0x76c) % 400 == 0) {\n        daysInYear = 0x1d;\n      }\n      else {\n        daysInYear = 0x1c;\n      }\n    }\n    else {\n      daysInYear = 0x1d;\n    }\n  }\n  else {\n    daysInYear = 0x1c;\n  }\n  if ((int)date[3] < 1) {\n    while ((int)date[3] < 1) {\n      day = date[4];\n      date[4] = day - 1;\n      if (day - 1 == 0xffffffff) {\n        year = date[5];\n        day = year - 1;\n        date[4] = 0xb;\n        date[5] = day;\n        if ((day & 3) == 0) {\n          if (day == (day / 100) * 100) {\n            if ((year + 0x76b) % 400 == 0) {\n              daysInYear = 0x1d;\n            }\n            else {\n              daysInYear = 0x1c;\n            }\n          }\n          else {\n            daysInYear = 0x1d;\n          }\n        }\n        else {\n          daysInYear = 0x1c;\n        }\n      }\n      daysInMonth = daysInYear;\n      if (date[4] != 1) {\n        daysInMonth = *(int *)(&DAYS_IN_MONTH + date[4] * 4);\n      }\n      date[3] = daysInMonth + date[3];\n    }\n  }\n  else {\n    while( true ) {\n      day = date[4];\n      daysInMonth = daysInYear;\n      if (day != 1) {\n        daysInMonth = *(int *)(&DAYS_IN_MONTH + day * 4);\n      }\n      if ((int)date[3] <= daysInMonth) break;\n      date[3] = date[3] - daysInMonth;\n      date[4] = day + 1;\n      if (day + 1 == 0xc) {\n        year = date[5];\n        day = year + 1;\n        date[4] = 0;\n        date[5] = day;\n        if ((day & 3) == 0) {\n          if (day % 100 == 0) {\n            if ((year + 0x76d) % 400 == 0) {\n              daysInYear = 0x1d;\n            }\n            else {\n              daysInYear = 0x1c;\n            }\n          }\n          else {\n            daysInYear = 0x1d;\n          }\n        }\n        else {\n          daysInYear = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004634": "update_date_00004634",
                "param_1": "date",
                "param_2": "daysToAdd",
                "param_3": "isLeapYear",
                "iVar1": "daysInMonth",
                "uVar2": "day",
                "uVar3": "year",
                "iVar4": "daysInYear",
                "bVar5": "isNegative",
                "local_20": "quotient",
                "local_1c": "remainder",
                "uStack_18": "leapYearFlag"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "div"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000047e4": {
            "entrypoint": "0x000047e4",
            "current_name": "calculate_time_000047e4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\ntime_t calculateTime_000047e4(tm *timeStruct)\n\n{\n  longlong totalSeconds;\n  int *timezoneInfo;\n  uint daysBeforeMonth;\n  int yearDivided100;\n  int daysInYear;\n  int daysInLeapYear;\n  uint currentDaysInYear;\n  uint currentYear;\n  uint previousDaysInYear;\n  int currentDayOfYear;\n  uint currentYear;\n  uint isDaylightSaving;\n  uint isDaylightSavingCopy;\n  uint currentSeconds;\n  time_t resultTime;\n  bool isPreviousYearLastLeapYear;\n  \n  timezoneInfo = (int *)__gettzinfo();\n  validate_structure(timeStruct);\n  currentYear = timeStruct->tm_year;\n  currentDayOfYear = timeStruct->tm_mday + -1 + *(int *)(&_DAYS_BEFORE_MONTH + timeStruct->tm_mon * 4);\n  if (((1 < timeStruct->tm_mon) && ((currentYear & 3) == 0)) &&\n     ((currentYear != (currentYear / 100) * 100 || (currentYear + 0x76c == ((currentYear + 0x76c) / 400) * 400)))) {\n    currentDayOfYear = currentDayOfYear + 1;\n  }\n  timeStruct->tm_yday = currentDayOfYear;\n  if (20000 < (int)&DAT_00002710 + currentYear) {\n    return -1;\n  }\n  if ((int)currentYear < 0x47) {\n    if (currentYear != 0x46) {\n      for (currentYear = 0x45; (int)currentYear < (int)currentYear; currentYear = currentYear - 1) {\n        if ((currentYear & 3) == 0) {\n          if (currentYear == (currentYear / 100) * 100) {\n            if ((currentYear + 0x76c) % 400 == 0) {\n              daysInLeapYear = 0x16e;\n            }\n            else {\n              daysInLeapYear = 0x16d;\n            }\n          }\n          else {\n            daysInLeapYear = 0x16e;\n          }\n        }\n        else {\n          daysInLeapYear = 0x16d;\n        }\n        currentDayOfYear = currentDayOfYear - daysInLeapYear;\n      }\n      if ((currentYear & 3) == 0) {\n        if (currentYear == (currentYear / 100) * 100) {\n          daysInLeapYear = 0x16d;\n          if ((currentYear + 0x76c) % 400 == 0) {\n            daysInLeapYear = 0x16e;\n          }\n        }\n        else {\n          daysInLeapYear = 0x16e;\n        }\n      }\n      else {\n        daysInLeapYear = 0x16d;\n      }\n      currentDayOfYear = currentDayOfYear - daysInLeapYear;\n    }\n  }\n  else {\n    currentYear = 0x46;\n    do {\n      if ((currentYear & 3) == 0) {\n        if (currentYear % 100 == 0) {\n          if ((currentYear + 0x76c) % 400 == 0) {\n            daysInLeapYear = 0x16e;\n          }\n          else {\n            daysInLeapYear = 0x16d;\n          }\n        }\n        else {\n          daysInLeapYear = 0x16e;\n        }\n      }\n      else {\n        daysInLeapYear = 0x16d;\n      }\n      currentYear = currentYear + 1;\n      currentDayOfYear = currentDayOfYear + daysInLeapYear;\n    } while (currentYear != currentYear);\n  }\n  totalSeconds = (longlong)currentDayOfYear * 0x15180 +\n          (longlong)(timeStruct->tm_hour * 0xe10 + timeStruct->tm_min * 0x3c + timeStruct->tm_sec);\n  currentSeconds = (uint)totalSeconds;\n  daysInLeapYear = (int)((ulonglong)totalSeconds >> 0x20);\n  __tz_lock();\n  updateTimezone();\n  currentYear = daylightFlag;\n  if (daylightFlag == 0) {\nLAB_00004934:\n    resultTime = currentSeconds + timezoneInfo[10];\n  }\n  else {\n    isDaylightSavingCopy = timeStruct->tm_isdst;\n    isDaylightSaving = isDaylightSavingCopy;\n    if (0 < (int)isDaylightSavingCopy) {\n      isDaylightSaving = 1;\n    }\n    if ((timezoneInfo[1] == timeStruct->tm_year + 0x76c) || (yearDivided100 = __tzcalc_limits(), yearDivided100 != 0)) {\n      previousDaysInYear = timezoneInfo[0x14];\n      daysBeforeMonth = timezoneInfo[0x12];\n      currentDaysInYear = timezoneInfo[10];\n      currentYear = daysBeforeMonth - currentDaysInYear;\n      yearDivided100 = (timezoneInfo[0x13] - ((int)currentDaysInYear >> 0x1f)) - (uint)(daysBeforeMonth < currentDaysInYear);\n      if (((int)((daysInLeapYear - yearDivided100) - (uint)(currentSeconds < currentYear)) < 0 ==\n           (SBORROW4(daysInLeapYear,yearDivided100) != SBORROW4(daysInLeapYear - yearDivided100,(uint)(currentSeconds < currentYear)))) &&\n         (daysInYear = (timezoneInfo[0x13] - ((int)previousDaysInYear >> 0x1f)) - (uint)(daysBeforeMonth < previousDaysInYear),\n         isPreviousYearLastLeapYear = currentSeconds < daysBeforeMonth - previousDaysInYear,\n         (int)((daysInLeapYear - daysInYear) - (uint)isPreviousYearLastLeapYear) < 0 !=\n         (SBORROW4(daysInLeapYear,daysInYear) != SBORROW4(daysInLeapYear - daysInYear,(uint)isPreviousYearLastLeapYear)))) goto LAB_00004a88;\n      daysBeforeMonth = timezoneInfo[8] - previousDaysInYear;\n      daysInYear = (timezoneInfo[9] - ((int)previousDaysInYear >> 0x1f)) - (uint)((uint)timezoneInfo[8] < previousDaysInYear);\n      if (*timezoneInfo != 0) {\n        if ((int)((daysInLeapYear - daysInYear) - (uint)(currentSeconds < daysBeforeMonth)) < 0 ==\n            (SBORROW4(daysInLeapYear,daysInYear) != SBORROW4(daysInLeapYear - daysInYear,(uint)(currentSeconds < daysBeforeMonth))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        currentYear = 0;\n        if ((int)isDaylightSavingCopy < 0) goto LAB_00004934;\nLAB_00004a14:\n        isDaylightSavingCopy = isDaylightSaving ^ currentYear;\n        isDaylightSaving = currentYear;\n        if (isDaylightSavingCopy == 1) {\n          if (currentYear == 0) {\n            daysInLeapYear = previousDaysInYear - currentDaysInYear;\n          }\n          else {\n            daysInLeapYear = currentDaysInYear - previousDaysInYear;\n          }\n          yearDivided100 = timeStruct->tm_mday;\n          currentSeconds = currentSeconds + daysInLeapYear;\n          timeStruct->tm_sec = timeStruct->tm_sec + daysInLeapYear;\n          validate_structure(timeStruct);\n          yearDivided100 = timeStruct->tm_mday - yearDivided100;\n          if (yearDivided100 != 0) {\n            if (yearDivided100 < 2) {\n              if (yearDivided100 == -2 || yearDivided100 + 2 < 0 != SCARRY4(yearDivided100,2)) {\n                yearDivided100 = 1;\n              }\n            }\n            else {\n              yearDivided100 = -1;\n            }\n            daysInLeapYear = yearDivided100 + timeStruct->tm_yday;\n            currentDayOfYear = currentDayOfYear + yearDivided100;\n            if (daysInLeapYear < 0) {\n              currentYear = currentYear - 1;\n              if ((currentYear & 3) == 0) {\n                if (currentYear == (currentYear / 100) * 100) {\n                  daysInLeapYear = 0x16d;\n                  if ((currentYear + 0x76b) % 400 != 0) {\n                    daysInLeapYear = 0x16c;\n                  }\n                }\n                else {\n                  daysInLeapYear = 0x16d;\n                }\n              }\n              else {\n                daysInLeapYear = 0x16c;\n              }\n            }\n            else {\n              if ((currentYear & 3) == 0) {\n                if (currentYear == (currentYear / 100) * 100) {\n                  yearDivided100 = 0x16d;\n                  if ((currentYear + 0x76c) % 400 == 0) {\n                    yearDivided100 = 0x16e;\n                  }\n                }\n                else {\n                  yearDivided100 = 0x16e;\n                }\n              }\n              else {\n                yearDivided100 = 0x16d;\n              }\n              if (yearDivided100 <= daysInLeapYear) {\n                daysInLeapYear = daysInLeapYear - yearDivided100;\n              }\n            }\n            timeStruct->tm_yday = daysInLeapYear;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((daysInLeapYear - daysInYear) - (uint)(currentSeconds < daysBeforeMonth)) < 0 !=\n          (SBORROW4(daysInLeapYear,daysInYear) != SBORROW4(daysInLeapYear - daysInYear,(uint)(currentSeconds < daysBeforeMonth)))) {\nLAB_0000491e:\n        if ((int)((daysInLeapYear - yearDivided100) - (uint)(currentSeconds < currentYear)) < 0 ==\n            (SBORROW4(daysInLeapYear,yearDivided100) != SBORROW4(daysInLeapYear - yearDivided100,(uint)(currentSeconds < currentYear))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)isDaylightSavingCopy) {\n        currentYear = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      currentYear = isDaylightSaving;\n      if (isDaylightSaving != 1) goto LAB_00004934;\n    }\n    resultTime = currentSeconds + timezoneInfo[0x14];\n    currentYear = 1;\n  }\n  __tz_unlock();\n  timeStruct->tm_isdst = currentYear;\n  timeStruct->tm_wday = (currentDayOfYear + 4U) % 7;\n  return resultTime;\n}\n\n",
            "renaming": {
                "FUN_000047e4": "calculate_time_000047e4",
                "__tp": "timeStruct",
                "lVar1": "totalSeconds",
                "piVar2": "timezoneInfo",
                "uVar3": "daysBeforeMonth",
                "iVar4": "yearDivided100",
                "iVar5": "daysInYear",
                "iVar6": "daysInLeapYear",
                "uVar7": "currentDaysInYear",
                "uVar8": "currentYear",
                "uVar9": "previousDaysInYear",
                "iVar10": "currentDayOfYear",
                "uVar11": "currentYear",
                "uVar12": "isDaylightSaving",
                "uVar13": "isDaylightSavingCopy",
                "uVar14": "currentSeconds",
                "tVar15": "resultTime",
                "bVar16": "isPreviousYearLastLeapYear",
                "_tzset_unlocked": "updateTimezone",
                "_daylight": "daylightFlag"
            },
            "calling": [
                "rtc_set_alarm",
                "rtc_set_time"
            ],
            "called": [
                "_tzset_unlocked",
                "validate_structure",
                "__tz_lock",
                "__gettzinfo",
                "__tz_unlock",
                "__tzcalc_limits"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004b34": {
            "entrypoint": "0x00004b34",
            "current_name": "allocate_memory_00004b34",
            "code": "\nvoid allocateMemory_00004b34(undefined4 *result,int size,undefined4 freeListPtr,undefined4 lock)\n\n{\n  int *currentBlockOffset;\n  int **nextBlockOffsetPtr;\n  int **currentBlockPtr;\n  int **previousBlockPtr;\n  int **currentFreeBlockPtr;\n  int **newFreeBlockPtr;\n  bool isSameFreeBlock;\n  \n  if (size == 0) {\n    return;\n  }\n  newFreeBlockPtr = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    newFreeBlockPtr = (int **)((int)newFreeBlockPtr + *(int *)(size + -4));\n  }\n  acquireLock();\n  previousBlockPtr = (int **)&freeList;\n  if (freeList == (int **)0x0) {\n    newFreeBlockPtr[1] = (int *)0x0;\n    currentBlockPtr = nextBlockOffsetPtr;\n    freeList = newFreeBlockPtr;\n  }\n  else {\n    currentFreeBlockPtr = freeList;\n    if (newFreeBlockPtr < freeList) {\n      currentBlockPtr = (int **)*newFreeBlockPtr;\n      previousBlockPtr = (int **)((int)newFreeBlockPtr + (int)currentBlockPtr);\n      isSameFreeBlock = freeList == previousBlockPtr;\n      if (isSameFreeBlock) {\n        previousBlockPtr = (int **)*freeList;\n        freeList = (int **)freeList[1];\n      }\n      newFreeBlockPtr[1] = (int *)freeList;\n      freeList = newFreeBlockPtr;\n      if (isSameFreeBlock) {\n        previousBlockPtr = (int **)((int)previousBlockPtr + (int)currentBlockPtr);\n        *newFreeBlockPtr = (int *)previousBlockPtr;\n      }\n    }\n    else {\n      do {\n        previousBlockPtr = currentFreeBlockPtr;\n        currentFreeBlockPtr = (int **)previousBlockPtr[1];\n        if (currentFreeBlockPtr == (int **)0x0) break;\n      } while (currentFreeBlockPtr <= newFreeBlockPtr);\n      currentBlockPtr = (int **)*previousBlockPtr;\n      if ((int **)((int)previousBlockPtr + (int)currentBlockPtr) == newFreeBlockPtr) {\n        currentBlockPtr = (int **)((int)currentBlockPtr + (int)*newFreeBlockPtr);\n        *previousBlockPtr = (int *)currentBlockPtr;\n        if (currentFreeBlockPtr == (int **)((int)previousBlockPtr + (int)currentBlockPtr)) {\n          currentBlockOffset = *currentFreeBlockPtr;\n          previousBlockPtr[1] = currentFreeBlockPtr[1];\n          currentBlockPtr = (int **)((int)currentBlockPtr + (int)currentBlockOffset);\n          *previousBlockPtr = (int *)currentBlockPtr;\n        }\n      }\n      else if (newFreeBlockPtr < (int **)((int)previousBlockPtr + (int)currentBlockPtr)) {\n        *result = 0xc;\n      }\n      else {\n        currentBlockPtr = (int **)((int)newFreeBlockPtr + (int)*newFreeBlockPtr);\n        isSameFreeBlock = currentFreeBlockPtr == currentBlockPtr;\n        if (isSameFreeBlock) {\n          currentBlockPtr = (int **)*currentFreeBlockPtr;\n          currentFreeBlockPtr = (int **)currentFreeBlockPtr[1];\n        }\n        newFreeBlockPtr[1] = (int *)currentFreeBlockPtr;\n        if (isSameFreeBlock) {\n          currentBlockPtr = (int **)((int)currentBlockPtr + (int)*newFreeBlockPtr);\n          *newFreeBlockPtr = (int *)currentBlockPtr;\n        }\n        previousBlockPtr[1] = (int *)newFreeBlockPtr;\n      }\n    }\n  }\n  releaseLock(result,currentBlockPtr,previousBlockPtr,lock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004b34": "allocate_memory_00004b34",
                "param_1": "result",
                "param_2": "size",
                "param_3": "freeListPtr",
                "param_4": "lock",
                "piVar1": "currentBlockOffset",
                "extraout_r1": "nextBlockOffsetPtr",
                "ppiVar2": "currentBlockPtr",
                "ppiVar3": "previousBlockPtr",
                "ppiVar4": "currentFreeBlockPtr",
                "ppiVar5": "newFreeBlockPtr",
                "bVar6": "isSameFreeBlock",
                "__malloc_lock": "acquireLock",
                "__malloc_free_list": "freeList",
                "__malloc_unlock": "releaseLock"
            },
            "calling": [
                "_realloc_r",
                "__ssrefill_r",
                "free",
                "__sflush_r",
                "__srefill_r",
                "__swsetup_r"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004bd0": {
            "entrypoint": "0x00004bd0",
            "current_name": "allocate_memory_00004bd0",
            "code": "\nuint allocate_memory_00004bd0(_reent *reent_struct,uint requested_bytes)\n\n{\n  uint *prev_block;\n  void *new_block;\n  int split_offset;\n  uint difference;\n  uint *current_block;\n  uint aligned_size;\n  \n  aligned_size = (requested_bytes + 3 & 0xfffffffc) + 8;\n  if (aligned_size < 0xc) {\n    aligned_size = 0xc;\n  }\n  if (((int)aligned_size < 0) || (aligned_size < requested_bytes)) {\n    reent_struct->_errno = 0xc;\n  }\n  else {\n    __malloc_lock();\n    prev_block = __malloc_free_list;\n    for (current_block = __malloc_free_list; current_block != (uint *)0x0; current_block = (uint *)current_block[1]) {\n      difference = *current_block - aligned_size;\n      if (-1 < (int)difference) {\n        if (0xb < difference) {\n          *current_block = difference;\n          current_block = (uint *)((int)current_block + difference);\n          goto LAB_00004c34;\n        }\n        if (prev_block == current_block) {\n          __malloc_free_list = (uint *)current_block[1];\n        }\n        if (prev_block != current_block) {\n          prev_block[1] = (uint)(uint *)current_block[1];\n        }\n        goto LAB_00004c42;\n      }\n      prev_block = current_block;\n    }\n    if (__malloc_sbrk_start == (void *)0x0) {\n      __malloc_sbrk_start = _sbrk_r(reent_struct,0);\n    }\n    prev_block = (uint *)_sbrk_r(reent_struct,aligned_size);\n    if ((prev_block != (uint *)0xffffffff) &&\n       ((current_block = (uint *)((int)prev_block + 3U & 0xfffffffc), prev_block == current_block ||\n        (new_block = _sbrk_r(reent_struct,(int)current_block - (int)prev_block), new_block != (void *)0xffffffff)))) {\nLAB_00004c34:\n      *current_block = aligned_size;\nLAB_00004c42:\n      __malloc_unlock(reent_struct);\n      aligned_size = (int)current_block + 0xbU & 0xfffffff8;\n      split_offset = aligned_size - (int)(current_block + 1);\n      if (split_offset == 0) {\n        return aligned_size;\n      }\n      *(uint *)((int)current_block + split_offset) = (int)(current_block + 1) - aligned_size;\n      return aligned_size;\n    }\n    reent_struct->_errno = 0xc;\n    __malloc_unlock(reent_struct);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00004bd0": "allocate_memory_00004bd0",
                "param_1": "reent_struct",
                "param_2": "requested_bytes",
                "puVar1": "prev_block",
                "pvVar2": "new_block",
                "iVar3": "split_offset",
                "uVar4": "difference",
                "puVar5": "current_block",
                "uVar6": "aligned_size"
            },
            "calling": [
                "__sfmoreglue",
                "__submore",
                "__smakebuf_r",
                "_realloc_r",
                "_tzset_unlocked_r"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock",
                "_sbrk_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004c84": {
            "entrypoint": "0x00004c84",
            "current_name": "print_formatted_string_00004c84",
            "code": "\nint print_formatted_string_00004c84(char *format_string,...)\n\n{\n  int impure_ptr;\n  undefined4 in_r1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *format_string_ptr;\n  undefined4 arg1;\n  undefined4 arg2;\n  undefined4 arg3;\n  \n  impure_ptr = _impure_ptr;\n  format_string_ptr = format_string;\n  arg1 = in_r1;\n  arg2 = in_r2;\n  arg3 = in_r3;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    initialize_stdio(_impure_ptr);\n  }\n  impure_ptr = _vfprintf_r(impure_ptr,*(undefined4 *)(impure_ptr + 8),format_string,&arg1,format_string_ptr,&arg1);\n  return impure_ptr;\n}\n\n",
            "renaming": {
                "FUN_00004c84": "print_formatted_string_00004c84",
                "__format": "format_string",
                "__sinit": "initialize_stdio",
                "iVar1": "impure_ptr",
                "pcVar2": "format_string_ptr",
                "uStack_c": "arg1",
                "uStack_8": "arg2",
                "uStack_4": "arg3"
            },
            "calling": [
                "main_trampoline",
                "read",
                "hard_fault_handler",
                "_rtc_handler",
                "handle_input_line",
                "cpu_print_last_instruction",
                "probe",
                "phydat_dump",
                "core_panic",
                "_saul",
                "write",
                "print_help",
                "ps",
                "_print_time",
                "list"
            ],
            "called": [
                "__sinit",
                "_vfprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004cb4": {
            "entrypoint": "0x00004cb4",
            "current_name": "put_char_00004cb4",
            "code": "\nint putChar_00004cb4(int character)\n\n{\n  int impure_ptr;\n  undefined4 placeholder;\n  \n  impure_ptr = impure_ptr;\n  if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n    __sinit(impure_ptr);\n  }\n  impure_ptr = _putc_r(impure_ptr,character,*(undefined4 *)(impure_ptr + 8),placeholder);\n  return impure_ptr;\n}\n\n",
            "renaming": {
                "FUN_00004cb4": "put_char_00004cb4",
                "__c": "character",
                "in_r3": "placeholder",
                "iVar1": "impure_ptr",
                "_impure_ptr": "impure_ptr"
            },
            "calling": [
                "_putchar"
            ],
            "called": [
                "__sinit",
                "_putc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004cdc": {
            "entrypoint": "0x00004cdc",
            "current_name": "print_string_00004cdc",
            "code": "\nundefined4 print_string_00004cdc(int str_ptr,int length)\n\n{\n  char current_char;\n  int result;\n  char *string_ptr;\n  char **file_ptr;\n  undefined4 return_val;\n  char *current_string;\n  \n  if ((str_ptr != 0) && (*(int *)(str_ptr + 0x18) == 0)) {\n    __sinit();\n  }\n  file_ptr = *(char ***)(str_ptr + 8);\n  if (*(int *)(str_ptr + 0x18) == 0) {\n    __sinit(str_ptr);\n  }\n  if (file_ptr == (char **)&__sf_fake_stdin) {\n    file_ptr = *(char ***)(str_ptr + 4);\n  }\n  else if (file_ptr == (char **)&__sf_fake_stdout) {\n    file_ptr = *(char ***)(str_ptr + 8);\n  }\n  else if (file_ptr == (char **)&__sf_fake_stderr) {\n    file_ptr = *(char ***)(str_ptr + 0xc);\n  }\n  if ((-1 < (int)file_ptr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(file_ptr + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(file_ptr[0x16]);\n  }\n  if ((((int)((uint)*(ushort *)(file_ptr + 3) << 0x1c) < 0) && (file_ptr[4] != (char *)0x0)) ||\n     (result = __swsetup_r(str_ptr,file_ptr), result == 0)) {\n    current_string = (char *)(length + -1);\n    do {\n      while( true ) {\n        current_string = current_string + 1;\n        current_char = *current_string;\n        string_ptr = file_ptr[2] + -1;\n        file_ptr[2] = string_ptr;\n        if (current_char == '\\0') {\n          if (-1 < (int)string_ptr) {\n            current_string = *file_ptr;\n            return_val = 10;\n            *file_ptr = current_string + 1;\n            *current_string = '\\n';\n            goto LAB_00004d64;\n          }\n          result = __swbuf_r(str_ptr,10,file_ptr);\n          if (result != -1) {\n            return_val = 10;\n            goto LAB_00004d64;\n          }\n          goto LAB_00004d60;\n        }\n        if (((int)string_ptr < 0) && (((int)string_ptr < (int)file_ptr[6] || (current_char == '\\n')))) break;\n        string_ptr = *file_ptr;\n        *file_ptr = string_ptr + 1;\n        *string_ptr = current_char;\n      }\n      result = __swbuf_r(str_ptr,current_char,file_ptr);\n    } while (result != -1);\n  }\nLAB_00004d60:\n  return_val = 0xffffffff;\nLAB_00004d64:\n  if ((-1 < (int)file_ptr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(file_ptr + 3) << 0x16))) {\n    __retarget_lock_release_recursive(file_ptr[0x16]);\n  }\n  return return_val;\n}\n\n",
            "renaming": {
                "FUN_00004cdc": "print_string_00004cdc",
                "param_1": "str_ptr",
                "param_2": "length",
                "cVar1": "current_char",
                "iVar2": "result",
                "pcVar3": "string_ptr",
                "ppcVar4": "file_ptr",
                "uVar5": "return_val",
                "pcVar6": "current_string"
            },
            "calling": [
                "puts"
            ],
            "called": [
                "__swbuf_r",
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004db8": {
            "entrypoint": "0x00004db8",
            "current_name": "print_string_00004db8",
            "code": "\nint print_string_00004db8(char *string)\n\n{\n  int result;\n  \n  result = _puts_r(platform_ptr,string);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00004db8": "print_string_00004db8",
                "__s": "string",
                "_impure_ptr": "platform_ptr",
                "iVar1": "result"
            },
            "calling": [
                "_rtc_usage",
                "_rtc_gettime",
                "read",
                "hard_fault_handler",
                "handle_input_line",
                "_alarm_handler",
                "phydat_dump",
                "_rtc_setalarm",
                "main",
                "_rtc_getalarm",
                "probe_all",
                "_rtc_settime",
                "write",
                "print_help",
                "list"
            ],
            "called": [
                "_puts_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004dc8": {
            "entrypoint": "0x00004dc8",
            "current_name": "update_read_count_00004dc8",
            "code": "\nvoid updateReadCount_00004dc8(_reent *reent_ptr,int data_ptr,void *buffer_ptr,size_t buffer_size)\n\n{\n  _ssize_t read_result;\n  uint updated_count;\n  bool is_valid_read;\n  \n  read_result = _read_r(reent_ptr,(int)*(short *)(data_ptr + 0xe),buffer_ptr,buffer_size);\n  is_valid_read = -1 < read_result;\n  if (is_valid_read) {\n    updated_count = *(int *)(data_ptr + 0x54) + read_result;\n  }\n  else {\n    updated_count = *(ushort *)(data_ptr + 0xc) & 0xffffefff;\n  }\n  if (is_valid_read) {\n    *(uint *)(data_ptr + 0x54) = updated_count;\n  }\n  if (!is_valid_read) {\n    *(short *)(data_ptr + 0xc) = (short)updated_count;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004dc8": "update_read_count_00004dc8",
                "param_1": "reent_ptr",
                "param_2": "data_ptr",
                "param_3": "buffer_ptr",
                "param_4": "buffer_size",
                "_Var1": "read_result",
                "uVar2": "updated_count",
                "bVar3": "is_valid_read"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004dea": {
            "entrypoint": "0x00004dea",
            "current_name": "get_default_value_00004dea",
            "code": "\nundefined4 getDefaultValue_00004dea(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00004dea": "get_default_value_00004dea"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004dee": {
            "entrypoint": "0x00004dee",
            "current_name": "write_to_file_00004dee",
            "code": "\nvoid writeToFile_00004dee(_reent *fileDescriptor,int bufferAddr,void *data,size_t dataSize)\n\n{\n  if ((int)((uint)*(ushort *)(bufferAddr + 0xc) << 0x17) < 0) {\n    _lseek_r(fileDescriptor,(int)*(short *)(bufferAddr + 0xe),0,2);\n  }\n  *(ushort *)(bufferAddr + 0xc) = *(ushort *)(bufferAddr + 0xc) & 0xefff;\n  _write_r(fileDescriptor,(int)*(short *)(bufferAddr + 0xe),data,dataSize);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004dee": "write_to_file_00004dee",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddr",
                "param_3": "data",
                "param_4": "dataSize"
            },
            "calling": [],
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e26": {
            "entrypoint": "0x00004e26",
            "current_name": "seek_and_set_offset_00004e26",
            "code": "\nvoid seekAndSetOffset_00004e26(_reent *reentrancy,int binaryData,_off_t offset,int whence)\n\n{\n  _off_t result;\n  ushort flag;\n  bool isError;\n  \n  result = _lseek_r(reentrancy,(int)*(short *)(binaryData + 0xe),offset,whence);\n  isError = result == -1;\n  if (isError) {\n    flag = *(ushort *)(binaryData + 0xc) & 0xefff;\n  }\n  else {\n    *(_off_t *)(binaryData + 0x54) = result;\n    flag = *(ushort *)(binaryData + 0xc) | 0x1000;\n  }\n  if (isError) {\n    *(ushort *)(binaryData + 0xc) = flag;\n  }\n  if (!isError) {\n    *(ushort *)(binaryData + 0xc) = flag;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004e26": "seek_and_set_offset_00004e26",
                "param_1": "reentrancy",
                "param_2": "binaryData",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "result",
                "uVar2": "flag",
                "bVar3": "isError"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e4a": {
            "entrypoint": "0x00004e4a",
            "current_name": "close_file_00004e4a",
            "code": "\nvoid closeFile_00004e4a(_reent *reentStruct,int filePointer)\n\n{\n  _close_r(reentStruct,(int)*(short *)(filePointer + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004e4a": "close_file_00004e4a",
                "param_1": "reentStruct",
                "param_2": "filePointer"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e52": {
            "entrypoint": "0x00004e52",
            "current_name": "compare_strings_00004e52",
            "code": "\nint compare_strings_00004e52(char *string1,char *string2)\n\n{\n  byte char1;\n  uint byte1;\n  bool is_equal;\n  \n  do {\n    byte1 = (uint)(byte)*string1;\n    char1 = *string2;\n    is_equal = byte1 == 1;\n    if (byte1 != 0) {\n      is_equal = byte1 == char1;\n    }\n    string1 = (char *)((byte *)string1 + 1);\n    string2 = (char *)((byte *)string2 + 1);\n  } while (is_equal);\n  return byte1 - char1;\n}\n\n",
            "renaming": {
                "FUN_00004e52": "compare_strings_00004e52",
                "__s1": "string1",
                "__s2": "string2",
                "bVar1": "char1",
                "uVar2": "byte1",
                "bVar3": "is_equal"
            },
            "calling": [
                "_saul",
                "read",
                "handle_input_line",
                "strcmp",
                "find_handler",
                "_tzset_unlocked_r"
            ],
            "called": [
                "strcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e66": {
            "entrypoint": "0x00004e66",
            "current_name": "compare_strings_00004e66",
            "code": "\nint compareStrings_00004e66(char *string1,char *string2,size_t length)\n\n{\n  byte *ptr1;\n  int difference;\n  byte *ptr2;\n  uint char1;\n  \n  if (length == 0) {\n    difference = 0;\n  }\n  else {\n    ptr2 = (byte *)(string2 + -1);\n    ptr1 = (byte *)string1;\n    do {\n      char1 = (uint)*ptr1;\n      ptr2 = ptr2 + 1;\n      if ((char1 != *ptr2) || (ptr1 + 1 == (byte *)(string1 + length))) break;\n      ptr1 = ptr1 + 1;\n    } while (char1 != 0);\n    difference = char1 - *ptr2;\n  }\n  return difference;\n}\n\n",
            "renaming": {
                "FUN_00004e66": "compare_strings_00004e66",
                "__s1": "string1",
                "__s2": "string2",
                "__n": "length",
                "pbVar1": "ptr1",
                "iVar2": "difference",
                "pbVar3": "ptr2",
                "uVar4": "char1"
            },
            "calling": [
                "_findenv_r",
                "_rtc_handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e8c": {
            "entrypoint": "0x00004e8c",
            "current_name": "parse_number_00004e8c",
            "code": "\nuint parseNumber_00004e8c(undefined4 *result,byte *input,byte **remaining,uint base)\n\n{\n  uint parsedNumber;\n  uint currentChar;\n  uint isNegative;\n  uint digitValue;\n  int isOverflow;\n  uint maxValue;\n  uint baseDividedByMaxValue;\n  byte *currentByte;\n  byte *nextByte;\n  \n  nextByte = input;\n  do {\n    currentByte = nextByte;\n    nextByte = currentByte + 1;\n    currentChar = (uint)*currentByte;\n    isNegative = (byte)(&DAT_00007a99)[currentChar] & 8;\n  } while (((&DAT_00007a99)[currentChar] & 8) != 0);\n  if (currentChar == 0x2d) {\n    currentChar = (uint)*nextByte;\n    isNegative = 1;\n    nextByte = currentByte + 2;\n  }\n  else if (currentChar == 0x2b) {\n    currentChar = (uint)*nextByte;\n    nextByte = currentByte + 2;\n  }\n  if (base == 0) {\n    if (currentChar != 0x30) {\n      base = 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((base != 0x10) || (currentChar != 0x30)) goto LAB_00004ed6;\n  if ((*nextByte & 0xdf) == 0x58) {\n    currentChar = (uint)nextByte[1];\n    base = 0x10;\n    nextByte = nextByte + 2;\n  }\n  else {\n    currentChar = 0x30;\n    if (base == 0) {\n      base = 8;\n    }\n  }\nLAB_00004ed6:\n  maxValue = isNegative + 0x7fffffff;\n  isOverflow = 0;\n  baseDividedByMaxValue = maxValue / base;\n  parsedNumber = 0;\n  do {\n    digitValue = currentChar - 0x30;\n    if (9 < digitValue) {\n      if (currentChar - 0x41 < 0x1a) {\n        digitValue = currentChar - 0x37;\n      }\n      else {\n        if (0x19 < currentChar - 0x61) break;\n        digitValue = currentChar - 0x57;\n      }\n    }\n    if ((int)base <= (int)digitValue) break;\n    if (isOverflow != -1) {\n      if ((baseDividedByMaxValue < parsedNumber) || ((baseDividedByMaxValue == parsedNumber && ((int)(maxValue - base * baseDividedByMaxValue) < (int)digitValue)))) {\n        isOverflow = -1;\n      }\n      else {\n        parsedNumber = parsedNumber * base + digitValue;\n        isOverflow = 1;\n      }\n    }\n    currentChar = (uint)*nextByte;\n    nextByte = nextByte + 1;\n  } while( true );\n  if (isOverflow == -1) {\n    *result = 0x22;\n    parsedNumber = maxValue;\n    if (remaining == (byte **)0x0) {\n      return maxValue;\n    }\n  }\n  else {\n    if (isNegative != 0) {\n      parsedNumber = -parsedNumber;\n    }\n    if (remaining == (byte **)0x0) {\n      return parsedNumber;\n    }\n    if (isOverflow == 0) goto LAB_00004f64;\n  }\n  input = nextByte + -1;\nLAB_00004f64:\n  *remaining = input;\n  return parsedNumber;\n}\n\n",
            "renaming": {
                "FUN_00004e8c": "parse_number_00004e8c",
                "param_1": "result",
                "param_2": "input",
                "param_3": "remaining",
                "param_4": "base",
                "uVar1": "parsedNumber",
                "uVar2": "currentChar",
                "uVar3": "isNegative",
                "uVar4": "digitValue",
                "iVar5": "isOverflow",
                "uVar6": "maxValue",
                "uVar7": "baseDividedByMaxValue",
                "pbVar8": "currentByte",
                "pbVar9": "nextByte"
            },
            "calling": [
                "strtol",
                "_strtol_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004f80": {
            "entrypoint": "0x00004f80",
            "current_name": "FUN_00004f80",
            "code": "\nuint _strtol_l_isra_0(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint uVar7;\n  byte *pbVar8;\n  byte *pbVar9;\n  \n  pbVar9 = param_2;\n  do {\n    pbVar8 = pbVar9;\n    pbVar9 = pbVar8 + 1;\n    uVar2 = (uint)*pbVar8;\n    uVar3 = (byte)(&DAT_00007a99)[uVar2] & 8;\n  } while (((&DAT_00007a99)[uVar2] & 8) != 0);\n  if (uVar2 == 0x2d) {\n    uVar2 = (uint)*pbVar9;\n    uVar3 = 1;\n    pbVar9 = pbVar8 + 2;\n  }\n  else if (uVar2 == 0x2b) {\n    uVar2 = (uint)*pbVar9;\n    pbVar9 = pbVar8 + 2;\n  }\n  if (param_4 == 0) {\n    if (uVar2 != 0x30) {\n      param_4 = 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((param_4 != 0x10) || (uVar2 != 0x30)) goto LAB_00004ed6;\n  if ((*pbVar9 & 0xdf) == 0x58) {\n    uVar2 = (uint)pbVar9[1];\n    param_4 = 0x10;\n    pbVar9 = pbVar9 + 2;\n  }\n  else {\n    uVar2 = 0x30;\n    if (param_4 == 0) {\n      param_4 = 8;\n    }\n  }\nLAB_00004ed6:\n  uVar6 = uVar3 + 0x7fffffff;\n  iVar5 = 0;\n  uVar7 = uVar6 / param_4;\n  uVar1 = 0;\n  do {\n    uVar4 = uVar2 - 0x30;\n    if (9 < uVar4) {\n      if (uVar2 - 0x41 < 0x1a) {\n        uVar4 = uVar2 - 0x37;\n      }\n      else {\n        if (0x19 < uVar2 - 0x61) break;\n        uVar4 = uVar2 - 0x57;\n      }\n    }\n    if ((int)param_4 <= (int)uVar4) break;\n    if (iVar5 != -1) {\n      if ((uVar7 < uVar1) || ((uVar7 == uVar1 && ((int)(uVar6 - param_4 * uVar7) < (int)uVar4)))) {\n        iVar5 = -1;\n      }\n      else {\n        uVar1 = uVar1 * param_4 + uVar4;\n        iVar5 = 1;\n      }\n    }\n    uVar2 = (uint)*pbVar9;\n    pbVar9 = pbVar9 + 1;\n  } while( true );\n  if (iVar5 == -1) {\n    *param_1 = 0x22;\n    uVar1 = uVar6;\n    if (param_3 == (byte **)0x0) {\n      return uVar6;\n    }\n  }\n  else {\n    if (uVar3 != 0) {\n      uVar1 = -uVar1;\n    }\n    if (param_3 == (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar5 == 0) goto LAB_00004f64;\n  }\n  param_2 = pbVar9 + -1;\nLAB_00004f64:\n  *param_3 = param_2;\n  return uVar1;\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "_strtol_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004f84": {
            "entrypoint": "0x00004f84",
            "current_name": "convert_string_to_long_00004f84",
            "code": "\nlong convertStringToLong_00004f84(char *inputString,char **endPointer,int base)\n\n{\n  long convertedValue;\n  \n  convertedValue = _strtol_l_isra_0(_impure_ptr,inputString,endPointer,base);\n  return convertedValue;\n}\n\n",
            "renaming": {
                "FUN_00004f84": "convert_string_to_long_00004f84",
                "__nptr": "inputString",
                "__endptr": "endPointer",
                "__base": "base",
                "lVar1": "convertedValue"
            },
            "calling": [
                "_parse_time",
                "atoi"
            ],
            "called": [
                "_strtol_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004f98": {
            "entrypoint": "0x00004f98",
            "current_name": "calculate_day_of_week_00004f98",
            "code": "\nundefined4 calculateDayOfWeek_00004f98(uint year)\n\n{\n  uint *timeZoneInfo;\n  undefined4 isLeapYear;\n  uint dayOfWeek;\n  int leapYearOffset;\n  uint *currentYearInfo;\n  int daysOffset;\n  uint isLeapYear2;\n  int monthIndex;\n  int daysToAdd;\n  uint isDivisibleBy400;\n  \n  timeZoneInfo = (uint *)__gettzinfo();\n  if ((int)year < 0x7b2) {\n    isLeapYear = 0;\n  }\n  else {\n    daysOffset = (year - 0x7b2) * 0x16d + ((int)(year - 0x7b1) >> 2) +\n            (year - 0x76d) / 0xffffff9c + (year - 0x641) / 400;\n    timeZoneInfo[1] = year;\n    isDivisibleBy400 = (uint)(year % 400 == 0);\n    currentYearInfo = timeZoneInfo;\n    do {\n      dayOfWeek = currentYearInfo[5];\n      if (*(char *)(currentYearInfo + 2) == 'J') {\n        if ((((year & 3) == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n          if ((int)dayOfWeek < 0x3c) {\n            leapYearOffset = 0;\n          }\n          else {\n            leapYearOffset = 1;\n          }\n        }\n        else {\n          leapYearOffset = 0;\n        }\n        leapYearOffset = leapYearOffset + daysOffset + dayOfWeek + -1;\n      }\n      else if (*(char *)(currentYearInfo + 2) == 'D') {\n        leapYearOffset = daysOffset + dayOfWeek;\n      }\n      else {\n        isLeapYear2 = isDivisibleBy400;\n        if (((year & 3) == 0) && (year % 100 != 0)) {\n          isLeapYear2 = 1;\n        }\n        monthIndex = 0;\n        leapYearOffset = daysOffset;\n        while( true ) {\n          monthIndex = monthIndex + 1;\n          if ((int)currentYearInfo[3] <= monthIndex) break;\n          leapYearOffset = leapYearOffset + *(int *)(&UNK_00007b98 + monthIndex * 4 + isLeapYear2 * 0x30);\n        }\n        daysToAdd = dayOfWeek - (leapYearOffset + 4U) % 7;\n        if (daysToAdd < 0) {\n          daysToAdd = daysToAdd + 7;\n        }\n        for (daysToAdd = (currentYearInfo[4] - 1) * 7 + daysToAdd;\n            *(int *)(&UNK_00007b98 + monthIndex * 4 + isLeapYear2 * 0x30) <= daysToAdd; daysToAdd = daysToAdd + -7) {\n        }\n        leapYearOffset = leapYearOffset + daysToAdd;\n      }\n      dayOfWeek = currentYearInfo[10] + leapYearOffset * 0x15180 + currentYearInfo[6];\n      currentYearInfo[8] = dayOfWeek;\n      currentYearInfo[9] = (int)dayOfWeek >> 0x1f;\n      currentYearInfo = currentYearInfo + 10;\n    } while (timeZoneInfo + 0x14 != currentYearInfo);\n    dayOfWeek = timeZoneInfo[9];\n    isDivisibleBy400 = timeZoneInfo[0x13];\n    *timeZoneInfo = (uint)((int)((dayOfWeek - isDivisibleBy400) - (uint)(timeZoneInfo[8] < timeZoneInfo[0x12])) < 0 !=\n                    (SBORROW4(dayOfWeek,isDivisibleBy400) !=\n                    SBORROW4(dayOfWeek - isDivisibleBy400,(uint)(timeZoneInfo[8] < timeZoneInfo[0x12]))));\n    isLeapYear = 1;\n  }\n  return isLeapYear;\n}\n\n",
            "renaming": {
                "FUN_00004f98": "calculate_day_of_week_00004f98",
                "param_1": "year",
                "puVar1": "timeZoneInfo",
                "uVar2": "isLeapYear",
                "uVar3": "dayOfWeek",
                "iVar4": "leapYearOffset",
                "puVar5": "currentYearInfo",
                "iVar6": "daysOffset",
                "uVar7": "isLeapYear2",
                "iVar8": "monthIndex",
                "iVar9": "daysToAdd",
                "uVar10": "isDivisibleBy400"
            },
            "calling": [
                "mktime",
                "_tzset_unlocked_r"
            ],
            "called": [
                "__gettzinfo"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000050e8": {
            "entrypoint": "0x000050e8",
            "current_name": "acquire_lock_000050e8",
            "code": "\nvoid acquire_lock_000050e8(void)\n\n{\n  acquire_lock_000050e8_helper(&lock_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000050e8": "acquire_lock_000050e8",
                "__retarget_lock_acquire": "acquire_lock_helper",
                "__lock___tz_mutex": "lock_mutex"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "__retarget_lock_acquire"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000050f4": {
            "entrypoint": "0x000050f4",
            "current_name": "release_tz_mutex_000050f4",
            "code": "\nvoid releaseTzMutex_000050f4(void)\n\n{\n  __retarget_lock_release(&mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000050f4": "release_tz_mutex_000050f4",
                "__lock___tz_mutex": "mutex"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "__retarget_lock_release"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005100": {
            "entrypoint": "0x00005100",
            "current_name": "initialize_timezone_00005100",
            "code": "\nvoid initializeTimezone_00005100(void)\n\n{\n  updateTimezone(timezonePointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005100": "initialize_timezone_00005100",
                "_tzset_unlocked_r": "updateTimezone",
                "_impure_ptr": "timezonePointer"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "_tzset_unlocked_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000510c": {
            "entrypoint": "0x0000510c",
            "current_name": "initialize_timezone_info_0000510c",
            "code": "\nvoid initializeTimezoneInfo_0000510c(undefined4 arg)\n\n{\n  int timezoneInfoPtr;\n  char *tzenv;\n  size_t envSize;\n  int strcmpResult;\n  int scanfResult;\n  ulong parsedValue;\n  undefined timezoneChar;\n  char *scanResult;\n  bool foundDelimiter;\n  ushort *dstHoursPtr;\n  int *lastScanResultPtr;\n  ushort *dstMinutesPtr;\n  int *lastScanResultPtr2;\n  ushort dstYear;\n  ushort dstMonth;\n  ushort dstDay;\n  ushort dstHour;\n  ushort dstMinute;\n  ushort dstSecond;\n  int endPos;\n  char *tznameResult [2];\n  \n  timezoneInfoPtr = __gettzinfo();\n  tzenv = (char *)_getenv_r(arg,&DAT_00007a5c);\n  if (tzenv == (char *)0x0) {\n    _tzname = &DAT_00007a5f;\n    DAT_1fff02e8 = &DAT_00007a5f;\n    _daylight = tzenv;\n    _timezone = tzenv;\n    free(prev_tzenv);\n    prev_tzenv = (char *)0x0;\n  }\n  else if ((prev_tzenv == (char *)0x0) || (strcmpResult = strcmp(tzenv,prev_tzenv), strcmpResult != 0)) {\n    free(prev_tzenv);\n    envSize = strlen(tzenv);\n    prev_tzenv = (char *)_malloc_r(arg,envSize + 1);\n    if (prev_tzenv != (char *)0x0) {\n      strcpy(prev_tzenv,tzenv);\n    }\n    if (*tzenv == ':') {\n      tzenv = tzenv + 1;\n    }\n    strcmpResult = siscanf(tzenv,\"%10[^0-9,+-]%n\",&__tzname_std,&endPos);\n    if (0 < strcmpResult) {\n      scanResult = tzenv + endPos;\n      if (tzenv[endPos] == '-') {\n        scanResult = scanResult + 1;\n        strcmpResult = -1;\n      }\n      else {\n        if (tzenv[endPos] == '+') {\n          scanResult = scanResult + 1;\n        }\n        strcmpResult = 1;\n      }\n      dstMonth = 0;\n      dstDay = 0;\n      dstHoursPtr = &dstMonth;\n      lastScanResultPtr = &endPos;\n      dstMinutesPtr = &dstDay;\n      lastScanResultPtr2 = &endPos;\n      scanfResult = siscanf(scanResult,\"%hu%n:%hu%n:%hu%n\",&dstYear,&endPos,&dstMonth,&endPos,&dstDay,\n                      &endPos);\n      if (0 < scanfResult) {\n        *(uint *)(timezoneInfoPtr + 0x28) =\n             ((uint)dstYear * 0xe10 + (uint)dstMonth * 0x3c + (uint)dstDay) * strcmpResult;\n        _tzname = &__tzname_std;\n        scanResult = scanResult + endPos;\n        strcmpResult = siscanf(scanResult,\"%10[^0-9,+-]%n\",&__tzname_dst,&endPos,dstHoursPtr,lastScanResultPtr,dstMinutesPtr,\n                        lastScanResultPtr2);\n        if (strcmpResult < 1) {\n          DAT_1fff02e8 = _tzname;\n          _timezone = *(char **)(timezoneInfoPtr + 0x28);\n          _daylight = (char *)0x0;\n        }\n        else {\n          DAT_1fff02e8 = &__tzname_dst;\n          tzenv = scanResult + endPos;\n          if (scanResult[endPos] == '-') {\n            tzenv = tzenv + 1;\n            strcmpResult = -1;\n          }\n          else {\n            if (scanResult[endPos] == '+') {\n              tzenv = tzenv + 1;\n            }\n            strcmpResult = 1;\n          }\n          dstYear = 0;\n          dstMonth = 0;\n          dstDay = 0;\n          endPos = 0;\n          scanfResult = siscanf(tzenv,\"%hu%n:%hu%n:%hu%n\",&dstYear,&endPos,&dstMonth,&endPos,\n                          &dstDay,&endPos);\n          if (scanfResult < 1) {\n            strcmpResult = *(int *)(timezoneInfoPtr + 0x28) + -0xe10;\n          }\n          else {\n            strcmpResult = ((uint)dstYear * 0xe10 + (uint)dstMonth * 0x3c + (uint)dstDay) * strcmpResult;\n          }\n          *(int *)(timezoneInfoPtr + 0x50) = strcmpResult;\n          tzenv = tzenv + endPos;\n          foundDelimiter = false;\n          strcmpResult = timezoneInfoPtr;\n          while( true ) {\n            if (*tzenv == ',') {\n              tzenv = tzenv + 1;\n            }\n            if (*tzenv == 'M') {\n              scanfResult = siscanf(tzenv,\"M%hu%n.%hu%n.%hu%n\",&dstHour,&endPos,&dstMinute,&endPos,\n                              &dstSecond,&endPos);\n              if (scanfResult != 3) {\n                return;\n              }\n              if (0xb < dstHour - 1) {\n                return;\n              }\n              if (4 < dstMinute - 1) {\n                return;\n              }\n              if (6 < dstSecond) {\n                return;\n              }\n              *(uint *)(strcmpResult + 0xc) = (uint)dstHour;\n              *(uint *)(strcmpResult + 0x10) = (uint)dstMinute;\n              *(undefined *)(strcmpResult + 8) = 0x4d;\n              *(uint *)(strcmpResult + 0x14) = (uint)dstSecond;\n              scanResult = tzenv + endPos;\n            }\n            else {\n              if (*tzenv == 'J') {\n                tzenv = tzenv + 1;\n                timezoneChar = 0x4a;\n              }\n              else {\n                timezoneChar = 0x44;\n              }\n              parsedValue = strtoul(tzenv,tznameResult,10);\n              dstSecond = (ushort)parsedValue;\n              scanResult = tznameResult[0];\n              if (tznameResult[0] == tzenv) {\n                if (foundDelimiter) {\n                  *(undefined *)(timezoneInfoPtr + 0x30) = 0x4d;\n                  *(undefined4 *)(timezoneInfoPtr + 0x34) = 0xb;\n                  *(undefined4 *)(timezoneInfoPtr + 0x38) = 1;\n                  *(undefined4 *)(timezoneInfoPtr + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(timezoneInfoPtr + 8) = 0x4d;\n                  *(undefined4 *)(timezoneInfoPtr + 0xc) = 3;\n                  *(undefined4 *)(timezoneInfoPtr + 0x10) = 2;\n                  *(undefined4 *)(timezoneInfoPtr + 0x14) = 0;\n                }\n              }\n              else {\n                *(undefined *)(strcmpResult + 8) = timezoneChar;\n                *(ulong *)(strcmpResult + 0x14) = parsedValue & 0xffff;\n              }\n            }\n            dstYear = 2;\n            dstMonth = 0;\n            dstDay = 0;\n            endPos = 0;\n            if (*scanResult == '/') {\n              siscanf(scanResult,\"/%hu%n:%hu%n:%hu%n\",&dstYear,&endPos,&dstMonth,&endPos,&dstDay,\n                      &endPos);\n            }\n            *(uint *)(strcmpResult + 0x18) =\n                 (uint)dstYear * 0xe10 + (uint)dstMonth * 0x3c + (uint)dstDay;\n            strcmpResult = strcmpResult + 0x28;\n            tzenv = scanResult + endPos;\n            if (foundDelimiter) break;\n            foundDelimiter = true;\n          }\n          __tzcalc_limits(*(undefined4 *)(timezoneInfoPtr + 4));\n          _timezone = *(char **)(timezoneInfoPtr + 0x28);\n          _daylight = (char *)(*(int *)(timezoneInfoPtr + 0x50) - (int)_timezone);\n          if (_daylight != (char *)0x0) {\n            _daylight = (char *)0x1;\n          }\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000510c": "initialize_timezone_info_0000510c",
                "param_1": "arg",
                "iVar1": "timezoneInfoPtr",
                "pcVar2": "tzenv",
                "sVar3": "envSize",
                "iVar4": "strcmpResult",
                "iVar5": "scanfResult",
                "uVar6": "parsedValue",
                "uVar7": "timezoneChar",
                "pcVar8": "scanResult",
                "bVar9": "foundDelimiter",
                "puVar10": "dstHoursPtr",
                "piVar11": "lastScanResultPtr",
                "puVar12": "dstMinutesPtr",
                "piVar13": "lastScanResultPtr2",
                "local_3c": "dstYear",
                "local_3a": "dstMonth",
                "local_38": "dstDay",
                "local_36": "dstHour",
                "local_34": "dstMinute",
                "local_32": "dstSecond",
                "local_30": "endPos",
                "local_2c": "tznameResult"
            },
            "calling": [
                "_tzset_unlocked"
            ],
            "called": [
                "_malloc_r",
                "_getenv_r",
                "__gettzinfo",
                "siscanf",
                "free",
                "strlen",
                "strtoul",
                "strcmp",
                "__tzcalc_limits",
                "strcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005404": {
            "entrypoint": "0x00005404",
            "current_name": "process_input_00005404",
            "code": "\nuint processInput_00005404(int inputStruct,uint data,int *streamPtr,undefined4 setupFlag)\n\n{\n  int result;\n  uint shiftedData;\n  undefined *ptr;\n  \n  if ((inputStruct != 0) && (*(int *)(inputStruct + 0x18) == 0)) {\n    initializeStreams();\n  }\n  if (streamPtr == &fakeStdin) {\n    streamPtr = *(int **)(inputStruct + 4);\n  }\n  else if (streamPtr == (int *)&fakeStdout) {\n    streamPtr = *(int **)(inputStruct + 8);\n  }\n  else if (streamPtr == (int *)&fakeStderr) {\n    streamPtr = *(int **)(inputStruct + 0xc);\n  }\n  streamPtr[2] = streamPtr[6];\n  shiftedData = (uint)*(ushort *)(streamPtr + 3);\n  result = shiftedData << 0x1c;\n  if (((result < 0) && (shiftedData = streamPtr[4], shiftedData != 0)) ||\n     (result = setupStream(inputStruct,streamPtr,result,shiftedData,setupFlag), result == 0)) {\n    result = *streamPtr - streamPtr[4];\n    data = data & 0xff;\n    if ((result < streamPtr[5]) || (result = flushStream(inputStruct,streamPtr), result == 0)) {\n      streamPtr[2] = streamPtr[2] + -1;\n      ptr = (undefined *)*streamPtr;\n      *streamPtr = (int)(ptr + 1);\n      *ptr = (char)data;\n      if (streamPtr[5] != result + 1) {\n        if (-1 < (int)((uint)*(ushort *)(streamPtr + 3) << 0x1f)) {\n          return data;\n        }\n        if (data != 10) {\n          return data;\n        }\n      }\n      result = flushStream(inputStruct,streamPtr);\n      if (result == 0) {\n        return data;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00005404": "process_input_00005404",
                "param_1": "inputStruct",
                "param_2": "data",
                "param_3": "streamPtr",
                "param_4": "setupFlag",
                "iVar1": "result",
                "uVar2": "shiftedData",
                "puVar3": "ptr",
                "__sinit": "initializeStreams",
                "__sf_fake_stdin": "fakeStdin",
                "__sf_fake_stdout": "fakeStdout",
                "__sf_fake_stderr": "fakeStderr",
                "__swsetup_r": "setupStream",
                "_fflush_r": "flushStream"
            },
            "calling": [
                "__sfputc_r",
                "_puts_r",
                "_putc_r"
            ],
            "called": [
                "__sinit",
                "_fflush_r",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000054a8": {
            "entrypoint": "0x000054a8",
            "current_name": "parse_input_000054a8",
            "code": "\nuint parseInput_000054a8(undefined4 *output_result,undefined4 *input_stream)\n\n{\n  ushort temp_val_1;\n  int impure_ptr;\n  ushort temp_val_2;\n  uint stream_length;\n  uint temp_val_3;\n  \n  impure_ptr = _impure_ptr;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  if (input_stream == &__sf_fake_stdin) {\n    input_stream = *(undefined4 **)(impure_ptr + 4);\n  }\n  else if (input_stream == (undefined4 *)&__sf_fake_stdout) {\n    input_stream = *(undefined4 **)(impure_ptr + 8);\n  }\n  else if (input_stream == (undefined4 *)&__sf_fake_stderr) {\n    input_stream = *(undefined4 **)(impure_ptr + 0xc);\n  }\n  stream_length = (uint)*(ushort *)(input_stream + 3);\n  temp_val_2 = *(ushort *)(input_stream + 3);\n  if (-1 < (int)(stream_length << 0x1c)) {\n    if (-1 < (int)(stream_length << 0x1b)) {\n      *output_result = 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(stream_length << 0x1d) < 0) {\n      if ((undefined4 *)input_stream[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)input_stream[0xd] != input_stream + 0x11) {\n          _free_r(output_result);\n        }\n        input_stream[0xd] = 0;\n      }\n      *(ushort *)(input_stream + 3) = *(ushort *)(input_stream + 3) & 0xffdb;\n      input_stream[1] = 0;\n      *input_stream = input_stream[4];\n    }\n    *(ushort *)(input_stream + 3) = *(ushort *)(input_stream + 3) | 8;\n  }\n  if ((input_stream[4] == 0) && ((*(ushort *)(input_stream + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(output_result,input_stream);\n  }\n  temp_val_1 = *(ushort *)(input_stream + 3);\n  stream_length = (uint)temp_val_1;\n  temp_val_2 = *(ushort *)(input_stream + 3);\n  temp_val_3 = stream_length & 1;\n  if ((temp_val_1 & 1) == 0) {\n    if (-1 < (int)(stream_length << 0x1e)) {\n      temp_val_3 = input_stream[5];\n    }\n    input_stream[2] = temp_val_3;\n  }\n  else {\n    input_stream[2] = 0;\n    input_stream[6] = -input_stream[5];\n  }\n  if (input_stream[4] != 0) {\n    return 0;\n  }\n  if ((temp_val_1 & 0x80) == 0) {\n    return stream_length & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(input_stream + 3) = temp_val_2 | 0x40;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_000054a8": "parse_input_000054a8",
                "param_1": "output_result",
                "param_2": "input_stream",
                "uVar1": "temp_val_1",
                "iVar2": "impure_ptr",
                "uVar3": "temp_val_2",
                "uVar4": "stream_length",
                "uVar5": "temp_val_3"
            },
            "calling": [
                "__swbuf_r",
                "_puts_r",
                "_vfprintf_r"
            ],
            "called": [
                "__smakebuf_r",
                "__sinit",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005584": {
            "entrypoint": "0x00005584",
            "current_name": "divide_with_remainder_00005584",
            "code": "\ndiv_t divideWithRemainder_00005584(int dividend,int divisor)\n\n{\n  uint remainder;\n  int divisorRemainder;\n  uint quotient;\n  div_t dVar3;\n  \n  quotient = (uint)divisor / remainder;\n  divisorRemainder = divisor - remainder * quotient;\n  if (divisor < 0) {\n    if (0 < divisorRemainder) {\n      quotient = quotient - 1;\n      divisorRemainder = divisorRemainder + remainder;\n    }\n  }\n  else if (divisorRemainder < 0) {\n    quotient = quotient + 1;\n    divisorRemainder = divisorRemainder - remainder;\n  }\n  *(uint *)dividend = quotient;\n  *(int *)(dividend + 4) = divisorRemainder;\n  remainderResult = divisor;\n  quotientResult = dividend;\n  return dVar3;\n}\n\n",
            "renaming": {
                "FUN_00005584": "divide_with_remainder_00005584",
                "__numer": "dividend",
                "__denom": "divisor",
                "in_r2": "remainder",
                "iVar1": "divisorRemainder",
                "uVar2": "quotient",
                "dVar3.rem": "remainderResult",
                "dVar3.quot": "quotientResult"
            },
            "calling": [
                "validate_structure"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000055ac": {
            "entrypoint": "0x000055ac",
            "current_name": "read_byte_from_stream_000055ac",
            "code": "\nuint readByteFromStream_000055ac(int streamHandle,byte **streamPtr)\n\n{\n  uint byteRead;\n  byte *streamBuffer;\n  \n  if ((streamHandle != 0) && (*(int *)(streamHandle + 0x18) == 0)) {\n    __sinit();\n  }\n  if (streamPtr == (byte **)&__sf_fake_stdin) {\n    streamPtr = *(byte ***)(streamHandle + 4);\n  }\n  else if (streamPtr == (byte **)&__sf_fake_stdout) {\n    streamPtr = *(byte ***)(streamHandle + 8);\n  }\n  else if (streamPtr == (byte **)&__sf_fake_stderr) {\n    streamPtr = *(byte ***)(streamHandle + 0xc);\n  }\n  if ((-1 < (int)streamPtr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(streamPtr + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(streamPtr[0x16]);\n  }\n  streamBuffer = streamPtr[1];\n  streamPtr[1] = streamBuffer + -1;\n  if ((int)(streamBuffer + -1) < 0) {\n    byteRead = __srget_r(streamHandle,streamPtr);\n  }\n  else {\n    streamBuffer = *streamPtr;\n    *streamPtr = streamBuffer + 1;\n    byteRead = (uint)*streamBuffer;\n  }\n  if ((-1 < (int)streamPtr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(streamPtr + 3) << 0x16))) {\n    __retarget_lock_release_recursive(streamPtr[0x16]);\n  }\n  return byteRead;\n}\n\n",
            "renaming": {
                "FUN_000055ac": "read_byte_from_stream_000055ac",
                "param_1": "streamHandle",
                "param_2": "streamPtr",
                "uVar1": "byteRead",
                "pbVar2": "streamBuffer"
            },
            "calling": [
                "getchar"
            ],
            "called": [
                "__sinit",
                "__srget_r",
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000562c": {
            "entrypoint": "0x0000562c",
            "current_name": "find_environment_variable_value_0000562c",
            "code": "\nchar * findEnvironmentVariableValue_0000562c(undefined4 lock,char *variableName,int *index)\n\n{\n  char currentChar;\n  char **envPointer;\n  int comparisonResult;\n  char *currentEnvVar;\n  char **currentEnvPointer;\n  size_t nameLength;\n  \n  __env_lock();\n  currentEnvVar = variableName;\n  if (environ != (char **)0x0) {\n    do {\n      currentChar = *currentEnvVar;\n      if (currentChar == '\\0') {\n        nameLength = (int)currentEnvVar - (int)variableName;\n        envPointer = environ;\n        while( true ) {\n          currentEnvPointer = envPointer;\n          if (*currentEnvPointer == (char *)0x0) break;\n          comparisonResult = strncmp(*currentEnvPointer,variableName,nameLength);\n          envPointer = currentEnvPointer + 1;\n          if ((comparisonResult == 0) && (currentEnvVar = *currentEnvPointer, currentEnvVar[nameLength] == '=')) {\n            *index = (int)currentEnvPointer - (int)environ >> 2;\n            __env_unlock(lock);\n            return currentEnvVar + nameLength + 1;\n          }\n        }\n        break;\n      }\n      currentEnvVar = currentEnvVar + 1;\n    } while (currentChar != '=');\n  }\n  __env_unlock(lock);\n  return (char *)0x0;\n}\n\n",
            "renaming": {
                "FUN_0000562c": "find_environment_variable_value_0000562c",
                "param_1": "lock",
                "param_2": "variableName",
                "param_3": "index",
                "cVar1": "currentChar",
                "ppcVar2": "envPointer",
                "iVar3": "comparisonResult",
                "pcVar4": "currentEnvVar",
                "ppcVar5": "currentEnvPointer",
                "__n": "nameLength"
            },
            "calling": [
                "_getenv_r"
            ],
            "called": [
                "__env_lock",
                "__env_unlock",
                "strncmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000056a0": {
            "entrypoint": "0x000056a0",
            "current_name": "find_environment_variable_000056a0",
            "code": "\nvoid find_environment_variable_000056a0(undefined4 env,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 env_copy;\n  undefined4 param_3_copy;\n  \n  env_copy = param_2;\n  param_3_copy = param_3;\n  _findenv_r(env,param_2,&env_copy,param_4,env);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000056a0": "find_environment_variable_000056a0",
                "param_1": "env",
                "uStack_c": "env_copy",
                "uStack_8": "param_3_copy"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "_findenv_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000056b0": {
            "entrypoint": "0x000056b0",
            "current_name": "get_timezone_info_000056b0",
            "code": "\nundefined1 * get_timezone_info_000056b0(void)\n\n{\n  return &timezone_info;\n}\n\n",
            "renaming": {
                "FUN_000056b0": "get_timezone_info_000056b0",
                "tzinfo": "timezone_info"
            },
            "calling": [
                "mktime",
                "__tzcalc_limits",
                "_tzset_unlocked_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000056b8": {
            "entrypoint": "0x000056b8",
            "current_name": "check_file_permissions_000056b8",
            "code": "\nundefined4 check_file_permissions_000056b8(_reent *reent_struct,int file_descriptor,undefined4 *status_result,uint *is_setuid)\n\n{\n  int fstat_result;\n  undefined4 permissions;\n  stat file_stats;\n  \n  if ((*(short *)(file_descriptor + 0xe) < 0) ||\n     (fstat_result = _fstat_r(reent_struct,(int)*(short *)(file_descriptor + 0xe),&file_stats), fstat_result < 0)) {\n    *is_setuid = 0;\n    if ((int)((uint)*(ushort *)(file_descriptor + 0xc) << 0x18) < 0) {\n      permissions = 0x40;\n      goto LAB_000056f8;\n    }\n  }\n  else {\n    *is_setuid = (uint)((file_stats.st_mode & 0xf000) == 0x2000);\n  }\n  permissions = 0x400;\nLAB_000056f8:\n  *status_result = permissions;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000056b8": "check_file_permissions_000056b8",
                "param_1": "reent_struct",
                "param_2": "file_descriptor",
                "param_3": "status_result",
                "param_4": "is_setuid",
                "iVar1": "fstat_result",
                "sStack_68": "file_stats",
                "uVar2": "permissions"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005700": {
            "entrypoint": "0x00005700",
            "current_name": "initialize_file_00005700",
            "code": "\nvoid initializeFile_00005700(_reent *reent_pointer,int *file_info)\n\n{\n  ushort status;\n  int allocated_memory;\n  _reent *temporary_reent_pointer;\n  int *temporary_file_info;\n  \n  if (-1 < (int)((uint)*(ushort *)(file_info + 3) << 0x1e)) {\n    temporary_reent_pointer = reent_pointer;\n    temporary_file_info = file_info;\n    status = __swhatbuf_r(reent_pointer,file_info,&temporary_reent_pointer,&temporary_file_info);\n    allocated_memory = _malloc_r(reent_pointer,temporary_reent_pointer);\n    if (allocated_memory != 0) {\n      reent_pointer->__cleanup = _cleanup_r + 1;\n      *file_info = allocated_memory;\n      *(ushort *)(file_info + 3) = *(ushort *)(file_info + 3) | 0x80;\n      file_info[5] = (int)temporary_reent_pointer;\n      file_info[4] = allocated_memory;\n      if ((temporary_file_info != (int *)0x0) &&\n         (allocated_memory = _isatty_r(reent_pointer,(int)*(short *)((int)file_info + 0xe)), allocated_memory != 0)) {\n        *(ushort *)(file_info + 3) = *(ushort *)(file_info + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(file_info + 3) = status | *(ushort *)(file_info + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(file_info + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(file_info + 3) = *(ushort *)(file_info + 3) & 0xfffc | 2;\n  }\n  *file_info = (int)file_info + 0x47;\n  file_info[4] = (int)file_info + 0x47;\n  file_info[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005700": "initialize_file_00005700",
                "param_1": "reent_pointer",
                "param_2": "file_info",
                "uVar1": "status",
                "iVar2": "allocated_memory",
                "local_18": "temporary_reent_pointer",
                "local_14": "temporary_file_info"
            },
            "calling": [
                "__srefill_r",
                "__swsetup_r"
            ],
            "called": [
                "_malloc_r",
                "_isatty_r",
                "__swhatbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005780": {
            "entrypoint": "0x00005780",
            "current_name": "free_memory_00005780",
            "code": "\nvoid freeMemory_00005780(void *memoryBlock)\n\n{\n  _free_r(_impure_ptr,memoryBlock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005780": "free_memory_00005780",
                "__ptr": "memoryBlock"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005790": {
            "entrypoint": "0x00005790",
            "current_name": "acquire_recursive_lock_for_malloc_00005790",
            "code": "\nvoid acquire_recursive_lock_for_malloc_00005790(void)\n\n{\n  acquire_recursive_lock(&malloc_recursive_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005790": "acquire_recursive_lock_for_malloc_00005790",
                "__retarget_lock_acquire_recursive": "acquire_recursive_lock",
                "__lock___malloc_recursive_mutex": "malloc_recursive_mutex"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000579c": {
            "entrypoint": "0x0000579c",
            "current_name": "release_recursive_lock_0000579c",
            "code": "\nvoid releaseRecursiveLock_0000579c(void)\n\n{\n  __retarget_lock_release_recursive(&recursiveMutexLock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000579c": "release_recursive_lock_0000579c",
                "__lock___malloc_recursive_mutex": "recursiveMutexLock"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000057a8": {
            "entrypoint": "0x000057a8",
            "current_name": "write_char_to_buffer_000057a8",
            "code": "\nint write_char_to_buffer_000057a8(undefined4 buffer,int character,undefined4 *buffer_info)\n\n{\n  int last_index;\n  undefined *ptr_buffer;\n  \n  last_index = buffer_info[2] + -1;\n  buffer_info[2] = last_index;\n  if ((last_index < 0) && ((last_index < (int)buffer_info[6] || (character == 10)))) {\n    last_index = buffer_overflow_check();\n    return last_index;\n  }\n  ptr_buffer = (undefined *)*buffer_info;\n  *buffer_info = ptr_buffer + 1;\n  *ptr_buffer = (char)character;\n  return character;\n}\n\n",
            "renaming": {
                "FUN_000057a8": "write_char_to_buffer_000057a8",
                "param_1": "buffer",
                "param_2": "character",
                "param_3": "buffer_info",
                "iVar1": "last_index",
                "puVar2": "ptr_buffer",
                "__swbuf_r": "buffer_overflow_check"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__swbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000057d2": {
            "entrypoint": "0x000057d2",
            "current_name": "write_to_stream_000057d2",
            "code": "\nint writeToStream_000057d2(undefined4 stream,undefined4 param,undefined *data,int length)\n\n{\n  int result;\n  undefined *end;\n  int remaining;\n  \n  end = data + length;\n  remaining = length;\n  do {\n    if (data == end) {\n      return 0;\n    }\n    result = __sfputc_r(stream,*data,param,length,remaining);\n    length = result + 1;\n    data = data + 1;\n  } while (length != 0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000057d2": "write_to_stream_000057d2",
                "param_1": "stream",
                "param_2": "param",
                "param_3": "data",
                "param_4": "length",
                "iVar1": "result",
                "puVar2": "end",
                "iVar3": "remaining"
            },
            "calling": [
                "_vfprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000057f8": {
            "entrypoint": "0x000057f8",
            "current_name": "process_format_string_000057f8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000059f0) */\n\nint processFormatString_000057f8(int fileDescriptor,undefined4 *stream,byte *formatString,int *args)\n\n{\n  bool foundNumber;\n  int integerValue;\n  int result;\n  void *searchResult;\n  int *argsPtr;\n  byte *formatPtr;\n  int resultVar;\n  byte *currentChar;\n  int *currentArg;\n  uint flags;\n  int precision;\n  undefined4 bufferSize;\n  int argWidth;\n  int totalCharsWritten;\n  byte specifier;\n  undefined spaceFlag;\n  undefined plusFlag;\n  undefined hashFlag;\n  undefined4 lengthMod;\n  \n  if ((fileDescriptor != 0) && (*(int *)(fileDescriptor + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = *(undefined4 **)(fileDescriptor + 4);\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stdout) {\n    stream = *(undefined4 **)(fileDescriptor + 8);\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stderr) {\n    stream = *(undefined4 **)(fileDescriptor + 0xc);\n  }\n  if ((-1 < (int)(stream[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(stream[0x16]);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1c)) || (stream[4] == 0)) &&\n     (integerValue = __swsetup_r(fileDescriptor,stream), integerValue != 0)) {\n    if ((-1 < (int)(stream[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x16)))\n    {\n      __retarget_lock_release_recursive(stream[0x16]);\n    }\n    return -1;\n  }\n  totalCharsWritten = 0;\n  spaceFlag = 0x20;\n  plusFlag = 0x30;\n  currentChar = formatString;\n  currentArg = args;\nLAB_0000588e:\n  formatPtr = currentChar;\n  if (*formatPtr != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  currentChar = formatPtr + 1;\n  if (*formatPtr == 0x25) {\nLAB_0000589a:\n    integerValue = (int)formatPtr - (int)formatString;\n    if (integerValue != 0) {\n      result = __sfputs_r(fileDescriptor,stream,formatString,integerValue);\n      if (result == -1) {\nLAB_00005a06:\n        if ((-1 < (int)(stream[0x19] << 0x1f)) &&\n           (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x16))) {\n          __retarget_lock_release_recursive(stream[0x16]);\n        }\n        if ((int)((uint)*(ushort *)(stream + 3) << 0x19) < 0) {\n          return -1;\n        }\n        return totalCharsWritten;\n      }\n      totalCharsWritten = totalCharsWritten + integerValue;\n    }\n    if (*formatPtr == 0) goto LAB_00005a06;\n    precision = -1;\n    bufferSize = 0;\n    flags = 0;\n    argWidth = 0;\n    hashFlag = 0;\n    lengthMod = 0;\n    currentChar = formatPtr + 1;\n    while( true ) {\n      formatPtr = currentChar + 1;\n      searchResult = memchr(\"#-0+ \",(uint)*currentChar,5);\n      if (searchResult == (void *)0x0) break;\n      flags = 1 << ((int)searchResult - 0x7bfcU & 0xff) | flags;\n      currentChar = formatPtr;\n    }\n    if ((int)(flags << 0x1b) < 0) {\n      hashFlag = 0x20;\n    }\n    if ((int)(flags << 0x1c) < 0) {\n      hashFlag = 0x2b;\n    }\n    if (*currentChar == 0x2a) {\n      argsPtr = currentArg + 1;\n      argWidth = *currentArg;\n      currentArg = argsPtr;\n      if (argWidth < 0) {\n        argWidth = -argWidth;\n        flags = flags | 2;\n      }\n    }\n    else {\n      foundNumber = false;\n      integerValue = argWidth;\n      formatPtr = currentChar;\n      while( true ) {\n        if (9 < *formatPtr - 0x30) break;\n        integerValue = integerValue * 10 + (*formatPtr - 0x30);\n        foundNumber = true;\n        formatPtr = formatPtr + 1;\n      }\n      if (foundNumber) {\n        argWidth = integerValue;\n      }\n    }\n    if (*formatPtr == 0x2e) {\n      if (formatPtr[1] == 0x2a) {\n        precision = *currentArg;\n        if (precision < 0) {\n          precision = -1;\n        }\n        formatPtr = formatPtr + 2;\n        currentArg = currentArg + 1;\n      }\n      else {\n        foundNumber = false;\n        precision = 0;\n        integerValue = 0;\n        while( true ) {\n          formatPtr = formatPtr + 1;\n          if (9 < *formatPtr - 0x30) break;\n          integerValue = integerValue * 10 + (*formatPtr - 0x30);\n          foundNumber = true;\n        }\n        if (foundNumber) {\n          precision = integerValue;\n        }\n      }\n    }\n    searchResult = memchr(&DAT_00007c02,(uint)*formatPtr,3);\n    if (searchResult != (void *)0x0) {\n      flags = flags | 0x40 << ((int)searchResult - 0x7c02U & 0xff);\n      formatPtr = formatPtr + 1;\n    }\n    formatString = formatPtr + 1;\n    specifier = *formatPtr;\n    searchResult = memchr(\"efgEFG\",(uint)specifier,6);\n    if (searchResult == (void *)0x0) {\n      resultVar = _printf_i(fileDescriptor,&flags,stream,0x57d3,&currentArg);\n      if (resultVar == -1) goto LAB_00005a06;\n    }\n    else {\n      currentArg = (int *)(((int)currentArg + 7U & 0xfffffff8) + 8);\n    }\n    totalCharsWritten = totalCharsWritten + resultVar;\n    currentChar = formatString;\n  }\n  goto LAB_0000588e;\n}\n\n",
            "renaming": {
                "FUN_000057f8": "process_format_string_000057f8",
                "param_1": "fileDescriptor",
                "param_2": "stream",
                "param_3": "formatString",
                "param_4": "args",
                "bVar1": "foundNumber",
                "iVar2": "integerValue",
                "iVar3": "result",
                "pvVar4": "searchResult",
                "piVar5": "argsPtr",
                "pbVar6": "formatPtr",
                "unaff_r7": "resultVar",
                "pbVar7": "currentChar",
                "local_8c": "currentArg",
                "local_88": "flags",
                "local_84": "precision",
                "uStack_80": "bufferSize",
                "local_7c": "argWidth",
                "local_74": "totalCharsWritten",
                "local_70": "specifier",
                "local_6f": "spaceFlag",
                "local_6e": "plusFlag",
                "local_45": "hashFlag",
                "local_30": "lengthMod"
            },
            "calling": [
                "iprintf"
            ],
            "called": [
                "_printf_i",
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__sfputs_r",
                "__retarget_lock_release_recursive",
                "memchr",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005a58": {
            "entrypoint": "0x00005a58",
            "current_name": "calculate_size_00005a58",
            "code": "\nundefined4\ncalculateSize_00005a58(undefined4 input,uint *data,uint *outputSize,undefined4 param4,code *callback)\n\n{\n  int i;\n  undefined4 result;\n  int tempVar;\n  uint maxSize;\n  uint index;\n  bool isZero;\n  \n  maxSize = data[4];\n  if ((int)data[4] < (int)data[2]) {\n    maxSize = data[2];\n  }\n  *outputSize = maxSize;\n  if (*(char *)((int)data + 0x43) != '\\0') {\n    *outputSize = maxSize + 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *outputSize = *outputSize + 2;\n  }\n  if ((*data & 6) == 0) {\n    for (i = 0; i < (int)(data[3] - *outputSize); i = i + 1) {\n      tempVar = (*callback)(input,param4,(int)data + 0x19,1);\n      if (tempVar == -1) goto errorLabel;\n    }\n  }\n  maxSize = (uint)*(byte *)((int)data + 0x43);\n  if (maxSize != 0) {\n    maxSize = 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *(undefined *)((int)data + maxSize + 0x43) = 0x30;\n    *(undefined *)((int)data + maxSize + 0x44) = *(undefined *)((int)data + 0x45);\n    maxSize = maxSize + 2;\n  }\n  i = (*callback)(input,param4,(int)data + 0x43,maxSize);\n  if (i == -1) {\nerrorLabel:\n    result = 0xffffffff;\n  }\n  else {\n    maxSize = data[3];\n    isZero = (*data & 6) == 4;\n    if (isZero) {\n      maxSize = maxSize - *outputSize;\n    }\n    if (isZero) {\n      maxSize = maxSize & ~((int)maxSize >> 0x1f);\n    }\n    else {\n      maxSize = 0;\n    }\n    if ((int)data[4] < (int)data[2]) {\n      maxSize = maxSize + (data[2] - data[4]);\n    }\n    for (index = 0; maxSize != index; index = index + 1) {\n      i = (*callback)(input,param4,(int)data + 0x1a,1);\n      if (i == -1) goto errorLabel;\n    }\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00005a58": "calculate_size_00005a58",
                "param_1": "input",
                "param_2": "data",
                "param_3": "outputSize",
                "param_4": "param4",
                "param_5": "callback",
                "iVar1": "i",
                "uVar2": "result",
                "iVar3": "tempVar",
                "uVar4": "maxSize",
                "uVar5": "index",
                "bVar6": "isZero",
                "LAB_00005afc": "errorLabel"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005b34": {
            "entrypoint": "0x00005b34",
            "current_name": "print_formatted_00005b34",
            "code": "\ncode * print_formatted_00005b34(undefined4 format_string,uint *arg_ptr,undefined4 width,code *writer_func,uint **arg_list\n                   )\n\n{\n  bool is_larger;\n  byte format_char;\n  int result;\n  code *return_value;\n  char *char_set;\n  void *memchr_result;\n  int write_result;\n  char *string;\n  uint tmp_val;\n  uint *arg_ptr_copy;\n  uint base;\n  uint **arg_list_copy;\n  char **string_arg;\n  uint arg_size;\n  char *curr_char;\n  uint *puVar15;\n  undefined4 flags;\n  code *local_writer;\n  \n  format_char = *(byte *)(arg_ptr + 6);\n  string = (char *)((int)arg_ptr + 0x43);\n  puVar15 = arg_ptr;\n  flags = width;\n  local_writer = writer_func;\n  if (0x78 < format_char) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)arg_ptr + 0x42) = format_char;\nLAB_00005bdc:\n    string = (char *)((int)arg_ptr + 0x42);\n    tmp_val = 1;\nLAB_00005d28:\n    arg_ptr[4] = tmp_val;\n    *(undefined *)((int)arg_ptr + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (format_char < 99) {\n    if (format_char == 0) goto LAB_00005d06;\n    if (format_char == 0x58) {\n      char_set = \"0123456789ABCDEF\";\n      *(undefined *)((int)arg_ptr + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(format_char) {\n  case 99:\n    tmp_val = **arg_list;\n    *arg_list = *arg_list + 1;\n    *(char *)((int)arg_ptr + 0x42) = (char)tmp_val;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    base = *arg_ptr;\n    arg_ptr_copy = *arg_list;\n    if ((int)(base << 0x18) < 0) {\n      tmp_val = *arg_ptr_copy;\n      *arg_list = arg_ptr_copy + 1;\n    }\n    else {\n      tmp_val = *arg_ptr_copy;\n      *arg_list = arg_ptr_copy + 1;\n      if ((base & 0x40) != 0) {\n        tmp_val = (uint)(short)tmp_val;\n      }\n    }\n    if ((int)tmp_val < 0) {\n      tmp_val = -tmp_val;\n      *(undefined *)((int)arg_ptr + 0x43) = 0x2d;\n    }\n    char_set = \"0123456789ABCDEF\";\n    base = 10;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    arg_list_copy = (uint **)*arg_list;\n    base = *arg_ptr;\n    tmp_val = arg_ptr[5];\n    *arg_list = (uint *)(arg_list_copy + 1);\n    arg_ptr_copy = *arg_list_copy;\n    if (((int)(base << 0x18) < 0) || (-1 < (int)(base << 0x19))) {\n      *arg_ptr_copy = tmp_val;\n    }\n    else {\n      *(short *)arg_ptr_copy = (short)tmp_val;\n    }\nLAB_00005d06:\n    arg_ptr[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    arg_ptr_copy = *arg_list;\n    tmp_val = *arg_ptr;\n    *arg_list = arg_ptr_copy + 1;\n    if (((int)(tmp_val << 0x18) < 0) || (-1 < (int)(tmp_val << 0x19))) {\n      tmp_val = *arg_ptr_copy;\n    }\n    else {\n      tmp_val = (uint)*(ushort *)arg_ptr_copy;\n    }\n    char_set = \"0123456789ABCDEF\";\n    if (format_char == 0x6f) {\n      base = 8;\n    }\n    else {\n      base = 10;\n    }\n    break;\n  case 0x70:\n    *arg_ptr = *arg_ptr | 0x20;\n  case 0x78:\n    char_set = \"0123456789abcdef\";\n    *(undefined *)((int)arg_ptr + 0x45) = 0x78;\nLAB_00005ca8:\n    base = *arg_ptr;\n    tmp_val = **arg_list;\n    *arg_list = *arg_list + 1;\n    if ((-1 < (int)(base << 0x18)) && ((int)(base << 0x19) < 0)) {\n      tmp_val = tmp_val & 0xffff;\n    }\n    if ((int)(base << 0x1f) < 0) {\n      *arg_ptr = base | 0x20;\n    }\n    if (tmp_val == 0) {\n      *arg_ptr = *arg_ptr & 0xffffffdf;\n    }\n    base = 0x10;\n    break;\n  case 0x73:\n    string_arg = (char **)*arg_list;\n    *arg_list = (uint *)(string_arg + 1);\n    string = *string_arg;\n    memchr_result = memchr(string,0,arg_ptr[1]);\n    if (memchr_result != (void *)0x0) {\n      arg_ptr[1] = (int)memchr_result - (int)string;\n    }\n    tmp_val = arg_ptr[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)arg_ptr + 0x43) = 0;\nLAB_00005c36:\n  arg_size = arg_ptr[1];\n  arg_ptr[2] = arg_size;\n  if (-1 < (int)arg_size) {\n    *arg_ptr = *arg_ptr & 0xfffffffb;\n  }\n  curr_char = string;\n  if ((tmp_val != 0) || (arg_size != 0)) {\n    do {\n      curr_char = curr_char + -1;\n      *curr_char = char_set[tmp_val - base * (tmp_val / base)];\n      is_larger = base <= tmp_val;\n      tmp_val = tmp_val / base;\n    } while (is_larger);\n  }\n  if (((base == 8) && ((int)(*arg_ptr << 0x1f) < 0)) && ((int)arg_ptr[1] <= (int)arg_ptr[4])) {\n    curr_char[-1] = '0';\n    curr_char = curr_char + -1;\n  }\n  arg_ptr[4] = (int)string - (int)curr_char;\n  string = curr_char;\nLAB_00005c84:\n  result = _printf_common(format_string,arg_ptr,&local_writer,width,writer_func,puVar15,flags);\n  if ((result == -1) || (result = (*writer_func)(format_string,width,string,arg_ptr[4]), result == -1)) {\nLAB_00005c98:\n    return_value = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*arg_ptr << 0x1e) < 0) {\n      for (result = 0; result < (int)(arg_ptr[3] - (int)local_writer); result = result + 1) {\n        write_result = (*writer_func)(format_string,width,(int)arg_ptr + 0x19,1);\n        if (write_result == -1) goto LAB_00005c98;\n      }\n    }\n    return_value = (code *)arg_ptr[3];\n    if ((int)(code *)arg_ptr[3] < (int)local_writer) {\n      return_value = local_writer;\n    }\n  }\n  return return_value;\n}\n\n",
            "renaming": {
                "FUN_00005b34": "print_formatted_00005b34",
                "param_1": "format_string",
                "param_2": "arg_ptr",
                "param_3": "width",
                "param_4": "writer_func",
                "param_5": "arg_list",
                "bVar1": "is_larger",
                "bVar2": "format_char",
                "iVar3": "result",
                "pcVar4": "return_value",
                "pcVar5": "char_set",
                "pcVar14": "curr_char",
                "puVar9": "arg_ptr_copy",
                "uVar8": "tmp_val",
                "uVar10": "base",
                "iVar7": "write_result",
                "ppuVar11": "arg_list_copy",
                "ppcVar12": "string_arg",
                "uVar13": "arg_size",
                "pvVar6": "memchr_result",
                "__s": "string",
                "uVar16": "flags",
                "local_24": "local_writer"
            },
            "calling": [
                "_vfprintf_r"
            ],
            "called": [
                "_printf_common",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005d80": {
            "entrypoint": "0x00005d80",
            "current_name": "write_byte_to_file_00005d80",
            "code": "\nuint writeByteToFile_00005d80(int filePtr,uint byte,undefined4 *stream)\n\n{\n  int count;\n  undefined *buffer;\n  \n  if ((filePtr != 0) && (*(int *)(filePtr + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = *(undefined4 **)(filePtr + 4);\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stdout) {\n    stream = *(undefined4 **)(filePtr + 8);\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stderr) {\n    stream = *(undefined4 **)(filePtr + 0xc);\n  }\n  if ((-1 < (int)(stream[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(stream[0x16]);\n  }\n  count = stream[2] + -1;\n  stream[2] = count;\n  if ((count < 0) && ((count < (int)stream[6] || ((byte & 0xff) == 10)))) {\n    byte = __swbuf_r(filePtr,byte,stream);\n  }\n  else {\n    buffer = (undefined *)*stream;\n    *stream = buffer + 1;\n    *buffer = (char)byte;\n    byte = byte & 0xff;\n  }\n  if ((-1 < (int)(stream[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x16))) {\n    __retarget_lock_release_recursive(stream[0x16]);\n  }\n  return byte;\n}\n\n",
            "renaming": {
                "FUN_00005d80": "write_byte_to_file_00005d80",
                "param_1": "filePtr",
                "param_2": "byte",
                "param_3": "stream",
                "iVar1": "count",
                "puVar2": "buffer"
            },
            "calling": [
                "putchar"
            ],
            "called": [
                "__swbuf_r",
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005e10": {
            "entrypoint": "0x00005e10",
            "current_name": "read_byte_00005e10",
            "code": "\nuint readByte_00005e10(int filePtr,byte **bufferPtr)\n\n{\n  int refillResult;\n  uint byteValue;\n  byte *currentByte;\n  \n  if ((filePtr != 0) && (*(int *)(filePtr + 0x18) == 0)) {\n    __sinit();\n  }\n  if (bufferPtr == (byte **)&__sf_fake_stdin) {\n    bufferPtr = *(byte ***)(filePtr + 4);\n  }\n  else if (bufferPtr == (byte **)&__sf_fake_stdout) {\n    bufferPtr = *(byte ***)(filePtr + 8);\n  }\n  else if (bufferPtr == (byte **)&__sf_fake_stderr) {\n    bufferPtr = *(byte ***)(filePtr + 0xc);\n  }\n  refillResult = __srefill_r(filePtr,bufferPtr);\n  if (refillResult == 0) {\n    bufferPtr[1] = bufferPtr[1] + -1;\n    currentByte = *bufferPtr;\n    *bufferPtr = currentByte + 1;\n    byteValue = (uint)*currentByte;\n  }\n  else {\n    byteValue = 0xffffffff;\n  }\n  return byteValue;\n}\n\n",
            "renaming": {
                "FUN_00005e10": "read_byte_00005e10",
                "param_1": "filePtr",
                "param_2": "bufferPtr",
                "iVar1": "refillResult",
                "uVar2": "byteValue",
                "pbVar3": "currentByte"
            },
            "calling": [
                "_getc_r"
            ],
            "called": [
                "__sinit",
                "__srefill_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005e68": {
            "entrypoint": "0x00005e68",
            "current_name": "scan_formatted_input_00005e68",
            "code": "\nint scanFormattedInput_00005e68(char *inputString,char *formatString,...)\n\n{\n  int scanResult;\n  undefined4 unusedParameter1;\n  undefined4 unusedParameter2;\n  char *scanStringPtr;\n  size_t inputStringLength;\n  undefined2 maxStringLength;\n  undefined2 escapedPercentValue;\n  char *formattedInputPtr;\n  size_t remainingStringLength;\n  undefined4 scannerBuffer1;\n  undefined4 scannerBuffer2;\n  undefined4 scannerBuffer3;\n  undefined4 unusedStackVar1;\n  undefined4 unusedStackVar2;\n  \n  maxStringLength = 0x204;\n  scanStringPtr = inputString;\n  formattedInputPtr = inputString;\n  unusedStackVar1 = unusedParameter1;\n  unusedStackVar2 = unusedParameter2;\n  inputStringLength = strlen(inputString);\n  scannerBuffer1 = 0x4deb;\n  scannerBuffer2 = 0;\n  scannerBuffer3 = 0;\n  escapedPercentValue = 0xffff;\n  remainingStringLength = inputStringLength;\n  scanResult = inputStringsvfiscanf_r(_impure_ptr,&scanStringPtr,formatString,&unusedStackVar1);\n  return scanResult;\n}\n\n",
            "renaming": {
                "FUN_00005e68": "scan_formatted_input_00005e68",
                "__s": "inputString",
                "__format": "formatString",
                "iVar1": "scanResult",
                "in_r2": "unusedParameter1",
                "in_r3": "unusedParameter2",
                "local_80": "scanStringPtr",
                "local_7c": "inputStringLength",
                "local_74": "maxStringLength",
                "local_72": "escapedPercentValue",
                "local_70": "formattedInputPtr",
                "local_6c": "remainingStringLength",
                "local_5c": "scannerBuffer1",
                "local_4c": "scannerBuffer2",
                "local_38": "scannerBuffer3",
                "uStack_8": "unusedStackVar1",
                "uStack_4": "unusedStackVar2"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "__ssvfiscanf_r",
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005ebc": {
            "entrypoint": "0x00005ebc",
            "current_name": "copy_string_00005ebc",
            "code": "\nchar * copyString_00005ebc(char *destination,char *source)\n\n{\n  char currentChar;\n  char *destinationPtr;\n  \n  destinationPtr = destination;\n  do {\n    currentChar = *source;\n    *destinationPtr = currentChar;\n    source = source + 1;\n    destinationPtr = destinationPtr + 1;\n  } while (currentChar != '\\0');\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_00005ebc": "copy_string_00005ebc",
                "__dest": "destination",
                "__src": "source",
                "cVar1": "currentChar",
                "pcVar2": "destinationPtr"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005ecc": {
            "entrypoint": "0x00005ecc",
            "current_name": "calculate_string_length_00005ecc",
            "code": "\nsize_t calculateStringLength_00005ecc(char *string)\n\n{\n  char currentChar;\n  char *nextCharPointer;\n  char *currentCharPointer;\n  \n  currentCharPointer = string;\n  do {\n    nextCharPointer = currentCharPointer + 1;\n    currentChar = *currentCharPointer;\n    currentCharPointer = nextCharPointer;\n  } while (currentChar != '\\0');\n  return (size_t)(nextCharPointer + (-1 - (int)string));\n}\n\n",
            "renaming": {
                "FUN_00005ecc": "calculate_string_length_00005ecc",
                "__s": "string",
                "pcVar3": "currentCharPointer",
                "pcVar2": "nextCharPointer",
                "cVar1": "currentChar"
            },
            "calling": [
                "siscanf",
                "_tzset_unlocked_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005edc": {
            "entrypoint": "0x00005edc",
            "current_name": "parse_integer_00005edc",
            "code": "\nuint parse_integer_00005edc(undefined4 *result,byte *input_string,byte **next_string,uint base)\n\n{\n  uint parsed_integer;\n  uint current_char;\n  byte is_negative;\n  int parse_status;\n  uint digit_value;\n  uint max_digit_value;\n  byte *current_char_ptr;\n  byte *next_char_ptr;\n  \n  next_char_ptr = input_string;\n  do {\n    current_char_ptr = next_char_ptr;\n    next_char_ptr = current_char_ptr + 1;\n    current_char = (uint)*current_char_ptr;\n    is_negative = (&DAT_00007a99)[current_char] & 8;\n  } while (((&DAT_00007a99)[current_char] & 8) != 0);\n  if (current_char == 0x2d) {\n    current_char = (uint)*next_char_ptr;\n    is_negative = 1;\n    next_char_ptr = current_char_ptr + 2;\n  }\n  else if (current_char == 0x2b) {\n    current_char = (uint)*next_char_ptr;\n    next_char_ptr = current_char_ptr + 2;\n  }\n  if (base == 0) {\n    if (current_char != 0x30) {\n      base = 10;\n      goto LAB_00005f26;\n    }\n  }\n  else if ((base != 0x10) || (current_char != 0x30)) goto LAB_00005f26;\n  if ((*next_char_ptr & 0xdf) == 0x58) {\n    current_char = (uint)next_char_ptr[1];\n    base = 0x10;\n    next_char_ptr = next_char_ptr + 2;\n  }\n  else {\n    current_char = 0x30;\n    if (base == 0) {\n      base = 8;\n    }\n  }\nLAB_00005f26:\n  parse_status = 0;\n  max_digit_value = 0xffffffff / base;\n  parsed_integer = 0;\n  do {\n    digit_value = current_char - 0x30;\n    if (9 < digit_value) {\n      if (current_char - 0x41 < 0x1a) {\n        digit_value = current_char - 0x37;\n      }\n      else {\n        if (0x19 < current_char - 0x61) break;\n        digit_value = current_char - 0x57;\n      }\n    }\n    if ((int)base <= (int)digit_value) break;\n    if (((parse_status < 0) || (max_digit_value < parsed_integer)) ||\n       ((max_digit_value == parsed_integer && ((int)~(base * max_digit_value) < (int)digit_value)))) {\n      parse_status = -1;\n    }\n    else {\n      parsed_integer = parsed_integer * base + digit_value;\n      parse_status = 1;\n    }\n    current_char = (uint)*next_char_ptr;\n    next_char_ptr = next_char_ptr + 1;\n  } while( true );\n  if (parse_status < 0) {\n    *result = 0x22;\n    parsed_integer = 0xffffffff;\n    if (next_string == (byte **)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (is_negative != 0) {\n      parsed_integer = -parsed_integer;\n    }\n    if (next_string == (byte **)0x0) {\n      return parsed_integer;\n    }\n    if (parse_status == 0) goto LAB_00005fb8;\n  }\n  input_string = next_char_ptr + -1;\nLAB_00005fb8:\n  *next_string = input_string;\n  return parsed_integer;\n}\n\n",
            "renaming": {
                "FUN_00005edc": "parse_integer_00005edc",
                "param_1": "result",
                "param_2": "input_string",
                "param_3": "next_string",
                "param_4": "base",
                "uVar1": "parsed_integer",
                "uVar2": "current_char",
                "bVar3": "is_negative",
                "iVar4": "parse_status",
                "uVar5": "digit_value",
                "uVar6": "max_digit_value",
                "pbVar7": "current_char_ptr",
                "pbVar8": "next_char_ptr"
            },
            "calling": [
                "_strtoul_r",
                "strtoul"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005fd4": {
            "entrypoint": "0x00005fd4",
            "current_name": "FUN_00005fd4",
            "code": "\nuint _strtoul_l_isra_0(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  byte bVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  byte *pbVar7;\n  byte *pbVar8;\n  \n  pbVar8 = param_2;\n  do {\n    pbVar7 = pbVar8;\n    pbVar8 = pbVar7 + 1;\n    uVar2 = (uint)*pbVar7;\n    bVar3 = (&DAT_00007a99)[uVar2] & 8;\n  } while (((&DAT_00007a99)[uVar2] & 8) != 0);\n  if (uVar2 == 0x2d) {\n    uVar2 = (uint)*pbVar8;\n    bVar3 = 1;\n    pbVar8 = pbVar7 + 2;\n  }\n  else if (uVar2 == 0x2b) {\n    uVar2 = (uint)*pbVar8;\n    pbVar8 = pbVar7 + 2;\n  }\n  if (param_4 == 0) {\n    if (uVar2 != 0x30) {\n      param_4 = 10;\n      goto LAB_00005f26;\n    }\n  }\n  else if ((param_4 != 0x10) || (uVar2 != 0x30)) goto LAB_00005f26;\n  if ((*pbVar8 & 0xdf) == 0x58) {\n    uVar2 = (uint)pbVar8[1];\n    param_4 = 0x10;\n    pbVar8 = pbVar8 + 2;\n  }\n  else {\n    uVar2 = 0x30;\n    if (param_4 == 0) {\n      param_4 = 8;\n    }\n  }\nLAB_00005f26:\n  iVar4 = 0;\n  uVar6 = 0xffffffff / param_4;\n  uVar1 = 0;\n  do {\n    uVar5 = uVar2 - 0x30;\n    if (9 < uVar5) {\n      if (uVar2 - 0x41 < 0x1a) {\n        uVar5 = uVar2 - 0x37;\n      }\n      else {\n        if (0x19 < uVar2 - 0x61) break;\n        uVar5 = uVar2 - 0x57;\n      }\n    }\n    if ((int)param_4 <= (int)uVar5) break;\n    if (((iVar4 < 0) || (uVar6 < uVar1)) ||\n       ((uVar6 == uVar1 && ((int)~(param_4 * uVar6) < (int)uVar5)))) {\n      iVar4 = -1;\n    }\n    else {\n      uVar1 = uVar1 * param_4 + uVar5;\n      iVar4 = 1;\n    }\n    uVar2 = (uint)*pbVar8;\n    pbVar8 = pbVar8 + 1;\n  } while( true );\n  if (iVar4 < 0) {\n    *param_1 = 0x22;\n    uVar1 = 0xffffffff;\n    if (param_3 == (byte **)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (bVar3 != 0) {\n      uVar1 = -uVar1;\n    }\n    if (param_3 == (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar4 == 0) goto LAB_00005fb8;\n  }\n  param_2 = pbVar8 + -1;\nLAB_00005fb8:\n  *param_3 = param_2;\n  return uVar1;\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "_strtoul_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005fd8": {
            "entrypoint": "0x00005fd8",
            "current_name": "convert_string_to_unsigned_long_00005fd8",
            "code": "\nulong convertStringToUnsignedLong_00005fd8(char *string,char **endOfString,int base)\n\n{\n  ulong result;\n  \n  result = _strtoul_l_isra_0(_impure_ptr,string,endOfString,base);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00005fd8": "convert_string_to_unsigned_long_00005fd8",
                "__nptr": "string",
                "__endptr": "endOfString",
                "__base": "base",
                "uVar1": "result"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "_strtoul_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005fec": {
            "entrypoint": "0x00005fec",
            "current_name": "acquire_recursive_lock_00005fec",
            "code": "\nvoid acquire_recursive_lock_00005fec(void)\n\n{\n  __retarget_lock_acquire_recursive(&recursive_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005fec": "acquire_recursive_lock_00005fec",
                "__lock___env_recursive_mutex": "recursive_mutex"
            },
            "calling": [
                "_findenv_r"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005ff8": {
            "entrypoint": "0x00005ff8",
            "current_name": "release_recursive_lock_00005ff8",
            "code": "\nvoid releaseRecursiveLock_00005ff8(void)\n\n{\n  releaseRecursiveLock_00005ff8(&__lock___env_recursive_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005ff8": "release_recursive_lock_00005ff8",
                "__retarget_lock_release_recursive": "releaseRecursiveLock"
            },
            "calling": [
                "_findenv_r"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006010": {
            "entrypoint": "0x00006010",
            "current_name": "find_character_00006010",
            "code": "\nvoid * find_character_00006010(void *input_string,int character,size_t length)\n\n{\n  byte current_byte;\n  char flag1;\n  char flag2;\n  char flag3;\n  char flag4;\n  byte *pointer1;\n  uint *pointer2;\n  byte *pointer3;\n  uint target_character;\n  uint alignment;\n  uint remaining_length;\n  uint xored_value1;\n  uint xored_value2;\n  bool xor_flag1;\n  bool xor_flag2;\n  bool xor_flag3;\n  bool xor_flag4;\n  \n  target_character = character & 0xff;\n  if ((int)length < 0x10) {\njoined_r0x00006070:\n    do {\n      if (length == 0) {\n        return (void *)0x0;\n      }\n                    /* WARNING: Load size is inaccurate */\n      pointer2 = (uint *)((int)input_string + 1);\n      current_byte = *input_string;\n      length = length - 1;\n      input_string = pointer2;\n    } while (current_byte != target_character);\n  }\n  else {\n    alignment = (uint)input_string & 7;\n    while( true ) {\n      if (alignment == 0) {\n        alignment = target_character | target_character << 8;\n        alignment = alignment | alignment << 0x10;\n        remaining_length = length & 0xfffffff8;\n        do {\n          pointer2 = (uint *)((int)input_string + 8);\n                    /* WARNING: Load size is inaccurate */\n          remaining_length = remaining_length - 8;\n          xored_value1 = *input_string ^ alignment;\n          xored_value2 = *(uint *)((int)input_string + 4) ^ alignment;\n          flag1 = -((char)xored_value1 == '\\0');\n          flag2 = -((char)(xored_value1 >> 8) == '\\0');\n          flag3 = -((char)(xored_value1 >> 0x10) == '\\0');\n          flag4 = -((char)(xored_value1 >> 0x18) == '\\0');\n          xored_value1 = CONCAT13(flag4,CONCAT12(flag3,CONCAT11(flag2,flag1)));\n          xor_flag1 = (char)xored_value2 != '\\0';\n          xor_flag2 = (char)(xored_value2 >> 8) != '\\0';\n          xor_flag3 = (char)(xored_value2 >> 0x10) != '\\0';\n          xor_flag4 = (char)(xored_value2 >> 0x18) != '\\0';\n          xored_value2 = CONCAT13(xor_flag4 * flag4 - !xor_flag4,\n                            CONCAT12(xor_flag3 * flag3 - !xor_flag3,\n                                     CONCAT11(xor_flag2 * flag2 - !xor_flag2,xor_flag1 * flag1 - !xor_flag1)));\n          if (xored_value2 != 0) {\n            if (xored_value1 == 0) {\n              pointer3 = (byte *)((int)input_string + 5);\n              xored_value1 = xored_value2;\n            }\n            else {\n              pointer3 = (byte *)((int)input_string + 1);\n            }\n            if ((xored_value1 & 1) == 0) {\n              xor_flag1 = (xored_value1 & 0x100) == 0;\n              pointer1 = pointer3 + 1;\n              if (xor_flag1) {\n                xor_flag1 = (xored_value1 & 0x18000) == 0;\n                pointer1 = pointer3 + 2;\n              }\n              pointer3 = pointer1;\n              if (xor_flag1) {\n                pointer3 = pointer3 + 1;\n              }\n            }\n            return pointer3 + -1;\n          }\n          input_string = pointer2;\n        } while (remaining_length != 0);\n        length = length & 7;\n        goto joined_r0x00006070;\n      }\n                    /* WARNING: Load size is inaccurate */\n      pointer2 = (uint *)((int)input_string + 1);\n      length = length - 1;\n      if (*input_string == target_character) break;\n      alignment = (uint)pointer2 & 7;\n      input_string = pointer2;\n      if (length == 0) {\n        return (void *)0x0;\n      }\n    }\n  }\n  return (byte *)((int)pointer2 + -1);\n}\n\n",
            "renaming": {
                "FUN_00006010": "find_character_00006010",
                "__s": "input_string",
                "__c": "character",
                "__n": "length",
                "bVar1": "current_byte",
                "cVar2": "flag1",
                "cVar3": "flag2",
                "cVar4": "flag3",
                "cVar5": "flag4",
                "pbVar6": "pointer1",
                "puVar7": "pointer2",
                "pbVar8": "pointer3",
                "uVar9": "target_character",
                "uVar10": "alignment",
                "uVar11": "remaining_length",
                "uVar12": "xored_value1",
                "uVar13": "xored_value2",
                "bVar14": "xor_flag1",
                "bVar15": "xor_flag2",
                "bVar16": "xor_flag3",
                "bVar17": "xor_flag4"
            },
            "calling": [
                "_printf_i",
                "__ssvfiscanf_r",
                "_vfprintf_r",
                "_scanf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000060b0": {
            "entrypoint": "0x000060b0",
            "current_name": "copy_memory_000060b0",
            "code": "\nvoid * copy_memory_000060b0(void *destination,void *source,size_t size)\n\n{\n  undefined *src_ptr;\n  undefined *src_end;\n  undefined *dest_ptr;\n  \n  src_end = (undefined *)(size + (int)source);\n  dest_ptr = (undefined *)((int)destination + -1);\n  if ((undefined *)source != src_end) {\n    do {\n                    /* WARNING: Load size is inaccurate */\n      src_ptr = (undefined *)((int)source + 1);\n      dest_ptr = dest_ptr + 1;\n      *dest_ptr = *source;\n      source = src_ptr;\n    } while (src_ptr != src_end);\n    return destination;\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_000060b0": "copy_memory_000060b0",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "puVar1": "src_ptr",
                "puVar2": "src_end",
                "puVar3": "dest_ptr"
            },
            "calling": [
                "__submore",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000060cc": {
            "entrypoint": "0x000060cc",
            "current_name": "resize_and_copy_memory_000060cc",
            "code": "\nvoid * resizeAndCopyMemory_000060cc(undefined4 memory_allocator,void *source_buffer,uint source_size,undefined4 extra_param)\n\n{\n  void *destination_buffer;\n  uint usable_size;\n  \n  if (source_buffer != (void *)0x0) {\n    if (source_size == 0) {\n      _free_r();\n      destination_buffer = (void *)0x0;\n    }\n    else {\n      usable_size = _malloc_usable_size_r();\n      destination_buffer = source_buffer;\n      if ((usable_size < source_size) && (destination_buffer = (void *)_malloc_r(memory_allocator,source_size), destination_buffer != (void *)0x0))\n      {\n        memcpy(destination_buffer,source_buffer,source_size);\n        _free_r(memory_allocator,source_buffer);\n      }\n    }\n    return destination_buffer;\n  }\n  destination_buffer = (void *)_malloc_r(memory_allocator,source_size,source_size,extra_param);\n  return destination_buffer;\n}\n\n",
            "renaming": {
                "FUN_000060cc": "resize_and_copy_memory_000060cc",
                "param_1": "memory_allocator",
                "param_2": "source_buffer",
                "param_3": "source_size",
                "param_4": "extra_param",
                "pvVar1": "destination_buffer",
                "uVar2": "usable_size"
            },
            "calling": [
                "__submore"
            ],
            "called": [
                "_malloc_r",
                "memcpy",
                "_malloc_usable_size_r",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006118": {
            "entrypoint": "0x00006118",
            "current_name": "update_data_00006118",
            "code": "\nuint updateData_00006118(undefined4 status,uint value,uint *data,undefined4 config)\n\n{\n  int result;\n  uint counter;\n  uint dataValue;\n  \n  if (value == 0xffffffff) {\nendLoop:\n    value = 0xffffffff;\n  }\n  else {\n    *(ushort *)(data + 3) = *(ushort *)(data + 3) & 0xffdf;\n    counter = data[1];\n    value = value & 0xff;\n    if (data[0xd] == 0) {\n      dataValue = *data;\n      if (((data[4] != 0) && (data[4] < dataValue)) && (*(byte *)(dataValue - 1) == value)) {\n        *data = dataValue - 1;\n        data[1] = counter + 1;\n        return value;\n      }\n      data[0xf] = dataValue;\n      data[0x10] = counter;\n      data[0xd] = (uint)(data + 0x11);\n      data[0xe] = 3;\n      *(undefined *)((int)data + 0x46) = (char)value;\n      *data = (uint)(undefined *)((int)data + 0x46);\n      counter = 1;\n    }\n    else {\n      if (((int)data[0xe] <= (int)counter) &&\n         (result = subtractionHelper(status,data,counter,data[0xe],config), result != 0))\n      goto endLoop;\n      counter = *data;\n      *data = counter - 1;\n      *(char *)(counter - 1) = (char)value;\n      counter = data[1] + 1;\n    }\n    data[1] = counter;\n  }\n  return value;\n}\n\n",
            "renaming": {
                "FUN_00006118": "update_data_00006118",
                "param_1": "status",
                "param_2": "value",
                "param_3": "data",
                "param_4": "config",
                "iVar1": "result",
                "uVar2": "counter",
                "uVar3": "dataValue",
                "LAB_00006120": "endLoop",
                "__submore": "subtractionHelper"
            },
            "calling": [],
            "called": [
                "__submore"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006192": {
            "entrypoint": "0x00006192",
            "current_name": "clear_memory_block_00006192",
            "code": "\nundefined4 clearMemoryBlock_00006192(undefined4 param,undefined4 *memoryBlock)\n\n{\n  if ((undefined4 *)memoryBlock[0xd] != (undefined4 *)0x0) {\n    if ((undefined4 *)memoryBlock[0xd] != memoryBlock + 0x11) {\n      _free_r();\n    }\n    memoryBlock[1] = memoryBlock[0x10];\n    memoryBlock[0xd] = 0;\n    if (memoryBlock[0x10] != 0) {\n      *memoryBlock = memoryBlock[0xf];\n      return 0;\n    }\n  }\n  *memoryBlock = memoryBlock[4];\n  memoryBlock[1] = 0;\n  *(ushort *)(memoryBlock + 3) = *(ushort *)(memoryBlock + 3) | 0x20;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00006192": "clear_memory_block_00006192",
                "param_1": "param",
                "param_2": "memoryBlock"
            },
            "calling": [
                "__ssvfiscanf_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000061cc": {
            "entrypoint": "0x000061cc",
            "current_name": "process_input_000061cc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006482) */\n\nint process_input_000061cc(undefined4 param1,byte **param2,byte *param3,int **param4)\n\n{\n  int var1;\n  void *var2;\n  uint var3;\n  byte *var4;\n  uint var5;\n  int **local_param4;\n  undefined stack_array [256];\n  uint local_var3;\n  undefined4 local_var2;\n  uint local_var5;\n  int local_var1;\n  int local_var6;\n  undefined *local_var7;\n  int local_var8;\n  undefined4 local_var9;\n  code *local_var10;\n  \n  local_var1 = 0;\n  local_var6 = 0;\n  local_var9 = 0x6119;\n  local_var10 = __ssrefill_r + 1;\n  local_param4 = param4;\n  local_var7 = stack_array;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      var5 = (uint)*param3;\n      if (var5 == 0) {\n        return local_var1;\n      }\n      var3 = (byte)(&DAT_00007a99)[var5] & 8;\n      var4 = param3 + 1;\n      if (((&DAT_00007a99)[var5] & 8) == 0) break;\n      while (((param3 = var4, 0 < (int)param2[1] ||\n              (var1 = (*local_var10)(param1,param2), var1 == 0)) &&\n             ((int)((uint)(byte)(&DAT_00007a99)[**param2] << 0x1c) < 0))) {\n        local_var6 = local_var6 + 1;\n        param2[1] = param2[1] + -1;\n        *param2 = *param2 + 1;\n      }\n    }\n    if (var5 == 0x25) break;\nLAB_00006352:\n    if (((int)param2[1] < 1) && (var1 = (*local_var10)(param1,param2), var1 != 0))\n    goto LAB_00006380;\n    if (**param2 != var5) {\n      return local_var1;\n    }\n    *param2 = *param2 + 1;\n    local_var6 = local_var6 + 1;\n    param2[1] = param2[1] + -1;\n    param3 = var4;\n  }\n  local_var5 = var3;\n  local_var3 = var3;\n  if (param3[1] == 0x2a) {\n    var4 = param3 + 2;\n    local_var3 = 0x10;\n  }\n  while( true ) {\n    var3 = (uint)*var4;\n    if (9 < var3 - 0x30) break;\n    var4 = var4 + 1;\n    local_var5 = (local_var5 * 10 + var3) - 0x30;\n  }\n  var2 = memchr(&DAT_00007c02,var3,3);\n  if (var2 != (void *)0x0) {\n    local_var3 = 1 << ((int)var2 - 0x7c02U & 0xff) | local_var3;\n    var4 = var4 + 1;\n  }\n  param3 = var4 + 1;\n  var3 = (uint)*var4;\n  if (var3 < 0x79) {\n    if (0x57 < var3) {\n      switch(var3) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        param3 = (byte *)__sccl(stack_array,param3);\n        local_var3 = local_var3 | 0x40;\n        local_var8 = 1;\n        break;\n      case 99:\n        local_var3 = local_var3 | 0x40;\n        local_var8 = 0;\n        break;\n      case 100:\n      case 0x75:\n        local_var2 = 10;\nLAB_000063a0:\n        if (var3 < 0x6f) {\n          local_var8 = 3;\n        }\n        else {\n          local_var8 = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        local_var8 = 5;\n        break;\n      case 0x69:\n        local_var2 = 0;\n        local_var8 = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(local_var3 << 0x1b)) {\n          if ((int)(local_var3 << 0x1f) < 0) {\n            *(short *)*local_param4 = (short)local_var6;\n            local_param4 = local_param4 + 1;\n          }\n          else {\n            **local_param4 = local_var6;\n            local_param4 = local_param4 + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        local_var2 = 8;\n        local_var8 = 4;\n        break;\n      case 0x70:\n        local_var3 = local_var3 | 0x20;\n      case 0x58:\n      case 0x78:\n        local_var3 = local_var3 | 0x200;\n        local_var2 = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        local_var8 = 2;\n      }\nLAB_000063ac:\n      if (((int)param2[1] < 1) && (var1 = (*local_var10)(param1,param2), var1 != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(local_var3 << 0x19)) {\n        while ((int)((uint)(byte)(&DAT_00007a99)[**param2] << 0x1c) < 0) {\n          local_var6 = local_var6 + 1;\n          var4 = param2[1];\n          param2[1] = var4 + -1;\n          if ((int)(var4 + -1) < 1) {\n            var1 = (*local_var10)(param1,param2);\n            if (var1 != 0) goto LAB_00006380;\n          }\n          else {\n            *param2 = *param2 + 1;\n          }\n        }\n      }\n      if (local_var8 < 3) {\n        var1 = _scanf_chars(param1,&local_var3,param2,&local_param4);\n      }\n      else {\n        if (4 < local_var8) goto LAB_000061f6;\n        var1 = _scanf_i(param1,&local_var3,param2,&local_param4);\n      }\n      if (var1 == 1) {\n        return local_var1;\n      }\n      if (var1 == 2) {\nLAB_00006380:\n        if (local_var1 == 0) {\nLAB_00006388:\n          local_var1 = -1;\n        }\n        else if ((*(ushort *)(param2 + 3) & 0x40) != 0) {\n          local_var1 = -1;\n        }\n        return local_var1;\n      }\n      goto LAB_000061f6;\n    }\n    var4 = param3;\n    if (var3 == 0x25) goto LAB_00006352;\n    if (var3 < 0x26) {\n      if (var3 != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (var3 - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  local_var8 = 3;\n  local_var2 = 10;\n  goto LAB_000063ac;\n}\n\n",
            "renaming": {
                "FUN_000061cc": "process_input_000061cc",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "iVar1": "var1",
                "pvVar2": "var2",
                "uVar3": "var3",
                "pbVar4": "var4",
                "uVar5": "var5",
                "local_2b0": "local_param4",
                "auStack_2ac": "stack_array",
                "local_1ac": "local_var3",
                "local_1a8": "local_var2",
                "local_1a4": "local_var5",
                "local_1a0": "local_var1",
                "local_19c": "local_var6",
                "local_198": "local_var7",
                "local_194": "local_var8",
                "local_30": "local_var9",
                "local_2c": "local_var10"
            },
            "calling": [
                "siscanf"
            ],
            "called": [
                "__sccl",
                "__ssrefill_r",
                "_scanf_chars",
                "_scanf_i",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000064bc": {
            "entrypoint": "0x000064bc",
            "current_name": "reverse_and_improve_000064bc",
            "code": "\nundefined4 reverse_and_improve_000064bc(undefined4 input_param,uint *param_array,byte **byte_array_ptr,undefined4 *result_ptr)\n\n{\n  int result;\n  uint flag;\n  byte **byte_ptr_ptr;\n  byte *byte_ptr;\n  byte *current_byte_ptr;\n  byte *byte_ptr_2;\n  int counter;\n  \n  if (param_array[2] == 0) {\n    if (param_array[6] == 0) {\n      flag = 1;\n    }\n    else {\n      flag = 0xffffffff;\n    }\n    param_array[2] = flag;\n  }\n  if (-1 < (int)(*param_array << 0x1b)) {\n    byte_ptr_ptr = (byte **)*result_ptr;\n    *result_ptr = byte_ptr_ptr + 1;\n    current_byte_ptr = *byte_ptr_ptr;\n  }\n  counter = 0;\n  do {\n    flag = param_array[6];\n    if (flag != 0) {\n      if (flag == 1) {\n        if (*(char *)(param_array[5] + (uint)**byte_array_ptr) == '\\0') {\n          if (counter == 0) {\n            return 1;\n          }\nLAB_0000654a:\n          if (((*param_array & 0x10) == 0) && (param_array[3] = param_array[3] + 1, param_array[6] != 0)) {\n            *current_byte_ptr = 0;\n          }\n          param_array[4] = counter + param_array[4];\n          return 0;\n        }\n      }\n      else if ((flag != 2) || ((int)((uint)(byte)(&DAT_00007a99)[**byte_array_ptr] << 0x1c) < 0))\n      goto LAB_0000654a;\n    }\n    byte_ptr_2 = current_byte_ptr;\n    if (-1 < (int)(*param_array << 0x1b)) {\n      byte_ptr_2 = current_byte_ptr + 1;\n      *current_byte_ptr = **byte_array_ptr;\n    }\n    byte_ptr = byte_array_ptr[1];\n    *byte_array_ptr = *byte_array_ptr + 1;\n    flag = param_array[2] - 1;\n    byte_array_ptr[1] = byte_ptr + -1;\n    counter = counter + 1;\n    param_array[2] = flag;\n    current_byte_ptr = byte_ptr_2;\n    if ((flag == 0) ||\n       (((int)(byte_ptr + -1) < 1 &&\n        (result = (*(code *)param_array[0x60])(input_param,byte_array_ptr,flag,(code *)param_array[0x60],result_ptr),\n        result != 0)))) goto LAB_0000654a;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000064bc": "reverse_and_improve_000064bc",
                "param_1": "input_param",
                "param_2": "param_array",
                "param_3": "byte_array_ptr",
                "param_4": "result_ptr",
                "iVar1": "result",
                "uVar2": "flag",
                "ppbVar3": "byte_ptr_ptr",
                "pbVar4": "byte_ptr",
                "unaff_r6": "current_byte_ptr",
                "pbVar5": "byte_ptr_2",
                "iVar6": "counter"
            },
            "calling": [
                "__ssvfiscanf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000656c": {
            "entrypoint": "0x0000656c",
            "current_name": "parse_input_0000656c",
            "code": "\nundefined4 parse_input_0000656c(undefined4 result,uint *input_flags,byte **input_data,undefined4 *output_ptr)\n\n{\n  code *string_conversion_function;\n  void *ptr;\n  int status;\n  undefined4 temp_var;\n  uint data_length;\n  byte *data_ptr;\n  uint limit;\n  undefined4 *output_data_ptr;\n  uint *temp_ptr;\n  uint *output_data_end;\n  uint *output_data_start;\n  int overflow_count;\n  int idx;\n  undefined *lookup_table [4];\n  \n  lookup_table[0] = &DAT_00007c2f;\n  lookup_table[1] = &DAT_00007c32;\n  lookup_table[2] = &DAT_00007c35;\n  string_conversion_function = _strtol_r;\n  if (input_flags[6] != 3) {\n    string_conversion_function = _strtoul_r;\n  }\n  limit = input_flags[2];\n  data_length = limit - 1;\n  if (0x15c < data_length) {\n    overflow_count = limit - 0x15d;\n    limit = 0x15d;\n  }\n  if (0x15c < data_length) {\n    input_flags[2] = limit;\n  }\n  output_data_start = input_flags + 7;\n  if (data_length < 0x15d) {\n    overflow_count = 0;\n  }\n  *input_flags = *input_flags | 0xd00;\n  idx = 0;\n  output_data_end = output_data_start;\n  do {\n    ptr = memchr(lookup_table[idx],(uint)**input_data,2);\n    if (ptr != (void *)0x0) {\n      if (idx == 1) {\n        if (input_flags[1] == 0) {\n          input_flags[1] = 8;\n          *input_flags = *input_flags | 0x200;\n        }\n        data_length = *input_flags & 0xfffffaff;\nLAB_000065f4:\n        *input_flags = data_length;\n      }\n      else if (idx == 2) {\n        if ((*input_flags & 0x600) != 0x200) goto LAB_00006624;\n        input_flags[1] = 0x10;\n        data_length = *input_flags | 0x100;\n        goto LAB_000065f4;\n      }\n      data_length = input_flags[2];\n      input_flags[2] = data_length - 1;\n      if (data_length != 0) {\n        data_ptr = *input_data;\n        *input_data = data_ptr + 1;\n        temp_ptr = (uint *)((int)output_data_end + 1);\n        *(byte *)output_data_end = *data_ptr;\n        data_ptr = input_data[1];\n        input_data[1] = data_ptr + -1;\n        output_data_end = temp_ptr;\n        if (((int)(data_ptr + -1) < 1) &&\n           (status = (*(code *)input_flags[0x60])(result,input_data), status != 0)) {\n          idx = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    idx = idx + 1;\n  } while (idx != 3);\n  if (input_flags[1] == 0) {\n    input_flags[1] = 10;\n  }\n  __sccl(input_flags[5],\"01234567]\" + (8 - input_flags[1]));\n  idx = 0;\n  while( true ) {\n    temp_ptr = output_data_end;\n    if (input_flags[2] == 0) break;\n    data_ptr = *input_data;\n    data_length = (uint)*data_ptr;\n    if (*(char *)(input_flags[5] + data_length) == '\\0') break;\n    if ((data_length == 0x30) && ((int)(*input_flags << 0x14) < 0)) {\n      idx = idx + 1;\n      if (overflow_count != 0) {\n        overflow_count = overflow_count + -1;\n        input_flags[2] = input_flags[2] + 1;\n      }\n    }\n    else {\n      *input_flags = *input_flags & 0xfffff6ff;\n      temp_ptr = (uint *)((int)output_data_end + 1);\n      *(byte *)output_data_end = *data_ptr;\n    }\n    data_ptr = input_data[1];\n    input_data[1] = data_ptr + -1;\n    if ((int)(data_ptr + -1) < 1) {\n      status = (*(code *)input_flags[0x60])(result,input_data);\n      if (status != 0) break;\n    }\n    else {\n      *input_data = *input_data + 1;\n    }\n    input_flags[2] = input_flags[2] - 1;\n    output_data_end = temp_ptr;\n  }\nLAB_000066ca:\n  if ((int)(*input_flags << 0x17) < 0) {\n    if (output_data_start < temp_ptr) {\n      (*(code *)input_flags[0x5f])(result,*(byte *)((int)temp_ptr + -1),input_data);\n      temp_ptr = (uint *)((int)temp_ptr + -1);\n    }\n    if (temp_ptr == output_data_start) {\n      return 1;\n    }\n  }\n  if ((*input_flags & 0x10) == 0) {\n    *(byte *)temp_ptr = 0;\n    temp_var = (*(string_conversion_function + 1))(result,output_data_start,0,input_flags[1]);\n    output_data_ptr = (undefined4 *)*output_ptr;\n    data_length = *input_flags;\n    *output_ptr = output_data_ptr + 1;\n    output_data_ptr = (undefined4 *)*output_data_ptr;\n    if ((data_length & 0x20) == 0) {\n      if ((int)(data_length << 0x1f) < 0) {\n        *(short *)output_data_ptr = (short)temp_var;\n      }\n      else {\n        *output_data_ptr = temp_var;\n      }\n    }\n    else {\n      *output_data_ptr = temp_var;\n    }\n    input_flags[3] = input_flags[3] + 1;\n  }\n  input_flags[4] = (uint)((int)temp_ptr + input_flags[4] + (idx - (int)output_data_start));\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000656c": "parse_input_0000656c",
                "param_1": "result",
                "param_2": "input_flags",
                "param_3": "input_data",
                "param_4": "output_ptr",
                "pcVar1": "string_conversion_function",
                "pvVar2": "ptr",
                "iVar3": "status",
                "uVar4": "temp_var",
                "uVar5": "data_length",
                "pbVar6": "data_ptr",
                "uVar7": "limit",
                "puVar8": "output_data_ptr",
                "puVar9": "temp_ptr",
                "puVar10": "output_data_end",
                "puVar11": "output_data_start",
                "unaff_r9": "overflow_count",
                "iVar12": "idx",
                "local_34": "lookup_table"
            },
            "calling": [
                "__ssvfiscanf_r"
            ],
            "called": [
                "__sccl",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006754": {
            "entrypoint": "0x00006754",
            "current_name": "flush_file_00006754",
            "code": "\nint flush_file_00006754(FILE *file)\n\n{\n  int status;\n  \n  if ((*(ushort *)&file->_IO_read_base & 9) == 9) {\n    status = fflush(file);\n    return status;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00006754": "flush_file_00006754",
                "param_1": "file",
                "iVar1": "status"
            },
            "calling": [],
            "called": [
                "fflush"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006768": {
            "entrypoint": "0x00006768",
            "current_name": "process_stream_00006768",
            "code": "\nundefined4\nprocessStream_00006768(undefined4 *streamConfig,undefined4 *stream,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined2 flags;\n  int result;\n  undefined4 temp;\n  ushort streamFlags;\n  uint tempUInt;\n  \n  if ((streamConfig != (undefined4 *)0x0) && (streamConfig[6] == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = (undefined4 *)streamConfig[1];\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stdout) {\n    stream = (undefined4 *)streamConfig[2];\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stderr) {\n    stream = (undefined4 *)streamConfig[3];\n  }\n  streamFlags = *(ushort *)(stream + 3);\n  stream[1] = 0;\n  tempUInt = (uint)*(ushort *)(stream + 3);\n  if ((int)(tempUInt << 0x1a) < 0) {\n    return 0xffffffff;\n  }\n  if ((int)(tempUInt << 0x1d) < 0) {\n    if ((undefined4 *)stream[0xd] != (undefined4 *)0x0) {\n      if ((undefined4 *)stream[0xd] != stream + 0x11) {\n        _free_r(streamConfig);\n      }\n      stream[1] = stream[0x10];\n      stream[0xd] = 0;\n      if (stream[0x10] != 0) {\n        *stream = stream[0xf];\n        return 0;\n      }\n    }\n  }\n  else {\n    if (-1 < (int)(tempUInt << 0x1b)) {\n      *streamConfig = 9;\n      streamFlags = streamFlags | 0x40;\n      goto LAB_000067b8;\n    }\n    if ((int)(tempUInt << 0x1c) < 0) {\n      result = _fflush_r(streamConfig,stream,tempUInt << 0x1c,tempUInt,param_4);\n      if (result != 0) {\n        return 0xffffffff;\n      }\n      stream[2] = 0;\n      *(ushort *)(stream + 3) = *(ushort *)(stream + 3) & 0xfff7;\n      stream[6] = 0;\n    }\n    *(ushort *)(stream + 3) = *(ushort *)(stream + 3) | 4;\n  }\n  if (stream[4] == 0) {\n    __smakebuf_r(streamConfig,stream);\n  }\n  streamFlags = *(ushort *)(stream + 3);\n  flags = *(undefined2 *)(stream + 3);\n  if ((streamFlags & 3) != 0) {\n    *(undefined2 *)(stream + 3) = 1;\n    _fwalk(&impure_data,0x6755);\n    *(undefined2 *)(stream + 3) = flags;\n    if ((streamFlags & 9) == 9) {\n      __sflush_r(streamConfig,stream);\n    }\n  }\n  temp = stream[4];\n  *stream = temp;\n  result = (*(code *)stream[9])(streamConfig,stream[8],temp,stream[5]);\n  stream[1] = result;\n  if (0 < result) {\n    return 0;\n  }\n  streamFlags = *(ushort *)(stream + 3);\n  if (result != 0) {\n    temp = 0;\n  }\n  else {\n    streamFlags = streamFlags | 0x20;\n  }\n  if (result != 0) {\n    stream[1] = temp;\n    streamFlags = streamFlags | 0x40;\n  }\nLAB_000067b8:\n  *(ushort *)(stream + 3) = streamFlags;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00006768": "process_stream_00006768",
                "param_1": "streamConfig",
                "param_2": "stream",
                "uVar1": "flags",
                "iVar2": "result",
                "uVar3": "temp",
                "uVar4": "streamFlags",
                "uVar5": "tempUInt"
            },
            "calling": [
                "__srget_r"
            ],
            "called": [
                "_fflush_r",
                "__sinit",
                "__smakebuf_r",
                "_fwalk",
                "__sflush_r",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000687c": {
            "entrypoint": "0x0000687c",
            "current_name": "decode_data_0000687c",
            "code": "\nbyte * decodeData_0000687c(int dataSize,byte *data)\n\n{\n  byte *result;\n  uint tempVar;\n  int index;\n  uint currentByte;\n  uint startByte;\n  uint endByte;\n  bool isByteEqual;\n  \n  currentByte = (uint)*data;\n  isByteEqual = currentByte == 0x5e;\n  if (isByteEqual) {\n    currentByte = (uint)data[1];\n    data = data + 2;\n  }\n  else {\n    data = data + 1;\n  }\n  index = dataSize + -1;\n  do {\n    index = index + 1;\n    *(bool *)index = isByteEqual;\n  } while (index != dataSize + 0xff);\n  if (currentByte == 0) {\n    result = data + -1;\n  }\n  else {\nLAB_000068aa:\n    do {\n      startByte = currentByte;\n      *(bool *)(dataSize + startByte) = !isByteEqual;\n      data = data + 1;\n      while( true ) {\n        currentByte = (uint)data[-1];\n        if (currentByte != 0x2d) break;\n        endByte = (uint)*data;\n        if ((endByte == 0x5d) || (tempVar = startByte, (int)endByte < (int)startByte)) goto LAB_000068aa;\n        do {\n          tempVar = tempVar + 1;\n          *(bool *)(dataSize + tempVar) = !isByteEqual;\n        } while ((int)tempVar < (int)endByte);\n        index = ~startByte + endByte;\n        if ((int)endByte <= (int)startByte) {\n          index = 0;\n        }\n        startByte = startByte + 1 + index;\n        data = data + 2;\n      }\n      result = data;\n    } while ((currentByte != 0x5d) && (result = data + -1, currentByte != 0));\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0000687c": "decode_data_0000687c",
                "param_1": "dataSize",
                "param_2": "data",
                "pbVar1": "result",
                "uVar2": "tempVar",
                "iVar3": "index",
                "uVar4": "currentByte",
                "uVar5": "startByte",
                "uVar6": "endByte",
                "bVar7": "isByteEqual"
            },
            "calling": [
                "__ssvfiscanf_r",
                "_scanf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000068f0": {
            "entrypoint": "0x000068f0",
            "current_name": "initialize_flash_config_000068f0",
            "code": "\nundefined4 initializeFlashConfig_000068f0(undefined4 param,void **config)\n\n{\n  void *allocatedMemory;\n  void *configSize;\n  \n  if ((void **)config[0xd] == config + 0x11) {\n    allocatedMemory = (void *)allocateMemory(param,0x400);\n    if (allocatedMemory != (void *)0x0) {\n      config[0xe] = defaultConfigField;\n      config[0xd] = allocatedMemory;\n      *(undefined *)((int)allocatedMemory + 0x3ff) = *(undefined *)((int)config + 0x46);\n      *(undefined *)((int)allocatedMemory + 0x3fe) = *(undefined *)((int)config + 0x45);\n      *(undefined *)((int)allocatedMemory + 0x3fd) = *(undefined *)(config + 0x11);\n      *config = (void *)((int)allocatedMemory + 0x3fd);\n      return 0;\n    }\n  }\n  else {\n    configSize = config[0xe];\n    allocatedMemory = (void *)reallocateMemory(param,config[0xd],(void *)((int)configSize << 1));\n    if (allocatedMemory != (void *)0x0) {\n      memcpy((void *)((int)allocatedMemory + (int)configSize),allocatedMemory,(size_t)configSize);\n      config[0xd] = allocatedMemory;\n      config[0xe] = (void *)((int)configSize << 1);\n      *config = (void *)((int)allocatedMemory + (int)configSize);\n      return 0;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_000068f0": "initialize_flash_config_000068f0",
                "param_1": "param",
                "param_2": "config",
                "pvVar1": "allocatedMemory",
                "__n": "configSize",
                "_malloc_r": "allocateMemory",
                "flash_configuration_field": "defaultConfigField",
                "_realloc_r": "reallocateMemory"
            },
            "calling": [
                "_sungetc_r"
            ],
            "called": [
                "_malloc_r",
                "memcpy",
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006964": {
            "entrypoint": "0x00006964",
            "current_name": "calculate_result_00006964",
            "code": "\nint calculateResult_00006964(undefined4 param,int arrayPtr)\n\n{\n  int result;\n  \n  result = *(int *)(arrayPtr + -4) + -4;\n  if (*(int *)(arrayPtr + -4) < 0) {\n    result = result + *(int *)(arrayPtr + result);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00006964": "calculate_result_00006964",
                "param_1": "param",
                "param_2": "arrayPtr",
                "iVar1": "result"
            },
            "calling": [
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006974": {
            "entrypoint": "0x00006974",
            "current_name": "divide_signed_unsigned_00006974",
            "code": "\nint divide_signed_unsigned_00006974(int dividend,int divisor,int modulus_dividend,int modulus_divisor)\n\n{\n  int result;\n  undefined temp [8];\n  \n  if ((modulus_divisor == 0) && (modulus_dividend == 0)) {\n    if (divisor < 0) {\n      dividend = 0;\n      divisor = -0x80000000;\n    }\n    else if (divisor != 0 || dividend != 0) {\n      divisor = 0x7fffffff;\n      dividend = -1;\n    }\n    result = __aeabi_idiv0(dividend,divisor);\n    return result;\n  }\n  if (divisor < 0) {\n    result = -divisor - (uint)(dividend != 0);\n    if (modulus_divisor < 0) {\n      result = __udivmoddi4(-dividend,result,-modulus_dividend,-modulus_divisor - (uint)(modulus_dividend != 0),temp);\n      return result;\n    }\n    result = __udivmoddi4(-dividend,result,modulus_dividend,modulus_divisor,temp);\n    return -result;\n  }\n  if (modulus_divisor < 0) {\n    result = __udivmoddi4(dividend,divisor,-modulus_dividend,-modulus_divisor - (uint)(modulus_dividend != 0),temp);\n    return -result;\n  }\n  result = __udivmoddi4();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00006974": "divide_signed_unsigned_00006974",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "modulus_dividend",
                "param_4": "modulus_divisor",
                "iVar1": "result",
                "local_8": "temp"
            },
            "calling": [
                "gmtime_r"
            ],
            "called": [
                "__aeabi_idiv0",
                "__udivmoddi4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006a14": {
            "entrypoint": "0x00006a14",
            "current_name": "divide_with_remainder_00006a14",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong divideWithRemainder_00006a14(uint dividend,uint divisor,uint quotientHigh,uint quotientLow,uint *remainder)\n\n{\n  code *udfTable;\n  uint dividendShifted;\n  int shiftAmount;\n  uint quotientHighTemp;\n  uint quotientLowTemp;\n  uint quotientLowResult;\n  uint quotientHighResult;\n  uint quotientBit;\n  uint remainderTemp;\n  uint quotientDivisor;\n  bool carry;\n  ulonglong result;\n  \n  if (quotientLow == 0) {\n    if (divisor < quotientHigh) {\n      shiftAmount = LZCOUNT(quotientHigh);\n      quotientLowResult = quotientHigh;\n      if (shiftAmount != 0) {\n        quotientLowResult = quotientHigh << shiftAmount;\n        divisor = dividend >> (0x20U - shiftAmount & 0xff) | divisor << shiftAmount;\n        dividend = dividend << shiftAmount;\n      }\n      quotientHighResult = quotientLowResult >> 0x10;\n      remainderTemp = divisor / quotientHighResult;\n      quotientHighTemp = dividend >> 0x10 | (divisor - quotientHighResult * remainderTemp) * 0x10000;\n      dividendShifted = remainderTemp * (quotientLowResult & 0xffff);\n      quotientLowTemp = remainderTemp;\n      if (quotientHighTemp <= dividendShifted && dividendShifted - quotientHighTemp != 0) {\n        carry = CARRY4(quotientLowResult,quotientHighTemp);\n        quotientHighTemp = quotientLowResult + quotientHighTemp;\n        quotientLowTemp = remainderTemp - 1;\n        if ((carry == false) && (quotientHighTemp <= dividendShifted && dividendShifted - quotientHighTemp != 0)) {\n          quotientLowTemp = remainderTemp - 2;\n          quotientHighTemp = quotientHighTemp + quotientLowResult;\n        }\n      }\n      remainderTemp = (quotientHighTemp - dividendShifted) / quotientHighResult;\n      quotientHighResult = dividend & 0xffff | ((quotientHighTemp - dividendShifted) - quotientHighResult * remainderTemp) * 0x10000;\n      quotientHighTemp = remainderTemp * (quotientLowResult & 0xffff);\n      dividendShifted = remainderTemp;\n      if (quotientHighResult <= quotientHighTemp && quotientHighTemp - quotientHighResult != 0) {\n        carry = CARRY4(quotientLowResult,quotientHighResult);\n        quotientHighResult = quotientLowResult + quotientHighResult;\n        dividendShifted = remainderTemp - 1;\n        if ((carry == false) && (quotientHighResult <= quotientHighTemp && quotientHighTemp - quotientHighResult != 0)) {\n          dividendShifted = remainderTemp - 2;\n          quotientHighResult = quotientHighResult + quotientLowResult;\n        }\n      }\n      quotientHighResult = quotientHighResult - quotientHighTemp;\n      dividendShifted = dividendShifted | quotientLowTemp << 0x10;\n      quotientLowResult = 0;\n    }\n    else {\n      if (quotientHigh == 0) {\n                    /* WARNING: Treating indirect jump as call */\n        udfTable = (code *)software_udf(0xff,0x6abc);\n        result = (*udfTable)();\n        return result;\n      }\n      shiftAmount = LZCOUNT(quotientHigh);\n      if (shiftAmount == 0) {\n        divisor = divisor - quotientHigh;\n        quotientDivisor = quotientHigh >> 0x10;\n        quotientBit = quotientHigh & 0xffff;\n        quotientLowResult = 1;\n        quotientLowTemp = quotientHigh;\n      }\n      else {\n        quotientLowTemp = quotientHigh << shiftAmount;\n        quotientDivisor = quotientLowTemp >> 0x10;\n        dividendShifted = divisor >> (0x20U - shiftAmount & 0xff);\n        quotientLowResult = dividend >> (0x20U - shiftAmount & 0xff) | divisor << shiftAmount;\n        quotientHighTemp = dividendShifted / quotientDivisor;\n        quotientBit = quotientLowTemp & 0xffff;\n        remainderTemp = quotientLowResult >> 0x10 | (dividendShifted - quotientDivisor * quotientHighTemp) * 0x10000;\n        quotientHighResult = quotientHighTemp * quotientBit;\n        dividend = dividend << shiftAmount;\n        dividendShifted = quotientHighTemp;\n        if (remainderTemp <= quotientHighResult && quotientHighResult - remainderTemp != 0) {\n          carry = CARRY4(quotientLowTemp,remainderTemp);\n          remainderTemp = quotientLowTemp + remainderTemp;\n          dividendShifted = quotientHighTemp - 1;\n          if ((carry == false) && (remainderTemp <= quotientHighResult && quotientHighResult - remainderTemp != 0)) {\n            dividendShifted = quotientHighTemp - 2;\n            remainderTemp = remainderTemp + quotientLowTemp;\n          }\n        }\n        quotientHighTemp = (remainderTemp - quotientHighResult) / quotientDivisor;\n        divisor = quotientLowResult & 0xffff | ((remainderTemp - quotientHighResult) - quotientDivisor * quotientHighTemp) * 0x10000;\n        quotientHighResult = quotientHighTemp * quotientBit;\n        quotientLowResult = quotientHighTemp;\n        if (divisor <= quotientHighResult && quotientHighResult - divisor != 0) {\n          carry = CARRY4(quotientLowTemp,divisor);\n          divisor = quotientLowTemp + divisor;\n          quotientLowResult = quotientHighTemp - 1;\n          if ((carry == false) && (divisor <= quotientHighResult && quotientHighResult - divisor != 0)) {\n            quotientLowResult = quotientHighTemp - 2;\n            divisor = divisor + quotientLowTemp;\n          }\n        }\n        divisor = divisor - quotientHighResult;\n        quotientLowResult = quotientLowResult | dividendShifted << 0x10;\n      }\n      remainderTemp = divisor / quotientDivisor;\n      quotientHighResult = dividend >> 0x10 | (divisor - quotientDivisor * remainderTemp) * 0x10000;\n      dividendShifted = quotientBit * remainderTemp;\n      quotientHighTemp = remainderTemp;\n      if (quotientHighResult <= dividendShifted && dividendShifted - quotientHighResult != 0) {\n        carry = CARRY4(quotientLowTemp,quotientHighResult);\n        quotientHighResult = quotientLowTemp + quotientHighResult;\n        quotientHighTemp = remainderTemp - 1;\n        if ((carry == false) && (quotientHighResult <= dividendShifted && dividendShifted - quotientHighResult != 0)) {\n          quotientHighTemp = remainderTemp - 2;\n          quotientHighResult = quotientHighResult + quotientLowTemp;\n        }\n      }\n      remainderTemp = (quotientHighResult - dividendShifted) / quotientDivisor;\n      quotientHighResult = dividend & 0xffff | ((quotientHighResult - dividendShifted) - quotientDivisor * remainderTemp) * 0x10000;\n      quotientBit = quotientBit * remainderTemp;\n      dividendShifted = remainderTemp;\n      if (quotientHighResult <= quotientBit && quotientBit - quotientHighResult != 0) {\n        carry = CARRY4(quotientLowTemp,quotientHighResult);\n        quotientHighResult = quotientLowTemp + quotientHighResult;\n        dividendShifted = remainderTemp - 1;\n        if ((carry == false) && (quotientHighResult <= quotientBit && quotientBit - quotientHighResult != 0)) {\n          dividendShifted = remainderTemp - 2;\n          quotientHighResult = quotientHighResult + quotientLowTemp;\n        }\n      }\n      quotientHighResult = quotientHighResult - quotientBit;\n      dividendShifted = dividendShifted | quotientHighTemp << 0x10;\n    }\n    if (remainder != (uint *)0x0) {\n      *remainder = quotientHighResult >> LZCOUNT(quotientHigh);\n      remainder[1] = 0;\n    }\n  }\n  else if (divisor < quotientLow) {\n    if (remainder != (uint *)0x0) {\n      *remainder = dividend;\n      remainder[1] = divisor;\n      return 0;\n    }\n    dividendShifted = 0;\n    quotientLowResult = 0;\n  }\n  else {\n    shiftAmount = LZCOUNT(quotientLow);\n    if (shiftAmount != 0) {\n      quotientBit = 0x20 - shiftAmount;\n      quotientHighTemp = quotientHigh >> (quotientBit & 0xff) | quotientLow << shiftAmount;\n      quotientDivisor = quotientHighTemp >> 0x10;\n      dividendShifted = divisor >> (quotientBit & 0xff);\n      quotientLowResult = dividend >> (quotientBit & 0xff) | divisor << shiftAmount;\n      quotientHighResult = dividendShifted / quotientDivisor;\n      quotientLowTemp = quotientLowResult >> 0x10 | (dividendShifted - quotientDivisor * quotientHighResult) * 0x10000;\n      remainderTemp = quotientHighResult * (quotientHighTemp & 0xffff);\n      dividend = dividend << shiftAmount;\n      dividendShifted = quotientHighResult;\n      if (quotientLowTemp <= remainderTemp && remainderTemp - quotientLowTemp != 0) {\n        carry = CARRY4(quotientHighTemp,quotientLowTemp);\n        quotientLowTemp = quotientHighTemp + quotientLowTemp;\n        dividendShifted = quotientHighResult - 1;\n        if ((carry == false) && (quotientLowTemp <= remainderTemp && remainderTemp - quotientLowTemp != 0)) {\n          dividendShifted = quotientHighResult - 2;\n          quotientLowTemp = quotientLowTemp + quotientHighTemp;\n        }\n      }\n      quotientHighResult = (quotientLowTemp - remainderTemp) / quotientDivisor;\n      quotientLowTemp = quotientLowResult & 0xffff | ((quotientLowTemp - remainderTemp) - quotientDivisor * quotientHighResult) * 0x10000;\n      remainderTemp = quotientHighResult * (quotientHighTemp & 0xffff);\n      quotientLowResult = quotientHighResult;\n      if (quotientLowTemp <= remainderTemp && remainderTemp - quotientLowTemp != 0) {\n        carry = CARRY4(quotientHighTemp,quotientLowTemp);\n        quotientLowTemp = quotientHighTemp + quotientLowTemp;\n        quotientLowResult = quotientHighResult - 1;\n        if ((carry == false) && (quotientLowTemp <= remainderTemp && remainderTemp - quotientLowTemp != 0)) {\n          quotientLowResult = quotientHighResult - 2;\n          quotientLowTemp = quotientLowTemp + quotientHighTemp;\n        }\n      }\n      quotientLowResult = quotientLowResult | dividendShifted << 0x10;\n      result = (ulonglong)quotientLowResult * (ulonglong)(quotientHigh << shiftAmount);\n      if (CONCAT44(quotientLowTemp - remainderTemp,dividend) < result) {\n        result = result - CONCAT44(quotientHighTemp,quotientHigh << shiftAmount);\n        quotientLowResult = quotientLowResult - 1;\n      }\n      if (remainder != (uint *)0x0) {\n        dividendShifted = ((quotientLowTemp - remainderTemp) - (int)(result >> 0x20)) - (uint)(dividend < (uint)result);\n        *remainder = dividendShifted << (quotientBit & 0xff) | dividend - (uint)result >> shiftAmount;\n        remainder[1] = dividendShifted >> shiftAmount;\n      }\n      return (ulonglong)quotientLowResult;\n    }\n    if ((quotientLow < divisor) || (quotientHigh <= dividend)) {\n      carry = dividend < quotientHigh;\n      dividend = dividend - quotientHigh;\n      divisor = (divisor - quotientLow) - (uint)carry;\n      dividendShifted = 1;\n    }\n    else {\n      dividendShifted = 0;\n    }\n    quotientLowResult = 0;\n    if (remainder != (uint *)0x0) {\n      *remainder = dividend;\n      remainder[1] = divisor;\n    }\n  }\n  return CONCAT44(quotientLowResult,dividendShifted);\n}\n\n",
            "renaming": {
                "FUN_00006a14": "divide_with_remainder_00006a14",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotientHigh",
                "param_4": "quotientLow",
                "param_5": "remainder",
                "UNRECOVERED_JUMPTABLE": "udfTable",
                "uVar1": "dividendShifted",
                "iVar2": "shiftAmount",
                "uVar3": "quotientHighTemp",
                "uVar4": "quotientLowTemp",
                "uVar5": "quotientLowResult",
                "uVar6": "quotientHighResult",
                "uVar7": "quotientBit",
                "uVar8": "remainderTemp",
                "uVar9": "quotientDivisor",
                "bVar10": "carry",
                "uVar11": "result"
            },
            "calling": [
                "__aeabi_ldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006cd4": {
            "entrypoint": "0x00006cd4",
            "current_name": "FUNC_00006cd4",
            "code": "\nvoid FUNC_00006cd4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00006cd4": "FUNC_00006cd4"
            },
            "calling": [
                "__aeabi_ldivmod"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 143743,
    "layers": [
        [
            "FUN_00000410",
            "FUN_00000428",
            "FUN_00000490",
            "FUN_000004b2",
            "FUN_000004d4",
            "FUN_000004f2",
            "FUN_00000514",
            "FUN_00000534",
            "FUN_00000566",
            "FUN_0000058e",
            "FUN_000005ca",
            "FUN_00000610",
            "FUN_00000698",
            "FUN_00000738",
            "FUN_00000794",
            "FUN_000007dc",
            "FUN_000008b8",
            "FUN_00000900",
            "FUN_0000091c",
            "FUN_00000930",
            "FUN_0000093c",
            "FUN_00000958",
            "FUN_00000974",
            "FUN_00000978",
            "FUN_0000099c",
            "FUN_00000a30",
            "FUN_00000a40",
            "FUN_00000a64",
            "FUN_00000aa8",
            "FUN_00000c80",
            "FUN_00000c90",
            "FUN_00000ca0",
            "FUN_00000cb0",
            "FUN_00000cc0",
            "FUN_00000cd0",
            "FUN_00000cf0",
            "FUN_00000d0c",
            "FUN_00000d2a",
            "FUN_00000d44",
            "FUN_00000d76",
            "FUN_00000d9c",
            "FUN_00000db0",
            "FUN_00000dc0",
            "FUN_00000dcc",
            "FUN_00000df4",
            "FUN_00000e14",
            "FUN_00000e38",
            "FUN_00000e58",
            "FUN_00000e64",
            "FUN_00000ed8",
            "FUN_00000f04",
            "FUN_00000f5c",
            "FUN_00000f80",
            "FUN_00000f8c",
            "FUN_00000fec",
            "FUN_00001034",
            "FUN_000010a0",
            "FUN_000010d4",
            "FUN_00001274",
            "FUN_0000129c",
            "FUN_000012b4",
            "FUN_000012e2",
            "FUN_00001318",
            "FUN_00001348",
            "FUN_00001360",
            "FUN_00001392",
            "FUN_000013b8",
            "FUN_00001448",
            "FUN_000014c4",
            "FUN_000015d0",
            "FUN_00001628",
            "FUN_00001688",
            "FUN_00001696",
            "FUN_000016c8",
            "FUN_000016ec",
            "FUN_00001710",
            "FUN_00001734",
            "FUN_00001748",
            "FUN_00001778",
            "FUN_000017dc",
            "FUN_0000182c",
            "FUN_000018bc",
            "FUN_0000191c",
            "FUN_00001960",
            "FUN_000019c0",
            "FUN_00001a18",
            "FUN_00001a3c",
            "FUN_00001a60",
            "FUN_00001ad4",
            "FUN_00001b10",
            "FUN_00001bb8",
            "FUN_00001c84",
            "FUN_00001cf0",
            "FUN_00001d08",
            "FUN_00001d3a",
            "FUN_00001d5e",
            "FUN_00001d80",
            "FUN_00001da2",
            "FUN_00001dc0",
            "FUN_00001ddc",
            "FUN_00001e0c",
            "FUN_00001e44",
            "FUN_00001ec4",
            "FUN_00001eea",
            "FUN_00001f80",
            "FUN_00001ff6",
            "FUN_00002028",
            "FUN_000020b8",
            "FUN_000020cc",
            "FUN_000020e0",
            "FUN_000020f4",
            "FUN_00002108",
            "FUN_0000211c",
            "FUN_00002270",
            "FUN_00002294",
            "FUN_000022be",
            "FUN_000022f0",
            "FUN_0000231c",
            "FUN_00002364",
            "FUN_00002396",
            "FUN_000023a4",
            "FUN_000023c8",
            "FUN_000023d0",
            "FUN_0000240c",
            "FUN_00002434",
            "FUN_000024bc",
            "FUN_00002538",
            "FUN_0000258c",
            "FUN_000025f4",
            "FUN_00002600",
            "FUN_00002624",
            "FUN_00002654",
            "FUN_00002690",
            "FUN_000026c0",
            "FUN_000026d8",
            "FUN_000026e4",
            "FUN_000026f0",
            "FUN_00002714",
            "FUN_00002744",
            "FUN_00002798",
            "FUN_000027b0",
            "FUN_0000281c",
            "FUN_0000285c",
            "FUN_00002894",
            "FUN_000028f0",
            "FUN_00002910",
            "FUN_0000294c",
            "FUN_00002970",
            "FUN_00002994",
            "FUN_00002a00",
            "FUN_00002a18",
            "FUN_00002a88",
            "FUN_00002b10",
            "FUN_00002d94",
            "FUN_00002e48",
            "FUN_00002e6c",
            "FUN_00002e9c",
            "FUN_00002eb4",
            "FUN_00002ecc",
            "FUN_00002f30",
            "FUN_00002f74",
            "FUN_00002fe0",
            "FUN_0000305c",
            "FUN_0000316c",
            "FUN_000031e0",
            "FUN_000031fc",
            "FUN_0000328c",
            "FUN_00003378",
            "FUN_000033c0",
            "FUN_000033f4",
            "FUN_00003444",
            "FUN_00003478",
            "FUN_000034c0",
            "FUN_00003524",
            "FUN_00003658",
            "FUN_00003688",
            "FUN_00003694",
            "FUN_00003810",
            "FUN_00003918",
            "FUN_000039e8",
            "FUN_00003d24",
            "FUN_00003d64",
            "FUN_00003d94",
            "FUN_00003dc4",
            "FUN_00003e58",
            "FUN_00003e9e",
            "FUN_00003ec4",
            "FUN_00003ff4",
            "FUN_00004042",
            "FUN_0000404c",
            "FUN_00004158",
            "FUN_000041d0",
            "FUN_000041f4",
            "FUN_0000423c",
            "FUN_00004248",
            "FUN_00004274",
            "FUN_00004280",
            "FUN_0000428c",
            "FUN_00004298",
            "FUN_000042a4",
            "FUN_00004314",
            "FUN_000043a0",
            "FUN_000043da",
            "FUN_00004418",
            "FUN_0000443c",
            "FUN_0000459c",
            "FUN_000045ee",
            "FUN_00004622",
            "FUN_00004634",
            "FUN_000047e4",
            "FUN_00004b34",
            "FUN_00004bd0",
            "FUN_00004c84",
            "FUN_00004cb4",
            "FUN_00004cdc",
            "FUN_00004db8",
            "FUN_00004dc8",
            "FUN_00004dea",
            "FUN_00004dee",
            "FUN_00004e26",
            "FUN_00004e4a",
            "FUN_00004e52",
            "FUN_00004e66",
            "FUN_00004e8c",
            "FUN_00004f84",
            "FUN_00004f98",
            "FUN_000050e8",
            "FUN_000050f4",
            "FUN_00005100",
            "FUN_0000510c",
            "FUN_00005404",
            "FUN_000054a8",
            "FUN_00005584",
            "FUN_000055ac",
            "FUN_0000562c",
            "FUN_000056a0",
            "FUN_000056b0",
            "FUN_000056b8",
            "FUN_00005700",
            "FUN_00005780",
            "FUN_00005790",
            "FUN_0000579c",
            "FUN_000057a8",
            "FUN_000057d2",
            "FUN_000057f8",
            "FUN_00005a58",
            "FUN_00005b34",
            "FUN_00005d80",
            "FUN_00005e10",
            "FUN_00005e68",
            "FUN_00005ebc",
            "FUN_00005ecc",
            "FUN_00005edc",
            "FUN_00005fd8",
            "FUN_00005fec",
            "FUN_00005ff8",
            "FUN_00006010",
            "FUN_000060b0",
            "FUN_000060cc",
            "FUN_00006118",
            "FUN_00006192",
            "FUN_000061cc",
            "FUN_000064bc",
            "FUN_0000656c",
            "FUN_00006754",
            "FUN_00006768",
            "FUN_0000687c",
            "FUN_000068f0",
            "FUN_00006964",
            "FUN_00006974",
            "FUN_00006a14"
        ]
    ],
    "locked_functions": []
}