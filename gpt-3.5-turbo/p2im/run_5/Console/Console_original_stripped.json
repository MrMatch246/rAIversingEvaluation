{
    "functions": {
        "FUN_000026c0": {
            "renaming": {
                "FUN_000026c0": "clearRTCAlarm_000026c0",
                "PTR_rtc_callback_000026d4": "rtcCallbackPtr"
            },
            "code": "void clearRTCAlarm_000026c0(void)\n{\n  rtt_clear_alarm();\n  *(undefined4 *)PTR_rtc_callback_000026d4 = 0;\n  return;\n}",
            "called": [
                "rtt_clear_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026c0",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "clearRTCAlarm_000026c0"
        },
        "FUN_00004bd0": {
            "renaming": {
                "FUN_00004bd0": "allocate_memory_00004bd0",
                "param_1": "reent",
                "param_2": "size",
                "puVar1": "start_brk",
                "pvVar2": "new_brk",
                "puVar3": "free_list_pointer",
                "iVar4": "difference",
                "uVar5": "block_size",
                "puVar6": "current_block_pointer",
                "uVar7": "adjusted_size",
                "previous_block_pointer": "previous_block_pointer"
            },
            "code": "uint allocate_memory_00004bd0(_reent *reent,uint size)\n{\n  undefined *start_brk;\n  void *new_brk;\n  uint *free_list_pointer;\n  int difference;\n  uint block_size;\n  uint *current_block_pointer;\n  uint *previous_block_pointer;\n  uint adjusted_size;\n  \n  adjusted_size = (size + 3 & 0xfffffffc) + 8;\n  if (adjusted_size < 0xc) {\n    adjusted_size = 0xc;\n  }\n  if (((int)adjusted_size < 0) || (adjusted_size < size)) {\n    reent->_errno = 0xc;\n  }\n  else {\n    __malloc_lock();\n    start_brk = PTR___malloc_sbrk_start_00004c80;\n    free_list_pointer = *(uint **)PTR___malloc_free_list_00004c7c;\n    for (current_block_pointer = *(uint **)PTR___malloc_free_list_00004c7c; current_block_pointer != (uint *)0x0;\n        current_block_pointer = (uint *)current_block_pointer[1]) {\n      difference = *current_block_pointer - adjusted_size;\n      if (-1 < difference) {\n        if (0xb < difference) {\n          *current_block_pointer = difference;\n          current_block_pointer = (uint *)((int)current_block_pointer + difference);\n          goto LAB_00004c34;\n        }\n        block_size = current_block_pointer[1];\n        if (free_list_pointer == current_block_pointer) {\n          *(uint *)PTR___malloc_free_list_00004c7c = block_size;\n        }\n        if (free_list_pointer != current_block_pointer) {\n          previous_block_pointer[1] = block_size;\n        }\n        goto LAB_00004c42;\n      }\n      previous_block_pointer = current_block_pointer;\n    }\n    if (*(int *)PTR___malloc_sbrk_start_00004c80 == 0) {\n      new_brk = _sbrk_r(reent,0);\n      *(void **)start_brk = new_brk;\n    }\n    current_block_pointer = (uint *)_sbrk_r(reent,adjusted_size);\n    if ((current_block_pointer != (uint *)0xffffffff) &&\n       ((previous_block_pointer = (uint *)((int)current_block_pointer + 3U & 0xfffffffc), current_block_pointer == previous_block_pointer ||\n        (new_brk = _sbrk_r(reent,(int)previous_block_pointer - (int)current_block_pointer), new_brk != (void *)0xffffffff)))) {\nLAB_00004c34:\n      *previous_block_pointer = adjusted_size;\nLAB_00004c42:\n      __malloc_unlock(reent);\n      block_size = (int)previous_block_pointer + 0xbU & 0xfffffff8;\n      difference = block_size - (int)(previous_block_pointer + 1);\n      if (difference == 0) {\n        return block_size;\n      }\n      *(uint *)((int)previous_block_pointer + difference) = (int)(previous_block_pointer + 1) - block_size;\n      return block_size;\n    }\n    reent->_errno = 0xc;\n    __malloc_unlock(reent);\n  }\n  return 0;\n}",
            "called": [
                "_sbrk_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004bd0",
            "calling": [
                "_tzset_unlocked_r",
                "__sfmoreglue",
                "__smakebuf_r",
                "__submore",
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_00004bd0"
        },
        "FUN_00000794": {
            "renaming": {
                "FUN_00000794": "terminate_active_thread_00000794",
                "PTR_sched_threads_000007d0": "threads",
                "PTR_sched_active_pid_000007cc": "active_pid",
                "PTR_sched_num_threads_000007d4": "num_threads",
                "PTR_sched_active_thread_000007d8": "active_thread",
                "cpu_switch_context_exit": "switch_context_exit",
                "sched_set_status": "set_thread_status"
            },
            "code": "void terminate_active_thread_00000794(void)\n{\n    irq_disable();\n    int* PTR_sched_num_PTR_sched_threads_000007d0_000007d4 = (int*)PTR_sched_PTR_sched_num_PTR_sched_threads_000007d0_000007d4_000007d4;\n    *PTR_sched_num_PTR_sched_threads_000007d0_000007d4 -= 1;\n    short* PTR_sched_active_pid_000007cc = (short*)PTR_sched_PTR_sched_active_pid_000007cc_000007cc;\n    thread_t** PTR_sched_active_thread_000007d8 = (thread_t**)PTR_sched_PTR_sched_active_thread_000007d8_000007d8;\n    *(thread_t**)(PTR_sched_PTR_sched_threads_000007d0_000007d0 + *PTR_sched_active_pid_000007cc * 4) = NULL;\n    sched_set_status(*PTR_sched_active_thread_000007d8, 0);\n    *PTR_sched_active_thread_000007d8 = NULL;\n    cpu_switch_context_exit();\n}",
            "called": [
                "cpu_switch_context_exit",
                "irq_disable",
                "sched_set_status"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000794",
            "calling": [],
            "imported": false,
            "current_name": "terminate_active_thread_00000794"
        },
        "FUN_000064bc": {
            "renaming": {
                "FUN_000064bc": "process_data_000064bc",
                "param_1": "data",
                "param_2": "buffer",
                "param_3": "input",
                "param_4": "counter",
                "puVar1": "output_buffer",
                "iVar2": "result",
                "iVar7": "input_index",
                "uVar3": "buffer_size",
                "ppbVar4": "output_index",
                "pbVar5": "input_buffer",
                "pbVar6": "output_buffer"
            },
            "code": "int process_data_000064bc(int data, uint32_t *buffer, byte **input, int *counter) {\n  byte *output_buffer;\n  int buffer_size;\n  int input_index;\n  int output_index;\n  int result;\n  \n  if (buffer[2] == 0) {\n    if (buffer[6] == 0) {\n      buffer_size = 1;\n    }\n    else {\n      buffer_size = -1;\n    }\n    buffer[2] = buffer_size;\n  }\n  output_buffer = NULL;\n  if (data >= 0) {\n    output_buffer = *counter;\n    *counter = output_buffer + 1;\n    output_buffer = *output_buffer;\n  }\n  result = 0;\n  input_index = 0;\n  do {\n    buffer_size = buffer[6];\n    if (buffer_size != 0) {\n      if (buffer_size == 1) {\n        if (*(char *)(buffer[5] + (uint)**input) == '\\0') {\n          if (result == 0) {\n            return 1;\n          }\n          if (((*buffer & 0x10) == 0) && (buffer[3]++, buffer[6] != 0)) {\n            *output_buffer = 0;\n          }\n          buffer[4] = result + buffer[4];\n          return 0;\n        }\n      }\n      else if ((buffer_size != 2) || ((int)((uint)(byte)output_buffer[**input] << 0x1c) < 0)) {\n        if (result == 0) {\n          return -1;\n        }\n        if (((*buffer & 0x10) == 0) && (buffer[3]++, buffer[6] != 0)) {\n          *output_buffer = 0;\n        }\n        buffer[4] = result + buffer[4];\n        return 0;\n      }\n    }\n    output_index = output_buffer;\n    if (data >= 0) {\n      output_index = output_buffer + 1;\n      *output_buffer = **input;\n    }\n    *input = *input + 1;\n    buffer_size = buffer[2] - 1;\n    buffer[2] = buffer_size;\n    input_index++;\n    output_buffer = output_index;\n    if ((buffer_size == 0) || (((int)(output_index + -1) < 1 && ((result = (*(code *)buffer[0x60])(data, input, buffer_size, (code *)buffer[0x60], counter)), result != 0))))) {\n      if (result == 0) {\n        return -1;\n      }\n      if (((*buffer & 0x10) == 0) && (buffer[3]++, buffer[6] != 0)) {\n        *output_index = 0;\n      }\n      buffer[4] = result + buffer[4];\n      return 0;\n    }\n  } while(true);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000064bc",
            "calling": [
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "process_data_000064bc"
        },
        "FUN_00002970": {
            "renaming": {
                "FUN_00002970": "clear_rtc_alarm_flag_00002970",
                "rtt": "rtc_instance",
                "*(uint *)(DAT_00002990 + 0x14)": "*alarm_flag_register",
                "0xffffffef": "~(1 << 4)"
            },
            "code": "void clear_rtc_alarm_flag_00002970(void)\n{\n  RTC_Type *rtc_instance = (RTC_Type *)PTR_00002970;\n  uint32_t *(uint *)(DAT_00002990 + 0x14) = (uint32_t *)(DAT_00002990 + 0x14);\n  *(uint *)(DAT_00002990 + 0x14) &= ~(1 << 4);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002970",
            "calling": [
                "rtc_poweroff"
            ],
            "imported": false,
            "current_name": "clear_rtc_alarm_flag_00002970"
        },
        "FUN_00000dc0": {
            "renaming": {
                "FUN_00000dc0": "run_default_function_00000dc0"
            },
            "code": "void run_default_function_00000dc0(void)\n{\n  run_default_function_00000dc0();\n  return;\n}",
            "called": [
                "dummy_handler_default"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dc0",
            "calling": [],
            "imported": false,
            "current_name": "run_default_function_00000dc0"
        },
        "FUN_00000ca0": {
            "renaming": {
                "FUN_00000ca0": "handle_usage_fault_00000ca0",
                "PTR_s_USAGE_FAULT_HANDLER_00000cac": "usage_fault_handler"
            },
            "code": "void handle_usage_fault_00000ca0(void)\n{\n    core_panic(PANIC_USAGE_FAULT, PTR_s_USAGE_FAULT_HANDLER_00000cac);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ca0",
            "calling": [],
            "imported": false,
            "current_name": "handle_usage_fault_00000ca0"
        },
        "FUN_00000d0c": {
            "renaming": {
                "FUN_00000d0c": "enableIRQinterrupts_if_privileged_00000d0c",
                "state": "state",
                "bVar1": "is_privileged",
                "enableIRQinterrupts": "enableIRQinterrupts",
                "isCurrentModePrivileged": "isCurrentModePrivileged"
            },
            "code": "void enableIRQinterrupts_if_privileged_00000d0c(uint state)\n{\n  bool is_privileged = (bool)isCurrentModePrivileged();\n  if (is_privileged) {\n    bool enable_interrupts = (state & 1) == 1;\n    enableIRQinterrupts(enable_interrupts);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d0c",
            "calling": [
                "kinetis_mcg_init",
                "_sbrk_r",
                "mutex_unlock",
                "thread_create",
                "_mutex_lock"
            ],
            "imported": false,
            "current_name": "enableIRQinterrupts_if_privileged_00000d0c"
        },
        "FUN_00003d94": {
            "renaming": {
                "FUN_00003d94": "write_physical_data_00003d94",
                "dev": "device",
                "data": "data",
                "iVar1": "result"
            },
            "code": "int write_physical_data_00003d94(saul_reg_t *device, phydat_t *data)\n{\n  int result;\n  if (device == NULL) {\n    result = -19;\n  }\n  else {\n    result = (*device->driver->write)(device->dev, data);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d94",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "write_physical_data_00003d94"
        },
        "FUN_0000579c": {
            "renaming": {
                "FUN_0000579c": "release_malloc_recursive_mutex_0000579c",
                "PTR___lock___malloc_recursive_mutex_000057a4": "PTR___lock___malloc_recursive_mutex_000057a4"
            },
            "code": "void release_malloc_recursive_mutex_0000579c(void)\n{\n  __retarget_lock_release_recursive(PTR___lock___malloc_recursive_mutex_000057a4);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000579c",
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "imported": false,
            "current_name": "release_malloc_recursive_mutex_0000579c"
        },
        "FUN_000015d0": {
            "renaming": {
                "FUN_000015d0": "send_data_over_uart_000015d0",
                "uart": "uart_t",
                "*data": "uint8_t *data",
                "len": "size_t len",
                "iVar1": "uart_config_offset",
                "dev": "uart_device",
                "i": "size_t i"
            },
            "code": "void send_data_over_uart_000015d0(uart_t uart, uint8_t *data, size_t len)\n{\n  int uart_config_offset = *(int *)(PTR_uart_config_00001624 + uart * 0x20);\n  UART_Type *uart_device = (UART_Type *)uart_config_offset;\n  for (size_t i = 0; i < len; i++) {\n    while (uart_device->SR & UART_SR_TXFULL_MASK);\n    uart_device->DR = data[i];\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000015d0",
            "calling": [
                "uart_stdio_write"
            ],
            "imported": false,
            "current_name": "send_data_over_uart_000015d0"
        },
        "FUN_00004cdc": {
            "renaming": {
                "FUN_00004cdc": "print_string_00004cdc",
                "param_1": "file",
                "param_2": "str",
                "cVar1": "character",
                "iVar2": "ret_val",
                "pcVar3": "buffer_ptr",
                "ppcVar4": "buffer",
                "uVar5": "ret_val",
                "pcVar6": "str_ptr"
            },
            "code": "int print_string_00004cdc(int file, char* str) {\n  char character;\n  int ret_val = 0;\n  char* buffer = *(char***)(file + 8);\n  if ((file != 0) && (*(int*)(file + 0x18) == 0)) {\n    __sinit(file);\n  }\n  if (buffer == (char**)PTR___sf_fake_stdin_00004dac) {\n    buffer = *(char***)(file + 4);\n  }\n  else if (buffer == (char**)PTR___sf_fake_stdout_00004db0) {\n    buffer = *(char***)(file + 8);\n  }\n  else if (buffer == (char**)PTR___sf_fake_stderr_00004db4) {\n    buffer = *(char***)(file + 0xc);\n  }\n  if ((-1 < (int)buffer[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort*)(buffer + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(buffer[0x16]);\n  }\n  while (*str != '\\0') {\n    character = *str;\n    if (((int)(buffer[2] - 1) < 0) && (((int)(buffer[2] - 1) < (int)buffer[6] || (character == '\\n')))) {\n      if ((int)(buffer[2] - 1) < 0) {\n        ret_val = __swbuf_r(file, 10, buffer);\n        if (ret_val == -1) {\n          ret_val = -1;\n          break;\n        }\n      }\n      *buffer[2] = '\\n';\n      buffer[2]--;\n    }\n    else {\n      *buffer[2] = character;\n      buffer[2]--;\n    }\n    str++;\n  }\n  if ((-1 < (int)buffer[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort*)(buffer + 3) << 0x16))) {\n    __retarget_lock_release_recursive(buffer[0x16]);\n  }\n  return ret_val;\n}\n",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__sinit",
                "__retarget_lock_release_recursive",
                "__swsetup_r",
                "__swbuf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cdc",
            "calling": [
                "puts"
            ],
            "imported": false,
            "current_name": "print_string_00004cdc"
        },
        "FUN_00005e68": {
            "renaming": {
                "FUN_00005e68": "scan_formatted_input_00005e68",
                "__s": "input_string",
                "__format": "format_string",
                "local_80": "input_string_start",
                "local_7c": "input_string_length",
                "local_74": "max_field_width",
                "local_72": "field_width",
                "local_70": "input_string_current",
                "local_6c": "input_string_remaining_length",
                "in_r2": "arg_1",
                "in_r3": "arg_2",
                "local_5c": "arg_3",
                "local_4c": "arg_4",
                "local_38": "arg_5",
                "uStack_8": "arg_6",
                "uStack_4": "arg_7",
                "PTR__impure_ptr_00005eb8": "PTR__impure_ptr_00005eb8",
                "DAT_00005eb4": "DAT_00005eb4"
            },
            "code": "int scan_formatted_input_00005e68(char *input_string, char *format_string, ...)\n{\n  int scan_result;\n  char *input_string_start;\n  char *input_string_current;\n  size_t input_string_length;\n  size_t input_string_remaining_length;\n  undefined2 max_field_width = 0x204;\n  undefined2 field_width = 0xffff;\n  undefined4 arg_1;\n  undefined4 arg_2;\n  undefined4 arg_3;\n  undefined4 arg_4;\n  undefined4 arg_5 = DAT_00005eb4;\n  undefined4 arg_6 = 0;\n  undefined4 arg_7 = 0;\n\n  input_string_start = input_string;\n  input_string_current = input_string;\n  arg_1 = *(undefined4 *)PTR__impure_ptr_00005eb8;\n  input_string_length = strlen(input_string);\n  input_string_remaining_length = input_string_length;\n  scan_result = __ssvfiscanf_r(arg_1, &input_string_current, format_string, &arg_2, &arg_3, &arg_4, &arg_5, &arg_6, &arg_7);\n  return scan_result;\n}\n",
            "called": [
                "strlen",
                "__ssvfiscanf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e68",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "scan_formatted_input_00005e68"
        },
        "FUN_00000dcc": {
            "renaming": {
                "FUN_00000dcc": "set_data_values_00000dcc",
                "DAT_00000df0": "data_array"
            },
            "code": "void set_data_values_00000dcc(void)\n{\n  int* DAT_00000df0 = DAT_00000df0;\n  DAT_00000df0[7] = 0xc520;\n  DAT_00000df0[7] = 0xd928;\n  *DAT_00000df0 = 0xd2;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dcc",
            "calling": [
                "pre_startup"
            ],
            "imported": false,
            "current_name": "set_data_values_00000dcc"
        },
        "FUN_0000285c": {
            "renaming": {
                "FUN_0000285c": "set_RTC_counter_0000285c",
                "counter": "new_counter",
                "puVar1": "counter_address",
                "rtt": "rtc"
            },
            "code": "void set_RTC_counter_0000285c(uint32_t counter)\n{\n  uint32_t *counter_address = DAT_00002890;\n  RTC_Type *rtc = (RTC_Type *)counter_address;\n  counter_address[5] &= 0xffffffef;\n  *counter_address = counter;\n  counter_address[5] |= 0x10;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000285c",
            "calling": [
                "rtc_set_time"
            ],
            "imported": false,
            "current_name": "set_RTC_counter_0000285c"
        },
        "FUN_00000e58": {
            "renaming": {
                "FUN_00000e58": "infinite_loop_00000e58",
                "irq_disable": "disable_interrupts"
            },
            "code": "void infinite_loop_00000e58(void)\n{\n  disable_interrupts();\n  while(true) {\n    // Do nothing block with infinite loop\n  }\n}",
            "called": [
                "irq_disable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e58",
            "calling": [
                "core_panic"
            ],
            "imported": false,
            "current_name": "infinite_loop_00000e58"
        },
        "FUN_00001778": {
            "renaming": {
                "FUN_00001778": "set_bit_and_clear_other_bits_00001778",
                "DAT_000017d0": "data_ptr",
                "DAT_000017d8": "flag_ptr",
                "PTR_000017d0": "data_ptr",
                "PTR_000017d8": "flag_ptr"
            },
            "code": "void set_bit_and_clear_other_bits_00001778(void)\n{\n  byte *DAT_000017d0 = DAT_000017d0;\n  byte *DAT_000017d8 = DAT_000017d8;\n  byte flag_mask = 0x02;\n  byte data_mask = 0xcf;\n  byte data_byte = *(DAT_000017d0 + 1);\n  data_byte = (data_byte & data_mask) | 0x20;\n  *(DAT_000017d0 + 1) = data_byte;\n  bit_clear8(*DAT_000017d8, flag_mask);\n  return;\n}",
            "called": [
                "bit_clear8",
                "bit_set8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001778",
            "calling": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fee"
            ],
            "imported": false,
            "current_name": "set_bit_and_clear_other_bits_00001778"
        },
        "FUN_000026d8": {
            "renaming": {
                "FUN_000026d8": "power_on_rtt_000026d8"
            },
            "code": "void power_on_rtt_000026d8(void)\n{\n  rtt_poweron();\n  return;\n}",
            "called": [
                "rtt_poweron"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026d8",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "power_on_rtt_000026d8"
        },
        "FUN_00000566": {
            "renaming": {
                "FUN_00000566": "count_leading_zeroes_32bit_00000566",
                "v": "value",
                "bVar1": "byte3",
                "bVar2": "byte0",
                "bVar3": "byte1",
                "bVar4": "byte2",
                "uVar5": "bits"
            },
            "code": "uint count_leading_zeroes_32bit_00000566(uint value)\n{\n  byte byte0 = (byte)value;\n  byte byte1 = (byte)(value >> 8);\n  byte byte2 = (byte)(value >> 16);\n  byte byte3 = (byte)(value >> 24);\n  uint bits = (uint)(byte)((((((((byte0 & 1) << 1 | byte0 >> 1 & 1) << 1 | byte0 >> 2 & 1) << 1 | byte0 >> 3 & 1) << 1 | byte0 >> 4 & 1) << 1 | byte0 >> 5 & 1) << 1 | byte0 >> 6 & 1) << 1 | byte0 >> 7) << 24 | (uint)(byte)((((((((byte1 & 1) << 1 | byte1 >> 1 & 1) << 1 | byte1 >> 2 & 1) << 1 | byte1 >> 3 & 1) << 1 | byte1 >> 4 & 1) << 1 | byte1 >> 5 & 1) << 1 | byte1 >> 6 & 1) << 1 | byte1 >> 7) << 16 | (uint)(byte)((((((((byte2 & 1) << 1 | byte2 >> 1 & 1) << 1 | byte2 >> 2 & 1) << 1 | byte2 >> 3 & 1) << 1 | byte2 >> 4 & 1) << 1 | byte2 >> 5 & 1) << 1 | byte2 >> 6 & 1) << 1 | byte2 >> 7) << 8 | (uint)(byte)((((((((byte3 & 1) << 1 | byte3 >> 1 & 1) << 1 | byte3 >> 2 & 1) << 1 | byte3 >> 3 & 1) << 1 | byte3 >> 4 & 1) << 1 | byte3 >> 5 & 1) << 1 | byte3 >> 6 & 1) << 1 | byte3 >> 7));\n  if (value == 0) {\n    bits = 0xffffffff;\n  }\n  return bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000566",
            "calling": [
                "sched_run"
            ],
            "imported": false,
            "current_name": "count_leading_zeroes_32bit_00000566"
        },
        "FUN_00001d08": {
            "renaming": {
                "FUN_00001d08": "calculate_address_00001d08",
                "ptr": "ptr",
                "bit": "bit"
            },
            "code": "void * calculate_address_00001d08(void *ptr, uintptr_t bit) {\n    uintptr_t ptr_value = (uintptr_t)ptr;\n    uintptr_t upper_bits = ptr_value & 0xf0000000;\n    uintptr_t lower_bits = ptr_value & 0xfffff;\n    uintptr_t offset = (lower_bits << 5) + 0x2000000;\n    return (void *)(bit * 4 + upper_bits + offset);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d08",
            "calling": [
                "bit_set32"
            ],
            "imported": false,
            "current_name": "calculate_address_00001d08"
        },
        "FUN_000031fc": {
            "renaming": {
                "FUN_000031fc": "calculate_day_of_week_000031fc",
                "year": "year",
                "month": "month",
                "day": "day",
                "bVar1": "adjusted_month",
                "iVar2": "year_offset",
                "iVar3": "century_offset"
            },
            "code": "int calculate_day_of_week_000031fc(int year, int month, int day) {\n  int adjusted_month = (month < 3) ? month + 12 : month;\n  int year_offset = (adjusted_month <= 2) ? (year - 1) : year;\n  int century_offset = year_offset / 100;\n  int leap_year_offset = (2 - century_offset + (century_offset / 4));\n  int weekday = (leap_year_offset + year_offset + (year_offset / 4) + *(int *)(PTR_t_00003284 + (month + -1) * 4) + day) % 7;\n  return (weekday == 0) ? 7 : weekday;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031fc",
            "calling": [
                "_parse_time"
            ],
            "imported": false,
            "current_name": "calculate_day_of_week_000031fc"
        },
        "FUN_000016ec": {
            "renaming": {
                "FUN_000016ec": "set_bit_at_position_000016ec",
                "ptr": "data",
                "bit": "position",
                "puVar1": "bitband_address"
            },
            "code": "void set_bit_at_position_000016ec(uint8_t *data, uint8_t position) {\n  uint32_t *bitband_address = bitband_addr(data, (uint32_t)position);\n  *bitband_address = 1;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016ec",
            "calling": [
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_blpi",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_blpe",
                "kinetis_mcg_init_mcgirclk"
            ],
            "imported": false,
            "current_name": "set_bit_at_position_000016ec"
        },
        "FUN_00004e8c": {
            "renaming": {
                "_strtol_l_isra_0": "convert_string_to_long",
                "param_1": "output",
                "param_2": "string",
                "param_3": "end_ptr",
                "param_4": "base",
                "uVar1": "current_value",
                "uVar2": "current_char",
                "uVar3": "is_hex",
                "uVar4": "base_divided",
                "iVar5": "status",
                "uVar6": "max_value",
                "uVar7": "max_base_divided",
                "pbVar8": "unused",
                "pbVar9": "current_ptr",
                "FUN_00004e8c": "convert_string_to_long_00004e8c"
            },
            "code": "uint convert_string_to_long_00004e8c(undefined4 *output, byte *string, byte **end_ptr, uint base) {\n  uint current_char;\n  uint is_negative;\n  uint is_hex;\n  byte *current_ptr;\n  uint max_value;\n  uint current_value;\n  int status;\n  uint max_base_divided;\n  uint max_base_modulo;\n  uint base_divided;\n  current_ptr = string;\n  do {\n    current_char = (uint)*current_ptr;\n    is_hex = (byte)PTR_DAT_00004f7c[current_char] & 8;\n    current_ptr++;\n  } while ((PTR_DAT_00004f7c[current_char] & 8) != 0);\n  if (current_char == 0x2d) {\n    current_char = (uint)*current_ptr;\n    is_negative = 1;\n    current_ptr++;\n  }\n  else if (current_char == 0x2b) {\n    current_char = (uint)*current_ptr;\n    current_ptr++;\n  }\n  if (base == 0) {\n    if (current_char != 0x30) {\n      base = 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((base != 0x10) || (current_char != 0x30)) {\n    goto LAB_00004ed6;\n  }\n  if ((*current_ptr & 0xdf) == 0x58) {\n    current_char = (uint)current_ptr[1];\n    base = 0x10;\n    current_ptr += 2;\n  }\n  else {\n    current_char = 0x30;\n    if (base == 0) {\n      base = 8;\n    }\n  }\n  LAB_00004ed6:\n  max_value = 0x7fffffff;\n  is_negative = is_negative + max_value;\n  max_base_divided = max_value / base;\n  current_value = 0;\n  do {\n    base_divided = current_char - 0x30;\n    if (9 < base_divided) {\n      if (current_char - 0x41 < 0x1a) {\n        base_divided = current_char - 0x37;\n      }\n      else {\n        if (0x19 < current_char - 0x61) break;\n        base_divided = current_char - 0x57;\n      }\n    }\n    if ((int)base <= (int)base_divided) {\n      break;\n    }\n    if (status != -1) {\n      max_base_modulo = is_negative - base * max_base_divided;\n      if ((max_base_divided < current_value) || ((max_base_divided == current_value && ((int)max_base_modulo < (int)base_divided)))) {\n        status = -1;\n      }\n      else {\n        current_value = current_value * base + base_divided;\n        status = 1;\n      }\n    }\n    current_char = (uint)*current_ptr;\n    current_ptr++;\n  } while( true );\n  if (status == -1) {\n    *output = 0x22;\n    current_value = is_negative;\n    if (end_ptr == (byte **)0x0) {\n      return is_negative;\n    }\n  }\n  else {\n    if (is_negative != 0) {\n      current_value = -current_value;\n    }\n    if (end_ptr == (byte **)0x0) {\n      return current_value;\n    }\n    if (status == 0) goto LAB_00004f64;\n  }\n  current_ptr--;\n  LAB_00004f64:\n  *end_ptr = current_ptr;\n  return current_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e8c",
            "calling": [
                "_strtol_r",
                "strtol"
            ],
            "imported": false,
            "current_name": "convert_string_to_long_00004e8c"
        },
        "FUN_00005100": {
            "renaming": {
                "FUN_00005100": "call_impure_ptr_function_00005100",
                "PTR__impure_ptr_00005108": "PTR__impure_ptr",
                "FUN_00005100_r": "impure_ptr_function"
            },
            "code": "void call_impure_ptr_function_00005100(void)\n{\n  int* impure_ptr = *(int**)PTR__impure_ptr_00005108_00005108;\n  impure_ptr_function(impure_ptr);\n  return;\n}",
            "called": [
                "_tzset_unlocked_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005100",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "call_impure_ptr_function_00005100"
        },
        "FUN_00005584": {
            "renaming": {
                "FUN_00005584_t": "DivisionResult",
                "FUN_00005584": "divide_00005584",
                "__numer": "dividend",
                "__denom": "divisor",
                "in_r2": "quotient",
                "uVar2": "quotient",
                "iVar1": "remainder"
            },
            "code": "typedef struct {\n  uint32_t quotient;\n  int32_t remainder;\n} DivisionResult;\n\nDivisionResult divide_00005584(int32_t divide_00005584nd, int32_t divisor)\n{\n  uint32_t quotient = (uint32_t)divide_00005584nd / divisor;\n  int32_t remainder = divide_00005584nd - (int32_t)quotient * divisor;\n  if (divide_00005584nd < 0) {\n    if (0 < remainder) {\n      quotient--;\n      remainder += divisor;\n    }\n  }\n  else if (remainder < 0) {\n    quotient++;\n    remainder -= divisor;\n  }\n  return (DivisionResult){ quotient, remainder };\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005584",
            "calling": [
                "validate_structure"
            ],
            "imported": false,
            "current_name": "divide_00005584"
        },
        "FUN_00000cb0": {
            "renaming": {
                "FUN_00000cb0": "debug_monitor_panic_00000cb0",
                "PTR_s_DEBUG_MON_HANDLER_00000cbc": "debug_monitor_handler"
            },
            "code": "void debug_monitor_panic_00000cb0(void)\n{\n    /* WARNING: Subroutine does not return */\n    core_panic(PANIC_DEBUG_MON, PTR_s_DEBUG_MON_HANDLER_00000cbc);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cb0",
            "calling": [],
            "imported": false,
            "current_name": "debug_monitor_panic_00000cb0"
        },
        "FUN_00004248": {
            "renaming": {
                "FUN_00004248": "allocate_memory_for_data_00004248",
                "param_1": "size_of_data",
                "param_2": "num_of_elements",
                "puVar1": "data_ptr",
                "iVar2": "total_size"
            },
            "code": "undefined4 * allocate_memory_for_data_00004248(int size_of_data, int num_of_elements)\n{\n  undefined4 *data_ptr;\n  int total_size = (num_of_elements - 1) * sizeof(int) + sizeof(int) * 3;\n  data_ptr = (undefined4 *)_malloc_r(size_of_data, total_size);\n  if (data_ptr != (undefined4 *)0x0) {\n    *data_ptr = 0;\n    *(data_ptr + 1) = num_of_elements;\n    *(data_ptr + 2) = data_ptr + 3;\n    memset(data_ptr + 3, 0, total_size - sizeof(int) * 3);\n  }\n  return data_ptr;\n}",
            "called": [
                "memset",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004248",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "allocate_memory_for_data_00004248"
        },
        "FUN_00000f5c": {
            "renaming": {
                "FUN_00000f5c": "start_RIOT_00000f5c",
                "auto_init": "auto_initialize",
                "iprintf": "print_initial_message",
                "PTR_s_main____This_is_RIOT___Version__2_00000f7c": "PTR_s_main____This_is_RIOT___Version__2_00000f7c",
                "main": "run_main"
            },
            "code": "void * start_RIOT_00000f5c(void *arg)\n{\n  auto_initialize();\n  print_initial_message(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n  run_main();\n  return (void *)0x0;\n}",
            "called": [
                "auto_init",
                "iprintf",
                "main"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f5c",
            "calling": [],
            "imported": false,
            "current_name": "start_RIOT_00000f5c"
        },
        "FUN_00001da2": {
            "renaming": {
                "FUN_00001da2": "get_pin_value_00001da2",
                "pin": "gpio_t pin"
            },
            "code": "int get_pin_value_00001da2(gpio_t pin) {\n    int mask = 7;\n    int shifted_pin = pin >> 6;\n    int pin_value = shifted_pin & mask;\n    return pin_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001da2",
            "calling": [
                "gpio_init_port",
                "clk_en"
            ],
            "imported": false,
            "current_name": "get_pin_value_00001da2"
        },
        "FUN_00001ec4": {
            "renaming": {
                "FUN_00001ec4": "write_context_to_map_00001ec4",
                "port": "port_num",
                "pin": "pin_num",
                "ctx_00": "context_pointer",
                "ctx": "context_value",
                "get_ctx": "get_context_pointer",
                "write_map": "write_to_map"
            },
            "code": "void write_context_to_map_00001ec4(int port_num, int pin_num)\n{\n  int context_pointer;\n  int context_value;\n  context_pointer = get_context_pointer(port_num, pin_num);\n  write_to_map(port_num, pin_num, context_pointer);\n  return;\n}",
            "called": [
                "write_map",
                "get_ctx"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ec4",
            "calling": [
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "write_context_to_map_00001ec4"
        },
        "FUN_00002744": {
            "renaming": {
                "FUN_00002744": "set_irq_priority_00002744",
                "IRQn": "irq",
                "priority": "priority",
                "*(char *)(((byte)IRQn & 0xf) + DAT_00002790 + 0x14)": "*(uint32_t*) (0xE000E400 + 0x14 + ((uint32_t)irq & 0xF))",
                "*(char *)(IRQn + DAT_00002794 + 0x300)": "*(uint32_t*) (0xE000E400 + 0x300 + ((uint32_t)irq - 16))"
            },
            "code": "void set_irq_priority_00002744(IRQn_Type irq, uint32_t priority) {\n  if (irq < DMA0_IRQn) {\n    uint32_t* nvic_ipr = (uint32_t*) (0xE000E400 + 0x14 + ((uint32_t)irq & 0xF));\n    *nvic_ipr = (priority & 0xFF) << 4;\n  }\n  else {\n    uint32_t* nvic_ipr = (uint32_t*) (0xE000E400 + 0x300 + ((uint32_t)irq - 16));\n    *nvic_ipr = (priority & 0xFF) << 4;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002744",
            "calling": [
                "rtt_set_alarm"
            ],
            "imported": false,
            "current_name": "set_irq_priority_00002744"
        },
        "FUN_00002624": {
            "renaming": {
                "FUN_00002624": "get_time_from_rtt_counter_00002624",
                "time": "time_struct",
                "t": "counter_time"
            },
            "code": "int get_time_from_rtt_counter_00002624(tm *time_struct)\n{\n  time_t counter_time;\n  counter_time._0_4_ = rtt_get_counter();\n  counter_time._4_4_ = 0;\n  gmtime_r((time_t *)&counter_time, (tm *)time_struct);\n  return 0;\n}",
            "called": [
                "gmtime_r",
                "rtt_get_counter"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002624",
            "calling": [
                "_rtc_gettime"
            ],
            "imported": false,
            "current_name": "get_time_from_rtt_counter_00002624"
        },
        "FUN_00001e0c": {
            "renaming": {
                "FUN_00001e0c": "get_pin_value_00001e0c",
                "port": "port_num",
                "pin": "pin_num",
                "PTR_isr_map_00001e40": "isr_map_ptr"
            },
            "code": "int get_pin_value_00001e0c(int port_num, int pin_num) {\n    uint* PTR_isr_map_00001e40 = PTR_isr_map_00001e40;\n    int pin_offset = (pin_num >> 3) + port_num * 4;\n    uint* pin_address_ptr = PTR_isr_map_00001e40 + pin_offset * 4;\n    int pin_shift_amount = (pin_num & 7U) << 2;\n    uint pin_value = *pin_address_ptr >> pin_shift_amount & 0xf;\n    return pin_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e0c",
            "calling": [
                "irq_handler",
                "ctx_clear"
            ],
            "imported": false,
            "current_name": "get_pin_value_00001e0c"
        },
        "FUN_00000ef8": {
            "renaming": {
                "FUN_00000ef8": "do_nothing_00000ef8"
            },
            "code": "\nvoid do_nothing_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ef8",
            "calling": [
                "core_panic"
            ],
            "imported": false,
            "current_name": "do_nothing_00000ef8"
        },
        "FUN_000041d0": {
            "renaming": {
                "FUN_000041d0": "file_walk_000041d0",
                "__stream": "__stream",
                "iVar1": "result",
                "PTR__global_impure_ptr_000041e8": "global_impure_ptr",
                "DAT_000041ec": "DAT_000041ec",
                "_fwalk_reent": "_file_walk_reentrant",
                "PTR__impure_ptr_000041f0": "impure_ptr"
            },
            "code": "int file_walk_000041d0(FILE *__stream) {\n  int result;\n  if (__stream == NULL) {\n    result = _fwalk_reent(*PTR__global_PTR__impure_ptr_000041f0_000041e8, DAT_000041ec);\n    return result;\n  }\n  result = _file_walk_000041d0_reentrant(*PTR__impure_ptr_000041f0, __stream);\n  return result;\n}",
            "called": [
                "_fflush_r",
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041d0",
            "calling": [
                "lflush",
                "print_prompt"
            ],
            "imported": false,
            "current_name": "file_walk_000041d0"
        },
        "FUN_0000459c": {
            "renaming": {
                "FUN_0000459c": "initialize_EVP_PKEY_CTX_0000459c",
                "param_1": "context",
                "puVar1": "pointer_1",
                "puVar2": "pointer_2",
                "iVar3": "fini_array_size",
                "ppcVar4": "fini_array_start",
                "iVar5": "i"
            },
            "code": "void initialize_EVP_PKEY_CTX_0000459c(EVP_PKEY_CTX *context)\n{\n  int fini_array_size = (int)PTR___fini_array_end_000045d8 - (int)PTR___fini_array_end_000045d4;\n  code **fini_array_start = (code **)PTR___fini_array_end_000045d4;\n  for (int i = 0; i < fini_array_size / 4; i++) {\n    context = (EVP_PKEY_CTX *)(*fini_array_start)();\n    fini_array_start++;\n  }\n  _init(context);\n  code **fini_array_end = (code **)PTR___fini_array_end_000045e0;\n  fini_array_start = (code **)PTR___fini_array_end_000045dc;\n  for (int i = 0; i < ((int)fini_array_end - (int)fini_array_start) / 4; i++) {\n    (*(*fini_array_start)())();\n    fini_array_start++;\n  }\n  return;\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000459c",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "initialize_EVP_PKEY_CTX_0000459c"
        },
        "FUN_000014c4": {
            "renaming": {
                "FUN_000014c4": "set_uart_configuration_000014c4",
                "uart": "uart_t",
                "baudrate": "uint32_t",
                "pbVar1": "config",
                "uVar2": "config_value",
                "txfifo_size": "N/A",
                "brfa": "brfa_value",
                "ubd": "ubr",
                "clk": "N/A",
                "dev": "N/A"
            },
            "code": "void set_uart_configuration_000014c4(uart_t uart, uint32_t baudrate) {\n  byte *config = *(byte **)(PTR_uart_config_000015cc + uart * 0x20);\n  uint32_t config_value = *(uint *)(PTR_uart_config_000015cc + uart * 0x20 + 4);\n  config[3] &= 0xf3;\n  config[2] = PTR_uart_config_000015cc[uart * 0x20 + 0x1d];\n  uint32_t ubr = config_value / (baudrate << 4);\n  config[0] = (byte)(ubr >> 8) & 0x1f;\n  config[1] = (byte)ubr;\n  uint32_t brfa_value = (config_value << 2) / baudrate + 1 >> 1;\n  config[10] = (byte)(brfa_value & 0x1f);\n  config[0x10] |= 0x88;\n  if ((config[0x10] & 0x70) == 0) {\n    config[0x13] = 0;\n  }\n  else {\n    config[0x13] = (char)(2 << (config[0x10] >> 4 & 7)) - 1;\n  }\n  config[0x15] = 1;\n  config[0x11] = 0xc0;\n  config[3] |= 0x2c;\n  NVIC_EnableIRQ(PTR_uart_config_000015cc[uart * 0x20 + 0x14]);\n  return;\n}",
            "called": [
                "NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000014c4",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "set_uart_configuration_000014c4"
        },
        "FUN_00004b34": {
            "renaming": {
                "FUN_00004b34": "allocateMemory_00004b34",
                "param_1": "errorCode",
                "param_2": "size",
                "param_3": "initialValue",
                "param_4": "unusedParameter",
                "puVar1": "headOfFreeList",
                "piVar2": "pointerToNextBlock",
                "extraout_r1": "pointerToMemoryBlock",
                "ppiVar3": "pointerToMemoryBlock",
                "ppiVar4": "pointerToPreviousBlock",
                "ppiVar5": "pointerToPointerToHeadOfFreeList",
                "ppiVar6": "pointerToPointerToMemoryBlock",
                "bVar7": "isMemoryBlockAtHeadOfList"
            },
            "code": "void allocateMemory_00004b34(int* errorCode, int size, int initialValue, int unusedParameter)\n{\n  bool isNegativeSize = false;\n  int** pointerToPointerToMemoryBlock = (int**)(size - 4);\n  if (*pointerToPointerToMemoryBlock < 0)\n  {\n    pointerToPointerToMemoryBlock = (int**)((int)pointerToPointerToMemoryBlock + **pointerToPointerToMemoryBlock);\n    isNegativeSize = true;\n  }\n  __malloc_lock();\n  void* headOfFreeList = PTR___malloc_free_list_00004bcc;\n  int** pointerToPointerToHeadOfFreeList = *(int***)(headOfFreeList);\n  if (pointerToPointerToHeadOfFreeList == NULL)\n  {\n    pointerToPointerToMemoryBlock[1] = NULL;\n    *(int***)headOfFreeList = pointerToPointerToMemoryBlock;\n    int** pointerToMemoryBlock = (int**)extraout_r1;\n    int** pointerToPreviousBlock = (int**)headOfFreeList;\n  }\n  else if (pointerToPointerToMemoryBlock < pointerToPointerToHeadOfFreeList)\n  {\n    int** pointerToMemoryBlock = *pointerToPointerToMemoryBlock;\n    int** pointerToNextBlock = (int**)((int)pointerToPointerToMemoryBlock + (int)pointerToMemoryBlock);\n    bool isMemoryBlockAtHeadOfList = pointerToPointerToHeadOfFreeList == pointerToNextBlock;\n    if (isMemoryBlockAtHeadOfList)\n    {\n      pointerToNextBlock = *pointerToPointerToHeadOfFreeList;\n      pointerToPointerToHeadOfFreeList = (int**)pointerToPointerToHeadOfFreeList[1];\n    }\n    pointerToMemoryBlock[1] = (int*)pointerToPointerToHeadOfFreeList;\n    if (isMemoryBlockAtHeadOfList)\n    {\n      pointerToNextBlock = (int**)((int)pointerToNextBlock + (int)pointerToMemoryBlock);\n      *pointerToPointerToMemoryBlock = (int*)pointerToNextBlock;\n    }\n    *(int***)headOfFreeList = pointerToPointerToMemoryBlock;\n  }\n  else\n  {\n    int** pointerToPreviousBlock = pointerToPointerToHeadOfFreeList;\n    int** pointerToNextBlock = (int**)pointerToPreviousBlock[1];\n    while (pointerToNextBlock != NULL && pointerToNextBlock <= pointerToPointerToMemoryBlock)\n    {\n      pointerToPreviousBlock = pointerToNextBlock;\n      pointerToNextBlock = (int**)pointerToPreviousBlock[1];\n    }\n    int** pointerToMemoryBlock = *pointerToPreviousBlock;\n    if ((int**)((int)pointerToPreviousBlock + (int)pointerToMemoryBlock) == pointerToPointerToMemoryBlock)\n    {\n      pointerToMemoryBlock = (int**)((int)pointerToMemoryBlock + **pointerToPointerToMemoryBlock);\n      *pointerToPreviousBlock = (int*)pointerToMemoryBlock;\n      if (pointerToNextBlock == (int**)((int)pointerToPreviousBlock + (int)pointerToMemoryBlock))\n      {\n        int* pointerToNextBlockValue = *pointerToNextBlock;\n        pointerToPreviousBlock[1] = pointerToNextBlock[1];\n        pointerToMemoryBlock = (int**)((int)pointerToMemoryBlock + (int)pointerToNextBlockValue);\n        *pointerToPreviousBlock = (int*)pointerToMemoryBlock;\n      }\n    }\n    else if (pointerToPointerToMemoryBlock < (int**)((int)pointerToPreviousBlock + (int)pointerToMemoryBlock))\n    {\n      *errorCode = 0xc;\n    }\n    else\n    {\n      int** pointerToNextBlock = (int**)((int)pointerToPointerToMemoryBlock + **pointerToPointerToMemoryBlock);\n      bool isMemoryBlockAtHeadOfList = pointerToNextBlock == pointerToPointerToHeadOfFreeList;\n      if (isMemoryBlockAtHeadOfList)\n      {\n        pointerToNextBlock = *pointerToNextBlock;\n        pointerToPointerToHeadOfFreeList = (int**)pointerToPointerToHeadOfFreeList[1];\n      }\n      pointerToMemoryBlock[1] = (int*)pointerToPointerToHeadOfFreeList;\n      if (isMemoryBlockAtHeadOfList)\n      {\n        pointerToNextBlock = (int**)((int)pointerToNextBlock + (int)*pointerToPointerToMemoryBlock);\n        *pointerToPointerToMemoryBlock = (int*)pointerToNextBlock;\n      }\n      pointerToPreviousBlock[1] = (int*)pointerToPointerToMemoryBlock;\n    }\n  }\n  __malloc_unlock(errorCode, pointerToMemoryBlock, pointerToPreviousBlock, unusedParameter);\n  return;\n}",
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004b34",
            "calling": [
                "__sflush_r",
                "free",
                "__srefill_r",
                "__ssrefill_r",
                "_realloc_r",
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "allocateMemory_00004b34"
        },
        "FUN_000004f2": {
            "renaming": {
                "FUN_000004f2": "set_errno_and_return_negative_one_if_invalid_position_000004f2",
                "r": "reent",
                "fd": "file_descriptor",
                "pos": "position",
                "dir": "direction"
            },
            "code": "_off_t set_errno_and_return_negative_one_if_invalid_position_000004f2(_reent *reent, int file_descriptor, _off_t position, int direction) {\n  reent->_errno = 0x13;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004f2",
            "calling": [
                "__swrite",
                "__sseek"
            ],
            "imported": false,
            "current_name": "set_errno_and_return_negative_one_if_invalid_position_000004f2"
        },
        "FUN_0000423c": {
            "renaming": {
                "FUN_0000423c": "walk_directory_and_free_memory_0000423c",
                "param_1": "reentrancy_structure",
                "DAT_00004244": "directory_free_function"
            },
            "code": "void walk_directory_and_free_memory_0000423c(void* reentrancy_structure){\n  _fwalk_reent(reentrancy_structure, DAT_00004244);\n  return;\n}",
            "called": [
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000423c",
            "calling": [],
            "imported": false,
            "current_name": "walk_directory_and_free_memory_0000423c"
        },
        "FUN_00004e66": {
            "renaming": {
                "FUN_00004e66": "compare_strings_00004e66",
                "__s1": "string1",
                "__s2": "string2",
                "__n": "length",
                "pbVar1": "current_byte_string1",
                "pbVar2": "current_byte_string2",
                "uVar3": "current_byte_value"
            },
            "code": "int compare_strings_00004e66(char* string1, char* string2, size_t length) {\n  byte *current_byte_string2;\n  byte *current_byte_string1;\n  uint current_byte_value;\n  \n  if (length != 0) {\n    current_byte_string2 = (byte *)(string2 + length - 1);\n    current_byte_string1 = (byte *)string1;\n    do {\n      current_byte_value = (uint)*current_byte_string1;\n      current_byte_string2++;\n      if ((current_byte_value != *current_byte_string2) || (current_byte_string1 + 1 == (byte *)(string1 + length))) break;\n      current_byte_string1++;\n    } while (current_byte_value != 0);\n    length = current_byte_value - *current_byte_string2;\n  }\n  return length;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e66",
            "calling": [
                "_rtc_handler",
                "_findenv_r"
            ],
            "imported": false,
            "current_name": "compare_strings_00004e66"
        },
        "FUN_00005ecc": {
            "renaming": {
                "FUN_00005ecc": "count_characters_00005ecc",
                "__s": "str",
                "pcVar3": "current_ptr",
                "pcVar2": "next_ptr",
                "cVar1": "current_char"
            },
            "code": "size_t count_characters_00005ecc(char* str) {\n  char current_char;\n  char* current_ptr = str;\n  while (current_char = *current_ptr++) {\n    ;\n  }\n  return (size_t)(current_ptr - str - 1);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ecc",
            "calling": [
                "siscanf",
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "count_characters_00005ecc"
        },
        "FUN_0000129c": {
            "renaming": {
                "FUN_0000129c": "lock_mutex_0000129c",
                "mutex": "mutex",
                "_FUN_0000129c": "lock_mutex_with_timeout"
            },
            "code": "void lock_mutex_0000129c(mutex_t *mutex){\n  lock_mutex_0000129c_with_timeout(mutex, 1);\n  return;\n}",
            "called": [
                "_mutex_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000129c",
            "calling": [
                "isrpipe_read"
            ],
            "imported": false,
            "current_name": "lock_mutex_0000129c"
        },
        "FUN_00001628": {
            "renaming": {
                "FUN_00001628": "uart_data_transmission_00001628",
                "data": "data",
                "dev": "uart_device",
                "PTR_uart_config_00001680": "PTR_uart_config_00001680",
                "PTR_config_00001684": "PTR_config_00001684",
                "uart": "uart_t",
                "uart_config_flags": "uart_config_flags",
                "uart_config_func": "uart_config_func",
                "uart_config_func_param": "uart_config_func_param"
            },
            "code": "void uart_data_transmission_00001628(uart_t uart)\n{\n  uint8_t data;\n  UART_Type *uart_device;\n  uint8_t uart_config_flags = *(byte *)(*(int *)(PTR_uart_config_00001680 + uart * 0x20) + 4);\n  uint32_t *uart_config_func = *(uint32_t **)(PTR_config_00001684 + uart * 8);\n  uint32_t uart_config_func_param = *(uint32_t *)(PTR_config_00001684 + uart * 8 + 4);\n\n  if ((uart_config_flags & 0x20) && (uart_config_func != 0)) {\n    (*(void (*)(uint32_t, uint8_t))uart_config_func)(uart_config_func_param, *(uint8_t *)(*(int *)(PTR_uart_config_00001680 + uart * 0x20) + 7));\n  }\n  cortexm_isr_end();\n  return;\n}",
            "called": [
                "cortexm_isr_end"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001628",
            "calling": [
                "isr_uart0_rx_tx"
            ],
            "imported": false,
            "current_name": "uart_data_transmission_00001628"
        },
        "FUN_00001748": {
            "renaming": {
                "FUN_00001748": "set_kinetis_mcg_fll_factor_00001748",
                "factor": "new_factor",
                "DAT_00001774": "PTR_DAT_00001774",
                "PTR_DAT_00001774": "PTR_DAT_00001774",
                "KINETIS_MCG_FLL_FACTOR_2929": "KINETIS_MCG_FLL_FACTOR_2929"
            },
            "code": "void set_kinetis_mcg_fll_factor_00001748(kinetis_mcg_fll_t factor) {\n  kinetis_mcg_fll_t* fll_factor_ptr = (kinetis_mcg_fll_t *)(DAT_00001774 + 3);\n  kinetis_mcg_fll_t current_fll_factor = *fll_factor_ptr;\n  kinetis_mcg_fll_t new_fll_factor = factor | (current_fll_factor & ~KINETIS_MCG_FLL_FACTOR_2929);\n  *fll_factor_ptr = new_fll_factor;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001748",
            "calling": [
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_fbi"
            ],
            "imported": false,
            "current_name": "set_kinetis_mcg_fll_factor_00001748"
        },
        "FUN_0000294c": {
            "renaming": {
                "FUN_0000294c": "set_RTC_alarm_flag_0000294c",
                "rtt": "rtc_instance",
                "*(uint *)(DAT_0000296c + 0x14)": "alarm_flag_register"
            },
            "code": "void set_RTC_alarm_flag_0000294c(void)\n{\n  RTC_Type *rtc_instance = PTR_RTC;\n  uint32_t **(uint *)(DAT_0000296c + 0x14) = &(DAT_0000296c[0x14]);\n  **(uint *)(DAT_0000296c + 0x14) |= 0x10;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000294c",
            "calling": [
                "rtc_poweron",
                "rtt_init"
            ],
            "imported": false,
            "current_name": "set_RTC_alarm_flag_0000294c"
        },
        "FUN_00005790": {
            "renaming": {
                "FUN_00005790": "acquireRecursiveLockForMalloc_00005790",
                "PTR___lock___malloc_recursive_mutex_00005798": "PTR_recursiveLockForMalloc"
            },
            "code": "void acquireRecursiveLockForMalloc_00005790(void)\n{\n  __retarget_lock_acquire_recursive(PTR___lock___malloc_recursive_mutex_00005798);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005790",
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "imported": false,
            "current_name": "acquireRecursiveLockForMalloc_00005790"
        },
        "FUN_00000534": {
            "renaming": {
                "FUN_00000534": "check_file_descriptor_validity_00000534",
                "r": "reent",
                "fd": "file_descriptor",
                "iVar1": "is_valid",
                "PTR_": "reent",
                "DAT_": "data"
            },
            "code": "int check_file_descriptor_validity_00000534(_PTR_ *PTR_, int file_descriptor) {\n  int is_valid = 0;\n  PTR_->_errno = 0;\n  if (((file_descriptor == STDIN_FILENO) || (file_descriptor == STDOUT_FILENO)) || (file_descriptor == STDERR_FILENO)) {\n    is_valid = 1;\n  }\n  return is_valid;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000534",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_file_descriptor_validity_00000534"
        },
        "FUN_000017dc": {
            "renaming": {
                "FUN_000017dc": "set_bit_and_check_000017dc",
                "DAT_00001820": "data",
                "DAT_00001824": "ptr",
                "DAT_00001828": "data_mask"
            },
            "code": "void set_bit_and_check_000017dc(uint32_t* DAT_00001820, uint32_t bit_position) {\n  bit_set32(DAT_00001820, bit_position);\n  uint32_t* DAT_00001824 = (uint32_t*)(DAT_00001820 + 0x10);\n  if ((*DAT_00001824 & 0x100) == 0) {\n    *DAT_00001824 = 0x104;\n  }\n  *DAT_00001820 = (*DAT_00001820 & 0xfff3ffff) | 0x80000;\n  return;\n}",
            "called": [
                "bit_set32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000017dc",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "set_bit_and_check_000017dc"
        },
        "FUN_00000410": {
            "renaming": {
                "FUN_00000410": "print_uart_stdio_00000410",
                "ctx": "context",
                "uart_stdioFUN_00000410": "uart_stdio"
            },
            "code": "int print_uart_stdio_00000410(EVP_PKEY_CTX *context){\n  uart_stdio();\n  return (int)context;\n}",
            "called": [
                "uart_stdio_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000410",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "print_uart_stdio_00000410"
        },
        "FUN_000005ca": {
            "renaming": {
                "FUN_000005ca": "remove_second_node_000005ca",
                "list": "list",
                "plVar1": "second_node"
            },
            "code": "clist_node_t* remove_second_node_000005ca(clist_node_t* list) {\n\tlist_node* second_node = NULL;\n\tif (list->next == NULL) {\n\t\tsecond_node = NULL;\n\t}\n\telse {\n\t\tsecond_node = list->next->next;\n\t\tif (second_node == list->next) {\n\t\t\tlist->next = NULL;\n\t\t}\n\t\telse {\n\t\t\tlist->next->next = second_node->next;\n\t\t}\n\t}\n\treturn second_node;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000005ca",
            "calling": [
                "sched_set_status"
            ],
            "imported": false,
            "current_name": "remove_second_node_000005ca"
        },
        "FUN_000043da": {
            "renaming": {
                "FUN_000043da": "processEntries_000043da",
                "param_1": "baseAddress",
                "param_2": "entryFunction",
                "param_3": "arg1",
                "param_4": "arg2",
                "piVar3": "entryPointer",
                "uVar5": "result",
                "iVar6": "entryCount",
                "iVar4": "entryData",
                "uVar1": "functionResult",
                "iVar2": "entryDataOffset"
            },
            "code": "uint processEntries_000043da(int baseAddress, code *entryFunction, undefined4 arg1, undefined4 arg2) {\n  uint result = 0;\n  int *entryPointer = (int *)(baseAddress + 0x48);\n  do {\n    int entryCount = entryPointer[1];\n    int entryData = entryPointer[2];\n    while (entryCount--) {\n      if (*(ushort *)(entryData + 0xc) > 1 && *(short *)(entryData + 0xe) != 0) {\n        uint functionResult = (*entryFunction)(baseAddress,entryData,arg1,*(short *)(entryData + 0xe) + 1,arg2);\n        result |= functionResult;\n      }\n      entryData += 0x68;\n    }\n    entryPointer = (int *)*entryPointer;\n  } while (entryPointer != (int *)0x0);\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043da",
            "calling": [
                "_cleanup_r",
                "fflush"
            ],
            "imported": false,
            "current_name": "processEntries_000043da"
        },
        "FUN_00005ff8": {
            "renaming": {
                "FUN_00005ff8": "release_recursive_mutex_00005ff8",
                "PTR___lock___env_recursive_mutex_00006000": "PTR_mutex_00006000"
            },
            "code": "void release_recursive_mutex_00005ff8(void)\n{\n  __retarget_lock_release_recursive(PTR___lock___env_recursive_mutex_00006000);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ff8",
            "calling": [
                "_findenv_r"
            ],
            "imported": false,
            "current_name": "release_recursive_mutex_00005ff8"
        },
        "FUN_00006754": {
            "renaming": {
                "FUN_00006754": "flush_file_if_read_mode_00006754",
                "param_1": "file_ptr",
                "iVar1": "flush_status",
                "PTR_": "file_ptr->",
                "_IO_": "_IO_",
                "DAT_": "data_"
            },
            "code": "int flush_file_if_read_mode_00006754(FILE* file_ptr)\n{\n  int flush_status;\n  ushort* read_base_ptr = (ushort*)&PTR__IO_read_base;\n  ushort read_base = *read_base_ptr;\n  if ((read_base & 9) == 9)\n  {\n    flush_status = fflush(file_ptr);\n    return flush_status;\n  }\n  return 0;\n}",
            "called": [
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006754",
            "calling": [],
            "imported": false,
            "current_name": "flush_file_if_read_mode_00006754"
        },
        "FUN_00002714": {
            "renaming": {
                "FUN_00002714": "setInterruptPriority_00002714",
                "IRQn": "interrupt_number",
                "DAT_00002740": "interrupt_register_base_address"
            },
            "code": "void setInterruptPriority_00002714(IRQn_Type interrupt_number)\n{\n    int* interrupt_register_address = (int*)(DAT_00002740 + ((uint)(int)interrupt_number >> 5) * 4);\n    int interrupt_bit_position = 1 << (interrupt_number & 0x1fU);\n    *interrupt_register_address = interrupt_bit_position;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002714",
            "calling": [
                "rtt_set_alarm"
            ],
            "imported": false,
            "current_name": "setInterruptPriority_00002714"
        },
        "FUN_000020e0": {
            "renaming": {
                "FUN_000020e0": "handle_interrupt_000020e0",
                "DAT_000020f0": "interrupt_type"
            },
            "code": "void handle_interrupt_000020e0(void)\n{\n  int DAT_000020f0 = 2;\n  irq_handler(DAT_000020f0);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020e0",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_000020e0"
        },
        "FUN_00004f80": {
            "renaming": {
                "FUN_00004f80": "parse_number_00004f80",
                "param_1": "result",
                "param_2": "string",
                "param_3": "end_ptr",
                "param_4": "base",
                "pbVar8": "current_char",
                "pbVar9": "ptr",
                "uVar1": "result_val",
                "uVar2": "digit",
                "uVar3": "char_type",
                "uVar4": "digit_val",
                "uVar6": "overflow_threshold",
                "uVar7": "max_divisor",
                "iVar5": "overflowed"
            },
            "code": "uint parse_number_00004f80(undefined4 *result, byte *string, byte **end_ptr, uint base) {\n  uint digit;\n  uint is_negative = 0;\n  uint overflow_threshold;\n  int overflowed = 0;\n  byte *ptr = string;\n  if (*ptr == '-') {\n    is_negative = 1;\n    ptr++;\n  }\n  else if (*ptr == '+') {\n    ptr++;\n  }\n  if (base == 0) {\n    if (*ptr != '0') {\n      base = 10;\n    }\n    else if ((*(ptr + 1) & 0xDF) == 'X') {\n      base = 16;\n      ptr += 2;\n    }\n    else {\n      base = 8;\n    }\n  }\n  else if (base != 16 || *ptr != '0') {\n    base = 10;\n  }\n  overflow_threshold = 0x7FFFFFFF / base;\n  *result = 0;\n  while (1) {\n    if (*ptr >= '0' && *ptr <= '9') {\n      digit = *ptr - '0';\n    }\n    else if (*ptr >= 'A' && *ptr <= 'Z') {\n      digit = *ptr - 'A' + 10;\n    }\n    else if (*ptr >= 'a' && *ptr <= 'z') {\n      digit = *ptr - 'a' + 10;\n    }\n    else {\n      break;\n    }\n    if (digit >= base) {\n      break;\n    }\n    if (*result > overflow_threshold || (*result == overflow_threshold && digit > 0x7FFFFFFF % base)) {\n      overflowed = 1;\n    }\n    else {\n      *result = *result * base + digit;\n    }\n    ptr++;\n  }\n  if (overflowed) {\n    *result = 0x7FFFFFFF + is_negative;\n    if (end_ptr == NULL) {\n      return overflow_threshold;\n    }\n  }\n  else {\n    if (is_negative) {\n      *result = -*result;\n    }\n    if (end_ptr == NULL) {\n      return *result;\n    }\n    if (overflowed == 0 && *ptr != '\\0') {\n      end_ptr = &ptr;\n    }\n  }\n  *end_ptr = ptr;\n  return *result;\n}",
            "called": [
                "_strtol_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f80",
            "calling": [],
            "imported": false,
            "current_name": "parse_number_00004f80"
        },
        "FUN_00005fec": {
            "renaming": {
                "FUN_00005fec": "acquire_recursive_lock_00005fec",
                "PTR___lock___env_recursive_mutex_00005ff4": "PTR_recursive_lock_mutex"
            },
            "code": "void acquire_recursive_lock_00005fec(void)\n{\n  __retarget_lock_acquire_recursive(PTR___lock___env_recursive_mutex_00005ff4);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fec",
            "calling": [
                "_findenv_r"
            ],
            "imported": false,
            "current_name": "acquire_recursive_lock_00005fec"
        },
        "FUN_00004f84": {
            "renaming": {
                "FUN_00004f84": "convertStringToLong_00004f84",
                "__nptr": "inputString",
                "__endptr": "endPtr",
                "__base": "base",
                "lVar1": "result"
            },
            "code": "long convertStringToLong_00004f84(char* inputString, char** endPtr, int base) {\n  long result = strtol(*(undefined4 *)PTR__impure_ptr_00004f94, inputString, endPtr, base);\n  return result;\n}",
            "called": [
                "_strtol_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f84",
            "calling": [
                "_parse_time",
                "atoi"
            ],
            "imported": false,
            "current_name": "convertStringToLong_00004f84"
        },
        "FUN_000028f0": {
            "renaming": {
                "FUN_000028f0": "get_RTC_Type_value_000028f0",
                "rtt": "rtc_type_pointer",
                "DAT_0000290c": "PTR_DAT_0000290c"
            },
            "code": "uint32_t get_RTC_Type_value_000028f0(void)\n{\n  RTC_Type *rtc_type_pointer = (RTC_Type *) DAT_0000290c;\n  uint32_t value = *(uint32_t *)(rtc_type_pointer + 8) + 1;\n  return value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000028f0",
            "calling": [
                "rtc_get_alarm"
            ],
            "imported": false,
            "current_name": "get_RTC_Type_value_000028f0"
        },
        "FUN_00004f98": {
            "renaming": {
                "FUN_00004f98": "calculate_day_of_week_00004f98",
                "param_1": "year",
                "puVar1": "tzinfo",
                "uVar2": "return_value",
                "uVar3": "month_day",
                "iVar4": "is_february",
                "puVar5": "month_data",
                "iVar6": "days_since_1900",
                "uVar7": "leading_zeroes",
                "iVar8": "month_index",
                "iVar9": "day_of_week"
            },
            "code": "uint32_t calculate_day_of_week_00004f98(uint32_t year)\n{\n  uint32_t *tzinfo = (uint32_t *)__gettzinfo();\n  if ((int32_t)year < 0x7b2) {\n    return 0;\n  }\n  else {\n    uint32_t leading_zeroes = count_leading_zeroes(year % 400);\n    uint32_t days_since_1900 = (year - 0x7b2) * 0x16d + ((int32_t)(year - 0x7b1) >> 2) + (year - 0x76d) / 0xffffff9c + (year - 0x641) / 400;\n    tzinfo[1] = year;\n    uint32_t *month_data = tzinfo;\n    do {\n      uint32_t month_day = month_data[5];\n      if (*(char *)(month_data + 2) == 'J') {\n        if ((((year & 3) == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n          if (month_day < 0x3c) {\n            days_since_1900--;\n          }\n        }\n        days_since_1900 += month_day - 1;\n      }\n      else if (*(char *)(month_data + 2) == 'D') {\n        days_since_1900 += month_day;\n      }\n      else {\n        uint32_t is_leap_year = leading_zeroes >> 5;\n        if (((year & 3) == 0) && (year % 100 != 0)) {\n          is_leap_year = 1;\n        }\n        uint32_t month_index = 0;\n        while (month_index < month_data[3]) {\n          days_since_1900 += *(int32_t *)(PTR___month_lengths_000050e4 + month_index * 4 + is_leap_year * 0x30 + -4);\n          month_index++;\n        }\n        uint32_t day_of_week = (month_data[4] - 1) * 7 + month_day - (days_since_1900 + 4U) % 7;\n        if (day_of_week >= *(int32_t *)(PTR___month_lengths_000050e4 + month_index * 4 + is_leap_year * 0x30 + -4)) {\n          day_of_week -= 7;\n        }\n        days_since_1900 += day_of_week;\n      }\n      month_day = month_data[10] + DAT_000050e0 * days_since_1900 + month_data[6];\n      month_data[8] = month_day;\n      month_data[9] = (int32_t)month_day >> 0x1f;\n      month_data += 10;\n    } while (tzinfo + 0x14 != month_data);\n    uint32_t is_dst = tzinfo[9];\n    uint32_t dst_start = tzinfo[0x13];\n    *tzinfo = (uint32_t)((int32_t)((is_dst - dst_start) - (uint32_t)(tzinfo[8] < tzinfo[0x12])) < 0 != (SBORROW4(is_dst,dst_start) != SBORROW4(is_dst - dst_start,(uint32_t)(tzinfo[8] < tzinfo[0x12]))));\n    return 1;\n  }\n}",
            "called": [
                "__gettzinfo"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f98",
            "calling": [
                "_tzset_unlocked_r",
                "mktime"
            ],
            "imported": false,
            "current_name": "calculate_day_of_week_00004f98"
        },
        "FUN_00004dee": {
            "renaming": {
                "FUN_00004dee": "write_data_to_file_00004dee",
                "param_1": "reent",
                "param_2": "file_descriptor",
                "param_3": "data_buffer",
                "param_4": "data_size",
                "flag": "file_flag",
                "*(ushort *)(param_2 + 0xc)": "flag",
                "_lseek_r": "_reent_seek",
                "*(short *)(param_2 + 0xe)": "file_offset",
                "_write_r": "_reent_write"
            },
            "code": "void write_data_to_file_00004dee(_reent *reent, int file_descriptor, void *data_buffer, size_t data_size) {\n  uint16_t flag = *(uint16_t *)(file_descriptor + 0xc);\n  if ((int)(flag << 0x17) < 0) {\n    _lseek_r(reent, *(int16_t *)(file_descriptor + 0xe), 0, 2);\n  }\n  *(uint16_t *)(file_descriptor + 0xc) = flag & 0xefff;\n  _write_r(reent, *(int16_t *)(file_descriptor + 0xe), data_buffer, data_size);\n  return;\n}",
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dee",
            "calling": [],
            "imported": false,
            "current_name": "write_data_to_file_00004dee"
        },
        "FUN_00000fec": {
            "renaming": {
                "FUN_00000fec": "initialize_circular_buffer_00000fec",
                "cib_t": "circular_buffer_t",
                "cib": "circular_buffer",
                "size": "size",
                "PTR_assert_crash_message_00001030": "PTR_assert_crash_message_00001030"
            },
            "code": "void initialize_circular_buffer_00000fec(circular_buffer_t *circular_buffer, uint32_t size)\n{\n\tif ((size & (size - 1)) != 0) {\n\t\tcore_panic(PANIC_ASSERT_FAIL, PTR_assert_crash_message_00001030);\n\t}\n\tcircular_buffer->read_count = 0;\n\tcircular_buffer->write_count = 0;\n\tcircular_buffer->mask = size - 1;\n\treturn;\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000fec",
            "calling": [
                "thread_create"
            ],
            "imported": false,
            "current_name": "initialize_circular_buffer_00000fec"
        },
        "FUN_00000428": {
            "renaming": {
                "FUN_00000428": "allocate_memory_00000428",
                "r": "reent",
                "incr": "increment",
                "state_00": "interrupt_state_1",
                "state": "interrupt_state_2",
                "res": "result"
            },
            "code": "void * allocate_memory_00000428(_reent *reent, ptrdiff_t increment)\n{\n  uint interrupt_state_1;\n  uint interrupt_state_2;\n  void *result;\n  \n  interrupt_state_1 = disable_interrupts();\n  result = *(void **)PTR_heap_top_00000484;\n  if ((PTR__eram_00000488 < (undefined *)(increment + *(int *)PTR_heap_top_00000484)) ||\n     ((undefined *)(increment + *(int *)PTR_heap_top_00000484) < PTR__sheap_0000048c)) {\n    reent->_errno = 0xc;\n    result = (void *)0xffffffff;\n  }\n  else {\n    *(ptrdiff_t *)PTR_heap_top_00000484 = increment + *(int *)PTR_heap_top_00000484;\n  }\n  restore_interrupts(interrupt_state_1);\n  return result;\n}",
            "called": [
                "irq_disable",
                "irq_restore"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000428",
            "calling": [
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_00000428"
        },
        "FUN_000039e8": {
            "renaming": {
                "FUN_000039e8": "getClassString_000039e8",
                "class_id": "class_id",
                "pcVar1": "class_string"
            },
            "code": "char * getClassString_000039e8(uint8_t class_id) {\n  char *class_string = PTR_s_CLASS_UNKNOWN_00003d20;\n  switch(class_id) {\n    case '\\0':\n      class_string = PTR_s_CLASS_UNDEF_00003cc0;\n      break;\n    case '@':\n      class_string = PTR_s_ACT_ANY_00003cc4;\n      break;\n    case 'B':\n      class_string = PTR_s_ACT_LED_RGB_00003cc8;\n      break;\n    case 'C':\n      class_string = PTR_s_ACT_SERVO_00003ccc;\n      break;\n    case 'D':\n      class_string = PTR_s_ACT_MOTOR_00003cd0;\n      break;\n    case 'E':\n      class_string = PTR_s_ACT_SWITCH_00003cd4;\n      break;\n    case 'F':\n      class_string = PTR_s_ACT_DIMMER_00003cd8;\n      break;\n    case 0x80:\n      class_string = PTR_s_SENSE_ANY_00003cdc;\n      break;\n    case 0x81:\n      class_string = PTR_s_SENSE_BTN_00003ce0;\n      break;\n    case 0x82:\n      class_string = PTR_s_SENSE_TEMP_00003ce4;\n      break;\n    case 0x83:\n      class_string = PTR_s_SENSE_HUM_00003ce8;\n      break;\n    case 0x84:\n      class_string = PTR_s_SENSE_LIGHT_00003cec;\n      break;\n    case 0x85:\n      class_string = PTR_s_SENSE_ACCEL_00003cf0;\n      break;\n    case 0x86:\n      class_string = PTR_s_SENSE_MAG_00003cf4;\n      break;\n    case 0x87:\n      class_string = PTR_s_SENSE_GYRO_00003cf8;\n      break;\n    case 0x88:\n      class_string = PTR_s_SENSE_COLOR_00003cfc;\n      break;\n    case 0x89:\n      class_string = PTR_s_SENSE_PRESS_00003d00;\n      break;\n    case 0x8a:\n      class_string = PTR_s_SENSE_ANALOG_00003d04;\n      break;\n    case 0x8b:\n      class_string = PTR_s_SENSE_UV_00003d08;\n      break;\n    case 0x8c:\n      class_string = PTR_s_SENSE_OBJTEMP_00003d0c;\n      break;\n    case 0x8d:\n      class_string = PTR_s_SENSE_PULSE_COUNT_00003d10;\n      break;\n    case 0x8e:\n      class_string = PTR_s_SENSE_DISTANCE_00003d14;\n      break;\n    case 0x8f:\n      class_string = PTR_s_SENSE_CO2_00003d18;\n      break;\n    case 0xff:\n      class_string = PTR_s_CLASS_ANY_00003d1c;\n      break;\n  }\n  return class_string;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000039e8",
            "calling": [
                "list",
                "probe"
            ],
            "imported": false,
            "current_name": "getClassString_000039e8"
        },
        "FUN_00000e38": {
            "renaming": {
                "FUN_00000e38": "write_to_uart_00000e38",
                "buffer": "buffer",
                "len": "buffer_length"
            },
            "code": "int write_to_uart_00000e38(char *buffer, int buffer_length)\n{\n  uart_write(0, (uint8_t *)buffer, buffer_length);\n  return buffer_length;\n}",
            "called": [
                "uart_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e38",
            "calling": [
                "_write_r"
            ],
            "imported": false,
            "current_name": "write_to_uart_00000e38"
        },
        "FUN_00002294": {
            "renaming": {
                "FUN_00002294": "isRingBufferFull_00002294",
                "rb": "ringBuffer",
                "uVar2": "bufferSize",
                "bVar3": "isFull",
                "bVar1": "result"
            },
            "code": "bool isRingBufferFull_00002294(tsrb_t *ringBuffer)\n{\n  uint32_t bufferSize = ringBuffer->size;\n  bool isFull = (ringBuffer->writes - ringBuffer->reads == bufferSize);\n  uint8_t result = (isFull) ? 1 : 0;\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002294",
            "calling": [
                "tsrb_add_one"
            ],
            "imported": false,
            "current_name": "isRingBufferFull_00002294"
        },
        "FUN_00003e9e": {
            "renaming": {
                "FUN_00003e9e": "format_s32_decimal_fixed_point_00003e9e",
                "out": "output_string",
                "val": "input_value",
                "fp_digits": "fractional_digits",
                "sVar1": "formatted_length"
            },
            "code": "size_t format_s32_decimal_fixed_point_00003e9e(char *output_string, int16_t input_value, int fractional_digits)\n{\n  size_t formatted_length;\n  formatted_length = format_s32_decimal_fixed_point_00003e9e(output_string, (int)input_value, fractional_digits);\n  return formatted_length;\n}",
            "called": [
                "fmt_s32_dfp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e9e",
            "calling": [
                "phydat_dump"
            ],
            "imported": false,
            "current_name": "format_s32_decimal_fixed_point_00003e9e"
        },
        "FUN_00003378": {
            "renaming": {
                "FUN_00003378": "print_time_00003378",
                "time": "time",
                "PTR_s__04i__02i__02i__02i__02i__02i_000033bc": "iprintf",
                "tm_year": "year",
                "tm_mon": "month",
                "tm_mday": "day",
                "tm_hour": "hour",
                "tm_min": "minute",
                "tm_sec": "second"
            },
            "code": "int print_time_00003378(tm *time)\n{\n  int year = time->tm_year + 0x76c;\n  int month = time->tm_mon + 1;\n  int day = time->tm_mday;\n  int hour = time->tm_hour;\n  int minute = time->tm_min;\n  int second = time->tm_sec;\n  PTR_s__04i__02i__02i__02i__02i__02i_000033bc(\"%04d-%02d-%02d %02d:%02d:%02d\", year, month, day, hour, minute, second);\n  return 0;\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003378",
            "calling": [
                "_rtc_gettime",
                "_rtc_getalarm"
            ],
            "imported": false,
            "current_name": "print_time_00003378"
        },
        "FUN_00006768": {
            "renaming": {
                "FUN_00006768": "process_input_output_buffers_00006768",
                "param_1": "input_buffer",
                "param_2": "output_buffer",
                "param_3": "input_buffer_size",
                "param_4": "output_buffer_size",
                "uVar1": "buffer_flags",
                "iVar2": "status_register",
                "uVar3": "return_value",
                "uVar4": "buffer_flags",
                "uVar5": "buffer_size",
                "__sinit": "initialize_input_buffer",
                "_free_r": "free_resources",
                "_fflush_r": "flush_output_buffer",
                "__smakebuf_r": "create_output_buffer",
                "_fwalk": "walk_files",
                "*PTR__global_impure_ptr_00006874": "global_impure_ptr",
                "DAT_00006878": "file_descriptor"
            },
            "code": "int process_input_output_buffers_00006768(int* input_buffer, int* output_buffer, int input_buffer_size, int output_buffer_size)\n{\n  int status_register;\n  int return_value;\n  int input_buffer_flags;\n  int output_buffer_flags;\n  \n  if ((input_buffer != NULL) && (input_buffer[6] == 0)) {\n    initialize_input_buffer();\n  }\n  if (output_buffer == PTR___sf_fake_stdin_00006868) {\n    output_buffer = input_buffer[1];\n  }\n  else if (output_buffer == PTR___sf_fake_stdout_0000686c) {\n    output_buffer = input_buffer[2];\n  }\n  else if (output_buffer == PTR___sf_fake_stderr_00006870) {\n    output_buffer = input_buffer[3];\n  }\n  \n  output_buffer_flags = *(unsigned short*)(output_buffer + 3);\n  output_buffer[1] = 0;\n  output_buffer_size = (unsigned int)*(unsigned short*)(output_buffer + 3);\n  \n  if ((int)(output_buffer_size << 0x1a) < 0) {\n    return -1;\n  }\n  if ((int)(output_buffer_size << 0x1d) < 0) {\n    if ((int*)(output_buffer[13]) != NULL) {\n      if ((int*)(output_buffer[13]) != output_buffer + 17) {\n        free_resources(input_buffer);\n      }\n      output_buffer[1] = output_buffer[16];\n      output_buffer[13] = 0;\n      if (output_buffer[16] != 0) {\n        *output_buffer = output_buffer[15];\n        return 0;\n      }\n    }\n  }\n  else {\n    if (-1 < (int)(output_buffer_size << 0x1b)) {\n      *input_buffer = 9;\n      output_buffer_flags |= 0x40;\n      goto LAB_000067b8;\n    }\n    if ((int)(output_buffer_size << 0x1c) < 0) {\n      status_register = flush_output_buffer(input_buffer, output_buffer, output_buffer_size << 0x1c, output_buffer_size, output_buffer_flags);\n      if (status_register != 0) {\n        return -1;\n      }\n      output_buffer[2] = 0;\n      *(unsigned short*)(output_buffer + 3) &= 0xfff7;\n      output_buffer[6] = 0;\n    }\n    *(unsigned short*)(output_buffer + 3) |= 4;\n  }\n  if (output_buffer[4] == 0) {\n    create_output_buffer(input_buffer, output_buffer);\n  }\n  output_buffer_flags = *(unsigned short*)(output_buffer + 3);\n  status_register = *(unsigned short*)(output_buffer + 3);\n  if ((output_buffer_flags & 3) != 0) {\n    *(unsigned short*)(output_buffer + 3) = 1;\n    walk_files(*(int*)PTR__*PTR__global_impure_ptr_00006874_00006874,DAT_00006878);\n    *(unsigned short*)(output_buffer + 3) = status_register;\n    if ((output_buffer_flags & 9) == 9) {\n      flush_output_buffer(input_buffer, output_buffer);\n    }\n  }\n  return_value = output_buffer[4];\n  *output_buffer = return_value;\n  status_register = (*(function_ptr*)(output_buffer[9]))(input_buffer, output_buffer[8], return_value, output_buffer[5]);\n  output_buffer[1] = status_register;\n  if (0 < status_register) {\n    return 0;\n  }\n  output_buffer_flags = *(unsigned short*)(output_buffer + 3);\n  if (status_register != 0) {\n    output_buffer[1] = 0;\n    output_buffer_flags |= 0x40;\n  }\n  LAB_000067b8:\n  *(unsigned short*)(output_buffer + 3) = output_buffer_flags;\n  return -1;\n}",
            "called": [
                "__sflush_r",
                "_fwalk",
                "__smakebuf_r",
                "__sinit",
                "_fflush_r",
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006768",
            "calling": [
                "__srget_r"
            ],
            "imported": false,
            "current_name": "process_input_output_buffers_00006768"
        },
        "FUN_00000db0": {
            "renaming": {
                "FUN_00000db0": "disable_watchdog_and_fix_cpu_errata_00000db0",
                "wdog_disable": "disable_watchdog",
                "cpu_errata_fixes": "fix_cpu_errata"
            },
            "code": "void disable_watchdog_and_fix_cpu_errata_00000db0(void)\n{\n  disable_watchdog();\n  fix_cpu_errata();\n  return;\n}",
            "called": [
                "wdog_disable",
                "cpu_errata_fixes"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000db0",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "disable_watchdog_and_fix_cpu_errata_00000db0"
        },
        "FUN_00002600": {
            "renaming": {
                "FUN_00002600": "set_rtt_counter_from_time_00002600",
                "time": "time_struct",
                "counter": "counter_from_time",
                "t": "time_in_seconds"
            },
            "code": "int set_rtt_counter_from_time_00002600(tm *time_struct)\n{\n  uint32_t counter_from_time;\n  time_t time_in_seconds;\n  \n  time_in_seconds = mktime((tm *)time_struct);\n  rtt_set_counter(counter_from_time);\n  return 0;\n}",
            "called": [
                "mktime",
                "rtt_set_counter"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002600",
            "calling": [
                "_rtc_settime"
            ],
            "imported": false,
            "current_name": "set_rtt_counter_from_time_00002600"
        },
        "FUN_00003810": {
            "renaming": {
                "FUN_00003810": "get_unit_name_00003810",
                "unit": "unit",
                "pcVar1": "unit_name"
            },
            "code": "char* get_unit_name_00003810(uint8_t unit) {\n  char* unit_name = PTR_DAT_00003914;\n  switch(unit) {\n    case '\\x02':\n      unit_name = PTR_DAT_000038cc;\n      break;\n    case '\\x03':\n      unit_name = PTR_DAT_000038d0;\n      break;\n    case '\\x04':\n      unit_name = PTR_DAT_000038d4;\n      break;\n    case '\\x05':\n      unit_name = PTR_PTR_s_R_000038d8;\n      break;\n    case '\\x06':\n      unit_name = PTR_DAT_000038dc;\n      break;\n    case '\\a':\n      unit_name = PTR_DAT_000038e0;\n      break;\n    case '\\b':\n      unit_name = PTR_DAT_000038e4;\n      break;\n    case '\\t':\n      unit_name = PTR_DAT_000038e8;\n      break;\n    case '\\n':\n      unit_name = PTR_DAT_000038ec;\n      break;\n    case '\\v':\n      unit_name = PTR_DAT_000038f0;\n      break;\n    case '\\f':\n      unit_name = PTR_DAT_000038f4;\n      break;\n    case '\\r':\n      unit_name = PTR_DAT_000038f8;\n      break;\n    case '\\x0e':\n      unit_name = PTR_DAT_000038fc;\n      break;\n    case '\\x0f':\n      unit_name = PTR_DAT_00003900;\n      break;\n    case '\\x10':\n      unit_name = PTR_DAT_00003904;\n      break;\n    case '\\x11':\n      unit_name = PTR_DAT_0000390c;\n      break;\n    case '\\x13':\n      unit_name = PTR_DAT_00003910;\n      break;\n    case '\\x15':\n      unit_name = PTR_DAT_00003908;\n  }\n  return unit_name;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003810",
            "calling": [
                "phydat_dump"
            ],
            "imported": false,
            "current_name": "get_unit_name_00003810"
        },
        "FUN_0000041c": {
            "renaming": {
                "FUN_0000041c": "do_nothing_0000041c"
            },
            "code": "\nvoid do_nothing_0000041c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000041c",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0000041c"
        },
        "FUN_00000ed8": {
            "renaming": {
                "FUN_00000ed8": "print_LR_value_00000ed8",
                "in_lr": "link_register_ptr"
            },
            "code": "void print_LR_value_00000ed8(void)\n{\n  uint32_t *link_register_ptr;\n  link_register_ptr = (uint32_t *)__builtin_return_address(0);\n  iprintf(\"Link Register Value: %p\\n\", *link_register_ptr);\n  return;\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ed8",
            "calling": [
                "core_panic"
            ],
            "imported": false,
            "current_name": "print_LR_value_00000ed8"
        },
        "FUN_000031e0": {
            "renaming": {
                "FUN_000031e0": "print_alarm_message_000031e0",
                "arg": "message",
                "PTR_s_The_alarm_rang_000031f8": "message"
            },
            "code": "void print_alarm_message_000031e0(void *PTR_s_The_alarm_rang_000031f8) {\n  puts(PTR_s_The_alarm_rang_000031f8);\n  return;\n}",
            "called": [
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031e0",
            "calling": [],
            "imported": false,
            "current_name": "print_alarm_message_000031e0"
        },
        "FUN_000004d4": {
            "renaming": {
                "FUN_000004d4": "set_errno_to_permission_denied_000004d4",
                "r": "reent",
                "fd": "file_descriptor",
                "_errno": "EACCES"
            },
            "code": "int set_errno_to_permission_denied_000004d4(_reent *reent, int file_descriptor) {\n  reent->_errno = EACCES;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004d4",
            "calling": [
                "__sclose"
            ],
            "imported": false,
            "current_name": "set_errno_to_permission_denied_000004d4"
        },
        "FUN_000020f4": {
            "renaming": {
                "FUN_000020f4": "handle_interrupt_000020f4",
                "DAT_00002104": "interrupt_data"
            },
            "code": "void handle_interrupt_000020f4(void)\n{\n  irq_handler(DAT_00002104, 3);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020f4",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_000020f4"
        },
        "FUN_0000687c": {
            "renaming": {
                "FUN_0000687c": "reverse_and_improve_0000687c",
                "param_1": "length",
                "param_2": "input",
                "pbVar1": "output",
                "uVar2": "range_end",
                "iVar3": "output_size",
                "uVar4": "current_char",
                "uVar5": "next_char",
                "uVar6": "range_end",
                "bVar7": "is_caret"
            },
            "code": "byte* reverse_and_improve_0000687c(int length, byte* input) {\n  byte* output = NULL;\n  uint current_char = (uint)*input;\n  bool is_caret = current_char == 0x5e;\n  if (is_caret) {\n    current_char = (uint)input[1];\n    input += 2;\n  }\n  else {\n    input++;\n  }\n  int output_size = length + 0xff;\n  output = (byte*)malloc(output_size);\n  for (int i = length; i < output_size; i++) {\n    *(bool *)i = is_caret;\n  }\n  if (current_char == 0) {\n    output = input - 1;\n  }\n  else {\n    while (true) {\n      uint next_char = current_char;\n      *(bool *)(length + next_char) = !is_caret;\n      input++;\n      while (true) {\n        current_char = (uint)input[-1];\n        if (current_char != 0x2d) break;\n        uint range_end = (uint)*input;\n        if ((range_end == 0x5d) || (next_char > range_end)) goto end_loop;\n        for (uint i = next_char + 1; i < range_end; i++) {\n          *(bool *)(length + i) = !is_caret;\n        }\n        int range_size = range_end - next_char - 1;\n        next_char += range_size + 1;\n        input += 2;\n      }\n      output = input - 1;\n      if ((current_char == 0x5d) || (current_char == 0)) break;\n    }\n  }\nend_loop:\n  return output;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000687c",
            "calling": [
                "_scanf_i",
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "reverse_and_improve_0000687c"
        },
        "FUN_00004dea": {
            "renaming": {
                "FUN_00004dea": "returnZero_00004dea"
            },
            "code": "int32_t returnZero_00004dea(void) {\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dea",
            "calling": [],
            "imported": false,
            "current_name": "returnZero_00004dea"
        },
        "FUN_00005edc": {
            "renaming": {
                "_strtoul_l_isra_0": "parse_unsigned_integer",
                "param_1": "output",
                "param_2": "input",
                "param_3": "end_ptr",
                "param_4": "base",
                "uVar1": "digit_value",
                "uVar2": "max_value",
                "bVar3": "is_negative",
                "iVar4": "result",
                "uVar5": "is_hex",
                "uVar6": "max_value",
                "pbVar7": "current_char",
                "pbVar8": "current_char",
                "PTR_DAT_00005fd0": "character_properties",
                "FUN_00005edc": "parse_unsigned_integer_00005edc"
            },
            "code": "uint parse_unsigned_integer_00005edc(undefined4 *output, byte *input, byte **end_ptr, uint base) {\n  uint digit_value;\n  uint max_value;\n  byte *current_char;\n  uint result;\n  bool is_negative;\n\n  current_char = input;\n  while ((PTR_DAT_00005fd0[(uint)*current_char] & 8) != 0) {\n    current_char++;\n  }\n\n  if (*current_char == '-') {\n    is_negative = true;\n    current_char++;\n  }\n  else {\n    is_negative = false;\n    if (*current_char == '+') {\n      current_char++;\n    }\n  }\n\n  if (base == 0) {\n    if (*current_char != '0') {\n      base = 10;\n    }\n    else if ((current_char[1] & 0xdf) == 'X') {\n      base = 16;\n      current_char += 2;\n    }\n    else {\n      base = 8;\n    }\n  }\n  else if (base == 16 && *current_char == '0' && (current_char[1] & 0xdf) == 'X') {\n    current_char += 2;\n  }\n\n  digit_value = *current_char - '0';\n  if (digit_value > 9) {\n    digit_value = (PTR_DAT_00005fd0[digit_value] & 0x10) != 0 ? digit_value - 55 : digit_value - 87;\n  }\n\n  max_value = 0xffffffff / base;\n  result = digit_value;\n  current_char++;\n\n  while ((PTR_DAT_00005fd0[(uint)*current_char] & 8) != 0) {\n    digit_value = *current_char - '0';\n    if (digit_value > 9) {\n      digit_value = (PTR_DAT_00005fd0[digit_value] & 0x10) != 0 ? digit_value - 55 : digit_value - 87;\n    }\n\n    if (digit_value >= base || result > max_value) {\n      *output = 0x22;\n      result = 0xffffffff;\n      if (end_ptr == NULL) {\n        return 0xffffffff;\n      }\n      else {\n        *end_ptr = current_char - 1;\n        return result;\n      }\n    }\n    result = result * base + digit_value;\n    current_char++;\n  }\n\n  if (is_negative) {\n    result = -result;\n  }\n\n  if (end_ptr == NULL) {\n    return result;\n  }\n  else {\n    if (current_char == input) {\n      *end_ptr = current_char;\n    }\n    else {\n      *end_ptr = current_char - 1;\n    }\n    return result;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005edc",
            "calling": [
                "_strtoul_r",
                "strtoul"
            ],
            "imported": false,
            "current_name": "parse_unsigned_integer_00005edc"
        },
        "FUN_00001eea": {
            "renaming": {
                "FUN_00001eea": "configure_gpio_pin_00001eea",
                "pin": "gpio_pin",
                "mode": "gpio_mode",
                "uVar1": "pin_number",
                "pGVar2": "gpio_ptr",
                "pPVar3": "port_ptr",
                "iVar4": "result",
                "FUN_00001eea_port": "configure_gpio_pin_port",
                "GPIO_Type": "GPIO_Type",
                "PORT_Type": "PORT_Type",
                "GPIO_IN": "GPIO_IN",
                "pin_num": "get_pin_number",
                "gpio": "get_gpio_pointer",
                "PDDR": "PDDR",
                "port": "get_port_pointer",
                "PCR": "PCR",
                "byte": "byte"
            },
            "code": "int configure_gpio_pin_00001eea(gpio_t pin, gpio_mode_t mode) {\n  uint32_t pin_number;\n  GPIO_Type *gpio_ptr;\n  PORT_Type *port_ptr;\n  int result = 0;\n  configure_gpio_pin_00001eea_port(pin, 0);\n  if (mode < GPIO_IN) {\n    pin_number = get_pin_number(pin);\n    gpio_ptr = get_gpio_pointer(pin);\n    gpio_ptr->PDDR |= 1 << (pin_number & 0xff);\n  }\n  else {\n    pin_number = get_pin_number(pin);\n    gpio_ptr = get_gpio_pointer(pin);\n    gpio_ptr->PDDR &= ~(1 << (pin_number & 0xff));\n  }\n  port_ptr = get_port_pointer(pin);\n  int pin_index = get_pin_number(pin);\n  port_ptr->PCR[pin_index] = (byte)mode & 0x23 | 0x100;\n  return result;\n}",
            "called": [
                "gpio_init_port",
                "pin_num",
                "gpio",
                "port"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001eea",
            "calling": [
                "board_init"
            ],
            "imported": false,
            "current_name": "configure_gpio_pin_00001eea"
        },
        "FUN_000023a4": {
            "renaming": {
                "FUN_000023a4": "run_shell_command_000023a4",
                "line_buf": "command_line",
                "PTR_s_Welcome_to_RIOT__000023c4": "welcome_message",
                "shell_command_t": "shell_command",
                "startForkserver": "start_fork_server"
            },
            "code": "void run_shell_command_000023a4(void)\n{\n  char command_line[128];\n  start_fork_server(0);\n  puts(PTR_s_Welcome_to_RIOT__000023c4);\n  shell_run((shell_command_t *)0x0, command_line, 0x80);\n}",
            "called": [
                "puts",
                "startForkserver",
                "shell_run"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023a4",
            "calling": [
                "main_trampoline"
            ],
            "imported": false,
            "current_name": "run_shell_command_000023a4"
        },
        "FUN_0000240c": {
            "renaming": {
                "FUN_0000240c": "remove_second_node_0000240c",
                "list": "list_head",
                "plVar1": "second_node"
            },
            "code": "list_node_t* remove_second_node_0000240c(list_node_t* list) {\n  list_node_t* second_node = list->next;\n  if (second_node != nullptr) {\n    list->next = second_node->next;\n  }\n  return second_node;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000240c",
            "calling": [
                "mutex_unlock"
            ],
            "imported": false,
            "current_name": "remove_second_node_0000240c"
        },
        "FUN_00004280": {
            "renaming": {
                "FUN_00004280": "release_lock_recursive_mutex_00004280",
                "PTR___lock___sfp_recursive_mutex_00004288": "sfp_recursive_mutex"
            },
            "code": "void release_lock_recursive_mutex_00004280(void)\n{\n  __retarget_lock_release_recursive(PTR___lock___sfp_recursive_mutex_00004288);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004280",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "release_lock_recursive_mutex_00004280"
        },
        "FUN_00001448": {
            "renaming": {
                "FUN_00001448": "init_uart_gpio_00001448",
                "uart": "uart",
                "PTR_uart_config_000014c0": "PTR_uart_config_000014c0",
                "gpio_init_port": "gpio_init_port",
                "gpio_t": "gpio_t",
                "uint32_t": "uint32_t",
                "config_value_1": "config_value_1",
                "config_value_2": "config_value_2",
                "gpio_port_1": "gpio_port_1",
                "gpio_pin_1": "gpio_pin_1",
                "gpio_port_2": "gpio_port_2",
                "gpio_pin_2": "gpio_pin_2"
            },
            "code": "void init_uart_gpio_00001448(uart_t uart)\n{\n  short config_value_1 = *(short *)(PTR_uart_config_000014c0 + uart * 0x20 + 8);\n  short config_value_2 = *(short *)(PTR_uart_config_000014c0 + uart * 0x20 + 10);\n  if (config_value_1 != -1) {\n    gpio_t gpio_port_1 = *(gpio_t *)(PTR_uart_config_000014c0 + uart * 0x20 + 8);\n    uint32_t gpio_pin_1 = *(uint32_t *)(PTR_uart_config_000014c0 + uart * 0x20 + 0xc);\n    gpio_init_port(gpio_port_1, gpio_pin_1);\n  }\n  if (config_value_2 != -1) {\n    gpio_t gpio_port_2 = *(gpio_t *)(PTR_uart_config_000014c0 + uart * 0x20 + 10);\n    uint32_t gpio_pin_2 = *(uint32_t *)(PTR_uart_config_000014c0 + uart * 0x20 + 0x10);\n    gpio_init_port(gpio_port_2, gpio_pin_2);\n  }\n  return;\n}",
            "called": [
                "gpio_init_port"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001448",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "init_uart_gpio_00001448"
        },
        "FUN_00001688": {
            "renaming": {
                "FUN_00001688": "handle_uart_interrupt_00001688"
            },
            "code": "void handle_uart_interrupt_00001688(void)\n{\n  irq_handler_uart(0);\n  return;\n}",
            "called": [
                "irq_handler_uart"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001688",
            "calling": [],
            "imported": false,
            "current_name": "handle_uart_interrupt_00001688"
        },
        "FUN_00004042": {
            "renaming": {
                "FUN_00004042": "convert_string_to_long_00004042",
                "__nptr": "input_string",
                "lVar1": "result"
            },
            "code": "long convert_string_to_long_00004042(char* input_string)\n{\n  long result = strtol(input_string, (char**)0x0, 10);\n  return result;\n}",
            "called": [
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004042",
            "calling": [
                "read",
                "write"
            ],
            "imported": false,
            "current_name": "convert_string_to_long_00004042"
        },
        "FUN_00000cf0": {
            "renaming": {
                "FUN_00000cf0": "getIRQinterruptsEnabledStatus_00000cf0",
                "uVar2": "interruptsEnabledStatus",
                "bVar1": "isPrivilegedMode",
                "isCurrentModePrivileged": "isCurrentModeInPrivilegedMode",
                "isIRQinterruptsEnabled": "getIRQinterruptsEnabled"
            },
            "code": "uint32_t getIRQinterruptsEnabledStatus_00000cf0(void)\n{\n  bool isPrivilegedMode;\n  uint32_t interruptsEnabledStatus;\n  enableIRQinterrupts();\n  interruptsEnabledStatus = 0;\n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    interruptsEnabledStatus = isIRQinterruptsEnabled();\n  }\n  return interruptsEnabledStatus;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cf0",
            "calling": [
                "cpu_switch_context_exit"
            ],
            "imported": false,
            "current_name": "getIRQinterruptsEnabledStatus_00000cf0"
        },
        "FUN_00006cd4": {
            "renaming": {
                "FUN_00006cd4": "do_nothing_00006cd4"
            },
            "code": "\nvoid do_nothing_00006cd4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006cd4",
            "calling": [
                "__aeabi_ldivmod"
            ],
            "imported": false,
            "current_name": "do_nothing_00006cd4"
        },
        "FUN_00000f8c": {
            "renaming": {
                "FUN_00000f8c": "create_idle_and_main_threads_00000f8c",
                "PTR_idle_stack_00000fdc": "idle_stack",
                "PTR_main_stack_00000fe8": "main_stack",
                "PTR_idle_name_00000fd4": "idle_name",
                "PTR_main_name_00000fe0": "main_name",
                "DAT_00000fd8": "idle_thread",
                "DAT_00000fe4": "main_thread"
            },
            "code": "void create_idle_and_main_threads_00000f8c(void)\n{\n  irq_disable();\n  thread_create(PTR_idle_stack_00000fdc, 256, THREAD_PRIORITY_LOW, THREAD_CREATE_WOUT_YIELD, DAT_00000fd8, NULL, PTR_idle_name_00000fd4);\n  thread_create(PTR_main_stack_00000fe8, 1536, THREAD_PRIORITY_NORMAL, THREAD_CREATE_WOUT_YIELD, DAT_00000fe4, NULL, PTR_main_name_00000fe0);\n  cpu_switch_context_exit();\n}\n",
            "called": [
                "cpu_switch_context_exit",
                "irq_disable",
                "thread_create"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f8c",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "create_idle_and_main_threads_00000f8c"
        },
        "FUN_00002894": {
            "renaming": {
                "FUN_00002894": "set_rtc_alarm_00002894",
                "alarm": "alarm_time",
                "cb": "callback",
                "arg": "callback_arg",
                "iVar1": "rtt_base_address",
                "RTC_Type": "RTC",
                "rtc_control_register": "rtc_control_register",
                "PTR_rtt_callback_000028ec": "PTR_rtt_callback_000028ec"
            },
            "code": "void set_rtc_alarm_00002894(uint32_t alarm_time, rtt_callback_t callback, void *callback_arg)\n{\n  int rtt_base_address = DAT_000028e8;\n  uint32_t rtc_control_register = *(uint *)(rtt_base_address + 0x1c);\n  rtc_control_register &= 0xfffffffb;\n  *(uint32_t *)(rtt_base_address + 8) = alarm_time - 1;\n  *(rtt_callback_t *)PTR_rtt_callback_000028ec = callback;\n  *(void **)(PTR_rtt_callback_000028ec + 4) = callback_arg;\n  rtc_control_register |= 4;\n  NVIC_SetPriority(RTC_IRQn,10);\n  NVIC_EnableIRQ(RTC_IRQn);\n  return;\n}",
            "called": [
                "NVIC_EnableIRQ",
                "NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002894",
            "calling": [
                "rtc_set_alarm"
            ],
            "imported": false,
            "current_name": "set_rtc_alarm_00002894"
        },
        "FUN_00004158": {
            "renaming": {
                "FUN_00004158": "flush_stream_00004158",
                "param_1": "stream_id",
                "param_2": "stream",
                "uVar1": "result"
            },
            "code": "int flush_stream_00004158(int stream_id, void *stream) {\n  int result;\n  if (*(int *)(stream + 0x10) != 0) {\n    if ((stream_id != 0) && (*(int *)(stream_id + 0x18) == 0)) {\n      __sinit();\n    }\n    if (stream == PTR___sf_fake_stdin_000041c4) {\n      stream = *(void **)(stream_id + 4);\n    }\n    else if (stream == PTR___sf_fake_stdout_000041c8) {\n      stream = *(void **)(stream_id + 8);\n    }\n    else if (stream == PTR___sf_fake_stderr_000041cc) {\n      stream = *(void **)(stream_id + 0xc);\n    }\n    if (*(short *)(stream + 0xc) != 0) {\n      if ((-1 < *(int *)(stream + 100) << 0x1f) && (-1 < (int)*(short *)(stream + 0xc) << 0x16)) {\n        __retarget_lock_acquire_recursive(*(int *)(stream + 0x58));\n      }\n      result = __sflush_r(stream_id, stream);\n      if (*(int *)(stream + 100) << 0x1f < 0) {\n        return result;\n      }\n      if ((int)((uint)*(ushort *)(stream + 0xc) << 0x16) < 0) {\n        return result;\n      }\n      __retarget_lock_release_recursive(*(int *)(stream + 0x58));\n      return result;\n    }\n  }\n  return 0;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__sflush_r",
                "__sinit",
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004158",
            "calling": [
                "__srefill_r",
                "fflush",
                "__swbuf_r"
            ],
            "imported": false,
            "current_name": "flush_stream_00004158"
        },
        "FUN_00002654": {
            "renaming": {
                "FUN_00002654": "set_rtc_alarm_00002654",
                "time": "alarm_time",
                "cb": "callback",
                "arg": "arg"
            },
            "code": "int set_rtc_alarm_00002654(tm *time, rtc_alarm_cb_t callback, void *arg)\n{\n  uint32_t alarm_time = mktime((tm *)time);\n  *(rtc_alarm_cb_t *)PTR_rtc_callback_00002688 = callback;\n  rtt_set_alarm(alarm_time, DAT_0000268c, arg);\n  return 0;\n}",
            "called": [
                "rtt_set_alarm",
                "mktime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002654",
            "calling": [
                "_rtc_setalarm"
            ],
            "imported": false,
            "current_name": "set_rtc_alarm_00002654"
        },
        "FUN_00000aa8": {
            "renaming": {
                "FUN_00000aa8": "handle_hard_fault_exception_00000aa8",
                "sp": "stack_pointer",
                "corrupted": "is_corrupted",
                "exc_return": "exc_return",
                "r4_to_r11_stack": "r4_to_r11_stack",
                "uVar2": "bfar_value",
                "uVar3": "mmfar_value",
                "uVar4": "cfsr_value",
                "uVar5": "hfsr_value",
                "uVar6": "dfsr_value",
                "uVar7": "afsr_value",
                "uVar8": "sp_value",
                "uVar9": "sp_value_1",
                "uVar10": "sp_value_2",
                "uVar11": "sp_value_4",
                "uVar12": "sp_value_5",
                "stack_left": "stack_left",
                "psr": "psr",
                "lr": "lr",
                "r12": "r12",
                "r3": "r3",
                "r2": "r2",
                "r1": "r1",
                "r0": "r0",
                "afsr": "afsr",
                "dfsr": "dfsr",
                "hfsr": "hfsr",
                "cfsr": "cfsr",
                "mmfar": "mmfar",
                "bfar": "bfar_value",
                "orig_sp": "orig_sp",
                "pc": "pc"
            },
            "code": "void handle_hard_fault_exception_00000aa8(uint32_t *stack_pointer, uint32_t is_corrupted, uint32_t exc_return, uint32_t *r4_to_r11_stack){\n  int stack_left;\n  uint32_t psr;\n  uint32_t lr;\n  uint32_t r12;\n  uint32_t r3;\n  uint32_t r2;\n  uint32_t r1;\n  uint32_t r0;\n  uint32_t afsr;\n  uint32_t dfsr;\n  uint32_t hfsr;\n  uint32_t cfsr;\n  uint32_t mmfar;\n  uint32_t bfar;\n  uint32_t *orig_sp;\n  uint32_t pc;\n  \n  uint32_t cfsr_value = *(uint *)(DAT_00000c24 + 0x28);\n  uint32_t hfsr_value = *(uint *)(DAT_00000c24 + 0x2c);\n  uint32_t dfsr_value = *(uint *)(DAT_00000c24 + 0x30);\n  uint32_t afsr_value = *(uint *)(DAT_00000c24 + 0x3c);\n  uint32_t bfar_value = *(uint *)(DAT_00000c24 + 0x38);\n  uint32_t mmfar_value = *(uint *)(DAT_00000c24 + 0x34);\n\n  pc = 0;\n  if (*(int *)PTR_isr_stack_00000c28 != DAT_00000c2c) {\n    puts(PTR_s__ISR_stack_overflowed_00000c30);\n  }\n  if (is_corrupted == 0) {\n    uint32_t sp_value = *stack_pointer;\n    uint32_t sp_value_1 = stack_pointer[1];\n    uint32_t sp_value_2 = stack_pointer[2];\n    uint32_t sp_value_4 = stack_pointer[4];\n    uint32_t sp_value_5 = stack_pointer[5];\n    pc = stack_pointer[6];\n    puts(PTR_s__Context_before_hardfault__00000c38);\n    iprintf(PTR_s__r0__0x_08lx_r1__0x_08lx_r2__0x__00000c3c, sp_value, sp_value_1, sp_value_2);\n    iprintf(PTR_s__r12__0x_08lx_lr__0x_08lx_pc__0x_00000c40, sp_value_4, sp_value_5, pc);\n  }\n  else {\n    puts(PTR_s_Stack_pointer_corrupted__reset_t_00000c34);\n  }\n  puts(PTR_s_FSR_FAR__00000c44);\n  iprintf(PTR_s__CFSR__0x_08lx_00000c48, cfsr_value);\n  iprintf(PTR_s__HFSR__0x_08lx_00000c4c, hfsr_value);\n  iprintf(PTR_s__DFSR__0x_08lx_00000c50, dfsr_value);\n  iprintf(PTR_s__AFSR__0x_08lx_00000c54, afsr_value);\n  if ((cfsr_value & *(uint *)PTR_BFARVALID_MASK_00000c58) != 0) {\n    iprintf(PTR_s__BFAR__0x_08lx_00000c5c, bfar_value);\n  }\n  if ((cfsr_value & *(uint *)PTR_MMARVALID_MASK_00000c60) != 0) {\n    iprintf(PTR_s_MMFAR__0x_08lx_00000c64, mmfar_value);\n  }\n  puts(PTR_DAT_00000c68);\n  iprintf(PTR_s_EXC_RET__0x_08lx_00000c6c, exc_return);\n  if (is_corrupted == 0) {\n    puts(PTR_s_Attempting_to_reconstruct_state_f_00000c70);\n    iprintf(PTR_s_In_GDB__set__pc_0x_lx_frame_0_bt_00000c74, pc);\n    stack_left = _stack_size_left(0x158);\n    if (stack_left < 0) {\n      iprintf(PTR_s__ISR_stack_overflowed_by_at_leas_00000c78, -stack_left);\n    }\n  }\n  software_bkpt(1);\n  core_panic(PANIC_HARD_FAULT, PTR_s_HARD_FAULT_HANDLER_00000c7c);\n}",
            "called": [
                "core_panic",
                "iprintf",
                "puts",
                "_stack_size_left"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000aa8",
            "calling": [
                "hard_fault_default"
            ],
            "imported": false,
            "current_name": "handle_hard_fault_exception_00000aa8"
        },
        "FUN_00002538": {
            "renaming": {
                "FUN_00002538": "set_irq_priority_00002538",
                "IRQn": "irq",
                "priority": "priority",
                "PTR_DAT_00002584": "PTR_OFFSET_1",
                "PTR_DAT_00002588": "PTR_OFFSET_2"
            },
            "code": "void set_irq_priority_00002538(IRQn_Type irq, uint32_t priority)\n{\n  if (irq < DMA0_IRQn) {\n    uint32_t offset = ((uint32_t)irq & 0xF) + PTR_DAT_00002584 + 0x14;\n    *(char *)offset = (char)((priority & 0xFF) << 4);\n  }\n  else {\n    uint32_t offset = irq + PTR_DAT_00002588 + 0x300;\n    *(char *)offset = (char)((priority & 0xFF) << 4);\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002538",
            "calling": [
                "cortexm_init"
            ],
            "imported": false,
            "current_name": "set_irq_priority_00002538"
        },
        "FUN_00004c84": {
            "renaming": {
                "FUN_00004c84": "print_formatted_string_00004c84",
                "__format": "format",
                "iVar1": "impure_ptr",
                "pcVar2": "arg_pointer",
                "uStack_c": "arg1",
                "uStack_8": "arg2",
                "uStack_4": "arg3"
            },
            "code": "int print_formatted_string_00004c84(char *format, ...)\n{\n  int impure_ptr = *(int *)PTR__impure_ptr_00004cb0;\n  char *arg_pointer = format;\n  undefined4 arg1 = 0;\n  undefined4 arg2 = 0;\n  undefined4 arg3 = 0;\n  if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n    __sinit(impure_ptr);\n  }\n  int result = _vfprintf_r(impure_ptr, *(undefined4 *)(impure_ptr + 8), format, &arg1, arg_pointer, &arg1);\n  return result;\n}",
            "called": [
                "__sinit",
                "_vfprintf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004c84",
            "calling": [
                "core_panic",
                "_print_time",
                "cpu_print_last_instruction",
                "print_help",
                "_saul",
                "ps",
                "read",
                "handle_input_line",
                "list",
                "write",
                "_rtc_handler",
                "hard_fault_handler",
                "probe",
                "phydat_dump",
                "main_trampoline"
            ],
            "imported": false,
            "current_name": "print_formatted_string_00004c84"
        },
        "FUN_0000305c": {
            "renaming": {
                "FUN_0000305c": "write_data_to_device_0000305c",
                "argc": "arg_count",
                "argv": "arguments",
                "num": "device_num",
                "dev": "device",
                "dim": "data_dim",
                "data": "data",
                "i": "i",
                "iVar1": "temp_int",
                "saul_reg_FUN_0000305c": "saul_reg_write",
                "PTR_s_usage___s__s__device_id___value_0_00003154": "usage_string",
                "PTR_s_error__undefined_device_given_00003158": "undefined_device_error_string",
                "PTR_s_Writing_to_device___i____s_0000315c": "writing_to_device_string",
                "PTR_s_error__device___i_is_not_writabl_00003160": "device_not_writable_error_string",
                "PTR_s_error__failure_to_FUN_0000305c_to_devic_00003164": "write_failure_error_string",
                "PTR_s_data_successfully_written_to_dev_00003168": "data_written_successfully_string"
            },
            "code": "void write_data_to_device_0000305c(int arg_count, char** arguments) {\n  int device_num, i, temp_int;\n  phydat_t data;\n  int data_dim;\n  saul_reg_t *device;\n  int saul_reg_return_value;\n  if (arg_count < 4) {\n    iprintf(PTR_s_usage___s__s__device_id___value_0_00003154, *arguments, arguments[1]);\n  }\n  else {\n    device_num = atoi(arguments[2]);\n    device = saul_reg_find_nth(device_num);\n    if (device == NULL) {\n      puts(PTR_s_error__undefined_device_given_00003158);\n    }\n    else {\n      memset(&data, 0, sizeof(phydat_t));\n      if (arg_count > 5) {\n        arg_count = 6;\n      }\n      data_dim = arg_count - 3;\n      for (i = 0; i < data_dim; i++) {\n        temp_int = atoi(arguments[i + 3]);\n        data.val[i] = (int16_t)temp_int;\n      }\n      iprintf(PTR_s_Writing_to_device___i____s_0000315c, device_num, device->name);\n      phydat_dump(&data, (uint8_t)data_dim);\n      saul_reg_return_value = saul_reg_write(device, &data);\n      if (saul_reg_return_value < 1) {\n        if (saul_reg_return_value == -0x86) {\n          iprintf(PTR_s_error__device___i_is_not_writabl_00003160, device_num);\n        }\n        else {\n          iprintf(PTR_s_error__failure_to_write_data_to_device_0000305c_to_devic_00003164, device_num);\n        }\n      }\n      else {\n        iprintf(PTR_s_data_successfully_written_to_dev_00003168, device_num);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "saul_reg_write",
                "iprintf",
                "saul_reg_find_nth",
                "memset",
                "phydat_dump",
                "puts",
                "atoi"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000305c",
            "calling": [
                "_saul"
            ],
            "imported": false,
            "current_name": "write_data_to_device_0000305c"
        },
        "FUN_000012b4": {
            "renaming": {
                "FUN_000012b4": "add_to_tsrb_000012b4",
                "isrpipe": "input_pipe",
                "c": "data",
                "iVar1": "result"
            },
            "code": "int add_to_tsrb_000012b4(isrpipe_t *isrpipe, char data) {\n  int result = tsrb_add_one(&isrpipe->tsrb, data);\n  mutex_unlock(&isrpipe->mutex);\n  return result;\n}",
            "called": [
                "mutex_unlock",
                "tsrb_add_one"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012b4",
            "calling": [],
            "imported": false,
            "current_name": "add_to_tsrb_000012b4"
        },
        "FUN_00005b34": {
            "renaming": {
                "FUN_00005b34": "FUNC_00005b34"
            },
            "code": "\ncode * FUNC_00005b34(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  bool bVar1;\n  byte bVar2;\n  undefined *puVar3;\n  int iVar4;\n  code *pcVar5;\n  void *pvVar6;\n  int iVar7;\n  undefined *__s;\n  uint uVar8;\n  uint *puVar9;\n  uint uVar10;\n  uint **ppuVar11;\n  uint uVar12;\n  undefined *puVar13;\n  uint *puVar14;\n  undefined4 uVar15;\n  code *local_24;\n  \n  puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n  bVar2 = *(byte *)(param_2 + 6);\n  __s = (undefined *)((int)param_2 + 0x43);\n  puVar14 = param_2;\n  uVar15 = param_3;\n  local_24 = param_4;\n  if (0x78 < bVar2) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)param_2 + 0x42) = bVar2;\nLAB_00005bdc:\n    __s = (undefined *)((int)param_2 + 0x42);\n    uVar8 = 1;\nLAB_00005d28:\n    param_2[4] = uVar8;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (bVar2 < 99) {\n    if (bVar2 == 0) goto LAB_00005d06;\n    if (bVar2 == 0x58) {\n      *(undefined *)((int)param_2 + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(bVar2) {\n  case 99:\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    *(char *)((int)param_2 + 0x42) = (char)uVar8;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    uVar10 = *param_2;\n    puVar9 = *param_5;\n    if ((int)(uVar10 << 0x18) < 0) {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n    }\n    else {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n      if ((uVar10 & 0x40) != 0) {\n        uVar8 = (uint)(short)uVar8;\n      }\n    }\n    if ((int)uVar8 < 0) {\n      uVar8 = -uVar8;\n      *(undefined *)((int)param_2 + 0x43) = 0x2d;\n    }\n    uVar10 = 10;\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    ppuVar11 = (uint **)*param_5;\n    uVar10 = *param_2;\n    uVar8 = param_2[5];\n    *param_5 = (uint *)(ppuVar11 + 1);\n    puVar9 = *ppuVar11;\n    if (((int)(uVar10 << 0x18) < 0) || (-1 < (int)(uVar10 << 0x19))) {\n      *puVar9 = uVar8;\n    }\n    else {\n      *(short *)puVar9 = (short)uVar8;\n    }\nLAB_00005d06:\n    param_2[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    puVar9 = *param_5;\n    uVar8 = *param_2;\n    *param_5 = puVar9 + 1;\n    if (((int)(uVar8 << 0x18) < 0) || (-1 < (int)(uVar8 << 0x19))) {\n      uVar8 = *puVar9;\n    }\n    else {\n      uVar8 = (uint)*(ushort *)puVar9;\n    }\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    if (bVar2 == 0x6f) {\n      uVar10 = 8;\n    }\n    else {\n      uVar10 = 10;\n    }\n    break;\n  case 0x70:\n    *param_2 = *param_2 | 0x20;\n  case 0x78:\n    puVar3 = PTR_s_0123456789abcdef_00005d7c;\n    *(undefined *)((int)param_2 + 0x45) = 0x78;\nLAB_00005ca8:\n    uVar10 = *param_2;\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    if ((-1 < (int)(uVar10 << 0x18)) && ((int)(uVar10 << 0x19) < 0)) {\n      uVar8 = uVar8 & 0xffff;\n    }\n    if ((int)(uVar10 << 0x1f) < 0) {\n      *param_2 = uVar10 | 0x20;\n    }\n    if (uVar8 == 0) {\n      *param_2 = *param_2 & 0xffffffdf;\n    }\n    uVar10 = 0x10;\n    break;\n  case 0x73:\n    puVar9 = *param_5;\n    *param_5 = puVar9 + 1;\n    __s = (undefined *)*puVar9;\n    pvVar6 = memchr(__s,0,param_2[1]);\n    if (pvVar6 != (void *)0x0) {\n      param_2[1] = (int)pvVar6 - (int)__s;\n    }\n    uVar8 = param_2[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)param_2 + 0x43) = 0;\nLAB_00005c36:\n  uVar12 = param_2[1];\n  param_2[2] = uVar12;\n  if (-1 < (int)uVar12) {\n    *param_2 = *param_2 & 0xfffffffb;\n  }\n  puVar13 = __s;\n  if ((uVar8 != 0) || (uVar12 != 0)) {\n    do {\n      puVar13 = puVar13 + -1;\n      *puVar13 = puVar3[uVar8 - uVar10 * (uVar8 / uVar10)];\n      bVar1 = uVar10 <= uVar8;\n      uVar8 = uVar8 / uVar10;\n    } while (bVar1);\n  }\n  if (((uVar10 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4])) {\n    puVar13[-1] = 0x30;\n    puVar13 = puVar13 + -1;\n  }\n  param_2[4] = (int)__s - (int)puVar13;\n  __s = puVar13;\nLAB_00005c84:\n  iVar4 = _printf_common(param_1,param_2,&local_24,param_3,param_4,puVar14,uVar15);\n  if ((iVar4 == -1) || (iVar4 = (*param_4)(param_1,param_3,__s,param_2[4]), iVar4 == -1)) {\nLAB_00005c98:\n    pcVar5 = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar4 = 0; iVar4 < (int)(param_2[3] - (int)local_24); iVar4 = iVar4 + 1) {\n        iVar7 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar7 == -1) goto LAB_00005c98;\n      }\n    }\n    pcVar5 = (code *)param_2[3];\n    if ((int)(code *)param_2[3] < (int)local_24) {\n      pcVar5 = local_24;\n    }\n  }\n  return pcVar5;\n}\n\n",
            "called": [
                "memchr",
                "_printf_common"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00005b34",
            "calling": [
                "_vfprintf_r"
            ],
            "imported": false,
            "current_name": "FUNC_00005b34"
        },
        "FUN_0000058e": {
            "renaming": {
                "FUN_0000058e": "insert_node_at_end_0000058e",
                "list": "head",
                "new_node": "new_node",
                "list_node": "clist_node_t",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void insert_node_at_end_0000058e(clist_node_t *head, clist_node_t *new_node) {\n  if (head->next == NULL) {\n    new_node->next = new_node;\n  }\n  else {\n    new_node->next = head->next->next;\n    head->next->next = new_node;\n  }\n  head->next = new_node;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000058e",
            "calling": [
                "sched_set_status"
            ],
            "imported": false,
            "current_name": "insert_node_at_end_0000058e"
        },
        "FUN_0000656c": {
            "renaming": {
                "FUN_0000656c": "FUNC_0000656c"
            },
            "code": "\nundefined4 FUNC_0000656c(undefined4 param_1,uint *param_2,byte **param_3,undefined4 *param_4)\n\n{\n  void *pvVar1;\n  int iVar2;\n  undefined4 uVar3;\n  code *pcVar4;\n  uint uVar5;\n  byte *pbVar6;\n  uint uVar7;\n  undefined4 *puVar8;\n  uint *puVar9;\n  uint *puVar10;\n  uint *puVar11;\n  int unaff_r9;\n  int iVar12;\n  void *local_34 [4];\n  \n  local_34[0] = *(void **)PTR_PTR_DAT_00006744;\n  local_34[1] = (void *)*(undefined4 *)(PTR_PTR_DAT_00006744 + 4);\n  local_34[2] = (void *)*(undefined4 *)(PTR_PTR_DAT_00006744 + 8);\n  pcVar4 = DAT_0000674c;\n  if (param_2[6] != 3) {\n    pcVar4 = DAT_00006748;\n  }\n  uVar7 = param_2[2];\n  uVar5 = uVar7 - 1;\n  if (0x15c < uVar5) {\n    unaff_r9 = uVar7 - 0x15d;\n    uVar7 = 0x15d;\n  }\n  if (0x15c < uVar5) {\n    param_2[2] = uVar7;\n  }\n  puVar11 = param_2 + 7;\n  if (uVar5 < 0x15d) {\n    unaff_r9 = 0;\n  }\n  *param_2 = *param_2 | 0xd00;\n  iVar12 = 0;\n  puVar10 = puVar11;\n  do {\n    pvVar1 = memchr(local_34[iVar12],(uint)**param_3,2);\n    if (pvVar1 != (void *)0x0) {\n      if (iVar12 == 1) {\n        if (param_2[1] == 0) {\n          param_2[1] = 8;\n          *param_2 = *param_2 | 0x200;\n        }\n        uVar5 = *param_2 & 0xfffffaff;\nLAB_000065f4:\n        *param_2 = uVar5;\n      }\n      else if (iVar12 == 2) {\n        if ((*param_2 & 0x600) != 0x200) goto LAB_00006624;\n        param_2[1] = 0x10;\n        uVar5 = *param_2 | 0x100;\n        goto LAB_000065f4;\n      }\n      uVar5 = param_2[2];\n      param_2[2] = uVar5 - 1;\n      if (uVar5 != 0) {\n        pbVar6 = *param_3;\n        *param_3 = pbVar6 + 1;\n        puVar9 = (uint *)((int)puVar10 + 1);\n        *(byte *)puVar10 = *pbVar6;\n        pbVar6 = param_3[1];\n        param_3[1] = pbVar6 + -1;\n        puVar10 = puVar9;\n        if (((int)(pbVar6 + -1) < 1) &&\n           (iVar2 = (*(code *)param_2[0x60])(param_1,param_3), iVar2 != 0)) {\n          iVar12 = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    iVar12 = iVar12 + 1;\n  } while (iVar12 != 3);\n  if (param_2[1] == 0) {\n    param_2[1] = 10;\n  }\n  __sccl(param_2[5],(int)PTR_DAT_00006750 - param_2[1]);\n  iVar12 = 0;\n  while( true ) {\n    puVar9 = puVar10;\n    if (param_2[2] == 0) break;\n    pbVar6 = *param_3;\n    uVar5 = (uint)*pbVar6;\n    if (*(char *)(param_2[5] + uVar5) == '\\0') break;\n    if ((uVar5 == 0x30) && ((int)(*param_2 << 0x14) < 0)) {\n      iVar12 = iVar12 + 1;\n      if (unaff_r9 != 0) {\n        unaff_r9 = unaff_r9 + -1;\n        param_2[2] = param_2[2] + 1;\n      }\n    }\n    else {\n      *param_2 = *param_2 & 0xfffff6ff;\n      puVar9 = (uint *)((int)puVar10 + 1);\n      *(byte *)puVar10 = *pbVar6;\n    }\n    pbVar6 = param_3[1];\n    param_3[1] = pbVar6 + -1;\n    if ((int)(pbVar6 + -1) < 1) {\n      iVar2 = (*(code *)param_2[0x60])(param_1,param_3);\n      if (iVar2 != 0) break;\n    }\n    else {\n      *param_3 = *param_3 + 1;\n    }\n    param_2[2] = param_2[2] - 1;\n    puVar10 = puVar9;\n  }\nLAB_000066ca:\n  if ((int)(*param_2 << 0x17) < 0) {\n    if (puVar11 < puVar9) {\n      (*(code *)param_2[0x5f])(param_1,*(byte *)((int)puVar9 + -1),param_3);\n      puVar9 = (uint *)((int)puVar9 + -1);\n    }\n    if (puVar9 == puVar11) {\n      return 1;\n    }\n  }\n  if ((*param_2 & 0x10) == 0) {\n    *(byte *)puVar9 = 0;\n    uVar3 = (*pcVar4)(param_1,puVar11,0,param_2[1]);\n    puVar8 = (undefined4 *)*param_4;\n    uVar5 = *param_2;\n    *param_4 = puVar8 + 1;\n    puVar8 = (undefined4 *)*puVar8;\n    if ((uVar5 & 0x20) == 0) {\n      if ((int)(uVar5 << 0x1f) < 0) {\n        *(short *)puVar8 = (short)uVar3;\n      }\n      else {\n        *puVar8 = uVar3;\n      }\n    }\n    else {\n      *puVar8 = uVar3;\n    }\n    param_2[3] = param_2[3] + 1;\n  }\n  param_2[4] = (uint)((int)puVar9 + param_2[4] + (iVar12 - (int)puVar11));\n  return 0;\n}\n\n",
            "called": [
                "memchr",
                "__sccl"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0000656c",
            "calling": [
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "FUNC_0000656c"
        },
        "FUN_000025f4": {
            "renaming": {
                "FUN_000025f4": "initialize_real_time_transmission_000025f4",
                "rtt_init": "initialize_real_time_transmission_tool"
            },
            "code": "void initialize_real_time_transmission_000025f4(void)\n{\n  initialize_real_time_transmission_000025f4_tool();\n  return;\n}",
            "called": [
                "rtt_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000025f4",
            "calling": [
                "periph_init"
            ],
            "imported": false,
            "current_name": "initialize_real_time_transmission_000025f4"
        },
        "FUN_00001ddc": {
            "renaming": {
                "FUN_00001ddc": "set_gpio_pin_00001ddc",
                "pin": "gpio_t pin",
                "iVar1": "int port_number",
                "DAT_00001e08": "uint32_t* data_ptr",
                "mask": "uint32_t mask"
            },
            "code": "void set_gpio_pin_00001ddc(gpio_t pin)\n{\n  int port_number = get_port_number(pin);\n  DAT_00001e08 = (uint32_t*)0x00001e08;\n  uint32_t mask = 1 << port_number;\n  *data_ptr |= mask;\n  return;\n}",
            "called": [
                "bit_set32",
                "port_num"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ddc",
            "calling": [
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_00001ddc"
        },
        "FUN_00002ecc": {
            "renaming": {
                "FUN_00002ecc": "read_sensor_data_00002ecc",
                "num": "sensor_number",
                "dev": "sensor_device",
                "iVar1": "read_result",
                "pcVar2": "sensor_name",
                "pcVar3": "sensor_driver_type",
                "res": "sensor_data",
                "dim": "sensor_data_dimension"
            },
            "code": "void read_sensor_data_00002ecc(int sensor_number, saul_reg_t *sensor_device) {\n  int read_result;\n  char *sensor_name;\n  char *sensor_driver_type;\n  phydat_t sensor_data;\n  int sensor_data_dimension;\n  read_result = saul_reg_read(sensor_device, &sensor_data);\n  if (read_result < 1) {\n    iprintf(error__failed_to_read_from_device, sensor_number);\n  }\n  else {\n    sensor_name = sensor_device->name;\n    sensor_driver_type = saul_class_to_str(sensor_device->driver->type);\n    iprintf(Reading_from__d___s__s__, sensor_number, sensor_name, sensor_driver_type);\n    phydat_dump(&sensor_data, (uint8_t)read_result);\n  }\n  return;\n}",
            "called": [
                "iprintf",
                "saul_class_to_str",
                "phydat_dump",
                "saul_reg_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002ecc",
            "calling": [
                "probe_all",
                "read"
            ],
            "imported": false,
            "current_name": "read_sensor_data_00002ecc"
        },
        "FUN_00000d76": {
            "renaming": {
                "FUN_00000d76": "clear_bit_00000d76",
                "ptr": "data_ptr",
                "bit": "bit_position",
                "puVar1": "bit_ptr"
            },
            "code": "void clear_bit_00000d76(uint32_t *data_ptr, uint8_t bit_position)\n{\n  undefined4 *bit_ptr;\n  bit_ptr = (undefined4 *)bitband_addr(data_ptr, (uint)bit_position);\n  *bit_ptr = 0;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d76",
            "calling": [
                "cpu_errata_fixes"
            ],
            "imported": false,
            "current_name": "clear_bit_00000d76"
        },
        "FUN_000057a8": {
            "renaming": {
                "FUN_000057a8": "decrease_and_write_char_to_buffer_000057a8",
                "param_1": "buffer_address",
                "param_2": "character",
                "param_3": "buffer_info",
                "iVar1": "buffer_index",
                "puVar2": "buffer_pointer"
            },
            "code": "int decrease_and_write_char_to_buffer_000057a8(undefined4 buffer_address, int character, undefined4 *buffer_info)\n{\n  int buffer_index = buffer_info[2] - 1;\n  buffer_info[2] = buffer_index;\n  if ((buffer_index < 0) && ((buffer_index < (int)buffer_info[6] || (character == 10)))) {\n    int result = __swbuf_r();\n    return result;\n  }\n  undefined *buffer_pointer = (undefined *)*buffer_info;\n  *buffer_info = buffer_pointer + 1;\n  *buffer_pointer = (char)character;\n  return character;\n}",
            "called": [
                "__swbuf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057a8",
            "calling": [
                "__sfputs_r"
            ],
            "imported": false,
            "current_name": "decrease_and_write_char_to_buffer_000057a8"
        },
        "FUN_00004298": {
            "renaming": {
                "FUN_00004298": "releaseRecursiveMutex_00004298"
            },
            "code": "void releaseRecursiveMutex_00004298(void)\n{\n  __retarget_lock_release_recursive(PTR___lock___sinit_recursive_mutex_000042a0);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004298",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "releaseRecursiveMutex_00004298"
        },
        "FUN_00001696": {
            "renaming": {
                "FUN_00001696": "calculate_memory_address_00001696",
                "ptr": "ptr",
                "bit": "bit",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "void * calculate_memory_address_00001696(void *ptr, uintPTR_t bit)\n{\n  uintPTR_t upper_bits = (uintPTR_t)ptr & 0xf0000000;\n  uintPTR_t lower_bits = (uintPTR_t)ptr & 0xfffff;\n  uintPTR_t offset = bit * 4 + (upper_bits | (lower_bits << 5)) + 0x2000000;\n  return (void *)offset;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001696",
            "calling": [
                "bit_clear8",
                "bit_set8",
                "bit_set32"
            ],
            "imported": false,
            "current_name": "calculate_memory_address_00001696"
        },
        "FUN_000008b8": {
            "renaming": {
                "FUN_000008b8": "count_consecutive_words_with_same_value_000008b8",
                "num_used_words": "num_used_words",
                "ptr": "current_word_ptr",
                "PTR_isr_stack_000008f4": "PTR_isr_stack_000008f4",
                "DAT_000008f8": "target_value",
                "PTR_heap_top_000008fc": "heap_top_ptr"
            },
            "code": "int count_consecutive_words_with_same_value_000008b8(void)\n{\n  ptrdiff_t num_used_words;\n  uint32_t *current_word_ptr;\n  uint32_t *PTR_heap_top_000008fc = (uint32_t *)PTR_heap_top_000008fc;\n  uint32_t DAT_000008f8 = *PTR_heap_top_000008fc;\n  \n  for (current_word_ptr = (uint32_t *)PTR_isr_stack_000008f4; (current_word_ptr < PTR_heap_top_000008fc) && (*current_word_ptr == DAT_000008f8); current_word_ptr++) {\n  }\n  \n  return (int)(((uintptr_t)PTR_heap_top_000008fc - (uintptr_t)current_word_ptr) / sizeof(uint32_t)) * sizeof(uint32_t);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000008b8",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "count_consecutive_words_with_same_value_000008b8"
        },
        "FUN_000024bc": {
            "renaming": {
                "FUN_000024bc": "release_mutex_000024bc",
                "mutex": "mutex_ptr",
                "state": "irq_state",
                "plVar2": "node_to_remove",
                "process_priority": "thread_priority",
                "irqstate": "irq_state",
                "__m____": "unused",
                "next": "next_node",
                "process": "thread_to_schedule",
                "bVar1": "thread_id"
            },
            "code": "void release_mutex_000024bc(mutex_t *mutex)\n{\n  uint irq_state;\n  list_node_t *node_to_remove;\n  uint16_t thread_priority;\n  byte thread_id;\n  clist_node_t *unused;\n  list_node_t *next_node;\n  thread_t *thread_to_schedule;\n  irq_state = irq_disable();\n  if ((mutex->queue).next == NULL)\n  {\n    irq_restore(irq_state);\n  }\n  else if ((mutex->queue).next == (list_node *)0xffffffff)\n  {\n    (mutex->queue).next = NULL;\n    irq_restore(irq_state);\n  }\n  else\n  {\n    node_to_remove = list_remove_head(&mutex->queue);\n    sched_set_status((thread_t *)(node_to_remove - 2), THREAD_STATUS_READY);\n    if ((mutex->queue).next == NULL)\n    {\n      (mutex->queue).next = (list_node *)0xffffffff;\n    }\n    thread_id = *(byte *)((int)&node_to_remove[-1].next + 1);\n    irq_restore(irq_state);\n    sched_switch((ushort)thread_id);\n  }\n  return;\n}",
            "called": [
                "list_remove_head",
                "irq_disable",
                "irq_restore",
                "sched_set_status",
                "sched_switch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000024bc",
            "calling": [
                "isrpipe_write_one"
            ],
            "imported": false,
            "current_name": "release_mutex_000024bc"
        },
        "FUN_00000490": {
            "renaming": {
                "FUN_00000490": "read_from_uart_00000490",
                "r": "reent",
                "fd": "file_descriptor",
                "buffer": "buffer",
                "count": "count",
                "iVar1": "bytes_read"
            },
            "code": "_ssize_t read_from_uart_00000490(_reent *reent, int file_descriptor, void *buffer, size_t count) {\n  int bytes_read = uart_stdio_read((char*)buffer, count);\n  return bytes_read;\n}",
            "called": [
                "uart_stdio_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000490",
            "calling": [
                "__sread"
            ],
            "imported": false,
            "current_name": "read_from_uart_00000490"
        },
        "FUN_0000091c": {
            "renaming": {
                "FUN_0000091c": "get_isr_stack_pointer_0000091c",
                "PTR_isr_stack_0000092c": "isr_stack_pointer"
            },
            "code": "void* get_isr_stack_pointer_0000091c(void) {\n  return PTR_isr_stack_0000092c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000091c",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "get_isr_stack_pointer_0000091c"
        },
        "FUN_00005d80": {
            "renaming": {
                "FUN_00005d80": "write_char_00005d80",
                "param_1": "stream",
                "param_2": "c",
                "param_3": "buffer",
                "iVar1": "buffer_pos",
                "puVar2": "buffer_start",
                "buffer_flags": "buffer_flags",
                "buffer_lock": "buffer_lock",
                "buffer_pos": "buffer_pos",
                "buffer_size": "buffer_size",
                "buffer_start": "buffer_start"
            },
            "code": "uint write_char_00005d80(int stream, uint c, undefined4 *buffer) {\n  int buffer_flags = buffer[0x19];\n  int buffer_lock = buffer[0x16];\n  int *buffer_pos = &buffer[2];\n  int buffer_size = buffer[6];\n  undefined *buffer_start = (undefined *)*buffer;\n\n  if (stream != 0 && *(int *)(stream + 0x18) == 0) {\n    __sinit();\n  }\n\n  if (buffer == (undefined4 *)PTR___sf_fake_stdin_00005e04) {\n    buffer = *(undefined4 **)(stream + 4);\n  }\n  else if (buffer == (undefined4 *)PTR___sf_fake_stdout_00005e08) {\n    buffer = *(undefined4 **)(stream + 8);\n  }\n  else if (buffer == (undefined4 *)PTR___sf_fake_stderr_00005e0c) {\n    buffer = *(undefined4 **)(stream + 0xc);\n  }\n\n  if (-1 < (buffer_flags << 0x1f) && -1 < ((uint)*(ushort *)(buffer + 3) << 0x16)) {\n    __retarget_lock_acquire_recursive(buffer_lock);\n  }\n\n  *buffer_pos = *buffer_pos - 1;\n\n  if (*buffer_pos < 0 && (*buffer_pos < buffer_size || (c & 0xff) == 10)) {\n    c = __swbuf_r(stream, c, buffer);\n  }\n  else {\n    *buffer_start = (char)c;\n    buffer_start = buffer_start + 1;\n    *buffer = (undefined4)buffer_start;\n    c &= 0xff;\n  }\n\n  if (-1 < (buffer_flags << 0x1f) && -1 < ((uint)*(ushort *)(buffer + 3) << 0x16)) {\n    __retarget_lock_release_recursive(buffer_lock);\n  }\n  return c;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive",
                "__sinit",
                "__swbuf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005d80",
            "calling": [
                "putchar"
            ],
            "imported": false,
            "current_name": "write_char_00005d80"
        },
        "FUN_00001f80": {
            "renaming": {
                "FUN_00001f80": "configure_gpio_pin_00001f80",
                "pin": "gpio_pin",
                "pcr": "pin_config",
                "pPVar1": "port_ptr",
                "iVar2": "pin_num",
                "pin_00": "pin_num",
                "uVar3": "prev_pin_config",
                "isr_state": "not_used",
                "clk_en": "enable_clock_for_pin",
                "port": "get_port_for_pin",
                "port_num": "get_port_number",
                "ctx_clear": "clear_interrupt_context"
            },
            "code": "void configure_gpio_pin_00001f80(gpio_t pin, uint32_t pin_config) {\n  PORT_Type *port_ptr;\n  int pin_num;\n  int port_num;\n  uint32_t prev_pin_config;\n  \n  enable_clock_for_pin(pin);\n  port_ptr = get_port_for_pin(pin);\n  pin_num = get_pin_number(pin);\n  prev_pin_config = port_ptr->PCR[pin_num];\n  port_ptr->PCR[pin_num] = pin_config;\n  if ((prev_pin_config & 0xf0000) != 0) {\n    port_num = get_port_number(pin);\n    pin_num = get_pin_number(pin);\n    clear_interrupt_context(port_num, pin_num);\n  }\n  return;\n}",
            "called": [
                "port_num",
                "pin_num",
                "clk_en",
                "port",
                "ctx_clear"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001f80",
            "calling": [
                "gpio_init",
                "uart_init_pins"
            ],
            "imported": false,
            "current_name": "configure_gpio_pin_00001f80"
        },
        "FUN_00000e64": {
            "renaming": {
                "FUN_00000e64": "initialize_system_00000e64",
                "DAT_00000ed0": "thread_list_offset",
                "DAT_00000ed4": "gpio_register_base",
                "uint": "unsigned int",
                "thread_add_to_list": "thread_list_base_address",
                "cpu_init": "initialize_cpu",
                "gpio_init": "initialize_gpio",
                "gpio_set": "set_gpio"
            },
            "code": "void initialize_system_00000e64(void)\n{\n  uint *thread_list_ptr = thread_add_to_list + DAT_00000ed0 + 4;\n  *thread_list_ptr |= 0x200;\n  uint *gpio_reg_ptr = DAT_00000ed4 + 0x48;\n  *gpio_reg_ptr &= 0xfefff8ff;\n  initialize_cpu();\n  initialize_gpio(0x2056, GPIO_OUT);\n  initialize_gpio(0x511a, GPIO_OUT);\n  initialize_gpio(0x2055, GPIO_OUT);\n  set_gpio(0x2056);\n  set_gpio(0x511a);\n  set_gpio(0x2055);\n  return;\n}",
            "called": [
                "gpio_init",
                "cpu_init",
                "gpio_set"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e64",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "initialize_system_00000e64"
        },
        "FUN_000026e4": {
            "renaming": {
                "FUN_000026e4": "power_off_rtt_debugger_000026e4"
            },
            "code": "void power_off_rtt_debugger_000026e4(void)\n{\n  rtt_poweroff();\n  return;\n}",
            "called": [
                "rtt_poweroff"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026e4",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "power_off_rtt_debugger_000026e4"
        },
        "FUN_00000d44": {
            "renaming": {
                "FUN_00000d44": "calculate_address_00000d44",
                "ptr": "ptr",
                "bit": "bit"
            },
            "code": "void * calculate_address_00000d44(void *ptr, uintptr_t bit) {\n\tuintptr_t upper_bits = (uintptr_t)ptr & 0xf0000000;\n\tuintptr_t lower_bits = ((uintptr_t)ptr & 0xfffff) << 5;\n\tuintptr_t offset = 0x2000000;\n\tuintptr_t result = (bit * 4) + upper_bits + lower_bits + offset;\n\treturn (void *)result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d44",
            "calling": [
                "bit_clear32"
            ],
            "imported": false,
            "current_name": "calculate_address_00000d44"
        },
        "FUN_00000698": {
            "renaming": {
                "FUN_00000698": "update_process_status_00000698",
                "process": "thread",
                "status": "new_status",
                "PTR_sched_runqueues_00000730": "sched_runqueues",
                "PTR_runqueue_bitcache_00000734": "runqueue_bitcache"
            },
            "code": "void update_process_status_00000698(thread_t *process, uint new_status) {\n  if (new_status < 9) {\n    if ((process->status > 8) && (clist_lpop((clist_node_t *)(PTR_PTR_sched_runqueues_00000730_00000730 + (uint)process->priority * 4)), *(int *)(PTR_PTR_sched_runqueues_00000730_00000730 + (uint)process->priority * 4) == 0)) {\n      *(uint *)PTR_PTR_runqueue_bitcache_00000734_00000734 &= ~(1 << process->priority);\n    }\n  }\n  else if (process->status < 9) {\n    clist_rpush((clist_node_t *)(PTR_PTR_sched_runqueues_00000730_00000730 + (uint)process->priority * 4), &process->rq_entry);\n    *(uint *)PTR_PTR_runqueue_bitcache_00000734_00000734 |= 1 << process->priority;\n  }\n  process->status = (uint8_t)new_status;\n  return;\n}",
            "called": [
                "clist_rpush",
                "clist_lpop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000698",
            "calling": [
                "sched_task_exit",
                "mutex_unlock",
                "thread_create",
                "_mutex_lock"
            ],
            "imported": false,
            "current_name": "update_process_status_00000698"
        },
        "FUN_00000cd0": {
            "renaming": {
                "FUN_00000cd0": "getIRQinterruptsEnabledStatus_00000cd0",
                "bVar1": "isCurrentModePrivileged",
                "uVar2": "IRQinterruptsEnabledStatus",
                "result": "N/A",
                "mask": "N/A"
            },
            "code": "uint32_t getIRQinterruptsEnabledStatus_00000cd0(void)\n{\n  bool isCurrentModePrivileged = (bool)isCurrentModePrivileged();\n  uint32_t IRQinterruptsEnabledStatus = 0;\n  if (isCurrentModePrivileged) {\n    IRQinterruptsEnabledStatus = isIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return IRQinterruptsEnabledStatus;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cd0",
            "calling": [
                "kinetis_mcg_init",
                "_sbrk_r",
                "sched_task_exit",
                "pm_off",
                "mutex_unlock",
                "core_panic",
                "kernel_init",
                "thread_create",
                "_mutex_lock"
            ],
            "imported": false,
            "current_name": "getIRQinterruptsEnabledStatus_00000cd0"
        },
        "FUN_00000cc0": {
            "renaming": {
                "FUN_00000cc0": "panic_dummy_handler_00000cc0",
                "PTR_s_DUMMY_HANDLER_00000ccc": "dummy_handler"
            },
            "code": "void panic_dummy_handler_00000cc0(void)\n{\n    /* WARNING: Subroutine does not return */\n    core_panic(PANIC_DUMMY_HANDLER, PTR_s_DUMMY_HANDLER_00000ccc);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cc0",
            "calling": [
                "dummy_handler"
            ],
            "imported": false,
            "current_name": "panic_dummy_handler_00000cc0"
        },
        "FUN_00002994": {
            "renaming": {
                "FUN_00002994": "rtt_callback_handler_00002994",
                "DAT_000029f8": "rtt_callback_ptr",
                "RTC_Type": "RTC_Type",
                "PTR_rtt_callback_000029fc": "PTR_rtt_callback_000029fc"
            },
            "code": "void rtt_callback_handler_00002994(void)\n{\n  int DAT_000029f8 = DAT_000029f8;\n  RTC_Type *rtt = (RTC_Type *) DAT_000029f8;\n  if (((*(uint *)(DAT_000029f8 + 0x14) & 4) != 0) && (*(int *)PTR_rtt_callback_000029fc != 0)) {\n    rtt->MODE0.INTENCLR.reg = RTC_MODE0_INTENCLR_CMP0; \n    (**(code **)PTR_rtt_callback_000029fc)(*(undefined4 *)(PTR_rtt_callback_000029fc + 4));\n  }\n  if (((*(uint *)(DAT_000029f8 + 0x14) & 2) != 0) && (*(int *)(PTR_rtt_callback_000029fc + 8) != 0)) {\n    (**(code **)(PTR_rtt_callback_000029fc + 8))(*(undefined4 *)(PTR_rtt_callback_000029fc + 0xc));\n  }\n  cortexm_isr_end();\n  return;\n}",
            "called": [
                "cortexm_isr_end"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002994",
            "calling": [],
            "imported": false,
            "current_name": "rtt_callback_handler_00002994"
        },
        "FUN_00000d2a": {
            "renaming": {
                "FUN_00000d2a": "get_exception_number_if_privileged_00000d2a",
                "uVar2": "exception_number",
                "bVar1": "is_privileged_mode"
            },
            "code": "uint32_t get_exception_number_if_privileged_00000d2a(void)\n{\n  bool is_privileged_mode;\n  uint32_t exception_number;\n  \n  exception_number = 0;\n  is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    exception_number = getCurrentExceptionNumber();\n    exception_number &= 0x1f;\n  }\n  return exception_number;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d2a",
            "calling": [
                "sched_switch"
            ],
            "imported": false,
            "current_name": "get_exception_number_if_privileged_00000d2a"
        },
        "FUN_00001ff6": {
            "renaming": {
                "FUN_00001ff6": "set_gpio_pin_high_00001ff6",
                "pin": "pin",
                "uVar1": "pin_number",
                "pGVar2": "gpio_pointer",
                "pin_num": "get_pin_number",
                "gpio": "get_gpio_pointer",
                "PSOR": "PSOR"
            },
            "code": "void set_gpio_pin_high_00001ff6(gpio_t pin)\n{\n  uint32_t pin_number = get_pin_number(pin);\n  GPIO_Type *gpio_pointer = get_gpio_pointer(pin);\n  gpio_pointer->PSOR = 1 << (pin_number & 0xff);\n  return;\n}",
            "called": [
                "pin_num",
                "gpio"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ff6",
            "calling": [
                "board_init"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_high_00001ff6"
        },
        "FUN_000013b8": {
            "renaming": {
                "FUN_000013b8": "initialize_uart_000013b8",
                "uart": "uart_id",
                "baudrate": "baud_rate",
                "rx_cb": "rx_callback",
                "arg": "callback_arg",
                "PANIC_ASSERT_FAIL": "assertion_failure",
                "PTR_assert_crash_message_0000143c": "assert_crash_message",
                "PTR_config_00001440": "config_rx_callback",
                "FUN_000013b8_pins": "initialize_uart_pins",
                "PTR_uart_config_00001444": "uart_config",
                "FUN_000013b8_uart": "initialize_uart_peripheral",
                "iVar1": "return_value"
            },
            "code": "int initialize_uart_000013b8(uart_t uart, uint32_t baudrate, uart_rx_cb_t rx_callback, void *callback_arg)\\n{\\n  int return_value;\\n  if (uart != 0) {\\n    /* WARNING: Subroutine does not return */\\n    core_panic(PANIC_ASSERT_FAIL, PTR_assert_crash_message_0000143c);\\n  }\\n  *(uart_rx_cb_t *)PTR_config_00001440 = rx_callback;\\n  *(void **)(PTR_config_00001440 + 4) = callback_arg;\\n  initialize_uart_000013b8_pins(0);\\n  bit_set32(*(uint32_t **)PTR_uart_config_00001444 + 0x18, PTR_uart_config_00001444[0x1c]);\\n  if (PTR_uart_config_00001444[0x1e] == \"\\0\") {\\n    initialize_uart_000013b8_peripheral(0, baudrate);\\n    return_value = 0;\\n  }\\n  else {\\n    return_value = -1;\\n  }\\n  return return_value;\\n}",
            "called": [
                "uart_init_uart",
                "core_panic",
                "bit_set32",
                "uart_init_pins"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000013b8",
            "calling": [
                "uart_stdio_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_000013b8"
        },
        "FUN_00000f80": {
            "renaming": {
                "FUN_00000f80": "infinite_loop_00000f80"
            },
            "code": "void * infinite_loop_00000f80(void *arg)\n{\n  do {\n    // Do nothing block with infinite loop\n  } while(true);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f80",
            "calling": [],
            "imported": false,
            "current_name": "infinite_loop_00000f80"
        },
        "FUN_00002a88": {
            "renaming": {
                "FUN_00002a88": "print_shell_commands_00002a88",
                "command_list": "command_list",
                "command_lists": "command_array",
                "i": "index",
                "entry": "entry",
                "PTR_s___20s__s_00002b04": "Command_Description_Format",
                "PTR_s_Command_00002b00": "Command_Title",
                "PTR_s_Description_00002afc": "Command_Description",
                "PTR_s__________________________________00002b08": "Separator",
                "shell_command_t": "ShellCommand",
                "name": "Name",
                "desc": "Description",
                "PTR__shell_command_list_00002b0c": "shell_command_list"
            },
            "code": "void print_shell_commands_00002a88(shell_command_t *command_list)\n{\n  shell_command_t *command_array[2];\n  uint index;\n  shell_command_t *entry;\n  iprintf(\"%s - %s\\n\", \"Command\", \"Description\");\n  puts(\"--------------------------------------------------\");\n  command_array[0] = command_list;\n  command_array[1] = (shell_command_t *)PTR__shell_command_list_00002b0c;\n  for (index = 0; index < 2; index++) {\n    entry = command_array[index];\n    if (entry != (shell_command_t *)0x0) {\n      for (; entry->name != (char *)0x0; entry++) {\n        iprintf(\"%s - %s\\n\", entry->name, entry->desc);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "iprintf",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a88",
            "calling": [
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "print_shell_commands_00002a88"
        },
        "FUN_00002f30": {
            "renaming": {
                "FUN_00002f30": "print_saul_devices_00002f30",
                "i": "device_index",
                "dev": "current_device"
            },
            "code": "void print_saul_devices_00002f30(void)\n{\n  int device_index = 0;\n  saul_reg_t *current_device = *(saul_reg_t **)PTR_saul_reg_00002f6c;\n  \n  while (current_device != (saul_reg_t *)0x0)\n  {\n    probe(device_index, current_device);\n    puts(PTR_DAT_00002f70);\n    device_index++;\n    current_device = current_device->next;\n  }\n  return;\n}",
            "called": [
                "probe",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f30",
            "calling": [
                "read"
            ],
            "imported": false,
            "current_name": "print_saul_devices_00002f30"
        },
        "FUN_00001e44": {
            "renaming": {
                "FUN_00001e44": "set_pin_context_00001e44",
                "port": "port",
                "pin": "pin",
                "ctx": "context",
                "iVar1": "pin_offset",
                "PTR_isr_map_00001ec0": "isr_map_ptr",
                "uint": "uint",
                "mask": "mask",
                "masked_value": "masked_value",
                "new_value": "new_value"
            },
            "code": "void set_pin_context_00001e44(int port, int pin, int context) {\n  int pin_offset = pin >> 3;\n  uint* PTR_isr_map_00001ec0 = PTR_isr_map_00001ec0 + (pin_offset + port * 4) * 4;\n  uint mask = ~(0xf << ((pin & 7U) << 2));\n  uint masked_value = *PTR_isr_map_00001ec0 & mask;\n  uint new_value = masked_value | (context << ((pin & 7U) << 2));\n  *PTR_isr_map_00001ec0 = new_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e44",
            "calling": [
                "ctx_clear"
            ],
            "imported": false,
            "current_name": "set_pin_context_00001e44"
        },
        "FUN_00001318": {
            "renaming": {
                "FUN_00001318": "setInterruptPriority_00001318",
                "IRQn": "interruptNumber",
                "DAT_00001344": "interruptRegisterBaseAddress"
            },
            "code": "void setInterruptPriority_00001318(IRQn_Type interruptNumber) {\n  int* interruptRegister = (int*)(DAT_00001344 + ((uint)(int)interruptNumber >> 5) * 4);\n  int interruptBit = 1 << (interruptNumber & 0x1fU);\n  *interruptRegister = interruptBit;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001318",
            "calling": [
                "uart_init_uart"
            ],
            "imported": false,
            "current_name": "setInterruptPriority_00001318"
        },
        "FUN_00000900": {
            "renaming": {
                "FUN_00000900": "get_main_stack_pointer_00000900",
                "pvVar1": "main_stack_pointer",
                "result": "N/A",
                "msp": "N/A"
            },
            "code": "void * get_main_stack_pointer_00000900(void)\n{\n  void *main_stack_pointer;\n  main_stack_pointer = (void *)getMainStackPointer();\n  return main_stack_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000900",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "get_main_stack_pointer_00000900"
        },
        "FUN_00004274": {
            "renaming": {
                "FUN_00004274": "acquire_recursive_lock_00004274",
                "PTR___lock___sfp_recursive_mutex_0000427c": "PTR_recursive_mutex"
            },
            "code": "void acquire_recursive_lock_00004274(void)\n{\n  __retarget_lock_acquire_recursive(PTR___lock___sfp_recursive_mutex_0000427c);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004274",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "acquire_recursive_lock_00004274"
        },
        "FUN_00002fe0": {
            "renaming": {
                "FUN_00002fe0": "probe_devices_00002fe0",
                "argc": "num_args",
                "argv": "arg_values",
                "dev_00": "device_00",
                "dev": "device",
                "num": "device_id",
                "PTR_s_usage___s__s__device_id__all_00003050": "usage_string",
                "PTR_DAT_00003054": "DEVICE_ID_ALL",
                "PTR_s_error__undefined_device_id_given_00003058": "undefined_device_id_error"
            },
            "code": "void probe_devices_00002fe0(int num_args, char **arg_values) {\n  int arg_count;\n  saul_reg_t *device_00;\n  saul_reg_t *device;\n  int device_id;\n\n  if (num_args < 3) {\n    iprintf(PTR_s_usage___s__s__device_id__all_00003050, arg_values[0], arg_values[1]);\n  }\n  else {\n    arg_count = strcmp(arg_values[2], PTR_DAT_00003054);\n    if (arg_count == 0) {\n      probe_all_devices();\n    }\n    else {\n      device_id = atoi(arg_values[2]);\n      device_00 = saul_reg_find_nth(device_id);\n      if (device_00 == (saul_reg_t *)0x0) {\n        puts(PTR_s_error__undefined_device_id_given_00003058);\n      }\n      else {\n        probe(device_id, device_00);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "probe_all",
                "strcmp",
                "iprintf",
                "saul_reg_find_nth",
                "probe",
                "puts",
                "atoi"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002fe0",
            "calling": [
                "_saul"
            ],
            "imported": false,
            "current_name": "probe_devices_00002fe0"
        },
        "FUN_00001dc0": {
            "renaming": {
                "FUN_00001dc0": "get_gpio_pin_number_00001dc0",
                "pin": "gpio_pin",
                "MAX_GPIO_PIN_NUMBER": "max_gpio_pin_number"
            },
            "code": "int get_gpio_pin_number_00001dc0(gpio_t pin)\n{\n  const int MAX_GPIO_PIN_NUMBER = 0x3f;\n  return pin & MAX_GPIO_PIN_NUMBER;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001dc0",
            "calling": [
                "gpio_init_port",
                "gpio_init",
                "gpio_set"
            ],
            "imported": false,
            "current_name": "get_gpio_pin_number_00001dc0"
        },
        "FUN_00000df4": {
            "renaming": {
                "FUN_00000df4": "initialize_uart_00000df4",
                "0": "uart_port",
                "0x1c200": "baud_rate",
                "DAT_00000e10": "data",
                "PTR_uart_stdio_isrpipe_00000e0c": "isr_pipe"
            },
            "code": "void initialize_uart_00000df4(void)\n{\n  int baud_rate = 115200;\n  int uart_port = 0;\n  int PTR_uart_stdio_isrpipe_00000e0c = PTR_uart_stdio_isrpipe_00000e0c;\n  int DAT_00000e10 = DAT_00000e10;\n  uart_init(uart_port, baud_rate, DAT_00000e10, PTR_uart_stdio_isrpipe_00000e0c);\n  return;\n}",
            "called": [
                "uart_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000df4",
            "calling": [
                "_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_00000df4"
        },
        "FUN_00002400": {
            "renaming": {
                "FUN_00002400": "do_nothing_00002400"
            },
            "code": "\nvoid do_nothing_00002400(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002400",
            "calling": [
                "main_trampoline"
            ],
            "imported": false,
            "current_name": "do_nothing_00002400"
        },
        "FUN_00002eb4": {
            "renaming": {
                "FUN_00002eb4": "print_system_info_00002eb4",
                "argc": "argument_count",
                "argv": "arguments",
                "ps": "print_system_info"
            },
            "code": "int print_system_info_00002eb4(int argument_count, char **arguments){\n  print_system_info_00002eb4();\n  return 0;\n}",
            "called": [
                "ps"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002eb4",
            "calling": [],
            "imported": false,
            "current_name": "print_system_info_00002eb4"
        },
        "FUN_0000328c": {
            "renaming": {
                "FUN_0000328c": "parse_time_from_args_0000328c",
                "argv": "args",
                "time": "time",
                "lVar1": "arg_as_long",
                "end": "end",
                "i": "short_value",
                "dow": "day_of_week_from_date",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int parse_time_from_args_0000328c(char **args, tm *time)\n{\n  long arg_as_long;\n  int day_of_week;\n  char *end;\n\n  arg_as_long = strtol(*args,&end,10);\n  short year_offset = (short)arg_as_long;\n  time->tm_year = year_offset - 1900;\n\n  arg_as_long = strtol(end + 1,&end,10);\n  short month_offset = (short)arg_as_long;\n  time->tm_mon = month_offset - 1;\n\n  arg_as_long = strtol(end + 1,&end,10);\n  short day_offset = (short)arg_as_long;\n  time->tm_mday = (int)day_offset;\n\n  arg_as_long = strtol(args[1],&end,10);\n  short hour_offset = (short)arg_as_long;\n  time->tm_hour = (int)hour_offset;\n\n  arg_as_long = strtol(end + 1,&end,10);\n  short minute_offset = (short)arg_as_long;\n  time->tm_min = (int)minute_offset;\n\n  arg_as_long = strtol(end + 1,&end,10);\n  short second_offset = (short)arg_as_long;\n  time->tm_sec = (int)second_offset;\n\n  day_of_week = day_of_week_from_date(time->tm_year + 1900, time->tm_mon + 1, time->tm_mday);\n  time->tm_wday = day_of_week;\n  time->tm_isdst = -1;\n  return 0;\n}",
            "called": [
                "dow",
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000328c",
            "calling": [
                "_rtc_setalarm",
                "_rtc_settime"
            ],
            "imported": false,
            "current_name": "parse_time_from_args_0000328c"
        },
        "FUN_000041f4": {
            "renaming": {
                "FUN_000041f4": "initialize_data_structures_000041f4",
                "param_1": "data_structure",
                "param_2": "parameter_2",
                "param_3": "parameter_3",
                "uVar1": "variable_1",
                "DAT_0000422c": "constant_1",
                "DAT_00004230": "constant_2",
                "DAT_00004234": "constant_3",
                "DAT_00004238": "constant_4"
            },
            "code": "void initialize_data_structures_000041f4(undefined4 *data_structure, undefined2 parameter_2, undefined2 parameter_3) {\n  *data_structure = 0;\n  data_structure[1] = 0;\n  data_structure[2] = 0;\n  data_structure[3] = parameter_2;\n  data_structure[4] = 0;\n  data_structure[5] = 0;\n  data_structure[6] = 0;\n  data_structure[7] = 0;\n  data_structure[8] = data_structure;\n  data_structure[9] = DAT_0000422c;\n  data_structure[10] = DAT_00004230;\n  data_structure[11] = DAT_00004234;\n  data_structure[12] = DAT_00004238;\n}\n",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041f4",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "initialize_data_structures_000041f4"
        },
        "FUN_0000316c": {
            "renaming": {
                "FUN_0000316c": "perform_operation_0000316c",
                "argc": "argument_count",
                "argv": "arguments",
                "iVar1": "comparison_result",
                "list": "list_operations",
                "strcmp": "strcmp",
                "PTR_DAT_000031d4": "PTR_DAT_000031d4",
                "read": "read_file",
                "PTR_s_write_000031d8": "PTR_s_write_000031d8",
                "write": "write_file",
                "iprintf": "iprintf",
                "PTR_s_usage___s_read_write_000031dc": "PTR_s_usage___s_read_write_000031dc"
            },
            "code": "int perform_operation_0000316c(int argument_count, char **arguments) {\n  int comparison_result;\n  if (argument_count < 2) {\n    list_operations();\n  }\n  else {\n    comparison_result = strcmp(arguments[1], PTR_DAT_000031d4);\n    if (comparison_result == 0) {\n      read_file(argument_count, arguments);\n    }\n    else {\n      comparison_result = strcmp(arguments[1], PTR_s_write_000031d8);\n      if (comparison_result == 0) {\n        write_file(argument_count, arguments);\n      }\n      else {\n        iprintf(PTR_s_usage___s_read_write_000031dc, *arguments);\n      }\n    }\n  }\n  return 0;\n}",
            "called": [
                "read",
                "strcmp",
                "iprintf",
                "list",
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000316c",
            "calling": [],
            "imported": false,
            "current_name": "perform_operation_0000316c"
        },
        "FUN_000026f0": {
            "renaming": {
                "FUN_000026f0": "checkAndCallRTC_000026f0",
                "arg": "argument",
                "PTR_rtc_callback_00002710": "rtc_callback_ptr"
            },
            "code": "void checkAndCallRTC_000026f0(void *arg) {\n  int *PTR_rtc_callback_00002710 = (int*) PTR_rtc_callback_00002710;\n  if (*PTR_rtc_callback_00002710 != 0) {\n    void (*rtc_callback_func)(void*) = *(void (**) (void*)) PTR_rtc_callback_00002710;\n    rtc_callback_func(arg);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026f0",
            "calling": [],
            "imported": false,
            "current_name": "checkAndCallRTC_000026f0"
        },
        "FUN_0000510c": {
            "renaming": {
                "FUN_0000510c": "FUNC_0000510c"
            },
            "code": "\nvoid FUNC_0000510c(undefined4 param_1)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  int iVar4;\n  char *pcVar5;\n  void *__ptr;\n  size_t sVar6;\n  char *pcVar7;\n  int iVar8;\n  int iVar9;\n  ulong uVar10;\n  char cVar11;\n  bool bVar12;\n  ushort *puVar13;\n  int *piVar14;\n  ushort *puVar15;\n  int *piVar16;\n  ushort local_3c;\n  ushort local_3a;\n  ushort local_38;\n  ushort local_36;\n  ushort local_34;\n  ushort local_32;\n  int local_30;\n  char *local_2c [2];\n  \n  iVar4 = __gettzinfo();\n  puVar1 = PTR_prev_tzenv_000053d8;\n  pcVar5 = (char *)_getenv_r(param_1,PTR_DAT_000053d4);\n  puVar2 = PTR_LAB_00007a5e_1_000053e0;\n  if (pcVar5 == (char *)0x0) {\n    *(undefined4 *)PTR__timezone_000053dc = 0;\n    *(undefined4 *)PTR__daylight_000053e4 = 0;\n    puVar3 = PTR__tzname_000053e8;\n    __ptr = *(void **)puVar1;\n    *(undefined **)PTR__tzname_000053e8 = puVar2;\n    *(undefined **)(puVar3 + 4) = puVar2;\n    free(__ptr);\n    *(undefined4 *)puVar1 = 0;\n  }\n  else if ((*(char **)puVar1 == (char *)0x0) ||\n          (iVar8 = strcmp(pcVar5,*(char **)puVar1), iVar8 != 0)) {\n    free(*(void **)puVar1);\n    sVar6 = strlen(pcVar5);\n    pcVar7 = (char *)_malloc_r(param_1,sVar6 + 1);\n    *(char **)puVar1 = pcVar7;\n    if (pcVar7 != (char *)0x0) {\n      strcpy(pcVar7,pcVar5);\n    }\n    if (*pcVar5 == ':') {\n      pcVar5 = pcVar5 + 1;\n    }\n    iVar8 = siscanf(pcVar5,PTR_s__10__0_9_____n_000053f0,PTR___tzname_std_000053ec,&local_30);\n    if (0 < iVar8) {\n      pcVar7 = pcVar5 + local_30;\n      if (pcVar5[local_30] == '-') {\n        pcVar7 = pcVar7 + 1;\n        iVar8 = -1;\n      }\n      else {\n        if (pcVar5[local_30] == '+') {\n          pcVar7 = pcVar7 + 1;\n        }\n        iVar8 = 1;\n      }\n      local_3a = 0;\n      local_38 = 0;\n      puVar13 = &local_3a;\n      piVar14 = &local_30;\n      puVar15 = &local_38;\n      piVar16 = &local_30;\n      iVar9 = siscanf(pcVar7,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a,\n                      &local_30,&local_38,&local_30);\n      puVar1 = PTR___tzname_dst_00005400;\n      if (0 < iVar9) {\n        *(uint *)(iVar4 + 0x28) =\n             ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar8;\n        puVar2 = PTR__tzname_000053e8;\n        *(undefined **)PTR__tzname_000053e8 = PTR___tzname_std_000053ec;\n        pcVar7 = pcVar7 + local_30;\n        iVar8 = siscanf(pcVar7,PTR_s__10__0_9_____n_000053f0,puVar1,&local_30,puVar13,piVar14,\n                        puVar15,piVar16);\n        if (iVar8 < 1) {\n          *(undefined4 *)(puVar2 + 4) = *(undefined4 *)puVar2;\n          *(undefined4 *)PTR__timezone_000053dc = *(undefined4 *)(iVar4 + 0x28);\n          *(undefined4 *)PTR__daylight_000053e4 = 0;\n        }\n        else {\n          *(undefined **)(puVar2 + 4) = puVar1;\n          pcVar5 = pcVar7 + local_30;\n          if (pcVar7[local_30] == '-') {\n            pcVar5 = pcVar5 + 1;\n            iVar8 = -1;\n          }\n          else {\n            if (pcVar7[local_30] == '+') {\n              pcVar5 = pcVar5 + 1;\n            }\n            iVar8 = 1;\n          }\n          local_3c = 0;\n          local_3a = 0;\n          local_38 = 0;\n          local_30 = 0;\n          iVar9 = siscanf(pcVar5,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a,\n                          &local_30,&local_38,&local_30);\n          if (iVar9 < 1) {\n            iVar8 = *(int *)(iVar4 + 0x28) + -0xe10;\n          }\n          else {\n            iVar8 = ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar8;\n          }\n          *(int *)(iVar4 + 0x50) = iVar8;\n          pcVar5 = pcVar5 + local_30;\n          bVar12 = false;\n          iVar8 = iVar4;\n          while( true ) {\n            if (*pcVar5 == ',') {\n              pcVar5 = pcVar5 + 1;\n            }\n            cVar11 = *pcVar5;\n            if (cVar11 == 'M') {\n              iVar9 = siscanf(pcVar5,PTR_s_M_hu_n__hu_n__hu_n_000053f8,&local_36,&local_30,&local_34\n                              ,&local_30,&local_32,&local_30);\n              if (iVar9 != 3) {\n                return;\n              }\n              if (0xb < local_36 - 1) {\n                return;\n              }\n              if (4 < local_34 - 1) {\n                return;\n              }\n              if (6 < local_32) {\n                return;\n              }\n              *(uint *)(iVar8 + 0xc) = (uint)local_36;\n              *(uint *)(iVar8 + 0x10) = (uint)local_34;\n              *(undefined *)(iVar8 + 8) = 0x4d;\n              *(uint *)(iVar8 + 0x14) = (uint)local_32;\n              pcVar7 = pcVar5 + local_30;\n            }\n            else {\n              if (cVar11 == 'J') {\n                pcVar5 = pcVar5 + 1;\n              }\n              else {\n                cVar11 = 'D';\n              }\n              uVar10 = strtoul(pcVar5,local_2c,10);\n              local_32 = (ushort)uVar10;\n              pcVar7 = local_2c[0];\n              if (local_2c[0] == pcVar5) {\n                if (bVar12) {\n                  *(undefined *)(iVar4 + 0x30) = 0x4d;\n                  *(undefined4 *)(iVar4 + 0x34) = 0xb;\n                  *(undefined4 *)(iVar4 + 0x38) = 1;\n                  *(undefined4 *)(iVar4 + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(iVar4 + 8) = 0x4d;\n                  *(undefined4 *)(iVar4 + 0xc) = 3;\n                  *(undefined4 *)(iVar4 + 0x10) = 2;\n                  *(undefined4 *)(iVar4 + 0x14) = 0;\n                }\n              }\n              else {\n                *(char *)(iVar8 + 8) = cVar11;\n                *(ulong *)(iVar8 + 0x14) = uVar10 & 0xffff;\n              }\n            }\n            local_3c = 2;\n            local_3a = 0;\n            local_38 = 0;\n            local_30 = 0;\n            if (*pcVar7 == '/') {\n              siscanf(pcVar7,PTR_DAT_000053fc,&local_3c,&local_30,&local_3a,&local_30,&local_38,\n                      &local_30);\n            }\n            *(uint *)(iVar8 + 0x18) =\n                 (uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38;\n            iVar8 = iVar8 + 0x28;\n            pcVar5 = pcVar7 + local_30;\n            if (bVar12) break;\n            bVar12 = true;\n          }\n          __tzcalc_limits(*(undefined4 *)(iVar4 + 4));\n          iVar8 = *(int *)(iVar4 + 0x28);\n          *(int *)PTR__timezone_000053dc = iVar8;\n          iVar8 = *(int *)(iVar4 + 0x50) - iVar8;\n          if (iVar8 != 0) {\n            iVar8 = 1;\n          }\n          *(int *)PTR__daylight_000053e4 = iVar8;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "siscanf",
                "_getenv_r",
                "strlen",
                "free",
                "strcmp",
                "__tzcalc_limits",
                "__gettzinfo",
                "_malloc_r",
                "strcpy",
                "strtoul"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0000510c",
            "calling": [
                "_tzset_unlocked"
            ],
            "imported": false,
            "current_name": "FUNC_0000510c"
        },
        "FUN_000057d2": {
            "renaming": {
                "FUN_000057d2": "write_string_to_file_000057d2",
                "param_1": "file_descriptor",
                "param_2": "flags",
                "param_3": "string",
                "param_4": "string_length",
                "puVar2": "string_end",
                "iVar3": "bytes_written",
                "iVar1": "write_result"
            },
            "code": "int write_string_to_file_000057d2(int file_descriptor, int flags, char *string, int string_length)\n{\n  int bytes_written = 0;\n  char *string_end = string + string_length;\n  while (string != string_end) {\n    if (string == string_end) {\n      return 0;\n    }\n    int write_result = __sfputc_r(file_descriptor, *string, flags, string_length, bytes_written);\n    bytes_written = write_result + 1;\n    string++;\n  }\n  return bytes_written;\n}",
            "called": [
                "__sfputc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057d2",
            "calling": [
                "_vfprintf_r"
            ],
            "imported": false,
            "current_name": "write_string_to_file_000057d2"
        },
        "FUN_00000958": {
            "renaming": {
                "FUN_00000958": "run_thread_00000958",
                "unaff_r4": "arg1",
                "unaff_r5": "arg2",
                "unaff_r6": "arg3",
                "unaff_r7": "arg4",
                "unaff_r8": "arg5",
                "unaff_r9": "arg6",
                "unaff_r10": "arg7",
                "unaff_r11": "arg8",
                "in_lr": "lr",
                "PTR_sched_active_thread_00000970": "active_thread",
                "PTR_sched_active_thread_0000098c": "active_thread",
                "getProcessStackPointer": "getProcessStackPointer",
                "setProcessStackPointer": "setProcessStackPointer",
                "isCurrentModePrivileged": "isCurrentModePrivileged",
                "isr_svc": "isr_svc",
                "sched_run": "sched_run"
            },
            "code": "void run_thread_00000958(void)\n{\n  bool is_privileged_mode;\n  int process_stack_ptr;\n  code *jumptable;\n  undefined4 arg1;\n  undefined4 arg2;\n  undefined4 arg3;\n  undefined4 arg4;\n  undefined4 arg5;\n  undefined4 arg6;\n  undefined4 arg7;\n  undefined4 arg8;\n  undefined4 lr;\n  code **PTR_sched_PTR_sched_active_thread_0000098c_00000970;\n  process_stack_ptr = getProcessStackPointer();\n  *(undefined4 *)(process_stack_ptr + -4) = lr;\n  *(undefined4 *)(process_stack_ptr + -8) = arg8;\n  *(undefined4 *)(process_stack_ptr + -0xc) = arg7;\n  *(undefined4 *)(process_stack_ptr + -0x10) = arg6;\n  *(undefined4 *)(process_stack_ptr + -0x14) = arg5;\n  *(undefined4 *)(process_stack_ptr + -0x18) = arg4;\n  *(undefined4 *)(process_stack_ptr + -0x1c) = arg3;\n  *(undefined4 *)(process_stack_ptr + -0x20) = arg2;\n  *(undefined4 *)(process_stack_ptr + -0x24) = arg1;\n  **(int **)PTR_sched_PTR_sched_active_thread_0000098c_00000970 = (int)(undefined4 *)(process_stack_ptr + -0x24);\n  isr_svc();\n  sched_run();\n  jumptable = *(code **)**(undefined4 **)PTR_sched_PTR_sched_active_thread_0000098c_00000970;\n  PTR_sched_PTR_sched_active_thread_0000098c_00000970 = (code **)**(undefined4 **)PTR_sched_PTR_sched_active_thread_0000098c_00000970 + 9;\n  is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    setProcessStackPointer(PTR_sched_PTR_sched_active_thread_0000098c_00000970);\n  }\n  (*jumptable)(jumptable,PTR_sched_PTR_sched_active_thread_0000098c_00000970);\n  return;\n}",
            "called": [
                "isr_svc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000958",
            "calling": [],
            "imported": false,
            "current_name": "run_thread_00000958"
        },
        "FUN_000056b8": {
            "renaming": {
                "FUN_000056b8": "check_file_permissions_000056b8",
                "param_1": "reent",
                "param_2": "file_descriptor",
                "param_3": "permissions",
                "param_4": "is_directory",
                "iVar1": "status",
                "uVar2": "mode",
                "sStack_68": "file_info"
            },
            "code": "int check_file_permissions_000056b8(_reent *reent, int file_descriptor, uint32_t *permissions, uint32_t *is_directory) {\n  int status;\n  uint32_t mode;\n  struct stat file_info;\n  if (*(short *)(file_descriptor + 0xe) < 0 || (status = _fstat_r(reent, (int)*(short *)(file_descriptor + 0xe), &file_info)) < 0) {\n    *is_directory = 0;\n    if ((int)((uint)*(ushort *)(file_descriptor + 0xc) << 0x18) < 0) {\n      *permissions = 0x40;\n      goto LAB_000056f8;\n    }\n  }\n  else {\n    *is_directory = (uint32_t)((file_info.st_mode & 0xf000) == 0x2000);\n  }\n  *permissions = 0x400;\nLAB_000056f8:\n  return 0;\n}",
            "called": [
                "_fstat_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b8",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_file_permissions_000056b8"
        },
        "FUN_00001a18": {
            "renaming": {
                "FUN_00001a18": "enable_pll_and_set_mode_to_4_00001a18",
                "DAT_00001a34": "pll_control_register",
                "PTR_current_mode_00001a38": "current_mode"
            },
            "code": "void enable_pll_and_set_mode_to_4_00001a18(void)\n{\n  set_bit_in_byte(DAT_DAT_00001a34, 0x01);\n  disable_pll();\n  *PTR_PTR_current_mode_00001a38 = 4;\n  return;\n}",
            "called": [
                "kinetis_mcg_disable_pll",
                "bit_set8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a18",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "enable_pll_and_set_mode_to_4_00001a18"
        },
        "FUN_00000d9c": {
            "renaming": {
                "FUN_00000d9c": "clearNullTerminator_00000d9c",
                "DAT_00000dac": "str"
            },
            "code": "void clearNullTerminator_00000d9c(char* DAT_00000dac) {\\n  bit_clear32(DAT_00000dac, \"\\0\");\\n  return;\\n}",
            "called": [
                "bit_clear32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d9c",
            "calling": [
                "pre_startup"
            ],
            "imported": false,
            "current_name": "clearNullTerminator_00000d9c"
        },
        "FUN_00003ff4": {
            "renaming": {
                "FUN_00003ff4": "pad_string_with_char_00003ff4",
                "out": "output",
                "in_len": "input_length",
                "pad_len": "padded_length",
                "pad_char": "padding_char",
                "sVar1": "padded_length_output",
                "n": "unused_variable"
            },
            "code": "size_t pad_string_with_char_00003ff4(char *output, size_t input_length, size_t padded_length, char padding_char) {\n  size_t padded_length_output;\n  if ((input_length < padded_length) && (output != (char *)0x0)) {\n    memmove(output + (padded_length - input_length), output, input_length);\n    memset(output, (uint)(byte)padding_char, padded_length - input_length);\n    padded_length_output = padded_length;\n  } else {\n    padded_length_output = input_length;\n  }\n  return padded_length_output;\n}",
            "called": [
                "memmove",
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ff4",
            "calling": [
                "fmt_s32_dfp"
            ],
            "imported": false,
            "current_name": "pad_string_with_char_00003ff4"
        },
        "FUN_00004634": {
            "renaming": {
                "FUN_00004634": "update_date_00004634",
                "param_1": "date",
                "param_2": "days",
                "param_3": "param_3",
                "puVar1": "days_in_month",
                "iVar2": "month_days",
                "uVar3": "new_month",
                "uVar4": "new_year",
                "iVar5": "month_days",
                "bVar6": "negative_days",
                "local_20": "current_date",
                "local_1c": "remaining_days",
                "uStack_18": "param_3"
            },
            "code": "void update_date_00004634(uint *date, uint days, undefined4 param_3)\n{\n  uint *current_date = date;\n  uint remaining_days = days;\n  undefined4 uStack_18 = param_3;\n  if (0x3b < *current_date) {\n    div((int)&current_date,*current_date);\n    uint new_month = current_date[1] + (int)current_date;\n    current_date[1] = new_month;\n    if ((int)remaining_days < 0) {\n      new_month = new_month - 1;\n      *current_date = remaining_days + 0x3c;\n    }\n    else {\n      *current_date = remaining_days;\n    }\n    if ((int)remaining_days < 0) {\n      current_date[1] = new_month;\n    }\n  }\n  if (0x3b < current_date[1]) {\n    div((int)&current_date,current_date[1]);\n    bool negative_days = (int)remaining_days < 0;\n    uint new_year = current_date[2] + (int)current_date;\n    current_date[2] = new_year;\n    uint new_month = remaining_days;\n    if (negative_days) {\n      new_month = remaining_days + 0x3c;\n      new_year = new_year - 1;\n    }\n    if (!negative_days) {\n      current_date[1] = new_month;\n    }\n    if (negative_days) {\n      current_date[1] = new_month;\n    }\n    if (negative_days) {\n      current_date[2] = new_year;\n    }\n  }\n  if (0x17 < current_date[2]) {\n    div((int)&current_date,current_date[2]);\n    bool negative_days = (int)remaining_days < 0;\n    uint new_year = current_date[3] + (int)current_date;\n    current_date[3] = new_year;\n    uint new_month = remaining_days;\n    if (negative_days) {\n      new_month = remaining_days + 0x18;\n      new_year = new_year - 1;\n    }\n    if (!negative_days) {\n      current_date[2] = new_month;\n    }\n    if (negative_days) {\n      current_date[2] = new_month;\n    }\n    if (negative_days) {\n      current_date[3] = new_year;\n    }\n  }\n  if (0xb < current_date[4]) {\n    div((int)&current_date,current_date[4]);\n    bool negative_days = (int)remaining_days < 0;\n    uint new_day = current_date[5] + (int)current_date;\n    current_date[5] = new_day;\n    if (negative_days) {\n      remaining_days = remaining_days + 0xc;\n      new_day = new_day - 1;\n    }\n    if (!negative_days) {\n      current_date[4] = remaining_days;\n    }\n    if (negative_days) {\n      current_date[4] = remaining_days;\n    }\n    if (negative_days) {\n      current_date[5] = new_day;\n    }\n  }\n  undefined *days_in_month = PTR_DAYS_IN_MONTH_000047e0;\n  uint current_year = current_date[5];\n  int month_days = 0x1d;\n  if ((current_year & 3) == 0) {\n    if (current_year == (current_year / 100) * 100) {\n      if ((current_year + 0x76c) % 400 == 0) {\n        month_days = 0x1d;\n      }\n      else {\n        month_days = 0x1c;\n      }\n    }\n    else {\n      month_days = 0x1d;\n    }\n  }\n  else {\n    month_days = 0x1c;\n  }\n  if ((int)current_date[3] < 1) {\n    while ((int)current_date[3] < 1) {\n      uint current_month = current_date[4];\n      current_date[4] = current_month - 1;\n      if (current_month - 1 == 0xffffffff) {\n        uint current_year = current_date[5];\n        uint new_year = current_year - 1;\n        current_date[4] = 0xb;\n        current_date[5] = new_year;\n        if ((new_year & 3) == 0) {\n          if (new_year % 100 == 0) {\n            if ((current_year + 0x76b) % 400 == 0) {\n              month_days = 0x1d;\n            }\n            else {\n              month_days = 0x1c;\n            }\n          }\n          else {\n            month_days = 0x1d;\n          }\n        }\n        else {\n          month_days = 0x1c;\n        }\n      }\n      int days_in_current_month = month_days;\n      if (current_date[4] != 1) {\n        days_in_current_month = *(int *)(days_in_month + current_date[4] * 4);\n      }\n      current_date[3] = days_in_current_month + current_date[3];\n    }\n  }\n  else {\n    while( true ) {\n      uint current_month = current_date[4];\n      int days_in_current_month = month_days;\n      if (current_month != 1) {\n        days_in_current_month = *(int *)(days_in_month + current_month * 4);\n      }\n      if ((int)current_date[3] <= days_in_current_month) break;\n      current_date[3] = current_date[3] - days_in_current_month;\n      current_date[4] = current_month + 1;\n      if (current_month + 1 == 0xc) {\n        uint current_year = current_date[5];\n        uint new_year = current_year + 1;\n        current_date[4] = 0;\n        current_date[5] = new_year;\n        if ((new_year & 3) == 0) {\n          if (new_year % 100 == 0) {\n            if ((current_year + 0x76d) % 400 == 0) {\n              month_days = 0x1d;\n            }\n            else {\n              month_days = 0x1c;\n            }\n          }\n          else {\n            month_days = 0x1d;\n          }\n        }\n        else {\n          month_days = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "div"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004634",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "update_date_00004634"
        },
        "FUN_00001d5e": {
            "renaming": {
                "FUN_00001d5e": "get_port_from_gpio_00001d5e",
                "pin": "gpio_pin",
                "PORT_Type": "PORT_Type",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "PORT_Type* get_port_from_gpio_00001d5e(gpio_t gpio_pin) {\n  const uint32_t PORT_BASE_ADDRESS = 0x40048000;\n  const uint32_t GPIO_PIN_MASK = 0x7000;\n  return (PORT_Type*)((uint32_t)gpio_pin & GPIO_PIN_MASK | PORT_BASE_ADDRESS);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d5e",
            "calling": [
                "gpio_init_port",
                "gpio_init"
            ],
            "imported": false,
            "current_name": "get_port_from_gpio_00001d5e"
        },
        "FUN_0000191c": {
            "renaming": {
                "FUN_0000191c": "enableOscillatorAndSetFllFactor_0000191c",
                "DAT_00001958": "statusRegister",
                "PTR_current_mode_0000195c": "currentModePtr",
                "KINETIS_MCG_FLL_FACTOR_1920": "FLL_FACTOR_1920"
            },
            "code": "void enableOscillatorAndSetFllFactor_0000191c(void)\n{\n  enableOscillator();\n  setFllFactor(FLL_FACTOR_1920);\n  *DAT_00001958 = *DAT_00001958 & 0x3b;\n  do {\n  } while ((DAT_00001958[6] & 0xc) != 0);\n  *PTR_current_mode_0000195c = 1;\n  return;\n}",
            "called": [
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000191c",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "enableOscillatorAndSetFllFactor_0000191c"
        },
        "FUN_000050f4": {
            "renaming": {
                "FUN_000050f4": "releaseTimezoneMutex_000050f4",
                "PTR___lock___tz_mutex_000050fc": "tz_mutex_lock"
            },
            "code": "void releaseTimezoneMutex_000050f4(void)\n{\n  __retarget_lock_release(PTR___lock___tz_mutex_000050fc);\n  return;\n}",
            "called": [
                "__retarget_lock_release"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050f4",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "releaseTimezoneMutex_000050f4"
        },
        "FUN_00000c80": {
            "renaming": {
                "FUN_00000c80": "handle_memory_management_00000c80",
                "PTR_s_MEM_MANAGE_HANDLER_00000c8c": "MEM_MANAGE_HANDLER"
            },
            "code": "void handle_memory_management_00000c80(void)\n{\n    // This function handles memory management panic\n    core_panic(PANIC_MEM_MANAGE, PTR_s_MEM_MANAGE_HANDLER_00000c8c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000c80",
            "calling": [],
            "imported": false,
            "current_name": "handle_memory_management_00000c80"
        },
        "FUN_00000a40": {
            "renaming": {
                "FUN_00000a40": "calculateStackOffset_00000a40",
                "auStack_18": "stackFrame",
                "sp": "stackPointer"
            },
            "code": "int calculateStackOffset_00000a40(uint32_t required)\n{\n  undefined stackFrame[12];\n  uint32_t *stackPointer;\n  \n  stackPointer = &stackFrame[0];\n  return (int)(stackPointer + (-(int)PTR_isr_stack_00000a60 - required));\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a40",
            "calling": [
                "hard_fault_handler"
            ],
            "imported": false,
            "current_name": "calculateStackOffset_00000a40"
        },
        "FUN_00005a58": {
            "renaming": {
                "FUN_00005a58": "decode_message_00005a58",
                "param_1": "message_start",
                "param_2": "message_ptr",
                "param_3": "message_end",
                "param_4": "param_4",
                "param_5": "decoder_function",
                "uVar2": "return_value",
                "uVar3": "max_byte_count",
                "uVar4": "current_byte_count",
                "bVar5": "is_type_4",
                "iVar1": "byte_count"
            },
            "code": "undefined4 decode_message_00005a58(undefined4 message_start, uint *message_ptr, uint *message_end, undefined4 param_4, code *decoder_function)\n{\n  int byte_count;\n  undefined4 return_value;\n  uint max_byte_count;\n  uint current_byte_count;\n  bool is_type_4;\n  \n  max_byte_count = message_ptr[4];\n  if ((int)message_ptr[4] < (int)message_ptr[2]) {\n    max_byte_count = message_ptr[2];\n  }\n  *message_end = max_byte_count;\n  if (*(char *)((int)message_ptr + 0x43) != '\\0') {\n    *message_end = max_byte_count + 1;\n  }\n  if ((int)(*message_ptr << 0x1a) < 0) {\n    *message_end = *message_end + 2;\n  }\n  current_byte_count = *message_ptr & 6;\n  if (current_byte_count == 0) {\n    for (; (int)current_byte_count < (int)(message_ptr[3] - *message_end); current_byte_count = current_byte_count + 1) {\n      byte_count = (*decoder_function)(message_start, param_4, (int)message_ptr + 0x19, 1);\n      if (byte_count == -1) goto LAB_00005afc;\n    }\n  }\n  current_byte_count = (uint)*(byte *)((int)message_ptr + 0x43);\n  if (current_byte_count != 0) {\n    current_byte_count = 1;\n  }\n  if ((int)(*message_ptr << 0x1a) < 0) {\n    *(undefined *)((int)message_ptr + current_byte_count + 0x43) = 0x30;\n    *(undefined *)((int)message_ptr + current_byte_count + 0x44) = *(undefined *)((int)message_ptr + 0x45);\n    current_byte_count = current_byte_count + 2;\n  }\n  byte_count = (*decoder_function)(message_start, param_4, (int)message_ptr + 0x43, current_byte_count);\n  if (byte_count == -1) {\nLAB_00005afc:\n    return_value = 0xffffffff;\n  }\n  else {\n    is_type_4 = (*message_ptr & 6) == 4;\n    current_byte_count = message_ptr[3];\n    if (is_type_4) {\n      current_byte_count = current_byte_count - *message_end;\n    }\n    if (is_type_4) {\n      current_byte_count = current_byte_count & ~((int)current_byte_count >> 0x1f);\n    }\n    else {\n      current_byte_count = 0;\n    }\n    if ((int)message_ptr[4] < (int)message_ptr[2]) {\n      current_byte_count = current_byte_count + (message_ptr[2] - message_ptr[4]);\n    }\n    for (uint i = 0; current_byte_count != i; i = i + 1) {\n      byte_count = (*decoder_function)(message_start, param_4, (int)message_ptr + 0x1a, 1);\n      if (byte_count == -1) goto LAB_00005afc;\n    }\n    return_value = 0;\n  }\n  return return_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005a58",
            "calling": [
                "_printf_i"
            ],
            "imported": false,
            "current_name": "decode_message_00005a58"
        },
        "FUN_000056b0": {
            "renaming": {
                "FUN_000056b0": "get_timezone_info_000056b0",
                "PTR_tzinfo_000056b4": "timezone_info_ptr"
            },
            "code": "const char* get_timezone_info_000056b0(void)\n{\n  return PTR_tzinfo_000056b4;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b0",
            "calling": [
                "_tzset_unlocked_r",
                "__tzcalc_limits",
                "mktime"
            ],
            "imported": false,
            "current_name": "get_timezone_info_000056b0"
        },
        "FUN_00003d24": {
            "renaming": {
                "FUN_00003d24": "get_saul_reg_at_position_00003d24",
                "pos": "position",
                "i": "current_position",
                "tmp": "current_saul_reg"
            },
            "code": "saul_reg_t get_saul_reg_at_position_00003d24(int position) {\n  int current_position = 0;\n  saul_reg_t *current_saul_reg = *(saul_reg_t **)PTR_saul_reg_00003d60;\n  \n  while (current_position < position && current_saul_reg != (saul_reg_t *)0x0) {\n    current_saul_reg = current_saul_reg->next;\n    current_position++;\n  }\n  \n  return current_saul_reg;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d24",
            "calling": [
                "read",
                "write"
            ],
            "imported": false,
            "current_name": "get_saul_reg_at_position_00003d24"
        },
        "FUN_000060cc": {
            "renaming": {
                "FUN_000060cc": "allocate_memory_000060cc",
                "param_1": "size",
                "param_2": "ptr1",
                "param_3": "ptr2",
                "param_4": "param",
                "pvVar1": "new_ptr",
                "pvVar2": "usable_ptr_size"
            },
            "code": "void * allocate_memory_000060cc(size_t size, void *ptr1, void *ptr2, size_t param)\n{\n  void *new_ptr;\n  void *usable_ptr_size;\n  \n  if (ptr1 != NULL) {\n    if (ptr2 == NULL) {\n      free(ptr2);\n      new_ptr = ptr2;\n    }\n    else {\n      usable_ptr_size = malloc_usable_size(ptr1);\n      new_ptr = ptr1;\n      if ((usable_ptr_size < ptr2) && (new_ptr = malloc(size), new_ptr != NULL)) {\n        memcpy(new_ptr, ptr1, (size_t)ptr2);\n        free(ptr1);\n      }\n    }\n    return new_ptr;\n  }\n  new_ptr = malloc(size);\n  return new_ptr;\n}",
            "called": [
                "memcpy",
                "_malloc_usable_size_r",
                "_malloc_r",
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060cc",
            "calling": [
                "__submore"
            ],
            "imported": false,
            "current_name": "allocate_memory_000060cc"
        },
        "FUN_000022be": {
            "renaming": {
                "FUN_000022be": "write_to_ring_buffer_000022be",
                "rb": "ring_buffer",
                "c": "data",
                "uVar1": "current_writes",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "void write_to_ring_buffer_000022be(tsrb_t *ring_buffer, char data) {\n  uint32_t current_writes = ring_buffer->writes;\n  ring_buffer->writes = current_writes + 1;\n  uint32_t buffer_size = ring_buffer->size;\n  uint32_t buffer_index = current_writes & (buffer_size - 1);\n  ring_buffer->buf[buffer_index] = data;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022be",
            "calling": [
                "tsrb_add_one"
            ],
            "imported": false,
            "current_name": "write_to_ring_buffer_000022be"
        },
        "FUN_00003dc4": {
            "renaming": {
                "FUN_00003dc4": "calculate_num_digits_00003dc4",
                "out": "output_str",
                "val": "value",
                "local_20": "remainder",
                "ptr": "curr_char_ptr",
                "tmp": "divisor",
                "len": "num_digits"
            },
            "code": "size_t calculate_num_digits_00003dc4(char *output_str, uint32_t value) {\n  uint32_t divisor;\n  char *curr_char_ptr;\n  uint32_t remainder;\n  size_t num_digits = 1;\n  if (DAT_00003e50 < value) {\n    num_digits = 10;\n  }\n  else {\n    for (divisor = 10; divisor <= value; divisor *= 10) {\n      num_digits++;\n    }\n  }\n  if (output_str != (char *)0x0) {\n    curr_char_ptr = output_str + num_digits;\n    remainder = value;\n    do {\n      curr_char_ptr--;\n      *curr_char_ptr = (char)remainder + ((char)(uint)((ulonglong)DAT_00003e54 * (ulonglong)remainder >> 0x23) * -10) + '0';\n      remainder = (uint32_t)((ulonglong)DAT_00003e54 * (ulonglong)remainder >> 0x23);\n    } while (remainder != 0);\n  }\n  return num_digits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003dc4",
            "calling": [
                "fmt_s32_dec"
            ],
            "imported": false,
            "current_name": "calculate_num_digits_00003dc4"
        },
        "FUN_00002108": {
            "renaming": {
                "FUN_00002108": "handle_interrupt_00002108",
                "DAT_00002118": "interrupt_number"
            },
            "code": "void handle_interrupt_00002108(void)\n{\n  int DAT_00002118 = DAT_00002118;\n  int interrupt_priority = 4;\n  irq_handler(DAT_00002118, interrupt_priority);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002108",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_00002108"
        },
        "FUN_00000c90": {
            "renaming": {
                "FUN_00000c90": "handle_bus_fault_00000c90",
                "PTR_s_BUS_FAULT_HANDLER_00000c9c": "bus_fault_handler"
            },
            "code": "void handle_bus_fault_00000c90(void)\n{\n    /* WARNING: Subroutine does not return */\n    core_panic(PANIC_BUS_FAULT, PTR_s_BUS_FAULT_HANDLER_00000c9c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000c90",
            "calling": [],
            "imported": false,
            "current_name": "handle_bus_fault_00000c90"
        },
        "FUN_00001d80": {
            "renaming": {
                "FUN_00001d80": "get_gpio_from_pin_num_00001d80",
                "pin": "pin_num",
                "GPIO_Type": "gpio_ptr",
                "GPIO_BASE_ADDRESS": "GPIO_BASE_ADDRESS",
                "PIN_MASK": "PIN_MASK",
                "gpio_address": "gpio_address"
            },
            "code": "GPIO_Type* get_gpio_from_pin_num_00001d80(get_gpio_from_pin_num_00001d80_t pin_num) {\n    const uint32_t GPIO_BASE_ADDRESS = 0x400ff000;\n    const uint32_t PIN_MASK = 0x1c0;\n    uint32_t gpio_address = (pin_num & PIN_MASK) | GPIO_BASE_ADDRESS;\n    return (GPIO_Type *)gpio_address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d80",
            "calling": [
                "gpio_init",
                "gpio_set"
            ],
            "imported": false,
            "current_name": "get_gpio_from_pin_num_00001d80"
        },
        "FUN_000033c0": {
            "renaming": {
                "FUN_000033c0": "get_rtc_alarm_status_000033c0",
                "iVar1": "alarm_status",
                "t": "current_time",
                "rtc_get_alarm": "get_rtc_alarm",
                "_print_time": "print_time"
            },
            "code": "int get_rtc_alarm_status_000033c0(void)\n{\n  int alarm_status;\n  tm current_time;\n  alarm_status = rtc_get_alarm(&current_time);\n  if (alarm_status != 0) {\n    puts(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else {\n    print_time(&current_time);\n  }\n  return (uint)(alarm_status != 0);\n}",
            "called": [
                "rtc_get_alarm",
                "_print_time",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033c0",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "get_rtc_alarm_status_000033c0"
        },
        "FUN_00002b10": {
            "renaming": {
                "FUN_00002b10": "parse_shell_command_00002b10",
                "command_list": "cmd",
                "line": "line",
                "local_48": "line_pos",
                "local_44": "cmd",
                "handler": "handler",
                "argv": "args",
                "local_34": "MAX_ARGS",
                "quote_char": "quote_char",
                "d": "d",
                "c": "c",
                "arg": "arg",
                "i": "i",
                "contains_esc_seq": "contains_esc_seq",
                "argc": "arg_count",
                "pos": "pos"
            },
            "code": "void parse_shell_command_00002b10(shell_command_t *command_list,char *line)\n{\n  int arg_count = 0;\n  char *line_pos = line;\n  int contains_esc_seq = 0;\n  char quote_char;\n  char **args;\n  uint i;\n  char *pos;\n  shell_command_t *cmd;\n  shell_command_handler_t handler;\n  \n  cmd = command_list;\n  args = (char **) malloc(sizeof(char *) * MAX_ARGS);\n  \n  while( true ) {\n    if (0x20 < (byte)*line_pos) {\n      if ((*line_pos == \"\\\"\") || (*line_pos == \"\\\"\")) {\n        quote_char = *line_pos;\n        do {\n          line_pos++;\n          if (*line_pos == \"\\0\") {\n            puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\n            return;\n          }\n          if (*line_pos == \"\\\") {\n            contains_esc_seq++;\n            line_pos++;\n            if (*line_pos == \"\\0\") {\n              puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\n              return;\n            }\n          }\n        } while (quote_char != *line_pos);\n        if (0x20 < (byte)line_pos[1]) {\n          puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\n          return;\n        }\n      }\n      else {\n        do {\n          if (*line_pos == \"\\\") {\n            contains_esc_seq++;\n            line_pos++;\n            if (*line_pos == \"\\0\") {\n              puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\n              return;\n            }\n          }\n          line_pos++;\n          if (*line_pos == 0x22) {\n            puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\n            return;\n          }\n        } while (0x20 < (byte)*line_pos);\n      }\n      arg_count++;\n    }\n    if (*line_pos == \"\\0\") break;\n    *line_pos = \"\\0\";\n    line_pos++;\n  }\n  \n  if (arg_count != 0) {\n    args[arg_count] = (char *)0x0;\n    pos = line;\n    for (i = 0; i < arg_count; i++) {\n      for (; *pos == \"\\0\"; pos++) {\n      }\n      if ((*pos == \"\\\"\") || (*pos == \"\\\"\")) {\n        pos++;\n      }\n      args[i] = pos;\n      for (; *pos != \"\\0\"; pos++) {\n      }\n    }\n    \n    for (char **arg = args; (contains_esc_seq != 0 && (*arg != (char *)0x0)); arg++) {\n      for (char *c = *arg; *c != \"\\0\"; c++) {\n        if (*c == \"\\\") {\n          for (char *d = c; *d != \"\\0\"; d++) {\n            *d = d[1];\n          }\n          contains_esc_seq--;\n          if (contains_esc_seq == 0) break;\n        }\n      }\n    }\n    \n    handler = find_handler(command_list,*args);\n    if (handler == (shell_command_handler_t)0x0) {\n      int cmp = strcmp(PTR_DAT_00002d8c,*args);\n      if (cmp == 0) {\n        print_help(cmd);\n      }\n      else {\n        iprintf(PTR_s_shell__command_not_found___s_00002d90,*args);\n      }\n    }\n    else {\n      (*handler)(arg_count,args);\n    }\n  }\n  free(args);\n  return;\n}",
            "called": [
                "print_help",
                "strcmp",
                "iprintf",
                "puts",
                "find_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002b10",
            "calling": [
                "shell_run"
            ],
            "imported": false,
            "current_name": "parse_shell_command_00002b10"
        },
        "FUN_00001b10": {
            "renaming": {
                "FUN_00001b10": "set_kinetis_mcg_mode_00001b10",
                "mode": "mode",
                "iVar1": "result",
                "PTR_mcg_mode_routing_00001bb4": "mcg_mode_routing",
                "PTR_current_mode_00001bb0": "current_mode",
                "KINETIS_MCG_MODE_NUMOF": "MCU_MODE_NUMOF",
                "KINETIS_MCG_MODE_FEI": "MCU_MODE_FEI",
                "KINETIS_MCG_MODE_FEE": "MCU_MODE_FEE",
                "KINETIS_MCG_MODE_FBI": "MCU_MODE_FBI",
                "KINETIS_MCG_MODE_FBE": "MCU_MODE_FBE",
                "KINETIS_MCG_MODE_BLPI": "MCU_MODE_BLPI",
                "KINETIS_MCG_MODE_BLPE": "MCU_MODE_BLPE",
                "KINETIS_MCG_MODE_PBE": "MCU_MODE_PBE",
                "KINETIS_MCG_MODE_PEE": "MCU_MODE_PEE"
            },
            "code": "int set_kinetis_mcg_mode_00001b10(kinetis_mcg_mode_t mode) {\n  int result;\n  if (mode < KINETIS_MCG_MODE_NUMOF) {\n    do {\n      uint8_t index = (uint8_t)*PTR_PTR_current_mode_00001bb0_00001bb0 * 8 + (uint8_t)mode;\n      switch(PTR_PTR_mcg_mode_routing_00001bb4_00001bb4[index])\n      {\n      case KINETIS_MCG_MODE_FEI:\n        kinetis_mcg_set_fei();\n        break;\n      case KINETIS_MCG_MODE_FEE:\n        kinetis_mcg_set_fee();\n        break;\n      case KINETIS_MCG_MODE_FBI:\n        kinetis_mcg_set_fbi();\n        break;\n      case KINETIS_MCG_MODE_FBE:\n        kinetis_mcg_set_fbe();\n        break;\n      case KINETIS_MCG_MODE_BLPI:\n        kinetis_mcg_set_blpi();\n        break;\n      case KINETIS_MCG_MODE_BLPE:\n        kinetis_mcg_set_blpe();\n        break;\n      case KINETIS_MCG_MODE_PBE:\n        kinetis_mcg_set_pbe();\n        break;\n      case KINETIS_MCG_MODE_PEE:\n        kinetis_mcg_set_pee();\n        break;\n      default:\n        return -1;\n      }\n    } while (mode != *PTR_PTR_current_mode_00001bb0_00001bb0);\n    result = 0;\n  }\n  else {\n    result = -1;\n  }\n  return result;\n}",
            "called": [
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_blpi",
                "kinetis_mcg_set_blpe",
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_pee",
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fee"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001b10",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "set_kinetis_mcg_mode_00001b10"
        },
        "FUN_000047e4": {
            "renaming": {
                "FUN_000047e4": "FUNC_000047e4"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\ntime_t FUNC_000047e4(tm *__tp)\n\n{\n  longlong lVar1;\n  int *piVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  int iVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  uint uVar14;\n  time_t tVar15;\n  bool bVar16;\n  \n  piVar2 = (int *)__gettzinfo();\n  validate_structure(__tp);\n  uVar11 = __tp->tm_year;\n  iVar10 = __tp->tm_mday + -1 + *(int *)(PTR__DAYS_BEFORE_MONTH_00004adc + __tp->tm_mon * 4);\n  if (((1 < __tp->tm_mon) && ((uVar11 & 3) == 0)) &&\n     ((uVar11 != (uVar11 / 100) * 100 || (uVar11 + 0x76c == ((uVar11 + 0x76c) / 400) * 400)))) {\n    iVar10 = iVar10 + 1;\n  }\n  __tp->tm_yday = iVar10;\n  if (20000 < (int)&PTR_rtc_callback_00002710 + uVar11) {\n    return -1;\n  }\n  if ((int)uVar11 < 0x47) {\n    if (uVar11 != 0x46) {\n      for (uVar8 = 0x45; (int)uVar11 < (int)uVar8; uVar8 = uVar8 - 1) {\n        if ((uVar8 & 3) == 0) {\n          if (uVar8 == (uVar8 / 100) * 100) {\n            if ((uVar8 + 0x76c) % 400 == 0) {\n              iVar6 = 0x16e;\n            }\n            else {\n              iVar6 = 0x16d;\n            }\n          }\n          else {\n            iVar6 = 0x16e;\n          }\n        }\n        else {\n          iVar6 = 0x16d;\n        }\n        iVar10 = iVar10 - iVar6;\n      }\n      if ((uVar8 & 3) == 0) {\n        if (uVar11 == (uVar11 / 100) * 100) {\n          iVar6 = 0x16d;\n          if ((uVar11 + 0x76c) % 400 == 0) {\n            iVar6 = 0x16e;\n          }\n        }\n        else {\n          iVar6 = 0x16e;\n        }\n      }\n      else {\n        iVar6 = 0x16d;\n      }\n      iVar10 = iVar10 - iVar6;\n    }\n  }\n  else {\n    uVar8 = 0x46;\n    do {\n      if ((uVar8 & 3) == 0) {\n        if (uVar8 % 100 == 0) {\n          if ((uVar8 + 0x76c) % 400 == 0) {\n            iVar6 = 0x16e;\n          }\n          else {\n            iVar6 = 0x16d;\n          }\n        }\n        else {\n          iVar6 = 0x16e;\n        }\n      }\n      else {\n        iVar6 = 0x16d;\n      }\n      uVar8 = uVar8 + 1;\n      iVar10 = iVar10 + iVar6;\n    } while (uVar11 != uVar8);\n  }\n  lVar1 = (longlong)DAT_00004ae0 * (longlong)iVar10 +\n          (longlong)(__tp->tm_hour * 0xe10 + __tp->tm_min * 0x3c + __tp->tm_sec);\n  uVar14 = (uint)lVar1;\n  iVar6 = (int)((ulonglong)lVar1 >> 0x20);\n  __tz_lock();\n  _tzset_unlocked();\n  uVar8 = *(uint *)PTR__daylight_00004ae4;\n  if (*(uint *)PTR__daylight_00004ae4 == 0) {\nLAB_00004934:\n    tVar15 = uVar14 + piVar2[10];\n  }\n  else {\n    uVar13 = __tp->tm_isdst;\n    uVar12 = uVar13;\n    if (0 < (int)uVar13) {\n      uVar12 = 1;\n    }\n    if ((piVar2[1] == __tp->tm_year + 0x76c) || (iVar4 = __tzcalc_limits(), iVar4 != 0)) {\n      uVar9 = piVar2[0x14];\n      uVar3 = piVar2[0x12];\n      uVar7 = piVar2[10];\n      uVar8 = uVar3 - uVar7;\n      iVar4 = (piVar2[0x13] - ((int)uVar7 >> 0x1f)) - (uint)(uVar3 < uVar7);\n      if (((int)((iVar6 - iVar4) - (uint)(uVar14 < uVar8)) < 0 ==\n           (SBORROW4(iVar6,iVar4) != SBORROW4(iVar6 - iVar4,(uint)(uVar14 < uVar8)))) &&\n         (iVar5 = (piVar2[0x13] - ((int)uVar9 >> 0x1f)) - (uint)(uVar3 < uVar9),\n         bVar16 = uVar14 < uVar3 - uVar9,\n         (int)((iVar6 - iVar5) - (uint)bVar16) < 0 !=\n         (SBORROW4(iVar6,iVar5) != SBORROW4(iVar6 - iVar5,(uint)bVar16)))) goto LAB_00004a88;\n      uVar3 = piVar2[8] - uVar9;\n      iVar5 = (piVar2[9] - ((int)uVar9 >> 0x1f)) - (uint)((uint)piVar2[8] < uVar9);\n      if (*piVar2 != 0) {\n        if ((int)((iVar6 - iVar5) - (uint)(uVar14 < uVar3)) < 0 ==\n            (SBORROW4(iVar6,iVar5) != SBORROW4(iVar6 - iVar5,(uint)(uVar14 < uVar3))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        uVar8 = 0;\n        if ((int)uVar13 < 0) goto LAB_00004934;\nLAB_00004a14:\n        uVar13 = uVar12 ^ uVar8;\n        uVar12 = uVar8;\n        if (uVar13 == 1) {\n          if (uVar8 == 0) {\n            iVar6 = uVar9 - uVar7;\n          }\n          else {\n            iVar6 = uVar7 - uVar9;\n          }\n          iVar4 = __tp->tm_mday;\n          uVar14 = uVar14 + iVar6;\n          __tp->tm_sec = __tp->tm_sec + iVar6;\n          validate_structure(__tp);\n          iVar4 = __tp->tm_mday - iVar4;\n          if (iVar4 != 0) {\n            if (iVar4 < 2) {\n              if (iVar4 == -2 || iVar4 + 2 < 0 != SCARRY4(iVar4,2)) {\n                iVar4 = 1;\n              }\n            }\n            else {\n              iVar4 = -1;\n            }\n            iVar6 = iVar4 + __tp->tm_yday;\n            iVar10 = iVar10 + iVar4;\n            if (iVar6 < 0) {\n              uVar8 = uVar11 - 1;\n              if ((uVar8 & 3) == 0) {\n                if (uVar8 == (uVar8 / 100) * 100) {\n                  iVar6 = 0x16d;\n                  if ((uVar11 + 0x76b) % 400 != 0) {\n                    iVar6 = 0x16c;\n                  }\n                }\n                else {\n                  iVar6 = 0x16d;\n                }\n              }\n              else {\n                iVar6 = 0x16c;\n              }\n            }\n            else {\n              if ((uVar11 & 3) == 0) {\n                if (uVar11 == (uVar11 / 100) * 100) {\n                  iVar4 = 0x16d;\n                  if ((uVar11 + 0x76c) % 400 == 0) {\n                    iVar4 = 0x16e;\n                  }\n                }\n                else {\n                  iVar4 = 0x16e;\n                }\n              }\n              else {\n                iVar4 = 0x16d;\n              }\n              if (iVar4 <= iVar6) {\n                iVar6 = iVar6 - iVar4;\n              }\n            }\n            __tp->tm_yday = iVar6;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((iVar6 - iVar5) - (uint)(uVar14 < uVar3)) < 0 !=\n          (SBORROW4(iVar6,iVar5) != SBORROW4(iVar6 - iVar5,(uint)(uVar14 < uVar3)))) {\nLAB_0000491e:\n        if ((int)((iVar6 - iVar4) - (uint)(uVar14 < uVar8)) < 0 ==\n            (SBORROW4(iVar6,iVar4) != SBORROW4(iVar6 - iVar4,(uint)(uVar14 < uVar8))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)uVar13) {\n        uVar8 = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      uVar8 = uVar12;\n      if (uVar12 != 1) goto LAB_00004934;\n    }\n    tVar15 = uVar14 + piVar2[0x14];\n    uVar8 = 1;\n  }\n  __tz_unlock();\n  __tp->tm_isdst = uVar8;\n  __tp->tm_wday = (iVar10 + 4U) % 7;\n  return tVar15;\n}\n\n",
            "called": [
                "_tzset_unlocked",
                "__tzcalc_limits",
                "__tz_unlock",
                "__tz_lock",
                "__gettzinfo",
                "validate_structure"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000047e4",
            "calling": [
                "rtc_set_time",
                "rtc_set_alarm"
            ],
            "imported": false,
            "current_name": "FUNC_000047e4"
        },
        "FUN_000023c8": {
            "renaming": {
                "FUN_000023c8": "execute_system_call_000023c8",
                "a0": "system_call_number",
                "a1": "argument",
                "a2": "error_code"
            },
            "code": "uint32_t execute_system_call_000023c8(uint32_t system_call_number, uint32_t argument, int32_t error_code) {\n  software_interrupt(system_call_number);\n  return argument;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023c8",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "execute_system_call_000023c8"
        },
        "FUN_00002e48": {
            "renaming": {
                "FUN_00002e48": "print_greater_than_sign_space_00002e48",
                "PTR__impure_ptr_00002e68": "impure_ptr"
            },
            "code": "void print_greater_than_sign_space_00002e48(void)\n{\n  int* PTR__impure_ptr_00002e68 = *(int*)PTR__PTR__impure_ptr_00002e68_00002e68;\n  FILE** file_ptr = (FILE**)(PTR__impure_ptr_00002e68 + 8);\n  _putchar('>');\n  _putchar(' ');\n  fflush(*file_ptr);\n  return;\n}",
            "called": [
                "_putchar",
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e48",
            "calling": [
                "shell_run"
            ],
            "imported": false,
            "current_name": "print_greater_than_sign_space_00002e48"
        },
        "FUN_00000930": {
            "renaming": {
                "FUN_00000930": "enable_interrupt_and_trigger_software_interrupt_00000930",
                "irq_enable": "enable_interrupt",
                "software_interrupt": "trigger_software_interrupt"
            },
            "code": "void enable_interrupt_and_trigger_software_interrupt_00000930(void)\n{\n  enable_interrupt();\n  trigger_software_interrupt(1);\n  while( true );\n}",
            "called": [
                "irq_enable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000930",
            "calling": [
                "sched_task_exit",
                "kernel_init"
            ],
            "imported": false,
            "current_name": "enable_interrupt_and_trigger_software_interrupt_00000930"
        },
        "FUN_00001348": {
            "renaming": {
                "FUN_00001348": "check_for_context_switch_request_00001348",
                "PTR_sched_context_switch_request_0000135c": "context_switch_request_ptr"
            },
            "code": "void check_for_context_switch_request_00001348(void)\n{\n  int* PTR_sched_context_switch_request_0000135c = (int*)PTR_sched_context_switch_request_0000135c;\n  if (*PTR_sched_context_switch_request_0000135c != 0)\n  {\n    thread_yield_higher();\n  }\n  return;\n}",
            "called": [
                "thread_yield_higher"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001348",
            "calling": [
                "irq_handler_uart"
            ],
            "imported": false,
            "current_name": "check_for_context_switch_request_00001348"
        },
        "FUN_00006118": {
            "renaming": {
                "FUN_00006118": "append_character_00006118",
                "param_1": "prev_char",
                "param_2": "current_char",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "uVar2": "buffer_end",
                "uVar3": "buffer_start",
                "iVar1": "index"
            },
            "code": "uint append_character_00006118(uint prev_char, uint current_char, uint *buffer, uint buffer_size)\n{\n  int index;\n  uint buffer_end;\n  uint buffer_start;\n  \n  if (current_char == 0xffffffff) {\n    buffer_end = 0xffffffff;\n  }\n  else {\n    *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) & 0xffdf;\n    buffer_end = buffer[1];\n    current_char = current_char & 0xff;\n    if (buffer[0xd] == 0) {\n      buffer_start = *buffer;\n      if (((buffer[4] != 0) && (buffer[4] < buffer_start)) && (*(byte *)(buffer_start - 1) == current_char)) {\n        *buffer = buffer_start - 1;\n        buffer[1] = buffer_end + 1;\n        return current_char;\n      }\n      buffer[0xf] = buffer_start;\n      buffer[0x10] = buffer_end;\n      buffer[0xd] = (uint)(buffer + 0x11);\n      buffer[0xe] = 3;\n      *(undefined *)((int)buffer + 0x46) = (char)current_char;\n      *buffer = (uint)(undefined *)((int)buffer + 0x46);\n      buffer_end = 1;\n    }\n    else {\n      if (((int)buffer[0xe] <= (int)buffer_end) &&\n         (index = __submore(prev_char, buffer, buffer_end, buffer[0xe], buffer_size), index != 0))\n      goto LAB_00006120;\n      buffer_start = *buffer;\n      *buffer = buffer_start - 1;\n      *(char *)(buffer_start - 1) = (char)current_char;\n      buffer_end = buffer[1] + 1;\n    }\n    buffer[1] = buffer_end;\n  }\n  return current_char;\n}",
            "called": [
                "__submore"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006118",
            "calling": [],
            "imported": false,
            "current_name": "append_character_00006118"
        },
        "FUN_00001d3a": {
            "renaming": {
                "FUN_00001d3a": "set_bit_00001d3a",
                "ptr": "address",
                "bit": "bit_position",
                "puVar1": "bit_address"
            },
            "code": "void set_bit_00001d3a(uint32_t *address, uint8_t bit_position)\n{\n  uint32_t *bit_address = (uint32_t *)(0x42000000 + ((uint32_t)address - 0x40000000) * 32 + bit_position * 4);\n  *bit_address = 1;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d3a",
            "calling": [
                "clk_en"
            ],
            "imported": false,
            "current_name": "set_bit_00001d3a"
        },
        "FUN_00002434": {
            "renaming": {
                "FUN_00002434": "acquire_mutex_00002434",
                "mutex": "mutex",
                "blocking": "blocking",
                "state": "irq_disabled_state",
                "iVar1": "mutex_acquired",
                "process": "current_thread",
                "irqstate": "irq_enabled_state",
                "me": "me"
            },
            "code": "int acquire_mutex_00002434(mutex_t *mutex, int blocking) {\n  uint irq_disabled_state;\n  int mutex_acquired;\n  thread_t *current_thread;\n  uint irq_enabled_state;\n  thread_t *me;\n  irq_disabled_state = irq_disable();\n  if (mutex->wait_queue.next == (list_node *)0x0) {\n    mutex->wait_queue.next = (list_node *)0xffffffff;\n    irq_restore(irq_disabled_state);\n    mutex_acquired = 1;\n  }\n  else if (blocking == 0) {\n    irq_restore(irq_disabled_state);\n    mutex_acquired = 0;\n  }\n  else {\n    current_thread = *(thread_t **)PTR_sched_active_thread_000024b8;\n    sched_set_status(current_thread, THREAD_BLOCKED);\n    if (mutex->wait_queue.next == (list_node *)0xffffffff) {\n      mutex->wait_queue.next = &current_thread->rq_entry;\n      mutex->wait_queue.next->next = (list_node *)0x0;\n    }\n    else {\n      thread_add_to_list(&mutex->wait_queue, current_thread);\n    }\n    irq_restore(irq_disabled_state);\n    thread_yield_higher();\n    mutex_acquired = 1;\n  }\n  return mutex_acquired;\n}",
            "called": [
                "thread_add_to_list",
                "irq_disable",
                "thread_yield_higher",
                "irq_restore",
                "sched_set_status"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002434",
            "calling": [
                "mutex_lock"
            ],
            "imported": false,
            "current_name": "acquire_mutex_00002434"
        },
        "FUN_00005700": {
            "renaming": {
                "FUN_00005700": "initialize_buffer_00005700",
                "param_1": "reent",
                "param_2": "buffer",
                "uVar1": "whatbuf_r_value",
                "iVar2": "allocated_buffer",
                "local_18": "local_reent",
                "local_14": "local_buffer"
            },
            "code": "void initialize_buffer_00005700(_reent *reent, int *buffer){\n  ushort flags = *(ushort *)(buffer + 3);\n  _reent *local_reent = reent;\n  int *local_buffer = buffer;\n  if (flags << 0x1e > -1) {\n    ushort whatbuf_r_value = __swhatbuf_r(reent, buffer, &local_reent, &local_buffer);\n    int *allocated_buffer = _malloc_r(reent, local_reent);\n    if (allocated_buffer != 0) {\n      reent->__cleanup = cleanup;\n      *buffer = (int)allocated_buffer;\n      *(ushort *)(buffer + 3) = flags | 0x80;\n      buffer[5] = (int)local_reent;\n      buffer[4] = (int)allocated_buffer;\n      if ((local_buffer != (int *)0x0) && (_isatty_r(reent, (int)*(short *)((int)buffer + 0xe)) != 0)) {\n        *(ushort *)(buffer + 3) = flags & 0xfffc | 1;\n      }\n      *(ushort *)(buffer + 3) = whatbuf_r_value | *(ushort *)(buffer + 3);\n      return;\n    }\n    if (flags << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(buffer + 3) = flags & 0xfffc | 2;\n  }\n  *buffer = (int)buffer + 0x47;\n  buffer[4] = (int)buffer + 0x47;\n  buffer[5] = 1;\n  return;\n}",
            "called": [
                "__swhatbuf_r",
                "_malloc_r",
                "_isatty_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005700",
            "calling": [
                "__srefill_r",
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "initialize_buffer_00005700"
        },
        "FUN_00002798": {
            "renaming": {
                "FUN_00002798": "check_context_switch_request_00002798",
                "PTR_sched_context_switch_request_000027ac": "context_switch_request_ptr"
            },
            "code": "void check_context_switch_request_00002798(void)\n{\n  int* PTR_sched_context_switch_request_000027ac = (int*)PTR_sched_context_switch_request_000027ac;\n  if (*PTR_sched_context_switch_request_000027ac != 0) {\n    thread_yield_higher();\n  }\n  return;\n}",
            "called": [
                "thread_yield_higher"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002798",
            "calling": [
                "isr_rtc"
            ],
            "imported": false,
            "current_name": "check_context_switch_request_00002798"
        },
        "FUN_00003524": {
            "renaming": {
                "FUN_00003524": "process_rtc_command_00003524",
                "argc": "argument_count",
                "argv": "arguments",
                "iVar1": "result",
                "_rtc_usage": "print_rtc_usage",
                "PTR_s_poweron_00003638": "power_on_command",
                "rtc_poweron": "rtc_poweron",
                "PTR_s_poweroff_0000363c": "power_off_command",
                "rtc_poweroff": "rtc_poweroff",
                "PTR_s_clearalarm_00003640": "clear_alarm_command",
                "rtc_clear_alarm": "rtc_clear_alarm",
                "PTR_s_getalarm_00003644": "get_alarm_command",
                "_rtc_getalarm": "get_rtc_alarm",
                "PTR_s_setalarm_00003648": "set_alarm_command",
                "_rtc_setalarm": "set_rtc_alarm",
                "PTR_s_gettime_0000364c": "get_time_command",
                "_rtc_gettime": "get_rtc_time",
                "PTR_s_settime_00003650": "set_time_command",
                "_rtc_settime": "set_rtc_time",
                "PTR_s_unknown_command_or_missing_param_00003654": "unknown_command_or_missing_param_message"
            },
            "code": "int process_rtc_command_00003524(int argc, char** argv) {\n    int result;\n    if (argc < 2) {\n        print_rtc_usage();\n        result = 1;\n    }\n    else {\n        const char* command = argv[1];\n        if (strncmp(command, PTR_s_poweron_00003638, 7) == 0) {\n            rtc_poweron();\n        }\n        else if (strncmp(command, PTR_s_poweroff_0000363c, 8) == 0) {\n            rtc_poweroff();\n        }\n        else if (strncmp(command, PTR_s_clearalarm_00003640, 8) == 0) {\n            rtc_clear_alarm();\n        }\n        else if (strncmp(command, PTR_s_getalarm_00003644, 8) == 0) {\n            get_rtc_alarm();\n        }\n        else if (strncmp(command, PTR_s_setalarm_00003648, 8) == 0 && argc == 4) {\n            set_rtc_alarm(argv + 2);\n        }\n        else if (strncmp(command, PTR_s_gettime_0000364c, 7) == 0) {\n            get_rtc_time();\n        }\n        else if (strncmp(command, PTR_s_settime_00003650, 7) == 0 && argc == 4) {\n            set_rtc_time(argv + 2);\n        }\n        else {\n            printf(PTR_s_unknown_command_or_missing_param_00003654, command);\n            print_rtc_usage();\n            result = 1;\n            return result;\n        }\n        result = 0;\n    }\n    return result;\n}",
            "called": [
                "iprintf",
                "rtc_poweron",
                "_rtc_setalarm",
                "rtc_clear_alarm",
                "rtc_poweroff",
                "_rtc_gettime",
                "_rtc_usage",
                "_rtc_getalarm",
                "_rtc_settime",
                "strncmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003524",
            "calling": [],
            "imported": false,
            "current_name": "process_rtc_command_00003524"
        },
        "FUN_00001bb8": {
            "renaming": {
                "FUN_00001bb8": "initialize_system_00001bb8",
                "DAT_00001c74": "system_flags",
                "DAT_00001c78": "system_flags[3]",
                "DAT_00001c7c": "system_flags[4]",
                "PTR_current_mode_00001c80": "current_mode",
                "KINETIS_MCG_FLL_FACTOR_640": "FLL_FACTOR_640",
                "bit_clear8": "clear_bit_in_byte"
            },
            "code": "void initialize_system_00001bb8(void)\n{\n  if ((DAT_00001c74[1] & 2) != 0) {\n    clear_bit_in_byte(DAT_00001c78, 1);\n  }\n  if ((DAT_00001c74[5] & 0x40) != 0) {\n    if ((*DAT_00001c74 & 0xc0) == 0) {\n      *DAT_00001c74 = *DAT_00001c74 & 0x3f | 0x80;\n      do {\n      } while ((DAT_00001c74[6] & 0xc) != 8);\n    }\n    clear_bit_in_byte(DAT_00001c7c, 6);\n    do {\n    } while ((DAT_00001c74[6] & 0x20) != 0);\n  }\n  set_fll_factor(KINETIS_MCG_FLL_FACTOR_640);\n  *DAT_00001c74 = *DAT_00001c74 & 0x3b | 4;\n  do {\n  } while ((DAT_00001c74[6] & 0x10) == 0);\n  do {\n  } while ((DAT_00001c74[6] & 0xc) != 0);\n  *PTR_current_mode_00001c80 = 0;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001bb8",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "initialize_system_00001bb8"
        },
        "FUN_0000428c": {
            "renaming": {
                "FUN_0000428c": "acquire_recursive_lock_0000428c",
                "PTR___lock___sinit_recursive_mutex_00004294": "lock_sinit_recursive_mutex"
            },
            "code": "void acquire_recursive_lock_0000428c(void)\n{\n  __retarget_lock_acquire_recursive(PTR___lock___sinit_recursive_mutex_00004294);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000428c",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "acquire_recursive_lock_0000428c"
        },
        "FUN_0000404c": {
            "renaming": {
                "FUN_0000404c": "process_data_0000404c",
                "param_1": "data",
                "param_2": "params",
                "iVar1": "total_bytes_processed",
                "piVar2": "ptr1",
                "uVar3": "flags_copy",
                "uVar4": "flags",
                "iVar5": "ptr2",
                "pcVar6": "func_ptr",
                "iVar7": "ptr3",
                "uVar8": "uVar1",
                "bVar9": "is_zero"
            },
            "code": "int process_data_0000404c(uint *data, int *params) {\n  int total_bytes_processed;\n  int *ptr1;\n  uint uVar1;\n  ushort flags;\n  int ptr2;\n  code *func_ptr;\n  int ptr3;\n  uint flags_copy;\n  bool is_zero;\n\n  flags = *(ushort *)(params + 3);\n  flags_copy = (uint)flags;\n  if ((int)(flags_copy << 0x1c) < 0) {\n    ptr2 = params[4];\n    if (ptr2 != 0) {\n      ptr3 = flags_copy << 0x1e;\n      is_zero = ptr3 == 0;\n      total_bytes_processed = *params;\n      if (is_zero) {\n        ptr3 = params[5];\n      }\n      *params = ptr2;\n      if (!is_zero) {\n        ptr3 = 0;\n      }\n      params[2] = ptr3;\n      for (total_bytes_processed = total_bytes_processed - ptr2; 0 < total_bytes_processed; total_bytes_processed = total_bytes_processed - ptr3) {\n        ptr3 = (*(code *)params[10])(data, params[8], ptr2, total_bytes_processed);\n        if (ptr3 < 1) {\n          *(ushort *)(params + 3) = *(ushort *)(params + 3) | 0x40;\n          return -1;\n        }\n        ptr2 = ptr2 + ptr3;\n      }\n    }\n  }\n  else {\n    if ((params[1] < 1) && (params[0x10] < 1)) {\n      return 0;\n    }\n    func_ptr = (code *)params[0xb];\n    if (func_ptr == (code *)0x0) {\n      return 0;\n    }\n    uVar1 = *data;\n    *data = 0;\n    if ((flags & 0x1000) == 0) {\n      ptr2 = (*func_ptr)(data, params[8], flags_copy & 0x1000, 1);\n      if ((ptr2 == -1) && (uVar1 = *data, uVar1 != 0)) {\n        if ((uVar1 == 0x1d) || (uVar1 == 0x16)) {\n          *data = uVar1;\n          return 0;\n        }\n        flags = *(ushort *)(params + 3);\n        goto LAB_00004104;\n      }\n    }\n    else {\n      ptr2 = params[0x15];\n    }\n    if (((int)((uint)*(ushort *)(params + 3) << 0x1d) < 0) &&\n       (ptr2 = ptr2 - params[1], params[0xd] != 0)) {\n      ptr2 = ptr2 - params[0x10];\n    }\n    ptr2 = (*(code *)params[0xb])(data, params[8], ptr2, 0);\n    flags = *(ushort *)(params + 3);\n    if ((ptr2 == -1) &&\n       ((0x1d < *data || (-1 < (int)((DAT_00004154 >> (*data & 0xff)) << 0x1f))))) {\nLAB_00004104:\n      *(ushort *)(params + 3) = flags | 0x40;\n      return ptr2;\n    }\n    params[1] = 0;\n    *params = params[4];\n    if (((int)((uint)flags << 0x13) < 0) && ((ptr2 != -1 || (*data == 0)))) {\n      params[0x15] = ptr2;\n    }\n    ptr1 = (int *)params[0xd];\n    *data = uVar1;\n    if (ptr1 != (int *)0x0) {\n      if (ptr1 != params + 0x11) {\n        _free_r(data);\n      }\n      params[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000404c",
            "calling": [
                "__srefill_r",
                "_fflush_r"
            ],
            "imported": false,
            "current_name": "process_data_0000404c"
        },
        "FUN_00002f74": {
            "renaming": {
                "FUN_00002f74": "print_saul_devices_00002f74",
                "dev": "current_device",
                "i": "device_count",
                "pcVar1": "class_str"
            },
            "code": "void print_saul_devices_00002f74(void)\n{\n  char *class_str;\n  int device_count = 0;\n  saul_reg_t *current_device = *(saul_reg_t **)PTR_saul_reg_00002fd0;\n  if (current_device == (saul_reg_t *)0x0) {\n    puts(PTR_s_No_devices_found_00002fd8);\n  }\n  else {\n    puts(PTR_s_ID_Class_Name_00002fd4);\n  }\n  while (current_device != (saul_reg_t *)0x0) {\n    class_str = saul_class_to_str(current_device->driver->type);\n    iprintf(PTR_s___i__s__s_00002fdc, device_count, class_str, current_device->name);\n    device_count++;\n    current_device = current_device->next;\n  }\n  return;\n}",
            "called": [
                "iprintf",
                "saul_class_to_str",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f74",
            "calling": [
                "_saul"
            ],
            "imported": false,
            "current_name": "print_saul_devices_00002f74"
        },
        "FUN_000010a0": {
            "renaming": {
                "FUN_000010a0": "find_free_space_000010a0",
                "stack": "stack_pointer",
                "space_free": "free_space",
                "stackp": "current_pointer"
            },
            "code": "uintptr_t find_free_space_000010a0(char *stack_pointer)\n{\n  uintptr_t free_space;\n  uintptr_t *current_pointer;\n  \n  for (current_pointer = (uintptr_t *)stack_pointer; (uintptr_t *)*current_pointer == current_pointer; current_pointer++) {\n  }\n  return (int)current_pointer - (int)stack_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010a0",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "find_free_space_000010a0"
        },
        "FUN_000012e2": {
            "renaming": {
                "FUN_000012e2": "read_from_isrpipe_000012e2",
                "isrpipe": "isr_pipe",
                "buffer": "buffer",
                "count": "count",
                "iVar1": "read_result",
                "res": "N/A"
            },
            "code": "int read_from_isrpipe_000012e2(isrpipe_t *isr_pipe, char *buffer, size_t count)\n{\n  int read_result;\n  while(true) {\n    read_result = tsrb_get(&isr_pipe->tsrb, buffer, count);\n    if (read_result != 0) break;\n    mutex_lock(&isr_pipe->mutex);\n  }\n  return read_result;\n}",
            "called": [
                "mutex_lock",
                "tsrb_get"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012e2",
            "calling": [
                "uart_stdio_read"
            ],
            "imported": false,
            "current_name": "read_from_isrpipe_000012e2"
        },
        "FUN_000056a0": {
            "renaming": {
                "FUN_000056a0": "find_environment_variable_000056a0",
                "param_1": "env_var",
                "param_2": "env_var_index",
                "param_3": "env_var_length",
                "param_4": "env_var_exists",
                "uStack_c": "env_var_ptr",
                "uStack_8": "env_var_len_ptr"
            },
            "code": "void find_environment_variable_000056a0(const char* env_var, int* env_var_index, int* env_var_length, int* env_var_exists) {\n    int* env_var_ptr = env_var_index;\n    int* env_var_len_ptr = env_var_length;\n    _findenv_r(env_var, *env_var_ptr, &env_var_ptr, *env_var_len_ptr, env_var);\n    *env_var_exists = (*env_var_ptr != -1);\n}",
            "called": [
                "_findenv_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056a0",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "find_environment_variable_000056a0"
        },
        "FUN_0000231c": {
            "renaming": {
                "FUN_0000231c": "copy_from_tsrb_0000231c",
                "rb": "ring_buffer",
                "dst": "destination",
                "n": "max_size",
                "cVar1": "current_char",
                "iVar2": "is_empty",
                "local_20": "destination_ptr",
                "tmp": "remaining_size",
                "_pop": "tsrb_pop"
            },
            "code": "int copy_from_tsrb_0000231c(tsrb_t *ring_buffer, char *destination, size_t max_size) {\n  char current_char;\n  int is_empty;\n  char *destination_ptr = destination;\n  size_t remaining_size = max_size;\n  \n  while ((remaining_size != 0 && (is_empty = tsrb_empty(ring_buffer), is_empty == 0))) {\n    current_char = tsrb_pop(ring_buffer);\n    *destination_ptr = current_char;\n    remaining_size--;\n    destination_ptr++;\n  }\n  return max_size - remaining_size;\n}",
            "called": [
                "tsrb_empty",
                "_pop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000231c",
            "calling": [
                "isrpipe_read"
            ],
            "imported": false,
            "current_name": "copy_from_tsrb_0000231c"
        },
        "FUN_000061cc": {
            "renaming": {
                "FUN_000061cc": "FUNC_000061cc"
            },
            "code": "\nint FUNC_000061cc(int param_1,byte **param_2,byte *param_3,int **param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  void *pvVar4;\n  uint uVar5;\n  byte *pbVar6;\n  uint uVar7;\n  int **local_2b0;\n  undefined auStack_2ac [256];\n  uint local_1ac;\n  undefined4 local_1a8;\n  uint local_1a4;\n  int local_1a0;\n  int local_19c;\n  undefined *local_198;\n  int local_194;\n  undefined4 local_30;\n  code *local_2c;\n  \n  puVar2 = PTR_DAT_000064b4;\n  puVar1 = PTR_DAT_000064b0;\n  local_1a0 = 0;\n  local_19c = 0;\n  local_30 = DAT_000064a8;\n  local_2c = DAT_000064ac;\n  local_2b0 = param_4;\n  local_198 = auStack_2ac;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      uVar7 = (uint)*param_3;\n      if (uVar7 == 0) {\n        return local_1a0;\n      }\n      uVar5 = (byte)puVar1[uVar7] & 8;\n      pbVar6 = param_3 + 1;\n      if ((puVar1[uVar7] & 8) == 0) break;\n      while (((param_3 = pbVar6, 0 < (int)param_2[1] ||\n              (iVar3 = (*local_2c)(param_1,param_2), iVar3 == 0)) &&\n             ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0))) {\n        local_19c = local_19c + 1;\n        param_2[1] = param_2[1] + -1;\n        *param_2 = *param_2 + 1;\n      }\n    }\n    if (uVar7 == 0x25) break;\nLAB_00006352:\n    if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n    goto LAB_00006380;\n    if (**param_2 != uVar7) {\n      return local_1a0;\n    }\n    *param_2 = *param_2 + 1;\n    local_19c = local_19c + 1;\n    param_2[1] = param_2[1] + -1;\n    param_3 = pbVar6;\n  }\n  local_1a4 = uVar5;\n  local_1ac = uVar5;\n  if (param_3[1] == 0x2a) {\n    pbVar6 = param_3 + 2;\n    local_1ac = 0x10;\n  }\n  while( true ) {\n    uVar5 = (uint)*pbVar6;\n    if (9 < uVar5 - 0x30) break;\n    pbVar6 = pbVar6 + 1;\n    local_1a4 = (local_1a4 * 10 + uVar5) - 0x30;\n  }\n  pvVar4 = memchr(PTR_DAT_000064b4,uVar5,3);\n  if (pvVar4 != (void *)0x0) {\n    local_1ac = 1 << ((int)pvVar4 - (int)puVar2 & 0xffU) | local_1ac;\n    pbVar6 = pbVar6 + 1;\n  }\n  param_3 = pbVar6 + 1;\n  uVar5 = (uint)*pbVar6;\n  if (uVar5 < 0x79) {\n    if (0x57 < uVar5) {\n      switch(uVar5) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        param_3 = (byte *)__sccl(auStack_2ac,param_3);\n        local_1ac = local_1ac | 0x40;\n        local_194 = 1;\n        break;\n      case 99:\n        local_1ac = local_1ac | 0x40;\n        local_194 = 0;\n        break;\n      case 100:\n      case 0x75:\n        local_1a8 = 10;\nLAB_000063a0:\n        if (uVar5 < 0x6f) {\n          local_194 = 3;\n        }\n        else {\n          local_194 = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        local_194 = 5;\n        break;\n      case 0x69:\n        local_1a8 = 0;\n        local_194 = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(local_1ac << 0x1b)) {\n          if ((int)(local_1ac << 0x1f) < 0) {\n            *(short *)*local_2b0 = (short)local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n          else {\n            **local_2b0 = local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        local_1a8 = 8;\n        local_194 = 4;\n        break;\n      case 0x70:\n        local_1ac = local_1ac | 0x20;\n      case 0x58:\n      case 0x78:\n        local_1ac = local_1ac | 0x200;\n        local_1a8 = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        local_194 = 2;\n      }\nLAB_000063ac:\n      if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(local_1ac << 0x19)) {\n        while ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0) {\n          local_19c = local_19c + 1;\n          pbVar6 = param_2[1];\n          param_2[1] = pbVar6 + -1;\n          if ((int)(pbVar6 + -1) < 1) {\n            iVar3 = (*local_2c)(param_1,param_2);\n            if (iVar3 != 0) goto LAB_00006380;\n          }\n          else {\n            *param_2 = *param_2 + 1;\n          }\n        }\n      }\n      if (local_194 < 3) {\n        iVar3 = _scanf_chars(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else if (local_194 < 5) {\n        iVar3 = _scanf_i(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else {\n        iVar3 = param_1;\n        if (DAT_000064b8 == 0) goto LAB_000061f6;\n      }\n      if (iVar3 == 1) {\n        return local_1a0;\n      }\n      if (iVar3 == 2) {\nLAB_00006380:\n        if (local_1a0 == 0) {\nLAB_00006388:\n          local_1a0 = -1;\n        }\n        else if ((*(ushort *)(param_2 + 3) & 0x40) != 0) {\n          local_1a0 = -1;\n        }\n        return local_1a0;\n      }\n      goto LAB_000061f6;\n    }\n    pbVar6 = param_3;\n    if (uVar5 == 0x25) goto LAB_00006352;\n    if (uVar5 < 0x26) {\n      if (uVar5 != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (uVar5 - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  local_194 = 3;\n  local_1a8 = 10;\n  goto LAB_000063ac;\n}\n\n",
            "called": [
                "memchr",
                "__ssrefill_r",
                "__sccl",
                "_scanf_i",
                "_scanf_chars"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000061cc",
            "calling": [
                "siscanf"
            ],
            "imported": false,
            "current_name": "FUNC_000061cc"
        },
        "FUN_00002690": {
            "renaming": {
                "FUN_00002690": "convert_alarm_time_to_gmtime_00002690",
                "time": "converted_time",
                "t": "alarm_time",
                "_4_4_": "zero_time"
            },
            "code": "int convert_alarm_time_to_gmtime_00002690(tm *converted_time)\n{\n  time_t alarm_time = rtt_get_alarm();\n  time_t zero_time = 0;\n  gmtime_r(&alarm_time, converted_time);\n  return 0;\n}",
            "called": [
                "rtt_get_alarm",
                "gmtime_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002690",
            "calling": [
                "_rtc_getalarm"
            ],
            "imported": false,
            "current_name": "convert_alarm_time_to_gmtime_00002690"
        },
        "FUN_00006010": {
            "renaming": {
                "FUN_00006010": "search_byte_sequence_00006010",
                "__s": "data",
                "__c": "byte_to_find",
                "__n": "size",
                "bVar1": "first_byte",
                "cVar2": "is_first_byte_zero",
                "cVar3": "is_second_byte_zero",
                "cVar4": "is_third_byte_zero",
                "cVar5": "is_fourth_byte_zero",
                "pbVar6": "data_as_byte_ptr",
                "puVar7": "data_as_uint_ptr",
                "pbVar8": "data_as_byte_ptr_2",
                "uVar9": "byte_as_uint",
                "uVar10": "data_alignment_offset",
                "uVar11": "size_aligned",
                "uVar12": "data_as_uint_3",
                "uVar13": "data_as_uint_4",
                "bVar14": "is_data_as_uint_2_nonzero",
                "bVar15": "is_data_as_uint_2_nonzero_2",
                "bVar16": "is_data_as_uint_2_nonzero_3",
                "bVar17": "is_data_as_uint_2_nonzero_4",
                "byte": "byte_ptr"
            },
            "code": "void * search_byte_sequence_00006010(void *data, int byte_to_find, size_t size) {\n  uint byte_as_uint = byte_to_find & 0xff;\n  if ((int)size < 0x10) {\n    while (size-- > 0) {\n      if (*(byte *)data == byte_as_uint) {\n        return data;\n      }\n      data = (byte *)data + 1;\n    }\n    return NULL;\n  }\n  uint data_alignment_offset = (uint)data & 7;\n  uint byte_pattern = byte_as_uint | byte_as_uint << 8 | byte_as_uint << 16 | byte_as_uint << 24;\n  size_t size_aligned = size & 0xfffffff8;\n  while (size_aligned > 0) {\n    uint data_as_uint = *(uint *)data ^ byte_pattern;\n    uint data_as_uint_2 = *(uint *)((byte *)data + 4) ^ byte_pattern;\n    bool is_data_as_uint_zero = (char)data_as_uint == 0;\n    bool is_data_as_uint_2_zero = (char)(data_as_uint >> 8) == 0;\n    bool is_data_as_uint_3_zero = (char)(data_as_uint >> 16) == 0;\n    bool is_data_as_uint_4_zero = (char)(data_as_uint >> 24) == 0;\n    uint data_as_uint_3 = (is_data_as_uint_4_zero << 3 | is_data_as_uint_3_zero << 2 | is_data_as_uint_2_zero << 1 | is_data_as_uint_zero) & 0xf;\n    bool is_data_as_uint_5_zero = (char)data_as_uint_2 == 0;\n    bool is_data_as_uint_6_zero = (char)(data_as_uint_2 >> 8) == 0;\n    bool is_data_as_uint_7_zero = (char)(data_as_uint_2 >> 16) == 0;\n    bool is_data_as_uint_8_zero = (char)(data_as_uint_2 >> 24) == 0;\n    uint data_as_uint_4 = (is_data_as_uint_8_zero << 3 | is_data_as_uint_7_zero << 2 | is_data_as_uint_6_zero << 1 | is_data_as_uint_5_zero) & 0xf;\n    if (data_as_uint_3 | data_as_uint_4) {\n      if (!data_as_uint_3) {\n        data = (byte *)data + 5;\n        data_as_uint_3 = data_as_uint_4;\n      }\n      else {\n        data = (byte *)data + 1;\n      }\n      if ((data_as_uint_3 & 1) == 0) {\n        if ((data_as_uint_3 & 0x100) == 0) {\n          if ((data_as_uint_3 & 0x18000) == 0) {\n            data = (byte *)data + 2;\n          }\n          else {\n            data = (byte *)data + 3;\n          }\n        }\n        else {\n          if ((data_as_uint_3 & 0x10000) == 0) {\n            data = (byte *)data + 4;\n          }\n          else {\n            data = (byte *)data + 5;\n          }\n        }\n      }\n      return (byte *)data - 1;\n    }\n    data = (byte *)data + 8;\n    size_aligned -= 8;\n  }\n  while (size-- > 0) {\n    if (*(byte *)data == byte_as_uint) {\n      return data;\n    }\n    data = (byte *)data + 1;\n  }\n  return NULL;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006010",
            "calling": [
                "_printf_i",
                "_vfprintf_r",
                "_scanf_i",
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "search_byte_sequence_00006010"
        },
        "FUN_00001cf0": {
            "renaming": {
                "FUN_00001cf0": "check_for_context_switch_request_00001cf0",
                "PTR_sched_context_switch_request_00001d04": "context_switch_request_ptr"
            },
            "code": "void check_for_context_switch_request_00001cf0(void)\n{\n  int* PTR_sched_context_switch_request_00001d04 = (int*)PTR_sched_context_switch_request_00001d04;\n  if (*PTR_sched_context_switch_request_00001d04 != 0) {\n    thread_yield_higher();\n  }\n  return;\n}",
            "called": [
                "thread_yield_higher"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001cf0",
            "calling": [
                "irq_handler"
            ],
            "imported": false,
            "current_name": "check_for_context_switch_request_00001cf0"
        },
        "FUN_00003ec4": {
            "renaming": {
                "FUN_00003ec4": "format_fp_number_00003ec4",
                "out": "output",
                "val": "value",
                "fp_digits": "fractional_digits",
                "sVar1": "output_length",
                "val_00": "integer_part",
                "iVar2": "integer_part_length",
                "div_len": "division_length",
                "abs": "absolute_value",
                "e": "exponent",
                "div": "remainder",
                "pos": "output_length"
            },
            "code": "size_t format_fp_number_00003ec4(char *output, int32_t value, int fractional_digits) {\n  size_t output_length;\n  uint32_t integer_part;\n  uint32_t remainder;\n  bool is_negative = (value < 0);\n  if (fractional_digits + 7 < 0) {\n    core_panic(PANIC_ASSERT_FAIL, ASSERT_CRASH_MESSAGE);\n  }\n  output_length = 0;\n  if (fractional_digits == 0) {\n    output_length = format_integer(output, value);\n  }\n  else if (fractional_digits < 1) {\n    integer_part = (uint32_t)value / *(uint32_t *)(TEN_MAP + fractional_digits * -4);\n    remainder = abs(value - *(uint32_t *)(TEN_MAP + fractional_digits * -4) * integer_part);\n    if (remainder < 0) {\n      remainder = -remainder;\n    }\n    if ((integer_part == 0) && is_negative) {\n      if (output != NULL) {\n        *output = '-';\n      }\n      output_length = 1;\n    }\n    if (output == NULL) {\n      output_length = format_integer(NULL, integer_part);\n      output_length += 1;\n      output_length += format_fraction(NULL, remainder, -fractional_digits);\n    }\n    else {\n      output_length = format_integer(output + output_length, integer_part);\n      output[output_length] = '.';\n      output_length += 1;\n      output_length += format_fraction(output + output_length, remainder, -fractional_digits);\n    }\n    output_length = -fractional_digits + output_length;\n  }\n  else {\n    output_length = format_integer(output, value);\n    if (output != NULL) {\n      memset(output + output_length, '0', fractional_digits);\n    }\n    output_length += fractional_digits;\n  }\n  return output_length;\n}",
            "called": [
                "core_panic",
                "memset",
                "fmt_s32_dec",
                "fmt_lpad"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ec4",
            "calling": [
                "fmt_s16_dfp"
            ],
            "imported": false,
            "current_name": "format_fp_number_00003ec4"
        },
        "FUN_00001360": {
            "renaming": {
                "FUN_00001360": "calculate_address_from_bit_and_ptr_00001360",
                "ptr": "PTR_ptr",
                "bit": "bit",
                "high_bits": "high_bits",
                "low_bits": "low_bits",
                "address": "address"
            },
            "code": "void * calculate_address_from_bit_and_ptr_00001360(void *PTR_ptr, uintptr_t bit){\n    uintptr_t ptr = (uintptr_t)PTR_ptr;\n    uintptr_t high_bits = ptr & 0xf0000000;\n    uintptr_t low_bits = ptr & 0xfffff;\n    uintptr_t address = (bit * 4) + (high_bits | (low_bits << 5)) + 0x2000000;\n    return (void *)address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001360",
            "calling": [
                "bit_set32"
            ],
            "imported": false,
            "current_name": "calculate_address_from_bit_and_ptr_00001360"
        },
        "FUN_00004622": {
            "renaming": {
                "FUN_00004622": "fill_memory_with_value_00004622",
                "__s": "ptr",
                "__c": "value",
                "__n": "size",
                "puVar1": "current_byte",
                "undefined": "unsigned char"
            },
            "code": "void * fill_memory_with_value_00004622(void *ptr, int value, size_t size) {\n  unsigned char *current_byte = (unsigned char *)ptr;\n  unsigned char *end_byte = current_byte + size;\n  while (current_byte != end_byte) {\n    *current_byte = (unsigned char)value;\n    current_byte++;\n  }\n  return ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004622",
            "calling": [
                "__sfmoreglue",
                "fmt_s32_dfp",
                "__sfp",
                "write",
                "std",
                "fmt_lpad"
            ],
            "imported": false,
            "current_name": "fill_memory_with_value_00004622"
        },
        "FUN_0000093c": {
            "renaming": {
                "FUN_0000093c": "set_flag_for_data_0000093c",
                "DAT_00000954": "data_start"
            },
            "code": "void set_flag_for_data_0000093c(void)\n{\n  uint* data_ptr = (uint*)(DAT_00000954 + 4);\n  *data_ptr |= 0x10000000;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000093c",
            "calling": [
                "sched_switch",
                "cortexm_isr_end",
                "cortexm_isr_end",
                "_mutex_lock",
                "cortexm_isr_end"
            ],
            "imported": false,
            "current_name": "set_flag_for_data_0000093c"
        },
        "FUN_00003658": {
            "renaming": {
                "FUN_00003658": "synchronizeData_00003658",
                "DAT_00003680": "dataStartAddr",
                "DAT_00003684": "dataValue",
                "PTR_": "pointer_"
            },
            "code": "void synchronizeData_00003658(void)\n{\n  DataSynchronizationBarrier(0xf);\n  uint* dataPtr = (uint*)(DAT_00003680 + 0xc);\n  *dataPtr = (*dataPtr & 0x700) | DAT_00003684;\n  DataSynchronizationBarrier(0xf);\n  while(true)\n  {\n    // Do nothing block with infinite loop\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003658",
            "calling": [
                "pm_reboot"
            ],
            "imported": false,
            "current_name": "synchronizeData_00003658"
        },
        "FUN_000019c0": {
            "renaming": {
                "FUN_000019c0": "configure_system_clock_000019c0",
                "kinetis_mcg_enable_osc": "enable_external_oscillator",
                "kinetis_mcg_set_fll_factor": "set_fll_factor",
                "DAT_00001a0c": "system_control_register",
                "DAT_00001a10": "system_divider_register",
                "bit_clear8": "clear_bit_in_byte",
                "KINETIS_MCG_FLL_FACTOR_1920": "FLL_FACTOR_1920",
                "kintis_mcg_disable_pll": "disable_pll",
                "PTR_current_mode_00001a14": "current_system_mode"
            },
            "code": "void configure_system_clock_000019c0(void)\n{\n  enable_external_oscillator();\n  set_fll_factor(FLL_FACTOR_1920);\n  clear_bit_in_byte(DAT_00001a0c, BIT_0);\n  *DAT_00001a10 = *DAT_00001a10 & 0x3b | 0x80;\n  while ((DAT_00001a10[6] & 0xc) != 8);\n  disable_pll();\n  *PTR_current_mode_00001a14 = SYSTEM_MODE_3;\n  return;\n}",
            "called": [
                "kinetis_mcg_disable_pll",
                "kinetis_mcg_enable_osc",
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000019c0",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "configure_system_clock_000019c0"
        },
        "FUN_000060b0": {
            "renaming": {
                "FUN_000060b0": "reverse_copy_000060b0",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "puVar1": "src_ptr",
                "puVar2": "src_end",
                "puVar3": "dst_ptr"
            },
            "code": "void * reverse_copy_000060b0(void *destination, const void *source, size_t size)\n{\n  unsigned char *src = (unsigned char *)source + size;\n  unsigned char *dst = (unsigned char *)destination - 1;\n  while (source != src)\n  {\n    src--;\n    dst++;\n    *dst = *src;\n  }\n  return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060b0",
            "calling": [
                "__submore",
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "reverse_copy_000060b0"
        },
        "FUN_00006a14": {
            "renaming": {
                "FUN_00006a14": "FUNC_00006a14"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong FUNC_00006a14(uint param_1,uint param_2,uint param_3,uint param_4,uint *param_5)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  uint uVar1;\n  uint *puVar2;\n  uint *puVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  bool bVar11;\n  ulonglong uVar12;\n  \n  if (param_4 == 0) {\n    if (param_2 < param_3) {\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 != 0) {\n        param_3 = param_3 << (uVar4 & 0xff);\n        param_2 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        param_1 = param_1 << (uVar4 & 0xff);\n      }\n      uVar7 = param_3 >> 0x10;\n      uVar9 = param_2 / uVar7;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar7 * uVar9) * 0x10000;\n      uVar1 = uVar9 * (param_3 & 0xffff);\n      uVar6 = uVar9;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar9 = (uVar5 - uVar1) / uVar7;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar7 * uVar9) * 0x10000;\n      uVar7 = uVar9 * (param_3 & 0xffff);\n      uVar1 = uVar9;\n      if (uVar5 <= uVar7 && uVar7 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar7 && uVar7 - uVar5 != 0)) {\n          uVar1 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar7;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n      puVar3 = (uint *)0x0;\n    }\n    else {\n      if (param_3 == 0) {\n                    /* WARNING: Could not recover jumptable at 0x00006abc. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x6abc);\n        uVar12 = (*UNRECOVERED_JUMPTABLE)();\n        return uVar12;\n      }\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 == 0) {\n        param_2 = param_2 - param_3;\n        uVar10 = param_3 >> 0x10;\n        uVar8 = param_3 & 0xffff;\n        puVar3 = (uint *)0x1;\n      }\n      else {\n        param_3 = param_3 << (uVar4 & 0xff);\n        uVar10 = param_3 >> 0x10;\n        uVar6 = param_2 >> (0x20 - uVar4 & 0xff);\n        uVar1 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        uVar5 = uVar6 / uVar10;\n        uVar8 = param_3 & 0xffff;\n        uVar9 = uVar1 >> 0x10 | (uVar6 - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        param_1 = param_1 << (uVar4 & 0xff);\n        uVar6 = uVar5;\n        if (uVar9 <= uVar7 && uVar7 - uVar9 != 0) {\n          bVar11 = CARRY4(param_3,uVar9);\n          uVar9 = param_3 + uVar9;\n          uVar6 = uVar5 - 1;\n          if ((bVar11 == false) && (uVar9 <= uVar7 && uVar7 - uVar9 != 0)) {\n            uVar6 = uVar5 - 2;\n            uVar9 = uVar9 + param_3;\n          }\n        }\n        uVar5 = (uVar9 - uVar7) / uVar10;\n        param_2 = uVar1 & 0xffff | ((uVar9 - uVar7) - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        uVar1 = uVar5;\n        if (param_2 <= uVar7 && uVar7 - param_2 != 0) {\n          bVar11 = CARRY4(param_3,param_2);\n          param_2 = param_3 + param_2;\n          uVar1 = uVar5 - 1;\n          if ((bVar11 == false) && (param_2 <= uVar7 && uVar7 - param_2 != 0)) {\n            uVar1 = uVar5 - 2;\n            param_2 = param_2 + param_3;\n          }\n        }\n        param_2 = param_2 - uVar7;\n        puVar3 = (uint *)(uVar1 | uVar6 << 0x10);\n      }\n      uVar7 = param_2 / uVar10;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar10 * uVar7) * 0x10000;\n      uVar1 = uVar8 * uVar7;\n      uVar6 = uVar7;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar7 = (uVar5 - uVar1) / uVar10;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar10 * uVar7) * 0x10000;\n      uVar8 = uVar8 * uVar7;\n      uVar1 = uVar7;\n      if (uVar5 <= uVar8 && uVar8 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar8 && uVar8 - uVar5 != 0)) {\n          uVar1 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar8;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = uVar5 >> (uVar4 & 0xff);\n      param_5[1] = 0;\n    }\n  }\n  else if (param_2 < param_4) {\n    puVar2 = param_5;\n    puVar3 = param_5;\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n      return 0;\n    }\n  }\n  else {\n    puVar3 = (uint *)count_leading_zeroes(param_4);\n    if (puVar3 != (uint *)0x0) {\n      uVar8 = 0x20 - (int)puVar3;\n      uVar5 = param_3 >> (uVar8 & 0xff) | param_4 << ((uint)puVar3 & 0xff);\n      uVar10 = uVar5 >> 0x10;\n      uVar4 = param_2 >> (uVar8 & 0xff);\n      uVar6 = param_1 >> (uVar8 & 0xff) | param_2 << ((uint)puVar3 & 0xff);\n      uVar7 = uVar4 / uVar10;\n      uVar1 = uVar6 >> 0x10 | (uVar4 - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      param_3 = param_3 << ((uint)puVar3 & 0xff);\n      param_1 = param_1 << ((uint)puVar3 & 0xff);\n      uVar4 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar4 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar4 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar7 = (uVar1 - uVar9) / uVar10;\n      uVar1 = uVar6 & 0xffff | ((uVar1 - uVar9) - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      uVar6 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar6 = uVar6 | uVar4 << 0x10;\n      uVar12 = (ulonglong)uVar6 * (ulonglong)param_3;\n      if (CONCAT44(uVar1 - uVar9,param_1) < uVar12) {\n        uVar12 = uVar12 - CONCAT44(uVar5,param_3);\n        uVar6 = uVar6 - 1;\n      }\n      if (param_5 != (uint *)0x0) {\n        uVar4 = ((uVar1 - uVar9) - (int)(uVar12 >> 0x20)) - (uint)(param_1 < (uint)uVar12);\n        *param_5 = uVar4 << (uVar8 & 0xff) | param_1 - (uint)uVar12 >> ((uint)puVar3 & 0xff);\n        param_5[1] = uVar4 >> ((uint)puVar3 & 0xff);\n      }\n      return (ulonglong)uVar6;\n    }\n    if ((param_4 < param_2) || (puVar2 = puVar3, param_3 <= param_1)) {\n      bVar11 = param_1 < param_3;\n      param_1 = param_1 - param_3;\n      param_2 = (param_2 - param_4) - (uint)bVar11;\n      puVar2 = (uint *)0x1;\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n    }\n  }\n  return CONCAT44(puVar3,puVar2);\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00006a14",
            "calling": [
                "__aeabi_ldivmod"
            ],
            "imported": false,
            "current_name": "FUNC_00006a14"
        },
        "FUN_000023d0": {
            "renaming": {
                "FUN_000023d0": "getTicks_000023d0",
                "ticks": "ticks",
                "PTR_noHyperCall_000023fc": "noHyperCall",
                "uVar1": "ticks"
            },
            "code": "int getTicks_000023d0(uint32_t* PTR_noHyperCall_000023fc){\n  uint32_t ticks = 0;\n  if (*PTR_noHyperCall_000023fc == 0){\n    ticks = aflCall(1, ticks, 0);\n  }\n  return ticks;\n}",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023d0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "getTicks_000023d0"
        },
        "FUN_00000a30": {
            "renaming": {
                "FUN_00000a30": "handle_non_maskable_interrupt_00000a30",
                "PTR_s_NMI_HANDLER_00000a3c": "nmi_handler_ptr"
            },
            "code": "void handle_non_maskable_interrupt_00000a30(void)\n{\n    /* WARNING: Subroutine does not return */\n    core_panic(PANIC_NMI_HANDLER, PTR_s_NMI_HANDLER_00000a3c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a30",
            "calling": [],
            "imported": false,
            "current_name": "handle_non_maskable_interrupt_00000a30"
        },
        "FUN_000034c0": {
            "renaming": {
                "FUN_000034c0": "print_rtc_commands_and_arguments_000034c0",
                "PTR_s_usage__rtc__command___arguments__00003500": "rtc_usage",
                "PTR_s_commands__00003504": "commands",
                "PTR_s__poweron_power_the_interface_on_00003508": "power_on_msg",
                "PTR_s__poweroff_power_the_interface_of_0000350c": "power_off_msg",
                "PTR_s__clearalarm_deactivate_the_curre_00003510": "deactivate_alarm_msg",
                "PTR_s__getalarm_print_the_currently_al_00003514": "current_alarm_msg",
                "PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518": "set_alarm_msg",
                "PTR_s__gettime_print_the_current_time_0000351c": "current_time_msg",
                "PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520": "set_time_msg"
            },
            "code": "int print_rtc_commands_and_arguments_000034c0(void)\n{\n  puts(PTR_s_usage__rtc__command___arguments__00003500);\n  puts(PTR_s_commands__00003504);\n  puts(PTR_s__poweron_power_the_interface_on_00003508);\n  puts(PTR_s__poweroff_power_the_interface_of_0000350c);\n  puts(PTR_s__clearalarm_deactivate_the_curre_00003510);\n  puts(PTR_s__getalarm_print_the_currently_al_00003514);\n  puts(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n  puts(PTR_s__gettime_print_the_current_time_0000351c);\n  puts(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n  return 0;\n}",
            "called": [
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000034c0",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "print_rtc_commands_and_arguments_000034c0"
        },
        "FUN_000050e8": {
            "renaming": {
                "FUN_000050e8": "acquire_time_zone_mutex_000050e8",
                "PTR___lock___tz_mutex_000050f0": "time_zone_mutex"
            },
            "code": "void acquire_time_zone_mutex_000050e8(void)\n{\n  __retarget_lock_acquire(PTR___lock___tz_mutex_000050f0);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050e8",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "acquire_time_zone_mutex_000050e8"
        },
        "FUN_000042a4": {
            "renaming": {
                "FUN_000042a4": "initialize_param_000042a4",
                "param_1": "param",
                "is_param_initialized": "is_param_initialized",
                "global_impure_ptr_value": "global_impure_ptr_value",
                "new_value": "new_value",
                "size": "size"
            },
            "code": "void initialize_param_000042a4(int param_1)\n{\n  bool is_param_initialized;\n  int global_impure_ptr_value;\n  int new_value;\n  unsigned int size;\n  \n  acquire_lock();\n  is_param_initialized = *(int *)(param_1 + 0x18) != 0;\n  if (!is_param_initialized) {\n    *(int *)(param_1 + 0x48) = 0;\n    *(int *)(param_1 + 0x4c) = 0;\n    *(int *)(param_1 + 0x50) = 0;\n    global_impure_ptr_value = *(int *)PTR__global_impure_ptr_0000430c;\n    *(int *)(param_1 + 0x28) = DAT_00004310;\n    new_value = global_impure_ptr_value == param_1 ? 1 : global_impure_ptr_value;\n    if (global_impure_ptr_value == param_1) {\n      *(int *)(param_1 + 0x18) = new_value;\n    }\n    size = sizeof(int);\n    *(int *)(param_1 + 4) = __sfp(param_1);\n    std(*(int *)(param_1 + 4),size,0);\n    *(int *)(param_1 + 8) = __sfp(param_1);\n    std(*(int *)(param_1 + 8),size+5,1);\n    *(int *)(param_1 + 0xc) = __sfp(param_1);\n    std(*(int *)(param_1 + 0xc),size+18,2);\n    *(int *)(param_1 + 0x18) = 1;\n  }\n  release_lock();\n  return;\n}",
            "called": [
                "__sfp",
                "__sinit_lock_release",
                "std",
                "__sinit_lock_acquire"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000042a4",
            "calling": [
                "_puts_r",
                "__srget_r",
                "putchar",
                "__srefill_r",
                "iprintf",
                "_fflush_r",
                "__swbuf_r",
                "getchar",
                "__sfp",
                "_putc_r",
                "_getc_r",
                "_vfprintf_r",
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "initialize_param_000042a4"
        },
        "FUN_00000514": {
            "renaming": {
                "FUN_00000514": "set_error_code_00000514",
                "r": "reent_context",
                "fd": "file_descriptor",
                "st": "file_status"
            },
            "code": "int set_error_code_00000514(_reent *reent_context, int file_descriptor, stat *file_status)\n{\n  reent_context->_errno = 0x13;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000514",
            "calling": [
                "__swhatbuf_r"
            ],
            "imported": false,
            "current_name": "set_error_code_00000514"
        },
        "FUN_00002e9c": {
            "renaming": {
                "FUN_00002e9c": "reboot_system_00002e9c",
                "argc": "arg_count",
                "argv": "arguments"
            },
            "code": "int reboot_system_00002e9c(int arg_count, char **arguments) {\n  pm_reboot();\n  return 0;\n}",
            "called": [
                "pm_reboot"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e9c",
            "calling": [],
            "imported": false,
            "current_name": "reboot_system_00002e9c"
        },
        "FUN_00001960": {
            "renaming": {
                "FUN_00001960": "initialize_system_00001960",
                "DAT_000019b4": "DAT_current_mode",
                "DAT_000019b8": "DAT_control_reg",
                "PTR_current_mode_000019bc": "PTR_current_mode",
                "kinetis_mcg_set_fll_factor": "set_fll_factor",
                "KINETIS_MCG_FLL_FACTOR_1464": "1464"
            },
            "code": "void initialize_system_00001960(void)\n{\n  set_fll_factor(KINETIS_MCG_FLL_FACTOR_1464);\n  clear_bit(DAT_000019b4, 0x01);\n  *DAT_000019b8 = (*DAT_000019b8 & 0x3b) | 0x44;\n  while ((DAT_000019b8[6] & 0xc) != 4);\n  while ((DAT_000019b8[6] & 0x10) == 0);\n  *PTR_current_mode_000019bc = 2;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001960",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "initialize_system_00001960"
        },
        "FUN_00000990": {
            "renaming": {
                "FUN_00000990": "do_nothing_00000990"
            },
            "code": "\nvoid do_nothing_00000990(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000990",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "do_nothing_00000990"
        },
        "FUN_00001a3c": {
            "renaming": {
                "FUN_00001a3c": "disable_PLL_and_set_current_mode_to_5_00001a3c",
                "DAT_00001a58": "DAT_pll_status_register",
                "kinetis_mcg_disable_pll": "disable_PLL",
                "*PTR_current_mode_00001a5c": "*PTR_current_mode"
            },
            "code": "void disable_PLL_and_set_current_mode_to_5_00001a3c(void)\n{\n  set_bit_in_byte(DAT_00001a58, 1);\n  disable_PLL();\n  *PTR_current_mode_00001a5c = 5;\n  return;\n}",
            "called": [
                "kinetis_mcg_disable_pll",
                "bit_set8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a3c",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "disable_PLL_and_set_current_mode_to_5_00001a3c"
        },
        "FUN_000045ee": {
            "renaming": {
                "FUN_000045ee": "copy_memory_000045ee",
                "__dest": "destination",
                "__src": "source",
                "__n": "num_bytes",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr"
            },
            "code": "void * copy_memory_000045ee(void * destination, const void * source, size_t num_bytes) {\n  unsigned char *dest = (unsigned char *)destination;\n  const unsigned char *src = (const unsigned char *)source;\n  if (src < dest && dest < src + num_bytes) {\n    for (size_t i = num_bytes; i > 0; i--) {\n      *(dest + i - 1) = *(src + i - 1);\n    }\n  }\n  else {\n    for (size_t i = 0; i < num_bytes; i++) {\n      *(dest + i) = *(src + i);\n    }\n  }\n  return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ee",
            "calling": [
                "fmt_lpad"
            ],
            "imported": false,
            "current_name": "copy_memory_000045ee"
        },
        "FUN_00005404": {
            "renaming": {
                "FUN_00005404": "write_to_stream_00005404",
                "param_1": "stream_handle",
                "param_2": "character",
                "param_3": "stream_buffer",
                "param_4": "write_mode",
                "iVar1": "buffer_size",
                "uVar2": "char_count",
                "puVar3": "buffer_ptr"
            },
            "code": "uint write_to_stream_00005404(int stream_handle, uint character, int *stream_buffer, undefined4 write_mode)\n{\n  int buffer_size;\n  uint char_count;\n  undefined *buffer_ptr;\n  \n  if ((stream_handle != 0) && (*(int *)(stream_handle + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream_buffer == (int *)PTR___sf_fake_stdin_0000549c) {\n    stream_buffer = *(int **)(stream_handle + 4);\n  }\n  else if (stream_buffer == (int *)PTR___sf_fake_stdout_000054a0) {\n    stream_buffer = *(int **)(stream_handle + 8);\n  }\n  else if (stream_buffer == (int *)PTR___sf_fake_stderr_000054a4) {\n    stream_buffer = *(int **)(stream_handle + 0xc);\n  }\n  stream_buffer[2] = stream_buffer[6];\n  char_count = (uint)*(ushort *)(stream_buffer + 3);\n  buffer_size = char_count << 0x1c;\n  if (((buffer_size < 0) && (char_count = stream_buffer[4], char_count != 0)) ||\n     (buffer_size = __swsetup_r(stream_handle,stream_buffer,buffer_size,char_count,write_mode), buffer_size == 0)) {\n    buffer_size = *stream_buffer - stream_buffer[4];\n    character = character & 0xff;\n    if ((buffer_size < stream_buffer[5]) || (buffer_size = _fflush_r(stream_handle,stream_buffer), buffer_size == 0)) {\n      stream_buffer[2] = stream_buffer[2] + -1;\n      buffer_ptr = (undefined *)*stream_buffer;\n      *stream_buffer = (int)(buffer_ptr + 1);\n      *buffer_ptr = (char)character;\n      if (stream_buffer[5] != buffer_size + 1) {\n        if (-1 < (int)((uint)*(ushort *)(stream_buffer + 3) << 0x1f)) {\n          return character;\n        }\n        if (character != 10) {\n          return character;\n        }\n      }\n      buffer_size = _fflush_r(stream_handle,stream_buffer);\n      if (buffer_size == 0) {\n        return character;\n      }\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "__sinit",
                "_fflush_r",
                "__swsetup_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005404",
            "calling": [
                "_puts_r",
                "_putc_r",
                "__sfputc_r"
            ],
            "imported": false,
            "current_name": "write_to_stream_00005404"
        },
        "FUN_00006974": {
            "renaming": {
                "FUN_00006974": "divide_or_modulo_00006974",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "remainder",
                "param_4": "unused",
                "iVar1": "quotient",
                "local_8": "local_array"
            },
            "code": "int divide_or_modulo_00006974(int dividend, int divisor, int* remainder) {\n  int quotient;\n  if (divisor == 0) {\n    if (dividend < 0) {\n      dividend = 0;\n      divisor = -2147483648;\n    }\n    else if (dividend != 0) {\n      dividend = 2147483647;\n      divisor = -1;\n    }\n    quotient = __aeabi_idiv0(dividend, divisor);\n    return quotient;\n  }\n  if (dividend < 0) {\n    quotient = -dividend - (divisor != 0);\n    if (*remainder < 0) {\n      quotient = __udivmoddi4(-dividend, quotient, -divisor, -*remainder - (divisor != 0), remainder);\n      return -quotient;\n    }\n    quotient = __udivmoddi4(-dividend, quotient, divisor, *remainder, remainder);\n    return -quotient;\n  }\n  if (*remainder < 0) {\n    quotient = __udivmoddi4(dividend, divisor, -(*remainder), -*remainder - (divisor != 0), remainder);\n    return -quotient;\n  }\n  quotient = __udivmoddi4(dividend, divisor, remainder);\n  return quotient;\n}",
            "called": [
                "__aeabi_idiv0",
                "__udivmoddi4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006974",
            "calling": [
                "gmtime_r"
            ],
            "imported": false,
            "current_name": "divide_or_modulo_00006974"
        },
        "FUN_00004314": {
            "renaming": {
                "FUN_00004314": "allocate_memory_block_00004314",
                "param_1": "error_code_ptr",
                "piVar1": "block_ptr",
                "piVar2": "current_block_ptr",
                "iVar3": "global_data_ptr",
                "ppiVar4": "next_block_ptr_ptr",
                "PTR__global_impure_ptr_00004398": "global_data_ptr_ptr",
                "DAT_0000439c": "ERROR_CODE"
            },
            "code": "int* allocate_memory_block_00004314(undefined4* error_code_ptr) {\n  int* block_ptr;\n  int* current_block_ptr;\n  int global_data_ptr;\n  int** next_block_ptr_ptr;\n  acquire_memory_lock();\n  global_data_ptr = *(int*)PTR__global_impure_ptr_00004398;\n  if (*(int*)(global_data_ptr + 0x18) == 0) {\n    initialize_global_data(global_data_ptr);\n  }\n  next_block_ptr_ptr = (int**)(global_data_ptr + 0x48);\n  do {\n    current_block_ptr = next_block_ptr_ptr[1];\n    block_ptr = next_block_ptr_ptr[2];\n    while (current_block_ptr = (int*)((int)current_block_ptr - 1), -1 < (int)current_block_ptr) {\n      if (*(short*)(block_ptr + 3) == 0) {\n        block_ptr[3] = DAT_0000439c;\n        block_ptr[0x19] = 0;\n        initialize_recursive_lock(block_ptr + 0x16);\n        release_memory_lock();\n        block_ptr[1] = 0;\n        block_ptr[2] = 0;\n        block_ptr[4] = 0;\n        block_ptr[5] = 0;\n        *block_ptr = 0;\n        block_ptr[6] = 0;\n        memset(block_ptr + 0x17, 0, 8);\n        block_ptr[0xd] = 0;\n        block_ptr[0xe] = 0;\n        block_ptr[0x12] = 0;\n        block_ptr[0x13] = 0;\n        return block_ptr;\n      }\n      block_ptr = block_ptr + 0x1a;\n    }\n    if (*next_block_ptr_ptr == (int*)0x0) {\n      current_block_ptr = (int*)request_more_memory(error_code_ptr, 4);\n      *next_block_ptr_ptr = current_block_ptr;\n      if (current_block_ptr == (int*)0x0) {\n        release_memory_lock();\n        *error_code_ptr = 0xc;\n        return (int*)0x0;\n      }\n    }\n    next_block_ptr_ptr = (int**)*next_block_ptr_ptr;\n  } while (true);\n}",
            "called": [
                "__sfmoreglue",
                "__retarget_lock_init_recursive",
                "__sfp_lock_release",
                "memset",
                "__sinit",
                "__sfp_lock_acquire"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004314",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_00004314"
        },
        "FUN_00005fd4": {
            "renaming": {
                "FUN_00005fd4": "parse_number_00005fd4",
                "param_1": "result",
                "param_2": "input_string",
                "param_3": "next_char",
                "param_4": "base",
                "uVar1": "digit_value",
                "uVar2": "current_char",
                "bVar3": "overflow_check",
                "iVar4": "sign",
                "uVar5": "value",
                "uVar6": "max_digit_value",
                "pbVar7": "current_char_ptr",
                "pbVar8": "next_char_ptr"
            },
            "code": "uint parse_number_00005fd4(undefined4 *result, byte *input_string, byte **next_char, uint base) {\n  uint digit_value;\n  uint overflow_check;\n  byte current_char;\n  int sign;\n  uint value = 0;\n  uint max_digit_value = 0xffffffff / base;\n  \n  // read leading whitespace\n  do {\n    current_char = *input_string++;\n  } while (current_char == ' ' || current_char == '\\t' || current_char == '\\n' || current_char == '\\r');\n  \n  // parse sign\n  sign = 1;\n  if (current_char == '-') {\n    sign = -1;\n    current_char = *input_string++;\n  }\n  else if (current_char == '+') {\n    current_char = *input_string++;\n  }\n  \n  // parse base\n  if (base == 0) {\n    if (current_char == '0') {\n      base = 8;\n      current_char = *input_string++;\n      if ((current_char == 'x') || (current_char == 'X')) {\n        base = 16;\n        current_char = *input_string++;\n      }\n    }\n    else {\n      base = 10;\n    }\n  }\n  else if (base == 16 && current_char == '0' && (*input_string == 'x' || *input_string == 'X')) {\n    current_char = *(input_string + 1);\n    input_string += 2;\n  }\n  \n  // parse digits\n  while (true) {\n    if (current_char >= '0' && current_char <= '9') {\n      digit_value = current_char - '0';\n    }\n    else if (current_char >= 'a' && current_char <= 'z') {\n      digit_value = current_char - 'a' + 10;\n    }\n    else if (current_char >= 'A' && current_char <= 'Z') {\n      digit_value = current_char - 'A' + 10;\n    }\n    else {\n      break;\n    }\n    if (digit_value >= base) {\n      break;\n    }\n    if (value > max_digit_value) {\n      overflow_check = 1;\n    }\n    else if ((value * base) > (max_digit_value + digit_value)) {\n      overflow_check = 1;\n    }\n    else {\n      value = (value * base) + digit_value;\n      overflow_check = 0;\n    }\n    if (overflow_check) {\n      value = 0xffffffff;\n      if (next_char == NULL) {\n        return 0xffffffff;\n      }\n      else {\n        *result = 34; // ASCII code for '\"'\n        return 0xffffffff;\n      }\n    }\n    current_char = *input_string++;\n  }\n  \n  // handle result\n  if (next_char == NULL) {\n    *result = (uint)(sign * value);\n    return (uint)(sign * value);\n  }\n  else {\n    if (input_string == (byte *)(1 + (int)next_char)) {\n      *next_char = (byte *)(1 + (int)next_char);\n    }\n    else {\n      *next_char = input_string - 1;\n    }\n    *result = (uint)(sign * value);\n    return 1;\n  }\n}",
            "called": [
                "_strtoul_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd4",
            "calling": [],
            "imported": false,
            "current_name": "parse_number_00005fd4"
        },
        "FUN_00004dc8": {
            "renaming": {
                "FUN_00004dc8": "read_data_from_file_00004dc8",
                "param_1": "reentrant_struct",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "_Var1": "read_result",
                "uVar2": "new_position",
                "bVar3": "read_success",
                "*(int *)(param_2 + 0x54)": "new_position",
                "*(ushort *)(param_2 + 0xc)": "error_mask"
            },
            "code": "void read_data_from_file_00004dc8(_reent* reentrant_struct, int file_descriptor, void* buffer, size_t buffer_size) {\n  _ssize_t read_result = _read_r(reentrant_struct, (int)*(short *)(file_descriptor + 0xe), buffer, buffer_size);\n  bool read_success = read_result >= 0;\n  if (read_success) {\n    uint new_position = *(int *)(file_descriptor + 0x54) + read_result;\n    *(uint *)(file_descriptor + 0x54) = new_position;\n  }\n  else {\n    uint error_mask = *(ushort *)(file_descriptor + 0xc) & 0xffffefff;\n    *(short *)(file_descriptor + 0xc) = (short)error_mask;\n  }\n  return;\n}",
            "called": [
                "_read_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dc8",
            "calling": [],
            "imported": false,
            "current_name": "read_data_from_file_00004dc8"
        },
        "FUN_00005fd8": {
            "renaming": {
                "FUN_00005fd8": "convertStringToUnsignedLong_00005fd8",
                "__nptr": "string",
                "__endptr": "endPtr",
                "__base": "base",
                "uVar1": "result"
            },
            "code": "unsigned long convertStringToUnsignedLong_00005fd8(char *string, char **endPtr, int base) {\n  unsigned long result = strtoul(*(unsigned int *)PTR__impure_ptr_00005fe8, string, endPtr, base);\n  return result;\n}",
            "called": [
                "_strtoul_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd8",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "convertStringToUnsignedLong_00005fd8"
        },
        "FUN_00005e10": {
            "renaming": {
                "FUN_00005e10": "refill_buffer_00005e10",
                "param_1": "stream",
                "param_2": "buffer",
                "iVar1": "status",
                "uVar2": "result",
                "pbVar3": "current_byte"
            },
            "code": "uint refill_buffer_00005e10(int stream, byte **buffer){\n  int status;\n  uint result;\n  byte *current_byte;\n  \n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (buffer == (byte **)PTR___sf_fake_stdin_00005e5c) {\n    buffer = *(byte ***)(stream + 4);\n  }\n  else if (buffer == (byte **)PTR___sf_fake_stdout_00005e60) {\n    buffer = *(byte ***)(stream + 8);\n  }\n  else if (buffer == (byte **)PTR___sf_fake_stderr_00005e64) {\n    buffer = *(byte ***)(stream + 0xc);\n  }\n  status = __srefill_r(stream, buffer);\n  if (status == 0) {\n    buffer[1] = buffer[1] + -1;\n    current_byte = *buffer;\n    *buffer = current_byte + 1;\n    result = (uint)*current_byte;\n  }\n  else {\n    result = 0xffffffff;\n  }\n  return result;\n}",
            "called": [
                "__srefill_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e10",
            "calling": [
                "_getc_r"
            ],
            "imported": false,
            "current_name": "refill_buffer_00005e10"
        },
        "FUN_000033f4": {
            "renaming": {
                "FUN_000033f4": "set_alarm_if_valid_time_000033f4",
                "argv": "arguments",
                "now": "current_time",
                "iVar1": "return_value"
            },
            "code": "int set_alarm_if_valid_time_000033f4(char **arguments)\n{\n  int return_value;\n  tm current_time;\n  return_value = parse_time(arguments, &current_time);\n  if (return_value == 0) {\n    return_value = rtc_set_alarm(&current_time, DAT_0000343c, (void *)0x0);\n    if (return_value == -1) {\n      puts(PTR_s_rtc__error_setting_alarm_00003440);\n      return_value = 1;\n    }\n    else {\n      return_value = 0;\n    }\n  }\n  else {\n    return_value = 1;\n  }\n  return return_value;\n}",
            "called": [
                "_parse_time",
                "puts",
                "rtc_set_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033f4",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "set_alarm_if_valid_time_000033f4"
        },
        "FUN_0000443c": {
            "renaming": {
                "FUN_0000443c": "decode_time_0000443c",
                "__timer": "timer",
                "__tp": "time_info",
                "iVar1": "quotient",
                "uVar2": "remainder",
                "uVar3": "year",
                "uVar4": "month",
                "iVar5": "day",
                "uVar6": "weekday",
                "uVar9": "yearday",
                "tVar7": "seconds_since_epoch",
                "tVar8": "remaining_seconds",
                "DAT_0000458c": "SECONDS_IN_DAY",
                "DAT_00004594": "DAYS_IN_400_YEARS",
                "DAT_00004590": "DAYS_IN_100_YEARS",
                "DAT_00004598": "DAYS_IN_4_YEARS",
                "count_leading_zeroes": "count_leading_zeros"
            },
            "code": "tm* decode_time_0000443c(time_t* timer, tm* time_info) {\n  int quotient;\n  uint remainder, year, month, day, weekday, yearday;\n  time_t seconds_since_epoch = *timer;\n  time_t remaining_seconds = timer[1];\n  quotient = __aeabi_ldivmod(seconds_since_epoch, remaining_seconds, 86400, 0);\n  remainder = quotient;\n  if ((int)remainder < 0) {\n    remainder += 86400;\n    quotient += 1;\n  }\n  weekday = (quotient + 3) % 7;\n  year = 400 * (quotient / 146097) + 1;\n  quotient %= 146097;\n  if (quotient >= 36524) {\n    year += 100 * ((quotient - 1) / 36524);\n    quotient = (quotient - 1) % 36524;\n    year += 4 * (quotient / 1461);\n    quotient %= 1461;\n    if (quotient >= 366) {\n      year += (quotient - 1) / 365;\n      quotient = (quotient - 1) % 365;\n    }\n    else {\n      remainder += 86400;\n      yearday = quotient + 31 + 28;\n      goto set_day_and_month;\n    }\n  }\n  year += 4 * (quotient / 1461);\n  quotient %= 1461;\n  if (quotient >= 366) {\n    year += (quotient - 1) / 365;\n    quotient = (quotient - 1) % 365;\n  }\n  else {\n    remainder += 86400;\n    yearday = quotient + 31 + 28;\n    goto set_day_and_month;\n  }\n  year += quotient / 365;\n  yearday = quotient % 365;\n  if ((yearday >= 59) && (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0))) {\n    yearday++;\n  }\n  set_day_and_month:\n  month = (100 * yearday + 52) / 3060;\n  day = yearday - (month * 306 + 5) / 10 + 1;\n  month += (month < 10) ? 3 : -9;\n  time_info->tm_sec = remainder % 60;\n  remainder /= 60;\n  time_info->tm_min = remainder % 60;\n  remainder /= 60;\n  time_info->tm_hour = remainder;\n  time_info->tm_mday = day;\n  time_info->tm_mon = month;\n  time_info->tm_year = year - 1900;\n  time_info->tm_wday = weekday;\n  time_info->tm_yday = yearday;\n  time_info->tm_isdst = 0;\n  return time_info;\n}",
            "called": [
                "__aeabi_ldivmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000443c",
            "calling": [
                "rtc_get_alarm",
                "rtc_get_time"
            ],
            "imported": false,
            "current_name": "decode_time_0000443c"
        },
        "FUN_000027b0": {
            "renaming": {
                "FUN_000027b0": "initialize_RTC_000027b0",
                "puVar1": "rtc_data_ptr",
                "rtt": "rtc"
            },
            "code": "void initialize_RTC_000027b0(void)\n{\n  uint32_t *rtc_data_ptr;\n  RTC_Type *rtc;\n  \n  rtc_data_ptr = DAT_00002814;\n  *(uint32_t *)(DAT_00002818 + 0x103c) |= 0x20000000;\n  rtc_data_ptr[4] = 1;\n  rtc_data_ptr[4] = 0;\n  if ((rtc_data_ptr[5] & 1) != 0) {\n    *rtc_data_ptr = 0;\n  }\n  rtc_data_ptr[4] = 0x104;\n  rtc_data_ptr[2] = 0xffffff42;\n  rtc_data_ptr[7] = 0;\n  rtt_poweron();\n  return;\n}",
            "called": [
                "rtt_poweron"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000027b0",
            "calling": [
                "rtc_init"
            ],
            "imported": false,
            "current_name": "initialize_RTC_000027b0"
        },
        "FUN_00005ebc": {
            "renaming": {
                "FUN_00005ebc": "copy_string_00005ebc",
                "__dest": "destination",
                "__src": "source",
                "cVar1": "current_char",
                "pcVar2": "destination_ptr"
            },
            "code": "char* copy_string_00005ebc(char* destination, char* source){\n  char current_char;\n  char* destination_ptr = destination;\n  do {\n    current_char = *source;\n    *destination_ptr = current_char;\n    source++;\n    destination_ptr++;\n  } while (current_char != '\\0');\n  return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ebc",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "copy_string_00005ebc"
        },
        "FUN_00006192": {
            "renaming": {
                "FUN_00006192": "handle_memory_allocation_00006192",
                "param_1": "size",
                "param_2": "data",
                "param_2[0xd]": "data[13]",
                "(undefined4 *)0x0": "NULL",
                "param_2 + 0x11": "data + 17",
                "_free_r": "free",
                "param_2[1]": "data[1]",
                "param_2[0x10]": "data[16]",
                "param_2[0xf]": "data[15]",
                "*param_2": "*data",
                "0xffffffff": "-1",
                "ushort": "unsigned short",
                "*(ushort *)(param_2 + 3)": "*(unsigned short *)(data + 3)",
                "0x20": "0x20"
            },
            "code": "int handle_memory_allocation_00006192(int size, int *data)\n{\n    int *ptr_check = (int *)data[13];\n    if (ptr_check != NULL)\n    {\n        if (ptr_check != data + 17)\n        {\n            free(ptr_check);\n        }\n        data[1] = data[16];\n        data[13] = NULL;\n        if (data[16] != NULL)\n        {\n            *data = data[15];\n            return 0;\n        }\n    }\n    *data = data[4];\n    data[1] = 0;\n    *(unsigned short *)(data + 3) = *(unsigned short *)(data + 3) | 0x20;\n    return -1;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006192",
            "calling": [
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "handle_memory_allocation_00006192"
        },
        "FUN_00001734": {
            "renaming": {
                "FUN_00001734": "clear_bit_at_position_six_00001734",
                "DAT_00001744": "data_register"
            },
            "code": "void clear_bit_at_position_six_00001734(void)\n{\n  bit_clear8(DAT_00001744, 0x06);\n  return;\n}",
            "called": [
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001734",
            "calling": [
                "kinetis_mcg_set_blpi",
                "kinetis_mcg_set_blpe",
                "kinetis_mcg_set_fbe"
            ],
            "imported": false,
            "current_name": "clear_bit_at_position_six_00001734"
        },
        "FUN_00000e14": {
            "renaming": {
                "FUN_00000e14": "read_isrpipe_00000e14",
                "buffer": "buffer",
                "count": "count",
                "iVar1": "num_bytes_read"
            },
            "code": "int read_isrpipe_00000e14(char *buffer, int count)\n{\n  int num_bytes_read;\n  num_bytes_read = isrpipe_read((isrpipe_t *)PTR_uart_stdio_isrpipe_00000e34, buffer, count);\n  return num_bytes_read;\n}",
            "called": [
                "isrpipe_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e14",
            "calling": [
                "_read_r"
            ],
            "imported": false,
            "current_name": "read_isrpipe_00000e14"
        },
        "FUN_0000281c": {
            "renaming": {
                "FUN_0000281c": "read_RTC_value_0000281c",
                "rtt": "rtc_pointer",
                "i": "loop_counter",
                "t": "time_value"
            },
            "code": "uint32_t read_RTC_value_0000281c(void)\n{\n  RTC_Type *rtc_pointer;\n  int i = 0;\n  uint32_t time_value;\n  \n  while ((i < 3 && (time_value = *DAT_00002858, time_value != *DAT_00002858))) {\n    i = i + 1;\n  }\n  return time_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000281c",
            "calling": [
                "rtc_get_time"
            ],
            "imported": false,
            "current_name": "read_RTC_value_0000281c"
        },
        "FUN_00002270": {
            "renaming": {
                "FUN_00002270": "is_rb_empty_00002270",
                "rb": "ring_buffer",
                "bVar1": "write_byte",
                "uVar2": "writes",
                "bVar3": "is_empty"
            },
            "code": "bool is_rb_empty_00002270(tsrb_t *ring_buffer){\n  uint writes = ring_buffer->writes;\n  bool is_empty = (ring_buffer->reads == writes);\n  if (is_empty) {\n    writes = 1;\n  }\n  byte write_byte = (byte)writes;\n  if (!is_empty) {\n    write_byte = 0;\n  }\n  return (uint)write_byte;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002270",
            "calling": [
                "tsrb_get"
            ],
            "imported": false,
            "current_name": "is_rb_empty_00002270"
        },
        "FUN_00005780": {
            "renaming": {
                "FUN_00005780": "call_function_with_ptr_00005780",
                "__ptr": "ptr",
                "_FUN_00005780_r": "function_with_ptr"
            },
            "code": "void call_function_with_ptr_00005780(void *ptr) {\n  function_with_ptr(*(int *)PTR__impure_ptr_0000578c, ptr);\n  return;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005780",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "call_function_with_ptr_00005780"
        },
        "FUN_000020cc": {
            "renaming": {
                "FUN_000020cc": "handle_interrupt_000020cc",
                "DAT_000020dc": "interrupt_number"
            },
            "code": "void handle_interrupt_000020cc(void)\n{\n  int DAT_000020dc = DAT_000020dc;\n  int enable_interrupts = 1;\n  irq_handler(DAT_000020dc, enable_interrupts);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020cc",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_000020cc"
        },
        "FUN_00002396": {
            "renaming": {
                "FUN_00002396": "initialize_real_time_clock_00002396"
            },
            "code": "void initialize_real_time_clock_00002396(void)\n{\n  rtc_init();\n  return;\n}",
            "called": [
                "rtc_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002396",
            "calling": [
                "cpu_init"
            ],
            "imported": false,
            "current_name": "initialize_real_time_clock_00002396"
        },
        "FUN_00004e4a": {
            "renaming": {
                "FUN_00004e4a": "close_file_descriptor_00004e4a",
                "param_1": "reentrancy_data",
                "param_2": "file_descriptor"
            },
            "code": "void close_file_descriptor_00004e4a(_reent *reentrancy_data, int file_descriptor) {\n  _close_r(reentrancy_data, (int)*(short *)(file_descriptor + 0xe));\n  return;\n}",
            "called": [
                "_close_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e4a",
            "calling": [],
            "imported": false,
            "current_name": "close_file_descriptor_00004e4a"
        },
        "FUN_00004cb4": {
            "renaming": {
                "FUN_00004cb4": "put_char_00004cb4",
                "__c": "character",
                "in_r3": "in_register_3",
                "iVar1": "impure_ptr",
                "PTR__impure_ptr_00004cd8": "PTR__impure_ptr_00004cd8",
                "__sinit": "__sinit",
                "_putc_r": "_putc_r"
            },
            "code": "int put_char_00004cb4(int character) {\n  undefined4 in_register_3;\n  int impure_ptr = *(int *)PTR__impure_ptr_00004cd8;\n  if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n    __sinit(impure_ptr);\n  }\n  int result = _putc_r(impure_ptr, character, *(undefined4 *)(impure_ptr + 8), in_register_3);\n  return result;\n}",
            "called": [
                "_putc_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cb4",
            "calling": [
                "_putchar"
            ],
            "imported": false,
            "current_name": "put_char_00004cb4"
        },
        "FUN_00003478": {
            "renaming": {
                "FUN_00003478": "set_rtc_time_00003478",
                "argv": "arguments",
                "now": "current_time",
                "iVar1": "parse_result",
                "_parse_time": "parse_time_from_args",
                "rtc_set_time": "rtc_set_time",
                "PTR_s_rtc__error_setting_time_000034bc": "PTR_s_rtc__error_setting_time_000034bc"
            },
            "code": "int set_rtc_time_00003478(char **arguments)\n{\n  int parse_result;\n  tm current_time;\n  \n  parse_result = parse_time_from_args(arguments,&current_time);\n  if (parse_result == 0) {\n    int set_result = rtc_set_time(&current_time);\n    if (set_result == -1) {\n      puts(PTR_s_rtc__error_setting_time_000034bc);\n      return 1;\n    }\n    else {\n      return 0;\n    }\n  }\n  else {\n    return 1;\n  }\n}",
            "called": [
                "_parse_time",
                "puts",
                "rtc_set_time"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003478",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "set_rtc_time_00003478"
        },
        "FUN_00002028": {
            "renaming": {
                "FUN_00002028": "handle_interrupt_00002028",
                "port_num": "port_number",
                "iVar1": "context_index",
                "uVar2": "interrupt_status",
                "ctx": "N/A"
            },
            "code": "void handle_interrupt_00002028(PORT_Type *port, int port_number) {\n  int context_index;\n  uint32_t interrupt_status;\n  int i;\n  interrupt_status = port->ISFR;\n  for (i = 0; i < 0x20; i++) {\n    if (((interrupt_status & (1 << (i & 0xffU))) != 0) && ((port->PCR[i] & 0xf0000) != 0)) {\n      port->ISFR = (1 << (i & 0xffU));\n      context_index = get_context_index(port_number, i);\n      (**(code **)(PTR_isr_ctx_000020b4 + context_index * 0xc))(*(undefined4 *)(PTR_isr_ctx_000020b4 + context_index * 0xc + 4));\n    }\n  }\n  end_interrupt_handler();\n  return;\n}",
            "called": [
                "get_ctx",
                "cortexm_isr_end"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002028",
            "calling": [
                "isr_porte",
                "isr_portd",
                "isr_portc",
                "isr_portb",
                "isr_porta"
            ],
            "imported": false,
            "current_name": "handle_interrupt_00002028"
        },
        "FUN_000016c8": {
            "renaming": {
                "FUN_000016c8": "set_bit_000016c8",
                "ptr": "ptr",
                "bit": "bit",
                "puVar1": "target_bit"
            },
            "code": "void set_bit_000016c8(uint32_t *ptr, uint8_t bit)\n{\n  undefined4 *target_bit;\n  target_bit = (undefined4 *)bitband_addr(ptr,(uint)bit);\n  *target_bit = 1;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016c8",
            "calling": [
                "kinetis_mcg_init_erclk32k"
            ],
            "imported": false,
            "current_name": "set_bit_000016c8"
        },
        "FUN_00001a60": {
            "renaming": {
                "FUN_00001a60": "set_current_mode_to_six_00001a60",
                "DAT_00001ac4": "current_mode_byte",
                "DAT_00001ac8": "mode_register_byte",
                "DAT_00001acc": "status_byte",
                "PTR_current_mode_00001ad0": "PTR_current_mode_00001ad0"
            },
            "code": "void set_current_mode_to_six_00001a60(void)\n{\n  clear_bit_in_byte(DAT_00001ac4, MODE_BIT_1);\n  *DAT_00001ac8 = (*DAT_00001ac8 & 0x3f) | 0x80;\n  do {} while ((DAT_00001ac8[6] & 0xc) != 8);\n  set_bit_in_byte(DAT_00001ac4, MODE_BIT_6);\n  do {} while ((DAT_00001ac8[6] & 0x20) == 0);\n  do {} while ((DAT_00001ac8[6] & 0x40) == 0);\n  *PTR_current_mode_00001ad0 = 6;\n  return;\n}",
            "called": [
                "bit_clear8",
                "bit_set8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a60",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "set_current_mode_to_six_00001a60"
        },
        "FUN_000004b2": {
            "renaming": {
                "FUN_000004b2": "write_to_uart_000004b2",
                "r": "reent",
                "fd": "file_descriptor",
                "data": "data_buffer",
                "count": "data_size",
                "iVar1": "bytes_written"
            },
            "code": "_ssize_t write_to_uart_000004b2(_reent *reent, int file_descriptor, void *data_buffer, size_t data_size) {\n  int bytes_written;\n  bytes_written = uart_stdio_write((char *)data_buffer, data_size);\n  return bytes_written;\n}",
            "called": [
                "uart_stdio_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004b2",
            "calling": [
                "__swrite"
            ],
            "imported": false,
            "current_name": "write_to_uart_000004b2"
        },
        "FUN_0000099c": {
            "renaming": {
                "FUN_0000099c": "initialize_system_0000099c",
                "uStack_18": "stack_top",
                "top": "stack_ptr",
                "src": "src_ptr",
                "dst": "dst_ptr"
            },
            "code": "void initialize_system_0000099c(void)\n{\n  uint32_t stack_top;\n  uint32_t *stack_ptr;\n  uint32_t *src_ptr;\n  uint32_t *dst_ptr;\n  stack_ptr = &stack_top;\n  src_ptr = (uint32_t *)PTR__etext_00000a14;\n  pre_startup();\n  dst_ptr = (uint32_t *)PTR_isr_stack_00000a18;\n  while (dst_ptr < &stack_top) {\n    *dst_ptr = DAT_00000a1c;\n    dst_ptr++;\n  }\n  dst_ptr = (uint32_t *)PTR_heap_top_00000a20;\n  while (dst_ptr < PTR_sched_num_threads_00000a24) {\n    *dst_ptr = *src_ptr;\n    src_ptr++;\n    dst_ptr++;\n  }\n  dst_ptr = (uint32_t *)PTR_sched_num_threads_00000a28;\n  while (dst_ptr < PTR__sheap_00000a2c) {\n    *dst_ptr = 0;\n    dst_ptr++;\n  }\n  post_startup();\n  board_init();\n  __libc_init_array();\n  kernel_init();\n  return;\n}",
            "called": [
                "__libc_init_array",
                "kernel_init",
                "pre_startup",
                "board_init",
                "post_startup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000099c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_system_0000099c"
        },
        "FUN_00002d94": {
            "renaming": {
                "FUN_00002d94": "read_input_line_00002d94",
                "buf": "buffer",
                "size": "buffer_size",
                "c_00": "input_char",
                "bVar1": "byte_var",
                "bVar2": "bool_var",
                "c": "return_value",
                "line_buf_ptr": "buffer_ptr"
            },
            "code": "int read_input_line_00002d94(char *buffer, size_t buffer_size)\n{\n  int input_char;\n  byte byte_var;\n  bool bool_var;\n  int return_value;\n  char *buffer_ptr;\n  buffer_ptr = buffer;\n  while (true) {\n    if ((int)(buffer_size - 1) <= (int)buffer_ptr - (int)buffer) {\n      return -1;\n    }\n    input_char = getchar();\n    if (input_char < 0) {\n      break;\n    }\n    if ((input_char == 0xd) || (input_char == 10)) {\n      *buffer_ptr = '\\0';\n      putchar(0xd);\n      putchar(10);\n      bool_var = buffer_ptr == buffer;\n      if (bool_var) {\n        buffer = (char *)0x1;\n      }\n      byte_var = (byte)buffer;\n      if (!bool_var) {\n        byte_var = 0;\n      }\n      return (uint)byte_var;\n    }\n    if ((input_char == 8) || (input_char == 0x7f)) {\n      if (buffer_ptr != buffer) {\n        buffer_ptr--;\n        *buffer_ptr = '\\0';\n        putchar(8);\n        putchar(0x20);\n        putchar(8);\n      }\n    }\n    else {\n      *buffer_ptr = (char)input_char;\n      putchar(input_char);\n      buffer_ptr++;\n    }\n  }\n  return 1;\n}",
            "called": [
                "getchar",
                "_putchar"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002d94",
            "calling": [
                "shell_run"
            ],
            "imported": false,
            "current_name": "read_input_line_00002d94"
        },
        "FUN_00003918": {
            "renaming": {
                "FUN_00003918": "get_scale_prefix_00003918",
                "scale": "scale",
                "cVar1": "prefix"
            },
            "code": "char get_scale_prefix_00003918(int8_t scale) {\n  char prefix;\n  switch(scale) {\n    case 2:\n      prefix = 'h';\n      break;\n    case 3:\n      prefix = 'k';\n      break;\n    case 6:\n      prefix = 'M';\n      break;\n    case 9:\n      prefix = 'G';\n      break;\n    case 12:\n      prefix = 'T';\n      break;\n    case 15:\n      prefix = 'P';\n      break;\n    case -15:\n      prefix = 'f';\n      break;\n    case -12:\n      prefix = 'p';\n      break;\n    case -9:\n      prefix = 'n';\n      break;\n    case -6:\n      prefix = 'u';\n      break;\n    case -3:\n      prefix = 'm';\n      break;\n    default:\n      prefix = '\\0';\n      break;\n  }\n  return prefix;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003918",
            "calling": [
                "phydat_dump"
            ],
            "imported": false,
            "current_name": "get_scale_prefix_00003918"
        },
        "FUN_00003d64": {
            "renaming": {
                "FUN_00003d64": "read_sensor_data_00003d64",
                "dev": "sensor",
                "res": "data",
                "iVar1": "result"
            },
            "code": "int read_sensor_data_00003d64(saul_reg_t *sensor, phydat_t *data) {\n  int result;\n  if (sensor == NULL) {\n    result = -19;\n  }\n  else {\n    result = (*sensor->driver->read)(sensor->dev, data);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d64",
            "calling": [
                "probe"
            ],
            "imported": false,
            "current_name": "read_sensor_data_00003d64"
        },
        "FUN_00004e52": {
            "renaming": {
                "FUN_00004e52": "compare_strings_00004e52",
                "__s1": "string1",
                "__s2": "string2",
                "bVar1": "compare_char",
                "uVar2": "current_char",
                "bVar3": "strings_match"
            },
            "code": "int compare_strings_00004e52(char* string1, char* string2) {\n  uint8_t current_char;\n  uint8_t compare_char;\n  bool strings_match = true;\n  do {\n    current_char = (uint8_t)*string1;\n    compare_char = *string2;\n    if (current_char != 0) {\n      strings_match = (current_char == compare_char);\n    }\n    string1++;\n    string2++;\n  } while (strings_match && current_char != 0);\n  return current_char - compare_char;\n}",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e52",
            "calling": [
                "_tzset_unlocked_r",
                "_saul",
                "read",
                "strcmp",
                "handle_input_line",
                "find_handler"
            ],
            "imported": false,
            "current_name": "compare_strings_00004e52"
        },
        "FUN_000010d4": {
            "renaming": {
                "FUN_000010d4": "create_thread_000010d4",
                "stacksize": "stack_size",
                "state_00": "state",
                "local_30": "total_stack_size",
                "local_2c": "stack_pointer",
                "stack_size": "stack_size_aligned",
                "process": "thread",
                "i": "pid",
                "flags": "flags",
                "function": "function",
                "arg": "arg",
                "name": "name",
                "priority": "priority",
                "PTR_sched_threads_0000126c": "sched_threads",
                "PTR_sched_num_threads_00001270": "sched_num_threads"
            },
            "code": "kernel_pid_t create_thread_000010d4(char *stack, int stack_size, char priority, int flags, thread_task_func_t function, void *arg, char *name) {\n  uint state;\n  char *stack_aligned;\n  thread_t *thread;\n  uintptr_t *stack_max;\n  int total_stack_size;\n  uintptr_t *stack_pointer;\n  kernel_pid_t pid;\n\n  if (priority < 0x10) {\n    stack_aligned = (char *)(((uint)stack + 3) & ~3);\n    total_stack_size = stack_size - (stack_aligned - stack) - 0x30;\n    stack_max = (uintptr_t *)(stack_aligned + total_stack_size);\n    thread = (thread_t *)(stack_max - 1);\n    if ((flags & 8U) == 0) {\n      *stack_max = (uintptr_t)stack_max;\n    }\n    else {\n      for (stack_pointer = stack_max; stack_pointer >= (uintptr_t *)stack_aligned; stack_pointer--) {\n        *stack_pointer = (uintptr_t)stack_pointer;\n      }\n    }\n    state = irq_disable();\n    pid = 0;\n    for (int i = 1; i < 0x21; i++) {\n      if (*(int *)(PTR_PTR_sched_threads_0000126c_0000126c + i * 4) == 0) {\n        pid = i;\n        break;\n      }\n    }\n    if (pid == 0) {\n      irq_restore(state);\n      return -0x8b;\n    }\n    *(thread_t **)(PTR_PTR_sched_threads_0000126c_0000126c + pid * 4) = thread;\n    thread->pid = pid;\n    thread->sp = thread_stack_init(function, arg, stack_aligned, total_stack_size);\n    thread->stack_start = stack;\n    thread->stack_size = stack_size;\n    thread->name = name;\n    thread->priority = priority;\n    thread->status = THREAD_STATUS_PENDING;\n    thread->rq_entry.next = NULL;\n    thread->wait_data = NULL;\n    thread->msg_waiters.next = NULL;\n    cib_init(&thread->msg_queue, 0);\n    thread->msg_array = NULL;\n    *(int *)PTR_PTR_sched_num_threads_00001270_00001270 += 1;\n    if ((flags & 1U) == 0) {\n      sched_set_status(thread, THREAD_STATUS_PENDING);\n      if ((flags & 4U) == 0) {\n        irq_restore(state);\n        sched_switch(priority);\n        return pid;\n      }\n    }\n    else {\n      sched_set_status(thread, THREAD_STATUS_RECEIVE_BLOCKED);\n    }\n    irq_restore(state);\n  }\n  else {\n    pid = -0x16;\n  }\n  return pid;\n}",
            "called": [
                "irq_disable",
                "sched_set_status",
                "irq_restore",
                "sched_switch",
                "thread_stack_init",
                "cib_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010d4",
            "calling": [
                "kernel_init"
            ],
            "imported": false,
            "current_name": "create_thread_000010d4"
        },
        "FUN_000045e4": {
            "renaming": {
                "FUN_000045e4": "do_nothing_000045e4"
            },
            "code": "\nvoid do_nothing_000045e4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e4",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e4"
        },
        "FUN_00000738": {
            "renaming": {
                "FUN_00000738": "check_thread_priority_and_yield_if_needed_00000738",
                "other_prio": "other_priority",
                "iVar1": "is_irq_enabled",
                "current_prio": "current_priority",
                "active_thread": "active_thread",
                "on_runqueue": "is_on_runqueue"
            },
            "code": "void check_thread_priority_and_yield_if_needed_00000738(uint16_t other_priority) {\n  int is_irq_enabled;\n  uint16_t current_priority;\n  thread_t *active_thread;\n  int is_on_runqueue;\n  \n  active_thread = *(thread_t **)PTR_sched_active_thread_0000078c;\n  current_priority = *(byte *)(active_thread + 4);\n  is_on_runqueue = *(byte *)(active_thread + 5);\n  if (current_priority < 9 || other_priority < is_on_runqueue) {\n    is_irq_enabled = irq_is_in();\n    if (is_irq_enabled == 0) {\n      thread_yield_higher();\n    }\n    else {\n      *(undefined4 *)PTR_sched_context_switch_request_00000790 = 1;\n    }\n  }\n  return;\n}",
            "called": [
                "thread_yield_higher",
                "irq_is_in"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000738",
            "calling": [
                "mutex_unlock",
                "thread_create"
            ],
            "imported": false,
            "current_name": "check_thread_priority_and_yield_if_needed_00000738"
        },
        "FUN_000045e6": {
            "renaming": {
                "FUN_000045e6": "do_nothing_000045e6"
            },
            "code": "\nvoid do_nothing_000045e6(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e6",
            "calling": [
                "__tz_lock"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e6"
        },
        "FUN_00003e58": {
            "renaming": {
                "FUN_00003e58": "convert_int32_to_string_00003e58",
                "out": "output_string",
                "val": "input_value",
                "local_18": "absolute_value",
                "local_14": "string_pointer",
                "negative": "is_negative",
                "sVar1": "string_length"
            },
            "code": "size_t convert_int32_to_string_00003e58(char *output_string, int32_t input_value) {\n  size_t string_length;\n  uint32_t absolute_value;\n  char *string_pointer;\n  uint32_t is_negative;\n\n  absolute_value = input_value;\n  string_pointer = output_string;\n  is_negative = -(input_value >> 0x1f);\n  if (is_negative != 0) {\n    if (output_string != (char *)0x0) {\n      string_pointer = output_string + 1;\n      *output_string = '-';\n    }\n    absolute_value = -input_value;\n  }\n  string_length = fmt_u32_dec(string_pointer, absolute_value);\n  return is_negative + string_length;\n}",
            "called": [
                "fmt_u32_dec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e58",
            "calling": [
                "fmt_s32_dfp"
            ],
            "imported": false,
            "current_name": "convert_int32_to_string_00003e58"
        },
        "FUN_00004e26": {
            "renaming": {
                "FUN_00004e26": "file_seek_00004e26",
                "param_1": "reent_ptr",
                "param_2": "file_descriptor",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "seek_result",
                "uVar2": "flags",
                "bVar3": "error_occurred"
            },
            "code": "void file_seek_00004e26(_reent *reent_ptr, int file_descriptor, _off_t offset, int whence) {\n  _off_t seek_result;\n  ushort flags;\n  bool error_occurred;\n  seek_result = _lseek_r(reent_ptr, (int)*(short *)(file_descriptor + 0xe), offset, whence);\n  error_occurred = seek_result == -1;\n  if (error_occurred) {\n    flags = *(ushort *)(file_descriptor + 0xc) & 0xefff;\n  }\n  else {\n    *(_off_t *)(file_descriptor + 0x54) = seek_result;\n    flags = *(ushort *)(file_descriptor + 0xc) | 0x1000;\n  }\n  if (error_occurred) {\n    *(ushort *)(file_descriptor + 0xc) = flags;\n  }\n  else {\n    *(ushort *)(file_descriptor + 0xc) = flags;\n  }\n}",
            "called": [
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e26",
            "calling": [],
            "imported": false,
            "current_name": "file_seek_00004e26"
        },
        "FUN_00000978": {
            "renaming": {
                "FUN_00000978": "execute_active_thread_00000978",
                "PTR_sched_active_thread_0000098c": "active_thread_ptr",
                "UNRECOVERED_JUMPTABLE": "jump_table",
                "ppcVar2": "process_stack_pointer",
                "bVar1": "is_privileged_mode"
            },
            "code": "void execute_active_thread_00000978(void)\n{\n  bool is_privileged_mode;\n  code *jump_table;\n  code **process_stack_pointer;\n\n  jump_table = *(code **)**(undefined4 **)PTR_sched_active_thread_0000098c;\n  process_stack_pointer = (code **)**(undefined4 **)PTR_sched_active_thread_0000098c + 9;\n  is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    setProcessStackPointer(process_stack_pointer);\n  }\n  (*jump_table)(jump_table,process_stack_pointer);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000978",
            "calling": [],
            "imported": false,
            "current_name": "execute_active_thread_00000978"
        },
        "FUN_000045e8": {
            "renaming": {
                "FUN_000045e8": "do_nothing_000045e8"
            },
            "code": "\nvoid do_nothing_000045e8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e8",
            "calling": [
                "_puts_r",
                "__env_lock",
                "_putc_r",
                "_getc_r",
                "__malloc_lock",
                "_fflush_r",
                "_vfprintf_r",
                "__sinit_lock_acquire",
                "__sfp_lock_acquire"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e8"
        },
        "FUN_000057f8": {
            "renaming": {
                "FUN_000057f8": "FUNC_000057f8"
            },
            "code": "\nint FUNC_000057f8(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  bool bVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  int iVar4;\n  int iVar5;\n  void *pvVar6;\n  int *piVar7;\n  byte *pbVar8;\n  int unaff_r7;\n  byte *pbVar9;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 uStack_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_2 == PTR___sf_fake_stdin_00005a38) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR___sf_fake_stdout_00005a3c) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR___sf_fake_stderr_00005a40) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n     (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n    __retarget_lock_acquire_recursive(*(undefined4 *)(param_2 + 0x58));\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar4 = __swsetup_r(param_1,param_2), iVar4 != 0)) {\n    if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n       (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n      __retarget_lock_release_recursive(*(undefined4 *)(param_2 + 0x58));\n    }\n    return -1;\n  }\n  puVar2 = PTR_s___0__00005a44;\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar9 = param_3;\n  local_8c = param_4;\nLAB_0000588e:\n  pbVar8 = pbVar9;\n  if (*pbVar8 != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  pbVar9 = pbVar8 + 1;\n  if (*pbVar8 != 0x25) goto LAB_0000588e;\nLAB_0000589a:\n  iVar4 = (int)pbVar8 - (int)param_3;\n  if (iVar4 != 0) {\n    iVar5 = __sfputs_r(param_1,param_2,param_3,iVar4);\n    if (iVar5 == -1) {\nLAB_00005a06:\n      if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n         (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n        __retarget_lock_release_recursive(*(undefined4 *)(param_2 + 0x58));\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar4;\n  }\n  if (*pbVar8 == 0) goto LAB_00005a06;\n  local_84 = -1;\n  uStack_80 = 0;\n  local_88 = 0;\n  local_7c = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar9 = pbVar8 + 1;\n  while( true ) {\n    pbVar8 = pbVar9 + 1;\n    pvVar6 = memchr(PTR_s___0__00005a44,(uint)*pbVar9,5);\n    puVar3 = PTR_DAT_00005a54;\n    if (pvVar6 == (void *)0x0) break;\n    local_88 = 1 << ((int)pvVar6 - (int)puVar2 & 0xffU) | local_88;\n    pbVar9 = pbVar8;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar9 == 0x2a) {\n    piVar7 = local_8c + 1;\n    local_7c = *local_8c;\n    local_8c = piVar7;\n    if (local_7c < 0) {\n      local_7c = -local_7c;\n      local_88 = local_88 | 2;\n    }\n  }\n  else {\n    bVar1 = false;\n    iVar4 = local_7c;\n    pbVar8 = pbVar9;\n    while( true ) {\n      if (9 < *pbVar8 - 0x30) break;\n      iVar4 = iVar4 * 10 + (*pbVar8 - 0x30);\n      bVar1 = true;\n      pbVar8 = pbVar8 + 1;\n    }\n    if (bVar1) {\n      local_7c = iVar4;\n    }\n  }\n  if (*pbVar8 == 0x2e) {\n    if (pbVar8[1] == 0x2a) {\n      local_84 = *local_8c;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n      pbVar8 = pbVar8 + 2;\n      local_8c = local_8c + 1;\n    }\n    else {\n      bVar1 = false;\n      local_84 = 0;\n      iVar4 = 0;\n      while( true ) {\n        pbVar8 = pbVar8 + 1;\n        if (9 < *pbVar8 - 0x30) break;\n        iVar4 = iVar4 * 10 + (*pbVar8 - 0x30);\n        bVar1 = true;\n      }\n      if (bVar1) {\n        local_84 = iVar4;\n      }\n    }\n  }\n  pvVar6 = memchr(PTR_DAT_00005a54,(uint)*pbVar8,3);\n  if (pvVar6 != (void *)0x0) {\n    local_88 = local_88 | 0x40 << ((int)pvVar6 - (int)puVar3 & 0xffU);\n    pbVar8 = pbVar8 + 1;\n  }\n  param_3 = pbVar8 + 1;\n  local_70 = *pbVar8;\n  pvVar6 = memchr(PTR_s_efgEFG_00005a48,(uint)local_70,6);\n  if (pvVar6 == (void *)0x0) {\n    iVar4 = _printf_i(param_1,&local_88,param_2,DAT_00005a50,&local_8c);\n  }\n  else {\n    iVar4 = param_1;\n    if (DAT_00005a4c == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar4 = unaff_r7;\n      goto LAB_000059b4;\n    }\n  }\n  if (iVar4 == -1) goto LAB_00005a06;\nLAB_000059b4:\n  local_74 = local_74 + iVar4;\n  pbVar9 = param_3;\n  unaff_r7 = iVar4;\n  goto LAB_0000588e;\n}\n\n",
            "called": [
                "memchr",
                "__retarget_lock_acquire_recursive",
                "__sfputs_r",
                "__retarget_lock_release_recursive",
                "__sinit",
                "_printf_i",
                "__swsetup_r"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000057f8",
            "calling": [
                "iprintf"
            ],
            "imported": false,
            "current_name": "FUNC_000057f8"
        },
        "FUN_000018bc": {
            "renaming": {
                "FUN_000018bc": "initialize_system_000018bc",
                "DAT_00001910": "control_register",
                "DAT_00001914": "status_register",
                "PTR_current_mode_00001918": "current_mode",
                "KINETIS_MCG_FLL_FACTOR_1464": "FLL_FACTOR_1464",
                "kinetis_mcg_set_fll_factor": "set_fll_factor",
                "bit_clear8": "clear_bit8"
            },
            "code": "void initialize_system_000018bc(void)\n{\n  set_fll_factor(KINETIS_MCG_FLL_FACTOR_1464);\n  *DAT_00001910 = (*DAT_00001910 & 0x3b) | 4;\n  clear_bit8(DAT_00001914, 0x01);\n  while ((DAT_00001914[6] & 0x10) == 0);\n  while ((DAT_00001914[6] & 0xc) != 0);\n  *PTR_current_mode_00001918 = 0;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000018bc",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "initialize_system_000018bc"
        },
        "FUN_00000974": {
            "renaming": {
                "FUN_00000974": "run_active_thread_00000974",
                "PTR_sched_active_thread_0000098c": "active_thread_func_ptr_ptr",
                "isCurrentModePrivileged": "isCurrentModePrivileged",
                "setProcessStackPointer": "setProcessStackPointer",
                "bool bVar1": "bool is_privileged_mode",
                "code *UNRECOVERED_JUMPTABLE": "code *active_thread_func_ptr",
                "code **ppcVar2": "code **active_thread_sp_ptr"
            },
            "code": "void run_active_thread_00000974(void)\n{\n  bool is_privileged_mode;\n  code *active_thread_func_ptr;\n  code **active_thread_sp_ptr;\n\n  sched_run();\n  active_thread_func_ptr = *(code **)**(undefined4 **)PTR_sched_active_thread_0000098c;\n  active_thread_sp_ptr = (code **)**(undefined4 **)PTR_sched_active_thread_0000098c + 9;\n  is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    setProcessStackPointer(active_thread_sp_ptr);\n  }\n  (*active_thread_func_ptr)(active_thread_func_ptr,active_thread_sp_ptr);\n  return;\n}",
            "called": [
                "sched_run"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000974",
            "calling": [
                "isr_pendsv"
            ],
            "imported": false,
            "current_name": "run_active_thread_00000974"
        },
        "FUN_00000f04": {
            "renaming": {
                "FUN_00000f04": "handle_crash_00000f04",
                "crash_code": "crash_type",
                "message": "crash_message",
                "local_10": "crash_message",
                "local_9": "crash_type",
                "uStack_18": "stack_top",
                "uStack_14": "stack_size"
            },
            "code": "void handle_crash_00000f04(handle_crash_00000f04_t crash_type, char *crash_message) {\n  bool is_crashed = *(int *)PTR_crashed_00000f4c;\n  *(undefined4 *)PTR_crashed_00000f4c = 1;\n  if (!is_crashed) {\n    if (crash_type == PANIC_ASSERT_FAIL) {\n      cpu_print_last_instruction();\n    }\n    iprintf(PTR_s_____RIOT_kernel_panic___s_00000f50, crash_message);\n    ps();\n    iprintf(PTR_DAT_00000f54);\n    iprintf(PTR_s_____halted__00000f58);\n  }\n  irq_disable();\n  panic_arch();\n  int stack_size = 0xf4d;\n  pm_off();\n  int stack_top = (int)&stack_top + 1;\n  auto_init();\n  iprintf(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n  main();\n  return;\n}",
            "called": [
                "ps",
                "pm_off",
                "irq_disable",
                "iprintf",
                "panic_arch",
                "cpu_print_last_instruction"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f04",
            "calling": [
                "thread_add_to_list",
                "mem_manage_default",
                "dummy_handler_default",
                "fmt_s32_dfp",
                "bus_fault_default",
                "hard_fault_handler",
                "uart_init",
                "nmi_default",
                "usage_fault_default",
                "debug_mon_default",
                "cib_init"
            ],
            "imported": false,
            "current_name": "handle_crash_00000f04"
        },
        "FUN_00000610": {
            "renaming": {
                "FUN_00000610": "perform_context_switch_00000610",
                "uVar1": "lsb_index",
                "iVar2": "active_thread_id",
                "iVar3": "next_thread_id",
                "active_thread": "active_thread",
                "nextrq": "next_node",
                "__m____": "next_node",
                "next_thread": "next_thread"
            },
            "code": "int perform_context_switch_00000610(void)\n{\n  uint lsb_index;\n  int active_thread_id;\n  int next_thread_id;\n  thread_t *active_thread;\n  clist_node_t *next_node;\n  thread_t *next_thread;\n  *(undefined4 *)PTR_sched_context_switch_request_00000684 = 0;\n  active_thread_id = *(int *)PTR_sched_active_thread_00000688;\n  lsb_index = bitarithm_lsb(*(uint *)PTR_runqueue_bitcache_0000068c);\n  next_node = **(clist_node_t ***)(PTR_perform_context_switch_00000610queues_00000690 + lsb_index * 4);\n  next_thread_id = next_node - 8;\n  if (active_thread_id == next_thread_id) {\n    active_thread_id = 0;\n  }\n  else {\n    if ((active_thread_id != 0) && (*(char *)(active_thread_id + 4) == '\t')) {\n      *(undefined *)(active_thread_id + 4) = 10;\n    }\n    *(undefined *)(next_thread_id + 4) = 9;\n    *(undefined2 *)PTR_sched_active_pid_00000694 = *(undefined2 *)(next_thread_id + 6);\n    *(int *)PTR_sched_active_thread_00000688 = next_thread_id;\n    active_thread_id = 1;\n  }\n  return active_thread_id;\n}",
            "called": [
                "bitarithm_lsb"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000610",
            "calling": [
                "isr_svc"
            ],
            "imported": false,
            "current_name": "perform_context_switch_00000610"
        },
        "FUN_00003694": {
            "renaming": {
                "FUN_00003694": "display_sensor_data_00003694",
                "data": "sensor_data",
                "dim": "num_dimensions",
                "pcVar2": "unit_string",
                "cVar3": "unit_char",
                "uVar4": "is_bit_set",
                "bVar5": "bool_result",
                "num": "num_string",
                "len": "length",
                "i": "i",
                "scale_prefix": "scale_prefix",
                "sVar1": "length"
            },
            "code": "void display_sensor_data_00003694(phydat_t *sensor_data, uint8_t num_dimensions) {\n  size_t length;\n  char *unit_string;\n  char scale_prefix;\n  uint8_t i;\n  if ((sensor_data == NULL) || (num_dimensions > 3)) {\n    puts(\"Unable to display data object.\");\n  }\n  else {\n    iprintf(\"Data:\\n\");\n    for (i = 0; i < num_dimensions; i++) {\n      if (sensor_data->unit < 20) {\n        bool is_bit_set = ((1 << sensor_data->unit) & 0x1) != 0;\n        char unit_char = is_bit_set ? '1' : '0';\n        if (!is_bit_set) {\n          unit_char = '0';\n        }\n        if (unit_char == '0') {\n          goto skip_unit;\n        }\n        scale_prefix = '0';\n      }\n      else {\n        skip_unit:\n        scale_prefix = phydat_prefix_from_scale(sensor_data->scale);\n      }\n      iprintf(\"  Data[%d]: \", i);\n      if (num_dimensions < 2) {\n        iprintf(\"%d\", sensor_data->val[i]);\n      }\n      else {\n        iprintf(\"%d\", i);\n      }\n      if (scale_prefix == '0') {\n        if (sensor_data->scale == 0) {\n          iprintf(\"%d\", sensor_data->val[i]);\n        }\n        else if ((sensor_data->scale + 4 < 0 == SCARRY4((int)sensor_data->scale,4)) && (sensor_data->scale < 0)) {\n          length = fmt_s16_dfp(num_string, sensor_data->val[i], (int)sensor_data->scale);\n          num_string[length] = '\\0';\n          iprintf(\"%s\", num_string);\n        }\n        else {\n          iprintf(\"%dE%d\", sensor_data->val[i], sensor_data->scale);\n        }\n      }\n      else {\n        iprintf(\"%dm%c\", sensor_data->val[i], scale_prefix);\n      }\n      unit_string = phydat_unit_to_str(sensor_data->unit);\n      iprintf(\" %s\\n\", unit_string);\n    }\n  }\n}",
            "called": [
                "phydat_prefix_from_scale",
                "iprintf",
                "puts",
                "phydat_unit_to_str",
                "fmt_s16_dfp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003694",
            "calling": [
                "write",
                "probe"
            ],
            "imported": false,
            "current_name": "display_sensor_data_00003694"
        },
        "FUN_00002364": {
            "renaming": {
                "FUN_00002364": "is_ring_buffer_full_00002364",
                "rb": "ring_buffer",
                "c": "data",
                "iVar1": "is_full",
                "_push": "push_to_ring_buffer"
            },
            "code": "int is_ring_buffer_full_00002364(tsrb_t *ring_buffer, char data) {\n  int is_full = tsrb_full(ring_buffer);\n  if (is_full == 0) {\n    push_to_ring_buffer(ring_buffer, data);\n    is_full = 0;\n  }\n  else {\n    is_full = -1;\n  }\n  return is_full;\n}",
            "called": [
                "_push",
                "tsrb_full"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002364",
            "calling": [
                "isrpipe_write_one"
            ],
            "imported": false,
            "current_name": "is_ring_buffer_full_00002364"
        },
        "FUN_00001ad4": {
            "renaming": {
                "FUN_00001ad4": "set_current_mode_to_7_00001ad4",
                "DAT_00001b08": "data_pointer",
                "PTR_current_mode_00001b0c": "PTR_current_mode"
            },
            "code": "void set_current_mode_to_7_00001ad4(void)\n{\n  unsigned char* DAT_00001b08 = DAT_00001b08;\n  *DAT_00001b08 = *DAT_00001b08 & 0x3f;\n  while ((*DAT_00001b08 & 0xc0) != 0xc0);\n  *PTR_current_mode_00001b0c_00001b0c = 7;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ad4",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "set_current_mode_to_7_00001ad4"
        },
        "FUN_00001274": {
            "renaming": {
                "FUN_00001274": "initialize_system_00001274",
                "*DAT_00001298": "*PTR_DAT_00001298",
                "cortexm_init": "initialize_cortexm",
                "kinetis_mcg_init": "initialize_kinetis_mcg",
                "periph_init": "initialize_peripherals"
            },
            "code": "void initialize_system_00001274(void)\n{\n  initialize_cortexm();\n  *DAT_00001298 |= 0x28;\n  initialize_kinetis_mcg();\n  initialize_peripherals();\n  return;\n}",
            "called": [
                "cortexm_init",
                "kinetis_mcg_init",
                "periph_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001274",
            "calling": [
                "board_init"
            ],
            "imported": false,
            "current_name": "initialize_system_00001274"
        },
        "FUN_00002e6c": {
            "renaming": {
                "FUN_00002e6c": "handle_shell_commands_00002e6c",
                "shell_commands": "commands",
                "line_buf": "input_buffer",
                "len": "buffer_len",
                "iVar1": "read_result",
                "res": "input_len",
                "print_prompt": "print_shell_prompt",
                "readline": "get_input",
                "handle_input_line": "handle_input"
            },
            "code": "void handle_shell_commands_00002e6c(shell_command_t *commands, char *input_buffer, int buffer_len)\n{\n  int input_len;\n  int read_result;\n  \n  print_shell_prompt();\n  do {\n    input_len = get_input(input_buffer, buffer_len);\n    if (input_len == 0) {\n      handle_input(commands, input_buffer);\n    }\n    print_shell_prompt();\n  } while (true);\n}",
            "called": [
                "handle_input_line",
                "print_prompt",
                "readline"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e6c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "handle_shell_commands_00002e6c"
        },
        "FUN_00003444": {
            "renaming": {
                "FUN_00003444": "get_rtc_time_or_print_error_00003444",
                "t": "rtc_time",
                "iVar1": "rtc_time_error_code",
                "_print_time": "print_rtc_time"
            },
            "code": "int get_rtc_time_or_print_error_00003444(void)\n{\n  int rtc_time_error_code;\n  tm rtc_time;\n  rtc_time_error_code = rtc_get_time(&rtc_time);\n  if (rtc_time_error_code != 0) {\n    puts(PTR_s_rtc__error_getting_time_00003474);\n  }\n  else {\n    print_rtc_time(&rtc_time);\n  }\n  return (uint)(rtc_time_error_code != 0);\n}",
            "called": [
                "_print_time",
                "puts",
                "rtc_get_time"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003444",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "get_rtc_time_or_print_error_00003444"
        },
        "FUN_00003688": {
            "renaming": {
                "FUN_00003688": "reset_system_00003688"
            },
            "code": "void reset_system_00003688(void)\n{\n  NVIC_SystemReset();\n  return;\n}",
            "called": [
                "NVIC_SystemReset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003688",
            "calling": [
                "_reboot_handler"
            ],
            "imported": false,
            "current_name": "reset_system_00003688"
        },
        "FUN_00001392": {
            "renaming": {
                "FUN_00001392": "set_bit_00001392",
                "ptr": "ptr",
                "bit": "bit",
                "puVar1": "bit_addr"
            },
            "code": "void set_bit_00001392(uint32_t *ptr, uint8_t bit)\n{\n  uint32_t *bit_addr = bitband_addr(ptr, (uint32_t)bit);\n  *bit_addr = 1;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001392",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "set_bit_00001392"
        },
        "FUN_00002910": {
            "renaming": {
                "FUN_00002910": "disable_rtc_interrupts_00002910",
                "DAT_00002944": "data_address",
                "PTR_rtt_callback_00002948": "PTR_rtt_callback",
                "interrupt_flags": "interrupt_flags",
                "data_address": "data_address"
            },
            "code": "void disable_rtc_interrupts_00002910(void)\n{\n  int DAT_00002944 = DAT_00002944;\n  uint* interrupt_flags = (uint*)(DAT_00002944 + 0x1c);\n  *interrupt_flags = *interrupt_flags & 0xfffffffb;\n  *(undefined4 *)(DAT_00002944 + 8) = 0;\n  *(undefined4 *)PTR_rtt_callback_00002948_00002948 = 0;\n  *(undefined4 *)(PTR_rtt_callback_00002948_00002948 + 4) = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002910",
            "calling": [
                "rtc_clear_alarm"
            ],
            "imported": false,
            "current_name": "disable_rtc_interrupts_00002910"
        },
        "FUN_00004418": {
            "renaming": {
                "FUN_00004418": "get_char_from_input_stream_00004418",
                "iVar1": "impure_ptr_value",
                "PTR__impure_ptr_00004438": "PTR__impure_ptr",
                "__sinit": "initialize_stream",
                "_getc_r": "read_from_stream",
                "*(int *)(iVar1 + 0x18)": "stream_initialized",
                "*(undefined4 *)(iVar1 + 4)": "stream_id",
                "char_value": "character"
            },
            "code": "int get_char_from_input_stream_00004418(void)\n{\n  int impure_ptr_value = *(int *)PTR__impure_ptr_00004438_00004438;\n  if ((impure_ptr_value != 0) && (*(int *)(impure_ptr_value + 0x18) == 0)) {\n    __sinit(impure_ptr_value);\n  }\n  int char_value = _getc_r(impure_ptr_value,*(undefined4 *)(impure_ptr_value + 4));\n  return char_value;\n}",
            "called": [
                "__sinit",
                "_getc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004418",
            "calling": [
                "readline"
            ],
            "imported": false,
            "current_name": "get_char_from_input_stream_00004418"
        },
        "FUN_0000258c": {
            "renaming": {
                "FUN_0000258c": "initialize_interrupt_priorities_0000258c",
                "i": "index",
                "uint": "uint32_t"
            },
            "code": "void initialize_interrupt_priorities_0000258c(void)\n{\n  uint32_t index;\n  *(uint32_t *)(DAT_000025ec + 8) = DAT_000025f0;\n  NVIC_SetPriority(PendSV_IRQn,1);\n  NVIC_SetPriority(SVCall_IRQn,1);\n  for (index = 0; index < 0x66; index++) {\n    NVIC_SetPriority((IRQn_Type)index,1);\n  }\n  *(uint32_t *)(DAT_000025ec + 0x10) |= 0x10;\n  *(uint32_t *)(DAT_000025ec + 0x14) |= 0x200;\n  return;\n}",
            "called": [
                "NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000258c",
            "calling": [
                "cpu_init"
            ],
            "imported": false,
            "current_name": "initialize_interrupt_priorities_0000258c"
        },
        "FUN_00002a00": {
            "renaming": {
                "FUN_00002a00": "print_character_to_console_00002a00",
                "c": "character",
                "putchar": "putchar",
                "return": "return"
            },
            "code": "void print_character_to_console_00002a00(int character) \n{ \n  putchar(character); \n  return; \n}",
            "called": [
                "putchar"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a00",
            "calling": [
                "print_prompt",
                "readline"
            ],
            "imported": false,
            "current_name": "print_character_to_console_00002a00"
        },
        "FUN_00000a64": {
            "renaming": {
                "FUN_00000a64": "handle_fault_00000a64",
                "sp": "stack_pointer",
                "corrupted": "is_corrupted",
                "unaff_r4": "r4_value",
                "unaff_r5": "r5_value",
                "unaff_r6": "r6_value",
                "unaff_r7": "r7_value",
                "unaff_r8": "r8_value",
                "unaff_r9": "r9_value",
                "unaff_r10": "r10_value",
                "unaff_r11": "r11_value",
                "in_lr": "lr_value",
                "PTR__eram_00000aa0": "PTR__eram_00000aa0",
                "&stack0x00000000": "&stack0x00000000",
                "DAT_00000a9c": "DAT_00000a9c",
                "register0x00000054": "heap_top",
                "getMainStackPointer()": "getMainStackPointer()",
                "getProcessStackPointer()": "getProcessStackPointer()",
                "hard_fault_handler": "hard_fault_handler"
            },
            "code": "void handle_fault_00000a64(uint32_t *stack_pointer, uint32_t is_corrupted, uint32_t lr_value, uint32_t *heap_top) {\n  uint32_t *main_stack_pointer = (uint32_t *)getMainStackPointer();\n  uint32_t *process_stack_pointer = (uint32_t *)getProcessStackPointer();\n  uint32_t r11_value = heap_top[-1];\n  uint32_t r10_value = heap_top[-2];\n  uint32_t r9_value = heap_top[-3];\n  uint32_t r8_value = heap_top[-4];\n  uint32_t r7_value = heap_top[-5];\n  uint32_t r6_value = heap_top[-6];\n  uint32_t r5_value = heap_top[-7];\n  uint32_t r4_value = heap_top[-8];\n  if (is_corrupted || (stack_pointer < &stack0x00000000) || (&stack0x00000000 <= DAT_00000a9c)) {\n    heap_top = (uint32_t *)PTR_heap_top_00000aa4;\n  }\n  hard_fault_handler(stack_pointer, is_corrupted, lr_value, heap_top, r4_value, r5_value, r6_value, r7_value, r8_value, r9_value, r10_value, r11_value);\n}",
            "called": [
                "hard_fault_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a64",
            "calling": [],
            "imported": false,
            "current_name": "handle_fault_00000a64"
        },
        "FUN_000043a0": {
            "renaming": {
                "FUN_000043a0": "process_items_000043a0",
                "param_1": "start_address",
                "param_2": "item_processor",
                "piVar2": "item",
                "uVar4": "result",
                "iVar5": "item_count",
                "iVar3": "item_data",
                "uVar1": "processed_item"
            },
            "code": "uint process_items_000043a0(int start_address, code* item_processor)\n{\n  uint result = 0;\n  int* item = (int*)(start_address + 0x48);\n  do {\n    int item_count = item[1];\n    int item_data = item[2];\n    while (item_count-- > 0) {\n      if ((*(ushort*)(item_data + 0xc) > 1) && (*(short*)(item_data + 0xe) != -1)) {\n        uint processed_item = (*item_processor)(item_data);\n        result |= processed_item;\n      }\n      item_data += 0x68;\n    }\n    item = (int*)*item;\n  } while (item != (int*)0x0);\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043a0",
            "calling": [
                "__srefill_r"
            ],
            "imported": false,
            "current_name": "process_items_000043a0"
        },
        "FUN_0000211c": {
            "renaming": {
                "FUN_0000211c": "print_thread_info_0000211c",
                "queued_name": "queued_thread_name",
                "stacksz": "overall_thread_stack_size",
                "queued": "queued_thread",
                "sname": "thread_name",
                "state": "thread_state",
                "p": "thread_pointer",
                "isr_sp": "isr_stack_pointer",
                "isr_start": "isr_stack_start",
                "isr_usage": "isr_stack_size",
                "i": "thread_id",
                "overall_used": "overall_used_stack_size",
                "overall_stacksz": "overall_thread_stack_size",
                "bVar1": "thread_state_byte",
                "uVar7": "thread_state_name",
                "puVar6": "thread_info_pointer"
            },
            "code": "void print_thread_info_0000211c(void)\n{\n  char queued_thread_name[2] = \"Q_\";\n  int overall_used_stack_size = 0;\n  int overall_thread_stack_size = 512;\n  int thread_state;\n  thread_t *thread_pointer;\n  void *isr_stack_pointer;\n  void *isr_stack_start;\n  int isr_stack_size;\n  kernel_pid_t thread_id;\n  int thread_used_stack_size;\n  int i;\n\n  printf(\"PID\\tState\\tPri\\tStack\\tName\\n\");\n\n  isr_stack_size = thread_isr_stack_usage();\n  isr_stack_start = thread_isr_stack_start();\n  isr_stack_pointer = thread_isr_stack_pointer();\n  printf(\"ISR\\t\\t\\t\\t%6i %6i %p %p\\n\", isr_stack_size, isr_stack_size, isr_stack_start, isr_stack_pointer);\n\n  for (i = 1; i < 33; i++) {\n    thread_pointer = *(thread_t **)(PTR_sched_threads_00002258 + i * 4);\n    if (thread_pointer != NULL) {\n      thread_state = *(int *)(thread_pointer + 4);\n      thread_used_stack_size = thread_pointer[11] - thread_measure_stack_free((char *)thread_pointer[9]);\n      overall_used_stack_size += thread_used_stack_size;\n      overall_thread_stack_size += thread_pointer[11];\n      printf(\"%d\\t%s\\t%3i\\t%5i\\t%s\\n\", (int)thread_pointer[1], PTR_state_names_0000225c[thread_state * 4], thread_pointer[10], thread_pointer[11], queued_thread_name + (thread_pointer[5] > 8), thread_used_stack_size, thread_pointer[9]);\n    }\n  }\n  printf(\"Overall\\t\\t\\t\\t%6i %6i\\n\", overall_thread_stack_size, overall_used_stack_size);\n  return;\n}",
            "called": [
                "thread_isr_stack_usage",
                "thread_isr_stack_start",
                "iprintf",
                "thread_measure_stack_free",
                "thread_isr_stack_pointer"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000211c",
            "calling": [
                "core_panic",
                "_ps_handler"
            ],
            "imported": false,
            "current_name": "print_thread_info_0000211c"
        },
        "FUN_0000562c": {
            "renaming": {
                "FUN_0000562c": "find_environment_variable_0000562c",
                "param_1": "lock",
                "param_2": "variable_name",
                "param_3": "index",
                "cVar1": "current_char",
                "puVar2": "PTR_environ_0000569c",
                "pcVar5": "current_variable",
                "ppcVar3": "current_environment_variable",
                "iVar4": "comparison_result",
                "ppcVar6": "environment_pointer",
                "__n": "name_length"
            },
            "code": "char * find_environment_variable_0000562c(int lock, char *variable_name, int *index)\n{\n  char current_char;\n  char **environment_pointer;\n  int comparison_result;\n  char *current_variable;\n  size_t name_length;\n  __env_lock();\n  environment_pointer = PTR_environ_0000569c;\n  current_variable = variable_name;\n  if (*environment_pointer != (char **)0x0) {\n    do {\n      current_char = *current_variable;\n      if (current_char == '\\0') {\n        name_length = (int)current_variable - (int)variable_name;\n        while (true) {\n          char **current_environment_variable = environment_pointer;\n          if (*current_environment_variable == (char *)0x0) break;\n          comparison_result = strncmp(*current_environment_variable, variable_name, name_length);\n          environment_pointer = current_environment_variable + 1;\n          if ((comparison_result == 0) && ((current_variable = *current_environment_variable)[name_length] == '=')) {\n            *index = (int)current_environment_variable - *(int *)PTR_environ_0000569c >> 2;\n            __env_unlock(lock);\n            return current_variable + name_length + 1;\n          }\n        }\n        break;\n      }\n      current_variable = current_variable + 1;\n    } while (current_char != '=');\n  }\n  __env_unlock(lock);\n  return (char *)0x0;\n}",
            "called": [
                "__env_lock",
                "__env_unlock",
                "strncmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000562c",
            "calling": [
                "_getenv_r"
            ],
            "imported": false,
            "current_name": "find_environment_variable_0000562c"
        },
        "FUN_000020b8": {
            "renaming": {
                "FUN_000020b8": "handle_interrupt_000020b8",
                "DAT_000020c8": "interrupt_number"
            },
            "code": "void handle_interrupt_000020b8(void)\n{\n  irq_handler(DAT_000020c8, 0);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020b8",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_000020b8"
        },
        "FUN_00002a18": {
            "renaming": {
                "FUN_00002a18": "find_shell_command_handler_00002a18",
                "command_list": "command_list",
                "command": "command",
                "iVar1": "result",
                "command_lists": "command_lists",
                "i": "list_index",
                "entry": "current_entry"
            },
            "code": "typedef struct shell_command{\n  char *name;\n  shell_command_handler_t handler;\n} shell_command_t;\n\nshell_command_handler_t find_shell_command_handler_00002a18(shell_command_t *command_list, char *command){\n  shell_command_t *command_lists[2];\n  uint32_t list_index;\n  shell_command_t *entry;\n\n  command_lists[0] = command_list;\n  command_lists[1] = (shell_command_t *)PTR__shell_command_list_00002a84;\n  list_index = 0;\n  while (list_index < 2){\n    entry = command_lists[list_index];\n    if (entry != NULL){\n      while (entry->name != NULL){\n        if (strcmp(entry->name, command) == 0){\n          return entry->handler;\n        }\n        entry++;\n      }\n    }\n    list_index++;\n  }\n  return NULL;\n}",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a18",
            "calling": [
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "find_shell_command_handler_00002a18"
        },
        "FUN_000054a8": {
            "renaming": {
                "FUN_000054a8": "check_and_process_input_000054a8",
                "param_1": "output_status",
                "param_2": "input_stream",
                "uVar1": "stream_flags",
                "uVar2": "stream_buffer_size",
                "uVar3": "stream_flags_as_uint",
                "uVar4": "stream_buffer_size_as_uint",
                "iVar5": "impure_ptr"
            },
            "code": "uint check_and_process_input_000054a8(undefined4 *output_status, undefined4 *input_stream)\n{\n  ushort stream_flags;\n  ushort stream_buffer_size;\n  uint stream_flags_as_uint;\n  uint stream_buffer_size_as_uint;\n  int impure_ptr = *(int *)PTR__impure_ptr_00005574;\n  if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n    __sinit(impure_ptr);\n  }\n  if (input_stream == (undefined4 *)PTR___sf_fake_stdin_00005578) {\n    input_stream = *(undefined4 **)(impure_ptr + 4);\n  }\n  else if (input_stream == (undefined4 *)PTR___sf_fake_stdout_0000557c) {\n    input_stream = *(undefined4 **)(impure_ptr + 8);\n  }\n  else if (input_stream == (undefined4 *)PTR___sf_fake_stderr_00005580) {\n    input_stream = *(undefined4 **)(impure_ptr + 0xc);\n  }\n  stream_flags_as_uint = (uint)*(ushort *)(input_stream + 3);\n  stream_buffer_size_as_uint = *(ushort *)(input_stream + 3);\n  if (-1 < (int)(stream_flags_as_uint << 0x1c)) {\n    if (-1 < (int)(stream_flags_as_uint << 0x1b)) {\n      *output_status = 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(stream_flags_as_uint << 0x1d) < 0) {\n      if ((undefined4 *)input_stream[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)input_stream[0xd] != input_stream + 0x11) {\n          _free_r(output_status);\n        }\n        input_stream[0xd] = 0;\n      }\n      *(ushort *)(input_stream + 3) = *(ushort *)(input_stream + 3) & 0xffdb;\n      input_stream[1] = 0;\n      *input_stream = input_stream[4];\n    }\n    *(ushort *)(input_stream + 3) = *(ushort *)(input_stream + 3) | 8;\n  }\n  if ((input_stream[4] == 0) && ((*(ushort *)(input_stream + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(output_status, input_stream);\n  }\n  stream_flags = *(ushort *)(input_stream + 3);\n  stream_flags_as_uint = (uint)stream_flags;\n  stream_buffer_size = *(ushort *)(input_stream + 3);\n  stream_buffer_size_as_uint = stream_flags_as_uint & 1;\n  if ((stream_flags & 1) == 0) {\n    if (-1 < (int)(stream_flags_as_uint << 0x1e)) {\n      stream_buffer_size_as_uint = input_stream[5];\n    }\n    input_stream[2] = stream_buffer_size_as_uint;\n  }\n  else {\n    input_stream[2] = 0;\n    input_stream[6] = -input_stream[5];\n  }\n  if (input_stream[4] != 0) {\n    return 0;\n  }\n  if ((stream_flags & 0x80) == 0) {\n    return stream_flags_as_uint & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(input_stream + 3) = stream_buffer_size | 0x40;\n  return 0xffffffff;\n}",
            "called": [
                "__smakebuf_r",
                "__sinit",
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000054a8",
            "calling": [
                "_puts_r",
                "_vfprintf_r",
                "__swbuf_r"
            ],
            "imported": false,
            "current_name": "check_and_process_input_000054a8"
        },
        "FUN_000007dc": {
            "renaming": {
                "FUN_000007dc": "create_thread_stack_000007dc",
                "task_func": "task_function",
                "arg": "argument",
                "stack_start": "stack_start",
                "stack_size": "stack_size",
                "uVar1": "size",
                "stk": "stack_pointer",
                "i_1": "i_1",
                "i": "i"
            },
            "code": "char * create_thread_stack_000007dc(thread_task_func_t task_function, void *argument, void *stack_start, int stack_size) {\n  uint32_t *stack_pointer;\n  uint32_t size = ((uint32_t)stack_start + stack_size) & 0xfffffffc;\n  stack_pointer = (uint32_t *)(size - 4);\n  *stack_pointer = 0x77777777;\n  if (((uint)stack_pointer & 7) != 0) {\n    stack_pointer = (uint32_t *)(size - 8);\n    *stack_pointer = 0x88888888;\n  }\n  stack_pointer[-1] = 0x1000000;\n  stack_pointer[-2] = (uint32_t)task_function;\n  stack_pointer[-3] = DAT_000008b4;\n  stack_pointer = stack_pointer - 4;\n  *stack_pointer = 0;\n  for (int i = 3; i > 0; i--) {\n    stack_pointer--;\n    *stack_pointer = i;\n  }\n  stack_pointer--;\n  *stack_pointer = (uint32_t)argument;\n  for (int i = 0xb; i > 3; i--) {\n    stack_pointer--;\n    *stack_pointer = i;\n  }\n  stack_pointer[-1] = 0xfffffffd;\n  return (char *)(stack_pointer - 1);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000007dc",
            "calling": [
                "thread_create"
            ],
            "imported": false,
            "current_name": "create_thread_stack_000007dc"
        },
        "FUN_00001710": {
            "renaming": {
                "FUN_00001710": "clear_bit_at_position_00001710",
                "ptr": "data",
                "bit": "position",
                "puVar1": "bit_address"
            },
            "code": "void clear_bit_at_position_00001710(uint8_t *data, uint8_t position)\n{\n  undefined *bit_address = (undefined *)bitband_addr(data, (uint)position);\n  *bit_address = 0;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001710",
            "calling": [
                "kinetis_mcg_disable_pll",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_fbi"
            ],
            "imported": false,
            "current_name": "clear_bit_at_position_00001710"
        },
        "FUN_000045ea": {
            "renaming": {
                "FUN_000045ea": "do_nothing_000045ea"
            },
            "code": "\nvoid do_nothing_000045ea(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ea",
            "calling": [
                "__tz_unlock"
            ],
            "imported": false,
            "current_name": "do_nothing_000045ea"
        },
        "FUN_000045ec": {
            "renaming": {
                "FUN_000045ec": "do_nothing_000045ec"
            },
            "code": "\nvoid do_nothing_000045ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ec",
            "calling": [
                "_puts_r",
                "_putc_r",
                "__malloc_unlock",
                "__sfp_lock_release",
                "__sinit_lock_release",
                "_getc_r",
                "_fflush_r",
                "_vfprintf_r",
                "__env_unlock"
            ],
            "imported": false,
            "current_name": "do_nothing_000045ec"
        },
        "FUN_00001034": {
            "renaming": {
                "FUN_00001034": "insert_thread_into_list_00001034",
                "list_entry": "current_thread",
                "__m____": "temp",
                "local_1c": "current_node",
                "new_node": "new_node",
                "my_prio": "thread_priority"
            },
            "code": "void insert_thread_into_list_00001034(list_node_t *list, thread_t *thread)\n{\n  list_node_t *current_node = list;\n  thread_t *current_thread;\n  clist_node_t *temp;\n  list_node_t *new_node;\n  uint16_t thread_priority;\n  \n  if (thread->status < 9) {\n    while ((current_node->next != (list_node_t *)0x0 &&\n           (*(byte *)((int)&current_node->next[-1].next + 1) <= thread->priority))) {\n      current_node = current_node->next;\n    }\n    (thread->rq_entry).next = current_node->next;\n    current_node->next = &thread->rq_entry;\n    return;\n  }\n  core_panic(PANIC_ASSERT_FAIL, PTR_assert_crash_message_0000109c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001034",
            "calling": [
                "_mutex_lock"
            ],
            "imported": false,
            "current_name": "insert_thread_into_list_00001034"
        },
        "FUN_000055ac": {
            "renaming": {
                "FUN_000055ac": "read_byte_000055ac",
                "param_1": "file_descriptor",
                "param_2": "stream_buffer",
                "uVar1": "byte_read",
                "pbVar2": "buffer_pointer"
            },
            "code": "uint read_byte_000055ac(int file_descriptor, byte **stream_buffer){\n  uint byte_read;\n  byte *buffer_pointer;\n  if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream_buffer == (byte **)PTR___sf_fake_stdin_00005620) {\n    stream_buffer = *(byte ***)(file_descriptor + 4);\n  }\n  else if (stream_buffer == (byte **)PTR___sf_fake_stdout_00005624) {\n    stream_buffer = *(byte ***)(file_descriptor + 8);\n  }\n  else if (stream_buffer == (byte **)PTR___sf_fake_stderr_00005628) {\n    stream_buffer = *(byte ***)(file_descriptor + 0xc);\n  }\n  if ((-1 < (int)stream_buffer[25] << 0x1f) && (-1 < (int)((uint)*(ushort *)(stream_buffer + 6) << 0x16))) {\n    __retarget_lock_acquire_recursive(stream_buffer[22]);\n  }\n  buffer_pointer = stream_buffer[1];\n  stream_buffer[1] = buffer_pointer + -1;\n  if ((int)(buffer_pointer + -1) < 0) {\n    byte_read = __srget_r(file_descriptor, stream_buffer);\n  }\n  else {\n    buffer_pointer = *stream_buffer;\n    *stream_buffer = buffer_pointer + 1;\n    byte_read = (uint)*buffer_pointer;\n  }\n  if ((-1 < (int)stream_buffer[25] << 0x1f) && (-1 < (int)((uint)*(ushort *)(stream_buffer + 6) << 0x16))) {\n    __retarget_lock_release_recursive(stream_buffer[22]);\n  }\n  return byte_read;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__srget_r",
                "__sinit",
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000055ac",
            "calling": [
                "getchar"
            ],
            "imported": false,
            "current_name": "read_byte_000055ac"
        },
        "FUN_00006964": {
            "renaming": {
                "FUN_00006964": "calculate_value_00006964",
                "param_1": "input_array",
                "param_2": "array_length",
                "iVar1": "current_index",
                "PTR_": "input_array",
                "DAT_": "array_length"
            },
            "code": "int calculate_value_00006964(int *PTR_, int DAT_)\n{\n  int current_index = DAT_ - 1;\n  int result = current_index - 1;\n  if (PTR_[current_index] < 0) {\n    result += PTR_[current_index];\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006964",
            "calling": [
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "calculate_value_00006964"
        },
        "FUN_0000182c": {
            "renaming": {
                "FUN_0000182c": "clear_bits_and_set_flag_0000182c",
                "DAT_000018b4": "data_ptr1",
                "DAT_000018b8": "data_ptr2"
            },
            "code": "void clear_bits_and_set_flag_0000182c(void)\n{\n  uint8_t flag_mask = 0xd0;\n  uint8_t* DAT_000018b4 = DAT_000018b4;\n  uint8_t* DAT_000018b8 = DAT_000018b8;\n  DAT_000018b4[8] &= flag_mask;\n  set_bit_in_byte(*DAT_000018b8, 0);\n  clear_bit_in_byte(*DAT_000018b4, 1);\n  clear_bit_in_byte(*DAT_000018b4, 0);\n  return;\n}",
            "called": [
                "bit_clear8",
                "bit_set8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000182c",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "clear_bits_and_set_flag_0000182c"
        },
        "FUN_00004db8": {
            "renaming": {
                "FUN_00004db8": "reverse_string_00004db8",
                "__s": "input_string",
                "iVar1": "is_palindrome",
                "PTR__impure_ptr_00004dc4": "PTR__impure_ptr"
            },
            "code": "int reverse_string_00004db8(char* input_string) {\n  int reversed_string_length = strlen(input_string);\n  char reversed_string[reversed_string_length];\n  for (int i = 0; i < reversed_string_length; i++) {\n    reversed_string[i] = input_string[reversed_string_length - i - 1];\n  }\n  reversed_string[reversed_string_length] = '\\0';\n  return strcmp(input_string, reversed_string) == 0;\n}",
            "called": [
                "_puts_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004db8",
            "calling": [
                "probe_all",
                "_rtc_setalarm",
                "_rtc_settime",
                "print_help",
                "read",
                "main",
                "handle_input_line",
                "list",
                "write",
                "_rtc_gettime",
                "_alarm_handler",
                "hard_fault_handler",
                "phydat_dump",
                "_rtc_usage",
                "_rtc_getalarm"
            ],
            "imported": false,
            "current_name": "reverse_string_00004db8"
        },
        "FUN_000022f0": {
            "renaming": {
                "FUN_000022f0": "read_from_ring_buffer_000022f0",
                "rb": "ring_buffer",
                "uVar1": "read_index",
                "reads": "reads",
                "buf": "buf",
                "size": "size"
            },
            "code": "char read_from_ring_buffer_000022f0(tsrb_t *ring_buffer){\n  uint32_t read_index = ring_buffer->reads;\n  ring_buffer->reads = read_index + 1;\n  uint32_t buffer_size = ring_buffer->size;\n  uint32_t buffer_index = read_index & (buffer_size - 1);\n  return ring_buffer->buf[buffer_index];\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022f0",
            "calling": [
                "tsrb_get"
            ],
            "imported": false,
            "current_name": "read_from_ring_buffer_000022f0"
        },
        "FUN_00001c84": {
            "renaming": {
                "FUN_00001c84": "initialize_clocks_00001c84",
                "state": "interrupt_state",
                "mask": "interrupt_mask",
                "kinetis_mcg_set_safe_mode": "set_safe_mode",
                "DAT_00001ce8": "data_section_1",
                "DAT_00001cec": "data_section_2",
                "initialize_mcgirclk": "initialize_internal_reference_clock",
                "initialize_erclk32k": "initialize_external_reference_clock",
                "kinetis_mcg_set_mode": "set_mode",
                "KINETIS_MCG_MODE_PEE": "MODE_PEE",
                "irq_disable": "disable_interrupts",
                "irq_restore": "restore_interrupts"
            },
            "code": "void initialize_clocks_00001c84(void)\n{\n  uint32_t state;\n  uint32_t mask;\n  state = disable_interrupts();\n  set_safe_mode();\n  *(uint32_t *)(DAT_00001ce8 + 0x1044) = 0x220000;\n  DAT_00001cec[12] = 0;\n  *DAT_00001cec = *DAT_00001cec & 199 | 0x38;\n  DAT_00001cec[4] = 0x13;\n  DAT_00001cec[5] = 0;\n  initialize_mcgirclk();\n  initialize_erclk32k();\n  set_mode(MODE_PEE);\n  restore_interrupts(state);\n  return;\n}",
            "called": [
                "irq_disable",
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_init_erclk32k",
                "irq_restore",
                "kinetis_mcg_set_mode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001c84",
            "calling": [
                "cpu_init"
            ],
            "imported": false,
            "current_name": "initialize_clocks_00001c84"
        },
        "FUN_000068f0": {
            "renaming": {
                "FUN_000068f0": "save_flash_config_field_000068f0",
                "param_1": "size",
                "param_2": "data",
                "pvVar1": "new_data_ptr",
                "__n": "config_field_ptr",
                "data[13]": "old_data_ptr",
                "data[14]": "config_field_ptr",
                "*(undefined *)((int)new_data_ptr + 0x3ff)": "*(undefined *)((int)data + 0x46)",
                "*(undefined *)((int)new_data_ptr + 0x3fe)": "*(undefined *)((int)data + 0x45)",
                "*(undefined *)((int)new_data_ptr + 0x3fd)": "*(undefined *)(data + 17)",
                "*data": "new_data_ptr"
            },
            "code": "int save_flash_config_field_000068f0(size_t size, void **data)\n{\n  void *new_data_ptr;\n  void *old_data_ptr;\n  void *config_field_ptr;\n  size_t current_size;\n  \n  if ((void **)data[13] == data + 17) {\n    new_data_ptr = (void *)malloc(size, 0x400);\n    if (new_data_ptr != (void *)0x0) {\n      config_field_ptr = flash_configuration_field;\n      old_data_ptr = data[13];\n      data[14] = config_field_ptr;\n      data[13] = new_data_ptr;\n      *(undefined *)((int)new_data_ptr + 0x3ff) = *(undefined *)((int)data + 0x46);\n      *(undefined *)((int)new_data_ptr + 0x3fe) = *(undefined *)((int)data + 0x45);\n      *(undefined *)((int)new_data_ptr + 0x3fd) = *(undefined *)(data + 17);\n      *data = (void *)((int)new_data_ptr + 0x3fd);\n      return 0;\n    }\n  }\n  else {\n    current_size = (size_t)data[14];\n    new_data_ptr = (void *)realloc(size, data[13], (void *)((int)current_size << 1));\n    if (new_data_ptr != (void *)0x0) {\n      memcpy((void *)((int)new_data_ptr + (int)current_size), new_data_ptr, current_size);\n      data[13] = new_data_ptr;\n      data[14] = (void *)((int)current_size << 1);\n      *data = (void *)((int)new_data_ptr + (int)current_size);\n      return 0;\n    }\n  }\n  return -1;\n}",
            "called": [
                "memcpy",
                "_malloc_r",
                "_realloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000068f0",
            "calling": [
                "_sungetc_r"
            ],
            "imported": false,
            "current_name": "save_flash_config_field_000068f0"
        }
    },
    "used_tokens": 186540,
    "layers": [
        [
            "FUN_00004bd0",
            "FUN_000064bc",
            "FUN_00004cdc",
            "FUN_00005e68",
            "FUN_00001778",
            "FUN_00000566",
            "FUN_00001d08",
            "FUN_000031fc",
            "FUN_000016ec",
            "FUN_00004e8c",
            "FUN_00005584",
            "FUN_00000cb0",
            "FUN_00004248",
            "FUN_00000f5c",
            "FUN_00001da2",
            "FUN_00001ec4",
            "FUN_00002744",
            "FUN_00002624",
            "FUN_00001e0c",
            "FUN_0000459c",
            "FUN_000014c4",
            "FUN_00004b34",
            "FUN_000004f2",
            "FUN_0000423c",
            "FUN_00004e66",
            "FUN_00005ecc",
            "FUN_00001628",
            "FUN_00001748",
            "FUN_0000294c",
            "FUN_00005790",
            "FUN_00000534",
            "FUN_000017dc",
            "FUN_000005ca",
            "FUN_000043da",
            "FUN_00005ff8",
            "FUN_00006754",
            "FUN_00002714",
            "FUN_000020e0",
            "FUN_00004f80",
            "FUN_00005fec",
            "FUN_000028f0",
            "FUN_00004f98",
            "FUN_00004dee",
            "FUN_00000fec",
            "FUN_00000428",
            "FUN_000039e8",
            "FUN_00000e38",
            "FUN_00002294",
            "FUN_00003e9e",
            "FUN_00003378",
            "FUN_00006768",
            "FUN_00000db0",
            "FUN_00002600",
            "FUN_00003810",
            "FUN_00000ed8",
            "FUN_000031e0",
            "FUN_000004d4",
            "FUN_000020f4",
            "FUN_0000687c",
            "FUN_00004dea",
            "FUN_00005edc",
            "FUN_000023a4",
            "FUN_0000240c",
            "FUN_00004280",
            "FUN_00001448",
            "FUN_00001688",
            "FUN_00004042",
            "FUN_00000cf0",
            "FUN_00000f8c",
            "FUN_00002894",
            "FUN_00004158",
            "FUN_00002654",
            "FUN_00000aa8",
            "FUN_00002538",
            "FUN_00004c84",
            "FUN_000012b4",
            "FUN_0000058e",
            "FUN_000025f4",
            "FUN_00001ddc",
            "FUN_00002ecc",
            "FUN_00000d76",
            "FUN_000057a8",
            "FUN_00004298",
            "FUN_00001696",
            "FUN_000008b8",
            "FUN_000024bc",
            "FUN_00000490",
            "FUN_0000091c",
            "FUN_00005d80",
            "FUN_00001f80",
            "FUN_00000e64",
            "FUN_000026e4",
            "FUN_00000d44",
            "FUN_00000698",
            "FUN_00000cd0",
            "FUN_00000cc0",
            "FUN_00002994",
            "FUN_00000d2a",
            "FUN_00001ff6",
            "FUN_00000f80",
            "FUN_00002a88",
            "FUN_00002f30",
            "FUN_00001e44",
            "FUN_00001318",
            "FUN_00000900",
            "FUN_00004274",
            "FUN_00002fe0",
            "FUN_00001dc0",
            "FUN_00000df4",
            "FUN_00002eb4",
            "FUN_0000328c",
            "FUN_000041f4",
            "FUN_0000316c",
            "FUN_000026f0",
            "FUN_000057d2",
            "FUN_00000958",
            "FUN_000056b8",
            "FUN_00001a18",
            "FUN_00000d9c",
            "FUN_00003ff4",
            "FUN_00004634",
            "FUN_00001d5e",
            "FUN_0000191c",
            "FUN_000050f4",
            "FUN_00000c80",
            "FUN_00000a40",
            "FUN_00005a58",
            "FUN_000056b0",
            "FUN_00003d24",
            "FUN_000060cc",
            "FUN_000022be",
            "FUN_00003dc4",
            "FUN_00002108",
            "FUN_00000c90",
            "FUN_00001d80",
            "FUN_000033c0",
            "FUN_00002b10",
            "FUN_00001b10",
            "FUN_000023c8",
            "FUN_00002e48",
            "FUN_00000930",
            "FUN_00001348",
            "FUN_00006118",
            "FUN_00001d3a",
            "FUN_00002434",
            "FUN_00005700",
            "FUN_00002798",
            "FUN_00003524",
            "FUN_00001bb8",
            "FUN_0000428c",
            "FUN_0000404c",
            "FUN_00002f74",
            "FUN_000010a0",
            "FUN_000012e2",
            "FUN_000056a0",
            "FUN_0000231c",
            "FUN_00002690",
            "FUN_00006010",
            "FUN_00001cf0",
            "FUN_00003ec4",
            "FUN_00001360",
            "FUN_00004622",
            "FUN_0000093c",
            "FUN_00003658",
            "FUN_000019c0",
            "FUN_000060b0",
            "FUN_000023d0",
            "FUN_00000a30",
            "FUN_000034c0",
            "FUN_000050e8",
            "FUN_00000514",
            "FUN_00002e9c",
            "FUN_00001960",
            "FUN_00001a3c",
            "FUN_000045ee",
            "FUN_00005404",
            "FUN_00006974",
            "FUN_00005fd4",
            "FUN_00004dc8",
            "FUN_00005e10",
            "FUN_000033f4",
            "FUN_0000443c",
            "FUN_000027b0",
            "FUN_00005ebc",
            "FUN_00006192",
            "FUN_00001734",
            "FUN_00000e14",
            "FUN_0000281c",
            "FUN_00002270",
            "FUN_000020cc",
            "FUN_00002396",
            "FUN_00004e4a",
            "FUN_00004cb4",
            "FUN_00003478",
            "FUN_00002028",
            "FUN_000016c8",
            "FUN_00001a60",
            "FUN_000004b2",
            "FUN_0000099c",
            "FUN_00002d94",
            "FUN_00003918",
            "FUN_00003d64",
            "FUN_00004e52",
            "FUN_000010d4",
            "FUN_00000738",
            "FUN_00003e58",
            "FUN_00004e26",
            "FUN_00000978",
            "FUN_000018bc",
            "FUN_00000974",
            "FUN_00000610",
            "FUN_00003694",
            "FUN_00002364",
            "FUN_00001ad4",
            "FUN_00001274",
            "FUN_00002e6c",
            "FUN_00003444",
            "FUN_00003688",
            "FUN_00001392",
            "FUN_00002910",
            "FUN_00004418",
            "FUN_0000258c",
            "FUN_00002a00",
            "FUN_00000a64",
            "FUN_000043a0",
            "FUN_0000211c",
            "FUN_0000562c",
            "FUN_000020b8",
            "FUN_00002a18",
            "FUN_000054a8",
            "FUN_000007dc",
            "FUN_00001710",
            "FUN_00001034",
            "FUN_000055ac",
            "FUN_00006964",
            "FUN_0000182c",
            "FUN_000022f0",
            "FUN_000068f0"
        ],
        [
            "FUN_00000dc0",
            "FUN_00005100",
            "FUN_000041d0",
            "FUN_0000129c",
            "FUN_00000410",
            "FUN_00004f84",
            "FUN_00001eea",
            "FUN_0000305c",
            "FUN_000013b8",
            "FUN_000042a4",
            "FUN_00004314",
            "FUN_00005fd8",
            "FUN_00005780",
            "FUN_00000f04",
            "FUN_00004db8",
            "FUN_00001c84"
        ]
    ],
    "locked_functions": []
}