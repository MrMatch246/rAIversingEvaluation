{
    "functions": {
        "FUN_08000110": {
            "entrypoint": "0x08000110",
            "current_name": "set_completed_flag_08000110",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800011c) */\n\nundefined4 set_completed_flag_08000110(undefined4 input)\n\n{\n  if ((char)completion_flag == '\\0') {\n    completion_flag._0_1_ = '\\x01';\n  }\n  return input;\n}\n\n",
            "renaming": {
                "FUN_08000110": "set_completed_flag_08000110",
                "param_1": "input",
                "completed_8672": "completion_flag"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000134": {
            "entrypoint": "0x08000134",
            "current_name": "combine32bit_values_08000134",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800013a) */\n\nundefined8 combine32bitValues_08000134(undefined4 value1,undefined4 value2)\n\n{\n  return CONCAT44(value2,value1);\n}\n\n",
            "renaming": {
                "FUN_08000134": "combine32bit_values_08000134",
                "param_1": "value1",
                "param_2": "value2"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000150": {
            "entrypoint": "0x08000150",
            "current_name": "calculate_string_length_08000150",
            "code": "\nsize_t calculateStringLength_08000150(char *string)\n\n{\n  char currentChar;\n  char *nextCharPointer;\n  char *currentCharPointer;\n  \n  currentCharPointer = string;\n  do {\n    nextCharPointer = currentCharPointer + 1;\n    currentChar = *currentCharPointer;\n    currentCharPointer = nextCharPointer;\n  } while (currentChar != '\\0');\n  return (size_t)(nextCharPointer + (-1 - (int)string));\n}\n\n",
            "renaming": {
                "FUN_08000150": "calculate_string_length_08000150",
                "__s": "string",
                "cVar1": "currentChar",
                "pcVar2": "nextCharPointer",
                "pcVar3": "currentCharPointer"
            },
            "calling": [
                "serialPrint"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000160": {
            "entrypoint": "0x08000160",
            "current_name": "add_unsigned_int_08000160",
            "code": "\nvoid addUnsignedInt_08000160(undefined4 result,uint input)\n\n{\n  __aeabi_dadd(result,input ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000160": "add_unsigned_int_08000160",
                "param_1": "result",
                "param_2": "input"
            },
            "calling": [],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000168": {
            "entrypoint": "0x08000168",
            "current_name": "calculate_result_08000168",
            "code": "\nulonglong calculateResult_08000168(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int shiftedInput2;\n  byte carryFlag;\n  uint result1;\n  uint result2;\n  uint result3;\n  uint temp1;\n  uint temp2;\n  int shiftedInput4;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  \n  temp1 = input4 ^ 0x80000000;\n  temp3 = input2 << 1;\n  input4 = input4 << 1;\n  condition1 = ((input2 ^ temp1) & 0x7fffffff) == 0;\n  condition2 = condition1 && input1 == input3;\n  if (!condition1 || input1 != input3) {\n    condition2 = (temp3 | input1) == 0;\n  }\n  if (!condition2) {\n    condition2 = (input4 | input3) == 0;\n  }\n  shiftedInput4 = (int)temp3 >> 0x15;\n  if (!condition2) {\n    condition2 = shiftedInput4 == -1;\n  }\n  shiftedInput2 = (int)input4 >> 0x15;\n  if (!condition2) {\n    condition2 = shiftedInput2 == -1;\n  }\n  if (condition2) {\n    if (shiftedInput4 == -1 || shiftedInput2 == -1) {\n      temp3 = temp1;\n      temp5 = input3;\n      if (shiftedInput4 == -1) {\n        temp3 = input2;\n        temp5 = input1;\n      }\n      if (shiftedInput4 != -1 || shiftedInput2 != -1) {\n        input3 = temp5;\n        temp1 = temp3;\n      }\n      condition2 = (temp5 | temp3 << 0xc) == 0;\n      if (condition2) {\n        condition2 = (input3 | temp1 << 0xc) == 0;\n      }\n      if (condition2) {\n        condition2 = temp3 == temp1;\n      }\n      if (!condition2) {\n        temp3 = temp3 | 0x80000;\n      }\n      return CONCAT44(temp3,temp5);\n    }\n    if (((input2 ^ temp1) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((temp3 | input1) == 0) {\n        input1 = input3;\n        input2 = temp1;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != temp1) {\n      return 0;\n    }\n    if (temp3 >> 0x15 == 0) {\n      condition2 = (input1 & 0x80000000) != 0;\n      temp1 = input2 * 2 + (uint)condition2;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)condition2)) {\n        temp1 = temp1 | 0x80000000;\n      }\n      return CONCAT44(temp1,input1 << 1);\n    }\n    if (temp3 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_080003ac:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  temp3 = temp3 >> 0x15;\n  input4 = input4 >> 0x15;\n  temp5 = input4 - temp3;\n  condition2 = temp5 != 0;\n  if (input4 < temp3) {\n    temp5 = -temp5;\n  }\n  temp4 = input1;\n  temp2 = input2;\n  if (condition2 && temp3 <= input4) {\n    temp3 = temp3 + temp5;\n    temp4 = input3;\n    temp2 = temp1;\n    input3 = input1;\n    temp1 = input2;\n  }\n  if (0x36 < temp5) {\n    return CONCAT44(temp2,temp4);\n  }\n  result2 = temp2 & 0xfffff | 0x100000;\n  if ((temp2 & 0x80000000) != 0) {\n    condition2 = temp4 != 0;\n    temp4 = -temp4;\n    result2 = -result2 - (uint)condition2;\n  }\n  temp2 = temp1 & 0xfffff | 0x100000;\n  if ((temp1 & 0x80000000) != 0) {\n    condition2 = input3 != 0;\n    input3 = -input3;\n    temp2 = -temp2 - (uint)condition2;\n  }\n  if (temp3 == temp5) {\n    temp2 = temp2 ^ 0x100000;\n    if (temp3 == 0) {\n      result2 = result2 ^ 0x100000;\n      temp3 = 1;\n    }\n    else {\n      temp5 = temp5 - 1;\n    }\n  }\n  temp1 = -temp5 + 0x20;\n  if ((int)temp5 < 0x21) {\n    temp6 = input3 << (temp1 & 0xff);\n    input3 = input3 >> (temp5 & 0xff);\n    result1 = temp4 + input3;\n    result3 = temp2 << (temp1 & 0xff);\n    temp1 = result1 + result3;\n    result2 = result2 + CARRY4(temp4,input3) + ((int)temp2 >> (temp5 & 0xff)) +\n            (uint)CARRY4(result1,result3);\n  }\n  else {\n    temp6 = temp2 << (-temp5 + 0x40 & 0xff);\n    if (input3 != 0) {\n      temp6 = temp6 | 2;\n    }\n    temp2 = (int)temp2 >> (temp5 - 0x20 & 0xff);\n    temp1 = temp4 + temp2;\n    result2 = result2 + ((int)temp2 >> 0x1f) + (uint)CARRY4(temp4,temp2);\n  }\n  input2 = result2 & 0x80000000;\n  temp5 = result2;\n  if ((int)result2 < 0) {\n    condition2 = temp6 == 0;\n    temp6 = -temp6;\n    temp5 = -temp1;\n    temp1 = -(uint)!condition2 - temp1;\n    temp5 = -(uint)(condition2 <= temp5) - result2;\n  }\n  if (0xfffff < temp5) {\n    temp4 = temp3 - 1;\n    if (0x1fffff < temp5) {\n      temp4 = temp5 & 1;\n      temp5 = temp5 >> 1;\n      carryFlag = (byte)temp1;\n      temp1 = (uint)(temp4 != 0) << 0x1f | temp1 >> 1;\n      temp6 = (uint)(carryFlag & 1) << 0x1f | temp6 >> 1;\n      temp4 = temp3;\n      if (0xffbfffff < temp3 * 0x200000) goto LAB_080003ac;\n    }\nLAB_08000278:\n    condition2 = 0x7fffffff < temp6;\n    if (temp6 == 0x80000000) {\n      condition2 = (temp1 & 1) != 0;\n    }\n    return CONCAT44(temp5 + temp4 * 0x100000 + (uint)CARRY4(temp1,(uint)condition2) | input2,\n                    temp1 + condition2);\n  }\n  condition1 = (temp6 & 0x80000000) != 0;\n  temp6 = temp6 << 1;\n  temp4 = temp1 * 2;\n  condition2 = CARRY4(temp1,temp1);\n  temp1 = temp1 * 2 + (uint)condition1;\n  temp5 = temp5 * 2 + (uint)(condition2 || CARRY4(temp4,(uint)condition1));\n  temp4 = temp3 - 2;\n  if ((temp5 & 0x100000) != 0) goto LAB_08000278;\n  temp2 = temp1;\n  temp3 = temp5;\n  if (temp5 == 0) {\n    temp2 = 0;\n    temp3 = temp1;\n  }\n  shiftedInput4 = LZCOUNT(temp3);\n  if (temp5 == 0) {\n    shiftedInput4 = shiftedInput4 + 0x20;\n  }\n  temp5 = shiftedInput4 - 0xb;\n  condition3 = SBORROW4(temp5,0x20);\n  temp1 = shiftedInput4 - 0x2b;\n  condition2 = (int)temp1 < 0;\n  condition1 = temp1 == 0;\n  if ((int)temp5 < 0x20) {\n    condition3 = SCARRY4(temp1,0xc);\n    shiftedInput4 = shiftedInput4 + -0x1f;\n    condition2 = shiftedInput4 < 0;\n    condition1 = shiftedInput4 == 0;\n    temp1 = temp5;\n    if (!condition1 && condition2 == condition3) {\n      temp2 = temp3 << (temp5 & 0xff);\n      temp3 = temp3 >> (0xcU - shiftedInput4 & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (condition1 || condition2 != condition3) {\n    temp6 = 0x20 - temp1;\n  }\n  temp3 = temp3 << (temp1 & 0xff);\n  if (condition1 || condition2 != condition3) {\n    temp3 = temp3 | temp2 >> (temp6 & 0xff);\n  }\n  if (condition1 || condition2 != condition3) {\n    temp2 = temp2 << (temp1 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)temp5 <= (int)temp4) {\n    return CONCAT44(temp3 + (temp4 - temp5) * 0x100000 | input2,temp2);\n  }\n  temp1 = ~(temp4 - temp5);\n  if ((int)temp1 < 0x1f) {\n    shiftedInput4 = temp1 - 0x13;\n    if (shiftedInput4 != 0 && shiftedInput4 < 0 == SCARRY4(temp1 - 0x1f,0xc)) {\n      return CONCAT44(result2,temp2 >> (0x20 - (0xcU - shiftedInput4) & 0xff) | temp3 << (0xcU - shiftedInput4 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    temp1 = temp1 + 1;\n    return CONCAT44(input2 | temp3 >> (temp1 & 0xff),\n                    temp2 >> (temp1 & 0xff) | temp3 << (0x20 - temp1 & 0xff));\n  }\n  return CONCAT44(result2,temp3 >> (temp1 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000168": "calculate_result_08000168",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shiftedInput2",
                "bVar2": "carryFlag",
                "uVar3": "result1",
                "uVar4": "result2",
                "uVar5": "result3",
                "uVar6": "temp1",
                "uVar7": "temp2",
                "iVar8": "shiftedInput4",
                "uVar9": "temp3",
                "uVar10": "temp4",
                "uVar11": "temp5",
                "uVar12": "temp6",
                "bVar13": "condition1",
                "bVar14": "condition2",
                "bVar15": "condition3"
            },
            "calling": [
                "__ieee754_atan2",
                "rint",
                "atan",
                "__ieee754_sqrt",
                "__ieee754_asin",
                "MS5611_Update",
                "__ieee754_pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800016c": {
            "entrypoint": "0x0800016c",
            "current_name": "perform_unsigned_math_0800016c",
            "code": "\nulonglong performUnsignedMath_0800016c(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int shift1;\n  byte carry;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int shift2;\n  uint shiftedInput1;\n  uint shiftedInput2;\n  uint shiftedInput3;\n  uint shiftedInput4;\n  uint shiftedTemp1;\n  uint shiftedTemp2;\n  bool isEqual;\n  bool isZero;\n  bool isNegative;\n  \n  shiftedInput1 = input2 << 1;\n  shiftedInput3 = input4 << 1;\n  isEqual = ((input2 ^ input4) & 0x7fffffff) == 0;\n  isZero = isEqual && input1 == input3;\n  if (!isEqual || input1 != input3) {\n    isZero = (shiftedInput1 | input1) == 0;\n  }\n  if (!isZero) {\n    isZero = (shiftedInput3 | input3) == 0;\n  }\n  shift2 = (int)shiftedInput1 >> 0x15;\n  if (!isZero) {\n    isZero = shift2 == -1;\n  }\n  shift1 = (int)shiftedInput3 >> 0x15;\n  if (!isZero) {\n    isZero = shift1 == -1;\n  }\n  if (isZero) {\n    if (shift2 == -1 || shift1 == -1) {\n      shiftedInput3 = input4;\n      shiftedInput1 = input3;\n      if (shift2 == -1) {\n        shiftedInput3 = input2;\n        shiftedInput1 = input1;\n      }\n      if (shift2 != -1 || shift1 != -1) {\n        input3 = shiftedInput1;\n        input4 = shiftedInput3;\n      }\n      isZero = (shiftedInput1 | shiftedInput3 << 0xc) == 0;\n      if (isZero) {\n        isZero = (input3 | input4 << 0xc) == 0;\n      }\n      if (isZero) {\n        isZero = shiftedInput3 == input4;\n      }\n      if (!isZero) {\n        shiftedInput3 = shiftedInput3 | 0x80000;\n      }\n      return CONCAT44(shiftedInput3,shiftedInput1);\n    }\n    if (((input2 ^ input4) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((shiftedInput1 | input1) == 0) {\n        input1 = input3;\n        input2 = input4;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != input4) {\n      return 0;\n    }\n    if (shiftedInput1 >> 0x15 == 0) {\n      isZero = (input1 & 0x80000000) != 0;\n      shiftedInput3 = input2 * 2 + (uint)isZero;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)isZero)) {\n        shiftedInput3 = shiftedInput3 | 0x80000000;\n      }\n      return CONCAT44(shiftedInput3,input1 << 1);\n    }\n    if (shiftedInput1 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_080003ac:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  shiftedInput1 = shiftedInput1 >> 0x15;\n  shiftedInput3 = shiftedInput3 >> 0x15;\n  shiftedInput4 = shiftedInput3 - shiftedInput1;\n  isZero = shiftedInput4 != 0;\n  if (shiftedInput3 < shiftedInput1) {\n    shiftedInput4 = -shiftedInput4;\n  }\n  shiftedInput2 = input1;\n  temp3 = input2;\n  if (isZero && shiftedInput1 <= shiftedInput3) {\n    shiftedInput1 = shiftedInput1 + shiftedInput4;\n    shiftedInput2 = input3;\n    temp3 = input4;\n    input3 = input1;\n    input4 = input2;\n  }\n  if (0x36 < shiftedInput4) {\n    return CONCAT44(temp3,shiftedInput2);\n  }\n  shiftedInput3 = temp3 & 0xfffff | 0x100000;\n  if ((temp3 & 0x80000000) != 0) {\n    isZero = shiftedInput2 != 0;\n    shiftedInput2 = -shiftedInput2;\n    shiftedInput3 = -shiftedInput3 - (uint)isZero;\n  }\n  temp3 = input4 & 0xfffff | 0x100000;\n  if ((input4 & 0x80000000) != 0) {\n    isZero = input3 != 0;\n    input3 = -input3;\n    temp3 = -temp3 - (uint)isZero;\n  }\n  if (shiftedInput1 == shiftedInput4) {\n    temp3 = temp3 ^ 0x100000;\n    if (shiftedInput1 == 0) {\n      shiftedInput3 = shiftedInput3 ^ 0x100000;\n      shiftedInput1 = 1;\n    }\n    else {\n      shiftedInput4 = shiftedInput4 - 1;\n    }\n  }\n  shiftedTemp2 = -shiftedInput4 + 0x20;\n  if ((int)shiftedInput4 < 0x21) {\n    shiftedTemp1 = input3 << (shiftedTemp2 & 0xff);\n    input3 = input3 >> (shiftedInput4 & 0xff);\n    temp1 = shiftedInput2 + input3;\n    temp2 = temp3 << (shiftedTemp2 & 0xff);\n    shiftedTemp2 = temp1 + temp2;\n    shiftedInput3 = shiftedInput3 + CARRY4(shiftedInput2,input3) + ((int)temp3 >> (shiftedInput4 & 0xff)) +\n            (uint)CARRY4(temp1,temp2);\n  }\n  else {\n    shiftedTemp1 = temp3 << (-shiftedInput4 + 0x40 & 0xff);\n    if (input3 != 0) {\n      shiftedTemp1 = shiftedTemp1 | 2;\n    }\n    temp3 = (int)temp3 >> (shiftedInput4 - 0x20 & 0xff);\n    shiftedTemp2 = shiftedInput2 + temp3;\n    shiftedInput3 = shiftedInput3 + ((int)temp3 >> 0x1f) + (uint)CARRY4(shiftedInput2,temp3);\n  }\n  input2 = shiftedInput3 & 0x80000000;\n  shiftedInput4 = shiftedInput3;\n  if ((int)shiftedInput3 < 0) {\n    isZero = shiftedTemp1 == 0;\n    shiftedTemp1 = -shiftedTemp1;\n    shiftedInput4 = -shiftedTemp2;\n    shiftedTemp2 = -(uint)!isZero - shiftedTemp2;\n    shiftedInput4 = -(uint)(isZero <= shiftedInput4) - shiftedInput3;\n  }\n  if (0xfffff < shiftedInput4) {\n    shiftedInput2 = shiftedInput1 - 1;\n    if (0x1fffff < shiftedInput4) {\n      shiftedInput3 = shiftedInput4 & 1;\n      shiftedInput4 = shiftedInput4 >> 1;\n      carry = (byte)shiftedTemp2;\n      shiftedTemp2 = (uint)(shiftedInput3 != 0) << 0x1f | shiftedTemp2 >> 1;\n      shiftedTemp1 = (uint)(carry & 1) << 0x1f | shiftedTemp1 >> 1;\n      shiftedInput2 = shiftedInput1;\n      if (0xffbfffff < shiftedInput1 * 0x200000) goto LAB_080003ac;\n    }\nLAB_08000278:\n    isZero = 0x7fffffff < shiftedTemp1;\n    if (shiftedTemp1 == 0x80000000) {\n      isZero = (shiftedTemp2 & 1) != 0;\n    }\n    return CONCAT44(shiftedInput4 + shiftedInput2 * 0x100000 + (uint)CARRY4(shiftedTemp2,(uint)isZero) | input2,\n                    shiftedTemp2 + isZero);\n  }\n  isEqual = (shiftedTemp1 & 0x80000000) != 0;\n  shiftedTemp1 = shiftedTemp1 << 1;\n  shiftedInput2 = shiftedTemp2 * 2;\n  isZero = CARRY4(shiftedTemp2,shiftedTemp2);\n  shiftedTemp2 = shiftedTemp2 * 2 + (uint)isEqual;\n  shiftedInput4 = shiftedInput4 * 2 + (uint)(isZero || CARRY4(shiftedInput2,(uint)isEqual));\n  shiftedInput2 = shiftedInput1 - 2;\n  if ((shiftedInput4 & 0x100000) != 0) goto LAB_08000278;\n  temp3 = shiftedTemp2;\n  shiftedInput1 = shiftedInput4;\n  if (shiftedInput4 == 0) {\n    temp3 = 0;\n    shiftedInput1 = shiftedTemp2;\n  }\n  shift2 = LZCOUNT(shiftedInput1);\n  if (shiftedInput4 == 0) {\n    shift2 = shift2 + 0x20;\n  }\n  shiftedTemp2 = shift2 - 0xb;\n  isNegative = SBORROW4(shiftedTemp2,0x20);\n  shiftedInput4 = shift2 - 0x2b;\n  isZero = (int)shiftedInput4 < 0;\n  isEqual = shiftedInput4 == 0;\n  if ((int)shiftedTemp2 < 0x20) {\n    isNegative = SCARRY4(shiftedInput4,0xc);\n    shift2 = shift2 + -0x1f;\n    isZero = shift2 < 0;\n    isEqual = shift2 == 0;\n    shiftedInput4 = shiftedTemp2;\n    if (!isEqual && isZero == isNegative) {\n      temp3 = shiftedInput1 << (shiftedTemp2 & 0xff);\n      shiftedInput1 = shiftedInput1 >> (0xcU - shift2 & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (isEqual || isZero != isNegative) {\n    shiftedTemp1 = 0x20 - shiftedInput4;\n  }\n  shiftedInput1 = shiftedInput1 << (shiftedInput4 & 0xff);\n  if (isEqual || isZero != isNegative) {\n    shiftedInput1 = shiftedInput1 | temp3 >> (shiftedTemp1 & 0xff);\n  }\n  if (isEqual || isZero != isNegative) {\n    temp3 = temp3 << (shiftedInput4 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)shiftedTemp2 <= (int)shiftedInput2) {\n    return CONCAT44(shiftedInput1 + (shiftedInput2 - shiftedTemp2) * 0x100000 | input2,temp3);\n  }\n  shiftedInput4 = ~(shiftedInput2 - shiftedTemp2);\n  if ((int)shiftedInput4 < 0x1f) {\n    shift2 = shiftedInput4 - 0x13;\n    if (shift2 != 0 && shift2 < 0 == SCARRY4(shiftedInput4 - 0x1f,0xc)) {\n      return CONCAT44(shiftedInput3,temp3 >> (0x20 - (0xcU - shift2) & 0xff) | shiftedInput1 << (0xcU - shift2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    shiftedInput4 = shiftedInput4 + 1;\n    return CONCAT44(input2 | shiftedInput1 >> (shiftedInput4 & 0xff),\n                    temp3 >> (shiftedInput4 & 0xff) | shiftedInput1 << (0x20 - shiftedInput4 & 0xff));\n  }\n  return CONCAT44(shiftedInput3,shiftedInput1 >> (shiftedInput4 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800016c": "perform_unsigned_math_0800016c",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shift1",
                "bVar2": "carry",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "iVar6": "shift2",
                "uVar7": "shiftedInput1",
                "uVar8": "shiftedInput2",
                "uVar9": "shiftedInput3",
                "uVar10": "shiftedInput4",
                "uVar11": "shiftedTemp1",
                "uVar12": "shiftedTemp2",
                "bVar13": "isEqual",
                "bVar14": "isZero",
                "bVar15": "isNegative"
            },
            "calling": [
                "scalbn",
                "__ieee754_atan2",
                "rint",
                "atan",
                "__ieee754_sqrt",
                "__ieee754_asin",
                "__aeabi_drsub",
                "__ieee754_pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003e4": {
            "entrypoint": "0x080003e4",
            "current_name": "bit_shift_and_concatenate_080003e4",
            "code": "\nulonglong bitShiftAndConcatenate_080003e4(uint input)\n\n{\n  uint result1;\n  uint result2;\n  int count;\n  uint offset;\n  uint remainingBits;\n  bool isNegative;\n  bool isZero;\n  bool isCarry;\n  \n  if (input == 0) {\n    return 0;\n  }\n  result1 = 0;\n  count = LZCOUNT(input);\n  offset = count + 0x15;\n  isCarry = SBORROW4(offset,0x20);\n  result2 = count - 0xb;\n  isNegative = (int)result2 < 0;\n  isZero = result2 == 0;\n  if (offset < 0x20) {\n    isCarry = SCARRY4(result2,0xc);\n    isNegative = false;\n    isZero = count + 1 == 0;\n    result2 = offset;\n    if (!isZero && isCarry == false) {\n      result1 = input << offset;\n      input = input >> (0xcU - (count + 1) & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (isZero || isNegative != isCarry) {\n    remainingBits = 0x20 - result2;\n  }\n  input = input << (result2 & 0xff);\n  if (isZero || isNegative != isCarry) {\n    input = input | 0U >> (remainingBits & 0xff);\n  }\n  if (isZero || isNegative != isCarry) {\n    result1 = 0 << (result2 & 0xff);\n  }\nLAB_080002f0:\n  if (offset < 0x433) {\n    return CONCAT44(input + (0x432 - offset) * 0x100000,result1);\n  }\n  result2 = ~(0x432 - offset);\n  if (0x1e < (int)result2) {\n    return (ulonglong)(input >> (result2 - 0x1f & 0xff));\n  }\n  count = result2 - 0x13;\n  if (count == 0 || count < 0 != SCARRY4(result2 - 0x1f,0xc)) {\n    result2 = result2 + 1;\n    return CONCAT44(input >> (result2 & 0xff),\n                    result1 >> (result2 & 0xff) | input << (0x20 - result2 & 0xff));\n  }\n  return (ulonglong)(result1 >> (0x20 - (0xcU - count) & 0xff) | input << (0xcU - count & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080003e4": "bit_shift_and_concatenate_080003e4",
                "param_1": "input",
                "uVar1": "result1",
                "uVar2": "result2",
                "iVar3": "count",
                "uVar4": "offset",
                "in_r12": "remainingBits",
                "bVar5": "isNegative",
                "bVar6": "isZero",
                "bVar7": "isCarry"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000404": {
            "entrypoint": "0x08000404",
            "current_name": "shift_and_concat_bits_08000404",
            "code": "\nulonglong shiftAndConcatBits_08000404(uint input)\n\n{\n  uint bitCount1;\n  uint absInput;\n  uint shiftAmount;\n  int leadingZeros;\n  uint totalBits;\n  uint signBit;\n  uint remainingBits;\n  bool isNegative;\n  bool isZero;\n  bool isCarry;\n  \n  if (input == 0) {\n    return 0;\n  }\n  signBit = input & 0x80000000;\n  absInput = input;\n  if ((int)signBit < 0) {\n    absInput = -input;\n  }\n  bitCount1 = 0;\n  leadingZeros = LZCOUNT(absInput);\n  totalBits = leadingZeros + 0x15;\n  isCarry = SBORROW4(totalBits,0x20);\n  shiftAmount = leadingZeros - 0xb;\n  isNegative = (int)shiftAmount < 0;\n  isZero = shiftAmount == 0;\n  if (totalBits < 0x20) {\n    isCarry = SCARRY4(shiftAmount,0xc);\n    isNegative = false;\n    isZero = leadingZeros + 1 == 0;\n    shiftAmount = totalBits;\n    if (!isZero && isCarry == false) {\n      bitCount1 = absInput << totalBits;\n      absInput = absInput >> (0xcU - (leadingZeros + 1) & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (isZero || isNegative != isCarry) {\n    remainingBits = 0x20 - shiftAmount;\n  }\n  absInput = absInput << (shiftAmount & 0xff);\n  if (isZero || isNegative != isCarry) {\n    absInput = absInput | 0U >> (remainingBits & 0xff);\n  }\n  if (isZero || isNegative != isCarry) {\n    bitCount1 = 0 << (shiftAmount & 0xff);\n  }\nLAB_080002f0:\n  if (totalBits < 0x433) {\n    return CONCAT44(absInput + (0x432 - totalBits) * 0x100000 | signBit,bitCount1);\n  }\n  shiftAmount = ~(0x432 - totalBits);\n  if (0x1e < (int)shiftAmount) {\n    return CONCAT44(input,absInput >> (shiftAmount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leadingZeros = shiftAmount - 0x13;\n  if (leadingZeros == 0 || leadingZeros < 0 != SCARRY4(shiftAmount - 0x1f,0xc)) {\n    shiftAmount = shiftAmount + 1;\n    return CONCAT44(signBit | absInput >> (shiftAmount & 0xff),\n                    bitCount1 >> (shiftAmount & 0xff) | absInput << (0x20 - shiftAmount & 0xff));\n  }\n  return CONCAT44(input,bitCount1 >> (0x20 - (0xcU - leadingZeros) & 0xff) | absInput << (0xcU - leadingZeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000404": "shift_and_concat_bits_08000404",
                "param_1": "input",
                "uVar1": "bitCount1",
                "uVar2": "absInput",
                "uVar3": "shiftAmount",
                "iVar4": "leadingZeros",
                "uVar5": "totalBits",
                "uVar6": "signBit",
                "in_r12": "remainingBits",
                "bVar7": "isNegative",
                "bVar8": "isZero",
                "bVar9": "isCarry"
            },
            "calling": [
                "__ieee754_pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000428": {
            "entrypoint": "0x08000428",
            "current_name": "process_data_08000428",
            "code": "\nulonglong processData_08000428(uint input,undefined4 arg1,undefined4 arg2,uint arg3)\n\n{\n  uint signBit;\n  uint shiftedInput;\n  uint resultHigh;\n  uint shiftAmount;\n  uint shiftedInput2;\n  int bitCount;\n  uint shiftedCount;\n  uint remainingBits;\n  bool isZero;\n  bool isFull;\n  bool isNegative;\n  \n  shiftedInput2 = input << 1;\n  isFull = shiftedInput2 == 0;\n  signBit = (uint)((input & 0x80000000) != 0) << 0x1f;\n  shiftAmount = (uint)((int)shiftedInput2 >> 3) >> 1;\n  resultHigh = signBit | shiftAmount;\n  input = input << 0x1d;\n  if (!isFull) {\n    arg3 = shiftedInput2 & 0xff000000;\n    isFull = arg3 == 0;\n  }\n  if (!isFull) {\n    isFull = arg3 == 0xff000000;\n  }\n  if (!isFull) {\n    return CONCAT44(resultHigh,input) ^ 0x3800000000000000;\n  }\n  if (shiftedInput2 == 0 || arg3 == 0xff000000) {\n    return CONCAT44(resultHigh,input);\n  }\n  shiftedInput = input;\n  shiftedInput2 = shiftAmount;\n  if (shiftAmount == 0) {\n    shiftedInput = 0;\n    shiftedInput2 = input;\n  }\n  bitCount = LZCOUNT(shiftedInput2);\n  if (shiftAmount == 0) {\n    bitCount = bitCount + 0x20;\n  }\n  shiftedCount = bitCount - 0xb;\n  isNegative = SBORROW4(shiftedCount,0x20);\n  shiftAmount = bitCount - 0x2b;\n  isFull = (int)shiftAmount < 0;\n  isZero = shiftAmount == 0;\n  if ((int)shiftedCount < 0x20) {\n    isNegative = SCARRY4(shiftAmount,0xc);\n    bitCount = bitCount + -0x1f;\n    isFull = bitCount < 0;\n    isZero = bitCount == 0;\n    shiftAmount = shiftedCount;\n    if (!isZero && isFull == isNegative) {\n      shiftedInput = shiftedInput2 << (shiftedCount & 0xff);\n      shiftedInput2 = shiftedInput2 >> (0xcU - bitCount & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (isZero || isFull != isNegative) {\n    remainingBits = 0x20 - shiftAmount;\n  }\n  shiftedInput2 = shiftedInput2 << (shiftAmount & 0xff);\n  if (isZero || isFull != isNegative) {\n    shiftedInput2 = shiftedInput2 | shiftedInput >> (remainingBits & 0xff);\n  }\n  if (isZero || isFull != isNegative) {\n    shiftedInput = shiftedInput << (shiftAmount & 0xff);\n  }\nLAB_080002f0:\n  if ((int)shiftedCount < 0x381) {\n    return CONCAT44(shiftedInput2 + (0x380 - shiftedCount) * 0x100000 | signBit,shiftedInput);\n  }\n  shiftAmount = ~(0x380 - shiftedCount);\n  if ((int)shiftAmount < 0x1f) {\n    bitCount = shiftAmount - 0x13;\n    if (bitCount != 0 && bitCount < 0 == SCARRY4(shiftAmount - 0x1f,0xc)) {\n      return CONCAT44(resultHigh,shiftedInput >> (0x20 - (0xcU - bitCount) & 0xff) | shiftedInput2 << (0xcU - bitCount & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    shiftAmount = shiftAmount + 1;\n    return CONCAT44(signBit | shiftedInput2 >> (shiftAmount & 0xff),\n                    shiftedInput >> (shiftAmount & 0xff) | shiftedInput2 << (0x20 - shiftAmount & 0xff));\n  }\n  return CONCAT44(resultHigh,shiftedInput2 >> (shiftAmount - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000428": "process_data_08000428",
                "param_1": "input",
                "param_2": "arg1",
                "param_3": "arg2",
                "param_4": "arg3",
                "uVar1": "signBit",
                "uVar2": "shiftedInput",
                "uVar3": "resultHigh",
                "uVar4": "shiftAmount",
                "uVar5": "shiftedInput2",
                "iVar6": "bitCount",
                "uVar7": "shiftedCount",
                "in_r12": "remainingBits",
                "bVar8": "isZero",
                "bVar9": "isFull",
                "bVar10": "isNegative"
            },
            "calling": [
                "MadgwickQuaternionUpdate",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000464": {
            "entrypoint": "0x08000464",
            "current_name": "convert_uint_to_double_08000464",
            "code": "\nulonglong convertUintToDouble_08000464(uint input1,uint input2)\n\n{\n  byte byteValue;\n  uint result1;\n  uint result2;\n  uint temp1;\n  int temp2;\n  uint temp3;\n  int count;\n  uint temp4;\n  bool bool1;\n  bool bool2;\n  bool bool3;\n  \n  if ((input1 | input2) == 0) {\n    return CONCAT44(input2,input1);\n  }\n  count = 0x432;\n  temp4 = input2 >> 0x16;\n  if (temp4 != 0) {\n    count = 3;\n    if (input2 >> 0x19 != 0) {\n      count = 6;\n    }\n    if (input2 >> 0x1c != 0) {\n      count = count + 3;\n    }\n    temp1 = count - ((int)input2 >> 0x1f);\n    temp4 = input1 << (0x20 - temp1 & 0xff);\n    input1 = input1 >> (temp1 & 0xff) | input2 << (0x20 - temp1 & 0xff);\n    input2 = input2 >> (temp1 & 0xff);\n    count = temp1 + 0x432;\n  }\n  if (0xfffff < input2) {\n    if (0x1fffff < input2) {\n      temp1 = input2 & 1;\n      input2 = input2 >> 1;\n      byteValue = (byte)input1;\n      input1 = (uint)(temp1 != 0) << 0x1f | input1 >> 1;\n      temp4 = (uint)(byteValue & 1) << 0x1f | temp4 >> 1;\n      count = count + 1;\n      if (0xffbfffff < (uint)(count * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_08000278:\n    bool2 = 0x7fffffff < temp4;\n    if (temp4 == 0x80000000) {\n      bool2 = (input1 & 1) != 0;\n    }\n    return CONCAT44(input2 + count * 0x100000 + (uint)CARRY4(input1,(uint)bool2),input1 + bool2\n                   );\n  }\n  bool1 = (temp4 & 0x80000000) != 0;\n  temp4 = temp4 << 1;\n  temp1 = input1 * 2;\n  bool2 = CARRY4(input1,input1);\n  input1 = input1 * 2 + (uint)bool1;\n  input2 = input2 * 2 + (uint)(bool2 || CARRY4(temp1,(uint)bool1));\n  count = count + -1;\n  if ((input2 & 0x100000) != 0) goto LAB_08000278;\n  result1 = input1;\n  temp1 = input2;\n  if (input2 == 0) {\n    result1 = 0;\n    temp1 = input1;\n  }\n  temp2 = LZCOUNT(temp1);\n  if (input2 == 0) {\n    temp2 = temp2 + 0x20;\n  }\n  temp3 = temp2 - 0xb;\n  bool3 = SBORROW4(temp3,0x20);\n  result2 = temp2 - 0x2b;\n  bool2 = (int)result2 < 0;\n  bool1 = result2 == 0;\n  if ((int)temp3 < 0x20) {\n    bool3 = SCARRY4(result2,0xc);\n    temp2 = temp2 + -0x1f;\n    bool2 = temp2 < 0;\n    bool1 = temp2 == 0;\n    result2 = temp3;\n    if (!bool1 && bool2 == bool3) {\n      result1 = temp1 << (temp3 & 0xff);\n      temp1 = temp1 >> (0xcU - temp2 & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (bool1 || bool2 != bool3) {\n    temp4 = 0x20 - result2;\n  }\n  temp1 = temp1 << (result2 & 0xff);\n  if (bool1 || bool2 != bool3) {\n    temp1 = temp1 | result1 >> (temp4 & 0xff);\n  }\n  if (bool1 || bool2 != bool3) {\n    result1 = result1 << (result2 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)temp3 <= count) {\n    return CONCAT44(temp1 + (count - temp3) * 0x100000,result1);\n  }\n  temp4 = ~(count - temp3);\n  if (0x1e < (int)temp4) {\n    return (ulonglong)(temp1 >> (temp4 - 0x1f & 0xff));\n  }\n  count = temp4 - 0x13;\n  if (count == 0 || count < 0 != SCARRY4(temp4 - 0x1f,0xc)) {\n    temp4 = temp4 + 1;\n    return CONCAT44(temp1 >> (temp4 & 0xff),result1 >> (temp4 & 0xff) | temp1 << (0x20 - temp4 & 0xff)\n                   );\n  }\n  return (ulonglong)(result1 >> (0x20 - (0xcU - count) & 0xff) | temp1 << (0xcU - count & 0xff));\n}\n\n",
            "renaming": {
                "FUN_08000464": "convert_uint_to_double_08000464",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "byteValue",
                "uVar2": "result1",
                "uVar3": "result2",
                "uVar4": "temp1",
                "iVar5": "temp2",
                "uVar6": "temp3",
                "iVar7": "count",
                "uVar8": "temp4",
                "bVar9": "bool1",
                "bVar10": "bool2",
                "bVar11": "bool3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000474": {
            "entrypoint": "0x08000474",
            "current_name": "perform_binary_arithmetic_08000474",
            "code": "\nulonglong performBinaryArithmetic_08000474(uint input1,uint input2)\n\n{\n  byte carry;\n  uint input1Temp;\n  uint input2Temp;\n  uint shiftCount;\n  int leadingZeros;\n  uint temp1;\n  int temp2;\n  uint signBit;\n  uint temp3;\n  bool overflow1;\n  bool overflow2;\n  bool isNegative;\n  \n  if ((input1 | input2) == 0) {\n    return concat(input2,input1);\n  }\n  signBit = input2 & 0x80000000;\n  input2Temp = input2;\n  if ((int)signBit < 0) {\n    overflow2 = input1 != 0;\n    input1 = -input1;\n    input2Temp = -input2 - (uint)overflow2;\n  }\n  temp2 = 0x432;\n  temp3 = input2Temp >> 0x16;\n  if (temp3 != 0) {\n    temp2 = 3;\n    if (input2Temp >> 0x19 != 0) {\n      temp2 = 6;\n    }\n    if (input2Temp >> 0x1c != 0) {\n      temp2 = temp2 + 3;\n    }\n    shiftCount = temp2 - ((int)input2Temp >> 0x1f);\n    temp3 = input1 << (0x20 - shiftCount & 0xff);\n    input1 = input1 >> (shiftCount & 0xff) | input2Temp << (0x20 - shiftCount & 0xff);\n    input2Temp = input2Temp >> (shiftCount & 0xff);\n    temp2 = shiftCount + 0x432;\n  }\n  if (0xfffff < input2Temp) {\n    if (0x1fffff < input2Temp) {\n      shiftCount = input2Temp & 1;\n      input2Temp = input2Temp >> 1;\n      carry = (byte)input1;\n      input1 = (uint)(shiftCount != 0) << 0x1f | input1 >> 1;\n      temp3 = (uint)(carry & 1) << 0x1f | temp3 >> 1;\n      temp2 = temp2 + 1;\n      if (0xffbfffff < (uint)(temp2 * 0x200000)) {\n        return (ulonglong)(signBit | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_08000278:\n    overflow2 = 0x7fffffff < temp3;\n    if (temp3 == 0x80000000) {\n      overflow2 = (input1 & 1) != 0;\n    }\n    return concat(input2Temp + temp2 * 0x100000 + (uint)isCarry4(input1,(uint)overflow2) | signBit,\n                    input1 + overflow2);\n  }\n  overflow1 = (temp3 & 0x80000000) != 0;\n  temp3 = temp3 << 1;\n  shiftCount = input1 * 2;\n  overflow2 = isCarry4(input1,input1);\n  input1 = input1 * 2 + (uint)overflow1;\n  input2Temp = input2Temp * 2 + (uint)(overflow2 || isCarry4(shiftCount,(uint)overflow1));\n  temp2 = temp2 + -1;\n  if ((input2Temp & 0x100000) != 0) goto LAB_08000278;\n  input1Temp = input1;\n  shiftCount = input2Temp;\n  if (input2Temp == 0) {\n    input1Temp = 0;\n    shiftCount = input1;\n  }\n  leadingZeros = leadingZeroCount(shiftCount);\n  if (input2Temp == 0) {\n    leadingZeros = leadingZeros + 0x20;\n  }\n  temp1 = leadingZeros - 0xb;\n  isNegative = signedBorrow4(temp1,0x20);\n  input2Temp = leadingZeros - 0x2b;\n  overflow2 = (int)input2Temp < 0;\n  overflow1 = input2Temp == 0;\n  if ((int)temp1 < 0x20) {\n    isNegative = signedCarry4(input2Temp,0xc);\n    leadingZeros = leadingZeros + -0x1f;\n    overflow2 = leadingZeros < 0;\n    overflow1 = leadingZeros == 0;\n    input2Temp = temp1;\n    if (!overflow1 && overflow2 == isNegative) {\n      input1Temp = shiftCount << (temp1 & 0xff);\n      shiftCount = shiftCount >> (0xcU - leadingZeros & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (overflow1 || overflow2 != isNegative) {\n    temp3 = 0x20 - input2Temp;\n  }\n  shiftCount = shiftCount << (input2Temp & 0xff);\n  if (overflow1 || overflow2 != isNegative) {\n    shiftCount = shiftCount | input1Temp >> (temp3 & 0xff);\n  }\n  if (overflow1 || overflow2 != isNegative) {\n    input1Temp = input1Temp << (input2Temp & 0xff);\n  }\nLAB_080002f0:\n  if ((int)temp1 <= temp2) {\n    return concat(shiftCount + (temp2 - temp1) * 0x100000 | signBit,input1Temp);\n  }\n  input2Temp = ~(temp2 - temp1);\n  if (0x1e < (int)input2Temp) {\n    return concat(input2,shiftCount >> (input2Temp - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  temp2 = input2Temp - 0x13;\n  if (temp2 == 0 || temp2 < 0 != signedCarry4(input2Temp - 0x1f,0xc)) {\n    input2Temp = input2Temp + 1;\n    return concat(signBit | shiftCount >> (input2Temp & 0xff),\n                    input1Temp >> (input2Temp & 0xff) | shiftCount << (0x20 - input2Temp & 0xff));\n  }\n  return concat(input2,input1Temp >> (0x20 - (0xcU - temp2) & 0xff) | shiftCount << (0xcU - temp2 & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000474": "perform_binary_arithmetic_08000474",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "carry",
                "uVar2": "input1Temp",
                "uVar3": "input2Temp",
                "uVar4": "shiftCount",
                "iVar5": "leadingZeros",
                "uVar6": "temp1",
                "iVar7": "temp2",
                "uVar8": "signBit",
                "uVar9": "temp3",
                "bVar10": "overflow1",
                "bVar11": "overflow2",
                "bVar12": "isNegative",
                "CARRY4": "isCarry4",
                "LZCOUNT": "leadingZeroCount",
                "SCARRY4": "signedCarry4",
                "SBORROW4": "signedBorrow4",
                "CONCAT44": "concat"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004d0": {
            "entrypoint": "0x080004d0",
            "current_name": "combine_and_shift_080004d0",
            "code": "\nulonglong combineAndShift_080004d0(undefined4 input1,uint input2,uint input3,uint input4)\n\n{\n  ulonglong result1;\n  longlong result2;\n  uint shiftedResult1;\n  uint shiftedResult2;\n  int temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  ulonglong combinedInputs;\n  \n  combinedInputs = CONCAT44(input2,input1);\n  temp4 = 0x7ff;\n  shiftedResult2 = input2 >> 0x14 & 0x7ff;\n  flag1 = shiftedResult2 == 0;\n  if (!flag1) {\n    temp3 = input4 >> 0x14 & 0x7ff;\n    flag1 = temp3 == 0;\n  }\n  if (!flag1) {\n    flag1 = shiftedResult2 == 0x7ff;\n  }\n  if (!flag1) {\n    flag1 = temp3 == 0x7ff;\n  }\n  if (flag1) {\n    combinedInputs = reverse_and_combine_080006ac();\n  }\n  shiftedResult1 = (uint)(combinedInputs >> 0x20);\n  temp1 = shiftedResult2 + temp3;\n  shiftedResult2 = shiftedResult1 ^ input4;\n  shiftedResult1 = shiftedResult1 & ~(temp4 << 0x15);\n  input4 = input4 & ~(temp4 << 0x15);\n  flag1 = ((uint)combinedInputs | shiftedResult1 << 0xc) == 0;\n  if (!flag1) {\n    flag1 = (input3 | input4 << 0xc) == 0;\n  }\n  shiftedResult1 = shiftedResult1 | 0x100000;\n  input4 = input4 | 0x100000;\n  if (flag1) {\n    input3 = (uint)combinedInputs | input3;\n    input4 = (shiftedResult2 & 0x80000000 | shiftedResult1) ^ input4;\n    shiftedResult2 = temp4 >> 1;\n    flag3 = SBORROW4(temp1,shiftedResult2);\n    temp2 = temp1 - shiftedResult2;\n    flag1 = temp2 == 0;\n    shiftedResult1 = temp2;\n    if (!flag1 && (int)shiftedResult2 <= temp1) {\n      flag3 = SBORROW4(temp4,temp2);\n      shiftedResult1 = temp4 - temp2;\n      flag1 = temp4 == temp2;\n    }\n    if (!flag1 && (int)shiftedResult1 < 0 == flag3) {\n      input4 = input4 | temp2 * 0x100000;\n    }\n    if (!flag1 && (int)shiftedResult1 < 0 == flag3) {\n      return CONCAT44(input4,input3);\n    }\n    input4 = input4 | 0x100000;\n    temp4 = 0;\n    flag3 = SBORROW4(temp2,1);\n    temp2 = temp2 - 1;\n    flag1 = temp2 == 0;\n    shiftedResult2 = temp2;\n  }\n  else {\n    result1 = (combinedInputs & 0xffffffff) * (ulonglong)input3;\n    combinedInputs = (combinedInputs & 0xffffffff) * (ulonglong)input4 +\n             (ulonglong)shiftedResult1 * (ulonglong)input3 + (result1 >> 0x20);\n    temp5 = (uint)combinedInputs;\n    result2 = (ulonglong)shiftedResult1 * (ulonglong)input4 + (combinedInputs >> 0x20);\n    temp4 = (uint)result2;\n    shiftedResult1 = (uint)((ulonglong)result2 >> 0x20);\n    if ((int)result1 != 0) {\n      temp5 = temp5 | 1;\n    }\n    temp2 = (temp1 + -0x3ff) - (uint)(shiftedResult1 < 0x200);\n    if (shiftedResult1 < 0x200) {\n      flag1 = (temp5 & 0x80000000) != 0;\n      temp5 = temp5 << 1;\n      result2 = CONCAT44(shiftedResult1 * 2 + (uint)(CARRY4(temp4,temp4) || CARRY4(temp4 * 2,(uint)flag1)),\n                       temp4 * 2 + (uint)flag1);\n    }\n    input4 = shiftedResult2 & 0x80000000 | (int)((ulonglong)result2 >> 0x20) << 0xb | (uint)result2 >> 0x15;\n    input3 = (uint)result2 << 0xb | temp5 >> 0x15;\n    temp4 = temp5 * 0x800;\n    flag2 = 0xfc < temp2;\n    flag3 = SBORROW4(temp2,0xfd);\n    shiftedResult1 = temp2 - 0xfd;\n    flag1 = shiftedResult1 == 0;\n    shiftedResult2 = shiftedResult1;\n    if (flag2 && !flag1) {\n      flag2 = 0x6ff < shiftedResult1;\n      flag3 = SBORROW4(shiftedResult1,0x700);\n      shiftedResult2 = temp2 - 0x7fd;\n      flag1 = shiftedResult1 == 0x700;\n    }\n    if (!flag2 || flag1) {\n      flag1 = 0x7fffffff < temp4;\n      if (temp4 == 0x80000000) {\n        flag1 = (temp5 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(input4 + temp2 * 0x100000 + (uint)CARRY4(input3,(uint)flag1),input3 + flag1\n                     );\n    }\n  }\n  if (!flag1 && (int)shiftedResult2 < 0 == flag3) {\n    return (ulonglong)(input4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag2 = SCARRY4(temp2,0x36);\n  flag1 = (int)(temp2 + 0x36) < 0;\n  flag3 = temp2 == 0xffffffca;\n  if (flag3 || flag1 != flag2) {\n    input3 = 0;\n  }\n  if (flag3 || flag1 != flag2) {\n    input4 = input4 & 0x80000000;\n  }\n  if (flag3 || flag1 != flag2) {\n    return CONCAT44(input4,input3);\n  }\n  shiftedResult2 = -temp2;\n  shiftedResult1 = shiftedResult2 - 0x20;\n  if (0x1f < (int)shiftedResult2) {\n    temp2 = input3 >> (shiftedResult1 & 0xff) | input4 << (0x20 - shiftedResult1 & 0xff);\n    shiftedResult2 = (input4 >> (shiftedResult1 & 0xff) & ~((input4 & 0x80000000) >> (shiftedResult1 & 0xff))) -\n            ((int)temp2 >> 0x1f);\n    if ((temp4 | input3 << (0x20 - shiftedResult1 & 0xff) | temp2 << 1) == 0) {\n      shiftedResult2 = shiftedResult2 & ~(temp2 >> 0x1f);\n    }\n    return CONCAT44(input4,shiftedResult2) & 0x80000000ffffffff;\n  }\n  temp1 = shiftedResult2 - 0x14;\n  if (temp1 == 0 || temp1 < 0 != SCARRY4(shiftedResult1,0xc)) {\n    temp5 = input3 << (temp2 + 0x20 & 0xff);\n    shiftedResult1 = input3 >> (shiftedResult2 & 0xff) | input4 << (temp2 + 0x20 & 0xff);\n    temp2 = shiftedResult1 + -((int)temp5 >> 0x1f);\n    if ((temp4 | temp5 << 1) == 0) {\n      temp2 = temp2 & ~(temp5 >> 0x1f);\n    }\n    return CONCAT44((input4 & 0x80000000) +\n                    ((input4 & 0x7fffffff) >> (shiftedResult2 & 0xff)) +\n                    (uint)CARRY4(shiftedResult1,-((int)temp5 >> 0x1f)),temp2);\n  }\n  shiftedResult2 = 0xc - temp1;\n  temp2 = input3 << (shiftedResult2 & 0xff);\n  shiftedResult2 = input3 >> (0x20 - shiftedResult2 & 0xff) | input4 << (shiftedResult2 & 0xff);\n  shiftedResult1 = shiftedResult2 + -((int)temp2 >> 0x1f);\n  if ((temp4 | temp2 << 1) == 0) {\n    shiftedResult1 = shiftedResult1 & ~(temp2 >> 0x1f);\n  }\n  return CONCAT44((input4 & 0x80000000) + (uint)CARRY4(shiftedResult2,-((int)temp2 >> 0x1f)),shiftedResult1);\n}\n\n",
            "renaming": {
                "FUN_080004d0": "combine_and_shift_080004d0",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "result1",
                "lVar2": "result2",
                "uVar3": "shiftedResult1",
                "uVar4": "shiftedResult2",
                "iVar5": "temp1",
                "uVar6": "temp2",
                "unaff_r5": "temp3",
                "uVar7": "temp4",
                "uVar8": "temp5",
                "bVar9": "flag1",
                "bVar10": "flag2",
                "bVar11": "flag3",
                "uVar12": "combinedInputs"
            },
            "calling": [
                "pow",
                "scalbn",
                "atan",
                "__ieee754_sqrt",
                "MadgwickQuaternionUpdate",
                "__ieee754_asin",
                "MS5611_Update",
                "__ieee754_pow"
            ],
            "called": [
                "FUN_080006ac"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006ac": {
            "entrypoint": "0x080006ac",
            "current_name": "reverse_and_combine_080006ac",
            "code": "\nulonglong reverse_and_combine_080006ac(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint bit1;\n  uint bit2;\n  uint bit3;\n  uint bit4;\n  uint bit5;\n  bool isZero;\n  \n  bit3 = bit5 & input4 >> 0x14;\n  if (bit2 != bit5 && bit3 != bit5) {\n    isZero = (input1 | input2 << 1) == 0;\n    if (!isZero) {\n      isZero = (input3 | input4 << 1) == 0;\n    }\n    if (isZero) {\n      return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n    }\n    if (bit2 == 0) {\n      bit4 = input2 & 0x80000000;\n      do {\n        bit1 = input1 & 0x80000000;\n        input1 = input1 << 1;\n        input2 = input2 * 2 + (uint)(bit1 != 0);\n      } while ((input2 & 0x100000) == 0);\n      input2 = input2 | bit4;\n      if (bit3 != 0) {\n        return CONCAT44(input2,input1);\n      }\n    }\n    do {\n      bit3 = input3 & 0x80000000;\n      input3 = input3 << 1;\n      input4 = input4 * 2 + (uint)(bit3 != 0);\n    } while ((input4 & 0x100000) == 0);\n    return CONCAT44(input2,input1);\n  }\n  isZero = (input1 | input2 << 1) == 0;\n  if (isZero) {\n    input2 = input4;\n    input1 = input3;\n  }\n  if (!isZero) {\n    isZero = (input3 | input4 << 1) == 0;\n  }\n  bit4 = input2;\n  if (((!isZero) && ((bit2 != bit5 || ((input1 | input2 << 0xc) == 0)))) &&\n     ((bit3 != bit5 || (input1 = input3, bit4 = input4, (input3 | input4 << 0xc) == 0)))) {\n    return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(bit4,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006ac": "reverse_and_combine_080006ac",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "bit1",
                "unaff_r4": "bit2",
                "uVar2": "bit3",
                "uVar3": "bit4",
                "in_r12": "bit5",
                "bVar4": "isZero"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000724": {
            "entrypoint": "0x08000724",
            "current_name": "calculate_floating_point_08000724",
            "code": "\nulonglong calculateFloatingPoint_08000724(undefined4 input_parameter1,uint input_parameter2,uint input_parameter3,uint input_parameter4)\n\n{\n  uint carry;\n  uint shiftAmount;\n  uint multiplication_result;\n  uint temp_variable1;\n  uint temp_variable2;\n  uint temp_variable3;\n  uint result_upper;\n  int difference;\n  uint result_lower;\n  uint unaff_r5;\n  uint mask;\n  uint result;\n  uint remainder;\n  uint check_zero;\n  bool is_zero1;\n  bool is_zero2;\n  bool is_overflow;\n  undefined8 carry7;\n  \n  carry7 = CONCAT44(input_parameter2,input_parameter1);\n  check_zero = 0x7ff;\n  result_upper = input_parameter2 >> 0x14 & 0x7ff;\n  is_zero1 = result_upper == 0;\n  if (!is_zero1) {\n    unaff_r5 = input_parameter4 >> 0x14 & 0x7ff;\n    is_zero1 = unaff_r5 == 0;\n  }\n  if (!is_zero1) {\n    is_zero1 = result_upper == 0x7ff;\n  }\n  if (!is_zero1) {\n    is_zero1 = unaff_r5 == 0x7ff;\n  }\n  if (is_zero1) {\n    carry7 = process_parameters_08000892();\n  }\n  result_lower = (uint)((ulonglong)carry7 >> 0x20);\n  result = (uint)carry7;\n  difference = result_upper - unaff_r5;\n  if ((input_parameter3 | input_parameter4 << 0xc) == 0) {\n    result_upper = (result_lower ^ input_parameter4) & 0x80000000 | result_lower & 0xfffff;\n    is_overflow = SCARRY4(difference,check_zero >> 1);\n    result_lower = difference + (check_zero >> 1);\n    is_zero1 = (int)result_lower < 0;\n    is_zero2 = result_lower == 0;\n    if (!is_zero2 && is_zero1 == is_overflow) {\n      is_overflow = SBORROW4(check_zero,result_lower);\n      is_zero1 = (int)(check_zero - result_lower) < 0;\n      is_zero2 = check_zero == result_lower;\n    }\n    if (!is_zero2 && is_zero1 == is_overflow) {\n      result_upper = result_upper | result_lower * 0x100000;\n    }\n    if (!is_zero2 && is_zero1 == is_overflow) {\n      return CONCAT44(result_upper,result);\n    }\n    result_upper = result_upper | 0x100000;\n    check_zero = 0;\n    is_zero2 = SBORROW4(result_lower,1);\n    result_lower = result_lower - 1;\n    is_zero1 = result_lower == 0;\n    multiplication_result = result_lower;\n  }\n  else {\n    multiplication_result = (input_parameter4 << 0xc) >> 4 | 0x10000000 | input_parameter3 >> 0x18;\n    check_zero = input_parameter3 << 8;\n    mask = (result_lower << 0xc) >> 4 | 0x10000000 | result >> 0x18;\n    result = result * 0x100;\n    result_upper = (result_lower ^ input_parameter4) & 0x80000000;\n    is_zero1 = multiplication_result <= mask;\n    if (mask == multiplication_result) {\n      is_zero1 = check_zero <= result;\n    }\n    difference = difference + (uint)is_zero1;\n    result_lower = difference + 0x3fd;\n    if (is_zero1 == false) {\n      multiplication_result = multiplication_result >> 1;\n      check_zero = (uint)((input_parameter3 >> 0x18 & 1) != 0) << 0x1f | check_zero >> 1;\n    }\n    remainder = result - check_zero;\n    mask = (mask - multiplication_result) - (uint)(result < check_zero);\n    temp_variable1 = multiplication_result >> 1;\n    carry = (uint)((multiplication_result & 1) != 0) << 0x1f | check_zero >> 1;\n    result = 0x100000;\n    multiplication_result = 0x80000;\n    while( true ) {\n      is_zero1 = carry <= remainder;\n      if (temp_variable1 < mask || mask - temp_variable1 < (uint)is_zero1) {\n        remainder = remainder - carry;\n        result = result | multiplication_result;\n        mask = (mask - temp_variable1) - (uint)!is_zero1;\n      }\n      temp_variable2 = temp_variable1 >> 1;\n      carry = (uint)((temp_variable1 & 1) != 0) << 0x1f | carry >> 1;\n      is_zero2 = carry <= remainder;\n      is_zero1 = mask - temp_variable2 < (uint)is_zero2;\n      check_zero = mask;\n      if (temp_variable2 < mask || is_zero1) {\n        remainder = remainder - carry;\n        check_zero = (mask - temp_variable2) - (uint)!is_zero2;\n      }\n      if (temp_variable2 < mask || is_zero1) {\n        result = result | multiplication_result >> 1;\n      }\n      mask = temp_variable1 >> 2;\n      shiftAmount = (uint)((temp_variable2 & 1) != 0) << 0x1f | carry >> 1;\n      is_zero2 = shiftAmount <= remainder;\n      is_zero1 = check_zero - mask < (uint)is_zero2;\n      temp_variable2 = check_zero;\n      if (mask < check_zero || is_zero1) {\n        remainder = remainder - shiftAmount;\n        temp_variable2 = (check_zero - mask) - (uint)!is_zero2;\n      }\n      if (mask < check_zero || is_zero1) {\n        result = result | multiplication_result >> 2;\n      }\n      temp_variable3 = temp_variable1 >> 3;\n      carry = (uint)((mask & 1) != 0) << 0x1f | shiftAmount >> 1;\n      is_zero2 = carry <= remainder;\n      is_zero1 = temp_variable2 - temp_variable3 < (uint)is_zero2;\n      mask = temp_variable2;\n      if (temp_variable3 < temp_variable2 || is_zero1) {\n        remainder = remainder - carry;\n        mask = (temp_variable2 - temp_variable3) - (uint)!is_zero2;\n      }\n      if (temp_variable3 < temp_variable2 || is_zero1) {\n        result = result | multiplication_result >> 3;\n      }\n      check_zero = mask | remainder;\n      if (check_zero == 0) break;\n      mask = mask << 4 | remainder >> 0x1c;\n      remainder = remainder << 4;\n      temp_variable1 = temp_variable1 & 0xfffffff8 | carry >> 0x1d;\n      carry = (shiftAmount >> 1) << 3;\n      multiplication_result = multiplication_result >> 4;\n      if (multiplication_result == 0) {\n        temp_variable3 = temp_variable1;\n        if ((result_upper & 0x100000) != 0) goto LAB_08000842;\n        result_upper = result_upper | result;\n        result = 0;\n        multiplication_result = 0x80000000;\n      }\n    }\n    if ((result_upper & 0x100000) == 0) {\n      result_upper = result_upper | result;\n      result = 0;\n    }\nLAB_08000842:\n    is_overflow = 0xfc < result_lower;\n    is_zero2 = SBORROW4(result_lower,0xfd);\n    temp_variable1 = difference + 0x300;\n    is_zero1 = temp_variable1 == 0;\n    multiplication_result = temp_variable1;\n    if (is_overflow && !is_zero1) {\n      is_overflow = 0x6ff < temp_variable1;\n      is_zero2 = SBORROW4(temp_variable1,0x700);\n      multiplication_result = difference - 0x400;\n      is_zero1 = temp_variable1 == 0x700;\n    }\n    if (!is_overflow || is_zero1) {\n      is_zero1 = temp_variable3 <= mask;\n      if (mask == temp_variable3) {\n        is_zero1 = carry <= remainder;\n      }\n      if (mask == temp_variable3 && remainder == carry) {\n        is_zero1 = (result & 1) != 0;\n      }\n      return CONCAT44(result_upper + result_lower * 0x100000 + (uint)CARRY4(result,(uint)is_zero1),result + is_zero1);\n    }\n  }\n  if (!is_zero1 && (int)multiplication_result < 0 == is_zero2) {\n    return (ulonglong)(result_upper & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  is_overflow = SCARRY4(result_lower,0x36);\n  is_zero1 = (int)(result_lower + 0x36) < 0;\n  is_zero2 = result_lower == 0xffffffca;\n  if (is_zero2 || is_zero1 != is_overflow) {\n    result = 0;\n  }\n  if (is_zero2 || is_zero1 != is_overflow) {\n    result_upper = result_upper & 0x80000000;\n  }\n  if (is_zero2 || is_zero1 != is_overflow) {\n    return CONCAT44(result_upper,result);\n  }\n  multiplication_result = -result_lower;\n  mask = multiplication_result - 0x20;\n  if (0x1f < (int)multiplication_result) {\n    multiplication_result = result >> (mask & 0xff) | result_upper << (0x20 - mask & 0xff);\n    result_lower = (result_upper >> (mask & 0xff) & ~((result_upper & 0x80000000) >> (mask & 0xff))) -\n            ((int)multiplication_result >> 0x1f);\n    if ((check_zero | result << (0x20 - mask & 0xff) | multiplication_result << 1) == 0) {\n      result_lower = result_lower & ~(multiplication_result >> 0x1f);\n    }\n    return CONCAT44(result_upper,result_lower) & 0x80000000ffffffff;\n  }\n  difference = multiplication_result - 0x14;\n  if (difference != 0 && difference < 0 == SCARRY4(mask,0xc)) {\n    result_lower = 0xc - difference;\n    multiplication_result = result << (result_lower & 0xff);\n    result = result >> (0x20 - result_lower & 0xff) | result_upper << (result_lower & 0xff);\n    result_lower = result + -((int)multiplication_result >> 0x1f);\n    if ((check_zero | multiplication_result << 1) == 0) {\n      result_lower = result_lower & ~(multiplication_result >> 0x1f);\n    }\n    return CONCAT44((result_upper & 0x80000000) + (uint)CARRY4(result,-((int)multiplication_result >> 0x1f)),result_lower);\n  }\n  mask = result << (result_lower + 0x20 & 0xff);\n  result = result >> (multiplication_result & 0xff) | result_upper << (result_lower + 0x20 & 0xff);\n  result_lower = result + -((int)mask >> 0x1f);\n  if ((check_zero | mask << 1) == 0) {\n    result_lower = result_lower & ~(mask >> 0x1f);\n  }\n  return CONCAT44((result_upper & 0x80000000) +\n                  ((result_upper & 0x7fffffff) >> (multiplication_result & 0xff)) +\n                  (uint)CARRY4(result,-((int)mask >> 0x1f)),result_lower);\n}\n\n",
            "renaming": {
                "FUN_08000724": "calculate_floating_point_08000724",
                "param_1": "input_parameter1",
                "param_2": "input_parameter2",
                "param_3": "input_parameter3",
                "param_4": "input_parameter4",
                "uVar1": "carry",
                "uVar2": "shiftAmount",
                "uVar3": "multiplication_result",
                "uVar4": "temp_variable1",
                "uVar5": "temp_variable2",
                "uVar6": "temp_variable3",
                "uVar7": "result_upper",
                "iVar8": "difference",
                "uVar9": "result_lower",
                "uVar10": "mask",
                "uVar11": "result",
                "uVar12": "remainder",
                "uVar13": "check_zero",
                "bVar14": "is_zero1",
                "bVar15": "is_zero2",
                "bVar16": "is_overflow"
            },
            "calling": [
                "pow",
                "__ieee754_atan2",
                "atan",
                "__ieee754_sqrt",
                "MadgwickQuaternionUpdate",
                "__ieee754_asin",
                "sqrt",
                "__ieee754_pow"
            ],
            "called": [
                "FUN_08000892"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000892": {
            "entrypoint": "0x08000892",
            "current_name": "process_parameters_08000892",
            "code": "\nulonglong processParameters_08000892(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint bit1;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint constant;\n  bool isZero;\n  \n  temp2 = constant & input4 >> 0x14;\n  temp3 = input2;\n  if (temp1 != constant || temp2 != constant) {\n    if (temp1 == constant) {\n      if (((input1 | input2 << 0xc) == 0) && (input1 = input3, temp3 = input4, temp2 != constant)\n         ) {\nLAB_08000704:\n        return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (temp2 == constant) {\n      input1 = input3;\n      temp3 = input4;\n      if ((input3 | input4 << 0xc) == 0) {\nLAB_080006c8:\n        return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      isZero = (input1 | input2 << 1) == 0;\n      if (!isZero) {\n        isZero = (input3 | input4 << 1) == 0;\n      }\n      if (!isZero) {\n        if (temp1 == 0) {\n          temp3 = input2 & 0x80000000;\n          do {\n            bit1 = input1 & 0x80000000;\n            input1 = input1 << 1;\n            input2 = input2 * 2 + (uint)(bit1 != 0);\n          } while ((input2 & 0x100000) == 0);\n          input2 = input2 | temp3;\n          if (temp2 != 0) {\n            return CONCAT44(input2,input1);\n          }\n        }\n        do {\n          temp3 = input3 & 0x80000000;\n          input3 = input3 << 1;\n          input4 = input4 * 2 + (uint)(temp3 != 0);\n        } while ((input4 & 0x100000) == 0);\n        return CONCAT44(input2,input1);\n      }\n      if ((input1 | input2 << 1) != 0) goto LAB_08000704;\n      if ((input3 | input4 << 1) != 0) goto LAB_080006c8;\n    }\n  }\n  return CONCAT44(temp3,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_08000892": "process_parameters_08000892",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "bit1",
                "unaff_r4": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "in_r12": "constant",
                "bVar4": "isZero"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008f4": {
            "entrypoint": "0x080008f4",
            "current_name": "check_params_080008f4",
            "code": "\nuint check_params_080008f4(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint result;\n  bool isZero;\n  bool isNegative;\n  \n  if (((int)(input_2 << 1) >> 0x15 == -1 || (int)(input_4 << 1) >> 0x15 == -1) &&\n     ((((int)(input_2 << 1) >> 0x15 == -1 && ((input_1 | input_2 << 0xc) != 0)) ||\n      (((int)(input_4 << 1) >> 0x15 == -1 && ((input_3 | input_4 << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  isZero = (input_1 | input_2 << 1) == 0;\n  if (isZero) {\n    isZero = (input_3 | input_4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = input_2 == input_4;\n  }\n  if (isZero) {\n    isZero = input_1 == input_3;\n  }\n  if (!isZero) {\n    result = input_2 ^ input_4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = input_2 == input_4;\n    }\n    isNegative = -1 < (int)result && input_4 <= input_2;\n    if (isZero) {\n      isNegative = input_3 <= input_1;\n    }\n    input_4 = (int)input_4 >> 0x1f;\n    if (!isNegative) {\n      input_4 = ~input_4;\n    }\n    return input_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008f4": "check_params_080008f4",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isNegative"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008fc": {
            "entrypoint": "0x080008fc",
            "current_name": "check_parameters_080008fc",
            "code": "\nuint check_parameters_080008fc(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint result;\n  bool check1;\n  bool check2;\n  \n  if (((int)(input_2 << 1) >> 0x15 == -1 || (int)(input_4 << 1) >> 0x15 == -1) &&\n     ((((int)(input_2 << 1) >> 0x15 == -1 && ((input_1 | input_2 << 0xc) != 0)) ||\n      (((int)(input_4 << 1) >> 0x15 == -1 && ((input_3 | input_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  check1 = (input_1 | input_2 << 1) == 0;\n  if (check1) {\n    check1 = (input_3 | input_4 << 1) == 0;\n  }\n  if (!check1) {\n    check1 = input_2 == input_4;\n  }\n  if (check1) {\n    check1 = input_1 == input_3;\n  }\n  if (!check1) {\n    result = input_2 ^ input_4;\n    check1 = result == 0;\n    if (-1 < (int)result) {\n      check1 = input_2 == input_4;\n    }\n    check2 = -1 < (int)result && input_4 <= input_2;\n    if (check1) {\n      check2 = input_3 <= input_1;\n    }\n    input_4 = (int)input_4 >> 0x1f;\n    if (!check2) {\n      input_4 = ~input_4;\n    }\n    return input_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008fc": "check_parameters_080008fc",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "result",
                "bVar2": "check1",
                "bVar3": "check2"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000904": {
            "entrypoint": "0x08000904",
            "current_name": "check_parameters_08000904",
            "code": "\nuint check_parameters_08000904(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint result;\n  bool isZero;\n  bool isLess;\n  \n  if (((int)(input_2 << 1) >> 0x15 == -1 || (int)(input_4 << 1) >> 0x15 == -1) &&\n     ((((int)(input_2 << 1) >> 0x15 == -1 && ((input_1 | input_2 << 0xc) != 0)) ||\n      (((int)(input_4 << 1) >> 0x15 == -1 && ((input_3 | input_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (input_1 | input_2 << 1) == 0;\n  if (isZero) {\n    isZero = (input_3 | input_4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = input_2 == input_4;\n  }\n  if (isZero) {\n    isZero = input_1 == input_3;\n  }\n  if (!isZero) {\n    result = input_2 ^ input_4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = input_2 == input_4;\n    }\n    isLess = -1 < (int)result && input_4 <= input_2;\n    if (isZero) {\n      isLess = input_3 <= input_1;\n    }\n    input_4 = (int)input_4 >> 0x1f;\n    if (!isLess) {\n      input_4 = ~input_4;\n    }\n    return input_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08000904": "check_parameters_08000904",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isLess"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000980": {
            "entrypoint": "0x08000980",
            "current_name": "compare_floating_point_values_08000980",
            "code": "\nvoid compareFloatingPointValues_08000980(undefined4 result,undefined4 firstComparisonValue,undefined4 secondComparisonValue,undefined4 thirdComparisonValue)\n\n{\n  __aeabi_cdcmpeq(secondComparisonValue,thirdComparisonValue,result,firstComparisonValue);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000980": "compare_floating_point_values_08000980",
                "param_1": "result",
                "param_2": "firstComparisonValue",
                "param_3": "secondComparisonValue",
                "param_4": "thirdComparisonValue"
            },
            "calling": [
                "__aeabi_dcmpge",
                "__aeabi_dcmpgt"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000990": {
            "entrypoint": "0x08000990",
            "current_name": "calculate_nedf2_08000990",
            "code": "\nundefined4 calculate_nedf2_08000990(undefined4 input_param)\n\n{\n  perform_nedf2();\n  return input_param;\n}\n\n",
            "renaming": {
                "FUN_08000990": "calculate_nedf2_08000990",
                "param_1": "input_param",
                "__nedf2": "perform_nedf2"
            },
            "calling": [
                "__aeabi_dcmpeq",
                "__aeabi_cdrcmple",
                "__aeabi_dcmplt",
                "__aeabi_dcmple"
            ],
            "called": [
                "__nedf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009a0": {
            "entrypoint": "0x080009a0",
            "current_name": "is_not_zero_080009a0",
            "code": "\nbool is_not_zero_080009a0(void)\n\n{\n  char result;\n  \n  __aeabi_cdcmpeq();\n  return result != '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009a0": "is_not_zero_080009a0",
                "in_ZR": "result"
            },
            "calling": [
                "pow"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009b4": {
            "entrypoint": "0x080009b4",
            "current_name": "check_if_equal_to_zero_080009b4",
            "code": "\nbool check_if_equal_to_zero_080009b4(void)\n\n{\n  char input_character;\n  \n  __aeabi_cdcmpeq();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009b4": "check_if_equal_to_zero_080009b4",
                "in_CY": "input_character"
            },
            "calling": [
                "pow",
                "sqrt"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c8": {
            "entrypoint": "0x080009c8",
            "current_name": "compare_floats_080009c8",
            "code": "\nbool compareFloats_080009c8(void)\n\n{\n  undefined isZeroResult;\n  undefined isCarrySet;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)isCarrySet || (bool)isZeroResult;\n}\n\n",
            "renaming": {
                "FUN_080009c8": "compare_floats_080009c8",
                "in_ZR": "isZeroResult",
                "in_CY": "isCarrySet"
            },
            "calling": [
                "__ieee754_pow"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009dc": {
            "entrypoint": "0x080009dc",
            "current_name": "is_less_or_equal_080009dc",
            "code": "\nbool is_less_or_equal_080009dc(void)\n\n{\n  undefined zero_result;\n  undefined carry_out;\n  \n  __aeabi_cdrcmple();\n  return !(bool)carry_out || (bool)zero_result;\n}\n\n",
            "renaming": {
                "FUN_080009dc": "is_less_or_equal_080009dc",
                "in_ZR": "zero_result",
                "in_CY": "carry_out"
            },
            "calling": [],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009f0": {
            "entrypoint": "0x080009f0",
            "current_name": "is_null_terminated_080009f0",
            "code": "\nbool is_null_terminated_080009f0(void)\n\n{\n  char input_character;\n  \n  __aeabi_cdrcmple();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009f0": "is_null_terminated_080009f0",
                "in_CY": "input_character"
            },
            "calling": [
                "atan",
                "__ieee754_asin",
                "__ieee754_pow",
                "asin"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a04": {
            "entrypoint": "0x08000a04",
            "current_name": "check_parameters_08000a04",
            "code": "\nundefined4 check_parameters_08000a04(uint input_value_1,int input_value_2,uint input_value_3,int input_value_4)\n\n{\n  if ((((input_value_2 << 1) >> 0x15 != -1) || ((input_value_1 | input_value_2 << 0xc) == 0)) &&\n     (((input_value_4 << 1) >> 0x15 != -1 || ((input_value_3 | input_value_4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08000a04": "check_parameters_08000a04",
                "param_1": "input_value_1",
                "param_2": "input_value_2",
                "param_3": "input_value_3",
                "param_4": "input_value_4"
            },
            "calling": [
                "pow",
                "sqrt",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a30": {
            "entrypoint": "0x08000a30",
            "current_name": "calculate_float_bits_08000a30",
            "code": "\nuint calculateFloatBits_08000a30(uint floatValue,uint floatBits)\n\n{\n  uint result;\n  uint floatBitsMultipliedBy2;\n  uint floatBitsOffset;\n  uint floatBitsOffsetComparison;\n  bool isZero;\n  bool isLessThanMaxBits;\n  \n  floatBitsMultipliedBy2 = floatBits * 2;\n  isLessThanMaxBits = floatBitsMultipliedBy2 < 0x70000000;\n  floatBitsOffset = floatBitsMultipliedBy2 + 0x90000000;\n  result = floatBitsOffset;\n  if (!isLessThanMaxBits) {\n    floatBitsOffsetComparison = floatBitsMultipliedBy2 + 0x8fe00000;\n    result = floatBitsOffsetComparison;\n  }\n  isZero = result == 0;\n  if (!isLessThanMaxBits && floatBitsOffset >= 0x200000) {\n    isZero = floatBitsOffsetComparison == 0x1fc00000;\n  }\n  if (((isLessThanMaxBits || floatBitsOffset < 0x200000) || 0x1fc00000 < floatBitsOffsetComparison) || isZero) {\n    if ((floatBits & 0x40000000) != 0) {\n      if (((int)floatBitsMultipliedBy2 >> 0x15 == -1) && ((floatValue | floatBits << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return floatBits & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(floatBitsMultipliedBy2 + 0x92e00000) < 0 != isSubtractionCarry(floatBitsOffset,0x2e00000)) {\n      return floatBits & 0x80000000;\n    }\n    floatBitsMultipliedBy2 = 0x18 - (floatBitsMultipliedBy2 + 0x92e00000 >> 0x15);\n    result = floatValue >> (floatBitsMultipliedBy2 & 0xff);\n    if (floatValue << (0x20 - floatBitsMultipliedBy2 & 0xff) != 0) {\n      result = result | 1;\n    }\n    floatBitsOffset = floatBits & 0x1fffff | 0x100000;\n    floatValue = result | floatBitsOffset << (0x20 - floatBitsMultipliedBy2 & 0xff);\n    floatBitsOffset = (floatBitsOffset >> (floatBitsMultipliedBy2 & 0xff)) << 1;\n  }\n  result = (floatBits & 0x80000000 | floatValue >> 0x1d) + floatBitsOffset * 4 + (uint)(0x7fffffff < floatValue * 8);\n  if (floatValue * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08000a30": "calculate_float_bits_08000a30",
                "param_1": "floatValue",
                "param_2": "floatBits",
                "uVar1": "result",
                "uVar2": "floatBitsMultipliedBy2",
                "uVar3": "floatBitsOffset",
                "in_r12": "floatBitsOffsetComparison",
                "bVar4": "isZero",
                "bVar5": "isLessThanMaxBits",
                "SCARRY4": "isSubtractionCarry"
            },
            "calling": [
                "MadgwickQuaternionUpdate",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ad0": {
            "entrypoint": "0x08000ad0",
            "current_name": "apply_negative_bitwise_xor_08000ad0",
            "code": "\nvoid applyNegativeBitwiseXor_08000ad0(uint data)\n\n{\n  adjustFloat(data ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ad0": "apply_negative_bitwise_xor_08000ad0",
                "param_1": "data",
                "__addsf3": "adjustFloat"
            },
            "calling": [],
            "called": [
                "__addsf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ad8": {
            "entrypoint": "0x08000ad8",
            "current_name": "reverse_bits_08000ad8",
            "code": "\nuint reverseBits_08000ad8(uint input,uint bitsToReverse,undefined4 param_3,uint param_4)\n\n{\n  int shiftedInput;\n  int shiftedInput2;\n  uint inputInverse;\n  uint result;\n  uint inputShifted;\n  uint shiftCount;\n  uint difference;\n  bool isFlagSet;\n  \n  inputInverse = bitsToReverse ^ 0x80000000;\n  inputShifted = input << 1;\n  isFlagSet = inputShifted == 0;\n  if (!isFlagSet) {\n    param_4 = bitsToReverse << 1;\n    isFlagSet = param_4 == 0;\n  }\n  if (!isFlagSet) {\n    isFlagSet = inputShifted == param_4;\n  }\n  shiftedInput = (int)inputShifted >> 0x18;\n  if (!isFlagSet) {\n    isFlagSet = shiftedInput == -1;\n  }\n  if (!isFlagSet) {\n    isFlagSet = (int)param_4 >> 0x18 == -1;\n  }\n  if (isFlagSet) {\n    shiftedInput2 = (int)(bitsToReverse << 1) >> 0x18;\n    if (shiftedInput == -1 || shiftedInput2 == -1) {\n      inputShifted = inputInverse;\n      if (shiftedInput == -1) {\n        inputShifted = input;\n      }\n      if (shiftedInput != -1 || shiftedInput2 != -1) {\n        inputInverse = inputShifted;\n      }\n      isFlagSet = (inputShifted & 0x7fffff) == 0;\n      if (isFlagSet) {\n        isFlagSet = (inputInverse & 0x7fffff) == 0;\n      }\n      if (isFlagSet) {\n        isFlagSet = inputShifted == inputInverse;\n      }\n      if (!isFlagSet) {\n        inputShifted = inputShifted | 0x400000;\n      }\n      return inputShifted;\n    }\n    if (((input ^ inputInverse) & 0x7fffffff) != 0) {\n      if (inputShifted == 0) {\n        input = inputInverse;\n      }\n      return input;\n    }\n    if (input != inputInverse) {\n      return 0;\n    }\n    if ((inputShifted & 0xff000000) == 0) {\n      inputInverse = input << 1;\n      if ((input & 0x80000000) != 0) {\n        inputInverse = inputInverse | 0x80000000;\n      }\n      return inputInverse;\n    }\n    if (inputShifted < 0xfe000000) {\n      return input + 0x800000;\n    }\n    input = input & 0x80000000;\nLAB_08000c12:\n    return input | 0x7f800000;\n  }\n  inputShifted = inputShifted >> 0x18;\n  param_4 = param_4 >> 0x18;\n  difference = param_4 - inputShifted;\n  isFlagSet = difference != 0;\n  shiftCount = inputShifted;\n  if (isFlagSet && inputShifted <= param_4) {\n    shiftCount = inputShifted + difference;\n  }\n  if (isFlagSet && inputShifted <= param_4) {\n    inputInverse = inputInverse ^ input;\n  }\n  if (isFlagSet && inputShifted <= param_4) {\n    input = input ^ inputInverse;\n  }\n  if (isFlagSet && inputShifted <= param_4) {\n    inputInverse = inputInverse ^ input;\n  }\n  if (param_4 < inputShifted) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return input;\n  }\n  inputShifted = input & 0xffffff | 0x800000;\n  if ((input & 0x80000000) != 0) {\n    inputShifted = -inputShifted;\n  }\n  result = inputInverse & 0xffffff | 0x800000;\n  if ((inputInverse & 0x80000000) != 0) {\n    result = -result;\n  }\n  if (shiftCount == difference) {\n    result = result ^ 0x800000;\n    if (shiftCount == 0) {\n      inputShifted = inputShifted ^ 0x800000;\n      shiftCount = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  inputShifted = inputShifted + ((int)result >> (difference & 0xff));\n  result = result << (0x20 - difference & 0xff);\n  input = inputShifted & 0x80000000;\n  if ((int)inputShifted < 0) {\n    isFlagSet = result != 0;\n    result = -result;\n    inputShifted = -inputShifted - (uint)isFlagSet;\n  }\n  if (inputShifted < 0x800000) {\n    inputInverse = result & 0x80000000;\n    result = result << 1;\n    inputShifted = inputShifted * 2 + (uint)(inputInverse != 0);\n    inputInverse = shiftCount - 2;\n    if ((inputShifted & 0x800000) == 0) {\n      difference = LZCOUNT(inputShifted) - 8;\n      inputShifted = inputShifted << (difference & 0xff);\n      if ((int)inputInverse < (int)difference) {\n        inputShifted = inputShifted >> (-(inputInverse - difference) & 0xff);\n      }\n      else {\n        inputShifted = inputShifted + (inputInverse - difference) * 0x800000;\n      }\n      return inputShifted | input;\n    }\n  }\n  else {\n    inputInverse = shiftCount - 1;\n    if (0xffffff < inputShifted) {\n      inputInverse = inputShifted & 1;\n      inputShifted = inputShifted >> 1;\n      result = (uint)(inputInverse != 0) << 0x1f | result >> 1;\n      inputInverse = shiftCount;\n      if (0xfd < shiftCount) goto LAB_08000c12;\n    }\n  }\n  inputShifted = inputShifted + inputInverse * 0x800000 + (uint)(0x7fffffff < result);\n  if (result == 0x80000000) {\n    inputShifted = inputShifted & 0xfffffffe;\n  }\n  return inputShifted | input;\n}\n\n",
            "renaming": {
                "FUN_08000ad8": "reverse_bits_08000ad8",
                "param_1": "input",
                "param_2": "bitsToReverse",
                "iVar1": "shiftedInput",
                "iVar2": "shiftedInput2",
                "uVar3": "inputInverse",
                "uVar4": "result",
                "uVar5": "inputShifted",
                "uVar6": "shiftCount",
                "uVar7": "difference",
                "bVar8": "isFlagSet"
            },
            "calling": [
                "PID_Compute",
                "lowPassFilter",
                "Motor_DistributeSpeed",
                "AK8963_ReadData",
                "MadgwickQuaternionUpdate",
                "MPU9250_ReadGyroData",
                "AHRS_GetYaw"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000adc": {
            "entrypoint": "0x08000adc",
            "current_name": "calculate_float_08000adc",
            "code": "\nuint calculateFloat_08000adc(uint num1,uint num2,undefined4 value1,uint value2)\n\n{\n  int shiftedNum1;\n  int shiftedNum2;\n  uint result1;\n  uint result2;\n  uint result3;\n  uint difference;\n  bool isConditionTrue;\n  \n  result2 = num1 << 1;\n  isConditionTrue = result2 == 0;\n  if (!isConditionTrue) {\n    value2 = num2 << 1;\n    isConditionTrue = value2 == 0;\n  }\n  if (!isConditionTrue) {\n    isConditionTrue = result2 == value2;\n  }\n  shiftedNum1 = (int)result2 >> 0x18;\n  if (!isConditionTrue) {\n    isConditionTrue = shiftedNum1 == -1;\n  }\n  if (!isConditionTrue) {\n    isConditionTrue = (int)value2 >> 0x18 == -1;\n  }\n  if (isConditionTrue) {\n    shiftedNum2 = (int)(num2 << 1) >> 0x18;\n    if (shiftedNum1 == -1 || shiftedNum2 == -1) {\n      result2 = num2;\n      if (shiftedNum1 == -1) {\n        result2 = num1;\n      }\n      if (shiftedNum1 != -1 || shiftedNum2 != -1) {\n        num2 = result2;\n      }\n      isConditionTrue = (result2 & 0x7fffff) == 0;\n      if (isConditionTrue) {\n        isConditionTrue = (num2 & 0x7fffff) == 0;\n      }\n      if (isConditionTrue) {\n        isConditionTrue = result2 == num2;\n      }\n      if (!isConditionTrue) {\n        result2 = result2 | 0x400000;\n      }\n      return result2;\n    }\n    if (((num1 ^ num2) & 0x7fffffff) != 0) {\n      if (result2 == 0) {\n        num1 = num2;\n      }\n      return num1;\n    }\n    if (num1 != num2) {\n      return 0;\n    }\n    if ((result2 & 0xff000000) == 0) {\n      result2 = num1 << 1;\n      if ((num1 & 0x80000000) != 0) {\n        result2 = result2 | 0x80000000;\n      }\n      return result2;\n    }\n    if (result2 < 0xfe000000) {\n      return num1 + 0x800000;\n    }\n    num1 = num1 & 0x80000000;\nLAB_08000c12:\n    return num1 | 0x7f800000;\n  }\n  result2 = result2 >> 0x18;\n  value2 = value2 >> 0x18;\n  difference = value2 - result2;\n  isConditionTrue = difference != 0;\n  result3 = result2;\n  if (isConditionTrue && result2 <= value2) {\n    result3 = result2 + difference;\n  }\n  if (isConditionTrue && result2 <= value2) {\n    num2 = num2 ^ num1;\n  }\n  if (isConditionTrue && result2 <= value2) {\n    num1 = num1 ^ num2;\n  }\n  if (isConditionTrue && result2 <= value2) {\n    num2 = num2 ^ num1;\n  }\n  if (value2 < result2) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return num1;\n  }\n  result2 = num1 & 0xffffff | 0x800000;\n  if ((num1 & 0x80000000) != 0) {\n    result2 = -result2;\n  }\n  result1 = num2 & 0xffffff | 0x800000;\n  if ((num2 & 0x80000000) != 0) {\n    result1 = -result1;\n  }\n  if (result3 == difference) {\n    result1 = result1 ^ 0x800000;\n    if (result3 == 0) {\n      result2 = result2 ^ 0x800000;\n      result3 = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  result2 = result2 + ((int)result1 >> (difference & 0xff));\n  result1 = result1 << (0x20 - difference & 0xff);\n  num1 = result2 & 0x80000000;\n  if ((int)result2 < 0) {\n    isConditionTrue = result1 != 0;\n    result1 = -result1;\n    result2 = -result2 - (uint)isConditionTrue;\n  }\n  if (result2 < 0x800000) {\n    difference = result1 & 0x80000000;\n    result1 = result1 << 1;\n    result2 = result2 * 2 + (uint)(difference != 0);\n    difference = result3 - 2;\n    if ((result2 & 0x800000) == 0) {\n      result3 = LZCOUNT(result2) - 8;\n      result2 = result2 << (result3 & 0xff);\n      if ((int)difference < (int)result3) {\n        result2 = result2 >> (-(difference - result3) & 0xff);\n      }\n      else {\n        result2 = result2 + (difference - result3) * 0x800000;\n      }\n      return result2 | num1;\n    }\n  }\n  else {\n    difference = result3 - 1;\n    if (0xffffff < result2) {\n      difference = result2 & 1;\n      result2 = result2 >> 1;\n      result1 = (uint)(difference != 0) << 0x1f | result1 >> 1;\n      difference = result3;\n      if (0xfd < result3) goto LAB_08000c12;\n    }\n  }\n  result2 = result2 + difference * 0x800000 + (uint)(0x7fffffff < result1);\n  if (result1 == 0x80000000) {\n    result2 = result2 & 0xfffffffe;\n  }\n  return result2 | num1;\n}\n\n",
            "renaming": {
                "FUN_08000adc": "calculate_float_08000adc",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "value1",
                "param_4": "value2",
                "iVar1": "shiftedNum1",
                "iVar2": "shiftedNum2",
                "uVar3": "result1",
                "uVar4": "result2",
                "uVar5": "result3",
                "uVar6": "difference",
                "bVar7": "isConditionTrue"
            },
            "calling": [
                "PID_Update",
                "PID_Compute",
                "lowPassFilter",
                "Motor_DistributeSpeed",
                "AK8963_Init",
                "MadgwickQuaternionUpdate",
                "__aeabi_frsub",
                "AHRS_GetYaw",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c3c": {
            "entrypoint": "0x08000c3c",
            "current_name": "calculate_unsigned_value_08000c3c",
            "code": "\nuint calculateUnsignedValue_08000c3c(uint inputValue)\n\n{\n  uint leadingZeroCount;\n  uint shiftValue;\n  int constantValue;\n  uint tempValue;\n  \n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZeroCount = LZCOUNT(inputValue);\n  shiftValue = leadingZeroCount - 8;\n  constantValue = shiftValue * -0x800000 + 0x4a800000;\n  if (7 < leadingZeroCount) {\n    tempValue = 0 << (shiftValue & 0xff);\n    leadingZeroCount = constantValue + (inputValue << (shiftValue & 0xff)) +\n            (0U >> (0x20 - shiftValue & 0xff)) + (uint)(0x7fffffff < tempValue);\n    if (tempValue == 0x80000000) {\n      leadingZeroCount = leadingZeroCount & 0xfffffffe;\n    }\n    return leadingZeroCount;\n  }\n  shiftValue = inputValue << leadingZeroCount + 0x18;\n  leadingZeroCount = constantValue + ((inputValue >> (0x20 - (leadingZeroCount + 0x18) & 0xff)) - ((int)shiftValue >> 0x1f));\n  if ((shiftValue & 0x7fffffff) == 0) {\n    leadingZeroCount = leadingZeroCount & ~(shiftValue >> 0x1f);\n  }\n  return leadingZeroCount;\n}\n\n",
            "renaming": {
                "FUN_08000c3c": "calculate_unsigned_value_08000c3c",
                "param_1": "inputValue",
                "uVar1": "leadingZeroCount",
                "uVar2": "shiftValue",
                "iVar3": "constantValue",
                "uVar4": "tempValue"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c44": {
            "entrypoint": "0x08000c44",
            "current_name": "calculate_modified_value_08000c44",
            "code": "\nuint calculateModifiedValue_08000c44(uint inputValue)\n\n{\n  uint leadingZeroes;\n  uint shiftAmount;\n  uint signBit;\n  int intermediateValue;\n  \n  signBit = inputValue & 0x80000000;\n  if ((int)signBit < 0) {\n    inputValue = -inputValue;\n  }\n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZeroes = LZCOUNT(inputValue);\n  shiftAmount = leadingZeroes - 8;\n  intermediateValue = ((signBit | 0x4b000000) - 0x800000) + shiftAmount * -0x800000;\n  if (7 < leadingZeroes) {\n    leadingZeroes = 0 << (shiftAmount & 0xff);\n    signBit = intermediateValue + (inputValue << (shiftAmount & 0xff)) +\n            (0U >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < leadingZeroes);\n    if (leadingZeroes == 0x80000000) {\n      signBit = signBit & 0xfffffffe;\n    }\n    return signBit;\n  }\n  shiftAmount = inputValue << leadingZeroes + 0x18;\n  signBit = intermediateValue + ((inputValue >> (0x20 - (leadingZeroes + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n  if ((shiftAmount & 0x7fffffff) == 0) {\n    signBit = signBit & ~(shiftAmount >> 0x1f);\n  }\n  return signBit;\n}\n\n",
            "renaming": {
                "FUN_08000c44": "calculate_modified_value_08000c44",
                "param_1": "inputValue",
                "uVar1": "leadingZeroes",
                "uVar2": "shiftAmount",
                "uVar3": "signBit",
                "iVar4": "intermediateValue"
            },
            "calling": [
                "PID_Compute",
                "AK8963_Init",
                "MPU9250_ReadAccelData",
                "AK8963_ReadData",
                "MPU9250_ReadGyroData",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c60": {
            "entrypoint": "0x08000c60",
            "current_name": "calculate_08000c60",
            "code": "\nuint calculate_08000c60(uint input1,uint input2)\n\n{\n  uint temp1;\n  uint temp2;\n  uint lzCount;\n  uint shift;\n  int constant;\n  \n  if ((input1 | input2) == 0) {\n    return input1;\n  }\n  temp1 = input1;\n  temp2 = input2;\n  if (input2 == 0) {\n    temp1 = 0;\n    temp2 = input1;\n  }\n  constant = 0x5b000000;\n  if (input2 == 0) {\n    constant = 0x4b000000;\n  }\n  lzCount = LZCOUNT(temp2);\n  shift = lzCount - 8;\n  constant = constant + -0x800000 + shift * -0x800000;\n  if (lzCount < 8) {\n    shift = temp2 << lzCount + 0x18;\n    temp2 = constant + ((temp2 >> (0x20 - (lzCount + 0x18) & 0xff)) - ((int)shift >> 0x1f));\n    if ((temp1 | shift << 1) == 0) {\n      temp2 = temp2 & ~(shift >> 0x1f);\n    }\n    return temp2;\n  }\n  lzCount = temp1 << (shift & 0xff);\n  temp2 = constant + (temp2 << (shift & 0xff)) +\n          (temp1 >> (0x20 - shift & 0xff)) + (uint)(0x7fffffff < lzCount);\n  if (lzCount == 0x80000000) {\n    temp2 = temp2 & 0xfffffffe;\n  }\n  return temp2;\n}\n\n",
            "renaming": {
                "FUN_08000c60": "calculate_08000c60",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "lzCount",
                "uVar4": "shift",
                "iVar5": "constant"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c70": {
            "entrypoint": "0x08000c70",
            "current_name": "calculate_08000c70",
            "code": "\nuint calculate_08000c70(uint input1,uint input2)\n\n{\n  uint result1;\n  uint result2;\n  uint count;\n  uint shift;\n  uint mask;\n  int offset;\n  bool isInput1NonZero;\n  \n  if ((input1 | input2) == 0) {\n    return input1;\n  }\n  mask = input2 & 0x80000000;\n  if ((int)mask < 0) {\n    isInput1NonZero = input1 != 0;\n    input1 = -input1;\n    input2 = -input2 - (uint)isInput1NonZero;\n  }\n  result2 = input1;\n  result1 = input2;\n  if (input2 == 0) {\n    result2 = 0;\n    result1 = input1;\n  }\n  mask = mask | 0x5b000000;\n  if (input2 == 0) {\n    mask = mask + 0xf0000000;\n  }\n  count = LZCOUNT(result1);\n  shift = count - 8;\n  offset = (mask - 0x800000) + shift * -0x800000;\n  if (count < 8) {\n    shift = result1 << count + 0x18;\n    mask = offset + ((result1 >> (0x20 - (count + 0x18) & 0xff)) - ((int)shift >> 0x1f));\n    if ((result2 | shift << 1) == 0) {\n      mask = mask & ~(shift >> 0x1f);\n    }\n    return mask;\n  }\n  count = result2 << (shift & 0xff);\n  mask = offset + (result1 << (shift & 0xff)) +\n          (result2 >> (0x20 - shift & 0xff)) + (uint)(0x7fffffff < count);\n  if (count == 0x80000000) {\n    mask = mask & 0xfffffffe;\n  }\n  return mask;\n}\n\n",
            "renaming": {
                "FUN_08000c70": "calculate_08000c70",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "count",
                "uVar4": "shift",
                "uVar5": "mask",
                "iVar6": "offset",
                "bVar7": "isInput1NonZero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cec": {
            "entrypoint": "0x08000cec",
            "current_name": "calculate_floating_point_08000cec",
            "code": "\nuint calculateFloatingPoint_08000cec(uint value1,uint value2,undefined4 param3,uint param4)\n\n{\n  longlong result1;\n  uint result2;\n  uint bits1;\n  int sum1;\n  int sum2;\n  uint multResult;\n  int mask1;\n  uint result3;\n  bool flag1;\n  bool flag2;\n  \n  bits1 = value1 >> 0x17 & 0xff;\n  flag1 = bits1 == 0;\n  if (!flag1) {\n    param4 = value2 >> 0x17 & 0xff;\n    flag1 = param4 == 0;\n  }\n  if (!flag1) {\n    flag1 = bits1 == 0xff;\n  }\n  if (!flag1) {\n    flag1 = param4 == 0xff;\n  }\n  if (flag1) {\n    param4 = value2 >> 0x17 & 0xff;\n    if (bits1 == 0xff || param4 == 0xff) {\n      flag1 = value1 == 0 || value1 == 0x80000000;\n      result2 = value2;\n      if (value1 != 0 && value1 != 0x80000000) {\n        flag1 = value2 == 0;\n        result2 = value1;\n      }\n      if (!flag1) {\n        flag1 = value2 == 0x80000000;\n      }\n      result3 = result2;\n      if (((flag1) || ((bits1 == 0xff && ((result2 & 0x7fffff) != 0)))) ||\n         ((param4 == 0xff && (result3 = value2, (value2 & 0x7fffff) != 0)))) {\n        return result3 | 0x7fc00000;\n      }\n      result2 = result2 ^ value2;\n      goto LAB_08000e3c;\n    }\n    flag1 = (value1 & 0x7fffffff) == 0;\n    if (!flag1) {\n      flag1 = (value2 & 0x7fffffff) == 0;\n    }\n    if (flag1) {\n      return (value1 ^ value2) & 0x80000000;\n    }\n    flag1 = bits1 == 0;\n    result2 = value1 & 0x80000000;\n    while( true ) {\n      if (flag1) {\n        value1 = value1 << 1;\n        flag1 = (value1 & 0x800000) == 0;\n      }\n      if (!flag1) break;\n      bits1 = bits1 - 1;\n    }\n    value1 = value1 | result2;\n    flag1 = param4 == 0;\n    result2 = value2 & 0x80000000;\n    while( true ) {\n      if (flag1) {\n        value2 = value2 << 1;\n        flag1 = (value2 & 0x800000) == 0;\n      }\n      if (!flag1) break;\n      param4 = param4 - 1;\n    }\n    value2 = value2 | result2;\n  }\n  sum1 = bits1 + param4;\n  result3 = value1 ^ value2;\n  bits1 = value1 << 9;\n  flag1 = bits1 == 0;\n  if (!flag1) {\n    value2 = value2 << 9;\n    flag1 = value2 == 0;\n  }\n  if (flag1) {\n    if (bits1 == 0) {\n      value2 = value2 << 9;\n    }\n    result2 = result3 & 0x80000000 | value1 & 0x7fffff | value2 >> 9;\n    flag2 = SBORROW4(sum1,0x7f);\n    sum2 = sum1 + -0x7f;\n    flag1 = sum2 == 0;\n    mask1 = sum2;\n    if (!flag1 && 0x7e < sum1) {\n      flag2 = SBORROW4(0xff,sum2);\n      mask1 = 0xff - sum2;\n      flag1 = sum2 == 0xff;\n    }\n    if (!flag1 && mask1 < 0 == flag2) {\n      result2 = result2 | sum2 * 0x800000;\n    }\n    if (!flag1 && mask1 < 0 == flag2) {\n      return result2;\n    }\n    result2 = result2 | 0x800000;\n    multResult = 0;\n    flag2 = SBORROW4(sum2,1);\n    result3 = sum1 - 0x80;\n    flag1 = result3 == 0;\n    bits1 = result3;\n  }\n  else {\n    result1 = (ulonglong)(bits1 >> 5 | 0x8000000) * (ulonglong)(value2 >> 5 | 0x8000000);\n    multResult = (uint)result1;\n    result2 = (uint)((ulonglong)result1 >> 0x20);\n    flag1 = result2 < 0x800000;\n    if (flag1) {\n      result2 = result2 << 1;\n    }\n    if (flag1) {\n      result2 = result2 | multResult >> 0x1f;\n      multResult = multResult << 1;\n    }\n    result2 = result3 & 0x80000000 | result2;\n    result3 = (sum1 + -0x7f) - (uint)flag1;\n    flag2 = SBORROW4(result3,0xfd);\n    flag1 = result3 == 0xfd;\n    bits1 = result3 - 0xfd;\n    if (result3 < 0xfe) {\n      result2 = result2 + result3 * 0x800000 + (uint)(0x7fffffff < multResult);\n      if (multResult == 0x80000000) {\n        result2 = result2 & 0xfffffffe;\n      }\n      return result2;\n    }\n  }\n  if (flag1 || (int)bits1 < 0 != flag2) {\n    flag1 = (int)(result3 + 0x19) < 0;\n    if (result3 == 0xffffffe7 || flag1 != SCARRY4(result3,0x19)) {\n      result2 = result2 & 0x80000000;\n    }\n    if (result3 != 0xffffffe7 && flag1 == SCARRY4(result3,0x19)) {\n      bits1 = (result2 << 1) >> (-result3 & 0xff);\n      result3 = result2 << (result3 + 0x20 & 0xff);\n      bits1 = ((uint)((result2 & 0x80000000) != 0) << 0x1f | bits1 >> 1) + (uint)((byte)bits1 & 1);\n      if ((multResult | result3 << 1) == 0) {\n        bits1 = bits1 & ~(result3 >> 0x1f);\n      }\n      return bits1;\n    }\n    return result2;\n  }\nLAB_08000e3c:\n  return result2 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000cec": "calculate_floating_point_08000cec",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "param3",
                "param_4": "param4",
                "lVar1": "result1",
                "uVar2": "result2",
                "uVar3": "bits1",
                "iVar4": "sum1",
                "iVar5": "sum2",
                "uVar6": "multResult",
                "iVar7": "mask1",
                "uVar8": "result3",
                "bVar9": "flag1",
                "bVar10": "flag2"
            },
            "calling": [
                "PID_Update",
                "PID_Compute",
                "lowPassFilter",
                "AK8963_Init",
                "AHRS_ComputeAngles",
                "MPU9250_ReadAccelData",
                "AK8963_ReadData",
                "MadgwickQuaternionUpdate",
                "MPU9250_ReadGyroData",
                "PID_UpdateAltitude"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e54": {
            "entrypoint": "0x08000e54",
            "current_name": "calculate_floating_point_08000e54",
            "code": "\nuint calculateFloatingPoint_08000e54(uint number1,uint number2,undefined4 flag1,uint flag2)\n\n{\n  uint bitmask1;\n  uint bitmask2;\n  int difference;\n  uint temp1;\n  int temp2;\n  uint result;\n  bool isZero;\n  bool overflow1;\n  bool overflow2;\n  \n  bitmask2 = number1 >> 0x17 & 0xff;\n  isZero = bitmask2 == 0;\n  if (!isZero) {\n    flag2 = number2 >> 0x17 & 0xff;\n    isZero = flag2 == 0;\n  }\n  if (!isZero) {\n    isZero = bitmask2 == 0xff;\n  }\n  if (!isZero) {\n    isZero = flag2 == 0xff;\n  }\n  if (isZero) {\n    flag2 = number2 >> 0x17 & 0xff;\n    result = number1;\n    if (bitmask2 == 0xff) {\n      if (((number1 & 0x7fffff) != 0) || (result = number2, flag2 == 0xff)) {\nLAB_08000e4a:\n        return result | 0x7fc00000;\n      }\n    }\n    else {\n      if (flag2 == 0xff) {\n        result = number2;\n        if ((number2 & 0x7fffff) == 0) {\nLAB_08000e00:\n          return (number1 ^ number2) & 0x80000000;\n        }\n        goto LAB_08000e4a;\n      }\n      isZero = (number1 & 0x7fffffff) == 0;\n      if (!isZero) {\n        isZero = (number2 & 0x7fffffff) == 0;\n      }\n      if (!isZero) {\n        isZero = bitmask2 == 0;\n        result = number1 & 0x80000000;\n        while( true ) {\n          if (isZero) {\n            number1 = number1 << 1;\n            isZero = (number1 & 0x800000) == 0;\n          }\n          if (!isZero) break;\n          bitmask2 = bitmask2 - 1;\n        }\n        number1 = number1 | result;\n        isZero = flag2 == 0;\n        result = number2 & 0x80000000;\n        while( true ) {\n          if (isZero) {\n            number2 = number2 << 1;\n            isZero = (number2 & 0x800000) == 0;\n          }\n          if (!isZero) break;\n          flag2 = flag2 - 1;\n        }\n        number2 = number2 | result;\n        goto LAB_08000e6c;\n      }\n      if ((number1 & 0x7fffffff) == 0) {\n        if ((number2 & 0x7fffffff) != 0) goto LAB_08000e00;\n        goto LAB_08000e4a;\n      }\n    }\n    number1 = number1 ^ number2;\n  }\n  else {\nLAB_08000e6c:\n    difference = bitmask2 - flag2;\n    if (number2 << 9 == 0) {\n      number1 = (number1 ^ number2) & 0x80000000 | number1 & 0x7fffff;\n      overflow2 = SCARRY4(difference,0x7f);\n      temp2 = difference + 0x7f;\n      isZero = temp2 < 0;\n      overflow1 = temp2 == 0;\n      if (!overflow1 && isZero == overflow2) {\n        overflow2 = SBORROW4(0xff,temp2);\n        isZero = 0xff - temp2 < 0;\n        overflow1 = temp2 == 0xff;\n      }\n      if (!overflow1 && isZero == overflow2) {\n        number1 = number1 | temp2 * 0x800000;\n      }\n      if (!overflow1 && isZero == overflow2) {\n        return number1;\n      }\n      number1 = number1 | 0x800000;\n      bitmask2 = 0;\n      overflow1 = SBORROW4(temp2,1);\n      temp1 = difference + 0x7e;\n      isZero = temp1 == 0;\n      result = temp1;\n    }\n    else {\n      bitmask1 = (number2 << 9) >> 4 | 0x10000000;\n      bitmask2 = (number1 << 9) >> 4 | 0x10000000;\n      number1 = (number1 ^ number2) & 0x80000000;\n      isZero = bitmask1 <= bitmask2;\n      if (!isZero) {\n        bitmask2 = bitmask2 << 1;\n      }\n      temp1 = difference + 0x7d + (uint)isZero;\n      result = 0x800000;\n      do {\n        if (bitmask1 <= bitmask2) {\n          bitmask2 = bitmask2 - bitmask1;\n          number1 = number1 | result;\n        }\n        isZero = bitmask1 >> 1 <= bitmask2;\n        if (isZero) {\n          bitmask2 = bitmask2 - (bitmask1 >> 1);\n        }\n        if (isZero) {\n          number1 = number1 | result >> 1;\n        }\n        isZero = bitmask1 >> 2 <= bitmask2;\n        if (isZero) {\n          bitmask2 = bitmask2 - (bitmask1 >> 2);\n        }\n        if (isZero) {\n          number1 = number1 | result >> 2;\n        }\n        isZero = bitmask1 >> 3 <= bitmask2;\n        if (isZero) {\n          bitmask2 = bitmask2 - (bitmask1 >> 3);\n        }\n        if (isZero) {\n          number1 = number1 | result >> 3;\n        }\n        bitmask2 = bitmask2 * 0x10;\n        isZero = bitmask2 == 0;\n        if (!isZero) {\n          result = result >> 4;\n          isZero = result == 0;\n        }\n      } while (!isZero);\n      overflow1 = SBORROW4(temp1,0xfd);\n      isZero = temp1 == 0xfd;\n      result = temp1 - 0xfd;\n      if (temp1 < 0xfe) {\n        number1 = number1 + temp1 * 0x800000 + (uint)(bitmask1 <= bitmask2);\n        if (bitmask2 - bitmask1 == 0) {\n          number1 = number1 & 0xfffffffe;\n        }\n        return number1;\n      }\n    }\n    if (isZero || (int)result < 0 != overflow1) {\n      isZero = (int)(temp1 + 0x19) < 0;\n      if (temp1 == 0xffffffe7 || isZero != SCARRY4(temp1,0x19)) {\n        number1 = number1 & 0x80000000;\n      }\n      if (temp1 == 0xffffffe7 || isZero != SCARRY4(temp1,0x19)) {\n        return number1;\n      }\n      result = (number1 << 1) >> (-temp1 & 0xff);\n      temp1 = number1 << (temp1 + 0x20 & 0xff);\n      result = ((uint)((number1 & 0x80000000) != 0) << 0x1f | result >> 1) + (uint)((byte)result & 1);\n      if ((bitmask2 | temp1 << 1) == 0) {\n        result = result & ~(temp1 >> 0x1f);\n      }\n      return result;\n    }\n  }\n  return number1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000e54": "calculate_floating_point_08000e54",
                "param_1": "number1",
                "param_2": "number2",
                "param_3": "flag1",
                "param_4": "flag2",
                "uVar1": "bitmask1",
                "uVar2": "bitmask2",
                "iVar3": "difference",
                "uVar4": "temp1",
                "iVar5": "temp2",
                "uVar6": "result",
                "bVar7": "isZero",
                "bVar8": "overflow1",
                "bVar9": "overflow2"
            },
            "calling": [
                "PID_Compute",
                "AHRS_ComputeAngles",
                "MadgwickQuaternionUpdate",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f8c": {
            "entrypoint": "0x08000f8c",
            "current_name": "calculate_unsigned_integer_08000f8c",
            "code": "\nuint calculate_unsigned_integer_08000f8c(uint input_number_1,uint input_number_2)\n\n{\n  bool is_combined_negative;\n  uint doubled_input_number_1;\n  uint doubled_input_number_2;\n  uint combined_numbers;\n  bool is_combined_zero;\n  \n  doubled_input_number_1 = input_number_1 * 2;\n  doubled_input_number_2 = input_number_2 * 2;\n  if (((int)doubled_input_number_1 >> 0x18 == -1 || (int)doubled_input_number_2 >> 0x18 == -1) &&\n     ((((int)doubled_input_number_1 >> 0x18 == -1 && ((input_number_1 & 0x7fffff) != 0)) ||\n      (((int)doubled_input_number_2 >> 0x18 == -1 && ((input_number_2 & 0x7fffff) != 0)))))) {\n    return 0xffffffff;\n  }\n  combined_numbers = doubled_input_number_1 | input_number_2 & 0x7fffffff;\n  is_combined_zero = combined_numbers == 0;\n  if (!is_combined_zero) {\n    combined_numbers = input_number_1 ^ input_number_2;\n    is_combined_zero = combined_numbers == 0;\n  }\n  is_combined_negative = -1 < (int)combined_numbers;\n  if (is_combined_negative) {\n    input_number_1 = doubled_input_number_1 + input_number_2 * -2;\n    is_combined_zero = input_number_1 == 0;\n  }\n  if ((is_combined_negative && doubled_input_number_2 <= doubled_input_number_1) && !is_combined_zero) {\n    input_number_1 = (int)input_number_2 >> 0x1f;\n  }\n  if (!is_combined_negative || doubled_input_number_2 > doubled_input_number_1) {\n    input_number_1 = ~((int)input_number_2 >> 0x1f);\n  }\n  if (!is_combined_zero) {\n    input_number_1 = input_number_1 | 1;\n  }\n  return input_number_1;\n}\n\n",
            "renaming": {
                "FUN_08000f8c": "calculate_unsigned_integer_08000f8c",
                "param_1": "input_number_1",
                "param_2": "input_number_2",
                "uVar2": "doubled_input_number_1",
                "uVar3": "doubled_input_number_2",
                "uVar4": "combined_numbers",
                "bVar5": "is_combined_zero",
                "bVar1": "is_combined_negative"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f94": {
            "entrypoint": "0x08000f94",
            "current_name": "check_overflow_08000f94",
            "code": "\nuint check_overflow_08000f94(uint input1,uint input2)\n\n{\n  bool is_negative;\n  uint double_input1;\n  uint double_input2;\n  uint combined_input;\n  bool is_zero;\n  \n  double_input1 = input1 * 2;\n  double_input2 = input2 * 2;\n  if (((int)double_input1 >> 0x18 == -1 || (int)double_input2 >> 0x18 == -1) &&\n     ((((int)double_input1 >> 0x18 == -1 && ((input1 & 0x7fffff) != 0)) ||\n      (((int)double_input2 >> 0x18 == -1 && ((input2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined_input = double_input1 | input2 & 0x7fffffff;\n  is_zero = combined_input == 0;\n  if (!is_zero) {\n    combined_input = input1 ^ input2;\n    is_zero = combined_input == 0;\n  }\n  is_negative = -1 < (int)combined_input;\n  if (is_negative) {\n    input1 = double_input1 + input2 * -2;\n    is_zero = input1 == 0;\n  }\n  if ((is_negative && double_input2 <= double_input1) && !is_zero) {\n    input1 = (int)input2 >> 0x1f;\n  }\n  if (!is_negative || double_input2 > double_input1) {\n    input1 = ~((int)input2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input1 = input1 | 1;\n  }\n  return input1;\n}\n\n",
            "renaming": {
                "FUN_08000f94": "check_overflow_08000f94",
                "param_1": "input1",
                "param_2": "input2",
                "uVar2": "double_input1",
                "uVar3": "double_input2",
                "uVar4": "combined_input",
                "bVar1": "is_negative",
                "bVar5": "is_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f9c": {
            "entrypoint": "0x08000f9c",
            "current_name": "check_overflow_08000f9c",
            "code": "\nuint check_overflow_08000f9c(uint input_1,uint input_2)\n\n{\n  bool is_negative_difference;\n  uint double_input_1;\n  uint double_input_2;\n  uint combined_value;\n  bool is_zero_difference;\n  \n  double_input_1 = input_1 * 2;\n  double_input_2 = input_2 * 2;\n  if (((int)double_input_1 >> 0x18 == -1 || (int)double_input_2 >> 0x18 == -1) &&\n     ((((int)double_input_1 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)double_input_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined_value = double_input_1 | input_2 & 0x7fffffff;\n  is_zero_difference = combined_value == 0;\n  if (!is_zero_difference) {\n    combined_value = input_1 ^ input_2;\n    is_zero_difference = combined_value == 0;\n  }\n  is_negative_difference = -1 < (int)combined_value;\n  if (is_negative_difference) {\n    input_1 = double_input_1 + input_2 * -2;\n    is_zero_difference = input_1 == 0;\n  }\n  if ((is_negative_difference && double_input_2 <= double_input_1) && !is_zero_difference) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_negative_difference || double_input_2 > double_input_1) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero_difference) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "renaming": {
                "FUN_08000f9c": "check_overflow_08000f9c",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar2": "double_input_1",
                "uVar3": "double_input_2",
                "uVar4": "combined_value",
                "bVar1": "is_negative_difference",
                "bVar5": "is_zero_difference"
            },
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ffc": {
            "entrypoint": "0x08000ffc",
            "current_name": "perform_comparison_08000ffc",
            "code": "\nvoid performComparison_08000ffc(undefined4 firstValue,undefined4 secondValue)\n\n{\n  __aeabi_cfcmpeq(secondValue,firstValue);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ffc": "perform_comparison_08000ffc",
                "param_1": "firstValue",
                "param_2": "secondValue"
            },
            "calling": [
                "__aeabi_fcmpgt",
                "__aeabi_fcmpge"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001004": {
            "entrypoint": "0x08001004",
            "current_name": "concatenate_params_08001004",
            "code": "\nundefined8 concatenateParams_08001004(undefined4 value1,undefined4 value2)\n\n{\n  __cmpsf2();\n  return CONCAT44(value2,value1);\n}\n\n",
            "renaming": {
                "FUN_08001004": "concatenate_params_08001004",
                "param_1": "value1",
                "param_2": "value2"
            },
            "calling": [
                "__aeabi_fcmpeq",
                "__aeabi_cfrcmple",
                "__aeabi_fcmple",
                "__aeabi_fcmplt"
            ],
            "called": [
                "__cmpsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001014": {
            "entrypoint": "0x08001014",
            "current_name": "check_float_equality_08001014",
            "code": "\nbool check_float_equality_08001014(void)\n\n{\n  char result;\n  \n  __aeabi_cfcmpeq();\n  return result != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001014": "check_float_equality_08001014",
                "in_ZR": "result"
            },
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001028": {
            "entrypoint": "0x08001028",
            "current_name": "check_null_08001028",
            "code": "\nbool check_null_08001028(void)\n\n{\n  char input_character;\n  \n  __aeabi_cfcmpeq();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001028": "check_null_08001028",
                "in_CY": "input_character"
            },
            "calling": [
                "PID_Update",
                "PID_Compute",
                "AHRS_GetYaw"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800103c": {
            "entrypoint": "0x0800103c",
            "current_name": "compare_floats_0800103c",
            "code": "\nbool compareFloats_0800103c(void)\n\n{\n  undefined isZero;\n  undefined isEqual;\n  \n  __aeabi_cfcmpeq();\n  return !(bool)isEqual || (bool)isZero;\n}\n\n",
            "renaming": {
                "FUN_0800103c": "compare_floats_0800103c",
                "in_ZR": "isZero",
                "in_CY": "isEqual"
            },
            "calling": [],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001050": {
            "entrypoint": "0x08001050",
            "current_name": "is_either_zero_or_negative_08001050",
            "code": "\nbool isEitherZeroOrNegative_08001050(void)\n\n{\n  undefined isZeroFlagSet;\n  undefined isCarryFlagSet;\n  \n  __aeabi_cfrcmple();\n  return !(bool)isCarryFlagSet || (bool)isZeroFlagSet;\n}\n\n",
            "renaming": {
                "FUN_08001050": "is_either_zero_or_negative_08001050",
                "in_CY": "isCarryFlagSet",
                "in_ZR": "isZeroFlagSet"
            },
            "calling": [
                "AHRS_GetYaw"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001064": {
            "entrypoint": "0x08001064",
            "current_name": "FUNC_08001064",
            "code": "\nbool FUNC_08001064(void)\n\n{\n  char in_CY;\n  \n  __aeabi_cfrcmple();\n  return in_CY == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001064": "FUNC_08001064"
            },
            "calling": [
                "PID_Update",
                "PID_Compute"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001078": {
            "entrypoint": "0x08001078",
            "current_name": "validate_input_08001078",
            "code": "\nuint validate_input_08001078(uint input_value)\n\n{\n  uint shifted_value;\n  uint difference;\n  \n  if (input_value << 1 < 0x7f000000) {\n    return 0;\n  }\n  shifted_value = (input_value << 1) >> 0x18;\n  difference = 0x9e - shifted_value;\n  if (shifted_value < 0x9f && difference != 0) {\n    shifted_value = (input_value << 8 | 0x80000000) >> (difference & 0xff);\n    if ((input_value & 0x80000000) != 0) {\n      shifted_value = -shifted_value;\n    }\n    return shifted_value;\n  }\n  if ((difference == 0xffffff9f) && ((input_value & 0x7fffff) != 0)) {\n    return 0;\n  }\n  input_value = input_value & 0x80000000;\n  if (input_value == 0) {\n    input_value = 0x7fffffff;\n  }\n  return input_value;\n}\n\n",
            "renaming": {
                "FUN_08001078": "validate_input_08001078",
                "param_1": "input_value",
                "uVar1": "shifted_value",
                "uVar2": "difference"
            },
            "calling": [
                "Motor_DistributeSpeed",
                "AHRS_ComputeAngles",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080010c4": {
            "entrypoint": "0x080010c4",
            "current_name": "check_parameter_validity_080010c4",
            "code": "\nuint checkParameterValidity_080010c4(uint inputValue)\n\n{\n  uint shiftAmount;\n  \n  if (((inputValue & 0x80000000) != 0) || (inputValue << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shiftAmount = 0x9e - ((inputValue << 1) >> 0x18);\n  if (-1 < (int)shiftAmount) {\n    return (inputValue << 8 | 0x80000000) >> (shiftAmount & 0xff);\n  }\n  if ((shiftAmount == 0xffffff9f) && ((inputValue & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080010c4": "check_parameter_validity_080010c4",
                "param_1": "inputValue",
                "uVar1": "shiftAmount"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001104": {
            "entrypoint": "0x08001104",
            "current_name": "initialize_system_tick_08001104",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeSystemTick_08001104(uint32_t priorityLevel)\n\n{\n  uint32_t hclkFrequency;\n  \n  hclkFrequency = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFrequency / 1000);\n  HAL_NVIC_SetPriority(SysTick_IRQn,priorityLevel,0);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001104": "initialize_system_tick_08001104",
                "TickPriority": "priorityLevel",
                "uVar1": "hclkFrequency"
            },
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_RCC_GetHCLKFreq",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001128": {
            "entrypoint": "0x08001128",
            "current_name": "initialize_hardware_08001128",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nInitializationStatus initializeHardware_08001128(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  setPriorityGroup(3);\n  initializeSysTick(0);\n  initializePeriph();\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001128": "initialize_hardware_08001128",
                "HAL_StatusTypeDef": "InitializationStatus",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGroup",
                "HAL_InitTick": "initializeSysTick",
                "HAL_MspInit": "initializePeriph"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800114c": {
            "entrypoint": "0x0800114c",
            "current_name": "update_tick_0800114c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateTick_0800114c(void)\n\n{\n  tickCounter = tickCounter + 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800114c": "update_tick_0800114c",
                "uwTick": "tickCounter"
            },
            "calling": [
                "SysTick_Handler",
                "main"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800115c": {
            "entrypoint": "0x0800115c",
            "current_name": "get_current_tick_0800115c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getCurrentTick_0800115c(void)\n\n{\n  return currentTick;\n}\n\n",
            "renaming": {
                "FUN_0800115c": "get_current_tick_0800115c",
                "uwTick": "currentTick"
            },
            "calling": [
                "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig",
                "I2C_RequestMemoryWrite",
                "I2C_RequestMemoryRead",
                "HAL_I2C_Mem_Read",
                "HAL_UART_Transmit",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_I2C_Mem_Write",
                "millis",
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "micros",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001168": {
            "entrypoint": "0x08001168",
            "current_name": "FUNC_08001168",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001168(uint32_t Delay)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001168": "FUNC_08001168"
            },
            "calling": [
                "HAL_RCC_OscConfig",
                "delay_ms"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001170": {
            "entrypoint": "0x08001170",
            "current_name": "set_priority_group_08001170",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setPriorityGroup_08001170(uint32_t priorityGroup)\n\n{\n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | 0x5fa0000 | (priorityGroup & 7) << 8;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001170": "set_priority_group_08001170",
                "PriorityGroup": "priorityGroup"
            },
            "calling": [
                "HAL_Init",
                "HAL_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001194": {
            "entrypoint": "0x08001194",
            "current_name": "set_irq_priority_08001194",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setIRQPriority_08001194(interrupt_Type interrupt,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint irqNumber;\n  undefined priorityValue;\n  uint32_t preemptPriorityBits;\n  uint mask;\n  uint32_t priorityGroupTmp;\n  uint32_t subPriorityBits;\n  uint increment;\n  \n  irqNumber = (uint)interrupt;\n  subPriorityBits = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  preemptPriorityBits = 7 - subPriorityBits;\n  increment = subPriorityBits + 4;\n  if (3 < preemptPriorityBits) {\n    preemptPriorityBits = 4;\n  }\n  if (increment < 7) {\n    subPriorityBits = 0;\n  }\n  mask = (1 << (preemptPriorityBits & 0xff)) - 1;\n  if (6 < increment) {\n    subPriorityBits = subPriorityBits - 3;\n  }\n  priorityValue = (undefined)\n          ((subPriority & (1 << (subPriorityBits & 0xff)) - 1U |\n           (preemptPriority & mask) << (subPriorityBits & 0xff)) << 4);\n  if (-1 < (int)irqNumber) {\n    increment = irqNumber + 0xe000e100;\n  }\n  else {\n    mask = 0xe000ed14;\n    increment = irqNumber & 0xf;\n  }\n  if (-1 < (int)irqNumber) {\n    *(undefined *)(increment + 0x300) = priorityValue;\n  }\n  else {\n    *(undefined *)(mask + increment) = priorityValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001194": "set_irq_priority_08001194",
                "IRQn": "interrupt",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "PreemptPriorityBits": "preemptPriorityBits",
                "PriorityGroupTmp": "priorityGroupTmp",
                "SubPriorityBits": "subPriorityBits",
                "uVar1": "irqNumber",
                "uVar2": "priorityValue",
                "uVar3": "mask",
                "uVar4": "increment"
            },
            "calling": [
                "HAL_UART_MspInit",
                "HAL_MspInit",
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011fc": {
            "entrypoint": "0x080011fc",
            "current_name": "set_irq_enabled_080011fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setIRQEnabled_080011fc(interruptType_Type interruptType)\n\n{\n  *(int *)(((uint)(int)interruptType >> 5) * 4 + -0x1fff1f00) = 1 << ((int)interruptType & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080011fc": "set_irq_enabled_080011fc",
                "IRQn": "interruptType"
            },
            "calling": [
                "HAL_UART_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001214": {
            "entrypoint": "0x08001214",
            "current_name": "initialize_ticks_08001214",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t initializeTicks_08001214(uint32_t ticks)\n\n{\n  if (ticks - 1 < 0x1000000) {\n    _DAT_e000e014 = ticks - 1;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08001214": "initialize_ticks_08001214",
                "TicksNumb": "ticks"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001240": {
            "entrypoint": "0x08001240",
            "current_name": "update_clk_source_08001240",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid updateCLKSource_08001240(uint32_t source)\n\n{\n  if (source == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001240": "update_clk_source_08001240",
                "CLKSource": "source"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001258": {
            "entrypoint": "0x08001258",
            "current_name": "FUNC_08001258",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001258(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001258": "FUNC_08001258"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800125a": {
            "entrypoint": "0x0800125a",
            "current_name": "initialize_sys_tick_0800125a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSysTick_0800125a(void)\n\n{\n  handleSysTickInterrupt();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800125a": "initialize_sys_tick_0800125a",
                "HAL_SYSTICK_Callback": "handleSysTickInterrupt"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001264": {
            "entrypoint": "0x08001264",
            "current_name": "configure_gpio_08001264",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureGPIO_08001264(GPIO_TypeDef *gpio,gpioInitTypeDef *gpioInit)\n\n{\n  uint32_t *configRegister;\n  uint32_t speedValue;\n  uint bitCheck;\n  uint modeValue;\n  int gpioIndex;\n  uint bitIndex;\n  uint bitMask;\n  uint pullValue;\n  GPIO_TypeDef *gpioReg;\n  int shiftValue;\n  uint32_t tempReg;\n  \n  speedValue = 0;\n  bitIndex = 0;\n  do {\n    bitMask = 1 << (bitIndex & 0xff);\n    bitCheck = bitMask & gpioInit->Pin;\n    if (bitMask == bitCheck) {\n      modeValue = gpioInit->Mode;\n      if (modeValue == 0x12) {\n        speedValue = gpioInit->Speed + 0xc;\n      }\n      else if (modeValue < 0x13) {\n        if (modeValue == 2) {\n          speedValue = gpioInit->Speed + 8;\n        }\n        else if (modeValue < 3) {\n          if (modeValue == 0) goto LAB_080013be;\n          if (modeValue == 1) {\n            speedValue = gpioInit->Speed;\n          }\n        }\n        else if (modeValue == 3) {\n          speedValue = 0;\n        }\n        else if (modeValue == 0x11) {\n          speedValue = gpioInit->Speed + 4;\n        }\n      }\n      else {\n        if (modeValue != 0x10210000) {\n          if (modeValue < 0x10210001) {\n            if (modeValue != 0x10110000) {\n              pullValue = 0x10120000;\nLAB_080013b8:\n              if (modeValue != pullValue) goto LAB_080012a8;\n            }\n          }\n          else if ((modeValue != 0x10310000) && (modeValue != 0x10320000)) {\n            pullValue = 0x10220000;\n            goto LAB_080013b8;\n          }\n        }\nLAB_080013be:\n        speedValue = gpioInit->Pull;\n        if (speedValue == 0) {\n          speedValue = 4;\n        }\n        else {\n          if (speedValue == 1) {\n            gpio->BSRR = bitMask;\n          }\n          if (speedValue != 1) {\n            gpio->BRR = bitMask;\n          }\n          speedValue = 8;\n        }\n      }\nLAB_080012a8:\n      if (bitCheck < 0x100) {\n        bitMask = gpio->CRL;\n        modeValue = bitIndex << 2;\n        gpioReg = gpio;\n      }\n      else {\n        bitMask = gpio->CRH;\n        modeValue = (bitIndex + 0x3ffffff8) * 4;\n      }\n      if (0xff < bitCheck) {\n        gpioReg = (GPIO_TypeDef *)&gpio->CRH;\n      }\n      gpioReg->CRL = bitMask & ~(0xf << (modeValue & 0xff)) | speedValue << (modeValue & 0xff);\n      gpioReg = (GPIO_TypeDef *)gpioInit->Mode;\n      if (((uint)gpioReg & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        shiftValue = (bitIndex & 3) << 2;\n        if (gpio == (GPIO_TypeDef *)0x40010800) {\n          gpioIndex = 0;\n        }\n        else if (gpio == (GPIO_TypeDef *)0x40010c00) {\n          gpioIndex = 1;\n        }\n        else if (gpio == (GPIO_TypeDef *)0x40011000) {\n          gpioIndex = 2;\n        }\n        else if (gpio == (GPIO_TypeDef *)0x40011400) {\n          gpioIndex = 3;\n        }\n        else {\n          gpioIndex = 4;\n        }\n        *(uint *)((bitIndex & 0xfffffffc) + 0x40010008) =\n             gpioIndex << shiftValue | *(uint *)((bitIndex & 0xfffffffc) + 0x40010008) & ~(0xf << shiftValue);\n        if (((uint)gpioReg & 0x10000) == 0) {\n          _DAT_40010400 = _DAT_40010400 & ~bitCheck;\n        }\n        else {\n          _DAT_40010400 = _DAT_40010400 | bitCheck;\n        }\n        if (((uint)gpioReg & 0x20000) == 0) {\n          _DAT_40010404 = _DAT_40010404 & ~bitCheck;\n        }\n        else {\n          _DAT_40010404 = _DAT_40010404 | bitCheck;\n        }\n        if (((uint)gpioReg & 0x100000) == 0) {\n          _DAT_40010408 = _DAT_40010408 & ~bitCheck;\n        }\n        else {\n          _DAT_40010408 = _DAT_40010408 | bitCheck;\n        }\n        if (((uint)gpioReg & 0x200000) == 0) {\n          _DAT_4001040c = _DAT_4001040c & ~bitCheck;\n        }\n        else {\n          _DAT_4001040c = bitCheck | _DAT_4001040c;\n        }\n      }\n    }\n    bitIndex = bitIndex + 1;\n    if (bitIndex == 0x10) {\n      return;\n    }\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08001264": "configure_gpio_08001264",
                "GPIOx": "gpio",
                "GPIO_Init": "gpioInit",
                "configregister": "configRegister",
                "uVar1": "speedValue",
                "uVar2": "bitCheck",
                "uVar3": "modeValue",
                "iVar4": "gpioIndex",
                "uVar5": "bitIndex",
                "uVar6": "bitMask",
                "uVar7": "pullValue",
                "unaff_r10": "gpioReg",
                "iVar8": "shiftValue",
                "tmpreg": "tempReg"
            },
            "calling": [
                "HAL_UART_MspInit",
                "Peripherals_Init",
                "HAL_I2C_MspInit",
                "HAL_TIM_MspPostInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001424": {
            "entrypoint": "0x08001424",
            "current_name": "set_gpio_state_08001424",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setGPIOState_08001424(GPIO_TypeDef *gpioPort,uint16_t pinNumber,pinNumberState pinState)\n\n{\n  uint32_t mask;\n  \n  mask = (uint32_t)pinNumber;\n  if (pinState == GPIO_PIN_RESET) {\n    mask = mask << 0x10;\n  }\n  gpioPort->BSRR = mask;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001424": "set_gpio_state_08001424",
                "GPIOx": "gpioPort",
                "GPIO_Pin": "pinNumber",
                "PinState": "pinState",
                "uVar1": "mask"
            },
            "calling": [
                "Peripherals_Init",
                "toggleLED",
                "_Error_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800142e": {
            "entrypoint": "0x0800142e",
            "current_name": "toggle_gpio_pin_state_0800142e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid toggleGPIO_PinState_0800142e(GPIO_TypeDef *gpioPort,uint16_t pinNumber)\n\n{\n  gpioPort->ODR = (uint)pinNumber ^ gpioPort->ODR;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800142e": "toggle_gpio_pin_state_0800142e",
                "GPIOx": "gpioPort",
                "GPIO_Pin": "pinNumber"
            },
            "calling": [
                "_Error_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001436": {
            "entrypoint": "0x08001436",
            "current_name": "clear_i2_c_error_flag_08001436",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef clearI2CErrorFlag_08001436(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2C_TypeDef *i2cInstance;\n  \n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->statusRegister1 & 0x400) != 0) {\n    i2cInstance->statusRegister1 = i2cInstance->statusRegister1 & 0xfffffbff;\n    i2cHandle->errorFlag = 4;\n    i2cHandle->i2cState = HAL_I2C_STATE_READY;\n    i2cHandle->i2cLock = HAL_UNLOCKED;\n    return HAL_ERROR;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001436": "clear_i2_c_error_flag_08001436",
                "hi2c": "i2cHandle",
                "pIVar1": "i2cInstance",
                "SR1": "statusRegister1",
                "ErrorCode": "errorFlag",
                "State": "i2cState",
                "Lock": "i2cLock"
            },
            "calling": [
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001460": {
            "entrypoint": "0x08001460",
            "current_name": "wait_for_i2_c_flag_08001460",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef waitForI2CFlag_08001460(I2C_HandleTypeDef *i2cHandle,uint32_t flag,uint32_t timeout)\n\n{\n  uint32_t startTick;\n  uint32_t currentTick;\n  uint statusReg;\n  I2C_TypeDef *i2cInstance;\n  \n  startTick = HAL_GetTick();\n  do {\n    i2cInstance = i2cHandle->Instance;\n    if ((flag << 8) >> 0x18 == 1) {\n      statusReg = i2cInstance->SR1;\n    }\n    else {\n      statusReg = i2cInstance->SR2;\n    }\n    if ((flag & 0xffff & ~statusReg) == 0) {\n      return HAL_OK;\n    }\n    if ((int)(i2cInstance->SR1 << 0x15) < 0) {\n      i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n      i2cInstance->SR1 = i2cInstance->SR1 & 0xfffffbff;\n      i2cHandle->ErrorCode = 4;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_ERROR;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - startTick <= timeout))));\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08001460": "wait_for_i2_c_flag_08001460",
                "hi2c": "i2cHandle",
                "Flag": "flag",
                "Timeout": "timeout",
                "uVar1": "startTick",
                "uVar2": "currentTick",
                "uVar3": "statusReg",
                "pIVar4": "i2cInstance"
            },
            "calling": [
                "I2C_RequestMemoryWrite",
                "I2C_RequestMemoryRead"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014e2": {
            "entrypoint": "0x080014e2",
            "current_name": "check_i2_c_acknowledge_080014e2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef checkI2CAcknowledge_080014e2(I2C_HandleTypeDef *i2cHandler,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTime;\n  uint32_t currentTime;\n  uint32_t tickStart;\n  \n  startTime = HAL_GetTick();\n  while( true ) {\n    if ((int)(i2cHandler->Instance->SR1 << 0x18) < 0) {\n      return HAL_OK;\n    }\n    status = I2C_IsAcknowledgeFailed(i2cHandler);\n    if (status != HAL_OK) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (currentTime = HAL_GetTick(), timeout < currentTime - startTime)))) {\n      i2cHandler->ErrorCode = i2cHandler->ErrorCode | 0x20;\n      i2cHandler->State = HAL_I2C_STATE_READY;\n      i2cHandler->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_080014e2": "check_i2_c_acknowledge_080014e2",
                "hi2c": "i2cHandler",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "startTime",
                "uVar3": "currentTime",
                "tickstart": "tickStart"
            },
            "calling": [
                "I2C_RequestMemoryWrite",
                "I2C_RequestMemoryRead",
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_IsAcknowledgeFailed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001530": {
            "entrypoint": "0x08001530",
            "current_name": "write_i2_c_memory_08001530",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nwriteI2CMemory_08001530(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTime;\n  uint32_t currentTime;\n  I2C_TypeDef *i2cInstance;\n  uint32_t tempRegister;\n  \n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n  startTime = HAL_GetTick();\n  do {\n    do {\n      if ((int)(i2cHandle->Instance->SR1 << 0x1f) < 0) {\n        i2cHandle->Instance->DR = deviceAddress & 0xfe;\n        status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout);\n        if (status == HAL_OK) {\n          status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n          if (status == HAL_OK) {\n            i2cInstance = i2cHandle->Instance;\n            if (memoryAddressSize == 1) {\nLAB_080015ca:\n              i2cInstance->DR = (uint)(byte)memoryAddress;\n              return HAL_OK;\n            }\n            i2cInstance->DR = (uint)(memoryAddress >> 8);\n            status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n            if (status == HAL_OK) {\n              i2cInstance = i2cHandle->Instance;\n              goto LAB_080015ca;\n            }\n          }\n          if (i2cHandle->ErrorCode != 4) {\n            return HAL_TIMEOUT;\n          }\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        }\n        else if (i2cHandle->ErrorCode != 4) {\n          return HAL_TIMEOUT;\n        }\n        return HAL_ERROR;\n      }\n    } while (timeout == 0xffffffff);\n    if ((timeout == 0) || (currentTime = HAL_GetTick(), timeout < currentTime - startTime)) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08001530": "write_i2_c_memory_08001530",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "startTime",
                "uVar3": "currentTime",
                "pIVar4": "i2cInstance",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015e8": {
            "entrypoint": "0x080015e8",
            "current_name": "i2c_transfer_080015e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\ni2c_transfer_080015e8(I2C_HandleTypeDef *i2c_handle,uint16_t device_address,uint16_t memory_address,uint16_t memory_address_size,\n            uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t start_tick;\n  uint32_t current_tick;\n  I2C_TypeDef *i2c_instance;\n  uint32_t temporary_register;\n  \n  i2c_instance = i2c_handle->Instance;\n  i2c_instance->CR1 = i2c_instance->CR1 | 0x400;\n  i2c_instance->CR1 = i2c_instance->CR1 | 0x100;\n  start_tick = HAL_GetTick();\nLAB_0800160e:\n  while (-1 < (int)(i2c_handle->Instance->SR1 << 0x1f)) {\n    if (timeout != 0xffffffff) goto code_r0x08001658;\n  }\n  i2c_handle->Instance->DR = (byte)device_address & 0xfe;\n  status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2c_handle,0x10002,timeout);\n  if (status != HAL_OK) goto LAB_080016ba;\n  status = I2C_WaitOnTXEFlagUntiltimeout(i2c_handle,timeout);\n  if (status == HAL_OK) {\n    i2c_instance = i2c_handle->Instance;\n    if (memory_address_size != 1) {\n      i2c_instance->DR = (uint)(memory_address >> 8);\n      status = I2C_WaitOnTXEFlagUntiltimeout(i2c_handle,timeout);\n      if (status != HAL_OK) goto LAB_08001642;\n      i2c_instance = i2c_handle->Instance;\n    }\n    i2c_instance->DR = (uint)(byte)memory_address;\n    status = I2C_WaitOnTXEFlagUntiltimeout(i2c_handle,timeout);\n    if (status == HAL_OK) {\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x100;\n      start_tick = HAL_GetTick();\n      do {\n        do {\n          if ((int)(i2c_handle->Instance->SR1 << 0x1f) < 0) {\n            i2c_handle->Instance->DR = (byte)device_address | 1;\n            status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2c_handle,0x10002,timeout);\n            if (status == HAL_OK) {\n              return HAL_OK;\n            }\nLAB_080016ba:\n            if (i2c_handle->ErrorCode != 4) {\n              return HAL_TIMEOUT;\n            }\n            return HAL_ERROR;\n          }\n        } while (timeout == 0xffffffff);\n      } while ((timeout != 0) && (current_tick = HAL_GetTick(), current_tick - start_tick <= timeout));\nLAB_0800165a:\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\nLAB_08001642:\n  if (i2c_handle->ErrorCode == 4) {\n    i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n    return HAL_ERROR;\n  }\n  return HAL_TIMEOUT;\ncode_r0x08001658:\n  if ((timeout == 0) || (current_tick = HAL_GetTick(), timeout < current_tick - start_tick)) goto LAB_0800165a;\n  goto LAB_0800160e;\n}\n\n",
            "renaming": {
                "FUN_080015e8": "i2c_transfer_080015e8",
                "hi2c": "i2c_handle",
                "DevAddress": "device_address",
                "MemAddress": "memory_address",
                "MemAddSize": "memory_address_size",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "start_tick",
                "uVar3": "current_tick",
                "pIVar4": "i2c_instance",
                "tmpreg": "temporary_register"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016f4": {
            "entrypoint": "0x080016f4",
            "current_name": "check_i2_c_flag_080016f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef checkI2CFlag_080016f4(I2C_HandleTypeDef *i2cHandle,uint32_t timeout)\n\n{\n  uint32_t startTick;\n  uint32_t currentTick;\n  I2C_TypeDef *i2cInstance;\n  \n  startTick = HAL_GetTick();\n  while( true ) {\n    i2cInstance = i2cHandle->Instance;\n    if ((i2cInstance->SR1 & 0x40) != 0) {\n      return HAL_OK;\n    }\n    if ((int)(i2cInstance->SR1 << 0x1b) < 0) break;\n    if ((timeout == 0) || (currentTick = HAL_GetTick(), timeout < currentTick - startTick)) {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 0x20;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  i2cInstance->SR1 = i2cInstance->SR1 & 0xffffffef;\n  i2cHandle->ErrorCode = 0;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_080016f4": "check_i2_c_flag_080016f4",
                "hi2c": "i2cHandle",
                "Timeout": "timeout",
                "uVar1": "startTick",
                "uVar2": "currentTick",
                "pIVar3": "i2cInstance"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001754": {
            "entrypoint": "0x08001754",
            "current_name": "initialize_i2_c_08001754",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeI2C_08001754(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t pclk1Freq;\n  uint extraReturn;\n  uint timeout;\n  I2C_TypeDef *i2cInstance;\n  uint clockSpeed;\n  uint divisor;\n  \n  if (i2cHandle != (I2C_HandleTypeDef *)0x0) {\n    if (i2cHandle->State == i2cStateReset) {\n      i2cHandle->Lock = unlocked;\n      initI2C_GPIO(i2cHandle);\n    }\n    i2cHandle->State = i2cStateBusy;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n    pclk1Freq = getPCLK1Frequency();\n    clockSpeed = (i2cHandle->Init).ClockSpeed;\n    divisor = pclk1Freq / 1000000;\n    timeout = extraReturn;\n    if (100000 < clockSpeed) {\n      timeout = 300;\n    }\n    i2cInstance = i2cHandle->Instance;\n    if (100000 < clockSpeed) {\n      timeout = divisor * timeout;\n    }\n    i2cInstance->CR2 = divisor;\n    if (100000 < clockSpeed) {\n      divisor = timeout / 1000;\n    }\n    i2cInstance->TRISE = divisor + 1;\n    if (clockSpeed < 0x186a1) {\n      pclk1Freq = pclk1Freq / (clockSpeed << 1);\n      if ((pclk1Freq & 0xfff) < 4) {\n        pclk1Freq = 4;\n      }\n    }\n    else {\n      if ((i2cHandle->Init).DutyCycle == 0) {\n        pclk1Freq = pclk1Freq / (clockSpeed * 3) | 0x8000;\n      }\n      else {\n        pclk1Freq = pclk1Freq / (clockSpeed * 0x19) | 0xc000;\n      }\n      if ((pclk1Freq & 0xfff) == 0) {\n        pclk1Freq = 1;\n      }\n    }\n    divisor = (i2cHandle->Init).NoStretchMode;\n    timeout = (i2cHandle->Init).GeneralCallMode;\n    i2cInstance->CCR = pclk1Freq;\n    i2cInstance->CR1 = timeout | divisor;\n    i2cInstance->OAR1 = (i2cHandle->Init).AddressingMode | (i2cHandle->Init).OwnAddress1;\n    i2cInstance->OAR2 = (i2cHandle->Init).DualAddressMode | (i2cHandle->Init).OwnAddress2;\n    i2cInstance->CR1 = i2cInstance->CR1 | 1;\n    i2cHandle->ErrorCode = 0;\n    i2cHandle->State = i2cStateReady;\n    i2cHandle->Mode = i2cModeNone;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08001754": "initialize_i2_c_08001754",
                "hi2c": "i2cHandle",
                "uVar1": "pclk1Freq",
                "extraout_r1": "extraReturn",
                "uVar2": "timeout",
                "pIVar3": "i2cInstance",
                "uVar4": "clockSpeed",
                "uVar5": "divisor",
                "HAL_RCC_GetPCLK1Freq": "getPCLK1Frequency",
                "HAL_I2C_MspInit": "initI2C_GPIO",
                "HAL_UNLOCKED": "unlocked",
                "HAL_I2C_STATE_RESET": "i2cStateReset",
                "HAL_I2C_STATE_BUSY": "i2cStateBusy",
                "HAL_I2C_MODE_NONE": "i2cModeNone",
                "HAL_I2C_STATE_READY": "i2cStateReady"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_I2C_MspInit",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001828": {
            "entrypoint": "0x08001828",
            "current_name": "i2c_memory_write_08001828",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\ni2c_memory_write_08001828(I2C_HandleTypeDef *i2c_handle,uint16_t device_address,uint16_t memory_address,uint16_t memory_address_size,\n            uint8_t *data,uint16_t data_size,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t start_time;\n  uint32_t current_time;\n  I2C_TypeDef *i2c_instance;\n  uint cr1_value;\n  \n  if (i2c_handle->State == HAL_I2C_STATE_READY) {\n    if (data == (uint8_t *)0x0) {\n      return HAL_ERROR;\n    }\n    if (data_size == 0) {\n      return HAL_ERROR;\n    }\n    start_time = HAL_GetTick();\n    do {\n      i2c_instance = i2c_handle->Instance;\n      if ((~i2c_instance->SR2 & 2) != 0) {\n        if (i2c_handle->Lock == HAL_LOCKED) {\n          return HAL_BUSY;\n        }\n        cr1_value = i2c_instance->CR1;\n        i2c_handle->Lock = HAL_LOCKED;\n        i2c_instance->CR1 = cr1_value & 0xfffff7ff;\n        i2c_handle->State = HAL_I2C_STATE_BUSY_TX;\n        i2c_handle->Mode = HAL_I2C_MODE_MEM;\n        i2c_handle->ErrorCode = 0;\n        status = I2C_RequestMemoryWrite(i2c_handle,device_address,memory_address,memory_address_size,timeout);\n        if (status != HAL_OK) {\n          i2c_handle->Lock = HAL_UNLOCKED;\n          if (i2c_handle->ErrorCode == 4) {\n            return HAL_ERROR;\n          }\n          return HAL_TIMEOUT;\n        }\n        goto LAB_080018e2;\n      }\n      current_time = HAL_GetTick();\n    } while (current_time - start_time < 0x2711);\n    i2c_handle->Lock = HAL_UNLOCKED;\n    i2c_handle->State = HAL_I2C_STATE_READY;\n  }\n  return HAL_BUSY;\n  while (data_size != 0) {\nLAB_080018e2:\n    status = I2C_WaitOnTXEFlagUntiltimeout(i2c_handle,timeout);\n    if (status != HAL_OK) goto LAB_080018ee;\n    i2c_instance = i2c_handle->Instance;\n    i2c_instance->DR = (uint)*data;\n    if ((int)(i2c_instance->SR1 << 0x1d) < 0) {\n      if ((uint16_t)(data_size - 1) == 0) break;\n      data_size = data_size - 2;\n      i2c_instance->DR = (uint)data[1];\n      data = data + 2;\n    }\n    else {\n      data = data + 1;\n      data_size = data_size - 1;\n    }\n  }\n  status = I2C_WaitOnTXEFlagUntiltimeout(i2c_handle,timeout);\n  if (status == HAL_OK) {\n    i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n    i2c_handle->Lock = HAL_UNLOCKED;\n    i2c_handle->State = HAL_I2C_STATE_READY;\n    i2c_handle->Mode = HAL_I2C_MODE_NONE;\n    return HAL_OK;\n  }\nLAB_080018ee:\n  if (i2c_handle->ErrorCode == 4) {\n    i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n    return HAL_ERROR;\n  }\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08001828": "i2c_memory_write_08001828",
                "hi2c": "i2c_handle",
                "DevAddress": "device_address",
                "MemAddress": "memory_address",
                "MemAddSize": "memory_address_size",
                "pData": "data",
                "Size": "data_size",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "start_time",
                "uVar3": "current_time",
                "pIVar4": "i2c_instance",
                "uVar5": "cr1_value"
            },
            "calling": [
                "I2C_WriteByte"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_RequestMemoryWrite",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001938": {
            "entrypoint": "0x08001938",
            "current_name": "read_memory_08001938",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nreadMemory_08001938(I2C_HandleTypeDef *i2c_handle,uint16_t device_address,uint16_t memory_address,uint16_t memory_size,\n            uint8_t *data_pointer,uint16_t data_size,uint32_t timeout)\n\n{\n  uint8_t *ptr_var1;\n  HAL_StatusTypeDef status;\n  uint32_t tick_start;\n  uint32_t tick_current;\n  I2C_TypeDef *i2c_instance;\n  uint i2c_cr1;\n  uint8_t *ptr_var7;\n  bool bit_var8;\n  uint32_t tmp_reg;\n  uint32_t tmp_reg1;\n  uint32_t tmp_reg2;\n  \n  if (i2c_handle->State != HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (data_pointer == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (data_size == 0) {\n    return HAL_ERROR;\n  }\n  tick_start = HAL_GetTick();\n  while (i2c_instance = i2c_handle->Instance, (~i2c_instance->SR2 & 2) == 0) {\n    tick_current = HAL_GetTick();\n    if (10000 < tick_current - tick_start) {\n      i2c_handle->Lock = HAL_UNLOCKED;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      return HAL_BUSY;\n    }\n  }\n  if (i2c_handle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  i2c_cr1 = i2c_instance->CR1;\n  i2c_handle->Lock = HAL_LOCKED;\n  i2c_instance->CR1 = i2c_cr1 & 0xfffff7ff;\n  i2c_handle->State = HAL_I2C_STATE_BUSY_RX;\n  i2c_handle->Mode = HAL_I2C_MODE_MEM;\n  i2c_handle->ErrorCode = 0;\n  status = I2C_RequestMemoryRead(i2c_handle,device_address,memory_address,memory_size,timeout);\n  if (status != HAL_OK) {\n    i2c_handle->Lock = HAL_UNLOCKED;\n    if (i2c_handle->ErrorCode == 4) {\n      return HAL_ERROR;\n    }\n    return HAL_TIMEOUT;\n  }\n  i2c_instance = i2c_handle->Instance;\n  i2c_cr1 = i2c_instance->CR1;\n  if (data_size == 1) {\n    i2c_instance->CR1 = i2c_cr1 & 0xfffffbff;\n    disableIRQinterrupts();\n    i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n    enableIRQinterrupts();\n    status = I2C_WaitOnRXNEFlagUntiltimeout(i2c_handle,timeout);\n    if (status == HAL_OK) {\n      *data_pointer = (uint8_t)i2c_handle->Instance->DR;\nLAB_08001ab8:\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Mode = HAL_I2C_MODE_NONE;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      return HAL_OK;\n    }\nLAB_08001a18:\n    if (i2c_handle->ErrorCode != 0x20) {\n      return HAL_ERROR;\n    }\n    return HAL_TIMEOUT;\n  }\n  if (data_size == 2) {\n    i2c_instance->CR1 = i2c_cr1 | 0x800;\n    disableIRQinterrupts();\n    i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffffbff;\n    enableIRQinterrupts();\n  }\n  else {\n    i2c_instance->CR1 = i2c_cr1 | 0x400;\n    while (3 < data_size) {\n      status = I2C_WaitOnRXNEFlagUntiltimeout(i2c_handle,timeout);\n      if (status != HAL_OK) goto LAB_08001a18;\n      *data_pointer = (uint8_t)i2c_handle->Instance->DR;\n      i2c_instance = i2c_handle->Instance;\n      bit_var8 = (int)(i2c_instance->SR1 << 0x1d) < 0;\n      if (bit_var8) {\n        i2c_instance = (I2C_TypeDef *)i2c_instance->DR;\n        ptr_var7 = data_pointer + 2;\n        data_size = data_size - 2;\n      }\n      else {\n        ptr_var7 = data_pointer + 1;\n        data_size = data_size - 1;\n      }\n      ptr_var1 = data_pointer + 1;\n      data_pointer = ptr_var7;\n      if (bit_var8) {\n        *ptr_var1 = (uint8_t)i2c_instance;\n      }\n    }\n    if (data_size != 2) {\n      tick_start = HAL_GetTick();\n      do {\n        i2c_instance = i2c_handle->Instance;\n        do {\n          if ((int)(i2c_instance->SR1 << 0x1d) < 0) {\n            i2c_instance->CR1 = i2c_instance->CR1 & 0xfffffbff;\n            disableIRQinterrupts();\n            *data_pointer = (uint8_t)i2c_handle->Instance->DR;\n            tick_start = HAL_GetTick();\n            goto LAB_08001b3a;\n          }\n        } while (timeout == 0xffffffff);\n      } while ((timeout != 0) && (tick_current = HAL_GetTick(), tick_current - tick_start <= timeout));\n      goto LAB_08001afa;\n    }\n  }\n  tick_start = HAL_GetTick();\n  do {\n    do {\n      if ((int)(i2c_handle->Instance->SR1 << 0x1d) < 0) {\n        disableIRQinterrupts();\n        i2c_instance = i2c_handle->Instance;\n        i2c_instance->CR1 = i2c_instance->CR1 | 0x200;\n        *data_pointer = (uint8_t)i2c_instance->DR;\n        enableIRQinterrupts();\n        data_pointer[1] = (uint8_t)i2c_handle->Instance->DR;\n        goto LAB_08001ab8;\n      }\n    } while (timeout == 0xffffffff);\n  } while ((timeout != 0) && (tick_current = HAL_GetTick(), tick_current - tick_start <= timeout));\nLAB_08001afa:\n  i2c_handle->State = HAL_I2C_STATE_READY;\n  i2c_handle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\nLAB_08001b3a:\n  do {\n    i2c_instance = i2c_handle->Instance;\n    do {\n      if ((int)(i2c_instance->SR1 << 0x1d) < 0) {\n        i2c_instance->CR1 = i2c_instance->CR1 | 0x200;\n        data_pointer[1] = (uint8_t)i2c_instance->DR;\n        enableIRQinterrupts();\n        data_pointer[2] = (uint8_t)i2c_handle->Instance->DR;\n        goto LAB_08001ab8;\n      }\n    } while (timeout == 0xffffffff);\n  } while ((timeout != 0) && (tick_current = HAL_GetTick(), tick_current - tick_start <= timeout));\n  goto LAB_08001afa;\n}\n\n",
            "renaming": {
                "FUN_08001938": "read_memory_08001938",
                "hi2c": "i2c_handle",
                "DevAddress": "device_address",
                "MemAddress": "memory_address",
                "MemAddSize": "memory_size",
                "pData": "data_pointer",
                "Size": "data_size",
                "Timeout": "timeout",
                "puVar1": "ptr_var1",
                "HVar2": "status",
                "uVar3": "tick_start",
                "uVar4": "tick_current",
                "pIVar5": "i2c_instance",
                "uVar6": "i2c_cr1",
                "puVar7": "ptr_var7",
                "bVar8": "bit_var8",
                "tmpreg": "tmp_reg",
                "tmpreg_1": "tmp_reg1",
                "tmpreg_2": "tmp_reg2"
            },
            "calling": [
                "I2C_ReadByte",
                "I2C_ReadBytes"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_RequestMemoryRead",
                "I2C_WaitOnRXNEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b58": {
            "entrypoint": "0x08001b58",
            "current_name": "initialize_clock_configuration_08001b58",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001eec) initializeClockConfiguration_08001b58\n/* WARNING: Removing unreachable block (ram,0x08001ee8) initializeClockConfiguration_08001b58\n\n/* WARNING: Unknown calling convention initializeClockConfiguration_08001b58\n\nHAL_StatusTypeDef initializeClockConfiguration_08001b58(RCC_OscInitTypeDef *clockConfig)\n\n{\n  uint32_t tickStart;\n  uint32_t tickEnd;\n  uint pllSource;\n  uint32_t temporaryRegister;\n  \n  if ((int)(clockConfig->OscillatorType << 0x1f) < 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((int)(_DAT_40021004 << 0xf) < 0)))) {\n      if (((int)((_DAT_40021000 >> 0x11) << 0x1f) < 0) && (clockConfig->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      tickStart = clockConfig->HSEState;\n      if (tickStart == 0x10000) {\nLAB_08001c1e:\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else {\n        if (tickStart == 0) {\n          _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n          tickStart = HAL_GetTick();\n          while ((int)((_DAT_40021000 >> 0x11) << 0x1f) < 0) {\n            tickEnd = HAL_GetTick();\n            if (100 < tickEnd - tickStart) {\n              return HAL_TIMEOUT;\n            }\n          }\n          goto LAB_08001b64;\n        }\n        if (tickStart == 0x50000) {\n          _DAT_40021000 = _DAT_40021000 | 0x40000;\n          goto LAB_08001c1e;\n        }\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      tickStart = HAL_GetTick();\n      while (-1 < (int)((_DAT_40021000 >> 0x11) << 0x1f)) {\n        tickEnd = HAL_GetTick();\n        if (100 < tickEnd - tickStart) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\nLAB_08001b64:\n  if ((int)(clockConfig->OscillatorType << 0x1e) < 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && (-1 < (int)(_DAT_40021004 << 0xf))))) {\n      if (((int)((_DAT_40021000 >> 1) << 0x1f) < 0) && (clockConfig->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      uRam42420000 = clockConfig->HSIState;\n      if (uRam42420000 == 0) {\n        tickStart = HAL_GetTick();\n        while ((int)((_DAT_40021000 >> 1) << 0x1f) < 0) {\n          tickEnd = HAL_GetTick();\n          if (2 < tickEnd - tickStart) {\n            return HAL_TIMEOUT;\n          }\n        }\n        goto LAB_08001b6c;\n      }\n      uRam42420000 = 1;\n      tickStart = HAL_GetTick();\n      while (-1 < (int)((_DAT_40021000 >> 1) << 0x1f)) {\n        tickEnd = HAL_GetTick();\n        if (2 < tickEnd - tickStart) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    _DAT_40021000 = clockConfig->HSICalibrationValue << 3 | _DAT_40021000 & 0xffffff07;\n  }\nLAB_08001b6c:\n  if ((int)(clockConfig->OscillatorType << 0x1c) < 0) {\n    uRam42420480 = clockConfig->LSIState;\n    if (uRam42420480 == 0) {\n      tickStart = HAL_GetTick();\n      while ((int)((_DAT_40021024 >> 1) << 0x1f) < 0) {\n        tickEnd = HAL_GetTick();\n        if (2 < tickEnd - tickStart) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      uRam42420480 = 1;\n      tickStart = HAL_GetTick();\n      while (-1 < (int)((_DAT_40021024 >> 1) << 0x1f)) {\n        tickEnd = HAL_GetTick();\n        if (2 < tickEnd - tickStart) {\n          return HAL_TIMEOUT;\n        }\n      }\n      HAL_Delay(1);\n    }\n  }\n  if (-1 < (int)(clockConfig->OscillatorType << 0x1d)) goto LAB_08001bc2;\n  _DAT_4002101c = _DAT_4002101c | 0x10000000;\n  _DAT_40007000 = _DAT_40007000 | 0x100;\n  tickStart = HAL_GetTick();\n  while (-1 < (int)(_DAT_40007000 << 0x17)) {\n    tickEnd = HAL_GetTick();\n    if (100 < tickEnd - tickStart) {\n      return HAL_TIMEOUT;\n    }\n  }\n  tickStart = clockConfig->LSEState;\n  if (tickStart == 1) {\nLAB_08001e1a:\n    _DAT_40021020 = _DAT_40021020 | 1;\n  }\n  else {\n    if (tickStart == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n      tickStart = HAL_GetTick();\n      while ((int)((_DAT_40021020 >> 1) << 0x1f) < 0) {\n        tickEnd = HAL_GetTick();\n        if (5000 < tickEnd - tickStart) {\n          return HAL_TIMEOUT;\n        }\n      }\n      goto LAB_08001bc2;\n    }\n    if (tickStart == 5) {\n      _DAT_40021020 = _DAT_40021020 | 4;\n      goto LAB_08001e1a;\n    }\n    _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n  }\n  tickStart = HAL_GetTick();\n  while (-1 < (int)((_DAT_40021020 >> 1) << 0x1f)) {\n    tickEnd = HAL_GetTick();\n    if (5000 < tickEnd - tickStart) {\n      return HAL_TIMEOUT;\n    }\n  }\nLAB_08001bc2:\n  tickStart = (clockConfig->PLL).PLLState;\n  if (tickStart == 0) {\n    return HAL_OK;\n  }\n  if ((_DAT_40021004 & 0xc) != 8) {\n    if (tickStart != 2) {\n      uRam42420060 = 0;\n      tickStart = HAL_GetTick();\n      do {\n        if (-1 < (int)((_DAT_40021000 >> 0x19) << 0x1f)) {\n          return HAL_OK;\n        }\n        tickEnd = HAL_GetTick();\n      } while (tickEnd - tickStart < 3);\n      return HAL_TIMEOUT;\n    }\n    uRam42420060 = 0;\n    tickStart = HAL_GetTick();\n    do {\n      if (-1 < (int)((_DAT_40021000 >> 0x19) << 0x1f)) {\n        pllSource = (clockConfig->PLL).PLLSource;\n        if (pllSource == 0x10000) {\n          _DAT_40021004 = _DAT_40021004 & 0xfffdffff | clockConfig->HSEPredivValue;\n        }\n        _DAT_40021004 = pllSource | (clockConfig->PLL).PLLMUL | _DAT_40021004 & 0xffc2ffff;\n        uRam42420060 = 1;\n        tickStart = HAL_GetTick();\n        do {\n          if ((int)((_DAT_40021000 >> 0x19) << 0x1f) < 0) {\n            return HAL_OK;\n          }\n          tickEnd = HAL_GetTick();\n        } while (tickEnd - tickStart < 3);\n        return HAL_TIMEOUT;\n      }\n      tickEnd = HAL_GetTick();\n    } while (tickEnd - tickStart < 3);\n    return HAL_TIMEOUT;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08001b58": "initialize_clock_configuration_08001b58",
                "RCC_OscInitStruct": "clockConfig",
                "uVar1": "tickStart",
                "uVar2": "tickEnd",
                "uVar3": "pllSource",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002008": {
            "entrypoint": "0x08002008",
            "current_name": "calculate_system_clock_frequency_08002008",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateSystemClockFrequency_08002008(void)\n\n{\n  undefined4 pllMulFactor;\n  uint32_t systemClockFrequency;\n  undefined4 predivFactor;\n  undefined4 *pllConfigPointer;\n  uint systemClockMultiplier;\n  undefined4 *pllMulFactorTable;\n  uint8_t predivFactorTable [2];\n  uint8_t pllMulFactorTable [16];\n  \n  pllConfigPointer = &DAT_080072f0;\n  pllMulFactorTable = (undefined4 *)pllMulFactorTable;\n  do {\n    pllMulFactor = *pllConfigPointer;\n    predivFactor = pllConfigPointer[1];\n    pllConfigPointer = pllConfigPointer + 2;\n    *pllMulFactorTable = pllMulFactor;\n    pllMulFactorTable[1] = predivFactor;\n    pllMulFactorTable = pllMulFactorTable + 2;\n  } while (pllConfigPointer != (undefined4 *)\"../Src/MPU9250.c\");\n  predivFactorTable[0] = '\\x01';\n  predivFactorTable[1] = '\\x02';\n  if ((_DAT_40021004 & 0xc) == 8) {\n    if ((int)(_DAT_40021004 << 0xf) < 0) {\n      systemClockMultiplier = 8000000 / predivFactorTable[(_DAT_40021004 & 0x20000) >> 0x11];\n    }\n    else {\n      systemClockMultiplier = 4000000;\n    }\n    systemClockFrequency = systemClockMultiplier * pllMulFactorTable[(_DAT_40021004 & 0x3c0000) >> 0x12];\n  }\n  else {\n    systemClockFrequency = 8000000;\n  }\n  return systemClockFrequency;\n}\n\n",
            "renaming": {
                "FUN_08002008": "calculate_system_clock_frequency_08002008",
                "uVar1": "pllMulFactor",
                "uVar2": "systemClockFrequency",
                "uVar3": "predivFactor",
                "puVar4": "pllConfigPointer",
                "uVar5": "systemClockMultiplier",
                "puVar6": "pllMulFactorTable",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllMulFactorTable"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800209c": {
            "entrypoint": "0x0800209c",
            "current_name": "configure_clocks_0800209c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureClocks_0800209c(RCC_ClkInitTypeDef *clockConfig,uint32_t flashLatency)\n\n{\n  char conditionVar1;\n  char conditionVar2;\n  uint32_t sysClockFreq;\n  uint32_t tickCount;\n  uint sysclkSource;\n  \n  if ((flashLatency <= (_DAT_40022000 & 7)) ||\n     (_DAT_40022000 = _DAT_40022000 & 0xfffffff8 | flashLatency, flashLatency == (flashLatency & 7))) {\n    if ((int)(clockConfig->ClockType << 0x1e) < 0) {\n      _DAT_40021004 = _DAT_40021004 & 0xffffff0f | clockConfig->AHBCLKDivider;\n    }\n    if (-1 < (int)(clockConfig->ClockType << 0x1f)) {\nLAB_080020ba:\n      if ((flashLatency < (_DAT_40022000 & 7)) &&\n         (_DAT_40022000 = _DAT_40022000 & 0xfffffff8 | flashLatency, flashLatency != (flashLatency & 7))) {\n        return HAL_ERROR;\n      }\n      if ((clockConfig->ClockType & 4) != 0) {\n        _DAT_40021004 = _DAT_40021004 & 0xfffff8ff | clockConfig->APB1CLKDivider;\n      }\n      if ((int)(clockConfig->ClockType << 0x1c) < 0) {\n        _DAT_40021004 = _DAT_40021004 & 0xffffc7ff | clockConfig->APB2CLKDivider << 3;\n      }\n      sysClockFreq = HAL_RCC_GetSysClockFreq();\n      SystemCoreClock = sysClockFreq >> \"\"[(_DAT_40021004 & 0xf0) >> 4];\n      HAL_InitTick(0);\n      return HAL_OK;\n    }\n    sysclkSource = clockConfig->SYSCLKSource;\n    if (sysclkSource == 1) {\n      conditionVar2 = '\\x01';\n      conditionVar1 = '\\0';\n    }\n    else {\n      if (sysclkSource == 2) goto LAB_08002176;\n      conditionVar2 = '\\0';\n      conditionVar1 = '\\x01';\n    }\n    if ((int)((_DAT_40021000 >>\n              (LZCOUNT((uint)(byte)(conditionVar1 << 6) << 0x18 | (uint)(byte)(conditionVar2 << 6) << 8) & 0x1fU))\n             << 0x1f) < 0) {\nLAB_08002176:\n      _DAT_40021004 = _DAT_40021004 & 0xfffffffc | sysclkSource;\n      sysClockFreq = HAL_GetTick();\n      if (clockConfig->SYSCLKSource == 1) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 4) goto LAB_080020ba;\n          tickCount = HAL_GetTick();\n        } while (tickCount - sysClockFreq < 0x1389);\n      }\n      else if (clockConfig->SYSCLKSource == 2) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 8) goto LAB_080020ba;\n          tickCount = HAL_GetTick();\n        } while (tickCount - sysClockFreq < 0x1389);\n      }\n      else {\n        do {\n          if ((_DAT_40021004 & 0xc) == 0) goto LAB_080020ba;\n          tickCount = HAL_GetTick();\n        } while (tickCount - sysClockFreq < 0x1389);\n      }\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_0800209c": "configure_clocks_0800209c",
                "RCC_ClkInitStruct": "clockConfig",
                "FLatency": "flashLatency",
                "cVar1": "conditionVar1",
                "cVar2": "conditionVar2",
                "uVar3": "sysClockFreq",
                "uVar4": "tickCount",
                "uVar5": "sysclkSource"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_GetTick",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002214": {
            "entrypoint": "0x08002214",
            "current_name": "get_system_core_clock_08002214",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_08002214(void)\n\n{\n  return systemCoreClock;\n}\n\n",
            "renaming": {
                "FUN_08002214": "get_system_core_clock_08002214",
                "SystemCoreClock": "systemCoreClock"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002220": {
            "entrypoint": "0x08002220",
            "current_name": "get_clock_divider_08002220",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getClockDivider_08002220(void)\n\n{\n  return systemClock >> \"\"[(_DAT_40021004 & 0x700) >> 8];\n}\n\n",
            "renaming": {
                "FUN_08002220": "get_clock_divider_08002220",
                "SystemCoreClock": "systemClock"
            },
            "calling": [
                "HAL_I2C_Init",
                "UART_SetConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002250": {
            "entrypoint": "0x08002250",
            "current_name": "get_clock_frequency_08002250",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getClockFrequency_08002250(void)\n\n{\n  return clockFrequency >> \"\"[(_DAT_40021004 & 0x3800) >> 0xb];\n}\n\n",
            "renaming": {
                "FUN_08002250": "get_clock_frequency_08002250",
                "SystemCoreClock": "clockFrequency"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002280": {
            "entrypoint": "0x08002280",
            "current_name": "configure_output_compare_08002280",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureOutputCompare_08002280(timerTypeDef *timer,TIM_OC_InitTypeDef *outputCompareConfig)\n\n{\n  uint32_t ccerValue;\n  uint32_t cr2Value;\n  uint ocMode;\n  \n  timer->CCER = timer->CCER & 0xfffffffe;\n  cr2Value = timer->CR2;\n  ocMode = outputCompareConfig->OCMode;\n  ccerValue = timer->CCER & 0xfffffffd | outputCompareConfig->OCPolarity;\n  if (timer == (timerTypeDef *)0x40012c00) {\n    ccerValue = (ccerValue & 0xfffffff7 | outputCompareConfig->OCNPolarity) & 0xfffffffb;\n    cr2Value = cr2Value & 0xfffffcff | outputCompareConfig->OCIdleState | outputCompareConfig->OCNIdleState;\n  }\n  timer->CR2 = cr2Value;\n  timer->CCMR1 = timer->CCMR1 & 0xffffff8c | ocMode;\n  timer->CCR1 = outputCompareConfig->Pulse;\n  timer->CCER = ccerValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002280": "configure_output_compare_08002280",
                "TIMx": "timer",
                "OC_Config": "outputCompareConfig",
                "uVar1": "ccerValue",
                "uVar2": "cr2Value",
                "uVar3": "ocMode",
                "TIM_TypeDef": "timerTypeDef"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080022d0": {
            "entrypoint": "0x080022d0",
            "current_name": "configure_timer_output_channel_080022d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerOutputChannel_080022d0(timerTypeDef *timer,TIM_OC_InitTypeDef *outputChannelConfig)\n\n{\n  uint32_t ccerValue;\n  uint32_t cr2Value;\n  uint ocMode;\n  \n  timer->CCER = timer->CCER & 0xfffffeff;\n  cr2Value = timer->CR2;\n  ocMode = outputChannelConfig->OCMode;\n  ccerValue = timer->CCER & 0xfffffdff | outputChannelConfig->OCPolarity << 8;\n  if (timer == (timerTypeDef *)0x40012c00) {\n    ccerValue = (ccerValue & 0xfffff7ff | outputChannelConfig->OCNPolarity << 8) & 0xfffffbff;\n    cr2Value = cr2Value & 0xffffcfff | (outputChannelConfig->OCIdleState | outputChannelConfig->OCNIdleState) << 4;\n  }\n  timer->CR2 = cr2Value;\n  timer->CCMR2 = timer->CCMR2 & 0xffffff8c | ocMode;\n  timer->CCR3 = outputChannelConfig->Pulse;\n  timer->CCER = ccerValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080022d0": "configure_timer_output_channel_080022d0",
                "TIMx": "timer",
                "OC_Config": "outputChannelConfig",
                "uVar1": "ccerValue",
                "uVar2": "cr2Value",
                "uVar3": "ocMode",
                "TIM_TypeDef": "timerTypeDef"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002324": {
            "entrypoint": "0x08002324",
            "current_name": "configure_timer_08002324",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimer_08002324(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputConfig)\n\n{\n  uint32_t controlReg1;\n  uint32_t mode;\n  uint32_t polarity;\n  uint32_t idleState;\n  \n  timer->CCER = timer->CCER & 0xffffefff;\n  controlReg1 = timer->CR2;\n  mode = outputConfig->OCMode;\n  polarity = outputConfig->OCPolarity;\n  idleState = 0x40012c00;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    idleState = outputConfig->OCIdleState;\n    controlReg1 = controlReg1 & 0xffffbfff;\n  }\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    controlReg1 = controlReg1 | idleState << 6;\n  }\n  timer->CR2 = controlReg1;\n  timer->CCMR2 = timer->CCMR2 & 0xffff8cff | mode << 8;\n  timer->CCR4 = outputConfig->Pulse;\n  timer->CCER = timer->CCER & 0xffffdfff | polarity << 0xc;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002324": "configure_timer_08002324",
                "TIMx": "timer",
                "OC_Config": "outputConfig",
                "uVar1": "controlReg1",
                "uVar2": "mode",
                "uVar3": "polarity",
                "uVar4": "idleState"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002368": {
            "entrypoint": "0x08002368",
            "current_name": "initialize_timer_08002368",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimer_08002368(TIM_TypeDef *timer,TIM_Base_InitTypeDef *config)\n\n{\n  uint32_t tempVar;\n  \n  tempVar = timer->CR1;\n  if (((((timer == (TIM_TypeDef *)0x40012c00) || (timer == (TIM_TypeDef *)0x40000000)) ||\n       (timer == (TIM_TypeDef *)0x40000400)) || (timer == (TIM_TypeDef *)0x40000800)) &&\n     (((tempVar = tempVar & 0xffffff8f | config->CounterMode, timer == (TIM_TypeDef *)0x40012c00 ||\n       (timer == (TIM_TypeDef *)0x40000000)) ||\n      ((timer == (TIM_TypeDef *)0x40000400 || (timer == (TIM_TypeDef *)0x40000800)))))) {\n    tempVar = tempVar & 0xfffffcff | config->ClockDivision;\n  }\n  timer->CR1 = tempVar;\n  timer->ARR = config->Period;\n  timer->PSC = config->Prescaler;\n  tempVar = 0x40012c00;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    tempVar = config->RepetitionCounter;\n  }\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    timer->RCR = tempVar;\n  }\n  timer->EGR = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002368": "initialize_timer_08002368",
                "TIMx": "timer",
                "Structure": "config",
                "uVar1": "tempVar"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080023d0": {
            "entrypoint": "0x080023d0",
            "current_name": "initialize_tim_080023d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeTim_080023d0(TIM_HandleTypeDef *timer)\n\n{\n  if (timer != (TIM_HandleTypeDef *)0x0) {\n    if (timer->State == resetState) {\n      timer->Lock = unlocked;\n      initializePwm(timer);\n    }\n    timer->State = busyState;\n    setTimerConfig(timer->Instance,&timer->Init);\n    timer->State = readyState;\n    return success;\n  }\n  return error;\n}\n\n",
            "renaming": {
                "FUN_080023d0": "initialize_tim_080023d0",
                "htim": "timer",
                "HAL_TIM_STATE_RESET": "resetState",
                "HAL_UNLOCKED": "unlocked",
                "HAL_TIM_PWM_MspInit": "initializePwm",
                "HAL_TIM_STATE_BUSY": "busyState",
                "TIM_Base_SetConfig": "setTimerConfig",
                "HAL_TIM_STATE_READY": "readyState",
                "HAL_OK": "success",
                "HAL_ERROR": "error"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "TIM_Base_SetConfig",
                "HAL_TIM_PWM_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002404": {
            "entrypoint": "0x08002404",
            "current_name": "configure_timer_output_compare_08002404",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerOutputCompare_08002404(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputCompareConfig)\n\n{\n  uint32_t ccerValue;\n  uint32_t cr2Value;\n  uint32_t ocModeValue;\n  \n  timer->CCER = timer->CCER & 0xffffffef;\n  cr2Value = timer->CR2;\n  ocModeValue = outputCompareConfig->OCMode;\n  ccerValue = timer->CCER & 0xffffffdf | outputCompareConfig->OCPolarity << 4;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    ccerValue = (ccerValue & 0xffffff7f | outputCompareConfig->OCNPolarity << 4) & 0xffffffbf;\n    cr2Value = cr2Value & 0xfffff3ff | (outputCompareConfig->OCIdleState | outputCompareConfig->OCNIdleState) << 2;\n  }\n  timer->CR2 = cr2Value;\n  timer->CCMR1 = timer->CCMR1 & 0xffff8cff | ocModeValue << 8;\n  timer->CCR2 = outputCompareConfig->Pulse;\n  timer->CCER = ccerValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002404": "configure_timer_output_compare_08002404",
                "TIMx": "timer",
                "OC_Config": "outputCompareConfig",
                "uVar1": "ccerValue",
                "uVar2": "cr2Value",
                "uVar3": "ocModeValue"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800245c": {
            "entrypoint": "0x0800245c",
            "current_name": "configure_tim_channel_0800245c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureTimChannel_0800245c(TIM_HandleTypeDef *timHandle,TIM_OC_InitTypeDef *channelConfig,uint32_t channel)\n\n{\n  int extra1;\n  int extra2;\n  int extra3;\n  uint value1;\n  int extra4;\n  int value2;\n  uint32_t newValue;\n  TIM_TypeDef *timInstance;\n  \n  if (timHandle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  timHandle->State = HAL_TIM_STATE_BUSY;\n  timHandle->Lock = HAL_LOCKED;\n  switch(channel) {\n  case 0:\n    TIM_OC1_SetConfig(timHandle->Instance,channelConfig);\n    timInstance = timHandle->Instance;\n    value1 = *(uint *)(extra1 + 0x10);\n    timInstance->CCMR1 = timInstance->CCMR1 | 8;\n    timInstance->CCMR1 = timInstance->CCMR1 & 0xfffffffb;\n    newValue = timInstance->CCMR1 | value1;\n    break;\n  default:\n    goto switchD_0800247a_caseD_1;\n  case 4:\n    TIM_OC2_SetConfig(timHandle->Instance,channelConfig);\n    timInstance = timHandle->Instance;\n    value2 = *(int *)(extra2 + 0x10);\n    timInstance->CCMR1 = timInstance->CCMR1 | 0x800;\n    timInstance->CCMR1 = timInstance->CCMR1 & 0xfffffbff;\n    newValue = timInstance->CCMR1 | value2 << 8;\n    break;\n  case 8:\n    TIM_OC3_SetConfig(timHandle->Instance,channelConfig);\n    timInstance = timHandle->Instance;\n    value1 = *(uint *)(extra3 + 0x10);\n    timInstance->CCMR2 = timInstance->CCMR2 | 8;\n    timInstance->CCMR2 = timInstance->CCMR2 & 0xfffffffb;\n    newValue = timInstance->CCMR2 | value1;\n    goto LAB_080024fa;\n  case 0xc:\n    TIM_OC4_SetConfig(timHandle->Instance,channelConfig);\n    timInstance = timHandle->Instance;\n    value2 = *(int *)(extra4 + 0x10);\n    timInstance->CCMR2 = timInstance->CCMR2 | 0x800;\n    timInstance->CCMR2 = timInstance->CCMR2 & 0xfffffbff;\n    newValue = timInstance->CCMR2 | value2 << 8;\nLAB_080024fa:\n    timInstance->CCMR2 = newValue;\n    goto switchD_0800247a_caseD_1;\n  }\n  timInstance->CCMR1 = newValue;\nswitchD_0800247a_caseD_1:\n  timHandle->State = HAL_TIM_STATE_READY;\n  timHandle->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800245c": "configure_tim_channel_0800245c",
                "htim": "timHandle",
                "sConfig": "channelConfig",
                "Channel": "channel",
                "extraout_r1": "extra1",
                "extraout_r1_00": "extra2",
                "extraout_r1_01": "extra3",
                "extraout_r1_02": "extra4",
                "uVar1": "value1",
                "iVar2": "value2",
                "uVar3": "newValue",
                "pTVar4": "timInstance"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC2_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002520": {
            "entrypoint": "0x08002520",
            "current_name": "set_channel_state_08002520",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setChannelState_08002520(TIM_TypeDef *timer,uint32_t channel,uint32_t state)\n\n{\n  timer->CCER = timer->CCER & ~(1 << (channel & 0xff));\n  timer->CCER = state << (channel & 0xff) | timer->CCER;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002520": "set_channel_state_08002520",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "state"
            },
            "calling": [
                "HAL_TIM_PWM_Start"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002538": {
            "entrypoint": "0x08002538",
            "current_name": "configure_timer_channel_08002538",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureTimerChannel_08002538(TIM_HandleTypeDef *timerHandle,uint32_t channelNumber)\n\n{\n  uint32_t initialValue;\n  TIM_TypeDef *timerInstance;\n  \n  TIM_CCxchannelNumberCmd(timerHandle->Instance,channelNumber,1);\n  timerInstance = timerHandle->Instance;\n  initialValue = 0x40012c00;\n  if (timerInstance == (TIM_TypeDef *)0x40012c00) {\n    initialValue = uRam40012c44 | 0x8000;\n  }\n  if (timerInstance == (TIM_TypeDef *)0x40012c00) {\n    timerInstance->BDTR = initialValue;\n  }\n  timerInstance->CR1 = timerInstance->CR1 | 1;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002538": "configure_timer_channel_08002538",
                "htim": "timerHandle",
                "Channel": "channelNumber",
                "uVar1": "initialValue",
                "pTVar2": "timerInstance"
            },
            "calling": [
                "PWM_Init"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002564": {
            "entrypoint": "0x08002564",
            "current_name": "configure_break_dead_time_08002564",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nconfigureBreakDeadTime_08002564(TIM_HandleTypeDef *timer,TIM_BreakDeadTimeConfigTypeDef *config)\n\n{\n  HAL_StatusTypeDef status;\n  \n  status = HAL_BUSY;\n  if (timer->Lock != HAL_LOCKED) {\n    timer->State = HAL_TIM_STATE_BUSY;\n    timer->Instance->BDTR =\n         config->OffStateRunMode | config->OffStateIDLEMode |\n         config->LockLevel | config->DeadTime |\n         config->BreakState | config->BreakPolarity |\n         config->AutomaticOutput;\n    timer->State = HAL_TIM_STATE_READY;\n    status = HAL_OK;\n    timer->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002564": "configure_break_dead_time_08002564",
                "htim": "timer",
                "sBreakDeadTimeConfig": "config",
                "HVar1": "status"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025a4": {
            "entrypoint": "0x080025a4",
            "current_name": "configure_master_080025a4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureMaster_080025a4(TIM_HandleTypeDef *timerHandle,TIM_MasterConfigTypeDef *masterConfig)\n\n{\n  uint masterSlaveMode;\n  HAL_StatusTypeDef status;\n  TIM_TypeDef *timerInstance;\n  uint masterOutputTrigger;\n  \n  status = HAL_BUSY;\n  if (timerHandle->Lock != HAL_LOCKED) {\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    timerInstance = timerHandle->Instance;\n    masterOutputTrigger = masterConfig->MasterOutputTrigger;\n    masterSlaveMode = masterConfig->MasterSlaveMode;\n    timerInstance->CR2 = timerInstance->CR2 & 0xffffff8f;\n    timerInstance->CR2 = timerInstance->CR2 | masterOutputTrigger;\n    timerInstance->SMCR = timerInstance->SMCR & 0xffffff7f;\n    timerInstance->SMCR = timerInstance->SMCR | masterSlaveMode;\n    timerHandle->State = HAL_TIM_STATE_READY;\n    status = HAL_OK;\n    timerHandle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080025a4": "configure_master_080025a4",
                "htim": "timerHandle",
                "sMasterConfig": "masterConfig",
                "HVar2": "status",
                "pTVar3": "timerInstance",
                "uVar1": "masterSlaveMode",
                "uVar4": "masterOutputTrigger"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025e8": {
            "entrypoint": "0x080025e8",
            "current_name": "configure_uart_080025e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureUART_080025e8(UART_HandleTypeDef *uartHandle)\n\n{\n  uint32_t pclkFreq;\n  uint32_t tmpVar;\n  uint parity;\n  int baudRateDivisor;\n  uint32_t baudRate;\n  int baudError;\n  USART_TypeDef *usartInstance;\n  \n  usartInstance = uartHandle->Instance;\n  parity = (uartHandle->Init).Parity;\n  usartInstance->CR2 = usartInstance->CR2 & 0xffffcfff | (uartHandle->Init).StopBits;\n  usartInstance->CR1 = (uartHandle->Init).WordLength | parity | (uartHandle->Init).Mode | usartInstance->CR1 & 0xffffe9f3;\n  usartInstance->CR3 = usartInstance->CR3 & 0xfffffcff | (uartHandle->Init).HwFlowCtl;\n  if (usartInstance == (USART_TypeDef *)0x40013800) {\n    pclkFreq = getPCLK2Frequency();\n    baudRateDivisor = (int)(((ulonglong)(pclkFreq * 0x19) / (ulonglong)((uartHandle->Init).BaudRate << 2)) / 100);\n    pclkFreq = getPCLK2Frequency();\n    baudRate = (uartHandle->Init).BaudRate;\n    tmpVar = getPCLK2Frequency();\n    baudError = (pclkFreq * 0x19) / (baudRate << 2) +\n            (int)(((ulonglong)(tmpVar * 0x19) / (ulonglong)((uartHandle->Init).BaudRate << 2)) / 100) *\n            -100;\n    pclkFreq = getPCLK2Frequency();\n    parity = (pclkFreq * 0x19) / ((uartHandle->Init).BaudRate << 2);\n    pclkFreq = getPCLK2Frequency();\n  }\n  else {\n    pclkFreq = getPCLK1Frequency();\n    baudRateDivisor = (int)(((ulonglong)(pclkFreq * 0x19) / (ulonglong)((uartHandle->Init).BaudRate << 2)) / 100);\n    pclkFreq = getPCLK1Frequency();\n    baudRate = (uartHandle->Init).BaudRate;\n    tmpVar = getPCLK1Frequency();\n    baudError = (pclkFreq * 0x19) / (baudRate << 2) +\n            (int)(((ulonglong)(tmpVar * 0x19) / (ulonglong)((uartHandle->Init).BaudRate << 2)) / 100) *\n            -100;\n    pclkFreq = getPCLK1Frequency();\n    parity = (pclkFreq * 0x19) / ((uartHandle->Init).BaudRate << 2);\n    pclkFreq = getPCLK1Frequency();\n  }\n  usartInstance->BRR = (((parity + (int)(((ulonglong)(pclkFreq * 0x19) /\n                                 (ulonglong)((uartHandle->Init).BaudRate << 2)) / 100) * -100) * 0x10 +\n                 0x32) / 100 & 0xf | (baudError * 0x10 + 0x32U) / 100 & 0xf0) + baudRateDivisor * 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080025e8": "configure_uart_080025e8",
                "pUVar7": "usartInstance",
                "huart": "uartHandle",
                "uVar1": "pclkFreq",
                "uVar2": "tmpVar",
                "uVar3": "parity",
                "iVar4": "baudRateDivisor",
                "uVar5": "baudRate",
                "iVar6": "baudError",
                "HAL_RCC_GetPCLK2Freq": "getPCLK2Frequency",
                "HAL_RCC_GetPCLK1Freq": "getPCLK1Frequency"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002724": {
            "entrypoint": "0x08002724",
            "current_name": "initialize_uart_08002724",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeUART_08002724(UART_HandleTypeDef *uartHandle)\n\n{\n  USART_TypeDef *usartInstance;\n  \n  if (uartHandle != (UART_HandleTypeDef *)0x0) {\n    if (uartHandle->State == HAL_UART_STATE_RESET) {\n      uartHandle->Lock = HAL_UNLOCKED;\n      HAL_UART_MspInit(uartHandle);\n    }\n    uartHandle->State = HAL_UART_STATE_BUSY;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xffffdfff;\n    UART_SetConfig(uartHandle);\n    usartInstance = uartHandle->Instance;\n    usartInstance->CR2 = usartInstance->CR2 & 0xffffb7ff;\n    usartInstance->CR3 = usartInstance->CR3 & 0xffffffd5;\n    usartInstance->CR1 = usartInstance->CR1 | 0x2000;\n    uartHandle->ErrorCode = 0;\n    uartHandle->State = HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002724": "initialize_uart_08002724",
                "huart": "uartHandle",
                "pUVar1": "usartInstance"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800277c": {
            "entrypoint": "0x0800277c",
            "current_name": "transmit_data_0800277c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatus\ntransmitData_0800277c(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t size,uint32_t timeout)\n\n{\n  uint32_t currentTime;\n  uint32_t elapsedTime;\n  UART_State uartState;\n  USART_TypeDef *uartInstance;\n  uint16_t *tmp;\n  \n  if ((uartHandle->State == UART_STATE_READY) || (uartHandle->State == UART_STATE_BUSY_RX)) {\n    if ((data == (uint8_t *)0x0) || (size == 0)) {\n      return ERROR;\n    }\n    if (uartHandle->Lock != LOCKED) {\n      uartHandle->Lock = LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->TxXfersize = size;\n      if (uartHandle->State == UART_STATE_BUSY_RX) {\n        uartState = UART_STATE_BUSY_TX_RX;\n      }\n      else {\n        uartState = UART_STATE_BUSY_TX;\n      }\n      uartHandle->TxXferCount = size;\n      uartHandle->State = uartState;\nlabel1:\n      if (uartHandle->TxXferCount == 0) {\n        currentTime = getTick();\n        do {\n          do {\n            if ((int)(uartHandle->Instance->SR << 0x19) < 0) {\n              if (uartHandle->State == UART_STATE_BUSY_TX_RX) {\n                uartState = UART_STATE_BUSY_RX;\n              }\n              else {\n                uartState = UART_STATE_READY;\n              }\n              uartHandle->State = uartState;\n              uartHandle->Lock = UNLOCKED;\n              return OK;\n            }\n          } while (timeout == 0xffffffff);\n        } while ((timeout != 0) && (elapsedTime = getTick(), elapsedTime - currentTime <= timeout));\n      }\n      else {\n        uartHandle->TxXferCount = uartHandle->TxXferCount - 1;\n        if ((uartHandle->Init).WordLength == 0x1000) {\n          currentTime = getTick();\n          do {\n            do {\n              if ((int)(uartHandle->Instance->SR << 0x18) < 0) {\n                uartHandle->Instance->DR = *(ushort *)data & 0x1ff;\n                if ((uartHandle->Init).Parity == 0) {\n                  data = (uint8_t *)((int)data + 2);\n                }\n                else {\nlabel2:\n                  data = (uint8_t *)((int)data + 1);\n                }\n                goto label1;\n              }\n            } while (timeout == 0xffffffff);\n          } while ((timeout != 0) && (elapsedTime = getTick(), elapsedTime - currentTime <= timeout));\n        }\n        else {\n          currentTime = getTick();\n          do {\n            do {\n              if ((int)(uartHandle->Instance->SR << 0x18) < 0) {\n                uartHandle->Instance->DR = (uint)*data;\n                goto label2;\n              }\n            } while (timeout == 0xffffffff);\n          } while ((timeout != 0) && (elapsedTime = getTick(), elapsedTime - currentTime <= timeout));\n        }\n      }\n      uartInstance = uartHandle->Instance;\n      uartInstance->CR1 = uartInstance->CR1 & 0xffffff7f;\n      uartInstance->CR1 = uartInstance->CR1 & 0xffffffdf;\n      uartInstance->CR1 = uartInstance->CR1 & 0xfffffeff;\n      uartInstance->CR3 = uartInstance->CR3 & 0xfffffffe;\n      uartHandle->State = UART_STATE_READY;\n      uartHandle->Lock = UNLOCKED;\n      return TIMEOUT;\n    }\n  }\n  return BUSY;\n}\n\n",
            "renaming": {
                "FUN_0800277c": "transmit_data_0800277c",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "HVar3": "uartState",
                "pUVar4": "uartInstance",
                "HAL_UART_StateTypeDef": "UART_State",
                "HAL_StatusTypeDef": "Status",
                "HAL_UART_STATE_READY": "UART_STATE_READY",
                "HAL_UART_STATE_BUSY_RX": "UART_STATE_BUSY_RX",
                "HAL_ERROR": "ERROR",
                "HAL_LOCKED": "LOCKED",
                "HAL_UNLOCKED": "UNLOCKED",
                "HAL_UART_STATE_BUSY_TX_RX": "UART_STATE_BUSY_TX_RX",
                "HAL_UART_STATE_BUSY_TX": "UART_STATE_BUSY_TX",
                "LAB_080027c4": "label1",
                "uVar1": "currentTime",
                "uVar2": "elapsedTime",
                "HAL_GetTick": "getTick",
                "HAL_OK": "OK",
                "LAB_08002812": "label2",
                "HAL_TIMEOUT": "TIMEOUT",
                "HAL_BUSY": "BUSY"
            },
            "calling": [
                "serialWrite"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028a6": {
            "entrypoint": "0x080028a6",
            "current_name": "initialize_uart_rx_080028a6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeUartRx_080028a6(UART_HandleTypeDef *uartHandle,uint8_t *dataBuffer,uint16_t dataSize)\n\n{\n  HAL_UART_StateTypeDef uartState;\n  uint controlRegData;\n  USART_TypeDef *usartInstance;\n  \n  if ((uartHandle->State == HAL_UART_STATE_READY) || (uartHandle->State == HAL_UART_STATE_BUSY_TX)) {\n    if ((dataBuffer == (uint8_t *)0x0) || (dataSize == 0)) {\n      return HAL_ERROR;\n    }\n    if (uartHandle->Lock != HAL_LOCKED) {\n      uartHandle->Lock = HAL_LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->RxXferdataSize = dataSize;\n      uartHandle->RxXferCount = dataSize;\n      uartHandle->Lock = HAL_UNLOCKED;\n      if (uartHandle->State == HAL_UART_STATE_BUSY_TX) {\n        uartState = HAL_UART_STATE_BUSY_TX_RX;\n      }\n      else {\n        uartState = HAL_UART_STATE_BUSY_RX;\n      }\n      usartInstance = uartHandle->Instance;\n      uartHandle->State = uartState;\n      controlRegData = usartInstance->CR1;\n      uartHandle->pRxBuffPtr = dataBuffer;\n      usartInstance->CR1 = controlRegData | 0x100;\n      usartInstance->CR3 = usartInstance->CR3 | 1;\n      usartInstance->CR1 = usartInstance->CR1 | 0x20;\n      return HAL_OK;\n    }\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_080028a6": "initialize_uart_rx_080028a6",
                "huart": "uartHandle",
                "pData": "dataBuffer",
                "Size": "dataSize",
                "HVar1": "uartState",
                "uVar2": "controlRegData",
                "pUVar3": "usartInstance"
            },
            "calling": [
                "HAL_UART_RxCpltCallback",
                "serialBegin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800290a": {
            "entrypoint": "0x0800290a",
            "current_name": "FUNC_0800290a",
            "code": "\nvoid FUNC_0800290a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800290a": "FUNC_0800290a"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800290c": {
            "entrypoint": "0x0800290c",
            "current_name": "process_received_data_0800290c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef processReceivedData_0800290c(UART_HandleTypeDef *uartHandle)\n\n{\n  uint32_t parity;\n  byte dataByte;\n  USART_TypeDef *uartInstance;\n  uint16_t remainingCount;\n  ushort *rxBufferPtr;\n  uint16_t *tmp;\n  ushort *nextBufferPtr;\n  bool isIdle;\n  \n  if ((uartHandle->State & 0xef) != 0x22) {\n    return HAL_BUSY;\n  }\n  parity = (uartHandle->Init).Parity;\n  uartInstance = uartHandle->Instance;\n  rxBufferPtr = (ushort *)uartHandle->pRxBuffPtr;\n  if ((uartHandle->Init).WordLength == 0x1000) {\n    if (parity == 0) {\n      nextBufferPtr = rxBufferPtr + 1;\n      *rxBufferPtr = (ushort)((uartInstance->DR << 0x17) >> 0x17);\n    }\n    else {\n      nextBufferPtr = (ushort *)((int)rxBufferPtr + 1);\n      *rxBufferPtr = (ushort)uartInstance->DR & 0xff;\n    }\n    uartHandle->pRxBuffPtr = (uint8_t *)nextBufferPtr;\n  }\n  else {\n    if (parity == 0) {\n      dataByte = (byte)uartInstance->DR;\n      uartHandle->pRxBuffPtr = (uint8_t *)((int)rxBufferPtr + 1);\n    }\n    else {\n      parity = uartInstance->DR;\n      uartHandle->pRxBuffPtr = (uint8_t *)((int)rxBufferPtr + 1);\n      dataByte = (byte)parity & 0x7f;\n    }\n    *(byte *)rxBufferPtr = dataByte;\n  }\n  remainingCount = uartHandle->RxXferCount - 1;\n  uartHandle->RxXferCount = remainingCount;\n  if (remainingCount == 0) {\n    uartInstance = uartHandle->Instance;\n    uartInstance->CR1 = uartInstance->CR1 & 0xffffffdf;\n    isIdle = uartHandle->State != HAL_UART_STATE_BUSY_TX_RX;\n    if (isIdle) {\n      parity = uartInstance->CR1 & 0xfffffeff;\n    }\n    else {\n      uartInstance = (USART_TypeDef *)0x12;\n      parity = 0x32;\n    }\n    if (isIdle) {\n      uartInstance->CR1 = parity;\n      parity = uartInstance->CR3 & 0xfffffffe;\n    }\n    if (isIdle) {\n      uartInstance->CR3 = parity;\n      uartInstance = (USART_TypeDef *)0x1;\n    }\n    uartHandle->State = (HAL_UART_StateTypeDef)uartInstance;\n    HAL_UART_RxCpltCallback(uartHandle);\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800290c": "process_received_data_0800290c",
                "huart": "uartHandle",
                "uVar1": "parity",
                "bVar2": "dataByte",
                "pUVar3": "uartInstance",
                "uVar4": "remainingCount",
                "puVar5": "rxBufferPtr",
                "puVar6": "nextBufferPtr",
                "bVar7": "isIdle"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002998": {
            "entrypoint": "0x08002998",
            "current_name": "FUNC_08002998",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002998(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002998": "FUNC_08002998"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800299a": {
            "entrypoint": "0x0800299a",
            "current_name": "handle_uart_interrupt_0800299a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleUartInterrupt_0800299a(UART_HandleTypeDef *uartHandle)\n\n{\n  uint srReg;\n  uint32_t cr1its;\n  uint16_t tempVar;\n  uint cr2Reg;\n  uint32_t intStatusFlags;\n  ushort *txBufferPtr;\n  uint16_t *tmpPtr;\n  HAL_UART_StateTypeDef uartState;\n  USART_TypeDef *uartInstance;\n  uint32_t errorFlag;\n  uint32_t cr3its;\n  uint cr3Flag;\n  bool errorDetected;\n  \n  uartInstance = uartHandle->Instance;\n  cr2Reg = uartInstance->SR;\n  srReg = uartInstance->CR1;\n  if ((cr2Reg & 0xf) == 0) {\n    if (((int)(cr2Reg << 0x1a) < 0) && ((int)(srReg << 0x1a) < 0)) {\n      UART_Receive_IT(uartHandle);\n      return;\n    }\n  }\n  else {\n    cr3Flag = uartInstance->CR3 & 1;\n    if ((cr3Flag != 0) || ((srReg & 0x120) != 0)) {\n      errorFlag = cr2Reg << 0x1f;\n      if ((int)errorFlag < 0) {\n        errorDetected = (int)(srReg << 0x17) < 0;\n        if (errorDetected) {\n          errorFlag = uartHandle->ErrorCode | 1;\n        }\n        if (errorDetected) {\n          uartHandle->ErrorCode = errorFlag;\n        }\n      }\n      if (((int)(cr2Reg << 0x1d) < 0) && (cr3Flag != 0)) {\n        uartHandle->ErrorCode = uartHandle->ErrorCode | 2;\n      }\n      if (((int)(cr2Reg << 0x1e) < 0) && (cr3Flag != 0)) {\n        uartHandle->ErrorCode = uartHandle->ErrorCode | 4;\n      }\n      if (((int)(cr2Reg << 0x1c) < 0) && (cr3Flag != 0)) {\n        uartHandle->ErrorCode = uartHandle->ErrorCode | 8;\n      }\n      if (uartHandle->ErrorCode == 0) {\n        return;\n      }\n      if (((int)(cr2Reg << 0x1a) < 0) && ((int)(srReg << 0x1a) < 0)) {\n        UART_Receive_IT(uartHandle);\n      }\n      uartInstance = uartHandle->Instance;\n      if ((-1 < (int)(uartHandle->ErrorCode << 0x1c)) && ((uartInstance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(uartHandle);\n        uartHandle->ErrorCode = 0;\n        return;\n      }\n      uartInstance->CR1 = uartInstance->CR1 & 0xfffffedf;\n      uartInstance->CR3 = uartInstance->CR3 & 0xfffffffe;\n      uartHandle->State = HAL_UART_STATE_READY;\n      HAL_UART_ErrorCallback(uartHandle);\n      return;\n    }\n  }\n  if (((int)(cr2Reg << 0x18) < 0) && ((int)(srReg << 0x18) < 0)) {\n    if ((uartHandle->State & 0xdf) == 0x12) {\n      txBufferPtr = (ushort *)uartHandle->pTxBuffPtr;\n      if ((uartHandle->Init).WordLength == 0x1000) {\n        uartInstance->DR = *txBufferPtr & 0x1ff;\n        if ((uartHandle->Init).Parity == 0) {\n          txBufferPtr = txBufferPtr + 1;\n        }\n        else {\n          txBufferPtr = (ushort *)((int)txBufferPtr + 1);\n        }\n        uartHandle->pTxBuffPtr = (uint8_t *)txBufferPtr;\n      }\n      else {\n        uartHandle->pTxBuffPtr = (byte *)((int)txBufferPtr + 1);\n        uartInstance->DR = (uint)*(byte *)txBufferPtr;\n      }\n      tempVar = uartHandle->TxXferCount - 1;\n      uartHandle->TxXferCount = tempVar;\n      if (tempVar == 0) {\n        uartInstance->CR1 = uartInstance->CR1 & 0xffffff7f;\n        uartInstance->CR1 = uartInstance->CR1 | 0x40;\n        return;\n      }\n    }\n  }\n  else if (((int)(cr2Reg << 0x19) < 0) && ((int)(srReg << 0x19) < 0)) {\n    uartInstance->CR1 = uartInstance->CR1 & 0xffffffbf;\n    if (uartHandle->State == HAL_UART_STATE_BUSY_TX_RX) {\n      uartState = HAL_UART_STATE_BUSY_RX;\n    }\n    else {\n      uartState = HAL_UART_STATE_READY;\n    }\n    uartHandle->State = uartState;\n    HAL_UART_TxCpltCallback(uartHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800299a": "handle_uart_interrupt_0800299a",
                "huart": "uartHandle",
                "uVar1": "srReg",
                "uVar2": "tempVar",
                "uVar3": "cr2Reg",
                "isrflags": "intStatusFlags",
                "puVar4": "txBufferPtr",
                "tmp": "tmpPtr",
                "HVar5": "uartState",
                "pUVar6": "uartInstance",
                "uVar7": "errorFlag",
                "uVar8": "cr3Flag",
                "bVar9": "errorDetected"
            },
            "calling": [
                "USART1_IRQHandler"
            ],
            "called": [
                "HAL_UART_ErrorCallback",
                "HAL_UART_TxCpltCallback",
                "UART_Receive_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad0": {
            "entrypoint": "0x08002ad0",
            "current_name": "initialize_mpu9250_08002ad0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeMPU9250_08002ad0(void)\n\n{\n  readByteFromI2C(0xd0,0x75,\"../Src/MPU9250.c\",0x3b);\n  writeByteToI2C(0xd0,0x6b,0x80,'\\x01');\n  writeByteToI2C(0xd0,0x6b,'\\x01','\\x01');\n  writeByteToI2C(0xd0,0x6c,'\\0','\\x01');\n  writeByteToI2C(0xd0,0x19,'\\0','\\x01');\n  writeByteToI2C(0xd0,0x1d,'\\x03','\\x01');\n  writeByteToI2C(0xd0,0x1a,'\\x03','\\x01');\n  writeByteToI2C(0xd0,0x1b,'\\x10','\\x01');\n  writeByteToI2C(0xd0,0x1c,'\\b','\\x01');\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ad0": "initialize_mpu9250_08002ad0",
                "I2C_ReadByte": "readByteFromI2C",
                "I2C_WriteByte": "writeByteToI2C"
            },
            "calling": [
                "IMU_Init"
            ],
            "called": [
                "I2C_ReadByte",
                "I2C_WriteByte"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002b48": {
            "entrypoint": "0x08002b48",
            "current_name": "convert_raw_accel_to_data_08002b48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid convertRawAccelToData_08002b48(void)\n\n{\n  undefined4 yAccelFloat;\n  uint rawAccelData;\n  int yAccelRawInt;\n  int zAccelRawInt;\n  uint8_t accelRawBytes [6];\n  \n  accelRawBytes[0] = '\\0';\n  accelRawBytes[1] = '\\0';\n  accelRawBytes[2] = '\\0';\n  accelRawBytes[3] = '\\0';\n  stack0xffffffec = rawAccelData & 0xffff0000;\n  I2C_ReadByteArray(0xd0,0x3b,accelRawBytes,6,\"../Src/MPU9250.c\",0x58);\n  yAccelRawByte = CONCAT11(accelRawBytes[2],accelRawBytes[3]);\n  xAccelRawByte = CONCAT11(accelRawBytes[0],accelRawBytes[1]);\n  zAccelRawByte = CONCAT11(accelRawBytes[4],accelRawBytes[5]);\n  zAccelRawInt = (int)yAccelRawByte;\n  yAccelRawInt = (int)zAccelRawByte;\n  yAccelFloat = __floatsisf();\n  yAccelFloat = __aeabi_fmul(yAccelFloat,0x40800000);\n  xAccelData = (float)__aeabi_fmul(yAccelFloat,0x38000000);\n  yAccelFloat = __floatsisf(zAccelRawInt);\n  yAccelFloat = __aeabi_fmul(yAccelFloat,0x40800000);\n  yAccelData = (float)__aeabi_fmul(yAccelFloat,0x38000000);\n  yAccelFloat = __floatsisf(yAccelRawInt);\n  yAccelFloat = __aeabi_fmul(yAccelFloat,0x40800000);\n  zAccelData = (float)__aeabi_fmul(yAccelFloat,0x38000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002b48": "convert_raw_accel_to_data_08002b48",
                "in_r3": "rawAccelData",
                "iVar2": "yAccelRawInt",
                "iVar3": "zAccelRawInt",
                "raw_data": "accelRawBytes",
                "accelRaw.y": "yAccelRawByte",
                "accelRaw.x": "xAccelRawByte",
                "accelRaw.z": "zAccelRawByte",
                "uVar1": "yAccelFloat",
                "accelData.x": "xAccelData",
                "accelData.y": "yAccelData",
                "accelData.z": "zAccelData"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002bf0": {
            "entrypoint": "0x08002bf0",
            "current_name": "read_gyro_data_08002bf0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readGyroData_08002bf0(void)\n\n{\n  undefined4 scaledValue;\n  int rawY;\n  int rawZ;\n  uint8_t gyroRawData [6];\n  \n  gyroRawData[0] = '\\0';\n  gyroRawData[1] = '\\0';\n  gyroRawData[2] = '\\0';\n  gyroRawData[3] = '\\0';\n  gyroRawData[4] = '\\0';\n  gyroRawData[5] = '\\0';\n  readI2CData(0xd0,0x43,gyroRawData,6,\"../Src/MPU9250.c\",0x7b);\n  gyroRawValues.y = CONCAT11(gyroRawData[2],gyroRawData[3]);\n  gyroRawValues.x = CONCAT11(gyroRawData[0],gyroRawData[1]);\n  gyroRawValues.z = CONCAT11(gyroRawData[4],gyroRawData[5]);\n  rawZ = (int)gyroRawValues.y;\n  rawY = (int)gyroRawValues.z;\n  scaledValue = __floatsisf();\n  scaledValue = __aeabi_fmul(scaledValue,0x447a0000);\n  scaledValue = __aeabi_fmul(scaledValue,0x38000000);\n  gyroProcessedData.x = (float)__aeabi_fsub(scaledValue,gyroBiasValues.x);\n  scaledValue = __floatsisf(rawZ);\n  scaledValue = __aeabi_fmul(scaledValue,0x447a0000);\n  scaledValue = __aeabi_fmul(scaledValue,0x38000000);\n  gyroProcessedData.y = (float)__aeabi_fsub(scaledValue,gyroBiasValues.y);\n  scaledValue = __floatsisf(rawY);\n  scaledValue = __aeabi_fmul(scaledValue,0x447a0000);\n  scaledValue = __aeabi_fmul(scaledValue,0x38000000);\n  gyroProcessedData.z = (float)__aeabi_fsub(scaledValue,gyroBiasValues.z);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002bf0": "read_gyro_data_08002bf0",
                "raw_data": "gyroRawData",
                "gyroRaw": "gyroRawValues",
                "gyroData": "gyroProcessedData",
                "gyroBias": "gyroBiasValues",
                "uVar1": "scaledValue",
                "iVar2": "rawY",
                "iVar3": "rawZ",
                "I2C_ReadByteArray": "readI2CData"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__aeabi_fsub",
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002cb0": {
            "entrypoint": "0x08002cb0",
            "current_name": "initialize_mag_calibration_08002cb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeMagCalibration_08002cb0(void)\n\n{\n  undefined4 uVar1;\n  uint rawDataValue;\n  uint8_t rawData [3];\n  \n  rawDataValue = rawDataValue;\n  writeByteToI2C(0xd0,0x37,'\\\"','\\x01');\n  writeByteToI2C(0xd0,0x6a,'\\x01','\\x01');\n  readByteFromI2C(0x18,0,\"../Src/MPU9250.c\",0xad);\n  writeByteToI2C(0x18,0xb,'\\x01','\\x01');\n  writeByteToI2C(0x18,10,'\\0','\\x01');\n  writeByteToI2C(0x18,10,'\\x0f','\\x01');\n  readByteArrayFromI2C(0x18,0x10,rawData,3,\"../Src/MPU9250.c\",0xb6);\n  uVar1 = convertIntToFloat((rawDataValue & 0xff) - 0x80);\n  uVar1 = multiplyFloats(uVar1,0x3b800000);\n  magCalibrationX = (float)addFloats(uVar1,0x3f800000);\n  uVar1 = convertIntToFloat((rawDataValue >> 8 & 0xff) - 0x80);\n  uVar1 = multiplyFloats(uVar1,0x3b800000);\n  magCalibrationY = (float)addFloats(uVar1,0x3f800000);\n  uVar1 = convertIntToFloat(rawData[2] - 0x80);\n  uVar1 = multiplyFloats(uVar1,0x3b800000);\n  magCalibrationZ = (float)addFloats(uVar1,0x3f800000);\n  writeByteToI2C(0x18,10,'\\0','\\x01');\n  writeByteToI2C(0x18,10,'\\x16','\\x01');\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002cb0": "initialize_mag_calibration_08002cb0",
                "in_r3": "rawDataValue",
                "_rawData": "rawDataValue",
                "I2C_WriteByte": "writeByteToI2C",
                "I2C_ReadByte": "readByteFromI2C",
                "I2C_ReadByteArray": "readByteArrayFromI2C",
                "__floatsisf": "convertIntToFloat",
                "__aeabi_fmul": "multiplyFloats",
                "__addsf3": "addFloats",
                "magCalib.x": "magCalibrationX",
                "magCalib.y": "magCalibrationY",
                "magCalib.z": "magCalibrationZ"
            },
            "calling": [
                "IMU_Init"
            ],
            "called": [
                "I2C_ReadByte",
                "__addsf3",
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_WriteByte",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d88": {
            "entrypoint": "0x08002d88",
            "current_name": "update_magnetometer_data_08002d88",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateMagnetometerData_08002d88(void)\n\n{\n  float fVar1;\n  byte byteVar;\n  undefined4 uVar3;\n  undefined4 param;\n  int iVar4;\n  int iVar5;\n  int16_t magValue;\n  undefined tempVar1;\n  undefined tempVar2;\n  undefined tempVar3;\n  undefined tempVar4;\n  uint8_t overflowFlag;\n  undefined param2;\n  \n  param2 = (undefined)((uint)param >> 0x18);\n  magValue = 0;\n  tempVar1 = 0;\n  tempVar2 = 0;\n  tempVar3 = 0;\n  tempVar4 = 0;\n  overflowFlag = '\\0';\n  byteVar = readByteFromI2C(0x18,2,\"../Src/MPU9250.c\",0xd7);\n  if ((int)((uint)byteVar << 0x1f) < 0) {\n    readByteArrayFromI2C(0x18,3,(uint8_t *)&magValue,7,\"../Src/MPU9250.c\",0xda);\n    fVar1 = magnetometerResolution;\n    if ((int)((uint)overflowFlag << 0x1c) < 0) {\n      i2cErrorsCount = i2cErrorsCount + 1;\n    }\n    else {\n      rawMagnetometerY = CONCAT11(tempVar2,tempVar1);\n      rawMagnetometerZ = CONCAT11(tempVar4,tempVar3);\n      iVar5 = (int)rawMagnetometerY;\n      iVar4 = (int)rawMagnetometerZ;\n      rawMagnetometerX = magValue;\n      uVar3 = convertIntToFloat();\n      uVar3 = multiplyFloats(uVar3,fVar1);\n      uVar3 = multiplyFloats(uVar3,magnetometerCalibX);\n      uVar3 = subtractFloats(uVar3,magnetometerBiasX);\n      magnetometerDataX = (float)multiplyFloats(uVar3,magnetometerScaleX);\n      uVar3 = convertIntToFloat(iVar5);\n      uVar3 = multiplyFloats(uVar3,fVar1);\n      uVar3 = multiplyFloats(uVar3,magnetometerCalibY);\n      uVar3 = subtractFloats(uVar3,magnetometerBiasY);\n      magnetometerDataY = (float)multiplyFloats(uVar3,magnetometerScaleY);\n      uVar3 = convertIntToFloat(iVar4);\n      uVar3 = multiplyFloats(uVar3,fVar1);\n      uVar3 = multiplyFloats(uVar3,magnetometerCalibZ);\n      uVar3 = subtractFloats(uVar3,magnetometerBiasZ);\n      magnetometerDataZ = (float)multiplyFloats(uVar3,magnetometerScaleZ);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d88": "update_magnetometer_data_08002d88",
                "in_r3": "param",
                "local_28": "magValue",
                "uStack_26": "tempVar1",
                "uStack_25": "tempVar2",
                "local_24": "tempVar3",
                "local_23": "tempVar4",
                "OVF": "overflowFlag",
                "uStack_21": "param2",
                "bVar2": "byteVar",
                "I2C_ReadByte": "readByteFromI2C",
                "I2C_ReadByteArray": "readByteArrayFromI2C",
                "mRes": "magnetometerResolution",
                "msp_txf_status.i2c_errors_count": "i2cErrorsCount",
                "magRaw.y": "rawMagnetometerY",
                "magRaw.z": "rawMagnetometerZ",
                "magRaw.x": "rawMagnetometerX",
                "__floatsisf": "convertIntToFloat",
                "__aeabi_fmul": "multiplyFloats",
                "__aeabi_fsub": "subtractFloats",
                "magCalib.x": "magnetometerCalibX",
                "magBias.x": "magnetometerBiasX",
                "magScale.x": "magnetometerScaleX",
                "magCalib.y": "magnetometerCalibY",
                "magBias.y": "magnetometerBiasY",
                "magScale.y": "magnetometerScaleY",
                "magCalib.z": "magnetometerCalibZ",
                "magBias.z": "magnetometerBiasZ",
                "magScale.z": "magnetometerScaleZ",
                "magData.x": "magnetometerDataX",
                "magData.y": "magnetometerDataY",
                "magData.z": "magnetometerDataZ"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "I2C_ReadByte",
                "__aeabi_fsub",
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ea0": {
            "entrypoint": "0x08002ea0",
            "current_name": "initialize_sensor_08002ea0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSensor_08002ea0(void)\n\n{\n  initializeMPU9250();\n  initializeAK8963();\n  setMadgwickBeta(0.6);\n  setMadgwickDelta(0.0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ea0": "initialize_sensor_08002ea0",
                "MPU9250_Init": "initializeMPU9250",
                "AK8963_Init": "initializeAK8963",
                "MadgwickSetBeta": "setMadgwickBeta",
                "MadgwickSetDelta": "setMadgwickDelta"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "MPU9250_Init",
                "AK8963_Init",
                "MadgwickSetDelta",
                "MadgwickSetBeta"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ec0": {
            "entrypoint": "0x08002ec0",
            "current_name": "filter_angle_08002ec0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat filterAngle_08002ec0(void)\n\n{\n  float filteredAngle;\n  \n  filteredAngle = lowPassFilter(&angleFilter,inputAngles[1]);\n  return filteredAngle;\n}\n\n",
            "renaming": {
                "FUN_08002ec0": "filter_angle_08002ec0",
                "lpf_pitch": "angleFilter",
                "AHRS_Angle": "inputAngles",
                "fVar1": "filteredAngle"
            },
            "calling": [
                "PID_Update",
                "AHRS_ComputeAngles"
            ],
            "called": [
                "lowPassFilter"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ed4": {
            "entrypoint": "0x08002ed4",
            "current_name": "apply_low_pass_filter_08002ed4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat applyLowPassFilter_08002ed4(void)\n\n{\n  float filteredAngle;\n  \n  filteredAngle = lowPassFilter(lowPassFilterObject,inputAngle);\n  return filteredAngle;\n}\n\n",
            "renaming": {
                "FUN_08002ed4": "apply_low_pass_filter_08002ed4",
                "fVar1": "filteredAngle",
                "&lpf_roll": "lowPassFilterObject",
                "AHRS_Angle[0]": "inputAngle"
            },
            "calling": [
                "PID_Update",
                "AHRS_ComputeAngles"
            ],
            "called": [
                "lowPassFilter"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ee8": {
            "entrypoint": "0x08002ee8",
            "current_name": "calculate_adjusted_angle_08002ee8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat calculateAdjustedAngle_08002ee8(void)\n\n{\n  int comparisonResult;\n  float angle;\n  float currentAngle;\n  \n  currentAngle = angleArray[2];\n  comparisonResult = compareFloatsGreaterThanOrEqual(angleArray[2],0xc3340000);\n  if ((comparisonResult != 0) && (comparisonResult = compareFloatsLessThan(currentAngle,0x42b40000), comparisonResult != 0)) {\n    currentAngle = (float)addFloats(currentAngle,0x42b40000);\n    return currentAngle;\n  }\n  currentAngle = (float)subtractFloats(currentAngle,0x43870000);\n  return currentAngle;\n}\n\n",
            "renaming": {
                "FUN_08002ee8": "calculate_adjusted_angle_08002ee8",
                "AHRS_Angle": "angleArray",
                "iVar1": "comparisonResult",
                "fVar2": "currentAngle",
                "__aeabi_fcmpge": "compareFloatsGreaterThanOrEqual",
                "__aeabi_fcmplt": "compareFloatsLessThan",
                "__addsf3": "addFloats",
                "__aeabi_fsub": "subtractFloats"
            },
            "calling": [
                "PID_Update",
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__aeabi_fcmpge",
                "__addsf3",
                "__aeabi_fsub",
                "__aeabi_fcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f28": {
            "entrypoint": "0x08002f28",
            "current_name": "update_ahrs_data_08002f28",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateAHRSData_08002f28(void)\n\n{\n  undefined4 timeDifference;\n  float deltaTime;\n  \n  MPU9250_ReadAccelData();\n  MPU9250_ReadGyroData();\n  AK8963_ReadData();\n  AHRS_timeNow = micros();\n  timeDifference = __floatunsisf(AHRS_timeNow - AHRS_lastUpdate);\n  deltaTime = (float)__aeabi_fdiv(timeDifference,0x447a0000);\n  MadgwickSetDelta(deltaTime);\n  AHRS_lastUpdate = AHRS_timeNow;\n  MadgwickQuaternionUpdate\n            ((float)((int)accelerationData.y + -0x80000000),(float)((int)accelerationData.x + -0x80000000),\n             accelerationData.z,gyroData.y,gyroData.x,(float)((int)gyroData.z + -0x80000000),magnetometerData.x,\n             magnetometerData.y,magnetometerData.z,AHRS_Angle);\n  msp_txf_raw_imu.accx = (int16_t)((uint)(int)rawAcceleration.x / 100);\n  msp_txf_raw_imu.accz = (int16_t)((uint)(int)rawAcceleration.z / 100);\n  msp_txf_raw_imu.accy = (int16_t)((uint)(int)rawAcceleration.y / 100);\n  msp_txf_raw_imu.gyrx = rawGyro.x;\n  msp_txf_raw_imu.gyry = rawGyro.y;\n  msp_txf_raw_imu.gyrz = rawGyro.z;\n  msp_txf_raw_imu.magx = rawMagnetometer.x;\n  msp_txf_raw_imu.magy = rawMagnetometer.y;\n  msp_txf_raw_imu.magz = rawMagnetometer.z;\n  AHRS_GetRoll();\n  __aeabi_fmul();\n  msp_txf_attitude.angx = __aeabi_f2iz();\n  AHRS_GetPitch();\n  __aeabi_fmul();\n  msp_txf_attitude.angy = __aeabi_f2iz();\n  AHRS_GetYaw();\n  msp_txf_attitude.heading = __aeabi_f2iz();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f28": "update_ahrs_data_08002f28",
                "_deltat": "deltaTime",
                "uVar1": "timeDifference",
                "accelData": "accelerationData",
                "magData": "magnetometerData",
                "accelRaw": "rawAcceleration",
                "gyroRaw": "rawGyro",
                "magRaw": "rawMagnetometer"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "__aeabi_f2iz",
                "__aeabi_fdiv",
                "__aeabi_fmul",
                "MPU9250_ReadAccelData",
                "micros",
                "MPU9250_ReadGyroData",
                "AHRS_GetRoll",
                "AHRS_GetPitch",
                "MadgwickQuaternionUpdate",
                "AK8963_ReadData",
                "AHRS_GetYaw",
                "MadgwickSetDelta",
                "__floatunsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003034": {
            "entrypoint": "0x08003034",
            "current_name": "read_sensor_data_08003034",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t readSensorData_08003034(void)\n\n{\n  undefined4 inputValue;\n  uint8_t receiveBuffer [3];\n  \n  _receiveBuffer = inputValue;\n  I2C_ReadBytes(0xee,0,receiveBuffer,3,\"../Src/MS5611.c\",0x8c);\n  return (uint)CONCAT12(receiveBuffer[0],CONCAT11(receiveBuffer[1],receiveBuffer[2]));\n}\n\n",
            "renaming": {
                "FUN_08003034": "read_sensor_data_08003034",
                "in_r3": "inputValue",
                "rxbuf": "receiveBuffer"
            },
            "calling": [
                "MS5611_Update"
            ],
            "called": [
                "I2C_ReadBytes"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003068": {
            "entrypoint": "0x08003068",
            "current_name": "get_input_value_08003068",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat getInputValue_08003068(void)\n\n{\n  float inputValue;\n  \n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_08003068": "get_input_value_08003068",
                "in_s0": "inputValue"
            },
            "calling": [
                "PID_UpdateAltitude"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003078": {
            "entrypoint": "0x08003078",
            "current_name": "calculate_compensated_pressure_and_temperature_08003078",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calculateCompensatedPressureAndTemperature_08003078(void)\n\n{\n  float *pfVar1;\n  longlong lVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  undefined4 uVar6;\n  float fVar7;\n  uint32_t uVar8;\n  undefined4 extraout_r1;\n  uint uVar9;\n  undefined4 unaff_r4;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  float *pfVar13;\n  undefined4 unaff_r5;\n  undefined4 unaff_r6;\n  undefined4 unaff_r7;\n  int iVar14;\n  int32_t TEMP;\n  int iVar15;\n  int iVar16;\n  int32_t dT;\n  bool bVar17;\n  undefined8 uVar18;\n  \n  if ((isTemperatureReady != '\\0') && (isPressureReady != '\\0')) {\n    iVar16 = rawTemperature + (uint)coefficients[5] * -0x100;\n    uVar9 = (uint)((longlong)(int)(uint)coefficients[6] * (longlong)iVar16) >> 0x17 |\n            (int)((ulonglong)((longlong)(int)(uint)coefficients[6] * (longlong)iVar16) >>\n                 0x20) << 9;\n    uVar10 = (uint)((longlong)(int)(uint)coefficients[4] * (longlong)iVar16 >> 7);\n    uVar11 = uVar10 + (uint)coefficients[2] * 0x10000;\n    uVar4 = (uint)((ulonglong)((longlong)(int)(uint)coefficients[3] * (longlong)iVar16) >> 8)\n    ;\n    iVar14 = uVar9 + 2000;\n    uVar5 = uVar4 + (uint)coefficients[1] * 0x8000;\n    bVar17 = (int)uVar9 < 0;\n    if (1999 < iVar14) {\n      uVar9 = 0;\n    }\n    uVar3 = uVar9;\n    if (bVar17 != SBORROW4(iVar14,2000)) {\n      iVar15 = uVar9 * uVar9 * 5;\n      uVar9 = iVar15 >> 2;\n      uVar3 = iVar15 >> 1;\n    }\n    uVar12 = uVar11 - uVar3;\n    lVar2 = (ulonglong)(uVar5 - uVar9) * (ulonglong)rawPressure;\n    iVar15 = rawPressure *\n             ((((int)((longlong)(int)(uint)coefficients[3] * (longlong)iVar16 >> 0x28) +\n               (uint)CARRY4(uVar4,(uint)coefficients[1] * 0x8000)) - ((int)uVar9 >> 0x1f)) -\n             (uint)(uVar5 < uVar9)) + (int)((ulonglong)lVar2 >> 0x20);\n    uVar4 = (uint)lVar2 >> 0x15 | iVar15 * 0x800;\n    uVar6 = __floatsisf(uVar4 - uVar12 >> 0xf |\n                        (((iVar15 >> 0x15) -\n                         ((((int)((longlong)(int)(uint)coefficients[4] * (longlong)iVar16 >>\n                                 0x27) + (uint)CARRY4(uVar10,(uint)coefficients[2] * 0x10000)\n                           ) - ((int)uVar3 >> 0x1f)) - (uint)(uVar11 < uVar3))) -\n                        (uint)(uVar4 < uVar12)) * 0x20000);\n    fVar7 = (float)__aeabi_fdiv(uVar6,0x42c80000);\n    compensatedPressure = fVar7;\n    uVar6 = __floatsisf(iVar14);\n    compensatedTemperature = (float)__aeabi_fdiv(uVar6,0x42c80000);\n    __aeabi_fdiv(fVar7,0x447d5000);\n    uVar6 = __aeabi_f2d();\n    pow((double)CONCAT44(unaff_r5,unaff_r4),(double)CONCAT44(unaff_r7,unaff_r6));\n    uVar18 = __subdf3(0,0x3ff00000,uVar6,extraout_r1);\n    __muldf3((int)uVar18,(int)((ulonglong)uVar18 >> 0x20),0,0x40e5a540);\n    fVar7 = (float)__truncdfsf2();\n    uVar6 = 0;\n    pfVar13 = alt_filter;\n    altitude = fVar7;\n    do {\n      pfVar1 = pfVar13 + 1;\n      *pfVar13 = *pfVar1;\n      uVar6 = __addsf3(uVar6);\n      pfVar13 = pfVar1;\n    } while (pfVar1 != alt_filter + 0x13);\n    alt_filter[19] = fVar7;\n    uVar6 = __addsf3(uVar6,fVar7);\n    filteredAltitude = (float)__aeabi_fdiv(uVar6,0x41a00000);\n    iVar14 = __aeabi_f2iz();\n    estimatedAltitude = iVar14 * 100;\n    isTemperatureReady = '\\0';\n    isPressureReady = '\\0';\n    writeI2CByte(0xee,MS5611_OSR + 0x50,'\\x01','\\0');\n    temperatureStartTime = getCurrentTime();\n  }\n  uVar8 = getCurrentTime();\n  if (((10 < uVar8 - temperatureStartTime) && (isTemperatureReady == '\\0')) && (isPressureReady == '\\0')) {\n    rawTemperature = MS5611_ReadADC();\n    isTemperatureReady = '\\x01';\n    writeI2CByte(0xee,MS5611_OSR + 0x40,'\\x01','\\0');\n    pressureStartTime = getCurrentTime();\n  }\n  uVar8 = getCurrentTime();\n  if (((10 < uVar8 - pressureStartTime) && (isTemperatureReady != '\\0')) && (isPressureReady == '\\0')) {\n    rawPressure = MS5611_ReadADC();\n    isPressureReady = '\\x01';\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003078": "calculate_compensated_pressure_and_temperature_08003078",
                "MS5611_RawTemperature": "rawTemperature",
                "MS5611_Coefficients": "coefficients",
                "MS5611_RawPressure": "rawPressure",
                "MS5611_CompensatedPressure": "compensatedPressure",
                "MS5611_CompensatedTemperature": "compensatedTemperature",
                "MS5611_Altitude": "altitude",
                "MS5611_FilteredAltitude": "filteredAltitude",
                "msp_txf_altitude.est_alt": "estimatedAltitude",
                "TEMP_READY": "isTemperatureReady",
                "PRESSURE_READY": "isPressureReady",
                "I2C_WriteByte": "writeI2CByte",
                "temp_time": "temperatureStartTime",
                "pressure_time": "pressureStartTime",
                "millis": "getCurrentTime"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "__aeabi_f2d",
                "pow",
                "__truncdfsf2",
                "__aeabi_f2iz",
                "__aeabi_fdiv",
                "__addsf3",
                "__floatsisf",
                "__muldf3",
                "millis",
                "MS5611_ReadADC",
                "I2C_WriteByte",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003298": {
            "entrypoint": "0x08003298",
            "current_name": "initialize_ms5611_sensor_08003298",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd initializeMS5611Sensor_08003298(voindexd)\n\n{\n  indexnt index;\n  indexnt counter;\n  uindexnt8_t receiveBuffer [2];\n  \n  counter = 0;\n  writeByteToI2C(0xee,0x1e,'\\x01','\\x01');\n  delayMilliseconds(10);\n  OSRValue = '\\b';\n  do {\n    receiveBuffer[0] = '\\0';\n    receiveBuffer[1] = '\\0';\n    readByteArrayFromI2C(0xee,(short)counter + 0xa0,receiveBuffer,2,\"../Src/MS5611.c\",0x7c);\n    *(ushort *)((indexnt)coefficients + counter) = concatenateBytes(receiveBuffer[0],receiveBuffer[1]);\n    counter = counter + 2;\n  } whindexle (counter != 0x10);\n  counter = 0;\n  do {\n    filteredValues[counter] = 0.0;\n    counter = counter + 1;\n  } whindexle (counter != 0x14);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003298": "initialize_ms5611_sensor_08003298",
                "rxbuf": "receiveBuffer",
                "i": "index",
                "iVar1": "counter",
                "I2C_WriteByte": "writeByteToI2C",
                "delay_ms": "delayMilliseconds",
                "MS5611_OSR": "OSRValue",
                "I2C_ReadByteArray": "readByteArrayFromI2C",
                "MS5611_Coefficients": "coefficients",
                "CONCAT11": "concatenateBytes",
                "alt_filter": "filteredValues"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "delay_ms",
                "I2C_WriteByte",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003314": {
            "entrypoint": "0x08003314",
            "current_name": "set_beta_08003314",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setBeta_08003314(float newBeta)\n\n{\n  currentBeta = newBeta;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003314": "set_beta_08003314",
                "_beta": "newBeta",
                "beta": "currentBeta"
            },
            "calling": [
                "IMU_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003320": {
            "entrypoint": "0x08003320",
            "current_name": "update_delta_time_08003320",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateDeltaTime_08003320(float deltaTime)\n\n{\n  deltat = deltaTime;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003320": "update_delta_time_08003320",
                "_deltat": "deltaTime"
            },
            "calling": [
                "AHRS_ComputeAngles",
                "IMU_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003330": {
            "entrypoint": "0x08003330",
            "current_name": "calculate_orientation_angles_08003330",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calculateOrientationAngles_08003330(float accelerationX,float accelerationY,float accelerationZ,float gyroX,float gyroY,float gyroZ,float magneticX,float magneticY,float magneticZ,\n                 float *orientationAngles)\n\n{\n  float tempVar1;\n  float tempVar2;\n  undefined4 tempVar3;\n  undefined4 tempVar4;\n  float norm;\n  undefined4 tempVar5;\n  int tempVar6;\n  undefined4 tempVar7;\n  undefined4 tempVar8;\n  undefined4 tempVar9;\n  int tempVar10;\n  undefined4 tempVar11;\n  undefined4 tempVar12;\n  undefined4 tempVar13;\n  undefined4 tempVar14;\n  undefined4 tempVar15;\n  undefined4 tempVar16;\n  undefined4 tempVar17;\n  undefined4 tempVar18;\n  undefined4 tempVar19;\n  undefined4 tempVar20;\n  int tempVar21;\n  float tempVar22;\n  undefined4 tempVar23;\n  float tempVar24;\n  undefined4 tempVar25;\n  float tempVar26;\n  undefined4 tempVar27;\n  float tempVar28;\n  undefined4 tempVar29;\n  undefined4 tempVar30;\n  undefined4 tempVar31;\n  int tempVar32;\n  float tempVar33;\n  float tempVar34;\n  float tempVar35;\n  float tempVar36;\n  float tempVar37;\n  float tempVar38;\n  float tempVar39;\n  float tempVar40;\n  float tempVar41;\n  float tempVar42;\n  float quaternion1;\n  float quaternion2;\n  float quaternion4;\n  float quaternion3;\n  undefined8 tempVar43;\n  undefined8 tempVar44;\n  undefined4 tempVar45;\n  float tempVar46;\n  float tempVar47;\n  float tempVar48;\n  \n  tempVar42 = q[3];\n  tempVar41 = q[2];\n  tempVar40 = q[0];\n  tempVar46 = q[1];\n  tempVar3 = __aeabi_fmul(accelerationX,accelerationX);\n  tempVar4 = __aeabi_fmul(accelerationY);\n  tempVar3 = __addsf3(tempVar3,tempVar4);\n  tempVar4 = __aeabi_fmul(accelerationZ);\n  __addsf3(tempVar3,tempVar4);\n  __aeabi_f2d();\n  sqrt((double)CONCAT44(tempVar46,tempVar45));\n  tempVar3 = __truncdfsf2();\n  norm = (float)__aeabi_fcmpeq(tempVar3,0);\n  if (norm == 0.0) {\n    tempVar4 = __aeabi_fmul(magneticX);\n    tempVar5 = __aeabi_fmul(magneticY);\n    tempVar4 = __addsf3(tempVar4,tempVar5);\n    tempVar5 = __aeabi_fmul(magneticZ);\n    __addsf3(tempVar4,tempVar5);\n    __aeabi_f2d();\n    sqrt((double)CONCAT44(tempVar46,tempVar45));\n    tempVar4 = __truncdfsf2();\n    tempVar6 = __aeabi_fcmpeq(tempVar4,0);\n    if (tempVar6 == 0) {\n      tempVar43 = __aeabi_f2d(gyroX);\n      __muldf3((int)tempVar43,(int)((ulonglong)tempVar43 >> 0x20),0xa2529d39,0x3f91df46);\n      tempVar5 = __truncdfsf2();\n      tempVar43 = __aeabi_f2d(gyroY);\n      __muldf3((int)tempVar43,(int)((ulonglong)tempVar43 >> 0x20),0xa2529d39,0x3f91df46);\n      tempVar7 = __truncdfsf2();\n      tempVar43 = __aeabi_f2d(gyroZ);\n      __muldf3((int)tempVar43,(int)((ulonglong)tempVar43 >> 0x20),0xa2529d39,0x3f91df46);\n      tempVar8 = __truncdfsf2();\n      tempVar6 = __addsf3(tempVar40);\n      tempVar9 = __addsf3(tempVar46);\n      tempVar10 = __addsf3(tempVar41,tempVar41);\n      tempVar11 = __addsf3(tempVar42,tempVar42);\n      tempVar12 = __aeabi_fmul(tempVar40);\n      tempVar13 = __aeabi_fmul(tempVar40,tempVar46);\n      tempVar14 = __aeabi_fmul(tempVar40,tempVar41);\n      tempVar15 = __aeabi_fmul(tempVar46);\n      tempVar16 = __aeabi_fmul(tempVar46,tempVar42);\n      tempVar17 = __aeabi_fmul(tempVar41,tempVar41);\n      tempVar18 = __aeabi_fmul(tempVar42,tempVar42);\n      tempVar3 = __aeabi_fdiv(0x3f800000,tempVar3);\n      tempVar4 = __aeabi_fdiv(0x3f800000,tempVar4);\n      tempVar19 = __aeabi_fmul(magneticX,tempVar4);\n      tempVar20 = __aeabi_fmul(magneticY,tempVar4);\n      tempVar4 = __aeabi_fmul(magneticZ,tempVar4);\n      tempVar21 = __aeabi_fmul(tempVar6,tempVar19);\n      tempVar23 = __aeabi_fmul(tempVar6,tempVar20);\n      tempVar25 = __aeabi_fmul(tempVar6,tempVar4);\n      tempVar27 = __aeabi_fmul(tempVar9,tempVar19);\n      tempVar29 = __aeabi_fmul(tempVar12,tempVar19);\n      tempVar30 = __aeabi_fmul(tempVar42,tempVar23);\n      tempVar29 = __aeabi_fsub(tempVar29,tempVar30);\n      tempVar30 = __aeabi_fmul(tempVar41,tempVar25);\n      tempVar29 = __addsf3(tempVar29,tempVar30);\n      tempVar30 = __aeabi_fmul(tempVar15,tempVar19);\n      tempVar29 = __addsf3(tempVar29,tempVar30);\n      tempVar30 = __aeabi_fmul(tempVar9,tempVar20);\n      tempVar30 = __aeabi_fmul(tempVar30,tempVar41);\n      tempVar29 = __addsf3(tempVar29,tempVar30);\n      tempVar30 = __aeabi_fmul(tempVar9,tempVar4);\n      tempVar30 = __aeabi_fmul(tempVar30,tempVar42);\n      tempVar29 = __addsf3(tempVar29,tempVar30);\n      tempVar30 = __aeabi_fmul(tempVar17,tempVar19);\n      tempVar29 = __aeabi_fsub(tempVar29,tempVar30);\n      tempVar30 = __aeabi_fmul(tempVar18,tempVar19);\n      tempVar29 = __aeabi_fsub(tempVar29,tempVar30);\n      tempVar30 = __aeabi_fmul(tempVar42,tempVar21);\n      tempVar31 = __aeabi_fmul(tempVar12,tempVar20);\n      tempVar30 = __addsf3(tempVar30,tempVar31);\n      tempVar25 = __aeabi_fmul(tempVar46,tempVar25);\n      tempVar25 = __aeabi_fsub(tempVar30,tempVar25);\n      tempVar30 = __aeabi_fmul(tempVar41,tempVar27);\n      tempVar25 = __addsf3(tempVar25,tempVar30);\n      tempVar30 = __aeabi_fmul(tempVar15,tempVar20);\n      tempVar25 = __aeabi_fsub(tempVar25,tempVar30);\n      tempVar30 = __aeabi_fmul(tempVar17,tempVar20);\n      tempVar25 = __addsf3(tempVar25,tempVar30);\n      tempVar30 = __aeabi_fmul(tempVar10,tempVar4);\n      tempVar30 = __aeabi_fmul(tempVar30,tempVar42);\n      tempVar25 = __addsf3(tempVar25,tempVar30);\n      tempVar30 = __aeabi_fmul(tempVar18,tempVar20);\n      tempVar25 = __aeabi_fsub(tempVar25,tempVar30);\n      tempVar29 = __aeabi_fmul(tempVar29,tempVar29);\n      tempVar25 = __aeabi_fmul(tempVar25,tempVar25);\n      __addsf3(tempVar29,tempVar25);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(tempVar46,tempVar45));\n      tempVar32 = __truncdfsf2();\n      tempVar25 = __aeabi_fmul(tempVar21 + -0x80000000,tempVar41);\n      tempVar23 = __aeabi_fmul(tempVar46,tempVar23);\n      tempVar23 = __addsf3(tempVar25,tempVar23);\n      tempVar12 = __aeabi_fmul(tempVar12,tempVar4);\n      tempVar12 = __addsf3(tempVar23,tempVar12);\n      tempVar23 = __aeabi_fmul(tempVar42,tempVar27);\n      tempVar12 = __addsf3(tempVar12,tempVar23);\n      tempVar23 = __aeabi_fmul(tempVar15,tempVar4);\n      tempVar12 = __aeabi_fsub(tempVar12,tempVar23);\n      tempVar23 = __aeabi_fmul(tempVar10,tempVar20);\n      tempVar23 = __aeabi_fmul(tempVar23,tempVar42);\n      tempVar12 = __addsf3(tempVar12,tempVar23);\n      tempVar23 = __aeabi_fmul(tempVar17,tempVar4);\n      tempVar12 = __aeabi_fsub(tempVar12,tempVar23);\n      tempVar23 = __aeabi_fmul(tempVar18,tempVar4);\n      tempVar12 = __addsf3(tempVar12,tempVar23);\n      tempVar34 = (float)__addsf3(tempVar12,tempVar12);\n      tempVar23 = __addsf3(tempVar16);\n      tempVar25 = __aeabi_fmul(tempVar41,tempVar6);\n      tempVar23 = __aeabi_fsub(tempVar23,tempVar25);\n      tempVar25 = __aeabi_fmul(accelerationX,tempVar3);\n      tempVar23 = __aeabi_fsub(tempVar23,tempVar25);\n      tempVar25 = __aeabi_fmul(tempVar42,tempVar10);\n      tempVar27 = __addsf3(tempVar13);\n      tempVar25 = __addsf3(tempVar25,tempVar27);\n      tempVar27 = __aeabi_fmul(accelerationY,tempVar3);\n      tempVar25 = __aeabi_fsub(tempVar25,tempVar27);\n      tempVar27 = __aeabi_fmul(tempVar41,tempVar12);\n      tempVar29 = __aeabi_fsub(0x3f000000,tempVar17);\n      tempVar18 = __aeabi_fsub(tempVar29,tempVar18);\n      tempVar18 = __aeabi_fmul(tempVar18,tempVar32);\n      tempVar29 = __aeabi_fsub(tempVar16,tempVar14);\n      tempVar29 = __aeabi_fmul(tempVar29,tempVar12);\n      tempVar18 = __addsf3(tempVar18,tempVar29);\n      tempVar18 = __aeabi_fsub(tempVar18,tempVar19);\n      tempVar19 = __aeabi_fmul(tempVar46,tempVar12);\n      tempVar29 = __aeabi_fmul(tempVar46,tempVar41);\n      tempVar30 = __aeabi_fmul(tempVar40,tempVar42);\n      tempVar29 = __aeabi_fsub(tempVar29,tempVar30);\n      tempVar29 = __aeabi_fmul(tempVar29,tempVar32);\n      tempVar30 = __aeabi_fmul(tempVar41,tempVar42);\n      tempVar13 = __addsf3(tempVar30,tempVar13);\n      tempVar13 = __aeabi_fmul(tempVar13,tempVar12);\n      tempVar13 = __addsf3(tempVar29,tempVar13);\n      tempVar13 = __aeabi_fsub(tempVar13,tempVar20);\n      tempVar20 = __aeabi_fmul(tempVar41,tempVar32);\n      tempVar29 = __aeabi_fsub(0x3f000000,tempVar15);\n      tempVar29 = __aeabi_fsub(tempVar29,tempVar17);\n      tempVar29 = __aeabi_fmul(tempVar29,tempVar12);\n      tempVar14 = __addsf3(tempVar14,tempVar16);\n      tempVar14 = __aeabi_fmul(tempVar14,tempVar32);\n      tempVar14 = __addsf3(tempVar29,tempVar14);\n      tempVar4 = __aeabi_fsub(tempVar14,tempVar4);\n      tempVar14 = __aeabi_fmul(tempVar10 + -0x80000000,tempVar23);\n      tempVar16 = __aeabi_fmul(tempVar9,tempVar25);\n      tempVar14 = __addsf3(tempVar14,tempVar16);\n      tempVar16 = __aeabi_fmul(tempVar27,tempVar18);\n      tempVar14 = __aeabi_fsub(tempVar14,tempVar16);\n      tempVar16 = __aeabi_fmul(tempVar42,tempVar32 + -0x80000000);\n      tempVar16 = __addsf3(tempVar16,tempVar19);\n      tempVar16 = __aeabi_fmul(tempVar16,tempVar13);\n      tempVar14 = __addsf3(tempVar14,tempVar16);\n      tempVar16 = __aeabi_fmul(tempVar20,tempVar4);\n      tempVar14 = __addsf3(tempVar14,tempVar16);\n      tempVar15 = __addsf3(tempVar15);\n      tempVar15 = __aeabi_fsub(0x3f800000,tempVar15);\n      tempVar16 = __addsf3(tempVar17);\n      tempVar15 = __aeabi_fsub(tempVar15,tempVar16);\n      tempVar3 = __aeabi_fmul(accelerationZ,tempVar3);\n      tempVar3 = __aeabi_fsub(tempVar15,tempVar3);\n      tempVar15 = __aeabi_fmul(tempVar42,tempVar12);\n      tempVar12 = __aeabi_fmul(tempVar40,tempVar12);\n      tempVar16 = __aeabi_fmul(tempVar11,tempVar23);\n      tempVar17 = __aeabi_fmul(tempVar6,tempVar25);\n      tempVar16 = __addsf3(tempVar16,tempVar17);\n      tempVar17 = __aeabi_fmul(tempVar46,0x40800000);\n      tempVar17 = __aeabi_fmul(tempVar17,tempVar3);\n      tempVar16 = __aeabi_fsub(tempVar16,tempVar17);\n      tempVar17 = __aeabi_fmul(tempVar18,tempVar15);\n      tempVar16 = __addsf3(tempVar16,tempVar17);\n      tempVar17 = __addsf3(tempVar20,tempVar12);\n      tempVar17 = __aeabi_fmul(tempVar17,tempVar13);\n      tempVar16 = __addsf3(tempVar16,tempVar17);\n      tempVar17 = __aeabi_fmul(tempVar42,tempVar32);\n      tempVar20 = __aeabi_fmul(tempVar46,tempVar34);\n      tempVar17 = __aeabi_fsub(tempVar17,tempVar20);\n      tempVar17 = __aeabi_fmul(tempVar17,tempVar4);\n      tempVar16 = __addsf3(tempVar16,tempVar17);\n      tempVar21 = __addsf3(tempVar32,tempVar32);\n      tempVar17 = __aeabi_fmul(tempVar46,tempVar32);\n      tempVar20 = __aeabi_fmul(tempVar6 + -0x80000000,tempVar23);\n      tempVar11 = __aeabi_fmul(tempVar11,tempVar25);\n      tempVar11 = __addsf3(tempVar20,tempVar11);\n      tempVar20 = __aeabi_fmul(tempVar41,0x40800000);\n      tempVar3 = __aeabi_fmul(tempVar20,tempVar3);\n      tempVar3 = __aeabi_fsub(tempVar11,tempVar3);\n      tempVar11 = __aeabi_fmul(tempVar41,tempVar21 + -0x80000000);\n      tempVar11 = __aeabi_fsub(tempVar11,tempVar12);\n      tempVar11 = __aeabi_fmul(tempVar11,tempVar18);\n      tempVar3 = __addsf3(tempVar3,tempVar11);\n      tempVar11 = __addsf3(tempVar15,tempVar17);\n      tempVar11 = __aeabi_fmul(tempVar11,tempVar13);\n      tempVar3 = __addsf3(tempVar3,tempVar11);\n      tempVar11 = __aeabi_fmul(tempVar40,tempVar32);\n      tempVar12 = __aeabi_fmul(tempVar41,tempVar34);\n      tempVar11 = __aeabi_fsub(tempVar11,tempVar12);\n      tempVar11 = __aeabi_fmul(tempVar11,tempVar4);\n      tempVar3 = __addsf3(tempVar3,tempVar11);\n      tempVar9 = __aeabi_fmul(tempVar9,tempVar23);\n      tempVar11 = __aeabi_fmul(tempVar10,tempVar25);\n      tempVar9 = __addsf3(tempVar9,tempVar11);\n      tempVar11 = __aeabi_fmul(tempVar42,tempVar21 + -0x80000000);\n      tempVar11 = __addsf3(tempVar11,tempVar19);\n      tempVar11 = __aeabi_fmul(tempVar11,tempVar18);\n      tempVar9 = __addsf3(tempVar9,tempVar11);\n      tempVar11 = __aeabi_fmul(tempVar40,tempVar32 + -0x80000000);\n      tempVar11 = __addsf3(tempVar11,tempVar27);\n      tempVar11 = __aeabi_fmul(tempVar11,tempVar13);\n      tempVar9 = __addsf3(tempVar9,tempVar11);\n      tempVar4 = __aeabi_fmul(tempVar4,tempVar17);\n      tempVar4 = __addsf3(tempVar9,tempVar4);\n      tempVar9 = __aeabi_fmul(tempVar14);\n      tempVar11 = __aeabi_fmul(tempVar16);\n      tempVar9 = __addsf3(tempVar9,tempVar11);\n      tempVar11 = __aeabi_fmul(tempVar3,tempVar3);\n      tempVar9 = __addsf3(tempVar9,tempVar11);\n      tempVar11 = __aeabi_fmul(tempVar4,tempVar4);\n      __addsf3(tempVar9,tempVar11);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(tempVar46,tempVar45));\n      tempVar9 = __truncdfsf2();\n      tempVar9 = __aeabi_fdiv(0x3f800000,tempVar9);\n      tempVar1 = beta;\n      tempVar11 = __aeabi_fmul((int)tempVar46 + -0x80000000,tempVar5);\n      tempVar12 = __aeabi_fmul(tempVar41,tempVar7);\n      tempVar11 = __aeabi_fsub(tempVar11,tempVar12);\n      tempVar12 = __aeabi_fmul(tempVar42,tempVar8);\n      tempVar11 = __aeabi_fsub(tempVar11,tempVar12);\n      tempVar11 = __aeabi_fmul(tempVar11,0x3f000000);\n      tempVar12 = __aeabi_fmul(tempVar14,tempVar9);\n      tempVar2 = deltat;\n      tempVar12 = __aeabi_fmul(tempVar12,tempVar1);\n      tempVar11 = __aeabi_fsub(tempVar11,tempVar12);\n      tempVar11 = __aeabi_fmul(tempVar11,tempVar2);\n      tempVar11 = __addsf3(tempVar11,tempVar40);\n      tempVar12 = __aeabi_fmul(tempVar40,tempVar5);\n      tempVar13 = __aeabi_fmul(tempVar41,tempVar8);\n      tempVar2 = deltat;\n      tempVar12 = __addsf3(tempVar12,tempVar13);\n      tempVar13 = __aeabi_fmul(tempVar42,tempVar7);\n      tempVar12 = __aeabi_fsub(tempVar12,tempVar13);\n      tempVar12 = __aeabi_fmul(tempVar12,0x3f000000);\n      tempVar13 = __aeabi_fmul(tempVar16,tempVar9);\n      tempVar13 = __aeabi_fmul(tempVar13,tempVar1);\n      tempVar12 = __aeabi_fsub(tempVar12,tempVar13);\n      tempVar12 = __aeabi_fmul(tempVar12,tempVar2);\n      tempVar12 = __addsf3(tempVar12,tempVar46);\n      tempVar2 = deltat;\n      tempVar13 = __aeabi_fmul(tempVar40,tempVar7);\n      tempVar14 = __aeabi_fmul(tempVar46,tempVar8);\n      tempVar13 = __aeabi_fsub(tempVar13,tempVar14);\n      tempVar14 = __aeabi_fmul(tempVar42,tempVar5);\n      tempVar13 = __addsf3(tempVar13,tempVar14);\n      tempVar13 = __aeabi_fmul(tempVar13,0x3f000000);\n      tempVar3 = __aeabi_fmul(tempVar3,tempVar9);\n      tempVar3 = __aeabi_fmul(tempVar3,tempVar1);\n      tempVar3 = __aeabi_fsub(tempVar13,tempVar3);\n      tempVar3 = __aeabi_fmul(tempVar3,tempVar2);\n      tempVar3 = __addsf3(tempVar3,tempVar41);\n      tempVar8 = __aeabi_fmul(tempVar40,tempVar8);\n      tempVar7 = __aeabi_fmul(tempVar46,tempVar7);\n      tempVar7 = __addsf3(tempVar8,tempVar7);\n      tempVar5 = __aeabi_fmul(tempVar41,tempVar5);\n      tempVar5 = __aeabi_fsub(tempVar7,tempVar5);\n      tempVar5 = __aeabi_fmul(tempVar5,0x3f000000);\n      tempVar4 = __aeabi_fmul(tempVar4,tempVar9);\n      tempVar4 = __aeabi_fmul(tempVar4,tempVar1);\n      tempVar40 = deltat;\n      tempVar4 = __aeabi_fsub(tempVar5,tempVar4);\n      tempVar4 = __aeabi_fmul(tempVar4,tempVar40);\n      tempVar4 = __addsf3(tempVar4,tempVar42);\n      tempVar5 = __aeabi_fmul(tempVar11,tempVar11);\n      tempVar8 = __aeabi_fmul(tempVar12,tempVar12);\n      tempVar5 = __addsf3(tempVar5,tempVar8);\n      tempVar8 = __aeabi_fmul(tempVar3,tempVar3);\n      tempVar5 = __addsf3(tempVar5,tempVar8);\n      tempVar8 = __aeabi_fmul(tempVar4,tempVar4);\n      __addsf3(tempVar5,tempVar8);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(tempVar7,tempVar45));\n      tempVar5 = __truncdfsf2();\n      tempVar5 = __aeabi_fdiv(0x3f800000,tempVar5);\n      tempVar40 = (float)__aeabi_fmul(tempVar11,tempVar5);\n      q[0] = tempVar40;\n      tempVar41 = (float)__aeabi_fmul(tempVar12,tempVar5);\n      q[1] = tempVar41;\n      tempVar42 = (float)__aeabi_fmul(tempVar3,tempVar5);\n      q[2] = tempVar42;\n      q[3] = (float)__aeabi_fmul(tempVar4,tempVar5);\n      tempVar3 = __aeabi_fmul(tempVar41,q[3]);\n      tempVar4 = __aeabi_fmul(tempVar40,tempVar42);\n      tempVar3 = __aeabi_fsub(tempVar3,tempVar4);\n      __addsf3(tempVar3,tempVar3);\n      __aeabi_f2d();\n      asin((double)CONCAT44(tempVar7,tempVar45));\n      tempVar43 = __muldf3();\n      __divdf3((int)tempVar43,(int)((ulonglong)tempVar43 >> 0x20),0x54442d18,0x400921fb);\n      tempVar40 = (float)__truncdfsf2();\n      *orientationAngles = tempVar40;\n      tempVar41 = q[1];\n      tempVar40 = q[0];\n      tempVar3 = __aeabi_fmul(q[0],q[0]);\n      tempVar4 = __aeabi_fmul(tempVar41,tempVar41);\n      tempVar3 = __aeabi_fsub(tempVar3,tempVar4);\n      tempVar42 = q[2];\n      tempVar4 = __aeabi_fmul(q[2],q[2]);\n      tempVar3 = __aeabi_fsub(tempVar3,tempVar4);\n      tempVar46 = q[3];\n      tempVar4 = __aeabi_fmul(q[3],q[3]);\n      __addsf3(tempVar3,tempVar4);\n      tempVar43 = __aeabi_f2d();\n      tempVar3 = __aeabi_fmul(tempVar40,tempVar41);\n      tempVar4 = __aeabi_fmul(tempVar42,tempVar46);\n      tempVar3 = __addsf3(tempVar3,tempVar4);\n      __addsf3(tempVar3,tempVar3);\n      tempVar44 = __aeabi_f2d();\n      tempVar43 = atan2((int)tempVar44,(int)((ulonglong)tempVar44 >> 0x20),(int)tempVar43,\n                     (int)((ulonglong)tempVar43 >> 0x20));\n      tempVar43 = __muldf3((int)tempVar43,(int)((ulonglong)tempVar43 >> 0x20),0,0x40668000);\n      __divdf3((int)tempVar43,(int)((ulonglong)tempVar43 >> 0x20),0x54442d18,0x400921fb);\n      tempVar40 = (float)__truncdfsf2();\n      orientationAngles[1] = tempVar40;\n      tempVar41 = q[1];\n      tempVar40 = q[0];\n      tempVar3 = __aeabi_fmul(q[0],q[0]);\n      tempVar4 = __aeabi_fmul(tempVar41,tempVar41);\n      tempVar3 = __addsf3(tempVar3,tempVar4);\n      tempVar42 = q[2];\n      tempVar4 = __aeabi_fmul(q[2],q[2]);\n      tempVar3 = __aeabi_fsub(tempVar3,tempVar4);\n      tempVar46 = q[3];\n      tempVar4 = __aeabi_fmul(q[3],q[3]);\n      __aeabi_fsub(tempVar3,tempVar4);\n      tempVar43 = __aeabi_f2d();\n      tempVar3 = __aeabi_fmul(tempVar41,tempVar42);\n      tempVar4 = __aeabi_fmul(tempVar40,tempVar46);\n      tempVar3 = __addsf3(tempVar3,tempVar4);\n      __addsf3(tempVar3,tempVar3);\n      tempVar44 = __aeabi_f2d();\n      tempVar43 = atan2((int)tempVar44,(int)((ulonglong)tempVar44 >> 0x20),(int)tempVar43,\n                     (int)((ulonglong)tempVar43 >> 0x20));\n      tempVar43 = __muldf3((int)tempVar43,(int)((ulonglong)tempVar43 >> 0x20),0,0x40668000);\n      __divdf3((int)tempVar43,(int)((ulonglong)tempVar43 >> 0x20),0x54442d18,0x400921fb);\n      tempVar40 = (float)__truncdfsf2();\n      orientationAngles[2] = tempVar40;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003330": "calculate_orientation_angles_08003330",
                "ax": "accelerationX",
                "ay": "accelerationY",
                "az": "accelerationZ",
                "gx": "gyroX",
                "gy": "gyroY",
                "gz": "gyroZ",
                "mx": "magneticX",
                "my": "magneticY",
                "mz": "magneticZ",
                "angle": "orientationAngles",
                "fVar1": "tempVar1",
                "fVar2": "tempVar2",
                "uVar3": "tempVar3",
                "uVar4": "tempVar4",
                "uVar5": "tempVar5",
                "iVar6": "tempVar6",
                "uVar7": "tempVar7",
                "uVar8": "tempVar8",
                "uVar9": "tempVar9",
                "iVar10": "tempVar10",
                "uVar11": "tempVar11",
                "uVar12": "tempVar12",
                "uVar13": "tempVar13",
                "uVar14": "tempVar14",
                "uVar15": "tempVar15",
                "uVar16": "tempVar16",
                "uVar17": "tempVar17",
                "uVar18": "tempVar18",
                "uVar19": "tempVar19",
                "uVar20": "tempVar20",
                "iVar21": "tempVar21",
                "_2q1mx": "tempVar22",
                "uVar22": "tempVar23",
                "_2q1my": "tempVar24",
                "uVar23": "tempVar25",
                "_2q1mz": "tempVar26",
                "uVar24": "tempVar27",
                "_2q2mx": "tempVar28",
                "uVar25": "tempVar29",
                "uVar26": "tempVar30",
                "uVar27": "tempVar31",
                "iVar28": "tempVar32",
                "_2bx": "tempVar33",
                "_2bz": "tempVar34",
                "_4bz": "tempVar35",
                "s1": "tempVar36",
                "s2": "tempVar37",
                "s3": "tempVar38",
                "s4": "tempVar39",
                "fVar29": "tempVar40",
                "fVar30": "tempVar41",
                "fVar31": "tempVar42",
                "q1": "quaternion1",
                "q2": "quaternion2",
                "q4": "quaternion4",
                "q3": "quaternion3",
                "uVar32": "tempVar43",
                "uVar33": "tempVar44",
                "in_stack_ffffff78": "tempVar45",
                "fVar34": "tempVar46",
                "hy": "tempVar47",
                "hx": "tempVar48"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__aeabi_f2d",
                "__truncdfsf2",
                "__aeabi_fdiv",
                "__aeabi_fcmpeq",
                "__addsf3",
                "__aeabi_fsub",
                "__muldf3",
                "__aeabi_fmul",
                "atan2",
                "sqrt",
                "__divdf3",
                "asin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003eac": {
            "entrypoint": "0x08003eac",
            "current_name": "execute_system_call_08003eac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_system_call_08003eac(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_08003eac": "execute_system_call_08003eac"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003eb0": {
            "entrypoint": "0x08003eb0",
            "current_name": "perform_afl_call_08003eb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint performAflCall_08003eb0(int numTicks)\n\n{\n  uint32_t aflResult;\n  \n  if (noHyperCall == 0) {\n    aflResult = aflCall(1,numTicks,0);\n    return aflResult;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08003eb0": "perform_afl_call_08003eb0",
                "ticks": "numTicks",
                "uVar1": "aflResult"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ec8": {
            "entrypoint": "0x08003ec8",
            "current_name": "append_to_circular_buffer_08003ec8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint appendToCircularBuffer_08003ec8(CircularBuffer *cb,uint8_t element)\n\n{\n  cb->size = cb->size + 1;\n  cb->buffer[cb->tail] = element;\n  cb->tail = cb->tail + 1 & 0x7ff;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08003ec8": "append_to_circular_buffer_08003ec8",
                "data": "element"
            },
            "calling": [
                "HAL_UART_RxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ef2": {
            "entrypoint": "0x08003ef2",
            "current_name": "initialize_circular_buffer_08003ef2",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd initializeCircularBuffer_08003ef2(CindexrcularBuffer *cb)\n\n{\n  indexnt index;\n  \n  index = 0;\n  cb->head = 0;\n  cb->taindexl = 0;\n  cb->sindexze = 0;\n  do {\n    cb->buffer[index] = '\\0';\n    index = index + 1;\n  } whindexle (index != 0x800);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ef2": "initialize_circular_buffer_08003ef2",
                "i": "index"
            },
            "calling": [
                "serialFlush"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f0e": {
            "entrypoint": "0x08003f0e",
            "current_name": "calculate_updated_value_08003f0e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat calculateUpdatedValue_08003f0e(LPF *inputData,float currentValue)\n\n{\n  undefined4 temp1;\n  undefined4 temp2;\n  float betaValue;\n  float result;\n  \n  betaValue = inputData->beta;\n  temp1 = __aeabi_fsub(0x3f800000,betaValue);\n  temp1 = __aeabi_fmul(temp1,currentValue);\n  temp2 = __aeabi_fmul(betaValue,inputData->last);\n  betaValue = (float)__addsf3(temp2,temp1);\n  inputData->last = betaValue;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003f0e": "calculate_updated_value_08003f0e",
                "var": "inputData",
                "current": "currentValue",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "fVar3": "betaValue",
                "extraout_s0": "result"
            },
            "calling": [
                "AHRS_GetRoll",
                "AHRS_GetPitch"
            ],
            "called": [
                "__addsf3",
                "__aeabi_fsub",
                "__aeabi_fmul"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f3c": {
            "entrypoint": "0x08003f3c",
            "current_name": "set_led_states_08003f3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_LED_states_08003f3c(int is_white_LED_on,int is_red_LED_on,int is_blue_LED_on)\n\n{\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x8000,is_white_LED_on == 0);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x4000,is_red_LED_on == 0);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x2000,is_blue_LED_on == 0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f3c": "set_led_states_08003f3c",
                "led_white": "is_white_LED_on",
                "led_red": "is_red_LED_on",
                "led_blue": "is_blue_LED_on"
            },
            "calling": [
                "PID_Update",
                "LED_StartupSequence"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f7c": {
            "entrypoint": "0x08003f7c",
            "current_name": "blink_led_08003f7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid blinkLED_08003f7c(void)\n\n{\n  int count;\n  \n  count = 3;\n  do {\n    toggleLED(1,0,0);\n    delay_ms(100);\n    toggleLED(0,1,0);\n    delay_ms(100);\n    toggleLED(0,0,1);\n    delay_ms(100);\n    count = count + -1;\n  } while (count != 0);\n  toggleLED(1,1,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f7c": "blink_led_08003f7c",
                "iVar1": "count"
            },
            "calling": [
                "Devices_Init"
            ],
            "called": [
                "toggleLED",
                "delay_ms"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fc4": {
            "entrypoint": "0x08003fc4",
            "current_name": "update_pwm_value_08003fc4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid update_pwm_value_08003fc4(int new_pwm)\n\n{\n  (timer4_instance.Instance)->CCR4 = new_pwm;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fc4": "update_pwm_value_08003fc4",
                "pwm": "new_pwm",
                "htim4": "timer4_instance"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fd0": {
            "entrypoint": "0x08003fd0",
            "current_name": "set_pwm_value_08003fd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_pwm_value_08003fd0(int pwm_value)\n\n{\n  (timer_instance.Instance)->CCR3 = pwm_value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fd0": "set_pwm_value_08003fd0",
                "pwm": "pwm_value",
                "htim4": "timer_instance"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fdc": {
            "entrypoint": "0x08003fdc",
            "current_name": "set_pwm_value_08003fdc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_pwm_value_08003fdc(int new_pwm_value)\n\n{\n  (htim2.Instance)->CCR2 = new_pwm_value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fdc": "set_pwm_value_08003fdc",
                "pwm": "new_pwm_value"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fe8": {
            "entrypoint": "0x08003fe8",
            "current_name": "set_pwm_duty_cycle_08003fe8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_pwm_duty_cycle_08003fe8(int duty_cycle)\n\n{\n  (timer3.Instance)->CCR3 = duty_cycle;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fe8": "set_pwm_duty_cycle_08003fe8",
                "pwm": "duty_cycle",
                "htim3": "timer3"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ff4": {
            "entrypoint": "0x08003ff4",
            "current_name": "start_pwm_timers_08003ff4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid start_PWM_timers_08003ff4(void)\n\n{\n  HAL_TIM_PWM_Start(timer2,4);\n  HAL_TIM_PWM_Start(timer3,8);\n  HAL_TIM_PWM_Start(timer4,8);\n  HAL_TIM_PWM_Start(timer4,0xc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ff4": "start_pwm_timers_08003ff4",
                "&htim2": "timer2",
                "&htim3": "timer3",
                "&htim4": "timer4"
            },
            "calling": [
                "Devices_Init"
            ],
            "called": [
                "HAL_TIM_PWM_Start"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004028": {
            "entrypoint": "0x08004028",
            "current_name": "initialize_peripherals_08004028",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePeripherals_08004028(void)\n\n{\n  initializePeripherals_08004028();\n  initializePWM();\n  performLEDStartupSequence();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004028": "initialize_peripherals_08004028",
                "Peripherals_Init": "initializePeripherals",
                "PWM_Init": "initializePWM",
                "LED_StartupSequence": "performLEDStartupSequence"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "Peripherals_Init",
                "LED_StartupSequence",
                "PWM_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800403c": {
            "entrypoint": "0x0800403c",
            "current_name": "write_register_value_0800403c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid writeRegisterValue_0800403c(uint16_t deviceAddress,uint16_t registerAddress,uint8_t registerValue,uint8_t delayMode)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t returnVal;\n  uint8_t valueArray [1];\n  \n  valueArray[0] = registerValue;\n  status = HAL_I2C_Mem_Write(&hi2c1,deviceAddress,registerAddress,1,valueArray,1,200);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../Src/i2c.c\",0x1b);\n  }\n  if (delayMode != '\\0') {\n    delay_ms(0x32);\n  }\n  returnValurn;\n}\n\n",
            "renaming": {
                "FUN_0800403c": "write_register_value_0800403c",
                "device_add": "deviceAddress",
                "register_add": "registerAddress",
                "register_val": "registerValue",
                "delay_mode": "delayMode",
                "HVar1": "status",
                "ret": "returnVal",
                "byte": "valueArray"
            },
            "calling": [
                "MPU9250_Init",
                "AK8963_Init",
                "MS5611_Init",
                "MS5611_Update"
            ],
            "called": [
                "delay_ms",
                "HAL_I2C_Mem_Write",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800407c": {
            "entrypoint": "0x0800407c",
            "current_name": "read_i2_c_memory_0800407c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t read_I2C_memory_0800407c(uint16_t device_address,uint16_t register_address,char *source_file,int source_line)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t result;\n  uint8_t buffer [1];\n  \n  buffer[0] = '\\0';\n  status = HAL_I2C_Mem_Read(&hi2c1,device_address,register_address,1,buffer,1,200);\n  if (status != HAL_OK) {\n    _Error_Handler(source_file,source_line);\n  }\n  resulturn buffer[0];\n}\n\n",
            "renaming": {
                "FUN_0800407c": "read_i2_c_memory_0800407c",
                "device_add": "device_address",
                "register_add": "register_address",
                "file": "source_file",
                "line": "source_line",
                "HVar1": "status",
                "ret": "result",
                "byte": "buffer"
            },
            "calling": [
                "MPU9250_Init",
                "AK8963_Init",
                "AK8963_ReadData",
                "I2C_ReadByteArray"
            ],
            "called": [
                "HAL_I2C_Mem_Read",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040b8": {
            "entrypoint": "0x080040b8",
            "current_name": "read_i2_c_data_080040b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readI2CData_080040b8(uint16_t deviceAddress,uint16_t registerAddress,uint8_t *data,uint16_t dataSize,char *fileName,\n                 int lineNumber)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t returnValue;\n  \n  status = HAL_I2C_Mem_Read(&hi2c1,deviceAddress,registerAddress,1,data,dataSize,200);\n  if (status != HAL_OK) {\n    _Error_Handler(fileName,lineNumber);\n    returnValueurn;\n  }\n  returnValueurn;\n}\n\n",
            "renaming": {
                "FUN_080040b8": "read_i2_c_data_080040b8",
                "device_add": "deviceAddress",
                "register_add": "registerAddress",
                "bytes": "data",
                "size": "dataSize",
                "file": "fileName",
                "line": "lineNumber",
                "HVar1": "status",
                "ret": "returnValue"
            },
            "calling": [
                "MS5611_ReadADC"
            ],
            "called": [
                "HAL_I2C_Mem_Read",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e8": {
            "entrypoint": "0x080040e8",
            "current_name": "read_and_store_data_080040e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readAndStoreData_080040e8(uint16_t deviceAddress,uint16_t registerAddress,uint8_t *dataBuffer,uint16_t bufferSize,\n                 char *sourceFile,int sourceLine)\n\n{\n  uint8_t readData;\n  int index;\n  uint8_t *dataPointer;\n  \n  dataPointer = dataBuffer + -1;\n  for (index = 0; index < (int)(uint)bufferSize; index = index + 1) {\n    readData = I2C_ReadByte(deviceAddress,registerAddress + (short)index,\"../Src/i2c.c\",0x4c);\n    dataPointer = dataPointer + 1;\n    *dataPointer = readData;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040e8": "read_and_store_data_080040e8",
                "device_add": "deviceAddress",
                "register_add": "registerAddress",
                "byte_array": "dataBuffer",
                "size": "bufferSize",
                "file": "sourceFile",
                "line": "sourceLine",
                "uVar1": "readData",
                "iVar2": "index",
                "puVar3": "dataPointer"
            },
            "calling": [
                "AK8963_Init",
                "MS5611_Init",
                "MPU9250_ReadAccelData",
                "AK8963_ReadData",
                "MPU9250_ReadGyroData"
            ],
            "called": [
                "I2C_ReadByte"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800411c": {
            "entrypoint": "0x0800411c",
            "current_name": "process_and_send_data_0800411c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processAndSendData_0800411c(void)\n\n{\n  uint32_t currentMillis;\n  \n  currentMillis = millis();\n  if (1 < currentMillis - previousTick1) {\n    previousTick1 = millis();\n    AHRS_ComputeAngles();\n  }\n  currentMillis = millis();\n  if (2 < currentMillis - previousTick3) {\n    previousTick3 = millis();\n    PID_Update();\n  }\n  currentMillis = millis();\n  if (3 < currentMillis - previousTick2) {\n    previousTick2 = millis();\n    MSP_SendIdent();\n    MSP_SendStatus();\n    MSP_SendMotor();\n    MSP_SendAttitude();\n    MSP_SendAltitude();\n    MSP_SendRawIMU();\n    MSP_SendPID();\n  }\n  MS5611_Update();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800411c": "process_and_send_data_0800411c",
                "uVar1": "currentMillis",
                "last_tick1": "previousTick1",
                "last_tick3": "previousTick3",
                "last_tick2": "previousTick2"
            },
            "calling": [
                "main"
            ],
            "called": [
                "MSP_SendMotor",
                "PID_Update",
                "MSP_SendAttitude",
                "MSP_SendAltitude",
                "MSP_SendStatus",
                "AHRS_ComputeAngles",
                "MSP_SendPID",
                "millis",
                "MSP_SendIdent",
                "MS5611_Update",
                "MSP_SendRawIMU"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004194": {
            "entrypoint": "0x08004194",
            "current_name": "initialize_system_08004194",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_08004194(void)\n\n{\n  initializeDevices();\n  initializeSerialCommunication();\n  initializeIMU();\n  initializeMS5611();\n  initializePID();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004194": "initialize_system_08004194",
                "Devices_Init": "initializeDevices",
                "serialBegin": "initializeSerialCommunication",
                "IMU_Init": "initializeIMU",
                "MS5611_Init": "initializeMS5611",
                "PID_Init": "initializePID"
            },
            "calling": [
                "main"
            ],
            "called": [
                "PID_Init",
                "Devices_Init",
                "MS5611_Init",
                "IMU_Init",
                "serialBegin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041ae": {
            "entrypoint": "0x080041ae",
            "current_name": "continuous_task_execution_080041ae",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint continuousTaskExecution_080041ae(void)\n\n{\n  initializeForkserver(0);\n  initialize();\n  do {\n    incrementSystemTick();\n    executeTask();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080041ae": "continuous_task_execution_080041ae",
                "startForkserver": "initializeForkserver",
                "setup": "initialize",
                "HAL_IncTick": "incrementSystemTick",
                "taskScheduler": "executeTask"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "startForkserver",
                "taskScheduler",
                "HAL_IncTick",
                "setup"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041c4": {
            "entrypoint": "0x080041c4",
            "current_name": "stop_motors_080041c4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopMotors_080041c4(void)\n\n{\n  setMotor1PWM(0);\n  setMotor2PWM(0);\n  setMotor3PWM(0);\n  setMotor4PWM(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041c4": "stop_motors_080041c4",
                "Motor1_SetPWM": "setMotor1PWM",
                "Motor2_SetPWM": "setMotor2PWM",
                "Motor3_SetPWM": "setMotor3PWM",
                "Motor4_SetPWM": "setMotor4PWM"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "Motor4_SetPWM",
                "Motor3_SetPWM",
                "Motor2_SetPWM",
                "Motor1_SetPWM"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041e4": {
            "entrypoint": "0x080041e4",
            "current_name": "set_motor_pwm_080041e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_motor_pwm_080041e4(int motor1_value,int motor2_value,int motor3_value,int motor4_value)\n\n{\n  if (999 < motor1_value) {\n    motor1_value = 1000;\n  }\n  if (999 < motor2_value) {\n    motor2_value = 1000;\n  }\n  if (999 < motor3_value) {\n    motor3_value = 1000;\n  }\n  if (999 < motor4_value) {\n    motor4_value = 1000;\n  }\n  motor3_pwm = motor3_value & ~(motor3_value >> 0x1f);\n  motor4_pwm = motor4_value & ~(motor4_value >> 0x1f);\n  motor2_pwm = motor2_value & ~(motor2_value >> 0x1f);\n  motor1_pwm = motor1_value & ~(motor1_value >> 0x1f);\n  set_motor1_pwm(motor1_pwm);\n  set_motor2_pwm(motor2_pwm);\n  set_motor3_pwm(motor3_pwm);\n  set_motor4_pwm(motor4_pwm);\n  msp_txf_motor_plus_1000_0 = (short)motor1_pwm + 1000;\n  msp_txf_motor_plus_1000_1 = (short)motor2_pwm + 1000;\n  msp_txf_motor_plus_1000_2 = (short)motor3_pwm + 1000;\n  msp_txf_motor_plus_1000_3 = (short)motor4_pwm + 1000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041e4": "set_motor_pwm_080041e4",
                "m1": "motor1_value",
                "m2": "motor2_value",
                "m3": "motor3_value",
                "m4": "motor4_value",
                "motor_pwm[2]": "motor3_pwm",
                "motor_pwm[3]": "motor4_pwm",
                "motor_pwm[1]": "motor2_pwm",
                "motor_pwm[0]": "motor1_pwm",
                "Motor1_SetPWM": "set_motor1_pwm",
                "Motor2_SetPWM": "set_motor2_pwm",
                "Motor3_SetPWM": "set_motor3_pwm",
                "Motor4_SetPWM": "set_motor4_pwm",
                "msp_txf_motor.motor[0]": "msp_txf_motor_plus_1000_0",
                "msp_txf_motor.motor[1]": "msp_txf_motor_plus_1000_1",
                "msp_txf_motor.motor[2]": "msp_txf_motor_plus_1000_2",
                "msp_txf_motor.motor[3]": "msp_txf_motor_plus_1000_3"
            },
            "calling": [
                "Motor_DistributeSpeed"
            ],
            "called": [
                "Motor4_SetPWM",
                "Motor3_SetPWM",
                "Motor2_SetPWM",
                "Motor1_SetPWM"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800426c": {
            "entrypoint": "0x0800426c",
            "current_name": "calculate_motor_speeds_0800426c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calculateMotorSpeeds_0800426c(float throttleInput,float pitchInput,float rollInput,float yawInput)\n\n{\n  undefined4 throttlePitchDifference;\n  undefined4 throttlePitchSum;\n  undefined4 throttlePitchRollDifference;\n  int motor4Speed;\n  int motor3Speed;\n  int motor2Speed;\n  int motor1Speed;\n  \n  throttlePitchDifference = __aeabi_fsub();\n  throttlePitchSum = __addsf3(throttleInput,pitchInput);\n  throttlePitchRollDifference = __aeabi_fsub(throttlePitchDifference,rollInput);\n  throttlePitchRollDifference = __addsf3(throttlePitchRollDifference,yawInput);\n  __aeabi_fsub(throttlePitchRollDifference,0x447a0000);\n  motor4Speed = __aeabi_f2iz();\n  throttlePitchRollDifference = __aeabi_fsub(throttlePitchSum,rollInput);\n  throttlePitchRollDifference = __aeabi_fsub(throttlePitchRollDifference,yawInput);\n  __aeabi_fsub(throttlePitchRollDifference,0x447a0000);\n  motor3Speed = __aeabi_f2iz();\n  throttlePitchDifference = __addsf3(throttlePitchDifference,rollInput);\n  throttlePitchDifference = __aeabi_fsub(throttlePitchDifference,yawInput);\n  __aeabi_fsub(throttlePitchDifference,0x447a0000);\n  motor2Speed = __aeabi_f2iz();\n  throttlePitchDifference = __addsf3(rollInput,throttlePitchSum);\n  throttlePitchDifference = __addsf3(throttlePitchDifference,yawInput);\n  __aeabi_fsub(throttlePitchDifference,0x447a0000);\n  motor1Speed = __aeabi_f2iz();\n  Motor_SetSpeed(motor1Speed,motor2Speed,motor3Speed,motor4Speed);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800426c": "calculate_motor_speeds_0800426c",
                "throttle": "throttleInput",
                "pitch": "pitchInput",
                "roll": "rollInput",
                "yaw": "yawInput",
                "uVar1": "throttlePitchDifference",
                "uVar2": "throttlePitchSum",
                "uVar3": "throttlePitchRollDifference",
                "m4": "motor4Speed",
                "m3": "motor3Speed",
                "m2": "motor2Speed",
                "m1": "motor1Speed"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "__aeabi_f2iz",
                "__addsf3",
                "__aeabi_fsub",
                "Motor_SetSpeed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004300": {
            "entrypoint": "0x08004300",
            "current_name": "transmit_coded_data_08004300",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitCodedData_08004300(uint8_t encryptionKey,uint8_t *inputData,uint16_t inputLength)\n\n{\n  byte checksum;\n  byte *currentByte;\n  \n  serialPrint(\"$M>\");\n  serialWrite((byte)inputLength);\n  checksum = (byte)inputLength ^ encryptionKey;\n  serialWrite(encryptionKey);\n  for (currentByte = inputData; (int)currentByte - (int)inputData < (int)(uint)inputLength; currentByte = currentByte + 1) {\n    serialWrite(*currentByte);\n    checksum = checksum ^ *currentByte;\n  }\n  serialWrite(checksum);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004300": "transmit_coded_data_08004300",
                "code": "encryptionKey",
                "data": "inputData",
                "data_length": "inputLength",
                "ch": "checksum",
                "pbVar1": "currentByte"
            },
            "calling": [
                "MSP_SendMotor",
                "MSP_SendAttitude",
                "MSP_SendStatus",
                "MSP_SendAltitude",
                "MSP_SendPID",
                "MSP_SendIdent",
                "MSP_SendRawIMU"
            ],
            "called": [
                "serialWrite",
                "serialPrint"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004348": {
            "entrypoint": "0x08004348",
            "current_name": "send_frame_to_msp_08004348",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendFrameToMSP_08004348(void)\n\n{\n  uint inputData;\n  uint8_t buffer [7];\n  undefined4 mspTxfIdent;\n  uint maskedInput;\n  \n  mspTransmitFrameIdentifier._0_4_ = 0x40003e9;\n  mspTransmitFrameIdentifier.capability._1_2_ = 0;\n  mspTransmitFrameIdentifier.capability._3_1_ = 0;\n  mspTxfIdent = 0x40003e9;\n  maskedInput = inputData & 0xff000000;\n  MSP_SendFrame('d',(uint8_t *)&mspTxfIdent,7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004348": "send_frame_to_msp_08004348",
                "in_r1": "inputData",
                "buff": "buffer",
                "local_10": "mspTxfIdent",
                "local_c": "maskedInput",
                "msp_txf_ident": "mspTransmitFrameIdentifier"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004384": {
            "entrypoint": "0x08004384",
            "current_name": "send_frame_to_msp_08004384",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendFrameToMSP_08004384(void)\n\n{\n  uint inputData;\n  undefined4 statusValue;\n  undefined4 stackValue;\n  uint maskedInput;\n  \n  mspTransmissionStatus._4_4_ = 0x2a0007;\n  statusValue = mspTransmissionStatus._0_4_;\n  stackValue = 0x2a0007;\n  mspTransmissionStatus.flag._2_2_ = 0;\n  mspTransmissionStatus.current_set = '\\0';\n  maskedInput = inputData & 0xff000000;\n  MSP_SendFrame('e',(uint8_t *)&statusValue,0xb);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004384": "send_frame_to_msp_08004384",
                "in_r3": "inputData",
                "local_14": "statusValue",
                "uStack_10": "stackValue",
                "local_c": "maskedInput",
                "msp_txf_status": "mspTransmissionStatus"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080043bc": {
            "entrypoint": "0x080043bc",
            "current_name": "copy_imu_data_and_send_frame_080043bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid copyImuDataAndSendFrame_080043bc(void)\n\n{\n  undefined4 accx;\n  undefined4 accy;\n  undefined4 *bufferPointer;\n  msp_raw_imu *imuDataPointer;\n  uint8_t buffer [18];\n  \n  imuDataPointer = &msp_txf_raw_imu;\n  bufferPointer = (undefined4 *)buffer;\n  do {\n    accx = *(undefined4 *)imuDataPointer;\n    accy = *(undefined4 *)&imuDataPointer->accz;\n    imuDataPointer = (msp_raw_imu *)&imuDataPointer->gyry;\n    *bufferPointer = accx;\n    bufferPointer[1] = accy;\n    bufferPointer = bufferPointer + 2;\n  } while (imuDataPointer != (msp_raw_imu *)&msp_txf_raw_imu.magz);\n  *(int16_t *)bufferPointer = msp_txf_raw_imu.magz;\n  MSP_SendFrame('f',buffer,0x12);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080043bc": "copy_imu_data_and_send_frame_080043bc",
                "pmVar4": "imuDataPointer",
                "puVar3": "bufferPointer",
                "uVar1": "accx",
                "uVar2": "accy",
                "buff": "buffer"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080043f0": {
            "entrypoint": "0x080043f0",
            "current_name": "send_motor_data_080043f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendMotorData_080043f0(void)\n\n{\n  uint8_t buffer [8];\n  undefined4 motorValue1;\n  undefined4 motorValue2;\n  \n  motorValue1 = msp_txf_motor.motor._0_4_;\n  motorValue2 = msp_txf_motor.motor._4_4_;\n  MSP_SendFrame('h',(uint8_t *)&motorValue1,8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080043f0": "send_motor_data_080043f0",
                "buff": "buffer",
                "local_10": "motorValue1",
                "uStack_c": "motorValue2"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004410": {
            "entrypoint": "0x08004410",
            "current_name": "send_attitude_frame_08004410",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid send_attitude_frame_08004410(void)\n\n{\n  undefined4 input_data;\n  uint8_t attitude_buffer [6];\n  undefined4 transmitted_attitude;\n  undefined4 attitude_heading;\n  \n  transmitted_attitude = msp_txf_attitude._0_4_;\n  attitude_heading = CONCAT22((short)((uint)input_data >> 0x10),msp_txf_attitude.heading);\n  MSP_SendFrame('l',(uint8_t *)&transmitted_attitude,6);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004410": "send_attitude_frame_08004410",
                "in_r1": "input_data",
                "buff": "attitude_buffer",
                "local_10": "transmitted_attitude",
                "local_c": "attitude_heading"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004434": {
            "entrypoint": "0x08004434",
            "current_name": "send_altitude_frame_08004434",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendAltitudeFrame_08004434(void)\n\n{\n  undefined4 inputParameter;\n  uint8_t buffer [6];\n  int32_t estimatedAltitude;\n  undefined4 combinedValue;\n  \n  estimatedAltitude = msp_txf_altitude.est_alt;\n  combinedValue = CONCAT22((short)((uint)inputParameter >> 0x10),msp_txf_altitude.vario);\n  MSP_SendFrame('m',(uint8_t *)&estimatedAltitude,6);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004434": "send_altitude_frame_08004434",
                "in_r1": "inputParameter",
                "buff": "buffer",
                "local_10": "estimatedAltitude",
                "local_c": "combinedValue"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004458": {
            "entrypoint": "0x08004458",
            "current_name": "send_telemetry_data_08004458",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendTelemetryData_08004458(void)\n\n{\n  undefined4 *localPIDArray;\n  undefined4 tempPitch;\n  undefined4 *newPIDArray;\n  msp_pid *currentPID;\n  msp_pid *nextPID;\n  uint8_t buffer [30];\n  undefined4 pidValues [3];\n  undefined2 yawValues [10];\n  \n  localPIDArray = pidValues;\n  nextPID = &msp_txf_pid;\n  do {\n    currentPID = nextPID;\n    newPIDArray = localPIDArray;\n    tempPitch = *(undefined4 *)&(currentPID->pitch).i;\n    nextPID = (msp_pid *)&(currentPID->yaw).d;\n    *newPIDArray = *(undefined4 *)currentPID;\n    newPIDArray[1] = tempPitch;\n    localPIDArray = newPIDArray + 2;\n  } while (nextPID != (msp_pid *)&msp_txf_pid.mag);\n  newPIDArray[2] = msp_txf_pid._24_4_;\n  *(undefined2 *)(newPIDArray + 3) = *(undefined2 *)&currentPID->pos;\n  MSP_SendFrame('p',(uint8_t *)pidValues,0x1e);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004458": "send_telemetry_data_08004458",
                "puVar1": "localPIDArray",
                "uVar2": "tempPitch",
                "puVar3": "newPIDArray",
                "pmVar4": "currentPID",
                "pmVar5": "nextPID",
                "buff": "buffer",
                "local_30": "pidValues",
                "local_24": "yawValues"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004490": {
            "entrypoint": "0x08004490",
            "current_name": "handle_error_08004490",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleError_08004490(char *fileName,int lineNumber)\n\n{\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x4000,GPIO_PIN_SET);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x8000,GPIO_PIN_RESET);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x2000,GPIO_PIN_RESET);\n  do {\n    HAL_GPIO_TogglePin((GPIO_TypeDef *)0x40011000,0x4000);\n    HAL_GPIO_TogglePin((GPIO_TypeDef *)0x40011000,0x8000);\n    HAL_GPIO_TogglePin((GPIO_TypeDef *)0x40011000,0x2000);\n    serialPrint(\"Error with \");\n    serialPrint(fileName);\n    serialPrint(\" at lineNumber: \");\n    serialInt(lineNumber);\n    serialWrite('\\n');\n    delay_ms(500);\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004490": "handle_error_08004490",
                "file": "fileName",
                "line": "lineNumber"
            },
            "calling": [
                "Peripherals_Init",
                "I2C_ReadByte",
                "I2C_ReadBytes",
                "I2C_WriteByte",
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GPIO_WritePin",
                "serialWrite",
                "delay_ms",
                "serialInt",
                "serialPrint",
                "HAL_GPIO_TogglePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004514": {
            "entrypoint": "0x08004514",
            "current_name": "initialize_clock_configuration_08004514",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeClockConfiguration_08004514(void)\n\n{\n  ClockStatus status;\n  char *errorMessage;\n  uint32_t hclkFrequency;\n  int lineNumber;\n  uint flashLatency;\n  ClockInitParameters RCC_ClkInitStruct;\n  RCC_OscInitTypeDef OscillatorInitParameters;\n  \n  OscillatorInitParameters.HSIState = 1;\n  OscillatorInitParameters.HSICalibrationValue = 0x10;\n  flashLatency = 2;\n  OscillatorInitParameters.PLL.PLLSource = 0;\n  OscillatorInitParameters.OscillatorType = 2;\n  OscillatorInitParameters.PLL.PLLState = 2;\n  OscillatorInitParameters.PLL.PLLMUL = 0x380000;\n  status = HAL_RCC_OscConfig(&OscillatorInitParameters);\n  errorMessage = (char *)(uint)status;\n  if (errorMessage == (char *)0x0) goto LAB_08004540;\n  lineNumber = 0x3c;\n  while( true ) {\n    errorMessage = \"../Src/peripherals.c\";\n    _Error_Handler(\"../Src/peripherals.c\",lineNumber);\nLAB_08004540:\n    RCC_ClkInitStruct.ClockType = 0xf;\n    RCC_ClkInitStruct.APB1CLKDivider = 0x400;\n    RCC_ClkInitStruct.SYSCLKSource = flashLatency;\n    RCC_ClkInitStruct.AHBCLKDivider = (uint32_t)errorMessage;\n    RCC_ClkInitStruct.APB2CLKDivider = (uint32_t)errorMessage;\n    status = HAL_RCC_ClockConfig(&RCC_ClkInitStruct,flashLatency);\n    flashLatency = (uint)status;\n    if (flashLatency == 0) break;\n    lineNumber = 0x49;\n  }\n  hclkFrequency = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFrequency / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004514": "initialize_clock_configuration_08004514",
                "HAL_StatusTypeDef": "ClockStatus",
                "pcVar2": "errorMessage",
                "uVar3": "hclkFrequency",
                "line": "lineNumber",
                "FLatency": "flashLatency",
                "RCC_ClkInitTypeDef": "ClockInitParameters",
                "RCC_OscInitStruct": "OscillatorInitParameters",
                "HVar1": "status"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_ClockConfig",
                "HAL_RCC_OscConfig",
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_GetHCLKFreq",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800458c": {
            "entrypoint": "0x0800458c",
            "current_name": "initialize_peripherals_0800458c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializePeripherals_0800458c(void)\n\n{\n  HAL_StatusTypeDef status;\n  char *errorFile;\n  uint result;\n  int currentLine;\n  uint prescaler;\n  uint32_t tempRegister;\n  uint32_t tempRegister1;\n  uint32_t tempRegister2;\n  TIM_MasterConfigTypeDef masterConfig;\n  TIM_OC_InitTypeDef ocConfig;\n  GPIO_InitTypeDef gpioConfig;\n  \n  HAL_Init();\n  SystemClock_Config();\n  prescaler = 2;\n  _DAT_40021018 = _DAT_40021018 | 0x1c;\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0xe000,GPIO_PIN_RESET);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40010800,0x20,GPIO_PIN_RESET);\n  gpioConfig.Pin = 0xe000;\n  gpioConfig.Mode = 1;\n  gpioConfig.Speed = 2;\n  HAL_GPIO_Init((GPIO_TypeDef *)0x40011000,&gpioConfig);\n  gpioConfig.Pin = 0x20;\n  gpioConfig.Mode = 1;\n  gpioConfig.Speed = 2;\n  HAL_GPIO_Init((GPIO_TypeDef *)0x40010800,&gpioConfig);\n  i2cInstance.Instance = (I2C_TypeDef *)0x40005400;\n  i2cInstance.Init.ClockSpeed = 400000;\n  i2cInstance.Init.AddressingMode = 0x4000;\n  i2cInstance.Init.DutyCycle = 0;\n  i2cInstance.Init.OwnAddress1 = 0;\n  i2cInstance.Init.DualAddressMode = 0;\n  i2cInstance.Init.OwnAddress2 = 0;\n  i2cInstance.Init.GeneralCallMode = 0;\n  i2cInstance.Init.NoStretchMode = 0;\n  status = HAL_I2C_Init(&i2cInstance);\n  errorFile = (char *)(uint)status;\n  if (errorFile == (char *)0x0) goto LAB_0800463a;\n  currentLine = 0x6b;\n  while( true ) {\n    while( true ) {\n      while( true ) {\n        while( true ) {\n          while( true ) {\n            while( true ) {\n              while( true ) {\n                while( true ) {\n                  while( true ) {\n                    while( true ) {\n                      while( true ) {\n                        while( true ) {\n                          while( true ) {\n                            while( true ) {\n                              while( true ) {\n                                while( true ) {\n                                  errorFile = \"../Src/peripherals.c\";\n                                  _Error_Handler(\"../Src/peripherals.c\",currentLine);\nLAB_0800463a:\n                                  uartInstance.Instance = (USART_TypeDef *)0x40013800;\n                                  uartInstance.Init.BaudRate = 0x1c200;\n                                  uartInstance.Init.Mode = 0xc;\n                                  uartInstance.Init.WordLength = (uint32_t)errorFile;\n                                  uartInstance.Init.StopBits = (uint32_t)errorFile;\n                                  uartInstance.Init.Parity = (uint32_t)errorFile;\n                                  uartInstance.Init.HwFlowCtl = (uint32_t)errorFile;\n                                  uartInstance.Init.OverSampling = (uint32_t)errorFile;\n                                  status = HAL_UART_Init(&uartInstance);\n                                  result = (uint)status;\n                                  if (result == 0) break;\n                                  currentLine = 0x151;\n                                }\n                                timer1.Instance = (TIM_TypeDef *)0x40012c00;\n                                timer1.Init.Period = 1000;\n                                timer1.Init.Prescaler = prescaler;\n                                timer1.Init.CounterMode = result;\n                                timer1.Init.ClockDivision = result;\n                                timer1.Init.RepetitionCounter = result;\n                                status = HAL_TIM_PWM_Init(&timer1);\n                                result = (uint)status;\n                                if (result == 0) break;\n                                currentLine = 0x88;\n                              }\n                              masterConfig.MasterOutputTrigger = result;\n                              masterConfig.MasterSlaveMode = result;\n                              status = HAL_TIMEx_MasterConfigSynchronization(&timer1,&masterConfig);\n                              result = (uint)status;\n                              if (result == 0) break;\n                              currentLine = 0x8f;\n                            }\n                            ocConfig.OCMode = 0x60;\n                            ocConfig.Pulse = result;\n                            ocConfig.OCPolarity = result;\n                            ocConfig.OCFastMode = result;\n                            ocConfig.OCIdleState = result;\n                            ocConfig.OCNIdleState = result;\n                            status = HAL_TIM_PWM_ConfigChannel(&timer1,&ocConfig,0xc);\n                            result = (uint)status;\n                            if (result == 0) break;\n                            currentLine = 0x9a;\n                          }\n                          gpioConfig.Pin = result;\n                          gpioConfig.Mode = result;\n                          gpioConfig.Pull = result;\n                          gpioConfig.Speed = result;\n                          status = HAL_TIMEx_ConfigBreakDeadTime\n                                            (&timer1,(TIM_BreakDeadTimeConfigTypeDef *)\n                                                    &gpioConfig);\n                          result = (uint)status;\n                          if (result == 0) break;\n                          currentLine = 0xa6;\n                        }\n                        HAL_TIM_MspPostInit(&timer1);\n                        timer2.Instance = (TIM_TypeDef *)0x40000000;\n                        timer2.Init.Period = 1000;\n                        timer2.Init.Prescaler = prescaler;\n                        timer2.Init.CounterMode = result;\n                        timer2.Init.ClockDivision = result;\n                        status = HAL_TIM_PWM_Init(&timer2);\n                        result = (uint)status;\n                        if (result == 0) break;\n                        currentLine = 0xc3;\n                      }\n                      ocConfig.OCMode = result;\n                      ocConfig.Pulse = result;\n                      status = HAL_TIMEx_MasterConfigSynchronization\n                                        (&timer2,(TIM_MasterConfigTypeDef *)&ocConfig);\n                      result = (uint)status;\n                      if (result == 0) break;\n                      currentLine = 0xca;\n                    }\n                    gpioConfig.Pin = 0x60;\n                    gpioConfig.Mode = result;\n                    gpioConfig.Pull = result;\n                    status = HAL_TIM_PWM_ConfigChannel\n                                      (&timer2,(TIM_OC_InitTypeDef *)&gpioConfig,4);\n                    result = (uint)status;\n                    if (result == 0) break;\n                    currentLine = 0xd3;\n                  }\n                  HAL_TIM_MspPostInit(&timer2);\n                  timer3.Init.Period = 1000;\n                  timer3.Instance = (TIM_TypeDef *)0x40000400;\n                  timer3.Init.Prescaler = prescaler;\n                  timer3.Init.CounterMode = result;\n                  timer3.Init.ClockDivision = result;\n                  status = HAL_TIM_PWM_Init(&timer3);\n                  if (status == HAL_OK) break;\n                  currentLine = 0xf0;\n                }\n                ocConfig.OCMode = 0;\n                ocConfig.Pulse = 0;\n                status = HAL_TIMEx_MasterConfigSynchronization\n                                  (&timer3,(TIM_MasterConfigTypeDef *)&ocConfig);\n                result = (uint)status;\n                if (result == 0) break;\n                currentLine = 0xf7;\n              }\n              gpioConfig.Pin = 0x60;\n              gpioConfig.Mode = result;\n              gpioConfig.Pull = result;\n              status = HAL_TIM_PWM_ConfigChannel(&timer3,(TIM_OC_InitTypeDef *)&gpioConfig,8);\n              if (status == HAL_OK) break;\n              currentLine = 0x100;\n            }\n            status = HAL_TIM_PWM_ConfigChannel(&timer3,(TIM_OC_InitTypeDef *)&gpioConfig,0xc);\n            prescaler = (uint)status;\n            if (prescaler == 0) break;\n            currentLine = 0x105;\n          }\n          HAL_TIM_MspPostInit(&timer3);\n          timer4.Instance = (TIM_TypeDef *)0x40000800;\n          timer4.Init.Prescaler = 2;\n          timer4.Init.Period = 1000;\n          timer4.Init.CounterMode = prescaler;\n          timer4.Init.ClockDivision = prescaler;\n          status = HAL_TIM_PWM_Init(&timer4);\n          result = (uint)status;\n          if (result == 0) break;\n          currentLine = 0x122;\n        }\n        ocConfig.OCMode = result;\n        ocConfig.Pulse = result;\n        status = HAL_TIMEx_MasterConfigSynchronization(&timer4,(TIM_MasterConfigTypeDef *)&ocConfig);\n        result = (uint)status;\n        if (result == 0) break;\n        currentLine = 0x129;\n      }\n      gpioConfig.Pin = 0x60;\n      gpioConfig.Mode = result;\n      gpioConfig.Pull = result;\n      status = HAL_TIM_PWM_ConfigChannel(&timer4,(TIM_OC_InitTypeDef *)&gpioConfig,8);\n      if (status == HAL_OK) break;\n      currentLine = 0x132;\n    }\n    status = HAL_TIM_PWM_ConfigChannel(&timer4,(TIM_OC_InitTypeDef *)&gpioConfig,0xc);\n    if (status == HAL_OK) break;\n    currentLine = 0x137;\n  }\n  HAL_TIM_MspPostInit(&timer4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800458c": "initialize_peripherals_0800458c",
                "HVar1": "status",
                "pcVar2": "errorFile",
                "uVar3": "result",
                "uVar4": "prescaler",
                "tmpreg": "tempRegister",
                "tmpreg_1": "tempRegister1",
                "tmpreg_2": "tempRegister2",
                "sMasterConfig": "masterConfig",
                "sConfigOC": "ocConfig",
                "GPIO_InitStruct": "gpioConfig",
                "hi2c1": "i2cInstance",
                "huart1": "uartInstance",
                "htim1": "timer1",
                "htim2": "timer2",
                "htim3": "timer3",
                "htim4": "timer4",
                "line": "currentLine"
            },
            "calling": [
                "Devices_Init"
            ],
            "called": [
                "HAL_GPIO_WritePin",
                "HAL_UART_Init",
                "HAL_Init",
                "HAL_GPIO_Init",
                "HAL_I2C_Init",
                "HAL_TIMEx_ConfigBreakDeadTime",
                "HAL_TIMEx_MasterConfigSynchronization",
                "HAL_TIM_PWM_ConfigChannel",
                "_Error_Handler",
                "HAL_TIM_PWM_Init",
                "HAL_TIM_MspPostInit",
                "SystemClock_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800483c": {
            "entrypoint": "0x0800483c",
            "current_name": "compute_pid_output_0800483c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid computePIDOutput_0800483c(PIDData *pidData)\n\n{\n  undefined4 tempVar1;\n  int tempVar2;\n  undefined4 tempVar3;\n  float error;\n  float proportional;\n  float integral;\n  \n  error = pidData->input;\n  tempVar1 = __addsf3(pidData->set_point,pidData->offset);\n  error = (float)__aeabi_fsub(tempVar1,error);\n  pidData->error = error;\n  if (pidData->instance == 3) {\n    tempVar2 = __aeabi_fcmpgt(pidData->error,0);\n    if (tempVar2 == 0) {\n      tempVar2 = __aeabi_fcmplt(pidData->error,0xc3340000);\n    }\n    else {\n      tempVar2 = __aeabi_fcmpgt(pidData->error,0x43340000);\n    }\n    if (tempVar2 != 0) {\n      proportional = pidData->error;\n      tempVar1 = __aeabi_fmul(pidData->error,0x43b40000);\n      tempVar2 = __aeabi_fcmpgt(pidData->error,0);\n      error = pidData->error;\n      if (tempVar2 == 0) {\n        error = (float)((int)error + -0x80000000);\n      }\n      tempVar1 = __aeabi_fdiv(tempVar1,error);\n      error = (float)__aeabi_fsub(proportional,tempVar1);\n      pidData->error = error;\n    }\n  }\n  integral = pidData->con_KI;\n  proportional = pidData->con_KD;\n  error = (float)__aeabi_fmul(pidData->con_KP,pidData->error);\n  pidData->proportional = error;\n  error = (float)__addsf3(pidData->error,pidData->integral);\n  pidData->integral = error;\n  tempVar2 = __aeabi_fcmplt(pidData->integral,0xc3fa0000);\n  if (tempVar2 == 0) {\n    tempVar2 = __aeabi_fcmpgt(pidData->integral,0x43fa0000);\n    if (tempVar2 == 0) {\n      error = pidData->integral;\n    }\n    else {\n      error = 500.0;\n    }\n  }\n  else {\n    error = -500.0;\n  }\n  pidData->integral = error;\n  error = (float)__aeabi_fsub(pidData->input,pidData->last_input);\n  pidData->derivative = error;\n  error = pidData->proportional;\n  tempVar1 = __aeabi_fmul(integral,pidData->integral);\n  tempVar1 = __addsf3(tempVar1,error);\n  tempVar3 = __aeabi_fmul(proportional,pidData->derivative);\n  error = (float)__aeabi_fsub(tempVar1,tempVar3);\n  pidData->output = error;\n  tempVar1 = __floatsisf(pidData->direction);\n  tempVar2 = __aeabi_fcmplt(pidData->output,0xc3fa0000);\n  if (tempVar2 == 0) {\n    tempVar2 = __aeabi_fcmpgt(pidData->output,0x43fa0000);\n    if (tempVar2 == 0) {\n      error = pidData->output;\n    }\n    else {\n      error = 500.0;\n    }\n  }\n  else {\n    error = -500.0;\n  }\n  error = (float)__aeabi_fmul(error,tempVar1);\n  pidData->output = error;\n  pidData->last_input = pidData->input;\n  pidData->last_error = pidData->error;\n  pidData->last_time = pidData->time;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800483c": "compute_pid_output_0800483c",
                "PID_TypeDef": "PIDData",
                "pid": "pidData",
                "uVar1": "tempVar1",
                "iVar2": "tempVar2",
                "uVar3": "tempVar3",
                "fVar4": "error",
                "fVar5": "proportional",
                "fVar6": "integral"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "__aeabi_fcmpgt",
                "__aeabi_fdiv",
                "__addsf3",
                "__aeabi_fsub",
                "__floatsisf",
                "__aeabi_fmul",
                "__aeabi_fcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004978": {
            "entrypoint": "0x08004978",
            "current_name": "initialize_pid_controllers_08004978",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePIDControllers_08004978(void)\n\n{\n  pitchPID.direction = 1;\n  rollPID.direction = 1;\n  yawPID.direction = -1;\n  altitudePID.direction = 1;\n  pitchPID.breakpoint = 1500.0;\n  rollPID.breakpoint = 1450.0;\n  yawPID.breakpoint = 2000.0;\n  altitudePID.breakpoint = 0.0;\n  pitchPID.controlled_KP = 4.4;\n  pitchPID.controlled_KI = 0.02;\n  pitchPID.controlled_KD = 280.0;\n  pitchPID.aggressive_KP = 4.5;\n  pitchPID.aggressive_KI = 0.02;\n  pitchPID.aggressive_KD = 360.0;\n  rollPID.controlled_KP = 3.8;\n  rollPID.controlled_KI = 0.02;\n  rollPID.controlled_KD = 260.0;\n  rollPID.aggressive_KP = 3.8;\n  rollPID.aggressive_KI = 0.02;\n  rollPID.aggressive_KD = 320.0;\n  yawPID.controlled_KP = 3.0;\n  yawPID.controlled_KI = 0.01;\n  yawPID.controlled_KD = 280.0;\n  yawPID.aggressive_KP = 0.0;\n  yawPID.aggressive_KI = 0.0;\n  yawPID.aggressive_KD = 0.0;\n  altitudePID.controlled_KP = 10.0;\n  altitudePID.controlled_KI = 0.0;\n  altitudePID.controlled_KD = 0.0;\n  altitudePID.aggressive_KP = 0.0;\n  altitudePID.aggressive_KI = 0.0;\n  altitudePID.aggressive_KD = 0.0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004978": "initialize_pid_controllers_08004978",
                "pid_pitch": "pitchPID",
                "pid_roll": "rollPID",
                "pid_yaw": "yawPID",
                "pid_altitude": "altitudePID",
                "con_KP": "controlled_KP",
                "con_KI": "controlled_KI",
                "con_KD": "controlled_KD",
                "agr_KP": "aggressive_KP",
                "agr_KI": "aggressive_KI",
                "agr_KD": "aggressive_KD"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a30": {
            "entrypoint": "0x08004a30",
            "current_name": "update_altitude_hold_08004a30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateAltitudeHold_08004a30(void)\n\n{\n  if (isAltitudeHold != '\\0') {\n    if (altitudeSet == '\\0') {\n      getFilteredAltitude();\n      altitudeSetPoint = (float)multiplyFloat();\n      altitudeSet = '\\x01';\n    }\n    else {\n      getFilteredAltitude();\n      altitudeInput = (float)multiplyFloat();\n    }\n  }\n  if (isAltitudeHold == '\\0') {\n    if (altitudeSet != '\\0') {\n      altitudeSet = isAltitudeHold;\n    }\n    altitudeOutput = throttleInput;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a30": "update_altitude_hold_08004a30",
                "joystick.ALT_HOLD": "isAltitudeHold",
                "ALT_FLAG": "altitudeSet",
                "MS5611_GetFilteredAltitude": "getFilteredAltitude",
                "__aeabi_fmul": "multiplyFloat",
                "pid_altitude.set_point": "altitudeSetPoint",
                "pid_altitude.input": "altitudeInput",
                "joystick.throttle": "throttleInput",
                "pid_altitude.output": "altitudeOutput"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "MS5611_GetFilteredAltitude",
                "__aeabi_fmul"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a84": {
            "entrypoint": "0x08004a84",
            "current_name": "update_flight_controls_08004a84",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateFlightControls_08004a84(void)\n\n{\n  float pitchInput;\n  int comparisonResult;\n  \n  AHRS_GetPitch();\n  pitchInput = pitchInput;\n  AHRS_GetRoll();\n  rollInput = pitchInput;\n  AHRS_GetYaw();\n  yawInput = pitchInput;\n  PID_UpdateAltitude();\n  comparisonResult = compareFloatGreaterThan(pitchInput,0);\n  if (comparisonResult == 0) {\n    comparisonResult = compareFloatLessThan(pitchInput,0xc2a00000);\n  }\n  else {\n    comparisonResult = compareFloatGreaterThan(pitchInput,0x42a00000);\n  }\n  if (comparisonResult == 0) {\n    comparisonResult = compareFloatGreaterThan(rollInput,0);\n    if (comparisonResult == 0) {\n      comparisonResult = compareFloatLessThan(rollInput,0xc2a00000);\n    }\n    else {\n      comparisonResult = compareFloatGreaterThan(rollInput,0x42a00000);\n    }\n    if (comparisonResult == 0) {\n      toggleLED(1,1,1);\n      PID_Compute(&pitchPID);\n      PID_Compute(&rollPID);\n      PID_Compute(&yawPID);\n      if (isAltHoldEnabled != '\\0') {\n        PID_Compute(&altitudePID);\n        addFloatToInt(altitudeOutput,0x44bb8000);\n      }\n      altitudeOutput = throttleInput;\n      if (isMotorArmed == '\\0') {\n        stopAllMotors();\n      }\n      else {\n        distributeMotorSpeed(throttleInput,pitchPID.output,rollPID.output,yawPID.output);\n      }\n      multiplyFloats(pitchPID.con_KP,0x437f0000);\n      mspTxfPID.pitch.p = floatToUnsignedInt();\n      multiplyFloats(pitchPID.con_KI,0x437f0000);\n      mspTxfPID.pitch.i = floatToUnsignedInt();\n      multiplyFloats(rollPID.con_KP,0x437f0000);\n      mspTxfPID.roll.p = floatToUnsignedInt();\n      multiplyFloats(rollPID.con_KI,0x437f0000);\n      mspTxfPID.roll.i = floatToUnsignedInt();\n      multiplyFloats(rollPID.con_KD,0x437f0000);\n      mspTxfPID.roll.d = floatToUnsignedInt();\n      multiplyFloats(yawPID.con_KP,0x437f0000);\n      mspTxfPID.yaw.p = floatToUnsignedInt();\n      multiplyFloats(yawPID.con_KI,0x437f0000);\n      mspTxfPID.yaw.i = floatToUnsignedInt();\n      multiplyFloats(yawPID.con_KD,0x437f0000);\n      mspTxfPID.yaw.d = floatToUnsignedInt();\n      multiplyFloats(altitudeKP,0x437f0000);\n      mspTxfPID.altitude.p = floatToUnsignedInt();\n      multiplyFloats(altitudeKI,0x437f0000);\n      mspTxfPID.altitude.i = floatToUnsignedInt();\n      multiplyFloats(altitudeKD,0x437f0000);\n      mspTxfPID.altitude.d = floatToUnsignedInt();\n      return;\n    }\n  }\n  stopAllMotors();\n  toggleLED(0,1,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a84": "update_flight_controls_08004a84",
                "in_r0": "pitchInput",
                "iVar1": "comparisonResult",
                "pid_pitch.input": "pitchInput",
                "pid_roll.input": "rollInput",
                "pid_yaw.input": "yawInput",
                "pid_altitude": "altitudePID",
                "joystick.ALT_HOLD": "isAltHoldEnabled",
                "joystick.MOTOR_ARM": "isMotorArmed",
                "joystick.throttle": "throttleInput",
                "msp_txf_pid": "mspTxfPID",
                "Motor_StopAll": "stopAllMotors",
                "Motor_DistributeSpeed": "distributeMotorSpeed",
                "pid_pitch": "pitchPID",
                "pid_roll": "rollPID",
                "pid_yaw": "yawPID",
                "pid_altitude.output": "altitudeOutput",
                "pid_altitude.con_KP": "altitudeKP",
                "pid_altitude.con_KI": "altitudeKI",
                "pid_altitude.con_KD": "altitudeKD",
                "msp_txf_pid.alt.p": "mspTxfPID.altitude.p",
                "msp_txf_pid.alt.i": "mspTxfPID.altitude.i",
                "msp_txf_pid.alt.d": "mspTxfPID.altitude.d",
                "msp_txf_pid.pitch.p": "mspTxfPID.pitch.p",
                "msp_txf_pid.pitch.i": "mspTxfPID.pitch.i",
                "msp_txf_pid.roll.p": "mspTxfPID.roll.p",
                "msp_txf_pid.roll.i": "mspTxfPID.roll.i",
                "msp_txf_pid.roll.d": "mspTxfPID.roll.d",
                "msp_txf_pid.yaw.p": "mspTxfPID.yaw.p",
                "msp_txf_pid.yaw.i": "mspTxfPID.yaw.i",
                "msp_txf_pid.yaw.d": "mspTxfPID.yaw.d",
                "__addsf3": "addFloatToInt",
                "__aeabi_fcmpgt": "compareFloatGreaterThan",
                "__aeabi_fcmplt": "compareFloatLessThan",
                "__aeabi_fmul": "multiplyFloats",
                "__fixunssfsi": "floatToUnsignedInt"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "__aeabi_fcmpgt",
                "Motor_StopAll",
                "__aeabi_fmul",
                "__aeabi_fcmplt",
                "AHRS_GetRoll",
                "PID_Compute",
                "__addsf3",
                "toggleLED",
                "Motor_DistributeSpeed",
                "AHRS_GetPitch",
                "__fixunssfsi",
                "AHRS_GetYaw",
                "PID_UpdateAltitude"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c18": {
            "entrypoint": "0x08004c18",
            "current_name": "transmit_char_08004c18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitChar_08004c18(uinputCharar inputChar)\n\n{\n  outputBuffer[0] = inputChar;\n  transmitData(uartHandle,(dataFormat *)outputBuffer,1,5);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c18": "transmit_char_08004c18",
                "ch": "inputChar",
                "tx_buffer": "outputBuffer",
                "HAL_UART_Transmit": "transmitData",
                "&huart1": "uartHandle",
                "uint8_t": "dataFormat"
            },
            "calling": [
                "MSP_SendFrame",
                "serialPrint",
                "_Error_Handler"
            ],
            "called": [
                "HAL_UART_Transmit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c30": {
            "entrypoint": "0x08004c30",
            "current_name": "handle_uart_interrupt_08004c30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART_interrupt_08004c30(UART_HandleTypeDef *UART_handle)\n\n{\n  if (UART_handle->Instance == (USART_Instance *)0x40013800) {\n    write_to_CircularBuffer(&receive_buffer,receive_data_buffer[0]);\n    initiate_UART_receive_interrupt(&UART_handle1,receive_data_buffer,1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c30": "handle_uart_interrupt_08004c30",
                "huart": "UART_handle",
                "USART_TypeDef": "USART_Instance",
                "CB_Write": "write_to_CircularBuffer",
                "rxc": "receive_buffer",
                "rx_buffer": "receive_data_buffer",
                "HAL_UART_Receive_IT": "initiate_UART_receive_interrupt"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "CB_Write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c64": {
            "entrypoint": "0x08004c64",
            "current_name": "initialize_rxc_08004c64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeRXC_08004c64(void)\n\n{\n  CB_Init(rxChannel);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c64": "initialize_rxc_08004c64",
                "&rxc": "rxChannel"
            },
            "calling": [
                "serialBegin"
            ],
            "called": [
                "CB_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c70": {
            "entrypoint": "0x08004c70",
            "current_name": "initialize_serial_communication_08004c70",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_08004c70(void)\n\n{\n  flushBuffer();\n  receiveData(&uartHandle,receiveBuffer,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c70": "initialize_serial_communication_08004c70",
                "serialFlush": "flushBuffer",
                "HAL_UART_Receive_IT": "receiveData",
                "&huart1": "&uartHandle",
                "rx_buffer": "receiveBuffer"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "serialFlush",
                "HAL_UART_Receive_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c8c": {
            "entrypoint": "0x08004c8c",
            "current_name": "serial_write_data_08004c8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid serialWriteData_08004c8c(char *inputData)\n\n{\n  size_t inputSize;\n  uchar *currentChar;\n  \n  for (currentChar = (uchar *)inputData; inputSize = strlen(inputData), (uint)((int)currentChar - (int)inputData) < inputSize;\n      currentChar = currentChar + 1) {\n    serialWrite(*currentChar);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c8c": "serial_write_data_08004c8c",
                "data": "inputData",
                "sVar1": "inputSize",
                "puVar2": "currentChar"
            },
            "calling": [
                "MSP_SendFrame",
                "serialInt",
                "_Error_Handler"
            ],
            "called": [
                "strlen",
                "serialWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cac": {
            "entrypoint": "0x08004cac",
            "current_name": "print_integer_08004cac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid printInteger_08004cac(int value)\n\n{\n  siprintf(buffer,\"%i\",value);\n  printToSerial(buffer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004cac": "print_integer_08004cac",
                "val": "value",
                "tx_buffer": "buffer",
                "serialPrint": "printToSerial"
            },
            "calling": [
                "_Error_Handler"
            ],
            "called": [
                "siprintf",
                "serialPrint"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ccc": {
            "entrypoint": "0x08004ccc",
            "current_name": "configure_interrupts_08004ccc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureInterrupts_08004ccc(void)\n\n{\n  uint32_t temporaryRegister;\n  \n  _DAT_40021018 = _DAT_40021018 | 1;\n  HAL_NVIC_SetPriorityGrouping(3);\n  HAL_NVIC_SetPriority(MemoryManagement_IRQn,0,0);\n  HAL_NVIC_SetPriority(BusFault_IRQn,0,0);\n  HAL_NVIC_SetPriority(UsageFault_IRQn,0,0);\n  HAL_NVIC_SetPriority(SVCall_IRQn,0,0);\n  HAL_NVIC_SetPriority(DebugMonitor_IRQn,0,0);\n  HAL_NVIC_SetPriority(PendSV_IRQn,0,0);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ccc": "configure_interrupts_08004ccc",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d48": {
            "entrypoint": "0x08004d48",
            "current_name": "initialize_i2_cgpio_08004d48",
            "code": "\n/* WARNING: Variable defined which should be unmapped: gpioInitStruct */\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeI2CGPIO_08004d48(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t temporaryRegister;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  if (i2cHandle->Instance == (I2C_TypeDef *)0x40005400) {\n    gpioInitStruct.Pin = 0xc0;\n    gpioInitStruct.Mode = 0x12;\n    gpioInitStruct.Speed = 3;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40010c00,&gpioInitStruct);\n    _DAT_4002101c = _DAT_4002101c | 0x200000;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d48": "initialize_i2_cgpio_08004d48",
                "hi2c": "i2cHandle",
                "GPIO_InitStruct": "gpioInitStruct",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_Init"
            ],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d8c": {
            "entrypoint": "0x08004d8c",
            "current_name": "initialize_tim_interrupts_08004d8c",
            "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n/* WARNING: Unknown calling convention */\n\nvoid initialize_TIM_interrupts_08004d8c(TIM_HandleTypeDef *tim_handle)\n\n{\n  TimerTypeDef *timer_instance;\n  uint32_t temporary_register;\n  uint32_t temporary_register_1;\n  uint32_t temporary_register_2;\n  uint32_t temporary_register_3;\n  \n  timer_instance = tim_handle->Instance;\n  if (timer_instance == (TimerTypeDef *)0x40012c00) {\n    _DAT_40021018 = _DAT_40021018 | 0x800;\n  }\n  else if (timer_instance == (TimerTypeDef *)0x40000000) {\n    _DAT_4002101c = _DAT_4002101c | 1;\n  }\n  else if (timer_instance == (TimerTypeDef *)0x40000400) {\n    _DAT_4002101c = _DAT_4002101c | 2;\n  }\n  else if (timer_instance == (TimerTypeDef *)0x40000800) {\n    _DAT_4002101c = _DAT_4002101c | 4;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d8c": "initialize_tim_interrupts_08004d8c",
                "htim_pwm": "tim_handle",
                "TIM_TypeDef": "TimerTypeDef",
                "pTVar1": "timer_instance",
                "tmpreg": "temporary_register",
                "tmpreg_1": "temporary_register_1",
                "tmpreg_2": "temporary_register_2",
                "tmpreg_3": "temporary_register_3"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e14": {
            "entrypoint": "0x08004e14",
            "current_name": "initialize_gpio_08004e14",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeGPIO_08004e14(TIM_HandleTypeDef *timer)\n\n{\n  GPIO_TypeDef *GPIO;\n  TIM_TypeDef *timInstance;\n  GPIO_InitTypeDef gpioConfig;\n  \n  timInstance = timer->Instance;\n  if (timInstance == (TIM_TypeDef *)0x40012c00) {\n    gpioConfig.Pin = 0x800;\n  }\n  else {\n    if (timInstance != (TIM_TypeDef *)0x40000000) {\n      if (timInstance == (TIM_TypeDef *)0x40000400) {\n        gpioConfig.Pin = 3;\n      }\n      else {\n        if (timInstance != (TIM_TypeDef *)0x40000800) {\n          return;\n        }\n        gpioConfig.Pin = 0x300;\n      }\n      GPIO = (GPIO_TypeDef *)0x40010c00;\n      goto LAB_08004e2e;\n    }\n    gpioConfig.Pin = 2;\n  }\n  GPIO = (GPIO_TypeDef *)0x40010800;\nLAB_08004e2e:\n  gpioConfig.Speed = 2;\n  gpioConfig.Mode = 2;\n  HAL_GPIO_Init(GPIO,&gpioConfig);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e14": "initialize_gpio_08004e14",
                "htim": "timer",
                "GPIOx": "GPIO",
                "GPIO_InitStruct": "gpioConfig",
                "pTVar1": "timInstance"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e7c": {
            "entrypoint": "0x08004e7c",
            "current_name": "configure_usart_08004e7c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureUSART_08004e7c(UART_HandleTypeDef *uartHandle)\n\n{\n  uint32_t temporaryRegister;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  if (uartHandle->Instance == (USART_TypeDef *)0x40013800) {\n    _DAT_40021018 = _DAT_40021018 | 0x4000;\n    gpioInitStruct.Pin = 0x200;\n    gpioInitStruct.Mode = 2;\n    gpioInitStruct.Speed = 3;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40010800,&gpioInitStruct);\n    gpioInitStruct.Pin = 0x400;\n    gpioInitStruct.Mode = 0;\n    gpioInitStruct.Pull = 0;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40010800,&gpioInitStruct);\n    HAL_NVIC_SetPriority(USART1_IRQn,0,0);\n    HAL_NVIC_EnableIRQ(USART1_IRQn);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e7c": "configure_usart_08004e7c",
                "huart": "uartHandle",
                "tmpreg": "temporaryRegister",
                "GPIO_InitStruct": "gpioInitStruct"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_GPIO_Init",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee4": {
            "entrypoint": "0x08004ee4",
            "current_name": "FUNC_08004ee4",
            "code": "\nvoid FUNC_08004ee4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ee4": "FUNC_08004ee4"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee6": {
            "entrypoint": "0x08004ee6",
            "current_name": "endless_loop_08004ee6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid endlessLoop_08004ee6(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004ee6": "endless_loop_08004ee6"
            },
            "calling": [
                "HardFault_Handler"
            ],
            "called": [
                "HardFault_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee8": {
            "entrypoint": "0x08004ee8",
            "current_name": "infinite_loop_08004ee8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infinite_loop_08004ee8(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004ee8": "infinite_loop_08004ee8"
            },
            "calling": [
                "MemManage_Handler"
            ],
            "called": [
                "MemManage_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004eea": {
            "entrypoint": "0x08004eea",
            "current_name": "infinite_loop_08004eea",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08004eea(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004eea": "infinite_loop_08004eea"
            },
            "calling": [
                "BusFault_Handler"
            ],
            "called": [
                "BusFault_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004eec": {
            "entrypoint": "0x08004eec",
            "current_name": "infinite_loop_08004eec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08004eec(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004eec": "infinite_loop_08004eec"
            },
            "calling": [
                "UsageFault_Handler"
            ],
            "called": [
                "UsageFault_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004eee": {
            "entrypoint": "0x08004eee",
            "current_name": "FUNC_08004eee",
            "code": "\nvoid FUNC_08004eee(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004eee": "FUNC_08004eee"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef0": {
            "entrypoint": "0x08004ef0",
            "current_name": "FUNC_08004ef0",
            "code": "\nvoid FUNC_08004ef0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef0": "FUNC_08004ef0"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef2": {
            "entrypoint": "0x08004ef2",
            "current_name": "FUNC_08004ef2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004ef2(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef2": "FUNC_08004ef2"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef4": {
            "entrypoint": "0x08004ef4",
            "current_name": "handle_sys_tick_irq_08004ef4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickIRQ_08004ef4(void)\n\n{\n  incrementTick();\n  processSysTickInterrupt();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef4": "handle_sys_tick_irq_08004ef4",
                "HAL_IncTick": "incrementTick",
                "HAL_SYSTICK_IRQHandler": "processSysTickInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_IncTick",
                "HAL_SYSTICK_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f04": {
            "entrypoint": "0x08004f04",
            "current_name": "handle_uart_interrupt_08004f04",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART_interrupt_08004f04(void)\n\n{\n  HAL_UART_IRQHandler(UART_handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f04": "handle_uart_interrupt_08004f04",
                "&huart1": "UART_handler"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f10": {
            "entrypoint": "0x08004f10",
            "current_name": "initialize_registers_08004f10",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeRegisters_08004f10(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f10": "initialize_registers_08004f10"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f5c": {
            "entrypoint": "0x08004f5c",
            "current_name": "FUN_08004f5c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_GetTick(void)\n\n{\n  return uwTick;\n}\n\n",
            "renaming": {},
            "calling": [
                "taskScheduler",
                "MS5611_Update"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f60": {
            "entrypoint": "0x08004f60",
            "current_name": "get_system_uptime_08004f60",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemUptime_08004f60(void)\n\n{\n  return systemUptime;\n}\n\n",
            "renaming": {
                "FUN_08004f60": "get_system_uptime_08004f60",
                "uwTick": "systemUptime"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f64": {
            "entrypoint": "0x08004f64",
            "current_name": "FUNC_08004f64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004f64(uint32_t Delay)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f64": "FUNC_08004f64"
            },
            "calling": [
                "LED_StartupSequence",
                "MS5611_Init",
                "I2C_WriteByte",
                "_Error_Handler"
            ],
            "called": [
                "HAL_Delay"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004f68": {
            "entrypoint": "0x08004f68",
            "current_name": "initialize_system_08004f68",
            "code": "\nvoid initializeSystem_08004f68(void)\n\n{\n  int index;\n  undefined4 *ptr;\n  code *jumptable;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &completed_8672; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&_sidata + index);\n  }\n  for (ptr = &completed_8672; ptr < &_ebss; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumptable = (code *)0x8004f9a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08004f9a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumptable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f68": "initialize_system_08004f68",
                "iVar1": "index",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "jumptable"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004fb0": {
            "entrypoint": "0x08004fb0",
            "current_name": "infinite_loop_08004fb0",
            "code": "\nvoid infiniteLoop_08004fb0(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004fb0": "infinite_loop_08004fb0"
            },
            "calling": [
                "USBWakeUp_IRQHandler"
            ],
            "called": [
                "USBWakeUp_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004fb4": {
            "entrypoint": "0x08004fb4",
            "current_name": "initialize_and_execute_08004fb4",
            "code": "\nvoid initializeAndExecute_08004fb4(EVP_PKEY_CTX *context)\n\n{\n  int iterator;\n  \n  for (iterator = 0; iterator != 0; iterator = iterator + 1) {\n    context = (EVP_PKEY_CTX *)(*(code *)(&__frame_dummy_init_array_entry)[iterator])();\n  }\n  _init(context);\n  for (iterator = 0; iterator != 1; iterator = iterator + 1) {\n    (*(code *)(&__frame_dummy_init_array_entry)[iterator])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004fb4": "initialize_and_execute_08004fb4",
                "param_1": "context",
                "iVar1": "iterator"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "_init",
                "frame_dummy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ffc": {
            "entrypoint": "0x08004ffc",
            "current_name": "formatted_print_08004ffc",
            "code": "\nint formattedPrint_08004ffc(char *string,char *format,...)\n\n{\n  int returnValue;\n  undefined4 arg2;\n  undefined4 arg3;\n  char *stringArray [2];\n  undefined4 maxLength1;\n  undefined2 constant1;\n  undefined2 constant2;\n  char *stringPointer;\n  undefined4 maxLength2;\n  char *formatPointer;\n  undefined4 impureArg2;\n  undefined4 impureArg3;\n  \n  constant1 = 0x208;\n  maxLength1 = 0x7fffffff;\n  maxLength2 = 0x7fffffff;\n  constant2 = 0xffff;\n  stringArray[0] = string;\n  stringPointer = string;\n  formatPointer = format;\n  impureArg2 = arg2;\n  impureArg3 = arg3;\n  returnValue = _svfiprintf_r(_impure_ptr,stringArray,format);\n  *stringArray[0] = '\\0';\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08004ffc": "formatted_print_08004ffc",
                "__s": "string",
                "__format": "format",
                "iVar1": "returnValue",
                "in_r2": "arg2",
                "in_r3": "arg3",
                "local_78": "stringArray",
                "local_70": "maxLength1",
                "local_6c": "constant1",
                "local_6a": "constant2",
                "local_68": "stringPointer",
                "local_64": "maxLength2",
                "pcStack_c": "formatPointer",
                "uStack_8": "impureArg2",
                "uStack_4": "impureArg3"
            },
            "calling": [
                "serialInt"
            ],
            "called": [
                "_svfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005044": {
            "entrypoint": "0x08005044",
            "current_name": "reverse_and_improve_code_08005044",
            "code": "\nundefined4 reverse_and_improve_code_08005044(undefined4 *status,void **data,void *source,void *dest)\n\n{\n  void *new_memory;\n  void *current_memory;\n  size_t data_length;\n  \n  current_memory = data[2];\n  if ((current_memory <= dest) && ((*(ushort *)(data + 3) & 0x480) != 0)) {\n    data_length = (int)*data - (int)data[4];\n    current_memory = (void *)((uint)((int)data[5] * 3) / 2);\n    new_memory = (void *)((int)dest + data_length + 1);\n    if (current_memory < new_memory) {\n      current_memory = new_memory;\n    }\n    if ((int)((uint)*(ushort *)(data + 3) << 0x15) < 0) {\n      new_memory = (void *)_malloc_r(status,current_memory);\n      if (new_memory == (void *)0x0) {\nLAB_0800508a:\n        *status = 0xc;\n        *(ushort *)(data + 3) = *(ushort *)(data + 3) | 0x40;\n        return 0xffffffff;\n      }\n      memcpy(new_memory,data[4],data_length);\n      *(ushort *)(data + 3) = *(ushort *)(data + 3) & 0xfb7f | 0x80;\n    }\n    else {\n      new_memory = (void *)_realloc_r(status,data[4],current_memory);\n      if (new_memory == (void *)0x0) {\n        _free_r(status,data[4]);\n        goto LAB_0800508a;\n      }\n    }\n    data[4] = new_memory;\n    *data = (void *)((int)new_memory + data_length);\n    data[5] = current_memory;\n    data[2] = (void *)((int)current_memory - data_length);\n    current_memory = dest;\n  }\n  if (dest <= current_memory) {\n    current_memory = dest;\n  }\n  memmove(*data,source,(size_t)current_memory);\n  data[2] = (void *)((int)data[2] - (int)current_memory);\n  *data = (void *)((int)current_memory + (int)*data);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005044": "reverse_and_improve_code_08005044",
                "param_1": "status",
                "param_2": "data",
                "param_3": "source",
                "param_4": "dest",
                "pvVar1": "new_memory",
                "pvVar2": "current_memory",
                "__n": "data_length"
            },
            "calling": [
                "_svfiprintf_r"
            ],
            "called": [
                "_free_r",
                "memmove",
                "_malloc_r",
                "memcpy",
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080050fc": {
            "entrypoint": "0x080050fc",
            "current_name": "parse_format_string_080050fc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005294) */\n\nint parseFormatString_080050fc(undefined4 *errnum,int *formats,byte *formatString,int *args)\n\n{\n  bool foundNumber;\n  int value;\n  int result;\n  void *memchrResult;\n  int *argsPointer;\n  byte *currentChar;\n  byte *temp;\n  int printfResult;\n  int *argsPointerCopy;\n  uint flags;\n  int width;\n  undefined4 precision;\n  int argIndex;\n  int totalLength;\n  byte conversionSpecifier;\n  undefined lengthModifier1;\n  undefined lengthModifier2;\n  undefined signFlag;\n  undefined4 formatParserState;\n  \n  argsPointerCopy = args;\n  if (((int)((uint)*(ushort *)(formats + 3) << 0x18) < 0) && (formats[4] == 0)) {\n    value = _malloc_r(errnum,0x40);\n    *formats = value;\n    formats[4] = value;\n    if (value == 0) {\n      *errnum = 0xc;\n      return -1;\n    }\n    formats[5] = 0x40;\n  }\n  totalLength = 0;\n  lengthModifier1 = 0x20;\n  lengthModifier2 = 0x30;\n  currentChar = formatString;\nLAB_08005146:\n  temp = currentChar;\n  if (*temp != 0) goto LAB_080051ca;\n  goto LAB_08005150;\nLAB_080051ca:\n  currentChar = temp + 1;\n  if (*temp != 0x25) goto LAB_08005146;\nLAB_08005150:\n  value = (int)temp - (int)formatString;\n  if (value != 0) {\n    result = __ssputs_r(errnum,formats,formatString,value);\n    if (result == -1) {\nLAB_080052ac:\n      if ((int)((uint)*(ushort *)(formats + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return totalLength;\n    }\n    totalLength = totalLength + value;\n  }\n  if (*temp == 0) goto LAB_080052ac;\n  flags = 0;\n  argIndex = 0;\n  width = -1;\n  precision = 0;\n  signFlag = 0;\n  formatParserState = 0;\n  currentChar = temp + 1;\n  while( true ) {\n    memchrResult = memchr(&DAT_08007379,(uint)*currentChar,5);\n    formatString = currentChar + 1;\n    if (memchrResult == (void *)0x0) break;\n    flags = 1 << ((int)memchrResult + 0xf7ff8c87U & 0xff) | flags;\n    currentChar = formatString;\n  }\n  if ((int)(flags << 0x1b) < 0) {\n    signFlag = 0x20;\n  }\n  if ((int)(flags << 0x1c) < 0) {\n    signFlag = 0x2b;\n  }\n  if (*currentChar == 0x2a) {\n    argsPointer = argsPointerCopy + 1;\n    value = *argsPointerCopy;\n    argsPointerCopy = argsPointer;\n    if (value < 0) {\n      argIndex = -value;\n      flags = flags | 2;\n      goto LAB_080051fc;\n    }\n  }\n  else {\n    foundNumber = false;\n    value = argIndex;\n    formatString = currentChar;\n    while( true ) {\n      if (9 < *formatString - 0x30) break;\n      value = value * 10 + (*formatString - 0x30);\n      foundNumber = true;\n      formatString = formatString + 1;\n    }\n    if (!foundNumber) goto LAB_080051fc;\n  }\n  argIndex = value;\nLAB_080051fc:\n  if (*formatString == 0x2e) {\n    if (formatString[1] == 0x2a) {\n      formatString = formatString + 2;\n      argsPointer = argsPointerCopy + 1;\n      width = *argsPointerCopy;\n      argsPointerCopy = argsPointer;\n      if (width < 0) {\n        width = -1;\n      }\n    }\n    else {\n      foundNumber = false;\n      value = 0;\n      width = 0;\n      while( true ) {\n        formatString = formatString + 1;\n        if (9 < *formatString - 0x30) break;\n        value = value * 10 + (*formatString - 0x30);\n        foundNumber = true;\n      }\n      if (foundNumber) {\n        width = value;\n      }\n    }\n  }\n  memchrResult = memchr(&DAT_0800737f,(uint)*formatString,3);\n  if (memchrResult != (void *)0x0) {\n    formatString = formatString + 1;\n    flags = flags | 0x40 << ((int)memchrResult + 0xf7ff8c81U & 0xff);\n  }\n  conversionSpecifier = *formatString;\n  formatString = formatString + 1;\n  memchrResult = memchr(\"efgEFG\",(uint)conversionSpecifier,6);\n  if (memchrResult == (void *)0x0) {\n    printfResult = _printf_i(errnum,&flags,formats,0x8005045,&argsPointerCopy);\n    if (printfResult == -1) goto LAB_080052ac;\n  }\n  else {\n    argsPointerCopy = (int *)(((int)argsPointerCopy + 7U & 0xfffffff8) + 8);\n  }\n  totalLength = totalLength + printfResult;\n  currentChar = formatString;\n  goto LAB_08005146;\n}\n\n",
            "renaming": {
                "FUN_080050fc": "parse_format_string_080050fc",
                "param_1": "errnum",
                "param_2": "formats",
                "param_3": "formatString",
                "param_4": "args",
                "bVar1": "foundNumber",
                "iVar2": "value",
                "iVar3": "result",
                "pvVar4": "memchrResult",
                "piVar5": "argsPointer",
                "pbVar6": "currentChar",
                "pbVar7": "temp",
                "unaff_r9": "printfResult",
                "local_8c": "argsPointerCopy",
                "local_88": "flags",
                "local_84": "width",
                "local_80": "precision",
                "local_7c": "argIndex",
                "local_74": "totalLength",
                "local_70": "conversionSpecifier",
                "local_6f": "lengthModifier1",
                "local_6e": "lengthModifier2",
                "local_45": "signFlag",
                "local_30": "formatParserState"
            },
            "calling": [
                "siprintf"
            ],
            "called": [
                "__ssputs_r",
                "memchr",
                "_malloc_r",
                "_printf_i"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052e4": {
            "entrypoint": "0x080052e4",
            "current_name": "process_data_080052e4",
            "code": "\nundefined4\nprocess_data_080052e4(undefined4 input_buffer,uint *data,uint *output_size,undefined4 param_4,code *callback)\n\n{\n  int i;\n  int result;\n  uint max_output_size;\n  uint additional_size;\n  bool is_condition_true;\n  \n  max_output_size = data[4];\n  if ((int)data[4] < (int)data[2]) {\n    max_output_size = data[2];\n  }\n  *output_size = max_output_size;\n  if (*(char *)((int)data + 0x43) != '\\0') {\n    *output_size = max_output_size + 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *output_size = *output_size + 2;\n  }\n  if ((*data & 6) == 0) {\n    for (i = 0; i < (int)(data[3] - *output_size); i = i + 1) {\n      result = (*callback)(input_buffer,param_4,(int)data + 0x19,1);\n      if (result == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  max_output_size = (uint)*(byte *)((int)data + 0x43);\n  if (max_output_size != 0) {\n    max_output_size = 1;\n  }\n  additional_size = max_output_size;\n  if ((int)(*data << 0x1a) < 0) {\n    *(undefined *)((int)data + max_output_size + 0x43) = 0x30;\n    additional_size = max_output_size + 2;\n    *(undefined *)((int)data + max_output_size + 0x44) = *(undefined *)((int)data + 0x45);\n  }\n  i = (*callback)(input_buffer,param_4,(int)data + 0x43,additional_size);\n  if (i != -1) {\n    max_output_size = data[3];\n    is_condition_true = (*data & 6) != 4;\n    if (is_condition_true) {\n      max_output_size = 0;\n    }\n    additional_size = 0;\n    if (!is_condition_true) {\n      max_output_size = max_output_size - *output_size;\n    }\n    if (!is_condition_true) {\n      max_output_size = max_output_size & ~((int)max_output_size >> 0x1f);\n    }\n    if ((int)data[4] < (int)data[2]) {\n      max_output_size = max_output_size + (data[2] - data[4]);\n    }\n    while( true ) {\n      if (max_output_size == additional_size) {\n        return 0;\n      }\n      i = (*callback)(input_buffer,param_4,(int)data + 0x1a,1);\n      if (i == -1) break;\n      additional_size = additional_size + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080052e4": "process_data_080052e4",
                "param_1": "input_buffer",
                "param_2": "data",
                "param_3": "output_size",
                "param_5": "callback",
                "iVar1": "i",
                "iVar2": "result",
                "uVar3": "max_output_size",
                "uVar4": "additional_size",
                "bVar5": "is_condition_true"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053d4": {
            "entrypoint": "0x080053d4",
            "current_name": "print_formatted_output_080053d4",
            "code": "\nuint print_formatted_output_080053d4(undefined4 format_string,uint *args,undefined4 width,code *putc_function,uint **arg_ptr)\n\n{\n  byte byte_val;\n  int ret_val;\n  uint *arg_ptr_temp;\n  void *mem_ptr;\n  int putc_ret_val;\n  char *hex_digits;\n  uint arg_val;\n  uint **arg_ptr2;\n  char **str_ptr;\n  uint arg_val_temp;\n  uint arg_val2;\n  char *hex_digit_ptr;\n  char *str;\n  uint buf [2];\n  \n  byte_val = *(byte *)(args + 6);\n  str = (char *)((int)args + 0x43);\n  if (byte_val != 0x6e) {\n    if (byte_val < 0x6f) {\n      if (byte_val != 99) {\n        if (byte_val < 100) {\n          if (byte_val == 0) goto LAB_0800558e;\n          if (byte_val != 0x58) goto LAB_08005404;\n          *(undefined *)((int)args + 0x45) = 0x58;\n          hex_digits = \"0123456789ABCDEF\";\nLAB_0800551e:\n          arg_val = *args;\n          arg_ptr_temp = *arg_ptr;\n          *arg_ptr = arg_ptr_temp + 1;\n          if (((arg_val & 0x80) == 0) && ((int)(arg_val << 0x19) < 0)) {\n            arg_val_temp = (uint)*(ushort *)arg_ptr_temp;\n          }\n          else {\n            arg_val_temp = *arg_ptr_temp;\n          }\n          if ((int)(arg_val << 0x1f) < 0) {\n            *args = arg_val | 0x20;\n          }\n          if (arg_val_temp == 0) {\n            *args = *args & 0xffffffdf;\n          }\n          arg_val = 0x10;\nLAB_080054b4:\n          *(undefined *)((int)args + 0x43) = 0;\n        }\n        else {\n          if ((byte_val != 100) && (byte_val != 0x69)) goto LAB_08005404;\n          arg_val_temp = *args;\n          arg_ptr_temp = *arg_ptr;\n          if ((arg_val_temp & 0x80) == 0) {\n            *arg_ptr = arg_ptr_temp + 1;\n            if ((arg_val_temp & 0x40) == 0) goto LAB_08005424;\n            arg_val_temp = (uint)(short)*(ushort *)arg_ptr_temp;\n          }\n          else {\n            *arg_ptr = arg_ptr_temp + 1;\nLAB_08005424:\n            arg_val_temp = *arg_ptr_temp;\n          }\n          if ((int)arg_val_temp < 0) {\n            arg_val_temp = -arg_val_temp;\n            *(undefined *)((int)args + 0x43) = 0x2d;\n          }\n          hex_digits = \"0123456789ABCDEF\";\n          arg_val = 10;\n        }\n        arg_val2 = args[1];\n        args[2] = arg_val2;\n        hex_digit_ptr = str;\n        if ((int)arg_val2 < 0) {\n          if (arg_val_temp != 0) goto LAB_08005552;\nLAB_08005600:\n          *(char *)((int)args + 0x42) = *hex_digits;\n          hex_digit_ptr = (char *)((int)args + 0x42);\n        }\n        else {\n          *args = *args & 0xfffffffb;\n          if (arg_val_temp == 0) {\n            if (arg_val2 != 0) goto LAB_08005600;\n          }\n          else {\nLAB_08005552:\n            do {\n              arg_val2 = arg_val_temp / arg_val;\n              hex_digit_ptr = hex_digit_ptr + -1;\n              *hex_digit_ptr = hex_digits[arg_val_temp - arg_val * arg_val2];\n              arg_val_temp = arg_val2;\n            } while (arg_val2 != 0);\n          }\n        }\n        if (((arg_val == 8) && ((int)(*args << 0x1f) < 0)) && ((int)args[1] <= (int)args[4]))\n        {\n          hex_digit_ptr[-1] = '0';\n          hex_digit_ptr = hex_digit_ptr + -1;\n        }\n        args[4] = (int)str - (int)hex_digit_ptr;\n        str = hex_digit_ptr;\n        goto LAB_080054fa;\n      }\n      arg_ptr_temp = *arg_ptr;\n      *arg_ptr = arg_ptr_temp + 1;\n      *(char *)((int)args + 0x42) = (char)*arg_ptr_temp;\nLAB_08005464:\n      str = (char *)((int)args + 0x42);\n      arg_val_temp = 1;\n    }\n    else {\n      if (byte_val != 0x73) {\n        if (byte_val < 0x74) {\n          if (byte_val == 0x6f) {\nLAB_0800548a:\n            arg_val_temp = *args;\n            arg_ptr_temp = *arg_ptr;\n            if ((arg_val_temp & 0x80) == 0) {\n              *arg_ptr = arg_ptr_temp + 1;\n              if ((arg_val_temp & 0x40) == 0) goto LAB_08005498;\n              arg_val_temp = (uint)*(ushort *)arg_ptr_temp;\n            }\n            else {\n              *arg_ptr = arg_ptr_temp + 1;\nLAB_08005498:\n              arg_val_temp = *arg_ptr_temp;\n            }\n            if (byte_val == 0x6f) {\n              arg_val = 8;\n            }\n            else {\n              arg_val = 10;\n            }\n            hex_digits = \"0123456789ABCDEF\";\n            goto LAB_080054b4;\n          }\n          if (byte_val == 0x70) {\n            *args = *args | 0x20;\nLAB_0800544a:\n            hex_digits = \"0123456789abcdef\";\n            *(undefined *)((int)args + 0x45) = 0x78;\n            goto LAB_0800551e;\n          }\n        }\n        else {\n          if (byte_val == 0x75) goto LAB_0800548a;\n          if (byte_val == 0x78) goto LAB_0800544a;\n        }\nLAB_08005404:\n        *(byte *)((int)args + 0x42) = byte_val;\n        goto LAB_08005464;\n      }\n      str_ptr = (char **)*arg_ptr;\n      *arg_ptr = (uint *)(str_ptr + 1);\n      str = *str_ptr;\n      mem_ptr = memchr(str,0,args[1]);\n      if (mem_ptr != (void *)0x0) {\n        args[1] = (int)mem_ptr - (int)str;\n      }\n      arg_val_temp = args[1];\n    }\n    args[4] = arg_val_temp;\n    *(undefined *)((int)args + 0x43) = 0;\n    goto LAB_080054fa;\n  }\n  arg_val_temp = *args;\n  arg_ptr2 = (uint **)*arg_ptr;\n  arg_val = args[5];\n  if ((arg_val_temp & 0x80) == 0) {\n    *arg_ptr = (uint *)(arg_ptr2 + 1);\n    arg_ptr_temp = *arg_ptr2;\n    if ((arg_val_temp & 0x40) == 0) goto LAB_0800557a;\n    *(short *)arg_ptr_temp = (short)arg_val;\n  }\n  else {\n    *arg_ptr = (uint *)(arg_ptr2 + 1);\n    arg_ptr_temp = *arg_ptr2;\nLAB_0800557a:\n    *arg_ptr_temp = arg_val;\n  }\nLAB_0800558e:\n  args[4] = 0;\nLAB_080054fa:\n  ret_val = _printf_common(format_string,args,buf,width,putc_function);\n  if ((ret_val == -1) || (ret_val = (*putc_function)(format_string,width,str,args[4]), ret_val == -1)) {\nLAB_0800550e:\n    arg_val_temp = 0xffffffff;\n  }\n  else {\n    if ((int)(*args << 0x1e) < 0) {\n      for (ret_val = 0; ret_val < (int)(args[3] - buf[0]); ret_val = ret_val + 1) {\n        putc_ret_val = (*putc_function)(format_string,width,(int)args + 0x19,1);\n        if (putc_ret_val == -1) goto LAB_0800550e;\n      }\n    }\n    arg_val_temp = args[3];\n    if ((int)args[3] < (int)buf[0]) {\n      arg_val_temp = buf[0];\n    }\n  }\n  return arg_val_temp;\n}\n\n",
            "renaming": {
                "FUN_080053d4": "print_formatted_output_080053d4",
                "param_1": "format_string",
                "param_2": "args",
                "param_3": "width",
                "param_4": "putc_function",
                "param_5": "arg_ptr",
                "bVar1": "byte_val",
                "iVar2": "ret_val",
                "puVar3": "arg_ptr_temp",
                "pvVar4": "mem_ptr",
                "iVar5": "putc_ret_val",
                "pcVar6": "hex_digits",
                "uVar7": "arg_val",
                "ppuVar8": "arg_ptr2",
                "ppcVar9": "str_ptr",
                "uVar10": "arg_val_temp",
                "uVar11": "arg_val2",
                "pcVar12": "hex_digit_ptr",
                "__s": "str",
                "local_24": "buf"
            },
            "calling": [
                "_svfiprintf_r"
            ],
            "called": [
                "_printf_common",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005614": {
            "entrypoint": "0x08005614",
            "current_name": "find_first_occurrence_08005614",
            "code": "\nvoid * findFirstOccurrence_08005614(void *input,int target,size_t size)\n\n{\n  byte *source;\n  byte *currentPointer;\n  \n  source = (byte *)input;\n  do {\n    currentPointer = source;\n    if (currentPointer == (byte *)(size + (int)input)) {\n      return (void *)0x0;\n    }\n    source = currentPointer + 1;\n  } while ((uint)*currentPointer != (target & 0xffU));\n  return currentPointer;\n}\n\n",
            "renaming": {
                "FUN_08005614": "find_first_occurrence_08005614",
                "__s": "input",
                "__c": "target",
                "__n": "size",
                "pbVar1": "source",
                "pbVar2": "currentPointer"
            },
            "calling": [
                "_svfiprintf_r",
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005630": {
            "entrypoint": "0x08005630",
            "current_name": "copy_memory_08005630",
            "code": "\nvoid * copy_memory_08005630(void *destination,void *source,size_t size)\n\n{\n  undefined *dest_ptr;\n  undefined *src_ptr;\n  \n  src_ptr = (undefined *)((int)destination + -1);\n  dest_ptr = (undefined *)(size + (int)source);\n  for (; (undefined *)source != dest_ptr; source = (void *)((int)source + 1)) {\n    src_ptr = src_ptr + 1;\n    *src_ptr = *source;\n                    /* WARNING: Load size is inaccurate */\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08005630": "copy_memory_08005630",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr"
            },
            "calling": [
                "__ssputs_r",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005646": {
            "entrypoint": "0x08005646",
            "current_name": "reverse_mem_copy_08005646",
            "code": "\nvoid * reverse_mem_copy_08005646(void *destination,void *source,size_t length)\n\n{\n  undefined *dest_ptr;\n  int remaining_length;\n  undefined *src_ptr;\n  \n  src_ptr = (undefined *)((int)source + length);\n  if ((source < destination) && (destination < src_ptr)) {\n    dest_ptr = (undefined *)((int)destination + length);\n    remaining_length = length - (int)src_ptr;\n    while (src_ptr + remaining_length != (undefined *)0x0) {\n      src_ptr = src_ptr + -1;\n      dest_ptr = dest_ptr + -1;\n      *dest_ptr = *src_ptr;\n    }\n    return destination;\n  }\n  dest_ptr = (undefined *)((int)destination + -1);\n  for (; (undefined *)source != src_ptr; source = (void *)((int)source + 1)) {\n    dest_ptr = dest_ptr + 1;\n    *dest_ptr = *source;\n                    /* WARNING: Load size is inaccurate */\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08005646": "reverse_mem_copy_08005646",
                "__dest": "destination",
                "__src": "source",
                "__n": "length",
                "puVar1": "dest_ptr",
                "iVar2": "remaining_length",
                "puVar3": "src_ptr"
            },
            "calling": [
                "__ssputs_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800567c": {
            "entrypoint": "0x0800567c",
            "current_name": "allocate_memory_0800567c",
            "code": "\nvoid allocateMemory_0800567c(undefined4 *result,int size,undefined4 ptr1,undefined4 ptr2)\n\n{\n  int **prevNode;\n  int **currentNode;\n  int **nextNode;\n  int *offset;\n  int **iterator1;\n  int **iterator2;\n  \n  if (size == 0) {\n    return;\n  }\n  iterator2 = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    iterator2 = (int **)((int)iterator2 + *(int *)(size + -4));\n  }\n  lockMemory();\n  nextNode = (int **)&freeList;\n  if (freeList == (int **)0x0) {\n    iterator2[1] = (int *)0x0;\n    currentNode = prevNode;\n    freeList = iterator2;\n  }\n  else {\n    nextNode = freeList;\n    if (iterator2 < freeList) {\n      currentNode = (int **)*iterator2;\n      nextNode = (int **)((int)iterator2 + (int)currentNode);\n      if (freeList == nextNode) {\n        offset = *freeList;\n        freeList = (int **)freeList[1];\n        nextNode = (int **)((int)offset + (int)currentNode);\n        *iterator2 = (int *)nextNode;\n      }\n      iterator2[1] = (int *)freeList;\n      freeList = iterator2;\n    }\n    else {\n      do {\n        iterator1 = nextNode;\n        nextNode = (int **)iterator1[1];\n        if (nextNode == (int **)0x0) break;\n      } while (nextNode <= iterator2);\n      currentNode = (int **)*iterator1;\n      if ((int **)((int)iterator1 + (int)currentNode) == iterator2) {\n        currentNode = (int **)((int)currentNode + (int)*iterator2);\n        *iterator1 = (int *)currentNode;\n        if (nextNode == (int **)((int)iterator1 + (int)currentNode)) {\n          offset = *nextNode;\n          nextNode = (int **)nextNode[1];\n          currentNode = (int **)((int)currentNode + (int)offset);\n          *iterator1 = (int *)currentNode;\n          iterator1[1] = (int *)nextNode;\n        }\n      }\n      else if (iterator2 < (int **)((int)iterator1 + (int)currentNode)) {\n        *result = 0xc;\n      }\n      else {\n        currentNode = (int **)((int)iterator2 + (int)*iterator2);\n        if (nextNode == currentNode) {\n          offset = *nextNode;\n          nextNode = (int **)nextNode[1];\n          currentNode = (int **)((int)offset + (int)*iterator2);\n          *iterator2 = (int *)currentNode;\n        }\n        iterator2[1] = (int *)nextNode;\n        iterator1[1] = (int *)iterator2;\n      }\n    }\n  }\n  unlockMemory(result,currentNode,nextNode,ptr2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800567c": "allocate_memory_0800567c",
                "param_1": "result",
                "param_2": "size",
                "param_3": "ptr1",
                "param_4": "ptr2",
                "extraout_r1": "prevNode",
                "ppiVar1": "currentNode",
                "ppiVar2": "nextNode",
                "piVar3": "offset",
                "ppiVar4": "iterator1",
                "ppiVar5": "iterator2",
                "__malloc_lock": "lockMemory",
                "__malloc_free_list": "freeList",
                "__malloc_unlock": "unlockMemory"
            },
            "calling": [
                "__ssputs_r",
                "_realloc_r"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "allocate_memory_08005714",
            "code": "\nuint allocate_memory_08005714(undefined4 *size_ptr,uint size)\n\n{\n  uint *free_list_ptr;\n  int iteration_var;\n  uint *current_ptr;\n  uint difference;\n  uint *prev_ptr;\n  uint alloc_size;\n  \n  alloc_size = (size + 3 & 0xfffffffc) + 8;\n  if (alloc_size < 0xc) {\n    alloc_size = 0xc;\n  }\n  if (((int)alloc_size < 0) || (alloc_size < size)) {\n    *size_ptr = 0xc;\n  }\n  else {\n    acquire_lock();\n    free_list_ptr = global_free_list;\n    prev_ptr = global_free_list;\n    while (current_ptr = free_list_ptr, current_ptr != (uint *)0x0) {\n      difference = *current_ptr - alloc_size;\n      if (-1 < (int)difference) {\n        if (difference < 0xc) {\n          if (prev_ptr == current_ptr) {\n            free_list_ptr = (uint *)prev_ptr[1];\n            global_free_list = free_list_ptr;\n          }\n          else {\n            free_list_ptr = (uint *)current_ptr[1];\n          }\n          if (prev_ptr != current_ptr) {\n            prev_ptr[1] = (uint)free_list_ptr;\n            prev_ptr = current_ptr;\n          }\n        }\n        else {\n          *current_ptr = difference;\n          *(uint *)((int)current_ptr + difference) = alloc_size;\n          prev_ptr = (uint *)((int)current_ptr + difference);\n        }\n        goto LAB_08005778;\n      }\n      prev_ptr = current_ptr;\n      free_list_ptr = (uint *)current_ptr[1];\n    }\n    if (sbrk_start == 0) {\n      sbrk_start = sbrk_r(size_ptr);\n    }\n    free_list_ptr = (uint *)sbrk_r(size_ptr,alloc_size);\n    if ((free_list_ptr != (uint *)0xffffffff) &&\n       ((prev_ptr = (uint *)((int)free_list_ptr + 3U & 0xfffffffc), free_list_ptr == prev_ptr ||\n        (iteration_var = sbrk_r(size_ptr,(int)prev_ptr - (int)free_list_ptr), iteration_var != -1)))) {\n      *prev_ptr = alloc_size;\nLAB_08005778:\n      release_lock(size_ptr);\n      alloc_size = (int)prev_ptr + 0xbU & 0xfffffff8;\n      iteration_var = alloc_size - (int)(prev_ptr + 1);\n      if (iteration_var != 0) {\n        *(int *)((int)prev_ptr + iteration_var) = -iteration_var;\n        return alloc_size;\n      }\n      return alloc_size;\n    }\n    *size_ptr = 0xc;\n    release_lock(size_ptr);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005714": "allocate_memory_08005714",
                "param_1": "size_ptr",
                "param_2": "size",
                "puVar1": "free_list_ptr",
                "iVar2": "iteration_var",
                "puVar3": "current_ptr",
                "uVar4": "difference",
                "puVar5": "prev_ptr",
                "uVar6": "alloc_size",
                "__malloc_lock": "acquire_lock",
                "__malloc_free_list": "global_free_list",
                "__malloc_sbrk_start": "sbrk_start",
                "_sbrk_r": "sbrk_r",
                "__malloc_unlock": "release_lock"
            },
            "calling": [
                "__ssputs_r",
                "_svfiprintf_r",
                "_realloc_r"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock",
                "_sbrk_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057d0": {
            "entrypoint": "0x080057d0",
            "current_name": "realloc_or_malloc_080057d0",
            "code": "\nvoid * realloc_or_malloc_080057d0(undefined4 ptr_realloc,void *ptr_input,uint size,undefined4 param_4)\n\n{\n  void *result_ptr;\n  uint usable_size;\n  \n  if (ptr_input != (void *)0x0) {\n    if (size == 0) {\n      _free_r();\n      result_ptr = (void *)0x0;\n    }\n    else {\n      usable_size = _malloc_usable_size_r();\n      result_ptr = ptr_input;\n      if ((usable_size < size) && (result_ptr = (void *)_malloc_r(ptr_realloc,size), result_ptr != (void *)0x0))\n      {\n        memcpy(result_ptr,ptr_input,size);\n        _free_r(ptr_realloc,ptr_input);\n      }\n    }\n    return result_ptr;\n  }\n  result_ptr = (void *)_malloc_r(ptr_realloc,size,size,param_4);\n  return result_ptr;\n}\n\n",
            "renaming": {
                "FUN_080057d0": "realloc_or_malloc_080057d0",
                "param_1": "ptr_realloc",
                "param_2": "ptr_input",
                "param_3": "size",
                "pvVar1": "result_ptr",
                "uVar2": "usable_size"
            },
            "calling": [
                "__ssputs_r"
            ],
            "called": [
                "_free_r",
                "_malloc_usable_size_r",
                "_malloc_r",
                "memcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800581c": {
            "entrypoint": "0x0800581c",
            "current_name": "allocate_memory_0800581c",
            "code": "\nvoid allocateMemory_0800581c(int *errorCode,intptr_t sizeToAllocate)\n\n{\n  void *memoryPointer;\n  \n  errno = 0;\n  memoryPointer = _sbrk(sizeToAllocate);\n  if ((memoryPointer == (void *)0xffffffff) && (errno != 0)) {\n    *errorCode = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800581c": "allocate_memory_0800581c",
                "param_1": "errorCode",
                "param_2": "sizeToAllocate",
                "pvVar1": "memoryPointer"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800583c": {
            "entrypoint": "0x0800583c",
            "current_name": "FUNC_0800583c",
            "code": "\nvoid FUNC_0800583c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800583c": "FUNC_0800583c"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800583e": {
            "entrypoint": "0x0800583e",
            "current_name": "FUNC_0800583e",
            "code": "\nvoid FUNC_0800583e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800583e": "FUNC_0800583e"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005840": {
            "entrypoint": "0x08005840",
            "current_name": "calculate_result_08005840",
            "code": "\nint calculateResult_08005840(undefined4 undefinedParam,int inputParam)\n\n{\n  int resultVar;\n  \n  resultVar = *(int *)(inputParam + -4) + -4;\n  if (*(int *)(inputParam + -4) < 0) {\n    resultVar = resultVar + *(int *)(inputParam + resultVar);\n  }\n  return resultVar;\n}\n\n",
            "renaming": {
                "FUN_08005840": "calculate_result_08005840",
                "param_1": "undefinedParam",
                "param_2": "inputParam",
                "iVar1": "resultVar"
            },
            "calling": [
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005854": {
            "entrypoint": "0x08005854",
            "current_name": "compute_asin_08005854",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080058d4) */\n\ndouble compute_asin_08005854(double input_value)\n\n{\n  int comparison_result;\n  undefined4 *error_indicator;\n  double result;\n  double temp_var1;\n  double temp_var2;\n  double temp_var3;\n  double temp_var4;\n  int value_1;\n  char *value_2;\n  \n  result = (double)__ieee754_asin();\n  if ((__fdlib_version != -1) && (comparison_result = __unorddf2(), result = temp_var1, comparison_result == 0)) {\n    fabs((double)CONCAT44(value_2,value_1));\n    comparison_result = __aeabi_dcmpgt();\n    result = temp_var2;\n    if ((comparison_result != 0) &&\n       ((nan(\"\"), __fdlib_version == '\\x02' ||\n        (comparison_result = matherr((exception *)&stack0xffffffb8), result = temp_var4, comparison_result == 0)))) {\n      error_indicator = (undefined4 *)__errno();\n      *error_indicator = 0x21;\n      result = temp_var3;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005854": "compute_asin_08005854",
                "__x": "input_value",
                "iVar1": "comparison_result",
                "puVar2": "error_indicator",
                "dVar3": "result",
                "extraout_d0": "temp_var1",
                "extraout_d0_00": "temp_var2",
                "extraout_d0_01": "temp_var3",
                "extraout_d0_02": "temp_var4",
                "in_stack_ffffffb8": "value_1",
                "in_stack_ffffffbc": "value_2"
            },
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__errno",
                "fabs",
                "matherr",
                "__aeabi_dcmpgt",
                "nan",
                "__ieee754_asin",
                "__unorddf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058fc": {
            "entrypoint": "0x080058fc",
            "current_name": "FUN_080058fc",
            "code": "\nundefined8 __ieee754_atan2(uint param_1,uint param_2,uint param_3,uint param_4,double param_5)\n\n{\n  undefined4 uVar1;\n  undefined4 extraout_r1;\n  int extraout_r1_00;\n  undefined4 unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  uint uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  \n  uVar5 = param_4 & 0x7fffffff;\n  if ((0x7ff00000 < (uVar5 | (-param_3 | param_3) >> 0x1f)) ||\n     (uVar3 = param_2 & 0x7fffffff, 0x7ff00000 < (uVar3 | (-param_1 | param_1) >> 0x1f))) {\n    uVar6 = __aeabi_dadd(param_1,param_2);\n    return uVar6;\n  }\n  if ((param_4 + 0xc0100000 | param_3) == 0) {\n    atan(param_5);\n    return CONCAT44(extraout_r1,param_1);\n  }\n  uVar2 = (int)param_4 >> 0x1e & 2U | param_2 >> 0x1f;\n  if ((param_1 | uVar3) == 0) {\n    if (uVar2 == 2) {\n      return 0x400921fb54442d18;\n    }\n    if (uVar2 != 3) {\n      return CONCAT44(param_2,param_1);\n    }\nLAB_0800613e:\n    uVar6 = 0xc00921fb54442d18;\n  }\n  else {\n    if ((param_3 | uVar5) != 0) {\n      if (uVar5 == 0x7ff00000) {\n        if (uVar3 == 0x7ff00000) {\n          if (uVar2 == 2) {\n            return 0x4002d97c7f3321d2;\n          }\n          if (uVar2 == 3) {\n            return 0xc002d97c7f3321d2;\n          }\n          if (uVar2 != 1) {\n            return 0x3fe921fb54442d18;\n          }\n          return 0xbfe921fb54442d18;\n        }\n        if (uVar2 == 2) {\n          return 0x400921fb54442d18;\n        }\n        if (uVar2 != 3) {\n          if (uVar2 != 1) {\n            return 0;\n          }\n          return 0x8000000000000000;\n        }\n        goto LAB_0800613e;\n      }\n      if (uVar3 != 0x7ff00000) {\n        iVar4 = (int)(uVar3 - uVar5) >> 0x14;\n        if (iVar4 < 0x3d) {\n          if (((int)param_4 < 0) && (iVar4 + 0x3c < 0 != SCARRY4(iVar4,0x3c))) {\n            uVar1 = 0;\n            iVar4 = 0;\n          }\n          else {\n            uVar1 = __divdf3(param_1,param_2);\n            fabs((double)CONCAT44(unaff_r4,param_4));\n            atan((double)CONCAT44(unaff_r4,param_4));\n            iVar4 = extraout_r1_00;\n          }\n        }\n        else {\n          uVar1 = 0x54442d18;\n          iVar4 = 0x3ff921fb;\n        }\n        if (uVar2 == 1) {\n          return CONCAT44(iVar4 + -0x80000000,uVar1);\n        }\n        if (uVar2 == 2) {\n          uVar7 = __subdf3(uVar1,iVar4,0x33145c07,0x3ca1a626);\n          uVar6 = 0x400921fb54442d18;\n        }\n        else {\n          if (uVar2 == 0) {\n            return CONCAT44(iVar4,uVar1);\n          }\n          uVar6 = __subdf3(uVar1,iVar4,0x33145c07,0x3ca1a626);\n          uVar7 = 0x400921fb54442d18;\n        }\n        uVar6 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),(int)uVar7,\n                         (int)((ulonglong)uVar7 >> 0x20));\n        return uVar6;\n      }\n    }\n    if ((int)param_2 < 0) {\n      uVar6 = 0xbff921fb54442d18;\n    }\n    else {\n      uVar6 = 0x3ff921fb54442d18;\n    }\n  }\n  return uVar6;\n}\n\n",
            "renaming": {},
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__ieee754_atan2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005900": {
            "entrypoint": "0x08005900",
            "current_name": "calculate_power_08005900",
            "code": "\ndouble calculatePower_08005900(double base,double exponent)\n\n{\n  char version;\n  int result;\n  int *errno_ptr;\n  undefined4 *errno_ptr_1;\n  int temporary;\n  undefined4 extra_result_1;\n  undefined4 extra_result_2;\n  undefined4 error_code;\n  double output_1;\n  double output_2;\n  double output_3;\n  double output_4;\n  double output_5;\n  double output_6;\n  double output_7;\n  double output_8;\n  double output_9;\n  double output_10;\n  double output_11;\n  double output_12;\n  double output_13;\n  double output_14;\n  double calculated_result;\n  undefined8 result_container;\n  undefined exception_info [24];\n  undefined8 exception_result;\n  int exception_error;\n  \n  calculated_result = (double)__ieee754_pow();\n  version = __fdlib_version;\n  if (__fdlib_version == -1) {\n    return output_1;\n  }\n  result = __unorddf2();\n  if (result != 0) {\n    return output_2;\n  }\n  result = __unorddf2();\n  if (result != 0) {\n    result = __aeabi_dcmpeq();\n    if (result == 0) {\n      return output_3;\n    }\n    exception_info._0_4_ = 1;\n    exception_info._4_4_ = \"pow\";\n    exception_result = 1.0;\n    exception_error = 0;\n    if (version == '\\x02') {\n      return output_3;\n    }\n    goto LAB_08005978;\n  }\n  result = __aeabi_dcmpeq();\n  if (result == 0) {\n    result = finite(calculated_result);\n    if ((result == 0) && (temporary = finite(calculated_result), temporary != 0)) {\n      temporary = finite(calculated_result);\n      if (temporary == 0) goto LAB_08005b4c;\n      exception_error = __unorddf2(SUB84(calculated_result,0),(int)((ulonglong)calculated_result >> 0x20));\n      version = __fdlib_version;\n      if (exception_error != 0) {\n        exception_info._4_4_ = \"pow\";\n        exception_info._0_4_ = 1;\n        exception_error = result;\n        if (__fdlib_version == '\\0') goto LAB_08005a22;\n        exception_result = (double)__divdf3(0,0,0,0);\n        goto LAB_08005a32;\n      }\n      exception_info._4_4_ = \"pow\";\n      exception_info._0_4_ = 3;\n      if (__fdlib_version != '\\0') {\n        exception_result._0_4_ = 0;\n        exception_result._4_4_ = 0x7ff00000;\n        result = __aeabi_dcmplt();\n        if (result != 0) {\n          result_container = __muldf3();\n          error_code = (int)result_container;\n          rint(calculated_result);\n          result = __aeabi_dcmpeq((int)result_container,(int)((ulonglong)result_container >> 0x20),error_code,extra_result_2);\n          if (result == 0) {\n            exception_result._0_4_ = 0;\n            exception_result._4_4_ = 0xfff00000;\n          }\n        }\n        goto LAB_08005afa;\n      }\n      exception_result._0_4_ = 0xe0000000;\n      exception_result._4_4_ = 0x47efffff;\n      result = __aeabi_dcmplt();\n      if (result != 0) {\n        result_container = __muldf3();\n        error_code = (int)result_container;\n        rint(calculated_result);\n        result = __aeabi_dcmpeq((int)result_container,(int)((ulonglong)result_container >> 0x20),error_code,extra_result_1);\n        if (result == 0) {\n          exception_result._0_4_ = 0xe0000000;\n          exception_result._4_4_ = 0xc7efffff;\n        }\n        goto LAB_08005afa;\n      }\nLAB_08005b98:\n      result = matherr((exception *)exception_info);\n      calculated_result = output_14;\n      if (result != 0) goto LAB_080059d0;\n    }\n    else {\nLAB_08005b4c:\n      result = __aeabi_dcmpeq(SUB84(calculated_result,0),(int)((ulonglong)calculated_result >> 0x20),0,0);\n      if (result == 0) {\n        return output_11;\n      }\n      result = finite(calculated_result);\n      if (result == 0) {\n        return output_12;\n      }\n      result = finite(calculated_result);\n      if (result == 0) {\n        return output_13;\n      }\n      exception_info._0_4_ = 4;\n      exception_info._4_4_ = \"pow\";\n      exception_error = 0;\n      exception_result._0_4_ = 0;\n      exception_result._4_4_ = 0;\nLAB_08005afa:\n      if (__fdlib_version != '\\x02') goto LAB_08005b98;\n    }\n    errno_ptr_1 = (undefined4 *)__errno();\n    error_code = 0x22;\n    calculated_result = output_10;\n  }\n  else {\n    result = __aeabi_dcmpeq();\n    if (result == 0) {\n      result = finite(calculated_result);\n      if (result == 0) {\n        return output_7;\n      }\n      result = __aeabi_dcmplt();\n      if (result == 0) {\n        return output_8;\n      }\n      exception_info._0_4_ = 1;\n      exception_info._4_4_ = \"pow\";\n      exception_error = 0;\n      if (__fdlib_version == '\\0') {\nLAB_08005a22:\n        exception_info._4_4_ = \"pow\";\n        exception_info._0_4_ = 1;\n        exception_result = 0.0;\n        goto LAB_08005978;\n      }\n      exception_result = -INFINITY;\n      exception_error = 0;\n      version = __fdlib_version;\nLAB_08005a32:\n      if (version != '\\x02') goto LAB_08005978;\n    }\n    else {\n      exception_info._0_4_ = 1;\n      exception_info._4_4_ = \"pow\";\n      exception_result = 0.0;\n      exception_error = 0;\n      if (version != '\\0') {\n        exception_result = 1.0;\n        calculated_result = output_5;\n        goto LAB_080059d0;\n      }\nLAB_08005978:\n      result = matherr((exception *)exception_info);\n      calculated_result = output_4;\n      if (result != 0) goto LAB_080059d0;\n    }\n    errno_ptr_1 = (undefined4 *)__errno();\n    error_code = 0x21;\n    calculated_result = output_9;\n  }\n  *errno_ptr_1 = error_code;\nLAB_080059d0:\n  if (exception_error != 0) {\n    errno_ptr = (int *)__errno();\n    *errno_ptr = exception_error;\n    calculated_result = output_6;\n  }\n  return calculated_result;\n}\n\n",
            "renaming": {
                "FUN_08005900": "calculate_power_08005900",
                "__x": "base",
                "__y": "exponent",
                "cVar1": "version",
                "iVar2": "result",
                "piVar3": "errno_ptr",
                "puVar4": "errno_ptr_1",
                "iVar5": "temporary",
                "extraout_r1": "extra_result_1",
                "extraout_r1_00": "extra_result_2",
                "uVar6": "error_code",
                "extraout_d0": "output_1",
                "extraout_d0_00": "output_2",
                "extraout_d0_01": "output_3",
                "extraout_d0_02": "output_4",
                "extraout_d0_03": "output_5",
                "extraout_d0_04": "output_6",
                "extraout_d0_05": "output_7",
                "extraout_d0_06": "output_8",
                "extraout_d0_07": "output_9",
                "extraout_d0_08": "output_10",
                "extraout_d0_09": "output_11",
                "extraout_d0_10": "output_12",
                "extraout_d0_11": "output_13",
                "extraout_d0_12": "output_14",
                "dVar7": "calculated_result",
                "uVar8": "result_container",
                "local_50": "exception_info",
                "local_38": "exception_result",
                "local_30": "exception_error"
            },
            "calling": [
                "MS5611_Update"
            ],
            "called": [
                "__aeabi_dcmpeq",
                "__aeabi_dcmplt",
                "__errno",
                "rint",
                "matherr",
                "__muldf3",
                "finite",
                "__ieee754_pow",
                "__unorddf2",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bc8": {
            "entrypoint": "0x08005bc8",
            "current_name": "calculate_square_root_08005bc8",
            "code": "\ndouble calculateSquareRoot_08005bc8(double inputValue)\n\n{\n  char versionFlag;\n  int comparisonResult;\n  int *errorPtr;\n  undefined4 *errnoPtr;\n  double result;\n  double sqrtResult;\n  double comparisonResultResult;\n  double matherrResult;\n  double exceptionResult;\n  double errnoResult;\n  undefined exceptionInfo [24];\n  undefined8 divResult;\n  int unordResult;\n  \n  result = (double)__ieee754_sqrt();\n  versionFlag = __fdlib_version;\n  if (__fdlib_version == -1) {\n    return result;\n  }\n  unordResult = __unorddf2();\n  if (unordResult != 0) {\n    return sqrtResult;\n  }\n  comparisonResult = __aeabi_dcmplt();\n  if (comparisonResult == 0) {\n    return comparisonResultResult;\n  }\n  exceptionInfo._0_4_ = 1;\n  exceptionInfo._4_4_ = \"sqrt\";\n  if (versionFlag == '\\0') {\n    divResult = 0.0;\nLAB_08005c26:\n    comparisonResult = matherr((exception *)exceptionInfo);\n    result = matherrResult;\n    if (comparisonResult != 0) goto LAB_08005c2e;\n  }\n  else {\n    divResult = (double)__divdf3(0,0,0,0);\n    if (versionFlag != '\\x02') goto LAB_08005c26;\n  }\n  errnoPtr = (undefined4 *)__errno();\n  *errnoPtr = 0x21;\n  result = errnoResult;\nLAB_08005c2e:\n  if (unordResult != 0) {\n    errorPtr = (int *)__errno();\n    *errorPtr = unordResult;\n    result = exceptionResult;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005bc8": "calculate_square_root_08005bc8",
                "__x": "inputValue",
                "cVar1": "versionFlag",
                "iVar2": "comparisonResult",
                "piVar3": "errorPtr",
                "puVar4": "errnoPtr",
                "dVar5": "result",
                "extraout_d0": "sqrtResult",
                "extraout_d0_00": "comparisonResultResult",
                "extraout_d0_01": "matherrResult",
                "extraout_d0_02": "exceptionResult",
                "extraout_d0_03": "errnoResult",
                "local_50": "exceptionInfo",
                "local_38": "divResult",
                "local_30": "unordResult"
            },
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__aeabi_dcmplt",
                "__errno",
                "matherr",
                "__ieee754_sqrt",
                "__divdf3",
                "__unorddf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c70": {
            "entrypoint": "0x08005c70",
            "current_name": "calculate_square_root_08005c70",
            "code": "\nundefined8 calculateSquareRoot_08005c70(uint input1,uint input2)\n\n{\n  int comparisonResult;\n  undefined4 extraCompareResult;\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined4 temp3;\n  undefined4 temp4;\n  undefined4 temp5;\n  undefined4 temp6;\n  uint input2Masked;\n  undefined8 result1;\n  undefined8 result2;\n  undefined8 result3;\n  undefined4 stackVar;\n  \n  result1 = CONCAT44(input2,input1);\n  input2Masked = input2 & 0x7fffffff;\n  if (input2Masked < 0x3ff00000) {\n    if (input2Masked < 0x3fe00000) {\n      if (0x3e3fffff < input2Masked) {\n        result2 = multiplyDoubleFloats(input1,input2,input1,input2);\n        temp6 = (undefined4)((ulonglong)result2 >> 0x20);\n        temp5 = (undefined4)result2;\n        result2 = multiplyDoubleFloats(temp5,temp6,0xdfdf709,0x3f023de1);\n        result2 = addDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),0x7501b288,0x3f49efe0);\n        result2 = multiplyDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),temp5,temp6);\n        result2 = subtractDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),0xb5688f3b,0x3fa48228);\n        result2 = multiplyDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),temp5,temp6);\n        result2 = addDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),0xe884455,0x3fc9c155);\n        result2 = multiplyDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),temp5,temp6);\n        result2 = subtractDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),0x3eb6f7d,0x3fd4d612);\n        result2 = multiplyDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),temp5,temp6);\n        result2 = addDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),0x55555555,0x3fc55555);\n        result2 = multiplyDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),temp5,temp6);\n        result3 = multiplyDoubleFloats(temp5,temp6,0xb12e9282,0x3fb3b8c5);\n        result3 = subtractDoubleFloats((int)result3,(int)((ulonglong)result3 >> 0x20),0x1b8d0159,0x3fe6066c);\n        result3 = multiplyDoubleFloats((int)result3,(int)((ulonglong)result3 >> 0x20),temp5,temp6);\n        result3 = addDoubleFloats((int)result3,(int)((ulonglong)result3 >> 0x20),0x9c598ac8,0x40002ae5);\n        result3 = multiplyDoubleFloats((int)result3,(int)((ulonglong)result3 >> 0x20),temp5,temp6);\n        result3 = subtractDoubleFloats((int)result3,(int)((ulonglong)result3 >> 0x20),0x1c8a2d4b,0x40033a27);\n        result3 = multiplyDoubleFloats((int)result3,(int)((ulonglong)result3 >> 0x20),temp5,temp6);\n        result3 = addDoubleFloats((int)result3,(int)((ulonglong)result3 >> 0x20),0,0x3ff00000);\n        result2 = divideDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result3,\n                          (int)((ulonglong)result3 >> 0x20));\n        result2 = multiplyDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),input1,input2);\n        goto LAB_08005cba;\n      }\n      result2 = addDoubleFloats(input1,input2,0x8800759c,0x7e37e43c);\n      comparisonResult = __aeabi_dcmpgt((int)result2,(int)((ulonglong)result2 >> 0x20),0,0x3ff00000);\n      if (comparisonResult != 0) {\n        return result1;\n      }\n    }\n    absoluteValue((double)CONCAT44(input2,stackVar));\n    result1 = subtractDoubleFloats(0,0x3ff00000,input1,extraCompareResult);\n    result1 = multiplyDoubleFloats((int)result1,(int)((ulonglong)result1 >> 0x20),0,0x3fe00000);\n    temp1 = (undefined4)((ulonglong)result1 >> 0x20);\n    temp5 = (undefined4)result1;\n    result1 = multiplyDoubleFloats(temp5,temp1,0xdfdf709,0x3f023de1);\n    result1 = addDoubleFloats((int)result1,(int)((ulonglong)result1 >> 0x20),0x7501b288,0x3f49efe0);\n    result1 = multiplyDoubleFloats((int)result1,(int)((ulonglong)result1 >> 0x20),temp5,temp1);\n    result1 = subtractDoubleFloats((int)result1,(int)((ulonglong)result1 >> 0x20),0xb5688f3b,0x3fa48228);\n    result1 = multiplyDoubleFloats((int)result1,(int)((ulonglong)result1 >> 0x20),temp5,temp1);\n    result1 = addDoubleFloats((int)result1,(int)((ulonglong)result1 >> 0x20),0xe884455,0x3fc9c155);\n    result1 = multiplyDoubleFloats((int)result1,(int)((ulonglong)result1 >> 0x20),temp5,temp1);\n    result1 = subtractDoubleFloats((int)result1,(int)((ulonglong)result1 >> 0x20),0x3eb6f7d,0x3fd4d612);\n    result1 = multiplyDoubleFloats((int)result1,(int)((ulonglong)result1 >> 0x20),temp5,temp1);\n    result1 = addDoubleFloats((int)result1,(int)((ulonglong)result1 >> 0x20),0x55555555,0x3fc55555);\n    result1 = multiplyDoubleFloats((int)result1,(int)((ulonglong)result1 >> 0x20),temp5,temp1);\n    temp2 = (undefined4)((ulonglong)result1 >> 0x20);\n    result2 = multiplyDoubleFloats(temp5,temp1,0xb12e9282,0x3fb3b8c5);\n    result2 = subtractDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),0x1b8d0159,0x3fe6066c);\n    result2 = multiplyDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),temp5,temp1);\n    result2 = addDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),0x9c598ac8,0x40002ae5);\n    result2 = multiplyDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),temp5,temp1);\n    result2 = subtractDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),0x1c8a2d4b,0x40033a27);\n    result2 = multiplyDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),temp5,temp1);\n    result2 = addDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),0,0x3ff00000);\n    temp3 = (undefined4)((ulonglong)result2 >> 0x20);\n    result3 = calculateSquareRoot_08005c70_IEEE754(temp5,temp1);\n    temp4 = (undefined4)((ulonglong)result3 >> 0x20);\n    temp6 = (undefined4)result3;\n    if (input2Masked < 0x3fef3333) {\n      result1 = divideDoubleFloats((int)result1,temp2,(int)result2,temp3);\n      result2 = addDoubleFloats(temp6,temp4,temp6,temp4);\n      result1 = multiplyDoubleFloats((int)result1,(int)((ulonglong)result1 >> 0x20),(int)result2,\n                       (int)((ulonglong)result2 >> 0x20));\n      result2 = multiplyDoubleFloats(0,temp4,0,temp4);\n      result2 = subtractDoubleFloats(temp5,temp1,(int)result2,(int)((ulonglong)result2 >> 0x20));\n      result3 = addDoubleFloats(temp6,temp4,0,temp4);\n      result2 = divideDoubleFloats((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result3,\n                        (int)((ulonglong)result3 >> 0x20));\n      temp5 = (undefined4)((ulonglong)result2 >> 0x20);\n      result2 = addDoubleFloats((int)result2,temp5,(int)result2,temp5);\n      result2 = subtractDoubleFloats(0x33145c07,0x3c91a626,(int)result2,(int)((ulonglong)result2 >> 0x20));\n      result1 = subtractDoubleFloats((int)result1,(int)((ulonglong)result1 >> 0x20),(int)result2,\n                       (int)((ulonglong)result2 >> 0x20));\n      result2 = addDoubleFloats(0,temp4,0,temp4);\n      result2 = subtractDoubleFloats(0x54442d18,0x3fe921fb,(int)result2,(int)((ulonglong)result2 >> 0x20));\n      result1 = subtractDoubleFloats((int)result1,(int)((ulonglong)result1 >> 0x20),(int)result2,\n                       (int)((ulonglong)result2 >> 0x20));\n      temp5 = 0x3fe921fb;\n    }\n    else {\n      result1 = divideDoubleFloats((int)result1,temp2,(int)result2,temp3);\n      result1 = multiplyDoubleFloats((int)result1,(int)((ulonglong)result1 >> 0x20),temp6,temp4);\n      result1 = addDoubleFloats((int)result1,(int)((ulonglong)result1 >> 0x20),temp6,temp4);\n      temp5 = (undefined4)((ulonglong)result1 >> 0x20);\n      result1 = addDoubleFloats((int)result1,temp5,(int)result1,temp5);\n      result1 = subtractDoubleFloats((int)result1,(int)((ulonglong)result1 >> 0x20),0x33145c07,0x3c91a626);\n      temp5 = 0x3ff921fb;\n    }\n    result1 = subtractDoubleFloats(0x54442d18,temp5,(int)result1,(int)((ulonglong)result1 >> 0x20));\n    if ((int)input2 < 1) {\n      result1 = CONCAT44((int)((ulonglong)result1 >> 0x20) + -0x80000000,(int)result1);\n    }\n  }\n  else {\n    if ((input2Masked + 0xc0100000 | input1) != 0) {\n      result1 = subtractDoubleFloats(input1,input2,input1,input2);\n      temp5 = (undefined4)((ulonglong)result1 >> 0x20);\n      result1 = divideDoubleFloats((int)result1,temp5,(int)result1,temp5);\n      return result1;\n    }\n    result1 = multiplyDoubleFloats(input1,input2,0x54442d18,0x3ff921fb);\n    result2 = multiplyDoubleFloats(input1,input2,0x33145c07,0x3c91a626);\nLAB_08005cba:\n    result1 = addDoubleFloats((int)result1,(int)((ulonglong)result1 >> 0x20),(int)result2,\n                         (int)((ulonglong)result2 >> 0x20));\n  }\n  return result1;\n}\n\n",
            "renaming": {
                "FUN_08005c70": "calculate_square_root_08005c70",
                "param_1": "input1",
                "param_2": "input2",
                "iVar1": "comparisonResult",
                "extraout_r1": "extraCompareResult",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "uVar5": "temp4",
                "uVar6": "temp5",
                "uVar7": "temp6",
                "uVar8": "input2Masked",
                "uVar9": "result1",
                "uVar10": "result2",
                "uVar11": "result3",
                "in_stack_ffffffc8": "stackVar",
                "__muldf3": "multiplyDoubleFloats",
                "__aeabi_dadd": "addDoubleFloats",
                "__subdf3": "subtractDoubleFloats",
                "__divdf3": "divideDoubleFloats",
                "fabs": "absoluteValue",
                "__ieee754_sqrt": "calculateSquareRoot_IEEE754"
            },
            "calling": [
                "asin"
            ],
            "called": [
                "fabs",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__ieee754_sqrt",
                "__muldf3",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006070": {
            "entrypoint": "0x08006070",
            "current_name": "calculate_result_08006070",
            "code": "\nundefined8 calculate_result_08006070(uint num1,uint num2,uint num3,uint num4,double num5)\n\n{\n  undefined4 result1;\n  undefined4 result2;\n  int result3;\n  undefined4 result4;\n  uint result5;\n  uint result6;\n  int result7;\n  uint result8;\n  undefined8 final_result1;\n  undefined8 final_result2;\n  \n  result8 = num4 & 0x7fffffff;\n  if ((0x7ff00000 < (result8 | (-num3 | num3) >> 0x1f)) ||\n     (result6 = num2 & 0x7fffffff, 0x7ff00000 < (result6 | (-num1 | num1) >> 0x1f))) {\n    final_result1 = __aeabi_dadd(num1,num2);\n    return final_result1;\n  }\n  if ((num4 + 0xc0100000 | num3) == 0) {\n    atan(num5);\n    return CONCAT44(result2,num1);\n  }\n  result5 = (int)num4 >> 0x1e & 2U | num2 >> 0x1f;\n  if ((num1 | result6) == 0) {\n    if (result5 == 2) {\n      return 0x400921fb54442d18;\n    }\n    if (result5 != 3) {\n      return CONCAT44(num2,num1);\n    }\nLAB_0800613e:\n    final_result1 = 0xc00921fb54442d18;\n  }\n  else {\n    if ((num3 | result8) != 0) {\n      if (result8 == 0x7ff00000) {\n        if (result6 == 0x7ff00000) {\n          if (result5 == 2) {\n            return 0x4002d97c7f3321d2;\n          }\n          if (result5 == 3) {\n            return 0xc002d97c7f3321d2;\n          }\n          if (result5 != 1) {\n            return 0x3fe921fb54442d18;\n          }\n          return 0xbfe921fb54442d18;\n        }\n        if (result5 == 2) {\n          return 0x400921fb54442d18;\n        }\n        if (result5 != 3) {\n          if (result5 != 1) {\n            return 0;\n          }\n          return 0x8000000000000000;\n        }\n        goto LAB_0800613e;\n      }\n      if (result6 != 0x7ff00000) {\n        result7 = (int)(result6 - result8) >> 0x14;\n        if (result7 < 0x3d) {\n          if (((int)num4 < 0) && (result7 + 0x3c < 0 != SCARRY4(result7,0x3c))) {\n            result1 = 0;\n            result7 = 0;\n          }\n          else {\n            result1 = __divdf3(num1,num2);\n            fabs((double)CONCAT44(result4,num4));\n            atan((double)CONCAT44(result4,num4));\n            result7 = result3;\n          }\n        }\n        else {\n          result1 = 0x54442d18;\n          result7 = 0x3ff921fb;\n        }\n        if (result5 == 1) {\n          return CONCAT44(result7 + -0x80000000,result1);\n        }\n        if (result5 == 2) {\n          final_result2 = __subdf3(result1,result7,0x33145c07,0x3ca1a626);\n          final_result1 = 0x400921fb54442d18;\n        }\n        else {\n          if (result5 == 0) {\n            return CONCAT44(result7,result1);\n          }\n          final_result1 = __subdf3(result1,result7,0x33145c07,0x3ca1a626);\n          final_result2 = 0x400921fb54442d18;\n        }\n        final_result1 = __subdf3((int)final_result1,(int)((ulonglong)final_result1 >> 0x20),(int)final_result2,\n                         (int)((ulonglong)final_result2 >> 0x20));\n        return final_result1;\n      }\n    }\n    if ((int)num2 < 0) {\n      final_result1 = 0xbff921fb54442d18;\n    }\n    else {\n      final_result1 = 0x3ff921fb54442d18;\n    }\n  }\n  return final_result1;\n}\n\n",
            "renaming": {
                "FUN_08006070": "calculate_result_08006070",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "num3",
                "param_4": "num4",
                "param_5": "num5",
                "uVar1": "result1",
                "extraout_r1": "result2",
                "extraout_r1_00": "result3",
                "unaff_r4": "result4",
                "uVar2": "result5",
                "uVar3": "result6",
                "iVar4": "result7",
                "uVar5": "result8",
                "uVar6": "final_result1",
                "uVar7": "final_result2"
            },
            "calling": [
                "atan2"
            ],
            "called": [
                "fabs",
                "atan",
                "__aeabi_dadd",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006228": {
            "entrypoint": "0x08006228",
            "current_name": "perform_calculation_08006228",
            "code": "\nvoid performCalculation_08006228(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint result1;\n  undefined4 extraout_r1;\n  uint extraout_r1_00;\n  undefined4 result2;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  uint extraout_r1_03;\n  undefined4 extraout_r1_04;\n  undefined4 result3;\n  int index;\n  uint value;\n  int index2;\n  undefined4 result4;\n  uint value2;\n  undefined4 result5;\n  uint value3;\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined8 temp3;\n  undefined8 temp4;\n  undefined8 temp5;\n  undefined8 temp6;\n  longlong temp7;\n  ulonglong temp8;\n  undefined8 temp9;\n  undefined4 temp10;\n  undefined4 stackVar1;\n  undefined4 localVar1;\n  undefined4 localVar2;\n  int localVar3;\n  \n  value3 = input4 & 0x7fffffff;\n  if ((value3 | input3) == 0) {\n    return;\n  }\n  value2 = input2 & 0x7fffffff;\n  if (value2 < 0x7ff00001) {\n    if (value2 == 0x7ff00000) {\n      if (input1 == 0) {\n        if (0x7ff00000 < value3) goto LAB_08006278;\nLAB_08006262:\n        if ((value3 != 0x7ff00000) || (input3 == 0)) {\n          if (-1 < (int)input2) goto LAB_0800632a;\n          if (value3 < 0x43400000) {\n            if (value3 < 0x3ff00000) {\nLAB_0800632a:\n              result1 = 0;\n              goto LAB_080062ba;\n            }\n            index = ((int)value3 >> 0x14) + -0x3ff;\n            if (0x14 < index) {\n              result1 = input3 >> (0x34U - index & 0xff);\n              if (input3 == result1 << (0x34U - index & 0xff)) {\n                result1 = 2 - (result1 & 1);\n                goto LAB_080062ba;\n              }\n              goto LAB_0800632a;\n            }\n            if (input3 == 0) {\n              result1 = (int)value3 >> (0x14U - index & 0xff);\n              if (value3 == result1 << (0x14U - index & 0xff)) {\n                result1 = 2 - (result1 & 1);\n              }\n              else {\n                result1 = 0;\n              }\n              goto LAB_0800630c;\n            }\n            result1 = 0;\n          }\n          else {\n            result1 = 2;\nLAB_080062ba:\n            if (input3 == 0) {\n              if (value3 == 0x7ff00000) {\n                return;\n              }\nLAB_0800630c:\n              if (value3 == 0x3ff00000) {\n                if (-1 < (int)input4) {\n                  return;\n                }\n                temp3 = 0x3ff0000000000000;\n                temp4 = CONCAT44(input2,input1);\n                goto LAB_08006320;\n              }\n              if (input4 == 0x40000000) goto LAB_0800634a;\n              if ((input4 == 0x3fe00000) && (-1 < (int)input2)) {\n                __ieee754_sqrt(input1,input2);\n                return;\n              }\n            }\n          }\n          value = input1;\n          fabs((double)CONCAT44(stackVar1,result1));\n          temp8 = CONCAT44(input2,value) & 0x7fffffffffffffff;\n          if ((input1 == 0) && ((value2 == 0 || ((input2 & 0x3fffffff) == 0x3ff00000)))) {\n            if ((int)input4 < 0) {\n              __divdf3(0,0x3ff00000,value,extraout_r1);\n            }\n            if (-1 < (int)input2) {\n              return;\n            }\n            if ((result1 | value2 + 0xc0100000) != 0) {\n              return;\n            }\n          }\n          else {\n            value = 0xffffffff - ((int)input2 >> 0x1f);\n            if ((result1 | value) != 0) {\n              if (value3 < 0x41e00001) {\n                localVar3 = 0;\n                if (value2 < 0x100000) {\n                  temp8 = __muldf3();\n                  localVar3 = -0x35;\n                }\n                value3 = (uint)(temp8 >> 0x20);\n                localVar3 = ((int)value3 >> 0x14) + -0x3ff + localVar3;\n                value3 = value3 & 0xfffff;\n                value2 = value3 | 0x3ff00000;\n                if (value3 < 0x3988f) {\nLAB_08006628:\n                  index = 0;\n                }\n                else {\n                  if (0xbb679 < value3) {\n                    value2 = value2 - 0x100000;\n                    localVar3 = localVar3 + 1;\n                    goto LAB_08006628;\n                  }\n                  index = 1;\n                }\n                index2 = index * 8;\n                result4 = (&bp)[index * 2];\n                temp10 = (&DAT_080073c4)[index * 2];\n                temp3 = __subdf3();\n                temp1 = (undefined4)((ulonglong)temp3 >> 0x20);\n                temp4 = __aeabi_dadd((int)temp8,value2,result4,temp10);\n                temp4 = __divdf3(0,0x3ff00000,(int)temp4,(int)((ulonglong)temp4 >> 0x20));\n                temp2 = (undefined4)((ulonglong)temp4 >> 0x20);\n                temp5 = __muldf3((int)temp3,temp1,(int)temp4,temp2);\n                result2 = (undefined4)((ulonglong)temp5 >> 0x20);\n                result5 = (undefined4)temp5;\n                temp5 = __muldf3(0,result2);\n                temp3 = __subdf3((int)temp3,temp1,(int)temp5,(int)((ulonglong)temp5 >> 0x20));\n                temp5 = __subdf3(0,((int)value2 >> 1 | 0x20000000U) + 0x80000 + index * 0x40000,\n                                  result4,temp10);\n                temp5 = __subdf3((int)temp8,value2,(int)temp5,(int)((ulonglong)temp5 >> 0x20));\n                temp5 = __muldf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),0,result2);\n                temp3 = __subdf3((int)temp3,(int)((ulonglong)temp3 >> 0x20),(int)temp5,\n                                  (int)((ulonglong)temp5 >> 0x20));\n                temp3 = __muldf3((int)temp3,(int)((ulonglong)temp3 >> 0x20),(int)temp4,temp2);\n                temp2 = (undefined4)((ulonglong)temp3 >> 0x20);\n                temp4 = __muldf3(result5,result2);\n                result4 = (undefined4)((ulonglong)temp4 >> 0x20);\n                temp1 = (undefined4)temp4;\n                temp4 = __muldf3(temp1,result4,0x4a454eef,0x3fca7e28);\n                temp4 = __aeabi_dadd((int)temp4,(int)((ulonglong)temp4 >> 0x20),0x93c9db65,\n                                      0x3fcd864a);\n                temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),temp1,result4);\n                temp4 = __aeabi_dadd((int)temp4,(int)((ulonglong)temp4 >> 0x20),0xa91d4101,\n                                      0x3fd17460);\n                temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),temp1,result4);\n                temp4 = __aeabi_dadd((int)temp4,(int)((ulonglong)temp4 >> 0x20),0x518f264d,\n                                      0x3fd55555);\n                temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),temp1,result4);\n                temp4 = __aeabi_dadd((int)temp4,(int)((ulonglong)temp4 >> 0x20),0xdb6fabff,\n                                      0x3fdb6db6);\n                temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),temp1,result4);\n                temp4 = __aeabi_dadd((int)temp4,(int)((ulonglong)temp4 >> 0x20),0x33333303,\n                                      0x3fe33333);\n                temp5 = __muldf3(temp1,result4,temp1,result4);\n                temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),(int)temp5,\n                                  (int)((ulonglong)temp5 >> 0x20));\n                temp5 = __aeabi_dadd(result5,result2,0,result2);\n                temp5 = __muldf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),(int)temp3,temp2);\n                temp4 = __aeabi_dadd((int)temp5,(int)((ulonglong)temp5 >> 0x20),(int)temp4,\n                                      (int)((ulonglong)temp4 >> 0x20));\n                temp1 = (undefined4)((ulonglong)temp4 >> 0x20);\n                temp5 = __muldf3(0,result2,0,result2);\n                result4 = (undefined4)((ulonglong)temp5 >> 0x20);\n                temp6 = __aeabi_dadd((int)temp5,result4,0,0x40080000);\n                __aeabi_dadd((int)temp6,(int)((ulonglong)temp6 >> 0x20),(int)temp4,temp1);\n                temp6 = __muldf3(0,result2,0,extraout_r1_01);\n                temp10 = (undefined4)((ulonglong)temp6 >> 0x20);\n                temp9 = __subdf3(0,extraout_r1_01,0,0x40080000);\n                temp5 = __subdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),(int)temp5,result4);\n                temp4 = __subdf3((int)temp4,temp1,(int)temp5,(int)((ulonglong)temp5 >> 0x20));\n                temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),result5,result2);\n                temp3 = __muldf3((int)temp3,temp2,0,extraout_r1_01);\n                temp4 = __aeabi_dadd((int)temp4,(int)((ulonglong)temp4 >> 0x20),(int)temp3,\n                                      (int)((ulonglong)temp3 >> 0x20));\n                result5 = (undefined4)((ulonglong)temp4 >> 0x20);\n                __aeabi_dadd((int)temp6,temp10,(int)temp4,result5);\n                temp3 = __muldf3(0,extraout_r1_02,0xe0000000,0x3feec709);\n                temp5 = __subdf3(0,extraout_r1_02,(int)temp6,temp10);\n                temp4 = __subdf3((int)temp4,result5,(int)temp5,(int)((ulonglong)temp5 >> 0x20));\n                temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),0xdc3a03fd,0x3feec709\n                                 );\n                temp5 = __muldf3(0,extraout_r1_02,0x145b01f5,0xbe3e2fe0);\n                temp4 = __aeabi_dadd((int)temp4,(int)((ulonglong)temp4 >> 0x20),(int)temp5,\n                                      (int)((ulonglong)temp5 >> 0x20));\n                temp4 = __aeabi_dadd((int)temp4,(int)((ulonglong)temp4 >> 0x20),\n                                      *(undefined4 *)(&dp_l + index2),\n                                      *(undefined4 *)(&DAT_080073e4 + index2));\n                temp5 = __aeabi_i2d(localVar3);\n                result5 = (undefined4)((ulonglong)temp5 >> 0x20);\n                temp1 = *(undefined4 *)(&dp_h + index2);\n                temp2 = *(undefined4 *)(&DAT_080073d4 + index2);\n                temp6 = __aeabi_dadd((int)temp3,(int)((ulonglong)temp3 >> 0x20),(int)temp4,\n                                      (int)((ulonglong)temp4 >> 0x20));\n                temp6 = __aeabi_dadd((int)temp6,(int)((ulonglong)temp6 >> 0x20),temp1,temp2);\n                __aeabi_dadd((int)temp6,(int)((ulonglong)temp6 >> 0x20),(int)temp5,result5);\n                temp5 = __subdf3(0,extraout_r1_03,(int)temp5,result5);\n                temp7 = __subdf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),temp1,temp2);\n                value3 = extraout_r1_03;\n              }\n              else {\n                if (0x43f00000 < value3) {\n                  if (0x3fefffff < value2) {\nLAB_08006418:\n                    if ((int)input4 < 1) {\n                      return;\n                    }\n                    goto LAB_0800634a;\n                  }\nLAB_080063fa:\n                  if (-1 < (int)input4) {\n                    return;\n                  }\n                  goto LAB_0800634a;\n                }\n                if (value2 < 0x3fefffff) goto LAB_080063fa;\n                if (0x3ff00000 < value2) goto LAB_08006418;\n                temp3 = __subdf3();\n                temp1 = (undefined4)((ulonglong)temp3 >> 0x20);\n                result5 = (undefined4)temp3;\n                temp3 = __muldf3(result5,temp1,0x60000000,0x3ff71547);\n                temp4 = __muldf3(result5,temp1,0xf85ddf44,0x3e54ae0b);\n                temp5 = __muldf3(result5,temp1,0,0x3fd00000);\n                temp5 = __subdf3(0x55555555,0x3fd55555,(int)temp5,(int)((ulonglong)temp5 >> 0x20)\n                                 );\n                temp5 = __muldf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),result5,temp1);\n                temp5 = __subdf3(0,0x3fe00000,(int)temp5,(int)((ulonglong)temp5 >> 0x20));\n                temp6 = __muldf3(result5,temp1,result5,temp1);\n                temp5 = __muldf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),(int)temp6,\n                                  (int)((ulonglong)temp6 >> 0x20));\n                temp5 = __muldf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),0x652b82fe,0x3ff71547\n                                 );\n                temp4 = __subdf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),(int)temp5,\n                                  (int)((ulonglong)temp5 >> 0x20));\n                __aeabi_dadd((int)temp3,(int)((ulonglong)temp3 >> 0x20),(int)temp4,\n                             (int)((ulonglong)temp4 >> 0x20));\n                temp7 = (ulonglong)extraout_r1_00 << 0x20;\n                value3 = extraout_r1_00;\n              }\n              temp3 = __subdf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),(int)temp3,\n                                (int)((ulonglong)temp3 >> 0x20));\n              temp3 = __subdf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),(int)temp3,\n                                (int)((ulonglong)temp3 >> 0x20));\n              if ((result1 - 1 | value) == 0) {\n                result5 = 0xbff00000;\n              }\n              else {\n                result5 = 0x3ff00000;\n              }\n              temp10 = 0;\n              temp4 = __subdf3(input3,input4,0,input4);\n              temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),0,value3);\n              temp3 = __muldf3((int)temp3,(int)((ulonglong)temp3 >> 0x20),input3,input4);\n              temp3 = __aeabi_dadd((int)temp4,(int)((ulonglong)temp4 >> 0x20),(int)temp3,\n                                    (int)((ulonglong)temp3 >> 0x20));\n              result2 = (undefined4)((ulonglong)temp3 >> 0x20);\n              temp1 = (undefined4)temp3;\n              temp3 = __muldf3(0,value3,0,input4);\n              result4 = (undefined4)((ulonglong)temp3 >> 0x20);\n              temp2 = (undefined4)temp3;\n              temp7 = __aeabi_dadd(temp1,result2,temp2,result4);\n              value2 = (uint)((ulonglong)temp7 >> 0x20);\n              value3 = (uint)temp7;\n              if (0x408fffffffffffff < temp7) {\n                if ((value2 + 0xbf700000 | value3) == 0) {\n                  temp4 = __aeabi_dadd(temp1,result2,0x652b82fe,0x3c971547);\n                  temp5 = __subdf3(value3,value2,temp2,result4);\n                  index = __aeabi_dcmpgt((int)temp4,(int)((ulonglong)temp4 >> 0x20),(int)temp5,\n                                         (int)((ulonglong)temp5 >> 0x20));\n                  if (index == 0) goto LAB_08006968;\n                }\n                __muldf3(temp10,result5,0x8800759c,0x7e37e43c);\n                goto LAB_0800634a;\n              }\n              if ((value2 & 0x7fffffff) < 0x4090cc00) {\nLAB_08006968:\n                if ((value2 & 0x7fffffff) < 0x3fe00001) {\n                  index = 0;\n                }\n                else {\n                  value2 = (0x100000 >> (((int)(value2 & 0x7fffffff) >> 0x14) - 0x3feU & 0xff)) +\n                          value2;\n                  value3 = (value2 * 2 >> 0x15) - 0x3ff;\n                  index = (int)(value2 & 0xfffff | 0x100000) >> (0x14 - value3 & 0xff);\n                  if (temp7 < 0) {\n                    index = -index;\n                  }\n                  temp3 = __subdf3(temp2,result4,0,value2 & ~(0xfffff >> (value3 & 0xff)));\n                }\n                localVar2 = (undefined4)((ulonglong)temp3 >> 0x20);\n                localVar1 = (undefined4)temp3;\n                __aeabi_dadd(localVar1,localVar2,temp1,result2);\n                temp3 = __muldf3(0,extraout_r1_04,0,0x3fe62e43);\n                temp2 = (undefined4)((ulonglong)temp3 >> 0x20);\n                temp4 = __subdf3(0,extraout_r1_04,localVar1,localVar2);\n                temp4 = __subdf3(temp1,result2,(int)temp4,(int)((ulonglong)temp4 >> 0x20));\n                temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),0xfefa39ef,0x3fe62e42\n                                 );\n                temp5 = __muldf3(0,extraout_r1_04,0xca86c39,0xbe205c61);\n                temp4 = __aeabi_dadd((int)temp4,(int)((ulonglong)temp4 >> 0x20),(int)temp5,\n                                      (int)((ulonglong)temp5 >> 0x20));\n                result2 = (undefined4)((ulonglong)temp4 >> 0x20);\n                temp5 = __aeabi_dadd((int)temp3,temp2,(int)temp4,result2);\n                result4 = (undefined4)((ulonglong)temp5 >> 0x20);\n                temp1 = (undefined4)temp5;\n                temp3 = __subdf3(temp1,result4,(int)temp3,temp2);\n                temp3 = __subdf3((int)temp4,result2,(int)temp3,(int)((ulonglong)temp3 >> 0x20));\n                result2 = (undefined4)((ulonglong)temp3 >> 0x20);\n                temp4 = __muldf3(temp1,result4,temp1,result4);\n                result3 = (undefined4)((ulonglong)temp4 >> 0x20);\n                temp2 = (undefined4)temp4;\n                temp4 = __muldf3(temp2,result3,0x72bea4d0,0x3e663769);\n                temp4 = __subdf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),0xc5d26bf1,0x3ebbbd41\n                                 );\n                temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),temp2,result3);\n                temp4 = __aeabi_dadd((int)temp4,(int)((ulonglong)temp4 >> 0x20),0xaf25de2c,\n                                      0x3f11566a);\n                temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),temp2,result3);\n                temp4 = __subdf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),0x16bebd93,0x3f66c16c\n                                 );\n                temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),temp2,result3);\n                temp4 = __aeabi_dadd((int)temp4,(int)((ulonglong)temp4 >> 0x20),0x5555553e,\n                                      0x3fc55555);\n                temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),temp2,result3);\n                temp4 = __subdf3(temp1,result4,(int)temp4,(int)((ulonglong)temp4 >> 0x20));\n                temp2 = (undefined4)((ulonglong)temp4 >> 0x20);\n                temp5 = __muldf3(temp1,result4,(int)temp4,temp2);\n                temp4 = __subdf3((int)temp4,temp2,0,0x40000000);\n                temp4 = __divdf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),(int)temp4,\n                                  (int)((ulonglong)temp4 >> 0x20));\n                temp5 = __muldf3(temp1,result4,(int)temp3,result2);\n                temp3 = __aeabi_dadd((int)temp5,(int)((ulonglong)temp5 >> 0x20),(int)temp3,result2\n                                     );\n                temp3 = __subdf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),(int)temp3,\n                                  (int)((ulonglong)temp3 >> 0x20));\n                temp3 = __subdf3((int)temp3,(int)((ulonglong)temp3 >> 0x20),temp1,result4);\n                temp3 = __subdf3(0,0x3ff00000,(int)temp3,(int)((ulonglong)temp3 >> 0x20));\n                if ((int)((ulonglong)temp3 >> 0x20) + index * 0x100000 < 0x100000) {\n                  scalbn((double)CONCAT44(result5,temp10),(int)temp3);\n                }\n              }\n              else {\n                if ((value2 + 0x3f6f3400 | value3) == 0) {\n                  temp4 = __subdf3(value3,value2,temp2,result4);\n                  index = __aeabi_dcmple(temp1,result2,(int)temp4,(int)((ulonglong)temp4 >> 0x20));\n                  if (index == 0) goto LAB_08006968;\n                }\n                __muldf3(temp10,result5,0xc2f8f359,0x1a56e1f);\n              }\nLAB_0800634a:\n              __muldf3();\n              return;\n            }\n          }\n          temp3 = __subdf3();\n          temp4 = temp3;\nLAB_08006320:\n          __divdf3((int)temp3,(int)((ulonglong)temp3 >> 0x20),(int)temp4,\n                   (int)((ulonglong)temp4 >> 0x20));\n          return;\n        }\n      }\n    }\n    else if (value3 < 0x7ff00001) goto LAB_08006262;\n  }\n  if ((value2 + 0xc0100000 | input1) == 0) {\n    return;\n  }\nLAB_08006278:\n  nan(\"\");\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006228": "perform_calculation_08006228",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "result3",
                "iVar4": "index",
                "uVar5": "value",
                "iVar6": "index2",
                "uVar7": "result4",
                "uVar8": "value2",
                "uVar9": "result5",
                "uVar10": "value3",
                "uVar11": "temp1",
                "uVar12": "temp2",
                "uVar13": "temp3",
                "uVar14": "temp4",
                "uVar15": "temp5",
                "uVar16": "temp6",
                "lVar17": "temp7",
                "uVar18": "temp8",
                "uVar19": "temp9",
                "uVar20": "temp10",
                "in_stack_ffffff94": "stackVar1",
                "local_68": "localVar1",
                "local_64": "localVar2",
                "local_54": "localVar3"
            },
            "calling": [
                "pow"
            ],
            "called": [
                "__aeabi_i2d",
                "scalbn",
                "fabs",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__ieee754_sqrt",
                "__muldf3",
                "__aeabi_dcmple",
                "nan",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c0c": {
            "entrypoint": "0x08006c0c",
            "current_name": "calculate_floating_point_08006c0c",
            "code": "\nundefined8 calculateFloatingPoint_08006c0c(uint input1,uint input2)\n\n{\n  undefined4 result1;\n  uint temp1;\n  int temp2;\n  int temp3;\n  uint temp4;\n  uint temp5;\n  int temp6;\n  uint temp7;\n  uint temp8;\n  int temp9;\n  uint temp10;\n  undefined8 output;\n  \n  if ((~input2 & 0x7ff00000) == 0) {\n    output = __muldf3(input1,input2,input1,input2);\n    output = __aeabi_dadd(input1,input2,(int)output,(int)((ulonglong)output >> 0x20));\n    return output;\n  }\n  if ((int)input2 < 1) {\n    if ((input2 & 0x7fffffff | input1) == 0) {\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != 0) {\n      output = __subdf3(input1,input2,input1,input2);\n      result1 = (undefined4)((ulonglong)output >> 0x20);\n      output = __divdf3((int)output,result1,(int)output,result1);\n      return output;\n    }\n  }\n  temp2 = (int)input2 >> 0x14;\n  if (temp2 == 0) {\n    while (input2 == 0) {\n      temp2 = temp2 + -0x15;\n      input2 = input1 >> 0xb;\n      input1 = input1 << 0x15;\n    }\n    temp1 = 0;\n    for (; -1 < (int)(input2 << 0xb); input2 = input2 << 1) {\n      temp1 = temp1 + 1;\n    }\n    temp2 = temp2 - (temp1 - 1);\n    input2 = input2 | input1 >> (0x20 - temp1 & 0xff);\n    input1 = input1 << (temp1 & 0xff);\n  }\n  temp6 = 0;\n  temp1 = input2 & 0xfffff | 0x100000;\n  if ((temp2 + -0x3ff) * -0x80000000 < 0) {\n    temp1 = temp1 * 2 - ((int)input1 >> 0x1f);\n    input1 = input1 << 1;\n  }\n  temp1 = temp1 * 2 - ((int)input1 >> 0x1f);\n  temp3 = 0x16;\n  temp4 = 0;\n  temp7 = 0x200000;\n  input1 = input1 << 1;\n  do {\n    temp9 = temp4 + temp7;\n    if (temp9 <= (int)temp1) {\n      temp1 = temp1 - temp9;\n      temp4 = temp9 + temp7;\n      temp6 = temp6 + temp7;\n    }\n    temp3 = temp3 + -1;\n    temp1 = temp1 * 2 - ((int)input1 >> 0x1f);\n    temp7 = temp7 >> 1;\n    input1 = input1 << 1;\n  } while (temp3 != 0);\n  temp9 = 0x20;\n  temp8 = 0x80000000;\n  temp7 = 0;\n  temp3 = 0;\n  do {\n    temp10 = temp8 + temp3;\n    temp5 = temp4;\n    if (((int)temp4 < (int)temp1) || ((temp1 == temp4 && (temp10 <= input1)))) {\n      temp3 = temp10 + temp8;\n      if (((int)temp10 < 0) && (-1 < temp3)) {\n        temp5 = temp4 + 1;\n      }\n      temp1 = temp1 - temp4;\n      if (input1 < temp10) {\n        temp1 = temp1 - 1;\n      }\n      input1 = input1 - temp10;\n      temp7 = temp7 + temp8;\n    }\n    temp1 = temp1 * 2 - ((int)input1 >> 0x1f);\n    temp9 = temp9 + -1;\n    input1 = input1 << 1;\n    temp8 = temp8 >> 1;\n    temp4 = temp5;\n  } while (temp9 != 0);\n  if ((input1 | temp1) != 0) {\n    if (temp7 == 0xffffffff) {\n      temp6 = temp6 + 1;\n      temp7 = 0;\n    }\n    else {\n      temp7 = temp7 + 1 & 0xfffffffe;\n    }\n  }\n  temp7 = temp7 >> 1;\n  if (temp6 << 0x1f < 0) {\n    temp7 = temp7 | 0x80000000;\n  }\n  return CONCAT44((temp6 >> 1) + 0x3fe00000 + (temp2 + -0x3ff >> 1) * 0x100000,temp7);\n}\n\n",
            "renaming": {
                "FUN_08006c0c": "calculate_floating_point_08006c0c",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "result1",
                "uVar2": "temp1",
                "iVar3": "temp2",
                "iVar4": "temp3",
                "uVar5": "temp4",
                "uVar6": "temp5",
                "iVar7": "temp6",
                "uVar8": "temp7",
                "uVar9": "temp8",
                "iVar10": "temp9",
                "uVar11": "temp10",
                "uVar12": "output"
            },
            "calling": [
                "__ieee754_asin",
                "sqrt",
                "__ieee754_pow"
            ],
            "called": [
                "__aeabi_dadd",
                "__muldf3",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d68": {
            "entrypoint": "0x08006d68",
            "current_name": "calculate_hyperbolic_function_08006d68",
            "code": "\ndouble calculateHyperbolicFunction_08006d68(double inputValue)\n\n{\n  int tempVar1;\n  int comparisonResult;\n  undefined4 tempVar3;\n  undefined4 tempVar4;\n  uint tempVar2;\n  undefined4 tempVar5;\n  undefined4 tempVar6;\n  undefined4 tempVar7;\n  undefined4 tempVar8;\n  undefined4 tempVar9;\n  undefined4 tempVar10;\n  undefined4 tempVar11;\n  uint absoluteValue;\n  double result;\n  double temporaryResult;\n  undefined8 tempVar12;\n  undefined8 tempVar13;\n  \n  tempVar13 = CONCAT44(tempVar2,tempVar1);\n  absoluteValue = tempVar2 & 0x7fffffff;\n  if (absoluteValue < 0x44100000) {\n    if (absoluteValue < 0x3fdc0000) {\n      if (absoluteValue < 0x3e200000) {\n        tempVar12 = __aeabi_dadd(tempVar1,tempVar2,0x8800759c,0x7e37e43c);\n        comparisonResult = __aeabi_dcmpgt((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),0,0x3ff00000);\n        if (comparisonResult != 0) {\n          return temporaryResult;\n        }\n      }\n      comparisonResult = -1;\n    }\n    else {\n      fabs((double)CONCAT44(tempVar9,tempVar8));\n      if (absoluteValue < 0x3ff30000) {\n        if (absoluteValue < 0x3fe60000) {\n          tempVar13 = __aeabi_dadd();\n          tempVar13 = __subdf3((int)tempVar13,(int)((ulonglong)tempVar13 >> 0x20),0,0x3ff00000);\n          tempVar12 = __aeabi_dadd(tempVar1,tempVar5,0,0x40000000);\n          tempVar13 = __divdf3((int)tempVar13,(int)((ulonglong)tempVar13 >> 0x20),(int)tempVar12,\n                            (int)((ulonglong)tempVar12 >> 0x20));\n          comparisonResult = 0;\n        }\n        else {\n          tempVar13 = __subdf3();\n          tempVar12 = __aeabi_dadd(tempVar1,tempVar5,0,0x3ff00000);\n          tempVar13 = __divdf3((int)tempVar13,(int)((ulonglong)tempVar13 >> 0x20),(int)tempVar12,\n                            (int)((ulonglong)tempVar12 >> 0x20));\n          comparisonResult = 1;\n        }\n      }\n      else if (absoluteValue < 0x40038000) {\n        tempVar13 = __subdf3();\n        tempVar12 = __muldf3(tempVar1,tempVar5,0,0x3ff80000);\n        tempVar12 = __aeabi_dadd((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),0,0x3ff00000);\n        tempVar13 = __divdf3((int)tempVar13,(int)((ulonglong)tempVar13 >> 0x20),(int)tempVar12,\n                          (int)((ulonglong)tempVar12 >> 0x20));\n        comparisonResult = 2;\n      }\n      else {\n        tempVar13 = __divdf3(0,0xbff00000,tempVar1,tempVar5);\n        comparisonResult = 3;\n      }\n    }\n    tempVar11 = (undefined4)((ulonglong)tempVar13 >> 0x20);\n    tempVar10 = (undefined4)tempVar13;\n    tempVar13 = __muldf3(tempVar10,tempVar11,tempVar10,tempVar11);\n    tempVar6 = (undefined4)((ulonglong)tempVar13 >> 0x20);\n    tempVar3 = (undefined4)tempVar13;\n    tempVar13 = __muldf3(tempVar3,tempVar6,tempVar3,tempVar6);\n    tempVar7 = (undefined4)((ulonglong)tempVar13 >> 0x20);\n    tempVar4 = (undefined4)tempVar13;\n    tempVar13 = __muldf3(tempVar4,tempVar7,0xe322da11,0x3f90ad3a);\n    tempVar13 = __aeabi_dadd((int)tempVar13,(int)((ulonglong)tempVar13 >> 0x20),0x24760deb,0x3fa97b4b);\n    tempVar13 = __muldf3((int)tempVar13,(int)((ulonglong)tempVar13 >> 0x20),tempVar4,tempVar7);\n    tempVar13 = __aeabi_dadd((int)tempVar13,(int)((ulonglong)tempVar13 >> 0x20),0xa0d03d51,0x3fb10d66);\n    tempVar13 = __muldf3((int)tempVar13,(int)((ulonglong)tempVar13 >> 0x20),tempVar4,tempVar7);\n    tempVar13 = __aeabi_dadd((int)tempVar13,(int)((ulonglong)tempVar13 >> 0x20),0xc54c206e,0x3fb745cd);\n    tempVar13 = __muldf3((int)tempVar13,(int)((ulonglong)tempVar13 >> 0x20),tempVar4,tempVar7);\n    tempVar13 = __aeabi_dadd((int)tempVar13,(int)((ulonglong)tempVar13 >> 0x20),0x920083ff,0x3fc24924);\n    tempVar13 = __muldf3((int)tempVar13,(int)((ulonglong)tempVar13 >> 0x20),tempVar4,tempVar7);\n    tempVar13 = __aeabi_dadd((int)tempVar13,(int)((ulonglong)tempVar13 >> 0x20),0x5555550d,0x3fd55555);\n    tempVar13 = __muldf3((int)tempVar13,(int)((ulonglong)tempVar13 >> 0x20),tempVar3,tempVar6);\n    tempVar3 = (undefined4)((ulonglong)tempVar13 >> 0x20);\n    tempVar12 = __muldf3(tempVar4,tempVar7,0x2c6a6c2f,0xbfa2b444);\n    tempVar12 = __subdf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),0x52defd9a,0x3fadde2d);\n    tempVar12 = __muldf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),tempVar4,tempVar7);\n    tempVar12 = __subdf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    tempVar12 = __muldf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),tempVar4,tempVar7);\n    tempVar12 = __subdf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),0xfe231671,0x3fbc71c6);\n    tempVar12 = __muldf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),tempVar4,tempVar7);\n    tempVar12 = __subdf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),0x9998ebc4,0x3fc99999);\n    tempVar12 = __muldf3((int)tempVar12,(int)((ulonglong)tempVar12 >> 0x20),tempVar4,tempVar7);\n    tempVar4 = (undefined4)((ulonglong)tempVar12 >> 0x20);\n    if (comparisonResult == -1) {\n      tempVar13 = __aeabi_dadd((int)tempVar13,tempVar3,(int)tempVar12,tempVar4);\n      tempVar13 = __muldf3((int)tempVar13,(int)((ulonglong)tempVar13 >> 0x20),tempVar10,tempVar11);\n      result = (double)__subdf3(tempVar10,tempVar11,(int)tempVar13,(int)((ulonglong)tempVar13 >> 0x20));\n    }\n    else {\n      tempVar13 = __aeabi_dadd((int)tempVar13,tempVar3,(int)tempVar12,tempVar4);\n      tempVar13 = __muldf3((int)tempVar13,(int)((ulonglong)tempVar13 >> 0x20),tempVar10,tempVar11);\n      comparisonResult = comparisonResult * 8;\n      tempVar13 = __subdf3((int)tempVar13,(int)((ulonglong)tempVar13 >> 0x20),\n                        *(undefined4 *)(&atanlo + comparisonResult),*(undefined4 *)(&UNK_08007414 + comparisonResult));\n      tempVar13 = __subdf3((int)tempVar13,(int)((ulonglong)tempVar13 >> 0x20),tempVar10,tempVar11);\n      result = (double)__subdf3(*(undefined4 *)(&atanhi + comparisonResult),\n                               *(undefined4 *)(&UNK_080073f4 + comparisonResult),(int)tempVar13,\n                               (int)((ulonglong)tempVar13 >> 0x20));\n    }\n  }\n  else if ((0x7ff00000 < absoluteValue) || ((absoluteValue == 0x7ff00000 && (tempVar1 != 0)))) {\n    result = (double)__aeabi_dadd();\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006d68": "calculate_hyperbolic_function_08006d68",
                "__x": "inputValue",
                "in_r0": "tempVar1",
                "in_r1": "tempVar2",
                "iVar1": "comparisonResult",
                "uVar2": "tempVar3",
                "uVar3": "tempVar4",
                "extraout_r1": "tempVar5",
                "uVar4": "tempVar6",
                "uVar5": "tempVar7",
                "in_r3": "tempVar8",
                "unaff_r4": "tempVar9",
                "uVar6": "tempVar10",
                "uVar7": "tempVar11",
                "uVar8": "absoluteValue",
                "in_d0": "result",
                "extraout_d0": "temporaryResult",
                "uVar9": "tempVar12",
                "uVar10": "tempVar13"
            },
            "calling": [
                "__ieee754_atan2"
            ],
            "called": [
                "fabs",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__muldf3",
                "__divdf3",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800708c": {
            "entrypoint": "0x0800708c",
            "current_name": "calculate_double_0800708c",
            "code": "\ndouble calculateDouble_0800708c(double inputValue)\n\n{\n  double result;\n  \n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800708c": "calculate_double_0800708c",
                "__x": "inputValue",
                "in_d0": "result"
            },
            "calling": [
                "__ieee754_atan2",
                "atan",
                "__ieee754_asin",
                "__ieee754_pow",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007092": {
            "entrypoint": "0x08007092",
            "current_name": "compute_signed_bit_08007092",
            "code": "\nint computeSignedBit_08007092(double inputValue)\n\n{\n  uint bitMask;\n  \n  return (bitMask | 0x80000000) + 0x100000 >> 0x1f;\n}\n\n",
            "renaming": {
                "FUN_08007092": "compute_signed_bit_08007092",
                "__value": "inputValue",
                "in_r1": "bitMask"
            },
            "calling": [
                "pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800709e": {
            "entrypoint": "0x0800709e",
            "current_name": "handle_exception_0800709e",
            "code": "\nint handle_exception_0800709e(exception *exception_obj)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800709e": "handle_exception_0800709e",
                "__exc": "exception_obj"
            },
            "calling": [
                "pow",
                "sqrt",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080070a4": {
            "entrypoint": "0x080070a4",
            "current_name": "calculate_tag_value_080070a4",
            "code": "\ndouble calculateTagValue_080070a4(char *tag)\n\n{\n  double tagValue;\n  \n  return tagValue;\n}\n\n",
            "renaming": {
                "FUN_080070a4": "calculate_tag_value_080070a4",
                "__tagb": "tag",
                "in_d0": "tagValue"
            },
            "calling": [
                "__ieee754_pow",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080070b0": {
            "entrypoint": "0x080070b0",
            "current_name": "calculate_double_difference_080070b0",
            "code": "\ndouble calculate_double_difference_080070b0(double input_value)\n\n{\n  int sign_shift;\n  uint lower_bits;\n  uint higher_bits;\n  undefined4 low_bits_1;\n  undefined4 low_bits_2;\n  uint exponent_diff;\n  uint exponent;\n  double default_value;\n  double result;\n  undefined8 temp_variable;\n  \n  exponent = (higher_bits << 1) >> 0x15;\n  exponent_diff = exponent - 0x3ff;\n  sign_shift = (int)higher_bits >> 0x1f;\n  if ((int)exponent_diff < 0x14) {\n    if ((int)exponent_diff < 0) {\n      if ((higher_bits & 0x7fffffff | lower_bits) == 0) {\n        return default_value;\n      }\n      exponent_diff = higher_bits & 0xfffff | lower_bits;\n      sign_shift = sign_shift * -8;\n      low_bits_1 = *(undefined4 *)(&TWO52 + sign_shift);\n      low_bits_2 = *(undefined4 *)(&DAT_08007434 + sign_shift);\n      temp_variable = __aeabi_dadd(lower_bits,(-exponent_diff | exponent_diff) >> 0xc & 0x80000 | higher_bits & 0xfffe0000,low_bits_1,low_bits_2)\n      ;\n      result = (double)__subdf3((int)temp_variable,(int)((ulonglong)temp_variable >> 0x20),low_bits_1,low_bits_2);\n      return result;\n    }\n    exponent = 0xfffff >> (exponent_diff & 0xff);\n    if ((higher_bits & exponent | lower_bits) == 0) {\n      return default_value;\n    }\n    exponent = exponent >> 1;\n    lower_bits = higher_bits & exponent | lower_bits;\n    if (lower_bits != 0) {\n      if (exponent_diff == 0x13) {\n        lower_bits = 0x80000000;\n      }\n      else {\n        lower_bits = 0;\n      }\n      higher_bits = 0x40000 >> (exponent_diff & 0xff) | higher_bits & ~exponent;\n    }\n  }\n  else {\n    if (0x33 < (int)exponent_diff) {\n      if (exponent_diff != 0x400) {\n        return default_value;\n      }\n      result = (double)__aeabi_dadd();\n      return result;\n    }\n    exponent = exponent - 0x413;\n    exponent_diff = 0xffffffff >> (exponent & 0xff);\n    if ((lower_bits & exponent_diff) == 0) {\n      return default_value;\n    }\n    exponent_diff = exponent_diff >> 1;\n    if ((lower_bits & exponent_diff) != 0) {\n      lower_bits = 0x40000000 >> (exponent & 0xff) | lower_bits & ~exponent_diff;\n    }\n  }\n  sign_shift = sign_shift * -8;\n  low_bits_1 = *(undefined4 *)(&TWO52 + sign_shift);\n  low_bits_2 = *(undefined4 *)(&DAT_08007434 + sign_shift);\n  temp_variable = __aeabi_dadd(lower_bits,higher_bits,low_bits_1,low_bits_2);\n  result = (double)__subdf3((int)temp_variable,(int)((ulonglong)temp_variable >> 0x20),low_bits_1,low_bits_2);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080070b0": "calculate_double_difference_080070b0",
                "__x": "input_value",
                "iVar1": "sign_shift",
                "in_r0": "lower_bits",
                "in_r1": "higher_bits",
                "uVar2": "low_bits_1",
                "uVar3": "low_bits_2",
                "uVar4": "exponent_diff",
                "uVar5": "exponent",
                "in_d0": "default_value",
                "dVar6": "result",
                "uVar7": "temp_variable"
            },
            "calling": [
                "pow"
            ],
            "called": [
                "__aeabi_dadd",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080071c0": {
            "entrypoint": "0x080071c0",
            "current_name": "calculate_exponential_080071c0",
            "code": "\ndouble calculateExponential_080071c0(double base,int exponent)\n\n{\n  uint shiftCount;\n  int extraShiftCount;\n  int secondPart;\n  uint shiftedShiftCount;\n  int totalShift;\n  undefined4 in_r3;\n  undefined4 signPart1;\n  undefined4 signPart2;\n  undefined4 signPart3;\n  double result;\n  double finalResult;\n  \n  shiftedShiftCount = (shiftCount << 1) >> 0x15;\n  if (shiftedShiftCount == 0) {\n    if ((shiftCount & 0x7fffffff | exponent) == 0) {\n      return result;\n    }\n    result = (double)__muldf3(exponent,shiftCount,0,0x43500000);\n    if (secondPart < -50000) goto LAB_0800722e;\n    shiftedShiftCount = ((uint)(extraShiftCount << 1) >> 0x15) - 0x36;\n  }\n  else if (shiftedShiftCount == 0x7ff) {\n    finalResult = (double)__aeabi_dadd(exponent,shiftCount,exponent);\n    return finalResult;\n  }\n  totalShift = shiftedShiftCount + secondPart;\n  if (totalShift < 0x7ff) {\n    if (0 < totalShift) {\n      return result;\n    }\n    if (totalShift + 0x35 < 0 == SCARRY4(totalShift,0x35)) goto LAB_0800722e;\n    if (secondPart < 0xc351) {\n      copysign((double)CONCAT44(signPart1,in_r3),(double)CONCAT44(signPart3,signPart2));\n      goto LAB_0800722e;\n    }\n  }\n  copysign((double)CONCAT44(signPart1,in_r3),(double)CONCAT44(signPart3,signPart2));\nLAB_0800722e:\n  finalResult = (double)__muldf3();\n  return finalResult;\n}\n\n",
            "renaming": {
                "FUN_080071c0": "calculate_exponential_080071c0",
                "__x": "base",
                "__n": "exponent",
                "in_r1": "shiftCount",
                "extraout_r1": "extraShiftCount",
                "in_r2": "secondPart",
                "uVar1": "shiftedShiftCount",
                "iVar2": "totalShift",
                "in_d0": "result",
                "dVar3": "finalResult",
                "unaff_r4": "signPart1",
                "unaff_r5": "signPart2",
                "unaff_r6": "signPart3"
            },
            "calling": [
                "__ieee754_pow"
            ],
            "called": [
                "__aeabi_dadd",
                "__muldf3",
                "copysign"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800729c": {
            "entrypoint": "0x0800729c",
            "current_name": "calculate_hypotenuse_0800729c",
            "code": "\ndouble calculateHypotenuse_0800729c(double base,double height)\n\n{\n  double hypotenuse;\n  \n  return hypotenuse;\n}\n\n",
            "renaming": {
                "FUN_0800729c": "calculate_hypotenuse_0800729c",
                "__x": "base",
                "__y": "height",
                "in_d0": "hypotenuse"
            },
            "calling": [
                "scalbn"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072ac": {
            "entrypoint": "0x080072ac",
            "current_name": "get_impure_pointer_080072ac",
            "code": "\nundefined4 getImpurePointer_080072ac(void)\n\n{\n  return impurePointer;\n}\n\n",
            "renaming": {
                "FUN_080072ac": "get_impure_pointer_080072ac",
                "_impure_ptr": "impurePointer"
            },
            "calling": [
                "pow",
                "sqrt",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072b8": {
            "entrypoint": "0x080072b8",
            "current_name": "allocate_memory_080072b8",
            "code": "\nvoid * allocateMemory_080072b8(intptr_t increaseSize)\n\n{\n  undefined *previousEnd;\n  \n  if (currentEnd == (undefined *)0x0) {\n    currentEnd = &endOfBss;\n  }\n  previousEnd = currentEnd;\n  currentEnd = currentEnd + increaseSize;\n  return previousEnd;\n}\n\n",
            "renaming": {
                "FUN_080072b8": "allocate_memory_080072b8",
                "__delta": "increaseSize",
                "puVar1": "previousEnd",
                "heap_end_4116": "currentEnd",
                "_ebss": "endOfBss"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072d4": {
            "entrypoint": "0x080072d4",
            "current_name": "get_context_pointer_080072d4",
            "code": "\nint getContextPointer_080072d4(EVP_PKEY_CTX *context)\n\n{\n  return (int)context;\n}\n\n",
            "renaming": {
                "FUN_080072d4": "get_context_pointer_080072d4",
                "ctx": "context"
            },
            "calling": [
                "__libc_init_array",
                "__do_global_dtors_aux",
                "frame_dummy"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072e0": {
            "entrypoint": "0x080072e0",
            "current_name": "FUNC_080072e0",
            "code": "\nvoid FUNC_080072e0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080072e0": "FUNC_080072e0"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 169420,
    "layers": [
        [
            "FUN_08000110",
            "FUN_08000134",
            "FUN_08000150",
            "FUN_08000160",
            "FUN_08000168",
            "FUN_0800016c",
            "FUN_080003e4",
            "FUN_08000404",
            "FUN_08000428",
            "FUN_08000464",
            "FUN_08000474",
            "FUN_080006ac",
            "FUN_08000892",
            "FUN_080008f4",
            "FUN_080008fc",
            "FUN_08000904",
            "FUN_08000980",
            "FUN_08000990",
            "FUN_080009a0",
            "FUN_080009b4",
            "FUN_080009c8",
            "FUN_080009dc",
            "FUN_080009f0",
            "FUN_08000a04",
            "FUN_08000a30",
            "FUN_08000ad0",
            "FUN_08000ad8",
            "FUN_08000adc",
            "FUN_08000c3c",
            "FUN_08000c44",
            "FUN_08000c60",
            "FUN_08000c70",
            "FUN_08000cec",
            "FUN_08000e54",
            "FUN_08000f8c",
            "FUN_08000f94",
            "FUN_08000f9c",
            "FUN_08000ffc",
            "FUN_08001004",
            "FUN_08001014",
            "FUN_08001028",
            "FUN_0800103c",
            "FUN_08001050",
            "FUN_08001064",
            "FUN_08001078",
            "FUN_080010c4",
            "FUN_08001104",
            "FUN_08001128",
            "FUN_0800114c",
            "FUN_0800115c",
            "FUN_08001170",
            "FUN_08001194",
            "FUN_080011fc",
            "FUN_08001214",
            "FUN_08001240",
            "FUN_0800125a",
            "FUN_08001264",
            "FUN_08001424",
            "FUN_0800142e",
            "FUN_08001436",
            "FUN_08001460",
            "FUN_080014e2",
            "FUN_08001530",
            "FUN_080015e8",
            "FUN_080016f4",
            "FUN_08001754",
            "FUN_08001828",
            "FUN_08001938",
            "FUN_08001b58",
            "FUN_08002008",
            "FUN_0800209c",
            "FUN_08002214",
            "FUN_08002220",
            "FUN_08002250",
            "FUN_08002280",
            "FUN_080022d0",
            "FUN_08002324",
            "FUN_08002368",
            "FUN_080023d0",
            "FUN_08002404",
            "FUN_0800245c",
            "FUN_08002520",
            "FUN_08002538",
            "FUN_08002564",
            "FUN_080025a4",
            "FUN_080025e8",
            "FUN_08002724",
            "FUN_0800277c",
            "FUN_080028a6",
            "FUN_0800290c",
            "FUN_0800299a",
            "FUN_08002ad0",
            "FUN_08002b48",
            "FUN_08002bf0",
            "FUN_08002cb0",
            "FUN_08002d88",
            "FUN_08002ea0",
            "FUN_08002ec0",
            "FUN_08002ed4",
            "FUN_08002ee8",
            "FUN_08002f28",
            "FUN_08003034",
            "FUN_08003068",
            "FUN_08003078",
            "FUN_08003298",
            "FUN_08003314",
            "FUN_08003320",
            "FUN_08003330",
            "FUN_08003eac",
            "FUN_08003eb0",
            "FUN_08003ec8",
            "FUN_08003ef2",
            "FUN_08003f0e",
            "FUN_08003f3c",
            "FUN_08003f7c",
            "FUN_08003fc4",
            "FUN_08003fd0",
            "FUN_08003fdc",
            "FUN_08003fe8",
            "FUN_08003ff4",
            "FUN_08004028",
            "FUN_0800403c",
            "FUN_0800407c",
            "FUN_080040b8",
            "FUN_080040e8",
            "FUN_0800411c",
            "FUN_08004194",
            "FUN_080041ae",
            "FUN_080041c4",
            "FUN_080041e4",
            "FUN_0800426c",
            "FUN_08004300",
            "FUN_08004348",
            "FUN_08004384",
            "FUN_080043bc",
            "FUN_080043f0",
            "FUN_08004410",
            "FUN_08004434",
            "FUN_08004458",
            "FUN_08004490",
            "FUN_08004514",
            "FUN_0800458c",
            "FUN_0800483c",
            "FUN_08004978",
            "FUN_08004a30",
            "FUN_08004a84",
            "FUN_08004c18",
            "FUN_08004c30",
            "FUN_08004c64",
            "FUN_08004c70",
            "FUN_08004c8c",
            "FUN_08004cac",
            "FUN_08004ccc",
            "FUN_08004d48",
            "FUN_08004d8c",
            "FUN_08004e14",
            "FUN_08004e7c",
            "FUN_08004ee6",
            "FUN_08004ee8",
            "FUN_08004eea",
            "FUN_08004eec",
            "FUN_08004ef4",
            "FUN_08004f04",
            "FUN_08004f10",
            "FUN_08004f60",
            "FUN_08004f68",
            "FUN_08004fb0",
            "FUN_08004fb4",
            "FUN_08004ffc",
            "FUN_08005044",
            "FUN_080050fc",
            "FUN_080052e4",
            "FUN_080053d4",
            "FUN_08005614",
            "FUN_08005630",
            "FUN_08005646",
            "FUN_0800567c",
            "FUN_08005714",
            "FUN_080057d0",
            "FUN_0800581c",
            "FUN_08005840",
            "FUN_08005854",
            "FUN_08005900",
            "FUN_08005bc8",
            "FUN_08005c70",
            "FUN_08006070",
            "FUN_08006228",
            "FUN_08006c0c",
            "FUN_08006d68",
            "FUN_0800708c",
            "FUN_08007092",
            "FUN_0800709e",
            "FUN_080070a4",
            "FUN_080070b0",
            "FUN_080071c0",
            "FUN_0800729c",
            "FUN_080072ac",
            "FUN_080072b8",
            "FUN_080072d4"
        ],
        [
            "FUN_080004d0",
            "FUN_08000724"
        ]
    ],
    "locked_functions": []
}