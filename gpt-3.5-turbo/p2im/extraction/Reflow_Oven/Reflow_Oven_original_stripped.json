{
  "functions": {
    "FUN_0800010c": {
      "entrypoint": "0x0800010c",
      "current_name": "FUN_0800010c",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x08000118) */\n\nundefined4 FUN_0800010c(undefined4 param_1)\n\n{\n  if ((char)completed_8667 \u003d\u003d \u0027\\0\u0027) {\n    completed_8667._0_1_ \u003d \u0027\\x01\u0027;\n  }\n  return param_1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_init"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08000130": {
      "entrypoint": "0x08000130",
      "current_name": "FUN_08000130",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x08000134) */\n/* WARNING: Removing unreachable block (ram,0x0800014e) */\n/* WARNING: Removing unreachable block (ram,0x08000144) */\n/* WARNING: Removing unreachable block (ram,0x08000160) */\n/* WARNING: Removing unreachable block (ram,0x08000154) */\n\n\nvoid FUN_08000130(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08000178": {
      "entrypoint": "0x08000178",
      "current_name": "FUN_08000178",
      "code": "\nsize_t FUN_08000178(char *__s)\n\n{\n  char cVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  pcVar3 \u003d __s;\n  do {\n    pcVar2 \u003d pcVar3 + 1;\n    cVar1 \u003d *pcVar3;\n    pcVar3 \u003d pcVar2;\n  } while (cVar1 !\u003d \u0027\\0\u0027);\n  return (size_t)(pcVar2 + (-1 - (int)__s));\n}\n\n",
      "renaming": {},
      "calling": [
        "print",
        "printNumber"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08000188": {
      "entrypoint": "0x08000188",
      "current_name": "FUN_08000188",
      "code": "\nvoid FUN_08000188(undefined4 param_1,uint param_2)\n\n{\n  __aeabi_dadd(param_1,param_2 ^ 0x80000000);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__aeabi_dadd"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08000190": {
      "entrypoint": "0x08000190",
      "current_name": "FUN_08000190",
      "code": "\nulonglong FUN_08000190(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  bool bVar14;\n  bool bVar15;\n  \n  uVar6 \u003d param_4 ^ 0x80000000;\n  uVar9 \u003d param_2 \u003c\u003c 1;\n  param_4 \u003d param_4 \u003c\u003c 1;\n  bVar13 \u003d ((param_2 ^ uVar6) \u0026 0x7fffffff) \u003d\u003d 0;\n  bVar14 \u003d bVar13 \u0026\u0026 param_1 \u003d\u003d param_3;\n  if (!bVar13 || param_1 !\u003d param_3) {\n    bVar14 \u003d (uVar9 | param_1) \u003d\u003d 0;\n  }\n  if (!bVar14) {\n    bVar14 \u003d (param_4 | param_3) \u003d\u003d 0;\n  }\n  iVar8 \u003d (int)uVar9 \u003e\u003e 0x15;\n  if (!bVar14) {\n    bVar14 \u003d iVar8 \u003d\u003d -1;\n  }\n  iVar1 \u003d (int)param_4 \u003e\u003e 0x15;\n  if (!bVar14) {\n    bVar14 \u003d iVar1 \u003d\u003d -1;\n  }\n  if (bVar14) {\n    if (iVar8 \u003d\u003d -1 || iVar1 \u003d\u003d -1) {\n      uVar9 \u003d uVar6;\n      uVar11 \u003d param_3;\n      if (iVar8 \u003d\u003d -1) {\n        uVar9 \u003d param_2;\n        uVar11 \u003d param_1;\n      }\n      if (iVar8 !\u003d -1 || iVar1 !\u003d -1) {\n        param_3 \u003d uVar11;\n        uVar6 \u003d uVar9;\n      }\n      bVar14 \u003d (uVar11 | uVar9 \u003c\u003c 0xc) \u003d\u003d 0;\n      if (bVar14) {\n        bVar14 \u003d (param_3 | uVar6 \u003c\u003c 0xc) \u003d\u003d 0;\n      }\n      if (bVar14) {\n        bVar14 \u003d uVar9 \u003d\u003d uVar6;\n      }\n      if (!bVar14) {\n        uVar9 \u003d uVar9 | 0x80000;\n      }\n      return CONCAT44(uVar9,uVar11);\n    }\n    if (((param_2 ^ uVar6) \u0026 0x7fffffff) !\u003d 0 || param_1 !\u003d param_3) {\n      if ((uVar9 | param_1) \u003d\u003d 0) {\n        param_1 \u003d param_3;\n        param_2 \u003d uVar6;\n      }\n      return CONCAT44(param_2,param_1);\n    }\n    if (param_2 !\u003d uVar6) {\n      return 0;\n    }\n    if (uVar9 \u003e\u003e 0x15 \u003d\u003d 0) {\n      bVar14 \u003d (param_1 \u0026 0x80000000) !\u003d 0;\n      uVar6 \u003d param_2 * 2 + (uint)bVar14;\n      if (CARRY4(param_2,param_2) || CARRY4(param_2 * 2,(uint)bVar14)) {\n        uVar6 \u003d uVar6 | 0x80000000;\n      }\n      return CONCAT44(uVar6,param_1 \u003c\u003c 1);\n    }\n    if (uVar9 \u003c 0xffc00000) {\n      return CONCAT44(param_2 + 0x100000,param_1);\n    }\n    param_2 \u003d param_2 \u0026 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(param_2 | 0x7ff00000) \u003c\u003c 0x20;\n  }\n  uVar9 \u003d uVar9 \u003e\u003e 0x15;\n  param_4 \u003d param_4 \u003e\u003e 0x15;\n  uVar11 \u003d param_4 - uVar9;\n  bVar14 \u003d uVar11 !\u003d 0;\n  if (param_4 \u003c uVar9) {\n    uVar11 \u003d -uVar11;\n  }\n  uVar10 \u003d param_1;\n  uVar7 \u003d param_2;\n  if (bVar14 \u0026\u0026 uVar9 \u003c\u003d param_4) {\n    uVar9 \u003d uVar9 + uVar11;\n    uVar10 \u003d param_3;\n    uVar7 \u003d uVar6;\n    param_3 \u003d param_1;\n    uVar6 \u003d param_2;\n  }\n  if (0x36 \u003c uVar11) {\n    return CONCAT44(uVar7,uVar10);\n  }\n  uVar4 \u003d uVar7 \u0026 0xfffff | 0x100000;\n  if ((uVar7 \u0026 0x80000000) !\u003d 0) {\n    bVar14 \u003d uVar10 !\u003d 0;\n    uVar10 \u003d -uVar10;\n    uVar4 \u003d -uVar4 - (uint)bVar14;\n  }\n  uVar7 \u003d uVar6 \u0026 0xfffff | 0x100000;\n  if ((uVar6 \u0026 0x80000000) !\u003d 0) {\n    bVar14 \u003d param_3 !\u003d 0;\n    param_3 \u003d -param_3;\n    uVar7 \u003d -uVar7 - (uint)bVar14;\n  }\n  if (uVar9 \u003d\u003d uVar11) {\n    uVar7 \u003d uVar7 ^ 0x100000;\n    if (uVar9 \u003d\u003d 0) {\n      uVar4 \u003d uVar4 ^ 0x100000;\n      uVar9 \u003d 1;\n    }\n    else {\n      uVar11 \u003d uVar11 - 1;\n    }\n  }\n  uVar6 \u003d -uVar11 + 0x20;\n  if ((int)uVar11 \u003c 0x21) {\n    uVar12 \u003d param_3 \u003c\u003c (uVar6 \u0026 0xff);\n    param_3 \u003d param_3 \u003e\u003e (uVar11 \u0026 0xff);\n    uVar3 \u003d uVar10 + param_3;\n    uVar5 \u003d uVar7 \u003c\u003c (uVar6 \u0026 0xff);\n    uVar6 \u003d uVar3 + uVar5;\n    uVar4 \u003d uVar4 + CARRY4(uVar10,param_3) + ((int)uVar7 \u003e\u003e (uVar11 \u0026 0xff)) +\n            (uint)CARRY4(uVar3,uVar5);\n  }\n  else {\n    uVar12 \u003d uVar7 \u003c\u003c (-uVar11 + 0x40 \u0026 0xff);\n    if (param_3 !\u003d 0) {\n      uVar12 \u003d uVar12 | 2;\n    }\n    uVar7 \u003d (int)uVar7 \u003e\u003e (uVar11 - 0x20 \u0026 0xff);\n    uVar6 \u003d uVar10 + uVar7;\n    uVar4 \u003d uVar4 + ((int)uVar7 \u003e\u003e 0x1f) + (uint)CARRY4(uVar10,uVar7);\n  }\n  param_2 \u003d uVar4 \u0026 0x80000000;\n  uVar11 \u003d uVar4;\n  if ((int)uVar4 \u003c 0) {\n    bVar14 \u003d uVar12 \u003d\u003d 0;\n    uVar12 \u003d -uVar12;\n    uVar11 \u003d -uVar6;\n    uVar6 \u003d -(uint)!bVar14 - uVar6;\n    uVar11 \u003d -(uint)(bVar14 \u003c\u003d uVar11) - uVar4;\n  }\n  if (0xfffff \u003c uVar11) {\n    uVar10 \u003d uVar9 - 1;\n    if (0x1fffff \u003c uVar11) {\n      uVar10 \u003d uVar11 \u0026 1;\n      uVar11 \u003d uVar11 \u003e\u003e 1;\n      bVar2 \u003d (byte)uVar6;\n      uVar6 \u003d (uint)(uVar10 !\u003d 0) \u003c\u003c 0x1f | uVar6 \u003e\u003e 1;\n      uVar12 \u003d (uint)(bVar2 \u0026 1) \u003c\u003c 0x1f | uVar12 \u003e\u003e 1;\n      uVar10 \u003d uVar9;\n      if (0xffbfffff \u003c uVar9 * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    bVar14 \u003d 0x7fffffff \u003c uVar12;\n    if (uVar12 \u003d\u003d 0x80000000) {\n      bVar14 \u003d (uVar6 \u0026 1) !\u003d 0;\n    }\n    return CONCAT44(uVar11 + uVar10 * 0x100000 + (uint)CARRY4(uVar6,(uint)bVar14) | param_2,\n                    uVar6 + bVar14);\n  }\n  bVar13 \u003d (uVar12 \u0026 0x80000000) !\u003d 0;\n  uVar12 \u003d uVar12 \u003c\u003c 1;\n  uVar10 \u003d uVar6 * 2;\n  bVar14 \u003d CARRY4(uVar6,uVar6);\n  uVar6 \u003d uVar6 * 2 + (uint)bVar13;\n  uVar11 \u003d uVar11 * 2 + (uint)(bVar14 || CARRY4(uVar10,(uint)bVar13));\n  uVar10 \u003d uVar9 - 2;\n  if ((uVar11 \u0026 0x100000) !\u003d 0) goto LAB_080002a0;\n  uVar7 \u003d uVar6;\n  uVar9 \u003d uVar11;\n  if (uVar11 \u003d\u003d 0) {\n    uVar7 \u003d 0;\n    uVar9 \u003d uVar6;\n  }\n  iVar8 \u003d LZCOUNT(uVar9);\n  if (uVar11 \u003d\u003d 0) {\n    iVar8 \u003d iVar8 + 0x20;\n  }\n  uVar11 \u003d iVar8 - 0xb;\n  bVar15 \u003d SBORROW4(uVar11,0x20);\n  uVar6 \u003d iVar8 - 0x2b;\n  bVar14 \u003d (int)uVar6 \u003c 0;\n  bVar13 \u003d uVar6 \u003d\u003d 0;\n  if ((int)uVar11 \u003c 0x20) {\n    bVar15 \u003d SCARRY4(uVar6,0xc);\n    iVar8 \u003d iVar8 + -0x1f;\n    bVar14 \u003d iVar8 \u003c 0;\n    bVar13 \u003d iVar8 \u003d\u003d 0;\n    uVar6 \u003d uVar11;\n    if (!bVar13 \u0026\u0026 bVar14 \u003d\u003d bVar15) {\n      uVar7 \u003d uVar9 \u003c\u003c (uVar11 \u0026 0xff);\n      uVar9 \u003d uVar9 \u003e\u003e (0xcU - iVar8 \u0026 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (bVar13 || bVar14 !\u003d bVar15) {\n    uVar12 \u003d 0x20 - uVar6;\n  }\n  uVar9 \u003d uVar9 \u003c\u003c (uVar6 \u0026 0xff);\n  if (bVar13 || bVar14 !\u003d bVar15) {\n    uVar9 \u003d uVar9 | uVar7 \u003e\u003e (uVar12 \u0026 0xff);\n  }\n  if (bVar13 || bVar14 !\u003d bVar15) {\n    uVar7 \u003d uVar7 \u003c\u003c (uVar6 \u0026 0xff);\n  }\nLAB_08000318:\n  if ((int)uVar11 \u003c\u003d (int)uVar10) {\n    return CONCAT44(uVar9 + (uVar10 - uVar11) * 0x100000 | param_2,uVar7);\n  }\n  uVar6 \u003d ~(uVar10 - uVar11);\n  if ((int)uVar6 \u003c 0x1f) {\n    iVar8 \u003d uVar6 - 0x13;\n    if (iVar8 !\u003d 0 \u0026\u0026 iVar8 \u003c 0 \u003d\u003d SCARRY4(uVar6 - 0x1f,0xc)) {\n      return CONCAT44(uVar4,uVar7 \u003e\u003e (0x20 - (0xcU - iVar8) \u0026 0xff) | uVar9 \u003c\u003c (0xcU - iVar8 \u0026 0xff)\n                     ) \u0026 0x80000000ffffffff;\n    }\n    uVar6 \u003d uVar6 + 1;\n    return CONCAT44(param_2 | uVar9 \u003e\u003e (uVar6 \u0026 0xff),\n                    uVar7 \u003e\u003e (uVar6 \u0026 0xff) | uVar9 \u003c\u003c (0x20 - uVar6 \u0026 0xff));\n  }\n  return CONCAT44(uVar4,uVar9 \u003e\u003e (uVar6 - 0x1f \u0026 0xff)) \u0026 0x80000000ffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "SetTunings",
        "Compute",
        "SetControllerDirection",
        "printFloat"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08000194": {
      "entrypoint": "0x08000194",
      "current_name": "FUN_08000194",
      "code": "\nulonglong FUN_08000194(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  bool bVar14;\n  bool bVar15;\n  \n  uVar7 \u003d param_2 \u003c\u003c 1;\n  uVar9 \u003d param_4 \u003c\u003c 1;\n  bVar13 \u003d ((param_2 ^ param_4) \u0026 0x7fffffff) \u003d\u003d 0;\n  bVar14 \u003d bVar13 \u0026\u0026 param_1 \u003d\u003d param_3;\n  if (!bVar13 || param_1 !\u003d param_3) {\n    bVar14 \u003d (uVar7 | param_1) \u003d\u003d 0;\n  }\n  if (!bVar14) {\n    bVar14 \u003d (uVar9 | param_3) \u003d\u003d 0;\n  }\n  iVar6 \u003d (int)uVar7 \u003e\u003e 0x15;\n  if (!bVar14) {\n    bVar14 \u003d iVar6 \u003d\u003d -1;\n  }\n  iVar1 \u003d (int)uVar9 \u003e\u003e 0x15;\n  if (!bVar14) {\n    bVar14 \u003d iVar1 \u003d\u003d -1;\n  }\n  if (bVar14) {\n    if (iVar6 \u003d\u003d -1 || iVar1 \u003d\u003d -1) {\n      uVar9 \u003d param_4;\n      uVar7 \u003d param_3;\n      if (iVar6 \u003d\u003d -1) {\n        uVar9 \u003d param_2;\n        uVar7 \u003d param_1;\n      }\n      if (iVar6 !\u003d -1 || iVar1 !\u003d -1) {\n        param_3 \u003d uVar7;\n        param_4 \u003d uVar9;\n      }\n      bVar14 \u003d (uVar7 | uVar9 \u003c\u003c 0xc) \u003d\u003d 0;\n      if (bVar14) {\n        bVar14 \u003d (param_3 | param_4 \u003c\u003c 0xc) \u003d\u003d 0;\n      }\n      if (bVar14) {\n        bVar14 \u003d uVar9 \u003d\u003d param_4;\n      }\n      if (!bVar14) {\n        uVar9 \u003d uVar9 | 0x80000;\n      }\n      return CONCAT44(uVar9,uVar7);\n    }\n    if (((param_2 ^ param_4) \u0026 0x7fffffff) !\u003d 0 || param_1 !\u003d param_3) {\n      if ((uVar7 | param_1) \u003d\u003d 0) {\n        param_1 \u003d param_3;\n        param_2 \u003d param_4;\n      }\n      return CONCAT44(param_2,param_1);\n    }\n    if (param_2 !\u003d param_4) {\n      return 0;\n    }\n    if (uVar7 \u003e\u003e 0x15 \u003d\u003d 0) {\n      bVar14 \u003d (param_1 \u0026 0x80000000) !\u003d 0;\n      uVar9 \u003d param_2 * 2 + (uint)bVar14;\n      if (CARRY4(param_2,param_2) || CARRY4(param_2 * 2,(uint)bVar14)) {\n        uVar9 \u003d uVar9 | 0x80000000;\n      }\n      return CONCAT44(uVar9,param_1 \u003c\u003c 1);\n    }\n    if (uVar7 \u003c 0xffc00000) {\n      return CONCAT44(param_2 + 0x100000,param_1);\n    }\n    param_2 \u003d param_2 \u0026 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(param_2 | 0x7ff00000) \u003c\u003c 0x20;\n  }\n  uVar7 \u003d uVar7 \u003e\u003e 0x15;\n  uVar9 \u003d uVar9 \u003e\u003e 0x15;\n  uVar10 \u003d uVar9 - uVar7;\n  bVar14 \u003d uVar10 !\u003d 0;\n  if (uVar9 \u003c uVar7) {\n    uVar10 \u003d -uVar10;\n  }\n  uVar8 \u003d param_1;\n  uVar5 \u003d param_2;\n  if (bVar14 \u0026\u0026 uVar7 \u003c\u003d uVar9) {\n    uVar7 \u003d uVar7 + uVar10;\n    uVar8 \u003d param_3;\n    uVar5 \u003d param_4;\n    param_3 \u003d param_1;\n    param_4 \u003d param_2;\n  }\n  if (0x36 \u003c uVar10) {\n    return CONCAT44(uVar5,uVar8);\n  }\n  uVar9 \u003d uVar5 \u0026 0xfffff | 0x100000;\n  if ((uVar5 \u0026 0x80000000) !\u003d 0) {\n    bVar14 \u003d uVar8 !\u003d 0;\n    uVar8 \u003d -uVar8;\n    uVar9 \u003d -uVar9 - (uint)bVar14;\n  }\n  uVar5 \u003d param_4 \u0026 0xfffff | 0x100000;\n  if ((param_4 \u0026 0x80000000) !\u003d 0) {\n    bVar14 \u003d param_3 !\u003d 0;\n    param_3 \u003d -param_3;\n    uVar5 \u003d -uVar5 - (uint)bVar14;\n  }\n  if (uVar7 \u003d\u003d uVar10) {\n    uVar5 \u003d uVar5 ^ 0x100000;\n    if (uVar7 \u003d\u003d 0) {\n      uVar9 \u003d uVar9 ^ 0x100000;\n      uVar7 \u003d 1;\n    }\n    else {\n      uVar10 \u003d uVar10 - 1;\n    }\n  }\n  uVar12 \u003d -uVar10 + 0x20;\n  if ((int)uVar10 \u003c 0x21) {\n    uVar11 \u003d param_3 \u003c\u003c (uVar12 \u0026 0xff);\n    param_3 \u003d param_3 \u003e\u003e (uVar10 \u0026 0xff);\n    uVar3 \u003d uVar8 + param_3;\n    uVar4 \u003d uVar5 \u003c\u003c (uVar12 \u0026 0xff);\n    uVar12 \u003d uVar3 + uVar4;\n    uVar9 \u003d uVar9 + CARRY4(uVar8,param_3) + ((int)uVar5 \u003e\u003e (uVar10 \u0026 0xff)) +\n            (uint)CARRY4(uVar3,uVar4);\n  }\n  else {\n    uVar11 \u003d uVar5 \u003c\u003c (-uVar10 + 0x40 \u0026 0xff);\n    if (param_3 !\u003d 0) {\n      uVar11 \u003d uVar11 | 2;\n    }\n    uVar5 \u003d (int)uVar5 \u003e\u003e (uVar10 - 0x20 \u0026 0xff);\n    uVar12 \u003d uVar8 + uVar5;\n    uVar9 \u003d uVar9 + ((int)uVar5 \u003e\u003e 0x1f) + (uint)CARRY4(uVar8,uVar5);\n  }\n  param_2 \u003d uVar9 \u0026 0x80000000;\n  uVar10 \u003d uVar9;\n  if ((int)uVar9 \u003c 0) {\n    bVar14 \u003d uVar11 \u003d\u003d 0;\n    uVar11 \u003d -uVar11;\n    uVar10 \u003d -uVar12;\n    uVar12 \u003d -(uint)!bVar14 - uVar12;\n    uVar10 \u003d -(uint)(bVar14 \u003c\u003d uVar10) - uVar9;\n  }\n  if (0xfffff \u003c uVar10) {\n    uVar8 \u003d uVar7 - 1;\n    if (0x1fffff \u003c uVar10) {\n      uVar9 \u003d uVar10 \u0026 1;\n      uVar10 \u003d uVar10 \u003e\u003e 1;\n      bVar2 \u003d (byte)uVar12;\n      uVar12 \u003d (uint)(uVar9 !\u003d 0) \u003c\u003c 0x1f | uVar12 \u003e\u003e 1;\n      uVar11 \u003d (uint)(bVar2 \u0026 1) \u003c\u003c 0x1f | uVar11 \u003e\u003e 1;\n      uVar8 \u003d uVar7;\n      if (0xffbfffff \u003c uVar7 * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    bVar14 \u003d 0x7fffffff \u003c uVar11;\n    if (uVar11 \u003d\u003d 0x80000000) {\n      bVar14 \u003d (uVar12 \u0026 1) !\u003d 0;\n    }\n    return CONCAT44(uVar10 + uVar8 * 0x100000 + (uint)CARRY4(uVar12,(uint)bVar14) | param_2,\n                    uVar12 + bVar14);\n  }\n  bVar13 \u003d (uVar11 \u0026 0x80000000) !\u003d 0;\n  uVar11 \u003d uVar11 \u003c\u003c 1;\n  uVar8 \u003d uVar12 * 2;\n  bVar14 \u003d CARRY4(uVar12,uVar12);\n  uVar12 \u003d uVar12 * 2 + (uint)bVar13;\n  uVar10 \u003d uVar10 * 2 + (uint)(bVar14 || CARRY4(uVar8,(uint)bVar13));\n  uVar8 \u003d uVar7 - 2;\n  if ((uVar10 \u0026 0x100000) !\u003d 0) goto LAB_080002a0;\n  uVar5 \u003d uVar12;\n  uVar7 \u003d uVar10;\n  if (uVar10 \u003d\u003d 0) {\n    uVar5 \u003d 0;\n    uVar7 \u003d uVar12;\n  }\n  iVar6 \u003d LZCOUNT(uVar7);\n  if (uVar10 \u003d\u003d 0) {\n    iVar6 \u003d iVar6 + 0x20;\n  }\n  uVar12 \u003d iVar6 - 0xb;\n  bVar15 \u003d SBORROW4(uVar12,0x20);\n  uVar10 \u003d iVar6 - 0x2b;\n  bVar14 \u003d (int)uVar10 \u003c 0;\n  bVar13 \u003d uVar10 \u003d\u003d 0;\n  if ((int)uVar12 \u003c 0x20) {\n    bVar15 \u003d SCARRY4(uVar10,0xc);\n    iVar6 \u003d iVar6 + -0x1f;\n    bVar14 \u003d iVar6 \u003c 0;\n    bVar13 \u003d iVar6 \u003d\u003d 0;\n    uVar10 \u003d uVar12;\n    if (!bVar13 \u0026\u0026 bVar14 \u003d\u003d bVar15) {\n      uVar5 \u003d uVar7 \u003c\u003c (uVar12 \u0026 0xff);\n      uVar7 \u003d uVar7 \u003e\u003e (0xcU - iVar6 \u0026 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (bVar13 || bVar14 !\u003d bVar15) {\n    uVar11 \u003d 0x20 - uVar10;\n  }\n  uVar7 \u003d uVar7 \u003c\u003c (uVar10 \u0026 0xff);\n  if (bVar13 || bVar14 !\u003d bVar15) {\n    uVar7 \u003d uVar7 | uVar5 \u003e\u003e (uVar11 \u0026 0xff);\n  }\n  if (bVar13 || bVar14 !\u003d bVar15) {\n    uVar5 \u003d uVar5 \u003c\u003c (uVar10 \u0026 0xff);\n  }\nLAB_08000318:\n  if ((int)uVar12 \u003c\u003d (int)uVar8) {\n    return CONCAT44(uVar7 + (uVar8 - uVar12) * 0x100000 | param_2,uVar5);\n  }\n  uVar10 \u003d ~(uVar8 - uVar12);\n  if ((int)uVar10 \u003c 0x1f) {\n    iVar6 \u003d uVar10 - 0x13;\n    if (iVar6 !\u003d 0 \u0026\u0026 iVar6 \u003c 0 \u003d\u003d SCARRY4(uVar10 - 0x1f,0xc)) {\n      return CONCAT44(uVar9,uVar5 \u003e\u003e (0x20 - (0xcU - iVar6) \u0026 0xff) | uVar7 \u003c\u003c (0xcU - iVar6 \u0026 0xff)\n                     ) \u0026 0x80000000ffffffff;\n    }\n    uVar10 \u003d uVar10 + 1;\n    return CONCAT44(param_2 | uVar7 \u003e\u003e (uVar10 \u0026 0xff),\n                    uVar5 \u003e\u003e (uVar10 \u0026 0xff) | uVar7 \u003c\u003c (0x20 - uVar10 \u0026 0xff));\n  }\n  return CONCAT44(uVar9,uVar7 \u003e\u003e (uVar10 - 0x1f \u0026 0xff)) \u0026 0x80000000ffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop",
        "Compute",
        "__aeabi_drsub",
        "readThermocouple",
        "printFloat"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800040c": {
      "entrypoint": "0x0800040c",
      "current_name": "FUN_0800040c",
      "code": "\nulonglong FUN_0800040c(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  uint in_r12;\n  bool bVar5;\n  bool bVar6;\n  bool bVar7;\n  \n  if (param_1 \u003d\u003d 0) {\n    return 0;\n  }\n  uVar1 \u003d 0;\n  iVar3 \u003d LZCOUNT(param_1);\n  uVar4 \u003d iVar3 + 0x15;\n  bVar7 \u003d SBORROW4(uVar4,0x20);\n  uVar2 \u003d iVar3 - 0xb;\n  bVar5 \u003d (int)uVar2 \u003c 0;\n  bVar6 \u003d uVar2 \u003d\u003d 0;\n  if (uVar4 \u003c 0x20) {\n    bVar7 \u003d SCARRY4(uVar2,0xc);\n    bVar5 \u003d false;\n    bVar6 \u003d iVar3 + 1 \u003d\u003d 0;\n    uVar2 \u003d uVar4;\n    if (!bVar6 \u0026\u0026 bVar7 \u003d\u003d false) {\n      uVar1 \u003d param_1 \u003c\u003c uVar4;\n      param_1 \u003d param_1 \u003e\u003e (0xcU - (iVar3 + 1) \u0026 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (bVar6 || bVar5 !\u003d bVar7) {\n    in_r12 \u003d 0x20 - uVar2;\n  }\n  param_1 \u003d param_1 \u003c\u003c (uVar2 \u0026 0xff);\n  if (bVar6 || bVar5 !\u003d bVar7) {\n    param_1 \u003d param_1 | 0U \u003e\u003e (in_r12 \u0026 0xff);\n  }\n  if (bVar6 || bVar5 !\u003d bVar7) {\n    uVar1 \u003d 0 \u003c\u003c (uVar2 \u0026 0xff);\n  }\nLAB_08000318:\n  if (uVar4 \u003c 0x433) {\n    return CONCAT44(param_1 + (0x432 - uVar4) * 0x100000,uVar1);\n  }\n  uVar2 \u003d ~(0x432 - uVar4);\n  if (0x1e \u003c (int)uVar2) {\n    return (ulonglong)(param_1 \u003e\u003e (uVar2 - 0x1f \u0026 0xff));\n  }\n  iVar3 \u003d uVar2 - 0x13;\n  if (iVar3 \u003d\u003d 0 || iVar3 \u003c 0 !\u003d SCARRY4(uVar2 - 0x1f,0xc)) {\n    uVar2 \u003d uVar2 + 1;\n    return CONCAT44(param_1 \u003e\u003e (uVar2 \u0026 0xff),\n                    uVar1 \u003e\u003e (uVar2 \u0026 0xff) | param_1 \u003c\u003c (0x20 - uVar2 \u0026 0xff));\n  }\n  return (ulonglong)(uVar1 \u003e\u003e (0x20 - (0xcU - iVar3) \u0026 0xff) | param_1 \u003c\u003c (0xcU - iVar3 \u0026 0xff));\n}\n\n",
      "renaming": {},
      "calling": [
        "loop",
        "SetTunings",
        "readThermocouple",
        "printFloat",
        "SetSampleTime"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800042c": {
      "entrypoint": "0x0800042c",
      "current_name": "FUN_0800042c",
      "code": "\nulonglong FUN_0800042c(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  uint in_r12;\n  bool bVar7;\n  bool bVar8;\n  bool bVar9;\n  \n  if (param_1 \u003d\u003d 0) {\n    return 0;\n  }\n  uVar6 \u003d param_1 \u0026 0x80000000;\n  uVar2 \u003d param_1;\n  if ((int)uVar6 \u003c 0) {\n    uVar2 \u003d -param_1;\n  }\n  uVar1 \u003d 0;\n  iVar4 \u003d LZCOUNT(uVar2);\n  uVar5 \u003d iVar4 + 0x15;\n  bVar9 \u003d SBORROW4(uVar5,0x20);\n  uVar3 \u003d iVar4 - 0xb;\n  bVar7 \u003d (int)uVar3 \u003c 0;\n  bVar8 \u003d uVar3 \u003d\u003d 0;\n  if (uVar5 \u003c 0x20) {\n    bVar9 \u003d SCARRY4(uVar3,0xc);\n    bVar7 \u003d false;\n    bVar8 \u003d iVar4 + 1 \u003d\u003d 0;\n    uVar3 \u003d uVar5;\n    if (!bVar8 \u0026\u0026 bVar9 \u003d\u003d false) {\n      uVar1 \u003d uVar2 \u003c\u003c uVar5;\n      uVar2 \u003d uVar2 \u003e\u003e (0xcU - (iVar4 + 1) \u0026 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (bVar8 || bVar7 !\u003d bVar9) {\n    in_r12 \u003d 0x20 - uVar3;\n  }\n  uVar2 \u003d uVar2 \u003c\u003c (uVar3 \u0026 0xff);\n  if (bVar8 || bVar7 !\u003d bVar9) {\n    uVar2 \u003d uVar2 | 0U \u003e\u003e (in_r12 \u0026 0xff);\n  }\n  if (bVar8 || bVar7 !\u003d bVar9) {\n    uVar1 \u003d 0 \u003c\u003c (uVar3 \u0026 0xff);\n  }\nLAB_08000318:\n  if (uVar5 \u003c 0x433) {\n    return CONCAT44(uVar2 + (0x432 - uVar5) * 0x100000 | uVar6,uVar1);\n  }\n  uVar3 \u003d ~(0x432 - uVar5);\n  if (0x1e \u003c (int)uVar3) {\n    return CONCAT44(param_1,uVar2 \u003e\u003e (uVar3 - 0x1f \u0026 0xff)) \u0026 0x80000000ffffffff;\n  }\n  iVar4 \u003d uVar3 - 0x13;\n  if (iVar4 \u003d\u003d 0 || iVar4 \u003c 0 !\u003d SCARRY4(uVar3 - 0x1f,0xc)) {\n    uVar3 \u003d uVar3 + 1;\n    return CONCAT44(uVar6 | uVar2 \u003e\u003e (uVar3 \u0026 0xff),\n                    uVar1 \u003e\u003e (uVar3 \u0026 0xff) | uVar2 \u003c\u003c (0x20 - uVar3 \u0026 0xff));\n  }\n  return CONCAT44(param_1,uVar1 \u003e\u003e (0x20 - (0xcU - iVar4) \u0026 0xff) | uVar2 \u003c\u003c (0xcU - iVar4 \u0026 0xff))\n         \u0026 0x80000000ffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop",
        "printFloat",
        "SetSampleTime"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08000450": {
      "entrypoint": "0x08000450",
      "current_name": "FUN_08000450",
      "code": "\nulonglong FUN_08000450(uint param_1,undefined4 param_2,undefined4 param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  uint uVar7;\n  uint in_r12;\n  bool bVar8;\n  bool bVar9;\n  bool bVar10;\n  \n  uVar5 \u003d param_1 \u003c\u003c 1;\n  bVar9 \u003d uVar5 \u003d\u003d 0;\n  uVar1 \u003d (uint)((param_1 \u0026 0x80000000) !\u003d 0) \u003c\u003c 0x1f;\n  uVar4 \u003d (uint)((int)uVar5 \u003e\u003e 3) \u003e\u003e 1;\n  uVar3 \u003d uVar1 | uVar4;\n  param_1 \u003d param_1 \u003c\u003c 0x1d;\n  if (!bVar9) {\n    param_4 \u003d uVar5 \u0026 0xff000000;\n    bVar9 \u003d param_4 \u003d\u003d 0;\n  }\n  if (!bVar9) {\n    bVar9 \u003d param_4 \u003d\u003d 0xff000000;\n  }\n  if (!bVar9) {\n    return CONCAT44(uVar3,param_1) ^ 0x3800000000000000;\n  }\n  if (uVar5 \u003d\u003d 0 || param_4 \u003d\u003d 0xff000000) {\n    return CONCAT44(uVar3,param_1);\n  }\n  uVar2 \u003d param_1;\n  uVar5 \u003d uVar4;\n  if (uVar4 \u003d\u003d 0) {\n    uVar2 \u003d 0;\n    uVar5 \u003d param_1;\n  }\n  iVar6 \u003d LZCOUNT(uVar5);\n  if (uVar4 \u003d\u003d 0) {\n    iVar6 \u003d iVar6 + 0x20;\n  }\n  uVar7 \u003d iVar6 - 0xb;\n  bVar10 \u003d SBORROW4(uVar7,0x20);\n  uVar4 \u003d iVar6 - 0x2b;\n  bVar9 \u003d (int)uVar4 \u003c 0;\n  bVar8 \u003d uVar4 \u003d\u003d 0;\n  if ((int)uVar7 \u003c 0x20) {\n    bVar10 \u003d SCARRY4(uVar4,0xc);\n    iVar6 \u003d iVar6 + -0x1f;\n    bVar9 \u003d iVar6 \u003c 0;\n    bVar8 \u003d iVar6 \u003d\u003d 0;\n    uVar4 \u003d uVar7;\n    if (!bVar8 \u0026\u0026 bVar9 \u003d\u003d bVar10) {\n      uVar2 \u003d uVar5 \u003c\u003c (uVar7 \u0026 0xff);\n      uVar5 \u003d uVar5 \u003e\u003e (0xcU - iVar6 \u0026 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (bVar8 || bVar9 !\u003d bVar10) {\n    in_r12 \u003d 0x20 - uVar4;\n  }\n  uVar5 \u003d uVar5 \u003c\u003c (uVar4 \u0026 0xff);\n  if (bVar8 || bVar9 !\u003d bVar10) {\n    uVar5 \u003d uVar5 | uVar2 \u003e\u003e (in_r12 \u0026 0xff);\n  }\n  if (bVar8 || bVar9 !\u003d bVar10) {\n    uVar2 \u003d uVar2 \u003c\u003c (uVar4 \u0026 0xff);\n  }\nLAB_08000318:\n  if ((int)uVar7 \u003c 0x381) {\n    return CONCAT44(uVar5 + (0x380 - uVar7) * 0x100000 | uVar1,uVar2);\n  }\n  uVar4 \u003d ~(0x380 - uVar7);\n  if ((int)uVar4 \u003c 0x1f) {\n    iVar6 \u003d uVar4 - 0x13;\n    if (iVar6 !\u003d 0 \u0026\u0026 iVar6 \u003c 0 \u003d\u003d SCARRY4(uVar4 - 0x1f,0xc)) {\n      return CONCAT44(uVar3,uVar2 \u003e\u003e (0x20 - (0xcU - iVar6) \u0026 0xff) | uVar5 \u003c\u003c (0xcU - iVar6 \u0026 0xff)\n                     ) \u0026 0x80000000ffffffff;\n    }\n    uVar4 \u003d uVar4 + 1;\n    return CONCAT44(uVar1 | uVar5 \u003e\u003e (uVar4 \u0026 0xff),\n                    uVar2 \u003e\u003e (uVar4 \u0026 0xff) | uVar5 \u003c\u003c (0x20 - uVar4 \u0026 0xff));\n  }\n  return CONCAT44(uVar3,uVar5 \u003e\u003e (uVar4 - 0x1f \u0026 0xff)) \u0026 0x80000000ffffffff;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800048c": {
      "entrypoint": "0x0800048c",
      "current_name": "FUN_0800048c",
      "code": "\nulonglong FUN_0800048c(uint param_1,uint param_2)\n\n{\n  byte bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  uint uVar8;\n  bool bVar9;\n  bool bVar10;\n  bool bVar11;\n  \n  if ((param_1 | param_2) \u003d\u003d 0) {\n    return CONCAT44(param_2,param_1);\n  }\n  iVar7 \u003d 0x432;\n  uVar8 \u003d param_2 \u003e\u003e 0x16;\n  if (uVar8 !\u003d 0) {\n    iVar7 \u003d 3;\n    if (param_2 \u003e\u003e 0x19 !\u003d 0) {\n      iVar7 \u003d 6;\n    }\n    if (param_2 \u003e\u003e 0x1c !\u003d 0) {\n      iVar7 \u003d iVar7 + 3;\n    }\n    uVar4 \u003d iVar7 - ((int)param_2 \u003e\u003e 0x1f);\n    uVar8 \u003d param_1 \u003c\u003c (0x20 - uVar4 \u0026 0xff);\n    param_1 \u003d param_1 \u003e\u003e (uVar4 \u0026 0xff) | param_2 \u003c\u003c (0x20 - uVar4 \u0026 0xff);\n    param_2 \u003d param_2 \u003e\u003e (uVar4 \u0026 0xff);\n    iVar7 \u003d uVar4 + 0x432;\n  }\n  if (0xfffff \u003c param_2) {\n    if (0x1fffff \u003c param_2) {\n      uVar4 \u003d param_2 \u0026 1;\n      param_2 \u003d param_2 \u003e\u003e 1;\n      bVar1 \u003d (byte)param_1;\n      param_1 \u003d (uint)(uVar4 !\u003d 0) \u003c\u003c 0x1f | param_1 \u003e\u003e 1;\n      uVar8 \u003d (uint)(bVar1 \u0026 1) \u003c\u003c 0x1f | uVar8 \u003e\u003e 1;\n      iVar7 \u003d iVar7 + 1;\n      if (0xffbfffff \u003c (uint)(iVar7 * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_080002a0:\n    bVar10 \u003d 0x7fffffff \u003c uVar8;\n    if (uVar8 \u003d\u003d 0x80000000) {\n      bVar10 \u003d (param_1 \u0026 1) !\u003d 0;\n    }\n    return CONCAT44(param_2 + iVar7 * 0x100000 + (uint)CARRY4(param_1,(uint)bVar10),param_1 + bVar10\n                   );\n  }\n  bVar9 \u003d (uVar8 \u0026 0x80000000) !\u003d 0;\n  uVar8 \u003d uVar8 \u003c\u003c 1;\n  uVar4 \u003d param_1 * 2;\n  bVar10 \u003d CARRY4(param_1,param_1);\n  param_1 \u003d param_1 * 2 + (uint)bVar9;\n  param_2 \u003d param_2 * 2 + (uint)(bVar10 || CARRY4(uVar4,(uint)bVar9));\n  iVar7 \u003d iVar7 + -1;\n  if ((param_2 \u0026 0x100000) !\u003d 0) goto LAB_080002a0;\n  uVar2 \u003d param_1;\n  uVar4 \u003d param_2;\n  if (param_2 \u003d\u003d 0) {\n    uVar2 \u003d 0;\n    uVar4 \u003d param_1;\n  }\n  iVar5 \u003d LZCOUNT(uVar4);\n  if (param_2 \u003d\u003d 0) {\n    iVar5 \u003d iVar5 + 0x20;\n  }\n  uVar6 \u003d iVar5 - 0xb;\n  bVar11 \u003d SBORROW4(uVar6,0x20);\n  uVar3 \u003d iVar5 - 0x2b;\n  bVar10 \u003d (int)uVar3 \u003c 0;\n  bVar9 \u003d uVar3 \u003d\u003d 0;\n  if ((int)uVar6 \u003c 0x20) {\n    bVar11 \u003d SCARRY4(uVar3,0xc);\n    iVar5 \u003d iVar5 + -0x1f;\n    bVar10 \u003d iVar5 \u003c 0;\n    bVar9 \u003d iVar5 \u003d\u003d 0;\n    uVar3 \u003d uVar6;\n    if (!bVar9 \u0026\u0026 bVar10 \u003d\u003d bVar11) {\n      uVar2 \u003d uVar4 \u003c\u003c (uVar6 \u0026 0xff);\n      uVar4 \u003d uVar4 \u003e\u003e (0xcU - iVar5 \u0026 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (bVar9 || bVar10 !\u003d bVar11) {\n    uVar8 \u003d 0x20 - uVar3;\n  }\n  uVar4 \u003d uVar4 \u003c\u003c (uVar3 \u0026 0xff);\n  if (bVar9 || bVar10 !\u003d bVar11) {\n    uVar4 \u003d uVar4 | uVar2 \u003e\u003e (uVar8 \u0026 0xff);\n  }\n  if (bVar9 || bVar10 !\u003d bVar11) {\n    uVar2 \u003d uVar2 \u003c\u003c (uVar3 \u0026 0xff);\n  }\nLAB_08000318:\n  if ((int)uVar6 \u003c\u003d iVar7) {\n    return CONCAT44(uVar4 + (iVar7 - uVar6) * 0x100000,uVar2);\n  }\n  uVar8 \u003d ~(iVar7 - uVar6);\n  if (0x1e \u003c (int)uVar8) {\n    return (ulonglong)(uVar4 \u003e\u003e (uVar8 - 0x1f \u0026 0xff));\n  }\n  iVar7 \u003d uVar8 - 0x13;\n  if (iVar7 \u003d\u003d 0 || iVar7 \u003c 0 !\u003d SCARRY4(uVar8 - 0x1f,0xc)) {\n    uVar8 \u003d uVar8 + 1;\n    return CONCAT44(uVar4 \u003e\u003e (uVar8 \u0026 0xff),uVar2 \u003e\u003e (uVar8 \u0026 0xff) | uVar4 \u003c\u003c (0x20 - uVar8 \u0026 0xff)\n                   );\n  }\n  return (ulonglong)(uVar2 \u003e\u003e (0x20 - (0xcU - iVar7) \u0026 0xff) | uVar4 \u003c\u003c (0xcU - iVar7 \u0026 0xff));\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800049c": {
      "entrypoint": "0x0800049c",
      "current_name": "FUN_0800049c",
      "code": "\nulonglong FUN_0800049c(uint param_1,uint param_2)\n\n{\n  byte bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  uint uVar8;\n  uint uVar9;\n  bool bVar10;\n  bool bVar11;\n  bool bVar12;\n  \n  if ((param_1 | param_2) \u003d\u003d 0) {\n    return CONCAT44(param_2,param_1);\n  }\n  uVar8 \u003d param_2 \u0026 0x80000000;\n  uVar3 \u003d param_2;\n  if ((int)uVar8 \u003c 0) {\n    bVar11 \u003d param_1 !\u003d 0;\n    param_1 \u003d -param_1;\n    uVar3 \u003d -param_2 - (uint)bVar11;\n  }\n  iVar7 \u003d 0x432;\n  uVar9 \u003d uVar3 \u003e\u003e 0x16;\n  if (uVar9 !\u003d 0) {\n    iVar7 \u003d 3;\n    if (uVar3 \u003e\u003e 0x19 !\u003d 0) {\n      iVar7 \u003d 6;\n    }\n    if (uVar3 \u003e\u003e 0x1c !\u003d 0) {\n      iVar7 \u003d iVar7 + 3;\n    }\n    uVar4 \u003d iVar7 - ((int)uVar3 \u003e\u003e 0x1f);\n    uVar9 \u003d param_1 \u003c\u003c (0x20 - uVar4 \u0026 0xff);\n    param_1 \u003d param_1 \u003e\u003e (uVar4 \u0026 0xff) | uVar3 \u003c\u003c (0x20 - uVar4 \u0026 0xff);\n    uVar3 \u003d uVar3 \u003e\u003e (uVar4 \u0026 0xff);\n    iVar7 \u003d uVar4 + 0x432;\n  }\n  if (0xfffff \u003c uVar3) {\n    if (0x1fffff \u003c uVar3) {\n      uVar4 \u003d uVar3 \u0026 1;\n      uVar3 \u003d uVar3 \u003e\u003e 1;\n      bVar1 \u003d (byte)param_1;\n      param_1 \u003d (uint)(uVar4 !\u003d 0) \u003c\u003c 0x1f | param_1 \u003e\u003e 1;\n      uVar9 \u003d (uint)(bVar1 \u0026 1) \u003c\u003c 0x1f | uVar9 \u003e\u003e 1;\n      iVar7 \u003d iVar7 + 1;\n      if (0xffbfffff \u003c (uint)(iVar7 * 0x200000)) {\n        return (ulonglong)(uVar8 | 0x7ff00000) \u003c\u003c 0x20;\n      }\n    }\nLAB_080002a0:\n    bVar11 \u003d 0x7fffffff \u003c uVar9;\n    if (uVar9 \u003d\u003d 0x80000000) {\n      bVar11 \u003d (param_1 \u0026 1) !\u003d 0;\n    }\n    return CONCAT44(uVar3 + iVar7 * 0x100000 + (uint)CARRY4(param_1,(uint)bVar11) | uVar8,\n                    param_1 + bVar11);\n  }\n  bVar10 \u003d (uVar9 \u0026 0x80000000) !\u003d 0;\n  uVar9 \u003d uVar9 \u003c\u003c 1;\n  uVar4 \u003d param_1 * 2;\n  bVar11 \u003d CARRY4(param_1,param_1);\n  param_1 \u003d param_1 * 2 + (uint)bVar10;\n  uVar3 \u003d uVar3 * 2 + (uint)(bVar11 || CARRY4(uVar4,(uint)bVar10));\n  iVar7 \u003d iVar7 + -1;\n  if ((uVar3 \u0026 0x100000) !\u003d 0) goto LAB_080002a0;\n  uVar2 \u003d param_1;\n  uVar4 \u003d uVar3;\n  if (uVar3 \u003d\u003d 0) {\n    uVar2 \u003d 0;\n    uVar4 \u003d param_1;\n  }\n  iVar5 \u003d LZCOUNT(uVar4);\n  if (uVar3 \u003d\u003d 0) {\n    iVar5 \u003d iVar5 + 0x20;\n  }\n  uVar6 \u003d iVar5 - 0xb;\n  bVar12 \u003d SBORROW4(uVar6,0x20);\n  uVar3 \u003d iVar5 - 0x2b;\n  bVar11 \u003d (int)uVar3 \u003c 0;\n  bVar10 \u003d uVar3 \u003d\u003d 0;\n  if ((int)uVar6 \u003c 0x20) {\n    bVar12 \u003d SCARRY4(uVar3,0xc);\n    iVar5 \u003d iVar5 + -0x1f;\n    bVar11 \u003d iVar5 \u003c 0;\n    bVar10 \u003d iVar5 \u003d\u003d 0;\n    uVar3 \u003d uVar6;\n    if (!bVar10 \u0026\u0026 bVar11 \u003d\u003d bVar12) {\n      uVar2 \u003d uVar4 \u003c\u003c (uVar6 \u0026 0xff);\n      uVar4 \u003d uVar4 \u003e\u003e (0xcU - iVar5 \u0026 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (bVar10 || bVar11 !\u003d bVar12) {\n    uVar9 \u003d 0x20 - uVar3;\n  }\n  uVar4 \u003d uVar4 \u003c\u003c (uVar3 \u0026 0xff);\n  if (bVar10 || bVar11 !\u003d bVar12) {\n    uVar4 \u003d uVar4 | uVar2 \u003e\u003e (uVar9 \u0026 0xff);\n  }\n  if (bVar10 || bVar11 !\u003d bVar12) {\n    uVar2 \u003d uVar2 \u003c\u003c (uVar3 \u0026 0xff);\n  }\nLAB_08000318:\n  if ((int)uVar6 \u003c\u003d iVar7) {\n    return CONCAT44(uVar4 + (iVar7 - uVar6) * 0x100000 | uVar8,uVar2);\n  }\n  uVar3 \u003d ~(iVar7 - uVar6);\n  if (0x1e \u003c (int)uVar3) {\n    return CONCAT44(param_2,uVar4 \u003e\u003e (uVar3 - 0x1f \u0026 0xff)) \u0026 0x80000000ffffffff;\n  }\n  iVar7 \u003d uVar3 - 0x13;\n  if (iVar7 \u003d\u003d 0 || iVar7 \u003c 0 !\u003d SCARRY4(uVar3 - 0x1f,0xc)) {\n    uVar3 \u003d uVar3 + 1;\n    return CONCAT44(uVar8 | uVar4 \u003e\u003e (uVar3 \u0026 0xff),\n                    uVar2 \u003e\u003e (uVar3 \u0026 0xff) | uVar4 \u003c\u003c (0x20 - uVar3 \u0026 0xff));\n  }\n  return CONCAT44(param_2,uVar2 \u003e\u003e (0x20 - (0xcU - iVar7) \u0026 0xff) | uVar4 \u003c\u003c (0xcU - iVar7 \u0026 0xff))\n         \u0026 0x80000000ffffffff;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080004f8": {
      "entrypoint": "0x080004f8",
      "current_name": "FUN_080004f8",
      "code": "\nulonglong FUN_080004f8(undefined4 param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  ulonglong uVar1;\n  longlong lVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint unaff_r5;\n  uint uVar7;\n  uint uVar8;\n  bool bVar9;\n  bool bVar10;\n  bool bVar11;\n  ulonglong uVar12;\n  \n  uVar12 \u003d CONCAT44(param_2,param_1);\n  uVar7 \u003d 0x7ff;\n  uVar4 \u003d param_2 \u003e\u003e 0x14 \u0026 0x7ff;\n  bVar9 \u003d uVar4 \u003d\u003d 0;\n  if (!bVar9) {\n    unaff_r5 \u003d param_4 \u003e\u003e 0x14 \u0026 0x7ff;\n    bVar9 \u003d unaff_r5 \u003d\u003d 0;\n  }\n  if (!bVar9) {\n    bVar9 \u003d uVar4 \u003d\u003d 0x7ff;\n  }\n  if (!bVar9) {\n    bVar9 \u003d unaff_r5 \u003d\u003d 0x7ff;\n  }\n  if (bVar9) {\n    uVar12 \u003d FUN_080006d4();\n  }\n  uVar3 \u003d (uint)(uVar12 \u003e\u003e 0x20);\n  iVar5 \u003d uVar4 + unaff_r5;\n  uVar4 \u003d uVar3 ^ param_4;\n  uVar3 \u003d uVar3 \u0026 ~(uVar7 \u003c\u003c 0x15);\n  param_4 \u003d param_4 \u0026 ~(uVar7 \u003c\u003c 0x15);\n  bVar9 \u003d ((uint)uVar12 | uVar3 \u003c\u003c 0xc) \u003d\u003d 0;\n  if (!bVar9) {\n    bVar9 \u003d (param_3 | param_4 \u003c\u003c 0xc) \u003d\u003d 0;\n  }\n  uVar3 \u003d uVar3 | 0x100000;\n  param_4 \u003d param_4 | 0x100000;\n  if (bVar9) {\n    param_3 \u003d (uint)uVar12 | param_3;\n    param_4 \u003d (uVar4 \u0026 0x80000000 | uVar3) ^ param_4;\n    uVar4 \u003d uVar7 \u003e\u003e 1;\n    bVar11 \u003d SBORROW4(iVar5,uVar4);\n    uVar6 \u003d iVar5 - uVar4;\n    bVar9 \u003d uVar6 \u003d\u003d 0;\n    uVar3 \u003d uVar6;\n    if (!bVar9 \u0026\u0026 (int)uVar4 \u003c\u003d iVar5) {\n      bVar11 \u003d SBORROW4(uVar7,uVar6);\n      uVar3 \u003d uVar7 - uVar6;\n      bVar9 \u003d uVar7 \u003d\u003d uVar6;\n    }\n    if (!bVar9 \u0026\u0026 (int)uVar3 \u003c 0 \u003d\u003d bVar11) {\n      param_4 \u003d param_4 | uVar6 * 0x100000;\n    }\n    if (!bVar9 \u0026\u0026 (int)uVar3 \u003c 0 \u003d\u003d bVar11) {\n      return CONCAT44(param_4,param_3);\n    }\n    param_4 \u003d param_4 | 0x100000;\n    uVar7 \u003d 0;\n    bVar11 \u003d SBORROW4(uVar6,1);\n    uVar6 \u003d uVar6 - 1;\n    bVar9 \u003d uVar6 \u003d\u003d 0;\n    uVar4 \u003d uVar6;\n  }\n  else {\n    uVar1 \u003d (uVar12 \u0026 0xffffffff) * (ulonglong)param_3;\n    uVar12 \u003d (uVar12 \u0026 0xffffffff) * (ulonglong)param_4 +\n             (ulonglong)uVar3 * (ulonglong)param_3 + (uVar1 \u003e\u003e 0x20);\n    uVar8 \u003d (uint)uVar12;\n    lVar2 \u003d (ulonglong)uVar3 * (ulonglong)param_4 + (uVar12 \u003e\u003e 0x20);\n    uVar7 \u003d (uint)lVar2;\n    uVar3 \u003d (uint)((ulonglong)lVar2 \u003e\u003e 0x20);\n    if ((int)uVar1 !\u003d 0) {\n      uVar8 \u003d uVar8 | 1;\n    }\n    uVar6 \u003d (iVar5 + -0x3ff) - (uint)(uVar3 \u003c 0x200);\n    if (uVar3 \u003c 0x200) {\n      bVar9 \u003d (uVar8 \u0026 0x80000000) !\u003d 0;\n      uVar8 \u003d uVar8 \u003c\u003c 1;\n      lVar2 \u003d CONCAT44(uVar3 * 2 + (uint)(CARRY4(uVar7,uVar7) || CARRY4(uVar7 * 2,(uint)bVar9)),\n                       uVar7 * 2 + (uint)bVar9);\n    }\n    param_4 \u003d uVar4 \u0026 0x80000000 | (int)((ulonglong)lVar2 \u003e\u003e 0x20) \u003c\u003c 0xb | (uint)lVar2 \u003e\u003e 0x15;\n    param_3 \u003d (uint)lVar2 \u003c\u003c 0xb | uVar8 \u003e\u003e 0x15;\n    uVar7 \u003d uVar8 * 0x800;\n    bVar10 \u003d 0xfc \u003c uVar6;\n    bVar11 \u003d SBORROW4(uVar6,0xfd);\n    uVar3 \u003d uVar6 - 0xfd;\n    bVar9 \u003d uVar3 \u003d\u003d 0;\n    uVar4 \u003d uVar3;\n    if (bVar10 \u0026\u0026 !bVar9) {\n      bVar10 \u003d 0x6ff \u003c uVar3;\n      bVar11 \u003d SBORROW4(uVar3,0x700);\n      uVar4 \u003d uVar6 - 0x7fd;\n      bVar9 \u003d uVar3 \u003d\u003d 0x700;\n    }\n    if (!bVar10 || bVar9) {\n      bVar9 \u003d 0x7fffffff \u003c uVar7;\n      if (uVar7 \u003d\u003d 0x80000000) {\n        bVar9 \u003d (uVar8 \u003e\u003e 0x15 \u0026 1) !\u003d 0;\n      }\n      return CONCAT44(param_4 + uVar6 * 0x100000 + (uint)CARRY4(param_3,(uint)bVar9),param_3 + bVar9\n                     );\n    }\n  }\n  if (!bVar9 \u0026\u0026 (int)uVar4 \u003c 0 \u003d\u003d bVar11) {\n    return (ulonglong)(param_4 \u0026 0x80000000 | 0x7ff00000) \u003c\u003c 0x20;\n  }\n  bVar10 \u003d SCARRY4(uVar6,0x36);\n  bVar9 \u003d (int)(uVar6 + 0x36) \u003c 0;\n  bVar11 \u003d uVar6 \u003d\u003d 0xffffffca;\n  if (bVar11 || bVar9 !\u003d bVar10) {\n    param_3 \u003d 0;\n  }\n  if (bVar11 || bVar9 !\u003d bVar10) {\n    param_4 \u003d param_4 \u0026 0x80000000;\n  }\n  if (bVar11 || bVar9 !\u003d bVar10) {\n    return CONCAT44(param_4,param_3);\n  }\n  uVar4 \u003d -uVar6;\n  uVar3 \u003d uVar4 - 0x20;\n  if (0x1f \u003c (int)uVar4) {\n    uVar6 \u003d param_3 \u003e\u003e (uVar3 \u0026 0xff) | param_4 \u003c\u003c (0x20 - uVar3 \u0026 0xff);\n    uVar4 \u003d (param_4 \u003e\u003e (uVar3 \u0026 0xff) \u0026 ~((param_4 \u0026 0x80000000) \u003e\u003e (uVar3 \u0026 0xff))) -\n            ((int)uVar6 \u003e\u003e 0x1f);\n    if ((uVar7 | param_3 \u003c\u003c (0x20 - uVar3 \u0026 0xff) | uVar6 \u003c\u003c 1) \u003d\u003d 0) {\n      uVar4 \u003d uVar4 \u0026 ~(uVar6 \u003e\u003e 0x1f);\n    }\n    return CONCAT44(param_4,uVar4) \u0026 0x80000000ffffffff;\n  }\n  iVar5 \u003d uVar4 - 0x14;\n  if (iVar5 \u003d\u003d 0 || iVar5 \u003c 0 !\u003d SCARRY4(uVar3,0xc)) {\n    uVar8 \u003d param_3 \u003c\u003c (uVar6 + 0x20 \u0026 0xff);\n    uVar3 \u003d param_3 \u003e\u003e (uVar4 \u0026 0xff) | param_4 \u003c\u003c (uVar6 + 0x20 \u0026 0xff);\n    uVar6 \u003d uVar3 + -((int)uVar8 \u003e\u003e 0x1f);\n    if ((uVar7 | uVar8 \u003c\u003c 1) \u003d\u003d 0) {\n      uVar6 \u003d uVar6 \u0026 ~(uVar8 \u003e\u003e 0x1f);\n    }\n    return CONCAT44((param_4 \u0026 0x80000000) +\n                    ((param_4 \u0026 0x7fffffff) \u003e\u003e (uVar4 \u0026 0xff)) +\n                    (uint)CARRY4(uVar3,-((int)uVar8 \u003e\u003e 0x1f)),uVar6);\n  }\n  uVar4 \u003d 0xc - iVar5;\n  uVar6 \u003d param_3 \u003c\u003c (uVar4 \u0026 0xff);\n  uVar4 \u003d param_3 \u003e\u003e (0x20 - uVar4 \u0026 0xff) | param_4 \u003c\u003c (uVar4 \u0026 0xff);\n  uVar3 \u003d uVar4 + -((int)uVar6 \u003e\u003e 0x1f);\n  if ((uVar7 | uVar6 \u003c\u003c 1) \u003d\u003d 0) {\n    uVar3 \u003d uVar3 \u0026 ~(uVar6 \u003e\u003e 0x1f);\n  }\n  return CONCAT44((param_4 \u0026 0x80000000) + (uint)CARRY4(uVar4,-((int)uVar6 \u003e\u003e 0x1f)),uVar3);\n}\n\n",
      "renaming": {},
      "calling": [
        "SetTunings",
        "Compute",
        "readThermocouple",
        "printFloat",
        "SetSampleTime"
      ],
      "called": [
        "FUN_080006d4"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080006d4": {
      "entrypoint": "0x080006d4",
      "current_name": "FUN_080006d4",
      "code": "\nulonglong FUN_080006d4(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  uint in_r12;\n  bool bVar4;\n  \n  uVar2 \u003d in_r12 \u0026 param_4 \u003e\u003e 0x14;\n  if (unaff_r4 !\u003d in_r12 \u0026\u0026 uVar2 !\u003d in_r12) {\n    bVar4 \u003d (param_1 | param_2 \u003c\u003c 1) \u003d\u003d 0;\n    if (!bVar4) {\n      bVar4 \u003d (param_3 | param_4 \u003c\u003c 1) \u003d\u003d 0;\n    }\n    if (bVar4) {\n      return (ulonglong)((param_2 ^ param_4) \u0026 0x80000000) \u003c\u003c 0x20;\n    }\n    if (unaff_r4 \u003d\u003d 0) {\n      uVar3 \u003d param_2 \u0026 0x80000000;\n      do {\n        uVar1 \u003d param_1 \u0026 0x80000000;\n        param_1 \u003d param_1 \u003c\u003c 1;\n        param_2 \u003d param_2 * 2 + (uint)(uVar1 !\u003d 0);\n      } while ((param_2 \u0026 0x100000) \u003d\u003d 0);\n      param_2 \u003d param_2 | uVar3;\n      if (uVar2 !\u003d 0) {\n        return CONCAT44(param_2,param_1);\n      }\n    }\n    do {\n      uVar2 \u003d param_3 \u0026 0x80000000;\n      param_3 \u003d param_3 \u003c\u003c 1;\n      param_4 \u003d param_4 * 2 + (uint)(uVar2 !\u003d 0);\n    } while ((param_4 \u0026 0x100000) \u003d\u003d 0);\n    return CONCAT44(param_2,param_1);\n  }\n  bVar4 \u003d (param_1 | param_2 \u003c\u003c 1) \u003d\u003d 0;\n  if (bVar4) {\n    param_2 \u003d param_4;\n    param_1 \u003d param_3;\n  }\n  if (!bVar4) {\n    bVar4 \u003d (param_3 | param_4 \u003c\u003c 1) \u003d\u003d 0;\n  }\n  uVar3 \u003d param_2;\n  if (((!bVar4) \u0026\u0026 ((unaff_r4 !\u003d in_r12 || ((param_1 | param_2 \u003c\u003c 0xc) \u003d\u003d 0)))) \u0026\u0026\n     ((uVar2 !\u003d in_r12 || (param_1 \u003d param_3, uVar3 \u003d param_4, (param_3 | param_4 \u003c\u003c 0xc) \u003d\u003d 0)))) {\n    return (ulonglong)((param_2 ^ param_4) \u0026 0x80000000 | 0x7ff00000) \u003c\u003c 0x20;\n  }\n  return CONCAT44(uVar3,param_1) | 0x7ff8000000000000;\n}\n\n",
      "renaming": {},
      "calling": [
        "__muldf3"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800074c": {
      "entrypoint": "0x0800074c",
      "current_name": "FUN_0800074c",
      "code": "\nulonglong FUN_0800074c(undefined4 param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  uint uVar9;\n  uint unaff_r5;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  bool bVar14;\n  bool bVar15;\n  bool bVar16;\n  undefined8 uVar17;\n  \n  uVar17 \u003d CONCAT44(param_2,param_1);\n  uVar13 \u003d 0x7ff;\n  uVar7 \u003d param_2 \u003e\u003e 0x14 \u0026 0x7ff;\n  bVar14 \u003d uVar7 \u003d\u003d 0;\n  if (!bVar14) {\n    unaff_r5 \u003d param_4 \u003e\u003e 0x14 \u0026 0x7ff;\n    bVar14 \u003d unaff_r5 \u003d\u003d 0;\n  }\n  if (!bVar14) {\n    bVar14 \u003d uVar7 \u003d\u003d 0x7ff;\n  }\n  if (!bVar14) {\n    bVar14 \u003d unaff_r5 \u003d\u003d 0x7ff;\n  }\n  if (bVar14) {\n    uVar17 \u003d FUN_080008ba();\n  }\n  uVar9 \u003d (uint)((ulonglong)uVar17 \u003e\u003e 0x20);\n  uVar11 \u003d (uint)uVar17;\n  iVar8 \u003d uVar7 - unaff_r5;\n  if ((param_3 | param_4 \u003c\u003c 0xc) \u003d\u003d 0) {\n    uVar7 \u003d (uVar9 ^ param_4) \u0026 0x80000000 | uVar9 \u0026 0xfffff;\n    bVar16 \u003d SCARRY4(iVar8,uVar13 \u003e\u003e 1);\n    uVar9 \u003d iVar8 + (uVar13 \u003e\u003e 1);\n    bVar14 \u003d (int)uVar9 \u003c 0;\n    bVar15 \u003d uVar9 \u003d\u003d 0;\n    if (!bVar15 \u0026\u0026 bVar14 \u003d\u003d bVar16) {\n      bVar16 \u003d SBORROW4(uVar13,uVar9);\n      bVar14 \u003d (int)(uVar13 - uVar9) \u003c 0;\n      bVar15 \u003d uVar13 \u003d\u003d uVar9;\n    }\n    if (!bVar15 \u0026\u0026 bVar14 \u003d\u003d bVar16) {\n      uVar7 \u003d uVar7 | uVar9 * 0x100000;\n    }\n    if (!bVar15 \u0026\u0026 bVar14 \u003d\u003d bVar16) {\n      return CONCAT44(uVar7,uVar11);\n    }\n    uVar7 \u003d uVar7 | 0x100000;\n    uVar13 \u003d 0;\n    bVar15 \u003d SBORROW4(uVar9,1);\n    uVar9 \u003d uVar9 - 1;\n    bVar14 \u003d uVar9 \u003d\u003d 0;\n    uVar3 \u003d uVar9;\n  }\n  else {\n    uVar3 \u003d (param_4 \u003c\u003c 0xc) \u003e\u003e 4 | 0x10000000 | param_3 \u003e\u003e 0x18;\n    uVar13 \u003d param_3 \u003c\u003c 8;\n    uVar10 \u003d (uVar9 \u003c\u003c 0xc) \u003e\u003e 4 | 0x10000000 | uVar11 \u003e\u003e 0x18;\n    uVar11 \u003d uVar11 * 0x100;\n    uVar7 \u003d (uVar9 ^ param_4) \u0026 0x80000000;\n    bVar14 \u003d uVar3 \u003c\u003d uVar10;\n    if (uVar10 \u003d\u003d uVar3) {\n      bVar14 \u003d uVar13 \u003c\u003d uVar11;\n    }\n    iVar8 \u003d iVar8 + (uint)bVar14;\n    uVar9 \u003d iVar8 + 0x3fd;\n    if (bVar14 \u003d\u003d false) {\n      uVar3 \u003d uVar3 \u003e\u003e 1;\n      uVar13 \u003d (uint)((param_3 \u003e\u003e 0x18 \u0026 1) !\u003d 0) \u003c\u003c 0x1f | uVar13 \u003e\u003e 1;\n    }\n    uVar12 \u003d uVar11 - uVar13;\n    uVar10 \u003d (uVar10 - uVar3) - (uint)(uVar11 \u003c uVar13);\n    uVar4 \u003d uVar3 \u003e\u003e 1;\n    uVar1 \u003d (uint)((uVar3 \u0026 1) !\u003d 0) \u003c\u003c 0x1f | uVar13 \u003e\u003e 1;\n    uVar11 \u003d 0x100000;\n    uVar3 \u003d 0x80000;\n    while( true ) {\n      bVar14 \u003d uVar1 \u003c\u003d uVar12;\n      if (uVar4 \u003c uVar10 || uVar10 - uVar4 \u003c (uint)bVar14) {\n        uVar12 \u003d uVar12 - uVar1;\n        uVar11 \u003d uVar11 | uVar3;\n        uVar10 \u003d (uVar10 - uVar4) - (uint)!bVar14;\n      }\n      uVar5 \u003d uVar4 \u003e\u003e 1;\n      uVar1 \u003d (uint)((uVar4 \u0026 1) !\u003d 0) \u003c\u003c 0x1f | uVar1 \u003e\u003e 1;\n      bVar15 \u003d uVar1 \u003c\u003d uVar12;\n      bVar14 \u003d uVar10 - uVar5 \u003c (uint)bVar15;\n      uVar13 \u003d uVar10;\n      if (uVar5 \u003c uVar10 || bVar14) {\n        uVar12 \u003d uVar12 - uVar1;\n        uVar13 \u003d (uVar10 - uVar5) - (uint)!bVar15;\n      }\n      if (uVar5 \u003c uVar10 || bVar14) {\n        uVar11 \u003d uVar11 | uVar3 \u003e\u003e 1;\n      }\n      uVar10 \u003d uVar4 \u003e\u003e 2;\n      uVar2 \u003d (uint)((uVar5 \u0026 1) !\u003d 0) \u003c\u003c 0x1f | uVar1 \u003e\u003e 1;\n      bVar15 \u003d uVar2 \u003c\u003d uVar12;\n      bVar14 \u003d uVar13 - uVar10 \u003c (uint)bVar15;\n      uVar5 \u003d uVar13;\n      if (uVar10 \u003c uVar13 || bVar14) {\n        uVar12 \u003d uVar12 - uVar2;\n        uVar5 \u003d (uVar13 - uVar10) - (uint)!bVar15;\n      }\n      if (uVar10 \u003c uVar13 || bVar14) {\n        uVar11 \u003d uVar11 | uVar3 \u003e\u003e 2;\n      }\n      uVar6 \u003d uVar4 \u003e\u003e 3;\n      uVar1 \u003d (uint)((uVar10 \u0026 1) !\u003d 0) \u003c\u003c 0x1f | uVar2 \u003e\u003e 1;\n      bVar15 \u003d uVar1 \u003c\u003d uVar12;\n      bVar14 \u003d uVar5 - uVar6 \u003c (uint)bVar15;\n      uVar10 \u003d uVar5;\n      if (uVar6 \u003c uVar5 || bVar14) {\n        uVar12 \u003d uVar12 - uVar1;\n        uVar10 \u003d (uVar5 - uVar6) - (uint)!bVar15;\n      }\n      if (uVar6 \u003c uVar5 || bVar14) {\n        uVar11 \u003d uVar11 | uVar3 \u003e\u003e 3;\n      }\n      uVar13 \u003d uVar10 | uVar12;\n      if (uVar13 \u003d\u003d 0) break;\n      uVar10 \u003d uVar10 \u003c\u003c 4 | uVar12 \u003e\u003e 0x1c;\n      uVar12 \u003d uVar12 \u003c\u003c 4;\n      uVar4 \u003d uVar4 \u0026 0xfffffff8 | uVar1 \u003e\u003e 0x1d;\n      uVar1 \u003d (uVar2 \u003e\u003e 1) \u003c\u003c 3;\n      uVar3 \u003d uVar3 \u003e\u003e 4;\n      if (uVar3 \u003d\u003d 0) {\n        uVar6 \u003d uVar4;\n        if ((uVar7 \u0026 0x100000) !\u003d 0) goto LAB_0800086a;\n        uVar7 \u003d uVar7 | uVar11;\n        uVar11 \u003d 0;\n        uVar3 \u003d 0x80000000;\n      }\n    }\n    if ((uVar7 \u0026 0x100000) \u003d\u003d 0) {\n      uVar7 \u003d uVar7 | uVar11;\n      uVar11 \u003d 0;\n    }\nLAB_0800086a:\n    bVar16 \u003d 0xfc \u003c uVar9;\n    bVar15 \u003d SBORROW4(uVar9,0xfd);\n    uVar4 \u003d iVar8 + 0x300;\n    bVar14 \u003d uVar4 \u003d\u003d 0;\n    uVar3 \u003d uVar4;\n    if (bVar16 \u0026\u0026 !bVar14) {\n      bVar16 \u003d 0x6ff \u003c uVar4;\n      bVar15 \u003d SBORROW4(uVar4,0x700);\n      uVar3 \u003d iVar8 - 0x400;\n      bVar14 \u003d uVar4 \u003d\u003d 0x700;\n    }\n    if (!bVar16 || bVar14) {\n      bVar14 \u003d uVar6 \u003c\u003d uVar10;\n      if (uVar10 \u003d\u003d uVar6) {\n        bVar14 \u003d uVar1 \u003c\u003d uVar12;\n      }\n      if (uVar10 \u003d\u003d uVar6 \u0026\u0026 uVar12 \u003d\u003d uVar1) {\n        bVar14 \u003d (uVar11 \u0026 1) !\u003d 0;\n      }\n      return CONCAT44(uVar7 + uVar9 * 0x100000 + (uint)CARRY4(uVar11,(uint)bVar14),uVar11 + bVar14);\n    }\n  }\n  if (!bVar14 \u0026\u0026 (int)uVar3 \u003c 0 \u003d\u003d bVar15) {\n    return (ulonglong)(uVar7 \u0026 0x80000000 | 0x7ff00000) \u003c\u003c 0x20;\n  }\n  bVar16 \u003d SCARRY4(uVar9,0x36);\n  bVar14 \u003d (int)(uVar9 + 0x36) \u003c 0;\n  bVar15 \u003d uVar9 \u003d\u003d 0xffffffca;\n  if (bVar15 || bVar14 !\u003d bVar16) {\n    uVar11 \u003d 0;\n  }\n  if (bVar15 || bVar14 !\u003d bVar16) {\n    uVar7 \u003d uVar7 \u0026 0x80000000;\n  }\n  if (bVar15 || bVar14 !\u003d bVar16) {\n    return CONCAT44(uVar7,uVar11);\n  }\n  uVar3 \u003d -uVar9;\n  uVar10 \u003d uVar3 - 0x20;\n  if (0x1f \u003c (int)uVar3) {\n    uVar3 \u003d uVar11 \u003e\u003e (uVar10 \u0026 0xff) | uVar7 \u003c\u003c (0x20 - uVar10 \u0026 0xff);\n    uVar9 \u003d (uVar7 \u003e\u003e (uVar10 \u0026 0xff) \u0026 ~((uVar7 \u0026 0x80000000) \u003e\u003e (uVar10 \u0026 0xff))) -\n            ((int)uVar3 \u003e\u003e 0x1f);\n    if ((uVar13 | uVar11 \u003c\u003c (0x20 - uVar10 \u0026 0xff) | uVar3 \u003c\u003c 1) \u003d\u003d 0) {\n      uVar9 \u003d uVar9 \u0026 ~(uVar3 \u003e\u003e 0x1f);\n    }\n    return CONCAT44(uVar7,uVar9) \u0026 0x80000000ffffffff;\n  }\n  iVar8 \u003d uVar3 - 0x14;\n  if (iVar8 !\u003d 0 \u0026\u0026 iVar8 \u003c 0 \u003d\u003d SCARRY4(uVar10,0xc)) {\n    uVar9 \u003d 0xc - iVar8;\n    uVar3 \u003d uVar11 \u003c\u003c (uVar9 \u0026 0xff);\n    uVar11 \u003d uVar11 \u003e\u003e (0x20 - uVar9 \u0026 0xff) | uVar7 \u003c\u003c (uVar9 \u0026 0xff);\n    uVar9 \u003d uVar11 + -((int)uVar3 \u003e\u003e 0x1f);\n    if ((uVar13 | uVar3 \u003c\u003c 1) \u003d\u003d 0) {\n      uVar9 \u003d uVar9 \u0026 ~(uVar3 \u003e\u003e 0x1f);\n    }\n    return CONCAT44((uVar7 \u0026 0x80000000) + (uint)CARRY4(uVar11,-((int)uVar3 \u003e\u003e 0x1f)),uVar9);\n  }\n  uVar10 \u003d uVar11 \u003c\u003c (uVar9 + 0x20 \u0026 0xff);\n  uVar11 \u003d uVar11 \u003e\u003e (uVar3 \u0026 0xff) | uVar7 \u003c\u003c (uVar9 + 0x20 \u0026 0xff);\n  uVar9 \u003d uVar11 + -((int)uVar10 \u003e\u003e 0x1f);\n  if ((uVar13 | uVar10 \u003c\u003c 1) \u003d\u003d 0) {\n    uVar9 \u003d uVar9 \u0026 ~(uVar10 \u003e\u003e 0x1f);\n  }\n  return CONCAT44((uVar7 \u0026 0x80000000) +\n                  ((uVar7 \u0026 0x7fffffff) \u003e\u003e (uVar3 \u0026 0xff)) +\n                  (uint)CARRY4(uVar11,-((int)uVar10 \u003e\u003e 0x1f)),uVar9);\n}\n\n",
      "renaming": {},
      "calling": [
        "SetTunings",
        "readThermocouple",
        "printFloat",
        "SetSampleTime"
      ],
      "called": [
        "FUN_080008ba"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080008ba": {
      "entrypoint": "0x080008ba",
      "current_name": "FUN_080008ba",
      "code": "\nulonglong FUN_080008ba(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  uint in_r12;\n  bool bVar4;\n  \n  uVar2 \u003d in_r12 \u0026 param_4 \u003e\u003e 0x14;\n  uVar3 \u003d param_2;\n  if (unaff_r4 !\u003d in_r12 || uVar2 !\u003d in_r12) {\n    if (unaff_r4 \u003d\u003d in_r12) {\n      if (((param_1 | param_2 \u003c\u003c 0xc) \u003d\u003d 0) \u0026\u0026 (param_1 \u003d param_3, uVar3 \u003d param_4, uVar2 !\u003d in_r12)\n         ) {\nLAB_0800072c:\n        return (ulonglong)((param_2 ^ param_4) \u0026 0x80000000 | 0x7ff00000) \u003c\u003c 0x20;\n      }\n    }\n    else if (uVar2 \u003d\u003d in_r12) {\n      param_1 \u003d param_3;\n      uVar3 \u003d param_4;\n      if ((param_3 | param_4 \u003c\u003c 0xc) \u003d\u003d 0) {\nLAB_080006f0:\n        return (ulonglong)((param_2 ^ param_4) \u0026 0x80000000) \u003c\u003c 0x20;\n      }\n    }\n    else {\n      bVar4 \u003d (param_1 | param_2 \u003c\u003c 1) \u003d\u003d 0;\n      if (!bVar4) {\n        bVar4 \u003d (param_3 | param_4 \u003c\u003c 1) \u003d\u003d 0;\n      }\n      if (!bVar4) {\n        if (unaff_r4 \u003d\u003d 0) {\n          uVar3 \u003d param_2 \u0026 0x80000000;\n          do {\n            uVar1 \u003d param_1 \u0026 0x80000000;\n            param_1 \u003d param_1 \u003c\u003c 1;\n            param_2 \u003d param_2 * 2 + (uint)(uVar1 !\u003d 0);\n          } while ((param_2 \u0026 0x100000) \u003d\u003d 0);\n          param_2 \u003d param_2 | uVar3;\n          if (uVar2 !\u003d 0) {\n            return CONCAT44(param_2,param_1);\n          }\n        }\n        do {\n          uVar3 \u003d param_3 \u0026 0x80000000;\n          param_3 \u003d param_3 \u003c\u003c 1;\n          param_4 \u003d param_4 * 2 + (uint)(uVar3 !\u003d 0);\n        } while ((param_4 \u0026 0x100000) \u003d\u003d 0);\n        return CONCAT44(param_2,param_1);\n      }\n      if ((param_1 | param_2 \u003c\u003c 1) !\u003d 0) goto LAB_0800072c;\n      if ((param_3 | param_4 \u003c\u003c 1) !\u003d 0) goto LAB_080006f0;\n    }\n  }\n  return CONCAT44(uVar3,param_1) | 0x7ff8000000000000;\n}\n\n",
      "renaming": {},
      "calling": [
        "__divdf3"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800091c": {
      "entrypoint": "0x0800091c",
      "current_name": "FUN_0800091c",
      "code": "\nuint FUN_0800091c(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  bool bVar2;\n  bool bVar3;\n  \n  if (((int)(param_2 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1 || (int)(param_4 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1) \u0026\u0026\n     ((((int)(param_2 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1 \u0026\u0026 ((param_1 | param_2 \u003c\u003c 0xc) !\u003d 0)) ||\n      (((int)(param_4 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1 \u0026\u0026 ((param_3 | param_4 \u003c\u003c 0xc) !\u003d 0)))))) {\n    return 0xffffffff;\n  }\n  bVar2 \u003d (param_1 | param_2 \u003c\u003c 1) \u003d\u003d 0;\n  if (bVar2) {\n    bVar2 \u003d (param_3 | param_4 \u003c\u003c 1) \u003d\u003d 0;\n  }\n  if (!bVar2) {\n    bVar2 \u003d param_2 \u003d\u003d param_4;\n  }\n  if (bVar2) {\n    bVar2 \u003d param_1 \u003d\u003d param_3;\n  }\n  if (!bVar2) {\n    uVar1 \u003d param_2 ^ param_4;\n    bVar2 \u003d uVar1 \u003d\u003d 0;\n    if (-1 \u003c (int)uVar1) {\n      bVar2 \u003d param_2 \u003d\u003d param_4;\n    }\n    bVar3 \u003d -1 \u003c (int)uVar1 \u0026\u0026 param_4 \u003c\u003d param_2;\n    if (bVar2) {\n      bVar3 \u003d param_3 \u003c\u003d param_1;\n    }\n    param_4 \u003d (int)param_4 \u003e\u003e 0x1f;\n    if (!bVar3) {\n      param_4 \u003d ~param_4;\n    }\n    return param_4 | 1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08000924": {
      "entrypoint": "0x08000924",
      "current_name": "FUN_08000924",
      "code": "\nuint FUN_08000924(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  bool bVar2;\n  bool bVar3;\n  \n  if (((int)(param_2 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1 || (int)(param_4 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1) \u0026\u0026\n     ((((int)(param_2 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1 \u0026\u0026 ((param_1 | param_2 \u003c\u003c 0xc) !\u003d 0)) ||\n      (((int)(param_4 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1 \u0026\u0026 ((param_3 | param_4 \u003c\u003c 0xc) !\u003d 0)))))) {\n    return 1;\n  }\n  bVar2 \u003d (param_1 | param_2 \u003c\u003c 1) \u003d\u003d 0;\n  if (bVar2) {\n    bVar2 \u003d (param_3 | param_4 \u003c\u003c 1) \u003d\u003d 0;\n  }\n  if (!bVar2) {\n    bVar2 \u003d param_2 \u003d\u003d param_4;\n  }\n  if (bVar2) {\n    bVar2 \u003d param_1 \u003d\u003d param_3;\n  }\n  if (!bVar2) {\n    uVar1 \u003d param_2 ^ param_4;\n    bVar2 \u003d uVar1 \u003d\u003d 0;\n    if (-1 \u003c (int)uVar1) {\n      bVar2 \u003d param_2 \u003d\u003d param_4;\n    }\n    bVar3 \u003d -1 \u003c (int)uVar1 \u0026\u0026 param_4 \u003c\u003d param_2;\n    if (bVar2) {\n      bVar3 \u003d param_3 \u003c\u003d param_1;\n    }\n    param_4 \u003d (int)param_4 \u003e\u003e 0x1f;\n    if (!bVar3) {\n      param_4 \u003d ~param_4;\n    }\n    return param_4 | 1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800092c": {
      "entrypoint": "0x0800092c",
      "current_name": "FUN_0800092c",
      "code": "\nuint FUN_0800092c(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  bool bVar2;\n  bool bVar3;\n  \n  if (((int)(param_2 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1 || (int)(param_4 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1) \u0026\u0026\n     ((((int)(param_2 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1 \u0026\u0026 ((param_1 | param_2 \u003c\u003c 0xc) !\u003d 0)) ||\n      (((int)(param_4 \u003c\u003c 1) \u003e\u003e 0x15 \u003d\u003d -1 \u0026\u0026 ((param_3 | param_4 \u003c\u003c 0xc) !\u003d 0)))))) {\n    return 1;\n  }\n  bVar2 \u003d (param_1 | param_2 \u003c\u003c 1) \u003d\u003d 0;\n  if (bVar2) {\n    bVar2 \u003d (param_3 | param_4 \u003c\u003c 1) \u003d\u003d 0;\n  }\n  if (!bVar2) {\n    bVar2 \u003d param_2 \u003d\u003d param_4;\n  }\n  if (bVar2) {\n    bVar2 \u003d param_1 \u003d\u003d param_3;\n  }\n  if (!bVar2) {\n    uVar1 \u003d param_2 ^ param_4;\n    bVar2 \u003d uVar1 \u003d\u003d 0;\n    if (-1 \u003c (int)uVar1) {\n      bVar2 \u003d param_2 \u003d\u003d param_4;\n    }\n    bVar3 \u003d -1 \u003c (int)uVar1 \u0026\u0026 param_4 \u003c\u003d param_2;\n    if (bVar2) {\n      bVar3 \u003d param_3 \u003c\u003d param_1;\n    }\n    param_4 \u003d (int)param_4 \u003e\u003e 0x1f;\n    if (!bVar3) {\n      param_4 \u003d ~param_4;\n    }\n    return param_4 | 1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_cdcmpeq"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080009a8": {
      "entrypoint": "0x080009a8",
      "current_name": "FUN_080009a8",
      "code": "\nvoid FUN_080009a8(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  __aeabi_cdcmpeq(param_3,param_4,param_1,param_2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_dcmpgt",
        "__aeabi_dcmpge"
      ],
      "called": [
        "__aeabi_cdcmpeq"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080009b8": {
      "entrypoint": "0x080009b8",
      "current_name": "FUN_080009b8",
      "code": "\nundefined4 FUN_080009b8(undefined4 param_1)\n\n{\n  __eqdf2();\n  return param_1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_dcmpeq",
        "__aeabi_cdrcmple",
        "__aeabi_dcmplt",
        "__aeabi_dcmple"
      ],
      "called": [
        "__eqdf2"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080009c8": {
      "entrypoint": "0x080009c8",
      "current_name": "FUN_080009c8",
      "code": "\nbool FUN_080009c8(void)\n\n{\n  char in_ZR;\n  \n  __aeabi_cdcmpeq();\n  return in_ZR !\u003d \u0027\\0\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "__aeabi_cdcmpeq"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080009dc": {
      "entrypoint": "0x080009dc",
      "current_name": "FUN_080009dc",
      "code": "\nbool FUN_080009dc(void)\n\n{\n  char in_CY;\n  \n  __aeabi_cdcmpeq();\n  return in_CY \u003d\u003d \u0027\\0\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "SetOutputLimits",
        "Initialize",
        "loop",
        "SetTunings",
        "Compute",
        "printFloat"
      ],
      "called": [
        "__aeabi_cdcmpeq"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080009f0": {
      "entrypoint": "0x080009f0",
      "current_name": "FUN_080009f0",
      "code": "\nbool FUN_080009f0(void)\n\n{\n  undefined in_ZR;\n  undefined in_CY;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)in_CY || (bool)in_ZR;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop",
        "printFloat"
      ],
      "called": [
        "__aeabi_cdcmpeq"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08000a04": {
      "entrypoint": "0x08000a04",
      "current_name": "FUN_08000a04",
      "code": "\nbool FUN_08000a04(void)\n\n{\n  undefined in_ZR;\n  undefined in_CY;\n  \n  __aeabi_cdrcmple();\n  return !(bool)in_CY || (bool)in_ZR;\n}\n\n",
      "renaming": {},
      "calling": [
        "SetOutputLimits",
        "loop"
      ],
      "called": [
        "__aeabi_cdrcmple"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08000a18": {
      "entrypoint": "0x08000a18",
      "current_name": "FUN_08000a18",
      "code": "\nbool FUN_08000a18(void)\n\n{\n  char in_CY;\n  \n  __aeabi_cdrcmple();\n  return in_CY \u003d\u003d \u0027\\0\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "SetOutputLimits",
        "Initialize",
        "loop",
        "Compute",
        "printFloat"
      ],
      "called": [
        "__aeabi_cdrcmple"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08000a2c": {
      "entrypoint": "0x08000a2c",
      "current_name": "FUN_08000a2c",
      "code": "\nundefined4 FUN_08000a2c(uint param_1,int param_2,uint param_3,int param_4)\n\n{\n  if ((((param_2 \u003c\u003c 1) \u003e\u003e 0x15 !\u003d -1) || ((param_1 | param_2 \u003c\u003c 0xc) \u003d\u003d 0)) \u0026\u0026\n     (((param_4 \u003c\u003c 1) \u003e\u003e 0x15 !\u003d -1 || ((param_3 | param_4 \u003c\u003c 0xc) \u003d\u003d 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "printFloat"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08000a58": {
      "entrypoint": "0x08000a58",
      "current_name": "FUN_08000a58",
      "code": "\nuint FUN_08000a58(uint param_1,uint param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  uint uVar3;\n  \n  iVar2 \u003d param_2 * 2 + 0x200000;\n  if (param_2 * 2 \u003c 0xffe00000) {\n    if (-1 \u003c iVar2) {\n      return 0;\n    }\n    uVar1 \u003d iVar2 \u003e\u003e 0x15;\n    uVar3 \u003d -uVar1 - 0x3e1;\n    if (uVar1 \u003c 0xfffffc20 \u0026\u0026 uVar3 !\u003d 0) {\n      uVar1 \u003d (param_2 \u003c\u003c 0xb | 0x80000000 | param_1 \u003e\u003e 0x15) \u003e\u003e (uVar3 \u0026 0xff);\n      if ((param_2 \u0026 0x80000000) !\u003d 0) {\n        uVar1 \u003d -uVar1;\n      }\n      return uVar1;\n    }\n  }\n  else if ((param_1 | param_2 \u003c\u003c 0xc) !\u003d 0) {\n    return 0;\n  }\n  param_2 \u003d param_2 \u0026 0x80000000;\n  if (param_2 \u003d\u003d 0) {\n    param_2 \u003d 0x7fffffff;\n  }\n  return param_2;\n}\n\n",
      "renaming": {},
      "calling": [
        "printFloat"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08000aa8": {
      "entrypoint": "0x08000aa8",
      "current_name": "FUN_08000aa8",
      "code": "\nuint FUN_08000aa8(uint param_1,uint param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  \n  if ((param_2 \u0026 0x80000000) !\u003d 0) {\n    return 0;\n  }\n  iVar1 \u003d param_2 * 2 + 0x200000;\n  if (param_2 * 2 \u003c 0xffe00000) {\n    if (-1 \u003c iVar1) {\n      return 0;\n    }\n    uVar2 \u003d -(iVar1 \u003e\u003e 0x15) - 0x3e1;\n    if (-1 \u003c (int)uVar2) {\n      return (param_2 \u003c\u003c 0xb | 0x80000000 | param_1 \u003e\u003e 0x15) \u003e\u003e (uVar2 \u0026 0xff);\n    }\n  }\n  else if ((param_1 | param_2 \u003c\u003c 0xc) !\u003d 0) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "printFloat"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08000ae8": {
      "entrypoint": "0x08000ae8",
      "current_name": "FUN_08000ae8",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t FUN_08000ae8(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
      "renaming": {},
      "calling": [
        "startForkserver"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08000aec": {
      "entrypoint": "0x08000aec",
      "current_name": "FUN_08000aec",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint FUN_08000aec(int ticks)\n\n{\n  uint32_t uVar1;\n  \n  if (noHyperCall !\u003d 0) {\n    return 0;\n  }\n  uVar1 \u003d aflCall(1,ticks,0);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup"
      ],
      "called": [
        "aflCall"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08000b08": {
      "entrypoint": "0x08000b08",
      "current_name": "FUN_08000b08",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08000b08(int __initialize_p,int __priority)\n\n{\n  if ((__initialize_p \u003d\u003d 1) \u0026\u0026 (__priority \u003d\u003d 0xffff)) {\n    PID::PID(\u0026reflowOvenPID,\u0026input,\u0026output,\u0026setpoint,(double)CONCAT44(kp._4_4_,kp._0_4_),\n             (double)CONCAT44(ki._4_4_,ki._0_4_),(double)CONCAT44(kd._4_4_,kd._0_4_),0);\n    LiquidCrystal::LiquidCrystal\n              (\u0026lcd,(uint8_t)lcdRsPin,(uint8_t)lcdEPin,(uint8_t)lcdD4Pin,(uint8_t)lcdD5Pin,\n               (uint8_t)lcdD6Pin,(uint8_t)lcdD7Pin);\n    MAX31855::MAX31855(\u0026thermocouple,(uchar)thermocoupleSOPin,(uchar)thermocoupleCSPin,\n                       (uchar)thermocoupleCLKPin);\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_GLOBAL__sub_I_lcdMessagesReflowStatus"
      ],
      "called": [
        "MAX31855",
        "LiquidCrystal",
        "PID"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08000bcc": {
      "entrypoint": "0x08000bcc",
      "current_name": "FUN_08000bcc",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08000bcc(void)\n\n{\n  digitalWrite(ssrPin,0);\n  pinMode(ssrPin,1);\n  digitalWrite(buzzerPin,0);\n  pinMode(buzzerPin,1);\n  digitalWrite(ledRedPin,0);\n  pinMode(ledRedPin,1);\n  digitalWrite(buzzerPin,1);\n  LiquidCrystal::begin(\u0026lcd,\u0027\\b\u0027,\u0027\\x02\u0027,\u0027\\0\u0027);\n  LiquidCrystal::createChar(\u0026lcd,\u0027\\0\u0027,degree);\n  LiquidCrystal::clear(\u0026lcd);\n  Print::print(\u0026lcd.super_Print,\"Reflow\");\n  LiquidCrystal::setCursor(\u0026lcd,\u0027\\0\u0027,\u0027\\x01\u0027);\n  Print::print(\u0026lcd.super_Print,\"Oven 1.2\");\n  digitalWrite(buzzerPin,0);\n  delay(0x9c4);\n  LiquidCrystal::clear(\u0026lcd);\n  HardwareSerial::begin(\u0026Serial2,0xe100,\u0027\\x06\u0027);\n  digitalWrite(ledRedPin,1);\n  windowSize \u003d 2000;\n  nextCheck \u003d millis();\n  nextRead \u003d millis();\n  startForkserver(0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "begin",
        "digitalWrite",
        "startForkserver",
        "delay",
        "setCursor",
        "print",
        "begin",
        "millis",
        "createChar",
        "pinMode",
        "clear"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08000cbc": {
      "entrypoint": "0x08000cbc",
      "current_name": "FUN_08000cbc",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08000cbc(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__static_initialization_and_destruction_0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08000cd0": {
      "entrypoint": "0x08000cd0",
      "current_name": "FUN_08000cd0",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08000cd0(void)\n\n{\n  double dVar1;\n  uint32_t uVar2;\n  MAX31855 *pMVar3;\n  int iVar4;\n  ulong now;\n  int iVar5;\n  size_t extraout_r1;\n  int digits;\n  int digits_00;\n  int digits_01;\n  size_t sVar6;\n  undefined4 unaff_r4;\n  undefined4 unaff_r5;\n  undefined8 uVar7;\n  undefined4 in_stack_ffffffe4;\n  undefined4 in_stack_ffffffe8;\n  undefined4 in_stack_ffffffec;\n  \n  uVar2 \u003d millis();\n  if (nextRead \u003c uVar2) {\n    nextRead \u003d nextRead + 1000;\n    pMVar3 \u003d \u0026thermocouple;\n    MAX31855::readThermocouple(\u0026thermocouple,CELSIUS);\n    input._0_4_ \u003d pMVar3;\n    input._4_4_ \u003d extraout_r1;\n    iVar5 \u003d __aeabi_dcmpeq();\n    if (((iVar5 !\u003d 0) || (iVar5 \u003d __aeabi_dcmpeq(pMVar3,extraout_r1,0,0x40c38880), iVar5 !\u003d 0)) ||\n       (iVar5 \u003d __aeabi_dcmpeq(pMVar3,extraout_r1,0,0x40c38900), iVar5 !\u003d 0)) {\n      reflowState \u003d REFLOW_STATE_ERROR;\n      reflowStatus \u003d REFLOW_STATUS_OFF;\n    }\n  }\n  uVar2 \u003d millis();\n  iVar5 \u003d ledRedPin;\n  if (nextCheck \u003c uVar2) {\n    nextCheck \u003d nextCheck + 1000;\n    if (reflowStatus \u003d\u003d REFLOW_STATUS_ON) {\n      iVar4 \u003d digitalRead(ledRedPin);\n      digitalWrite(iVar5,(uint)(iVar4 \u003d\u003d 0));\n      timerSeconds \u003d timerSeconds + 1;\n      Print::print((Print *)\u0026Serial2,timerSeconds,10);\n      Print::print((Print *)\u0026Serial2,\" \");\n      Print::print((Print *)\u0026Serial2,(double)CONCAT44(in_stack_ffffffe4,2),digits);\n      Print::print((Print *)\u0026Serial2,\" \");\n      Print::print((Print *)\u0026Serial2,(double)CONCAT44(in_stack_ffffffe4,2),digits_00);\n      Print::print((Print *)\u0026Serial2,\" \");\n      Print::println((Print *)\u0026Serial2,(double)CONCAT44(in_stack_ffffffe4,2),digits_01);\n    }\n    else {\n      digitalWrite(ledRedPin,1);\n    }\n    LiquidCrystal::clear(\u0026lcd);\n    Print::print(\u0026lcd.super_Print,lcdMessagesReflowStatus[reflowState]);\n    LiquidCrystal::setCursor(\u0026lcd,\u0027\\0\u0027,\u0027\\x01\u0027);\n    if (reflowState \u003d\u003d REFLOW_STATE_ERROR) {\n      Print::print(\u0026lcd.super_Print,\"TC Error!\");\n    }\n    else {\n      pMVar3 \u003d input._0_4_;\n      sVar6 \u003d input._4_4_;\n      Print::print(\u0026lcd.super_Print,(double)CONCAT44(in_stack_ffffffe4,2),2);\n      LiquidCrystal::write(\u0026lcd,0,pMVar3,sVar6);\n      Print::print(\u0026lcd.super_Print,\"C \");\n    }\n  }\n  sVar6 \u003d input._4_4_;\n  pMVar3 \u003d input._0_4_;\n  setpoint \u003d (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n  switch(reflowState) {\n  case REFLOW_STATE_IDLE:\n    iVar5 \u003d __aeabi_dcmpge(input._0_4_,input._4_4_,0,0x40490000);\n    if (iVar5 \u003d\u003d 0) {\n      if (switchStatus \u003d\u003d SWITCH_1) {\n        Print::println((Print *)\u0026Serial2,\"Time Setpoint Input Output\");\n        timerSeconds \u003d 0;\n        windowStartTime \u003d millis();\n        setpoint._0_4_ \u003d 0;\n        setpoint._4_4_ \u003d 0x4062c000;\n        dVar1 \u003d (double)__floatsidf(windowSize);\n        PID::SetOutputLimits\n                  (\u0026reflowOvenPID,dVar1,(double)CONCAT44(in_stack_ffffffec,in_stack_ffffffe8));\n        PID::SetSampleTime(\u0026reflowOvenPID,1000);\n        PID::SetMode(\u0026reflowOvenPID,1);\n        reflowState \u003d REFLOW_STATE_PREHEAT;\n      }\n    }\n    else {\n      reflowState \u003d REFLOW_STATE_TOO_HOT;\n      setpoint \u003d (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_PREHEAT:\n    reflowStatus \u003d REFLOW_STATUS_ON;\n    iVar5 \u003d __aeabi_dcmpge(input._0_4_,input._4_4_,0,0x4062c000);\n    setpoint \u003d (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (iVar5 !\u003d 0) {\n      uVar2 \u003d millis();\n      timerSoak \u003d uVar2 + 9000;\n      PID::SetTunings(\u0026reflowOvenPID,0.05,250.0,(double)CONCAT44(unaff_r5,unaff_r4));\n      reflowState \u003d REFLOW_STATE_SOAK;\n      setpoint \u003d 155.0;\n    }\n    break;\n  case REFLOW_STATE_SOAK:\n    uVar2 \u003d millis();\n    setpoint \u003d (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (timerSoak \u003c uVar2) {\n      uVar2 \u003d millis();\n      timerSoak \u003d uVar2 + 9000;\n      setpoint \u003d (double)__aeabi_dadd(setpoint._0_4_,setpoint._4_4_,0,0x40140000);\n      iVar5 \u003d __aeabi_dcmpgt(SUB84(setpoint,0),(int)((ulonglong)setpoint \u003e\u003e 0x20),0,0x40690000);\n      if (iVar5 !\u003d 0) {\n        PID::SetTunings(\u0026reflowOvenPID,0.05,350.0,(double)CONCAT44(unaff_r5,unaff_r4));\n        reflowState \u003d REFLOW_STATE_REFLOW;\n        setpoint \u003d 250.0;\n      }\n    }\n    break;\n  case REFLOW_STATE_REFLOW:\n    iVar5 \u003d __aeabi_dcmpge(input._0_4_,input._4_4_,0,0x406ea000);\n    setpoint \u003d (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (iVar5 !\u003d 0) {\n      PID::SetTunings(\u0026reflowOvenPID,0.05,350.0,(double)CONCAT44(unaff_r5,unaff_r4));\n      reflowState \u003d REFLOW_STATE_COOL;\n      setpoint \u003d 100.0;\n    }\n    break;\n  case REFLOW_STATE_COOL:\n    iVar5 \u003d __aeabi_dcmple(input._0_4_,input._4_4_,0,0x40590000);\n    setpoint \u003d (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (iVar5 !\u003d 0) {\n      uVar2 \u003d millis();\n      buzzerPeriod \u003d uVar2 + 1000;\n      digitalWrite(buzzerPin,1);\n      reflowStatus \u003d REFLOW_STATUS_OFF;\n      reflowState \u003d REFLOW_STATE_COMPLETE;\n      setpoint \u003d (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_COMPLETE:\n    uVar2 \u003d millis();\n    setpoint \u003d (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (buzzerPeriod \u003c uVar2) {\n      digitalWrite(buzzerPin,0);\n      reflowState \u003d REFLOW_STATE_IDLE;\n      setpoint \u003d (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_TOO_HOT:\n    iVar5 \u003d __aeabi_dcmplt(input._0_4_,input._4_4_,0,0x40490000);\n    setpoint \u003d (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (iVar5 !\u003d 0) {\n      reflowState \u003d REFLOW_STATE_IDLE;\n      setpoint \u003d (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_ERROR:\n    iVar5 \u003d __aeabi_dcmpeq(input._0_4_,input._4_4_,0,0x40c38800);\n    if ((iVar5 \u003d\u003d 0) \u0026\u0026 (iVar5 \u003d __aeabi_dcmpeq(pMVar3,sVar6,0,0x40c38880), iVar5 \u003d\u003d 0)) {\n      iVar5 \u003d __aeabi_dcmpeq(pMVar3,sVar6,0,0x40c38900);\n      if (iVar5 \u003d\u003d 0) {\n        reflowState \u003d REFLOW_STATE_IDLE;\n        setpoint \u003d (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n        break;\n      }\n    }\n    reflowState \u003d REFLOW_STATE_ERROR;\n    setpoint \u003d (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n  }\n  if ((switchStatus \u003d\u003d SWITCH_1) \u0026\u0026 (reflowStatus \u003d\u003d REFLOW_STATUS_ON)) {\n    reflowStatus \u003d REFLOW_STATUS_OFF;\n    reflowState \u003d REFLOW_STATE_IDLE;\n  }\n  if (debounceState \u003d\u003d DEBOUNCE_STATE_CHECK) {\n    uVar2 \u003d analogRead(switchPin);\n    if (uVar2 \u003d\u003d 0) {\n      uVar2 \u003d millis();\n      if (0x32 \u003c uVar2 - lastDebounceTime) {\n        debounceState \u003d DEBOUNCE_STATE_RELEASE;\n      }\n    }\n    else {\n      debounceState \u003d DEBOUNCE_STATE_IDLE;\n    }\n  }\n  else if (debounceState \u003d\u003d DEBOUNCE_STATE_IDLE) {\n    switchStatus \u003d SWITCH_NONE;\n    uVar2 \u003d analogRead(switchPin);\n    if (uVar2 \u003d\u003d 0) {\n      lastDebounceTime \u003d millis();\n      debounceState \u003d DEBOUNCE_STATE_CHECK;\n    }\n  }\n  else if (debounceState \u003d\u003d DEBOUNCE_STATE_RELEASE) {\n    uVar2 \u003d analogRead(switchPin);\n    if (uVar2 !\u003d 0) {\n      switchStatus \u003d SWITCH_1;\n      debounceState \u003d DEBOUNCE_STATE_IDLE;\n    }\n  }\n  if (reflowStatus \u003d\u003d REFLOW_STATUS_ON) {\n    uVar2 \u003d millis();\n    PID::Compute(\u0026reflowOvenPID);\n    if ((uint)windowSize \u003c uVar2 - windowStartTime) {\n      windowStartTime \u003d windowStartTime + windowSize;\n    }\n    uVar7 \u003d __floatunsidf(uVar2 - windowStartTime);\n    iVar5 \u003d __aeabi_dcmplt((int)uVar7,(int)((ulonglong)uVar7 \u003e\u003e 0x20),output._0_4_,output._4_4_);\n    if (iVar5 \u003d\u003d 0) {\n      digitalWrite(ssrPin,0);\n      dVar1 \u003d setpoint;\n    }\n    else {\n      digitalWrite(ssrPin,1);\n      dVar1 \u003d setpoint;\n    }\n  }\n  else {\n    digitalWrite(ssrPin,0);\n    dVar1 \u003d setpoint;\n  }\n  setpoint._4_4_ \u003d (undefined4)((ulonglong)dVar1 \u003e\u003e 0x20);\n  setpoint._0_4_ \u003d SUB84(dVar1,0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "SetOutputLimits",
        "write",
        "print",
        "setCursor",
        "analogRead",
        "millis",
        "__aeabi_dadd",
        "__aeabi_dcmpgt",
        "print",
        "__aeabi_dcmpeq",
        "println",
        "digitalRead",
        "__aeabi_dcmpge",
        "clear",
        "__aeabi_dcmple",
        "readThermocouple",
        "digitalWrite",
        "__floatsidf",
        "print",
        "Compute",
        "SetTunings",
        "SetSampleTime",
        "SetMode",
        "__floatunsidf",
        "__aeabi_dcmplt",
        "println"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001294": {
      "entrypoint": "0x08001294",
      "current_name": "FUN_08001294",
      "code": "\n/* DWARF original prototype: void  setRowOffsets(LiquidCrystal * this, int row0, int row1, int row2,\n   int row3) */\n\nvoid __thiscall LiquidCrystal::FUN_08001294(LiquidCrystal *this,int row0,int row1,int row2,int row3)\n\n{\n  this-\u003e_row_offsets[0] \u003d (uint8_t)row0;\n  this-\u003e_row_offsets[1] \u003d (uint8_t)row1;\n  this-\u003e_row_offsets[2] \u003d (uint8_t)row2;\n  this-\u003e_row_offsets[3] \u003d (uint8_t)row3;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "begin"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080012a2": {
      "entrypoint": "0x080012a2",
      "current_name": "FUN_080012a2",
      "code": "\n/* DWARF original prototype: void  pulseEnable(LiquidCrystal * this) */\n\nvoid __thiscall LiquidCrystal::FUN_080012a2(LiquidCrystal *this)\n\n{\n  digitalWrite((uint)this-\u003e_enable_pin,0);\n  digitalWrite((uint)this-\u003e_enable_pin,1);\n  digitalWrite((uint)this-\u003e_enable_pin,0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "write4bits",
        "write8bits"
      ],
      "called": [
        "digitalWrite"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080012c0": {
      "entrypoint": "0x080012c0",
      "current_name": "FUN_080012c0",
      "code": "\n/* DWARF original prototype: void  write4bits(LiquidCrystal * this, uint8_t value) */\n\nvoid __thiscall LiquidCrystal::FUN_080012c0(LiquidCrystal *this,uint8_t value)\n\n{\n  uint uVar1;\n  \n  for (uVar1 \u003d 0; (int)uVar1 \u003c 4; uVar1 \u003d uVar1 + 1) {\n    digitalWrite((uint)this-\u003e_data_pins[uVar1],(int)(uint)value \u003e\u003e (uVar1 \u0026 0xff) \u0026 1);\n  }\n  pulseEnable(this);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "send",
        "begin"
      ],
      "called": [
        "digitalWrite",
        "pulseEnable"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080012e8": {
      "entrypoint": "0x080012e8",
      "current_name": "FUN_080012e8",
      "code": "\n/* DWARF original prototype: void  write8bits(LiquidCrystal * this, uint8_t value) */\n\nvoid __thiscall LiquidCrystal::FUN_080012e8(LiquidCrystal *this,uint8_t value)\n\n{\n  uint uVar1;\n  \n  for (uVar1 \u003d 0; (int)uVar1 \u003c 8; uVar1 \u003d uVar1 + 1) {\n    digitalWrite((uint)this-\u003e_data_pins[uVar1],(int)(uint)value \u003e\u003e (uVar1 \u0026 0xff) \u0026 1);\n  }\n  pulseEnable(this);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "send"
      ],
      "called": [
        "digitalWrite",
        "pulseEnable"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001310": {
      "entrypoint": "0x08001310",
      "current_name": "FUN_08001310",
      "code": "\n/* DWARF original prototype: void  send(LiquidCrystal * this, uint8_t value, uint8_t mode) */\n\nssize_t __thiscall\nLiquidCrystal::FUN_08001310(LiquidCrystal *this,int __fd,void *__buf,size_t __n,int __flags)\n\n{\n  digitalWrite((uint)this-\u003e_rs_pin,(uint32_t)__buf);\n  if (this-\u003e_rw_pin !\u003d 0xff) {\n    digitalWrite((uint)this-\u003e_rw_pin,0);\n  }\n  if ((this-\u003e_displayfunction \u0026 0x10) \u003d\u003d 0) {\n    write4bits(this,(uint8_t)((uint)__fd \u003e\u003e 4));\n    write4bits(this,(uint8_t)__fd);\n    return (ssize_t)this;\n  }\n  write8bits(this,(uint8_t)__fd);\n  return (ssize_t)this;\n}\n\n",
      "renaming": {},
      "calling": [
        "write",
        "setCursor",
        "begin",
        "display",
        "createChar",
        "clear"
      ],
      "called": [
        "digitalWrite",
        "write4bits",
        "write8bits"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800134e": {
      "entrypoint": "0x0800134e",
      "current_name": "FUN_0800134e",
      "code": "\n/* DWARF original prototype: size_t  write(LiquidCrystal * this, uint8_t value) */\n\nssize_t __thiscall LiquidCrystal::FUN_0800134e(LiquidCrystal *this,int __fd,void *__buf,size_t __n)\n\n{\n  send(this,__fd,(void *)0x1,__n,__n);\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "send"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800135a": {
      "entrypoint": "0x0800135a",
      "current_name": "FUN_0800135a",
      "code": "\n/* DWARF original prototype: void  clear(LiquidCrystal * this) */\n\nvoid __thiscall LiquidCrystal::FUN_0800135a(LiquidCrystal *this)\n\n{\n  size_t in_r3;\n  \n  send(this,1,(void *)0x0,in_r3,in_r3);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup",
        "begin",
        "loop"
      ],
      "called": [
        "send"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001366": {
      "entrypoint": "0x08001366",
      "current_name": "FUN_08001366",
      "code": "\n/* DWARF original prototype: void  setCursor(LiquidCrystal * this, uint8_t col, uint8_t row) */\n\nvoid __thiscall LiquidCrystal::FUN_08001366(LiquidCrystal *this,uint8_t col,uint8_t row)\n\n{\n  uint uVar1;\n  int in_r3;\n  \n  uVar1 \u003d (uint)row;\n  if (3 \u003c uVar1) {\n    uVar1 \u003d 3;\n  }\n  if (this-\u003e_numlines \u003c\u003d uVar1) {\n    uVar1 \u003d this-\u003e_numlines - 1 \u0026 0xff;\n  }\n  send(this,(uint)(byte)(col + this-\u003e_row_offsets[uVar1] | 0x80),(void *)0x0,\n       (uint)this-\u003e_row_offsets[uVar1],in_r3);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup",
        "loop"
      ],
      "called": [
        "send"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800138e": {
      "entrypoint": "0x0800138e",
      "current_name": "FUN_0800138e",
      "code": "\n/* DWARF original prototype: void  display(LiquidCrystal * this) */\n\nvoid __thiscall LiquidCrystal::FUN_0800138e(LiquidCrystal *this)\n\n{\n  byte bVar1;\n  size_t in_r3;\n  \n  bVar1 \u003d this-\u003e_displaycontrol;\n  this-\u003e_displaycontrol \u003d bVar1 | 4;\n  send(this,bVar1 | 0xc,(void *)0x0,in_r3,in_r3);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "begin"
      ],
      "called": [
        "send"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080013a4": {
      "entrypoint": "0x080013a4",
      "current_name": "FUN_080013a4",
      "code": "\n/* DWARF original prototype: void  begin(LiquidCrystal * this, uint8_t cols, uint8_t lines, uint8_t\n   dotsize) */\n\nvoid __thiscall\nLiquidCrystal::FUN_080013a4(LiquidCrystal *this,uint8_t cols,uint8_t lines,uint8_t dotsize)\n\n{\n  int row3;\n  size_t __n;\n  int iVar1;\n  \n  if (1 \u003c lines) {\n    this-\u003e_displayfunction \u003d this-\u003e_displayfunction | 8;\n  }\n  this-\u003e_numlines \u003d lines;\n  row3 \u003d cols + 0x40;\n  setRowOffsets(this,0,0x40,(uint)cols,row3);\n  if ((dotsize !\u003d \u0027\\0\u0027) \u0026\u0026 (lines \u003d\u003d \u0027\\x01\u0027)) {\n    this-\u003e_displayfunction \u003d this-\u003e_displayfunction | 4;\n  }\n  pinMode((uint)this-\u003e_rs_pin,1);\n  if (this-\u003e_rw_pin !\u003d 0xff) {\n    pinMode((uint)this-\u003e_rw_pin,1);\n  }\n  pinMode((uint)this-\u003e_enable_pin,1);\n  iVar1 \u003d 0;\n  while( true ) {\n    if ((this-\u003e_displayfunction \u0026 0x10) \u003d\u003d 0) {\n      __n \u003d 4;\n    }\n    else {\n      __n \u003d 8;\n    }\n    if ((int)__n \u003c\u003d iVar1) break;\n    pinMode((uint)this-\u003e_data_pins[iVar1],1);\n    iVar1 \u003d iVar1 + 1;\n  }\n  digitalWrite((uint)this-\u003e_rs_pin,0);\n  digitalWrite((uint)this-\u003e_enable_pin,0);\n  if (this-\u003e_rw_pin !\u003d 0xff) {\n    digitalWrite((uint)this-\u003e_rw_pin,0);\n  }\n  if ((this-\u003e_displayfunction \u0026 0x10) \u003d\u003d 0) {\n    write4bits(this,\u0027\\x03\u0027);\n    write4bits(this,\u0027\\x03\u0027);\n    write4bits(this,\u0027\\x03\u0027);\n    write4bits(this,\u0027\\x02\u0027);\n  }\n  else {\n    send(this,this-\u003e_displayfunction | 0x20,(void *)0x0,__n,row3);\n    send(this,this-\u003e_displayfunction | 0x20,(void *)0x0,__n,row3);\n    send(this,this-\u003e_displayfunction | 0x20,(void *)0x0,__n,row3);\n  }\n  send(this,this-\u003e_displayfunction | 0x20,(void *)0x0,__n,row3);\n  this-\u003e_displaycontrol \u003d \u0027\\x04\u0027;\n  display(this);\n  clear(this);\n  this-\u003e_displaymode \u003d \u0027\\x02\u0027;\n  send(this,6,(void *)0x0,2,row3);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup",
        "init"
      ],
      "called": [
        "digitalWrite",
        "send",
        "display",
        "pinMode",
        "clear",
        "setRowOffsets",
        "write4bits"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080014ba": {
      "entrypoint": "0x080014ba",
      "current_name": "FUN_080014ba",
      "code": "\n/* DWARF original prototype: void  init(LiquidCrystal * this, uint8_t fourbitmode, uint8_t rs,\n   uint8_t rw, uint8_t enable, uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3, uint8_t d4, uint8_t\n   d5, uint8_t d6, uint8_t d7) */\n\nint __thiscall LiquidCrystal::FUN_080014ba(LiquidCrystal *this,EVP_PKEY_CTX *ctx)\n\n{\n  uint8_t in_r2;\n  uint8_t in_r3;\n  uint8_t in_stack_00000000;\n  uint8_t in_stack_00000004;\n  uint8_t in_stack_00000008;\n  uint8_t in_stack_0000000c;\n  uint8_t in_stack_00000010;\n  uint8_t in_stack_00000014;\n  uint8_t in_stack_00000018;\n  uint8_t in_stack_0000001c;\n  uint8_t in_stack_00000020;\n  \n  this-\u003e_rs_pin \u003d in_r2;\n  this-\u003e_rw_pin \u003d in_r3;\n  this-\u003e_enable_pin \u003d in_stack_00000000;\n  this-\u003e_data_pins[0] \u003d in_stack_00000004;\n  this-\u003e_data_pins[1] \u003d in_stack_00000008;\n  this-\u003e_data_pins[2] \u003d in_stack_0000000c;\n  this-\u003e_data_pins[3] \u003d in_stack_00000010;\n  this-\u003e_data_pins[4] \u003d in_stack_00000014;\n  this-\u003e_data_pins[5] \u003d in_stack_00000018;\n  this-\u003e_data_pins[6] \u003d in_stack_0000001c;\n  this-\u003e_data_pins[7] \u003d in_stack_00000020;\n  if (ctx \u003d\u003d (EVP_PKEY_CTX *)0x0) {\n    this-\u003e_displayfunction \u003d \u0027\\x10\u0027;\n  }\n  else {\n    this-\u003e_displayfunction \u003d \u0027\\0\u0027;\n  }\n  begin(this,\u0027\\x10\u0027,\u0027\\x01\u0027,\u0027\\0\u0027);\n  return (int)this;\n}\n\n",
      "renaming": {},
      "calling": [
        "LiquidCrystal"
      ],
      "called": [
        "begin"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001510": {
      "entrypoint": "0x08001510",
      "current_name": "FUN_08001510",
      "code": "\n/* DWARF original prototype: LiquidCrystal *  LiquidCrystal(LiquidCrystal * this, uint8_t rs,\n   uint8_t enable, uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3) */\n\nLiquidCrystal * __thiscall\nLiquidCrystal::FUN_08001510\n          (LiquidCrystal *this,uint8_t rs,uint8_t enable,uint8_t d0,uint8_t d1,uint8_t d2,uint8_t d3\n          )\n\n{\n  (this-\u003esuper_Print).write_error \u003d 0;\n  (this-\u003esuper_Print)._vptr_Print \u003d (_func_int_varargs **)\u0026PTR_write_1_080073f8;\n  init(this,(EVP_PKEY_CTX *)0x1);\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "__static_initialization_and_destruction_0"
      ],
      "called": [
        "init"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001550": {
      "entrypoint": "0x08001550",
      "current_name": "FUN_08001550",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08001574 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  createChar(LiquidCrystal * this, uint8_t location, uint8_t *\n   charmap) */\n\nvoid __thiscall LiquidCrystal::FUN_08001550(LiquidCrystal *this,uint8_t location,uint8_t *charmap)\n\n{\n  size_t in_r3;\n  int unaff_r4;\n  int iVar1;\n  \n  send(this,(location \u0026 7) \u003c\u003c 3 | 0x40,(void *)0x0,in_r3,unaff_r4);\n  for (iVar1 \u003d 0; iVar1 \u003c 8; iVar1 \u003d iVar1 + 1) {\n    (**(this-\u003esuper_Print)._vptr_Print)(this,(uint)charmap[iVar1]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup"
      ],
      "called": [
        "send"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800157c": {
      "entrypoint": "0x0800157c",
      "current_name": "FUN_0800157c",
      "code": "\n/* DWARF original prototype: MAX31855 *  MAX31855(MAX31855 * this, uchar SO, uchar CS, uchar SCK) */\n\nMAX31855 * __thiscall MAX31855::FUN_0800157c(MAX31855 *this,uchar SO,uchar CS,uchar SCK)\n\n{\n  this-\u003eso \u003d SO;\n  this-\u003ecs \u003d CS;\n  this-\u003esck \u003d SCK;\n  pinMode((uint)SO,0);\n  pinMode((uint)this-\u003ecs,1);\n  pinMode((uint)this-\u003esck,1);\n  digitalWrite((uint)this-\u003ecs,1);\n  digitalWrite((uint)this-\u003esck,0);\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "__static_initialization_and_destruction_0"
      ],
      "called": [
        "digitalWrite",
        "pinMode"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080015b2": {
      "entrypoint": "0x080015b2",
      "current_name": "FUN_080015b2",
      "code": "\n/* DWARF original prototype: ulong  readData(MAX31855 * this) */\n\nulong __thiscall MAX31855::FUN_080015b2(MAX31855 *this)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  \n  digitalWrite((uint)this-\u003ecs,0);\n  uVar3 \u003d 0;\n  for (uVar2 \u003d 0x1f; -1 \u003c (int)uVar2; uVar2 \u003d uVar2 - 1) {\n    digitalWrite((uint)this-\u003esck,1);\n    iVar1 \u003d digitalRead((uint)this-\u003eso);\n    if (iVar1 !\u003d 0) {\n      uVar3 \u003d uVar3 | 1 \u003c\u003c (uVar2 \u0026 0xff);\n    }\n    digitalWrite((uint)this-\u003esck,0);\n  }\n  digitalWrite((uint)this-\u003ecs,1);\n  return uVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "readThermocouple"
      ],
      "called": [
        "digitalWrite",
        "digitalRead"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080015f8": {
      "entrypoint": "0x080015f8",
      "current_name": "FUN_080015f8",
      "code": "\n/* DWARF original prototype: double  readThermocouple(MAX31855 * this, unit_t unit) */\n\ndouble __thiscall MAX31855::FUN_080015f8(MAX31855 *this,unit_t unit)\n\n{\n  ulong uVar1;\n  ulong data;\n  uint uVar2;\n  double extraout_d0;\n  double extraout_d0_00;\n  double dVar3;\n  undefined8 uVar4;\n  \n  uVar1 \u003d readData(this);\n  if ((uVar1 \u0026 0x10000) \u003d\u003d 0) {\n    uVar2 \u003d uVar1 \u003e\u003e 0x12;\n    uVar4 \u003d __floatunsidf(uVar2 \u0026 0x1fff);\n    if ((uVar2 \u0026 0x2000) !\u003d 0) {\n      uVar4 \u003d __floatunsidf(~uVar2 \u0026 0x1fff);\n      uVar4 \u003d __aeabi_dadd((int)uVar4,(int)((ulonglong)uVar4 \u003e\u003e 0x20),0,0x3ff00000);\n      uVar4 \u003d CONCAT44((int)((ulonglong)uVar4 \u003e\u003e 0x20) + -0x80000000,(int)uVar4);\n    }\n    uVar4 \u003d __muldf3((int)uVar4,(int)((ulonglong)uVar4 \u003e\u003e 0x20),0,0x3fd00000);\n    dVar3 \u003d extraout_d0_00;\n    if (unit \u003d\u003d FAHRENHEIT) {\n      uVar4 \u003d __muldf3((int)uVar4,(int)((ulonglong)uVar4 \u003e\u003e 0x20),0,0x40220000);\n      uVar4 \u003d __divdf3((int)uVar4,(int)((ulonglong)uVar4 \u003e\u003e 0x20),0,0x40140000);\n      dVar3 \u003d (double)__aeabi_dadd((int)uVar4,(int)((ulonglong)uVar4 \u003e\u003e 0x20),0,0x40400000);\n      return dVar3;\n    }\n  }\n  else {\n    uVar2 \u003d uVar1 \u0026 7;\n    if (uVar2 \u003d\u003d 2) {\n      return extraout_d0;\n    }\n    if (uVar2 \u003d\u003d 4) {\n      return extraout_d0;\n    }\n    dVar3 \u003d extraout_d0;\n    if (uVar2 !\u003d 1) {\n      return extraout_d0;\n    }\n  }\n  return dVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "__muldf3",
        "__aeabi_dadd",
        "__floatunsidf",
        "__divdf3",
        "readData"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080016b4": {
      "entrypoint": "0x080016b4",
      "current_name": "FUN_080016b4",
      "code": "\n/* DWARF original prototype: bool  Compute(PID * this) */\n\nbool __thiscall PID::FUN_080016b4(PID *this)\n\n{\n  bool bVar1;\n  uint32_t uVar2;\n  ulong now;\n  int iVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  ulong timeChange;\n  undefined4 uVar8;\n  undefined4 uVar9;\n  undefined4 uVar10;\n  char cVar11;\n  undefined4 uVar12;\n  undefined4 uVar13;\n  undefined4 uVar14;\n  undefined8 uVar15;\n  undefined8 uVar16;\n  undefined8 uVar17;\n  double dVar18;\n  double dVar19;\n  double output;\n  \n  cVar11 \u003d this-\u003einAuto;\n  if ((bool)cVar11 !\u003d false) {\n    uVar2 \u003d millis();\n    if (uVar2 - this-\u003elastTime \u003c this-\u003eSampleTime) {\n      cVar11 \u003d \u0027\\0\u0027;\n    }\n    else {\n      uVar5 \u003d *(undefined4 *)this-\u003emyInput;\n      uVar8 \u003d *(undefined4 *)((int)this-\u003emyInput + 4);\n      uVar15 \u003d __subdf3(*(undefined4 *)this-\u003emySetpoint,*(undefined4 *)((int)this-\u003emySetpoint + 4));\n      uVar14 \u003d (undefined4)((ulonglong)uVar15 \u003e\u003e 0x20);\n      uVar16 \u003d __subdf3(uVar5,uVar8,*(undefined4 *)\u0026this-\u003elastInput,\n                        *(undefined4 *)((int)\u0026this-\u003elastInput + 4));\n      uVar4 \u003d (undefined4)((ulonglong)uVar16 \u003e\u003e 0x20);\n      uVar17 \u003d __muldf3((int)uVar15,uVar14,*(undefined4 *)\u0026this-\u003eki,\n                        *(undefined4 *)((int)\u0026this-\u003eki + 4));\n      dVar18 \u003d (double)__aeabi_dadd((int)uVar17,(int)((ulonglong)uVar17 \u003e\u003e 0x20),\n                                    *(undefined4 *)\u0026this-\u003eoutputSum,\n                                    *(undefined4 *)((int)\u0026this-\u003eoutputSum + 4));\n      this-\u003eoutputSum \u003d dVar18;\n      bVar1 \u003d this-\u003epOnE;\n      if (bVar1 \u003d\u003d false) {\n        uVar17 \u003d __muldf3((int)uVar16,uVar4,*(undefined4 *)\u0026this-\u003ekp,\n                          *(undefined4 *)((int)\u0026this-\u003ekp + 4));\n        dVar18 \u003d (double)__subdf3(SUB84(dVar18,0),(int)((ulonglong)dVar18 \u003e\u003e 0x20),(int)uVar17,\n                                  (int)((ulonglong)uVar17 \u003e\u003e 0x20));\n        this-\u003eoutputSum \u003d dVar18;\n      }\n      uVar6 \u003d *(undefined4 *)\u0026this-\u003eoutputSum;\n      uVar9 \u003d *(undefined4 *)((int)\u0026this-\u003eoutputSum + 4);\n      uVar12 \u003d *(undefined4 *)\u0026this-\u003eoutMax;\n      uVar13 \u003d *(undefined4 *)((int)\u0026this-\u003eoutMax + 4);\n      dVar18 \u003d this-\u003eoutMax;\n      iVar3 \u003d __aeabi_dcmpgt(uVar6,uVar9,uVar12,uVar13);\n      if (iVar3 \u003d\u003d 0) {\n        uVar7 \u003d *(undefined4 *)\u0026this-\u003eoutMin;\n        uVar10 \u003d *(undefined4 *)((int)\u0026this-\u003eoutMin + 4);\n        iVar3 \u003d __aeabi_dcmplt(uVar6,uVar9);\n        if (iVar3 !\u003d 0) {\n          *(undefined4 *)\u0026this-\u003eoutputSum \u003d uVar7;\n          *(undefined4 *)((int)\u0026this-\u003eoutputSum + 4) \u003d uVar10;\n        }\n      }\n      else {\n        *(undefined4 *)\u0026this-\u003eoutputSum \u003d uVar12;\n        *(undefined4 *)((int)\u0026this-\u003eoutputSum + 4) \u003d uVar13;\n      }\n      if (bVar1 \u003d\u003d false) {\n        uVar15 \u003d 0;\n      }\n      else {\n        uVar15 \u003d __muldf3((int)uVar15,uVar14,*(undefined4 *)\u0026this-\u003ekp,\n                          *(undefined4 *)((int)\u0026this-\u003ekp + 4));\n      }\n      output._4_4_ \u003d (undefined4)((ulonglong)uVar15 \u003e\u003e 0x20);\n      output._0_4_ \u003d (undefined4)uVar15;\n      uVar14 \u003d *(undefined4 *)\u0026this-\u003eoutputSum;\n      uVar6 \u003d *(undefined4 *)((int)\u0026this-\u003eoutputSum + 4);\n      uVar15 \u003d __muldf3((int)uVar16,uVar4,*(undefined4 *)\u0026this-\u003ekd,\n                        *(undefined4 *)((int)\u0026this-\u003ekd + 4));\n      uVar15 \u003d __subdf3(uVar14,uVar6,(int)uVar15,(int)((ulonglong)uVar15 \u003e\u003e 0x20));\n      dVar19 \u003d (double)__aeabi_dadd(output._0_4_,output._4_4_,(int)uVar15,\n                                    (int)((ulonglong)uVar15 \u003e\u003e 0x20));\n      uVar14 \u003d (undefined4)((ulonglong)dVar19 \u003e\u003e 0x20);\n      iVar3 \u003d __aeabi_dcmplt(uVar12,uVar13,SUB84(dVar19,0),uVar14);\n      if (iVar3 \u003d\u003d 0) {\n        dVar18 \u003d this-\u003eoutMin;\n        iVar3 \u003d __aeabi_dcmplt(SUB84(dVar19,0),uVar14,*(undefined4 *)\u0026this-\u003eoutMin,\n                               *(undefined4 *)((int)\u0026this-\u003eoutMin + 4));\n        if (iVar3 \u003d\u003d 0) {\n          dVar18 \u003d dVar19;\n        }\n      }\n      *this-\u003emyOutput \u003d dVar18;\n      *(undefined4 *)\u0026this-\u003elastInput \u003d uVar5;\n      *(undefined4 *)((int)\u0026this-\u003elastInput + 4) \u003d uVar8;\n      this-\u003elastTime \u003d uVar2;\n    }\n  }\n  return (bool)cVar11;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "__muldf3",
        "__subdf3",
        "__aeabi_dadd",
        "millis",
        "__aeabi_dcmpgt",
        "__aeabi_dcmplt"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001814": {
      "entrypoint": "0x08001814",
      "current_name": "FUN_08001814",
      "code": "\n/* DWARF original prototype: void  SetTunings(PID * this, double Kp, double Ki, double Kd, int POn)\n    */\n\nvoid __thiscall PID::FUN_08001814(PID *this,double Kp,double Ki,double Kd,int POn)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  undefined uVar3;\n  bool bVar4;\n  undefined8 uVar5;\n  double dVar6;\n  double dVar7;\n  double dVar8;\n  \n  iVar1 \u003d __aeabi_dcmplt();\n  if (((iVar1 \u003d\u003d 0) \u0026\u0026 (iVar1 \u003d __aeabi_dcmplt(Kp._0_4_,Kp._4_4_,0,0), iVar1 \u003d\u003d 0)) \u0026\u0026\n     (iVar1 \u003d __aeabi_dcmplt(Ki._0_4_,Ki._4_4_,0,0), iVar1 \u003d\u003d 0)) {\n    this-\u003epOn \u003d Kd._0_4_;\n    bVar4 \u003d Kd._0_4_ !\u003d 1;\n    if (bVar4) {\n      Kd._0_4_ \u003d 0;\n    }\n    uVar3 \u003d (undefined)Kd._0_4_;\n    if (!bVar4) {\n      uVar3 \u003d true;\n    }\n    this-\u003epOnE \u003d (bool)uVar3;\n    *(undefined4 *)\u0026this-\u003edispKp \u003d in_r2;\n    *(undefined4 *)((int)\u0026this-\u003edispKp + 4) \u003d in_r3;\n    this-\u003edispKi \u003d Kp;\n    this-\u003edispKd \u003d Ki;\n    uVar5 \u003d __floatunsidf(this-\u003eSampleTime);\n    uVar5 \u003d __divdf3((int)uVar5,(int)((ulonglong)uVar5 \u003e\u003e 0x20),0,0x408f4000);\n    uVar2 \u003d (undefined4)((ulonglong)uVar5 \u003e\u003e 0x20);\n    *(undefined4 *)\u0026this-\u003ekp \u003d in_r2;\n    *(undefined4 *)((int)\u0026this-\u003ekp + 4) \u003d in_r3;\n    dVar6 \u003d (double)__muldf3(Kp._0_4_,Kp._4_4_,(int)uVar5,uVar2);\n    this-\u003eki \u003d dVar6;\n    dVar7 \u003d (double)__divdf3(Ki._0_4_,Ki._4_4_,(int)uVar5,uVar2);\n    this-\u003ekd \u003d dVar7;\n    if (this-\u003econtrollerDirection \u003d\u003d 1) {\n      dVar8 \u003d (double)__subdf3(0,0);\n      this-\u003ekp \u003d dVar8;\n      dVar6 \u003d (double)__subdf3(0,0,SUB84(dVar6,0),(int)((ulonglong)dVar6 \u003e\u003e 0x20));\n      this-\u003eki \u003d dVar6;\n      dVar6 \u003d (double)__subdf3(0,0,SUB84(dVar7,0),(int)((ulonglong)dVar7 \u003e\u003e 0x20));\n      this-\u003ekd \u003d dVar6;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "PID",
        "SetTunings"
      ],
      "called": [
        "__muldf3",
        "__subdf3",
        "__floatunsidf",
        "__divdf3",
        "__aeabi_dcmplt"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080018f8": {
      "entrypoint": "0x080018f8",
      "current_name": "FUN_080018f8",
      "code": "\n/* DWARF original prototype: void  SetTunings(PID * this, double Kp, double Ki, double Kd) */\n\nvoid __thiscall PID::FUN_080018f8(PID *this,double Kp,double Ki,double Kd)\n\n{\n  undefined4 in_stack_ffffffec;\n  \n  SetTunings(this,Kp,Ki,(double)CONCAT44(in_stack_ffffffec,this-\u003epOn),this-\u003epOn);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "SetTunings"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001918": {
      "entrypoint": "0x08001918",
      "current_name": "FUN_08001918",
      "code": "\n/* DWARF original prototype: void  SetSampleTime(PID * this, int NewSampleTime) */\n\nvoid __thiscall PID::FUN_08001918(PID *this,int NewSampleTime)\n\n{\n  undefined4 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  double dVar4;\n  \n  if (0 \u003c NewSampleTime) {\n    uVar2 \u003d __floatsidf(NewSampleTime);\n    uVar3 \u003d __floatunsidf(this-\u003eSampleTime);\n    uVar2 \u003d __divdf3((int)uVar2,(int)((ulonglong)uVar2 \u003e\u003e 0x20),(int)uVar3,\n                     (int)((ulonglong)uVar3 \u003e\u003e 0x20));\n    uVar1 \u003d (undefined4)((ulonglong)uVar2 \u003e\u003e 0x20);\n    dVar4 \u003d (double)__muldf3((int)uVar2,uVar1,*(undefined4 *)\u0026this-\u003eki,\n                             *(undefined4 *)((int)\u0026this-\u003eki + 4));\n    this-\u003eki \u003d dVar4;\n    dVar4 \u003d (double)__divdf3(*(undefined4 *)\u0026this-\u003ekd,*(undefined4 *)((int)\u0026this-\u003ekd + 4),(int)uVar2\n                             ,uVar1);\n    this-\u003ekd \u003d dVar4;\n    this-\u003eSampleTime \u003d NewSampleTime;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "__muldf3",
        "__floatsidf",
        "__floatunsidf",
        "__divdf3"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001960": {
      "entrypoint": "0x08001960",
      "current_name": "FUN_08001960",
      "code": "\n/* DWARF original prototype: void  SetOutputLimits(PID * this, double Min, double Max) */\n\nvoid __thiscall PID::FUN_08001960(PID *this,double Min,double Max)\n\n{\n  int iVar1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  double *pdVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  \n  iVar1 \u003d __aeabi_dcmpge();\n  if (iVar1 \u003d\u003d 0) {\n    *(undefined4 *)\u0026this-\u003eoutMin \u003d in_r2;\n    *(undefined4 *)((int)\u0026this-\u003eoutMin + 4) \u003d in_r3;\n    this-\u003eoutMax \u003d Min;\n    if (this-\u003einAuto !\u003d false) {\n      pdVar2 \u003d this-\u003emyOutput;\n      iVar1 \u003d __aeabi_dcmplt(Min._0_4_,Min._4_4_,*(undefined4 *)pdVar2,\n                             *(undefined4 *)((int)pdVar2 + 4));\n      if (iVar1 \u003d\u003d 0) {\n        iVar1 \u003d __aeabi_dcmpgt();\n        if (iVar1 !\u003d 0) {\n          *(undefined4 *)pdVar2 \u003d in_r2;\n          *(undefined4 *)((int)pdVar2 + 4) \u003d in_r3;\n        }\n      }\n      else {\n        *pdVar2 \u003d Min;\n      }\n      uVar3 \u003d *(undefined4 *)\u0026this-\u003eoutputSum;\n      uVar4 \u003d *(undefined4 *)((int)\u0026this-\u003eoutputSum + 4);\n      uVar5 \u003d *(undefined4 *)\u0026this-\u003eoutMax;\n      uVar6 \u003d *(undefined4 *)((int)\u0026this-\u003eoutMax + 4);\n      iVar1 \u003d __aeabi_dcmpgt(uVar3,uVar4,uVar5,uVar6);\n      if (iVar1 !\u003d 0) {\n        *(undefined4 *)\u0026this-\u003eoutputSum \u003d uVar5;\n        *(undefined4 *)((int)\u0026this-\u003eoutputSum + 4) \u003d uVar6;\n        return;\n      }\n      uVar5 \u003d *(undefined4 *)\u0026this-\u003eoutMin;\n      uVar6 \u003d *(undefined4 *)((int)\u0026this-\u003eoutMin + 4);\n      iVar1 \u003d __aeabi_dcmplt(uVar3,uVar4,uVar5,uVar6);\n      if (iVar1 !\u003d 0) {\n        *(undefined4 *)\u0026this-\u003eoutputSum \u003d uVar5;\n        *(undefined4 *)((int)\u0026this-\u003eoutputSum + 4) \u003d uVar6;\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "PID",
        "loop"
      ],
      "called": [
        "__aeabi_dcmpgt",
        "__aeabi_dcmpge",
        "__aeabi_dcmplt"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080019f6": {
      "entrypoint": "0x080019f6",
      "current_name": "FUN_080019f6",
      "code": "\n/* DWARF original prototype: void  Initialize(PID * this) */\n\nvoid __thiscall PID::FUN_080019f6(PID *this)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  \n  uVar3 \u003d *(undefined4 *)this-\u003emyOutput;\n  uVar4 \u003d *(undefined4 *)((int)this-\u003emyOutput + 4);\n  *(undefined4 *)\u0026this-\u003eoutputSum \u003d uVar3;\n  *(undefined4 *)((int)\u0026this-\u003eoutputSum + 4) \u003d uVar4;\n  uVar2 \u003d *(undefined4 *)((int)this-\u003emyInput + 4);\n  *(undefined4 *)\u0026this-\u003elastInput \u003d *(undefined4 *)this-\u003emyInput;\n  *(undefined4 *)((int)\u0026this-\u003elastInput + 4) \u003d uVar2;\n  uVar2 \u003d *(undefined4 *)\u0026this-\u003eoutMax;\n  uVar5 \u003d *(undefined4 *)((int)\u0026this-\u003eoutMax + 4);\n  iVar1 \u003d __aeabi_dcmpgt(uVar3,uVar4,uVar2,uVar5);\n  if (iVar1 \u003d\u003d 0) {\n    uVar2 \u003d *(undefined4 *)\u0026this-\u003eoutMin;\n    uVar5 \u003d *(undefined4 *)((int)\u0026this-\u003eoutMin + 4);\n    iVar1 \u003d __aeabi_dcmplt(uVar3,uVar4,uVar2,uVar5);\n    if (iVar1 !\u003d 0) {\n      *(undefined4 *)\u0026this-\u003eoutputSum \u003d uVar2;\n      *(undefined4 *)((int)\u0026this-\u003eoutputSum + 4) \u003d uVar5;\n    }\n    return;\n  }\n  *(undefined4 *)\u0026this-\u003eoutputSum \u003d uVar2;\n  *(undefined4 *)((int)\u0026this-\u003eoutputSum + 4) \u003d uVar5;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SetMode"
      ],
      "called": [
        "__aeabi_dcmpgt",
        "__aeabi_dcmplt"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001a44": {
      "entrypoint": "0x08001a44",
      "current_name": "FUN_08001a44",
      "code": "\n/* DWARF original prototype: void  SetMode(PID * this, int Mode) */\n\nvoid __thiscall PID::FUN_08001a44(PID *this,int Mode)\n\n{\n  bool newAuto;\n  bool bVar1;\n  \n  if (Mode \u003d\u003d 1) {\n    bVar1 \u003d true;\n    if (this-\u003einAuto \u003d\u003d false) {\n      Initialize(this);\n    }\n  }\n  else {\n    bVar1 \u003d false;\n  }\n  this-\u003einAuto \u003d bVar1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "Initialize"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001a66": {
      "entrypoint": "0x08001a66",
      "current_name": "FUN_08001a66",
      "code": "\n/* DWARF original prototype: void  SetControllerDirection(PID * this, int Direction) */\n\nvoid __thiscall PID::FUN_08001a66(PID *this,int Direction)\n\n{\n  double dVar1;\n  \n  if ((this-\u003einAuto !\u003d false) \u0026\u0026 (this-\u003econtrollerDirection !\u003d Direction)) {\n    dVar1 \u003d (double)__subdf3(0,0,*(undefined4 *)\u0026this-\u003ekp,*(undefined4 *)((int)\u0026this-\u003ekp + 4));\n    this-\u003ekp \u003d dVar1;\n    dVar1 \u003d (double)__subdf3(0,0,*(undefined4 *)\u0026this-\u003eki,*(undefined4 *)((int)\u0026this-\u003eki + 4));\n    this-\u003eki \u003d dVar1;\n    dVar1 \u003d (double)__subdf3(0,0,*(undefined4 *)\u0026this-\u003ekd,*(undefined4 *)((int)\u0026this-\u003ekd + 4));\n    this-\u003ekd \u003d dVar1;\n  }\n  this-\u003econtrollerDirection \u003d Direction;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "PID"
      ],
      "called": [
        "__subdf3"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001ab0": {
      "entrypoint": "0x08001ab0",
      "current_name": "FUN_08001ab0",
      "code": "\n/* DWARF original prototype: PID *  PID(PID * this, double * Input, double * Output, double *\n   Setpoint, double Kp, double Ki, double Kd, int POn, int ControllerDirection) */\n\nPID * __thiscall\nPID::FUN_08001ab0(PID *this,double *Input,double *Output,double *Setpoint,double Kp,double Ki,\n                 double Kd,int POn,int ControllerDirection)\n\n{\n  uint32_t uVar1;\n  int POn_00;\n  undefined4 in_stack_ffffffe8;\n  undefined4 in_stack_ffffffec;\n  undefined4 in_stack_fffffff4;\n  \n  this-\u003emyOutput \u003d Output;\n  this-\u003emyInput \u003d Input;\n  this-\u003emySetpoint \u003d Setpoint;\n  this-\u003einAuto \u003d false;\n  SetOutputLimits(this,255.0,(double)CONCAT44(in_stack_ffffffec,in_stack_ffffffe8));\n  this-\u003eSampleTime \u003d 100;\n  SetControllerDirection(this,ControllerDirection);\n  SetTunings(this,Ki,Kd,(double)CONCAT44(in_stack_fffffff4,POn),POn_00);\n  uVar1 \u003d millis();\n  this-\u003elastTime \u003d uVar1 - this-\u003eSampleTime;\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "PID"
      ],
      "called": [
        "SetOutputLimits",
        "millis",
        "SetTunings",
        "SetControllerDirection"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001b18": {
      "entrypoint": "0x08001b18",
      "current_name": "FUN_08001b18",
      "code": "\n/* DWARF original prototype: PID *  PID(PID * this, double * Input, double * Output, double *\n   Setpoint, double Kp, double Ki, double Kd, int ControllerDirection) */\n\nPID * __thiscall\nPID::FUN_08001b18(PID *this,double *Input,double *Output,double *Setpoint,double Kp,double Ki,\n                 double Kd,int ControllerDirection)\n\n{\n  PID(this,Input,Output,Setpoint,Kp,Ki,Kd,1,ControllerDirection);\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "__static_initialization_and_destruction_0"
      ],
      "called": [
        "PID"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001b48": {
      "entrypoint": "0x08001b48",
      "current_name": "FUN_08001b48",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08001b48(void)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  RCC_PeriphCLKInitTypeDef PeriphClkInit;\n  RCC_ClkInitTypeDef RCC_ClkInitStruct;\n  RCC_OscInitTypeDef RCC_OscInitStruct;\n  \n  RCC_OscInitStruct.OscillatorType \u003d 2;\n  RCC_OscInitStruct.HSIState \u003d 1;\n  RCC_OscInitStruct.HSICalibrationValue \u003d 0x10;\n  RCC_OscInitStruct.PLL.PLLState \u003d 2;\n  RCC_OscInitStruct.PLL.PLLSource \u003d 0;\n  RCC_OscInitStruct.PLL.PLLMUL \u003d 0x380000;\n  HVar1 \u003d HAL_RCC_OscConfig((RCC_OscInitTypeDef_conflict *)\u0026RCC_OscInitStruct);\n  if (HVar1 !\u003d HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x88);\n  }\n  RCC_ClkInitStruct.ClockType \u003d 0xf;\n  RCC_ClkInitStruct.SYSCLKSource \u003d 2;\n  RCC_ClkInitStruct.AHBCLKDivider \u003d 0;\n  RCC_ClkInitStruct.APB1CLKDivider \u003d 0x400;\n  RCC_ClkInitStruct.APB2CLKDivider \u003d 0;\n  HVar1 \u003d HAL_RCC_ClockConfig((RCC_ClkInitTypeDef_conflict *)\u0026RCC_ClkInitStruct,2);\n  if (HVar1 !\u003d HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x95);\n  }\n  PeriphClkInit.PeriphClockSelection \u003d 2;\n  PeriphClkInit.AdcClockSelection \u003d 0x8000;\n  HVar1 \u003d HAL_RCCEx_PeriphCLKConfig((RCC_PeriphCLKInitTypeDef_conflict *)\u0026PeriphClkInit);\n  if (HVar1 !\u003d HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x9c);\n  }\n  uVar2 \u003d HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(uVar2 / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "hw_config_init"
      ],
      "called": [
        "HAL_RCCEx_PeriphCLKConfig",
        "HAL_NVIC_SetPriority",
        "HAL_RCC_GetHCLKFreq",
        "HAL_SYSTICK_CLKSourceConfig",
        "HAL_RCC_ClockConfig",
        "HAL_SYSTICK_Config",
        "_Error_Handler",
        "HAL_RCC_OscConfig"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001be8": {
      "entrypoint": "0x08001be8",
      "current_name": "FUN_08001be8",
      "code": "\nvoid FUN_08001be8(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  code *UNRECOVERED_JUMPTABLE;\n  \n  for (iVar1 \u003d 0; (undefined *)(iVar1 + 0x20000000) \u003c \u0026_edata; iVar1 \u003d iVar1 + 4) {\n    *(undefined4 *)(iVar1 + 0x20000000) \u003d *(undefined4 *)(\u0026_sidata + iVar1);\n  }\n  for (puVar2 \u003d \u0026completed_8667; puVar2 \u003c \u0026_ebss; puVar2 \u003d puVar2 + 1) {\n    *puVar2 \u003d 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  UNRECOVERED_JUMPTABLE \u003d (code *)0x8001c1a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08001c1a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__libc_init_array",
        "SystemInit",
        "main"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001c30": {
      "entrypoint": "0x08001c30",
      "current_name": "FUN_08001c30",
      "code": "\nvoid FUN_08001c30(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "USB_HP_CAN1_TX_IRQHandler"
      ],
      "called": [
        "USB_HP_CAN1_TX_IRQHandler"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001c32": {
      "entrypoint": "0x08001c32",
      "current_name": "FUN_08001c32",
      "code": "\nint FUN_08001c32(EVP_PKEY_CTX *ctx)\n\n{\n  hw_config_init();\n  return (int)ctx;\n}\n\n",
      "renaming": {},
      "calling": [
        "premain"
      ],
      "called": [
        "hw_config_init"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001c3a": {
      "entrypoint": "0x08001c3a",
      "current_name": "FUN_08001c3a",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08001c3a(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_Init"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001c3c": {
      "entrypoint": "0x08001c3c",
      "current_name": "FUN_08001c3c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08001c3c(uint32_t TickPriority)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 \u003d HAL_SYSTICK_Config((uint32_t)((ulonglong)SystemCoreClock / (1000 / (ulonglong)uwTickFreq))\n                            );\n  if (uVar1 !\u003d 0) {\n    return HAL_ERROR;\n  }\n  if (0xf \u003c TickPriority) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn,TickPriority,0);\n  uwTickPrio \u003d TickPriority;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_RCC_ClockConfig",
        "HAL_Init"
      ],
      "called": [
        "HAL_NVIC_SetPriority",
        "HAL_SYSTICK_Config"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001c88": {
      "entrypoint": "0x08001c88",
      "current_name": "FUN_08001c88",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08001c88(void)\n\n{\n  _DAT_40022000 \u003d _DAT_40022000 | 0x10;\n  HAL_NVIC_SetPriorityGrouping(3);\n  HAL_InitTick(0xf);\n  HAL_MspInit();\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "hw_config_init"
      ],
      "called": [
        "HAL_NVIC_SetPriorityGrouping",
        "HAL_MspInit",
        "HAL_InitTick"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001cac": {
      "entrypoint": "0x08001cac",
      "current_name": "FUN_08001cac",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08001cac(void)\n\n{\n  uwTick \u003d uwTickFreq + uwTick;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SysTick_Handler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001cc4": {
      "entrypoint": "0x08001cc4",
      "current_name": "FUN_08001cc4",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t FUN_08001cc4(void)\n\n{\n  return uwTick;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_RCCEx_PeriphCLKConfig",
        "ADC_ConversionStop_Disable",
        "HAL_ADC_PollForConversion",
        "GetCurrentMilli",
        "HAL_RCC_ClockConfig",
        "HAL_ADCEx_Calibration_Start",
        "UART_WaitOnFlagUntilTimeout",
        "HAL_UART_Transmit",
        "ADC_Enable",
        "HAL_RCC_OscConfig",
        "uart_debug_write"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001cd0": {
      "entrypoint": "0x08001cd0",
      "current_name": "FUN_08001cd0",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08001cd0(ADC_HandleTypeDef *hadc,uint32_t Timeout)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  int iVar4;\n  uint32_t uVar5;\n  ADC_TypeDef *pAVar6;\n  uint uVar7;\n  uint32_t Conversion_Timeout_CPU_cycles;\n  \n  Conversion_Timeout_CPU_cycles \u003d 0;\n  uVar2 \u003d HAL_GetTick();\n  uVar5 \u003d SystemCoreClock;\n  pAVar6 \u003d hadc-\u003eInstance;\n  if ((pAVar6-\u003eCR2 \u0026 0x100) \u003d\u003d 0) {\n    if (((pAVar6-\u003eCR1 \u0026 0x100) \u003d\u003d 0) \u0026\u0026 ((pAVar6-\u003eSQR1 \u0026 0xf00000) \u003d\u003d 0)) {\n      do {\n        if ((hadc-\u003eInstance-\u003eSR \u0026 2) !\u003d 0) goto LAB_08001de2;\n      } while ((Timeout \u003d\u003d 0xffffffff) ||\n              ((Timeout !\u003d 0 \u0026\u0026 (uVar5 \u003d HAL_GetTick(), uVar5 - uVar2 \u003c\u003d Timeout))));\n      hadc-\u003eState \u003d hadc-\u003eState | 4;\n      hadc-\u003eLock \u003d HAL_UNLOCKED;\n      HVar1 \u003d HAL_TIMEOUT;\n    }\n    else {\n      uVar3 \u003d HAL_RCCEx_GetPeriphCLKFreq(2);\n      pAVar6 \u003d hadc-\u003eInstance;\n      if (((pAVar6-\u003eSMPR2 \u0026 0x24924924) \u003d\u003d 0) \u0026\u0026 ((pAVar6-\u003eSMPR1 \u0026 0x924924) \u003d\u003d 0)) {\n        if ((pAVar6-\u003eSMPR2 \u0026 0x12492492) \u003d\u003d 0) {\n          if ((pAVar6-\u003eSMPR1 \u0026 0x492492) \u003d\u003d 0) {\n            iVar4 \u003d 0x14;\n          }\n          else {\n            iVar4 \u003d 0x29;\n          }\n        }\n        else {\n          iVar4 \u003d 0x29;\n        }\n      }\n      else if (((pAVar6-\u003eSMPR2 \u0026 0x12492492) \u003d\u003d 0) \u0026\u0026 ((pAVar6-\u003eSMPR1 \u0026 0x492492) \u003d\u003d 0)) {\n        iVar4 \u003d 0x54;\n      }\n      else if ((pAVar6-\u003eSMPR2 \u0026 0x249249) \u003d\u003d 0) {\n        if ((pAVar6-\u003eSMPR1 \u0026 0x249249) \u003d\u003d 0) {\n          iVar4 \u003d 0x54;\n        }\n        else {\n          iVar4 \u003d 0xfc;\n        }\n      }\n      else {\n        iVar4 \u003d 0xfc;\n      }\n      uVar7 \u003d (uVar5 / uVar3) * iVar4;\n      for (; Conversion_Timeout_CPU_cycles \u003c\u003d uVar7 \u0026\u0026 uVar7 - Conversion_Timeout_CPU_cycles !\u003d 0;\n          Conversion_Timeout_CPU_cycles \u003d Conversion_Timeout_CPU_cycles + 1) {\n        if ((Timeout !\u003d 0xffffffff) \u0026\u0026\n           ((Timeout \u003d\u003d 0 || (uVar5 \u003d HAL_GetTick(), Timeout \u003c uVar5 - uVar2)))) {\n          hadc-\u003eState \u003d hadc-\u003eState | 4;\n          hadc-\u003eLock \u003d HAL_UNLOCKED;\n          return HAL_TIMEOUT;\n        }\n      }\nLAB_08001de2:\n      hadc-\u003eInstance-\u003eSR \u003d 0xffffffed;\n      hadc-\u003eState \u003d hadc-\u003eState | 0x200;\n      if ((hadc-\u003eInstance-\u003eCR2 \u0026 0xe0000) \u003d\u003d 0xe0000) {\n        if ((hadc-\u003eInit).ContinuousConvMode \u003d\u003d 0) {\n          hadc-\u003eState \u003d hadc-\u003eState \u0026 0xfffffeff;\n          if ((hadc-\u003eState \u0026 0x1000) \u003d\u003d 0) {\n            hadc-\u003eState \u003d hadc-\u003eState | 1;\n            HVar1 \u003d HAL_OK;\n          }\n          else {\n            HVar1 \u003d HAL_OK;\n          }\n        }\n        else {\n          HVar1 \u003d HAL_OK;\n        }\n      }\n      else {\n        HVar1 \u003d HAL_OK;\n      }\n    }\n  }\n  else {\n    hadc-\u003eState \u003d hadc-\u003eState | 0x20;\n    hadc-\u003eLock \u003d HAL_UNLOCKED;\n    HVar1 \u003d HAL_ERROR;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [
        "HAL_GetTick",
        "HAL_RCCEx_GetPeriphCLKFreq"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001e40": {
      "entrypoint": "0x08001e40",
      "current_name": "FUN_08001e40",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t FUN_08001e40(ADC_HandleTypeDef *hadc)\n\n{\n  return hadc-\u003eInstance-\u003eDR;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001e48": {
      "entrypoint": "0x08001e48",
      "current_name": "FUN_08001e48",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08001e48(ADC_HandleTypeDef *hadc,ADC_ChannelConfTypeDef *sConfig)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint uVar2;\n  uint32_t wait_loop_index;\n  \n  if (hadc-\u003eLock \u003d\u003d HAL_LOCKED) {\n    HVar1 \u003d HAL_BUSY;\n  }\n  else {\n    hadc-\u003eLock \u003d HAL_LOCKED;\n    uVar2 \u003d sConfig-\u003eRank;\n    if (uVar2 \u003c 7) {\n      uVar2 \u003d uVar2 * 5 - 5;\n      hadc-\u003eInstance-\u003eSQR3 \u003d\n           sConfig-\u003eChannel \u003c\u003c (uVar2 \u0026 0xff) | hadc-\u003eInstance-\u003eSQR3 \u0026 ~(0x1f \u003c\u003c (uVar2 \u0026 0xff));\n    }\n    else if (uVar2 \u003c 0xd) {\n      uVar2 \u003d uVar2 * 5 - 0x23;\n      hadc-\u003eInstance-\u003eSQR2 \u003d\n           sConfig-\u003eChannel \u003c\u003c (uVar2 \u0026 0xff) | hadc-\u003eInstance-\u003eSQR2 \u0026 ~(0x1f \u003c\u003c (uVar2 \u0026 0xff));\n    }\n    else {\n      uVar2 \u003d uVar2 * 5 - 0x41;\n      hadc-\u003eInstance-\u003eSQR1 \u003d\n           sConfig-\u003eChannel \u003c\u003c (uVar2 \u0026 0xff) | hadc-\u003eInstance-\u003eSQR1 \u0026 ~(0x1f \u003c\u003c (uVar2 \u0026 0xff));\n    }\n    uVar2 \u003d sConfig-\u003eChannel;\n    if (uVar2 \u003c 10) {\n      hadc-\u003eInstance-\u003eSMPR2 \u003d\n           sConfig-\u003eSamplingTime \u003c\u003c (uVar2 * 3 \u0026 0xff) |\n           hadc-\u003eInstance-\u003eSMPR2 \u0026 ~(7 \u003c\u003c (uVar2 * 3 \u0026 0xff));\n    }\n    else {\n      uVar2 \u003d uVar2 * 3 - 0x1e;\n      hadc-\u003eInstance-\u003eSMPR1 \u003d\n           sConfig-\u003eSamplingTime \u003c\u003c (uVar2 \u0026 0xff) | hadc-\u003eInstance-\u003eSMPR1 \u0026 ~(7 \u003c\u003c (uVar2 \u0026 0xff));\n    }\n    if (sConfig-\u003eChannel - 0x10 \u003c 2) {\n      if (hadc-\u003eInstance \u003d\u003d (ADC_TypeDef *)0x40012400) {\n        if ((uRam40012408 \u0026 0x800000) \u003d\u003d 0) {\n          uRam40012408 \u003d uRam40012408 | 0x800000;\n          if (sConfig-\u003eChannel \u003d\u003d 0x10) {\n            for (wait_loop_index \u003d (SystemCoreClock / 1000000) * 10; wait_loop_index !\u003d 0;\n                wait_loop_index \u003d wait_loop_index - 1) {\n            }\n            HVar1 \u003d HAL_OK;\n          }\n          else {\n            HVar1 \u003d HAL_OK;\n          }\n        }\n        else {\n          HVar1 \u003d HAL_OK;\n        }\n      }\n      else {\n        hadc-\u003eState \u003d hadc-\u003eState | 0x20;\n        HVar1 \u003d HAL_ERROR;\n      }\n    }\n    else {\n      HVar1 \u003d HAL_OK;\n    }\n    hadc-\u003eLock \u003d HAL_UNLOCKED;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001f80": {
      "entrypoint": "0x08001f80",
      "current_name": "FUN_08001f80",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t FUN_08001f80(ADC_HandleTypeDef *hadc)\n\n{\n  return hadc-\u003eState;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08001f84": {
      "entrypoint": "0x08001f84",
      "current_name": "FUN_08001f84",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08001f84(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  ADC_TypeDef *pAVar4;\n  uint32_t wait_loop_index;\n  \n  pAVar4 \u003d hadc-\u003eInstance;\n  if ((pAVar4-\u003eCR2 \u0026 1) \u003d\u003d 0) {\n    pAVar4-\u003eCR2 \u003d pAVar4-\u003eCR2 | 1;\n    for (wait_loop_index \u003d SystemCoreClock / 1000000; wait_loop_index !\u003d 0;\n        wait_loop_index \u003d wait_loop_index - 1) {\n    }\n    uVar2 \u003d HAL_GetTick();\n    do {\n      if ((hadc-\u003eInstance-\u003eCR2 \u0026 1) !\u003d 0) {\n        return HAL_OK;\n      }\n      uVar3 \u003d HAL_GetTick();\n    } while (uVar3 - uVar2 \u003c 3);\n    hadc-\u003eState \u003d hadc-\u003eState | 0x10;\n    hadc-\u003eErrorCode \u003d hadc-\u003eErrorCode | 1;\n    hadc-\u003eLock \u003d HAL_UNLOCKED;\n    HVar1 \u003d HAL_ERROR;\n  }\n  else {\n    HVar1 \u003d HAL_OK;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_ADCEx_Calibration_Start",
        "HAL_ADC_Start"
      ],
      "called": [
        "HAL_GetTick"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002004": {
      "entrypoint": "0x08002004",
      "current_name": "FUN_08002004",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08002004(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  ADC_TypeDef *pAVar2;\n  \n  if (hadc-\u003eLock !\u003d HAL_LOCKED) {\n    hadc-\u003eLock \u003d HAL_LOCKED;\n    HVar1 \u003d ADC_Enable(hadc);\n    if (HVar1 \u003d\u003d HAL_OK) {\n      hadc-\u003eState \u003d hadc-\u003eState \u0026 0xfffffcfe | 0x100;\n      pAVar2 \u003d hadc-\u003eInstance;\n      if ((pAVar2 \u003d\u003d (ADC_TypeDef *)0x40012800) \u0026\u0026 ((_DAT_40012404 \u0026 0xf0000) !\u003d 0)) {\n        hadc-\u003eState \u003d hadc-\u003eState | 0x100000;\n        if ((_DAT_40012404 \u0026 0x400) !\u003d 0) {\n          hadc-\u003eState \u003d hadc-\u003eState \u0026 0xffffcfff | 0x1000;\n        }\n      }\n      else {\n        hadc-\u003eState \u003d hadc-\u003eState \u0026 0xffefffff;\n        if ((pAVar2-\u003eCR1 \u0026 0x400) !\u003d 0) {\n          hadc-\u003eState \u003d hadc-\u003eState \u0026 0xffffcfff | 0x1000;\n        }\n      }\n      if ((hadc-\u003eState \u0026 0x1000) \u003d\u003d 0) {\n        hadc-\u003eErrorCode \u003d 0;\n      }\n      else {\n        hadc-\u003eErrorCode \u003d hadc-\u003eErrorCode \u0026 0xfffffff9;\n      }\n      hadc-\u003eLock \u003d HAL_UNLOCKED;\n      pAVar2-\u003eSR \u003d 0xfffffffd;\n      pAVar2 \u003d hadc-\u003eInstance;\n      if (((pAVar2-\u003eCR2 \u0026 0xe0000) \u003d\u003d 0xe0000) \u0026\u0026\n         ((pAVar2 !\u003d (ADC_TypeDef *)0x40012800 || ((_DAT_40012404 \u0026 0xf0000) \u003d\u003d 0)))) {\n        pAVar2-\u003eCR2 \u003d pAVar2-\u003eCR2 | 0x500000;\n      }\n      else {\n        pAVar2-\u003eCR2 \u003d pAVar2-\u003eCR2 | 0x100000;\n      }\n    }\n    else {\n      hadc-\u003eLock \u003d HAL_UNLOCKED;\n    }\n    return HVar1;\n  }\n  return HAL_BUSY;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [
        "ADC_Enable"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080020f0": {
      "entrypoint": "0x080020f0",
      "current_name": "FUN_080020f0",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_080020f0(ADC_HandleTypeDef *hadc)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  ADC_TypeDef *pAVar3;\n  \n  pAVar3 \u003d hadc-\u003eInstance;\n  if ((pAVar3-\u003eCR2 \u0026 1) \u003d\u003d 0) {\n    return HAL_OK;\n  }\n  pAVar3-\u003eCR2 \u003d pAVar3-\u003eCR2 \u0026 0xfffffffe;\n  uVar1 \u003d HAL_GetTick();\n  do {\n    if ((hadc-\u003eInstance-\u003eCR2 \u0026 1) \u003d\u003d 0) {\n      return HAL_OK;\n    }\n    uVar2 \u003d HAL_GetTick();\n  } while (uVar2 - uVar1 \u003c 3);\n  hadc-\u003eState \u003d hadc-\u003eState | 0x10;\n  hadc-\u003eErrorCode \u003d hadc-\u003eErrorCode | 1;\n  return HAL_ERROR;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_ADC_DeInit",
        "HAL_ADCEx_Calibration_Start",
        "HAL_ADC_Stop",
        "HAL_ADC_Init"
      ],
      "called": [
        "HAL_GetTick"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800213c": {
      "entrypoint": "0x0800213c",
      "current_name": "FUN_0800213c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_0800213c(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint32_t uVar5;\n  \n  if (hadc \u003d\u003d (ADC_HandleTypeDef *)0x0) {\n    return HAL_ERROR;\n  }\n  if (hadc-\u003eState \u003d\u003d 0) {\n    hadc-\u003eErrorCode \u003d 0;\n    hadc-\u003eLock \u003d HAL_UNLOCKED;\n    HAL_ADC_MspInit(hadc);\n  }\n  HVar1 \u003d ADC_ConversionStop_Disable(hadc);\n  if (((hadc-\u003eState \u0026 0x10) \u003d\u003d 0) \u0026\u0026 (HVar1 \u003d\u003d HAL_OK)) {\n    hadc-\u003eState \u003d hadc-\u003eState \u0026 0xffffeefd | 2;\n    uVar5 \u003d (hadc-\u003eInit).ContinuousConvMode;\n    uVar3 \u003d (hadc-\u003eInit).DataAlign | (hadc-\u003eInit).ExternalTrigConv | uVar5 \u003c\u003c 1;\n    uVar2 \u003d (hadc-\u003eInit).ScanConvMode;\n    if (uVar2 \u003d\u003d 0x100) {\n      uVar4 \u003d 0x100;\n    }\n    else {\n      uVar4 \u003d 0;\n      if (uVar2 \u003d\u003d 1) {\n        uVar4 \u003d 0x100;\n      }\n    }\n    if ((hadc-\u003eInit).DiscontinuousConvMode \u003d\u003d 1) {\n      if (uVar5 \u003d\u003d 0) {\n        uVar4 \u003d uVar4 | ((hadc-\u003eInit).NbrOfDiscConversion - 1) * 0x2000 | 0x800;\n      }\n      else {\n        hadc-\u003eState \u003d hadc-\u003eState | 0x20;\n        hadc-\u003eErrorCode \u003d hadc-\u003eErrorCode | 1;\n      }\n    }\n    hadc-\u003eInstance-\u003eCR1 \u003d uVar4 | hadc-\u003eInstance-\u003eCR1 \u0026 0xffff16ff;\n    hadc-\u003eInstance-\u003eCR2 \u003d hadc-\u003eInstance-\u003eCR2 \u0026 0xffe1f7fd | uVar3;\n    uVar2 \u003d (hadc-\u003eInit).ScanConvMode;\n    if ((uVar2 \u003d\u003d 0x100) || (uVar2 \u003d\u003d 1)) {\n      uVar4 \u003d ((hadc-\u003eInit).NbrOfConversion - 1) * 0x100000;\n    }\n    else {\n      uVar4 \u003d 0;\n    }\n    hadc-\u003eInstance-\u003eSQR1 \u003d uVar4 | hadc-\u003eInstance-\u003eSQR1 \u0026 0xff0fffff;\n    if (uVar3 !\u003d (hadc-\u003eInstance-\u003eCR2 \u0026 0xff1f0efe)) {\n      hadc-\u003eState \u003d hadc-\u003eState \u0026 0xffffffed | 0x10;\n      hadc-\u003eErrorCode \u003d hadc-\u003eErrorCode | 1;\n      return HAL_ERROR;\n    }\n    hadc-\u003eErrorCode \u003d 0;\n    hadc-\u003eState \u003d hadc-\u003eState \u0026 0xfffffffc | 1;\n    return HAL_OK;\n  }\n  hadc-\u003eState \u003d hadc-\u003eState | 0x10;\n  return HAL_ERROR;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [
        "ADC_ConversionStop_Disable",
        "HAL_ADC_MspInit"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800224c": {
      "entrypoint": "0x0800224c",
      "current_name": "FUN_0800224c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_0800224c(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  \n  if (hadc \u003d\u003d (ADC_HandleTypeDef *)0x0) {\n    HVar1 \u003d HAL_ERROR;\n  }\n  else {\n    hadc-\u003eState \u003d hadc-\u003eState | 2;\n    HVar1 \u003d ADC_ConversionStop_Disable(hadc);\n    if (HVar1 \u003d\u003d HAL_OK) {\n      hadc-\u003eInstance-\u003eSR \u003d 0xffffffe0;\n      hadc-\u003eInstance-\u003eCR1 \u003d hadc-\u003eInstance-\u003eCR1 \u0026 0xff3f0000;\n      hadc-\u003eInstance-\u003eCR2 \u003d hadc-\u003eInstance-\u003eCR2 \u0026 0xff0106f0;\n      hadc-\u003eInstance-\u003eSMPR1 \u003d hadc-\u003eInstance-\u003eSMPR1 \u0026 0xff000000;\n      hadc-\u003eInstance-\u003eSMPR2 \u003d hadc-\u003eInstance-\u003eSMPR2 \u0026 0xc0000000;\n      hadc-\u003eInstance-\u003eJOFR1 \u003d hadc-\u003eInstance-\u003eJOFR1 \u0026 0xfffff000;\n      hadc-\u003eInstance-\u003eJOFR2 \u003d hadc-\u003eInstance-\u003eJOFR2 \u0026 0xfffff000;\n      hadc-\u003eInstance-\u003eJOFR3 \u003d hadc-\u003eInstance-\u003eJOFR3 \u0026 0xfffff000;\n      hadc-\u003eInstance-\u003eJOFR4 \u003d hadc-\u003eInstance-\u003eJOFR4 \u0026 0xfffff000;\n      hadc-\u003eInstance-\u003eHTR \u003d hadc-\u003eInstance-\u003eHTR \u0026 0xfffff000;\n      hadc-\u003eInstance-\u003eLTR \u003d hadc-\u003eInstance-\u003eLTR \u0026 0xfffff000;\n      hadc-\u003eInstance-\u003eSQR1 \u003d hadc-\u003eInstance-\u003eSQR1 \u0026 0xff000000;\n      hadc-\u003eInstance-\u003eSQR1 \u003d hadc-\u003eInstance-\u003eSQR1 \u0026 0xff000000;\n      hadc-\u003eInstance-\u003eSQR2 \u003d hadc-\u003eInstance-\u003eSQR2 \u0026 0xc0000000;\n      hadc-\u003eInstance-\u003eSQR3 \u003d hadc-\u003eInstance-\u003eSQR3 \u0026 0xc0000000;\n      hadc-\u003eInstance-\u003eJSQR \u003d hadc-\u003eInstance-\u003eJSQR \u0026 0xffc00000;\n      hadc-\u003eInstance-\u003eJSQR \u003d hadc-\u003eInstance-\u003eJSQR \u0026 0xffc00000;\n      HAL_ADC_MspDeInit(hadc);\n      hadc-\u003eErrorCode \u003d 0;\n      hadc-\u003eState \u003d 0;\n    }\n    hadc-\u003eLock \u003d HAL_UNLOCKED;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [
        "ADC_ConversionStop_Disable",
        "HAL_ADC_MspDeInit"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002348": {
      "entrypoint": "0x08002348",
      "current_name": "FUN_08002348",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08002348(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  \n  if (hadc-\u003eLock \u003d\u003d HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  hadc-\u003eLock \u003d HAL_LOCKED;\n  HVar1 \u003d ADC_ConversionStop_Disable(hadc);\n  if (HVar1 \u003d\u003d HAL_OK) {\n    hadc-\u003eState \u003d hadc-\u003eState \u0026 0xffffeefe | 1;\n  }\n  hadc-\u003eLock \u003d HAL_UNLOCKED;\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [
        "ADC_ConversionStop_Disable"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002384": {
      "entrypoint": "0x08002384",
      "current_name": "FUN_08002384",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08002384(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  ADC_TypeDef *pAVar4;\n  uint32_t tickstart;\n  uint32_t wait_loop_index;\n  \n  if (hadc-\u003eLock \u003d\u003d HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  hadc-\u003eLock \u003d HAL_LOCKED;\n  HVar1 \u003d ADC_ConversionStop_Disable(hadc);\n  if (HVar1 \u003d\u003d HAL_OK) {\n    hadc-\u003eState \u003d hadc-\u003eState \u0026 0xffffeefd | 2;\n    uVar3 \u003d SystemCoreClock;\n    uVar2 \u003d HAL_RCCEx_GetPeriphCLKFreq(2);\n    for (wait_loop_index \u003d uVar3 / uVar2 \u003c\u003c 1; wait_loop_index !\u003d 0;\n        wait_loop_index \u003d wait_loop_index - 1) {\n    }\n    ADC_Enable(hadc);\n    hadc-\u003eInstance-\u003eCR2 \u003d hadc-\u003eInstance-\u003eCR2 | 8;\n    uVar3 \u003d HAL_GetTick();\n    while (pAVar4 \u003d hadc-\u003eInstance, (pAVar4-\u003eCR2 \u0026 8) !\u003d 0) {\n      uVar2 \u003d HAL_GetTick();\n      if (10 \u003c uVar2 - uVar3) {\n        hadc-\u003eState \u003d hadc-\u003eState \u0026 0xffffffed | 0x10;\n        hadc-\u003eLock \u003d HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    pAVar4-\u003eCR2 \u003d pAVar4-\u003eCR2 | 4;\n    uVar3 \u003d HAL_GetTick();\n    while ((hadc-\u003eInstance-\u003eCR2 \u0026 4) !\u003d 0) {\n      uVar2 \u003d HAL_GetTick();\n      if (10 \u003c uVar2 - uVar3) {\n        hadc-\u003eState \u003d hadc-\u003eState \u0026 0xffffffed | 0x10;\n        hadc-\u003eLock \u003d HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    hadc-\u003eState \u003d hadc-\u003eState \u0026 0xfffffffc | 1;\n  }\n  hadc-\u003eLock \u003d HAL_UNLOCKED;\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [
        "HAL_GetTick",
        "ADC_ConversionStop_Disable",
        "HAL_RCCEx_GetPeriphCLKFreq",
        "ADC_Enable"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002470": {
      "entrypoint": "0x08002470",
      "current_name": "FUN_08002470",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08002470(uint32_t PriorityGroup)\n\n{\n  uint32_t reg_value;\n  \n  _DAT_e000ed0c \u003d (PriorityGroup \u0026 7) \u003c\u003c 8 | _DAT_e000ed0c \u0026 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "premain",
        "HAL_Init"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002494": {
      "entrypoint": "0x08002494",
      "current_name": "FUN_08002494",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08002494(IRQn_Type_conflict IRQn,uint32_t PreemptPriority,uint32_t SubPriority)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint32_t PriorityGroupTmp;\n  uint32_t SubPriorityBits;\n  uint32_t PreemptPriorityBits;\n  \n  uVar1 \u003d (uint)IRQn;\n  uVar2 \u003d (uint)(_DAT_e000ed0c \u003c\u003c 0x15) \u003e\u003e 0x1d;\n  PreemptPriorityBits \u003d 7 - uVar2;\n  if (3 \u003c PreemptPriorityBits) {\n    PreemptPriorityBits \u003d 4;\n  }\n  if (uVar2 + 4 \u003c 7) {\n    SubPriorityBits \u003d 0;\n  }\n  else {\n    SubPriorityBits \u003d uVar2 - 3;\n  }\n  uVar2 \u003d (PreemptPriority \u0026 (1 \u003c\u003c (PreemptPriorityBits \u0026 0xff)) - 1U) \u003c\u003c (SubPriorityBits \u0026 0xff) |\n          (1 \u003c\u003c (SubPriorityBits \u0026 0xff)) - 1U \u0026 SubPriority;\n  if ((int)uVar1 \u003c 0) {\n    *(char *)((uVar1 \u0026 0xf) + 0xe000ed14) \u003d (char)(uVar2 \u003c\u003c 4);\n  }\n  else {\n    *(char *)(uVar1 + 0xe000e400) \u003d (char)(uVar2 \u003c\u003c 4);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_attach_tx_callback",
        "uart_attach_rx_callback",
        "SystemClock_Config",
        "HAL_InitTick"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080024f8": {
      "entrypoint": "0x080024f8",
      "current_name": "FUN_080024f8",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_080024f8(IRQn_Type_conflict IRQn)\n\n{\n  uint uVar1;\n  \n  uVar1 \u003d (uint)IRQn;\n  if (-1 \u003c (int)uVar1) {\n    *(int *)((uVar1 \u003e\u003e 5) * 4 + -0x1fff1f00) \u003d 1 \u003c\u003c (uVar1 \u0026 0x1f);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_attach_tx_callback",
        "uart_attach_rx_callback"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002514": {
      "entrypoint": "0x08002514",
      "current_name": "FUN_08002514",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t FUN_08002514(uint32_t TicksNumb)\n\n{\n  if (TicksNumb - 1 \u003c 0x1000000) {\n    _DAT_e000e014 \u003d TicksNumb - 1;\n    DAT_e000ed23 \u003d 0xf0;\n    _DAT_e000e018 \u003d 0;\n    _DAT_e000e010 \u003d 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "SystemClock_Config",
        "HAL_InitTick"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002540": {
      "entrypoint": "0x08002540",
      "current_name": "FUN_08002540",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08002540(IRQn_Type_conflict IRQn)\n\n{\n  uint uVar1;\n  \n  uVar1 \u003d (uint)IRQn;\n  if (-1 \u003c (int)uVar1) {\n    *(int *)(((uVar1 \u003e\u003e 5) + 0x60) * 4 + -0x1fff1f00) \u003d 1 \u003c\u003c (uVar1 \u0026 0x1f);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "USART2_IRQHandler",
        "USART3_IRQHandler",
        "USART1_IRQHandler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002560": {
      "entrypoint": "0x08002560",
      "current_name": "FUN_08002560",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08002560(uint32_t CLKSource)\n\n{\n  if (CLKSource !\u003d 4) {\n    _DAT_e000e010 \u003d _DAT_e000e010 \u0026 0xfffffffb;\n    return;\n  }\n  _DAT_e000e010 \u003d _DAT_e000e010 | 4;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SystemClock_Config"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002580": {
      "entrypoint": "0x08002580",
      "current_name": "FUN_08002580",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08002580(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_SYSTICK_IRQHandler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002582": {
      "entrypoint": "0x08002582",
      "current_name": "FUN_08002582",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08002582(void)\n\n{\n  HAL_SYSTICK_Callback();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SysTick_Handler"
      ],
      "called": [
        "HAL_SYSTICK_Callback"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800258c": {
      "entrypoint": "0x0800258c",
      "current_name": "FUN_0800258c",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_0800258c(DMA_HandleTypeDef *hdma)\n\n{\n  DMA_Channel_TypeDef *pDVar1;\n  \n  if (hdma-\u003eState !\u003d HAL_DMA_STATE_BUSY) {\n    hdma-\u003eErrorCode \u003d 4;\n    return HAL_ERROR;\n  }\n  hdma-\u003eInstance-\u003eCCR \u003d hdma-\u003eInstance-\u003eCCR \u0026 0xfffffff1;\n  hdma-\u003eInstance-\u003eCCR \u003d hdma-\u003eInstance-\u003eCCR \u0026 0xfffffffe;\n  pDVar1 \u003d hdma-\u003eInstance;\n  if (pDVar1 \u003d\u003d (DMA_Channel_TypeDef *)0x40020008) {\n    _DAT_40020004 \u003d 1;\n  }\n  else if (pDVar1 \u003d\u003d (DMA_Channel_TypeDef *)0x4002001c) {\n    _DAT_40020004 \u003d 0x10;\n  }\n  else if (pDVar1 \u003d\u003d (DMA_Channel_TypeDef *)0x40020030) {\n    _DAT_40020004 \u003d 0x100;\n  }\n  else if (pDVar1 \u003d\u003d (DMA_Channel_TypeDef *)0x40020044) {\n    _DAT_40020004 \u003d 0x1000;\n  }\n  else if (pDVar1 \u003d\u003d (DMA_Channel_TypeDef *)0x40020058) {\n    _DAT_40020004 \u003d 0x10000;\n  }\n  else if (pDVar1 \u003d\u003d (DMA_Channel_TypeDef *)0x4002006c) {\n    _DAT_40020004 \u003d 0x100000;\n  }\n  else {\n    _DAT_40020004 \u003d 0x1000000;\n  }\n  hdma-\u003eState \u003d HAL_DMA_STATE_READY;\n  hdma-\u003eLock \u003d HAL_UNLOCKED;\n  if (hdma-\u003eXferAbortCallback !\u003d (_func_void___DMA_HandleTypeDef_ptr *)0x0) {\n    (*hdma-\u003eXferAbortCallback)(hdma);\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_ITError",
        "HAL_UART_IRQHandler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002624": {
      "entrypoint": "0x08002624",
      "current_name": "FUN_08002624",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08002624(GPIO_TypeDef *GPIOx,GPIO_InitTypeDef *GPIO_Init)\n\n{\n  GPIO_TypeDef *pGVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint32_t uVar6;\n  int iVar7;\n  uint32_t *configregister;\n  int iVar8;\n  uint32_t tmpreg;\n  \n  uVar6 \u003d 0;\n  uVar4 \u003d 0;\n  do {\n    if (0xf \u003c uVar4) {\n      return;\n    }\n    uVar2 \u003d 1 \u003c\u003c (uVar4 \u0026 0xff);\n    uVar3 \u003d GPIO_Init-\u003ePin \u0026 uVar2;\n    if (uVar2 \u003d\u003d uVar3) {\n      uVar5 \u003d GPIO_Init-\u003eMode;\n      if (uVar5 \u003d\u003d 0x12) {\n        uVar6 \u003d GPIO_Init-\u003eSpeed + 0xc;\n      }\n      else if (uVar5 \u003c 0x13) {\n        if (uVar5 \u003d\u003d 2) {\n          uVar6 \u003d GPIO_Init-\u003eSpeed + 8;\n        }\n        else if (uVar5 \u003c 3) {\n          if (uVar5 \u003d\u003d 0) goto LAB_08002776;\n          if (uVar5 \u003d\u003d 1) {\n            uVar6 \u003d GPIO_Init-\u003eSpeed;\n          }\n        }\n        else if (uVar5 \u003d\u003d 3) {\n          uVar6 \u003d 0;\n        }\n        else if (uVar5 \u003d\u003d 0x11) {\n          uVar6 \u003d GPIO_Init-\u003eSpeed + 4;\n        }\n      }\n      else if (uVar5 \u003d\u003d 0x10210000) {\nLAB_08002776:\n        if (GPIO_Init-\u003ePull \u003d\u003d 0) {\n          uVar6 \u003d 4;\n        }\n        else if (GPIO_Init-\u003ePull \u003d\u003d 1) {\n          GPIOx-\u003eBSRR \u003d uVar2;\n          uVar6 \u003d 8;\n        }\n        else {\n          GPIOx-\u003eBRR \u003d uVar2;\n          uVar6 \u003d 8;\n        }\n      }\n      else if (uVar5 \u003c 0x10210001) {\n        if ((uVar5 \u003d\u003d 0x10110000) || (uVar5 \u003d\u003d 0x10120000)) goto LAB_08002776;\n      }\n      else if ((uVar5 \u003d\u003d 0x10310000) || ((uVar5 \u003d\u003d 0x10320000 || (uVar5 \u003d\u003d 0x10220000))))\n      goto LAB_08002776;\n      uVar2 \u003d uVar4;\n      pGVar1 \u003d GPIOx;\n      if (0xff \u003c uVar3) {\n        uVar2 \u003d uVar4 - 8;\n        pGVar1 \u003d (GPIO_TypeDef *)\u0026GPIOx-\u003eCRH;\n      }\n      pGVar1-\u003eCRL \u003d pGVar1-\u003eCRL \u0026 ~(0xf \u003c\u003c (uVar2 \u003c\u003c 2 \u0026 0xff)) | uVar6 \u003c\u003c (uVar2 \u003c\u003c 2 \u0026 0xff);\n      if ((GPIO_Init-\u003eMode \u0026 0x10000000) !\u003d 0) {\n        _DAT_40021018 \u003d _DAT_40021018 | 1;\n        iVar7 \u003d (uVar4 \u0026 3) \u003c\u003c 2;\n        if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40010800) {\n          iVar8 \u003d 0;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40010c00) {\n          iVar8 \u003d 1;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40011000) {\n          iVar8 \u003d 2;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40011400) {\n          iVar8 \u003d 3;\n        }\n        else {\n          iVar8 \u003d 4;\n        }\n        *(uint *)(((uVar4 \u003e\u003e 2) + 2) * 4 + 0x40010000) \u003d\n             *(uint *)(((uVar4 \u003e\u003e 2) + 2) * 4 + 0x40010000) \u0026 ~(0xf \u003c\u003c iVar7) | iVar8 \u003c\u003c iVar7;\n        if ((GPIO_Init-\u003eMode \u0026 0x10000) \u003d\u003d 0) {\n          _DAT_40010400 \u003d _DAT_40010400 \u0026 ~uVar3;\n        }\n        else {\n          _DAT_40010400 \u003d _DAT_40010400 | uVar3;\n        }\n        if ((GPIO_Init-\u003eMode \u0026 0x20000) \u003d\u003d 0) {\n          _DAT_40010404 \u003d _DAT_40010404 \u0026 ~uVar3;\n        }\n        else {\n          _DAT_40010404 \u003d _DAT_40010404 | uVar3;\n        }\n        if ((GPIO_Init-\u003eMode \u0026 0x100000) \u003d\u003d 0) {\n          _DAT_40010408 \u003d _DAT_40010408 \u0026 ~uVar3;\n        }\n        else {\n          _DAT_40010408 \u003d _DAT_40010408 | uVar3;\n        }\n        if ((GPIO_Init-\u003eMode \u0026 0x200000) \u003d\u003d 0) {\n          _DAT_4001040c \u003d _DAT_4001040c \u0026 ~uVar3;\n        }\n        else {\n          _DAT_4001040c \u003d uVar3 | _DAT_4001040c;\n        }\n      }\n    }\n    uVar4 \u003d uVar4 + 1;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "digital_io_init",
        "uart_init",
        "HAL_ADC_MspInit"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002810": {
      "entrypoint": "0x08002810",
      "current_name": "FUN_08002810",
      "code": "\n/* WARNING: Unknown calling convention */\n\nGPIO_PinState FUN_08002810(GPIO_TypeDef *GPIOx,uint16_t GPIO_Pin)\n\n{\n  GPIO_PinState bitstatus;\n  \n  if (((uint)GPIO_Pin \u0026 GPIOx-\u003eIDR) \u003d\u003d 0) {\n    bitstatus \u003d GPIO_PIN_RESET;\n    return bitstatus;\n  }\n  return GPIO_PIN_SET;\n}\n\n",
      "renaming": {},
      "calling": [
        "digital_io_read"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800281e": {
      "entrypoint": "0x0800281e",
      "current_name": "FUN_0800281e",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_0800281e(GPIO_TypeDef *GPIOx,uint16_t GPIO_Pin,GPIO_PinState PinState)\n\n{\n  if (PinState \u003d\u003d GPIO_PIN_RESET) {\n    GPIOx-\u003eBSRR \u003d (uint)GPIO_Pin \u003c\u003c 0x10;\n    return;\n  }\n  GPIOx-\u003eBSRR \u003d (uint)GPIO_Pin;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "digital_io_write"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800282c": {
      "entrypoint": "0x0800282c",
      "current_name": "FUN_0800282c",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid FUN_0800282c(uint16_t GPIO_Pin)\n\n{\n  if ((_DAT_40010414 \u0026 GPIO_Pin) !\u003d 0) {\n    _DAT_40010414 \u003d (uint)GPIO_Pin;\n    HAL_GPIO_EXTI_Callback(GPIO_Pin);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "EXTI4_IRQHandler",
        "EXTI3_IRQHandler",
        "EXTI15_10_IRQHandler",
        "EXTI2_IRQHandler",
        "EXTI9_5_IRQHandler",
        "EXTI0_IRQHandler",
        "EXTI1_IRQHandler"
      ],
      "called": [
        "HAL_GPIO_EXTI_Callback"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002848": {
      "entrypoint": "0x08002848",
      "current_name": "FUN_08002848",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08002848(I2C_HandleTypeDef *hi2c)\n\n{\n  if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM) {\n    if (hi2c-\u003eEventCount \u003d\u003d 0) {\n      hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eDevaddress \u0026 0xfe;\n    }\n    else {\n      hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eDevaddress \u0026 0xff | 1;\n    }\n  }\n  else if ((hi2c-\u003eInit).AddressingMode \u003d\u003d 0x4000) {\n    if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_TX) {\n      hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eDevaddress \u0026 0xfe;\n    }\n    else {\n      hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eDevaddress \u0026 0xff | 1;\n    }\n  }\n  else if (hi2c-\u003eEventCount \u003d\u003d 0) {\n    hi2c-\u003eInstance-\u003eDR \u003d (hi2c-\u003eDevaddress \u003c\u003c 0x10) \u003e\u003e 0x17 \u0026 6 | 0xf0;\n  }\n  else if (hi2c-\u003eEventCount \u003d\u003d 1) {\n    hi2c-\u003eInstance-\u003eDR \u003d (hi2c-\u003eDevaddress \u003c\u003c 0x10) \u003e\u003e 0x17 \u0026 6 | 0xf1;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080028d2": {
      "entrypoint": "0x080028d2",
      "current_name": "FUN_080028d2",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_080028d2(I2C_HandleTypeDef *hi2c)\n\n{\n  hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eDevaddress \u0026 0xff;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080028de": {
      "entrypoint": "0x080028de",
      "current_name": "FUN_080028de",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_080028de(I2C_HandleTypeDef *hi2c)\n\n{\n  uint32_t CurrentXferOptions;\n  uint32_t uVar1;\n  I2C_TypeDef *pIVar2;\n  uint32_t Prev_State;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  uint32_t tmpreg_10;\n  \n  uVar1 \u003d hi2c-\u003eXferOptions;\n  if ((hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_RX) \u0026\u0026\n     ((hi2c-\u003eEventCount !\u003d 0 || (hi2c-\u003eMode !\u003d HAL_I2C_MODE_MEM)))) {\n    if ((hi2c-\u003eEventCount \u003d\u003d 0) \u0026\u0026 ((hi2c-\u003eInit).AddressingMode \u003d\u003d 0xc000)) {\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x100;\n      hi2c-\u003eEventCount \u003d hi2c-\u003eEventCount + 1;\n    }\n    else {\n      if (hi2c-\u003eXferCount \u003d\u003d 0) {\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x200;\n      }\n      else if (hi2c-\u003eXferCount \u003d\u003d 1) {\n        if (uVar1 \u003d\u003d 0xffff0000) {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n          pIVar2 \u003d hi2c-\u003eInstance;\n          if ((pIVar2-\u003eCR2 \u0026 0x800) \u003d\u003d 0) {\n            pIVar2-\u003eCR1 \u003d pIVar2-\u003eCR1 | 0x200;\n          }\n          else {\n            pIVar2-\u003eCR1 \u003d pIVar2-\u003eCR1 \u0026 0xfffffbff;\n          }\n        }\n        else if (((uVar1 \u003d\u003d 4) || (uVar1 \u003d\u003d 8)) || (hi2c-\u003ePreviousState \u003d\u003d 0x12)) {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x200;\n        }\n        else if (hi2c-\u003eXferOptions \u003d\u003d 2) {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x400;\n        }\n        else {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n        }\n      }\n      else if (hi2c-\u003eXferCount \u003d\u003d 2) {\n        if (hi2c-\u003eXferOptions \u003d\u003d 2) {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x400;\n        }\n        else {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x800;\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n        }\n        pIVar2 \u003d hi2c-\u003eInstance;\n        if ((pIVar2-\u003eCR2 \u0026 0x800) !\u003d 0) {\n          pIVar2-\u003eCR2 \u003d pIVar2-\u003eCR2 | 0x1000;\n        }\n      }\n      else {\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x400;\n        pIVar2 \u003d hi2c-\u003eInstance;\n        if ((pIVar2-\u003eCR2 \u0026 0x800) !\u003d 0) {\n          pIVar2-\u003eCR2 \u003d pIVar2-\u003eCR2 | 0x1000;\n        }\n      }\n      hi2c-\u003eEventCount \u003d 0;\n    }\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002ab8": {
      "entrypoint": "0x08002ab8",
      "current_name": "FUN_08002ab8",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08002ab8(I2C_HandleTypeDef *hi2c)\n\n{\n  byte *pbVar1;\n  \n  if (hi2c-\u003eXferCount !\u003d 0) {\n    pbVar1 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d pbVar1 + 1;\n    hi2c-\u003eInstance-\u003eDR \u003d (uint)*pbVar1;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002ad8": {
      "entrypoint": "0x08002ad8",
      "current_name": "FUN_08002ad8",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08002ad8(I2C_HandleTypeDef *hi2c)\n\n{\n  uint8_t *puVar1;\n  \n  if (hi2c-\u003eXferCount !\u003d 0) {\n    puVar1 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d puVar1 + 1;\n    *puVar1 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002af8": {
      "entrypoint": "0x08002af8",
      "current_name": "FUN_08002af8",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nFUN_08002af8(I2C_HandleTypeDef *hi2c,uint8_t *pData,uint16_t Size,uint32_t XferOptions)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  I2C_TypeDef *pIVar2;\n  uint32_t tmpreg;\n  \n  if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_LISTEN) {\n    if (pData \u003d\u003d (uint8_t *)0x0) {\n      HVar1 \u003d HAL_ERROR;\n    }\n    else if (Size \u003d\u003d 0) {\n      HVar1 \u003d HAL_ERROR;\n    }\n    else if (hi2c-\u003eLock \u003d\u003d HAL_LOCKED) {\n      HVar1 \u003d HAL_BUSY;\n    }\n    else {\n      hi2c-\u003eLock \u003d HAL_LOCKED;\n      pIVar2 \u003d hi2c-\u003eInstance;\n      if ((pIVar2-\u003eCR1 \u0026 1) \u003d\u003d 0) {\n        pIVar2-\u003eCR1 \u003d pIVar2-\u003eCR1 | 1;\n      }\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffff7ff;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_BUSY_TX_LISTEN;\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_SLAVE;\n      HVar1 \u003d HAL_OK;\n      hi2c-\u003eErrorCode \u003d 0;\n      hi2c-\u003epBuffPtr \u003d pData;\n      hi2c-\u003eXferCount \u003d Size;\n      hi2c-\u003eXferOptions \u003d XferOptions;\n      hi2c-\u003eXferSize \u003d hi2c-\u003eXferCount;\n      hi2c-\u003eLock \u003d HAL_UNLOCKED;\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 | 0x700;\n    }\n  }\n  else {\n    HVar1 \u003d HAL_BUSY;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_AddrCallback"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002b84": {
      "entrypoint": "0x08002b84",
      "current_name": "FUN_08002b84",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nFUN_08002b84(I2C_HandleTypeDef *hi2c,uint8_t *pData,uint16_t Size,uint32_t XferOptions)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  I2C_TypeDef *pIVar2;\n  uint32_t tmpreg;\n  \n  if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_LISTEN) {\n    if (pData \u003d\u003d (uint8_t *)0x0) {\n      HVar1 \u003d HAL_ERROR;\n    }\n    else if (Size \u003d\u003d 0) {\n      HVar1 \u003d HAL_ERROR;\n    }\n    else if (hi2c-\u003eLock \u003d\u003d HAL_LOCKED) {\n      HVar1 \u003d HAL_BUSY;\n    }\n    else {\n      hi2c-\u003eLock \u003d HAL_LOCKED;\n      pIVar2 \u003d hi2c-\u003eInstance;\n      if ((pIVar2-\u003eCR1 \u0026 1) \u003d\u003d 0) {\n        pIVar2-\u003eCR1 \u003d pIVar2-\u003eCR1 | 1;\n      }\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffff7ff;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_BUSY_RX_LISTEN;\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_SLAVE;\n      HVar1 \u003d HAL_OK;\n      hi2c-\u003eErrorCode \u003d 0;\n      hi2c-\u003epBuffPtr \u003d pData;\n      hi2c-\u003eXferCount \u003d Size;\n      hi2c-\u003eXferOptions \u003d XferOptions;\n      hi2c-\u003eXferSize \u003d hi2c-\u003eXferCount;\n      hi2c-\u003eLock \u003d HAL_UNLOCKED;\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 | 0x700;\n    }\n  }\n  else {\n    HVar1 \u003d HAL_BUSY;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_AddrCallback"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002c10": {
      "entrypoint": "0x08002c10",
      "current_name": "FUN_08002c10",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08002c10(I2C_HandleTypeDef *hi2c)\n\n{\n  I2C_TypeDef *pIVar1;\n  \n  if (hi2c-\u003eState !\u003d HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  hi2c-\u003eState \u003d HAL_I2C_STATE_LISTEN;\n  pIVar1 \u003d hi2c-\u003eInstance;\n  if ((pIVar1-\u003eCR1 \u0026 1) \u003d\u003d 0) {\n    pIVar1-\u003eCR1 \u003d pIVar1-\u003eCR1 | 1;\n  }\n  hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x400;\n  hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 | 0x300;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_ListenCpltCallback",
        "HAL_I2C_ErrorCallback"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002c4e": {
      "entrypoint": "0x08002c4e",
      "current_name": "FUN_08002c4e",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08002c4e(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_MasterTransmit_BTF",
        "I2C_MasterTransmit_TXE"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002c50": {
      "entrypoint": "0x08002c50",
      "current_name": "FUN_08002c50",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08002c50(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_MasterReceive_BTF",
        "I2C_MasterReceive_RXNE"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002c52": {
      "entrypoint": "0x08002c52",
      "current_name": "FUN_08002c52",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08002c52(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_SlaveTransmit_TXE",
        "I2C_Slave_AF"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002c54": {
      "entrypoint": "0x08002c54",
      "current_name": "FUN_08002c54",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08002c54(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  byte *pbVar2;\n  \n  HVar1 \u003d hi2c-\u003eState;\n  if (hi2c-\u003eXferCount !\u003d 0) {\n    pbVar2 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d pbVar2 + 1;\n    hi2c-\u003eInstance-\u003eDR \u003d (uint)*pbVar2;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    if ((hi2c-\u003eXferCount \u003d\u003d 0) \u0026\u0026 (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffffbff;\n      hi2c-\u003ePreviousState \u003d 0x21;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(hi2c);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_SlaveTxCpltCallback"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002ca4": {
      "entrypoint": "0x08002ca4",
      "current_name": "FUN_08002ca4",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08002ca4(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_SlaveReceive_RXNE",
        "I2C_Slave_STOPF"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002ca6": {
      "entrypoint": "0x08002ca6",
      "current_name": "FUN_08002ca6",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08002ca6(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  uint8_t *puVar2;\n  \n  HVar1 \u003d hi2c-\u003eState;\n  if (hi2c-\u003eXferCount !\u003d 0) {\n    puVar2 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n    *puVar2 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    if ((hi2c-\u003eXferCount \u003d\u003d 0) \u0026\u0026 (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffffbff;\n      hi2c-\u003ePreviousState \u003d 0x22;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveRxCpltCallback(hi2c);\n    }\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_SlaveRxCpltCallback"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002cf2": {
      "entrypoint": "0x08002cf2",
      "current_name": "FUN_08002cf2",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08002cf2(I2C_HandleTypeDef *hi2c)\n\n{\n  uint16_t AddrMatchCode;\n  \n  if ((hi2c-\u003eInstance-\u003eSR2 \u0026 0x80) \u003d\u003d 0) {\n    AddrMatchCode \u003d *(uint16_t *)\u0026(hi2c-\u003eInit).OwnAddress1;\n  }\n  else {\n    AddrMatchCode \u003d *(uint16_t *)\u0026(hi2c-\u003eInit).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(hi2c,(hi2c-\u003eInstance-\u003eSR2 \u0026 4) \u003d\u003d 0,AddrMatchCode);\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_AddrCallback"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002d1c": {
      "entrypoint": "0x08002d1c",
      "current_name": "FUN_08002d1c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08002d1c(I2C_HandleTypeDef *hi2c)\n\n{\n  uint32_t CurrentXferOptions;\n  uint32_t CurrentState;\n  \n  if (((hi2c-\u003eXferOptions \u003d\u003d 4) || (hi2c-\u003eXferOptions \u003d\u003d 8)) \u0026\u0026\n     (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_LISTEN)) {\n    hi2c-\u003eXferOptions \u003d 0xffff0000;\n    hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n    hi2c-\u003eInstance-\u003eSR1 \u003d 0xfffffbff;\n    hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n    hi2c-\u003ePreviousState \u003d 0;\n    hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n    hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(hi2c);\n  }\n  else if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_TX) {\n    hi2c-\u003eXferOptions \u003d 0xffff0000;\n    hi2c-\u003ePreviousState \u003d 0x21;\n    hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n    hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n    hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n    hi2c-\u003eInstance-\u003eSR1 \u003d 0xfffffbff;\n    hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback(hi2c);\n  }\n  else {\n    hi2c-\u003eInstance-\u003eSR1 \u003d 0xfffffbff;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_ER_IRQHandler"
      ],
      "called": [
        "HAL_I2C_SlaveTxCpltCallback",
        "HAL_I2C_ListenCpltCallback"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002db0": {
      "entrypoint": "0x08002db0",
      "current_name": "FUN_08002db0",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08002db0(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_MasterTransmit_BTF",
        "I2C_MasterTransmit_TXE"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002db2": {
      "entrypoint": "0x08002db2",
      "current_name": "FUN_08002db2",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08002db2(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  uint32_t CurrentState;\n  byte *pbVar2;\n  uint32_t CurrentXferOptions;\n  uint32_t uVar3;\n  \n  HVar1 \u003d hi2c-\u003eState;\n  uVar3 \u003d hi2c-\u003eXferOptions;\n  if ((hi2c-\u003eXferSize \u003d\u003d 0) \u0026\u0026 (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_TX)) {\n    if ((uVar3 \u003d\u003d 4) || ((uVar3 \u003d\u003d 8 || (uVar3 \u003d\u003d 0xffff0000)))) {\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x200;\n      hi2c-\u003ePreviousState \u003d 0;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n      if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM) {\n        hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(hi2c);\n      }\n      else {\n        hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(hi2c);\n      }\n    }\n    else {\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n      hi2c-\u003ePreviousState \u003d 0x11;\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(hi2c);\n    }\n  }\n  else if ((HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_TX) ||\n          ((hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM \u0026\u0026 (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_RX)))) {\n    if (hi2c-\u003eXferCount \u003d\u003d 0) {\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffffbff;\n    }\n    else if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM) {\n      if (hi2c-\u003eEventCount \u003d\u003d 0) {\n        if (hi2c-\u003eMemaddSize \u003d\u003d 1) {\n          hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eMemaddress \u0026 0xff;\n          hi2c-\u003eEventCount \u003d hi2c-\u003eEventCount + 2;\n        }\n        else {\n          hi2c-\u003eInstance-\u003eDR \u003d (hi2c-\u003eMemaddress \u003c\u003c 0x10) \u003e\u003e 0x18;\n          hi2c-\u003eEventCount \u003d hi2c-\u003eEventCount + 1;\n        }\n      }\n      else if (hi2c-\u003eEventCount \u003d\u003d 1) {\n        hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eMemaddress \u0026 0xff;\n        hi2c-\u003eEventCount \u003d hi2c-\u003eEventCount + 1;\n      }\n      else if (hi2c-\u003eEventCount \u003d\u003d 2) {\n        if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_RX) {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x100;\n        }\n        else if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_TX) {\n          pbVar2 \u003d hi2c-\u003epBuffPtr;\n          hi2c-\u003epBuffPtr \u003d pbVar2 + 1;\n          hi2c-\u003eInstance-\u003eDR \u003d (uint)*pbVar2;\n          hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n        }\n      }\n    }\n    else {\n      pbVar2 \u003d hi2c-\u003epBuffPtr;\n      hi2c-\u003epBuffPtr \u003d pbVar2 + 1;\n      hi2c-\u003eInstance-\u003eDR \u003d (uint)*pbVar2;\n      hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_MemTxCpltCallback",
        "HAL_I2C_MasterTxCpltCallback"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002efc": {
      "entrypoint": "0x08002efc",
      "current_name": "FUN_08002efc",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08002efc(I2C_HandleTypeDef *hi2c)\n\n{\n  uint32_t uVar1;\n  uint32_t CurrentXferOptions;\n  byte *pbVar2;\n  \n  uVar1 \u003d hi2c-\u003eXferOptions;\n  if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_TX) {\n    if (hi2c-\u003eXferCount \u003d\u003d 0) {\n      if (((uVar1 \u003d\u003d 4) || (uVar1 \u003d\u003d 8)) || (uVar1 \u003d\u003d 0xffff0000)) {\n        hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x200;\n        hi2c-\u003ePreviousState \u003d 0;\n        hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n        if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM) {\n          hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(hi2c);\n        }\n        else {\n          hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(hi2c);\n        }\n      }\n      else {\n        hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n        hi2c-\u003ePreviousState \u003d 0x11;\n        hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n        hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(hi2c);\n      }\n    }\n    else {\n      pbVar2 \u003d hi2c-\u003epBuffPtr;\n      hi2c-\u003epBuffPtr \u003d pbVar2 + 1;\n      hi2c-\u003eInstance-\u003eDR \u003d (uint)*pbVar2;\n      hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_MemTxCpltCallback",
        "HAL_I2C_MasterTxCpltCallback"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002f9a": {
      "entrypoint": "0x08002f9a",
      "current_name": "FUN_08002f9a",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08002f9a(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_MasterReceive_BTF",
        "I2C_MasterReceive_RXNE"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08002f9c": {
      "entrypoint": "0x08002f9c",
      "current_name": "FUN_08002f9c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08002f9c(I2C_HandleTypeDef *hi2c)\n\n{\n  uint8_t *puVar1;\n  \n  if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_RX) {\n    if (hi2c-\u003eXferCount \u003c 4) {\n      if (hi2c-\u003eXferCount - 2 \u003c 2) {\n        if (hi2c-\u003eXferOptions \u003d\u003d 2) {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x400;\n        }\n        else {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x800;\n        }\n        hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffffbff;\n      }\n      else {\n        if (hi2c-\u003eXferOptions \u003d\u003d 2) {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x400;\n        }\n        else {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n        }\n        hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n        puVar1 \u003d hi2c-\u003epBuffPtr;\n        hi2c-\u003epBuffPtr \u003d puVar1 + 1;\n        *puVar1 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n        hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n        hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n        hi2c-\u003ePreviousState \u003d 0;\n        if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM) {\n          hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n          HAL_I2C_MemRxCpltCallback(hi2c);\n        }\n        else {\n          hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterRxCpltCallback(hi2c);\n        }\n      }\n    }\n    else {\n      puVar1 \u003d hi2c-\u003epBuffPtr;\n      hi2c-\u003epBuffPtr \u003d puVar1 + 1;\n      *puVar1 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n      hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_MasterRxCpltCallback",
        "HAL_I2C_MemRxCpltCallback"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800306c": {
      "entrypoint": "0x0800306c",
      "current_name": "FUN_0800306c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_0800306c(I2C_HandleTypeDef *hi2c)\n\n{\n  uint32_t uVar1;\n  uint32_t CurrentXferOptions;\n  uint8_t *puVar2;\n  \n  uVar1 \u003d hi2c-\u003eXferOptions;\n  if (hi2c-\u003eXferCount \u003d\u003d 3) {\n    if (((uVar1 \u003d\u003d 4) || (uVar1 \u003d\u003d 8)) || (uVar1 \u003d\u003d 0xffff0000)) {\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n    }\n    puVar2 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n    *puVar2 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n  }\n  else if (hi2c-\u003eXferCount \u003d\u003d 2) {\n    if (((uVar1 \u003d\u003d 4) || (uVar1 \u003d\u003d 8)) || (uVar1 \u003d\u003d 0xffff0000)) {\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffffcff;\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x200;\n    }\n    else {\n      if (uVar1 \u003d\u003d 2) {\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x400;\n      }\n      else {\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n      }\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffffcff;\n    }\n    puVar2 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n    *puVar2 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    puVar2 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n    *puVar2 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n    hi2c-\u003ePreviousState \u003d 0;\n    if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM) {\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n      HAL_I2C_MemRxCpltCallback(hi2c);\n    }\n    else {\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n      HAL_I2C_MasterRxCpltCallback(hi2c);\n    }\n  }\n  else {\n    puVar2 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n    *puVar2 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_MasterRxCpltCallback",
        "HAL_I2C_MemRxCpltCallback"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800316a": {
      "entrypoint": "0x0800316a",
      "current_name": "FUN_0800316a",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_0800316a(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_DMAAbort",
        "I2C_ITError"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800316c": {
      "entrypoint": "0x0800316c",
      "current_name": "FUN_0800316c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_0800316c(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint8_t *puVar2;\n  I2C_TypeDef *pIVar3;\n  \n  if (hi2c-\u003eState - 0x29 \u003c 2) {\n    hi2c-\u003ePreviousState \u003d 0;\n    hi2c-\u003eState \u003d HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((hi2c-\u003eState !\u003d HAL_I2C_STATE_ABORT) \u0026\u0026 ((hi2c-\u003eInstance-\u003eCR2 \u0026 0x800) \u003d\u003d 0)) {\n      hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n    }\n    hi2c-\u003ePreviousState \u003d 0;\n    hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n  }\n  hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffff7ff;\n  pIVar3 \u003d hi2c-\u003eInstance;\n  if ((pIVar3-\u003eCR2 \u0026 0x800) \u003d\u003d 0) {\n    if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_ABORT) {\n      hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n      hi2c-\u003eErrorCode \u003d 0;\n      if ((pIVar3-\u003eSR1 \u0026 0x40) !\u003d 0) {\n        puVar2 \u003d hi2c-\u003epBuffPtr;\n        hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n        *puVar2 \u003d (uint8_t)pIVar3-\u003eDR;\n      }\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(hi2c);\n    }\n    else {\n      if ((pIVar3-\u003eSR1 \u0026 0x40) !\u003d 0) {\n        puVar2 \u003d hi2c-\u003epBuffPtr;\n        hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n        *puVar2 \u003d (uint8_t)pIVar3-\u003eDR;\n      }\n      HAL_I2C_ErrorCallback(hi2c);\n    }\n  }\n  else {\n    pIVar3-\u003eCR2 \u003d pIVar3-\u003eCR2 \u0026 0xfffff7ff;\n    if (hi2c-\u003ehdmatx-\u003eState \u003d\u003d HAL_DMA_STATE_READY) {\n      hi2c-\u003ehdmarx-\u003eXferAbortCallback \u003d I2C_DMAAbort + 1;\n      HVar1 \u003d HAL_DMA_Abort_IT(hi2c-\u003ehdmarx);\n      if (HVar1 !\u003d HAL_OK) {\n        if ((hi2c-\u003eInstance-\u003eSR1 \u0026 0x40) !\u003d 0) {\n          puVar2 \u003d hi2c-\u003epBuffPtr;\n          hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n          *puVar2 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n        }\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffffe;\n        hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n        (*hi2c-\u003ehdmarx-\u003eXferAbortCallback)(hi2c-\u003ehdmarx);\n      }\n    }\n    else {\n      hi2c-\u003ehdmatx-\u003eXferAbortCallback \u003d I2C_DMAAbort + 1;\n      HVar1 \u003d HAL_DMA_Abort_IT(hi2c-\u003ehdmatx);\n      if (HVar1 !\u003d HAL_OK) {\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffffe;\n        hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n        (*hi2c-\u003ehdmatx-\u003eXferAbortCallback)(hi2c-\u003ehdmatx);\n      }\n    }\n  }\n  if ((hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_LISTEN) \u0026\u0026 ((hi2c-\u003eErrorCode \u0026 4) !\u003d 0)) {\n    hi2c-\u003eXferOptions \u003d 0xffff0000;\n    hi2c-\u003ePreviousState \u003d 0;\n    hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n    hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(hi2c);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_ER_IRQHandler",
        "I2C_Slave_STOPF"
      ],
      "called": [
        "HAL_DMA_Abort_IT",
        "HAL_I2C_AbortCpltCallback",
        "HAL_I2C_ListenCpltCallback",
        "HAL_I2C_ErrorCallback"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080032b4": {
      "entrypoint": "0x080032b4",
      "current_name": "FUN_080032b4",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_080032b4(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  I2C_TypeDef *pIVar2;\n  uint8_t *puVar3;\n  uint32_t CurrentState;\n  uint32_t tmpreg;\n  \n  HVar1 \u003d hi2c-\u003eState;\n  hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n  hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 1;\n  hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n  pIVar2 \u003d hi2c-\u003eInstance;\n  if ((pIVar2-\u003eCR2 \u0026 0x800) !\u003d 0) {\n    if ((hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_RX) || (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      hi2c-\u003eXferCount \u003d (uint16_t)hi2c-\u003ehdmarx-\u003eInstance-\u003eCNDTR;\n    }\n    else {\n      hi2c-\u003eXferCount \u003d (uint16_t)hi2c-\u003ehdmatx-\u003eInstance-\u003eCNDTR;\n    }\n  }\n  if (hi2c-\u003eXferCount !\u003d 0) {\n    if ((pIVar2-\u003eSR1 \u0026 4) !\u003d 0) {\n      puVar3 \u003d hi2c-\u003epBuffPtr;\n      hi2c-\u003epBuffPtr \u003d puVar3 + 1;\n      *puVar3 \u003d (uint8_t)pIVar2-\u003eDR;\n      hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    }\n    if ((hi2c-\u003eInstance-\u003eSR1 \u0026 0x40) !\u003d 0) {\n      puVar3 \u003d hi2c-\u003epBuffPtr;\n      hi2c-\u003epBuffPtr \u003d puVar3 + 1;\n      *puVar3 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n      hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    }\n    hi2c-\u003eErrorCode \u003d hi2c-\u003eErrorCode | 4;\n  }\n  if (hi2c-\u003eErrorCode \u003d\u003d 0) {\n    if (((HVar1 \u003d\u003d HAL_I2C_STATE_LISTEN) || (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      hi2c-\u003eXferOptions \u003d 0xffff0000;\n      hi2c-\u003ePreviousState \u003d 0;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(hi2c);\n    }\n    else if ((hi2c-\u003ePreviousState \u003d\u003d 0x22) || (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_RX)) {\n      hi2c-\u003ePreviousState \u003d 0;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(hi2c);\n    }\n  }\n  else {\n    I2C_ITError(hi2c);\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_SlaveRxCpltCallback",
        "I2C_ITError",
        "HAL_I2C_ListenCpltCallback"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080033b8": {
      "entrypoint": "0x080033b8",
      "current_name": "FUN_080033b8",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_080033b8(I2C_HandleTypeDef *hi2c)\n\n{\n  I2C_TypeDef *pIVar1;\n  uint32_t CurrentMode;\n  uint uVar2;\n  uint32_t sr1itflags;\n  uint uVar3;\n  uint32_t itsources;\n  uint uVar4;\n  uint32_t sr2itflags;\n  \n  pIVar1 \u003d hi2c-\u003eInstance;\n  uVar4 \u003d pIVar1-\u003eSR2;\n  uVar2 \u003d pIVar1-\u003eSR1;\n  uVar3 \u003d pIVar1-\u003eCR2;\n  if ((hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MASTER) || (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM)) {\n    if (((uVar2 \u0026 0x10001) \u003d\u003d 0) || ((uVar3 \u0026 0x200) \u003d\u003d 0)) {\n      if (((uVar2 \u0026 0x10008) \u003d\u003d 0) || ((uVar3 \u0026 0x200) \u003d\u003d 0)) {\n        if (((uVar2 \u0026 0x10002) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n          I2C_Master_ADDR(hi2c);\n        }\n      }\n      else {\n        I2C_Master_ADD10(hi2c);\n      }\n    }\n    else {\n      I2C_Master_SB(hi2c);\n    }\n    if ((uVar4 \u0026 0x100004) \u003d\u003d 0) {\n      if ((((uVar2 \u0026 0x10040) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x400) !\u003d 0)) \u0026\u0026 ((uVar2 \u0026 0x10004) \u003d\u003d 0)) {\n        I2C_MasterReceive_RXNE(hi2c);\n        return;\n      }\n      if (((uVar2 \u0026 0x10004) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n        I2C_MasterReceive_BTF(hi2c);\n        return;\n      }\n    }\n    else {\n      if ((((uVar2 \u0026 0x10080) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x400) !\u003d 0)) \u0026\u0026 ((uVar2 \u0026 0x10004) \u003d\u003d 0)) {\n        I2C_MasterTransmit_TXE(hi2c);\n        return;\n      }\n      if (((uVar2 \u0026 0x10004) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n        I2C_MasterTransmit_BTF(hi2c);\n        return;\n      }\n    }\n  }\n  else {\n    if (((uVar2 \u0026 0x10002) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n      I2C_Slave_ADDR(hi2c);\n      return;\n    }\n    if (((uVar2 \u0026 0x10010) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n      I2C_Slave_STOPF(hi2c);\n      return;\n    }\n    if ((uVar4 \u0026 0x100004) \u003d\u003d 0) {\n      if ((((uVar2 \u0026 0x10040) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x400) !\u003d 0)) \u0026\u0026 ((uVar2 \u0026 0x10004) \u003d\u003d 0)) {\n        I2C_SlaveReceive_RXNE(hi2c);\n        return;\n      }\n      if (((uVar2 \u0026 0x10004) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n        I2C_SlaveReceive_BTF(hi2c);\n      }\n    }\n    else {\n      if ((((uVar2 \u0026 0x10080) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x400) !\u003d 0)) \u0026\u0026 ((uVar2 \u0026 0x10004) \u003d\u003d 0)) {\n        I2C_SlaveTransmit_TXE(hi2c);\n        return;\n      }\n      if (((uVar2 \u0026 0x10004) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n        I2C_SlaveTransmit_BTF(hi2c);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C1_EV_IRQHandler",
        "I2C2_EV_IRQHandler"
      ],
      "called": [
        "I2C_MasterTransmit_BTF",
        "I2C_MasterReceive_BTF",
        "I2C_Master_ADD10",
        "I2C_Slave_ADDR",
        "I2C_SlaveTransmit_BTF",
        "I2C_MasterReceive_RXNE",
        "I2C_SlaveTransmit_TXE",
        "I2C_Master_SB",
        "I2C_SlaveReceive_BTF",
        "I2C_SlaveReceive_RXNE",
        "I2C_Slave_STOPF",
        "I2C_Master_ADDR",
        "I2C_MasterTransmit_TXE"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08003520": {
      "entrypoint": "0x08003520",
      "current_name": "FUN_08003520",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08003520(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  I2C_TypeDef *pIVar2;\n  uint32_t sr1itflags;\n  uint uVar3;\n  uint32_t itsources;\n  uint uVar4;\n  \n  pIVar2 \u003d hi2c-\u003eInstance;\n  uVar3 \u003d pIVar2-\u003eSR1;\n  uVar4 \u003d pIVar2-\u003eCR2;\n  if (((uVar3 \u0026 0x10100) !\u003d 0) \u0026\u0026 ((uVar4 \u0026 0x100) !\u003d 0)) {\n    hi2c-\u003eErrorCode \u003d hi2c-\u003eErrorCode | 1;\n    pIVar2-\u003eSR1 \u003d 0xfffffeff;\n    hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x8000;\n  }\n  if (((uVar3 \u0026 0x10200) !\u003d 0) \u0026\u0026 ((uVar4 \u0026 0x100) !\u003d 0)) {\n    hi2c-\u003eErrorCode \u003d hi2c-\u003eErrorCode | 2;\n    hi2c-\u003eInstance-\u003eSR1 \u003d 0xfffffdff;\n  }\n  if (((uVar3 \u0026 0x10400) !\u003d 0) \u0026\u0026 ((uVar4 \u0026 0x100) !\u003d 0)) {\n    HVar1 \u003d hi2c-\u003eState;\n    if (((hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_SLAVE) \u0026\u0026 (hi2c-\u003eXferCount \u003d\u003d 0)) \u0026\u0026\n       (((HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_TX || (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_TX_LISTEN)) ||\n        ((HVar1 \u003d\u003d HAL_I2C_STATE_LISTEN \u0026\u0026 (hi2c-\u003ePreviousState \u003d\u003d 0x21)))))) {\n      I2C_Slave_AF(hi2c);\n    }\n    else {\n      hi2c-\u003eErrorCode \u003d hi2c-\u003eErrorCode | 4;\n      if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MASTER) {\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x200;\n      }\n      hi2c-\u003eInstance-\u003eSR1 \u003d 0xfffffbff;\n    }\n  }\n  if (((uVar3 \u0026 0x10800) !\u003d 0) \u0026\u0026 ((uVar4 \u0026 0x100) !\u003d 0)) {\n    hi2c-\u003eErrorCode \u003d hi2c-\u003eErrorCode | 8;\n    hi2c-\u003eInstance-\u003eSR1 \u003d 0xfffff7ff;\n  }\n  if (hi2c-\u003eErrorCode !\u003d 0) {\n    I2C_ITError(hi2c);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C1_ER_IRQHandler",
        "I2C2_ER_IRQHandler"
      ],
      "called": [
        "I2C_ITError",
        "I2C_Slave_AF"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080035fc": {
      "entrypoint": "0x080035fc",
      "current_name": "FUN_080035fc",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_080035fc(DMA_HandleTypeDef *hdma)\n\n{\n  I2C_HandleTypeDef *hi2c_00;\n  I2C_HandleTypeDef *hi2c;\n  \n  hi2c_00 \u003d (I2C_HandleTypeDef *)hdma-\u003eParent;\n  hi2c_00-\u003eInstance-\u003eCR1 \u003d hi2c_00-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n  hi2c_00-\u003eXferCount \u003d 0;\n  hi2c_00-\u003ehdmatx-\u003eXferAbortCallback \u003d (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  hi2c_00-\u003ehdmarx-\u003eXferAbortCallback \u003d (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  if (hi2c_00-\u003eState !\u003d HAL_I2C_STATE_ABORT) {\n    hi2c_00-\u003eState \u003d HAL_I2C_STATE_READY;\n    hi2c_00-\u003eMode \u003d HAL_I2C_MODE_NONE;\n    hi2c_00-\u003eInstance-\u003eCR1 \u003d hi2c_00-\u003eInstance-\u003eCR1 \u0026 0xfffffffe;\n    HAL_I2C_ErrorCallback(hi2c_00);\n    return;\n  }\n  hi2c_00-\u003eState \u003d HAL_I2C_STATE_READY;\n  hi2c_00-\u003eMode \u003d HAL_I2C_MODE_NONE;\n  hi2c_00-\u003eErrorCode \u003d 0;\n  hi2c_00-\u003eInstance-\u003eCR1 \u003d hi2c_00-\u003eInstance-\u003eCR1 \u0026 0xfffffffe;\n  HAL_I2C_AbortCpltCallback(hi2c_00);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_I2C_AbortCpltCallback",
        "HAL_I2C_ErrorCallback"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800365c": {
      "entrypoint": "0x0800365c",
      "current_name": "FUN_0800365c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_0800365c(uint32_t mdelay)\n\n{\n  bool bVar1;\n  uint32_t Delay;\n  \n  Delay \u003d mdelay * (SystemCoreClock / 8000);\n  do {\n    bVar1 \u003d Delay !\u003d 0;\n    Delay \u003d Delay - 1;\n  } while (bVar1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_RCC_OscConfig"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08003688": {
      "entrypoint": "0x08003688",
      "current_name": "FUN_08003688",
      "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08003688(RCC_OscInitTypeDef_conflict *RCC_OscInitStruct)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  bool bVar4;\n  uint32_t tmpreg;\n  \n  if ((RCC_OscInitStruct-\u003eOscillatorType \u0026 1) !\u003d 0) {\n    if (((_DAT_40021004 \u0026 0xc) \u003d\u003d 4) ||\n       (((_DAT_40021004 \u0026 0xc) \u003d\u003d 8 \u0026\u0026 ((_DAT_40021004 \u0026 0x10000) !\u003d 0)))) {\n      if (((_DAT_40021000 \u0026 0x20000) !\u003d 0) \u0026\u0026 (RCC_OscInitStruct-\u003eHSEState \u003d\u003d 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      uVar3 \u003d RCC_OscInitStruct-\u003eHSEState;\n      if (uVar3 \u003d\u003d 0x10000) {\n        _DAT_40021000 \u003d _DAT_40021000 | 0x10000;\n      }\n      else if (uVar3 \u003d\u003d 0) {\n        _DAT_40021000 \u003d _DAT_40021000 \u0026 0xfffaffff;\n      }\n      else if (uVar3 \u003d\u003d 0x50000) {\n        _DAT_40021000 \u003d _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 \u003d _DAT_40021000 \u0026 0xfffaffff;\n      }\n      if (RCC_OscInitStruct-\u003eHSEState \u003d\u003d 0) {\n        uVar3 \u003d HAL_GetTick();\n        while ((_DAT_40021000 \u0026 0x20000) !\u003d 0) {\n          uVar2 \u003d HAL_GetTick();\n          if (100 \u003c uVar2 - uVar3) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        uVar3 \u003d HAL_GetTick();\n        while ((_DAT_40021000 \u0026 0x20000) \u003d\u003d 0) {\n          uVar2 \u003d HAL_GetTick();\n          if (100 \u003c uVar2 - uVar3) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct-\u003eOscillatorType \u0026 2) !\u003d 0) {\n    if (((_DAT_40021004 \u0026 0xc) \u003d\u003d 0) ||\n       (((_DAT_40021004 \u0026 0xc) \u003d\u003d 8 \u0026\u0026 ((_DAT_40021004 \u0026 0x10000) \u003d\u003d 0)))) {\n      if (((_DAT_40021000 \u0026 2) !\u003d 0) \u0026\u0026 (RCC_OscInitStruct-\u003eHSIState !\u003d 1)) {\n        return HAL_ERROR;\n      }\n      _DAT_40021000 \u003d _DAT_40021000 \u0026 0xffffff07 | RCC_OscInitStruct-\u003eHSICalibrationValue \u003c\u003c 3;\n    }\n    else if (RCC_OscInitStruct-\u003eHSIState \u003d\u003d 0) {\n      _DAT_42420000 \u003d 0;\n      uVar3 \u003d HAL_GetTick();\n      while ((_DAT_40021000 \u0026 2) !\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (2 \u003c uVar2 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 \u003d 1;\n      uVar3 \u003d HAL_GetTick();\n      while ((_DAT_40021000 \u0026 2) \u003d\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (2 \u003c uVar2 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40021000 \u003d _DAT_40021000 \u0026 0xffffff07 | RCC_OscInitStruct-\u003eHSICalibrationValue \u003c\u003c 3;\n    }\n  }\n  if ((RCC_OscInitStruct-\u003eOscillatorType \u0026 8) !\u003d 0) {\n    if (RCC_OscInitStruct-\u003eLSIState \u003d\u003d 0) {\n      _DAT_42420480 \u003d 0;\n      uVar3 \u003d HAL_GetTick();\n      while ((_DAT_40021024 \u0026 2) !\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (2 \u003c uVar2 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 \u003d 1;\n      uVar3 \u003d HAL_GetTick();\n      while ((_DAT_40021024 \u0026 2) \u003d\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (2 \u003c uVar2 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((RCC_OscInitStruct-\u003eOscillatorType \u0026 4) !\u003d 0) {\n    bVar4 \u003d (_DAT_4002101c \u0026 0x10000000) \u003d\u003d 0;\n    if (bVar4) {\n      _DAT_4002101c \u003d _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 \u0026 0x100) \u003d\u003d 0) {\n      _DAT_40007000 \u003d _DAT_40007000 | 0x100;\n      uVar3 \u003d HAL_GetTick();\n      while ((_DAT_40007000 \u0026 0x100) \u003d\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (100 \u003c uVar2 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    uVar3 \u003d RCC_OscInitStruct-\u003eLSEState;\n    if (uVar3 \u003d\u003d 1) {\n      _DAT_40021020 \u003d _DAT_40021020 | 1;\n    }\n    else if (uVar3 \u003d\u003d 0) {\n      _DAT_40021020 \u003d _DAT_40021020 \u0026 0xfffffffa;\n    }\n    else if (uVar3 \u003d\u003d 5) {\n      _DAT_40021020 \u003d _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 \u003d _DAT_40021020 \u0026 0xfffffffa;\n    }\n    if (RCC_OscInitStruct-\u003eLSEState \u003d\u003d 0) {\n      uVar3 \u003d HAL_GetTick();\n      while ((_DAT_40021020 \u0026 2) !\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (5000 \u003c uVar2 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      uVar3 \u003d HAL_GetTick();\n      while ((_DAT_40021020 \u0026 2) \u003d\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (5000 \u003c uVar2 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (bVar4) {\n      _DAT_4002101c \u003d _DAT_4002101c \u0026 0xefffffff;\n    }\n  }\n  uVar3 \u003d (RCC_OscInitStruct-\u003ePLL).PLLState;\n  if (uVar3 \u003d\u003d 0) {\n    HVar1 \u003d HAL_OK;\n  }\n  else if ((_DAT_40021004 \u0026 0xc) \u003d\u003d 8) {\n    HVar1 \u003d HAL_ERROR;\n  }\n  else if (uVar3 \u003d\u003d 2) {\n    _DAT_42420060 \u003d 0;\n    uVar3 \u003d HAL_GetTick();\n    do {\n      if ((_DAT_40021000 \u0026 0x2000000) \u003d\u003d 0) {\n        if ((RCC_OscInitStruct-\u003ePLL).PLLSource \u003d\u003d 0x10000) {\n          _DAT_40021004 \u003d _DAT_40021004 \u0026 0xfffdffff | RCC_OscInitStruct-\u003eHSEPredivValue;\n        }\n        _DAT_40021004 \u003d\n             _DAT_40021004 \u0026 0xffc2ffff |\n             (RCC_OscInitStruct-\u003ePLL).PLLSource | (RCC_OscInitStruct-\u003ePLL).PLLMUL;\n        _DAT_42420060 \u003d 1;\n        uVar3 \u003d HAL_GetTick();\n        do {\n          if ((_DAT_40021000 \u0026 0x2000000) !\u003d 0) {\n            return HAL_OK;\n          }\n          uVar2 \u003d HAL_GetTick();\n        } while (uVar2 - uVar3 \u003c 3);\n        return HAL_TIMEOUT;\n      }\n      uVar2 \u003d HAL_GetTick();\n    } while (uVar2 - uVar3 \u003c 3);\n    HVar1 \u003d HAL_TIMEOUT;\n  }\n  else {\n    _DAT_42420060 \u003d 0;\n    uVar3 \u003d HAL_GetTick();\n    do {\n      if ((_DAT_40021000 \u0026 0x2000000) \u003d\u003d 0) {\n        return HAL_OK;\n      }\n      uVar2 \u003d HAL_GetTick();\n    } while (uVar2 - uVar3 \u003c 3);\n    HVar1 \u003d HAL_TIMEOUT;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "SystemClock_Config"
      ],
      "called": [
        "HAL_GetTick",
        "RCC_Delay"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08003a68": {
      "entrypoint": "0x08003a68",
      "current_name": "FUN_08003a68",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t FUN_08003a68(void)\n\n{\n  uint32_t uVar1;\n  uint8_t aPredivFactorTable [2];\n  uint8_t aPLLMULFactorTable [16];\n  \n  aPLLMULFactorTable[12] \u003d \u0027\\x0e\u0027;\n  aPLLMULFactorTable[13] \u003d \u0027\\x0f\u0027;\n  aPLLMULFactorTable[14] \u003d \u0027\\x10\u0027;\n  aPLLMULFactorTable[15] \u003d \u0027\\x10\u0027;\n  aPLLMULFactorTable[8] \u003d \u0027\\n\u0027;\n  aPLLMULFactorTable[9] \u003d \u0027\\v\u0027;\n  aPLLMULFactorTable[10] \u003d \u0027\\f\u0027;\n  aPLLMULFactorTable[11] \u003d \u0027\\r\u0027;\n  aPLLMULFactorTable[4] \u003d \u0027\\x06\u0027;\n  aPLLMULFactorTable[5] \u003d \u0027\\a\u0027;\n  aPLLMULFactorTable[6] \u003d \u0027\\b\u0027;\n  aPLLMULFactorTable[7] \u003d \u0027\\t\u0027;\n  aPLLMULFactorTable[0] \u003d \u0027\\x02\u0027;\n  aPLLMULFactorTable[1] \u003d \u0027\\x03\u0027;\n  aPLLMULFactorTable[2] \u003d \u0027\\x04\u0027;\n  aPLLMULFactorTable[3] \u003d \u0027\\x05\u0027;\n  aPredivFactorTable[0] \u003d \u0027\\x01\u0027;\n  aPredivFactorTable[1] \u003d \u0027\\x02\u0027;\n  if ((_DAT_40021004 \u0026 0xc) \u003d\u003d 8) {\n    if ((_DAT_40021004 \u0026 0x10000) \u003d\u003d 0) {\n      uVar1 \u003d (uint)aPLLMULFactorTable[(_DAT_40021004 \u003c\u003c 10) \u003e\u003e 0x1c] * 4000000;\n    }\n    else {\n      uVar1 \u003d ((uint)aPLLMULFactorTable[(_DAT_40021004 \u003c\u003c 10) \u003e\u003e 0x1c] * 8000000) /\n              (uint)aPredivFactorTable[-((int)(_DAT_40021004 \u003c\u003c 0xe) \u003e\u003e 0x1f)];\n    }\n  }\n  else {\n    uVar1 \u003d 8000000;\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_RCC_ClockConfig"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08003ad4": {
      "entrypoint": "0x08003ad4",
      "current_name": "FUN_08003ad4",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nFUN_08003ad4(RCC_ClkInitTypeDef_conflict *RCC_ClkInitStruct,uint32_t FLatency)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  \n  if ((_DAT_40022000 \u0026 7) \u003c FLatency) {\n    _DAT_40022000 \u003d _DAT_40022000 \u0026 0xfffffff8 | FLatency;\n    if (FLatency !\u003d (FLatency \u0026 7)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((RCC_ClkInitStruct-\u003eClockType \u0026 2) !\u003d 0) {\n    _DAT_40021004 \u003d _DAT_40021004 \u0026 0xffffff0f | RCC_ClkInitStruct-\u003eAHBCLKDivider;\n  }\n  if ((RCC_ClkInitStruct-\u003eClockType \u0026 1) !\u003d 0) {\n    uVar3 \u003d RCC_ClkInitStruct-\u003eSYSCLKSource;\n    if (uVar3 \u003d\u003d 1) {\n      if ((_DAT_40021000 \u0026 0x20000) \u003d\u003d 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((uVar3 !\u003d 2) \u0026\u0026 ((_DAT_40021000 \u0026 2) \u003d\u003d 0)) {\n      return HAL_ERROR;\n    }\n    _DAT_40021004 \u003d uVar3 | _DAT_40021004 \u0026 0xfffffffc;\n    uVar1 \u003d HAL_GetTick();\n    if (RCC_ClkInitStruct-\u003eSYSCLKSource \u003d\u003d 1) {\n      while ((_DAT_40021004 \u0026 0xc) !\u003d 4) {\n        uVar2 \u003d HAL_GetTick();\n        if (5000 \u003c uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else if (RCC_ClkInitStruct-\u003eSYSCLKSource \u003d\u003d 2) {\n      while ((_DAT_40021004 \u0026 0xc) !\u003d 8) {\n        uVar2 \u003d HAL_GetTick();\n        if (5000 \u003c uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      while ((_DAT_40021004 \u0026 0xc) !\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (5000 \u003c uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if (FLatency \u003c (_DAT_40022000 \u0026 7)) {\n    _DAT_40022000 \u003d _DAT_40022000 \u0026 0xfffffff8 | FLatency;\n    if (FLatency !\u003d (FLatency \u0026 7)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((RCC_ClkInitStruct-\u003eClockType \u0026 4) !\u003d 0) {\n    _DAT_40021004 \u003d _DAT_40021004 \u0026 0xfffff8ff | RCC_ClkInitStruct-\u003eAPB1CLKDivider;\n  }\n  if ((RCC_ClkInitStruct-\u003eClockType \u0026 8) !\u003d 0) {\n    _DAT_40021004 \u003d _DAT_40021004 \u0026 0xffffc7ff | RCC_ClkInitStruct-\u003eAPB2CLKDivider \u003c\u003c 3;\n  }\n  uVar1 \u003d HAL_RCC_GetSysClockFreq();\n  SystemCoreClock \u003d uVar1 \u003e\u003e \"\"[(_DAT_40021004 \u003c\u003c 0x18) \u003e\u003e 0x1c];\n  HAL_InitTick(0xf);\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "SystemClock_Config"
      ],
      "called": [
        "HAL_GetTick",
        "HAL_RCC_GetSysClockFreq",
        "HAL_InitTick"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08003c44": {
      "entrypoint": "0x08003c44",
      "current_name": "FUN_08003c44",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t FUN_08003c44(void)\n\n{\n  return SystemCoreClock;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_RCC_GetPCLK1Freq",
        "HAL_RCC_GetPCLK2Freq",
        "SystemClock_Config"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08003c50": {
      "entrypoint": "0x08003c50",
      "current_name": "FUN_08003c50",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t FUN_08003c50(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 \u003d HAL_RCC_GetHCLKFreq();\n  return uVar1 \u003e\u003e \"\"[(uint)(_DAT_40021004 \u003c\u003c 0x15) \u003e\u003e 0x1d];\n}\n\n",
      "renaming": {},
      "calling": [
        "UART_SetConfig"
      ],
      "called": [
        "HAL_RCC_GetHCLKFreq"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08003c70": {
      "entrypoint": "0x08003c70",
      "current_name": "FUN_08003c70",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t FUN_08003c70(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 \u003d HAL_RCC_GetHCLKFreq();\n  return uVar1 \u003e\u003e \"\"[(uint)(_DAT_40021004 \u003c\u003c 0x12) \u003e\u003e 0x1d];\n}\n\n",
      "renaming": {},
      "calling": [
        "UART_SetConfig",
        "HAL_RCCEx_GetPeriphCLKFreq"
      ],
      "called": [
        "HAL_RCC_GetHCLKFreq"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08003c90": {
      "entrypoint": "0x08003c90",
      "current_name": "FUN_08003c90",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08003c90(RCC_PeriphCLKInitTypeDef_conflict *PeriphClkInit)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  bool bVar5;\n  uint32_t tmpreg;\n  \n  if ((PeriphClkInit-\u003ePeriphClockSelection \u0026 1) !\u003d 0) {\n    bVar5 \u003d (_DAT_4002101c \u0026 0x10000000) \u003d\u003d 0;\n    if (bVar5) {\n      _DAT_4002101c \u003d _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 \u0026 0x100) \u003d\u003d 0) {\n      _DAT_40007000 \u003d _DAT_40007000 | 0x100;\n      uVar3 \u003d HAL_GetTick();\n      while ((_DAT_40007000 \u0026 0x100) \u003d\u003d 0) {\n        uVar4 \u003d HAL_GetTick();\n        if (100 \u003c uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (((_DAT_40021020 \u0026 0x300) !\u003d 0) \u0026\u0026\n       ((_DAT_40021020 \u0026 0x300) !\u003d (PeriphClkInit-\u003eRTCClockSelection \u0026 0x300))) {\n      uVar2 \u003d _DAT_40021020 \u0026 0xfffffcff;\n      _DAT_42420440 \u003d 0;\n      uVar1 \u003d _DAT_40021020 \u0026 1;\n      _DAT_40021020 \u003d uVar2;\n      if (uVar1 !\u003d 0) {\n        uVar3 \u003d HAL_GetTick();\n        while ((_DAT_40021020 \u0026 2) \u003d\u003d 0) {\n          uVar4 \u003d HAL_GetTick();\n          if (5000 \u003c uVar4 - uVar3) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    _DAT_40021020 \u003d _DAT_40021020 \u0026 0xfffffcff | PeriphClkInit-\u003eRTCClockSelection;\n    if (bVar5) {\n      _DAT_4002101c \u003d _DAT_4002101c \u0026 0xefffffff;\n    }\n  }\n  if ((PeriphClkInit-\u003ePeriphClockSelection \u0026 2) !\u003d 0) {\n    _DAT_40021004 \u003d _DAT_40021004 \u0026 0xffff3fff | PeriphClkInit-\u003eAdcClockSelection;\n  }\n  if ((PeriphClkInit-\u003ePeriphClockSelection \u0026 0x10) !\u003d 0) {\n    _DAT_40021004 \u003d _DAT_40021004 \u0026 0xffbfffff | PeriphClkInit-\u003eUsbClockSelection;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "SystemClock_Config"
      ],
      "called": [
        "HAL_GetTick"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08003da4": {
      "entrypoint": "0x08003da4",
      "current_name": "FUN_08003da4",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t FUN_08003da4(uint32_t PeriphClk)\n\n{\n  uint32_t uVar1;\n  uint uVar2;\n  uint8_t aPredivFactorTable [2];\n  uint8_t aPLLMULFactorTable [16];\n  \n  aPLLMULFactorTable[12] \u003d \u0027\\x0e\u0027;\n  aPLLMULFactorTable[13] \u003d \u0027\\x0f\u0027;\n  aPLLMULFactorTable[14] \u003d \u0027\\x10\u0027;\n  aPLLMULFactorTable[15] \u003d \u0027\\x10\u0027;\n  aPLLMULFactorTable[8] \u003d \u0027\\n\u0027;\n  aPLLMULFactorTable[9] \u003d \u0027\\v\u0027;\n  aPLLMULFactorTable[10] \u003d \u0027\\f\u0027;\n  aPLLMULFactorTable[11] \u003d \u0027\\r\u0027;\n  aPLLMULFactorTable[4] \u003d \u0027\\x06\u0027;\n  aPLLMULFactorTable[5] \u003d \u0027\\a\u0027;\n  aPLLMULFactorTable[6] \u003d \u0027\\b\u0027;\n  aPLLMULFactorTable[7] \u003d \u0027\\t\u0027;\n  aPLLMULFactorTable[0] \u003d \u0027\\x02\u0027;\n  aPLLMULFactorTable[1] \u003d \u0027\\x03\u0027;\n  aPLLMULFactorTable[2] \u003d \u0027\\x04\u0027;\n  aPLLMULFactorTable[3] \u003d \u0027\\x05\u0027;\n  aPredivFactorTable[0] \u003d \u0027\\x01\u0027;\n  aPredivFactorTable[1] \u003d \u0027\\x02\u0027;\n  if (PeriphClk \u003d\u003d 2) {\n    uVar1 \u003d HAL_RCC_GetPCLK2Freq();\n    uVar1 \u003d uVar1 / ((((_DAT_40021004 \u003c\u003c 0x10) \u003e\u003e 0x1e) + 1) * 2);\n  }\n  else if (PeriphClk \u003d\u003d 0x10) {\n    if ((_DAT_40021000 \u0026 0x1000000) \u003d\u003d 0) {\n      uVar1 \u003d 0;\n    }\n    else {\n      if ((_DAT_40021004 \u0026 0x10000) \u003d\u003d 0) {\n        uVar2 \u003d 4000000;\n      }\n      else {\n        uVar2 \u003d 8000000 / aPredivFactorTable[-((int)(_DAT_40021004 \u003c\u003c 0xe) \u003e\u003e 0x1f)];\n      }\n      uVar1 \u003d uVar2 * aPLLMULFactorTable[(_DAT_40021004 \u003c\u003c 10) \u003e\u003e 0x1c];\n      if ((_DAT_40021004 \u0026 0x400000) \u003d\u003d 0) {\n        uVar1 \u003d (uVar1 * 2) / 3;\n      }\n    }\n  }\n  else if (PeriphClk \u003d\u003d 1) {\n    if ((_DAT_40021020 \u0026 0x302) \u003d\u003d 0x102) {\n      uVar1 \u003d 0x8000;\n    }\n    else if (((_DAT_40021020 \u0026 0x300) \u003d\u003d 0x200) \u0026\u0026 ((_DAT_40021024 \u0026 2) !\u003d 0)) {\n      uVar1 \u003d 32000;\n    }\n    else if ((_DAT_40021020 \u0026 0x300) \u003d\u003d 0x300) {\n      if ((_DAT_40021000 \u0026 0x20000) \u003d\u003d 0) {\n        uVar1 \u003d 0;\n      }\n      else {\n        uVar1 \u003d 0xf424;\n      }\n    }\n    else {\n      uVar1 \u003d 0;\n    }\n  }\n  else {\n    uVar1 \u003d 0;\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_ADC_PollForConversion",
        "HAL_ADCEx_Calibration_Start"
      ],
      "called": [
        "HAL_RCC_GetPCLK2Freq"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08003ea0": {
      "entrypoint": "0x08003ea0",
      "current_name": "FUN_08003ea0",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08003ea0(RTC_HandleTypeDef *hrtc)\n\n{\n  if (((hrtc-\u003eInstance-\u003eCRH \u0026 2) !\u003d 0) \u0026\u0026 ((hrtc-\u003eInstance-\u003eCRL \u0026 2) !\u003d 0)) {\n    HAL_RTC_AlarmAEventCallback(hrtc);\n    hrtc-\u003eInstance-\u003eCRL \u003d 0xfffffffd;\n  }\n  _DAT_40010414 \u003d 0x20000;\n  hrtc-\u003eState \u003d HAL_RTC_STATE_READY;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "RTC_Alarm_IRQHandler"
      ],
      "called": [
        "HAL_RTC_AlarmAEventCallback"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08003ed8": {
      "entrypoint": "0x08003ed8",
      "current_name": "FUN_08003ed8",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08003ed8(TIM_HandleTypeDef *htim)\n\n{\n  TIM_TypeDef *pTVar1;\n  \n  htim-\u003eState \u003d HAL_TIM_STATE_BUSY;\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eCCER \u0026 0x1111) \u003d\u003d 0) \u0026\u0026 ((pTVar1-\u003eCCER \u0026 0x444) \u003d\u003d 0)) {\n    pTVar1-\u003eCR1 \u003d pTVar1-\u003eCR1 \u0026 0xfffffffe;\n  }\n  HAL_TIM_PWM_MspDeInit(htim);\n  htim-\u003eState \u003d HAL_TIM_STATE_RESET;\n  htim-\u003eLock \u003d HAL_UNLOCKED;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_stop"
      ],
      "called": [
        "HAL_TIM_PWM_MspDeInit"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08003f12": {
      "entrypoint": "0x08003f12",
      "current_name": "FUN_08003f12",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08003f12(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08003f14": {
      "entrypoint": "0x08003f14",
      "current_name": "FUN_08003f14",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08003f14(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08003f16": {
      "entrypoint": "0x08003f16",
      "current_name": "FUN_08003f16",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08003f16(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08003f18": {
      "entrypoint": "0x08003f18",
      "current_name": "FUN_08003f18",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08003f18(TIM_HandleTypeDef *htim)\n\n{\n  TIM_TypeDef *pTVar1;\n  \n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 2) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 2) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xfffffffd;\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_1;\n    if ((htim-\u003eInstance-\u003eCCMR1 \u0026 3) \u003d\u003d 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 4) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 4) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xfffffffb;\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_2;\n    if ((htim-\u003eInstance-\u003eCCMR1 \u0026 0x300) \u003d\u003d 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 8) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 8) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xfffffff7;\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_3;\n    if ((htim-\u003eInstance-\u003eCCMR2 \u0026 3) \u003d\u003d 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 0x10) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 0x10) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xffffffef;\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_4;\n    if ((htim-\u003eInstance-\u003eCCMR2 \u0026 0x300) \u003d\u003d 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 1) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 1) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(htim);\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 0x80) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 0x80) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xffffff7f;\n    HAL_TIMEx_BreakCallback(htim);\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 0x40) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 0x40) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xffffffbf;\n    HAL_TIM_TriggerCallback(htim);\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 0x20) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 0x20) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(htim);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "TIM1_UP_IRQHandler",
        "TIM3_IRQHandler",
        "TIM4_IRQHandler",
        "TIM2_IRQHandler"
      ],
      "called": [
        "HAL_TIM_OC_DelayElapsedCallback",
        "HAL_TIM_PeriodElapsedCallback",
        "HAL_TIMEx_CommutationCallback",
        "HAL_TIM_IC_CaptureCallback",
        "HAL_TIMEx_BreakCallback",
        "HAL_TIM_TriggerCallback",
        "HAL_TIM_PWM_PulseFinishedCallback"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004092": {
      "entrypoint": "0x08004092",
      "current_name": "FUN_08004092",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004092(TIM_TypeDef *TIMx,uint32_t Channel,uint32_t ChannelState)\n\n{\n  TIMx-\u003eCCER \u003d TIMx-\u003eCCER \u0026 ~(1 \u003c\u003c (Channel \u0026 0xff));\n  TIMx-\u003eCCER \u003d TIMx-\u003eCCER | ChannelState \u003c\u003c (Channel \u0026 0xff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_PWM_Stop"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080040b0": {
      "entrypoint": "0x080040b0",
      "current_name": "FUN_080040b0",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_080040b0(TIM_HandleTypeDef *htim,uint32_t Channel)\n\n{\n  TIM_TypeDef *pTVar1;\n  \n  TIM_CCxChannelCmd(htim-\u003eInstance,Channel,0);\n  if (((htim-\u003eInstance \u003d\u003d (TIM_TypeDef *)0x40012c00) \u0026\u0026 ((uRam40012c20 \u0026 0x1111) \u003d\u003d 0)) \u0026\u0026\n     ((uRam40012c20 \u0026 0x444) \u003d\u003d 0)) {\n    uRam40012c44 \u003d uRam40012c44 \u0026 0xffff7fff;\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eCCER \u0026 0x1111) \u003d\u003d 0) \u0026\u0026 ((pTVar1-\u003eCCER \u0026 0x444) \u003d\u003d 0)) {\n    pTVar1-\u003eCR1 \u003d pTVar1-\u003eCR1 \u0026 0xfffffffe;\n  }\n  htim-\u003eState \u003d HAL_TIM_STATE_READY;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_stop"
      ],
      "called": [
        "TIM_CCxChannelCmd"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004110": {
      "entrypoint": "0x08004110",
      "current_name": "FUN_08004110",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004110(TIM_TypeDef *TIMx,uint32_t Channel,uint32_t ChannelNState)\n\n{\n  TIMx-\u003eCCER \u003d TIMx-\u003eCCER \u0026 ~(4 \u003c\u003c (Channel \u0026 0xff));\n  TIMx-\u003eCCER \u003d TIMx-\u003eCCER | ChannelNState \u003c\u003c (Channel \u0026 0xff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIMEx_PWMN_Stop"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800412c": {
      "entrypoint": "0x0800412c",
      "current_name": "FUN_0800412c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_0800412c(TIM_HandleTypeDef *htim,uint32_t Channel)\n\n{\n  TIM_TypeDef *pTVar1;\n  \n  TIM_CCxNChannelCmd(htim-\u003eInstance,Channel,0);\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eCCER \u0026 0x1111) \u003d\u003d 0) \u0026\u0026 ((pTVar1-\u003eCCER \u0026 0x444) \u003d\u003d 0)) {\n    pTVar1-\u003eBDTR \u003d pTVar1-\u003eBDTR \u0026 0xffff7fff;\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eCCER \u0026 0x1111) \u003d\u003d 0) \u0026\u0026 ((pTVar1-\u003eCCER \u0026 0x444) \u003d\u003d 0)) {\n    pTVar1-\u003eCR1 \u003d pTVar1-\u003eCR1 \u0026 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_stop"
      ],
      "called": [
        "TIM_CCxNChannelCmd"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004178": {
      "entrypoint": "0x08004178",
      "current_name": "FUN_08004178",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004178(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800417a": {
      "entrypoint": "0x0800417a",
      "current_name": "FUN_0800417a",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_0800417a(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800417c": {
      "entrypoint": "0x0800417c",
      "current_name": "FUN_0800417c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_0800417c(UART_HandleTypeDef *huart)\n\n{\n  huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xfffffedf;\n  huart-\u003eInstance-\u003eCR3 \u003d huart-\u003eInstance-\u003eCR3 \u0026 0xfffffffe;\n  huart-\u003eRxState \u003d HAL_UART_STATE_READY;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_IRQHandler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004198": {
      "entrypoint": "0x08004198",
      "current_name": "FUN_08004198",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08004198(UART_HandleTypeDef *huart)\n\n{\n  uint16_t uVar1;\n  byte *pbVar2;\n  uint16_t *tmp;\n  \n  if (huart-\u003egState !\u003d HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  if ((huart-\u003eInit).WordLength \u003d\u003d 0x1000) {\n    huart-\u003eInstance-\u003eDR \u003d *(ushort *)huart-\u003epTxBuffPtr \u0026 0x1ff;\n    if ((huart-\u003eInit).Parity \u003d\u003d 0) {\n      huart-\u003epTxBuffPtr \u003d huart-\u003epTxBuffPtr + 2;\n    }\n    else {\n      huart-\u003epTxBuffPtr \u003d huart-\u003epTxBuffPtr + 1;\n    }\n  }\n  else {\n    pbVar2 \u003d huart-\u003epTxBuffPtr;\n    huart-\u003epTxBuffPtr \u003d pbVar2 + 1;\n    huart-\u003eInstance-\u003eDR \u003d (uint)*pbVar2;\n  }\n  uVar1 \u003d huart-\u003eTxXferCount - 1;\n  huart-\u003eTxXferCount \u003d uVar1;\n  if (uVar1 \u003d\u003d 0) {\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xffffff7f;\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 | 0x40;\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_IRQHandler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004204": {
      "entrypoint": "0x08004204",
      "current_name": "FUN_08004204",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004204(UART_HandleTypeDef *huart)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  uint32_t uVar5;\n  uint32_t uVar6;\n  uint32_t uVar7;\n  uint32_t uVar8;\n  uint32_t uVar9;\n  USART_TypeDef *pUVar10;\n  \n  huart-\u003eInstance-\u003eCR2 \u003d huart-\u003eInstance-\u003eCR2 \u0026 0xffffcfff | (huart-\u003eInit).StopBits;\n  huart-\u003eInstance-\u003eCR1 \u003d\n       (huart-\u003eInit).WordLength | (huart-\u003eInit).Parity | (huart-\u003eInit).Mode |\n       huart-\u003eInstance-\u003eCR1 \u0026 0xffffe9f3;\n  huart-\u003eInstance-\u003eCR3 \u003d huart-\u003eInstance-\u003eCR3 \u0026 0xfffffcff | (huart-\u003eInit).HwFlowCtl;\n  pUVar10 \u003d huart-\u003eInstance;\n  if (pUVar10 !\u003d (USART_TypeDef *)0x40013800) {\n    uVar1 \u003d HAL_RCC_GetPCLK1Freq();\n    uVar6 \u003d (huart-\u003eInit).BaudRate;\n    uVar2 \u003d HAL_RCC_GetPCLK1Freq();\n    uVar7 \u003d (huart-\u003eInit).BaudRate;\n    uVar3 \u003d HAL_RCC_GetPCLK1Freq();\n    uVar8 \u003d (huart-\u003eInit).BaudRate;\n    uVar4 \u003d HAL_RCC_GetPCLK1Freq();\n    uVar9 \u003d (huart-\u003eInit).BaudRate;\n    uVar5 \u003d HAL_RCC_GetPCLK1Freq();\n    pUVar10-\u003eBRR \u003d ((uint)((int)((ulonglong)\n                                 (((uVar4 * 0x19) / (uVar9 \u003c\u003c 2) +\n                                  (int)(((ulonglong)(uVar5 * 0x19) /\n                                        (ulonglong)((huart-\u003eInit).BaudRate \u003c\u003c 2)) / 100) * -100) *\n                                  0x10 + 0x32) * 0x51eb851f \u003e\u003e 0x20) \u003c\u003c 0x17) \u003e\u003e 0x1c) +\n                   ((((uVar2 * 0x19) / (uVar7 \u003c\u003c 2) +\n                     (int)(((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 \u003c\u003c 2)) / 100) * -100) *\n                     0x10 + 0x32) / 100 \u0026 0xf0) +\n                   (int)(((ulonglong)(uVar1 * 0x19) / (ulonglong)(uVar6 \u003c\u003c 2)) / 100) * 0x10;\n    return;\n  }\n  uVar1 \u003d HAL_RCC_GetPCLK2Freq();\n  uVar6 \u003d (huart-\u003eInit).BaudRate;\n  uVar2 \u003d HAL_RCC_GetPCLK2Freq();\n  uVar7 \u003d (huart-\u003eInit).BaudRate;\n  uVar3 \u003d HAL_RCC_GetPCLK2Freq();\n  uVar8 \u003d (huart-\u003eInit).BaudRate;\n  uVar4 \u003d HAL_RCC_GetPCLK2Freq();\n  uVar9 \u003d (huart-\u003eInit).BaudRate;\n  uVar5 \u003d HAL_RCC_GetPCLK2Freq();\n  iRam40013808 \u003d ((uint)((int)((ulonglong)\n                               (((uVar4 * 0x19) / (uVar9 \u003c\u003c 2) +\n                                (int)(((ulonglong)(uVar5 * 0x19) /\n                                      (ulonglong)((huart-\u003eInit).BaudRate \u003c\u003c 2)) / 100) * -100) *\n                                0x10 + 0x32) * 0x51eb851f \u003e\u003e 0x20) \u003c\u003c 0x17) \u003e\u003e 0x1c) +\n                 ((((uVar2 * 0x19) / (uVar7 \u003c\u003c 2) +\n                   (int)(((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 \u003c\u003c 2)) / 100) * -100) * 0x10\n                  + 0x32) / 100 \u0026 0xf0) +\n                 (int)(((ulonglong)(uVar1 * 0x19) / (ulonglong)(uVar6 \u003c\u003c 2)) / 100) * 0x10;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_Init"
      ],
      "called": [
        "HAL_RCC_GetPCLK1Freq",
        "HAL_RCC_GetPCLK2Freq"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080043b4": {
      "entrypoint": "0x080043b4",
      "current_name": "FUN_080043b4",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nFUN_080043b4(UART_HandleTypeDef *huart,uint32_t Flag,FlagStatus Status,uint32_t Tickstart,\n            uint32_t Timeout)\n\n{\n  uint32_t uVar1;\n  \n  do {\n    if (((Flag \u0026 ~huart-\u003eInstance-\u003eSR) \u003d\u003d 0) !\u003d (bool)Status) {\n      return HAL_OK;\n    }\n  } while ((Timeout \u003d\u003d 0xffffffff) ||\n          ((Timeout !\u003d 0 \u0026\u0026 (uVar1 \u003d HAL_GetTick(), uVar1 - Tickstart \u003c\u003d Timeout))));\n  huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xfffffe5f;\n  huart-\u003eInstance-\u003eCR3 \u003d huart-\u003eInstance-\u003eCR3 \u0026 0xfffffffe;\n  huart-\u003egState \u003d HAL_UART_STATE_READY;\n  huart-\u003eRxState \u003d HAL_UART_STATE_READY;\n  huart-\u003eLock \u003d HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_Transmit"
      ],
      "called": [
        "HAL_GetTick"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004418": {
      "entrypoint": "0x08004418",
      "current_name": "FUN_08004418",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004418(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_Init"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800441a": {
      "entrypoint": "0x0800441a",
      "current_name": "FUN_0800441a",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_0800441a(UART_HandleTypeDef *huart)\n\n{\n  if (huart !\u003d (UART_HandleTypeDef *)0x0) {\n    if (huart-\u003egState \u003d\u003d HAL_UART_STATE_RESET) {\n      huart-\u003eLock \u003d HAL_UNLOCKED;\n      HAL_UART_MspInit(huart);\n    }\n    huart-\u003egState \u003d HAL_UART_STATE_BUSY;\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xffffdfff;\n    UART_SetConfig(huart);\n    huart-\u003eInstance-\u003eCR2 \u003d huart-\u003eInstance-\u003eCR2 \u0026 0xffffb7ff;\n    huart-\u003eInstance-\u003eCR3 \u003d huart-\u003eInstance-\u003eCR3 \u0026 0xffffffd5;\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 | 0x2000;\n    huart-\u003eErrorCode \u003d 0;\n    huart-\u003egState \u003d HAL_UART_STATE_READY;\n    huart-\u003eRxState \u003d HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_init"
      ],
      "called": [
        "UART_SetConfig",
        "HAL_UART_MspInit"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004478": {
      "entrypoint": "0x08004478",
      "current_name": "FUN_08004478",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nFUN_08004478(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size,uint32_t Timeout)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t Tickstart;\n  uint16_t *tmp;\n  \n  if (huart-\u003egState \u003d\u003d HAL_UART_STATE_READY) {\n    if (pData \u003d\u003d (uint8_t *)0x0) {\n      HVar1 \u003d HAL_ERROR;\n    }\n    else if (Size \u003d\u003d 0) {\n      HVar1 \u003d HAL_ERROR;\n    }\n    else if (huart-\u003eLock \u003d\u003d HAL_LOCKED) {\n      HVar1 \u003d HAL_BUSY;\n    }\n    else {\n      huart-\u003eLock \u003d HAL_LOCKED;\n      huart-\u003eErrorCode \u003d 0;\n      huart-\u003egState \u003d HAL_UART_STATE_BUSY_TX;\n      Tickstart \u003d HAL_GetTick();\n      huart-\u003eTxXferSize \u003d Size;\n      huart-\u003eTxXferCount \u003d Size;\n      while (huart-\u003eTxXferCount !\u003d 0) {\n        huart-\u003eTxXferCount \u003d huart-\u003eTxXferCount - 1;\n        if ((huart-\u003eInit).WordLength \u003d\u003d 0x1000) {\n          HVar1 \u003d UART_WaitOnFlagUntilTimeout(huart,0x80,RESET,Tickstart,Timeout);\n          if (HVar1 !\u003d HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          huart-\u003eInstance-\u003eDR \u003d *(ushort *)pData \u0026 0x1ff;\n          if ((huart-\u003eInit).Parity \u003d\u003d 0) {\n            pData \u003d (uint8_t *)((int)pData + 2);\n          }\n          else {\n            pData \u003d (uint8_t *)((int)pData + 1);\n          }\n        }\n        else {\n          HVar1 \u003d UART_WaitOnFlagUntilTimeout(huart,0x80,RESET,Tickstart,Timeout);\n          if (HVar1 !\u003d HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          huart-\u003eInstance-\u003eDR \u003d (uint)*pData;\n          pData \u003d (uint8_t *)((int)pData + 1);\n        }\n      }\n      HVar1 \u003d UART_WaitOnFlagUntilTimeout(huart,0x40,RESET,Tickstart,Timeout);\n      if (HVar1 \u003d\u003d HAL_OK) {\n        huart-\u003egState \u003d HAL_UART_STATE_READY;\n        huart-\u003eLock \u003d HAL_UNLOCKED;\n        HVar1 \u003d HAL_OK;\n      }\n      else {\n        HVar1 \u003d HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    HVar1 \u003d HAL_BUSY;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_debug_write"
      ],
      "called": [
        "HAL_GetTick",
        "UART_WaitOnFlagUntilTimeout"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800455a": {
      "entrypoint": "0x0800455a",
      "current_name": "FUN_0800455a",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_0800455a(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size)\n\n{\n  if (huart-\u003egState !\u003d HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (pData \u003d\u003d (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (Size \u003d\u003d 0) {\n    return HAL_ERROR;\n  }\n  if (huart-\u003eLock !\u003d HAL_LOCKED) {\n    huart-\u003epTxBuffPtr \u003d pData;\n    huart-\u003eTxXferSize \u003d Size;\n    huart-\u003eTxXferCount \u003d Size;\n    huart-\u003eErrorCode \u003d 0;\n    huart-\u003egState \u003d HAL_UART_STATE_BUSY_TX;\n    huart-\u003eLock \u003d HAL_UNLOCKED;\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 | 0x80;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_attach_tx_callback",
        "HAL_UART_TxCpltCallback"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080045a2": {
      "entrypoint": "0x080045a2",
      "current_name": "FUN_080045a2",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_080045a2(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size)\n\n{\n  if (huart-\u003eRxState !\u003d HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (pData \u003d\u003d (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (Size \u003d\u003d 0) {\n    return HAL_ERROR;\n  }\n  if (huart-\u003eLock !\u003d HAL_LOCKED) {\n    huart-\u003epRxBuffPtr \u003d pData;\n    huart-\u003eRxXferSize \u003d Size;\n    huart-\u003eRxXferCount \u003d Size;\n    huart-\u003eErrorCode \u003d 0;\n    huart-\u003eRxState \u003d HAL_UART_STATE_BUSY_RX;\n    huart-\u003eLock \u003d HAL_UNLOCKED;\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 | 0x100;\n    huart-\u003eInstance-\u003eCR3 \u003d huart-\u003eInstance-\u003eCR3 | 1;\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 | 0x20;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_attach_rx_callback",
        "uart_getc"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080045fe": {
      "entrypoint": "0x080045fe",
      "current_name": "FUN_080045fe",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_080045fe(UART_HandleTypeDef *huart)\n\n{\n  huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xffffffbf;\n  huart-\u003egState \u003d HAL_UART_STATE_READY;\n  HAL_UART_TxCpltCallback(huart);\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_IRQHandler"
      ],
      "called": [
        "HAL_UART_TxCpltCallback"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004618": {
      "entrypoint": "0x08004618",
      "current_name": "FUN_08004618",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict FUN_08004618(UART_HandleTypeDef *huart)\n\n{\n  uint16_t *tmp;\n  byte *pbVar1;\n  uint16_t uVar2;\n  uint8_t *puVar3;\n  \n  if (huart-\u003eRxState !\u003d HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  if ((huart-\u003eInit).WordLength \u003d\u003d 0x1000) {\n    if ((huart-\u003eInit).Parity \u003d\u003d 0) {\n      *(ushort *)huart-\u003epRxBuffPtr \u003d (ushort)((huart-\u003eInstance-\u003eDR \u003c\u003c 0x17) \u003e\u003e 0x17);\n      huart-\u003epRxBuffPtr \u003d huart-\u003epRxBuffPtr + 2;\n    }\n    else {\n      *(ushort *)huart-\u003epRxBuffPtr \u003d (ushort)huart-\u003eInstance-\u003eDR \u0026 0xff;\n      huart-\u003epRxBuffPtr \u003d huart-\u003epRxBuffPtr + 1;\n    }\n  }\n  else if ((huart-\u003eInit).Parity \u003d\u003d 0) {\n    puVar3 \u003d huart-\u003epRxBuffPtr;\n    huart-\u003epRxBuffPtr \u003d puVar3 + 1;\n    *puVar3 \u003d (uint8_t)huart-\u003eInstance-\u003eDR;\n  }\n  else {\n    pbVar1 \u003d huart-\u003epRxBuffPtr;\n    huart-\u003epRxBuffPtr \u003d pbVar1 + 1;\n    *pbVar1 \u003d (byte)huart-\u003eInstance-\u003eDR \u0026 0x7f;\n  }\n  uVar2 \u003d huart-\u003eRxXferCount - 1;\n  huart-\u003eRxXferCount \u003d uVar2;\n  if (uVar2 !\u003d 0) {\n    return HAL_OK;\n  }\n  huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xffffffdf;\n  huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xfffffeff;\n  huart-\u003eInstance-\u003eCR3 \u003d huart-\u003eInstance-\u003eCR3 \u0026 0xfffffffe;\n  huart-\u003eRxState \u003d HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(huart);\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_IRQHandler"
      ],
      "called": [
        "HAL_UART_RxCpltCallback"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080046b8": {
      "entrypoint": "0x080046b8",
      "current_name": "FUN_080046b8",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_080046b8(UART_HandleTypeDef *huart)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint uVar2;\n  uint32_t cr1its;\n  USART_TypeDef *pUVar3;\n  uint32_t cr3its;\n  uint uVar4;\n  uint uVar5;\n  uint32_t isrflags;\n  \n  pUVar3 \u003d huart-\u003eInstance;\n  uVar5 \u003d pUVar3-\u003eSR;\n  uVar2 \u003d pUVar3-\u003eCR1;\n  if ((((uVar5 \u0026 0xf) \u003d\u003d 0) \u0026\u0026 ((uVar5 \u0026 0x20) !\u003d 0)) \u0026\u0026 ((uVar2 \u0026 0x20) !\u003d 0)) {\n    UART_Receive_IT(huart);\n    return;\n  }\n  if (((uVar5 \u0026 0xf) \u003d\u003d 0) || ((uVar4 \u003d pUVar3-\u003eCR3 \u0026 1, uVar4 \u003d\u003d 0 \u0026\u0026 ((uVar2 \u0026 0x120) \u003d\u003d 0)))) {\n    if (((uVar5 \u0026 0x80) !\u003d 0) \u0026\u0026 ((uVar2 \u0026 0x80) !\u003d 0)) {\n      UART_Transmit_IT(huart);\n      return;\n    }\n    if (((uVar5 \u0026 0x40) !\u003d 0) \u0026\u0026 ((uVar2 \u0026 0x40) !\u003d 0)) {\n      UART_EndTransmit_IT(huart);\n    }\n  }\n  else {\n    if (((uVar5 \u0026 1) !\u003d 0) \u0026\u0026 ((uVar2 \u0026 0x100) !\u003d 0)) {\n      huart-\u003eErrorCode \u003d huart-\u003eErrorCode | 1;\n    }\n    if (((uVar5 \u0026 4) !\u003d 0) \u0026\u0026 (uVar4 !\u003d 0)) {\n      huart-\u003eErrorCode \u003d huart-\u003eErrorCode | 2;\n    }\n    if (((uVar5 \u0026 2) !\u003d 0) \u0026\u0026 (uVar4 !\u003d 0)) {\n      huart-\u003eErrorCode \u003d huart-\u003eErrorCode | 4;\n    }\n    if (((uVar5 \u0026 8) !\u003d 0) \u0026\u0026 (uVar4 !\u003d 0)) {\n      huart-\u003eErrorCode \u003d huart-\u003eErrorCode | 8;\n    }\n    if (huart-\u003eErrorCode !\u003d 0) {\n      if (((uVar5 \u0026 0x20) !\u003d 0) \u0026\u0026 ((uVar2 \u0026 0x20) !\u003d 0)) {\n        UART_Receive_IT(huart);\n      }\n      if (((huart-\u003eErrorCode \u0026 8) \u003d\u003d 0) \u0026\u0026 ((huart-\u003eInstance-\u003eCR3 \u0026 0x40) \u003d\u003d 0)) {\n        HAL_UART_ErrorCallback(huart);\n        huart-\u003eErrorCode \u003d 0;\n        return;\n      }\n      UART_EndRxTransfer(huart);\n      pUVar3 \u003d huart-\u003eInstance;\n      if ((pUVar3-\u003eCR3 \u0026 0x40) \u003d\u003d 0) {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      pUVar3-\u003eCR3 \u003d pUVar3-\u003eCR3 \u0026 0xffffffbf;\n      if (huart-\u003ehdmarx \u003d\u003d (DMA_HandleTypeDef *)0x0) {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      huart-\u003ehdmarx-\u003eXferAbortCallback \u003d UART_DMAAbortOnError + 1;\n      HVar1 \u003d HAL_DMA_Abort_IT(huart-\u003ehdmarx);\n      if (HVar1 !\u003d HAL_OK) {\n        (*huart-\u003ehdmarx-\u003eXferAbortCallback)(huart-\u003ehdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "USART2_IRQHandler",
        "USART3_IRQHandler",
        "USART1_IRQHandler"
      ],
      "called": [
        "HAL_DMA_Abort_IT",
        "HAL_UART_ErrorCallback",
        "UART_EndRxTransfer",
        "UART_EndTransmit_IT",
        "UART_Transmit_IT",
        "UART_Receive_IT"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080047d8": {
      "entrypoint": "0x080047d8",
      "current_name": "FUN_080047d8",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_080047d8(DMA_HandleTypeDef *hdma)\n\n{\n  UART_HandleTypeDef *huart_00;\n  UART_HandleTypeDef *huart;\n  \n  huart_00 \u003d (UART_HandleTypeDef *)hdma-\u003eParent;\n  huart_00-\u003eRxXferCount \u003d 0;\n  huart_00-\u003eTxXferCount \u003d 0;\n  HAL_UART_ErrorCallback(huart_00);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_UART_ErrorCallback"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080047e8": {
      "entrypoint": "0x080047e8",
      "current_name": "FUN_080047e8",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_UART_StateTypeDef FUN_080047e8(UART_HandleTypeDef *huart)\n\n{\n  return huart-\u003eRxState | huart-\u003egState;\n}\n\n",
      "renaming": {},
      "calling": [
        "serial_tx_active",
        "serial_rx_active"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080047f4": {
      "entrypoint": "0x080047f4",
      "current_name": "FUN_080047f4",
      "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool FUN_080047f4(PinName_conflict pin,uint32_t *map)\n\n{\n  uint32_t index;\n  \n  index \u003d map[(uint)((int)pin \u003c\u003c 0x18) \u003e\u003e 0x1c];\n  return (_Bool)((byte)(index \u003e\u003e ((int)pin \u0026 0xfU)) \u0026 1);\n}\n\n",
      "renaming": {},
      "calling": [
        "digitalWrite",
        "digitalRead",
        "pinMode"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800480a": {
      "entrypoint": "0x0800480a",
      "current_name": "FUN_0800480a",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_0800480a(PinName_conflict pin,uint32_t *map)\n\n{\n  uint uVar1;\n  uint32_t index;\n  \n  uVar1 \u003d (uint)((int)pin \u003c\u003c 0x18) \u003e\u003e 0x1c;\n  map[uVar1] \u003d map[uVar1] | 1 \u003c\u003c ((int)pin \u0026 0xfU);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004828": {
      "entrypoint": "0x08004828",
      "current_name": "FUN_08004828",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004828(PinName_conflict pin,uint32_t *map)\n\n{\n  uint uVar1;\n  uint32_t index;\n  \n  uVar1 \u003d (uint)((int)pin \u003c\u003c 0x18) \u003e\u003e 0x1c;\n  map[uVar1] \u003d map[uVar1] \u0026 ~(1 \u003c\u003c ((int)pin \u0026 0xfU));\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004848": {
      "entrypoint": "0x08004848",
      "current_name": "FUN_08004848",
      "code": "\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * FUN_08004848(uint32_t port_idx)\n\n{\n  switch(port_idx) {\n  case 0:\n    return (GPIO_TypeDef *)0x40010800;\n  case 1:\n    return (GPIO_TypeDef *)0x40010c00;\n  case 2:\n    return (GPIO_TypeDef *)0x40011000;\n  case 3:\n    return (GPIO_TypeDef *)0x40011400;\n  case 4:\n    return (GPIO_TypeDef *)0x40011800;\n  default:\n    return (GPIO_TypeDef *)0x0;\n  }\n}\n\n",
      "renaming": {},
      "calling": [
        "digitalWrite",
        "digitalRead"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004884": {
      "entrypoint": "0x08004884",
      "current_name": "FUN_08004884",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * FUN_08004884(uint32_t port_idx)\n\n{\n  GPIO_TypeDef *pGVar1;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  \n  switch(port_idx) {\n  case 0:\n    _DAT_40021018 \u003d _DAT_40021018 | 4;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40010800;\n    break;\n  case 1:\n    _DAT_40021018 \u003d _DAT_40021018 | 8;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40010c00;\n    break;\n  case 2:\n    _DAT_40021018 \u003d _DAT_40021018 | 0x10;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40011000;\n    break;\n  case 3:\n    _DAT_40021018 \u003d _DAT_40021018 | 0x20;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40011400;\n    break;\n  case 4:\n    _DAT_40021018 \u003d _DAT_40021018 | 0x40;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40011800;\n    break;\n  default:\n    pGVar1 \u003d (GPIO_TypeDef *)0x0;\n  }\n  return pGVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "digital_io_init",
        "uart_init",
        "HAL_ADC_MspInit"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800492c": {
      "entrypoint": "0x0800492c",
      "current_name": "FUN_0800492c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t FUN_0800492c(PinName_conflict pin)\n\n{\n  uint32_t uVar1;\n  uint32_t function;\n  \n  uVar1 \u003d pinmap_function(pin,(PinMap_conflict *)\u0026PinMap_ADC);\n  function \u003d uVar1 \u003c\u003c 0xc;\n  function \u003d function \u003e\u003e 0x1b;\n  if (0x10 \u003c function - 1) {\n    function \u003d 0;\n  }\n  return function;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [
        "pinmap_function"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004948": {
      "entrypoint": "0x08004948",
      "current_name": "FUN_08004948",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t FUN_08004948(PinName_conflict pin)\n\n{\n  uint32_t uVar1;\n  uint32_t function;\n  \n  uVar1 \u003d pinmap_function(pin,(PinMap_conflict *)\u0026PinMap_PWM);\n  function \u003d uVar1 \u003c\u003c 0xc;\n  function \u003d function \u003e\u003e 0x1b;\n  if (function \u003d\u003d 3) {\n    return 8;\n  }\n  if (function !\u003d 4) {\n    if (function !\u003d 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_stop"
      ],
      "called": [
        "pinmap_function"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004974": {
      "entrypoint": "0x08004974",
      "current_name": "FUN_08004974",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004974(ADC_HandleTypeDef *hadc)\n\n{\n  GPIO_TypeDef *GPIOx;\n  GPIO_TypeDef *port;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (hadc-\u003eInstance \u003d\u003d (ADC_TypeDef *)0x40012400) {\n    _DAT_40021018 \u003d _DAT_40021018 | 0x200;\n  }\n  else if (hadc-\u003eInstance \u003d\u003d (ADC_TypeDef *)0x40012800) {\n    _DAT_40021018 \u003d _DAT_40021018 | 0x400;\n  }\n  GPIOx \u003d set_GPIO_Port_Clock((uint)((int)g_current_pin \u003c\u003c 0x18) \u003e\u003e 0x1c);\n  GPIO_InitStruct.Pin \u003d 1 \u003c\u003c (g_current_pin \u0026 0xfU) \u0026 0xffff;\n  GPIO_InitStruct.Mode \u003d 3;\n  GPIO_InitStruct.Pull \u003d 0;\n  HAL_GPIO_Init(GPIOx,\u0026GPIO_InitStruct);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_ADC_Init"
      ],
      "called": [
        "HAL_GPIO_Init",
        "set_GPIO_Port_Clock"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080049f0": {
      "entrypoint": "0x080049f0",
      "current_name": "FUN_080049f0",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid FUN_080049f0(ADC_HandleTypeDef *hadc)\n\n{\n  if (hadc-\u003eInstance !\u003d (ADC_TypeDef *)0x40012400) {\n    if (hadc-\u003eInstance \u003d\u003d (ADC_TypeDef *)0x40012800) {\n      _DAT_4002100c \u003d _DAT_4002100c \u0026 0xfffffbff;\n      _DAT_40021018 \u003d _DAT_40021018 \u0026 0xfffffbff;\n    }\n    return;\n  }\n  _DAT_4002100c \u003d _DAT_4002100c \u0026 0xfffffdff;\n  _DAT_40021018 \u003d _DAT_40021018 \u0026 0xfffffdff;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_ADC_DeInit"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004a4c": {
      "entrypoint": "0x08004a4c",
      "current_name": "FUN_08004a4c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint16_t FUN_08004a4c(PinName_conflict pin)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint16_t uhADCxConvertedValue;\n  ADC_ChannelConfTypeDef AdcChannelConf;\n  ADC_HandleTypeDef AdcHandle;\n  \n  memset(\u0026AdcHandle,0,0x30);\n  AdcChannelConf.Channel \u003d 0;\n  AdcChannelConf.Rank \u003d 0;\n  AdcChannelConf.SamplingTime \u003d 0;\n  uhADCxConvertedValue \u003d 0;\n  AdcHandle.Instance \u003d (ADC_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)\u0026PinMap_ADC);\n  if (AdcHandle.Instance \u003d\u003d (ADC_TypeDef *)0x0) {\n    uhADCxConvertedValue \u003d 0;\n  }\n  else {\n    AdcHandle.Init.DataAlign \u003d 0;\n    AdcHandle.Init.ScanConvMode \u003d 0;\n    AdcHandle.Init.ContinuousConvMode \u003d 0;\n    AdcHandle.Init.DiscontinuousConvMode \u003d 0;\n    AdcHandle.Init.ExternalTrigConv \u003d 0xe0000;\n    AdcHandle.State \u003d 0;\n    AdcHandle.Init.NbrOfConversion \u003d 1;\n    AdcHandle.Init.NbrOfDiscConversion \u003d 0;\n    g_current_pin \u003d pin;\n    HVar1 \u003d HAL_ADC_Init(\u0026AdcHandle);\n    if (HVar1 \u003d\u003d HAL_OK) {\n      AdcChannelConf.Channel \u003d get_adc_channel(pin);\n      if (AdcChannelConf.Channel \u003c 0x12) {\n        AdcChannelConf.Rank \u003d 1;\n        AdcChannelConf.SamplingTime \u003d 2;\n        HVar1 \u003d HAL_ADC_ConfigChannel(\u0026AdcHandle,\u0026AdcChannelConf);\n        if (HVar1 \u003d\u003d HAL_OK) {\n          HVar1 \u003d HAL_ADCEx_Calibration_Start(\u0026AdcHandle);\n          if (HVar1 \u003d\u003d HAL_OK) {\n            HVar1 \u003d HAL_ADC_Start(\u0026AdcHandle);\n            if (HVar1 \u003d\u003d HAL_OK) {\n              HVar1 \u003d HAL_ADC_PollForConversion(\u0026AdcHandle,10);\n              if (HVar1 \u003d\u003d HAL_OK) {\n                uVar2 \u003d HAL_ADC_GetState(\u0026AdcHandle);\n                if ((uVar2 \u0026 0x200) !\u003d 0) {\n                  uVar2 \u003d HAL_ADC_GetValue(\u0026AdcHandle);\n                  uhADCxConvertedValue \u003d (uint16_t)uVar2;\n                }\n                HVar1 \u003d HAL_ADC_Stop(\u0026AdcHandle);\n                if (HVar1 \u003d\u003d HAL_OK) {\n                  HVar1 \u003d HAL_ADC_DeInit(\u0026AdcHandle);\n                  if (HVar1 !\u003d HAL_OK) {\n                    uhADCxConvertedValue \u003d 0;\n                  }\n                }\n                else {\n                  uhADCxConvertedValue \u003d 0;\n                }\n              }\n              else {\n                uhADCxConvertedValue \u003d 0;\n              }\n            }\n            else {\n              uhADCxConvertedValue \u003d 0;\n            }\n          }\n          else {\n            uhADCxConvertedValue \u003d 0;\n          }\n        }\n        else {\n          uhADCxConvertedValue \u003d 0;\n        }\n      }\n      else {\n        uhADCxConvertedValue \u003d 0;\n      }\n    }\n    else {\n      uhADCxConvertedValue \u003d 0;\n    }\n  }\n  return uhADCxConvertedValue;\n}\n\n",
      "renaming": {},
      "calling": [
        "analogRead"
      ],
      "called": [
        "HAL_ADC_DeInit",
        "HAL_ADC_GetState",
        "get_adc_channel",
        "HAL_ADC_PollForConversion",
        "HAL_ADC_ConfigChannel",
        "HAL_ADC_GetValue",
        "memset",
        "HAL_ADCEx_Calibration_Start",
        "HAL_ADC_Stop",
        "pinmap_peripheral",
        "HAL_ADC_Init",
        "HAL_ADC_Start"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004b34": {
      "entrypoint": "0x08004b34",
      "current_name": "FUN_08004b34",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004b34(TIM_HandleTypeDef *htim)\n\n{\n  timer_disable_clock(htim);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_PWM_DeInit"
      ],
      "called": [
        "timer_disable_clock"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004b3c": {
      "entrypoint": "0x08004b3c",
      "current_name": "FUN_08004b3c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004b3c(PinName_conflict pin)\n\n{\n  uint32_t Channel;\n  uint32_t timChannel;\n  uint32_t uVar1;\n  TIM_HandleTypeDef timHandle;\n  \n  timHandle.Instance \u003d (TIM_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)\u0026PinMap_PWM);\n  if ((timHandle.Instance !\u003d (TIM_TypeDef *)0x0) \u0026\u0026\n     ((((Channel \u003d get_pwm_channel(pin), Channel \u003d\u003d 0 || (Channel \u003d\u003d 4)) || (Channel \u003d\u003d 8)) ||\n      ((Channel \u003d\u003d 0xc || (Channel \u003d\u003d 0x18)))))) {\n    uVar1 \u003d pinmap_function(pin,(PinMap_conflict *)\u0026PinMap_PWM);\n    if ((uVar1 \u0026 0x100000) \u003d\u003d 0) {\n      HAL_TIM_PWM_Stop(\u0026timHandle,Channel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(\u0026timHandle,Channel);\n    }\n    HAL_TIM_PWM_DeInit(\u0026timHandle);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode"
      ],
      "called": [
        "HAL_TIM_PWM_DeInit",
        "HAL_TIM_PWM_Stop",
        "get_pwm_channel",
        "pinmap_peripheral",
        "HAL_TIMEx_PWMN_Stop",
        "pinmap_function"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004b94": {
      "entrypoint": "0x08004b94",
      "current_name": "FUN_08004b94",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t FUN_08004b94(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 \u003d HAL_GetTick();\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "millis"
      ],
      "called": [
        "HAL_GetTick"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004b9c": {
      "entrypoint": "0x08004b9c",
      "current_name": "FUN_08004b9c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004b9c(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SysTick_Handler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004b9e": {
      "entrypoint": "0x08004b9e",
      "current_name": "FUN_08004b9e",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004b9e(void)\n\n{\n  HAL_IncTick();\n  HAL_SYSTICK_IRQHandler();\n  noOsSystickHandler();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_SYSTICK_IRQHandler",
        "noOsSystickHandler",
        "HAL_IncTick"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004bb0": {
      "entrypoint": "0x08004bb0",
      "current_name": "FUN_08004bb0",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004bb0(PinName_conflict pin,uint32_t mode,uint32_t pull)\n\n{\n  uint uVar1;\n  GPIO_TypeDef *GPIOx;\n  GPIO_TypeDef *port;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg;\n  GPIO_InitTypeDef GPIO_InitStructure;\n  \n  uVar1 \u003d (uint)pin;\n  GPIOx \u003d set_GPIO_Port_Clock((uVar1 \u003c\u003c 0x18) \u003e\u003e 0x1c);\n  GPIO_InitStructure.Pin \u003d 1 \u003c\u003c (uVar1 \u0026 0xf) \u0026 0xffff;\n  GPIO_InitStructure.Speed \u003d 3;\n  _DAT_40021018 \u003d _DAT_40021018 | 1;\n  if ((uVar1 - 0xd \u0026 0xff) \u003c 2) {\n    _DAT_40010004 \u003d _DAT_40010004 \u0026 0xf8ffffff | 0x4000000;\n  }\n  if (((uVar1 \u003d\u003d 0xf) || (uVar1 \u003d\u003d 0x13)) || (uVar1 \u003d\u003d 0x14)) {\n    tmpreg_1 \u003d _DAT_40010004 \u0026 0xf8ffffff;\n    _DAT_40010004 \u003d tmpreg_1 | 0x2000000;\n  }\n  GPIO_InitStructure.Mode \u003d mode;\n  GPIO_InitStructure.Pull \u003d pull;\n  HAL_GPIO_Init(GPIOx,\u0026GPIO_InitStructure);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode"
      ],
      "called": [
        "HAL_GPIO_Init",
        "set_GPIO_Port_Clock"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004c30": {
      "entrypoint": "0x08004c30",
      "current_name": "FUN_08004c30",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004c30(GPIO_TypeDef *port,uint32_t pin,uint32_t val)\n\n{\n  if (val \u003d\u003d 0) {\n    HAL_GPIO_WritePin(port,(uint16_t)pin,GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(port,(uint16_t)pin,GPIO_PIN_SET);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "digitalWrite"
      ],
      "called": [
        "HAL_GPIO_WritePin"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004c48": {
      "entrypoint": "0x08004c48",
      "current_name": "FUN_08004c48",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t FUN_08004c48(GPIO_TypeDef *port,uint32_t pin)\n\n{\n  GPIO_PinState GVar1;\n  \n  GVar1 \u003d HAL_GPIO_ReadPin(port,(uint16_t)pin);\n  return (uint)GVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "digitalRead"
      ],
      "called": [
        "HAL_GPIO_ReadPin"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004c52": {
      "entrypoint": "0x08004c52",
      "current_name": "FUN_08004c52",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004c52(void)\n\n{\n  HAL_Init();\n  SystemClock_Config();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "init"
      ],
      "called": [
        "HAL_Init",
        "SystemClock_Config"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004c5e": {
      "entrypoint": "0x08004c5e",
      "current_name": "FUN_08004c5e",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * FUN_08004c5e(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  while( true ) {\n    if (map-\u003epin \u003d\u003d NC) {\n      return (void *)0x0;\n    }\n    if (map-\u003epin \u003d\u003d pin) break;\n    map \u003d map + 1;\n  }\n  return map-\u003eperipheral;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinmap_find_peripheral",
        "pinmap_peripheral"
      ],
      "called": [
        "pinmap_find_peripheral"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004c78": {
      "entrypoint": "0x08004c78",
      "current_name": "FUN_08004c78",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * FUN_08004c78(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  void *pvVar1;\n  \n  if (pin !\u003d NC) {\n    pvVar1 \u003d pinmap_find_peripheral(pin,map);\n    return pvVar1;\n  }\n  return (void *)0x0;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_debug_init",
        "adc_read_value",
        "pwm_stop",
        "uart_init",
        "uart_debug_write"
      ],
      "called": [
        "pinmap_find_peripheral"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004c8a": {
      "entrypoint": "0x08004c8a",
      "current_name": "FUN_08004c8a",
      "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict FUN_08004c8a(void *peripheral,PinMap_conflict *map)\n\n{\n  while( true ) {\n    if (map-\u003eperipheral \u003d\u003d (void *)0x0) {\n      return NC;\n    }\n    if (map-\u003eperipheral \u003d\u003d peripheral) break;\n    map \u003d map + 1;\n  }\n  return map-\u003epin;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinmap_pin",
        "pinmap_find_pin"
      ],
      "called": [
        "pinmap_find_pin"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004ca2": {
      "entrypoint": "0x08004ca2",
      "current_name": "FUN_08004ca2",
      "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict FUN_08004ca2(void *peripheral,PinMap_conflict *map)\n\n{\n  PinName_conflict PVar1;\n  \n  if (peripheral !\u003d (void *)0x0) {\n    PVar1 \u003d pinmap_find_pin(peripheral,map);\n    return PVar1;\n  }\n  return NC;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_debug_init",
        "HardwareSerial"
      ],
      "called": [
        "pinmap_find_pin"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004cb2": {
      "entrypoint": "0x08004cb2",
      "current_name": "FUN_08004cb2",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t FUN_08004cb2(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  while( true ) {\n    if (map-\u003epin \u003d\u003d NC) {\n      return 0xffffffff;\n    }\n    if (map-\u003epin \u003d\u003d pin) break;\n    map \u003d map + 1;\n  }\n  return map-\u003efunction;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinmap_find_function",
        "pinmap_function"
      ],
      "called": [
        "pinmap_find_function"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004cce": {
      "entrypoint": "0x08004cce",
      "current_name": "FUN_08004cce",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t FUN_08004cce(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  uint32_t uVar1;\n  \n  if (pin \u003d\u003d NC) {\n    return 0xffffffff;\n  }\n  uVar1 \u003d pinmap_find_function(pin,map);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "get_adc_channel",
        "pwm_stop",
        "get_pwm_channel",
        "uart_init"
      ],
      "called": [
        "pinmap_find_function"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004ce2": {
      "entrypoint": "0x08004ce2",
      "current_name": "FUN_08004ce2",
      "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool FUN_08004ce2(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  if (pin \u003d\u003d NC) {\n    return false;\n  }\n  while( true ) {\n    if (map-\u003epin \u003d\u003d NC) {\n      return false;\n    }\n    if (pin \u003d\u003d map-\u003epin) break;\n    map \u003d map + 1;\n  }\n  return true;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004d06": {
      "entrypoint": "0x08004d06",
      "current_name": "FUN_08004d06",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * FUN_08004d06(void *a,void *b)\n\n{\n  if (a !\u003d b) {\n    if (a \u003d\u003d (void *)0x0) {\n      return b;\n    }\n    if (b \u003d\u003d (void *)0x0) {\n      return a;\n    }\n    a \u003d (void *)0x0;\n  }\n  return a;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_init"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004d18": {
      "entrypoint": "0x08004d18",
      "current_name": "FUN_08004d18",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004d18(RTC_HandleTypeDef *hrtc)\n\n{\n  if (RTCUserCallback !\u003d (voidCallbackPtr)0x0) {\n    (*RTCUserCallback)(callbackUserData);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_RTC_AlarmIRQHandler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004d30": {
      "entrypoint": "0x08004d30",
      "current_name": "FUN_08004d30",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004d30(void)\n\n{\n  HAL_RTC_AlarmIRQHandler(\u0026RtcHandle);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_RTC_AlarmIRQHandler"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004d40": {
      "entrypoint": "0x08004d40",
      "current_name": "FUN_08004d40",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004d40(char *msg,int val)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "_Error_Handler",
        "SystemClock_Config"
      ],
      "called": [
        "_Error_Handler"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004d44": {
      "entrypoint": "0x08004d44",
      "current_name": "FUN_08004d44",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004d44(void)\n\n{\n  _DAT_40021000 \u003d _DAT_40021000 \u0026 0xfef2ffff | 1;\n  _DAT_40021004 \u003d _DAT_40021004 \u0026 0xf8800000;\n  _DAT_40021008 \u003d 0x9f0000;\n  _DAT_e000ed08 \u003d 0x8000000;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "Reset_Handler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004d90": {
      "entrypoint": "0x08004d90",
      "current_name": "FUN_08004d90",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004d90(TIM_HandleTypeDef *htim)\n\n{\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef *)0x40012c00) {\n    _DAT_40021018 \u003d _DAT_40021018 \u0026 0xfffff7ff;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef *)0x40000000) {\n    _DAT_4002101c \u003d _DAT_4002101c \u0026 0xfffffffe;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef *)0x40000400) {\n    _DAT_4002101c \u003d _DAT_4002101c \u0026 0xfffffffd;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef *)0x40000800) {\n    _DAT_4002101c \u003d _DAT_4002101c \u0026 0xfffffffb;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_PWM_MspDeInit"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004df4": {
      "entrypoint": "0x08004df4",
      "current_name": "FUN_08004df4",
      "code": "\n/* WARNING: Unknown calling convention */\n\nstimer_t * FUN_08004df4(TIM_HandleTypeDef *htim)\n\n{\n  return (stimer_t *)\u0026htim[-1].Lock;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_OC_DelayElapsedCallback",
        "HAL_TIM_PeriodElapsedCallback"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004df8": {
      "entrypoint": "0x08004df8",
      "current_name": "FUN_08004df8",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004df8(TIM_HandleTypeDef *htim)\n\n{\n  stimer_t *psVar1;\n  stimer_t *obj;\n  \n  psVar1 \u003d get_timer_obj(htim);\n  if ((psVar1-\u003eirqHandleOC !\u003d (_func_void_stimer_t_ptr_uint32_t *)0x0) \u0026\u0026\n     (htim-\u003eChannel \u003d\u003d HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*psVar1-\u003eirqHandleOC)(psVar1,0);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [
        "get_timer_obj"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004e12": {
      "entrypoint": "0x08004e12",
      "current_name": "FUN_08004e12",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004e12(TIM_HandleTypeDef *htim)\n\n{\n  stimer_t *psVar1;\n  stimer_t *obj;\n  \n  psVar1 \u003d get_timer_obj(htim);\n  if (psVar1-\u003eirqHandle !\u003d (_func_void_stimer_t_ptr *)0x0) {\n    (*psVar1-\u003eirqHandle)(psVar1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [
        "get_timer_obj"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004e20": {
      "entrypoint": "0x08004e20",
      "current_name": "FUN_08004e20",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004e20(void)\n\n{\n  if (timer_handles[0] !\u003d (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[0]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004e34": {
      "entrypoint": "0x08004e34",
      "current_name": "FUN_08004e34",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004e34(void)\n\n{\n  if (timer_handles[1] !\u003d (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[1]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004e48": {
      "entrypoint": "0x08004e48",
      "current_name": "FUN_08004e48",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004e48(void)\n\n{\n  if (timer_handles[2] !\u003d (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[2]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004e5c": {
      "entrypoint": "0x08004e5c",
      "current_name": "FUN_08004e5c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004e5c(void)\n\n{\n  if (timer_handles[3] !\u003d (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[3]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004e70": {
      "entrypoint": "0x08004e70",
      "current_name": "FUN_08004e70",
      "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_t * FUN_08004e70(I2C_HandleTypeDef *hi2c)\n\n{\n  return (i2c_t *)\u0026hi2c[-1].EventCount;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_AddrCallback",
        "HAL_I2C_ListenCpltCallback",
        "HAL_I2C_ErrorCallback"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004e74": {
      "entrypoint": "0x08004e74",
      "current_name": "FUN_08004e74",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004e74(I2C_HandleTypeDef *hi2c,uint8_t TransferDirection,uint16_t AddrMatchCode)\n\n{\n  i2c_t *piVar1;\n  i2c_t *obj;\n  \n  piVar1 \u003d get_i2c_obj(hi2c);\n  if ((uint)AddrMatchCode \u003d\u003d (hi2c-\u003eInit).OwnAddress1) {\n    if (TransferDirection \u003d\u003d \u0027\\0\u0027) {\n      piVar1-\u003ei2cTxRxBufferSize \u003d \u0027\\0\u0027;\n      piVar1-\u003eslaveMode \u003d \u0027\\0\u0027;\n      if (piVar1-\u003ei2c_onSlaveTransmit !\u003d (_func_void *)0x0) {\n        (*piVar1-\u003ei2c_onSlaveTransmit)();\n      }\n      HAL_I2C_Slave_Sequential_Transmit_IT\n                (hi2c,piVar1-\u003ei2cTxRxBuffer,(ushort)piVar1-\u003ei2cTxRxBufferSize,8);\n      return;\n    }\n    piVar1-\u003eslaveMode \u003d \u0027\\x01\u0027;\n    HAL_I2C_Slave_Sequential_Receive_IT(hi2c,piVar1-\u003ei2cTxRxBuffer,0x20,8);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_Slave_ADDR"
      ],
      "called": [
        "HAL_I2C_Slave_Sequential_Receive_IT",
        "HAL_I2C_Slave_Sequential_Transmit_IT",
        "get_i2c_obj"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004ec4": {
      "entrypoint": "0x08004ec4",
      "current_name": "FUN_08004ec4",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004ec4(I2C_HandleTypeDef *hi2c)\n\n{\n  i2c_t *piVar1;\n  i2c_t *obj;\n  uint uVar2;\n  \n  piVar1 \u003d get_i2c_obj(hi2c);\n  if (((piVar1-\u003ei2c_onSlaveReceive !\u003d (_func_void_uint8_t_ptr_int *)0x0) \u0026\u0026\n      (piVar1-\u003eslaveMode \u003d\u003d \u0027\\x01\u0027)) \u0026\u0026\n     (uVar2 \u003d 0x20 - *(byte *)\u0026(piVar1-\u003ehandle).XferSize \u0026 0xff, uVar2 !\u003d 0)) {\n    (*piVar1-\u003ei2c_onSlaveReceive)(piVar1-\u003ei2cTxRxBuffer,uVar2);\n  }\n  HAL_I2C_EnableListen_IT(hi2c);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_ITError",
        "I2C_Slave_AF",
        "I2C_Slave_STOPF"
      ],
      "called": [
        "HAL_I2C_EnableListen_IT",
        "get_i2c_obj"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004ef4": {
      "entrypoint": "0x08004ef4",
      "current_name": "FUN_08004ef4",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004ef4(I2C_HandleTypeDef *hi2c)\n\n{\n  i2c_t *piVar1;\n  i2c_t *obj;\n  \n  piVar1 \u003d get_i2c_obj(hi2c);\n  if (piVar1-\u003eisMaster \u003d\u003d \u0027\\0\u0027) {\n    HAL_I2C_EnableListen_IT(hi2c);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_DMAAbort",
        "I2C_ITError"
      ],
      "called": [
        "HAL_I2C_EnableListen_IT",
        "get_i2c_obj"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004f0c": {
      "entrypoint": "0x08004f0c",
      "current_name": "FUN_08004f0c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004f0c(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2c_handles);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004f1c": {
      "entrypoint": "0x08004f1c",
      "current_name": "FUN_08004f1c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004f1c(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c_handles);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_I2C_ER_IRQHandler"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004f2c": {
      "entrypoint": "0x08004f2c",
      "current_name": "FUN_08004f2c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004f2c(void)\n\n{\n  HAL_I2C_EV_IRQHandler(I2C2_ER_IRQHandler::handle);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004f3c": {
      "entrypoint": "0x08004f3c",
      "current_name": "FUN_08004f3c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004f3c(void)\n\n{\n  HAL_I2C_ER_IRQHandler(I2C2_ER_IRQHandler::handle);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_I2C_ER_IRQHandler"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08004f4c": {
      "entrypoint": "0x08004f4c",
      "current_name": "FUN_08004f4c",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08004f4c(serial_t *obj)\n\n{\n  void *a;\n  USART_TypeDef *uart_tx;\n  void *b;\n  USART_TypeDef *uart_rx;\n  USART_TypeDef *pUVar1;\n  GPIO_TypeDef *pGVar2;\n  GPIO_TypeDef *port;\n  uint32_t uVar3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  uint32_t tmpreg_10;\n  uint32_t tmpreg_11;\n  uint32_t tmpreg_12;\n  uint32_t tmpreg_13;\n  uint32_t tmpreg_14;\n  uint32_t tmpreg_15;\n  uint32_t tmpreg_16;\n  UART_HandleTypeDef *huart;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (obj !\u003d (serial_t *)0x0) {\n    a \u003d pinmap_peripheral(obj-\u003epin_tx,(PinMap_conflict *)\u0026PinMap_UART_TX);\n    b \u003d pinmap_peripheral(obj-\u003epin_rx,(PinMap_conflict *)\u0026PinMap_UART_RX);\n    if ((b \u003d\u003d (void *)0x0) || (a \u003d\u003d (void *)0x0)) {\n      iprintf(\"ERROR: at least one UART pin has no peripheral\\n\");\n    }\n    else {\n      pUVar1 \u003d (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      obj-\u003euart \u003d pUVar1;\n      if (pUVar1 \u003d\u003d (USART_TypeDef *)0x0) {\n        iprintf(\"ERROR: U(S)ART pins mismatch\\n\");\n      }\n      else {\n        if (pUVar1 \u003d\u003d (USART_TypeDef *)0x40013800) {\n          _DAT_4002100c \u003d _DAT_4002100c \u0026 0xffffbfff;\n          _DAT_40021018 \u003d _DAT_40021018 | 0x4000;\n          obj-\u003eindex \u003d \u0027\\0\u0027;\n          obj-\u003eirq \u003d USART1_IRQn;\n        }\n        else if (pUVar1 \u003d\u003d (USART_TypeDef *)0x40004400) {\n          _DAT_40021010 \u003d _DAT_40021010 \u0026 0xfffdffff;\n          _DAT_4002101c \u003d _DAT_4002101c | 0x20000;\n          obj-\u003eindex \u003d \u0027\\x01\u0027;\n          obj-\u003eirq \u003d USART2_IRQn;\n        }\n        else if (pUVar1 \u003d\u003d (USART_TypeDef *)0x40004800) {\n          _DAT_40021010 \u003d _DAT_40021010 \u0026 0xfffbffff;\n          _DAT_4002101c \u003d _DAT_4002101c | 0x40000;\n          obj-\u003eindex \u003d \u0027\\x02\u0027;\n          obj-\u003eirq \u003d USART3_IRQn;\n        }\n        pGVar2 \u003d set_GPIO_Port_Clock((uint)((int)obj-\u003epin_rx \u003c\u003c 0x18) \u003e\u003e 0x1c);\n        uVar3 \u003d pinmap_function(obj-\u003epin_rx,(PinMap_conflict *)\u0026PinMap_UART_RX);\n        GPIO_InitStruct.Pin \u003d 1 \u003c\u003c (obj-\u003epin_rx \u0026 0xfU) \u0026 0xffff;\n        GPIO_InitStruct.Mode \u003d (uVar3 \u003e\u003e 3 \u0026 1) \u003c\u003c 4 | uVar3 \u0026 7;\n        GPIO_InitStruct.Pull \u003d (uVar3 \u003c\u003c 0x1a) \u003e\u003e 0x1e;\n        _DAT_40021018 \u003d _DAT_40021018 | 1;\n        switch((uVar3 \u003c\u003c 0x11) \u003e\u003e 0x19) {\n        case 1:\n          tmpreg_13 \u003d tmpreg_13 | 0x7000001;\n          break;\n        case 2:\n          tmpreg_13 \u003d tmpreg_13 \u0026 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          tmpreg_13 \u003d tmpreg_13 | 0x7000002;\n          break;\n        case 4:\n          tmpreg_13 \u003d tmpreg_13 \u0026 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          tmpreg_13 \u003d tmpreg_13 | 0x7000004;\n          break;\n        case 6:\n          tmpreg_13 \u003d tmpreg_13 \u0026 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          tmpreg_13 \u003d tmpreg_13 | 0x7000008;\n          break;\n        case 8:\n          tmpreg_13 \u003d tmpreg_13 \u0026 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          tmpreg_13 \u003d tmpreg_13 | 0x7000030;\n          break;\n        case 10:\n          tmpreg_4 \u003d tmpreg_13 \u0026 0xffffffcf;\n          tmpreg_13 \u003d tmpreg_4 | 0x7000010;\n          break;\n        case 0xb:\n          tmpreg_5 \u003d tmpreg_13 \u0026 0xffffffcf;\n          tmpreg_13 \u003d tmpreg_5 | 0x7000000;\n          break;\n        case 0xc:\n          tmpreg_13 \u003d tmpreg_13 | 0x70000c0;\n          break;\n        case 0xd:\n          tmpreg_6 \u003d tmpreg_13 \u0026 0xffffff3f;\n          tmpreg_13 \u003d tmpreg_6 | 0x7000040;\n          break;\n        case 0xe:\n          tmpreg_7 \u003d tmpreg_13 \u0026 0xffffff3f;\n          tmpreg_13 \u003d tmpreg_7 | 0x7000000;\n          break;\n        case 0xf:\n          tmpreg_13 \u003d tmpreg_13 | 0x7000300;\n          break;\n        case 0x10:\n          tmpreg_8 \u003d tmpreg_13 \u0026 0xfffffcff;\n          tmpreg_13 \u003d tmpreg_8 | 0x7000200;\n          break;\n        case 0x11:\n          tmpreg_9 \u003d tmpreg_13 \u0026 0xfffffcff;\n          tmpreg_13 \u003d tmpreg_9 | 0x7000100;\n          break;\n        case 0x12:\n          tmpreg_10 \u003d tmpreg_13 \u0026 0xfffffcff;\n          tmpreg_13 \u003d tmpreg_10 | 0x7000000;\n          break;\n        case 0x13:\n          tmpreg_13 \u003d tmpreg_13 | 0x7000c00;\n          break;\n        case 0x14:\n          tmpreg_11 \u003d tmpreg_13 \u0026 0xfffff3ff;\n          tmpreg_13 \u003d tmpreg_11 | 0x7000800;\n          break;\n        case 0x15:\n          tmpreg_12 \u003d tmpreg_13 \u0026 0xfffff3ff;\n          tmpreg_13 \u003d tmpreg_12 | 0x7000000;\n          break;\n        case 0x16:\n          tmpreg_13 \u003d tmpreg_13 | 0x7001000;\n          break;\n        case 0x17:\n          tmpreg_13 \u003d tmpreg_13 \u0026 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          tmpreg_13 \u003d tmpreg_13 | 0x7008000;\n          break;\n        case 0x1c:\n          tmpreg_13 \u003d tmpreg_13 \u0026 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          tmpreg_13 \u003d tmpreg_13 \u0026 0xf8ffffff;\n          break;\n        case 0x22:\n          tmpreg_14 \u003d tmpreg_13 \u0026 0xf8ffffff;\n          tmpreg_13 \u003d tmpreg_14 | 0x1000000;\n          break;\n        case 0x23:\n          tmpreg_15 \u003d tmpreg_13 \u0026 0xf8ffffff;\n          tmpreg_13 \u003d tmpreg_15 | 0x2000000;\n          break;\n        case 0x24:\n          tmpreg_16 \u003d tmpreg_13 \u0026 0xf8ffffff;\n          tmpreg_13 \u003d tmpreg_16 | 0x4000000;\n        }\n        GPIO_InitStruct.Speed \u003d 3;\n        HAL_GPIO_Init(pGVar2,\u0026GPIO_InitStruct);\n        pGVar2 \u003d set_GPIO_Port_Clock((uint)((int)obj-\u003epin_tx \u003c\u003c 0x18) \u003e\u003e 0x1c);\n        uVar3 \u003d pinmap_function(obj-\u003epin_tx,(PinMap_conflict *)\u0026PinMap_UART_TX);\n        GPIO_InitStruct.Pin \u003d 1 \u003c\u003c (obj-\u003epin_tx \u0026 0xfU) \u0026 0xffff;\n        GPIO_InitStruct.Mode \u003d (uVar3 \u003e\u003e 3 \u0026 1) \u003c\u003c 4 | uVar3 \u0026 7;\n        GPIO_InitStruct.Pull \u003d (uVar3 \u003c\u003c 0x1a) \u003e\u003e 0x1e;\n        HAL_GPIO_Init(pGVar2,\u0026GPIO_InitStruct);\n        uart_handlers[obj-\u003eindex] \u003d \u0026obj-\u003ehandle;\n        (obj-\u003ehandle).Instance \u003d obj-\u003euart;\n        (obj-\u003ehandle).Init.BaudRate \u003d obj-\u003ebaudrate;\n        (obj-\u003ehandle).Init.WordLength \u003d obj-\u003edatabits;\n        (obj-\u003ehandle).Init.StopBits \u003d obj-\u003estopbits;\n        (obj-\u003ehandle).Init.Parity \u003d obj-\u003eparity;\n        (obj-\u003ehandle).Init.Mode \u003d 0xc;\n        (obj-\u003ehandle).Init.HwFlowCtl \u003d 0;\n        (obj-\u003ehandle).Init.OverSampling \u003d 0;\n        HAL_UART_Init(\u0026obj-\u003ehandle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "begin",
        "uart_debug_init"
      ],
      "called": [
        "HAL_GPIO_Init",
        "pinmap_merge_peripheral",
        "HAL_UART_Init",
        "set_GPIO_Port_Clock",
        "pinmap_peripheral",
        "iprintf",
        "pinmap_function"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005384": {
      "entrypoint": "0x08005384",
      "current_name": "FUN_08005384",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08005384(void)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d pinmap_peripheral(PA_2,(PinMap_conflict *)\u0026PinMap_UART_TX);\n  if (pvVar1 !\u003d (void *)0x0) {\n    pvVar1 \u003d pinmap_peripheral(PA_2,(PinMap_conflict *)\u0026PinMap_UART_TX);\n    serial_debug.pin_rx \u003d pinmap_pin(pvVar1,(PinMap_conflict *)\u0026PinMap_UART_RX);\n    serial_debug.pin_tx \u003d PA_2;\n    serial_debug.baudrate \u003d 0x2580;\n    serial_debug.parity \u003d 0;\n    serial_debug.databits \u003d 0;\n    serial_debug.stopbits \u003d 0;\n    uart_init(\u0026serial_debug);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_debug_write"
      ],
      "called": [
        "pinmap_pin",
        "pinmap_peripheral",
        "uart_init"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080053d4": {
      "entrypoint": "0x080053d4",
      "current_name": "FUN_080053d4",
      "code": "\n/* WARNING: Unknown calling convention */\n\nsize_t FUN_080053d4(uint8_t *data,uint32_t size)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint32_t tickstart;\n  void *pvVar3;\n  USART_TypeDef *pUVar4;\n  uint32_t uVar5;\n  uint uVar6;\n  \n  uVar2 \u003d HAL_GetTick();\n  pvVar3 \u003d pinmap_peripheral(PA_2,(PinMap_conflict *)\u0026PinMap_UART_TX);\n  if (pvVar3 \u003d\u003d (void *)0x0) {\n    return 0;\n  }\n  uVar6 \u003d 0;\n  while ((uVar6 \u003c 5 \u0026\u0026\n         ((uart_handlers[uVar6] \u003d\u003d (UART_HandleTypeDef *)0x0 ||\n          (pUVar4 \u003d (USART_TypeDef *)pinmap_peripheral(PA_2,(PinMap_conflict *)\u0026PinMap_UART_TX),\n          uart_handlers[uVar6]-\u003eInstance !\u003d pUVar4))))) {\n    uVar6 \u003d uVar6 + 1 \u0026 0xff;\n  }\n  if (4 \u003c uVar6) {\n    if ((4 \u003c serial_debug.index) \u0026\u0026 (uart_debug_init(), 4 \u003c serial_debug.index)) {\n      return 0;\n    }\n    uVar6 \u003d (uint)serial_debug.index;\n  }\n  do {\n    HVar1 \u003d HAL_UART_Transmit(uart_handlers[uVar6],data,(uint16_t)size,1000);\n    if (HVar1 \u003d\u003d HAL_OK) {\n      return size;\n    }\n    uVar5 \u003d HAL_GetTick();\n  } while (uVar5 - uVar2 \u003c 1000);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_write"
      ],
      "called": [
        "HAL_GetTick",
        "uart_debug_init",
        "pinmap_peripheral",
        "HAL_UART_Transmit"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800548c": {
      "entrypoint": "0x0800548c",
      "current_name": "FUN_0800548c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t FUN_0800548c(serial_t *obj)\n\n{\n  HAL_UART_StateTypeDef HVar1;\n  \n  HVar1 \u003d HAL_UART_GetState(uart_handlers[obj-\u003eindex]);\n  return (HVar1 \u0026 0x22) \u003d\u003d 0x22;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_attach_rx_callback",
        "uart_getc"
      ],
      "called": [
        "HAL_UART_GetState"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080054b0": {
      "entrypoint": "0x080054b0",
      "current_name": "FUN_080054b0",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t FUN_080054b0(serial_t *obj)\n\n{\n  HAL_UART_StateTypeDef HVar1;\n  \n  HVar1 \u003d HAL_UART_GetState(uart_handlers[obj-\u003eindex]);\n  return (HVar1 \u0026 0x21) \u003d\u003d 0x21;\n}\n\n",
      "renaming": {},
      "calling": [
        "write"
      ],
      "called": [
        "HAL_UART_GetState"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080054d4": {
      "entrypoint": "0x080054d4",
      "current_name": "FUN_080054d4",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint FUN_080054d4(serial_t *obj,uchar *c)\n\n{\n  uint8_t uVar1;\n  \n  if (obj \u003d\u003d (serial_t *)0x0) {\n    return -1;\n  }\n  uVar1 \u003d serial_rx_active(obj);\n  if (uVar1 \u003d\u003d \u0027\\0\u0027) {\n    *c \u003d obj-\u003erecv;\n    HAL_UART_Receive_IT(uart_handlers[obj-\u003eindex],\u0026obj-\u003erecv,1);\n    return 0;\n  }\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_rx_complete_irq"
      ],
      "called": [
        "HAL_UART_Receive_IT",
        "serial_rx_active"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005510": {
      "entrypoint": "0x08005510",
      "current_name": "FUN_08005510",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08005510(serial_t *obj,_func_void_serial_t_ptr *callback)\n\n{\n  byte bVar1;\n  uint8_t uVar2;\n  \n  if (obj !\u003d (serial_t *)0x0) {\n    uVar2 \u003d serial_rx_active(obj);\n    if (uVar2 \u003d\u003d \u0027\\0\u0027) {\n      bVar1 \u003d obj-\u003eindex;\n      rx_callback[bVar1] \u003d callback;\n      rx_callback_obj[bVar1] \u003d obj;\n      HAL_NVIC_SetPriority(obj-\u003eirq,0,1);\n      HAL_NVIC_EnableIRQ(obj-\u003eirq);\n      HAL_UART_Receive_IT(uart_handlers[obj-\u003eindex],\u0026obj-\u003erecv,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "begin"
      ],
      "called": [
        "HAL_NVIC_SetPriority",
        "HAL_UART_Receive_IT",
        "HAL_NVIC_EnableIRQ",
        "serial_rx_active"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005568": {
      "entrypoint": "0x08005568",
      "current_name": "FUN_08005568",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08005568(serial_t *obj,_func_int_serial_t_ptr *callback)\n\n{\n  byte bVar1;\n  \n  if (obj !\u003d (serial_t *)0x0) {\n    bVar1 \u003d obj-\u003eindex;\n    tx_callback[bVar1] \u003d callback;\n    tx_callback_obj[bVar1] \u003d obj;\n    HAL_NVIC_SetPriority(obj-\u003eirq,0,2);\n    HAL_NVIC_EnableIRQ(obj-\u003eirq);\n    HAL_UART_Transmit_IT(uart_handlers[obj-\u003eindex],obj-\u003etx_buff + obj-\u003etx_tail,1);\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "write"
      ],
      "called": [
        "HAL_NVIC_SetPriority",
        "HAL_UART_Transmit_IT",
        "HAL_NVIC_EnableIRQ"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080055bc": {
      "entrypoint": "0x080055bc",
      "current_name": "FUN_080055bc",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t FUN_080055bc(UART_HandleTypeDef *huart)\n\n{\n  uint uVar1;\n  \n  if (huart \u003d\u003d (UART_HandleTypeDef *)0x0) {\n    uVar1 \u003d 5;\n  }\n  else {\n    uVar1 \u003d 0;\n    while( true ) {\n      if (4 \u003c uVar1) {\n        return (uint8_t)uVar1;\n      }\n      if (huart \u003d\u003d uart_handlers[uVar1]) break;\n      uVar1 \u003d uVar1 + 1 \u0026 0xff;\n    }\n  }\n  return (uint8_t)uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_TxCpltCallback",
        "HAL_UART_RxCpltCallback"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080055e0": {
      "entrypoint": "0x080055e0",
      "current_name": "FUN_080055e0",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_080055e0(UART_HandleTypeDef *huart)\n\n{\n  byte bVar1;\n  uint8_t index;\n  uint uVar2;\n  \n  bVar1 \u003d uart_index(huart);\n  uVar2 \u003d (uint)bVar1;\n  if (uVar2 \u003c 5) {\n    (*rx_callback[uVar2])(rx_callback_obj[uVar2]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "UART_Receive_IT"
      ],
      "called": [
        "uart_index"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005604": {
      "entrypoint": "0x08005604",
      "current_name": "FUN_08005604",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08005604(UART_HandleTypeDef *huart)\n\n{\n  byte bVar1;\n  uint8_t index;\n  int iVar3;\n  serial_t *obj;\n  serial_t *psVar4;\n  uint uVar2;\n  \n  bVar1 \u003d uart_index(huart);\n  uVar2 \u003d (uint)bVar1;\n  psVar4 \u003d tx_callback_obj[uVar2];\n  if ((uVar2 \u003c 5) \u0026\u0026 (iVar3 \u003d (*tx_callback[uVar2])(psVar4), iVar3 !\u003d -1)) {\n    HAL_UART_Transmit_IT(uart_handlers[psVar4-\u003eindex],psVar4-\u003etx_buff + psVar4-\u003etx_tail,1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "UART_EndTransmit_IT"
      ],
      "called": [
        "HAL_UART_Transmit_IT",
        "uart_index"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005650": {
      "entrypoint": "0x08005650",
      "current_name": "FUN_08005650",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08005650(UART_HandleTypeDef *huart)\n\n{\n  uint32_t tmpval;\n  \n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "UART_DMAAbortOnError",
        "HAL_UART_IRQHandler"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005690": {
      "entrypoint": "0x08005690",
      "current_name": "FUN_08005690",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08005690(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART1_IRQn);\n  HAL_UART_IRQHandler(uart_handlers[0]);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_UART_IRQHandler",
        "HAL_NVIC_ClearPendingIRQ"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080056a8": {
      "entrypoint": "0x080056a8",
      "current_name": "FUN_080056a8",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_080056a8(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART2_IRQn);\n  HAL_UART_IRQHandler(uart_handlers[1]);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_UART_IRQHandler",
        "HAL_NVIC_ClearPendingIRQ"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080056c0": {
      "entrypoint": "0x080056c0",
      "current_name": "FUN_080056c0",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_080056c0(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART3_IRQn);\n  if (uart_handlers[2] !\u003d (UART_HandleTypeDef *)0x0) {\n    HAL_UART_IRQHandler(uart_handlers[2]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_UART_IRQHandler",
        "HAL_NVIC_ClearPendingIRQ"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080056d8": {
      "entrypoint": "0x080056d8",
      "current_name": "FUN_080056d8",
      "code": "\nvoid * FUN_080056d8(intptr_t __delta)\n\n{\n  char *pcVar1;\n  char *prev_heap_end;\n  \n  if (_sbrk::heap_end \u003d\u003d (char *)0x0) {\n    _sbrk::heap_end \u003d \u0026_ebss;\n  }\n  pcVar1 \u003d _sbrk::heap_end;\n  if (_sbrk::heap_end + __delta \u003c\u003d \u0026stack0x00000000) {\n    _sbrk::heap_end \u003d _sbrk::heap_end + __delta;\n    return pcVar1;\n  }\n  errno \u003d 0xc;\n  return (void *)0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "_sbrk_r"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005714": {
      "entrypoint": "0x08005714",
      "current_name": "FUN_08005714",
      "code": "\nint FUN_08005714(int __fd)\n\n{\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_close_r"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800571a": {
      "entrypoint": "0x0800571a",
      "current_name": "FUN_0800571a",
      "code": "\nint FUN_0800571a(int __fd,stat *__buf)\n\n{\n  *(undefined4 *)((int)\u0026__buf-\u003est_dev + 4) \u003d 0x2000;\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fstat_r"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005724": {
      "entrypoint": "0x08005724",
      "current_name": "FUN_08005724",
      "code": "\nint FUN_08005724(int __fd)\n\n{\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_isatty_r"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005728": {
      "entrypoint": "0x08005728",
      "current_name": "FUN_08005728",
      "code": "\n__off_t FUN_08005728(int __fd,__off_t __offset,int __whence)\n\n{\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_lseek_r"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800572c": {
      "entrypoint": "0x0800572c",
      "current_name": "FUN_0800572c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint FUN_0800572c(int file_UNUSED,char *ptr_UNUSED,int len_UNUSED)\n\n{\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_read_r"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005730": {
      "entrypoint": "0x08005730",
      "current_name": "FUN_08005730",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint FUN_08005730(int file_UNUSED,char *ptr,int len)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d uart_debug_write((uint8_t *)ptr,len);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_write_r"
      ],
      "called": [
        "uart_debug_write"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800573c": {
      "entrypoint": "0x0800573c",
      "current_name": "FUN_0800573c",
      "code": "\nvoid FUN_0800573c(int __status)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "_exit",
        "abort"
      ],
      "called": [
        "_exit"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005740": {
      "entrypoint": "0x08005740",
      "current_name": "FUN_08005740",
      "code": "\nint FUN_08005740(__pid_t __pid,int __sig)\n\n{\n  errno \u003d 0x16;\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_kill_r"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005750": {
      "entrypoint": "0x08005750",
      "current_name": "FUN_08005750",
      "code": "\n\n\n__pid_t FUN_08005750(void)\n\n{\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_getpid_r"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005754": {
      "entrypoint": "0x08005754",
      "current_name": "FUN_08005754",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t FUN_08005754(uint32_t ulPin)\n\n{\n  bool bVar1;\n  PinName_conflict p;\n  uint16_t uVar2;\n  uint32_t uVar3;\n  \n  if (ulPin \u003c 0xe) {\n    if (ulPin + 0x2e \u003c 0x3c) {\n      bVar1 \u003d true;\n    }\n    else {\n      bVar1 \u003d false;\n    }\n  }\n  else {\n    bVar1 \u003d ulPin \u003c 0x3c;\n  }\n  if (bVar1) {\n    if (ulPin \u003c 0xe) {\n      ulPin \u003d ulPin + 0x2e;\n    }\n    p \u003d (\u0026digitalPin)[ulPin];\n  }\n  else {\n    p \u003d NC;\n  }\n  if (p \u003d\u003d NC) {\n    uVar3 \u003d 0;\n  }\n  else {\n    uVar2 \u003d adc_read_value(p);\n    uVar3 \u003d (uint32_t)uVar2;\n    if (_readResolution !\u003d 0xc) {\n      if ((uint)_readResolution \u003c 0xc) {\n        return (uint)(uVar2 \u003e\u003e (0xcU - _readResolution \u0026 0xff));\n      }\n      return uVar3 \u003c\u003c (_readResolution - 0xcU \u0026 0xff);\n    }\n  }\n  return uVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "adc_read_value"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080057b4": {
      "entrypoint": "0x080057b4",
      "current_name": "FUN_080057b4",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_080057b4(uint32_t ulPin,uint32_t ulMode)\n\n{\n  _Bool _Var1;\n  PinName_conflict p;\n  \n  if (ulPin \u003c 0x3c) {\n    p \u003d (\u0026digitalPin)[ulPin];\n  }\n  else {\n    p \u003d NC;\n  }\n  if (p !\u003d NC) {\n    _Var1 \u003d is_pin_configured(p,g_anOutputPinConfigured);\n    if (_Var1) {\n      _Var1 \u003d pin_in_pinmap(p,(PinMap_conflict *)\u0026PinMap_PWM);\n      if (_Var1) {\n        pwm_stop(p);\n      }\n      reset_pin_configured(p,g_anOutputPinConfigured);\n    }\n    switch(ulMode) {\n    case 0:\n      digital_io_init(p,0,0);\n      break;\n    case 1:\n      digital_io_init(p,1,0);\n      break;\n    case 2:\n      digital_io_init(p,0,1);\n      break;\n    case 3:\n      digital_io_init(p,0,2);\n    }\n    set_pin_configured(p,g_digPinConfigured);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup",
        "MAX31855",
        "begin"
      ],
      "called": [
        "set_pin_configured",
        "pin_in_pinmap",
        "is_pin_configured",
        "digital_io_init",
        "pwm_stop",
        "reset_pin_configured"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005848": {
      "entrypoint": "0x08005848",
      "current_name": "FUN_08005848",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08005848(uint32_t ulPin,uint32_t ulVal)\n\n{\n  _Bool _Var1;\n  GPIO_TypeDef *port;\n  PinName_conflict p;\n  uint uVar2;\n  \n  if (ulPin \u003c 0x3c) {\n    uVar2 \u003d (uint)(char)(\u0026digitalPin)[ulPin];\n  }\n  else {\n    uVar2 \u003d 0xffffffff;\n  }\n  if ((uVar2 !\u003d 0xffffffff) \u0026\u0026\n     (_Var1 \u003d is_pin_configured((PinName_conflict)uVar2,g_digPinConfigured), _Var1)) {\n    port \u003d get_GPIO_Port((uVar2 \u003c\u003c 0x18) \u003e\u003e 0x1c);\n    digital_io_write(port,1 \u003c\u003c (uVar2 \u0026 0xf) \u0026 0xffff,ulVal);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup",
        "pulseEnable",
        "send",
        "MAX31855",
        "begin",
        "loop",
        "readData",
        "write4bits",
        "write8bits"
      ],
      "called": [
        "is_pin_configured",
        "get_GPIO_Port",
        "digital_io_write"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005890": {
      "entrypoint": "0x08005890",
      "current_name": "FUN_08005890",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint FUN_08005890(uint32_t ulPin)\n\n{\n  _Bool _Var1;\n  GPIO_TypeDef *port;\n  uint32_t uVar2;\n  PinName_conflict p;\n  uint uVar3;\n  \n  if (ulPin \u003c 0x3c) {\n    uVar3 \u003d (uint)(char)(\u0026digitalPin)[ulPin];\n  }\n  else {\n    uVar3 \u003d 0xffffffff;\n  }\n  if (uVar3 \u003d\u003d 0xffffffff) {\n    uVar3 \u003d 0;\n  }\n  else {\n    _Var1 \u003d is_pin_configured((PinName_conflict)uVar3,g_digPinConfigured);\n    if (_Var1) {\n      port \u003d get_GPIO_Port((uVar3 \u003c\u003c 0x18) \u003e\u003e 0x1c);\n      uVar2 \u003d digital_io_read(port,1 \u003c\u003c (uVar3 \u0026 0xf) \u0026 0xffff);\n      uVar3 \u003d uVar2 \u0026 0xff;\n    }\n    else {\n      uVar3 \u003d 0;\n    }\n  }\n  if (uVar3 !\u003d 0) {\n    uVar3 \u003d 1;\n  }\n  return uVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop",
        "readData"
      ],
      "called": [
        "is_pin_configured",
        "get_GPIO_Port",
        "digital_io_read"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080058e0": {
      "entrypoint": "0x080058e0",
      "current_name": "FUN_080058e0",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t FUN_080058e0(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 \u003d GetCurrentMilli();\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup",
        "PID",
        "loop",
        "Compute"
      ],
      "called": [
        "GetCurrentMilli"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080058e8": {
      "entrypoint": "0x080058e8",
      "current_name": "FUN_080058e8",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_080058e8(uint32_t ms)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080058ea": {
      "entrypoint": "0x080058ea",
      "current_name": "FUN_080058ea",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint HardwareSerial::FUN_080058ea(serial_t_conflict *obj)\n\n{\n  ushort uVar1;\n  uint16_t uVar2;\n  int iVar3;\n  \n  iVar3 \u003d obj-\u003etx_tail + 1;\n  uVar1 \u003d (ushort)iVar3;\n  uVar2 \u003d uVar1 \u0026 0x7f;\n  if (iVar3 \u003d\u003d 0) {\n    uVar2 \u003d -(-uVar1 \u0026 0x7f);\n  }\n  obj-\u003etx_tail \u003d uVar2;\n  if (obj-\u003etx_head !\u003d obj-\u003etx_tail) {\n    return 0;\n  }\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800591e": {
      "entrypoint": "0x0800591e",
      "current_name": "FUN_0800591e",
      "code": "\n/* DWARF original prototype: int  available(HardwareSerial * this) */\n\nint __thiscall HardwareSerial::FUN_0800591e(HardwareSerial *this)\n\n{\n  return ((this-\u003e_serial).rx_head + 0x40) - (uint)(this-\u003e_serial).rx_tail \u0026 0x3f;\n}\n\n",
      "renaming": {},
      "calling": [
        "serialEventRun"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005932": {
      "entrypoint": "0x08005932",
      "current_name": "FUN_08005932",
      "code": "\n/* DWARF original prototype: int  peek(HardwareSerial * this) */\n\nint __thiscall HardwareSerial::FUN_08005932(HardwareSerial *this)\n\n{\n  uint uVar1;\n  \n  uVar1 \u003d (uint)(this-\u003e_serial).rx_tail;\n  if ((this-\u003e_serial).rx_head !\u003d uVar1) {\n    return (uint)(this-\u003e_serial).rx_buff[uVar1];\n  }\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800594e": {
      "entrypoint": "0x0800594e",
      "current_name": "FUN_0800594e",
      "code": "\n/* DWARF original prototype: int  read(HardwareSerial * this) */\n\nssize_t __thiscall\nHardwareSerial::FUN_0800594e(HardwareSerial *this,int __fd,void *__buf,size_t __nbytes)\n\n{\n  byte bVar1;\n  ushort uVar2;\n  uchar c;\n  \n  uVar2 \u003d (this-\u003e_serial).rx_tail;\n  if ((uint)(this-\u003e_serial).rx_head !\u003d (uint)uVar2) {\n    bVar1 \u003d (this-\u003e_serial).rx_buff[uVar2];\n    (this-\u003e_serial).rx_tail \u003d uVar2 + 1 \u0026 0x3f;\n    return (uint)bVar1;\n  }\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005976": {
      "entrypoint": "0x08005976",
      "current_name": "FUN_08005976",
      "code": "\n/* DWARF original prototype: void  flush(HardwareSerial * this) */\n\nvoid __thiscall HardwareSerial::FUN_08005976(HardwareSerial *this)\n\n{\n  if (this-\u003e_written !\u003d false) {\n    do {\n    } while ((this-\u003e_serial).tx_head !\u003d (this-\u003e_serial).tx_tail);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800598a": {
      "entrypoint": "0x0800598a",
      "current_name": "FUN_0800598a",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HardwareSerial::FUN_0800598a(serial_t_conflict *obj)\n\n{\n  int iVar1;\n  rx_buffer_index_t i;\n  ushort uVar2;\n  uchar c;\n  \n  iVar1 \u003d uart_getc((serial_t *)obj,\u0026c);\n  if ((iVar1 \u003d\u003d 0) \u0026\u0026 (uVar2 \u003d obj-\u003erx_head + 1 \u0026 0x3f, uVar2 !\u003d obj-\u003erx_tail)) {\n    obj-\u003erx_buff[obj-\u003erx_head] \u003d c;\n    obj-\u003erx_head \u003d uVar2;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "uart_getc"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080059c8": {
      "entrypoint": "0x080059c8",
      "current_name": "FUN_080059c8",
      "code": "\n/* DWARF original prototype: size_t  write(HardwareSerial * this, uint8_t c) */\n\nssize_t __thiscall\nHardwareSerial::FUN_080059c8(HardwareSerial *this,int __fd,void *__buf,size_t __n)\n\n{\n  byte bVar1;\n  uint8_t uVar2;\n  byte bVar3;\n  int iVar4;\n  uint uVar5;\n  tx_buffer_index_t i;\n  \n  this-\u003e_written \u003d true;\n  uVar5 \u003d (uint)(this-\u003e_serial).tx_head;\n  iVar4 \u003d uVar5 + 1;\n  bVar1 \u003d (byte)iVar4;\n  bVar3 \u003d bVar1 \u0026 0x7f;\n  if (iVar4 \u003d\u003d 0) {\n    bVar3 \u003d -(-bVar1 \u0026 0x7f);\n  }\n  do {\n  } while ((this-\u003e_serial).tx_tail \u003d\u003d (ushort)bVar3);\n  (this-\u003e_serial).tx_buff[uVar5] \u003d (uint8_t)__fd;\n  (this-\u003e_serial).tx_head \u003d (ushort)bVar3;\n  uVar2 \u003d serial_tx_active((serial_t *)\u0026this-\u003e_serial);\n  if (uVar2 \u003d\u003d \u0027\\0\u0027) {\n    uart_attach_tx_callback((serial_t *)\u0026this-\u003e_serial,_tx_complete_irq + 1);\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "uart_attach_tx_callback",
        "serial_tx_active"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005a18": {
      "entrypoint": "0x08005a18",
      "current_name": "FUN_08005a18",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x08005a1e) */\n/* WARNING: Removing unreachable block (ram,0x08005a30) */\n/* WARNING: Removing unreachable block (ram,0x08005a26) */\n/* WARNING: Removing unreachable block (ram,0x08005a38) */\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08005a18(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "available"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005a44": {
      "entrypoint": "0x08005a44",
      "current_name": "FUN_08005a44",
      "code": "\n/* DWARF original prototype: void  init(HardwareSerial * this) */\n\nint __thiscall HardwareSerial::FUN_08005a44(HardwareSerial *this,EVP_PKEY_CTX *ctx)\n\n{\n  (this-\u003e_serial).rx_buff \u003d this-\u003e_rx_buffer;\n  (this-\u003e_serial).rx_head \u003d 0;\n  (this-\u003e_serial).rx_tail \u003d 0;\n  (this-\u003e_serial).tx_buff \u003d this-\u003e_tx_buffer;\n  (this-\u003e_serial).tx_head \u003d 0;\n  (this-\u003e_serial).tx_tail \u003d 0;\n  return (int)this;\n}\n\n",
      "renaming": {},
      "calling": [
        "HardwareSerial"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005a68": {
      "entrypoint": "0x08005a68",
      "current_name": "FUN_08005a68",
      "code": "\n/* DWARF original prototype: void  begin(HardwareSerial * this, ulong baud, byte config) */\n\nvoid __thiscall HardwareSerial::FUN_08005a68(HardwareSerial *this,ulong baud,byte config)\n\n{\n  byte bVar1;\n  int iVar2;\n  \n  (this-\u003e_serial).baudrate \u003d baud;\n  this-\u003e_config \u003d config;\n  bVar1 \u003d config \u0026 7;\n  if (bVar1 \u003d\u003d 4) {\n    iVar2 \u003d 7;\n  }\n  else if (bVar1 \u003d\u003d 6) {\n    iVar2 \u003d 8;\n  }\n  else if (bVar1 \u003d\u003d 2) {\n    iVar2 \u003d 6;\n  }\n  else {\n    iVar2 \u003d 0;\n  }\n  if ((config \u0026 0x30) \u003d\u003d 0x30) {\n    (this-\u003e_serial).parity \u003d 0x600;\n    iVar2 \u003d iVar2 + 1;\n  }\n  else if ((config \u0026 0x20) \u003d\u003d 0) {\n    (this-\u003e_serial).parity \u003d 0;\n  }\n  else {\n    (this-\u003e_serial).parity \u003d 0x400;\n    iVar2 \u003d iVar2 + 1;\n  }\n  if ((config \u0026 8) \u003d\u003d 0) {\n    (this-\u003e_serial).stopbits \u003d 0;\n  }\n  else {\n    (this-\u003e_serial).stopbits \u003d 0x2000;\n  }\n  if (iVar2 \u003d\u003d 8) {\n    (this-\u003e_serial).databits \u003d 0;\n  }\n  else if (iVar2 \u003d\u003d 9) {\n    (this-\u003e_serial).databits \u003d 0x1000;\n  }\n  else {\n    iVar2 \u003d 0;\n  }\n  if (iVar2 !\u003d 0) {\n    uart_init((serial_t *)\u0026this-\u003e_serial);\n    uart_attach_rx_callback((serial_t *)\u0026this-\u003e_serial,_rx_complete_irq + 1);\n    return;\n  }\n                    \n  __assert_func(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/cores/arduino/HardwareSerial.cpp\"\n                ,299,\"void HardwareSerial::begin(long unsigned int, byte)\",\"databits!\u003d0\");\n}\n\n",
      "renaming": {},
      "calling": [
        "setup"
      ],
      "called": [
        "__assert_func",
        "uart_attach_rx_callback",
        "uart_init"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005b24": {
      "entrypoint": "0x08005b24",
      "current_name": "FUN_08005b24",
      "code": "\n/* DWARF original prototype: void  setRx(HardwareSerial * this, uint32_t _rx) */\n\nvoid __thiscall HardwareSerial::FUN_08005b24(HardwareSerial *this,uint32_t _rx)\n\n{\n  PinName PVar1;\n  \n  if (_rx \u003c 0x3c) {\n    PVar1 \u003d (\u0026digitalPin)[_rx];\n  }\n  else {\n    PVar1 \u003d NC;\n  }\n  (this-\u003e_serial).pin_rx \u003d PVar1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HardwareSerial"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005b3c": {
      "entrypoint": "0x08005b3c",
      "current_name": "FUN_08005b3c",
      "code": "\n/* DWARF original prototype: void  setTx(HardwareSerial * this, uint32_t _tx) */\n\nvoid __thiscall HardwareSerial::FUN_08005b3c(HardwareSerial *this,uint32_t _tx)\n\n{\n  PinName PVar1;\n  \n  if (_tx \u003c 0x3c) {\n    PVar1 \u003d (\u0026digitalPin)[_tx];\n  }\n  else {\n    PVar1 \u003d NC;\n  }\n  (this-\u003e_serial).pin_tx \u003d PVar1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HardwareSerial"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005b54": {
      "entrypoint": "0x08005b54",
      "current_name": "FUN_08005b54",
      "code": "\n/* DWARF original prototype: HardwareSerial *  HardwareSerial(HardwareSerial * this, void *\n   peripheral) */\n\nHardwareSerial * __thiscall HardwareSerial::FUN_08005b54(HardwareSerial *this,void *peripheral)\n\n{\n  PinName_conflict PVar1;\n  EVP_PKEY_CTX *extraout_r1;\n  EVP_PKEY_CTX *ctx;\n  EVP_PKEY_CTX *extraout_r1_00;\n  \n  (this-\u003esuper_Stream).super_Print.write_error \u003d 0;\n  (this-\u003esuper_Stream)._timeout \u003d 1000;\n  (this-\u003esuper_Stream).super_Print._vptr_Print \u003d (_func_int_varargs **)\u0026PTR_write_1_08007804;\n  if (this \u003d\u003d \u0026Serial2) {\n    setRx(\u0026Serial2,0);\n    setTx(\u0026Serial2,1);\n    ctx \u003d extraout_r1_00;\n  }\n  else {\n    PVar1 \u003d pinmap_pin(peripheral,(PinMap_conflict *)\u0026PinMap_UART_RX);\n    (this-\u003e_serial).pin_rx \u003d PVar1;\n    PVar1 \u003d pinmap_pin(peripheral,(PinMap_conflict *)\u0026PinMap_UART_TX);\n    (this-\u003e_serial).pin_tx \u003d PVar1;\n    ctx \u003d extraout_r1;\n  }\n  init(this,ctx);\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "__static_initialization_and_destruction_0"
      ],
      "called": [
        "setTx",
        "init",
        "pinmap_pin",
        "setRx"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005bb0": {
      "entrypoint": "0x08005bb0",
      "current_name": "FUN_08005bb0",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08005bb0(int __initialize_p,int __priority)\n\n{\n  if (__initialize_p !\u003d 1) {\n    return;\n  }\n  if (__priority \u003d\u003d 0xffff) {\n    HardwareSerial::HardwareSerial(\u0026Serial2,(void *)0x40004400);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_GLOBAL__sub_I_Serial2"
      ],
      "called": [
        "HardwareSerial"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005bd4": {
      "entrypoint": "0x08005bd4",
      "current_name": "FUN_08005bd4",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08005bd4(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__static_initialization_and_destruction_0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005be2": {
      "entrypoint": "0x08005be2",
      "current_name": "FUN_08005be2",
      "code": "\n/* DWARF original prototype: size_t  printTo(IPAddress * this, Print * p) */\n\nsize_t __thiscall IPAddress::FUN_08005be2(IPAddress *this,Print *p)\n\n{\n  size_t sVar1;\n  size_t sVar2;\n  int iVar3;\n  int iVar4;\n  \n  iVar4 \u003d 0;\n  for (iVar3 \u003d 0; iVar3 \u003c 3; iVar3 \u003d iVar3 + 1) {\n    sVar1 \u003d Print::print(p,(this-\u003e_address).bytes[iVar3],10);\n    sVar2 \u003d Print::print(p,\u0027.\u0027);\n    iVar4 \u003d iVar4 + sVar1 + sVar2;\n  }\n  sVar1 \u003d Print::print(p,(this-\u003e_address).bytes[3],10);\n  return sVar1 + iVar4;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "print",
        "print"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005c1c": {
      "entrypoint": "0x08005c1c",
      "current_name": "FUN_08005c1c",
      "code": "\n/* DWARF original prototype: IPAddress *  IPAddress(IPAddress * this, uint8_t first_octet, uint8_t\n   second_octet, uint8_t third_octet, uint8_t fourth_octet) */\n\nIPAddress * __thiscall\nIPAddress::FUN_08005c1c\n          (IPAddress *this,uint8_t first_octet,uint8_t second_octet,uint8_t third_octet,\n          uint8_t fourth_octet)\n\n{\n  (this-\u003esuper_Printable)._vptr_Printable \u003d (_func_int_varargs **)\u0026DAT_08007858;\n  (this-\u003e_address).bytes[0] \u003d first_octet;\n  (this-\u003e_address).bytes[1] \u003d second_octet;\n  (this-\u003e_address).bytes[2] \u003d third_octet;\n  (this-\u003e_address).bytes[3] \u003d fourth_octet;\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "__static_initialization_and_destruction_0"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005c38": {
      "entrypoint": "0x08005c38",
      "current_name": "FUN_08005c38",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08005c38(int __initialize_p,int __priority)\n\n{\n  if ((__initialize_p \u003d\u003d 1) \u0026\u0026 (__priority \u003d\u003d 0xffff)) {\n    IPAddress::IPAddress(\u0026INADDR_NONE,\u0027\\0\u0027,\u0027\\0\u0027,\u0027\\0\u0027,\u0027\\0\u0027);\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
      ],
      "called": [
        "IPAddress"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005c64": {
      "entrypoint": "0x08005c64",
      "current_name": "FUN_08005c64",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08005c64(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__static_initialization_and_destruction_0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005c72": {
      "entrypoint": "0x08005c72",
      "current_name": "FUN_08005c72",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005c86 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * this, uint8_t * buffer, size_t size) */\n\nssize_t __thiscall Print::FUN_08005c72(Print *this,int __fd,void *__buf,size_t __n)\n\n{\n  Print *pPVar1;\n  int iVar2;\n  \n  iVar2 \u003d 0;\n  pPVar1 \u003d this;\n  while( true ) {\n    if (__buf \u003d\u003d (void *)0x0) {\n      return iVar2;\n    }\n    pPVar1 \u003d (Print *)(**this-\u003e_vptr_Print)(pPVar1,(uint)*(byte *)__fd,__buf,*this-\u003e_vptr_Print,__n)\n    ;\n    if (pPVar1 \u003d\u003d (Print *)0x0) break;\n    iVar2 \u003d iVar2 + 1;\n    __fd \u003d (int)(__fd + 1);\n    __buf \u003d (void *)((int)__buf + -1);\n  }\n  return iVar2;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005c96": {
      "entrypoint": "0x08005c96",
      "current_name": "FUN_08005c96",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005cae */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * this, char * str) */\n\nsize_t __thiscall Print::FUN_08005c96(Print *this,char *str)\n\n{\n  size_t sVar1;\n  size_t sVar2;\n  \n  if (str !\u003d (char *)0x0) {\n    sVar1 \u003d strlen(str);\n    sVar2 \u003d (*this-\u003e_vptr_Print[1])(sVar1,str,sVar1);\n    return sVar2;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup",
        "loop",
        "printFloat",
        "println"
      ],
      "called": [
        "strlen"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005cb6": {
      "entrypoint": "0x08005cb6",
      "current_name": "FUN_08005cb6",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005cbc */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * this, char c) */\n\nsize_t __thiscall Print::FUN_08005cb6(Print *this,char c)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d (**this-\u003e_vptr_Print)(this,(int)c);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "print",
        "printTo",
        "printFloat"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005cc0": {
      "entrypoint": "0x08005cc0",
      "current_name": "FUN_08005cc0",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005cca */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  println(Print * this) */\n\nsize_t __thiscall Print::FUN_08005cc0(Print *this)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d (*this-\u003e_vptr_Print[1])(this,\u0026DAT_0800786c,2);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "println",
        "println"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005cd4": {
      "entrypoint": "0x08005cd4",
      "current_name": "FUN_08005cd4",
      "code": "\n/* DWARF original prototype: size_t  println(Print * this, char * c) */\n\nsize_t __thiscall Print::FUN_08005cd4(Print *this,char *c)\n\n{\n  size_t sVar1;\n  size_t n;\n  size_t sVar2;\n  \n  sVar1 \u003d print(this,c);\n  sVar2 \u003d println(this);\n  return sVar2 + sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "println",
        "print"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005ce8": {
      "entrypoint": "0x08005ce8",
      "current_name": "FUN_08005ce8",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005d38 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  printNumber(Print * this, ulong n, uint8_t base) */\n\nsize_t __thiscall Print::FUN_08005ce8(Print *this,ulong n,uint8_t base)\n\n{\n  char cVar1;\n  char c;\n  size_t sVar2;\n  size_t sVar3;\n  ulong m;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  char *__s;\n  char buf [33];\n  \n  uVar5 \u003d (uint)base;\n  buf[32] \u003d \u0027\\0\u0027;\n  if (uVar5 \u003c 2) {\n    uVar5 \u003d 10;\n  }\n  __s \u003d buf + 0x20;\n  m \u003d n;\n  do {\n    uVar6 \u003d m / uVar5;\n    uVar4 \u003d (m \u0026 0xff) - (uVar6 * uVar5 \u0026 0xff) \u0026 0xff;\n    __s \u003d __s + -1;\n    cVar1 \u003d (char)uVar4;\n    if (uVar4 \u003c 10) {\n      cVar1 \u003d cVar1 + \u00270\u0027;\n    }\n    else {\n      cVar1 \u003d cVar1 + \u00277\u0027;\n    }\n    *__s \u003d cVar1;\n    m \u003d uVar6;\n  } while (uVar6 !\u003d 0);\n  if (__s \u003d\u003d (char *)0x0) {\n    sVar3 \u003d 0;\n  }\n  else {\n    sVar2 \u003d strlen(__s);\n    sVar3 \u003d (*this-\u003e_vptr_Print[1])(sVar2,__s,sVar2);\n  }\n  return sVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "print",
        "print"
      ],
      "called": [
        "strlen"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005d42": {
      "entrypoint": "0x08005d42",
      "current_name": "FUN_08005d42",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005d5c */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * this, long n, int base) */\n\nsize_t __thiscall Print::FUN_08005d42(Print *this,long n,int base)\n\n{\n  size_t sVar1;\n  int t;\n  size_t sVar2;\n  \n  if (base \u003d\u003d 0) {\n    sVar1 \u003d (**this-\u003e_vptr_Print)(this,n \u0026 0xff);\n    return sVar1;\n  }\n  if (base !\u003d 10) {\n    sVar1 \u003d printNumber(this,n,(uint8_t)base);\n    return sVar1;\n  }\n  if (-1 \u003c n) {\n    sVar1 \u003d printNumber(this,n,\u0027\\n\u0027);\n    return sVar1;\n  }\n  sVar1 \u003d print(this,\u0027-\u0027);\n  sVar2 \u003d printNumber(this,-n,\u0027\\n\u0027);\n  return sVar2 + sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "print"
      ],
      "called": [
        "print",
        "printNumber"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005d82": {
      "entrypoint": "0x08005d82",
      "current_name": "FUN_08005d82",
      "code": "\n/* DWARF original prototype: size_t  print(Print * this, int n, int base) */\n\nsize_t __thiscall Print::FUN_08005d82(Print *this,int n,int base)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d print(this,n,base);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop",
        "printFloat"
      ],
      "called": [
        "print"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005d8a": {
      "entrypoint": "0x08005d8a",
      "current_name": "FUN_08005d8a",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005d9c */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * this, ulong n, int base) */\n\nsize_t __thiscall Print::FUN_08005d8a(Print *this,ulong n,int base)\n\n{\n  size_t sVar1;\n  \n  if (base !\u003d 0) {\n    sVar1 \u003d printNumber(this,n,(uint8_t)base);\n    return sVar1;\n  }\n  sVar1 \u003d (**this-\u003e_vptr_Print)(this,n \u0026 0xff);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "print",
        "printFloat"
      ],
      "called": [
        "printNumber"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005da0": {
      "entrypoint": "0x08005da0",
      "current_name": "FUN_08005da0",
      "code": "\n/* DWARF original prototype: size_t  print(Print * this, uchar b, int base) */\n\nsize_t __thiscall Print::FUN_08005da0(Print *this,uchar b,int base)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d print(this,(uint)b,base);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "printTo"
      ],
      "called": [
        "print"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005da8": {
      "entrypoint": "0x08005da8",
      "current_name": "FUN_08005da8",
      "code": "\n/* DWARF original prototype: size_t  printFloat(Print * this, double number, uint8_t digits) */\n\nsize_t __thiscall Print::FUN_08005da8(Print *this,double number,uint8_t digits)\n\n{\n  int iVar1;\n  ulong n;\n  ulong int_part;\n  size_t sVar2;\n  int toPrint;\n  size_t sVar3;\n  byte bVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  \n  iVar1 \u003d __unorddf2();\n  if (iVar1 \u003d\u003d 0) {\n    iVar1 \u003d __unorddf2();\n    if ((iVar1 \u003d\u003d 0) \u0026\u0026 (iVar1 \u003d __aeabi_dcmple(), iVar1 \u003d\u003d 0)) {\n      sVar3 \u003d print(this,\"inf\");\n    }\n    else {\n      iVar1 \u003d __aeabi_dcmpgt();\n      if (iVar1 \u003d\u003d 0) {\n        iVar1 \u003d __aeabi_dcmplt();\n        if (iVar1 \u003d\u003d 0) {\n          iVar1 \u003d __aeabi_dcmplt();\n          if (iVar1 \u003d\u003d 0) {\n            sVar3 \u003d 0;\n          }\n          else {\n            sVar3 \u003d print(this,\u0027-\u0027);\n          }\n          uVar5 \u003d 0x3fe0000000000000;\n          for (bVar4 \u003d 0; bVar4 \u003c number._0_1_; bVar4 \u003d bVar4 + 1) {\n            uVar5 \u003d __divdf3((int)uVar5,(int)((ulonglong)uVar5 \u003e\u003e 0x20),0,0x40240000);\n          }\n          uVar5 \u003d __aeabi_dadd();\n          n \u003d __fixunsdfsi();\n          uVar6 \u003d __floatunsidf();\n          int_part \u003d (ulong)uVar6;\n          uVar5 \u003d __subdf3((int)uVar5,(int)((ulonglong)uVar5 \u003e\u003e 0x20),int_part,\n                           (int)((ulonglong)uVar6 \u003e\u003e 0x20));\n          sVar2 \u003d print(this,n,10);\n          sVar3 \u003d sVar3 + sVar2;\n          if (number._0_1_ !\u003d 0) {\n            sVar2 \u003d print(this,\".\");\n            sVar3 \u003d sVar3 + sVar2;\n          }\n          while( true ) {\n            if (number._0_1_ \u003d\u003d 0) break;\n            uVar5 \u003d __muldf3((int)uVar5,(int)((ulonglong)uVar5 \u003e\u003e 0x20),0,0x40240000);\n            iVar1 \u003d __fixdfsi();\n            sVar2 \u003d print(this,iVar1,10);\n            sVar3 \u003d sVar3 + sVar2;\n            uVar6 \u003d __floatsidf(iVar1);\n            uVar5 \u003d __subdf3((int)uVar5,(int)((ulonglong)uVar5 \u003e\u003e 0x20),(int)uVar6,\n                             (int)((ulonglong)uVar6 \u003e\u003e 0x20));\n            number._0_1_ \u003d number._0_1_ - 1;\n          }\n        }\n        else {\n          sVar3 \u003d print(this,\"ovf\");\n        }\n      }\n      else {\n        sVar3 \u003d print(this,\"ovf\");\n      }\n    }\n  }\n  else {\n    sVar3 \u003d print(this,\"nan\");\n  }\n  return sVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "print"
      ],
      "called": [
        "__unorddf2",
        "__floatsidf",
        "print",
        "print",
        "__fixunsdfsi",
        "__aeabi_dadd",
        "__aeabi_dcmpgt",
        "__muldf3",
        "print",
        "__subdf3",
        "print",
        "__fixdfsi",
        "__floatunsidf",
        "__divdf3",
        "__aeabi_dcmplt",
        "__aeabi_dcmple"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005f2c": {
      "entrypoint": "0x08005f2c",
      "current_name": "FUN_08005f2c",
      "code": "\n/* DWARF original prototype: size_t  print(Print * this, double n, int digits) */\n\nsize_t __thiscall Print::FUN_08005f2c(Print *this,double n,int digits)\n\n{\n  size_t sVar1;\n  undefined4 in_stack_fffffff4;\n  \n  sVar1 \u003d printFloat(this,(double)CONCAT44(in_stack_fffffff4,(uint)n._0_1_),n._0_1_);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "println",
        "loop"
      ],
      "called": [
        "printFloat"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005f40": {
      "entrypoint": "0x08005f40",
      "current_name": "FUN_08005f40",
      "code": "\n/* DWARF original prototype: size_t  println(Print * this, double num, int digits) */\n\nsize_t __thiscall Print::FUN_08005f40(Print *this,double num,int digits)\n\n{\n  size_t sVar1;\n  size_t n;\n  size_t sVar2;\n  undefined4 in_stack_ffffffec;\n  \n  sVar1 \u003d print(this,(double)CONCAT44(in_stack_ffffffec,num._0_4_),num._0_4_);\n  sVar2 \u003d println(this);\n  return sVar2 + sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "print",
        "println"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005f5c": {
      "entrypoint": "0x08005f5c",
      "current_name": "FUN_08005f5c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08005f5c(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005f5e": {
      "entrypoint": "0x08005f5e",
      "current_name": "FUN_08005f5e",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08005f5e(void)\n\n{\n  EVP_PKEY_CTX *ctx;\n  \n  ctx \u003d (EVP_PKEY_CTX *)0x3;\n  HAL_NVIC_SetPriorityGrouping(3);\n  init(ctx);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_init_array"
      ],
      "called": [
        "HAL_NVIC_SetPriorityGrouping",
        "init"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005f6c": {
      "entrypoint": "0x08005f6c",
      "current_name": "FUN_08005f6c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint FUN_08005f6c(void)\n\n{\n  initVariant();\n  setup();\n  do {\n    loop();\n    serialEventRun();\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "Reset_Handler"
      ],
      "called": [
        "setup",
        "serialEventRun",
        "loop",
        "initVariant"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005f8c": {
      "entrypoint": "0x08005f8c",
      "current_name": "FUN_08005f8c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t FUN_08005f8c(uint16_t pin)\n\n{\n  uint uVar1;\n  uint8_t uVar2;\n  \n  uVar2 \u003d \u0027\\0\u0027;\n  for (uVar1 \u003d (uint)pin; uVar1 !\u003d 1; uVar1 \u003d uVar1 \u003e\u003e 1) {\n    uVar2 \u003d uVar2 + \u0027\\x01\u0027;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_GPIO_EXTI_Callback"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005fa0": {
      "entrypoint": "0x08005fa0",
      "current_name": "FUN_08005fa0",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08005fa0(void *param_1)\n\n{\n  gpio_irq_conf_str *pgVar1;\n  _Manager_type p_Var2;\n  gpio_irq_conf_str *pgVar3;\n  \n  pgVar1 \u003d (gpio_irq_conf_str *)\u0026__malloc_free_list;\n  while (pgVar3 \u003d pgVar1, pgVar3 !\u003d gpio_irq_conf) {\n    p_Var2 \u003d pgVar3[-1].callback.super__Function_base._M_manager;\n    pgVar1 \u003d pgVar3 + -1;\n    if (p_Var2 !\u003d (_Manager_type)0x0) {\n      (*p_Var2)((_Any_data *)\u0026pgVar3[-1].callback,(_Any_data *)\u0026pgVar3[-1].callback,\n                __destroy_functor);\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08005fc8": {
      "entrypoint": "0x08005fc8",
      "current_name": "FUN_08005fc8",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08005fc8(int __initialize_p,int __priority)\n\n{\n  if (__initialize_p !\u003d 1) {\n    return;\n  }\n  if (__priority \u003d\u003d 0xffff) {\n    gpio_irq_conf[0].irqnb \u003d EXTI0_IRQn;\n    gpio_irq_conf[0].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[1].irqnb \u003d EXTI1_IRQn;\n    gpio_irq_conf[1].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[2].irqnb \u003d EXTI2_IRQn;\n    gpio_irq_conf[2].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[3].irqnb \u003d EXTI3_IRQn;\n    gpio_irq_conf[3].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[4].irqnb \u003d EXTI4_IRQn;\n    gpio_irq_conf[4].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[5].irqnb \u003d EXTI9_5_IRQn;\n    gpio_irq_conf[5].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[6].irqnb \u003d EXTI9_5_IRQn;\n    gpio_irq_conf[6].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[7].irqnb \u003d EXTI9_5_IRQn;\n    gpio_irq_conf[7].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[8].irqnb \u003d EXTI9_5_IRQn;\n    gpio_irq_conf[8].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[9].irqnb \u003d EXTI9_5_IRQn;\n    gpio_irq_conf[9].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[10].irqnb \u003d EXTI15_10_IRQn;\n    gpio_irq_conf[10].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[11].irqnb \u003d EXTI15_10_IRQn;\n    gpio_irq_conf[11].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[12].irqnb \u003d EXTI15_10_IRQn;\n    gpio_irq_conf[12].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[13].irqnb \u003d EXTI15_10_IRQn;\n    gpio_irq_conf[13].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[14].irqnb \u003d EXTI15_10_IRQn;\n    gpio_irq_conf[14].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[15].irqnb \u003d EXTI15_10_IRQn;\n    gpio_irq_conf[15].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    __aeabi_atexit(0,0x8005fa1,0x20000000);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
      ],
      "called": [
        "__aeabi_atexit"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006074": {
      "entrypoint": "0x08006074",
      "current_name": "FUN_08006074",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08006074(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800607e": {
      "entrypoint": "0x0800607e",
      "current_name": "FUN_0800607e",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_0800607e(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006088": {
      "entrypoint": "0x08006088",
      "current_name": "FUN_08006088",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08006088(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006092": {
      "entrypoint": "0x08006092",
      "current_name": "FUN_08006092",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08006092(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(8);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800609c": {
      "entrypoint": "0x0800609c",
      "current_name": "FUN_0800609c",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_0800609c(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(0x10);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080060a6": {
      "entrypoint": "0x080060a6",
      "current_name": "FUN_080060a6",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_080060a6(void)\n\n{\n  uint uVar1;\n  \n  for (uVar1 \u003d 0x20; uVar1 \u003c 0x201; uVar1 \u003d uVar1 \u003c\u003c 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)uVar1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080060bc": {
      "entrypoint": "0x080060bc",
      "current_name": "FUN_080060bc",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_080060bc(void)\n\n{\n  uint uVar1;\n  \n  for (uVar1 \u003d 0x400; uVar1 \u003c 0x8001; uVar1 \u003d uVar1 \u003c\u003c 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)uVar1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080060d4": {
      "entrypoint": "0x080060d4",
      "current_name": "FUN_080060d4",
      "code": "\n/* DWARF original prototype: void  operator()(function\u003cvoid()\u003e * this) */\n\nvoid __thiscall std::function\u003cvoid()\u003e::FUN_080060d4(function\u003cvoid()\u003e *this)\n\n{\n  if ((this-\u003esuper__Function_base)._M_manager !\u003d (_Manager_type)0x0) {\n    (*this-\u003e_M_invoker)((_Any_data *)this);\n    return;\n  }\n                    \n  __throw_bad_function_call();\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_GPIO_EXTI_Callback"
      ],
      "called": [
        "__throw_bad_function_call"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080060e4": {
      "entrypoint": "0x080060e4",
      "current_name": "FUN_080060e4",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_080060e4(uint16_t GPIO_Pin)\n\n{\n  byte bVar1;\n  uint8_t irq_id;\n  \n  bVar1 \u003d get_pin_id(GPIO_Pin);\n  if (gpio_irq_conf[bVar1].callback.super__Function_base._M_manager !\u003d (_Manager_type)0x0) {\n    std::function\u003cvoid()\u003e::operator()(\u0026gpio_irq_conf[bVar1].callback);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "called": [
        "operator()",
        "get_pin_id"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006104": {
      "entrypoint": "0x08006104",
      "current_name": "FUN_08006104",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUN_08006104(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__static_initialization_and_destruction_0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006112": {
      "entrypoint": "0x08006112",
      "current_name": "FUN_08006112",
      "code": "\nvoid FUN_08006112(undefined4 param_1,undefined4 param_2)\n\n{\n  __cxa_atexit(param_2,param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__static_initialization_and_destruction_0"
      ],
      "called": [
        "__cxa_atexit"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800611c": {
      "entrypoint": "0x0800611c",
      "current_name": "FUN_0800611c",
      "code": "\nvoid FUN_0800611c(undefined4 param_1,undefined4 param_2,char *param_3,undefined4 param_4)\n\n{\n  char *pcVar1;\n  \n  if (param_3 \u003d\u003d (char *)0x0) {\n    param_3 \u003d \"\";\n    pcVar1 \u003d param_3;\n  }\n  else {\n    pcVar1 \u003d \", function: \";\n  }\n  fiprintf(*(FILE **)(_impure_ptr + 0xc),\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",\n           param_4,param_1,param_2,pcVar1,param_3,param_4);\n                    \n  abort();\n}\n\n",
      "renaming": {},
      "calling": [
        "begin"
      ],
      "called": [
        "fiprintf",
        "abort"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006158": {
      "entrypoint": "0x08006158",
      "current_name": "FUN_08006158",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x08006160) */\n\nlonglong FUN_08006158(undefined4 param_1,uint param_2)\n\n{\n  return (ulonglong)param_2 \u003c\u003c 0x20;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_atexit"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006174": {
      "entrypoint": "0x08006174",
      "current_name": "FUN_08006174",
      "code": "\nint FUN_08006174(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  uStack_8 \u003d in_r2;\n  uStack_4 \u003d in_r3;\n  iVar1 \u003d _vfiprintf_r(_impure_ptr,__stream,__format,\u0026uStack_8,__stream,\u0026uStack_8);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__assert_func"
      ],
      "called": [
        "_vfiprintf_r"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006198": {
      "entrypoint": "0x08006198",
      "current_name": "FUN_08006198",
      "code": "\nvoid FUN_08006198(void)\n\n{\n  int iVar1;\n  \n  for (iVar1 \u003d 0; iVar1 !\u003d 0; iVar1 \u003d iVar1 + 1) {\n    (*(code *)(\u0026__preinit_array_end)[iVar1])();\n  }\n  _init();\n  for (iVar1 \u003d 0; iVar1 !\u003d 10; iVar1 \u003d iVar1 + 1) {\n    (*(code *)(\u0026__preinit_array_end)[iVar1])();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "Reset_Handler"
      ],
      "called": [
        "_init",
        "premain"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080061e0": {
      "entrypoint": "0x080061e0",
      "current_name": "FUN_080061e0",
      "code": "\nvoid * FUN_080061e0(void *__s,int __c,size_t __n)\n\n{\n  undefined *puVar1;\n  \n  for (puVar1 \u003d (undefined *)__s; puVar1 !\u003d (undefined *)(__n + (int)__s); puVar1 \u003d puVar1 + 1) {\n    *puVar1 \u003d (char)__c;\n  }\n  return __s;\n}\n\n",
      "renaming": {},
      "calling": [
        "std.isra.0",
        "__sfp",
        "adc_read_value",
        "__sfmoreglue"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080061f0": {
      "entrypoint": "0x080061f0",
      "current_name": "FUN_080061f0",
      "code": "\nvoid FUN_080061f0(undefined4 *param_1,int param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int **extraout_r1;\n  int **ppiVar1;\n  int **ppiVar2;\n  int *piVar3;\n  int **ppiVar4;\n  int **ppiVar5;\n  \n  if (param_2 \u003d\u003d 0) {\n    return;\n  }\n  ppiVar5 \u003d (int **)(param_2 + -4);\n  if (*(int *)(param_2 + -4) \u003c 0) {\n    ppiVar5 \u003d (int **)((int)ppiVar5 + *(int *)(param_2 + -4));\n  }\n  __malloc_lock();\n  ppiVar2 \u003d (int **)\u0026__malloc_free_list;\n  if (__malloc_free_list \u003d\u003d (int **)0x0) {\n    ppiVar5[1] \u003d (int *)0x0;\n    ppiVar1 \u003d extraout_r1;\n    __malloc_free_list \u003d ppiVar5;\n  }\n  else {\n    ppiVar2 \u003d __malloc_free_list;\n    if (ppiVar5 \u003c __malloc_free_list) {\n      ppiVar1 \u003d (int **)*ppiVar5;\n      ppiVar2 \u003d (int **)((int)ppiVar5 + (int)ppiVar1);\n      if (__malloc_free_list \u003d\u003d ppiVar2) {\n        piVar3 \u003d *__malloc_free_list;\n        __malloc_free_list \u003d (int **)__malloc_free_list[1];\n        ppiVar2 \u003d (int **)((int)piVar3 + (int)ppiVar1);\n        *ppiVar5 \u003d (int *)ppiVar2;\n      }\n      ppiVar5[1] \u003d (int *)__malloc_free_list;\n      __malloc_free_list \u003d ppiVar5;\n    }\n    else {\n      do {\n        ppiVar4 \u003d ppiVar2;\n        ppiVar2 \u003d (int **)ppiVar4[1];\n        if (ppiVar2 \u003d\u003d (int **)0x0) break;\n      } while (ppiVar2 \u003c\u003d ppiVar5);\n      ppiVar1 \u003d (int **)*ppiVar4;\n      if ((int **)((int)ppiVar4 + (int)ppiVar1) \u003d\u003d ppiVar5) {\n        ppiVar1 \u003d (int **)((int)ppiVar1 + (int)*ppiVar5);\n        *ppiVar4 \u003d (int *)ppiVar1;\n        if (ppiVar2 \u003d\u003d (int **)((int)ppiVar4 + (int)ppiVar1)) {\n          piVar3 \u003d *ppiVar2;\n          ppiVar2 \u003d (int **)ppiVar2[1];\n          ppiVar1 \u003d (int **)((int)ppiVar1 + (int)piVar3);\n          *ppiVar4 \u003d (int *)ppiVar1;\n          ppiVar4[1] \u003d (int *)ppiVar2;\n        }\n      }\n      else if (ppiVar5 \u003c (int **)((int)ppiVar4 + (int)ppiVar1)) {\n        *param_1 \u003d 0xc;\n      }\n      else {\n        ppiVar1 \u003d (int **)((int)ppiVar5 + (int)*ppiVar5);\n        if (ppiVar2 \u003d\u003d ppiVar1) {\n          piVar3 \u003d *ppiVar2;\n          ppiVar2 \u003d (int **)ppiVar2[1];\n          ppiVar1 \u003d (int **)((int)piVar3 + (int)*ppiVar5);\n          *ppiVar5 \u003d (int *)ppiVar1;\n        }\n        ppiVar5[1] \u003d (int *)ppiVar2;\n        ppiVar4[1] \u003d (int *)ppiVar5;\n      }\n    }\n  }\n  __malloc_unlock(param_1,ppiVar1,ppiVar2,param_4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swsetup_r",
        "__sflush_r"
      ],
      "called": [
        "__malloc_unlock",
        "__malloc_lock"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006288": {
      "entrypoint": "0x08006288",
      "current_name": "FUN_08006288",
      "code": "\nuint FUN_08006288(undefined4 *param_1,uint param_2)\n\n{\n  uint *puVar1;\n  int iVar2;\n  uint *puVar3;\n  uint uVar4;\n  uint *puVar5;\n  uint uVar6;\n  \n  uVar6 \u003d (param_2 + 3 \u0026 0xfffffffc) + 8;\n  if (uVar6 \u003c 0xc) {\n    uVar6 \u003d 0xc;\n  }\n  if (((int)uVar6 \u003c 0) || (uVar6 \u003c param_2)) {\n    *param_1 \u003d 0xc;\n  }\n  else {\n    __malloc_lock();\n    puVar1 \u003d __malloc_free_list;\n    puVar5 \u003d __malloc_free_list;\n    while (puVar3 \u003d puVar1, puVar3 !\u003d (uint *)0x0) {\n      uVar4 \u003d *puVar3 - uVar6;\n      if (-1 \u003c (int)uVar4) {\n        if (uVar4 \u003c 0xc) {\n          if (puVar5 \u003d\u003d puVar3) {\n            puVar1 \u003d (uint *)puVar5[1];\n            __malloc_free_list \u003d puVar1;\n          }\n          else {\n            puVar1 \u003d (uint *)puVar3[1];\n          }\n          if (puVar5 !\u003d puVar3) {\n            puVar5[1] \u003d (uint)puVar1;\n            puVar5 \u003d puVar3;\n          }\n        }\n        else {\n          *puVar3 \u003d uVar4;\n          *(uint *)((int)puVar3 + uVar4) \u003d uVar6;\n          puVar5 \u003d (uint *)((int)puVar3 + uVar4);\n        }\n        goto LAB_080062ec;\n      }\n      puVar5 \u003d puVar3;\n      puVar1 \u003d (uint *)puVar3[1];\n    }\n    if (__malloc_sbrk_start \u003d\u003d 0) {\n      __malloc_sbrk_start \u003d _sbrk_r(param_1);\n    }\n    puVar1 \u003d (uint *)_sbrk_r(param_1,uVar6);\n    if ((puVar1 !\u003d (uint *)0xffffffff) \u0026\u0026\n       ((puVar5 \u003d (uint *)((int)puVar1 + 3U \u0026 0xfffffffc), puVar1 \u003d\u003d puVar5 ||\n        (iVar2 \u003d _sbrk_r(param_1,(int)puVar5 - (int)puVar1), iVar2 !\u003d -1)))) {\n      *puVar5 \u003d uVar6;\nLAB_080062ec:\n      __malloc_unlock(param_1);\n      uVar6 \u003d (int)puVar5 + 0xbU \u0026 0xfffffff8;\n      iVar2 \u003d uVar6 - (int)(puVar5 + 1);\n      if (iVar2 !\u003d 0) {\n        *(int *)((int)puVar5 + iVar2) \u003d -iVar2;\n        return uVar6;\n      }\n      return uVar6;\n    }\n    *param_1 \u003d 0xc;\n    __malloc_unlock(param_1);\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__smakebuf_r",
        "__sfmoreglue"
      ],
      "called": [
        "__malloc_unlock",
        "__malloc_lock",
        "_sbrk_r"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006344": {
      "entrypoint": "0x08006344",
      "current_name": "FUN_08006344",
      "code": "\nuint FUN_08006344(undefined4 param_1,byte param_2,byte **param_3)\n\n{\n  uint uVar1;\n  byte *pbVar2;\n  \n  pbVar2 \u003d param_3[2] + -1;\n  param_3[2] \u003d pbVar2;\n  if (((int)pbVar2 \u003c 0) \u0026\u0026 (((int)pbVar2 \u003c (int)param_3[6] || (param_2 \u003d\u003d 10)))) {\n    uVar1 \u003d __swbuf_r();\n    return uVar1;\n  }\n  pbVar2 \u003d *param_3;\n  *param_3 \u003d pbVar2 + 1;\n  *pbVar2 \u003d param_2;\n  return (uint)param_2;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfputs_r"
      ],
      "called": [
        "__swbuf_r"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006370": {
      "entrypoint": "0x08006370",
      "current_name": "FUN_08006370",
      "code": "\nint FUN_08006370(undefined4 param_1,undefined4 param_2,undefined *param_3,int param_4)\n\n{\n  int iVar1;\n  undefined *puVar2;\n  int iVar3;\n  \n  puVar2 \u003d param_3 + param_4;\n  iVar3 \u003d param_4;\n  do {\n    if (param_3 \u003d\u003d puVar2) {\n      return 0;\n    }\n    iVar1 \u003d __sfputc_r(param_1,*param_3,param_2,param_4,iVar3);\n    param_4 \u003d iVar1 + 1;\n    param_3 \u003d param_3 + 1;\n  } while (param_4 !\u003d 0);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_vfiprintf_r"
      ],
      "called": [
        "__sfputc_r"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006394": {
      "entrypoint": "0x08006394",
      "current_name": "FUN_08006394",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x08006568) */\n\nint FUN_08006394(int param_1,undefined4 *param_2,byte *param_3,int *param_4)\n\n{\n  bool bVar1;\n  int iVar2;\n  void *pvVar3;\n  int *piVar4;\n  byte *pbVar5;\n  byte *pbVar6;\n  int unaff_r9;\n  int iVar7;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 local_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  local_8c \u003d param_4;\n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (param_2 \u003d\u003d \u0026__sf_fake_stdin) {\n    param_2 \u003d *(undefined4 **)(param_1 + 4);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stdout) {\n    param_2 \u003d *(undefined4 **)(param_1 + 8);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stderr) {\n    param_2 \u003d *(undefined4 **)(param_1 + 0xc);\n  }\n  if (((-1 \u003c (int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x1c)) || (param_2[4] \u003d\u003d 0)) \u0026\u0026\n     (iVar7 \u003d __swsetup_r(param_1,param_2), iVar7 !\u003d 0)) {\n    return -1;\n  }\n  local_74 \u003d 0;\n  local_6f \u003d 0x20;\n  local_6e \u003d 0x30;\n  pbVar5 \u003d param_3;\nLAB_080063d6:\n  pbVar6 \u003d pbVar5;\n  if (*pbVar6 !\u003d 0) goto LAB_0800648c;\n  goto LAB_080063e0;\nLAB_0800648c:\n  pbVar5 \u003d pbVar6 + 1;\n  if (*pbVar6 !\u003d 0x25) goto LAB_080063d6;\nLAB_080063e0:\n  iVar7 \u003d (int)pbVar6 - (int)param_3;\n  if (iVar7 !\u003d 0) {\n    iVar2 \u003d __sfputs_r(param_1,param_2,param_3,iVar7);\n    if (iVar2 \u003d\u003d -1) {\nLAB_08006580:\n      if ((int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x19) \u003c 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 \u003d local_74 + iVar7;\n  }\n  if (*pbVar6 \u003d\u003d 0) goto LAB_08006580;\n  local_88 \u003d 0;\n  local_7c \u003d 0;\n  local_84 \u003d -1;\n  local_80 \u003d 0;\n  local_45 \u003d 0;\n  local_30 \u003d 0;\n  pbVar5 \u003d pbVar6 + 1;\n  while( true ) {\n    pvVar3 \u003d memchr(\"#-0+ \",(uint)*pbVar5,5);\n    param_3 \u003d pbVar5 + 1;\n    if (pvVar3 \u003d\u003d (void *)0x0) break;\n    local_88 \u003d 1 \u003c\u003c ((int)pvVar3 + 0xf7ff8750U \u0026 0xff) | local_88;\n    pbVar5 \u003d param_3;\n  }\n  if ((int)(local_88 \u003c\u003c 0x1b) \u003c 0) {\n    local_45 \u003d 0x20;\n  }\n  if ((int)(local_88 \u003c\u003c 0x1c) \u003c 0) {\n    local_45 \u003d 0x2b;\n  }\n  if (*pbVar5 \u003d\u003d 0x2a) {\n    piVar4 \u003d local_8c + 1;\n    iVar7 \u003d *local_8c;\n    local_8c \u003d piVar4;\n    if (iVar7 \u003c 0) {\n      local_7c \u003d -iVar7;\n      local_88 \u003d local_88 | 2;\n      goto LAB_080064be;\n    }\n  }\n  else {\n    bVar1 \u003d false;\n    iVar7 \u003d local_7c;\n    param_3 \u003d pbVar5;\n    while( true ) {\n      if (9 \u003c *param_3 - 0x30) break;\n      iVar7 \u003d iVar7 * 10 + (*param_3 - 0x30);\n      bVar1 \u003d true;\n      param_3 \u003d param_3 + 1;\n    }\n    if (!bVar1) goto LAB_080064be;\n  }\n  local_7c \u003d iVar7;\nLAB_080064be:\n  if (*param_3 \u003d\u003d 0x2e) {\n    if (param_3[1] \u003d\u003d 0x2a) {\n      param_3 \u003d param_3 + 2;\n      piVar4 \u003d local_8c + 1;\n      local_84 \u003d *local_8c;\n      local_8c \u003d piVar4;\n      if (local_84 \u003c 0) {\n        local_84 \u003d -1;\n      }\n    }\n    else {\n      bVar1 \u003d false;\n      iVar7 \u003d 0;\n      local_84 \u003d 0;\n      while( true ) {\n        param_3 \u003d param_3 + 1;\n        if (9 \u003c *param_3 - 0x30) break;\n        iVar7 \u003d iVar7 * 10 + (*param_3 - 0x30);\n        bVar1 \u003d true;\n      }\n      if (bVar1) {\n        local_84 \u003d iVar7;\n      }\n    }\n  }\n  pvVar3 \u003d memchr(\u0026DAT_080078b6,(uint)*param_3,3);\n  if (pvVar3 !\u003d (void *)0x0) {\n    param_3 \u003d param_3 + 1;\n    local_88 \u003d local_88 | 0x40 \u003c\u003c ((int)pvVar3 + 0xf7ff874aU \u0026 0xff);\n  }\n  local_70 \u003d *param_3;\n  param_3 \u003d param_3 + 1;\n  pvVar3 \u003d memchr(\"efgEFG\",(uint)local_70,6);\n  if (pvVar3 \u003d\u003d (void *)0x0) {\n    unaff_r9 \u003d _printf_i(param_1,\u0026local_88,param_2,0x8006371,\u0026local_8c);\n    if (unaff_r9 \u003d\u003d -1) goto LAB_08006580;\n  }\n  else {\n    local_8c \u003d (int *)(((int)local_8c + 7U \u0026 0xfffffff8) + 8);\n  }\n  local_74 \u003d local_74 + unaff_r9;\n  pbVar5 \u003d param_3;\n  goto LAB_080063d6;\n}\n\n",
      "renaming": {},
      "calling": [
        "fiprintf",
        "iprintf"
      ],
      "called": [
        "memchr",
        "__swsetup_r",
        "__sfputs_r",
        "_printf_i",
        "__sinit"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080065c0": {
      "entrypoint": "0x080065c0",
      "current_name": "FUN_080065c0",
      "code": "\nundefined4\nFUN_080065c0(undefined4 param_1,uint *param_2,uint *param_3,undefined4 param_4,code *param_5)\n\n{\n  int iVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  bool bVar5;\n  \n  uVar3 \u003d param_2[4];\n  if ((int)param_2[4] \u003c (int)param_2[2]) {\n    uVar3 \u003d param_2[2];\n  }\n  *param_3 \u003d uVar3;\n  if (*(char *)((int)param_2 + 0x43) !\u003d \u0027\\0\u0027) {\n    *param_3 \u003d uVar3 + 1;\n  }\n  if ((int)(*param_2 \u003c\u003c 0x1a) \u003c 0) {\n    *param_3 \u003d *param_3 + 2;\n  }\n  if ((*param_2 \u0026 6) \u003d\u003d 0) {\n    for (iVar1 \u003d 0; iVar1 \u003c (int)(param_2[3] - *param_3); iVar1 \u003d iVar1 + 1) {\n      iVar2 \u003d (*param_5)(param_1,param_4,(int)param_2 + 0x19,1);\n      if (iVar2 \u003d\u003d -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  uVar3 \u003d (uint)*(byte *)((int)param_2 + 0x43);\n  if (uVar3 !\u003d 0) {\n    uVar3 \u003d 1;\n  }\n  uVar4 \u003d uVar3;\n  if ((int)(*param_2 \u003c\u003c 0x1a) \u003c 0) {\n    *(undefined *)((int)param_2 + uVar3 + 0x43) \u003d 0x30;\n    uVar4 \u003d uVar3 + 2;\n    *(undefined *)((int)param_2 + uVar3 + 0x44) \u003d *(undefined *)((int)param_2 + 0x45);\n  }\n  iVar1 \u003d (*param_5)(param_1,param_4,(int)param_2 + 0x43,uVar4);\n  if (iVar1 !\u003d -1) {\n    uVar3 \u003d param_2[3];\n    bVar5 \u003d (*param_2 \u0026 6) !\u003d 4;\n    if (bVar5) {\n      uVar3 \u003d 0;\n    }\n    uVar4 \u003d 0;\n    if (!bVar5) {\n      uVar3 \u003d uVar3 - *param_3;\n    }\n    if (!bVar5) {\n      uVar3 \u003d uVar3 \u0026 ~((int)uVar3 \u003e\u003e 0x1f);\n    }\n    if ((int)param_2[4] \u003c (int)param_2[2]) {\n      uVar3 \u003d uVar3 + (param_2[2] - param_2[4]);\n    }\n    while( true ) {\n      if (uVar3 \u003d\u003d uVar4) {\n        return 0;\n      }\n      iVar1 \u003d (*param_5)(param_1,param_4,(int)param_2 + 0x1a,1);\n      if (iVar1 \u003d\u003d -1) break;\n      uVar4 \u003d uVar4 + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "_printf_i"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080066b0": {
      "entrypoint": "0x080066b0",
      "current_name": "FUN_080066b0",
      "code": "\nuint FUN_080066b0(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  byte bVar1;\n  int iVar2;\n  uint *puVar3;\n  void *pvVar4;\n  int iVar5;\n  char *pcVar6;\n  uint uVar7;\n  uint **ppuVar8;\n  char **ppcVar9;\n  uint uVar10;\n  uint uVar11;\n  char *pcVar12;\n  char *__s;\n  uint local_24 [2];\n  \n  bVar1 \u003d *(byte *)(param_2 + 6);\n  __s \u003d (char *)((int)param_2 + 0x43);\n  if (bVar1 !\u003d 0x6e) {\n    if (bVar1 \u003c 0x6f) {\n      if (bVar1 !\u003d 99) {\n        if (bVar1 \u003c 100) {\n          if (bVar1 \u003d\u003d 0) goto LAB_0800686a;\n          if (bVar1 !\u003d 0x58) goto LAB_080066e0;\n          *(undefined *)((int)param_2 + 0x45) \u003d 0x58;\n          pcVar6 \u003d \"0123456789ABCDEF\";\nLAB_080067fa:\n          uVar7 \u003d *param_2;\n          puVar3 \u003d *param_5;\n          *param_5 \u003d puVar3 + 1;\n          if (((uVar7 \u0026 0x80) \u003d\u003d 0) \u0026\u0026 ((int)(uVar7 \u003c\u003c 0x19) \u003c 0)) {\n            uVar10 \u003d (uint)*(ushort *)puVar3;\n          }\n          else {\n            uVar10 \u003d *puVar3;\n          }\n          if ((int)(uVar7 \u003c\u003c 0x1f) \u003c 0) {\n            *param_2 \u003d uVar7 | 0x20;\n          }\n          if (uVar10 \u003d\u003d 0) {\n            *param_2 \u003d *param_2 \u0026 0xffffffdf;\n          }\n          uVar7 \u003d 0x10;\nLAB_08006790:\n          *(undefined *)((int)param_2 + 0x43) \u003d 0;\n        }\n        else {\n          if ((bVar1 !\u003d 100) \u0026\u0026 (bVar1 !\u003d 0x69)) goto LAB_080066e0;\n          uVar10 \u003d *param_2;\n          puVar3 \u003d *param_5;\n          if ((uVar10 \u0026 0x80) \u003d\u003d 0) {\n            *param_5 \u003d puVar3 + 1;\n            if ((uVar10 \u0026 0x40) \u003d\u003d 0) goto LAB_08006700;\n            uVar10 \u003d (uint)(short)*(ushort *)puVar3;\n          }\n          else {\n            *param_5 \u003d puVar3 + 1;\nLAB_08006700:\n            uVar10 \u003d *puVar3;\n          }\n          if ((int)uVar10 \u003c 0) {\n            uVar10 \u003d -uVar10;\n            *(undefined *)((int)param_2 + 0x43) \u003d 0x2d;\n          }\n          pcVar6 \u003d \"0123456789ABCDEF\";\n          uVar7 \u003d 10;\n        }\n        uVar11 \u003d param_2[1];\n        param_2[2] \u003d uVar11;\n        pcVar12 \u003d __s;\n        if ((int)uVar11 \u003c 0) {\n          if (uVar10 !\u003d 0) goto LAB_0800682e;\nLAB_080068dc:\n          *(char *)((int)param_2 + 0x42) \u003d *pcVar6;\n          pcVar12 \u003d (char *)((int)param_2 + 0x42);\n        }\n        else {\n          *param_2 \u003d *param_2 \u0026 0xfffffffb;\n          if (uVar10 \u003d\u003d 0) {\n            if (uVar11 !\u003d 0) goto LAB_080068dc;\n          }\n          else {\nLAB_0800682e:\n            do {\n              uVar11 \u003d uVar10 / uVar7;\n              pcVar12 \u003d pcVar12 + -1;\n              *pcVar12 \u003d pcVar6[uVar10 - uVar7 * uVar11];\n              uVar10 \u003d uVar11;\n            } while (uVar11 !\u003d 0);\n          }\n        }\n        if (((uVar7 \u003d\u003d 8) \u0026\u0026 ((int)(*param_2 \u003c\u003c 0x1f) \u003c 0)) \u0026\u0026 ((int)param_2[1] \u003c\u003d (int)param_2[4]))\n        {\n          pcVar12[-1] \u003d \u00270\u0027;\n          pcVar12 \u003d pcVar12 + -1;\n        }\n        param_2[4] \u003d (int)__s - (int)pcVar12;\n        __s \u003d pcVar12;\n        goto LAB_080067d6;\n      }\n      puVar3 \u003d *param_5;\n      *param_5 \u003d puVar3 + 1;\n      *(char *)((int)param_2 + 0x42) \u003d (char)*puVar3;\nLAB_08006740:\n      __s \u003d (char *)((int)param_2 + 0x42);\n      uVar10 \u003d 1;\n    }\n    else {\n      if (bVar1 !\u003d 0x73) {\n        if (bVar1 \u003c 0x74) {\n          if (bVar1 \u003d\u003d 0x6f) {\nLAB_08006766:\n            uVar10 \u003d *param_2;\n            puVar3 \u003d *param_5;\n            if ((uVar10 \u0026 0x80) \u003d\u003d 0) {\n              *param_5 \u003d puVar3 + 1;\n              if ((uVar10 \u0026 0x40) \u003d\u003d 0) goto LAB_08006774;\n              uVar10 \u003d (uint)*(ushort *)puVar3;\n            }\n            else {\n              *param_5 \u003d puVar3 + 1;\nLAB_08006774:\n              uVar10 \u003d *puVar3;\n            }\n            if (bVar1 \u003d\u003d 0x6f) {\n              uVar7 \u003d 8;\n            }\n            else {\n              uVar7 \u003d 10;\n            }\n            pcVar6 \u003d \"0123456789ABCDEF\";\n            goto LAB_08006790;\n          }\n          if (bVar1 \u003d\u003d 0x70) {\n            *param_2 \u003d *param_2 | 0x20;\nLAB_08006726:\n            pcVar6 \u003d \"0123456789abcdef\";\n            *(undefined *)((int)param_2 + 0x45) \u003d 0x78;\n            goto LAB_080067fa;\n          }\n        }\n        else {\n          if (bVar1 \u003d\u003d 0x75) goto LAB_08006766;\n          if (bVar1 \u003d\u003d 0x78) goto LAB_08006726;\n        }\nLAB_080066e0:\n        *(byte *)((int)param_2 + 0x42) \u003d bVar1;\n        goto LAB_08006740;\n      }\n      ppcVar9 \u003d (char **)*param_5;\n      *param_5 \u003d (uint *)(ppcVar9 + 1);\n      __s \u003d *ppcVar9;\n      pvVar4 \u003d memchr(__s,0,param_2[1]);\n      if (pvVar4 !\u003d (void *)0x0) {\n        param_2[1] \u003d (int)pvVar4 - (int)__s;\n      }\n      uVar10 \u003d param_2[1];\n    }\n    param_2[4] \u003d uVar10;\n    *(undefined *)((int)param_2 + 0x43) \u003d 0;\n    goto LAB_080067d6;\n  }\n  uVar10 \u003d *param_2;\n  ppuVar8 \u003d (uint **)*param_5;\n  uVar7 \u003d param_2[5];\n  if ((uVar10 \u0026 0x80) \u003d\u003d 0) {\n    *param_5 \u003d (uint *)(ppuVar8 + 1);\n    puVar3 \u003d *ppuVar8;\n    if ((uVar10 \u0026 0x40) \u003d\u003d 0) goto LAB_08006856;\n    *(short *)puVar3 \u003d (short)uVar7;\n  }\n  else {\n    *param_5 \u003d (uint *)(ppuVar8 + 1);\n    puVar3 \u003d *ppuVar8;\nLAB_08006856:\n    *puVar3 \u003d uVar7;\n  }\nLAB_0800686a:\n  param_2[4] \u003d 0;\nLAB_080067d6:\n  iVar2 \u003d _printf_common(param_1,param_2,local_24,param_3,param_4);\n  if ((iVar2 \u003d\u003d -1) || (iVar2 \u003d (*param_4)(param_1,param_3,__s,param_2[4]), iVar2 \u003d\u003d -1)) {\nLAB_080067ea:\n    uVar10 \u003d 0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 \u003c\u003c 0x1e) \u003c 0) {\n      for (iVar2 \u003d 0; iVar2 \u003c (int)(param_2[3] - local_24[0]); iVar2 \u003d iVar2 + 1) {\n        iVar5 \u003d (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar5 \u003d\u003d -1) goto LAB_080067ea;\n      }\n    }\n    uVar10 \u003d param_2[3];\n    if ((int)param_2[3] \u003c (int)local_24[0]) {\n      uVar10 \u003d local_24[0];\n    }\n  }\n  return uVar10;\n}\n\n",
      "renaming": {},
      "calling": [
        "_vfiprintf_r"
      ],
      "called": [
        "memchr",
        "_printf_common"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080068f0": {
      "entrypoint": "0x080068f0",
      "current_name": "FUN_080068f0",
      "code": "\nint FUN_080068f0(char *__format,...)\n\n{\n  int iVar1;\n  undefined4 in_r1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *pcVar2;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  iVar1 \u003d _impure_ptr;\n  pcVar2 \u003d __format;\n  uStack_c \u003d in_r1;\n  uStack_8 \u003d in_r2;\n  uStack_4 \u003d in_r3;\n  if ((_impure_ptr !\u003d 0) \u0026\u0026 (*(int *)(_impure_ptr + 0x18) \u003d\u003d 0)) {\n    __sinit(_impure_ptr);\n  }\n  iVar1 \u003d _vfiprintf_r(iVar1,*(undefined4 *)(iVar1 + 8),__format,\u0026uStack_c,pcVar2,\u0026uStack_c);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_init"
      ],
      "called": [
        "_vfiprintf_r",
        "__sinit"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006920": {
      "entrypoint": "0x08006920",
      "current_name": "FUN_08006920",
      "code": "\nvoid FUN_08006920(int *param_1,intptr_t param_2)\n\n{\n  void *pvVar1;\n  \n  errno \u003d 0;\n  pvVar1 \u003d _sbrk(param_2);\n  if ((pvVar1 \u003d\u003d (void *)0xffffffff) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_malloc_r"
      ],
      "called": [
        "_sbrk"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006940": {
      "entrypoint": "0x08006940",
      "current_name": "FUN_08006940",
      "code": "\nuint FUN_08006940(int param_1,uint param_2,int *param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined *puVar3;\n  \n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (param_3 \u003d\u003d \u0026__sf_fake_stdin) {\n    param_3 \u003d *(int **)(param_1 + 4);\n  }\n  else if (param_3 \u003d\u003d (int *)\u0026__sf_fake_stdout) {\n    param_3 \u003d *(int **)(param_1 + 8);\n  }\n  else if (param_3 \u003d\u003d (int *)\u0026__sf_fake_stderr) {\n    param_3 \u003d *(int **)(param_1 + 0xc);\n  }\n  param_3[2] \u003d param_3[6];\n  uVar2 \u003d (uint)*(ushort *)(param_3 + 3);\n  iVar1 \u003d uVar2 \u003c\u003c 0x1c;\n  if (((iVar1 \u003c 0) \u0026\u0026 (uVar2 \u003d param_3[4], uVar2 !\u003d 0)) ||\n     (iVar1 \u003d __swsetup_r(param_1,param_3,iVar1,uVar2,param_4), iVar1 \u003d\u003d 0)) {\n    param_2 \u003d param_2 \u0026 0xff;\n    iVar1 \u003d *param_3 - param_3[4];\n    if ((iVar1 \u003c param_3[5]) || (iVar1 \u003d _fflush_r(param_1,param_3), iVar1 \u003d\u003d 0)) {\n      param_3[2] \u003d param_3[2] + -1;\n      puVar3 \u003d (undefined *)*param_3;\n      *param_3 \u003d (int)(puVar3 + 1);\n      *puVar3 \u003d (char)param_2;\n      if (iVar1 + 1 !\u003d param_3[5]) {\n        if (-1 \u003c (int)((uint)*(ushort *)(param_3 + 3) \u003c\u003c 0x1f)) {\n          return param_2;\n        }\n        if (param_2 !\u003d 10) {\n          return param_2;\n        }\n      }\n      iVar1 \u003d _fflush_r(param_1,param_3);\n      if (iVar1 \u003d\u003d 0) {\n        return param_2;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfputc_r"
      ],
      "called": [
        "_fflush_r",
        "__swsetup_r",
        "__sinit"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080069e4": {
      "entrypoint": "0x080069e4",
      "current_name": "FUN_080069e4",
      "code": "\nuint FUN_080069e4(undefined4 *param_1,undefined4 *param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  ushort uVar3;\n  \n  iVar1 \u003d _impure_ptr;\n  if ((_impure_ptr !\u003d 0) \u0026\u0026 (*(int *)(_impure_ptr + 0x18) \u003d\u003d 0)) {\n    __sinit(_impure_ptr);\n  }\n  if (param_2 \u003d\u003d \u0026__sf_fake_stdin) {\n    param_2 \u003d *(undefined4 **)(iVar1 + 4);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stdout) {\n    param_2 \u003d *(undefined4 **)(iVar1 + 8);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stderr) {\n    param_2 \u003d *(undefined4 **)(iVar1 + 0xc);\n  }\n  uVar3 \u003d *(ushort *)(param_2 + 3);\n  uVar2 \u003d (uint)uVar3;\n  if (-1 \u003c (int)(uVar2 \u003c\u003c 0x1c)) {\n    if (-1 \u003c (int)(uVar2 \u003c\u003c 0x1b)) {\n      *param_1 \u003d 9;\n      goto LAB_08006a14;\n    }\n    if ((int)(uVar2 \u003c\u003c 0x1d) \u003c 0) {\n      if ((undefined4 *)param_2[0xd] !\u003d (undefined4 *)0x0) {\n        if ((undefined4 *)param_2[0xd] !\u003d param_2 + 0x11) {\n          _free_r(param_1);\n        }\n        param_2[0xd] \u003d 0;\n      }\n      *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xffdb;\n      param_2[1] \u003d 0;\n      *param_2 \u003d param_2[4];\n    }\n    *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 8;\n  }\n  if ((param_2[4] \u003d\u003d 0) \u0026\u0026 ((*(ushort *)(param_2 + 3) \u0026 0x280) !\u003d 0x200)) {\n    __smakebuf_r(param_1,param_2);\n  }\n  uVar3 \u003d *(ushort *)(param_2 + 3);\n  uVar2 \u003d uVar3 \u0026 1;\n  if ((uVar3 \u0026 1) \u003d\u003d 0) {\n    if (-1 \u003c (int)((uint)uVar3 \u003c\u003c 0x1e)) {\n      uVar2 \u003d param_2[5];\n    }\n    param_2[2] \u003d uVar2;\n  }\n  else {\n    param_2[2] \u003d 0;\n    param_2[6] \u003d -param_2[5];\n  }\n  if (param_2[4] \u003d\u003d 0) {\n    uVar3 \u003d *(ushort *)(param_2 + 3);\n    uVar2 \u003d (int)(short)uVar3 \u0026 0x80;\n    if (uVar2 !\u003d 0) {\nLAB_08006a14:\n      *(ushort *)(param_2 + 3) \u003d uVar3 | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    uVar2 \u003d 0;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swbuf_r",
        "_vfiprintf_r"
      ],
      "called": [
        "__smakebuf_r",
        "_free_r",
        "__sinit"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006ac0": {
      "entrypoint": "0x08006ac0",
      "current_name": "FUN_08006ac0",
      "code": "\n\n\nvoid FUN_08006ac0(void)\n\n{\n  raise(6);\n                    \n  _exit(1);\n}\n\n",
      "renaming": {},
      "calling": [
        "__assert_func",
        "__throw_bad_function_call"
      ],
      "called": [
        "_exit",
        "raise"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006ad0": {
      "entrypoint": "0x08006ad0",
      "current_name": "FUN_08006ad0",
      "code": "\nundefined4 FUN_08006ad0(uint *param_1,int *param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  uint uVar3;\n  ushort uVar4;\n  int iVar5;\n  code *pcVar6;\n  int iVar7;\n  uint uVar8;\n  bool bVar9;\n  \n  uVar4 \u003d *(ushort *)(param_2 + 3);\n  uVar3 \u003d (uint)uVar4;\n  if ((int)(uVar3 \u003c\u003c 0x1c) \u003c 0) {\n    iVar1 \u003d param_2[4];\n    if (iVar1 !\u003d 0) {\n      iVar5 \u003d uVar3 \u003c\u003c 0x1e;\n      bVar9 \u003d iVar5 !\u003d 0;\n      if (bVar9) {\n        iVar5 \u003d 0;\n      }\n      iVar7 \u003d *param_2;\n      if (!bVar9) {\n        iVar5 \u003d param_2[5];\n      }\n      *param_2 \u003d iVar1;\n      param_2[2] \u003d iVar5;\n      for (iVar7 \u003d iVar7 - iVar1; 0 \u003c iVar7; iVar7 \u003d iVar7 - iVar5) {\n        iVar5 \u003d (*(code *)param_2[10])(param_1,param_2[8],iVar1,iVar7);\n        if (iVar5 \u003c 1) {\n          uVar4 \u003d *(ushort *)(param_2 + 3);\n          goto LAB_08006bc6;\n        }\n        iVar1 \u003d iVar1 + iVar5;\n      }\n    }\n  }\n  else if (((0 \u003c param_2[1]) || (0 \u003c param_2[0x10])) \u0026\u0026\n          (pcVar6 \u003d (code *)param_2[0xb], pcVar6 !\u003d (code *)0x0)) {\n    uVar8 \u003d *param_1;\n    *param_1 \u003d 0;\n    if ((uVar4 \u0026 0x1000) \u003d\u003d 0) {\n      iVar1 \u003d (*pcVar6)(param_1,param_2[8],uVar3 \u0026 0x1000,1);\n      if ((iVar1 \u003d\u003d -1) \u0026\u0026 (uVar3 \u003d *param_1, uVar3 !\u003d 0)) {\n        if ((uVar3 !\u003d 0x1d) \u0026\u0026 (uVar3 !\u003d 0x16)) {\n          *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *param_1 \u003d uVar8;\n        return 0;\n      }\n    }\n    else {\n      iVar1 \u003d param_2[0x15];\n    }\n    if (((int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x1d) \u003c 0) \u0026\u0026\n       (iVar1 \u003d iVar1 - param_2[1], param_2[0xd] !\u003d 0)) {\n      iVar1 \u003d iVar1 - param_2[0x10];\n    }\n    iVar1 \u003d (*(code *)param_2[0xb])(param_1,param_2[8],iVar1,0);\n    uVar4 \u003d *(ushort *)(param_2 + 3);\n    if ((iVar1 \u003d\u003d -1) \u0026\u0026\n       ((0x1d \u003c *param_1 || (-1 \u003c (int)((0x20400001U \u003e\u003e (*param_1 \u0026 0xff)) \u003c\u003c 0x1f))))) {\nLAB_08006bc6:\n      *(ushort *)(param_2 + 3) \u003d uVar4 | 0x40;\n      return 0xffffffff;\n    }\n    param_2[1] \u003d 0;\n    *param_2 \u003d param_2[4];\n    if (((int)((uint)uVar4 \u003c\u003c 0x13) \u003c 0) \u0026\u0026 ((iVar1 !\u003d -1 || (*param_1 \u003d\u003d 0)))) {\n      param_2[0x15] \u003d iVar1;\n    }\n    piVar2 \u003d (int *)param_2[0xd];\n    *param_1 \u003d uVar8;\n    if (piVar2 !\u003d (int *)0x0) {\n      if (piVar2 !\u003d param_2 + 0x11) {\n        _free_r(param_1);\n      }\n      param_2[0xd] \u003d 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fflush_r"
      ],
      "called": [
        "_free_r"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006be0": {
      "entrypoint": "0x08006be0",
      "current_name": "FUN_08006be0",
      "code": "\nundefined4 FUN_08006be0(int param_1,undefined4 *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 uVar1;\n  \n  if (param_2[4] !\u003d 0) {\n    if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n      __sinit();\n    }\n    if (param_2 \u003d\u003d \u0026__sf_fake_stdin) {\n      param_2 \u003d *(undefined4 **)(param_1 + 4);\n    }\n    else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stdout) {\n      param_2 \u003d *(undefined4 **)(param_1 + 8);\n    }\n    else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stderr) {\n      param_2 \u003d *(undefined4 **)(param_1 + 0xc);\n    }\n    if (*(short *)(param_2 + 3) !\u003d 0) {\n      uVar1 \u003d __sflush_r(param_1,param_2,param_3,param_4);\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swbuf_r"
      ],
      "called": [
        "__sflush_r",
        "__sinit"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006c34": {
      "entrypoint": "0x08006c34",
      "current_name": "FUN_08006c34",
      "code": "\nvoid FUN_08006c34(undefined4 param_1)\n\n{\n  _fwalk_reent(param_1,0x8006be1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_fwalk_reent"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006c40": {
      "entrypoint": "0x08006c40",
      "current_name": "FUN_08006c40",
      "code": "\nvoid FUN_08006c40(undefined4 *param_1,undefined2 param_2,undefined2 param_3)\n\n{\n  *param_1 \u003d 0;\n  param_1[1] \u003d 0;\n  param_1[2] \u003d 0;\n  *(undefined2 *)(param_1 + 3) \u003d param_2;\n  param_1[0x19] \u003d 0;\n  *(undefined2 *)((int)param_1 + 0xe) \u003d param_3;\n  param_1[4] \u003d 0;\n  param_1[5] \u003d 0;\n  param_1[6] \u003d 0;\n  memset(param_1 + 0x17,0,8);\n  param_1[8] \u003d param_1;\n  param_1[9] \u003d 0x8006f39;\n  param_1[10] \u003d 0x8006f5b;\n  param_1[0xb] \u003d 0x8006f93;\n  param_1[0xc] \u003d 0x8006fb7;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sinit"
      ],
      "called": [
        "memset"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006c88": {
      "entrypoint": "0x08006c88",
      "current_name": "FUN_08006c88",
      "code": "\nundefined4 * FUN_08006c88(undefined4 param_1,int param_2)\n\n{\n  undefined4 *puVar1;\n  int iVar2;\n  \n  iVar2 \u003d (param_2 + -1) * 0x68;\n  puVar1 \u003d (undefined4 *)_malloc_r(param_1,iVar2 + 0x74);\n  if (puVar1 !\u003d (undefined4 *)0x0) {\n    *puVar1 \u003d 0;\n    puVar1[1] \u003d param_2;\n    puVar1[2] \u003d puVar1 + 3;\n    memset(puVar1 + 3,0,iVar2 + 0x68);\n  }\n  return puVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfp"
      ],
      "called": [
        "_malloc_r",
        "memset"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006cb4": {
      "entrypoint": "0x08006cb4",
      "current_name": "FUN_08006cb4",
      "code": "\nvoid FUN_08006cb4(undefined1 *param_1)\n\n{\n  undefined4 uVar1;\n  undefined1 *puVar2;\n  \n  if (*(int *)(param_1 + 0x18) \u003d\u003d 0) {\n    *(undefined4 *)(param_1 + 0x48) \u003d 0;\n    *(undefined4 *)(param_1 + 0x4c) \u003d 0;\n    *(undefined4 *)(param_1 + 0x50) \u003d 0;\n    puVar2 \u003d \u0026impure_data;\n    *(undefined4 *)(param_1 + 0x28) \u003d 0x8006c35;\n    if (param_1 \u003d\u003d \u0026impure_data) {\n      puVar2 \u003d (undefined1 *)0x1;\n    }\n    if (param_1 \u003d\u003d \u0026impure_data) {\n      *(undefined1 **)(param_1 + 0x18) \u003d puVar2;\n    }\n    uVar1 \u003d __sfp();\n    *(undefined4 *)(param_1 + 4) \u003d uVar1;\n    uVar1 \u003d __sfp(param_1);\n    *(undefined4 *)(param_1 + 8) \u003d uVar1;\n    uVar1 \u003d __sfp(param_1);\n    *(undefined4 *)(param_1 + 0xc) \u003d uVar1;\n    std_isra_0(*(undefined4 *)(param_1 + 4),4,0);\n    std_isra_0(*(undefined4 *)(param_1 + 8),9,1);\n    std_isra_0(*(undefined4 *)(param_1 + 0xc),0x12,2);\n    *(undefined4 *)(param_1 + 0x18) \u003d 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fflush_r",
        "__swbuf_r",
        "__sfp",
        "__swsetup_r",
        "iprintf",
        "_vfiprintf_r"
      ],
      "called": [
        "std.isra.0",
        "__sfp"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006d14": {
      "entrypoint": "0x08006d14",
      "current_name": "FUN_08006d14",
      "code": "\nint * FUN_08006d14(undefined4 *param_1)\n\n{\n  int *piVar1;\n  int *piVar2;\n  int **ppiVar3;\n  \n  if (DAT_20000114 \u003d\u003d 0) {\n    __sinit(\u0026impure_data);\n  }\n  ppiVar3 \u003d (int **)\u0026DAT_20000144;\n  do {\n    piVar2 \u003d ppiVar3[2];\n    piVar1 \u003d ppiVar3[1];\n    while (piVar1 \u003d (int *)((int)piVar1 + -1), -1 \u003c (int)piVar1) {\n      if (*(short *)(piVar2 + 3) \u003d\u003d 0) {\n        *(undefined2 *)((int)piVar2 + 0xe) \u003d 0xffff;\n        piVar2[0x19] \u003d 0;\n        *(undefined2 *)(piVar2 + 3) \u003d 1;\n        *piVar2 \u003d 0;\n        piVar2[2] \u003d 0;\n        piVar2[1] \u003d 0;\n        piVar2[4] \u003d 0;\n        piVar2[5] \u003d 0;\n        piVar2[6] \u003d 0;\n        memset(piVar2 + 0x17,0,8);\n        piVar2[0xd] \u003d 0;\n        piVar2[0xe] \u003d 0;\n        piVar2[0x12] \u003d 0;\n        piVar2[0x13] \u003d 0;\n        return piVar2;\n      }\n      piVar2 \u003d piVar2 + 0x1a;\n    }\n    if (*ppiVar3 \u003d\u003d (int *)0x0) {\n      piVar1 \u003d (int *)__sfmoreglue(param_1,4);\n      *ppiVar3 \u003d piVar1;\n      if (piVar1 \u003d\u003d (int *)0x0) {\n        *param_1 \u003d 0xc;\n        return (int *)0x0;\n      }\n    }\n    ppiVar3 \u003d (int **)*ppiVar3;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "__sinit"
      ],
      "called": [
        "memset",
        "__sfmoreglue",
        "__sinit"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006d8c": {
      "entrypoint": "0x08006d8c",
      "current_name": "FUN_08006d8c",
      "code": "\nuint FUN_08006d8c(int param_1,code *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  uint uVar1;\n  int iVar2;\n  int *piVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  \n  uVar5 \u003d 0;\n  for (piVar3 \u003d (int *)(param_1 + 0x48); piVar3 !\u003d (int *)0x0; piVar3 \u003d (int *)*piVar3) {\n    iVar4 \u003d piVar3[2];\n    iVar6 \u003d piVar3[1];\n    while (iVar6 \u003d iVar6 + -1, -1 \u003c iVar6) {\n      if ((1 \u003c *(ushort *)(iVar4 + 0xc)) \u0026\u0026 (iVar2 \u003d *(short *)(iVar4 + 0xe) + 1, iVar2 !\u003d 0)) {\n        uVar1 \u003d (*param_2)(param_1,iVar4,param_3,iVar2,param_4);\n        uVar5 \u003d uVar5 | uVar1;\n      }\n      iVar4 \u003d iVar4 + 0x68;\n    }\n  }\n  return uVar5;\n}\n\n",
      "renaming": {},
      "calling": [
        "_cleanup_r"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006dc8": {
      "entrypoint": "0x08006dc8",
      "current_name": "FUN_08006dc8",
      "code": "\nundefined4 FUN_08006dc8(undefined4 param_1,int param_2,undefined4 *param_3,uint *param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_4c [4];\n  uint local_48;\n  \n  if ((*(short *)(param_2 + 0xe) \u003c 0) ||\n     (iVar1 \u003d _fstat_r(param_1,(int)*(short *)(param_2 + 0xe),auStack_4c), iVar1 \u003c 0)) {\n    *param_4 \u003d 0;\n    if ((int)((uint)*(ushort *)(param_2 + 0xc) \u003c\u003c 0x18) \u003c 0) {\n      uVar2 \u003d 0x40;\n      goto LAB_08006e08;\n    }\n  }\n  else {\n    *param_4 \u003d (uint)((local_48 \u0026 0xf000) \u003d\u003d 0x2000);\n  }\n  uVar2 \u003d 0x400;\nLAB_08006e08:\n  *param_3 \u003d uVar2;\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__smakebuf_r"
      ],
      "called": [
        "_fstat_r"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006e10": {
      "entrypoint": "0x08006e10",
      "current_name": "FUN_08006e10",
      "code": "\nvoid FUN_08006e10(int param_1,int *param_2)\n\n{\n  ushort uVar1;\n  int iVar2;\n  int local_18;\n  int *local_14;\n  \n  if (-1 \u003c (int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x1e)) {\n    local_18 \u003d param_1;\n    local_14 \u003d param_2;\n    uVar1 \u003d __swhatbuf_r(param_1,param_2,\u0026local_18,\u0026local_14);\n    iVar2 \u003d _malloc_r(param_1,local_18);\n    if (iVar2 !\u003d 0) {\n      *(undefined4 *)(param_1 + 0x28) \u003d 0x8006c35;\n      *param_2 \u003d iVar2;\n      *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x80;\n      param_2[4] \u003d iVar2;\n      param_2[5] \u003d local_18;\n      if ((local_14 !\u003d (int *)0x0) \u0026\u0026\n         (iVar2 \u003d _isatty_r(param_1,(int)*(short *)((int)param_2 + 0xe)), iVar2 !\u003d 0)) {\n        *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xfffc | 1;\n      }\n      *(ushort *)(param_2 + 3) \u003d uVar1 | *(ushort *)(param_2 + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(param_2 + 3) \u003c\u003c 0x16 \u003c 0) {\n      return;\n    }\n    *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xfffc | 2;\n  }\n  *param_2 \u003d (int)param_2 + 0x47;\n  param_2[4] \u003d (int)param_2 + 0x47;\n  param_2[5] \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swsetup_r"
      ],
      "called": [
        "_malloc_r",
        "_isatty_r",
        "__swhatbuf_r"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006e90": {
      "entrypoint": "0x08006e90",
      "current_name": "FUN_08006e90",
      "code": "\nvoid * FUN_08006e90(void *__s,int __c,size_t __n)\n\n{\n  byte *pbVar1;\n  byte *pbVar2;\n  \n  pbVar1 \u003d (byte *)__s;\n  do {\n    pbVar2 \u003d pbVar1;\n    if (pbVar2 \u003d\u003d (byte *)(__n + (int)__s)) {\n      return (void *)0x0;\n    }\n    pbVar1 \u003d pbVar2 + 1;\n  } while ((uint)*pbVar2 !\u003d (__c \u0026 0xffU));\n  return pbVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "_vfiprintf_r",
        "_printf_i"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006eac": {
      "entrypoint": "0x08006eac",
      "current_name": "FUN_08006eac",
      "code": "\nvoid FUN_08006eac(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_malloc_r",
        "_free_r"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006eae": {
      "entrypoint": "0x08006eae",
      "current_name": "FUN_08006eae",
      "code": "\nvoid FUN_08006eae(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_malloc_r",
        "_free_r"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006eb0": {
      "entrypoint": "0x08006eb0",
      "current_name": "FUN_08006eb0",
      "code": "\nundefined4 FUN_08006eb0(undefined4 *param_1,uint param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  __pid_t _Var1;\n  undefined4 uVar2;\n  int iVar3;\n  code *pcVar4;\n  \n  if (0x1f \u003c param_2) {\n    *param_1 \u003d 0x16;\n    return 0xffffffff;\n  }\n  iVar3 \u003d param_1[0x11];\n  if ((iVar3 !\u003d 0) \u0026\u0026 (pcVar4 \u003d *(code **)(iVar3 + param_2 * 4), pcVar4 !\u003d (code *)0x0)) {\n    if (pcVar4 !\u003d (code *)0x1) {\n      if (pcVar4 \u003d\u003d (code *)0xffffffff) {\n        *param_1 \u003d 0x16;\n        return 1;\n      }\n      *(undefined4 *)(iVar3 + param_2 * 4) \u003d 0;\n      (*pcVar4)(param_2);\n    }\n    return 0;\n  }\n  _Var1 \u003d _getpid_r();\n  uVar2 \u003d _kill_r(param_1,_Var1,param_2,param_4);\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "raise"
      ],
      "called": [
        "_kill_r",
        "_getpid_r"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006f00": {
      "entrypoint": "0x08006f00",
      "current_name": "FUN_08006f00",
      "code": "\nint FUN_08006f00(int __sig)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d _raise_r(_impure_ptr,__sig);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "abort"
      ],
      "called": [
        "_raise_r"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006f10": {
      "entrypoint": "0x08006f10",
      "current_name": "FUN_08006f10",
      "code": "\nvoid FUN_08006f10(int *param_1,__pid_t param_2,int param_3)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _kill(param_2,param_3);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_raise_r"
      ],
      "called": [
        "_kill"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006f34": {
      "entrypoint": "0x08006f34",
      "current_name": "FUN_08006f34",
      "code": "\n\n\n__pid_t _getpid(void)\n\n{\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_raise_r"
      ],
      "called": [
        "_getpid"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006f38": {
      "entrypoint": "0x08006f38",
      "current_name": "FUN_08006f38",
      "code": "\nvoid FUN_08006f38(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  bool bVar3;\n  \n  iVar1 \u003d _read_r(param_1,(int)*(short *)(param_2 + 0xe));\n  bVar3 \u003d -1 \u003c iVar1;\n  if (bVar3) {\n    uVar2 \u003d *(int *)(param_2 + 0x54) + iVar1;\n  }\n  else {\n    uVar2 \u003d *(ushort *)(param_2 + 0xc) \u0026 0xffffefff;\n  }\n  if (bVar3) {\n    *(uint *)(param_2 + 0x54) \u003d uVar2;\n  }\n  if (!bVar3) {\n    *(short *)(param_2 + 0xc) \u003d (short)uVar2;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_read_r"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006f5a": {
      "entrypoint": "0x08006f5a",
      "current_name": "FUN_08006f5a",
      "code": "\nvoid FUN_08006f5a(undefined4 param_1,int param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  if ((int)((uint)*(ushort *)(param_2 + 0xc) \u003c\u003c 0x17) \u003c 0) {\n    _lseek_r(param_1,(int)*(short *)(param_2 + 0xe),0,2);\n  }\n  *(ushort *)(param_2 + 0xc) \u003d *(ushort *)(param_2 + 0xc) \u0026 0xefff;\n  _write_r(param_1,(int)*(short *)(param_2 + 0xe),param_3,param_4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_write_r",
        "_lseek_r"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006f92": {
      "entrypoint": "0x08006f92",
      "current_name": "FUN_08006f92",
      "code": "\nvoid FUN_08006f92(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  ushort uVar2;\n  bool bVar3;\n  \n  iVar1 \u003d _lseek_r(param_1,(int)*(short *)(param_2 + 0xe));\n  bVar3 \u003d iVar1 \u003d\u003d -1;\n  if (bVar3) {\n    uVar2 \u003d *(ushort *)(param_2 + 0xc) \u0026 0xefff;\n  }\n  else {\n    *(int *)(param_2 + 0x54) \u003d iVar1;\n    uVar2 \u003d *(ushort *)(param_2 + 0xc) | 0x1000;\n  }\n  if (bVar3) {\n    *(ushort *)(param_2 + 0xc) \u003d uVar2;\n  }\n  if (!bVar3) {\n    *(ushort *)(param_2 + 0xc) \u003d uVar2;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_lseek_r"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006fb6": {
      "entrypoint": "0x08006fb6",
      "current_name": "FUN_08006fb6",
      "code": "\nvoid FUN_08006fb6(undefined4 param_1,int param_2)\n\n{\n  _close_r(param_1,(int)*(short *)(param_2 + 0xe));\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_close_r"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006fc0": {
      "entrypoint": "0x08006fc0",
      "current_name": "FUN_08006fc0",
      "code": "\nvoid FUN_08006fc0(int *param_1,int param_2,char *param_3,int param_4)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _write(param_2,param_3,param_4);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swrite"
      ],
      "called": [
        "_write"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08006fe4": {
      "entrypoint": "0x08006fe4",
      "current_name": "FUN_08006fe4",
      "code": "\nvoid FUN_08006fe4(int *param_1,int param_2)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _close(param_2);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sclose"
      ],
      "called": [
        "_close"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08007004": {
      "entrypoint": "0x08007004",
      "current_name": "FUN_08007004",
      "code": "\nvoid FUN_08007004(int *param_1,int param_2,stat *param_3)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _fstat(param_2,param_3);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swhatbuf_r"
      ],
      "called": [
        "_fstat"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08007028": {
      "entrypoint": "0x08007028",
      "current_name": "FUN_08007028",
      "code": "\nvoid FUN_08007028(int *param_1,int param_2)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _isatty(param_2);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__smakebuf_r"
      ],
      "called": [
        "_isatty"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08007048": {
      "entrypoint": "0x08007048",
      "current_name": "FUN_08007048",
      "code": "\nvoid FUN_08007048(int *param_1,int param_2,__off_t param_3,int param_4)\n\n{\n  __off_t _Var1;\n  \n  errno \u003d 0;\n  _Var1 \u003d _lseek(param_2,param_3,param_4);\n  if ((_Var1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swrite",
        "__sseek"
      ],
      "called": [
        "_lseek"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800706c": {
      "entrypoint": "0x0800706c",
      "current_name": "FUN_0800706c",
      "code": "\nvoid FUN_0800706c(int *param_1,int param_2,char *param_3,int param_4)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _read(param_2,param_3,param_4);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sread"
      ],
      "called": [
        "_read"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08007090": {
      "entrypoint": "0x08007090",
      "current_name": "FUN_08007090",
      "code": "\n\n/* std::__throw_bad_function_call() */\n\nvoid std::FUN_08007090(void)\n\n{\n                    \n  abort();\n}\n\n",
      "renaming": {},
      "calling": [
        "operator()"
      ],
      "called": [
        "abort"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08007098": {
      "entrypoint": "0x08007098",
      "current_name": "FUN_08007098",
      "code": "\n/* std::ctype_byname\u003cchar\u003e::ctype_byname(std::basic_string\u003cchar, std::char_traits\u003cchar\u003e,\n   std::allocator\u003cchar\u003e \u003e const\u0026, unsigned int) */\n\nvoid std::ctype_byname\u003cchar\u003e::FUN_08007098(void)\n\n{\n  if (-1 \u003c moneypunct\u003cchar,false\u003e::id \u003c\u003c 0x1f) {\n    moneypunct\u003cchar,false\u003e::id \u003d 1;\n  }\n  if (-1 \u003c moneypunct\u003cchar,true\u003e::id \u003c\u003c 0x1f) {\n    moneypunct\u003cchar,true\u003e::id \u003d 1;\n  }\n  if (-1 \u003c money_get\u003cchar,std::istreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003c\u003c 0x1f) {\n    money_get\u003cchar,std::istreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c money_put\u003cchar,std::ostreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003c\u003c 0x1f) {\n    money_put\u003cchar,std::ostreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c numpunct\u003cchar\u003e::id \u003c\u003c 0x1f) {\n    numpunct\u003cchar\u003e::id \u003d 1;\n  }\n  if (-1 \u003c num_get\u003cchar,std::istreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003c\u003c 0x1f) {\n    num_get\u003cchar,std::istreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c num_put\u003cchar,std::ostreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003c\u003c 0x1f) {\n    num_put\u003cchar,std::ostreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __timepunct\u003cchar\u003e::id \u003c\u003c 0x1f) {\n    __timepunct\u003cchar\u003e::id \u003d 1;\n  }\n  if (-1 \u003c time_put\u003cchar,std::ostreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003c\u003c 0x1f) {\n    time_put\u003cchar,std::ostreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c time_get\u003cchar,std::istreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003c\u003c 0x1f) {\n    time_get\u003cchar,std::istreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c messages\u003cchar\u003e::id \u003c\u003c 0x1f) {\n    messages\u003cchar\u003e::id \u003d 1;\n  }\n  if (-1 \u003c collate\u003cchar\u003e::id \u003c\u003c 0x1f) {\n    collate\u003cchar\u003e::id \u003d 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0800715c": {
      "entrypoint": "0x0800715c",
      "current_name": "FUN_0800715c",
      "code": "\n/* std::ctype_byname\u003cwchar_t\u003e::ctype_byname(std::basic_string\u003cchar, std::char_traits\u003cchar\u003e,\n   std::allocator\u003cchar\u003e \u003e const\u0026, unsigned int) */\n\nvoid std::ctype_byname\u003cwchar_t\u003e::FUN_0800715c(void)\n\n{\n  if (-1 \u003c moneypunct\u003cwchar_t,false\u003e::id \u003c\u003c 0x1f) {\n    moneypunct\u003cwchar_t,false\u003e::id \u003d 1;\n  }\n  if (-1 \u003c moneypunct\u003cwchar_t,true\u003e::id \u003c\u003c 0x1f) {\n    moneypunct\u003cwchar_t,true\u003e::id \u003d 1;\n  }\n  if (-1 \u003c money_get\u003cwchar_t,std::istreambuf_iterator\u003cwchar_t,std::char_traits\u003cwchar_t\u003e\u003e\u003e::id \u003c\u003c\n           0x1f) {\n    money_get\u003cwchar_t,std::istreambuf_iterator\u003cwchar_t,std::char_traits\u003cwchar_t\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c money_put\u003cwchar_t,std::ostreambuf_iterator\u003cwchar_t,std::char_traits\u003cwchar_t\u003e\u003e\u003e::id \u003c\u003c\n           0x1f) {\n    money_put\u003cwchar_t,std::ostreambuf_iterator\u003cwchar_t,std::char_traits\u003cwchar_t\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c numpunct\u003cwchar_t\u003e::id \u003c\u003c 0x1f) {\n    numpunct\u003cwchar_t\u003e::id \u003d 1;\n  }\n  if (-1 \u003c num_get\u003cwchar_t,std::istreambuf_iterator\u003cwchar_t,std::char_traits\u003cwchar_t\u003e\u003e\u003e::id \u003c\u003c 0x1f)\n  {\n    num_get\u003cwchar_t,std::istreambuf_iterator\u003cwchar_t,std::char_traits\u003cwchar_t\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c num_put\u003cwchar_t,std::ostreambuf_iterator\u003cwchar_t,std::char_traits\u003cwchar_t\u003e\u003e\u003e::id \u003c\u003c 0x1f)\n  {\n    num_put\u003cwchar_t,std::ostreambuf_iterator\u003cwchar_t,std::char_traits\u003cwchar_t\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __timepunct\u003cwchar_t\u003e::id \u003c\u003c 0x1f) {\n    __timepunct\u003cwchar_t\u003e::id \u003d 1;\n  }\n  if (-1 \u003c time_put\u003cwchar_t,std::ostreambuf_iterator\u003cwchar_t,std::char_traits\u003cwchar_t\u003e\u003e\u003e::id \u003c\u003c 0x1f\n     ) {\n    time_put\u003cwchar_t,std::ostreambuf_iterator\u003cwchar_t,std::char_traits\u003cwchar_t\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c time_get\u003cwchar_t,std::istreambuf_iterator\u003cwchar_t,std::char_traits\u003cwchar_t\u003e\u003e\u003e::id \u003c\u003c 0x1f\n     ) {\n    time_get\u003cwchar_t,std::istreambuf_iterator\u003cwchar_t,std::char_traits\u003cwchar_t\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c messages\u003cwchar_t\u003e::id \u003c\u003c 0x1f) {\n    messages\u003cwchar_t\u003e::id \u003d 1;\n  }\n  if (-1 \u003c collate\u003cwchar_t\u003e::id \u003c\u003c 0x1f) {\n    collate\u003cwchar_t\u003e::id \u003d 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08007220": {
      "entrypoint": "0x08007220",
      "current_name": "FUN_08007220",
      "code": "\n/* std::ctype_byname\u003cwchar_t\u003e::ctype_byname(std::__cxx11::basic_string\u003cchar, std::char_traits\u003cchar\u003e,\n   std::allocator\u003cchar\u003e \u003e const\u0026, unsigned int) */\n\nvoid std::ctype_byname\u003cwchar_t\u003e::FUN_08007220(void)\n\n{\n  if (-1 \u003c __cxx11::moneypunct\u003cwchar_t,false\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::moneypunct\u003cwchar_t,false\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::moneypunct\u003cwchar_t,true\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::moneypunct\u003cwchar_t,true\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::money_get\u003cwchar_t,std::istreambuf_iterator\u003cwchar_t,std::char_traits\u003cwchar_t\u003e\u003e\u003e::\n           id \u003c\u003c 0x1f) {\n    __cxx11::money_get\u003cwchar_t,std::istreambuf_iterator\u003cwchar_t,std::char_traits\u003cwchar_t\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::money_put\u003cwchar_t,std::ostreambuf_iterator\u003cwchar_t,std::char_traits\u003cwchar_t\u003e\u003e\u003e::\n           id \u003c\u003c 0x1f) {\n    __cxx11::money_put\u003cwchar_t,std::ostreambuf_iterator\u003cwchar_t,std::char_traits\u003cwchar_t\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::numpunct\u003cwchar_t\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::numpunct\u003cwchar_t\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::time_get\u003cwchar_t,std::istreambuf_iterator\u003cwchar_t,std::char_traits\u003cwchar_t\u003e\u003e\u003e::\n           id \u003c\u003c 0x1f) {\n    __cxx11::time_get\u003cwchar_t,std::istreambuf_iterator\u003cwchar_t,std::char_traits\u003cwchar_t\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::messages\u003cwchar_t\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::messages\u003cwchar_t\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::collate\u003cwchar_t\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::collate\u003cwchar_t\u003e::id \u003d 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_080072a4": {
      "entrypoint": "0x080072a4",
      "current_name": "FUN_080072a4",
      "code": "\n/* std::ctype_byname\u003cchar\u003e::ctype_byname(std::__cxx11::basic_string\u003cchar, std::char_traits\u003cchar\u003e,\n   std::allocator\u003cchar\u003e \u003e const\u0026, unsigned int) */\n\nvoid std::ctype_byname\u003cchar\u003e::FUN_080072a4(void)\n\n{\n  if (-1 \u003c __cxx11::moneypunct\u003cchar,false\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::moneypunct\u003cchar,false\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::moneypunct\u003cchar,true\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::moneypunct\u003cchar,true\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::money_get\u003cchar,std::istreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003c\u003c\n           0x1f) {\n    __cxx11::money_get\u003cchar,std::istreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::money_put\u003cchar,std::ostreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003c\u003c\n           0x1f) {\n    __cxx11::money_put\u003cchar,std::ostreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::numpunct\u003cchar\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::numpunct\u003cchar\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::time_get\u003cchar,std::istreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003c\u003c 0x1f\n     ) {\n    __cxx11::time_get\u003cchar,std::istreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::messages\u003cchar\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::messages\u003cchar\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::collate\u003cchar\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::collate\u003cchar\u003e::id \u003d 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08007328": {
      "entrypoint": "0x08007328",
      "current_name": "FUN_08007328",
      "code": "\nvoid FUN_08007328(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_init_array",
        "__do_global_dtors_aux"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_08007334": {
      "entrypoint": "0x08007334",
      "current_name": "FUN_08007334",
      "code": "\nvoid FUN_08007334(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    }
  },
  "layers": [],
  "locked_functions": [],
  "used_tokens": 0
}