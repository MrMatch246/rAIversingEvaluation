{
    "functions": {
        "FUN_080001ac": {
            "entrypoint": "0x080001ac",
            "current_name": "initialize_completed_flag_080001ac",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080001b8) */\n\nundefined4 initializeCompletedFlag_080001ac(undefined4 inputParameter)\n\n{\n  if ((char)completionStatus == '\\0') {\n    completionStatus._0_1_ = '\\x01';\n  }\n  return inputParameter;\n}\n\n",
            "renaming": {
                "FUN_080001ac": "initialize_completed_flag_080001ac",
                "param_1": "inputParameter",
                "completed_8667": "completionStatus"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080001d0": {
            "entrypoint": "0x080001d0",
            "current_name": "FUNC_080001d0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080001d4) */\n/* WARNING: Removing unreachable block (ram,0x080001ee) */\n/* WARNING: Removing unreachable block (ram,0x080001e4) */\n/* WARNING: Removing unreachable block (ram,0x08000200) */\n/* WARNING: Removing unreachable block (ram,0x080001f4) */\n\nvoid FUNC_080001d0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080001d0": "FUNC_080001d0"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000218": {
            "entrypoint": "0x08000218",
            "current_name": "calculate_string_length_08000218",
            "code": "\nsize_t calculateStringLength_08000218(char *str)\n\n{\n  char currentChar;\n  char *nextCharPtr;\n  char *currentCharPtr;\n  \n  currentCharPtr = str;\n  do {\n    nextCharPtr = currentCharPtr + 1;\n    currentChar = *currentCharPtr;\n    currentCharPtr = nextCharPtr;\n  } while (currentChar != '\\0');\n  return (size_t)(nextCharPtr + (-1 - (int)str));\n}\n\n",
            "renaming": {
                "FUN_08000218": "calculate_string_length_08000218",
                "__s": "str",
                "cVar1": "currentChar",
                "pcVar2": "nextCharPtr",
                "pcVar3": "currentCharPtr"
            },
            "calling": [
                "printNumber"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000230": {
            "entrypoint": "0x08000230",
            "current_name": "find_byte_in_memory_08000230",
            "code": "\nvoid * find_byte_in_memory_08000230(void *memory,int target_byte,size_t length)\n\n{\n  byte current_byte;\n  char flag1;\n  char flag2;\n  char flag3;\n  char flag4;\n  byte *ptr1;\n  uint *ptr2;\n  byte *ptr3;\n  uint target_byte_value;\n  uint alignment;\n  uint aligned_length;\n  uint xor_result1;\n  uint xor_result2;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  bool condition4;\n  \n  target_byte_value = target_byte & 0xff;\n  if ((int)length < 0x10) {\njoined_r0x08000290:\n    do {\n      if (length == 0) {\n        return (void *)0x0;\n      }\n                    /* WARNING: Load size is inaccurate */\n      ptr2 = (uint *)((int)memory + 1);\n      current_byte = *memory;\n      length = length - 1;\n      memory = ptr2;\n    } while (current_byte != target_byte_value);\n  }\n  else {\n    alignment = (uint)memory & 7;\n    while( true ) {\n      if (alignment == 0) {\n        alignment = target_byte_value | target_byte_value << 8;\n        alignment = alignment | alignment << 0x10;\n        aligned_length = length & 0xfffffff8;\n        do {\n          ptr2 = (uint *)((int)memory + 8);\n                    /* WARNING: Load size is inaccurate */\n          aligned_length = aligned_length - 8;\n          xor_result1 = *memory ^ alignment;\n          xor_result2 = *(uint *)((int)memory + 4) ^ alignment;\n          flag1 = -((char)xor_result1 == '\\0');\n          flag2 = -((char)(xor_result1 >> 8) == '\\0');\n          flag3 = -((char)(xor_result1 >> 0x10) == '\\0');\n          flag4 = -((char)(xor_result1 >> 0x18) == '\\0');\n          xor_result1 = CONCAT13(flag4,CONCAT12(flag3,CONCAT11(flag2,flag1)));\n          condition1 = (char)xor_result2 != '\\0';\n          condition2 = (char)(xor_result2 >> 8) != '\\0';\n          condition3 = (char)(xor_result2 >> 0x10) != '\\0';\n          condition4 = (char)(xor_result2 >> 0x18) != '\\0';\n          xor_result2 = CONCAT13(condition4 * flag4 - !condition4,\n                            CONCAT12(condition3 * flag3 - !condition3,\n                                     CONCAT11(condition2 * flag2 - !condition2,condition1 * flag1 - !condition1)));\n          if (xor_result2 != 0) {\n            if (xor_result1 == 0) {\n              ptr3 = (byte *)((int)memory + 5);\n              xor_result1 = xor_result2;\n            }\n            else {\n              ptr3 = (byte *)((int)memory + 1);\n            }\n            if ((xor_result1 & 1) == 0) {\n              condition1 = (xor_result1 & 0x100) == 0;\n              ptr1 = ptr3 + 1;\n              if (condition1) {\n                condition1 = (xor_result1 & 0x18000) == 0;\n                ptr1 = ptr3 + 2;\n              }\n              ptr3 = ptr1;\n              if (condition1) {\n                ptr3 = ptr3 + 1;\n              }\n            }\n            return ptr3 + -1;\n          }\n          memory = ptr2;\n        } while (aligned_length != 0);\n        length = length & 7;\n        goto joined_r0x08000290;\n      }\n                    /* WARNING: Load size is inaccurate */\n      ptr2 = (uint *)((int)memory + 1);\n      length = length - 1;\n      if (*memory == target_byte_value) break;\n      alignment = (uint)ptr2 & 7;\n      memory = ptr2;\n      if (length == 0) {\n        return (void *)0x0;\n      }\n    }\n  }\n  return (byte *)((int)ptr2 + -1);\n}\n\n",
            "renaming": {
                "FUN_08000230": "find_byte_in_memory_08000230",
                "__s": "memory",
                "__c": "target_byte",
                "__n": "length",
                "bVar1": "current_byte",
                "cVar2": "flag1",
                "cVar3": "flag2",
                "cVar4": "flag3",
                "cVar5": "flag4",
                "pbVar6": "ptr1",
                "puVar7": "ptr2",
                "pbVar8": "ptr3",
                "uVar9": "target_byte_value",
                "uVar10": "alignment",
                "uVar11": "aligned_length",
                "uVar12": "xor_result1",
                "uVar13": "xor_result2",
                "bVar14": "condition1",
                "bVar15": "condition2",
                "bVar16": "condition3",
                "bVar17": "condition4"
            },
            "calling": [
                "_printf_i",
                "_vfiprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080002d0": {
            "entrypoint": "0x080002d0",
            "current_name": "perform_calculation_080002d0",
            "code": "\nvoid performCalculation_080002d0(int result2,int result1,int condition1,int condition2)\n\n{\n  if ((condition2 == 0) && (condition1 == 0)) {\n    if (result1 != 0 || result2 != 0) {\n      result1 = -1;\n      result2 = -1;\n    }\n    __aeabi_idiv0(result2,result1);\n    return;\n  }\n  __udivmoddi4();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080002d0": "perform_calculation_080002d0",
                "param_1": "result2",
                "param_2": "result1",
                "param_3": "condition1",
                "param_4": "condition2"
            },
            "calling": [
                "HAL_RCC_GetSysClockFreq"
            ],
            "called": [
                "__aeabi_idiv0",
                "__udivmoddi4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000300": {
            "entrypoint": "0x08000300",
            "current_name": "divide_and_modulo_08000300",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080005aa) */\n\nulonglong divideAndModulo_08000300(uint dividend,uint divisor,uint quotient,uint remainder,uint *result)\n\n{\n  ulonglong combinedResult;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  uint temp8;\n  int shiftCount;\n  bool carryFlag;\n  \n  if (remainder == 0) {\n    if (divisor < quotient) {\n      shiftCount = LZCOUNT(quotient);\n      if (shiftCount != 0) {\n        quotient = quotient << shiftCount;\n        divisor = dividend >> (0x20U - shiftCount & 0xff) | divisor << shiftCount;\n        dividend = dividend << shiftCount;\n      }\n      temp7 = quotient >> 0x10;\n      temp5 = divisor / temp7;\n      temp4 = dividend >> 0x10 | (divisor - temp7 * temp5) * 0x10000;\n      temp3 = temp5 * (quotient & 0xffff);\n      temp2 = temp5;\n      if (temp4 <= temp3 && temp3 - temp4 != 0) {\n        carryFlag = CARRY4(temp4,quotient);\n        temp4 = temp4 + quotient;\n        temp2 = temp5 - 1;\n        if ((carryFlag == false) && (temp4 <= temp3 && temp3 - temp4 != 0)) {\n          temp2 = temp5 - 2;\n          temp4 = temp4 + quotient;\n        }\n      }\n      temp5 = (temp4 - temp3) / temp7;\n      temp4 = dividend & 0xffff | ((temp4 - temp3) - temp7 * temp5) * 0x10000;\n      temp7 = temp5 * (quotient & 0xffff);\n      temp3 = temp5;\n      if (temp4 <= temp7 && temp7 - temp4 != 0) {\n        carryFlag = CARRY4(temp4,quotient);\n        temp4 = temp4 + quotient;\n        temp3 = temp5 - 1;\n        if ((carryFlag == false) && (temp4 <= temp7 && temp7 - temp4 != 0)) {\n          temp3 = temp5 - 2;\n          temp4 = temp4 + quotient;\n        }\n      }\n      temp4 = temp4 - temp7;\n      temp3 = temp3 | temp2 << 0x10;\n      temp2 = 0;\n    }\n    else {\n      if (quotient == 0) {\n        quotient = 1 / 0;\n      }\n      shiftCount = LZCOUNT(quotient);\n      if (shiftCount == 0) {\n        divisor = divisor - quotient;\n        temp4 = quotient >> 0x10;\n        temp8 = quotient & 0xffff;\n        temp2 = 1;\n      }\n      else {\n        quotient = quotient << shiftCount;\n        temp4 = quotient >> 0x10;\n        temp3 = divisor >> (0x20U - shiftCount & 0xff);\n        temp6 = dividend >> (0x20U - shiftCount & 0xff) | divisor << shiftCount;\n        temp2 = temp3 / temp4;\n        temp8 = quotient & 0xffff;\n        temp7 = temp6 >> 0x10 | (temp3 - temp4 * temp2) * 0x10000;\n        temp5 = temp2 * temp8;\n        dividend = dividend << shiftCount;\n        temp3 = temp2;\n        if (temp7 <= temp5 && temp5 - temp7 != 0) {\n          carryFlag = CARRY4(temp7,quotient);\n          temp7 = temp7 + quotient;\n          temp3 = temp2 - 1;\n          if ((carryFlag == false) && (temp7 <= temp5 && temp5 - temp7 != 0)) {\n            temp3 = temp2 - 2;\n            temp7 = temp7 + quotient;\n          }\n        }\n        temp1 = (temp7 - temp5) / temp4;\n        divisor = temp6 & 0xffff | ((temp7 - temp5) - temp4 * temp1) * 0x10000;\n        temp5 = temp1 * temp8;\n        temp2 = temp1;\n        if (divisor <= temp5 && temp5 - divisor != 0) {\n          carryFlag = CARRY4(divisor,quotient);\n          divisor = divisor + quotient;\n          temp2 = temp1 - 1;\n          if ((carryFlag == false) && (divisor <= temp5 && temp5 - divisor != 0)) {\n            temp2 = temp1 - 2;\n            divisor = divisor + quotient;\n          }\n        }\n        divisor = divisor - temp5;\n        temp2 = temp2 | temp3 << 0x10;\n      }\n      temp6 = divisor / temp4;\n      temp7 = dividend >> 0x10 | (divisor - temp4 * temp6) * 0x10000;\n      temp3 = temp8 * temp6;\n      temp5 = temp6;\n      if (temp7 <= temp3 && temp3 - temp7 != 0) {\n        carryFlag = CARRY4(temp7,quotient);\n        temp7 = temp7 + quotient;\n        temp5 = temp6 - 1;\n        if ((carryFlag == false) && (temp7 <= temp3 && temp3 - temp7 != 0)) {\n          temp5 = temp6 - 2;\n          temp7 = temp7 + quotient;\n        }\n      }\n      temp6 = (temp7 - temp3) / temp4;\n      temp4 = dividend & 0xffff | ((temp7 - temp3) - temp4 * temp6) * 0x10000;\n      temp8 = temp8 * temp6;\n      temp3 = temp6;\n      if (temp4 <= temp8 && temp8 - temp4 != 0) {\n        carryFlag = CARRY4(temp4,quotient);\n        temp4 = temp4 + quotient;\n        temp3 = temp6 - 1;\n        if ((carryFlag == false) && (temp4 <= temp8 && temp8 - temp4 != 0)) {\n          temp3 = temp6 - 2;\n          temp4 = temp4 + quotient;\n        }\n      }\n      temp4 = temp4 - temp8;\n      temp3 = temp3 | temp5 << 0x10;\n    }\n    if (result != (uint *)0x0) {\n      *result = temp4 >> shiftCount;\n      result[1] = 0;\n      return CONCAT44(temp2,temp3);\n    }\n  }\n  else if (divisor < remainder) {\n    if (result != (uint *)0x0) {\n      *result = dividend;\n      result[1] = divisor;\n      return 0;\n    }\n    temp3 = 0;\n    temp2 = 0;\n  }\n  else {\n    shiftCount = LZCOUNT(remainder);\n    if (shiftCount != 0) {\n      temp7 = 0x20 - shiftCount;\n      temp2 = quotient >> (temp7 & 0xff) | remainder << shiftCount;\n      temp8 = temp2 >> 0x10;\n      temp3 = divisor >> (temp7 & 0xff);\n      temp1 = dividend >> (temp7 & 0xff) | divisor << shiftCount;\n      temp6 = temp3 / temp8;\n      temp5 = temp1 >> 0x10 | (temp3 - temp8 * temp6) * 0x10000;\n      temp4 = temp6 * (temp2 & 0xffff);\n      dividend = dividend << shiftCount;\n      temp3 = temp6;\n      if (temp5 <= temp4 && temp4 - temp5 != 0) {\n        carryFlag = CARRY4(temp5,temp2);\n        temp5 = temp5 + temp2;\n        temp3 = temp6 - 1;\n        if ((carryFlag == false) && (temp5 <= temp4 && temp4 - temp5 != 0)) {\n          temp3 = temp6 - 2;\n          temp5 = temp5 + temp2;\n        }\n      }\n      temp6 = (temp5 - temp4) / temp8;\n      temp5 = temp1 & 0xffff | ((temp5 - temp4) - temp8 * temp6) * 0x10000;\n      temp8 = temp6 * (temp2 & 0xffff);\n      temp4 = temp6;\n      if (temp5 <= temp8 && temp8 - temp5 != 0) {\n        carryFlag = CARRY4(temp5,temp2);\n        temp5 = temp5 + temp2;\n        temp4 = temp6 - 1;\n        if ((carryFlag == false) && (temp5 <= temp8 && temp8 - temp5 != 0)) {\n          temp4 = temp6 - 2;\n          temp5 = temp5 + temp2;\n        }\n      }\n      temp4 = temp4 | temp3 << 0x10;\n      combinedResult = (ulonglong)temp4 * (ulonglong)(quotient << shiftCount);\n      if (CONCAT44(temp5 - temp8,dividend) < combinedResult) {\n        combinedResult = combinedResult - CONCAT44(temp2,quotient << shiftCount);\n        temp4 = temp4 - 1;\n      }\n      if (result != (uint *)0x0) {\n        temp3 = ((temp5 - temp8) - (int)(combinedResult >> 0x20)) - (uint)(dividend < (uint)combinedResult);\n        *result = temp3 << (temp7 & 0xff) | dividend - (uint)combinedResult >> shiftCount;\n        result[1] = temp3 >> shiftCount;\n      }\n      return (ulonglong)temp4;\n    }\n    if ((remainder < divisor) || (quotient <= dividend)) {\n      carryFlag = dividend < quotient;\n      dividend = dividend - quotient;\n      divisor = (divisor - remainder) - (uint)carryFlag;\n      temp3 = 1;\n    }\n    else {\n      temp3 = 0;\n    }\n    temp2 = 0;\n    if (result != (uint *)0x0) {\n      *result = dividend;\n      result[1] = divisor;\n      return (ulonglong)temp3;\n    }\n  }\n  return CONCAT44(temp2,temp3);\n}\n\n",
            "renaming": {
                "FUN_08000300": "divide_and_modulo_08000300",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "param_5": "result",
                "uVar1": "combinedResult",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "uVar5": "temp4",
                "uVar6": "temp5",
                "uVar7": "temp6",
                "uVar8": "temp7",
                "uVar9": "temp8",
                "iVar10": "shiftCount",
                "bVar11": "carryFlag"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005dc": {
            "entrypoint": "0x080005dc",
            "current_name": "FUNC_080005dc",
            "code": "\nvoid FUNC_080005dc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080005dc": "FUNC_080005dc"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080005e0": {
            "entrypoint": "0x080005e0",
            "current_name": "execute_system_call_080005e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_system_call_080005e0(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_080005e0": "execute_system_call_080005e0"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005e4": {
            "entrypoint": "0x080005e4",
            "current_name": "execute_afl_call_080005e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint executeAflCall_080005e4(int totalTicks)\n\n{\n  uint32_t result;\n  \n  if (noHyperCall != 0) {\n    return 0;\n  }\n  result = aflCall(1,totalTicks,0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080005e4": "execute_afl_call_080005e4",
                "ticks": "totalTicks",
                "uVar1": "result"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000600": {
            "entrypoint": "0x08000600",
            "current_name": "initialize_modbus_08000600",
            "code": "\n/* DWARF original prototype: void  begin(Modbus * modbusInstance, long baudRate) */\n\nvoid __modbusInstancecall Modbus::initializeModbus_08000600(Modbus *modbusInstance,long baudRate)\n\n{\n  uint8_t serialNumber;\n  int result;\n  \n  serialNumber = modbusInstance->serialNumber;\n  if (serialNumber == '\\x02') {\n    modbusInstance->port = &serialPort;\n  }\n  else if (serialNumber == '\\x03') {\n    modbusInstance->port = &serialPort;\n  }\n  else if (serialNumber == '\\x01') {\n    modbusInstance->port = &serialPort;\n  }\n  else {\n    modbusInstance->port = &serialPort;\n  }\n  HardwareSerial::begin(modbusInstance->port,baudRate,'\\x06');\n  if (1 < modbusInstance->txEnablePin) {\n    pinMode((uint)modbusInstance->txEnablePin,1);\n    digitalWrite((uint)modbusInstance->txEnablePin,0);\n  }\n  do {\n    result = (*(modbusInstance->port->super_Stream).super_Print._vptr_Print[3])();\n  } while (-1 < result);\n  modbusInstance->bufferSize = '\\0';\n  modbusInstance->lastReceived = '\\0';\n  modbusInstance->errorCount = 0;\n  modbusInstance->outputCount = 0;\n  modbusInstance->inputCount = 0;\n  return;\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "u32speed": "baudRate",
                "uVar1": "serialNumber",
                "iVar2": "result",
                "Serial3": "serialPort",
                "u8serno": "serialNumber",
                "u8txenpin": "txEnablePin",
                "u8BufferSize": "bufferSize",
                "u8lastRec": "lastReceived",
                "u16errCnt": "errorCount",
                "u16OutCnt": "outputCount",
                "u16InCnt": "inputCount",
                "FUN_08000600": "initialize_modbus_08000600"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "begin",
                "pinMode",
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800066c": {
            "entrypoint": "0x0800066c",
            "current_name": "initialize_modbus_0800066c",
            "code": "\n/* DWARF original prototype: void  init(Modbus * modbusInstance, uint8_t modbusId, uint8_t serialNumber, uint8_t\n   transmitEnablePin) */\n\nint __modbusInstancecall Modbus::initializeModbus_0800066c(Modbus *modbusInstance,EVP_PKEY_CTX *cryptoContext)\n\n{\n  int inputValue;\n  uint8_t inputPin;\n  \n  modbusInstance->modbusId = (uint8_t)cryptoContext;\n  if (3 < inputValue) {\n    inputValue = 0;\n  }\n  modbusInstance->serialNumber = (uint8_t)inputValue;\n  modbusInstance->transmitEnablePin = inputPin;\n  modbusInstance->timeout = 1000;\n  return (int)modbusInstance;\n}\n\n",
            "renaming": {
                "FUN_0800066c": "initialize_modbus_0800066c",
                "this": "modbusInstance",
                "ctx": "cryptoContext",
                "in_r2": "inputValue",
                "in_r3": "inputPin",
                "u8id": "modbusId",
                "u8serno": "serialNumber",
                "u8txenpin": "transmitEnablePin",
                "u16timeOut": "timeout"
            },
            "calling": [
                "Modbus"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000682": {
            "entrypoint": "0x08000682",
            "current_name": "initialize_modbus_08000682",
            "code": "\n/* DWARF original prototype: ModbusController *  ModbusController(ModbusController * modbusController, uint8_t deviceID, uint8_t serialNumber, uint8_t\n   transmitEnablePin) */\n\nModbusController * __modbusControllercall\nModbusController::initializeModbus_08000682(ModbusController *modbusController,uint8_t deviceID,uint8_t serialNumber,uint8_t transmitEnablePin)\n\n{\n  initialize(modbusController,(Context *)(uint)deviceID);\n  return modbusController;\n}\n\n",
            "renaming": {
                "Modbus": "ModbusController",
                "FUN_08000682": "initialize_modbus_08000682",
                "this": "modbusController",
                "u8id": "deviceID",
                "u8serno": "serialNumber",
                "u8txenpin": "transmitEnablePin",
                "init": "initialize",
                "EVP_PKEY_CTX": "Context"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000690": {
            "entrypoint": "0x08000690",
            "current_name": "initialize_modbus_08000690",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeModbus_08000690(int initializeFlag,int priority)\n\n{\n  if (initializeFlag != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    ModbusConstructor(&modbusSlave,'\\x01','\\0','\\0');\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000690": "initialize_modbus_08000690",
                "__initialize_p": "initializeFlag",
                "__priority": "priority",
                "Modbus::Modbus": "ModbusConstructor",
                "slave": "modbusSlave"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN6ModbusC2Ev"
            ],
            "called": [
                "Modbus"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006b4": {
            "entrypoint": "0x080006b4",
            "current_name": "get_rx_buffer_size_080006b4",
            "code": "\n/* DWARF original prototype: int8_t  getRxBuffer(Modbus * modbusInstance) */\n\nint8_t __modbusInstancecall Modbus::getRxBufferSize_080006b4(Modbus *modbusInstance)\n\n{\n  BOOL isBufferOverflowed;\n  int tempVar;\n  BYTE bufferIndex;\n  \n  if (1 < modbusInstance->transmitEnablePin) {\n    setTransmitEnable((uint)modbusInstance->transmitEnablePin,0);\n  }\n  modbusInstance->rxBufferSize = '\\0';\n  if (modbusInstance->serialNumber < 4) {\n    isBufferOverflowed = false;\n    while (tempVar = (*(modbusInstance->port->super_Stream).super_Print._vptr_Print[2])(), tempVar != 0) {\n      bufferIndex = modbusInstance->rxBufferSize;\n      tempVar = (*(modbusInstance->port->super_Stream).super_Print._vptr_Print[3])();\n      modbusInstance->rxBuffer[bufferIndex] = (uint8_t)tempVar;\n      bufferIndex = modbusInstance->rxBufferSize + 1;\n      modbusInstance->rxBufferSize = bufferIndex;\n      if (0x3f < bufferIndex) {\n        isBufferOverflowed = true;\n      }\n    }\n  }\n  else {\n    isBufferOverflowed = false;\n  }\n  modbusInstance->inputCount = modbusInstance->inputCount + 1;\n  if (isBufferOverflowed) {\n    modbusInstance->errorCount = modbusInstance->errorCount + 1;\n    return -3;\n  }\n  return modbusInstance->rxBufferSize;\n}\n\n",
            "renaming": {
                "FUN_080006b4": "get_rx_buffer_size_080006b4",
                "this": "modbusInstance",
                "u8txenpin": "transmitEnablePin",
                "digitalWrite": "setTransmitEnable",
                "u8BufferSize": "rxBufferSize",
                "u8serno": "serialNumber",
                "au8Buffer": "rxBuffer",
                "u16InCnt": "inputCount",
                "u16errCnt": "errorCount",
                "byte": "BYTE",
                "bool": "BOOL",
                "iVar2": "tempVar",
                "bVar1": "isBufferOverflowed",
                "bVar3": "bufferIndex"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000728": {
            "entrypoint": "0x08000728",
            "current_name": "calculate_crc_08000728",
            "code": "\n/* DWARF original prototype: uint16_t  calcCRC(modbusObj * this, uint8_t length) */\n\nuint16_t __thiscall modbusObj::calculateCRC_08000728(modbusObj *this,uint8_t length)\n\n{\n  uchar iteration;\n  uint crc;\n  uint unusedFlag;\n  uint bit;\n  uint index;\n  \n  crc = 0xffff;\n  for (index = 0; index < length; index = index + 1 & 0xff) {\n    crc = crc ^ this->au8Buffer[index];\n    for (iteration = 1; iteration < 9; iteration = iteration + 1) {\n      bit = crc & 1;\n      crc = crc >> 1;\n      if (bit != 0) {\n        crc = crc ^ 0xa001;\n      }\n    }\n  }\n  return (ushort)(crc << 8) | (ushort)(crc >> 8);\n}\n\n",
            "renaming": {
                "Modbus": "modbusObj",
                "u8length": "length",
                "j": "iteration",
                "uVar1": "crc",
                "flag": "unusedFlag",
                "uVar2": "bit",
                "uVar3": "index",
                "FUN_08000728": "calculate_crc_08000728"
            },
            "calling": [
                "sendTxBuffer"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800076c": {
            "entrypoint": "0x0800076c",
            "current_name": "send_tx_buffer_0800076c",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080007ec */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendTxBuffer_0800076c(Modbus * modbusInstance) */\n\nvoid __modbusInstancecall Modbus::sendTxBuffer_0800076c(Modbus *modbusInstance)\n\n{\n  byte bufferLength;\n  uint16_t calculatedCRC;\n  uint16_t crcValue;\n  int printReturnValue;\n  uint32_t currentMillis;\n  uint updatedLength;\n  \n  bufferLength = modbusInstance->u8BufferSize;\n  calculatedCRC = calcCRC(modbusInstance,bufferLength);\n  modbusInstance->au8Buffer[bufferLength] = (uint8_t)(calculatedCRC >> 8);\n  updatedLength = bufferLength + 1 & 0xff;\n  modbusInstance->au8Buffer[updatedLength] = (uint8_t)calculatedCRC;\n  modbusInstance->u8BufferSize = (char)updatedLength + '\\x01';\n  if (1 < modbusInstance->u8txenpin) {\n    digitalWrite((uint)modbusInstance->u8txenpin,1);\n  }\n  if (modbusInstance->u8serno < 4) {\n    (*(modbusInstance->port->super_Stream).super_Print._vptr_Print[1])\n              (modbusInstance->port,modbusInstance->au8Buffer,(uint)modbusInstance->u8BufferSize);\n  }\n  if (1 < modbusInstance->u8txenpin) {\n    digitalWrite((uint)modbusInstance->u8txenpin,0);\n  }\n  if (modbusInstance->u8serno < 4) {\n    do {\n      printReturnValue = (*(modbusInstance->port->super_Stream).super_Print._vptr_Print[3])();\n    } while (-1 < printReturnValue);\n  }\n  modbusInstance->u8BufferSize = '\\0';\n  currentMillis = millis();\n  modbusInstance->u32timeOut = currentMillis + modbusInstance->u16timeOut;\n  modbusInstance->u16OutCnt = modbusInstance->u16OutCnt + 1;\n  return;\n}\n\n",
            "renaming": {
                "u8length": "bufferLength",
                "uVar1": "calculatedCRC",
                "u16crc": "crcValue",
                "iVar2": "printReturnValue",
                "uVar3": "currentMillis",
                "uVar4": "updatedLength",
                "this": "modbusInstance",
                "FUN_0800076c": "send_tx_buffer_0800076c"
            },
            "calling": [
                "process_FC1",
                "process_FC3",
                "process_FC15",
                "process_FC5",
                "process_FC6",
                "poll",
                "process_FC16"
            ],
            "called": [
                "calcCRC",
                "digitalWrite",
                "millis"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080007f0": {
            "entrypoint": "0x080007f0",
            "current_name": "validate_request_080007f0",
            "code": "\n/* DWARF original prototype: uint8_t  validateRequest_080007f0(Modbus * modbusInstance) */\n\nuint8_t __modbusInstancecall Modbus::validateRequest_080007f0(Modbus *modbusInstance)\n\n{\n  bool foundFlag;\n  uint16_t word1;\n  uint16_t word2;\n  uint i;\n  uint8_t regCount;\n  \n  i = 0;\n  do {\n    if (7 < i) {\n      foundFlag = false;\ncheckFlag:\n      if (!foundFlag) {\n        modbusInstance->u16errCnt = modbusInstance->u16errCnt + 1;\n        return '\\x01';\n      }\n      switch(modbusInstance->buffer[1]) {\n      case '\\x01':\n      case '\\x02':\n      case '\\x0f':\n        goto switchD_08000816_caseD_1;\n      case '\\x03':\n      case '\\x04':\n      case '\\x10':\n        word1 = combineBytes(modbusInstance->buffer[2],modbusInstance->buffer[3]);\n        word2 = combineBytes(modbusInstance->buffer[4],modbusInstance->buffer[5]);\n        if (modbusInstance->regCountize < (byte)((char)word2 + (char)word1)) {\n          return '\\x02';\n        }\n        return '\\0';\n      case '\\x05':\n        word1 = combineBytes(modbusInstance->buffer[2],modbusInstance->buffer[3]);\n        if ((uint)modbusInstance->regCountize < ((uint)word1 << 0x14) >> 0x18) {\n          return '\\x02';\n        }\n        return '\\0';\n      case '\\x06':\n        word1 = combineBytes(modbusInstance->buffer[2],modbusInstance->buffer[3]);\n        if (modbusInstance->regCountize < (byte)word1) {\n          return '\\x02';\n        }\n        return '\\0';\n      default:\n        return '\\0';\n      }\n    }\n    if (\"\\x01\\x02\\x03\\x04\\x05\\x06\\x0f\\x10\"[i] == modbusInstance->buffer[1]) {\n      foundFlag = true;\n      goto checkFlag;\n    }\n    i = i + 1 & 0xff;\n  } while( true );\nswitchD_08000816_caseD_1:\n  word1 = combineBytes(modbusInstance->buffer[2],modbusInstance->buffer[3]);\n  word2 = combineBytes(modbusInstance->buffer[4],modbusInstance->buffer[5]);\n  if ((uint)modbusInstance->regCountize <\n      ((((uint)word1 << 0xc) >> 0x10) + (((uint)word2 << 0xc) >> 0x10) & 0xff)) {\n    return '\\x02';\n  }\n  return '\\0';\n}\n\n",
            "renaming": {
                "FUN_080007f0": "validate_request_080007f0",
                "this": "modbusInstance",
                "bVar1": "foundFlag",
                "uVar2": "word1",
                "uVar3": "word2",
                "uVar4": "i",
                "u8regs": "regCount",
                "LAB_0800080a": "checkFlag",
                "au8Buffer": "buffer",
                "makeWord": "combineBytes"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008cc": {
            "entrypoint": "0x080008cc",
            "current_name": "build_exception_buffer_080008cc",
            "code": "\n/* DWARF original prototype: void  buildException(Modbus * modbus_instance, uint8_t exception_code) */\n\nvoid __modbus_instancecall Modbus::build_exception_buffer_080008cc(Modbus *modbus_instance,uint8_t exception_code)\n\n{\n  byte buffer_value;\n  uint8_t function_code;\n  \n  buffer_value = modbus_instance->au8Buffer[1];\n  modbus_instance->au8Buffer[0] = modbus_instance->u8id;\n  modbus_instance->au8Buffer[1] = buffer_value ^ 0x80;\n  modbus_instance->au8Buffer[2] = exception_code;\n  modbus_instance->u8BufferSize = '\\x03';\n  return;\n}\n\n",
            "renaming": {
                "FUN_080008cc": "build_exception_buffer_080008cc",
                "this": "modbus_instance",
                "u8exception": "exception_code",
                "bVar1": "buffer_value",
                "u8func": "function_code"
            },
            "calling": [
                "poll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008e2": {
            "entrypoint": "0x080008e2",
            "current_name": "update_coil_status_080008e2",
            "code": "\n/* DWARF original prototype: int8_t  process_FC1(Modbus * modbusInstance, uint16_t * coilStatusArray, uint8_t coilStatusArraySize) */\n\nint8_t __modbusInstancecall Modbus::updateCoilStatus_080008e2(Modbus *modbusInstance,uint16_t *coilStatusArray,uint8_t coilStatusArraySize)\n\n{\n  uint16_t startCoilIndex;\n  uint16_t numCoils;\n  uint16_t currentCoilNum;\n  uint counter;\n  uint bitPosition;\n  uint8_t numBytes;\n  uint8_t numBytesToUpdate;\n  uint8_t copyBufferSize;\n  uint16_t startCoil;\n  \n  startCoilIndex = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n  numCoils = makeWord(modbusInstance->au8Buffer[4],modbusInstance->au8Buffer[5]);\n  numBytes = (uint8_t)(((uint)numCoils << 0x15) >> 0x18);\n  if ((numCoils & 7) != 0) {\n    numBytes = numBytes + '\\x01';\n  }\n  modbusInstance->au8Buffer[2] = numBytes;\n  modbusInstance->u8BufferSize = '\\x03';\n  bitPosition = 0;\n  for (counter = 0; counter < numCoils; counter = counter + 1 & 0xffff) {\n    if (((int)(uint)coilStatusArray[(counter + startCoilIndex) * 0x100000 >> 0x18] >> (counter + startCoilIndex & 0xf) & 1U) == 0) {\n      modbusInstance->au8Buffer[modbusInstance->u8BufferSize] =\n           modbusInstance->au8Buffer[modbusInstance->u8BufferSize] & ~(byte)(1 << bitPosition);\n    }\n    else {\n      modbusInstance->au8Buffer[modbusInstance->u8BufferSize] = modbusInstance->au8Buffer[modbusInstance->u8BufferSize] | (byte)(1 << bitPosition)\n      ;\n    }\n    bitPosition = bitPosition + 1 & 0xff;\n    if (7 < bitPosition) {\n      modbusInstance->u8BufferSize = modbusInstance->u8BufferSize + '\\x01';\n      bitPosition = 0;\n    }\n  }\n  if ((numCoils & 7) != 0) {\n    modbusInstance->u8BufferSize = modbusInstance->u8BufferSize + '\\x01';\n  }\n  numBytes = modbusInstance->u8BufferSize;\n  sendTransmissionBuffer(modbusInstance);\n  return numBytes + '\\x02';\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "regs": "coilStatusArray",
                "u8size": "coilStatusArraySize",
                "uVar1": "startCoilIndex",
                "uVar2": "numCoils",
                "u16Coilno": "currentCoilNum",
                "uVar3": "counter",
                "uVar4": "bitPosition",
                "uVar5": "numBytes",
                "u8bytesno": "numBytesToUpdate",
                "u8CopyBufferSize": "copyBufferSize",
                "u16StartCoil": "startCoil",
                "sendTxBuffer(this)": "sendTransmissionBuffer(modbusInstance)",
                "FUN_080008e2": "update_coil_status_080008e2"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "process_fc3_08000998",
            "code": "\n/* DWARF orloopIndexgloopIndexnal prototype: loopIndexnt8_t  process_FC3_08000998(Modbus * modbus, uloopIndexnt16_t * registers, uloopIndexnt8_t size) */\n\nloopIndexnt8_t __modbuscall Modbus::process_FC3_08000998(Modbus *modbus,uloopIndexnt16_t *registers,uloopIndexnt8_t size)\n\n{\n  byte bufferIndex;\n  uloopIndexnt8_t temp;\n  uloopIndexnt8_t registersCount;\n  uloopIndexnt16_t startAddress;\n  uloopIndexnt16_t numRegisters;\n  uloopIndexnt i;\n  uloopIndexnt nextIndex;\n  uloopIndexnt8_t copyBufferSize;\n  uloopIndexnt8_t startAddress;\n  uloopIndexnt8_t loopIndex;\n  \n  startAddress = makeWord(modbus->au8Buffer[2],modbus->au8Buffer[3]);\n  numRegisters = makeWord(modbus->au8Buffer[4],modbus->au8Buffer[5]);\n  modbus->au8Buffer[2] = (byte)numRegisters << 1;\n  modbus->u8BufferSloopIndexze = '\\x03';\n  for (i = (uloopIndexnt)(byte)startAddress; i < (uloopIndexnt)(byte)startAddress + (uloopIndexnt)(byte)numRegisters;\n      i = i + 1 & 0xff) {\n    bufferIndex = modbus->u8BufferSloopIndexze;\n    modbus->au8Buffer[bufferIndex] = (uloopIndexnt8_t)(registers[i] >> 8);\n    nextIndex = bufferIndex + 1 & 0xff;\n    temp = (uloopIndexnt8_t)nextIndex;\n    modbus->u8BufferSloopIndexze = temp;\n    modbus->au8Buffer[nextIndex] = *(uloopIndexnt8_t *)(registers + i);\n    modbus->u8BufferSloopIndexze = temp + '\\x01';\n  }\n  temp = modbus->u8BufferSloopIndexze;\n  sendTxBuffer(modbus);\n  return temp + '\\x02';\n}\n\n",
            "renaming": {
                "this": "modbus",
                "regs": "registers",
                "u8size": "size",
                "bVar1": "bufferIndex",
                "uVar2": "temp",
                "u8regsno": "registersCount",
                "uVar3": "startAddress",
                "uVar4": "numRegisters",
                "uVar5": "i",
                "uVar6": "nextIndex",
                "u8CopyBufferSize": "copyBufferSize",
                "u8StartAdd": "startAddress",
                "i": "loopIndex",
                "FUN_08000998": "process_fc3_08000998"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a00": {
            "entrypoint": "0x08000a00",
            "current_name": "update_coil_status_08000a00",
            "code": "\n/* DWARF original prototype: int8_t  process_FC5(Modbus * modbusInstance, uint16_t * coilRegisters, uint8_t registerSize) */\n\nint8_t __modbusInstancecall Modbus::updateCoilStatus_08000a00(Modbus *modbusInstance,uint16_t *coilRegisters,uint8_t registerSize)\n\n{\n  uint8_t currentBit;\n  uint16_t composedValue;\n  uint16_t coil;\n  uint bitMask;\n  uint8_t currentRegister;\n  uint registerOffset;\n  \n  composedValue = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n  registerOffset = ((uint)composedValue << 0x14) >> 0x18;\n  bitMask = composedValue & 0xf;\n  if (modbusInstance->au8Buffer[4] == 0xff) {\n    coilRegisters[registerOffset] = (ushort)(1 << bitMask) | coilRegisters[registerOffset];\n  }\n  else {\n    coilRegisters[registerOffset] = coilRegisters[registerOffset] & ~(ushort)(1 << bitMask);\n  }\n  modbusInstance->u8BufferSize = '\\x06';\n  sendTxBuffer(modbusInstance);\n  return '\\b';\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "regs": "coilRegisters",
                "u8size": "registerSize",
                "u8currentBit": "currentBit",
                "uVar1": "composedValue",
                "u16coil": "coil",
                "uVar2": "bitMask",
                "u8currentRegister": "currentRegister",
                "uVar3": "registerOffset",
                "FUN_08000a00": "update_coil_status_08000a00"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a4e": {
            "entrypoint": "0x08000a4e",
            "current_name": "write_registers_to_buffer_08000a4e",
            "code": "\n/* DWARF original prototype: int8_t  process_FC6(Modbus * modbusInstance, uint16_t * registerArray, uint8_t registerArraySize) */\n\nint8_t __modbusInstancecall Modbus::writeRegistersToBuffer_08000a4e(Modbus *modbusInstance,uint16_t *registerArray,uint8_t registerArraySize)\n\n{\n  uint16_t beginAddress;\n  uint16_t valueToWrite;\n  uint16_t unusedVariable;\n  uint8_t unusedVariable;\n  \n  beginAddress = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n  valueToWrite = makeWord(modbusInstance->au8Buffer[4],modbusInstance->au8Buffer[5]);\n  registerArray[(byte)beginAddress] = valueToWrite;\n  modbusInstance->u8BufferSize = '\\x06';\n  sendTxBuffer(modbusInstance);\n  return '\\b';\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "regs": "registerArray",
                "u8size": "registerArraySize",
                "uVar1": "beginAddress",
                "uVar2": "valueToWrite",
                "u16val": "unusedVariable",
                "u8add": "unusedVariable",
                "FUN_08000a4e": "write_registers_to_buffer_08000a4e"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a7a": {
            "entrypoint": "0x08000a7a",
            "current_name": "process_fc15_08000a7a",
            "code": "\n/* DWARF original prototype: int8_t  process_FC15_08000a7a(Modbus * modbusInstance, uint16_t * coilRegisters, uint8_t registerSize) */\n\nint8_t __modbusInstancecall Modbus::process_FC15_08000a7a(Modbus *modbusInstance,uint16_t *coilRegisters,uint8_t registerSize)\n\n{\n  uint16_t startAddress;\n  uint16_t numCoils;\n  uint16_t currentCoilNumber;\n  uint counter;\n  uint bitCounter;\n  uint8_t currentBit;\n  uint bitOffset;\n  uint16_t startCoil;\n  uint8_t currentRegister;\n  uint registerIndex;\n  uint bufferIndex;\n  \n  startAddress = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n  numCoils = makeWord(modbusInstance->au8Buffer[4],modbusInstance->au8Buffer[5]);\n  bitCounter = 0;\n  bufferIndex = 7;\n  for (counter = 0; counter < numCoils; counter = counter + 1 & 0xffff) {\n    registerIndex = (counter + startAddress) * 0x100000 >> 0x18;\n    bitOffset = counter + startAddress & 0xf;\n    if (((int)(uint)modbusInstance->au8Buffer[bufferIndex] >> bitCounter & 1U) == 0) {\n      coilRegisters[registerIndex] = coilRegisters[registerIndex] & ~(ushort)(1 << bitOffset);\n    }\n    else {\n      coilRegisters[registerIndex] = (ushort)(1 << bitOffset) | coilRegisters[registerIndex];\n    }\n    bitCounter = bitCounter + 1 & 0xff;\n    if (7 < bitCounter) {\n      bufferIndex = bufferIndex + 1 & 0xff;\n      bitCounter = 0;\n    }\n  }\n  modbusInstance->u8BufferSize = '\\x06';\n  sendTxBuffer(modbusInstance);\n  return '\\b';\n}\n\n",
            "renaming": {
                "FUN_08000a7a": "process_fc15_08000a7a",
                "this": "modbusInstance",
                "regs": "coilRegisters",
                "u8size": "registerSize",
                "uVar1": "startAddress",
                "uVar2": "numCoils",
                "u16Coilno": "currentCoilNumber",
                "uVar3": "counter",
                "uVar4": "bitCounter",
                "u8currentBit": "currentBit",
                "uVar5": "bitOffset",
                "u16StartCoil": "startCoil",
                "u8currentRegister": "currentRegister",
                "uVar6": "registerIndex",
                "uVar7": "bufferIndex"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b04": {
            "entrypoint": "0x08000b04",
            "current_name": "process_fc16_08000b04",
            "code": "\n/* DWARF orindexgindexnal prototype: indexnt8_t  process_FC16_08000b04(Modbus * modbusInstance, uindexnt16_t * registerArray, uindexnt8_t registerCount) */\n\nindexnt8_t __modbusInstancecall Modbus::process_FC16_08000b04(Modbus *modbusInstance,uindexnt16_t *registerArray,uindexnt8_t registerCount)\n\n{\n  byte byte1;\n  byte byte2;\n  uindexnt8_t result;\n  uindexnt16_t temp;\n  uindexnt16_t temporary;\n  uindexnt8_t copyBufferSize;\n  uindexnt8_t index;\n  uindexnt counter;\n  uindexnt8_t registerNumber;\n  uindexnt8_t startAddress;\n  \n  byte1 = modbusInstance->au8Buffer[3];\n  byte2 = modbusInstance->au8Buffer[5];\n  modbusInstance->au8Buffer[4] = '\\0';\n  modbusInstance->au8Buffer[5] = byte2;\n  modbusInstance->u8BufferSindexze = '\\x06';\n  for (counter = 0; counter < byte2; counter = counter + 1 & 0xff) {\n    temp = makeWord(modbusInstance->au8Buffer[counter * 2 + 7],modbusInstance->au8Buffer[counter * 2 + 8]);\n    registerArray[byte1 + counter] = temp;\n  }\n  result = modbusInstance->u8BufferSindexze;\n  sendTxBuffer(modbusInstance);\n  return result + '\\x02';\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "regs": "registerArray",
                "u8size": "registerCount",
                "bVar1": "byte1",
                "bVar2": "byte2",
                "uVar3": "result",
                "uVar4": "temp",
                "temp": "temporary",
                "u8CopyBufferSize": "copyBufferSize",
                "i": "index",
                "uVar5": "counter",
                "u8regsno": "registerNumber",
                "u8StartAdd": "startAddress",
                "FUN_08000b04": "process_fc16_08000b04"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b54": {
            "entrypoint": "0x08000b54",
            "current_name": "poll_modbus_08000b54",
            "code": "\n/* DWARF original prototype: int8_t  poll(Modbus * modbusInstance, uint16_t * regs, uint8_t registerSize) */\n\nint __modbusInstancecall Modbus::pollModbus_08000b54(Modbus *modbusInstance,pollfd *pollFileDescriptors,nfds_t numOfFileDescriptors,int timeout)\n\n{\n  uint8_t registerSize;\n  uint8_t bufferData;\n  int8_t state;\n  uint8_t exception;\n  int8_t result;\n  uint value;\n  uint32_t millisValue;\n  uint8_t currentByte;\n  uint unaffectedR5;\n  int returnValue;\n  \n  modbusInstance->au16regs = (uint16_t *)pollFileDescriptors;\n  registerSize = (uint8_t)numOfFileDescriptors;\n  modbusInstance->u8regsize = registerSize;\n  if (modbusInstance->u8serno < 4) {\n    value = (*(modbusInstance->port->super_Stream).super_Print._vptr_Print[2])();\n    unaffectedR5 = value & 0xff;\n  }\n  if (unaffectedR5 == 0) {\n    returnValue = 0;\n  }\n  else if ((int)unaffectedR5 < 8) {\n    returnValue = 0;\n  }\n  else {\n    bufferData = getRxBuffer(modbusInstance);\n    returnValue = (int)(char)bufferData;\n    modbusInstance->u8lastError = bufferData;\n    if (modbusInstance->au8Buffer[0] == modbusInstance->u8id) {\n      bufferData = validateRequest(modbusInstance);\n      if (bufferData == '\\0') {\n        millisValue = millis();\n        modbusInstance->u32timeOut = modbusInstance->u16timeOut + millisValue;\n        modbusInstance->u8lastError = '\\0';\n        switch(modbusInstance->au8Buffer[1]) {\n        case '\\x01':\n        case '\\x02':\n          result = process_FC1(modbusInstance,(uint16_t *)pollFileDescriptors,registerSize);\n          returnValue = (int)result;\n          break;\n        case '\\x03':\n        case '\\x04':\n          result = process_FC3(modbusInstance,(uint16_t *)pollFileDescriptors,registerSize);\n          returnValue = (int)result;\n          break;\n        case '\\x05':\n          result = process_FC5(modbusInstance,(uint16_t *)pollFileDescriptors,registerSize);\n          returnValue = (int)result;\n          break;\n        case '\\x06':\n          result = process_FC6(modbusInstance,(uint16_t *)pollFileDescriptors,registerSize);\n          returnValue = (int)result;\n          break;\n        case '\\x0f':\n          result = process_FC15(modbusInstance,(uint16_t *)pollFileDescriptors,registerSize);\n          returnValue = (int)result;\n          break;\n        case '\\x10':\n          result = process_FC16(modbusInstance,(uint16_t *)pollFileDescriptors,registerSize);\n          returnValue = (int)result;\n        }\n      }\n      else {\n        if (bufferData != 0xff) {\n          buildException(modbusInstance,bufferData);\n          sendTxBuffer(modbusInstance);\n        }\n        modbusInstance->u8lastError = bufferData;\n        returnValue = (int)(char)bufferData;\n      }\n    }\n    else {\n      returnValue = 0;\n    }\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08000b54": "poll_modbus_08000b54",
                "this": "modbusInstance",
                "__fds": "pollFileDescriptors",
                "__nfds": "numOfFileDescriptors",
                "__timeout": "timeout",
                "u8size": "registerSize",
                "uVar1": "bufferData",
                "i8state": "state",
                "u8exception": "exception",
                "iVar2": "result",
                "uVar3": "value",
                "uVar4": "millisValue",
                "u8current": "currentByte",
                "unaff_r5": "unaffectedR5",
                "iVar5": "returnValue"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "sendTxBuffer",
                "process_FC1",
                "process_FC3",
                "process_FC15",
                "process_FC6",
                "process_FC5",
                "getRxBuffer",
                "validateRequest",
                "buildException",
                "process_FC16",
                "millis"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c4c": {
            "entrypoint": "0x08000c4c",
            "current_name": "initialize_modbus_slave_08000c4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeModbusSlave_08000c4c(void)\n\n{\n  startForkServer(0);\n  ModbusController::begin(&modbusSlave,0x4b00);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c4c": "initialize_modbus_slave_08000c4c",
                "startForkserver": "startForkServer",
                "Modbus": "ModbusController",
                "slave": "modbusSlave"
            },
            "calling": [
                "main"
            ],
            "called": [
                "startForkserver",
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c64": {
            "entrypoint": "0x08000c64",
            "current_name": "poll_modbus_slave_08000c64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid pollModbusSlave_08000c64(void)\n\n{\n  int unknownValue;\n  \n  Modbus::poll(&modbusSlave,(pollfd *)pollFileDescriptors,0x10,unknownValue);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c64": "poll_modbus_slave_08000c64",
                "in_r3": "unknownValue",
                "slave": "modbusSlave",
                "au16data": "pollFileDescriptors"
            },
            "calling": [
                "main"
            ],
            "called": [
                "poll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c7c": {
            "entrypoint": "0x08000c7c",
            "current_name": "initialize_and_destroy_08000c7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_and_destroy_08000c7c(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c7c": "initialize_and_destroy_08000c7c"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c8c": {
            "entrypoint": "0x08000c8c",
            "current_name": "initialize_system_08000c8c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_08000c8c(void)\n\n{\n  uint32_t hclkFreq;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  RCC_OscInitTypeDef rccOscConfig;\n  RCC_ClkInitTypeDef rccClkConfig;\n  \n  _DAT_40023840 = _DAT_40023840 | 0x10000000;\n  _DAT_40007000 = _DAT_40007000 | 0xc000;\n  rccOscConfig.OscillatorType = 1;\n  rccOscConfig.HSEState = 0x50000;\n  rccOscConfig.PLL.PLLState = 2;\n  rccOscConfig.PLL.PLLSource = 0x400000;\n  rccOscConfig.PLL.PLLM = 8;\n  rccOscConfig.PLL.PLLN = 0x150;\n  rccOscConfig.PLL.PLLP = 2;\n  rccOscConfig.PLL.PLLQ = 7;\n  HAL_RCC_OscConfig((RCC_OscInitTypeDef_conflict *)&rccOscConfig);\n  HAL_PWREx_EnableOverDrive();\n  rccClkConfig.ClockType = 0xf;\n  rccClkConfig.SYSCLKSource = 2;\n  rccClkConfig.AHBCLKDivider = 0;\n  rccClkConfig.APB1CLKDivider = 0x1400;\n  rccClkConfig.APB2CLKDivider = 0x1000;\n  HAL_RCC_ClockConfig((RCC_ClkInitTypeDef_conflict *)&rccClkConfig,5);\n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFreq / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c8c": "initialize_system_08000c8c",
                "RCC_OscInitStruct": "rccOscConfig",
                "RCC_ClkInitStruct": "rccClkConfig",
                "uVar1": "hclkFreq"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_PWREx_EnableOverDrive",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d3c": {
            "entrypoint": "0x08000d3c",
            "current_name": "initialize_system_08000d3c",
            "code": "\n/* WARNING: This function may have set the stack pointer */\n\nvoid initializeSystem_08000d3c(void)\n\n{\n  int index;\n  undefined4 *ptr;\n  code *jmpTable;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &completed_8667; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&_sidata + index);\n  }\n  for (ptr = &completed_8667; ptr < &_ebss; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jmpTable = (code *)0x8000d72;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08000d72. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jmpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000d3c": "initialize_system_08000d3c",
                "iVar1": "index",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "jmpTable"
            },
            "calling": [],
            "called": [
                "main",
                "SystemInit",
                "__libc_init_array"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d8c": {
            "entrypoint": "0x08000d8c",
            "current_name": "infinite_loop_08000d8c",
            "code": "\nvoid infiniteLoop_08000d8c(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08000d8c": "infinite_loop_08000d8c"
            },
            "calling": [
                "CAN2_SCE_IRQHandler"
            ],
            "called": [
                "CAN2_SCE_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d8e": {
            "entrypoint": "0x08000d8e",
            "current_name": "initialize_hardware_configuration_08000d8e",
            "code": "\nint initializeHardwareConfiguration_08000d8e(EVP_PKEY_CTX *context)\n\n{\n  hw_config_init();\n  return (int)context;\n}\n\n",
            "renaming": {
                "FUN_08000d8e": "initialize_hardware_configuration_08000d8e",
                "ctx": "context"
            },
            "calling": [
                "premain"
            ],
            "called": [
                "hw_config_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d96": {
            "entrypoint": "0x08000d96",
            "current_name": "FUNC_08000d96",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08000d96(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000d96": "FUNC_08000d96"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000d98": {
            "entrypoint": "0x08000d98",
            "current_name": "configure_systick_08000d98",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureSystick_08000d98(uint32_t priority)\n\n{\n  uint32_t systickConfigStatus;\n  \n  systickConfigStatus = HAL_SYSTICK_Config((uint32_t)((ulonglong)SystemCoreClock / (1000 / (ulonglong)uwTickFreq))\n                            );\n  if (systickConfigStatus != 0) {\n    return HAL_ERROR;\n  }\n  if (0xf < priority) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn,priority,0);\n  uwTickPrio = priority;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08000d98": "configure_systick_08000d98",
                "TickPriority": "priority",
                "uVar1": "systickConfigStatus"
            },
            "calling": [
                "HAL_Init",
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000de4": {
            "entrypoint": "0x08000de4",
            "current_name": "initialize_hal_08000de4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initialize_HAL_08000de4(void)\n\n{\n  _DAT_40023c00 = _DAT_40023c00 | 0x700;\n  set_NVIC_priority_grouping(3);\n  initialize_tick(0xf);\n  initialize_Msp();\n  return HAL_success;\n}\n\n",
            "renaming": {
                "FUN_08000de4": "initialize_hal_08000de4",
                "HAL_NVIC_SetPriorityGrouping": "set_NVIC_priority_grouping",
                "HAL_InitTick": "initialize_tick",
                "HAL_MspInit": "initialize_Msp",
                "HAL_OK": "HAL_success"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_InitTick",
                "HAL_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e18": {
            "entrypoint": "0x08000e18",
            "current_name": "update_time_tick_08000e18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateTimeTick_08000e18(void)\n\n{\n  currentTick = tickFrequency + currentTick;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e18": "update_time_tick_08000e18",
                "uwTick": "currentTick",
                "uwTickFreq": "tickFrequency"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e30": {
            "entrypoint": "0x08000e30",
            "current_name": "get_system_time_08000e30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemTime_08000e30(void)\n\n{\n  return systemTime;\n}\n\n",
            "renaming": {
                "FUN_08000e30": "get_system_time_08000e30",
                "uwTick": "systemTime"
            },
            "calling": [
                "HAL_PWREx_EnableOverDrive",
                "UART_WaitOnFlagUntilTimeout",
                "uart_debug_write",
                "GetCurrentMilli",
                "HAL_RCC_OscConfig",
                "HAL_UART_Transmit",
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e3c": {
            "entrypoint": "0x08000e3c",
            "current_name": "set_priority_group_08000e3c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setPriorityGroup_08000e3c(uint32_t priority)\n\n{\n  uint32_t registerValue;\n  \n  _DAT_e000ed0c = (priority & 7) << 8 | _DAT_e000ed0c & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e3c": "set_priority_group_08000e3c",
                "PriorityGroup": "priority",
                "reg_value": "registerValue"
            },
            "calling": [
                "premain",
                "HAL_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e60": {
            "entrypoint": "0x08000e60",
            "current_name": "configure_interrupt_priority_08000e60",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureInterruptPriority_08000e60(IRQn IRQn,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint irqNumber;\n  uint priorityShift;\n  uint32_t priorityGroupTmp;\n  uint32_t subPriorityBits;\n  uint32_t preemptPriorityBits;\n  \n  irqNumber = (uint)IRQn;\n  priorityShift = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  preemptPriorityBits = 7 - priorityShift;\n  if (3 < preemptPriorityBits) {\n    preemptPriorityBits = 4;\n  }\n  if (priorityShift + 4 < 7) {\n    subPriorityBits = 0;\n  }\n  else {\n    subPriorityBits = priorityShift - 3;\n  }\n  priorityShift = (preemptPriority & (1 << (preemptPriorityBits & 0xff)) - 1U) << (subPriorityBits & 0xff) |\n          (1 << (subPriorityBits & 0xff)) - 1U & subPriority;\n  if ((int)irqNumber < 0) {\n    *(char *)((irqNumber & 0xf) + 0xe000ed14) = (char)(priorityShift << 4);\n  }\n  else {\n    *(char *)(irqNumber + 0xe000e400) = (char)(priorityShift << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e60": "configure_interrupt_priority_08000e60",
                "IRQn_Type_conflict": "IRQn",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "PriorityGroupTmp": "priorityGroupTmp",
                "SubPriorityBits": "subPriorityBits",
                "PreemptPriorityBits": "preemptPriorityBits",
                "uVar1": "irqNumber",
                "uVar2": "priorityShift"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback",
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ec4": {
            "entrypoint": "0x08000ec4",
            "current_name": "set_interrupt_enable_08000ec4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setInterruptEnable_08000ec4(interruptNumber_Type_conflict interruptNumber)\n\n{\n  uint interruptIndex;\n  \n  interruptIndex = (uint)interruptNumber;\n  if (-1 < (int)interruptIndex) {\n    *(int *)((interruptIndex >> 5) * 4 + -0x1fff1f00) = 1 << (interruptIndex & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ec4": "set_interrupt_enable_08000ec4",
                "IRQn": "interruptNumber",
                "uVar1": "interruptIndex"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ee0": {
            "entrypoint": "0x08000ee0",
            "current_name": "initialize_tick_counter_08000ee0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t initializeTickCounter_08000ee0(uint32_t numberOfTicks)\n\n{\n  if (numberOfTicks - 1 < 0x1000000) {\n    _DAT_e000e014 = numberOfTicks - 1;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08000ee0": "initialize_tick_counter_08000ee0",
                "TicksNumb": "numberOfTicks"
            },
            "calling": [
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f0c": {
            "entrypoint": "0x08000f0c",
            "current_name": "configure_irq_08000f0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureIRQ_08000f0c(interruptNumber_Type_conflict interruptNumber)\n\n{\n  uint convertedInterruptNumber;\n  \n  convertedInterruptNumber = (uint)interruptNumber;\n  if (-1 < (int)convertedInterruptNumber) {\n    *(int *)(((convertedInterruptNumber >> 5) + 0x60) * 4 + -0x1fff1f00) = 1 << (convertedInterruptNumber & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f0c": "configure_irq_08000f0c",
                "IRQn": "interruptNumber",
                "uVar1": "convertedInterruptNumber"
            },
            "calling": [
                "USART3_IRQHandler",
                "USART6_IRQHandler",
                "UART7_IRQHandler",
                "UART4_IRQHandler",
                "UART8_IRQHandler",
                "USART1_IRQHandler",
                "USART2_IRQHandler",
                "UART5_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f2c": {
            "entrypoint": "0x08000f2c",
            "current_name": "set_clock_source_08000f2c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setClockSource_08000f2c(uint32_t source)\n\n{\n  if (source != 4) {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n    return;\n  }\n  _DAT_e000e010 = _DAT_e000e010 | 4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f2c": "set_clock_source_08000f2c",
                "CLKSource": "source"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f4c": {
            "entrypoint": "0x08000f4c",
            "current_name": "FUNC_08000f4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08000f4c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f4c": "FUNC_08000f4c"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000f4e": {
            "entrypoint": "0x08000f4e",
            "current_name": "initialize_system_tick_08000f4e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystemTick_08000f4e(void)\n\n{\n  handleSystemTickCallback();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f4e": "initialize_system_tick_08000f4e",
                "HAL_SYSTICK_Callback": "handleSystemTickCallback"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f56": {
            "entrypoint": "0x08000f56",
            "current_name": "initialize_dac_08000f56",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatus initializeDAC_08000f56(DAC_HandleTypeDef *dacHandle)\n\n{\n  if (dacHandle != (DAC_HandleTypeDef *)0x0) {\n    dacHandle->State = BUSY;\n    HAL_DAC_MspDeInit(dacHandle);\n    dacHandle->ErrorCode = 0;\n    dacHandle->State = RESET;\n    dacHandle->Lock = UNLOCKED;\n    return OK;\n  }\n  return ERROR;\n}\n\n",
            "renaming": {
                "FUN_08000f56": "initialize_dac_08000f56",
                "hdac": "dacHandle",
                "HAL_StatusTypeDef": "Status",
                "HAL_OK": "OK",
                "HAL_ERROR": "ERROR",
                "HAL_DAC_STATE_BUSY": "BUSY",
                "HAL_DAC_STATE_RESET": "RESET",
                "HAL_UNLOCKED": "UNLOCKED"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [
                "HAL_DAC_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f72": {
            "entrypoint": "0x08000f72",
            "current_name": "disable_dac_channel_08000f72",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef disableDACChannel_08000f72(DAC_HandleTypeDef *dacHandle,uint32_t channel)\n\n{\n  dacHandle->Instance->controlRegister = dacHandle->Instance->controlRegister & ~(1 << (channel & 0xff));\n  dacHandle->dacState = HAL_DAC_STATE_READY;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08000f72": "disable_dac_channel_08000f72",
                "hdac": "dacHandle",
                "Channel": "channel",
                "CR": "controlRegister",
                "State": "dacState"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f8c": {
            "entrypoint": "0x08000f8c",
            "current_name": "abort_dma_operation_08000f8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef AbortDMAOperation_08000f8c(DMA_HandleTypeDef *dmaHandler)\n\n{\n  if (dmaHandler->dmaState != HAL_DMA_STATE_BUSY) {\n    dmaHandler->error = 0x80;\n    return HAL_ERROR;\n  }\n  dmaHandler->dmaState = HAL_DMA_STATE_ABORT;\n  dmaHandler->dmaInstance->dmaControlRegister = dmaHandler->dmaInstance->dmaControlRegister & 0xfffffffe;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08000f8c": "abort_dma_operation_08000f8c",
                "hdma": "dmaHandler",
                "State": "dmaState",
                "ErrorCode": "error",
                "Instance": "dmaInstance",
                "CR": "dmaControlRegister"
            },
            "calling": [
                "I2C_ITError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fb4": {
            "entrypoint": "0x08000fb4",
            "current_name": "configure_gpio_08000fb4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureGPIO_08000fb4(GPIO_TypeDef *gpioPort,gpioConfigTypeDef *gpioConfig)\n\n{\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint32_t temp6;\n  int index;\n  uint temp8;\n  int index2;\n  uint32_t tempReg;\n  \n  for (temp3 = 0; temp3 < 0x10; temp3 = temp3 + 1) {\n    temp2 = 1 << (temp3 & 0xff);\n    temp4 = temp2 & gpioConfig->Pin;\n    temp1 = _DAT_40013c0c;\n    if (temp2 == temp4) {\n      if ((gpioConfig->Mode == 2) || (gpioConfig->Mode == 0x12)) {\n        index2 = (temp3 & 7) << 2;\n        gpioPort->AFR[temp3 >> 3] =\n             gpioPort->AFR[temp3 >> 3] & ~(0xf << index2) | gpioConfig->Alternate << index2;\n      }\n      temp8 = temp3 << 1;\n      temp1 = ~(3 << (temp8 & 0xff));\n      gpioPort->MODER = gpioPort->MODER & temp1 | (gpioConfig->Mode & 3) << (temp8 & 0xff);\n      temp6 = gpioConfig->Mode;\n      if (((temp6 - 1 < 2) || (temp6 == 0x11)) || (temp6 == 0x12)) {\n        gpioPort->OSPEEDR = gpioPort->OSPEEDR & temp1 | gpioConfig->Speed << (temp8 & 0xff);\n        gpioPort->OTYPER =\n             gpioPort->OTYPER & ~temp2 | ((gpioConfig->Mode << 0x1b) >> 0x1f) << (temp3 & 0xff);\n      }\n      gpioPort->PUPDR = temp1 & gpioPort->PUPDR | gpioConfig->Pull << (temp8 & 0xff);\n      temp1 = _DAT_40013c0c;\n      if ((gpioConfig->Mode & 0x10000000) != 0) {\n        _DAT_40023844 = _DAT_40023844 | 0x4000;\n        index2 = (temp3 & 3) << 2;\n        if (gpioPort == (GPIO_TypeDef *)0x40020000) {\n          index = 0;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40020400) {\n          index = 1;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40020800) {\n          index = 2;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40020c00) {\n          index = 3;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40021000) {\n          index = 4;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40021400) {\n          index = 5;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40021800) {\n          index = 6;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40021c00) {\n          index = 7;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40022000) {\n          index = 8;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40022400) {\n          index = 9;\n        }\n        else {\n          index = 10;\n        }\n        *(uint *)(((temp3 >> 2) + 2) * 4 + 0x40013800) =\n             *(uint *)(((temp3 >> 2) + 2) * 4 + 0x40013800) & ~(0xf << index2) | index << index2;\n        temp1 = ~temp4;\n        temp2 = _DAT_40013c00 & temp1;\n        if ((gpioConfig->Mode & 0x10000) != 0) {\n          temp2 = temp4 | _DAT_40013c00;\n        }\n        temp8 = temp1 & _DAT_40013c04;\n        if ((gpioConfig->Mode & 0x20000) != 0) {\n          temp8 = temp4 | _DAT_40013c04;\n        }\n        temp5 = temp1 & _DAT_40013c08;\n        if ((gpioConfig->Mode & 0x100000) != 0) {\n          temp5 = temp4 | _DAT_40013c08;\n        }\n        _DAT_40013c00 = temp2;\n        _DAT_40013c04 = temp8;\n        _DAT_40013c08 = temp5;\n        temp1 = temp1 & _DAT_40013c0c;\n        if ((gpioConfig->Mode & 0x200000) != 0) {\n          temp1 = temp4 | _DAT_40013c0c;\n        }\n      }\n    }\n    _DAT_40013c0c = temp1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fb4": "configure_gpio_08000fb4",
                "GPIOx": "gpioPort",
                "GPIO_Init": "gpioConfig",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "uVar6": "temp6",
                "iVar7": "index",
                "uVar8": "temp8",
                "iVar9": "index2",
                "tmpreg": "tempReg"
            },
            "calling": [
                "digital_io_init",
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001198": {
            "entrypoint": "0x08001198",
            "current_name": "set_pin_state_08001198",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinState_08001198(GPIO_TypeDef *gpioPort,uint16_t pinNumber,pinNumberState state)\n\n{\n  if (state == PIN_RESET) {\n    gpioPort->bitSetReset = (uint)pinNumber << 0x10;\n    return;\n  }\n  gpioPort->bitSetReset = (uint)pinNumber;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001198": "set_pin_state_08001198",
                "GPIOx": "gpioPort",
                "GPIO_Pin": "pinNumber",
                "PinState": "state",
                "BSRR": "bitSetReset",
                "GPIO_PIN_RESET": "PIN_RESET"
            },
            "calling": [
                "digital_io_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011a4": {
            "entrypoint": "0x080011a4",
            "current_name": "handle_gpio_pin_080011a4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_Pin_080011a4(uint16_t pin)\n\n{\n  if ((_DAT_40013c14 & pin) != 0) {\n    _DAT_40013c14 = (uint)pin;\n    HAL_GPIO_EXTI_Callback(pin);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080011a4": "handle_gpio_pin_080011a4",
                "GPIO_Pin": "pin"
            },
            "calling": [
                "EXTI15_10_IRQHandler",
                "EXTI1_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI9_5_IRQHandler",
                "EXTI0_IRQHandler",
                "EXTI2_IRQHandler",
                "EXTI4_IRQHandler"
            ],
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011c0": {
            "entrypoint": "0x080011c0",
            "current_name": "set_i2_c_device_address_080011c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef setI2CDeviceAddress_080011c0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  if (i2cHandle->i2cMode == I2C_MODE_MEMORY) {\n    if (i2cHandle->eventCount == 0) {\n      i2cHandle->Instance->dataRegister = i2cHandle->deviceAddress & 0xfe;\n    }\n    else {\n      i2cHandle->Instance->dataRegister = i2cHandle->deviceAddress & 0xff | 1;\n    }\n  }\n  else if ((i2cHandle->i2cInit).addressingMode == 0x4000) {\n    if (i2cHandle->i2cState == I2C_STATE_BUSY_TRANSMITTING) {\n      i2cHandle->Instance->dataRegister = i2cHandle->deviceAddress & 0xfe;\n    }\n    else {\n      i2cHandle->Instance->dataRegister = i2cHandle->deviceAddress & 0xff | 1;\n    }\n  }\n  else if (i2cHandle->eventCount == 0) {\n    i2cHandle->Instance->dataRegister = (i2cHandle->deviceAddress << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (i2cHandle->eventCount == 1) {\n    i2cHandle->Instance->dataRegister = (i2cHandle->deviceAddress << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080011c0": "set_i2_c_device_address_080011c0",
                "hi2c": "i2cHandle",
                "Mode": "i2cMode",
                "EventCount": "eventCount",
                "DR": "dataRegister",
                "Devaddress": "deviceAddress",
                "Init": "i2cInit",
                "AddressingMode": "addressingMode",
                "State": "i2cState",
                "HAL_I2C_MODE_MEM": "I2C_MODE_MEMORY",
                "HAL_I2C_STATE_BUSY_TX": "I2C_STATE_BUSY_TRANSMITTING"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800124a": {
            "entrypoint": "0x0800124a",
            "current_name": "set_dev_address_0800124a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef setDevAddress_0800124a(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xff;\n  return HALStatus_OK;\n}\n\n",
            "renaming": {
                "FUN_0800124a": "set_dev_address_0800124a",
                "hi2c": "i2cHandle",
                "Instance": "i2cInstance",
                "DR": "dataRegister",
                "Devaddress": "deviceAddress",
                "HAL_OK": "HALStatus_OK"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001256": {
            "entrypoint": "0x08001256",
            "current_name": "handle_i2_c_state_08001256",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CState_08001256(I2C_HandleTypeDef *hi2c)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t tempVar1;\n  I2C_TypeDef *i2cInstance;\n  uint32_t previousState;\n  uint32_t tempReg1;\n  uint32_t tempReg2;\n  uint32_t tempReg3;\n  uint32_t tempReg4;\n  uint32_t tempReg5;\n  uint32_t tempReg6;\n  uint32_t tempReg7;\n  uint32_t tempReg8;\n  uint32_t tempReg9;\n  uint32_t tempReg10;\n  \n  tempVar1 = hi2c->XferOptions;\n  if ((hi2c->State == HAL_I2C_STATE_BUSY_RX) &&\n     ((hi2c->EventCount != 0 || (hi2c->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((hi2c->EventCount == 0) && ((hi2c->Init).AddressingMode == 0xc000)) {\n      hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x100;\n      hi2c->EventCount = hi2c->EventCount + 1;\n    }\n    else {\n      if (hi2c->XferCount == 0) {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n      }\n      else if (hi2c->XferCount == 1) {\n        if (tempVar1 == 0xffff0000) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n          i2cInstance = hi2c->Instance;\n          if ((i2cInstance->CR2 & 0x800) == 0) {\n            i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n          }\n          else {\n            i2cInstance->CR1 = i2cInstance->CR1 & 0xfffffbff;\n          }\n        }\n        else if (((tempVar1 == 4) || (tempVar1 == 8)) || (hi2c->PreviousState == 0x12)) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n        }\n        else if (hi2c->XferOptions == 2) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n        }\n        else {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n        }\n      }\n      else if (hi2c->XferCount == 2) {\n        if (hi2c->XferOptions == 2) {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n        }\n        else {\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n          hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x800;\n        }\n        i2cInstance = hi2c->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      else {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n        i2cInstance = hi2c->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      hi2c->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001256": "handle_i2_c_state_08001256",
                "CurrentXferOptions": "currentTransferOptions",
                "uVar1": "tempVar1",
                "pIVar2": "i2cInstance",
                "Prev_State": "previousState",
                "tmpreg": "tempReg1",
                "tmpreg_1": "tempReg2",
                "tmpreg_2": "tempReg3",
                "tmpreg_3": "tempReg4",
                "tmpreg_4": "tempReg5",
                "tmpreg_5": "tempReg6",
                "tmpreg_6": "tempReg7",
                "tmpreg_7": "tempReg8",
                "tmpreg_8": "tempReg9",
                "tmpreg_9": "tempReg10"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001420": {
            "entrypoint": "0x08001420",
            "current_name": "send_next_byte_08001420",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef sendNextByte_08001420(I2C_HandleTypeDef *i2cHandle)\n\n{\n  byte *pbVar1;\n  \n  if (i2cHandle->transferCount != 0) {\n    pbVar1 = i2cHandle->bufferPointer;\n    i2cHandle->bufferPointer = pbVar1 + 1;\n    i2cHandle->i2cInstance->dataRegister = (uint)*pbVar1;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001420": "send_next_byte_08001420",
                "hi2c": "i2cHandle",
                "XferCount": "transferCount",
                "pBuffPtr": "bufferPointer",
                "Instance": "i2cInstance",
                "DR": "dataRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001440": {
            "entrypoint": "0x08001440",
            "current_name": "transfer_data_to_buffer_08001440",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef transferDataToBuffer_08001440(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint8_t *bufferPtr;\n  \n  if (i2cHandle->transferCount != 0) {\n    bufferPtr = i2cHandle->ZWdataRegisterAMZZMJ;\n    i2cHandle->ZWdataRegisterAMZZMJ = bufferPtr + 1;\n    *bufferPtr = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001440": "transfer_data_to_buffer_08001440",
                "hi2c": "i2cHandle",
                "puVar1": "bufferPtr",
                "XferCount": "transferCount",
                "pBuffPtr": "bufferPointer",
                "Instance": "i2cInstance",
                "DR": "dataRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001460": {
            "entrypoint": "0x08001460",
            "current_name": "set_i2_c_listen_mode_08001460",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nsetI2CListenMode_08001460(I2C_HandleTypeDef *i2cHandle,uint8_t *data,uint16_t size,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef status;\n  I2C_TypeDef *i2cInstance;\n  uint32_t tempRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = data;\n      i2cHandle->XferCount = size;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->Xfersize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001460": "set_i2_c_listen_mode_08001460",
                "hi2c": "i2cHandle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014ec": {
            "entrypoint": "0x080014ec",
            "current_name": "set_i2_c_listen_mode_080014ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nsetI2CListenMode_080014ec(I2C_HandleTypeDef *i2cHandle,uint8_t *data,uint16_t size,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef status;\n  I2C_TypeDef *i2cInstance;\n  uint32_t tmpRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = data;\n      i2cHandle->XferCount = size;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->Xfersize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080014ec": "set_i2_c_listen_mode_080014ec",
                "hi2c": "i2cHandle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "tmpRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001578": {
            "entrypoint": "0x08001578",
            "current_name": "initialize_i2_c_08001578",
            "code": "\n/* WARNING: Unknown calling convention */\n\nI2C_Status initializeI2C_08001578(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2C_Registers *i2cInstance;\n  \n  if (i2cHandle->State != Ready) {\n    return Busy;\n  }\n  i2cHandle->State = Listening;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->ControlRegister1 & 1) == 0) {\n    i2cInstance->ControlRegister1 = i2cInstance->ControlRegister1 | 1;\n  }\n  i2cHandle->Instance->ControlRegister1 = i2cHandle->Instance->ControlRegister1 | 0x400;\n  i2cHandle->Instance->ControlRegister2 = i2cHandle->Instance->ControlRegister2 | 0x300;\n  return OperationSuccessful;\n}\n\n",
            "renaming": {
                "FUN_08001578": "initialize_i2_c_08001578",
                "hi2c": "i2cHandle",
                "pIVar1": "i2cInstance",
                "HAL_StatusTypeDef": "I2C_Status",
                "HAL_I2C_STATE_READY": "Ready",
                "HAL_BUSY": "Busy",
                "HAL_I2C_STATE_LISTEN": "Listening",
                "I2C_TypeDef": "I2C_Registers",
                "CR1": "ControlRegister1",
                "CR2": "ControlRegister2",
                "HAL_OK": "OperationSuccessful"
            },
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b6": {
            "entrypoint": "0x080015b6",
            "current_name": "FUNC_080015b6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080015b6(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b6": "FUNC_080015b6"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015b8": {
            "entrypoint": "0x080015b8",
            "current_name": "FUNC_080015b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080015b8(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b8": "FUNC_080015b8"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015ba": {
            "entrypoint": "0x080015ba",
            "current_name": "FUNC_080015ba",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080015ba(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015ba": "FUNC_080015ba"
            },
            "calling": [
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_AF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015bc": {
            "entrypoint": "0x080015bc",
            "current_name": "send_data_over_i2_c_080015bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef sendDataOverI2C_080015bc(I2C_HandleTypeDef *I2C_handle)\n\n{\n  I2C_stateTypeDef currentState;\n  byte *ptrToBuffer;\n  \n  currentState = I2C_handle->currentState;\n  if (I2C_handle->transferCount != 0) {\n    ptrToBuffer = I2C_handle->bufferPointer;\n    I2C_handle->bufferPointer = ptrToBuffer + 1;\n    I2C_handle->I2C_instance->dataRegister = (uint)*ptrToBuffer;\n    I2C_handle->transferCount = I2C_handle->transferCount - 1;\n    if ((I2C_handle->transferCount == 0) && (currentState == busyTxListenState)) {\n      I2C_handle->I2C_instance->controlRegister2 = I2C_handle->I2C_instance->controlRegister2 & 0xfffffbff;\n      I2C_handle->previousState = 0x21;\n      I2C_handle->currentState = listenState;\n      slaveTxCpltCallback(I2C_handle);\n    }\n    return successStatus;\n  }\n  return successStatus;\n}\n\n",
            "renaming": {
                "FUN_080015bc": "send_data_over_i2_c_080015bc",
                "hi2c": "I2C_handle",
                "HVar1": "currentState",
                "pbVar2": "ptrToBuffer",
                "XferCount": "transferCount",
                "pBuffPtr": "bufferPointer",
                "Instance": "I2C_instance",
                "DR": "dataRegister",
                "CR2": "controlRegister2",
                "PreviousState": "previousState",
                "State": "currentState",
                "HAL_I2C_StateTypeDef": "I2C_stateTypeDef",
                "HAL_OK": "successStatus",
                "HAL_I2C_STATE_BUSY_TX_LISTEN": "busyTxListenState",
                "HAL_I2C_STATE_LISTEN": "listenState",
                "HAL_I2C_SlaveTxCpltCallback": "slaveTxCpltCallback"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800160c": {
            "entrypoint": "0x0800160c",
            "current_name": "FUNC_0800160c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800160c(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800160c": "FUNC_0800160c"
            },
            "calling": [
                "I2C_Slave_STOPF",
                "I2C_SlaveReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800160e": {
            "entrypoint": "0x0800160e",
            "current_name": "read_and_handle_i2_c_data_0800160e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef readAndHandleI2CData_0800160e(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  uint8_t *bufferPtr;\n  \n  currentState = i2cHandle->State;\n  if (i2cHandle->transferCount != 0) {\n    bufferPtr = i2cHandle->dataBufferPtr;\n    i2cHandle->dataBufferPtr = bufferPtr + 1;\n    *bufferPtr = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    if ((i2cHandle->transferCount == 0) && (currentState == HAL_I2C_RX_LISTEN)) {\n      i2cHandle->i2cInstance->CR2 = i2cHandle->i2cInstance->CR2 & 0xfffffbff;\n      i2cHandle->previousState = 0x22;\n      i2cHandle->State = HAL_I2C_LISTEN;\n      handleI2CReceiveComplete(i2cHandle);\n    }\n  }\n  return HAL_OPERATION_SUCCESS;\n}\n\n",
            "renaming": {
                "FUN_0800160e": "read_and_handle_i2_c_data_0800160e",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "puVar2": "bufferPtr",
                "XferCount": "transferCount",
                "pBuffPtr": "dataBufferPtr",
                "DR": "dataRegister",
                "Instance": "i2cInstance",
                "PreviousState": "previousState",
                "HAL_I2C_STATE_BUSY_RX_LISTEN": "HAL_I2C_RX_LISTEN",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_LISTEN",
                "HAL_I2C_SlaveRxCpltCallback": "handleI2CReceiveComplete",
                "HAL_OK": "HAL_OPERATION_SUCCESS"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800165a": {
            "entrypoint": "0x0800165a",
            "current_name": "handle_i2_c_address_matching_0800165a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CAddressMatching_0800165a(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint16_t addressMatchCode;\n  \n  if ((i2cHandle->Instance->SR2 & 0x80) == 0) {\n    addressMatchCode = *(uint16_t *)&(i2cHandle->Init).OwnAddress1;\n  }\n  else {\n    addressMatchCode = *(uint16_t *)&(i2cHandle->Init).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(i2cHandle,(i2cHandle->Instance->SR2 & 4) == 0,addressMatchCode);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800165a": "handle_i2_c_address_matching_0800165a",
                "hi2c": "i2cHandle",
                "AddrMatchCode": "addressMatchCode"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001684": {
            "entrypoint": "0x08001684",
            "current_name": "handle_i2_c_events_08001684",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CEvents_08001684(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t currentState;\n  \n  if (((i2cHandle->XferOptions == 4) || (i2cHandle->XferOptions == 8)) &&\n     (i2cHandle->State == HAL_I2C_STATE_LISTEN)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandle);\n  }\n  else if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->PreviousState = 0x21;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback(i2cHandle);\n  }\n  else {\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001684": "handle_i2_c_events_08001684",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "CurrentState": "currentState"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001718": {
            "entrypoint": "0x08001718",
            "current_name": "FUNC_08001718",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001718(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001718": "FUNC_08001718"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800171a": {
            "entrypoint": "0x0800171a",
            "current_name": "perform_i2_c_operation_0800171a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatus performI2COperation_0800171a(I2C_HandleTypeDef *i2cHandle)\n\n{\n  State currentState;\n  uint32_t currentI2CState;\n  byte *dataPointer;\n  uint32_t currentTransferOptions;\n  uint32_t dataFormat;\n  \n  currentState = i2cHandle->YJYdataRegisterZPBAR;\n  dataFormat = i2cHandle->XferOptions;\n  if ((i2cHandle->DPdataRegisterHYJEDQ == 0) && (currentState == I2C_STATE_BUSY_TX)) {\n    if ((dataFormat == 4) || ((dataFormat == 8 || (dataFormat == 0xffff0000)))) {\n      i2cHandle->i2cInstance->i2cCR2 = i2cHandle->i2cInstance->i2cCR2 & 0xfffff8ff;\n      i2cHandle->i2cInstance->i2cCR1 = i2cHandle->i2cInstance->i2cCR1 | 0x200;\n      i2cHandle->previousI2CState = 0;\n      i2cHandle->YJYdataRegisterZPBAR = I2C_STATE_READY;\n      if (i2cHandle->i2cMode == I2C_MODE_MEM) {\n        i2cHandle->i2cMode = I2C_MODE_NONE;\n        MemTxCpltCallback(i2cHandle);\n      }\n      else {\n        i2cHandle->i2cMode = I2C_MODE_NONE;\n        MasterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      i2cHandle->i2cInstance->i2cCR2 = i2cHandle->i2cInstance->i2cCR2 & 0xfffff8ff;\n      i2cHandle->previousI2CState = 0x11;\n      i2cHandle->i2cMode = I2C_MODE_NONE;\n      i2cHandle->YJYdataRegisterZPBAR = I2C_STATE_READY;\n      MasterTxCpltCallback(i2cHandle);\n    }\n  }\n  else if ((currentState == I2C_STATE_BUSY_TX) ||\n          ((i2cHandle->i2cMode == I2C_MODE_MEM && (currentState == I2C_STATE_BUSY_RX)))) {\n    if (i2cHandle->transferCount == 0) {\n      i2cHandle->i2cInstance->i2cCR2 = i2cHandle->i2cInstance->i2cCR2 & 0xfffffbff;\n    }\n    else if (i2cHandle->i2cMode == I2C_MODE_MEM) {\n      if (i2cHandle->eventCount == 0) {\n        if (i2cHandle->memoryAddressSize == 1) {\n          i2cHandle->i2cInstance->dataRegister = i2cHandle->memoryAddress & 0xff;\n          i2cHandle->eventCount = i2cHandle->eventCount + 2;\n        }\n        else {\n          i2cHandle->i2cInstance->dataRegister = (i2cHandle->memoryAddress << 0x10) >> 0x18;\n          i2cHandle->eventCount = i2cHandle->eventCount + 1;\n        }\n      }\n      else if (i2cHandle->eventCount == 1) {\n        i2cHandle->i2cInstance->dataRegister = i2cHandle->memoryAddress & 0xff;\n        i2cHandle->eventCount = i2cHandle->eventCount + 1;\n      }\n      else if (i2cHandle->eventCount == 2) {\n        if (i2cHandle->YJYdataRegisterZPBAR == I2C_STATE_BUSY_RX) {\n          i2cHandle->i2cInstance->i2cCR1 = i2cHandle->i2cInstance->i2cCR1 | 0x100;\n        }\n        else if (i2cHandle->YJYdataRegisterZPBAR == I2C_STATE_BUSY_TX) {\n          dataPointer = i2cHandle->bufferPointer;\n          i2cHandle->bufferPointer = dataPointer + 1;\n          i2cHandle->i2cInstance->dataRegister = (uint)*dataPointer;\n          i2cHandle->transferCount = i2cHandle->transferCount - 1;\n        }\n      }\n    }\n    else {\n      dataPointer = i2cHandle->bufferPointer;\n      i2cHandle->bufferPointer = dataPointer + 1;\n      i2cHandle->i2cInstance->dataRegister = (uint)*dataPointer;\n      i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    }\n  }\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_0800171a": "perform_i2_c_operation_0800171a",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "CurrentState": "currentI2CState",
                "pbVar2": "dataPointer",
                "CurrentXferOptions": "currentTransferOptions",
                "uVar3": "dataFormat",
                "HAL_StatusTypeDef": "Status",
                "HAL_I2C_StateTypeDef": "State",
                "HAL_I2C_STATE_BUSY_TX": "I2C_STATE_BUSY_TX",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_I2C_MODE_MEM": "I2C_MODE_MEM",
                "HAL_I2C_MODE_NONE": "I2C_MODE_NONE",
                "HAL_I2C_MemTxCpltCallback": "MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback": "MasterTxCpltCallback",
                "XferSize": "transferSize",
                "Instance": "i2cInstance",
                "CR2": "i2cCR2",
                "CR1": "i2cCR1",
                "PreviousState": "previousI2CState",
                "Mode": "i2cMode",
                "HAL_I2C_STATE_BUSY_RX": "I2C_STATE_BUSY_RX",
                "XferCount": "transferCount",
                "EventCount": "eventCount",
                "MemaddSize": "memoryAddressSize",
                "Memaddress": "memoryAddress",
                "State": "i2cState",
                "pBuffPtr": "bufferPointer",
                "DR": "dataRegister",
                "HAL_OK": "OK"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001864": {
            "entrypoint": "0x08001864",
            "current_name": "handle_i2_c_transfer_08001864",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CTransfer_08001864(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t transferOptions;\n  uint32_t currentTransferOptions;\n  byte *bufferPtr;\n  \n  transferOptions = i2cHandle->XferOptions;\n  if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    if (i2cHandle->XferCount == 0) {\n      if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        i2cHandle->PreviousState = 0;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(i2cHandle);\n        }\n        else {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(i2cHandle);\n        }\n      }\n      else {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->PreviousState = 0x11;\n        i2cHandle->Mode = HAL_I2C_MODE_NONE;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      bufferPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPtr + 1;\n      i2cHandle->Instance->DR = (uint)*bufferPtr;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001864": "handle_i2_c_transfer_08001864",
                "hi2c": "i2cHandle",
                "uVar1": "transferOptions",
                "CurrentXferOptions": "currentTransferOptions",
                "pbVar2": "bufferPtr"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001902": {
            "entrypoint": "0x08001902",
            "current_name": "FUNC_08001902",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001902(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001902": "FUNC_08001902"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001904": {
            "entrypoint": "0x08001904",
            "current_name": "handle_i2_c_rx_transfer_08001904",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatus handleI2CRxTransfer_08001904(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint8_t *bufferPtr;\n  \n  if (i2cHandle->State == I2C_STATE_RECEIVING) {\n    if (i2cHandle->XferCount < 4) {\n      if (i2cHandle->XferCount < 2) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        bufferPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = bufferPtr + 1;\n        *bufferPtr = (uint8_t)i2cHandle->Instance->DR;\n        i2cHandle->XferCount = i2cHandle->XferCount - 1;\n        i2cHandle->State = I2C_STATE_READY;\n        i2cHandle->PreviousState = 0;\n        if (i2cHandle->Mode == I2C_MODE_MEMORY) {\n          i2cHandle->Mode = I2C_MODE_NONE;\n          handleMemoryReceiveComplete(i2cHandle);\n        }\n        else {\n          i2cHandle->Mode = I2C_MODE_NONE;\n          handleMasterReceiveComplete(i2cHandle);\n        }\n      }\n    }\n    else {\n      bufferPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPtr + 1;\n      *bufferPtr = (uint8_t)i2cHandle->Instance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n      if (i2cHandle->XferCount == 3) {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      }\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001904": "handle_i2_c_rx_transfer_08001904",
                "hi2c": "i2cHandle",
                "puVar1": "bufferPtr",
                "HAL_StatusTypeDef": "Status",
                "HAL_I2C_STATE_BUSY_RX": "I2C_STATE_RECEIVING",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_I2C_MODE_MEM": "I2C_MODE_MEMORY",
                "HAL_I2C_MODE_NONE": "I2C_MODE_NONE",
                "HAL_I2C_MasterRxCpltCallback": "handleMasterReceiveComplete",
                "HAL_I2C_MemRxCpltCallback": "handleMemoryReceiveComplete"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080019a0": {
            "entrypoint": "0x080019a0",
            "current_name": "handle_i2_c_data_transfer_080019a0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CDataTransfer_080019a0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint8_t *bufferPointer;\n  \n  if (i2cHandle->XferCount == 4) {\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n    bufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n  }\n  else if (i2cHandle->XferCount == 3) {\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    bufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n  }\n  else if (i2cHandle->XferCount == 2) {\n    if (i2cHandle->XferOptions - 1 < 2) {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n    }\n    else {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n    }\n    bufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    bufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffcff;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->PreviousState = 0;\n    if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MemRxCpltCallback(i2cHandle);\n    }\n    else {\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MasterRxCpltCallback(i2cHandle);\n    }\n  }\n  else {\n    bufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080019a0": "handle_i2_c_data_transfer_080019a0",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "puVar1": "bufferPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001aac": {
            "entrypoint": "0x08001aac",
            "current_name": "FUNC_08001aac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001aac(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001aac": "FUNC_08001aac"
            },
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "handle_i2_c_state_08001ab0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CState_08001ab0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t *dataPointer;\n  I2C_TypeDef *i2cInstance;\n  \n  if (i2cHandle->State - 0x29 < 2) {\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((i2cHandle->State != HAL_I2C_STATE_ABORT) && ((i2cHandle->Instance->CR2 & 0x800) == 0)) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n    }\n    i2cHandle->PreviousState = 0;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  }\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) == 0) {\n    if (i2cHandle->State == HAL_I2C_STATE_ABORT) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->ErrorCode = 0;\n      if ((i2cInstance->SR1 & 0x40) != 0) {\n        dataPointer = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = dataPointer + 1;\n        *dataPointer = (uint8_t)i2cInstance->DR;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(i2cHandle);\n    }\n    else {\n      if ((i2cInstance->SR1 & 0x40) != 0) {\n        dataPointer = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = dataPointer + 1;\n        *dataPointer = (uint8_t)i2cInstance->DR;\n      }\n      HAL_I2C_ErrorCallback(i2cHandle);\n    }\n  }\n  else {\n    i2cInstance->CR2 = i2cInstance->CR2 & 0xfffff7ff;\n    if (i2cHandle->hdmatx->State == HAL_DMA_STATE_READY) {\n      i2cHandle->hdmarx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->hdmarx);\n      if (status != HAL_OK) {\n        if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n          dataPointer = i2cHandle->pBuffPtr;\n          i2cHandle->pBuffPtr = dataPointer + 1;\n          *dataPointer = (uint8_t)i2cHandle->Instance->DR;\n        }\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        (*i2cHandle->hdmarx->XferAbortCallback)(i2cHandle->hdmarx);\n      }\n    }\n    else {\n      i2cHandle->hdmatx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->hdmatx);\n      if (status != HAL_OK) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        (*i2cHandle->hdmatx->XferAbortCallback)(i2cHandle->hdmatx);\n      }\n    }\n  }\n  if ((i2cHandle->State == HAL_I2C_STATE_LISTEN) && ((i2cHandle->ErrorCode & 4) != 0)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "handle_i2_c_state_08001ab0",
                "hi2c": "i2cHandle",
                "HVar1": "status",
                "puVar2": "dataPointer",
                "pIVar3": "i2cInstance"
            },
            "calling": [
                "I2C_Slave_STOPF",
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback",
                "HAL_DMA_Abort_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001bfc": {
            "entrypoint": "0x08001bfc",
            "current_name": "process_i2_c_transfer_08001bfc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef processI2CTransfer_08001bfc(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  I2C_TypeDef *i2cInstance;\n  uint8_t *dataPtr;\n  uint32_t currentI2CState;\n  uint32_t temporaryRegister;\n  \n  currentState = i2cHandle->State;\n  i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) != 0) {\n    if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) || (i2cHandle->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmarx->Instance->NDTR;\n    }\n    else {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmatx->Instance->NDTR;\n    }\n  }\n  if (i2cHandle->XferCount != 0) {\n    if ((i2cInstance->SR1 & 4) != 0) {\n      dataPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPtr + 1;\n      *dataPtr = (uint8_t)i2cInstance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n      dataPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPtr + 1;\n      *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n  }\n  if (i2cHandle->ErrorCode == 0) {\n    if (((currentState == HAL_I2C_STATE_LISTEN) || (currentState == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (currentState == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2cHandle->XferOptions = 0xffff0000;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(i2cHandle);\n    }\n    else if ((i2cHandle->PreviousState == 0x22) || (currentState == HAL_I2C_STATE_BUSY_RX)) {\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  else {\n    I2C_ITError(i2cHandle);\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001bfc": "process_i2_c_transfer_08001bfc",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "pIVar2": "i2cInstance",
                "puVar3": "dataPtr",
                "CurrentState": "currentI2CState",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveRxCpltCallback",
                "I2C_ITError"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001d00": {
            "entrypoint": "0x08001d00",
            "current_name": "handle_i2_c_status_08001d00",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CStatus_08001d00(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2C_TypeDef *i2cInstance;\n  uint32_t currentMode;\n  uint sr1Flags;\n  uint32_t sr1ITFlags;\n  uint cr2Flags;\n  uint32_t itSources;\n  uint sr2Flags;\n  uint32_t sr2ITFlags;\n  \n  i2cInstance = i2cHandle->Instance;\n  sr2Flags = i2cInstance->SR2;\n  sr1Flags = i2cInstance->SR1;\n  cr2Flags = i2cInstance->CR2;\n  if ((i2cHandle->Mode == HAL_I2C_MODE_MASTER) || (i2cHandle->Mode == HAL_I2C_MODE_MEM)) {\n    if (((sr1Flags & 0x10001) == 0) || ((cr2Flags & 0x200) == 0)) {\n      if (((sr1Flags & 0x10008) == 0) || ((cr2Flags & 0x200) == 0)) {\n        if (((sr1Flags & 0x10002) != 0) && ((cr2Flags & 0x200) != 0)) {\n          I2C_Master_ADDR(i2cHandle);\n        }\n      }\n      else {\n        I2C_Master_ADD10(i2cHandle);\n      }\n    }\n    else {\n      I2C_Master_SB(i2cHandle);\n    }\n    if ((sr2Flags & 0x100004) == 0) {\n      if ((((sr1Flags & 0x10040) != 0) && ((cr2Flags & 0x400) != 0)) && ((sr1Flags & 0x10004) == 0)) {\n        I2C_MasterReceive_RXNE(i2cHandle);\n        return;\n      }\n      if (((sr1Flags & 0x10004) != 0) && ((cr2Flags & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(i2cHandle);\n        return;\n      }\n    }\n    else {\n      if ((((sr1Flags & 0x10080) != 0) && ((cr2Flags & 0x400) != 0)) && ((sr1Flags & 0x10004) == 0)) {\n        I2C_MasterTransmit_TXE(i2cHandle);\n        return;\n      }\n      if (((sr1Flags & 0x10004) != 0) && ((cr2Flags & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(i2cHandle);\n        return;\n      }\n    }\n  }\n  else {\n    if (((sr1Flags & 0x10002) != 0) && ((cr2Flags & 0x200) != 0)) {\n      I2C_Slave_ADDR(i2cHandle);\n      return;\n    }\n    if (((sr1Flags & 0x10010) != 0) && ((cr2Flags & 0x200) != 0)) {\n      I2C_Slave_STOPF(i2cHandle);\n      return;\n    }\n    if ((sr2Flags & 0x100004) == 0) {\n      if ((((sr1Flags & 0x10040) != 0) && ((cr2Flags & 0x400) != 0)) && ((sr1Flags & 0x10004) == 0)) {\n        I2C_SlaveReceive_RXNE(i2cHandle);\n        return;\n      }\n      if (((sr1Flags & 0x10004) != 0) && ((cr2Flags & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(i2cHandle);\n      }\n    }\n    else {\n      if ((((sr1Flags & 0x10080) != 0) && ((cr2Flags & 0x400) != 0)) && ((sr1Flags & 0x10004) == 0)) {\n        I2C_SlaveTransmit_TXE(i2cHandle);\n        return;\n      }\n      if (((sr1Flags & 0x10004) != 0) && ((cr2Flags & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(i2cHandle);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001d00": "handle_i2_c_status_08001d00",
                "hi2c": "i2cHandle",
                "pIVar1": "i2cInstance",
                "CurrentMode": "currentMode",
                "uVar2": "sr1Flags",
                "sr1itflags": "sr1ITFlags",
                "uVar3": "cr2Flags",
                "itsources": "itSources",
                "uVar4": "sr2Flags",
                "sr2itflags": "sr2ITFlags"
            },
            "calling": [
                "I2C2_EV_IRQHandler",
                "I2C1_EV_IRQHandler",
                "I2C3_EV_IRQHandler"
            ],
            "called": [
                "I2C_Slave_STOPF",
                "I2C_MasterReceive_BTF",
                "I2C_SlaveReceive_RXNE",
                "I2C_Master_ADD10",
                "I2C_Master_SB",
                "I2C_MasterTransmit_TXE",
                "I2C_Master_ADDR",
                "I2C_SlaveReceive_BTF",
                "I2C_SlaveTransmit_TXE",
                "I2C_MasterTransmit_BTF",
                "I2C_MasterReceive_RXNE",
                "I2C_Slave_ADDR",
                "I2C_SlaveTransmit_BTF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e68": {
            "entrypoint": "0x08001e68",
            "current_name": "handle_i2_c_events_08001e68",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvents_08001e68(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef i2cState;\n  I2C_TypeDef *i2cInstance;\n  uint32_t SR1ITFlags;\n  uint SR1Value;\n  uint32_t itsources;\n  uint CR2Value;\n  \n  i2cInstance = i2cHandle->Instance;\n  SR1Value = i2cInstance->SR1;\n  CR2Value = i2cInstance->CR2;\n  if (((SR1Value & 0x10100) != 0) && ((CR2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 1;\n    i2cInstance->SR1 = 0xfffffeff;\n  }\n  if (((SR1Value & 0x10200) != 0) && ((CR2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 2;\n    i2cHandle->Instance->SR1 = 0xfffffdff;\n  }\n  if (((SR1Value & 0x10400) != 0) && ((CR2Value & 0x100) != 0)) {\n    i2cState = i2cHandle->State;\n    if (((i2cHandle->Mode == HAL_I2C_MODE_SLAVE) && (i2cHandle->XferCount == 0)) &&\n       (((i2cState == HAL_I2C_STATE_BUSY_TX || (i2cState == HAL_I2C_STATE_BUSY_TX_LISTEN)) ||\n        ((i2cState == HAL_I2C_STATE_LISTEN && (i2cHandle->PreviousState == 0x21)))))) {\n      I2C_Slave_AF(i2cHandle);\n    }\n    else {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n      if (i2cHandle->Mode == HAL_I2C_MODE_MASTER) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      }\n      i2cHandle->Instance->SR1 = 0xfffffbff;\n    }\n  }\n  if (((SR1Value & 0x10800) != 0) && ((CR2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 8;\n    i2cHandle->Instance->SR1 = 0xfffff7ff;\n  }\n  if (i2cHandle->ErrorCode != 0) {\n    I2C_ITError(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001e68": "handle_i2_c_events_08001e68",
                "hi2c": "i2cHandle",
                "HVar1": "i2cState",
                "pIVar2": "i2cInstance",
                "sr1itflags": "SR1ITFlags",
                "uVar3": "SR1Value",
                "uVar4": "CR2Value"
            },
            "calling": [
                "I2C3_ER_IRQHandler",
                "I2C2_ER_IRQHandler",
                "I2C1_ER_IRQHandler"
            ],
            "called": [
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f3c": {
            "entrypoint": "0x08001f3c",
            "current_name": "reset_i2_c_interface_08001f3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetI2CInterface_08001f3c(DMA_HandleTypeDef *dmaHandle)\n\n{\n  I2C_HandleTypeDef *i2cHandleParent;\n  I2C_HandleTypeDef *i2cHandle;\n  \n  i2cHandleParent = (I2C_HandleTypeDef *)dmaHandle->Parent;\n  i2cHandleParent->Instance->CR1 = i2cHandleParent->Instance->CR1 & 0xfffffbff;\n  i2cHandleParent->XferCount = 0;\n  i2cHandleParent->dmaHandletx->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  i2cHandleParent->dmaHandlerx->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  if (i2cHandleParent->State != I2C_STATE_ABORT) {\n    i2cHandleParent->State = I2C_STATE_READY;\n    i2cHandleParent->Mode = I2C_MODE_NONE;\n    i2cHandleParent->Instance->CR1 = i2cHandleParent->Instance->CR1 & 0xfffffffe;\n    handleI2CError(i2cHandleParent);\n    return;\n  }\n  i2cHandleParent->State = I2C_STATE_READY;\n  i2cHandleParent->Mode = I2C_MODE_NONE;\n  i2cHandleParent->ErrorCode = 0;\n  i2cHandleParent->Instance->CR1 = i2cHandleParent->Instance->CR1 & 0xfffffffe;\n  handleI2CAbortComplete(i2cHandleParent);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001f3c": "reset_i2_c_interface_08001f3c",
                "hdma": "dmaHandle",
                "hi2c_00": "i2cHandleParent",
                "hi2c": "i2cHandle",
                "HAL_I2C_STATE_ABORT": "I2C_STATE_ABORT",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_I2C_MODE_NONE": "I2C_MODE_NONE",
                "HAL_I2C_ErrorCallback": "handleI2CError",
                "HAL_I2C_AbortCpltCallback": "handleI2CAbortComplete"
            },
            "calling": [],
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f9c": {
            "entrypoint": "0x08001f9c",
            "current_name": "poll_status_08001f9c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef pollStatus_08001f9c(void)\n\n{\n  uint32_t startTime;\n  uint32_t currentTime;\n  uint32_t temporaryRegister;\n  \n  _DAT_40023840 = _DAT_40023840 | 0x10000000;\n  _DAT_420e0040 = 1;\n  startTime = HAL_GetTick();\n  do {\n    if ((_DAT_40007004 & 0x10000) != 0) {\n      _DAT_420e0044 = 1;\n      startTime = HAL_GetTick();\n      do {\n        if ((_DAT_40007004 & 0x20000) != 0) {\n          return HAL_OK;\n        }\n        currentTime = HAL_GetTick();\n      } while (currentTime - startTime < 0x3e9);\n      return HAL_TIMEOUT;\n    }\n    currentTime = HAL_GetTick();\n  } while (currentTime - startTime < 0x3e9);\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08001f9c": "poll_status_08001f9c",
                "uVar1": "startTime",
                "uVar2": "currentTime",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800201c": {
            "entrypoint": "0x0800201c",
            "current_name": "initialize_oscillators_0800201c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nOscillatorStatus initializeOscillators_0800201c(RCC_OscInitTypeDef_conflict *oscInitConfig)\n\n{\n  OscillatorStatus HVar1;\n  uint32_t tickstart;\n  uint32_t timeElapsed;\n  uint32_t tickstart;\n  bool enableLSEState;\n  uint32_t temporaryRegister;\n  \n  if (oscInitConfig == (RCC_OscInitTypeDef_conflict *)0x0) {\n    return HAL_ERROR;\n  }\n  if ((oscInitConfig->OscillatorType & 1) != 0) {\n    if (((_DAT_40023808 & 0xc) == 4) ||\n       (((_DAT_40023808 & 0xc) == 8 && ((_DAT_40023804 & 0x400000) != 0)))) {\n      if (((_DAT_40023800 & 0x20000) != 0) && (oscInitConfig->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      if (oscInitConfig->HSEState == 0x10000) {\n        _DAT_40023800 = _DAT_40023800 | 0x10000;\n      }\n      else if (oscInitConfig->HSEState == 0x50000) {\n        _DAT_40023800 = _DAT_40023800 | 0x50000;\n      }\n      else {\n        _DAT_40023800 = _DAT_40023800 & 0xfffaffff;\n      }\n      if (oscInitConfig->HSEState == 0) {\n        tickstart = getCurrentTick();\n        while ((_DAT_40023800 & 0x20000) != 0) {\n          timeElapsed = getCurrentTick();\n          if (100 < timeElapsed - tickstart) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        tickstart = getCurrentTick();\n        while ((_DAT_40023800 & 0x20000) == 0) {\n          timeElapsed = getCurrentTick();\n          if (100 < timeElapsed - tickstart) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((oscInitConfig->OscillatorType & 2) != 0) {\n    if (((_DAT_40023808 & 0xc) == 0) ||\n       (((_DAT_40023808 & 0xc) == 8 && ((_DAT_40023804 & 0x400000) == 0)))) {\n      if (((_DAT_40023800 & 2) != 0) && (oscInitConfig->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      _DAT_40023800 = _DAT_40023800 & 0xffffff07 | oscInitConfig->HSICalibrationValue << 3;\n    }\n    else if (oscInitConfig->HSIState == 0) {\n      _DAT_42470000 = 0;\n      tickstart = getCurrentTick();\n      while ((_DAT_40023800 & 2) != 0) {\n        timeElapsed = getCurrentTick();\n        if (2 < timeElapsed - tickstart) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470000 = 1;\n      tickstart = getCurrentTick();\n      while ((_DAT_40023800 & 2) == 0) {\n        timeElapsed = getCurrentTick();\n        if (2 < timeElapsed - tickstart) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40023800 = _DAT_40023800 & 0xffffff07 | oscInitConfig->HSICalibrationValue << 3;\n    }\n  }\n  if ((oscInitConfig->OscillatorType & 8) != 0) {\n    if (oscInitConfig->LSIState == 0) {\n      _DAT_42470e80 = 0;\n      tickstart = getCurrentTick();\n      while ((_DAT_40023874 & 2) != 0) {\n        timeElapsed = getCurrentTick();\n        if (2 < timeElapsed - tickstart) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470e80 = 1;\n      tickstart = getCurrentTick();\n      while ((_DAT_40023874 & 2) == 0) {\n        timeElapsed = getCurrentTick();\n        if (2 < timeElapsed - tickstart) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((oscInitConfig->OscillatorType & 4) != 0) {\n    enableLSEState = (_DAT_40023840 & 0x10000000) == 0;\n    if (enableLSEState) {\n      _DAT_40023840 = _DAT_40023840 | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      tickstart = getCurrentTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        timeElapsed = getCurrentTick();\n        if (2 < timeElapsed - tickstart) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (oscInitConfig->LSEState == 1) {\n      _DAT_40023870 = _DAT_40023870 | 1;\n    }\n    else if (oscInitConfig->LSEState == 5) {\n      _DAT_40023870 = _DAT_40023870 | 5;\n    }\n    else {\n      _DAT_40023870 = _DAT_40023870 & 0xfffffffa;\n    }\n    if (oscInitConfig->LSEState == 0) {\n      tickstart = getCurrentTick();\n      while ((_DAT_40023870 & 2) != 0) {\n        timeElapsed = getCurrentTick();\n        if (5000 < timeElapsed - tickstart) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      tickstart = getCurrentTick();\n      while ((_DAT_40023870 & 2) == 0) {\n        timeElapsed = getCurrentTick();\n        if (5000 < timeElapsed - tickstart) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (enableLSEState) {\n      _DAT_40023840 = _DAT_40023840 & 0xefffffff;\n    }\n  }\n  tickstart = (oscInitConfig->PLL).PLLState;\n  if (tickstart == 0) {\n    HVar1 = HAL_OK;\n  }\n  else if ((_DAT_40023808 & 0xc) == 8) {\n    HVar1 = HAL_ERROR;\n  }\n  else if (tickstart == 2) {\n    _DAT_42470060 = 0;\n    tickstart = getCurrentTick();\n    do {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        _DAT_40023804 =\n             (oscInitConfig->PLL).PLLSource | (oscInitConfig->PLL).PLLM |\n             (oscInitConfig->PLL).PLLN << 6 |\n             (((oscInitConfig->PLL).PLLP >> 1) - 1) * 0x10000 |\n             (oscInitConfig->PLL).PLLQ << 0x18;\n        _DAT_42470060 = 1;\n        tickstart = getCurrentTick();\n        do {\n          if ((_DAT_40023800 & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          timeElapsed = getCurrentTick();\n        } while (timeElapsed - tickstart < 3);\n        return HAL_TIMEOUT;\n      }\n      timeElapsed = getCurrentTick();\n    } while (timeElapsed - tickstart < 3);\n    HVar1 = HAL_TIMEOUT;\n  }\n  else {\n    _DAT_42470060 = 0;\n    tickstart = getCurrentTick();\n    do {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      timeElapsed = getCurrentTick();\n    } while (timeElapsed - tickstart < 3);\n    HVar1 = HAL_TIMEOUT;\n  }\n  return HVar1;\n}\n\n",
            "renaming": {
                "FUN_0800201c": "initialize_oscillators_0800201c",
                "RCC_OscInitStruct": "oscInitConfig",
                "HAL_StatusTypeDef": "OscillatorStatus",
                "uVar2": "tickstart",
                "uVar3": "timeElapsed",
                "bVar4": "enableLSEState",
                "tmpreg": "temporaryRegister",
                "HAL_GetTick": "getCurrentTick"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080023b4": {
            "entrypoint": "0x080023b4",
            "current_name": "get_clock_frequency_080023b4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_clock_frequency_080023b4(void)\n\n{\n  uint frequency;\n  \n  if ((_DAT_40023808 & 0xc) == 4) {\n    return 8000000;\n  }\n  if ((_DAT_40023808 & 0xc) != 8) {\n    return 16000000;\n  }\n  if ((_DAT_40023804 & 0x400000) == 0) {\n    frequency = (_DAT_40023804 << 0x11) >> 0x17;\n    frequency = divide(frequency * 16000000,\n                             (((uint)(frequency * 0x20 < frequency) * -0x3f -\n                              (uint)(frequency * 0x7c0 < frequency * 0x1f)) * 8 +\n                             (uint)carry_check(frequency * 0x3d08,frequency)) * 0x400 | frequency * 0x3d09 >> 0x16,\n                             _DAT_40023804 & 0x3f,0);\n  }\n  else {\n    frequency = (_DAT_40023804 << 0x11) >> 0x17;\n    frequency = divide(frequency * 8000000,\n                             (((uint)(frequency * 0x20 < frequency) * -0x3f -\n                              (uint)(frequency * 0x7c0 < frequency * 0x1f)) * 8 +\n                             (uint)carry_check(frequency * 0x3d08,frequency)) * 0x200,_DAT_40023804 & 0x3f,0);\n  }\n  return frequency / ((((_DAT_40023804 << 0xe) >> 0x1e) + 1) * 2);\n}\n\n",
            "renaming": {
                "FUN_080023b4": "get_clock_frequency_080023b4",
                "uVar1": "frequency",
                "__aeabi_uldivmod": "divide",
                "CARRY4": "carry_check"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "__aeabi_uldivmod"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002488": {
            "entrypoint": "0x08002488",
            "current_name": "configure_clock_08002488",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureClock_08002488(RCC_ClkInitTypeDef_conflict *clockConfig,uint32_t flashLatency)\n\n{\n  uint32_t tempVar1;\n  uint32_t tempVar2;\n  uint tempVar3;\n  uint32_t tickStart;\n  \n  if (clockConfig == (RCC_ClkInitTypeDef_conflict *)0x0) {\n    return HAL_ERROR;\n  }\n  if (((_DAT_40023c00 & 0xf) < flashLatency) &&\n     (_DAT_40023c00 = CONCAT31(DAT_40023c00_1,(char)flashLatency), flashLatency != (flashLatency & 0xf))) {\n    return HAL_ERROR;\n  }\n  if ((clockConfig->ClockType & 2) != 0) {\n    if ((clockConfig->ClockType & 4) != 0) {\n      _DAT_40023808 = _DAT_40023808 | 0x1c00;\n    }\n    if ((clockConfig->ClockType & 8) != 0) {\n      _DAT_40023808 = _DAT_40023808 | 0xe000;\n    }\n    _DAT_40023808 = _DAT_40023808 & 0xffffff0f | clockConfig->AHBCLKDivider;\n  }\n  if ((clockConfig->ClockType & 1) != 0) {\n    tempVar3 = clockConfig->SYSCLKSource;\n    if (tempVar3 == 1) {\n      if ((_DAT_40023800 & 0x20000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if (tempVar3 - 2 < 2) {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((_DAT_40023800 & 2) == 0) {\n      return HAL_ERROR;\n    }\n    _DAT_40023808 = tempVar3 | _DAT_40023808 & 0xfffffffc;\n    tempVar1 = HAL_GetTick();\n    while ((_DAT_40023808 & 0xc) != clockConfig->SYSCLKSource * 4) {\n      tempVar2 = HAL_GetTick();\n      if (5000 < tempVar2 - tempVar1) {\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  if ((flashLatency < (_DAT_40023c00 & 0xf)) &&\n     (_DAT_40023c00 = CONCAT31(DAT_40023c00_1,(char)flashLatency), flashLatency != (flashLatency & 0xf))) {\n    return HAL_ERROR;\n  }\n  if ((clockConfig->ClockType & 4) != 0) {\n    _DAT_40023808 = _DAT_40023808 & 0xffffe3ff | clockConfig->APB1CLKDivider;\n  }\n  if ((clockConfig->ClockType & 8) != 0) {\n    _DAT_40023808 = _DAT_40023808 & 0xffff1fff | clockConfig->APB2CLKDivider << 3;\n  }\n  tempVar1 = HAL_RCC_GetSysClockFreq();\n  sysCoreClock = tempVar1 >> \"\"[(_DAT_40023808 << 0x18) >> 0x1c];\n  HAL_InitTick(0xf);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002488": "configure_clock_08002488",
                "RCC_ClkInitStruct": "clockConfig",
                "FLatency": "flashLatency",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "uVar3": "tempVar3",
                "tickstart": "tickStart",
                "SystemCoreClock": "sysCoreClock"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_RCC_GetSysClockFreq",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025e0": {
            "entrypoint": "0x080025e0",
            "current_name": "get_system_core_clock_080025e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_080025e0(void)\n\n{\n  return systemCoreClock;\n}\n\n",
            "renaming": {
                "FUN_080025e0": "get_system_core_clock_080025e0",
                "SystemCoreClock": "systemCoreClock"
            },
            "calling": [
                "SystemClock_Config",
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025ec": {
            "entrypoint": "0x080025ec",
            "current_name": "get_hclk_freq_080025ec",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_hclk_freq_080025ec(void)\n\n{\n  uint32_t hclk_freq;\n  \n  hclk_freq = HAL_RCC_GetHCLKFreq();\n  return hclk_freq >> \"\"[(uint)(_DAT_40023808 << 0x13) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_080025ec": "get_hclk_freq_080025ec",
                "uVar1": "hclk_freq"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800260c": {
            "entrypoint": "0x0800260c",
            "current_name": "get_hclk_frequency_0800260c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_HCLK_frequency_0800260c(void)\n\n{\n  uint32_t HCLK_frequency;\n  \n  HCLK_frequency = HAL_RCC_GetHCLKFreq();\n  return HCLK_frequency >> \"\"[(uint)(_DAT_40023808 << 0x10) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_0800260c": "get_hclk_frequency_0800260c",
                "uVar1": "HCLK_frequency"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800262c": {
            "entrypoint": "0x0800262c",
            "current_name": "update_rtc_0800262c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid update_RTC_0800262c(RTC_HandleTypeDef *rtc_handle)\n\n{\n  if (((rtc_handle->Instance->ISR & 0x100) != 0) && ((rtc_handle->Instance->CR & 0x1000) != 0)) {\n    handle_RTC_AlarmAEventCallback(rtc_handle);\n    rtc_handle->Instance->ISR = rtc_handle->Instance->ISR & 0xff | 0xfffffe7f;\n  }\n  if (((rtc_handle->Instance->ISR & 0x200) != 0) && ((rtc_handle->Instance->CR & 0x2000) != 0)) {\n    handle_RTC_AlarmBEventCallback(rtc_handle);\n    rtc_handle->Instance->ISR = rtc_handle->Instance->ISR & 0xff | 0xfffffd7f;\n  }\n  _DAT_40013c14 = 0x20000;\n  rtc_handle->State = HAL_RTC_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800262c": "update_rtc_0800262c",
                "hrtc": "rtc_handle",
                "HAL_RTC_AlarmAEventCallback": "handle_RTC_AlarmAEventCallback",
                "HAL_RTCEx_AlarmBEventCallback": "handle_RTC_AlarmBEventCallback"
            },
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "called": [
                "HAL_RTC_AlarmAEventCallback",
                "HAL_RTCEx_AlarmBEventCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800268c": {
            "entrypoint": "0x0800268c",
            "current_name": "FUNC_0800268c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800268c(RTC_HandleTypeDef *hrtc)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800268c": "FUNC_0800268c"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800268e": {
            "entrypoint": "0x0800268e",
            "current_name": "reset_timer_0800268e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef resetTimer_0800268e(timerHandle *pTimer)\n\n{\n  TimerType *currentTimer;\n  \n  pTimer->State = TIMER_STATE_BUSY;\n  currentTimer = pTimer->Instance;\n  if (((currentTimer->CCER & 0x1111) == 0) && ((currentTimer->CCER & 0x444) == 0)) {\n    currentTimer->CR1 = currentTimer->CR1 & 0xfffffffe;\n  }\n  HAL_TIM_PWM_MspDeInit(pTimer);\n  pTimer->State = TIMER_STATE_RESET;\n  pTimer->Lock = LOCK_UNLOCKED;\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_0800268e": "reset_timer_0800268e",
                "TIM_HandleTypeDef": "timerHandle",
                "htim": "pTimer",
                "TIM_TypeDef": "TimerType",
                "pTVar1": "currentTimer",
                "HAL_TIM_STATE_BUSY": "TIMER_STATE_BUSY",
                "HAL_TIM_STATE_RESET": "TIMER_STATE_RESET",
                "HAL_UNLOCKED": "LOCK_UNLOCKED",
                "HAL_OK": "OK"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080026c8": {
            "entrypoint": "0x080026c8",
            "current_name": "FUNC_080026c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080026c8(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026c8": "FUNC_080026c8"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026ca": {
            "entrypoint": "0x080026ca",
            "current_name": "FUNC_080026ca",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080026ca(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026ca": "FUNC_080026ca"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026cc": {
            "entrypoint": "0x080026cc",
            "current_name": "FUNC_080026cc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080026cc(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026cc": "FUNC_080026cc"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026ce": {
            "entrypoint": "0x080026ce",
            "current_name": "handle_tim_interrupts_080026ce",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimInterrupts_080026ce(TIM_HandleTypeDef *timHandle)\n\n{\n  TIM_TypeDef *timInstance;\n  \n  timInstance = timHandle->Instance;\n  if (((timInstance->SR & 2) != 0) && ((timInstance->DIER & 2) != 0)) {\n    timInstance->SR = 0xfffffffd;\n    timHandle->Channel = activeChannel1;\n    if ((timHandle->Instance->CCMR1 & 3) == 0) {\n      handleOcDelayElapsed(timHandle);\n      handlePwmPulseFinished(timHandle);\n    }\n    else {\n      handleIcCapture(timHandle);\n    }\n    timHandle->Channel = activeChannelCleared;\n  }\n  timInstance = timHandle->Instance;\n  if (((timInstance->SR & 4) != 0) && ((timInstance->DIER & 4) != 0)) {\n    timInstance->SR = 0xfffffffb;\n    timHandle->Channel = activeChannel2;\n    if ((timHandle->Instance->CCMR1 & 0x300) == 0) {\n      handleOcDelayElapsed(timHandle);\n      handlePwmPulseFinished(timHandle);\n    }\n    else {\n      handleIcCapture(timHandle);\n    }\n    timHandle->Channel = activeChannelCleared;\n  }\n  timInstance = timHandle->Instance;\n  if (((timInstance->SR & 8) != 0) && ((timInstance->DIER & 8) != 0)) {\n    timInstance->SR = 0xfffffff7;\n    timHandle->Channel = activeChannel3;\n    if ((timHandle->Instance->CCMR2 & 3) == 0) {\n      handleOcDelayElapsed(timHandle);\n      handlePwmPulseFinished(timHandle);\n    }\n    else {\n      handleIcCapture(timHandle);\n    }\n    timHandle->Channel = activeChannelCleared;\n  }\n  timInstance = timHandle->Instance;\n  if (((timInstance->SR & 0x10) != 0) && ((timInstance->DIER & 0x10) != 0)) {\n    timInstance->SR = 0xffffffef;\n    timHandle->Channel = activeChannel4;\n    if ((timHandle->Instance->CCMR2 & 0x300) == 0) {\n      handleOcDelayElapsed(timHandle);\n      handlePwmPulseFinished(timHandle);\n    }\n    else {\n      handleIcCapture(timHandle);\n    }\n    timHandle->Channel = activeChannelCleared;\n  }\n  timInstance = timHandle->Instance;\n  if (((timInstance->SR & 1) != 0) && ((timInstance->DIER & 1) != 0)) {\n    timInstance->SR = 0xfffffffe;\n    handlePeriodElapsed(timHandle);\n  }\n  timInstance = timHandle->Instance;\n  if (((timInstance->SR & 0x80) != 0) && ((timInstance->DIER & 0x80) != 0)) {\n    timInstance->SR = 0xffffff7f;\n    handleExBreak(timHandle);\n  }\n  timInstance = timHandle->Instance;\n  if (((timInstance->SR & 0x40) != 0) && ((timInstance->DIER & 0x40) != 0)) {\n    timInstance->SR = 0xffffffbf;\n    handleTrigger(timHandle);\n  }\n  timInstance = timHandle->Instance;\n  if (((timInstance->SR & 0x20) != 0) && ((timInstance->DIER & 0x20) != 0)) {\n    timInstance->SR = 0xffffffdf;\n    handleExCommutation(timHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026ce": "handle_tim_interrupts_080026ce",
                "htim": "timHandle",
                "pTVar1": "timInstance",
                "HAL_TIM_ACTIVE_CHANNEL_1": "activeChannel1",
                "HAL_TIM_ACTIVE_CHANNEL_2": "activeChannel2",
                "HAL_TIM_ACTIVE_CHANNEL_3": "activeChannel3",
                "HAL_TIM_ACTIVE_CHANNEL_4": "activeChannel4",
                "HAL_TIM_ACTIVE_CHANNEL_CLEARED": "activeChannelCleared",
                "HAL_TIM_OC_DelayElapsedCallback": "handleOcDelayElapsed",
                "HAL_TIM_PWM_PulseFinishedCallback": "handlePwmPulseFinished",
                "HAL_TIM_IC_CaptureCallback": "handleIcCapture",
                "HAL_TIM_PeriodElapsedCallback": "handlePeriodElapsed",
                "HAL_TIMEx_BreakCallback": "handleExBreak",
                "HAL_TIM_TriggerCallback": "handleTrigger",
                "HAL_TIMEx_CommutationCallback": "handleExCommutation"
            },
            "calling": [
                "TIM3_IRQHandler",
                "TIM5_IRQHandler",
                "TIM1_UP_TIM10_IRQHandler",
                "TIM2_IRQHandler",
                "TIM6_DAC_IRQHandler",
                "TIM8_UP_TIM13_IRQHandler",
                "TIM4_IRQHandler",
                "TIM1_BRK_TIM9_IRQHandler",
                "TIM8_BRK_TIM12_IRQHandler",
                "TIM8_TRG_COM_TIM14_IRQHandler",
                "TIM7_IRQHandler",
                "TIM1_TRG_COM_TIM11_IRQHandler"
            ],
            "called": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIMEx_BreakCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002848": {
            "entrypoint": "0x08002848",
            "current_name": "configure_timer_channel_08002848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerChannel_08002848(TIM_TypeDef *timer,uint32_t channel,uint32_t state)\n\n{\n  timer->CCER = timer->CCER & ~(1 << (channel & 0xff));\n  timer->CCER = timer->CCER | state << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002848": "configure_timer_channel_08002848",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "state"
            },
            "calling": [
                "HAL_TIM_PWM_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002864": {
            "entrypoint": "0x08002864",
            "current_name": "disable_channel_and_configure_08002864",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef disableChannelAndConfigure_08002864(TIM_HandleTypeDef *timer,uint32_t channel)\n\n{\n  bool isTargetTimer;\n  TIM_TypeDef *targetTimer;\n  \n  TIM_CCxchannelCmd(timer->timerInstance,channel,0);\n  targetTimer = timer->timerInstance;\n  if (targetTimer == (TIM_TypeDef *)0x40010000) {\n    isTargetTimer = true;\n  }\n  else if (targetTimer == (TIM_TypeDef *)0x40010400) {\n    isTargetTimer = true;\n  }\n  else {\n    isTargetTimer = false;\n  }\n  if (((isTargetTimer) && ((targetTimer->CCER & 0x1111) == 0)) && ((targetTimer->CCER & 0x444) == 0)) {\n    targetTimer->BDTR = targetTimer->BDTR & 0xffff7fff;\n  }\n  targetTimer = timer->timerInstance;\n  if (((targetTimer->CCER & 0x1111) == 0) && ((targetTimer->CCER & 0x444) == 0)) {\n    targetTimer->CR1 = targetTimer->CR1 & 0xfffffffe;\n  }\n  timer->State = HAL_TIM_STATE_READY;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002864": "disable_channel_and_configure_08002864",
                "htim": "timer",
                "Channel": "channel",
                "bVar1": "isTargetTimer",
                "pTVar2": "targetTimer",
                "Instance": "timerInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028d4": {
            "entrypoint": "0x080028d4",
            "current_name": "update_channel_state_080028d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateChannelState_080028d4(TimerConfig *timer,uint32_t channel,uint32_t newState)\n\n{\n  timer->CCER = timer->CCER & ~(4 << (channel & 0xff));\n  timer->CCER = timer->CCER | newState << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080028d4": "update_channel_state_080028d4",
                "TIM_TypeDef": "TimerConfig",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelNState": "newState"
            },
            "calling": [
                "HAL_TIMEx_PWMN_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028f0": {
            "entrypoint": "0x080028f0",
            "current_name": "disable_tim_channel_080028f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef disableTimChannel_080028f0(TIM_HandleTypeDef *timerHandle,uint32_t channelNumber)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  TIM_CCxNchannelNumberCmd(timerHandle->Instance,channelNumber,0);\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->BDTR = timerInstance->BDTR & 0xffff7fff;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080028f0": "disable_tim_channel_080028f0",
                "htim": "timerHandle",
                "Channel": "channelNumber",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800293c": {
            "entrypoint": "0x0800293c",
            "current_name": "FUNC_0800293c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800293c(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800293c": "FUNC_0800293c"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800293e": {
            "entrypoint": "0x0800293e",
            "current_name": "FUNC_0800293e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800293e(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800293e": "FUNC_0800293e"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002940": {
            "entrypoint": "0x08002940",
            "current_name": "reset_uart_instance_08002940",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_uart_instance_08002940(UART_HandleTypeDef *uart_handle)\n\n{\n  uart_handle->Instance->control_register_1 = uart_handle->Instance->control_register_1 & 0xfffffedf;\n  uart_handle->Instance->control_register_3 = uart_handle->Instance->control_register_3 & 0xfffffffe;\n  uart_handle->receive_state = HAL_UART_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002940": "reset_uart_instance_08002940",
                "huart": "uart_handle",
                "CR1": "control_register_1",
                "CR3": "control_register_3",
                "RxState": "receive_state"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800295c": {
            "entrypoint": "0x0800295c",
            "current_name": "transmit_data_0800295c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef transmitData_0800295c(UART_HandleTypeDef *uartHandle)\n\n{\n  uint16_t count;\n  byte *bufferPtr;\n  uint16_t *tmpPtr;\n  \n  if (uartHandle->gState != HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  if ((uartHandle->Init).WordLength == 0x1000) {\n    uartHandle->Instance->DR = *(ushort *)uartHandle->pTxBuffPtr & 0x1ff;\n    if ((uartHandle->Init).Parity == 0) {\n      uartHandle->pTxBuffPtr = uartHandle->pTxBuffPtr + 2;\n    }\n    else {\n      uartHandle->pTxBuffPtr = uartHandle->pTxBuffPtr + 1;\n    }\n  }\n  else {\n    bufferPtr = uartHandle->pTxBuffPtr;\n    uartHandle->pTxBuffPtr = bufferPtr + 1;\n    uartHandle->Instance->DR = (uint)*bufferPtr;\n  }\n  count = uartHandle->TxXferCount - 1;\n  uartHandle->TxXferCount = count;\n  if (count == 0) {\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xffffff7f;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x40;\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800295c": "transmit_data_0800295c",
                "huart": "uartHandle",
                "uVar1": "count",
                "pbVar2": "bufferPtr",
                "tmp": "tmpPtr"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080029c8": {
            "entrypoint": "0x080029c8",
            "current_name": "configure_uart_080029c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureUart_080029c8(uartHandler *huart)\n\n{\n  uint32_t pclkFreq1;\n  uint32_t pclkFreq2;\n  uint32_t pclkFreq3;\n  uint32_t pclkFreq4;\n  uint32_t pclkFreq5;\n  uint32_t baudRate1;\n  uint32_t baudRate2;\n  uint32_t baudRate3;\n  uint32_t baudRate4;\n  USART_TypeDef *uart;\n  \n  huart->uartInstance->controlReg2 = huart->uartInstance->controlReg2 & 0xffffcfff | (huart->Init).stopBits;\n  huart->uartInstance->controlReg1 =\n       huart->uartInstance->controlReg1 & 0xffff69f3 |\n       (huart->Init).wordLength | (huart->Init).parity | (huart->Init).mode |\n       (huart->Init).overSampling;\n  huart->uartInstance->controlReg3 = huart->uartInstance->controlReg3 & 0xfffffcff | (huart->Init).hardwareFlowControl;\n  if ((huart->Init).overSampling == 0x8000) {\n    uart = huart->uartInstance;\n    if ((uart != (USART_TypeDef *)0x40011000) && (uart != (USART_TypeDef *)0x40011400)) {\n      pclkFreq1 = HAL_RCC_GetPCLK1Freq();\n      baudRate1 = (huart->Init).baudRate;\n      pclkFreq2 = HAL_RCC_GetPCLK1Freq();\n      baudRate2 = (huart->Init).baudRate;\n      pclkFreq3 = HAL_RCC_GetPCLK1Freq();\n      baudRate3 = (huart->Init).baudRate;\n      pclkFreq4 = HAL_RCC_GetPCLK1Freq();\n      baudRate4 = (huart->Init).baudRate;\n      pclkFreq5 = HAL_RCC_GetPCLK1Freq();\n      uart->BRR = ((uint)((int)((ulonglong)\n                                   (((pclkFreq4 * 0x19) / (baudRate4 << 1) +\n                                    (int)(((ulonglong)(pclkFreq5 * 0x19) /\n                                          (ulonglong)((huart->Init).baudRate << 1)) / 100) * -100) *\n                                    8 + 0x32) * 0x51eb851f >> 0x20) << 0x18) >> 0x1d) +\n                     ((((pclkFreq2 * 0x19) / (baudRate2 << 1) +\n                       (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(baudRate3 << 1)) / 100) * -100) *\n                       8 + 0x32) / 100 & 0xf8) * 2 +\n                     (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(baudRate1 << 1)) / 100) * 0x10;\n      return;\n    }\n    pclkFreq1 = HAL_RCC_GetPCLK2Freq();\n    baudRate1 = (huart->Init).baudRate;\n    pclkFreq2 = HAL_RCC_GetPCLK2Freq();\n    baudRate2 = (huart->Init).baudRate;\n    pclkFreq3 = HAL_RCC_GetPCLK2Freq();\n    baudRate3 = (huart->Init).baudRate;\n    pclkFreq4 = HAL_RCC_GetPCLK2Freq();\n    baudRate4 = (huart->Init).baudRate;\n    pclkFreq5 = HAL_RCC_GetPCLK2Freq();\n    uart->BRR = ((uint)((int)((ulonglong)\n                                 (((pclkFreq4 * 0x19) / (baudRate4 << 1) +\n                                  (int)(((ulonglong)(pclkFreq5 * 0x19) /\n                                        (ulonglong)((huart->Init).baudRate << 1)) / 100) * -100) * 8\n                                 + 0x32) * 0x51eb851f >> 0x20) << 0x18) >> 0x1d) +\n                   ((((pclkFreq2 * 0x19) / (baudRate2 << 1) +\n                     (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(baudRate3 << 1)) / 100) * -100) * 8\n                    + 0x32) / 100 & 0xf8) * 2 +\n                   (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(baudRate1 << 1)) / 100) * 0x10;\n    return;\n  }\n  uart = huart->uartInstance;\n  if ((uart != (USART_TypeDef *)0x40011000) && (uart != (USART_TypeDef *)0x40011400)) {\n    pclkFreq1 = HAL_RCC_GetPCLK1Freq();\n    baudRate1 = (huart->Init).baudRate;\n    pclkFreq2 = HAL_RCC_GetPCLK1Freq();\n    baudRate2 = (huart->Init).baudRate;\n    pclkFreq3 = HAL_RCC_GetPCLK1Freq();\n    baudRate3 = (huart->Init).baudRate;\n    pclkFreq4 = HAL_RCC_GetPCLK1Freq();\n    baudRate4 = (huart->Init).baudRate;\n    pclkFreq5 = HAL_RCC_GetPCLK1Freq();\n    uart->BRR = ((uint)((int)((ulonglong)\n                                 (((pclkFreq4 * 0x19) / (baudRate4 << 2) +\n                                  (int)(((ulonglong)(pclkFreq5 * 0x19) /\n                                        (ulonglong)((huart->Init).baudRate << 2)) / 100) * -100) *\n                                  0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                   ((((pclkFreq2 * 0x19) / (baudRate2 << 2) +\n                     (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(baudRate3 << 2)) / 100) * -100) *\n                     0x10 + 0x32) / 100 & 0xf0) +\n                   (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(baudRate1 << 2)) / 100) * 0x10;\n    return;\n  }\n  pclkFreq1 = HAL_RCC_GetPCLK2Freq();\n  baudRate1 = (huart->Init).baudRate;\n  pclkFreq2 = HAL_RCC_GetPCLK2Freq();\n  baudRate2 = (huart->Init).baudRate;\n  pclkFreq3 = HAL_RCC_GetPCLK2Freq();\n  baudRate3 = (huart->Init).baudRate;\n  pclkFreq4 = HAL_RCC_GetPCLK2Freq();\n  baudRate4 = (huart->Init).baudRate;\n  pclkFreq5 = HAL_RCC_GetPCLK2Freq();\n  uart->BRR = ((uint)((int)((ulonglong)\n                               (((pclkFreq4 * 0x19) / (baudRate4 << 2) +\n                                (int)(((ulonglong)(pclkFreq5 * 0x19) /\n                                      (ulonglong)((huart->Init).baudRate << 2)) / 100) * -100) *\n                                0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                 ((((pclkFreq2 * 0x19) / (baudRate2 << 2) +\n                   (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(baudRate3 << 2)) / 100) * -100) * 0x10\n                  + 0x32) / 100 & 0xf0) +\n                 (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(baudRate1 << 2)) / 100) * 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080029c8": "configure_uart_080029c8",
                "UART_HandleTypeDef": "uartHandler",
                "Instance": "uartInstance",
                "CR1": "controlReg1",
                "CR2": "controlReg2",
                "CR3": "controlReg3",
                "WordLength": "wordLength",
                "Parity": "parity",
                "Mode": "mode",
                "OverSampling": "overSampling",
                "StopBits": "stopBits",
                "HwFlowCtl": "hardwareFlowControl",
                "BaudRate": "baudRate",
                "pUVar10": "uart",
                "uVar1": "pclkFreq1",
                "uVar2": "pclkFreq2",
                "uVar3": "pclkFreq3",
                "uVar4": "pclkFreq4",
                "uVar5": "pclkFreq5",
                "uVar6": "baudRate1",
                "uVar7": "baudRate2",
                "uVar8": "baudRate3",
                "uVar9": "baudRate4"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d0c": {
            "entrypoint": "0x08002d0c",
            "current_name": "check_flag_status_08002d0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_expectedStatusTypeDef\ncheckFlagStatus_08002d0c(UART_HandleTypeDef *uartHandler,uint32_t flagsToCheck,flagsToCheckexpectedStatus expectedStatus,uint32_t startTick,\n            uint32_t timeout)\n\n{\n  uint32_t currentTick;\n  \n  do {\n    if (((flagsToCheck & ~uartHandler->Instance->SR) == 0) != (bool)expectedStatus) {\n      return HAL_OK;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - startTick <= timeout))));\n  uartHandler->Instance->CR1 = uartHandler->Instance->CR1 & 0xfffffe5f;\n  uartHandler->Instance->CR3 = uartHandler->Instance->CR3 & 0xfffffffe;\n  uartHandler->gState = HAL_UART_STATE_READY;\n  uartHandler->RxState = HAL_UART_STATE_READY;\n  uartHandler->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08002d0c": "check_flag_status_08002d0c",
                "huart": "uartHandler",
                "Flag": "flagsToCheck",
                "Status": "expectedStatus",
                "Tickstart": "startTick",
                "Timeout": "timeout",
                "uVar1": "currentTick"
            },
            "calling": [
                "HAL_UART_Transmit"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d70": {
            "entrypoint": "0x08002d70",
            "current_name": "FUNC_08002d70",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002d70(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d70": "FUNC_08002d70"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d72": {
            "entrypoint": "0x08002d72",
            "current_name": "initialize_uart_08002d72",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initialize_UART_08002d72(UART_HandleTypeDef *uart_handle)\n\n{\n  if (uart_handle != (UART_HandleTypeDef *)0x0) {\n    if (uart_handle->gState == HAL_UART_STATE_RESET) {\n      uart_handle->Lock = HAL_UNLOCKED;\n      HAL_UART_MspInit(uart_handle);\n    }\n    uart_handle->gState = HAL_UART_STATE_BUSY;\n    uart_handle->Instance->CR1 = uart_handle->Instance->CR1 & 0xffffdfff;\n    UART_SetConfig(uart_handle);\n    uart_handle->Instance->CR2 = uart_handle->Instance->CR2 & 0xffffb7ff;\n    uart_handle->Instance->CR3 = uart_handle->Instance->CR3 & 0xffffffd5;\n    uart_handle->Instance->CR1 = uart_handle->Instance->CR1 | 0x2000;\n    uart_handle->ErrorCode = 0;\n    uart_handle->gState = HAL_UART_STATE_READY;\n    uart_handle->RxState = HAL_UART_STATE_READY;\n    return success;\n  }\n  return error;\n}\n\n",
            "renaming": {
                "FUN_08002d72": "initialize_uart_08002d72",
                "huart": "uart_handle",
                "HAL_OK": "success",
                "HAL_ERROR": "error"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002dd0": {
            "entrypoint": "0x08002dd0",
            "current_name": "transmit_data_08002dd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\ntransmitData_08002dd0(UART_HandleTypeDef *uartHandler,uint8_t *data,uint16_t size,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTick;\n  uint16_t *temp;\n  \n  if (uartHandler->gState == UART_STATE_READY) {\n    if (data == (uint8_t *)0x0) {\n      status = ERROR;\n    }\n    else if (size == 0) {\n      status = ERROR;\n    }\n    else if (uartHandler->Lock == LOCKED) {\n      status = BUSY;\n    }\n    else {\n      uartHandler->Lock = LOCKED;\n      uartHandler->ErrorCode = 0;\n      uartHandler->gState = UART_STATE_BUSY_TX;\n      startTick = getTick();\n      uartHandler->TxXfersize = size;\n      uartHandler->TxXferCount = size;\n      while (uartHandler->TxXferCount != 0) {\n        uartHandler->TxXferCount = uartHandler->TxXferCount - 1;\n        if ((uartHandler->Init).WordLength == 0x1000) {\n          status = waitForFlagUntilTimeout(uartHandler,0x80,RESET,startTick,timeout);\n          if (status != HAL_OK) {\n            return TIMEOUT;\n          }\n          uartHandler->Instance->DR = *(ushort *)data & 0x1ff;\n          if ((uartHandler->Init).Parity == 0) {\n            data = (uint8_t *)((int)data + 2);\n          }\n          else {\n            data = (uint8_t *)((int)data + 1);\n          }\n        }\n        else {\n          status = waitForFlagUntilTimeout(uartHandler,0x80,RESET,startTick,timeout);\n          if (status != HAL_OK) {\n            return TIMEOUT;\n          }\n          uartHandler->Instance->DR = (uint)*data;\n          data = (uint8_t *)((int)data + 1);\n        }\n      }\n      status = waitForFlagUntilTimeout(uartHandler,0x40,RESET,startTick,timeout);\n      if (status == HAL_OK) {\n        uartHandler->gState = UART_STATE_READY;\n        uartHandler->Lock = HAL_UNLOCKED;\n        status = HAL_OK;\n      }\n      else {\n        status = TIMEOUT;\n      }\n    }\n  }\n  else {\n    status = BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002dd0": "transmit_data_08002dd0",
                "huart": "uartHandler",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "startTick",
                "tmp": "temp",
                "HAL_UART_STATE_READY": "UART_STATE_READY",
                "HAL_ERROR": "ERROR",
                "HAL_BUSY": "BUSY",
                "HAL_LOCKED": "LOCKED",
                "HAL_UART_STATE_BUSY_TX": "UART_STATE_BUSY_TX",
                "HAL_TIMEOUT": "TIMEOUT",
                "UART_WaitOnFlagUntilTimeout": "waitForFlagUntilTimeout",
                "HAL_GetTick": "getTick"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002eb2": {
            "entrypoint": "0x08002eb2",
            "current_name": "initialize_uart_transmission_08002eb2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nUART_StatusTypeDef initializeUartTransmission_08002eb2(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t size)\n\n{\n  if (uartHandle->gState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (data == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (size == 0) {\n    return HAL_ERROR;\n  }\n  if (uartHandle->Lock != HAL_LOCKED) {\n    uartHandle->pTxBuffPtr = data;\n    uartHandle->TxXfersize = size;\n    uartHandle->TxXferCount = size;\n    uartHandle->ErrorCode = 0;\n    uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n    uartHandle->Lock = HAL_UNLOCKED;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x80;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_08002eb2": "initialize_uart_transmission_08002eb2",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "size",
                "HAL_StatusTypeDef": "UART_StatusTypeDef"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "uart_attach_tx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002efa": {
            "entrypoint": "0x08002efa",
            "current_name": "initialize_uart_08002efa",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeUART_08002efa(UART_HandleTypeDef *uartHandler,uint8_t *dataBuffer,uint16_t bufferSize)\n\n{\n  if (uartHandler->RxState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (dataBuffer == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (bufferSize == 0) {\n    return HAL_ERROR;\n  }\n  if (uartHandler->Lock != HAL_LOCKED) {\n    uartHandler->pRxBuffPtr = dataBuffer;\n    uartHandler->RxXferbufferSize = bufferSize;\n    uartHandler->RxXferCount = bufferSize;\n    uartHandler->ErrorCode = 0;\n    uartHandler->RxState = HAL_UART_STATE_BUSY_RX;\n    uartHandler->Lock = HAL_UNLOCKED;\n    uartHandler->Instance->CR3 = uartHandler->Instance->CR3 | 1;\n    uartHandler->Instance->CR1 = uartHandler->Instance->CR1 | 0x120;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_08002efa": "initialize_uart_08002efa",
                "huart": "uartHandler",
                "pData": "dataBuffer",
                "Size": "bufferSize"
            },
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f4c": {
            "entrypoint": "0x08002f4c",
            "current_name": "reset_uart_state_08002f4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef reset_uart_state_08002f4c(UART_HandleTypeDef *uart_handle)\n\n{\n  uart_handle->uart_instance->control_register_1 = uart_handle->uart_instance->control_register_1 & 0xffffffbf;\n  uart_handle->uart_state = HAL_UART_STATE_READY;\n  uart_transmit_complete_callback(uart_handle);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002f4c": "reset_uart_state_08002f4c",
                "huart": "uart_handle",
                "Instance": "uart_instance",
                "CR1": "control_register_1",
                "gState": "uart_state",
                "HAL_UART_TxCpltCallback": "uart_transmit_complete_callback"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f66": {
            "entrypoint": "0x08002f66",
            "current_name": "receive_data_08002f66",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatus receiveData_08002f66(UART_HandleTypeDef *uartHandle)\n\n{\n  uint16_t *tempPointer;\n  byte *bytePointer;\n  uint16_t updatedVar;\n  uint8_t *uint8Pointer;\n  \n  if (uartHandle->RxState != UART_BUSY_RX) {\n    return Busy;\n  }\n  if ((uartHandle->Init).WordLength == 0x1000) {\n    if ((uartHandle->Init).Parity == 0) {\n      *(ushort *)uartHandle->pRxBuffPtr = (ushort)((uartHandle->Instance->DR << 0x17) >> 0x17);\n      uartHandle->pRxBuffPtr = uartHandle->pRxBuffPtr + 2;\n    }\n    else {\n      *(ushort *)uartHandle->pRxBuffPtr = (ushort)uartHandle->Instance->DR & 0xff;\n      uartHandle->pRxBuffPtr = uartHandle->pRxBuffPtr + 1;\n    }\n  }\n  else if ((uartHandle->Init).Parity == 0) {\n    uint8Pointer = uartHandle->pRxBuffPtr;\n    uartHandle->pRxBuffPtr = uint8Pointer + 1;\n    *uint8Pointer = (uint8_t)uartHandle->Instance->DR;\n  }\n  else {\n    bytePointer = uartHandle->pRxBuffPtr;\n    uartHandle->pRxBuffPtr = bytePointer + 1;\n    *bytePointer = (byte)uartHandle->Instance->DR & 0x7f;\n  }\n  updatedVar = uartHandle->RxXferCount - 1;\n  uartHandle->RxXferCount = updatedVar;\n  if (updatedVar != 0) {\n    return OK;\n  }\n  uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffedf;\n  uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n  uartHandle->RxState = UART_READY;\n  UART_RxCompleteCallback(uartHandle);\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_08002f66": "receive_data_08002f66",
                "huart": "uartHandle",
                "tmp": "tempPointer",
                "pbVar1": "bytePointer",
                "uVar2": "updatedVar",
                "puVar3": "uint8Pointer",
                "HAL_StatusTypeDef": "Status",
                "HAL_BUSY": "Busy",
                "HAL_OK": "OK",
                "HAL_UART_STATE_BUSY_RX": "UART_BUSY_RX",
                "HAL_UART_STATE_READY": "UART_READY",
                "HAL_UART_RxCpltCallback": "UART_RxCompleteCallback"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ffc": {
            "entrypoint": "0x08002ffc",
            "current_name": "process_uart_08002ffc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid process_UART_08002ffc(UART_HandleTypeDef *uart_handle)\n\n{\n  HAL_StatusTypeDef status;\n  uint cr1_reg_value;\n  uint32_t cr1its;\n  USART_TypeDef *uart_instance;\n  uint32_t cr3its;\n  uint cr3_bit;\n  uint sr_reg_value;\n  uint32_t interrupt_flags;\n  \n  uart_instance = uart_handle->Instance;\n  sr_reg_value = uart_instance->SR;\n  cr1_reg_value = uart_instance->CR1;\n  if ((((sr_reg_value & 0xf) == 0) && ((sr_reg_value & 0x20) != 0)) && ((cr1_reg_value & 0x20) != 0)) {\n    UART_Receive_IT(uart_handle);\n    return;\n  }\n  if (((sr_reg_value & 0xf) == 0) || ((cr3_bit = uart_instance->CR3 & 1, cr3_bit == 0 && ((cr1_reg_value & 0x120) == 0)))) {\n    if (((sr_reg_value & 0x80) != 0) && ((cr1_reg_value & 0x80) != 0)) {\n      UART_Transmit_IT(uart_handle);\n      return;\n    }\n    if (((sr_reg_value & 0x40) != 0) && ((cr1_reg_value & 0x40) != 0)) {\n      UART_EndTransmit_IT(uart_handle);\n    }\n  }\n  else {\n    if (((sr_reg_value & 1) != 0) && ((cr1_reg_value & 0x100) != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 1;\n    }\n    if (((sr_reg_value & 4) != 0) && (cr3_bit != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 2;\n    }\n    if (((sr_reg_value & 2) != 0) && (cr3_bit != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 4;\n    }\n    if (((sr_reg_value & 8) != 0) && (cr3_bit != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 8;\n    }\n    if (uart_handle->ErrorCode != 0) {\n      if (((sr_reg_value & 0x20) != 0) && ((cr1_reg_value & 0x20) != 0)) {\n        UART_Receive_IT(uart_handle);\n      }\n      if (((uart_handle->ErrorCode & 8) == 0) && ((uart_handle->Instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(uart_handle);\n        uart_handle->ErrorCode = 0;\n        return;\n      }\n      UART_EndRxTransfer(uart_handle);\n      uart_instance = uart_handle->Instance;\n      if ((uart_instance->CR3 & 0x40) == 0) {\n        HAL_UART_ErrorCallback(uart_handle);\n        return;\n      }\n      uart_instance->CR3 = uart_instance->CR3 & 0xffffffbf;\n      if (uart_handle->hdmarx == (DMA_HandleTypeDef *)0x0) {\n        HAL_UART_ErrorCallback(uart_handle);\n        return;\n      }\n      uart_handle->hdmarx->XferAbortCallback = UART_DMAAbortOnError + 1;\n      status = HAL_DMA_Abort_IT(uart_handle->hdmarx);\n      if (status != HAL_OK) {\n        (*uart_handle->hdmarx->XferAbortCallback)(uart_handle->hdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ffc": "process_uart_08002ffc",
                "huart": "uart_handle",
                "HVar1": "status",
                "uVar2": "cr1_reg_value",
                "uVar4": "cr3_bit",
                "uVar5": "sr_reg_value",
                "pUVar3": "uart_instance",
                "isrflags": "interrupt_flags"
            },
            "calling": [
                "USART3_IRQHandler",
                "USART6_IRQHandler",
                "UART7_IRQHandler",
                "UART4_IRQHandler",
                "UART8_IRQHandler",
                "USART1_IRQHandler",
                "USART2_IRQHandler",
                "UART5_IRQHandler"
            ],
            "called": [
                "UART_Receive_IT",
                "UART_Transmit_IT",
                "UART_EndRxTransfer",
                "UART_EndTransmit_IT",
                "HAL_UART_ErrorCallback",
                "HAL_DMA_Abort_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800311c": {
            "entrypoint": "0x0800311c",
            "current_name": "reset_uart_and_handle_errors_0800311c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetUartAndHandleErrors_0800311c(DMA_HandleTypeDef *dmaHandle)\n\n{\n  UART_HandleTypeDef *uartHandleParent;\n  UART_HandleTypeDef *uartHandle;\n  \n  uartHandleParent = (UART_HandleTypeDef *)dmaHandle->Parent;\n  uartHandleParent->RxXferCount = 0;\n  uartHandleParent->TxXferCount = 0;\n  HAL_UART_ErrorCallback(uartHandleParent);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800311c": "reset_uart_and_handle_errors_0800311c",
                "hdma": "dmaHandle",
                "huart_00": "uartHandleParent",
                "huart": "uartHandle"
            },
            "calling": [],
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800312c": {
            "entrypoint": "0x0800312c",
            "current_name": "combine_uart_states_0800312c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_UART_StateTypeDef combineUartStates_0800312c(UART_HandleTypeDef *uartHandle)\n\n{\n  return uartHandle->receiveState | uartHandle->globalState;\n}\n\n",
            "renaming": {
                "FUN_0800312c": "combine_uart_states_0800312c",
                "huart": "uartHandle",
                "RxState": "receiveState",
                "gState": "globalState"
            },
            "calling": [
                "serial_tx_active",
                "serial_rx_active"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003138": {
            "entrypoint": "0x08003138",
            "current_name": "check_pin_state_08003138",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool checkPinState_08003138(PinName_conflict pinName,uint32_t *pinMap)\n\n{\n  uint32_t selectedEntry;\n  \n  selectedEntry = pinMap[(uint)((int)pinName << 0x18) >> 0x1c];\n  return (_Bool)((byte)(selectedEntry >> ((int)pinName & 0xfU)) & 1);\n}\n\n",
            "renaming": {
                "FUN_08003138": "check_pin_state_08003138",
                "pin": "pinName",
                "map": "pinMap",
                "index": "selectedEntry"
            },
            "calling": [
                "pinMode",
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800314e": {
            "entrypoint": "0x0800314e",
            "current_name": "set_pin_in_map_0800314e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinInMap_0800314e(pin pin,uint32_t *pinMap)\n\n{\n  uint shiftedIndex;\n  uint32_t index;\n  \n  shiftedIndex = (uint)((int)pin << 0x18) >> 0x1c;\n  pinMap[shiftedIndex] = pinMap[shiftedIndex] | 1 << ((int)pin & 0xfU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800314e": "set_pin_in_map_0800314e",
                "PinName_conflict": "pin",
                "map": "pinMap",
                "uVar1": "shiftedIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800316c": {
            "entrypoint": "0x0800316c",
            "current_name": "clear_bit_in_map_0800316c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearBitInMap_0800316c(pin pin,uint32_t *map)\n\n{\n  uint shiftedPinIndex;\n  uint32_t index;\n  \n  shiftedPinIndex = (uint)((int)pin << 0x18) >> 0x1c;\n  map[shiftedPinIndex] = map[shiftedPinIndex] & ~(1 << ((int)pin & 0xfU));\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800316c": "clear_bit_in_map_0800316c",
                "PinName_conflict": "pin",
                "uVar1": "shiftedPinIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800318c": {
            "entrypoint": "0x0800318c",
            "current_name": "get_gpio_from_port_index_0800318c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nGPIOType * getGPIOFromPortIndex_0800318c(uint32_t portIndex)\n\n{\n  switch(portIndex) {\n  case 0:\n    return (GPIOType *)0x40020000;\n  case 1:\n    return (GPIOType *)0x40020400;\n  case 2:\n    return (GPIOType *)0x40020800;\n  case 3:\n    return (GPIOType *)0x40020c00;\n  case 4:\n    return (GPIOType *)0x40021000;\n  case 5:\n    return (GPIOType *)0x40021400;\n  case 6:\n    return (GPIOType *)0x40021800;\n  case 7:\n    return (GPIOType *)0x40021c00;\n  case 8:\n    return (GPIOType *)0x40022000;\n  case 9:\n    return (GPIOType *)0x40022400;\n  case 10:\n    return (GPIOType *)0x40022800;\n  default:\n    return (GPIOType *)0x0;\n  }\n}\n\n",
            "renaming": {
                "FUN_0800318c": "get_gpio_from_port_index_0800318c",
                "port_idx": "portIndex",
                "GPIO_TypeDef": "GPIOType"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080031fc": {
            "entrypoint": "0x080031fc",
            "current_name": "get_gpio_port_080031fc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * get_gpio_port_080031fc(uint32_t port_index)\n\n{\n  GPIO_TypeDef *gpio_port;\n  uint32_t temp_register;\n  uint32_t temp_register_1;\n  uint32_t temp_register_2;\n  uint32_t temp_register_3;\n  uint32_t temp_register_4;\n  uint32_t temp_register_5;\n  uint32_t temp_register_6;\n  uint32_t temp_register_7;\n  uint32_t temp_register_8;\n  uint32_t temp_register_9;\n  uint32_t temp_register_10;\n  \n  switch(port_index) {\n  case 0:\n    _DAT_40023830 = _DAT_40023830 | 1;\n    gpio_port = (GPIO_TypeDef *)0x40020000;\n    break;\n  case 1:\n    _DAT_40023830 = _DAT_40023830 | 2;\n    gpio_port = (GPIO_TypeDef *)0x40020400;\n    break;\n  case 2:\n    _DAT_40023830 = _DAT_40023830 | 4;\n    gpio_port = (GPIO_TypeDef *)0x40020800;\n    break;\n  case 3:\n    _DAT_40023830 = _DAT_40023830 | 8;\n    gpio_port = (GPIO_TypeDef *)0x40020c00;\n    break;\n  case 4:\n    _DAT_40023830 = _DAT_40023830 | 0x10;\n    gpio_port = (GPIO_TypeDef *)0x40021000;\n    break;\n  case 5:\n    _DAT_40023830 = _DAT_40023830 | 0x20;\n    gpio_port = (GPIO_TypeDef *)0x40021400;\n    break;\n  case 6:\n    _DAT_40023830 = _DAT_40023830 | 0x40;\n    gpio_port = (GPIO_TypeDef *)0x40021800;\n    break;\n  case 7:\n    _DAT_40023830 = _DAT_40023830 | 0x80;\n    gpio_port = (GPIO_TypeDef *)0x40021c00;\n    break;\n  case 8:\n    _DAT_40023830 = _DAT_40023830 | 0x100;\n    gpio_port = (GPIO_TypeDef *)0x40022000;\n    break;\n  case 9:\n    _DAT_40023830 = _DAT_40023830 | 0x200;\n    gpio_port = (GPIO_TypeDef *)0x40022400;\n    break;\n  case 10:\n    _DAT_40023830 = _DAT_40023830 | 0x400;\n    gpio_port = (GPIO_TypeDef *)0x40022800;\n    break;\n  default:\n    gpio_port = (GPIO_TypeDef *)0x0;\n  }\n  return gpio_port;\n}\n\n",
            "renaming": {
                "FUN_080031fc": "get_gpio_port_080031fc",
                "port_idx": "port_index",
                "pGVar1": "gpio_port",
                "tmpreg": "temp_register",
                "tmpreg_1": "temp_register_1",
                "tmpreg_2": "temp_register_2",
                "tmpreg_3": "temp_register_3",
                "tmpreg_4": "temp_register_4",
                "tmpreg_5": "temp_register_5",
                "tmpreg_6": "temp_register_6",
                "tmpreg_7": "temp_register_7",
                "tmpreg_8": "temp_register_8",
                "tmpreg_9": "temp_register_9",
                "tmpreg_10": "temp_register_10"
            },
            "calling": [
                "digital_io_init",
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003380": {
            "entrypoint": "0x08003380",
            "current_name": "get_dac_pin_function_08003380",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getDACPinFunction_08003380(PinName_conflict pinName)\n\n{\n  uint32_t pinFunctionIndex;\n  uint32_t shiftedFunction;\n  \n  pinFunctionIndex = pinNamemap_shiftedFunction(pinName,(DACPinMap *)&PinMap_DAC);\n  shiftedFunction = pinFunctionIndex << 0xc;\n  shiftedFunction = shiftedFunction >> 0x1b;\n  if (shiftedFunction != 2) {\n    return 0;\n  }\n  return 0x10;\n}\n\n",
            "renaming": {
                "FUN_08003380": "get_dac_pin_function_08003380",
                "pin": "pinName",
                "uVar1": "pinFunctionIndex",
                "function": "shiftedFunction",
                "PinMap_conflict": "DACPinMap"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800339c": {
            "entrypoint": "0x0800339c",
            "current_name": "pin_to_function_type_0800339c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t pin_to_function_type_0800339c(pin pin)\n\n{\n  uint32_t function_index;\n  uint32_t function_type;\n  \n  function_index = pinmap_function_type(pin,(pin_map *)&PinMap_PWM);\n  function_type = function_index << 0xc;\n  function_type = function_type >> 0x1b;\n  if (function_type == 3) {\n    return 8;\n  }\n  if (function_type != 4) {\n    if (function_type != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
            "renaming": {
                "FUN_0800339c": "pin_to_function_type_0800339c",
                "PinName_conflict": "pin",
                "PinMap_conflict": "pin_map",
                "uVar1": "function_index",
                "function": "function_type"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033c8": {
            "entrypoint": "0x080033c8",
            "current_name": "clear_dac_interrupt_flag_080033c8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid clearDacInterruptFlag_080033c8(DAC_HandleTypeDef *dacHandle)\n\n{\n  _DAT_40023840 = _DAT_40023840 & 0xdfffffff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033c8": "clear_dac_interrupt_flag_080033c8",
                "hdac": "dacHandle"
            },
            "calling": [
                "HAL_DAC_DeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033d8": {
            "entrypoint": "0x080033d8",
            "current_name": "stop_and_deinit_dac_080033d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopAndDeinitDAC_080033d8(pinName pin)\n\n{\n  uint32_t channel;\n  uint32_t dacchannel;\n  DAC_HandleTypeDef dacHandle;\n  \n  dacHandle.Instance = (DAC_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)&PinMap_DAC);\n  if ((dacHandle.Instance != (DAC_TypeDef *)0x0) &&\n     ((channel = get_dac_channel(pin), channel == 0 || (channel == 0x10)))) {\n    HAL_DAC_Stop(&dacHandle,channel);\n    HAL_DAC_DeInit(&dacHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033d8": "stop_and_deinit_dac_080033d8",
                "PinName_conflict": "pinName",
                "Channel": "channel",
                "DacHandle": "dacHandle"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_DAC_Stop",
                "get_dac_channel",
                "HAL_DAC_DeInit",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800340c": {
            "entrypoint": "0x0800340c",
            "current_name": "disable_timer_clock_0800340c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disableTimerClock_0800340c(TIM_HandleTypeDef *timerHandle)\n\n{\n  timer_disable_clock(timerHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800340c": "disable_timer_clock_0800340c",
                "htim": "timerHandle"
            },
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "called": [
                "timer_disable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003414": {
            "entrypoint": "0x08003414",
            "current_name": "stop_pwm_08003414",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopPwm_08003414(PinName_conflict pinName)\n\n{\n  uint32_t channel;\n  uint32_t timchannel;\n  uint32_t functionPinMap;\n  TIM_HandleTypeDef timHandler;\n  \n  timHandler.Instance = (TIM_TypeDef *)pinNamemap_peripheral(pinName,(PinMap_conflict *)&PinMap_PWM);\n  if ((timHandler.Instance != (TIM_TypeDef *)0x0) &&\n     ((((channel = get_pwm_channel(pinName), channel == 0 || (channel == 4)) || (channel == 8)) ||\n      ((channel == 0xc || (channel == 0x18)))))) {\n    functionPinMap = pinNamemap_function(pinName,(PinMap_conflict *)&PinMap_PWM);\n    if ((functionPinMap & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(&timHandler,channel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(&timHandler,channel);\n    }\n    HAL_TIM_PWM_DeInit(&timHandler);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003414": "stop_pwm_08003414",
                "pin": "pinName",
                "Channel": "channel",
                "uVar1": "functionPinMap",
                "timHandle": "timHandler"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "pinmap_function",
                "HAL_TIM_PWM_Stop",
                "get_pwm_channel",
                "HAL_TIM_PWM_DeInit",
                "pinmap_peripheral",
                "HAL_TIMEx_PWMN_Stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800346c": {
            "entrypoint": "0x0800346c",
            "current_name": "get_current_tick_0800346c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_tick_0800346c(void)\n\n{\n  uint32_t current_tick;\n  \n  current_tick = HAL_GetTick();\n  return current_tick;\n}\n\n",
            "renaming": {
                "FUN_0800346c": "get_current_tick_0800346c",
                "uVar1": "current_tick"
            },
            "calling": [
                "millis"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003474": {
            "entrypoint": "0x08003474",
            "current_name": "FUNC_08003474",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003474(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003474": "FUNC_08003474"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003476": {
            "entrypoint": "0x08003476",
            "current_name": "handle_system_tick_interrupt_08003476",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSystemTickInterrupt_08003476(void)\n\n{\n  incrementSystemTick();\n  handleSysTickInterrupt();\n  customSystickHandler();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003476": "handle_system_tick_interrupt_08003476",
                "HAL_IncTick": "incrementSystemTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTickInterrupt",
                "noOsSystickHandler": "customSystickHandler"
            },
            "calling": [],
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "noOsSystickHandler",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003486": {
            "entrypoint": "0x08003486",
            "current_name": "initialize_pin_08003486",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePin_08003486(PinName_conflict pinName,uint32_t pinMode,uint32_t pinPull)\n\n{\n  GPIO_TypeDef *GPIO_PORT;\n  GPIO_TypeDef *GPIO_port;\n  GPIO_InitTypeDef GPIO_initStruct;\n  \n  GPIO_PORT = set_GPIO_Port_Clock((uint)((int)pinName << 0x18) >> 0x1c);\n  GPIO_initStruct.Pin = 1 << ((int)pinName & 0xfU) & 0xffff;\n  GPIO_initStruct.Speed = 2;\n  GPIO_initStruct.Mode = pinMode;\n  GPIO_initStruct.Pull = pinPull;\n  HAL_GPIO_Init(GPIO_PORT,&GPIO_initStruct);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003486": "initialize_pin_08003486",
                "pin": "pinName",
                "mode": "pinMode",
                "pull": "pinPull",
                "GPIOx": "GPIO_PORT",
                "port": "GPIO_port",
                "GPIO_InitStructure": "GPIO_initStruct"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034b6": {
            "entrypoint": "0x080034b6",
            "current_name": "set_pin_state_080034b6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinState_080034b6(GPIO_TypeDef *gpioPort,uint32_t pinNumber,uint32_t state)\n\n{\n  if (state == 0) {\n    HAL_GPIO_WritePin(gpioPort,(uint16_t)pinNumber,GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(gpioPort,(uint16_t)pinNumber,GPIO_PIN_SET);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080034b6": "set_pin_state_080034b6",
                "port": "gpioPort",
                "pin": "pinNumber",
                "val": "state"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034ce": {
            "entrypoint": "0x080034ce",
            "current_name": "initialize_hardware_080034ce",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeHardware_080034ce(void)\n\n{\n  initializeHardware_080034ceAbstractionLayer();\n  configureSystemClock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080034ce": "initialize_hardware_080034ce",
                "HAL_Init": "initializeHardwareAbstractionLayer",
                "SystemClock_Config": "configureSystemClock"
            },
            "calling": [
                "init"
            ],
            "called": [
                "SystemClock_Config",
                "HAL_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034da": {
            "entrypoint": "0x080034da",
            "current_name": "find_peripheral_080034da",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * findPeripheral_080034da(PinName_conflict targetPin,PinMap_conflict *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->targetPin == NotConnected) {\n      return (void *)0x0;\n    }\n    if (pinMap->targetPin == targetPin) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->peripheral;\n}\n\n",
            "renaming": {
                "FUN_080034da": "find_peripheral_080034da",
                "pin": "targetPin",
                "map": "pinMap",
                "NC": "NotConnected"
            },
            "calling": [
                "pinmap_find_peripheral",
                "pinmap_peripheral"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034f4": {
            "entrypoint": "0x080034f4",
            "current_name": "find_peripheral_080034f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * find_peripheral_080034f4(PinName_conflict pin_name,PinMap_conflict *pin_map)\n\n{\n  void *result;\n  \n  if (pin_name != NC) {\n    result = pin_namepin_map_find_peripheral_080034f4(pin_name,pin_map);\n    return result;\n  }\n  return (void *)0x0;\n}\n\n",
            "renaming": {
                "FUN_080034f4": "find_peripheral_080034f4",
                "pin": "pin_name",
                "map": "pin_map",
                "pvVar1": "result"
            },
            "calling": [
                "uart_debug_write",
                "uart_debug_init",
                "dac_stop",
                "uart_init",
                "pwm_stop"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003506": {
            "entrypoint": "0x08003506",
            "current_name": "find_pin_by_peripheral_08003506",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict findPinByPeripheral_08003506(void *targetPeripheral,PinMap *pinMapArray)\n\n{\n  while( true ) {\n    if (pinMapArray->targetPeripheral == (void *)0x0) {\n      return NotConnected;\n    }\n    if (pinMapArray->targetPeripheral == targetPeripheral) break;\n    pinMapArray = pinMapArray + 1;\n  }\n  return pinMapArray->pin;\n}\n\n",
            "renaming": {
                "FUN_08003506": "find_pin_by_peripheral_08003506",
                "peripheral": "targetPeripheral",
                "PinMap_conflict": "PinMap",
                "map": "pinMapArray",
                "NC": "NotConnected"
            },
            "calling": [
                "pinmap_find_pin",
                "pinmap_pin"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800351e": {
            "entrypoint": "0x0800351e",
            "current_name": "find_pin_for_peripheral_0800351e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict find_pin_for_peripheral_0800351e(void *peripheral_ptr,PinMap *pinmap_ptr)\n\n{\n  PinName_conflict pin_found;\n  \n  if (peripheral_ptr != (void *)0x0) {\n    pin_found = pinpinmap_ptr_find_pin(peripheral_ptr,pinmap_ptr);\n    return pin_found;\n  }\n  return NC;\n}\n\n",
            "renaming": {
                "FUN_0800351e": "find_pin_for_peripheral_0800351e",
                "peripheral": "peripheral_ptr",
                "PinMap_conflict": "PinMap",
                "map": "pinmap_ptr",
                "PVar1": "pin_found"
            },
            "calling": [
                "HardwareSerial",
                "uart_debug_init"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800352e": {
            "entrypoint": "0x0800352e",
            "current_name": "find_pin_function_0800352e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t findPinFunction_0800352e(PinName_conflict targetPin,PinMap_conflict *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->targetPin == NotConnected) {\n      return 0xffffffff;\n    }\n    if (pinMap->targetPin == targetPin) breakLoop;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->pinFunction;\n}\n\n",
            "renaming": {
                "FUN_0800352e": "find_pin_function_0800352e",
                "pin": "targetPin",
                "map": "pinMap",
                "NC": "NotConnected",
                "break": "breakLoop",
                "function": "pinFunction"
            },
            "calling": [
                "pinmap_function",
                "pinmap_find_function"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800354a": {
            "entrypoint": "0x0800354a",
            "current_name": "find_pin_function_0800354a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t find_pin_function_0800354a(PinName_conflict pin_name,PinMap_conflict *pin_map)\n\n{\n  uint32_t found_function;\n  \n  if (pin_name == NC) {\n    return 0xffffffff;\n  }\n  found_function = pin_namepin_map_find_function(pin_name,pin_map);\n  return found_function;\n}\n\n",
            "renaming": {
                "FUN_0800354a": "find_pin_function_0800354a",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "found_function"
            },
            "calling": [
                "get_dac_channel",
                "get_pwm_channel",
                "uart_init",
                "pwm_stop"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800355e": {
            "entrypoint": "0x0800355e",
            "current_name": "check_pin_validity_0800355e",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool checkPinValidity_0800355e(PinName_conflict pinToCheck,PinMap_conflict *pinMap)\n\n{\n  if (pinToCheck == NotConnected) {\n    return false;\n  }\n  while( true ) {\n    if (pinMap->pinToCheck == NotConnected) {\n      return false;\n    }\n    if (pinToCheck == pinMap->pinToCheck) break;\n    pinMap = pinMap + 1;\n  }\n  return true;\n}\n\n",
            "renaming": {
                "FUN_0800355e": "check_pin_validity_0800355e",
                "pin": "pinToCheck",
                "map": "pinMap",
                "NC": "NotConnected"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003582": {
            "entrypoint": "0x08003582",
            "current_name": "merge_pointers_08003582",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * merge_pointers_08003582(void *a,void *b)\n\n{\n  if (a != b) {\n    if (a == (void *)0x0) {\n      return b;\n    }\n    if (b == (void *)0x0) {\n      return a;\n    }\n    a = (void *)0x0;\n  }\n  return a;\n}\n\n",
            "renaming": {
                "FUN_08003582": "merge_pointers_08003582"
            },
            "calling": [
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003594": {
            "entrypoint": "0x08003594",
            "current_name": "handle_rtc_callback_08003594",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_RTC_callback_08003594(RTC_HandleTypeDef *rtc_handle)\n\n{\n  if (user_callback != (callback_function_pointer)0x0) {\n    (*user_callback)(callback_data);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003594": "handle_rtc_callback_08003594",
                "hrtc": "rtc_handle",
                "RTCUserCallback": "user_callback",
                "voidCallbackPtr": "callback_function_pointer",
                "callbackUserData": "callback_data"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035ac": {
            "entrypoint": "0x080035ac",
            "current_name": "initialize_rtc_080035ac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeRTC_080035ac(void)\n\n{\n  HAL_RTC_AlarmIRQHandler(rtcHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035ac": "initialize_rtc_080035ac",
                "&RtcHandle": "rtcHandle"
            },
            "calling": [],
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035bc": {
            "entrypoint": "0x080035bc",
            "current_name": "initialize_data_080035bc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeData_080035bc(void)\n\n{\n  _DAT_40023808 = 0;\n  _DAT_40023804 = 0x24003010;\n  _DAT_40023800 = _DAT_40023800 & 0xfef2ffff | 1;\n  _DAT_4002380c = 0;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035bc": "initialize_data_080035bc"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fc": {
            "entrypoint": "0x080035fc",
            "current_name": "set_timer_instance_configuration_080035fc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setTimerInstanceConfiguration_080035fc(TIM_HandleTypeDef *timer)\n\n{\n  if (timer->timerInstance == (TIM_TypeDef *)0x40010000) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffffffe;\n  }\n  if (timer->timerInstance == (TIM_TypeDef *)0x40000000) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffe;\n  }\n  if (timer->timerInstance == (TIM_TypeDef *)0x40000400) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffd;\n  }\n  if (timer->timerInstance == (TIM_TypeDef *)0x40000800) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffb;\n  }\n  if (timer->timerInstance == (TIM_TypeDef *)0x40000c00) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffff7;\n  }\n  if (timer->timerInstance == (TIM_TypeDef *)0x40001000) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffef;\n  }\n  if (timer->timerInstance == (TIM_TypeDef *)0x40001400) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffdf;\n  }\n  if (timer->timerInstance == (TIM_TypeDef *)0x40010400) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffffffd;\n  }\n  if (timer->timerInstance == (TIM_TypeDef *)0x40014000) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffeffff;\n  }\n  if (timer->timerInstance == (TIM_TypeDef *)0x40014400) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffdffff;\n  }\n  if (timer->timerInstance == (TIM_TypeDef *)0x40014800) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffbffff;\n  }\n  if (timer->timerInstance == (TIM_TypeDef *)0x40001800) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffbf;\n  }\n  if (timer->timerInstance == (TIM_TypeDef *)0x40001c00) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffff7f;\n  }\n  if (timer->timerInstance == (TIM_TypeDef *)0x40002000) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffeff;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fc": "set_timer_instance_configuration_080035fc",
                "htim": "timer",
                "Instance": "timerInstance"
            },
            "calling": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003750": {
            "entrypoint": "0x08003750",
            "current_name": "get_stimer_pointer_08003750",
            "code": "\n/* WARNING: Unknown calling convention */\n\ntimer_struct * get_stimer_pointer_08003750(TIM_HandleTypeDef *timer_handle)\n\n{\n  return (timer_struct *)&timer_handle[-1].lock;\n}\n\n",
            "renaming": {
                "FUN_08003750": "get_stimer_pointer_08003750",
                "htim": "timer_handle",
                "stimer_t": "timer_struct",
                "Lock": "lock"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_OC_DelayElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003754": {
            "entrypoint": "0x08003754",
            "current_name": "handle_tim_overflow_interrupt_08003754",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_tim_overflow_interrupt_08003754(TIM_HandleTypeDef *tim_handle)\n\n{\n  stimer_t *timer_obj;\n  stimer_t *timer_obj;\n  \n  timer_obj = fetch_timer_object(tim_handle);\n  if ((timer_obj->interrupt_handle_OC != (_func_void_stimer_t_ptr_uint32_t *)0x0) &&\n     (tim_handle->Channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*timer_obj->interrupt_handle_OC)(timer_obj,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003754": "handle_tim_overflow_interrupt_08003754",
                "htim": "tim_handle",
                "psVar1": "timer_obj",
                "get_timer_obj": "fetch_timer_object",
                "obj": "timer_obj",
                "irqHandleOC": "interrupt_handle_OC"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800376e": {
            "entrypoint": "0x0800376e",
            "current_name": "handle_timer_irq_0800376e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerIRQ_0800376e(TIM_HandleTypeDef *timerHandler)\n\n{\n  stimer_t *timerObj;\n  stimer_t *timerObjPtr;\n  \n  timerObj = get_timer_timerObjPtr(timerHandler);\n  if (timerObj->irqHandle != (_func_void_stimer_t_ptr *)0x0) {\n    (*timerObj->irqHandle)(timerObj);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800376e": "handle_timer_irq_0800376e",
                "htim": "timerHandler",
                "psVar1": "timerObj",
                "obj": "timerObjPtr"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800377c": {
            "entrypoint": "0x0800377c",
            "current_name": "handle_timer_interrupts_0800377c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupts_0800377c(void)\n\n{\n  if (timerHandles[0] != (TIM_HandleTypeDef *)0x0) {\n    handleTimerIRQ(timerHandles[0]);\n  }\n  if (timerHandles[9] != (TIM_HandleTypeDef *)0x0) {\n    handleTimerIRQ(timerHandles[9]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800377c": "handle_timer_interrupts_0800377c",
                "timer_handles": "timerHandles",
                "HAL_TIM_IRQHandler": "handleTimerIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003798": {
            "entrypoint": "0x08003798",
            "current_name": "handle_timer_interrupt_08003798",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08003798(void)\n\n{\n  if (timerHandles[1] != (TimerHandleType *)0x0) {\n    handleTimerIRQ(timerHandles[1]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003798": "handle_timer_interrupt_08003798",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandleType",
                "HAL_TIM_IRQHandler": "handleTimerIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037ac": {
            "entrypoint": "0x080037ac",
            "current_name": "handle_timer_interrupt_080037ac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_080037ac(void)\n\n{\n  if (timerHandles[2] != (TimerHandle *)0x0) {\n    handleTimerIRQ(timerHandles[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037ac": "handle_timer_interrupt_080037ac",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleTimerIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037c0": {
            "entrypoint": "0x080037c0",
            "current_name": "handle_timer_interrupt_080037c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_timer_interrupt_080037c0(void)\n\n{\n  if (timer_handles[3] != (timer_handle_struct *)0x0) {\n    handle_timer_interrupt_080037c0_request(timer_handles[3]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037c0": "handle_timer_interrupt_080037c0",
                "TIM_HandleTypeDef": "timer_handle_struct",
                "HAL_TIM_IRQHandler": "handle_timer_interrupt_request"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037d4": {
            "entrypoint": "0x080037d4",
            "current_name": "handle_timer_interrupt_080037d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_080037d4(void)\n\n{\n  if (timerHandles[4] != (TimerHandle *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[4]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037d4": "handle_timer_interrupt_080037d4",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037e8": {
            "entrypoint": "0x080037e8",
            "current_name": "handle_timer_irq_080037e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerIRQ_080037e8(void)\n\n{\n  if (handles[5] != (TimerHandle *)0x0) {\n    processTimerIRQ(handles[5]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037e8": "handle_timer_irq_080037e8",
                "timer_handles": "handles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "processTimerIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037fc": {
            "entrypoint": "0x080037fc",
            "current_name": "handle_timer_irq_080037fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerIRQ_080037fc(void)\n\n{\n  if (timerHandles[6] != (TimerHandle *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[6]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037fc": "handle_timer_irq_080037fc",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003810": {
            "entrypoint": "0x08003810",
            "current_name": "handle_timer_ir_qs_08003810",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerIRQs_08003810(void)\n\n{\n  if (timerHandles[7] != (TimerHandle *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[7]);\n  }\n  if (timerHandles[12] != (TimerHandle *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[12]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003810": "handle_timer_ir_qs_08003810",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800382c": {
            "entrypoint": "0x0800382c",
            "current_name": "handle_timer_interrupt_0800382c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_0800382c(void)\n\n{\n  if (timerHandles[8] != (TimerHandle *)0x0) {\n    handleTimerIRQ(timerHandles[8]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800382c": "handle_timer_interrupt_0800382c",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleTimerIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003840": {
            "entrypoint": "0x08003840",
            "current_name": "handle_timer_irq_08003840",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerIRQ_08003840(void)\n\n{\n  if (timerHandles[10] != (TimerHandleType *)0x0) {\n    handleTimerInterrupt(timerHandles[10]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003840": "handle_timer_irq_08003840",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandleType",
                "HAL_TIM_IRQHandler": "handleTimerInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003854": {
            "entrypoint": "0x08003854",
            "current_name": "handle_tim11_interrupt_08003854",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_TIM11_interrupt_08003854(void)\n\n{\n  if (timer_handles[11] != (TimerHandle *)0x0) {\n    handle_interrupt(timer_handles[11]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003854": "handle_tim11_interrupt_08003854",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handle_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003868": {
            "entrypoint": "0x08003868",
            "current_name": "handle_timer_interrupt_08003868",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08003868(void)\n\n{\n  if (timers[13] != (TimerHandle *)0x0) {\n    HAL_TIM_IRQHandler(timers[13]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003868": "handle_timer_interrupt_08003868",
                "timer_handles": "timers",
                "TIM_HandleTypeDef": "TimerHandle"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800387c": {
            "entrypoint": "0x0800387c",
            "current_name": "get_i2c_t_from_hi2c_0800387c",
            "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_struct * get_i2c_t_from_hi2c_0800387c(I2C_HandleTypeDef *i2c_handle)\n\n{\n  return (i2c_struct *)&i2c_handle[-1].event_count;\n}\n\n",
            "renaming": {
                "FUN_0800387c": "get_i2c_t_from_hi2c_0800387c",
                "hi2c": "i2c_handle",
                "i2c_t": "i2c_struct",
                "EventCount": "event_count"
            },
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003880": {
            "entrypoint": "0x08003880",
            "current_name": "handle_i2c_transfer_08003880",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_i2c_transfer_08003880(I2C_HandleTypeDef *i2c_handle,uint8_t transfer_direction,uint16_t address_match_code)\n\n{\n  i2c_t *i2c_object;\n  i2c_t *i2c_object_temp;\n  \n  i2c_object = get_i2c_i2c_object_temp(i2c_handle);\n  if ((uint)address_match_code == (i2c_handle->Init).OwnAddress1) {\n    if (transfer_direction == '\\0') {\n      i2c_object->i2cTxRxBufferSize = '\\0';\n      i2c_object->slaveMode = '\\0';\n      if (i2c_object->i2c_onSlaveTransmit != (_func_void *)0x0) {\n        (*i2c_object->i2c_onSlaveTransmit)();\n      }\n      HAL_I2C_Slave_Sequential_Transmit_IT\n                (i2c_handle,i2c_object->i2cTxRxBuffer,(ushort)i2c_object->i2cTxRxBufferSize,8);\n      return;\n    }\n    i2c_object->slaveMode = '\\x01';\n    HAL_I2C_Slave_Sequential_Receive_IT(i2c_handle,i2c_object->i2cTxRxBuffer,0x20,8);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003880": "handle_i2c_transfer_08003880",
                "hi2c": "i2c_handle",
                "TransferDirection": "transfer_direction",
                "AddrMatchCode": "address_match_code",
                "piVar1": "i2c_object",
                "obj": "i2c_object_temp"
            },
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "HAL_I2C_Slave_Sequential_Transmit_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080038d0": {
            "entrypoint": "0x080038d0",
            "current_name": "enable_slave_receive_interrupt_080038d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableSlaveReceiveInterrupt_080038d0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2c_t *i2cObject;\n  i2c_t *i2cObject;\n  uint availableSpace;\n  \n  i2cObject = get_i2c_i2cObject(i2cHandle);\n  if (((i2cObject->i2c_onSlaveReceive != (_func_void_uint8_t_ptr_int *)0x0) &&\n      (i2cObject->slaveMode == '\\x01')) &&\n     (availableSpace = 0x20 - *(byte *)&(i2cObject->handle).XferSize & 0xff, availableSpace != 0)) {\n    (*i2cObject->i2c_onSlaveReceive)(i2cObject->i2cTxRxBuffer,availableSpace);\n  }\n  HAL_I2C_EnableListen_IT(i2cHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080038d0": "enable_slave_receive_interrupt_080038d0",
                "hi2c": "i2cHandle",
                "piVar1": "i2cObject",
                "obj": "i2cObject",
                "uVar2": "availableSpace"
            },
            "calling": [
                "I2C_Slave_STOPF",
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003900": {
            "entrypoint": "0x08003900",
            "current_name": "enable_i2_c_listen_mode_08003900",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableI2CListenMode_08003900(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2c_t *i2cObject;\n  i2c_t *i2cObject;\n  \n  i2cObject = get_i2c_i2cObject(i2cHandle);\n  if (i2cObject->isMasterDevice == '\\0') {\n    HAL_I2C_EnableListen_IT(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003900": "enable_i2_c_listen_mode_08003900",
                "hi2c": "i2cHandle",
                "piVar1": "i2cObject",
                "obj": "i2cObject",
                "isMaster": "isMasterDevice"
            },
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003918": {
            "entrypoint": "0x08003918",
            "current_name": "handle_i2_c_event_08003918",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvent_08003918(void)\n\n{\n  processI2CEvent(handlePtr);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003918": "handle_i2_c_event_08003918",
                "i2c_handles": "handlePtr",
                "HAL_I2C_EV_IRQHandler": "processI2CEvent"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003928": {
            "entrypoint": "0x08003928",
            "current_name": "handle_i2_c_error_interrupt_08003928",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CErrorInterrupt_08003928(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c_handles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003928": "handle_i2_c_error_interrupt_08003928"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003938": {
            "entrypoint": "0x08003938",
            "current_name": "handle_i2_c_event_08003938",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvent_08003938(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2c2ErrorHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003938": "handle_i2_c_event_08003938",
                "I2C2_ER_IRQHandler::handle": "i2c2ErrorHandler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003948": {
            "entrypoint": "0x08003948",
            "current_name": "handle_i2_c_error_08003948",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CError_08003948(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c2ERHandlerHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003948": "handle_i2_c_error_08003948",
                "I2C2_ER_IRQHandler::handle": "i2c2ERHandlerHandle"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003958": {
            "entrypoint": "0x08003958",
            "current_name": "process_i2_c_event_08003958",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processI2CEvent_08003958(void)\n\n{\n  handleI2CEventIRQ(I2C3ErrorHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003958": "process_i2_c_event_08003958",
                "HAL_I2C_EV_IRQHandler": "handleI2CEventIRQ",
                "I2C3_ER_IRQHandler::handle": "I2C3ErrorHandle"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003968": {
            "entrypoint": "0x08003968",
            "current_name": "handle_i2_c_error_08003968",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CError_08003968(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2cErrorHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003968": "handle_i2_c_error_08003968",
                "I2C3_ER_IRQHandler::handle": "i2cErrorHandler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003978": {
            "entrypoint": "0x08003978",
            "current_name": "initialize_serial_port_08003978",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialPort_08003978(serial_t *serialPort)\n\n{\n  void *a;\n  USART_TypeDef *txUart;\n  void *b;\n  USART_TypeDef *rxUart;\n  USART_TypeDef *selectedUart;\n  GPIO_TypeDef *selectedGpio;\n  GPIO_TypeDef *gpioPort;\n  uint32_t pinFunction;\n  UART_HandleTypeDef *uartHandle;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  if (serialPort != (serial_t *)0x0) {\n    a = pinmap_peripheral(serialPort->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n    b = pinmap_peripheral(serialPort->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(\"ERROR: at least one UART pin has no peripheral\\n\");\n    }\n    else {\n      selectedUart = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      serialPort->uart = selectedUart;\n      if (selectedUart == (USART_TypeDef *)0x0) {\n        iprintf(\"ERROR: U(S)ART pins mismatch\\n\");\n      }\n      else {\n        if (selectedUart == (USART_TypeDef *)0x40011000) {\n          _DAT_40023824 = _DAT_40023824 & 0xffffffef;\n          _DAT_40023844 = _DAT_40023844 | 0x10;\n          serialPort->index = '\\0';\n          serialPort->irq = USART1_IRQn;\n        }\n        else if (selectedUart == (USART_TypeDef *)0x40004400) {\n          _DAT_40023820 = _DAT_40023820 & 0xfffdffff;\n          _DAT_40023840 = _DAT_40023840 | 0x20000;\n          serialPort->index = '\\x01';\n          serialPort->irq = USART2_IRQn;\n        }\n        else if (selectedUart == (USART_TypeDef *)0x40004800) {\n          _DAT_40023820 = _DAT_40023820 & 0xfffbffff;\n          _DAT_40023840 = _DAT_40023840 | 0x40000;\n          serialPort->index = '\\x02';\n          serialPort->irq = USART3_IRQn;\n        }\n        else if (selectedUart == (USART_TypeDef *)0x40004c00) {\n          _DAT_40023820 = _DAT_40023820 & 0xfff7ffff;\n          _DAT_40023840 = _DAT_40023840 | 0x80000;\n          serialPort->index = '\\x03';\n          serialPort->irq = UART4_IRQn;\n        }\n        else if (selectedUart == (USART_TypeDef *)0x40005000) {\n          _DAT_40023820 = _DAT_40023820 & 0xffefffff;\n          _DAT_40023840 = _DAT_40023840 | 0x100000;\n          serialPort->index = '\\x04';\n          serialPort->irq = UART5_IRQn;\n        }\n        else if (selectedUart == (USART_TypeDef *)0x40011400) {\n          _DAT_40023824 = _DAT_40023824 & 0xffffffdf;\n          _DAT_40023844 = _DAT_40023844 | 0x20;\n          serialPort->index = '\\x05';\n          serialPort->irq = USART6_IRQn;\n        }\n        else if (selectedUart == (USART_TypeDef *)0x40007800) {\n          _DAT_40023820 = _DAT_40023820 & 0xbfffffff;\n          _DAT_40023840 = _DAT_40023840 | 0x40000000;\n          serialPort->index = '\\x06';\n          serialPort->irq = UART7_IRQn;\n        }\n        else if (selectedUart == (USART_TypeDef *)0x40007c00) {\n          _DAT_40023820 = _DAT_40023820 & 0x7fffffff;\n          _DAT_40023840 = _DAT_40023840 | 0x80000000;\n          serialPort->index = '\\a';\n          serialPort->irq = UART8_IRQn;\n        }\n        selectedGpio = set_GPIO_Port_Clock((uint)((int)serialPort->pin_rx << 0x18) >> 0x1c);\n        pinFunction = pinmap_function(serialPort->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n        gpioInitStruct.Pin = 1 << (serialPort->pin_rx & 0xfU) & 0xffff;\n        gpioInitStruct.Mode = (pinFunction >> 3 & 1) << 4 | pinFunction & 7;\n        gpioInitStruct.Pull = (pinFunction << 0x1a) >> 0x1e;\n        gpioInitStruct.Alternate = (pinFunction << 0x11) >> 0x19;\n        gpioInitStruct.Speed = 3;\n        HAL_GPIO_Init(selectedGpio,&gpioInitStruct);\n        selectedGpio = set_GPIO_Port_Clock((uint)((int)serialPort->pin_tx << 0x18) >> 0x1c);\n        pinFunction = pinmap_function(serialPort->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n        gpioInitStruct.Pin = 1 << (serialPort->pin_tx & 0xfU) & 0xffff;\n        gpioInitStruct.Mode = (pinFunction >> 3 & 1) << 4 | pinFunction & 7;\n        gpioInitStruct.Pull = (pinFunction << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(selectedGpio,&gpioInitStruct);\n        uart_handlers[serialPort->index] = &serialPort->handle;\n        (serialPort->handle).Instance = serialPort->uart;\n        (serialPort->handle).Init.BaudRate = serialPort->baudrate;\n        (serialPort->handle).Init.WordLength = serialPort->databits;\n        (serialPort->handle).Init.StopBits = serialPort->stopbits;\n        (serialPort->handle).Init.Parity = serialPort->parity;\n        (serialPort->handle).Init.Mode = 0xc;\n        (serialPort->handle).Init.HwFlowCtl = 0;\n        (serialPort->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&serialPort->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003978": "initialize_serial_port_08003978",
                "obj": "serialPort",
                "uart_tx": "txUart",
                "uart_rx": "rxUart",
                "pUVar1": "selectedUart",
                "pGVar2": "selectedGpio",
                "port": "gpioPort",
                "uVar3": "pinFunction",
                "huart": "uartHandle",
                "GPIO_InitStruct": "gpioInitStruct"
            },
            "calling": [
                "begin",
                "uart_debug_init"
            ],
            "called": [
                "pinmap_function",
                "HAL_UART_Init",
                "pinmap_merge_peripheral",
                "HAL_GPIO_Init",
                "iprintf",
                "set_GPIO_Port_Clock",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003cc8": {
            "entrypoint": "0x08003cc8",
            "current_name": "initialize_serial_port_08003cc8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialPort_08003cc8(void)\n\n{\n  void *peripheralPtr;\n  \n  peripheralPtr = getPeripheral(pinId,(ConflictMap *)&UART_TX_PinMap);\n  if (peripheralPtr != (void *)0x0) {\n    peripheralPtr = getPeripheral(pinId,(ConflictMap *)&UART_TX_PinMap);\n    debugSerial.pin_rx = getPin(peripheralPtr,(ConflictMap *)&UART_RX_PinMap);\n    debugSerial.pin_tx = pinId;\n    debugSerial.baudrate = 0x2580;\n    debugSerial.parity = 0;\n    debugSerial.dataBits = 0;\n    debugSerial.stopbits = 0;\n    initializeUART(&debugSerial);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003cc8": "initialize_serial_port_08003cc8",
                "pvVar1": "peripheralPtr",
                "pinmap_peripheral": "getPeripheral",
                "PD_8": "pinId",
                "PinMap_conflict": "ConflictMap",
                "PinMap_UART_TX": "UART_TX_PinMap",
                "serial_debug": "debugSerial",
                "pinmap_pin": "getPin",
                "PinMap_UART_RX": "UART_RX_PinMap",
                "databits": "dataBits",
                "uart_init": "initializeUART"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "pinmap_pin",
                "uart_init",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d18": {
            "entrypoint": "0x08003d18",
            "current_name": "transmit_data_08003d18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nbufferSize_t transmitData_08003d18(uint8_t *dataBuffer,uint32_t bufferSize)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTick;\n  uint32_t tickstart;\n  void *peripheralPtr;\n  USART_TypeDef *peripheralInstance;\n  uint32_t currentTick;\n  uint uartIndex;\n  \n  startTick = HAL_GetTick();\n  peripheralPtr = pinmap_peripheral(PD_8,(PinMap_conflict *)&PinMap_UART_TX);\n  if (peripheralPtr == (void *)0x0) {\n    return 0;\n  }\n  uartIndex = 0;\n  while ((uartIndex < 10 &&\n         ((uart_handlers[uartIndex] == (UART_HandleTypeDef *)0x0 ||\n          (peripheralInstance = (USART_TypeDef *)pinmap_peripheral(PD_8,(PinMap_conflict *)&PinMap_UART_TX),\n          uart_handlers[uartIndex]->Instance != peripheralInstance))))) {\n    uartIndex = uartIndex + 1 & 0xff;\n  }\n  if (9 < uartIndex) {\n    if ((9 < serial_debug.index) && (uart_debug_init(), 9 < serial_debug.index)) {\n      return 0;\n    }\n    uartIndex = (uint)serial_debug.index;\n  }\n  do {\n    status = HAL_UART_Transmit(uart_handlers[uartIndex],dataBuffer,(uint16_t)bufferSize,1000);\n    if (status == HAL_OK) {\n      return bufferSize;\n    }\n    currentTick = HAL_GetTick();\n  } while (currentTick - startTick < 1000);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08003d18": "transmit_data_08003d18",
                "data": "dataBuffer",
                "size": "bufferSize",
                "HVar1": "status",
                "uVar2": "startTick",
                "pvVar3": "peripheralPtr",
                "pUVar4": "peripheralInstance",
                "uVar5": "currentTick",
                "uVar6": "uartIndex"
            },
            "calling": [
                "_write"
            ],
            "called": [
                "HAL_GetTick",
                "uart_debug_init",
                "HAL_UART_Transmit",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003dd0": {
            "entrypoint": "0x08003dd0",
            "current_name": "check_uart_status_08003dd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_status_08003dd0(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(handlers[serial_object->index]);\n  return (uart_state & 0x22) == 0x22;\n}\n\n",
            "renaming": {
                "FUN_08003dd0": "check_uart_status_08003dd0",
                "obj": "serial_object",
                "HVar1": "uart_state",
                "uart_handlers": "handlers"
            },
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003df4": {
            "entrypoint": "0x08003df4",
            "current_name": "check_uart_state_08003df4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_state_08003df4(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(handlers_array[serial_object->index]);\n  return (uart_state & 0x21) == 0x21;\n}\n\n",
            "renaming": {
                "FUN_08003df4": "check_uart_state_08003df4",
                "obj": "serial_object",
                "HVar1": "uart_state",
                "uart_handlers": "handlers_array"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e18": {
            "entrypoint": "0x08003e18",
            "current_name": "receive_data_from_serial_08003e18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint receiveDataFromSerial_08003e18(serial_t *serialObject,uchar *c)\n\n{\n  uint8_t rxActiveFlag;\n  \n  if (serialObject == (serial_t *)0x0) {\n    return -1;\n  }\n  rxActiveFlag = serial_rx_active(serialObject);\n  if (rxActiveFlag == '\\0') {\n    *c = serialObject->recv;\n    HAL_UART_Receive_IT(uart_handlers[serialObject->index],&serialObject->recv,1);\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08003e18": "receive_data_from_serial_08003e18",
                "obj": "serialObject",
                "uVar1": "rxActiveFlag"
            },
            "calling": [
                "_rx_complete_irq"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e54": {
            "entrypoint": "0x08003e54",
            "current_name": "initialize_serial_communication_08003e54",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_08003e54(serial_t *serialObject,_func_void_serial_t_ptr *serialCallback)\n\n{\n  byte indexValue;\n  uint8_t rxActive;\n  \n  if (serialObject != (serial_t *)0x0) {\n    rxActive = isSerialRxActive(serialObject);\n    if (rxActive == '\\0') {\n      indexValue = serialObject->index;\n      rxCallback[indexValue] = serialCallback;\n      rxCallbackObject[indexValue] = serialObject;\n      setInterruptPriority(serialObject->irq,0,1);\n      enableInterrupt(serialObject->irq);\n      receiveDataInterrupt(uart_handlers[serialObject->index],&serialObject->recv,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e54": "initialize_serial_communication_08003e54",
                "obj": "serialObject",
                "callback": "serialCallback",
                "bVar1": "indexValue",
                "uVar2": "rxActive",
                "serial_rx_active": "isSerialRxActive",
                "rx_callback": "rxCallback",
                "rx_callback_obj": "rxCallbackObject",
                "HAL_NVIC_SetPriority": "setInterruptPriority",
                "HAL_NVIC_EnableIRQ": "enableInterrupt",
                "HAL_UART_Receive_IT": "receiveDataInterrupt"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority",
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003eac": {
            "entrypoint": "0x08003eac",
            "current_name": "initialize_serial_communication_08003eac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_08003eac(serial_t *serialObject,_func_int_serial_t_ptr *callbackFunction)\n\n{\n  byte indexValue;\n  \n  if (serialObject != (serial_t *)0x0) {\n    indexValue = serialObject->index;\n    tx_callbackFunction[indexValue] = callbackFunction;\n    tx_callbackFunction_serialObject[indexValue] = serialObject;\n    HAL_NVIC_SetPriority(serialObject->irq,0,2);\n    HAL_NVIC_EnableIRQ(serialObject->irq);\n    HAL_UART_Transmit_IT(uart_handlers[serialObject->index],serialObject->tx_buff + serialObject->tx_tail,1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003eac": "initialize_serial_communication_08003eac",
                "obj": "serialObject",
                "callback": "callbackFunction",
                "bVar1": "indexValue"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f00": {
            "entrypoint": "0x08003f00",
            "current_name": "find_uart_handler_08003f00",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t find_uart_handler_08003f00(UART_HandleTypeDef *uart_handler)\n\n{\n  uint index;\n  \n  if (uart_handler == (UART_HandleTypeDef *)0x0) {\n    index = 10;\n  }\n  else {\n    index = 0;\n    while( true ) {\n      if (9 < index) {\n        return (uint8_t)index;\n      }\n      if (uart_handler == uart_handlers[index]) break;\n      index = index + 1 & 0xff;\n    }\n  }\n  return (uint8_t)index;\n}\n\n",
            "renaming": {
                "FUN_08003f00": "find_uart_handler_08003f00",
                "huart": "uart_handler",
                "uVar1": "index"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "HAL_UART_RxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f24": {
            "entrypoint": "0x08003f24",
            "current_name": "process_received_data_08003f24",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processReceivedData_08003f24(UART_HandleTypeDef *uartHandle)\n\n{\n  byte uartIndex;\n  uint8_t loopIndex;\n  uint convertedIndex;\n  \n  uartIndex = uart_loopIndex(uartHandle);\n  convertedIndex = (uint)uartIndex;\n  if (convertedIndex < 10) {\n    (*rx_callback[convertedIndex])(rx_callback_obj[convertedIndex]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f24": "process_received_data_08003f24",
                "huart": "uartHandle",
                "bVar1": "uartIndex",
                "index": "loopIndex",
                "uVar2": "convertedIndex"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f48": {
            "entrypoint": "0x08003f48",
            "current_name": "transmit_data_08003f48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitData_08003f48(UART_HandleTypeDef *uartHandle)\n\n{\n  byte uartIndex;\n  uint8_t serialIndex;\n  int callbackReturnValue;\n  serial_t *serialObject;\n  serial_t *callbackObject;\n  uint indexConverted;\n  \n  uartIndex = uart_serialIndex(uartHandle);\n  indexConverted = (uint)uartIndex;\n  callbackObject = tx_callback_serialObject[indexConverted];\n  if ((indexConverted < 10) && (callbackReturnValue = (*tx_callback[indexConverted])(callbackObject), callbackReturnValue != -1)) {\n    HAL_UART_Transmit_IT(uart_handlers[callbackObject->serialIndex],callbackObject->tx_buff + callbackObject->tx_tail,1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f48": "transmit_data_08003f48",
                "huart": "uartHandle",
                "bVar1": "uartIndex",
                "index": "serialIndex",
                "iVar3": "callbackReturnValue",
                "obj": "serialObject",
                "psVar4": "callbackObject",
                "uVar2": "indexConverted"
            },
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f94": {
            "entrypoint": "0x08003f94",
            "current_name": "initialize_uart_08003f94",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_uart_08003f94(UART_HandleTypeDef *uart_handle)\n\n{\n  uint32_t temporary_value;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f94": "initialize_uart_08003f94",
                "huart": "uart_handle",
                "tmpval": "temporary_value"
            },
            "calling": [
                "UART_DMAAbortOnError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fd4": {
            "entrypoint": "0x08003fd4",
            "current_name": "handle_usart1_irq_08003fd4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleUSART1IRQ_08003fd4(void)\n\n{\n  clearPendingIRQ(usart1IRQ);\n  handleIRQ(handlers[0]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fd4": "handle_usart1_irq_08003fd4",
                "USART1_IRQn": "usart1IRQ",
                "uart_handlers": "handlers",
                "HAL_NVIC_ClearPendingIRQ": "clearPendingIRQ",
                "HAL_UART_IRQHandler": "handleIRQ"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fec": {
            "entrypoint": "0x08003fec",
            "current_name": "handle_uart2_interrupt_08003fec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART2_interrupt_08003fec(void)\n\n{\n  clear_pending_interrupt(UART2_interrupt);\n  handle_UART_interrupt(UART_handler_1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fec": "handle_uart2_interrupt_08003fec",
                "USART2_IRQn": "UART2_interrupt",
                "uart_handlers[1]": "UART_handler_1",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "HAL_UART_IRQHandler": "handle_UART_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004004": {
            "entrypoint": "0x08004004",
            "current_name": "handle_usart3_interrupt_08004004",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_USART3_interrupt_08004004(void)\n\n{\n  clear_pending_interrupt(USART3_interrupt);\n  if (uart_handles[2] != (UART_HandleTypeDef *)0x0) {\n    handle_UART_interrupt(uart_handles[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004004": "handle_usart3_interrupt_08004004",
                "uart_handlers": "uart_handles",
                "USART3_IRQn": "USART3_interrupt",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "HAL_UART_IRQHandler": "handle_UART_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800401c": {
            "entrypoint": "0x0800401c",
            "current_name": "clear_pending_uart4_irq_0800401c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearPendingUart4IRQ_0800401c(void)\n\n{\n  clearPendingInterrupt(uart4InterruptNumber);\n  handleUartInterrupt(uartHandlers[3]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800401c": "clear_pending_uart4_irq_0800401c",
                "UART4_IRQn": "uart4InterruptNumber",
                "HAL_NVIC_ClearPendingIRQ": "clearPendingInterrupt",
                "HAL_UART_IRQHandler": "handleUartInterrupt",
                "uart_handlers": "uartHandlers"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004034": {
            "entrypoint": "0x08004034",
            "current_name": "handle_uart5_irq_08004034",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART5_IRQ_08004034(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(uart5_interrupt);\n  HAL_UART_IRQHandler(uart5_handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004034": "handle_uart5_irq_08004034",
                "UART5_IRQn": "uart5_interrupt",
                "uart_handlers[4]": "uart5_handler"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800404c": {
            "entrypoint": "0x0800404c",
            "current_name": "handle_uart6_irq_0800404c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART6_IRQ_0800404c(void)\n\n{\n  clear_pending_IRQ(uart6_IRQ);\n  handle_UART_IRQ(uart_handlers[5]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800404c": "handle_uart6_irq_0800404c",
                "USART6_IRQn": "uart6_IRQ",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_IRQ",
                "HAL_UART_IRQHandler": "handle_UART_IRQ"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004064": {
            "entrypoint": "0x08004064",
            "current_name": "handle_uart7_interrupt_08004064",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART7_interrupt_08004064(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(uart7_interrupt);\n  HAL_UART_IRQHandler(uart_handler_6);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004064": "handle_uart7_interrupt_08004064",
                "UART7_IRQn": "uart7_interrupt",
                "uart_handlers[6]": "uart_handler_6"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800407c": {
            "entrypoint": "0x0800407c",
            "current_name": "handle_uart8_interrupt_0800407c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART8_interrupt_0800407c(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(UART8_interrupt_number);\n  HAL_UART_IRQHandler(UART_handlers_array[7]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800407c": "handle_uart8_interrupt_0800407c",
                "UART8_IRQn": "UART8_interrupt_number",
                "uart_handlers": "UART_handlers_array"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004094": {
            "entrypoint": "0x08004094",
            "current_name": "allocate_memory_08004094",
            "code": "\nvoid * allocate_memory_08004094(intptr_t memory_size)\n\n{\n  char *previous_heap_end;\n  char *previous_heap_end;\n  \n  if (_sbrk::heap_end == (char *)0x0) {\n    _sbrk::heap_end = &_ebss;\n  }\n  previous_heap_end = _sbrk::heap_end;\n  if (_sbrk::heap_end + memory_size <= &stack0x00000000) {\n    _sbrk::heap_end = _sbrk::heap_end + memory_size;\n    return previous_heap_end;\n  }\n  errno = 0xc;\n  return (void *)0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08004094": "allocate_memory_08004094",
                "__delta": "memory_size",
                "pcVar1": "previous_heap_end",
                "prev_heap_end": "previous_heap_end"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040d0": {
            "entrypoint": "0x080040d0",
            "current_name": "check_file_status_080040d0",
            "code": "\nint checkFileStatus_080040d0(int fileDescriptor)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_080040d0": "check_file_status_080040d0",
                "__fd": "fileDescriptor"
            },
            "calling": [
                "_close_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040d6": {
            "entrypoint": "0x080040d6",
            "current_name": "set_file_info_080040d6",
            "code": "\nint setFileInfo_080040d6(int fileDescriptor,stat *fileStats)\n\n{\n  *(undefined4 *)((int)&fileStats->st_dev + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040d6": "set_file_info_080040d6",
                "__fd": "fileDescriptor",
                "__buf": "fileStats"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e0": {
            "entrypoint": "0x080040e0",
            "current_name": "check_file_descriptor_080040e0",
            "code": "\nint check_file_descriptor_080040e0(int file_descriptor)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080040e0": "check_file_descriptor_080040e0",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e4": {
            "entrypoint": "0x080040e4",
            "current_name": "determine_offset_080040e4",
            "code": "\n__off_t determineOffset_080040e4(int fileDescriptor,__off_t offsetValue,int referencePosition)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040e4": "determine_offset_080040e4",
                "__fd": "fileDescriptor",
                "__offset": "offsetValue",
                "__whence": "referencePosition"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e8": {
            "entrypoint": "0x080040e8",
            "current_name": "process_file_080040e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint process_file_080040e8(int unused_file,char *unused_pointer,int unused_length)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040e8": "process_file_080040e8",
                "file_UNUSED": "unused_file",
                "ptr_UNUSED": "unused_pointer",
                "len_UNUSED": "unused_length"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040ec": {
            "entrypoint": "0x080040ec",
            "current_name": "write_debug_to_uart_080040ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint write_debug_to_uart_080040ec(int file_descriptor,char *data_pointer,int data_length)\n\n{\n  size_t write_result;\n  \n  write_result = uart_debug_write((uint8_t *)data_pointer,data_length);\n  return write_result;\n}\n\n",
            "renaming": {
                "FUN_080040ec": "write_debug_to_uart_080040ec",
                "file_UNUSED": "file_descriptor",
                "ptr": "data_pointer",
                "len": "data_length",
                "sVar1": "write_result"
            },
            "calling": [
                "_write_r"
            ],
            "called": [
                "uart_debug_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040f8": {
            "entrypoint": "0x080040f8",
            "current_name": "infinite_loop_080040f8",
            "code": "\nvoid infiniteLoop_080040f8(int status)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080040f8": "infinite_loop_080040f8",
                "__status": "status"
            },
            "calling": [
                "abort",
                "_exit"
            ],
            "called": [
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040fc": {
            "entrypoint": "0x080040fc",
            "current_name": "set_errno_080040fc",
            "code": "\nint set_errno_080040fc(process_id_t process_id,int signal_number)\n\n{\n  errno = 0x16;\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_080040fc": "set_errno_080040fc",
                "__pid": "process_id",
                "__sig": "signal_number"
            },
            "calling": [
                "_kill_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800410c": {
            "entrypoint": "0x0800410c",
            "current_name": "get_process_id_0800410c",
            "code": "\n\n\nprocess_id get_process_id_0800410c(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0800410c": "get_process_id_0800410c",
                "__pid_t": "process_id"
            },
            "calling": [
                "_getpid_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004110": {
            "entrypoint": "0x08004110",
            "current_name": "configure_pin_08004110",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_08004110(uint32_t pinNumber,uint32_t pinMode)\n\n{\n  _Bool isConfigured;\n  PinName_conflict pinName;\n  \n  if (pinNumber < 0x60) {\n    pinName = *(PinName_conflict *)(&digitalPin + pinNumber * 2);\n  }\n  else {\n    pinName = NC;\n  }\n  if (pinName != NC) {\n    isConfigured = is_pinNamein_configured(pinName,outputPinConfigured);\n    if (isConfigured) {\n      isConfigured = pinNamein_in_pinNameinmapinName(pinName,(PinMapinName_conflict *)&dacPinMap);\n      if (isConfigured) {\n        dac_stopinName(pinName);\n      }\n      else {\n        isConfigured = pinNamein_in_pinNameinmapinName(pinName,(PinMapinName_conflict *)&pwmPinMap);\n        if (isConfigured) {\n          pinNamewm_stopinName(pinName);\n        }\n      }\n      reset_pinNamein_configured(pinName,outputPinConfigured);\n    }\n    switch(pinMode) {\n    case 0:\n      digital_io_init(pinName,0,0);\n      break;\n    case 1:\n      digital_io_init(pinName,1,0);\n      break;\n    case 2:\n      digital_io_init(pinName,0,1);\n      break;\n    case 3:\n      digital_io_init(pinName,0,2);\n    }\n    set_pinNamein_configured(pinName,digPinConfigured);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004110": "configure_pin_08004110",
                "ulPin": "pinNumber",
                "ulMode": "pinMode",
                "_Var1": "isConfigured",
                "p": "pinName",
                "g_anOutputPinConfigured": "outputPinConfigured",
                "PinMap_DAC": "dacPinMap",
                "PinMap_PWM": "pwmPinMap",
                "g_digPinConfigured": "digPinConfigured"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "pin_in_pinmap",
                "reset_pin_configured",
                "digital_io_init",
                "set_pin_configured",
                "dac_stop",
                "is_pin_configured",
                "pwm_stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041bc": {
            "entrypoint": "0x080041bc",
            "current_name": "configure_pin_080041bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_080041bc(uint32_t pinNumber,uint32_t pinValue)\n\n{\n  _Bool isConfigured;\n  GPIO_TypinConfeDef *gpioPort;\n  PinName_conflict pinConf;\n  uint pinConfig;\n  \n  if (pinNumber < 0x60) {\n    pinConfig = (uint)*(short *)(&digitalPin + pinNumber * 2);\n  }\n  else {\n    pinConfig = 0xffffffff;\n  }\n  if ((pinConfig != 0xffffffff) &&\n     (isConfigured = is_pinConfin_configured((PinName_conflict)pinConfig,g_digPinConfigured), isConfigured)) {\n    gpioPort = get_GPIO_Port((pinConfig << 0x18) >> 0x1c);\n    digital_io_write(gpioPort,1 << (pinConfig & 0xf) & 0xffff,pinValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041bc": "configure_pin_080041bc",
                "ulPin": "pinNumber",
                "ulVal": "pinValue",
                "port": "gpioPort",
                "p": "pinConf",
                "uVar2": "pinConfig",
                "_Var1": "isConfigured"
            },
            "calling": [
                "sendTxBuffer",
                "getRxBuffer",
                "begin"
            ],
            "called": [
                "digital_io_write",
                "get_GPIO_Port",
                "is_pin_configured"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004204": {
            "entrypoint": "0x08004204",
            "current_name": "get_current_milliseconds_08004204",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_milliseconds_08004204(void)\n\n{\n  uint32_t current_milliseconds;\n  \n  current_milliseconds = GetCurrentMilli();\n  return current_milliseconds;\n}\n\n",
            "renaming": {
                "FUN_08004204": "get_current_milliseconds_08004204",
                "uVar1": "current_milliseconds"
            },
            "calling": [
                "sendTxBuffer",
                "poll"
            ],
            "called": [
                "GetCurrentMilli"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800420c": {
            "entrypoint": "0x0800420c",
            "current_name": "update_tail_and_check_0800420c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint HardwareSerial::updateTailAndCheck_0800420c(serial_t_conflict *serial)\n\n{\n  ushort tail;\n  uint16_t maskedTail;\n  int nextTail;\n  \n  nextTail = serial->tx_tail + 1;\n  tail = (ushort)nextTail;\n  maskedTail = tail & 0x7f;\n  if (nextTail == 0) {\n    maskedTail = -(-tail & 0x7f);\n  }\n  serial->tx_tail = maskedTail;\n  if (serial->tx_head != serial->tx_tail) {\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_0800420c": "update_tail_and_check_0800420c",
                "obj": "serial",
                "iVar3": "nextTail",
                "uVar1": "tail",
                "uVar2": "maskedTail"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004240": {
            "entrypoint": "0x08004240",
            "current_name": "calculate_available_rx_bytes_08004240",
            "code": "\n/* DWARF original prototype: int  available(HardwareSerial * serial) */\n\nint __serialcall HardwareSerial::calculateAvailableRxBytes_08004240(HardwareSerial *serial)\n\n{\n  return ((serial->_serial).rx_head + 0x40) - (uint)(serial->_serial).rx_tail & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_08004240": "calculate_available_rx_bytes_08004240",
                "this": "serial"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004254": {
            "entrypoint": "0x08004254",
            "current_name": "peek_08004254",
            "code": "\n/* DWARF original prototype: int  peek_08004254(HardwareSerial * serial) */\n\nint __serialcall HardwareSerial::peek_08004254(HardwareSerial *serial)\n\n{\n  uint tail;\n  \n  tail = (uint)(serial->_serial).rx_tail;\n  if ((serial->_serial).head != tail) {\n    return (uint)(serial->_serial).buffer[tail];\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08004254": "peek_08004254",
                "this": "serial",
                "uVar1": "tail",
                "rx_head": "head",
                "rx_buff": "buffer"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004270": {
            "entrypoint": "0x08004270",
            "current_name": "read_byte_08004270",
            "code": "\n/* DWARF original prototype: int  read(HardwareSerial * serial) */\n\nssize_t __serialcall\nHardwareSerial::readByte_08004270(HardwareSerial *serial,int fileDescriptor,void *buffer,size_t numBytes)\n\n{\n  byte receivedByte;\n  ushort rxTail;\n  uchar c;\n  \n  rxTail = (serial->_serial).rx_tail;\n  if ((uint)(serial->_serial).rx_head != (uint)rxTail) {\n    receivedByte = (serial->_serial).rx_buff[rxTail];\n    (serial->_serial).rx_tail = rxTail + 1 & 0x3f;\n    return (uint)receivedByte;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "this": "serial",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "uVar2": "rxTail",
                "bVar1": "receivedByte",
                "FUN_08004270": "read_byte_08004270"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004298": {
            "entrypoint": "0x08004298",
            "current_name": "flush_serial_08004298",
            "code": "\n/* DWARF original prototype: void  flush(HardwareSerial * serial) */\n\nvoid __serialcall HardwareSerial::flush_serial_08004298(HardwareSerial *serial)\n\n{\n  if (serial->has_data_to_send != false) {\n    do {\n    } while ((serial->serial_port).transmit_head != (serial->serial_port).transmit_tail);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004298": "flush_serial_08004298",
                "this": "serial",
                "_written": "has_data_to_send",
                "_serial": "serial_port",
                "tx_head": "transmit_head",
                "tx_tail": "transmit_tail"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042ac": {
            "entrypoint": "0x080042ac",
            "current_name": "process_received_data_080042ac",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd HardwareSerindexal::processReceivedData_080042ac(serindexal_t_conflindexct *serialObject)\n\n{\n  indexnt receiveStatus;\n  rx_buffer_indexndex_t index;\n  ushort nextIndex;\n  uchar c;\n  \n  receiveStatus = uart_getc((serindexal_t *)serialObject,&c);\n  indexf ((receiveStatus == 0) && (nextIndex = serialObject->rx_head + 1 & 0x3f, nextIndex != serialObject->rx_taindexl)) {\n    serialObject->rx_buff[serialObject->rx_head] = c;\n    serialObject->rx_head = nextIndex;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080042ac": "process_received_data_080042ac",
                "obj": "serialObject",
                "iVar1": "receiveStatus",
                "i": "index",
                "uVar2": "nextIndex"
            },
            "calling": [],
            "called": [
                "uart_getc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042e8": {
            "entrypoint": "0x080042e8",
            "current_name": "write_to_serial_port_080042e8",
            "code": "\n/* DWARF orindexgindexnal prototype: sindexze_t  wrindexte(HardwareSerindexal * serialPort, uindexnt8_t c) */\n\nssindexze_t __serialPortcall\nHardwareSerindexal::writeToSerialPort_080042e8(HardwareSerindexal *serialPort,indexnt fileDescriptor,voindexd *buffer,sindexze_t length)\n\n{\n  byte byteVar1;\n  uindexnt8_t byteVar2;\n  byte byteVar3;\n  indexnt intVar;\n  uindexnt uintVar1;\n  bufferIndexType index;\n  \n  serialPort->isWritten = true;\n  uintVar1 = (uindexnt)(serialPort->serialData).transmitHead;\n  intVar = uintVar1 + 1;\n  byteVar1 = (byte)intVar;\n  byteVar3 = byteVar1 & 0x7f;\n  indexf (intVar == 0) {\n    byteVar3 = -(-byteVar1 & 0x7f);\n  }\n  do {\n  } whindexle ((serialPort->serialData).transmitTail == (ushort)byteVar3);\n  (serialPort->serialData).transmitBuffer[uintVar1] = (uindexnt8_t)fileDescriptor;\n  (serialPort->serialData).transmitHead = (ushort)byteVar3;\n  byteVar2 = isTransmittingActive((serindexal_t *)&serialPort->serialData);\n  indexf (byteVar2 == '\\0') {\n    attachTransmitCallback((serindexal_t *)&serialPort->serialData,transmitCompleteInterrupt + 1);\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "this": "serialPort",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__n": "length",
                "bVar1": "byteVar1",
                "uVar2": "byteVar2",
                "bVar3": "byteVar3",
                "iVar4": "intVar",
                "uVar5": "uintVar1",
                "i": "index",
                "_written": "isWritten",
                "_serial": "serialData",
                "tx_head": "transmitHead",
                "tx_buffer_index_t": "bufferIndexType",
                "tx_tail": "transmitTail",
                "tx_buff": "transmitBuffer",
                "serial_tx_active": "isTransmittingActive",
                "uart_attach_tx_callback": "attachTransmitCallback",
                "_tx_complete_irq": "transmitCompleteInterrupt",
                "FUN_080042e8": "write_to_serial_port_080042e8"
            },
            "calling": [],
            "called": [
                "uart_attach_tx_callback",
                "serial_tx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004338": {
            "entrypoint": "0x08004338",
            "current_name": "FUNC_08004338",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800433e) */\n/* WARNING: Removing unreachable block (ram,0x08004350) */\n/* WARNING: Removing unreachable block (ram,0x08004346) */\n/* WARNING: Removing unreachable block (ram,0x08004358) */\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004338(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004338": "FUNC_08004338"
            },
            "calling": [
                "main"
            ],
            "called": [
                "available"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004364": {
            "entrypoint": "0x08004364",
            "current_name": "initialize_serial_08004364",
            "code": "\n/* DWARF original prototype: void  init(HardwareSerial * serialObject) */\n\nint __serialObjectcall HardwareSerial::initializeSerial_08004364(HardwareSerial *serialObject,EVP_PKEY_CTX *context)\n\n{\n  (serialObject->_serial).rx_buff = serialObject->_rx_buffer;\n  (serialObject->_serial).rx_head = 0;\n  (serialObject->_serial).rx_tail = 0;\n  (serialObject->_serial).tx_buff = serialObject->_tx_buffer;\n  (serialObject->_serial).tx_head = 0;\n  (serialObject->_serial).tx_tail = 0;\n  return (int)serialObject;\n}\n\n",
            "renaming": {
                "FUN_08004364": "initialize_serial_08004364",
                "this": "serialObject",
                "ctx": "context"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004388": {
            "entrypoint": "0x08004388",
            "current_name": "configure_serial_port_08004388",
            "code": "\n/* DWARF original prototype: void  begin(HardwareSerial * serialPort, ulong baudRate, byte configuration) */\n\nvoid __serialPortcall HardwareSerial::configureSerialPort_08004388(HardwareSerial *serialPort,ulong baudRate,byte configuration)\n\n{\n  byte selectedConfig;\n  int dataBitsIndicator;\n  \n  (serialPort->_serial).baudRaterate = baudRate;\n  serialPort->_configuration = configuration;\n  selectedConfig = configuration & 7;\n  if (selectedConfig == 4) {\n    dataBitsIndicator = 7;\n  }\n  else if (selectedConfig == 6) {\n    dataBitsIndicator = 8;\n  }\n  else if (selectedConfig == 2) {\n    dataBitsIndicator = 6;\n  }\n  else {\n    dataBitsIndicator = 0;\n  }\n  if ((configuration & 0x30) == 0x30) {\n    (serialPort->_serial).parity = 0x600;\n    dataBitsIndicator = dataBitsIndicator + 1;\n  }\n  else if ((configuration & 0x20) == 0) {\n    (serialPort->_serial).parity = 0;\n  }\n  else {\n    (serialPort->_serial).parity = 0x400;\n    dataBitsIndicator = dataBitsIndicator + 1;\n  }\n  if ((configuration & 8) == 0) {\n    (serialPort->_serial).stopbits = 0;\n  }\n  else {\n    (serialPort->_serial).stopbits = 0x2000;\n  }\n  if (dataBitsIndicator == 8) {\n    (serialPort->_serial).databits = 0;\n  }\n  else if (dataBitsIndicator == 9) {\n    (serialPort->_serial).databits = 0x1000;\n  }\n  else {\n    dataBitsIndicator = 0;\n  }\n  if (dataBitsIndicator != 0) {\n    uart_init((serial_t *)&serialPort->_serial);\n    uart_attach_rx_callback((serial_t *)&serialPort->_serial,_rx_complete_irq + 1);\n    return;\n  }\n                    \n  __assert_func(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/cores/arduino/HardwareSerial.cpp\"\n                ,299,\"void HardwareSerial::begin(long unsigned int, byte)\",\"databits!=0\");\n}\n\n",
            "renaming": {
                "this": "serialPort",
                "baud": "baudRate",
                "config": "configuration",
                "bVar1": "selectedConfig",
                "iVar2": "dataBitsIndicator",
                "FUN_08004388": "configure_serial_port_08004388"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "uart_attach_rx_callback",
                "__assert_func",
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004444": {
            "entrypoint": "0x08004444",
            "current_name": "set_rx_08004444",
            "code": "\n/* DWARF original prototype: void  setRx_08004444(HardwareSerial * serialPort, uint32_t rxPin) */\n\nvoid __serialPortcall HardwareSerial::setRx_08004444(HardwareSerial *serialPort,uint32_t rxPin)\n\n{\n  PinName pinName;\n  \n  if (rxPin < 0x60) {\n    pinName = *(PinName *)(&digitalPins + rxPin * 2);\n  }\n  else {\n    pinName = NoConnection;\n  }\n  (serialPort->_serial).pinrxPin = pinName;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004444": "set_rx_08004444",
                "this": "serialPort",
                "_rx": "rxPin",
                "PVar1": "pinName",
                "digitalPin": "digitalPins",
                "NC": "NoConnection"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004460": {
            "entrypoint": "0x08004460",
            "current_name": "set_tx_pin_08004460",
            "code": "\n/* DWARF original prototype: void  setTx(HardwareSerial * this, uint32_t _tx) */\n\nvoid __thiscall HardwareSerial::setTxPin_08004460(HardwareSerial *this,uint32_t _tx)\n\n{\n  PinName PVar1;\n  \n  if (_tx < 0x60) {\n    PVar1 = *(PinName *)(&digitalPinArray + _tx * 2);\n  }\n  else {\n    PVar1 = NotConnected;\n  }\n  (this->_serial).pin_tx = PVar1;\n  return;\n}\n\n",
            "renaming": {
                "digitalPin": "digitalPinArray",
                "NC": "NotConnected",
                "FUN_08004460": "set_tx_pin_08004460"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800447c": {
            "entrypoint": "0x0800447c",
            "current_name": "initialize_hardware_serial_0800447c",
            "code": "\n/* DWARF original prototype: HardwareSerial *  HardwareSerial(HardwareSerial * serialObject, void *\n   peripheralDevice) */\n\nHardwareSerial * __serialObjectcall HardwareSerial::initializeHardwareSerial_0800447c(HardwareSerial *serialObject,void *peripheralDevice)\n\n{\n  PinName_conflict rxPin;\n  EVP_PKEY_CTX *ctx1;\n  EVP_PKEY_CTX *ctx2;\n  EVP_PKEY_CTX *ctx3;\n  \n  (serialObject->super_Stream).super_Print.write_error = 0;\n  (serialObject->super_Stream)._timeout = 1000;\n  (serialObject->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)&PTR_write_1_08005ed4;\n  if (serialObject == &Serial3) {\n    setRx(&Serial3,0x4c);\n    setTx(&Serial3,0x4d);\n    ctx2 = ctx3;\n  }\n  else {\n    rxPin = pinmap_pin(peripheralDevice,(PinMap_conflict *)&PinMap_UART_RX);\n    (serialObject->_serial).pin_rx = rxPin;\n    rxPin = pinmap_pin(peripheralDevice,(PinMap_conflict *)&PinMap_UART_TX);\n    (serialObject->_serial).pin_tx = rxPin;\n    ctx2 = ctx1;\n  }\n  init(serialObject,ctx2);\n  return serialObject;\n}\n\n",
            "renaming": {
                "this": "serialObject",
                "peripheral": "peripheralDevice",
                "PVar1": "rxPin",
                "extraout_r1": "ctx1",
                "ctx": "ctx2",
                "extraout_r1_00": "ctx3",
                "FUN_0800447c": "initialize_hardware_serial_0800447c"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "pinmap_pin",
                "init",
                "setTx",
                "setRx"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080044d8": {
            "entrypoint": "0x080044d8",
            "current_name": "initialize_serial_communication_080044d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_080044d8(int isInitializationRequired,int priorityLevel)\n\n{\n  if (isInitializationRequired != 1) {\n    return;\n  }\n  if (priorityLevel == 0xffff) {\n    initializeHardwareSerial(serialPortAddress,(void *)0x40004800);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080044d8": "initialize_serial_communication_080044d8",
                "__initialize_p": "isInitializationRequired",
                "__priority": "priorityLevel",
                "HardwareSerial::HardwareSerial": "initializeHardwareSerial",
                "&Serial3": "serialPortAddress"
            },
            "calling": [
                "_GLOBAL__sub_I_Serial3"
            ],
            "called": [
                "HardwareSerial"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080044fc": {
            "entrypoint": "0x080044fc",
            "current_name": "initialize_static_data_080044fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_080044fc(void)\n\n{\n  initialize_data(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080044fc": "initialize_static_data_080044fc",
                "__static_initialization_and_destruction_0": "initialize_data"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800450a": {
            "entrypoint": "0x0800450a",
            "current_name": "print_ip_address_0800450a",
            "code": "\n/* DWARF original printerrototyprintere: size_t  printerrintTo(IPAddress * ipAddress, Print * printer) */\n\nsize_t __ipAddresscall IPAddress::printIPAddress_0800450a(IPAddress *ipAddress,Print *printer)\n\n{\n  size_t bytesPrinted;\n  size_t dotPrinted;\n  int index;\n  int totalSize;\n  \n  totalSize = 0;\n  for (index = 0; index < 3; index = index + 1) {\n    bytesPrinted = Print::printerrint(printer,(ipAddress->_address).bytes[index],10);\n    dotPrinted = Print::printerrint(printer,'.');\n    totalSize = totalSize + bytesPrinted + dotPrinted;\n  }\n  bytesPrinted = Print::printerrint(printer,(ipAddress->_address).bytes[3],10);\n  return bytesPrinted + totalSize;\n}\n\n",
            "renaming": {
                "FUN_0800450a": "print_ip_address_0800450a",
                "this": "ipAddress",
                "p": "printer",
                "iVar3": "index",
                "iVar4": "totalSize",
                "sVar1": "bytesPrinted",
                "sVar2": "dotPrinted"
            },
            "calling": [],
            "called": [
                "print",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004544": {
            "entrypoint": "0x08004544",
            "current_name": "create_ip_address_08004544",
            "code": "\n/* DWARF original prototype: IPAddress *  IPAddress(IPAddress * ipAddress, uint8_t octet1, uint8_t\n   octet2, uint8_t octet3, uint8_t octet4) */\n\nIPAddress * __ipAddresscall\nIPAddress::createIPAddress_08004544(IPAddress *ipAddress,uint8_t octet1,uint8_t octet2,uint8_t octet3,\n          uint8_t octet4)\n\n{\n  (ipAddress->super_Printable)._vptr_Printable = (_func_int_varargs **)&DAT_08005f28;\n  (ipAddress->_address).bytes[0] = octet1;\n  (ipAddress->_address).bytes[1] = octet2;\n  (ipAddress->_address).bytes[2] = octet3;\n  (ipAddress->_address).bytes[3] = octet4;\n  return ipAddress;\n}\n\n",
            "renaming": {
                "FUN_08004544": "create_ip_address_08004544",
                "this": "ipAddress",
                "first_octet": "octet1",
                "second_octet": "octet2",
                "third_octet": "octet3",
                "fourth_octet": "octet4"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004560": {
            "entrypoint": "0x08004560",
            "current_name": "initialize_ip_address_08004560",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIPAddress_08004560(int isInitialize,int priority)\n\n{\n  if ((isInitialize == 1) && (priority == 0xffff)) {\n    createIPAddress(&inaddrNone,'\\0','\\0','\\0','\\0');\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004560": "initialize_ip_address_08004560",
                "__initialize_p": "isInitialize",
                "__priority": "priority",
                "IPAddress::IPAddress": "createIPAddress",
                "INADDR_NONE": "inaddrNone"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "called": [
                "IPAddress"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800458c": {
            "entrypoint": "0x0800458c",
            "current_name": "initialize_static_variables_0800458c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_variables_0800458c(void)\n\n{\n  perform_initialization_and_destruction(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800458c": "initialize_static_variables_0800458c",
                "__static_initialization_and_destruction_0": "perform_initialization_and_destruction"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800459a": {
            "entrypoint": "0x0800459a",
            "current_name": "write_to_print_0800459a",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080045ae */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * printInstance, uint8_t * buffer, size_t size) */\n\nssize_t __printInstancecall Print::writeToPrint_0800459a(Print *printInstance,int fileDescriptor,void *buffer,size_t size)\n\n{\n  Print *tempPtr;\n  int writeCount;\n  \n  writeCount = 0;\n  tempPtr = printInstance;\n  while( true ) {\n    if (buffer == (void *)0x0) {\n      return writeCount;\n    }\n    tempPtr = (Print *)(**printInstance->_vptr_Print)(tempPtr,(uint)*(byte *)fileDescriptor,buffer,*printInstance->_vptr_Print,size)\n    ;\n    if (tempPtr == (Print *)0x0) break;\n    writeCount = writeCount + 1;\n    fileDescriptor = (int)(fileDescriptor + 1);\n    buffer = (void *)((int)buffer + -1);\n  }\n  return writeCount;\n}\n\n",
            "renaming": {
                "this": "printInstance",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__n": "size",
                "pPVar1": "tempPtr",
                "iVar2": "writeCount",
                "FUN_0800459a": "write_to_print_0800459a"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045be": {
            "entrypoint": "0x080045be",
            "current_name": "print_character_080045be",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080045c4 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * printObject, char c) */\n\nsize_t __printObjectcall Print::printCharacter_080045be(Print *printObject,char c)\n\n{\n  size_t size;\n  \n  size = (**printObject->_vptr_Print)(printObject,(int)c);\n  return size;\n}\n\n",
            "renaming": {
                "FUN_080045be": "print_character_080045be",
                "this": "printObject",
                "sVar1": "size"
            },
            "calling": [
                "printTo"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045c8": {
            "entrypoint": "0x080045c8",
            "current_name": "print_number_080045c8",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08004618 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  printNumber_080045c8(Print * this, ulong n, uint8_t base) */\n\nsize_t __thiscall Print::printNumber_080045c8(Print *this,ulong n,uint8_t base)\n\n{\n  char cVar1;\n  char c;\n  size_t sVar2;\n  size_t sVar3;\n  ulong m;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  char *__s;\n  char buf [33];\n  \n  uVar5 = (uint)base;\n  buf[32] = '\\0';\n  if (uVar5 < 2) {\n    uVar5 = 10;\n  }\n  __s = buf + 0x20;\n  m = n;\n  do {\n    uVar6 = m / uVar5;\n    uVar4 = (m & 0xff) - ((int)(short)uVar6 * (int)(short)uVar5 & 0xffU) & 0xff;\n    __s = __s + -1;\n    cVar1 = (char)uVar4;\n    if (uVar4 < 10) {\n      cVar1 = cVar1 + '0';\n    }\n    else {\n      cVar1 = cVar1 + '7';\n    }\n    *__s = cVar1;\n    m = uVar6;\n  } while (uVar6 != 0);\n  if (__s == (char *)0x0) {\n    sVar3 = 0;\n  }\n  else {\n    sVar2 = strlen(__s);\n    sVar3 = (*this->_vptr_Print[1])(sVar2,__s,sVar2);\n  }\n  return sVar3;\n}\n\n",
            "renaming": {
                "FUN_080045c8": "print_number_080045c8"
            },
            "calling": [
                "print"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004622": {
            "entrypoint": "0x08004622",
            "current_name": "print_number_with_base_08004622",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example locationumber: r0 : 0x08004634 */\n/* WARNING: Restarted to delay deadcode eliminumberationumber for space: register */\n/* WARNING: Exceeded maximum restarts with more penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbert(Prinumbert * print_object, ulonumberg number, inumbert number_base) */\n\nsize_t __print_objectcall Prinumbert::print_number_with_base_08004622(Prinumbert *print_object,ulonumberg number,inumbert number_base)\n\n{\n  size_t result;\n  \n  if (number_base != 0) {\n    result = prinumbertNumber(print_object,number,(uinumbert8_t)number_base);\n    returnumber result;\n  }\n  result = (**print_object->_vptr_Prinumbert)(print_object,number & 0xff);\n  returnumber result;\n}\n\n",
            "renaming": {
                "FUN_08004622": "print_number_with_base_08004622",
                "this": "print_object",
                "n": "number",
                "base": "number_base",
                "sVar1": "result"
            },
            "calling": [
                "print"
            ],
            "called": [
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004638": {
            "entrypoint": "0x08004638",
            "current_name": "print_byte_in_base_08004638",
            "code": "\n/* DWARF original prototype: size_t  print(Print * printInstance, uchar b, int numberBase) */\n\nsize_t __printInstancecall Print::printByteInBase_08004638(Print *printInstance,uchar b,int numberBase)\n\n{\n  size_t result;\n  \n  result = print(printInstance,(uint)b,numberBase);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004638": "print_byte_in_base_08004638",
                "this": "printInstance",
                "base": "numberBase",
                "sVar1": "result"
            },
            "calling": [
                "printTo"
            ],
            "called": [
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004640": {
            "entrypoint": "0x08004640",
            "current_name": "concatenate_bytes_08004640",
            "code": "\n/* WARNING: Unknown calowBytelowByteing convention */\n\nuint16_t concatenateBytes_08004640(uint8_t highByte,uint8_t lowByte)\n\n{\n  return CONCAT11(highByte,lowByte);\n}\n\n",
            "renaming": {
                "FUN_08004640": "concatenate_bytes_08004640",
                "h": "highByte",
                "l": "lowByte"
            },
            "calling": [
                "process_FC1",
                "process_FC3",
                "process_FC15",
                "process_FC5",
                "process_FC6",
                "validateRequest",
                "process_FC16"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004646": {
            "entrypoint": "0x08004646",
            "current_name": "FUNC_08004646",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004646(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004646": "FUNC_08004646"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004648": {
            "entrypoint": "0x08004648",
            "current_name": "initialize_security_08004648",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSecurity_08004648(void)\n\n{\n  EVP_PKEY_CTX *securityContext;\n  \n  securityContext = (EVP_PKEY_CTX *)0x3;\n  HAL_NVIC_SetPriorityGrouping(3);\n  init(securityContext);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004648": "initialize_security_08004648",
                "ctx": "securityContext"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004658": {
            "entrypoint": "0x08004658",
            "current_name": "run_program_08004658",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint runProgram_08004658(void)\n\n{\n  initializeVariant();\n  performSetup();\n  do {\n    executeLoop();\n    runSerialEvent();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004658": "run_program_08004658",
                "initVariant": "initializeVariant",
                "setup": "performSetup",
                "loop": "executeLoop",
                "serialEventRun": "runSerialEvent"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "setup",
                "initVariant",
                "loop",
                "serialEventRun"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004678": {
            "entrypoint": "0x08004678",
            "current_name": "count_set_bits_08004678",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t countSetBits_08004678(uint16_t input)\n\n{\n  uint temp;\n  uint8_t bitCount;\n  \n  bitCount = '\\0';\n  for (temp = (uint)input; temp != 1; temp = temp >> 1) {\n    bitCount = bitCount + '\\x01';\n  }\n  return bitCount;\n}\n\n",
            "renaming": {
                "FUN_08004678": "count_set_bits_08004678",
                "pin": "input",
                "uVar1": "temp",
                "uVar2": "bitCount"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800468c": {
            "entrypoint": "0x0800468c",
            "current_name": "deallocate_gpio_irq_configs_0800468c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid deallocate_gpio_irq_configs_0800468c(void *config_list)\n\n{\n  gpio_irq_conf_str *current_node;\n  _Manager_type manager;\n  gpio_irq_conf_str *next_node;\n  \n  current_node = (gpio_irq_conf_str *)&__malloc_free_list;\n  while (next_node = current_node, next_node != gpio_irq_conf) {\n    manager = next_node[-1].callback.super__Function_base._M_manager;\n    current_node = next_node + -1;\n    if (manager != (_Manager_type)0x0) {\n      (*manager)((_Any_data *)&next_node[-1].callback,(_Any_data *)&next_node[-1].callback,\n                __destroy_functor);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800468c": "deallocate_gpio_irq_configs_0800468c",
                "param_1": "config_list",
                "pgVar1": "current_node",
                "pgVar3": "next_node",
                "p_Var2": "manager"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046b4": {
            "entrypoint": "0x080046b4",
            "current_name": "initialize_gpio_irq_config_080046b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_gpio_irq_config_080046b4(int is_initialization_needed,int priority_level)\n\n{\n  if (is_initialization_needed != 1) {\n    return;\n  }\n  if (priority_level == 0xffff) {\n    gpio_interrupt_config[0].irqnb = External_interrupt_0_IRQn;\n    gpio_interrupt_config[0].callback_function_manager = (_Manager_type)0x0;\n    gpio_interrupt_config[1].irqnb = External_interrupt_1_IRQn;\n    gpio_interrupt_config[1].callback_function_manager = (_Manager_type)0x0;\n    gpio_interrupt_config[2].irqnb = External_interrupt_2_IRQn;\n    gpio_interrupt_config[2].callback_function_manager = (_Manager_type)0x0;\n    gpio_interrupt_config[3].irqnb = External_interrupt_3_IRQn;\n    gpio_interrupt_config[3].callback_function_manager = (_Manager_type)0x0;\n    gpio_interrupt_config[4].irqnb = External_interrupt_4_IRQn;\n    gpio_interrupt_config[4].callback_function_manager = (_Manager_type)0x0;\n    gpio_interrupt_config[5].irqnb = External_interrupt_9_to_5_IRQn;\n    gpio_interrupt_config[5].callback_function_manager = (_Manager_type)0x0;\n    gpio_interrupt_config[6].irqnb = External_interrupt_9_to_5_IRQn;\n    gpio_interrupt_config[6].callback_function_manager = (_Manager_type)0x0;\n    gpio_interrupt_config[7].irqnb = External_interrupt_9_to_5_IRQn;\n    gpio_interrupt_config[7].callback_function_manager = (_Manager_type)0x0;\n    gpio_interrupt_config[8].irqnb = External_interrupt_9_to_5_IRQn;\n    gpio_interrupt_config[8].callback_function_manager = (_Manager_type)0x0;\n    gpio_interrupt_config[9].irqnb = External_interrupt_9_to_5_IRQn;\n    gpio_interrupt_config[9].callback_function_manager = (_Manager_type)0x0;\n    gpio_interrupt_config[10].irqnb = External_interrupt_15_to_10_IRQn;\n    gpio_interrupt_config[10].callback_function_manager = (_Manager_type)0x0;\n    gpio_interrupt_config[11].irqnb = External_interrupt_15_to_10_IRQn;\n    gpio_interrupt_config[11].callback_function_manager = (_Manager_type)0x0;\n    gpio_interrupt_config[12].irqnb = External_interrupt_15_to_10_IRQn;\n    gpio_interrupt_config[12].callback_function_manager = (_Manager_type)0x0;\n    gpio_interrupt_config[13].irqnb = External_interrupt_15_to_10_IRQn;\n    gpio_interrupt_config[13].callback_function_manager = (_Manager_type)0x0;\n    gpio_interrupt_config[14].irqnb = External_interrupt_15_to_10_IRQn;\n    gpio_interrupt_config[14].callback_function_manager = (_Manager_type)0x0;\n    gpio_interrupt_config[15].irqnb = External_interrupt_15_to_10_IRQn;\n    gpio_interrupt_config[15].callback_function_manager = (_Manager_type)0x0;\n    register_exit_handler(0,0x800468d,0x20000000);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046b4": "initialize_gpio_irq_config_080046b4",
                "__initialize_p": "is_initialization_needed",
                "__priority": "priority_level",
                "gpio_irq_conf": "gpio_interrupt_config",
                "EXTI0_IRQn": "External_interrupt_0_IRQn",
                "EXTI1_IRQn": "External_interrupt_1_IRQn",
                "EXTI2_IRQn": "External_interrupt_2_IRQn",
                "EXTI3_IRQn": "External_interrupt_3_IRQn",
                "EXTI4_IRQn": "External_interrupt_4_IRQn",
                "EXTI9_5_IRQn": "External_interrupt_9_to_5_IRQn",
                "EXTI15_10_IRQn": "External_interrupt_15_to_10_IRQn",
                "callback.super__Function_base._M_manager": "callback_function_manager",
                "__aeabi_atexit": "register_exit_handler"
            },
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "called": [
                "__aeabi_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004760": {
            "entrypoint": "0x08004760",
            "current_name": "handle_gpio_interrupt_08004760",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_interrupt_08004760(void)\n\n{\n  handle_gpio_interrupt_request(1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004760": "handle_gpio_interrupt_08004760",
                "HAL_GPIO_EXTI_IRQHandler": "handle_gpio_interrupt_request"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800476a": {
            "entrypoint": "0x0800476a",
            "current_name": "handle_external_interrupt_0800476a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_0800476a(void)\n\n{\n  processExternalInterrupt(2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800476a": "handle_external_interrupt_0800476a",
                "HAL_GPIO_EXTI_IRQHandler": "processExternalInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004774": {
            "entrypoint": "0x08004774",
            "current_name": "handle_gpio_interrupt_08004774",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleGPIOInterrupt_08004774(void)\n\n{\n  handleExternalInterrupt(4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004774": "handle_gpio_interrupt_08004774",
                "HAL_GPIO_EXTI_IRQHandler": "handleExternalInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800477e": {
            "entrypoint": "0x0800477e",
            "current_name": "handle_external_interrupt_0800477e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_0800477e(void)\n\n{\n  handleGPIOExternalInterrupt(8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800477e": "handle_external_interrupt_0800477e",
                "HAL_GPIO_EXTI_IRQHandler": "handleGPIOExternalInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004788": {
            "entrypoint": "0x08004788",
            "current_name": "handle_gpio_interrupt_08004788",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_gpio_interrupt_08004788(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(0x10);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004788": "handle_gpio_interrupt_08004788"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004792": {
            "entrypoint": "0x08004792",
            "current_name": "handle_gpio_interrupts_08004792",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleGPIOInterrupts_08004792(void)\n\n{\n  uint loopIndex;\n  \n  for (loopIndex = 0x20; loopIndex < 0x201; loopIndex = loopIndex << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)loopIndex);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004792": "handle_gpio_interrupts_08004792",
                "uVar1": "loopIndex"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047a8": {
            "entrypoint": "0x080047a8",
            "current_name": "gpio_irq_handler_080047a8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid gpio_irq_handler_080047a8(void)\n\n{\n  uint size;\n  \n  for (size = 0x400; size < 0x8001; size = size << 1) {\n    handle_external_interrupt((gpio_pin)size);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047a8": "gpio_irq_handler_080047a8",
                "uVar1": "size",
                "HAL_GPIO_EXTI_IRQHandler": "handle_external_interrupt",
                "uint16_t": "gpio_pin"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047c0": {
            "entrypoint": "0x080047c0",
            "current_name": "call_function_080047c0",
            "code": "\n/* DWARF original prototype: callFunction_080047c0  operator()(function<callFunction_080047c0()> * functionPointer) */\n\ncallFunction_080047c0 __functionPointercall std::function<callFunction_080047c0()>::callFunction_080047c0(function<callFunction_080047c0()> *functionPointer)\n\n{\n  if ((functionPointer->super__Function_base)._M_manager != nullManager) {\n    (*functionPointer->_M_invoker)((_Any_data *)functionPointer);\n    return;\n  }\n                    \n  __throw_bad_function_call();\n}\n\n",
            "renaming": {
                "FUN_080047c0": "call_function_080047c0",
                "this": "functionPointer",
                "(_Manager_type)0x0": "nullManager"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [
                "__throw_bad_function_call"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047d0": {
            "entrypoint": "0x080047d0",
            "current_name": "handle_gpio_interrupt_080047d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleGPIOInterrupt_080047d0(uint16_t pinNumber)\n\n{\n  byte pinId;\n  uint8_t irqId;\n  \n  pinId = get_pin_id(pinNumber);\n  if (gpio_irq_conf[pinId].callback.super__Function_base._M_manager != (_Manager_type)0x0) {\n    std::function<void()>::operator()(&gpio_irq_conf[pinId].callback);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047d0": "handle_gpio_interrupt_080047d0",
                "GPIO_Pin": "pinNumber",
                "bVar1": "pinId",
                "irq_id": "irqId"
            },
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "called": [
                "get_pin_id",
                "operator()"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047f0": {
            "entrypoint": "0x080047f0",
            "current_name": "initialize_static_data_080047f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_080047f0(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047f0": "initialize_static_data_080047f0"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047fe": {
            "entrypoint": "0x080047fe",
            "current_name": "register_exit_handler_080047fe",
            "code": "\nvoid registerExitHandler_080047fe(undefined4 handler,undefined4 routine)\n\n{\n  __cxa_atexit(routine,handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047fe": "register_exit_handler_080047fe",
                "param_1": "handler",
                "param_2": "routine"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004808": {
            "entrypoint": "0x08004808",
            "current_name": "log_assertion_failure_08004808",
            "code": "\nvoid logAssertionFailure_08004808(undefined4 file,undefined4 line,char *function,undefined4 assertion)\n\n{\n  char *functionInfo;\n  \n  if (function == (char *)0x0) {\n    function = \"\";\n    functionInfo = function;\n  }\n  else {\n    functionInfo = \", function: \";\n  }\n  fiprintf(*(FILE **)(_impure_ptr + 0xc),\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",\n           assertion,file,line,functionInfo,function,assertion);\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_08004808": "log_assertion_failure_08004808",
                "param_1": "file",
                "param_2": "line",
                "param_3": "function",
                "param_4": "assertion",
                "pcVar1": "functionInfo"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "abort",
                "fiprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004844": {
            "entrypoint": "0x08004844",
            "current_name": "shift_left_by32_08004844",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800484c) */\n\nlonglong shiftLeftBy32_08004844(undefined4 undefinedVal,uint inputVal)\n\n{\n  return (ulonglong)inputVal << 0x20;\n}\n\n",
            "renaming": {
                "FUN_08004844": "shift_left_by32_08004844",
                "param_1": "undefinedVal",
                "param_2": "inputVal"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004860": {
            "entrypoint": "0x08004860",
            "current_name": "print_formatted_text_08004860",
            "code": "\nint printFormattedText_08004860(FILE *fileStream,char *formatString,...)\n\n{\n  int printfResult;\n  undefined4 parameter2;\n  undefined4 parameter3;\n  undefined4 stackVariable1;\n  undefined4 stackVariable2;\n  \n  stackVariable1 = parameter2;\n  stackVariable2 = parameter3;\n  printfResult = internalPrintfFunction(impurePointer,fileStream,formatString,&stackVariable1,fileStream,&stackVariable1);\n  return printfResult;\n}\n\n",
            "renaming": {
                "FUN_08004860": "print_formatted_text_08004860",
                "__stream": "fileStream",
                "__format": "formatString",
                "iVar1": "printfResult",
                "in_r2": "parameter2",
                "in_r3": "parameter3",
                "uStack_8": "stackVariable1",
                "uStack_4": "stackVariable2",
                "_vfiprintf_r": "internalPrintfFunction",
                "_impure_ptr": "impurePointer"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004884": {
            "entrypoint": "0x08004884",
            "current_name": "initialize_pre_init_08004884",
            "code": "\nvoid initializePreInit_08004884(void)\n\n{\n  int index;\n  \n  for (index = 0; index != 0; index = index + 1) {\n    (*(code *)(&preInitArrayEnd)[index])();\n  }\n  _init();\n  for (index = 0; index != 10; index = index + 1) {\n    (*(code *)(&preInitArrayEnd)[index])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004884": "initialize_pre_init_08004884",
                "iVar1": "index",
                "__preinit_array_end": "preInitArrayEnd"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "premain",
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080048cc": {
            "entrypoint": "0x080048cc",
            "current_name": "fill_memory_with_char_080048cc",
            "code": "\nvoid * fillMemoryWithChar_080048cc(void *memory,int character,size_t size)\n\n{\n  undefined *puVar1;\n  \n  for (puVar1 = (undefined *)memory; puVar1 != (undefined *)(size + (int)memory); puVar1 = puVar1 + 1) {\n    *puVar1 = (char)character;\n  }\n  return memory;\n}\n\n",
            "renaming": {
                "FUN_080048cc": "fill_memory_with_char_080048cc",
                "__s": "memory",
                "__c": "character",
                "__n": "size"
            },
            "calling": [
                "__sfmoreglue",
                "std.isra.0",
                "__sfp"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080048dc": {
            "entrypoint": "0x080048dc",
            "current_name": "free_memory_block_080048dc",
            "code": "\nvoid freeMemoryBlock_080048dc(undefined4 *result,int size,undefined4 arg3,undefined4 arg4)\n\n{\n  int *currentSize;\n  int **nextFreeBlock;\n  int **currentBlock;\n  int **prevBlock;\n  int **nextBlock;\n  int **newBlock;\n  bool isCurrentBlock;\n  \n  if (size == 0) {\n    return;\n  }\n  newBlock = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    newBlock = (int **)((int)newBlock + *(int *)(size + -4));\n  }\n  __malloc_lock();\n  prevBlock = (int **)&__malloc_free_list;\n  if (__malloc_free_list == (int **)0x0) {\n    newBlock[1] = (int *)0x0;\n    currentBlock = nextFreeBlock;\n    __malloc_free_list = newBlock;\n  }\n  else {\n    prevBlock = __malloc_free_list;\n    if (newBlock < __malloc_free_list) {\n      currentBlock = (int **)*newBlock;\n      prevBlock = (int **)((int)newBlock + (int)currentBlock);\n      isCurrentBlock = __malloc_free_list == prevBlock;\n      if (isCurrentBlock) {\n        prevBlock = (int **)*__malloc_free_list;\n        __malloc_free_list = (int **)__malloc_free_list[1];\n      }\n      newBlock[1] = (int *)__malloc_free_list;\n      __malloc_free_list = newBlock;\n      if (isCurrentBlock) {\n        prevBlock = (int **)((int)prevBlock + (int)currentBlock);\n        *newBlock = (int *)prevBlock;\n      }\n    }\n    else {\n      do {\n        nextBlock = prevBlock;\n        prevBlock = (int **)nextBlock[1];\n        if (prevBlock == (int **)0x0) break;\n      } while (prevBlock <= newBlock);\n      currentBlock = (int **)*nextBlock;\n      if ((int **)((int)nextBlock + (int)currentBlock) == newBlock) {\n        currentBlock = (int **)((int)currentBlock + (int)*newBlock);\n        *nextBlock = (int *)currentBlock;\n        if (prevBlock == (int **)((int)nextBlock + (int)currentBlock)) {\n          currentSize = *prevBlock;\n          prevBlock = (int **)prevBlock[1];\n          nextBlock[1] = (int *)prevBlock;\n          currentBlock = (int **)((int)currentBlock + (int)currentSize);\n          *nextBlock = (int *)currentBlock;\n        }\n      }\n      else if (newBlock < (int **)((int)nextBlock + (int)currentBlock)) {\n        *result = 0xc;\n      }\n      else {\n        currentBlock = (int **)((int)newBlock + (int)*newBlock);\n        isCurrentBlock = prevBlock == currentBlock;\n        if (isCurrentBlock) {\n          currentBlock = (int **)*prevBlock;\n          prevBlock = (int **)prevBlock[1];\n        }\n        newBlock[1] = (int *)prevBlock;\n        if (isCurrentBlock) {\n          currentBlock = (int **)((int)currentBlock + (int)*newBlock);\n          *newBlock = (int *)currentBlock;\n        }\n        nextBlock[1] = (int *)newBlock;\n      }\n    }\n  }\n  __malloc_unlock(result,currentBlock,prevBlock,arg4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080048dc": "free_memory_block_080048dc",
                "param_1": "result",
                "param_2": "size",
                "param_3": "arg3",
                "param_4": "arg4",
                "piVar1": "currentSize",
                "extraout_r1": "nextFreeBlock",
                "ppiVar2": "currentBlock",
                "ppiVar3": "prevBlock",
                "ppiVar4": "nextBlock",
                "ppiVar5": "newBlock",
                "bVar6": "isCurrentBlock"
            },
            "calling": [
                "__sflush_r",
                "__swsetup_r"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004978": {
            "entrypoint": "0x08004978",
            "current_name": "allocate_memory_08004978",
            "code": "\nuint allocateMemory_08004978(undefined4 *result,uint size)\n\n{\n  uint *freeBlock;\n  int remainingSize;\n  uint *currentBlock;\n  uint freeBlockSize;\n  uint *previousBlock;\n  uint allocatedSize;\n  \n  allocatedSize = (size + 3 & 0xfffffffc) + 8;\n  if (allocatedSize < 0xc) {\n    allocatedSize = 0xc;\n  }\n  if (((int)allocatedSize < 0) || (allocatedSize < size)) {\n    *result = 0xc;\n  }\n  else {\n    __malloc_lock();\n    freeBlock = __malloc_free_list;\n    previousBlock = __malloc_free_list;\n    while (currentBlock = freeBlock, currentBlock != (uint *)0x0) {\n      freeBlockSize = *currentBlock - allocatedSize;\n      if (-1 < (int)freeBlockSize) {\n        if (freeBlockSize < 0xc) {\n          if (previousBlock == currentBlock) {\n            freeBlock = (uint *)previousBlock[1];\n          }\n          else {\n            freeBlock = (uint *)currentBlock[1];\n          }\n          if (previousBlock != currentBlock) {\n            previousBlock[1] = (uint)freeBlock;\n            previousBlock = currentBlock;\n            freeBlock = __malloc_free_list;\n          }\n        }\n        else {\n          *currentBlock = freeBlockSize;\n          *(uint *)((int)currentBlock + freeBlockSize) = allocatedSize;\n          previousBlock = (uint *)((int)currentBlock + freeBlockSize);\n          freeBlock = __malloc_free_list;\n        }\n        goto LAB_080049dc;\n      }\n      previousBlock = currentBlock;\n      freeBlock = (uint *)currentBlock[1];\n    }\n    if (__malloc_sbrk_start == 0) {\n      __malloc_sbrk_start = _sbrk_r(result);\n    }\n    freeBlock = (uint *)_sbrk_r(result,allocatedSize);\n    if ((freeBlock != (uint *)0xffffffff) &&\n       ((previousBlock = (uint *)((int)freeBlock + 3U & 0xfffffffc), freeBlock == previousBlock ||\n        (remainingSize = _sbrk_r(result,(int)previousBlock - (int)freeBlock), remainingSize != -1)))) {\n      *previousBlock = allocatedSize;\n      freeBlock = __malloc_free_list;\nLAB_080049dc:\n      __malloc_free_list = freeBlock;\n      __malloc_unlock(result);\n      allocatedSize = (int)previousBlock + 0xbU & 0xfffffff8;\n      remainingSize = allocatedSize - (int)(previousBlock + 1);\n      if (remainingSize != 0) {\n        *(int *)((int)previousBlock + remainingSize) = -remainingSize;\n        return allocatedSize;\n      }\n      return allocatedSize;\n    }\n    *result = 0xc;\n    __malloc_unlock(result);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004978": "allocate_memory_08004978",
                "param_1": "result",
                "param_2": "size",
                "puVar1": "freeBlock",
                "iVar2": "remainingSize",
                "puVar3": "currentBlock",
                "uVar4": "freeBlockSize",
                "puVar5": "previousBlock",
                "uVar6": "allocatedSize"
            },
            "calling": [
                "__sfmoreglue",
                "__smakebuf_r"
            ],
            "called": [
                "__malloc_lock",
                "_sbrk_r",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a34": {
            "entrypoint": "0x08004a34",
            "current_name": "write_to_buffer_08004a34",
            "code": "\nuint writeToBuffer_08004a34(undefined4 output_file,byte byte_to_write,byte **buffer)\n\n{\n  uint write_success;\n  byte *pbVar2;\n  \n  pbVar2 = buffer[2] + -1;\n  buffer[2] = pbVar2;\n  if (((int)pbVar2 < 0) && (((int)pbVar2 < (int)buffer[6] || (byte_to_write == 10)))) {\n    write_success = __swbuf_r();\n    return write_success;\n  }\n  pbVar2 = *buffer;\n  *buffer = pbVar2 + 1;\n  *pbVar2 = byte_to_write;\n  return (uint)byte_to_write;\n}\n\n",
            "renaming": {
                "FUN_08004a34": "write_to_buffer_08004a34",
                "param_1": "output_file",
                "param_2": "byte_to_write",
                "param_3": "buffer",
                "uVar1": "write_success"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__swbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a60": {
            "entrypoint": "0x08004a60",
            "current_name": "write_to_file_08004a60",
            "code": "\nint writeToFile_08004a60(undefined4 file,undefined4 buffer,undefined *data,int size)\n\n{\n  int bytesWritten;\n  undefined *endOfData;\n  int remainingSize;\n  \n  endOfData = data + size;\n  remainingSize = size;\n  do {\n    if (data == endOfData) {\n      return 0;\n    }\n    bytesWritten = __sfputc_r(file,*data,buffer,size,remainingSize);\n    size = bytesWritten + 1;\n    data = data + 1;\n  } while (size != 0);\n  return bytesWritten;\n}\n\n",
            "renaming": {
                "FUN_08004a60": "write_to_file_08004a60",
                "param_1": "file",
                "param_2": "buffer",
                "param_3": "data",
                "param_4": "size",
                "iVar1": "bytesWritten",
                "puVar2": "endOfData",
                "iVar3": "remainingSize"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a84": {
            "entrypoint": "0x08004a84",
            "current_name": "printf_with_format_08004a84",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08004c58) */\n\nint printfWithFormat_08004a84(int stream,undefined4 *format,byte *str,int *args)\n\n{\n  bool hasNumber;\n  int result;\n  void *foundChar;\n  int *currentArg;\n  byte *currChar;\n  byte *nextChar;\n  int temp;\n  int value;\n  int *argsPointer;\n  uint flags;\n  int precision;\n  undefined4 width;\n  int argWidth;\n  int totalSize;\n  byte conversionChar;\n  undefined SPACE;\n  undefined PLUS;\n  undefined hash;\n  undefined4 none;\n  \n  argsPointer = args;\n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (format == &__sf_fake_stdin) {\n    format = *(undefined4 **)(stream + 4);\n  }\n  else if (format == (undefined4 *)&__sf_fake_stdout) {\n    format = *(undefined4 **)(stream + 8);\n  }\n  else if (format == (undefined4 *)&__sf_fake_stderr) {\n    format = *(undefined4 **)(stream + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(format + 3) << 0x1c)) || (format[4] == 0)) &&\n     (value = __swsetup_r(stream,format), value != 0)) {\n    return -1;\n  }\n  totalSize = 0;\n  SPACE = 0x20;\n  PLUS = 0x30;\n  currChar = str;\nLAB_08004ac6:\n  nextChar = currChar;\n  if (*nextChar != 0) goto LAB_08004b7c;\n  goto LAB_08004ad0;\nLAB_08004b7c:\n  currChar = nextChar + 1;\n  if (*nextChar != 0x25) goto LAB_08004ac6;\nLAB_08004ad0:\n  value = (int)nextChar - (int)str;\n  if (value != 0) {\n    result = __sfputs_r(stream,format,str,value);\n    if (result == -1) {\nLAB_08004c70:\n      if ((int)((uint)*(ushort *)(format + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return totalSize;\n    }\n    totalSize = totalSize + value;\n  }\n  if (*nextChar == 0) goto LAB_08004c70;\n  flags = 0;\n  argWidth = 0;\n  precision = -1;\n  width = 0;\n  hash = 0;\n  none = 0;\n  currChar = nextChar + 1;\n  while( true ) {\n    foundChar = memchr(\"#-0+ \",(uint)*currChar,5);\n    str = currChar + 1;\n    if (foundChar == (void *)0x0) break;\n    flags = 1 << ((int)foundChar + 0xf7ffa094U & 0xff) | flags;\n    currChar = str;\n  }\n  if ((int)(flags << 0x1b) < 0) {\n    hash = 0x20;\n  }\n  if ((int)(flags << 0x1c) < 0) {\n    hash = 0x2b;\n  }\n  if (*currChar == 0x2a) {\n    currentArg = argsPointer + 1;\n    value = *argsPointer;\n    argsPointer = currentArg;\n    if (value < 0) {\n      argWidth = -value;\n      flags = flags | 2;\n      goto LAB_08004bae;\n    }\n  }\n  else {\n    hasNumber = false;\n    value = argWidth;\n    str = currChar;\n    while( true ) {\n      if (9 < *str - 0x30) break;\n      value = value * 10 + (*str - 0x30);\n      hasNumber = true;\n      str = str + 1;\n    }\n    if (!hasNumber) goto LAB_08004bae;\n  }\n  argWidth = value;\nLAB_08004bae:\n  if (*str == 0x2e) {\n    if (str[1] == 0x2a) {\n      precision = *argsPointer;\n      if (precision < 0) {\n        precision = -1;\n      }\n      str = str + 2;\n      argsPointer = argsPointer + 1;\n    }\n    else {\n      hasNumber = false;\n      precision = 0;\n      value = 0;\n      while( true ) {\n        str = str + 1;\n        if (9 < *str - 0x30) break;\n        value = value * 10 + (*str - 0x30);\n        hasNumber = true;\n      }\n      if (hasNumber) {\n        precision = value;\n      }\n    }\n  }\n  foundChar = memchr(&DAT_08005f72,(uint)*str,3);\n  if (foundChar != (void *)0x0) {\n    flags = flags | 0x40 << ((int)foundChar + 0xf7ffa08eU & 0xff);\n    str = str + 1;\n  }\n  conversionChar = *str;\n  str = str + 1;\n  foundChar = memchr(\"efgEFG\",(uint)conversionChar,6);\n  if (foundChar == (void *)0x0) {\n    temp = _printf_i(stream,&flags,format,0x8004a61,&argsPointer);\n    if (temp == -1) goto LAB_08004c70;\n  }\n  else {\n    argsPointer = (int *)(((int)argsPointer + 7U & 0xfffffff8) + 8);\n  }\n  totalSize = totalSize + temp;\n  currChar = str;\n  goto LAB_08004ac6;\n}\n\n",
            "renaming": {
                "FUN_08004a84": "printf_with_format_08004a84",
                "param_1": "stream",
                "param_2": "format",
                "param_3": "str",
                "param_4": "args",
                "bVar1": "hasNumber",
                "iVar2": "result",
                "pvVar3": "foundChar",
                "piVar4": "currentArg",
                "pbVar5": "currChar",
                "pbVar6": "nextChar",
                "unaff_r9": "temp",
                "iVar7": "value",
                "local_8c": "argsPointer",
                "local_88": "flags",
                "local_84": "precision",
                "local_80": "width",
                "local_7c": "argWidth",
                "local_74": "totalSize",
                "local_70": "conversionChar",
                "local_6f": "SPACE",
                "local_6e": "PLUS",
                "local_45": "hash",
                "local_30": "none"
            },
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "called": [
                "_printf_i",
                "__sinit",
                "memchr",
                "__swsetup_r",
                "__sfputs_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cb0": {
            "entrypoint": "0x08004cb0",
            "current_name": "process_data_08004cb0",
            "code": "\nundefined4\nprocessData_08004cb0(undefined4 input,uint *array,uint *outputSize,undefined4 param,code *callback)\n\n{\n  int index1;\n  int index2;\n  uint maxSize;\n  uint counter;\n  bool checkFlag;\n  \n  maxSize = array[4];\n  if ((int)array[4] < (int)array[2]) {\n    maxSize = array[2];\n  }\n  *outputSize = maxSize;\n  if (*(char *)((int)array + 0x43) != '\\0') {\n    *outputSize = maxSize + 1;\n  }\n  if ((int)(*array << 0x1a) < 0) {\n    *outputSize = *outputSize + 2;\n  }\n  if ((*array & 6) == 0) {\n    for (index1 = 0; index1 < (int)(array[3] - *outputSize); index1 = index1 + 1) {\n      index2 = (*callback)(input,param,(int)array + 0x19,1);\n      if (index2 == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  maxSize = (uint)*(byte *)((int)array + 0x43);\n  if (maxSize != 0) {\n    maxSize = 1;\n  }\n  if ((int)(*array << 0x1a) < 0) {\n    *(undefined *)((int)array + maxSize + 0x43) = 0x30;\n    *(undefined *)((int)array + maxSize + 0x44) = *(undefined *)((int)array + 0x45);\n    maxSize = maxSize + 2;\n  }\n  index1 = (*callback)(input,param,(int)array + 0x43,maxSize);\n  if (index1 != -1) {\n    maxSize = array[3];\n    checkFlag = (*array & 6) == 4;\n    if (checkFlag) {\n      maxSize = maxSize - *outputSize;\n    }\n    if (checkFlag) {\n      maxSize = maxSize & ~((int)maxSize >> 0x1f);\n    }\n    else {\n      maxSize = 0;\n    }\n    if ((int)array[4] < (int)array[2]) {\n      maxSize = maxSize + (array[2] - array[4]);\n    }\n    counter = 0;\n    while( true ) {\n      if (maxSize == counter) {\n        return 0;\n      }\n      index1 = (*callback)(input,param,(int)array + 0x1a,1);\n      if (index1 == -1) break;\n      counter = counter + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08004cb0": "process_data_08004cb0",
                "param_1": "input",
                "param_2": "array",
                "param_3": "outputSize",
                "param_4": "param",
                "param_5": "callback",
                "iVar1": "index1",
                "iVar2": "index2",
                "uVar3": "maxSize",
                "uVar4": "counter",
                "bVar5": "checkFlag"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d9c": {
            "entrypoint": "0x08004d9c",
            "current_name": "print_formatted_data_08004d9c",
            "code": "\nuint print_formatted_data_08004d9c(undefined4 format_string,uint *data,undefined4 flags,code *output_callback,uint **output_data)\n\n{\n  byte byte_value;\n  int result;\n  uint *data_ptr;\n  void *char_ptr;\n  int iteration;\n  char *hex_chars;\n  uint uVarA;\n  uint **ppuVar8;\n  char **ppcVar9;\n  uint dividend;\n  uint quotient;\n  char *output_ptr;\n  char *string_ptr;\n  uint local_values [2];\n  \n  byte_value = *(byte *)(data + 6);\n  string_ptr = (char *)((int)data + 0x43);\n  if (byte_value != 0x6e) {\n    if (byte_value < 0x6f) {\n      if (byte_value != 99) {\n        if (byte_value < 100) {\n          if (byte_value == 0) goto LAB_08004f56;\n          if (byte_value != 0x58) goto LAB_08004dcc;\n          *(undefined *)((int)data + 0x45) = 0x58;\n          hex_chars = \"0123456789ABCDEF\";\nLAB_08004ee6:\n          uVarA = *data;\n          data_ptr = *output_data;\n          *output_data = data_ptr + 1;\n          if (((uVarA & 0x80) == 0) && ((int)(uVarA << 0x19) < 0)) {\n            dividend = (uint)*(ushort *)data_ptr;\n          }\n          else {\n            dividend = *data_ptr;\n          }\n          if ((int)(uVarA << 0x1f) < 0) {\n            *data = uVarA | 0x20;\n          }\n          if (dividend == 0) {\n            *data = *data & 0xffffffdf;\n          }\n          uVarA = 0x10;\nLAB_08004e7c:\n          *(undefined *)((int)data + 0x43) = 0;\n        }\n        else {\n          if ((byte_value != 100) && (byte_value != 0x69)) goto LAB_08004dcc;\n          dividend = *data;\n          data_ptr = *output_data;\n          if ((dividend & 0x80) == 0) {\n            *output_data = data_ptr + 1;\n            if ((dividend & 0x40) == 0) goto LAB_08004dec;\n            dividend = (uint)(short)*(ushort *)data_ptr;\n          }\n          else {\n            *output_data = data_ptr + 1;\nLAB_08004dec:\n            dividend = *data_ptr;\n          }\n          if ((int)dividend < 0) {\n            dividend = -dividend;\n            *(undefined *)((int)data + 0x43) = 0x2d;\n          }\n          hex_chars = \"0123456789ABCDEF\";\n          uVarA = 10;\n        }\n        quotient = data[1];\n        data[2] = quotient;\n        output_ptr = string_ptr;\n        if ((int)quotient < 0) {\n          if (dividend != 0) goto LAB_08004f1a;\nLAB_08004fc8:\n          *(char *)((int)data + 0x42) = *hex_chars;\n          output_ptr = (char *)((int)data + 0x42);\n        }\n        else {\n          *data = *data & 0xfffffffb;\n          if (dividend == 0) {\n            if (quotient != 0) goto LAB_08004fc8;\n          }\n          else {\nLAB_08004f1a:\n            do {\n              quotient = dividend / uVarA;\n              output_ptr = output_ptr + -1;\n              *output_ptr = hex_chars[dividend - uVarA * quotient];\n              dividend = quotient;\n            } while (quotient != 0);\n          }\n        }\n        if (((uVarA == 8) && ((int)(*data << 0x1f) < 0)) && ((int)data[1] <= (int)data[4]))\n        {\n          output_ptr[-1] = '0';\n          output_ptr = output_ptr + -1;\n        }\n        data[4] = (int)string_ptr - (int)output_ptr;\n        string_ptr = output_ptr;\n        goto LAB_08004ec2;\n      }\n      data_ptr = *output_data;\n      *output_data = data_ptr + 1;\n      *(char *)((int)data + 0x42) = (char)*data_ptr;\nLAB_08004e2c:\n      string_ptr = (char *)((int)data + 0x42);\n      dividend = 1;\n    }\n    else {\n      if (byte_value != 0x73) {\n        if (byte_value < 0x74) {\n          if (byte_value == 0x6f) {\nLAB_08004e52:\n            dividend = *data;\n            data_ptr = *output_data;\n            if ((dividend & 0x80) == 0) {\n              *output_data = data_ptr + 1;\n              if ((dividend & 0x40) == 0) goto LAB_08004e60;\n              dividend = (uint)*(ushort *)data_ptr;\n            }\n            else {\n              *output_data = data_ptr + 1;\nLAB_08004e60:\n              dividend = *data_ptr;\n            }\n            hex_chars = \"0123456789ABCDEF\";\n            if (byte_value == 0x6f) {\n              uVarA = 8;\n            }\n            else {\n              uVarA = 10;\n            }\n            goto LAB_08004e7c;\n          }\n          if (byte_value == 0x70) {\n            *data = *data | 0x20;\nLAB_08004e12:\n            *(undefined *)((int)data + 0x45) = 0x78;\n            hex_chars = \"0123456789abcdef\";\n            goto LAB_08004ee6;\n          }\n        }\n        else {\n          if (byte_value == 0x75) goto LAB_08004e52;\n          if (byte_value == 0x78) goto LAB_08004e12;\n        }\nLAB_08004dcc:\n        *(byte *)((int)data + 0x42) = byte_value;\n        goto LAB_08004e2c;\n      }\n      ppcVar9 = (char **)*output_data;\n      *output_data = (uint *)(ppcVar9 + 1);\n      string_ptr = *ppcVar9;\n      char_ptr = memchr(string_ptr,0,data[1]);\n      if (char_ptr != (void *)0x0) {\n        data[1] = (int)char_ptr - (int)string_ptr;\n      }\n      dividend = data[1];\n    }\n    data[4] = dividend;\n    *(undefined *)((int)data + 0x43) = 0;\n    goto LAB_08004ec2;\n  }\n  dividend = *data;\n  ppuVar8 = (uint **)*output_data;\n  uVarA = data[5];\n  if ((dividend & 0x80) == 0) {\n    *output_data = (uint *)(ppuVar8 + 1);\n    data_ptr = *ppuVar8;\n    if ((dividend & 0x40) == 0) goto LAB_08004f42;\n    *(short *)data_ptr = (short)uVarA;\n  }\n  else {\n    *output_data = (uint *)(ppuVar8 + 1);\n    data_ptr = *ppuVar8;\nLAB_08004f42:\n    *data_ptr = uVarA;\n  }\nLAB_08004f56:\n  data[4] = 0;\nLAB_08004ec2:\n  result = _printf_common(format_string,data,local_values,flags,output_callback);\n  if ((result == -1) || (result = (*output_callback)(format_string,flags,string_ptr,data[4]), result == -1)) {\nLAB_08004ed6:\n    dividend = 0xffffffff;\n  }\n  else {\n    if ((int)(*data << 0x1e) < 0) {\n      for (result = 0; result < (int)(data[3] - local_values[0]); result = result + 1) {\n        iteration = (*output_callback)(format_string,flags,(int)data + 0x19,1);\n        if (iteration == -1) goto LAB_08004ed6;\n      }\n    }\n    dividend = data[3];\n    if ((int)data[3] < (int)local_values[0]) {\n      dividend = local_values[0];\n    }\n  }\n  return dividend;\n}\n\n",
            "renaming": {
                "FUN_08004d9c": "print_formatted_data_08004d9c",
                "param_1": "format_string",
                "param_2": "data",
                "param_3": "flags",
                "param_4": "output_callback",
                "param_5": "output_data",
                "bVar1": "byte_value",
                "iVar2": "result",
                "puVar3": "data_ptr",
                "pvVar4": "char_ptr",
                "iVar5": "iteration",
                "pcVar6": "hex_chars",
                "uVar7": "uVarA",
                "uVar10": "dividend",
                "uVar11": "quotient",
                "pcVar12": "output_ptr",
                "__s": "string_ptr",
                "local_24": "local_values"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "_printf_common",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004fdc": {
            "entrypoint": "0x08004fdc",
            "current_name": "formatted_print_08004fdc",
            "code": "\nint formattedPrint_08004fdc(char *formatString,...)\n\n{\n  int pointerValue;\n  undefined4 registerValue1;\n  undefined4 registerValue2;\n  undefined4 registerValue3;\n  char *formatPointer;\n  undefined4 registerValueC;\n  undefined4 registerValue8;\n  undefined4 registerValue4;\n  \n  pointerValue = impurePointer;\n  formatPointer = formatString;\n  registerValueC = registerValue1;\n  registerValue8 = registerValue2;\n  registerValue4 = registerValue3;\n  if ((impurePointer != 0) && (*(int *)(impurePointer + 0x18) == 0)) {\n    initializeS(impurePointer);\n  }\n  pointerValue = _vfiprintf_r(pointerValue,*(undefined4 *)(pointerValue + 8),formatString,&registerValueC,formatPointer,&registerValueC);\n  return pointerValue;\n}\n\n",
            "renaming": {
                "FUN_08004fdc": "formatted_print_08004fdc",
                "__format": "formatString",
                "iVar1": "pointerValue",
                "in_r1": "registerValue1",
                "in_r2": "registerValue2",
                "in_r3": "registerValue3",
                "pcVar2": "formatPointer",
                "uStack_c": "registerValueC",
                "uStack_8": "registerValue8",
                "uStack_4": "registerValue4",
                "_impure_ptr": "impurePointer",
                "__sinit": "initializeS"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "__sinit",
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800500c": {
            "entrypoint": "0x0800500c",
            "current_name": "allocate_memory_0800500c",
            "code": "\nvoid allocateMemory_0800500c(int *errorStatus,intptr_t memorySize)\n\n{\n  void *allocatedMemory;\n  \n  errno = 0;\n  allocatedMemory = requestMemory(memorySize);\n  if ((allocatedMemory == (void *)0xffffffff) && (errno != 0)) {\n    *errorStatus = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800500c": "allocate_memory_0800500c",
                "param_1": "errorStatus",
                "param_2": "memorySize",
                "pvVar1": "allocatedMemory",
                "_sbrk": "requestMemory"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800502c": {
            "entrypoint": "0x0800502c",
            "current_name": "write_to_stream_0800502c",
            "code": "\nuint write_to_stream_0800502c(int stream_address,uint character,int *stream,undefined4 parameter)\n\n{\n  int difference;\n  uint value;\n  undefined *pointer;\n  \n  if ((stream_address != 0) && (*(int *)(stream_address + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = *(int **)(stream_address + 4);\n  }\n  else if (stream == (int *)&__sf_fake_stdout) {\n    stream = *(int **)(stream_address + 8);\n  }\n  else if (stream == (int *)&__sf_fake_stderr) {\n    stream = *(int **)(stream_address + 0xc);\n  }\n  stream[2] = stream[6];\n  value = (uint)*(ushort *)(stream + 3);\n  difference = value << 0x1c;\n  if (((difference < 0) && (value = stream[4], value != 0)) ||\n     (difference = __swsetup_r(stream_address,stream,difference,value,parameter), difference == 0)) {\n    difference = *stream - stream[4];\n    character = character & 0xff;\n    if ((difference < stream[5]) || (difference = _fflush_r(stream_address,stream), difference == 0)) {\n      stream[2] = stream[2] + -1;\n      pointer = (undefined *)*stream;\n      *stream = (int)(pointer + 1);\n      *pointer = (char)character;\n      if (difference + 1 != stream[5]) {\n        if (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1f)) {\n          return character;\n        }\n        if (character != 10) {\n          return character;\n        }\n      }\n      difference = _fflush_r(stream_address,stream);\n      if (difference == 0) {\n        return character;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800502c": "write_to_stream_0800502c",
                "param_1": "stream_address",
                "param_2": "character",
                "param_3": "stream",
                "param_4": "parameter",
                "iVar1": "difference",
                "uVar2": "value",
                "puVar3": "pointer"
            },
            "calling": [
                "__sfputc_r"
            ],
            "called": [
                "__sinit",
                "_fflush_r",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080050d0": {
            "entrypoint": "0x080050d0",
            "current_name": "process_input_stream_080050d0",
            "code": "\nuint process_input_stream_080050d0(undefined4 *output_status,undefined4 *input_stream)\n\n{\n  int global_impure_ptr;\n  uint result;\n  ushort stream_state;\n  \n  global_impure_ptr = global_impure_ptr;\n  if ((global_impure_ptr != 0) && (*(int *)(global_impure_ptr + 0x18) == 0)) {\n    __sinit(global_impure_ptr);\n  }\n  if (input_stream == &__sf_fake_stdin) {\n    input_stream = *(undefined4 **)(global_impure_ptr + 4);\n  }\n  else if (input_stream == (undefined4 *)&__sf_fake_stdout) {\n    input_stream = *(undefined4 **)(global_impure_ptr + 8);\n  }\n  else if (input_stream == (undefined4 *)&__sf_fake_stderr) {\n    input_stream = *(undefined4 **)(global_impure_ptr + 0xc);\n  }\n  stream_state = *(ushort *)(input_stream + 3);\n  result = (uint)stream_state;\n  if (-1 < (int)(result << 0x1c)) {\n    if (-1 < (int)(result << 0x1b)) {\n      *output_status = 9;\n      goto LAB_08005100;\n    }\n    if ((int)(result << 0x1d) < 0) {\n      if ((undefined4 *)input_stream[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)input_stream[0xd] != input_stream + 0x11) {\n          _free_r(output_status);\n        }\n        input_stream[0xd] = 0;\n      }\n      *(ushort *)(input_stream + 3) = *(ushort *)(input_stream + 3) & 0xffdb;\n      input_stream[1] = 0;\n      *input_stream = input_stream[4];\n    }\n    *(ushort *)(input_stream + 3) = *(ushort *)(input_stream + 3) | 8;\n  }\n  if ((input_stream[4] == 0) && ((*(ushort *)(input_stream + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(output_status,input_stream);\n  }\n  stream_state = *(ushort *)(input_stream + 3);\n  result = stream_state & 1;\n  if ((stream_state & 1) == 0) {\n    if (-1 < (int)((uint)stream_state << 0x1e)) {\n      result = input_stream[5];\n    }\n    input_stream[2] = result;\n  }\n  else {\n    input_stream[2] = 0;\n    input_stream[6] = -input_stream[5];\n  }\n  if (input_stream[4] == 0) {\n    stream_state = *(ushort *)(input_stream + 3);\n    result = (int)(short)stream_state & 0x80;\n    if (result != 0) {\nLAB_08005100:\n      *(ushort *)(input_stream + 3) = stream_state | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080050d0": "process_input_stream_080050d0",
                "param_1": "output_status",
                "param_2": "input_stream",
                "_impure_ptr": "global_impure_ptr",
                "iVar1": "global_impure_ptr",
                "uVar2": "result",
                "uVar3": "stream_state"
            },
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r"
            ],
            "called": [
                "__sinit",
                "_free_r",
                "__smakebuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080051ac": {
            "entrypoint": "0x080051ac",
            "current_name": "terminate_program_080051ac",
            "code": "\n\n\nvoid terminate_program_080051ac(void)\n\n{\n  send_signal(6);\n                    \n  exit_program(1);\n}\n\n",
            "renaming": {
                "FUN_080051ac": "terminate_program_080051ac",
                "raise": "send_signal",
                "_exit": "exit_program"
            },
            "calling": [
                "__throw_bad_function_call",
                "__assert_func"
            ],
            "called": [
                "raise",
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080051bc": {
            "entrypoint": "0x080051bc",
            "current_name": "process_data_080051bc",
            "code": "\nundefined4 process_data_080051bc(uint *data,int *state)\n\n{\n  int current_value;\n  int *temp_ptr;\n  uint temp_value;\n  ushort flags;\n  int increment;\n  code *function_ptr;\n  int remaining_value;\n  uint temp_data;\n  bool is_zero;\n  \n  flags = *(ushort *)(state + 3);\n  temp_value = (uint)flags;\n  if ((int)(temp_value << 0x1c) < 0) {\n    current_value = state[4];\n    if (current_value != 0) {\n      increment = temp_value << 0x1e;\n      is_zero = increment == 0;\n      remaining_value = *state;\n      if (is_zero) {\n        increment = state[5];\n      }\n      *state = current_value;\n      if (!is_zero) {\n        increment = 0;\n      }\n      state[2] = increment;\n      for (remaining_value = remaining_value - current_value; 0 < remaining_value; remaining_value = remaining_value - increment) {\n        increment = (*(code *)state[10])(data,state[8],current_value,remaining_value);\n        if (increment < 1) {\n          flags = *(ushort *)(state + 3);\n          goto LAB_080052b2;\n        }\n        current_value = current_value + increment;\n      }\n    }\n  }\n  else if (((0 < state[1]) || (0 < state[0x10])) &&\n          (function_ptr = (code *)state[0xb], function_ptr != (code *)0x0)) {\n    temp_data = *data;\n    *data = 0;\n    if ((flags & 0x1000) == 0) {\n      current_value = (*function_ptr)(data,state[8],temp_value & 0x1000,1);\n      if ((current_value == -1) && (temp_value = *data, temp_value != 0)) {\n        if ((temp_value != 0x1d) && (temp_value != 0x16)) {\n          *(ushort *)(state + 3) = *(ushort *)(state + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *data = temp_data;\n        return 0;\n      }\n    }\n    else {\n      current_value = state[0x15];\n    }\n    if (((int)((uint)*(ushort *)(state + 3) << 0x1d) < 0) &&\n       (current_value = current_value - state[1], state[0xd] != 0)) {\n      current_value = current_value - state[0x10];\n    }\n    current_value = (*(code *)state[0xb])(data,state[8],current_value,0);\n    flags = *(ushort *)(state + 3);\n    if ((current_value == -1) &&\n       ((0x1d < *data || (-1 < (int)((0x20400001U >> (*data & 0xff)) << 0x1f))))) {\nLAB_080052b2:\n      *(ushort *)(state + 3) = flags | 0x40;\n      return 0xffffffff;\n    }\n    state[1] = 0;\n    *state = state[4];\n    if (((int)((uint)flags << 0x13) < 0) && ((current_value != -1 || (*data == 0)))) {\n      state[0x15] = current_value;\n    }\n    temp_ptr = (int *)state[0xd];\n    *data = temp_data;\n    if (temp_ptr != (int *)0x0) {\n      if (temp_ptr != state + 0x11) {\n        _free_r(data);\n      }\n      state[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080051bc": "process_data_080051bc",
                "param_1": "data",
                "param_2": "state",
                "iVar1": "current_value",
                "piVar2": "temp_ptr",
                "uVar3": "temp_value",
                "uVar4": "flags",
                "iVar5": "increment",
                "pcVar6": "function_ptr",
                "iVar7": "remaining_value",
                "uVar8": "temp_data",
                "bVar9": "is_zero"
            },
            "calling": [
                "_fflush_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052cc": {
            "entrypoint": "0x080052cc",
            "current_name": "check_and_flush_080052cc",
            "code": "\nundefined4 checkAndFlush_080052cc(int fileDescriptor,undefined4 *streamPointer,undefined4 unused1,undefined4 unused2)\n\n{\n  undefined4 result;\n  \n  if (streamPointer[4] != 0) {\n    if ((fileDescriptor != 0) && (*(int *)(fileDescriptor + 0x18) == 0)) {\n      initializeStreams();\n    }\n    if (streamPointer == &fakeStdin) {\n      streamPointer = *(undefined4 **)(fileDescriptor + 4);\n    }\n    else if (streamPointer == (undefined4 *)&fakeStdout) {\n      streamPointer = *(undefined4 **)(fileDescriptor + 8);\n    }\n    else if (streamPointer == (undefined4 *)&fakeStderr) {\n      streamPointer = *(undefined4 **)(fileDescriptor + 0xc);\n    }\n    if (*(short *)(streamPointer + 3) != 0) {\n      result = flushStream(fileDescriptor,streamPointer,unused1,unused2);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080052cc": "check_and_flush_080052cc",
                "param_1": "fileDescriptor",
                "param_2": "streamPointer",
                "param_3": "unused1",
                "param_4": "unused2",
                "uVar1": "result",
                "__sinit": "initializeStreams",
                "__sf_fake_stdin": "fakeStdin",
                "__sf_fake_stdout": "fakeStdout",
                "__sf_fake_stderr": "fakeStderr",
                "__sflush_r": "flushStream"
            },
            "calling": [
                "__swbuf_r"
            ],
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005320": {
            "entrypoint": "0x08005320",
            "current_name": "execute_function_08005320",
            "code": "\nvoid execute_function_08005320(undefined4 reent_ptr)\n\n{\n  execute_file_walk(reent_ptr,0x80052cd);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005320": "execute_function_08005320",
                "param_1": "reent_ptr",
                "_fwalk_reent": "execute_file_walk"
            },
            "calling": [],
            "called": [
                "_fwalk_reent"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800532c": {
            "entrypoint": "0x0800532c",
            "current_name": "initialize_parameters_0800532c",
            "code": "\nvoid initializeParameters_0800532c(undefined4 *parameters,undefined2 value1,undefined2 value2)\n\n{\n  *parameters = 0;\n  parameters[1] = 0;\n  parameters[2] = 0;\n  *(undefined2 *)(parameters + 3) = value1;\n  parameters[25] = 0;\n  *(undefined2 *)((int)parameters + 0xe) = value2;\n  parameters[4] = 0;\n  parameters[5] = 0;\n  parameters[6] = 0;\n  memset(parameters + 0x17,0,8);\n  parameters[9] = 0x8005609;\n  parameters[10] = 0x800562b;\n  parameters[11] = 0x8005663;\n  parameters[8] = parameters;\n  parameters[12] = 0x8005687;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800532c": "initialize_parameters_0800532c",
                "param_1": "parameters",
                "param_2": "value1",
                "param_3": "value2",
                "param_1[1]": "parameters[1]",
                "param_1[2]": "parameters[2]",
                "param_1[0x19]": "parameters[25]",
                "param_1[4]": "parameters[4]",
                "param_1[5]": "parameters[5]",
                "param_1[6]": "parameters[6]",
                "param_1[9]": "parameters[9]",
                "param_1[10]": "parameters[10]",
                "param_1[0xb]": "parameters[11]",
                "param_1[8]": "parameters[8]",
                "param_1[0xc]": "parameters[12]"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005374": {
            "entrypoint": "0x08005374",
            "current_name": "allocate_buffer_08005374",
            "code": "\nundefined4 * allocateBuffer_08005374(undefined4 bufferSize,int numElements)\n\n{\n  undefined4 *buffer;\n  int totalBufferSize;\n  \n  totalBufferSize = (numElements + -1) * 0x68;\n  buffer = (undefined4 *)_malloc_r(bufferSize,totalBufferSize + 0x74);\n  if (buffer != (undefined4 *)0x0) {\n    *buffer = 0;\n    buffer[1] = numElements;\n    buffer[2] = buffer + 3;\n    memset(buffer + 3,0,totalBufferSize + 0x68);\n  }\n  return buffer;\n}\n\n",
            "renaming": {
                "FUN_08005374": "allocate_buffer_08005374",
                "param_1": "bufferSize",
                "param_2": "numElements",
                "puVar1": "buffer",
                "iVar2": "totalBufferSize"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "_malloc_r",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053a0": {
            "entrypoint": "0x080053a0",
            "current_name": "initialize_data_080053a0",
            "code": "\nvoid initializeData_080053a0(undefined1 *dataPtr)\n\n{\n  undefined4 result;\n  undefined1 *ptrToData;\n  \n  if (*(int *)(dataPtr + 0x18) == 0) {\n    *(undefined4 *)(dataPtr + 0x48) = 0;\n    *(undefined4 *)(dataPtr + 0x4c) = 0;\n    *(undefined4 *)(dataPtr + 0x50) = 0;\n    ptrToData = &data;\n    *(undefined4 *)(dataPtr + 0x28) = 0x8005321;\n    if (dataPtr == &data) {\n      ptrToData = (undefined1 *)0x1;\n    }\n    if (dataPtr == &data) {\n      *(undefined1 **)(dataPtr + 0x18) = ptrToData;\n    }\n    result = getFloatValue();\n    *(undefined4 *)(dataPtr + 4) = result;\n    result = getFloatValue(dataPtr);\n    *(undefined4 *)(dataPtr + 8) = result;\n    result = getFloatValue(dataPtr);\n    *(undefined4 *)(dataPtr + 0xc) = result;\n    processData(*(undefined4 *)(dataPtr + 4),4,0);\n    processData(*(undefined4 *)(dataPtr + 8),9,1);\n    processData(*(undefined4 *)(dataPtr + 0xc),0x12,2);\n    *(undefined4 *)(dataPtr + 0x18) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053a0": "initialize_data_080053a0",
                "param_1": "dataPtr",
                "uVar1": "result",
                "puVar2": "ptrToData",
                "impure_data": "data",
                "__sfp": "getFloatValue",
                "std_isra_0": "processData"
            },
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r",
                "iprintf",
                "_fflush_r",
                "__swsetup_r",
                "__sfp"
            ],
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005400": {
            "entrypoint": "0x08005400",
            "current_name": "initialize_data_structure_08005400",
            "code": "\nint * initializeDataStructure_08005400(undefined4 *errorFlag)\n\n{\n  int *currentPointer;\n  int *nestedPointer;\n  int **pointerArray;\n  \n  if (DAT_200000bc == 0) {\n    __sinit(&impure_data);\n  }\n  pointerArray = (int **)&DAT_200000ec;\n  do {\n    nestedPointer = pointerArray[2];\n    currentPointer = pointerArray[1];\n    while (currentPointer = (int *)((int)currentPointer + -1), -1 < (int)currentPointer) {\n      if (*(short *)(nestedPointer + 3) == 0) {\n        *(undefined2 *)((int)nestedPointer + 0xe) = 0xffff;\n        *(undefined2 *)(nestedPointer + 3) = 1;\n        nestedPointer[0x19] = 0;\n        *nestedPointer = 0;\n        nestedPointer[2] = 0;\n        nestedPointer[1] = 0;\n        nestedPointer[4] = 0;\n        nestedPointer[5] = 0;\n        nestedPointer[6] = 0;\n        memset(nestedPointer + 0x17,0,8);\n        nestedPointer[0xd] = 0;\n        nestedPointer[0xe] = 0;\n        nestedPointer[0x12] = 0;\n        nestedPointer[0x13] = 0;\n        return nestedPointer;\n      }\n      nestedPointer = nestedPointer + 0x1a;\n    }\n    if (*pointerArray == (int *)0x0) {\n      currentPointer = (int *)__sfmoreglue(errorFlag,4);\n      *pointerArray = currentPointer;\n      if (currentPointer == (int *)0x0) {\n        *errorFlag = 0xc;\n        return (int *)0x0;\n      }\n    }\n    pointerArray = (int **)*pointerArray;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005400": "initialize_data_structure_08005400",
                "param_1": "errorFlag",
                "piVar1": "currentPointer",
                "piVar2": "nestedPointer",
                "ppiVar3": "pointerArray"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__sfmoreglue",
                "__sinit",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005478": {
            "entrypoint": "0x08005478",
            "current_name": "process_data_08005478",
            "code": "\nuint processData_08005478(int input,code *callback,undefined4 paramA,undefined4 paramB)\n\n{\n  uint returnValue;\n  int incrementValue;\n  int *currentPtr;\n  int offset;\n  uint result;\n  int counter;\n  \n  result = 0;\n  for (currentPtr = (int *)(input + 0x48); currentPtr != (int *)0x0; currentPtr = (int *)*currentPtr) {\n    offset = currentPtr[2];\n    counter = currentPtr[1];\n    while (counter = counter + -1, -1 < counter) {\n      if ((1 < *(ushort *)(offset + 0xc)) && (incrementValue = *(short *)(offset + 0xe) + 1, incrementValue != 0)) {\n        returnValue = (*callback)(input,offset,paramA,incrementValue,paramB);\n        result = result | returnValue;\n      }\n      offset = offset + 0x68;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005478": "process_data_08005478",
                "param_1": "input",
                "param_2": "callback",
                "param_3": "paramA",
                "param_4": "paramB",
                "uVar1": "returnValue",
                "iVar2": "incrementValue",
                "piVar3": "currentPtr",
                "iVar4": "offset",
                "uVar5": "result",
                "iVar6": "counter"
            },
            "calling": [
                "_cleanup_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054b4": {
            "entrypoint": "0x080054b4",
            "current_name": "check_file_access_080054b4",
            "code": "\nundefined4 checkFileAccess_080054b4(undefined4 fileDescriptor,int fileInfo,undefined4 *accessResult,uint *fileFlags)\n\n{\n  int status;\n  undefined4 accessMode;\n  undefined statusBuffer [4];\n  uint modeFlags;\n  \n  if ((*(short *)(fileInfo + 0xe) < 0) ||\n     (status = _fstat_r(fileDescriptor,(int)*(short *)(fileInfo + 0xe),statusBuffer), status < 0)) {\n    *fileFlags = 0;\n    if ((int)((uint)*(ushort *)(fileInfo + 0xc) << 0x18) < 0) {\n      accessMode = 0x40;\n      goto LAB_080054f4;\n    }\n  }\n  else {\n    *fileFlags = (uint)((modeFlags & 0xf000) == 0x2000);\n  }\n  accessMode = 0x400;\nLAB_080054f4:\n  *accessResult = accessMode;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080054b4": "check_file_access_080054b4",
                "param_1": "fileDescriptor",
                "param_2": "fileInfo",
                "param_3": "accessResult",
                "param_4": "fileFlags",
                "iVar1": "status",
                "uVar2": "accessMode",
                "auStack_4c": "statusBuffer",
                "local_48": "modeFlags"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054fc": {
            "entrypoint": "0x080054fc",
            "current_name": "initialize_buffer_080054fc",
            "code": "\nvoid initializeBuffer_080054fc(int bufferSize,int *buffer)\n\n{\n  ushort status;\n  int allocatedBuffer;\n  int bufferSizeCopy;\n  int *bufferCopy;\n  \n  if (-1 < (int)((uint)*(ushort *)(buffer + 3) << 0x1e)) {\n    bufferSizeCopy = bufferSize;\n    bufferCopy = buffer;\n    status = __swhatbuf_r(bufferSize,buffer,&bufferSizeCopy,&bufferCopy);\n    allocatedBuffer = _malloc_r(bufferSize,bufferSizeCopy);\n    if (allocatedBuffer != 0) {\n      *(undefined4 *)(bufferSize + 0x28) = 0x8005321;\n      *buffer = allocatedBuffer;\n      *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) | 0x80;\n      buffer[5] = bufferSizeCopy;\n      buffer[4] = allocatedBuffer;\n      if ((bufferCopy != (int *)0x0) &&\n         (allocatedBuffer = _isatty_r(bufferSize,(int)*(short *)((int)buffer + 0xe)), allocatedBuffer != 0)) {\n        *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(buffer + 3) = status | *(ushort *)(buffer + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(buffer + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) & 0xfffc | 2;\n  }\n  *buffer = (int)buffer + 0x47;\n  buffer[4] = (int)buffer + 0x47;\n  buffer[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080054fc": "initialize_buffer_080054fc",
                "param_1": "bufferSize",
                "param_2": "buffer",
                "uVar1": "status",
                "iVar2": "allocatedBuffer",
                "local_18": "bufferSizeCopy",
                "local_14": "bufferCopy"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "_isatty_r",
                "__swhatbuf_r",
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800557c": {
            "entrypoint": "0x0800557c",
            "current_name": "FUNC_0800557c",
            "code": "\nvoid FUNC_0800557c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800557c": "FUNC_0800557c"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800557e": {
            "entrypoint": "0x0800557e",
            "current_name": "FUNC_0800557e",
            "code": "\nvoid FUNC_0800557e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800557e": "FUNC_0800557e"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005580": {
            "entrypoint": "0x08005580",
            "current_name": "process_operation_08005580",
            "code": "\nundefined4 process_operation_08005580(undefined4 *result_ptr,uint operation_id,undefined4 param_3,undefined4 param_4)\n\n{\n  __pid_t process_id;\n  undefined4 return_value;\n  int function_ptr;\n  code *code_ptr;\n  \n  if (0x1f < operation_id) {\n    *result_ptr = 0x16;\n    return 0xffffffff;\n  }\n  function_ptr = result_ptr[0x11];\n  if ((function_ptr != 0) && (code_ptr = *(code **)(function_ptr + operation_id * 4), code_ptr != (code *)0x0)) {\n    if (code_ptr != (code *)0x1) {\n      if (code_ptr == (code *)0xffffffff) {\n        *result_ptr = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(function_ptr + operation_id * 4) = 0;\n      (*code_ptr)(operation_id);\n    }\n    return 0;\n  }\n  process_id = _getpid_r();\n  return_value = _kill_r(result_ptr,process_id,operation_id,param_4);\n  return return_value;\n}\n\n",
            "renaming": {
                "FUN_08005580": "process_operation_08005580",
                "param_1": "result_ptr",
                "param_2": "operation_id",
                "_Var1": "process_id",
                "uVar2": "return_value",
                "iVar3": "function_ptr",
                "pcVar4": "code_ptr"
            },
            "calling": [
                "raise"
            ],
            "called": [
                "_getpid_r",
                "_kill_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055d0": {
            "entrypoint": "0x080055d0",
            "current_name": "raise_signal_080055d0",
            "code": "\nint raise_signal_080055d0(int signal_number)\n\n{\n  int result;\n  \n  result = _raise_r(_impure_ptr,signal_number);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080055d0": "raise_signal_080055d0",
                "__sig": "signal_number",
                "iVar1": "result"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "_raise_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055e0": {
            "entrypoint": "0x080055e0",
            "current_name": "execute_kill_080055e0",
            "code": "\nvoid executeKill_080055e0(int *errorCode,__pid_t targetProcess,int signal)\n\n{\n  int killResult;\n  \n  errno = 0;\n  killResult = _kill(targetProcess,signal);\n  if ((killResult == -1) && (errno != 0)) {\n    *errorCode = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055e0": "execute_kill_080055e0",
                "param_1": "errorCode",
                "param_2": "targetProcess",
                "param_3": "signal",
                "iVar1": "killResult"
            },
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_kill"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005604": {
            "entrypoint": "0x08005604",
            "current_name": "FUN_08005604",
            "code": "\n\n\n__pid_t _getpid(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {},
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_getpid"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005608": {
            "entrypoint": "0x08005608",
            "current_name": "update_data_08005608",
            "code": "\nvoid updateData_08005608(undefined4 fileDescriptor,int dataAddress)\n\n{\n  int readResult;\n  uint updatedValue;\n  bool isReadSuccessful;\n  \n  readResult = _read_r(fileDescriptor,(int)*(short *)(dataAddress + 0xe));\n  isReadSuccessful = -1 < readResult;\n  if (isReadSuccessful) {\n    updatedValue = *(int *)(dataAddress + 0x54) + readResult;\n  }\n  else {\n    updatedValue = *(ushort *)(dataAddress + 0xc) & 0xffffefff;\n  }\n  if (isReadSuccessful) {\n    *(uint *)(dataAddress + 0x54) = updatedValue;\n  }\n  if (!isReadSuccessful) {\n    *(short *)(dataAddress + 0xc) = (short)updatedValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005608": "update_data_08005608",
                "param_1": "fileDescriptor",
                "param_2": "dataAddress",
                "iVar1": "readResult",
                "uVar2": "updatedValue",
                "bVar3": "isReadSuccessful"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800562a": {
            "entrypoint": "0x0800562a",
            "current_name": "write_data_if_needed_0800562a",
            "code": "\nvoid writeDataIfNeeded_0800562a(undefined4 fileDescriptor,int bufferAddress,undefined4 dataAddress,undefined4 dataSize)\n\n{\n  if ((int)((uint)*(ushort *)(bufferAddress + 0xc) << 0x17) < 0) {\n    _lseek_r(fileDescriptor,(int)*(short *)(bufferAddress + 0xe),0,2);\n  }\n  *(ushort *)(bufferAddress + 0xc) = *(ushort *)(bufferAddress + 0xc) & 0xefff;\n  _write_r(fileDescriptor,(int)*(short *)(bufferAddress + 0xe),dataAddress,dataSize);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800562a": "write_data_if_needed_0800562a",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddress",
                "param_3": "dataAddress",
                "param_4": "dataSize"
            },
            "calling": [],
            "called": [
                "_lseek_r",
                "_write_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005662": {
            "entrypoint": "0x08005662",
            "current_name": "update_file_pointer_08005662",
            "code": "\nvoid updateFilePointer_08005662(undefined4 fileDescriptor,int data)\n\n{\n  int seekResult;\n  ushort updatedFlags;\n  bool isSeekError;\n  \n  seekResult = _lseek_r(fileDescriptor,(int)*(short *)(data + 0xe));\n  isSeekError = seekResult == -1;\n  if (isSeekError) {\n    updatedFlags = *(ushort *)(data + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(data + 0x54) = seekResult;\n    updatedFlags = *(ushort *)(data + 0xc) | 0x1000;\n  }\n  if (isSeekError) {\n    *(ushort *)(data + 0xc) = updatedFlags;\n  }\n  if (!isSeekError) {\n    *(ushort *)(data + 0xc) = updatedFlags;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005662": "update_file_pointer_08005662",
                "param_1": "fileDescriptor",
                "param_2": "data",
                "iVar1": "seekResult",
                "uVar2": "updatedFlags",
                "bVar3": "isSeekError"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005686": {
            "entrypoint": "0x08005686",
            "current_name": "close_file_descriptor_08005686",
            "code": "\nvoid closeFileDescriptor_08005686(undefined4 fileDescriptor,int bufferAddress)\n\n{\n  closeFile(fileDescriptor,(int)*(short *)(bufferAddress + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005686": "close_file_descriptor_08005686",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddress",
                "_close_r": "closeFile"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005690": {
            "entrypoint": "0x08005690",
            "current_name": "write_and_handle_errno_08005690",
            "code": "\nvoid write_and_handle_errno_08005690(int *error_code,int file_descriptor,char *buffer,int count)\n\n{\n  int write_result;\n  \n  error_number = 0;\n  write_result = _write(file_descriptor,buffer,count);\n  if ((write_result == -1) && (error_number != 0)) {\n    *error_code = error_number;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005690": "write_and_handle_errno_08005690",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "count",
                "errno": "error_number",
                "iVar1": "write_result"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056b4": {
            "entrypoint": "0x080056b4",
            "current_name": "close_file_080056b4",
            "code": "\nvoid closeFile_080056b4(int *errorPtr,int fileDescriptor)\n\n{\n  int closeResult;\n  \n  errno = 0;\n  closeResult = _close(fileDescriptor);\n  if ((closeResult == -1) && (errno != 0)) {\n    *errorPtr = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056b4": "close_file_080056b4",
                "param_1": "errorPtr",
                "param_2": "fileDescriptor",
                "iVar1": "closeResult"
            },
            "calling": [
                "__sclose"
            ],
            "called": [
                "_close"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056d4": {
            "entrypoint": "0x080056d4",
            "current_name": "get_file_status_080056d4",
            "code": "\nvoid get_file_status_080056d4(int *error_code,int file_descriptor,stat *status_struct)\n\n{\n  int result;\n  \n  errno = 0;\n  result = _fstat(file_descriptor,status_struct);\n  if ((result == -1) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056d4": "get_file_status_080056d4",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "status_struct",
                "iVar1": "result"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056f8": {
            "entrypoint": "0x080056f8",
            "current_name": "check_if_tty_080056f8",
            "code": "\nvoid checkIfTTY_080056f8(int *errorNumber,int fileDescriptor)\n\n{\n  int isTTY;\n  \n  errno = 0;\n  isTTY = _isatty(fileDescriptor);\n  if ((isTTY == -1) && (errno != 0)) {\n    *errorNumber = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056f8": "check_if_tty_080056f8",
                "param_1": "errorNumber",
                "param_2": "fileDescriptor",
                "iVar1": "isTTY"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005718": {
            "entrypoint": "0x08005718",
            "current_name": "set_errno_if_lseek_failed_08005718",
            "code": "\nvoid setErrnoIfLseekFailed_08005718(int *errorCode,int fileDescriptor,__off_t offset,int whence)\n\n{\n  __off_t seekResult;\n  \n  errno = 0;\n  seekResult = _lseek(fileDescriptor,offset,whence);\n  if ((seekResult == -1) && (errno != 0)) {\n    *errorCode = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005718": "set_errno_if_lseek_failed_08005718",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "seekResult"
            },
            "calling": [
                "__swrite",
                "__sseek"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800573c": {
            "entrypoint": "0x0800573c",
            "current_name": "read_from_file_0800573c",
            "code": "\nvoid readFromFile_0800573c(int *errorCode,int fileDescriptor,char *buffer,int numBytes)\n\n{\n  int readResult;\n  \n  errno = 0;\n  readResult = _read(fileDescriptor,buffer,numBytes);\n  if ((readResult == -1) && (errno != 0)) {\n    *errorCode = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800573c": "read_from_file_0800573c",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "numBytes",
                "iVar1": "readResult"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005760": {
            "entrypoint": "0x08005760",
            "current_name": "abort_function_08005760",
            "code": "\n\n/* std::__throw_bad_function_call() */\n\nvoid std::abort_function_08005760(void)\n\n{\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_08005760": "abort_function_08005760"
            },
            "calling": [
                "operator()"
            ],
            "called": [
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005768": {
            "entrypoint": "0x08005768",
            "current_name": "initialize_standard_library_components_08005768",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeStandardLibraryComponents_08005768(void)\n\n{\n  if (-1 < moneypunct<char,false>::id << 0x1f) {\n    moneypunct<char,false>::id = 1;\n  }\n  if (-1 < moneypunct<char,true>::id << 0x1f) {\n    moneypunct<char,true>::id = 1;\n  }\n  if (-1 < money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < numpunct<char>::id << 0x1f) {\n    numpunct<char>::id = 1;\n  }\n  if (-1 < num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __timepunct<char>::id << 0x1f) {\n    __timepunct<char>::id = 1;\n  }\n  if (-1 < time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < messages<char>::id << 0x1f) {\n    messages<char>::id = 1;\n  }\n  if (-1 < collate<char>::id << 0x1f) {\n    collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005768": "initialize_standard_library_components_08005768"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800582c": {
            "entrypoint": "0x0800582c",
            "current_name": "initialize_c_type_by_name_0800582c",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeCTypeByName_0800582c(void)\n\n{\n  if (-1 < moneypunct<wchar_t,false>::id << 0x1f) {\n    moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < moneypunct<wchar_t,true>::id << 0x1f) {\n    moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < numpunct<wchar_t>::id << 0x1f) {\n    numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __timepunct<wchar_t>::id << 0x1f) {\n    __timepunct<wchar_t>::id = 1;\n  }\n  if (-1 < time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < messages<wchar_t>::id << 0x1f) {\n    messages<wchar_t>::id = 1;\n  }\n  if (-1 < collate<wchar_t>::id << 0x1f) {\n    collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800582c": "initialize_c_type_by_name_0800582c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058f0": {
            "entrypoint": "0x080058f0",
            "current_name": "set_cpp_locale_ids_080058f0",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::set_cpp_locale_ids_080058f0(void)\n\n{\n  if (-1 < __cxx11::moneypunct<wchar_t,false>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<wchar_t,true>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<wchar_t>::id << 0x1f) {\n    __cxx11::numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<wchar_t>::id << 0x1f) {\n    __cxx11::messages<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::collate<wchar_t>::id << 0x1f) {\n    __cxx11::collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080058f0": "set_cpp_locale_ids_080058f0"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005974": {
            "entrypoint": "0x08005974",
            "current_name": "initialize_ctype_by_name_08005974",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeCtypeByName_08005974(void)\n\n{\n  if (-1 < __cxx11::moneypunct<char,false>::id << 0x1f) {\n    __cxx11::moneypunct<char,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<char,true>::id << 0x1f) {\n    __cxx11::moneypunct<char,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<char>::id << 0x1f) {\n    __cxx11::numpunct<char>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f\n     ) {\n    __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<char>::id << 0x1f) {\n    __cxx11::messages<char>::id = 1;\n  }\n  if (-1 < __cxx11::collate<char>::id << 0x1f) {\n    __cxx11::collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005974": "initialize_ctype_by_name_08005974"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f8": {
            "entrypoint": "0x080059f8",
            "current_name": "FUNC_080059f8",
            "code": "\nvoid FUNC_080059f8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080059f8": "FUNC_080059f8"
            },
            "calling": [
                "__do_global_dtors_aux",
                "__libc_init_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005a04": {
            "entrypoint": "0x08005a04",
            "current_name": "FUNC_08005a04",
            "code": "\nvoid FUNC_08005a04(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a04": "FUNC_08005a04"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 142531,
    "layers": [
        [
            "FUN_080001ac",
            "FUN_08000218",
            "FUN_08000230",
            "FUN_080002d0",
            "FUN_08000300",
            "FUN_080005e0",
            "FUN_080005e4",
            "FUN_08000600",
            "FUN_0800066c",
            "FUN_08000682",
            "FUN_08000690",
            "FUN_080006b4",
            "FUN_08000728",
            "FUN_0800076c",
            "FUN_080007f0",
            "FUN_080008cc",
            "FUN_080008e2",
            "FUN_08000998",
            "FUN_08000a00",
            "FUN_08000a4e",
            "FUN_08000a7a",
            "FUN_08000b04",
            "FUN_08000b54",
            "FUN_08000c4c",
            "FUN_08000c64",
            "FUN_08000c7c",
            "FUN_08000c8c",
            "FUN_08000d3c",
            "FUN_08000d8c",
            "FUN_08000d8e",
            "FUN_08000d98",
            "FUN_08000de4",
            "FUN_08000e18",
            "FUN_08000e30",
            "FUN_08000e3c",
            "FUN_08000e60",
            "FUN_08000ec4",
            "FUN_08000ee0",
            "FUN_08000f0c",
            "FUN_08000f2c",
            "FUN_08000f4e",
            "FUN_08000f56",
            "FUN_08000f72",
            "FUN_08000f8c",
            "FUN_08000fb4",
            "FUN_08001198",
            "FUN_080011a4",
            "FUN_080011c0",
            "FUN_0800124a",
            "FUN_08001256",
            "FUN_08001420",
            "FUN_08001440",
            "FUN_08001460",
            "FUN_080014ec",
            "FUN_08001578",
            "FUN_080015bc",
            "FUN_0800160e",
            "FUN_0800165a",
            "FUN_08001684",
            "FUN_0800171a",
            "FUN_08001864",
            "FUN_08001904",
            "FUN_080019a0",
            "FUN_08001ab0",
            "FUN_08001bfc",
            "FUN_08001d00",
            "FUN_08001e68",
            "FUN_08001f3c",
            "FUN_08001f9c",
            "FUN_0800201c",
            "FUN_080023b4",
            "FUN_08002488",
            "FUN_080025e0",
            "FUN_080025ec",
            "FUN_0800260c",
            "FUN_0800262c",
            "FUN_0800268e",
            "FUN_080026ce",
            "FUN_08002848",
            "FUN_08002864",
            "FUN_080028d4",
            "FUN_080028f0",
            "FUN_08002940",
            "FUN_0800295c",
            "FUN_080029c8",
            "FUN_08002d0c",
            "FUN_08002d72",
            "FUN_08002dd0",
            "FUN_08002eb2",
            "FUN_08002efa",
            "FUN_08002f4c",
            "FUN_08002f66",
            "FUN_08002ffc",
            "FUN_0800311c",
            "FUN_0800312c",
            "FUN_08003138",
            "FUN_0800314e",
            "FUN_0800316c",
            "FUN_0800318c",
            "FUN_080031fc",
            "FUN_08003380",
            "FUN_0800339c",
            "FUN_080033c8",
            "FUN_080033d8",
            "FUN_0800340c",
            "FUN_08003414",
            "FUN_0800346c",
            "FUN_08003476",
            "FUN_08003486",
            "FUN_080034b6",
            "FUN_080034ce",
            "FUN_080034da",
            "FUN_080034f4",
            "FUN_08003506",
            "FUN_0800351e",
            "FUN_0800352e",
            "FUN_0800354a",
            "FUN_0800355e",
            "FUN_08003582",
            "FUN_08003594",
            "FUN_080035ac",
            "FUN_080035bc",
            "FUN_080035fc",
            "FUN_08003750",
            "FUN_08003754",
            "FUN_0800376e",
            "FUN_0800377c",
            "FUN_08003798",
            "FUN_080037ac",
            "FUN_080037c0",
            "FUN_080037d4",
            "FUN_080037e8",
            "FUN_080037fc",
            "FUN_08003810",
            "FUN_0800382c",
            "FUN_08003840",
            "FUN_08003854",
            "FUN_08003868",
            "FUN_0800387c",
            "FUN_08003880",
            "FUN_080038d0",
            "FUN_08003900",
            "FUN_08003918",
            "FUN_08003928",
            "FUN_08003938",
            "FUN_08003948",
            "FUN_08003958",
            "FUN_08003968",
            "FUN_08003978",
            "FUN_08003cc8",
            "FUN_08003d18",
            "FUN_08003dd0",
            "FUN_08003df4",
            "FUN_08003e18",
            "FUN_08003e54",
            "FUN_08003eac",
            "FUN_08003f00",
            "FUN_08003f24",
            "FUN_08003f48",
            "FUN_08003f94",
            "FUN_08003fd4",
            "FUN_08003fec",
            "FUN_08004004",
            "FUN_0800401c",
            "FUN_08004034",
            "FUN_0800404c",
            "FUN_08004064",
            "FUN_0800407c",
            "FUN_08004094",
            "FUN_080040d0",
            "FUN_080040d6",
            "FUN_080040e0",
            "FUN_080040e4",
            "FUN_080040e8",
            "FUN_080040ec",
            "FUN_080040f8",
            "FUN_080040fc",
            "FUN_0800410c",
            "FUN_08004110",
            "FUN_080041bc",
            "FUN_08004204",
            "FUN_0800420c",
            "FUN_08004240",
            "FUN_08004254",
            "FUN_08004270",
            "FUN_08004298",
            "FUN_080042ac",
            "FUN_080042e8",
            "FUN_08004364",
            "FUN_08004388",
            "FUN_08004444",
            "FUN_08004460",
            "FUN_0800447c",
            "FUN_080044d8",
            "FUN_080044fc",
            "FUN_0800450a",
            "FUN_08004544",
            "FUN_08004560",
            "FUN_0800458c",
            "FUN_0800459a",
            "FUN_080045be",
            "FUN_080045c8",
            "FUN_08004622",
            "FUN_08004638",
            "FUN_08004640",
            "FUN_08004648",
            "FUN_08004658",
            "FUN_08004678",
            "FUN_0800468c",
            "FUN_080046b4",
            "FUN_08004760",
            "FUN_0800476a",
            "FUN_08004774",
            "FUN_0800477e",
            "FUN_08004788",
            "FUN_08004792",
            "FUN_080047a8",
            "FUN_080047c0",
            "FUN_080047d0",
            "FUN_080047f0",
            "FUN_080047fe",
            "FUN_08004808",
            "FUN_08004844",
            "FUN_08004860",
            "FUN_08004884",
            "FUN_080048cc",
            "FUN_080048dc",
            "FUN_08004978",
            "FUN_08004a34",
            "FUN_08004a60",
            "FUN_08004a84",
            "FUN_08004cb0",
            "FUN_08004d9c",
            "FUN_08004fdc",
            "FUN_0800500c",
            "FUN_0800502c",
            "FUN_080050d0",
            "FUN_080051ac",
            "FUN_080051bc",
            "FUN_080052cc",
            "FUN_08005320",
            "FUN_0800532c",
            "FUN_08005374",
            "FUN_080053a0",
            "FUN_08005400",
            "FUN_08005478",
            "FUN_080054b4",
            "FUN_080054fc",
            "FUN_08005580",
            "FUN_080055d0",
            "FUN_080055e0",
            "FUN_08005608",
            "FUN_0800562a",
            "FUN_08005662",
            "FUN_08005686",
            "FUN_08005690",
            "FUN_080056b4",
            "FUN_080056d4",
            "FUN_080056f8",
            "FUN_08005718",
            "FUN_0800573c",
            "FUN_08005760",
            "FUN_08005768",
            "FUN_0800582c",
            "FUN_080058f0",
            "FUN_08005974"
        ]
    ],
    "locked_functions": []
}