{
  "functions": {
    "__do_global_dtors_aux": {
      "entrypoint": "0x000800f4",
      "current_name": "__do_global_dtors_aux",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00080100) */\n\nundefined4 __do_global_dtors_aux(undefined4 param_1)\n\n{\n  if ((char)completed_7857 \u003d\u003d \u0027\\0\u0027) {\n    completed_7857._0_1_ \u003d \u0027\\x01\u0027;\n  }\n  return param_1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_fini_array"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "frame_dummy": {
      "entrypoint": "0x00080118",
      "current_name": "frame_dummy",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x0008011e) */\n/* WARNING: Removing unreachable block (ram,0x00080130) */\n\n\nvoid frame_dummy(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_init_array"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "aflCall": {
      "entrypoint": "0x00080148",
      "current_name": "aflCall",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t aflCall(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
      "renaming": {},
      "calling": [
        "startForkserver"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "startForkserver": {
      "entrypoint": "0x0008014c",
      "current_name": "startForkserver",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint startForkserver(int ticks)\n\n{\n  uint32_t uVar1;\n  \n  if (noHyperCall \u003d\u003d 0) {\n    uVar1 \u003d aflCall(1,ticks,0);\n    return uVar1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup"
      ],
      "called": [
        "aflCall"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "begin": {
      "entrypoint": "0x000815ca",
      "current_name": "begin",
      "code": "\n/* DWARF original prototype: void  begin(USARTClass * this, uint32_t dwBaudRate) */\n\nvoid __thiscall USARTClass::begin(USARTClass *this,uint32_t dwBaudRate)\n\n{\n  UARTClass::init(\u0026this-\u003esuper_UARTClass,(EVP_PKEY_CTX *)dwBaudRate);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getRxBuffer": {
      "entrypoint": "0x000801b0",
      "current_name": "getRxBuffer",
      "code": "\n/* DWARF original prototype: int8_t  getRxBuffer(Modbus * this) */\n\nint8_t __thiscall Modbus::getRxBuffer(Modbus *this)\n\n{\n  bool bVar1;\n  uchar uVar2;\n  uint8_t uVar3;\n  int iVar4;\n  byte bVar5;\n  \n  if (1 \u003c this-\u003eu8txenpin) {\n    digitalWrite((uint)this-\u003eu8txenpin,0);\n  }\n  bVar1 \u003d false;\n  this-\u003eu8BufferSize \u003d \u0027\\0\u0027;\n  if (this-\u003eu8serno \u003c 4) {\n    while (iVar4 \u003d (**(code **)(*(int *)this-\u003eport + 8))(), iVar4 !\u003d 0) {\n      bVar5 \u003d this-\u003eu8BufferSize;\n      uVar2 \u003d (**(code **)(*(int *)this-\u003eport + 0xc))();\n      uVar3 \u003d this-\u003eu8BufferSize;\n      this-\u003eau8Buffer[bVar5] \u003d uVar2;\n      bVar5 \u003d uVar3 + 1;\n      this-\u003eu8BufferSize \u003d bVar5;\n      if (0x3f \u003c bVar5) {\n        bVar1 \u003d true;\n      }\n    }\n  }\n  this-\u003eu16InCnt \u003d this-\u003eu16InCnt + 1;\n  if (bVar1) {\n    uVar3 \u003d 0xfd;\n    this-\u003eu16errCnt \u003d this-\u003eu16errCnt + 1;\n  }\n  else {\n    uVar3 \u003d this-\u003eu8BufferSize;\n  }\n  return uVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "poll"
      ],
      "called": [
        "digitalWrite"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "calcCRC": {
      "entrypoint": "0x0008021c",
      "current_name": "calcCRC",
      "code": "\n/* DWARF original prototype: uint16_t  calcCRC(Modbus * this, uint8_t u8length) */\n\nuint16_t __thiscall Modbus::calcCRC(Modbus *this,uint8_t u8length)\n\n{\n  Modbus *pMVar1;\n  uint uVar2;\n  char cVar3;\n  uint uVar4;\n  uint flag;\n  \n  uVar2 \u003d 0xffff;\n  for (pMVar1 \u003d this; ((int)pMVar1 - (int)this \u0026 0xffU) \u003c (uint)u8length;\n      pMVar1 \u003d (Modbus *)((int)\u0026pMVar1-\u003eport + 1)) {\n    uVar2 \u003d uVar2 ^ pMVar1-\u003eau8Buffer[0];\n    cVar3 \u003d \u0027\\b\u0027;\n    do {\n      uVar4 \u003d uVar2 \u0026 1;\n      uVar2 \u003d uVar2 \u003e\u003e 1;\n      if (uVar4 !\u003d 0) {\n        uVar2 \u003d uVar2 ^ 0xa001;\n      }\n      cVar3 \u003d cVar3 + -1;\n    } while (cVar3 !\u003d \u0027\\0\u0027);\n  }\n  return (ushort)(uVar2 \u003c\u003c 8) | (ushort)(uVar2 \u003e\u003e 8);\n}\n\n",
      "renaming": {},
      "calling": [
        "sendTxBuffer"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sendTxBuffer": {
      "entrypoint": "0x00080258",
      "current_name": "sendTxBuffer",
      "code": "\n/* DWARF original prototype: void  sendTxBuffer(Modbus * this) */\n\nvoid __thiscall Modbus::sendTxBuffer(Modbus *this)\n\n{\n  byte u8length;\n  uint16_t uVar1;\n  uint16_t u16crc;\n  uint32_t uVar2;\n  int iVar3;\n  \n  u8length \u003d this-\u003eu8BufferSize;\n  uVar1 \u003d calcCRC(this,u8length);\n  this-\u003eau8Buffer[u8length] \u003d (uchar)(uVar1 \u003e\u003e 8);\n  this-\u003eau8Buffer[u8length + 1 \u0026 0xff] \u003d (uchar)uVar1;\n  this-\u003eu8BufferSize \u003d u8length + 2;\n  if (1 \u003c this-\u003eu8txenpin) {\n    digitalWrite((uint)this-\u003eu8txenpin,1);\n  }\n  if (this-\u003eu8serno \u003c 4) {\n    (**(code **)(*(int *)this-\u003eport + 4))(this-\u003eport,this-\u003eau8Buffer,this-\u003eu8BufferSize);\n  }\n  if (1 \u003c this-\u003eu8txenpin) {\n    digitalWrite((uint)this-\u003eu8txenpin,0);\n  }\n  if (this-\u003eu8serno \u003c 4) {\n    do {\n      iVar3 \u003d (**(code **)(*(int *)this-\u003eport + 0xc))();\n    } while (-1 \u003c iVar3);\n  }\n  this-\u003eu8BufferSize \u003d \u0027\\0\u0027;\n  uVar2 \u003d millis();\n  this-\u003eu32timeOut \u003d uVar2 + this-\u003eu16timeOut;\n  this-\u003eu16OutCnt \u003d this-\u003eu16OutCnt + 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "query"
      ],
      "called": [
        "calcCRC",
        "millis",
        "digitalWrite"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "query": {
      "entrypoint": "0x000802da",
      "current_name": "query",
      "code": "\n/* DWARF original prototype: int8_t  query(Modbus * this, modbus_t telegram) */\n\nint8_t __thiscall Modbus::query(Modbus *this,modbus_t telegram)\n\n{\n  uchar uVar1;\n  uint in_r1;\n  uint8_t u8bytesno;\n  byte bVar3;\n  ushort in_r2;\n  ushort *puVar4;\n  uint8_t uVar5;\n  ushort uVar6;\n  ushort *in_r3;\n  uint uVar7;\n  ushort *puVar8;\n  uchar local_1c;\n  uchar local_1b;\n  uchar uVar2;\n  \n  local_1c \u003d (uchar)in_r1;\n  local_1b \u003d (uchar)(in_r1 \u003e\u003e 8);\n  uVar7 \u003d (uint)in_r2;\n  if (this-\u003eu8id !\u003d \u0027\\0\u0027) {\n    return -2;\n  }\n  if (this-\u003eu8state !\u003d \u0027\\0\u0027) {\n    return -1;\n  }\n  if (0xf6 \u003c ((in_r1 \u0026 0xff) - 1 \u0026 0xff)) {\n    return -3;\n  }\n  this-\u003eau8Buffer[0] \u003d local_1c;\n  this-\u003eau8Buffer[1] \u003d local_1b;\n  this-\u003eau16regs \u003d in_r3;\n  this-\u003eau8Buffer[2] \u003d (uchar)(in_r1 \u003e\u003e 0x18);\n  this-\u003eau8Buffer[3] \u003d (uchar)(in_r1 \u003e\u003e 0x10);\n  uVar1 \u003d (uchar)in_r2;\n  uVar2 \u003d (uchar)(in_r2 \u003e\u003e 8);\n  switch(local_1b) {\n  case \u0027\\x01\u0027:\n  case \u0027\\x02\u0027:\n  case \u0027\\x03\u0027:\n  case \u0027\\x04\u0027:\n    this-\u003eau8Buffer[4] \u003d uVar2;\n    break;\n  case \u0027\\x05\u0027:\n    uVar6 \u003d *in_r3;\n    if (uVar6 !\u003d 0) {\n      uVar6 \u003d 1;\n    }\n    this-\u003eau8Buffer[4] \u003d -(char)uVar6;\n    uVar7 \u003d 0;\n    break;\n  case \u0027\\x06\u0027:\n    this-\u003eau8Buffer[4] \u003d (uchar)(*in_r3 \u003e\u003e 8);\n    uVar7 \u003d (uint)*in_r3;\n    break;\n  default:\n    goto switchD_0008031e_caseD_7;\n  case \u0027\\x0f\u0027:\n    bVar3 \u003d (byte)(in_r2 \u003e\u003e 3) \u0026 0xfe;\n    if ((in_r2 \u0026 0xf) !\u003d 0) {\n      bVar3 \u003d bVar3 + 1;\n    }\n    this-\u003eau8Buffer[5] \u003d uVar1;\n    this-\u003eau8Buffer[4] \u003d uVar2;\n    this-\u003eau8Buffer[6] \u003d bVar3;\n    uVar5 \u003d \u0027\\a\u0027;\n    goto LAB_0008034a;\n  case \u0027\\x10\u0027:\n    this-\u003eau8Buffer[4] \u003d uVar2;\n    this-\u003eau8Buffer[5] \u003d uVar1;\n    puVar4 \u003d in_r3 + -1;\n    this-\u003eau8Buffer[6] \u003d uVar1 * \u0027\\x02\u0027;\n    this-\u003eu8BufferSize \u003d \u0027\\a\u0027;\n    puVar8 \u003d puVar4 + uVar7;\n    while (puVar4 !\u003d puVar8) {\n      bVar3 \u003d this-\u003eu8BufferSize;\n      this-\u003eau8Buffer[bVar3] \u003d (uchar)(puVar4[1] \u003e\u003e 8);\n      uVar7 \u003d bVar3 + 1 \u0026 0xff;\n      this-\u003eu8BufferSize \u003d (uint8_t)uVar7;\n      puVar4 \u003d puVar4 + 1;\n      this-\u003eau8Buffer[uVar7] \u003d (uchar)*puVar4;\n      this-\u003eu8BufferSize \u003d bVar3 + 2;\n    }\n    goto switchD_0008031e_caseD_7;\n  }\n  this-\u003eau8Buffer[5] \u003d (uchar)uVar7;\n  uVar5 \u003d \u0027\\x06\u0027;\nLAB_0008034a:\n  this-\u003eu8BufferSize \u003d uVar5;\nswitchD_0008031e_caseD_7:\n  sendTxBuffer(this);\n  this-\u003eu8state \u003d \u0027\\x01\u0027;\n  return \u0027\\0\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "sendTxBuffer"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "validateAnswer": {
      "entrypoint": "0x000803d4",
      "current_name": "validateAnswer",
      "code": "\n/* DWARF original prototype: uint8_t  validateAnswer(Modbus * this) */\n\nuint8_t __thiscall Modbus::validateAnswer(Modbus *this)\n\n{\n  uint8_t i;\n  int iVar1;\n  \n  if ((int)((uint)this-\u003eau8Buffer[1] \u003c\u003c 0x18) \u003c 0) {\n    this-\u003eu16errCnt \u003d this-\u003eu16errCnt + 1;\n    return 0xfb;\n  }\n  iVar1 \u003d 0;\n  do {\n    if (\"\\x01\\x02\\x03\\x04\\x05\\x06\\x0f\\x10\"[iVar1] \u003d\u003d this-\u003eau8Buffer[1]) {\n      return \u0027\\0\u0027;\n    }\n    iVar1 \u003d iVar1 + 1;\n  } while (iVar1 !\u003d 8);\n  this-\u003eu16errCnt \u003d this-\u003eu16errCnt + 1;\n  return \u0027\\x01\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "poll"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "get_FC3": {
      "entrypoint": "0x00080410",
      "current_name": "get_FC3",
      "code": "\n/* DWARF original prototype: void  get_FC3(Modbus * this) */\n\nvoid __thiscall Modbus::get_FC3(Modbus *this)\n\n{\n  uint16_t uVar1;\n  uint uVar2;\n  byte bVar3;\n  uint uVar4;\n  uint16_t *puVar5;\n  \n  bVar3 \u003d 0;\n  while( true ) {\n    uVar4 \u003d (uint)bVar3;\n    bVar3 \u003d bVar3 + 1;\n    uVar2 \u003d uVar4 * 2 + 3 \u0026 0xff;\n    if (this-\u003eau8Buffer[2] \u003e\u003e 1 \u003c\u003d uVar4) break;\n    puVar5 \u003d this-\u003eau16regs;\n    uVar1 \u003d makeWord(this-\u003eau8Buffer[uVar2],this-\u003eau8Buffer[uVar2 + 1]);\n    puVar5[uVar4] \u003d uVar1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "poll"
      ],
      "called": [
        "makeWord"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "poll": {
      "entrypoint": "0x0008043e",
      "current_name": "poll",
      "code": "\n/* DWARF original prototype: int8_t  poll(Modbus * this) */\n\nint __thiscall Modbus::poll(Modbus *this,pollfd *__fds,nfds_t __nfds,int __timeout)\n\n{\n  byte bVar1;\n  uint8_t uVar2;\n  uint8_t u8exception;\n  uint32_t uVar3;\n  uint8_t u8current;\n  uint unaff_r6;\n  \n  if (this-\u003eu8serno \u003c 4) {\n    bVar1 \u003d (**(code **)(*(int *)this-\u003eport + 8))();\n    unaff_r6 \u003d (uint)bVar1;\n  }\n  uVar3 \u003d millis();\n  if (this-\u003eu32timeOut \u003c uVar3) {\n    this-\u003eu8lastError \u003d 0xff;\n    this-\u003eu8state \u003d \u0027\\0\u0027;\n    this-\u003eu16errCnt \u003d this-\u003eu16errCnt + 1;\n  }\n  else if (7 \u003c unaff_r6) {\n    getRxBuffer(this);\n    uVar2 \u003d validateAnswer(this);\n    if (uVar2 \u003d\u003d \u0027\\0\u0027) {\n      if (this-\u003eau8Buffer[1] - 3 \u003c 2) {\n        get_FC3(this);\n      }\n      this-\u003eu8state \u003d \u0027\\0\u0027;\n      uVar2 \u003d this-\u003eu8BufferSize;\n    }\n    else {\n      this-\u003eu8state \u003d \u0027\\0\u0027;\n    }\n    goto LAB_000804a2;\n  }\n  uVar2 \u003d \u0027\\0\u0027;\nLAB_000804a2:\n  return (int)(char)uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "getRxBuffer",
        "get_FC3",
        "validateAnswer",
        "millis"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setup": {
      "entrypoint": "0x000804a8",
      "current_name": "setup",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setup(void)\n\n{\n  uint32_t uVar1;\n  \n  pinMode(1,0);\n  pinMode(6,1);\n  pinMode(0,1);\n  pinMode(1,1);\n  digitalWrite(0,0);\n  digitalWrite(1,0);\n  telegram[1].u16RegAdd \u003d 0x13;\n  telegram[1].u16CoilsNo \u003d 10;\n  telegram[1].au16reg \u003d au16data + 0x13;\n  telegram[0].u8fct \u003d \u0027\\x03\u0027;\n  telegram[2].u8fct \u003d \u0027\\x03\u0027;\n  telegram[2].u16RegAdd \u003d 0x14;\n  telegram[3].u16CoilsNo \u003d 3;\n  telegram[0].u16CoilsNo \u003d 0x10;\n  telegram[0].au16reg \u003d au16data;\n  telegram[1].u8fct \u003d \u0027\\x10\u0027;\n  telegram[2].u16CoilsNo \u003d 0xc;\n  telegram[3].u8fct \u003d \u0027\\x10\u0027;\n  telegram[4].u16CoilsNo \u003d 8;\n  telegram[3].u16RegAdd \u003d 0x1c;\n  telegram[3].au16reg \u003d au16data + 0x1c;\n  telegram[4].u8id \u003d \u0027\\x02\u0027;\n  telegram[4].u8fct \u003d \u0027\\x02\u0027;\n  telegram[4].au16reg \u003d data8024;\n  telegram[5].u8id \u003d \u0027\\x02\u0027;\n  telegram[0].u8id \u003d \u0027\\x01\u0027;\n  telegram[1].u8id \u003d \u0027\\x01\u0027;\n  telegram[2].u8id \u003d \u0027\\x01\u0027;\n  telegram[3].u8id \u003d \u0027\\x01\u0027;\n  telegram[5].u16RegAdd \u003d 1;\n  telegram[5].u16CoilsNo \u003d 1;\n  telegram[0].u16RegAdd \u003d 0;\n  telegram[2].au16reg \u003d au16data + 0x14;\n  telegram[4].u16RegAdd \u003d 0;\n  telegram[5].u8fct \u003d \u0027\\x05\u0027;\n  telegram[5].au16reg \u003d data8024 + 1;\n  Modbus::begin(\u0026master,0x4b00);\n  master.u16timeOut \u003d 2000;\n  u32wait \u003d millis();\n  uVar1 \u003d millis();\n  tiempopid1 \u003d uVar1 + 1000;\n  uVar1 \u003d millis();\n  dutyalto1 \u003d uVar1 + 1000;\n  uVar1 \u003d millis();\n  dutybajo1 \u003d uVar1 + 1000;\n  uVar1 \u003d millis();\n  reloj \u003d uVar1 + 1000;\n  u8state \u003d \u0027\\0\u0027;\n  startForkserver(0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "startForkserver",
        "pinMode",
        "millis",
        "digitalWrite",
        "begin"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "loop": {
      "entrypoint": "0x000805d0",
      "current_name": "loop",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid loop(void)\n\n{\n  modbus_t telegram;\n  modbus_t telegram_00;\n  modbus_t telegram_01;\n  modbus_t telegram_02;\n  uint32_t uVar1;\n  undefined4 uVar2;\n  float fVar3;\n  float fVar4;\n  float fVar5;\n  int iVar6;\n  pollfd *in_r1;\n  nfds_t in_r2;\n  int *piVar7;\n  uint __timeout;\n  undefined4 in_stack_ffffffc8;\n  undefined4 in_stack_ffffffcc;\n  float *pfVar8;\n  undefined4 in_stack_ffffffd0;\n  ulong *puVar9;\n  float *pfVar10;\n  \n  __timeout \u003d (uint)u8state;\n  switch(__timeout) {\n  case 0:\n    uVar1 \u003d millis();\n    if (u32wait \u003c uVar1) goto LAB_000806ca;\n    break;\n  case 1:\n    Modbus::poll(\u0026master,in_r1,in_r2,__timeout);\n    if (master.u8state \u003d\u003d \u0027\\0\u0027) {\n      telegram._4_4_ \u003d in_stack_ffffffcc;\n      telegram.u8id \u003d (char)in_stack_ffffffc8;\n      telegram.u8fct \u003d (char)((uint)in_stack_ffffffc8 \u003e\u003e 8);\n      telegram.u16RegAdd \u003d (short)((uint)in_stack_ffffffc8 \u003e\u003e 0x10);\n      telegram.au16reg \u003d (uint16_t *)in_stack_ffffffd0;\n      Modbus::query(\u0026master,telegram);\n      u8state \u003d u8state + \u0027\\x01\u0027;\n      u32wait \u003d millis();\n      tempe_z1 \u003d (int)au16data[1];\n      tempe_z2 \u003d (int)au16data[2];\n      kpa1 \u003d (float)__floatunsisf(au16data[6]);\n      kia1 \u003d (float)__floatsisf(au16data[7] / 10);\n      kda1 \u003d (float)__floatunsisf(au16data[8]);\n      duty2 \u003d (int)au16data[12];\n      duty1 \u003d (int)au16data[9];\n      minutos \u003d (int)au16data[14];\n      segundos \u003d (int)au16data[15];\n    }\n    break;\n  case 2:\n  case 4:\n  case 6:\n  case 8:\n    Modbus::poll(\u0026master,in_r1,in_r2,__timeout);\n    if (master.u8state \u003d\u003d \u0027\\0\u0027) {\n      u8state \u003d u8state + \u0027\\x01\u0027;\n      u32wait \u003d millis();\n    }\n    break;\n  case 3:\n    Modbus::poll(\u0026master,in_r1,in_r2,__timeout);\n    if (master.u8state \u003d\u003d \u0027\\0\u0027) {\n      telegram_00._4_4_ \u003d in_stack_ffffffcc;\n      telegram_00.u8id \u003d (char)in_stack_ffffffc8;\n      telegram_00.u8fct \u003d (char)((uint)in_stack_ffffffc8 \u003e\u003e 8);\n      telegram_00.u16RegAdd \u003d (short)((uint)in_stack_ffffffc8 \u003e\u003e 0x10);\n      telegram_00.au16reg \u003d (uint16_t *)in_stack_ffffffd0;\n      Modbus::query(\u0026master,telegram_00);\n      u8state \u003d u8state + \u0027\\x01\u0027;\n      u32wait \u003d millis();\n      tiempo_espera \u003d (int)au16data[30];\n      estado \u003d (int)au16data[29];\n    }\n    break;\n  case 5:\n    Modbus::poll(\u0026master,in_r1,in_r2,__timeout);\n    if (master.u8state \u003d\u003d \u0027\\0\u0027) {\nLAB_000806c4:\n      telegram_01._4_4_ \u003d in_stack_ffffffcc;\n      telegram_01.u8id \u003d (char)in_stack_ffffffc8;\n      telegram_01.u8fct \u003d (char)((uint)in_stack_ffffffc8 \u003e\u003e 8);\n      telegram_01.u16RegAdd \u003d (short)((uint)in_stack_ffffffc8 \u003e\u003e 0x10);\n      telegram_01.au16reg \u003d (uint16_t *)in_stack_ffffffd0;\n      Modbus::query(\u0026master,telegram_01);\n      goto LAB_000806ca;\n    }\n    break;\n  case 7:\n    Modbus::poll(\u0026master,in_r1,in_r2,__timeout);\n    if ((terminar_ciclo \u003d\u003d 1) \u0026\u0026 (master.u8state \u003d\u003d \u0027\\0\u0027)) {\n      au16data[29] \u003d 0;\n      terminar_ciclo \u003d 0;\n      goto LAB_000806c4;\n    }\nLAB_000806ca:\n    u8state \u003d u8state + \u0027\\x01\u0027;\n    break;\n  case 9:\n    Modbus::poll(\u0026master,in_r1,in_r2,__timeout);\n    if (master.u8state \u003d\u003d \u0027\\0\u0027) {\n      telegram_02._4_4_ \u003d in_stack_ffffffcc;\n      telegram_02.u8id \u003d (char)in_stack_ffffffc8;\n      telegram_02.u8fct \u003d (char)((uint)in_stack_ffffffc8 \u003e\u003e 8);\n      telegram_02.u16RegAdd \u003d (short)((uint)in_stack_ffffffc8 \u003e\u003e 0x10);\n      telegram_02.au16reg \u003d (uint16_t *)in_stack_ffffffd0;\n      Modbus::query(\u0026master,telegram_02);\n      u32wait \u003d millis();\n    }\n    u8state \u003d \u0027\\0\u0027;\n  }\n  mmt \u003d minutos - mmres;\n  if (mmt \u003c 0) {\n    mmt \u003d mmt + 0x3c;\n  }\n  sst \u003d segundos - ssres;\n  if (sst \u003c 0) {\n    mmt \u003d mmt + -1;\n    sst \u003d sst + 0x3c;\n  }\n  au16data[27] \u003d (ushort)mmt;\n  au16data[28] \u003d (ushort)sst;\n  if ((mmt \u003d\u003d 0) \u0026\u0026 (sst \u003d\u003d 0)) {\n    terminar_ciclo \u003d 1;\n    mmres \u003d sst;\n    ssres \u003d sst;\n  }\n  if (minutosp \u003d\u003d minutos) {\n    segundosp \u003d 1 - segundos;\n    if (1 \u003c (uint)segundos) {\n      segundosp \u003d 0;\n    }\n    if (segundosp !\u003d 0) goto LAB_00080a08;\n  }\n  else {\nLAB_00080a08:\n    segundosp \u003d segundos;\n    mmres \u003d 0;\n    ssres \u003d 0;\n    espera_plancha \u003d 0;\n    minutosp \u003d minutos;\n  }\n  if (estado \u003d\u003d 0) {\n    mmres \u003d estado;\n    ssres \u003d estado;\n    piVar7 \u003d \u0026espera_plancha;\nLAB_000808f2:\n    *piVar7 \u003d ssres;\n  }\n  else {\n    if (estado !\u003d 1) goto LAB_000808f4;\n    if ((espera_plancha \u003c tiempo_espera) \u0026\u0026 (uVar1 \u003d millis(), reloj \u003c uVar1)) {\n      espera_plancha \u003d espera_plancha + 1;\n      puVar9 \u003d \u0026reloj;\n      uVar1 \u003d millis();\n      *puVar9 \u003d uVar1 + 1000;\n    }\n    if (espera_plancha \u003c tiempo_espera) goto LAB_000808f4;\n    espera_plancha \u003d tiempo_espera + 1;\n    if (mmres \u003c minutos) {\n      uVar1 \u003d millis();\n      if (reloj \u003c uVar1) {\n        ssres \u003d ssres + 1;\n        uVar1 \u003d millis();\n        reloj \u003d uVar1 + 1000;\n      }\n    }\n    else {\n      if (mmres !\u003d minutos) goto LAB_000808f4;\n      if (segundos \u003c ssres) {\n        piVar7 \u003d \u0026mmres;\n        ssres \u003d 0;\n        goto LAB_000808f2;\n      }\n      uVar1 \u003d millis();\n      if (reloj \u003c uVar1) {\n        ssres \u003d ssres + 1;\n        uVar1 \u003d millis();\n        reloj \u003d uVar1 + 1000;\n      }\n    }\n    if (0x3b \u003c ssres) {\n      ssres \u003d 0;\n      mmres \u003d mmres + 1;\n    }\n  }\nLAB_000808f4:\n  uVar1 \u003d millis();\n  if (tiempopid1 \u003c uVar1) {\n    uVar2 \u003d __floatsisf(tempe_z1);\n    fVar3 \u003d (float)__aeabi_fsub(uVar2,temperatura1);\n    pfVar8 \u003d \u0026ep1;\n    e1 \u003d fVar3;\n    fVar5 \u003d ep1;\n    uVar2 \u003d __addsf3(fVar3,ep1);\n    uVar2 \u003d __aeabi_fmul(uVar2,kia1);\n    fVar4 \u003d (float)__addsf3(uVar2,kip1);\n    kia1 \u003d fVar4;\n    uVar2 \u003d __aeabi_fsub(fVar3,fVar5);\n    uVar2 \u003d __aeabi_fmul(uVar2,kda1);\n    pfVar10 \u003d \u0026kdp1;\n    fVar5 \u003d (float)__aeabi_fsub(uVar2,kdp1);\n    kda1 \u003d fVar5;\n    uVar2 \u003d __aeabi_fmul(fVar3,kpa1);\n    uVar2 \u003d __addsf3(uVar2,fVar4);\n    __addsf3(uVar2,fVar5);\n    pid1 \u003d __aeabi_f2iz();\n    YN \u003d (float)__floatsisf();\n    *pfVar8 \u003d fVar3;\n    incre \u003d 0;\n    kip1 \u003d fVar4;\n    *pfVar10 \u003d fVar5;\n    uVar1 \u003d millis();\n    tiempopid1 \u003d uVar1 + duty1;\n  }\n  fVar5 \u003d (float)__floatsisf(duty1);\n  iVar6 \u003d __aeabi_fcmpge(YN,fVar5);\n  if (iVar6 !\u003d 0) {\n    YN \u003d fVar5;\n  }\n  iVar6 \u003d __aeabi_fcmple(YN,0);\n  if (iVar6 !\u003d 0) {\n    YN \u003d 0.0;\n  }\n  au16data[21] \u003d __fixunssfsi(YN);\n  incre \u003d incre + 1;\n  in1 \u003d data8024[0] \u0026 1 ^ 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "__aeabi_fsub",
        "__floatunsisf",
        "__aeabi_fmul",
        "__aeabi_f2iz",
        "query",
        "__floatsisf",
        "__fixunssfsi",
        "millis",
        "__aeabi_fcmple",
        "__aeabi_fcmpge",
        "__addsf3",
        "poll"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_GLOBAL__sub_I__ZN6ModbusC2Ev": {
      "entrypoint": "0x00080a68",
      "current_name": "_GLOBAL__sub_I__ZN6ModbusC2Ev",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _GLOBAL__sub_I__ZN6ModbusC2Ev(void)\n\n{\n  String::String(\u0026RxString,\"\");\n  __aeabi_atexit(\u0026RxString,0x815ff,\u0026__dso_handle);\n  master.u8id \u003d \u0027\\0\u0027;\n  master.u8serno \u003d \u0027\\0\u0027;\n  master.u8txenpin \u003d \u0027\\x06\u0027;\n  master.u16timeOut \u003d 1000;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "String",
        "__aeabi_atexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serialEvent": {
      "entrypoint": "0x00080aa8",
      "current_name": "serialEvent",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid serialEvent(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "serialEventRun"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART_Handler": {
      "entrypoint": "0x00080aac",
      "current_name": "UART_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid UART_Handler(void)\n\n{\n  UARTClass::IrqHandler(\u0026Serial);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "IrqHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serialEvent1": {
      "entrypoint": "0x00080ab8",
      "current_name": "serialEvent1",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid serialEvent1(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "serialEventRun"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serialEvent2": {
      "entrypoint": "0x00080aba",
      "current_name": "serialEvent2",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid serialEvent2(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "serialEventRun"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serialEvent3": {
      "entrypoint": "0x00080abc",
      "current_name": "serialEvent3",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid serialEvent3(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "serialEventRun"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "USART0_Handler": {
      "entrypoint": "0x00080ac0",
      "current_name": "USART0_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid USART0_Handler(void)\n\n{\n  UARTClass::IrqHandler(\u0026Serial1.super_UARTClass);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "IrqHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "USART1_Handler": {
      "entrypoint": "0x00080acc",
      "current_name": "USART1_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid USART1_Handler(void)\n\n{\n  UARTClass::IrqHandler(\u0026Serial2.super_UARTClass);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "IrqHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "USART3_Handler": {
      "entrypoint": "0x00080ad8",
      "current_name": "USART3_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid USART3_Handler(void)\n\n{\n  UARTClass::IrqHandler(\u0026Serial3.super_UARTClass);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "IrqHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "init": {
      "entrypoint": "0x00081508",
      "current_name": "init",
      "code": "\n/* DWARF original prototype: void  init(UARTClass * this, uint32_t dwBaudRate, uint32_t modeReg) */\n\nint __thiscall UARTClass::init(UARTClass *this,EVP_PKEY_CTX *ctx)\n\n{\n  uint uVar1;\n  RingBuffer *pRVar2;\n  RwReg in_r2;\n  Uart *pUVar3;\n  \n  pmc_enable_periph_clk(this-\u003e_dwId);\n  pUVar3 \u003d this-\u003e_pUart;\n  pUVar3-\u003eUART_PTCR \u003d 0x202;\n  pUVar3-\u003eUART_CR \u003d 0xac;\n  pUVar3-\u003eUART_MR \u003d in_r2;\n  pUVar3-\u003eUART_BRGR \u003d SystemCoreClock / (uint)ctx \u003e\u003e 4;\n  pUVar3-\u003eUART_IDR \u003d 0xffffffff;\n  pUVar3-\u003eUART_IER \u003d 0x61;\n  uVar1 \u003d (uint)(int)this-\u003e_dwIrq \u003e\u003e 5;\n  *(int *)(uVar1 * 4 + -0x1fff1f00) \u003d 1 \u003c\u003c (uint)(byte)(this-\u003e_dwIrq \u0026 0x1f);\n  pRVar2 \u003d this-\u003e_rx_buffer;\n  pRVar2-\u003e_iTail \u003d 0;\n  pRVar2-\u003e_iHead \u003d 0;\n  pRVar2 \u003d this-\u003e_tx_buffer;\n  pRVar2-\u003e_iTail \u003d 0;\n  pRVar2-\u003e_iHead \u003d 0;\n  pUVar3-\u003eUART_CR \u003d 0x50;\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "begin",
        "begin"
      ],
      "called": [
        "pmc_enable_periph_clk"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_GLOBAL__sub_I_g_APinDescription": {
      "entrypoint": "0x00080c0c",
      "current_name": "_GLOBAL__sub_I_g_APinDescription",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _GLOBAL__sub_I_g_APinDescription(void)\n\n{\n  RingBuffer::RingBuffer(\u0026rx_buffer1);\n  RingBuffer::RingBuffer(\u0026tx_buffer1);\n  UARTClass::UARTClass(\u0026Serial,(Uart *)0x400e0800,UART_IRQn,8,\u0026rx_buffer1,\u0026tx_buffer1);\n  RingBuffer::RingBuffer(\u0026rx_buffer2);\n  RingBuffer::RingBuffer(\u0026rx_buffer3);\n  RingBuffer::RingBuffer(\u0026rx_buffer4);\n  RingBuffer::RingBuffer(\u0026tx_buffer2);\n  RingBuffer::RingBuffer(\u0026tx_buffer3);\n  RingBuffer::RingBuffer(\u0026tx_buffer4);\n  USARTClass::USARTClass(\u0026Serial1,(Usart *)0x40098000,USART0_IRQn,0x11,\u0026rx_buffer2,\u0026tx_buffer2);\n  USARTClass::USARTClass(\u0026Serial2,(Usart *)0x4009c000,USART1_IRQn,0x12,\u0026rx_buffer3,\u0026tx_buffer3);\n  USARTClass::USARTClass(\u0026Serial3,(Usart *)0x400a4000,USART3_IRQn,0x14,\u0026rx_buffer4,\u0026tx_buffer4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "USARTClass",
        "UARTClass",
        "RingBuffer"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serialEventRun": {
      "entrypoint": "0x00080ce0",
      "current_name": "serialEventRun",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid serialEventRun(void)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d UARTClass::available(\u0026Serial);\n  if (iVar1 !\u003d 0) {\n    serialEvent();\n  }\n  iVar1 \u003d UARTClass::available(\u0026Serial1.super_UARTClass);\n  if (iVar1 !\u003d 0) {\n    serialEvent1();\n  }\n  iVar1 \u003d UARTClass::available(\u0026Serial2.super_UARTClass);\n  if (iVar1 !\u003d 0) {\n    serialEvent2();\n  }\n  iVar1 \u003d UARTClass::available(\u0026Serial3.super_UARTClass);\n  if (iVar1 !\u003d 0) {\n    serialEvent3();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "serialEvent2",
        "serialEvent3",
        "serialEvent1",
        "available",
        "serialEvent"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIO_PullUp": {
      "entrypoint": "0x00080d24",
      "current_name": "PIO_PullUp",
      "code": "\nvoid PIO_PullUp(int param_1,undefined4 param_2,int param_3)\n\n{\n  if (param_3 !\u003d 0) {\n    *(undefined4 *)(param_1 + 100) \u003d param_2;\n    return;\n  }\n  *(undefined4 *)(param_1 + 0x60) \u003d param_2;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "digitalWrite"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIO_SetPeripheral": {
      "entrypoint": "0x00080d2e",
      "current_name": "PIO_SetPeripheral",
      "code": "\nvoid PIO_SetPeripheral(int param_1,undefined4 param_2,uint param_3)\n\n{\n  uint uVar1;\n  \n  *(uint *)(param_1 + 0x44) \u003d param_3;\n  switch(param_2) {\n  case 0:\n  case 3:\n  case 4:\n  case 5:\n    return;\n  case 1:\n    uVar1 \u003d *(uint *)(param_1 + 0x70) \u0026 *(uint *)(param_1 + 0x70) \u0026 ~param_3;\n    break;\n  case 2:\n    uVar1 \u003d *(uint *)(param_1 + 0x70) | param_3;\n    break;\n  default:\n    goto switchD_00080d34_caseD_6;\n  }\n  *(uint *)(param_1 + 0x70) \u003d uVar1;\nswitchD_00080d34_caseD_6:\n  *(uint *)(param_1 + 4) \u003d param_3;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "PIO_Configure"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIO_SetInput": {
      "entrypoint": "0x00080d54",
      "current_name": "PIO_SetInput",
      "code": "\nvoid PIO_SetInput(undefined4 *param_1,undefined4 param_2,uint param_3)\n\n{\n  bool bVar1;\n  \n  bVar1 \u003d (int)(param_3 \u003c\u003c 0x1f) \u003c 0;\n  param_1[0x11] \u003d param_2;\n  if (bVar1) {\n    param_1[0x19] \u003d param_2;\n  }\n  if (!bVar1) {\n    param_1[0x18] \u003d param_2;\n  }\n  bVar1 \u003d (param_3 \u0026 10) !\u003d 0;\n  if (bVar1) {\n    param_1[8] \u003d param_2;\n  }\n  if (!bVar1) {\n    param_1[9] \u003d param_2;\n  }\n  if (((int)(param_3 \u003c\u003c 0x1e) \u003c 0) || ((int)(param_3 \u003c\u003c 0x1c) \u003c 0)) {\n    param_1[0x20] \u003d param_2;\n  }\n  param_1[5] \u003d param_2;\n  *param_1 \u003d param_2;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "PIO_Configure"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIO_SetOutput": {
      "entrypoint": "0x00080d7a",
      "current_name": "PIO_SetOutput",
      "code": "\nvoid PIO_SetOutput(undefined4 *param_1,undefined4 param_2,int param_3,int param_4,int param_5)\n\n{\n  param_1[0x11] \u003d param_2;\n  if (param_5 \u003d\u003d 0) {\n    param_1[0x18] \u003d param_2;\n  }\n  else {\n    param_1[0x19] \u003d param_2;\n  }\n  if (param_4 \u003d\u003d 0) {\n    param_1[0x15] \u003d param_2;\n  }\n  else {\n    param_1[0x14] \u003d param_2;\n  }\n  if (param_3 \u003d\u003d 0) {\n    param_1[0xd] \u003d param_2;\n  }\n  else {\n    param_1[0xc] \u003d param_2;\n  }\n  param_1[4] \u003d param_2;\n  *param_1 \u003d param_2;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "PIO_Configure",
        "digitalWrite"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIO_Configure": {
      "entrypoint": "0x00080da0",
      "current_name": "PIO_Configure",
      "code": "\nundefined4 PIO_Configure(int param_1,int param_2,undefined4 param_3,uint param_4)\n\n{\n  bool bVar1;\n  \n  switch(param_2) {\n  case 1:\n  case 2:\n    PIO_SetPeripheral(param_1,param_2,param_3);\n    bVar1 \u003d (int)(param_4 \u003c\u003c 0x1f) \u003c 0;\n    *(undefined4 *)(param_1 + 0x44) \u003d param_3;\n    if (bVar1) {\n      *(undefined4 *)(param_1 + 100) \u003d param_3;\n    }\n    if (!bVar1) {\n      *(undefined4 *)(param_1 + 0x60) \u003d param_3;\n    }\n    break;\n  case 3:\n    PIO_SetInput(param_1,param_3,param_4,0x80d55,param_1);\n    break;\n  case 4:\n  case 5:\n    PIO_SetOutput(param_1,param_3,param_2 \u003d\u003d 5,(param_4 \u003c\u003c 0x1d) \u003e\u003e 0x1f,param_4 \u0026 1,param_2,param_3\n                 );\n    break;\n  default:\n    return 0;\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "init",
        "pinMode"
      ],
      "called": [
        "PIO_SetInput",
        "PIO_SetOutput",
        "PIO_SetPeripheral"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIO_GetOutputDataStatus": {
      "entrypoint": "0x00080e04",
      "current_name": "PIO_GetOutputDataStatus",
      "code": "\nuint PIO_GetOutputDataStatus(int param_1,uint param_2)\n\n{\n  uint uVar1;\n  \n  uVar1 \u003d *(uint *)(param_1 + 8) \u0026 param_2;\n  if (uVar1 !\u003d 0) {\n    if ((param_2 \u0026 *(uint *)(param_1 + 0x18)) \u003d\u003d 0) {\n      uVar1 \u003d 0;\n    }\n    else {\n      uVar1 \u003d 1;\n    }\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "digitalWrite"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pmc_enable_periph_clk": {
      "entrypoint": "0x00080e18",
      "current_name": "pmc_enable_periph_clk",
      "code": "\n\n\nundefined4 pmc_enable_periph_clk(uint param_1)\n\n{\n  uint uVar1;\n  \n  if (param_1 \u003c 0x2d) {\n    if (param_1 \u003c 0x20) {\n      uVar1 \u003d 1 \u003c\u003c (param_1 \u0026 0xff);\n      if ((uVar1 \u0026 _DAT_400e0618) !\u003d uVar1) {\n        _DAT_400e0610 \u003d uVar1;\n      }\n    }\n    else {\n      uVar1 \u003d 1 \u003c\u003c (param_1 - 0x20 \u0026 0xff);\n      if ((uVar1 \u0026 _DAT_400e0708) !\u003d uVar1) {\n        _DAT_400e0700 \u003d uVar1;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "init",
        "init",
        "pinMode"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pmc_disable_periph_clk": {
      "entrypoint": "0x00080e5c",
      "current_name": "pmc_disable_periph_clk",
      "code": "\n\n\nundefined4 pmc_disable_periph_clk(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  if (param_1 \u003c 0x2d) {\n    if (param_1 \u003c 0x20) {\n      uVar1 \u003d 1 \u003c\u003c (param_1 \u0026 0xff);\n      uVar2 \u003d _DAT_400e0618 \u0026 uVar1;\n      if (uVar2 \u003d\u003d uVar1) {\n        _DAT_400e0614 \u003d uVar2;\n      }\n    }\n    else {\n      uVar1 \u003d 1 \u003c\u003c (param_1 - 0x20 \u0026 0xff);\n      uVar2 \u003d _DAT_400e0708 \u0026 uVar1;\n      if (uVar2 \u003d\u003d uVar1) {\n        _DAT_400e0704 \u003d uVar2;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "end",
        "pinMode"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "SystemInit": {
      "entrypoint": "0x00080e9c",
      "current_name": "SystemInit",
      "code": "\n\n\nvoid SystemInit(void)\n\n{\n  _DAT_400e0a00 \u003d 0x400;\n  _DAT_400e0c00 \u003d 0x400;\n  _DAT_400e0620 \u003d _DAT_400e0620 \u003c\u003c 7;\n  while (-1 \u003c _DAT_400e0620) {\n    _DAT_400e0620 \u003d _DAT_400e0668 \u003c\u003c 0x1f;\n  }\n  _DAT_400e0620 \u003d 0x1370809;\n  do {\n  } while (-1 \u003c _DAT_400e0668 \u003c\u003c 0xf);\n  do {\n  } while (-1 \u003c _DAT_400e0668 \u003c\u003c 0x1c);\n  _DAT_400e0628 \u003d 0x200d3f01;\n  do {\n  } while (-1 \u003c _DAT_400e0668 \u003c\u003c 0x1e);\n  do {\n  } while (-1 \u003c _DAT_400e0668 \u003c\u003c 0x1c);\n  _DAT_400e0630 \u003d 0x12;\n  do {\n  } while (-1 \u003c _DAT_400e0668 \u003c\u003c 0x1c);\n  SystemCoreClock \u003d 84000000;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "Reset_Handler": {
      "entrypoint": "0x00080f24",
      "current_name": "Reset_Handler",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00080f6e) */\n\n\nvoid Reset_Handler(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  \n  for (iVar1 \u003d 0; banzai + iVar1 \u003c \u0026completed_7857; iVar1 \u003d iVar1 + 4) {\n    *(undefined4 *)(banzai + iVar1) \u003d *(undefined4 *)(\u0026_etext + iVar1);\n  }\n  for (puVar2 \u003d \u0026completed_7857; puVar2 \u003c \u0026_ebss; puVar2 \u003d puVar2 + 1) {\n    *puVar2 \u003d 0;\n  }\n  _DAT_e000ed08 \u003d 0x80000;\n  main();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "main",
        "banzai"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "adc_init": {
      "entrypoint": "0x00080f9c",
      "current_name": "adc_init",
      "code": "\nundefined4 adc_init(undefined4 *param_1,uint param_2,int param_3,int param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint local_58 [16];\n  \n  local_58[0] \u003d 0;\n  local_58[1] \u003d 8;\n  local_58[2] \u003d 0x10;\n  local_58[3] \u003d 0x18;\n  local_58[4] \u003d 0x40;\n  local_58[5] \u003d 0x50;\n  local_58[6] \u003d 0x60;\n  local_58[7] \u003d 0x70;\n  local_58[8] \u003d 0x200;\n  local_58[9] \u003d 0x240;\n  local_58[10] \u003d 0x280;\n  local_58[11] \u003d 0x2c0;\n  local_58[12] \u003d 0x300;\n  local_58[13] \u003d 0x340;\n  local_58[14] \u003d 0x380;\n  local_58[15] \u003d 0x3c0;\n  *param_1 \u003d 1;\n  param_1[1] \u003d 0;\n  param_1[0x48] \u003d 0x202;\n  param_1[0x41] \u003d 0;\n  param_1[0x45] \u003d 0;\n  uVar1 \u003d param_2 / (uint)(param_3 * 2);\n  if (param_2 \u003d\u003d param_3 * 2 * uVar1) {\n    uVar1 \u003d uVar1 - 1;\n  }\n  uVar2 \u003d 0;\n  do {\n    if ((uint)(param_4 * (int)(((ulonglong)param_2 / (ulonglong)((uVar1 + 1) * 2)) / 1000000)) \u003c\u003d\n        local_58[uVar2]) {\n      param_1[1] \u003d (uVar2 \u0026 0xf) \u003c\u003c 0x10 | (uVar1 \u0026 0xff) \u003c\u003c 8 | param_1[1];\n      return 0;\n    }\n    uVar2 \u003d uVar2 + 1;\n  } while (uVar2 !\u003d 0x10);\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "adc_configure_trigger": {
      "entrypoint": "0x00081034",
      "current_name": "adc_configure_trigger",
      "code": "\nvoid adc_configure_trigger(int param_1,uint param_2,uint param_3)\n\n{\n  *(uint *)(param_1 + 4) \u003d param_2 | *(uint *)(param_1 + 4) | (param_3 \u0026 1) \u003c\u003c 7;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "adc_configure_timing": {
      "entrypoint": "0x00081042",
      "current_name": "adc_configure_timing",
      "code": "\nvoid adc_configure_timing(int param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  *(uint *)(param_1 + 4) \u003d\n       param_3 | *(uint *)(param_1 + 4) | (param_2 \u0026 0xf) \u003c\u003c 0x18 | (param_4 \u0026 3) \u003c\u003c 0x1c;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "adc_disable_channel": {
      "entrypoint": "0x0008105c",
      "current_name": "adc_disable_channel",
      "code": "\nvoid adc_disable_channel(int param_1,uint param_2)\n\n{\n  *(int *)(param_1 + 0x14) \u003d 1 \u003c\u003c (param_2 \u0026 0xff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "adc_disable_all_channel": {
      "entrypoint": "0x00081066",
      "current_name": "adc_disable_all_channel",
      "code": "\nvoid adc_disable_all_channel(int param_1)\n\n{\n  *(undefined4 *)(param_1 + 0x14) \u003d 0xffff;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "adc_disable_interrupt": {
      "entrypoint": "0x0008106e",
      "current_name": "adc_disable_interrupt",
      "code": "\nvoid adc_disable_interrupt(int param_1,undefined4 param_2)\n\n{\n  *(undefined4 *)(param_1 + 0x28) \u003d param_2;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UOTGHS_Handler": {
      "entrypoint": "0x00081074",
      "current_name": "UOTGHS_Handler",
      "code": "\nvoid UOTGHS_Handler(void)\n\n{\n  if (gpf_isr !\u003d (code *)0x0) {\n    (*gpf_isr)();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIOA_Handler": {
      "entrypoint": "0x00081084",
      "current_name": "PIOA_Handler",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid PIOA_Handler(void)\n\n{\n  uint8_t leading_zeros;\n  uint32_t isr;\n  uint uVar1;\n  \n  for (isr \u003d _DAT_400e0e4c; (uint)LZCOUNT(isr) \u003c 0x20; isr \u003d isr \u0026 ~(1 \u003c\u003c uVar1)) {\n    uVar1 \u003d 0x1fU - LZCOUNT(isr) \u0026 0xff;\n    if (callbacksPioA[uVar1] !\u003d (interruptCB)0x0) {\n      (*callbacksPioA[uVar1])();\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIOB_Handler": {
      "entrypoint": "0x000810bc",
      "current_name": "PIOB_Handler",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid PIOB_Handler(void)\n\n{\n  uint8_t leading_zeros;\n  uint32_t isr;\n  uint uVar1;\n  \n  for (isr \u003d _DAT_400e104c; (uint)LZCOUNT(isr) \u003c 0x20; isr \u003d isr \u0026 ~(1 \u003c\u003c uVar1)) {\n    uVar1 \u003d 0x1fU - LZCOUNT(isr) \u0026 0xff;\n    if (callbacksPioB[uVar1] !\u003d (interruptCB)0x0) {\n      (*callbacksPioB[uVar1])();\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIOC_Handler": {
      "entrypoint": "0x000810f4",
      "current_name": "PIOC_Handler",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid PIOC_Handler(void)\n\n{\n  uint8_t leading_zeros;\n  uint32_t isr;\n  uint uVar1;\n  \n  for (isr \u003d _DAT_400e124c; (uint)LZCOUNT(isr) \u003c 0x20; isr \u003d isr \u0026 ~(1 \u003c\u003c uVar1)) {\n    uVar1 \u003d 0x1fU - LZCOUNT(isr) \u0026 0xff;\n    if (callbacksPioC[uVar1] !\u003d (interruptCB)0x0) {\n      (*callbacksPioC[uVar1])();\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIOD_Handler": {
      "entrypoint": "0x0008112c",
      "current_name": "PIOD_Handler",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid PIOD_Handler(void)\n\n{\n  uint8_t leading_zeros;\n  uint32_t isr;\n  uint uVar1;\n  \n  for (isr \u003d _DAT_400e144c; (uint)LZCOUNT(isr) \u003c 0x20; isr \u003d isr \u0026 ~(1 \u003c\u003c uVar1)) {\n    uVar1 \u003d 0x1fU - LZCOUNT(isr) \u0026 0xff;\n    if (callbacksPioD[uVar1] !\u003d (interruptCB)0x0) {\n      (*callbacksPioD[uVar1])();\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__halt": {
      "entrypoint": "0x00081188",
      "current_name": "__halt",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid __halt(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "__halt",
        "SVC_Handler",
        "PendSV_Handler"
      ],
      "called": [
        "__halt"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "SVC_Handler": {
      "entrypoint": "0x00081166",
      "current_name": "SVC_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid SVC_Handler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__halt"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PendSV_Handler": {
      "entrypoint": "0x0008116a",
      "current_name": "PendSV_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid PendSV_Handler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__halt"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "SysTick_Handler": {
      "entrypoint": "0x0008116e",
      "current_name": "SysTick_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid SysTick_Handler(void)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d __false();\n  if (iVar1 \u003d\u003d 0) {\n    tickReset();\n    TimeTick_Increment();\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__false",
        "tickReset",
        "TimeTick_Increment"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__false": {
      "entrypoint": "0x00081184",
      "current_name": "__false",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint __false(void)\n\n{\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "SysTick_Handler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_sbrk": {
      "entrypoint": "0x0008118c",
      "current_name": "_sbrk",
      "code": "\nvoid * _sbrk(intptr_t __delta)\n\n{\n  uchar *puVar1;\n  uchar *prev_heap;\n  \n  if (_sbrk::heap \u003d\u003d (uchar *)0x0) {\n    _sbrk::heap \u003d \u0026_ebss;\n  }\n  puVar1 \u003d _sbrk::heap;\n  _sbrk::heap \u003d _sbrk::heap + __delta;\n  return puVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_sbrk_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "link": {
      "entrypoint": "0x000811a8",
      "current_name": "link",
      "code": "\nint link(char *__from,char *__to)\n\n{\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_close": {
      "entrypoint": "0x000811ae",
      "current_name": "_close",
      "code": "\nint _close(int __fd)\n\n{\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_close_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fstat": {
      "entrypoint": "0x000811b4",
      "current_name": "_fstat",
      "code": "\nint _fstat(int __fd,stat *__buf)\n\n{\n  *(undefined4 *)((int)\u0026__buf-\u003est_dev + 4) \u003d 0x2000;\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fstat_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_isatty": {
      "entrypoint": "0x000811be",
      "current_name": "_isatty",
      "code": "\nint _isatty(int __fd)\n\n{\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_isatty_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_lseek": {
      "entrypoint": "0x000811c2",
      "current_name": "_lseek",
      "code": "\n__off_t _lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_lseek_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_read": {
      "entrypoint": "0x000811c6",
      "current_name": "_read",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint _read(int file_UNUSED,char *ptr_UNUSED,int len_UNUSED)\n\n{\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_read_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_write": {
      "entrypoint": "0x000811cc",
      "current_name": "_write",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nint _write(int file_UNUSED,char *ptr,int len)\n\n{\n  int iVar1;\n  \n  for (iVar1 \u003d 0; iVar1 \u003c len; iVar1 \u003d iVar1 + 1) {\n    do {\n    } while (-1 \u003c _DAT_400e0814 \u003c\u003c 0x1e);\n    _DAT_400e081c \u003d (uint)(byte)ptr[iVar1];\n  }\n  return len \u0026 ~(len \u003e\u003e 0x1f);\n}\n\n",
      "renaming": {},
      "calling": [
        "_write_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_exit": {
      "entrypoint": "0x000811f0",
      "current_name": "_exit",
      "code": "\nvoid _exit(int __status)\n\n{\n  iprintf(\"Exiting with status %d.\\n\",__status);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "iprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_kill": {
      "entrypoint": "0x00081200",
      "current_name": "_kill",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _kill(int pid_UNUSED,int sig_UNUSED)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_kill_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_getpid": {
      "entrypoint": "0x00081202",
      "current_name": "_getpid",
      "code": "\n\n\n__pid_t _getpid(void)\n\n{\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "millis": {
      "entrypoint": "0x00081208",
      "current_name": "millis",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t millis(void)\n\n{\n  return _dwTickCount;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop",
        "setup",
        "sendTxBuffer",
        "poll"
      ],
      "called": [
        "GetTickCount"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "delay": {
      "entrypoint": "0x0008120c",
      "current_name": "delay",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid delay(uint32_t ms)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "analogOutputInit": {
      "entrypoint": "0x0008120e",
      "current_name": "analogOutputInit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid analogOutputInit(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pinMode": {
      "entrypoint": "0x00081210",
      "current_name": "pinMode",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid pinMode(uint32_t ulPin,uint32_t ulMode)\n\n{\n  undefined4 uVar1;\n  byte bVar2;\n  byte bVar3;\n  Pio_conflict *pPVar4;\n  \n  if (g_APinDescription[ulPin].ulPinType !\u003d PIO_NOT_A_PIN) {\n    if ((g_pinStatus[ulPin] \u0026 0xf) \u003d\u003d 4) {\n      adc_disable_channel(0x400c0000,g_APinDescription[ulPin].ulADCChannelNumber);\n    }\n    bVar3 \u003d g_pinStatus[ulPin];\n    bVar2 \u003d bVar3 \u0026 0xf;\n    if ((bVar2 \u003c 3) \u0026\u0026 (bVar3 !\u003d 0)) {\n      if (bVar2 \u003d\u003d 2) {\n        if (ulMode \u003d\u003d 0) {\n          return;\n        }\n      }\n      else if (bVar2 \u003d\u003d 1) {\n        if (ulMode \u003d\u003d 2) {\n          return;\n        }\n      }\n      else if (bVar2 \u003d\u003d 3) {\n        if (ulMode \u003d\u003d 1) {\n          return;\n        }\n        goto LAB_0008126c;\n      }\n    }\n    if (ulMode !\u003d 1) {\nLAB_0008126c:\n      if (ulMode \u003d\u003d 0) {\n        pmc_enable_periph_clk(g_APinDescription[ulPin].ulPeripheralId);\n        PIO_Configure(g_APinDescription[ulPin].pPort,3,g_APinDescription[ulPin].ulPin,0);\n        bVar3 \u003d g_pinStatus[ulPin] \u0026 0xf0 | 2;\n      }\n      else {\n        if (ulMode !\u003d 2) {\n          return;\n        }\n        pmc_enable_periph_clk(g_APinDescription[ulPin].ulPeripheralId);\n        PIO_Configure(g_APinDescription[ulPin].pPort,3,g_APinDescription[ulPin].ulPin,1);\n        bVar3 \u003d g_pinStatus[ulPin] \u0026 0xf0 | 1;\n      }\n      g_pinStatus[ulPin] \u003d bVar3;\n      return;\n    }\n    pPVar4 \u003d g_APinDescription[ulPin].pPort;\n    if (bVar3 \u003e\u003e 4 \u003d\u003d 0) {\n      uVar1 \u003d 4;\n    }\n    else {\n      uVar1 \u003d 5;\n    }\n    PIO_Configure(pPVar4,uVar1,g_APinDescription[ulPin].ulPin,\n                  g_APinDescription[ulPin].ulPinConfiguration);\n    g_pinStatus[ulPin] \u003d g_pinStatus[ulPin] \u0026 0xf0 | 3;\n    if (pPVar4-\u003ePIO_OSR \u003d\u003d 0xffffffff) {\n      pmc_disable_periph_clk(g_APinDescription[ulPin].ulPeripheralId);\n      return;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup",
        "digitalWrite",
        "begin"
      ],
      "called": [
        "adc_disable_channel",
        "PIO_Configure",
        "pmc_enable_periph_clk",
        "pmc_disable_periph_clk"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "digitalWrite": {
      "entrypoint": "0x00081318",
      "current_name": "digitalWrite",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid digitalWrite(uint32_t ulPin,uint32_t ulVal)\n\n{\n  int iVar1;\n  uint32_t uVar2;\n  Pio_conflict *pPVar3;\n  uint32_t uVar4;\n  \n  if (g_APinDescription[ulPin].ulPinType !\u003d PIO_NOT_A_PIN) {\n    uVar4 \u003d ulVal;\n    if ((g_pinStatus[ulPin] \u0026 0xf) \u003d\u003d 5) {\n      pinMode(ulPin,1);\n    }\n    g_pinStatus[ulPin] \u003d g_pinStatus[ulPin] \u0026 0xf | (byte)(ulVal \u003c\u003c 4);\n    pPVar3 \u003d g_APinDescription[ulPin].pPort;\n    uVar2 \u003d g_APinDescription[ulPin].ulPin;\n    iVar1 \u003d PIO_GetOutputDataStatus(pPVar3,uVar2);\n    if (iVar1 \u003d\u003d 0) {\n      PIO_PullUp(pPVar3,uVar2,ulVal);\n      return;\n    }\n    PIO_SetOutput(pPVar3,uVar2,ulVal,0,1,uVar4);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "getRxBuffer",
        "setup",
        "init",
        "sendTxBuffer",
        "begin"
      ],
      "called": [
        "pinMode",
        "PIO_SetOutput",
        "PIO_GetOutputDataStatus",
        "PIO_PullUp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "tickReset": {
      "entrypoint": "0x00081388",
      "current_name": "tickReset",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid tickReset(void)\n\n{\n  if ((ticks !\u003d -1) \u0026\u0026 (ticks \u003d ticks + -1, ticks \u003d\u003d 0)) {\n    banzai();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SysTick_Handler"
      ],
      "called": [
        "banzai"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "RingBuffer": {
      "entrypoint": "0x000813a8",
      "current_name": "RingBuffer",
      "code": "\n/* DWARF original prototype: RingBuffer *  RingBuffer(RingBuffer * this) */\n\nRingBuffer * __thiscall RingBuffer::RingBuffer(RingBuffer *this)\n\n{\n  memset(this,0,0x80);\n  this-\u003e_iHead \u003d 0;\n  this-\u003e_iTail \u003d 0;\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "_GLOBAL__sub_I_g_APinDescription"
      ],
      "called": [
        "memset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "store_char": {
      "entrypoint": "0x000813c2",
      "current_name": "store_char",
      "code": "\n/* DWARF original prototype: void  store_char(RingBuffer * this, uint8_t c) */\n\nvoid __thiscall RingBuffer::store_char(RingBuffer *this,uint8_t c)\n\n{\n  int i;\n  uint uVar1;\n  \n  i \u003d this-\u003e_iHead;\n  uVar1 \u003d i + 1U \u0026 0x7f;\n  if (uVar1 !\u003d this-\u003e_iTail) {\n    this-\u003e_aucBuffer[this-\u003e_iHead] \u003d c;\n    this-\u003e_iHead \u003d uVar1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "IrqHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "operator_bool": {
      "entrypoint": "0x000813e0",
      "current_name": "operator_bool",
      "code": "\n/* DWARF original name: operator bool\n   DWARF original prototype: bool  operator_bool(UARTClass * this) */\n\nbool __thiscall UARTClass::operator_bool(UARTClass *this)\n\n{\n  return true;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "available": {
      "entrypoint": "0x000813e4",
      "current_name": "available",
      "code": "\n/* DWARF original prototype: int  available(UARTClass * this) */\n\nint __thiscall UARTClass::available(UARTClass *this)\n\n{\n  return this-\u003e_rx_buffer-\u003e_iHead - this-\u003e_rx_buffer-\u003e_iTail \u0026 0x7f;\n}\n\n",
      "renaming": {},
      "calling": [
        "serialEventRun"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "peek": {
      "entrypoint": "0x000813f6",
      "current_name": "peek",
      "code": "\n/* DWARF original prototype: int  peek(UARTClass * this) */\n\nint __thiscall UARTClass::peek(UARTClass *this)\n\n{\n  uint uVar1;\n  RingBuffer *pRVar2;\n  \n  pRVar2 \u003d this-\u003e_rx_buffer;\n  if (pRVar2-\u003e_iHead \u003d\u003d pRVar2-\u003e_iTail) {\n    uVar1 \u003d 0xffffffff;\n  }\n  else {\n    uVar1 \u003d (uint)pRVar2-\u003e_aucBuffer[pRVar2-\u003e_iTail];\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "read": {
      "entrypoint": "0x00081412",
      "current_name": "read",
      "code": "\n/* DWARF original prototype: int  read(UARTClass * this) */\n\nssize_t __thiscall UARTClass::read(UARTClass *this,int __fd,void *__buf,size_t __nbytes)\n\n{\n  byte bVar1;\n  uint8_t uc;\n  RingBuffer *pRVar2;\n  \n  pRVar2 \u003d this-\u003e_rx_buffer;\n  if (pRVar2-\u003e_iHead !\u003d pRVar2-\u003e_iTail) {\n    bVar1 \u003d pRVar2-\u003e_aucBuffer[pRVar2-\u003e_iTail];\n    pRVar2-\u003e_iTail \u003d pRVar2-\u003e_iTail + 1U \u0026 0x7f;\n    return (uint)bVar1;\n  }\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "flush": {
      "entrypoint": "0x0008143c",
      "current_name": "flush",
      "code": "\n/* DWARF original prototype: void  flush(UARTClass * this) */\n\nvoid __thiscall UARTClass::flush(UARTClass *this)\n\n{\n  do {\n  } while (this-\u003e_tx_buffer-\u003e_iHead !\u003d this-\u003e_tx_buffer-\u003e_iTail);\n  do {\n  } while (-1 \u003c (int)(this-\u003e_pUart-\u003eUART_SR \u003c\u003c 0x16));\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "write": {
      "entrypoint": "0x000816e0",
      "current_name": "write",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x000816f6 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * this, uint8_t * buffer, size_t size) */\n\nssize_t __thiscall Print::write(Print *this,int __fd,void *__buf,size_t __n)\n\n{\n  Print *pPVar1;\n  void *pvVar2;\n  \n  pvVar2 \u003d (void *)0x0;\n  pPVar1 \u003d this;\n  while ((pvVar2 !\u003d __buf \u0026\u0026\n         (pPVar1 \u003d (Print *)(**this-\u003e_vptr_Print)(pPVar1,(uint)*(byte *)(__fd + (int)pvVar2)),\n         pPVar1 !\u003d (Print *)0x0))) {\n    pvVar2 \u003d (void *)((int)pvVar2 + 1);\n  }\n  return (ssize_t)pvVar2;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "end": {
      "entrypoint": "0x000814a8",
      "current_name": "end",
      "code": "\n/* DWARF original prototype: void  end(UARTClass * this) */\n\nvoid __thiscall UARTClass::end(UARTClass *this)\n\n{\n  this-\u003e_rx_buffer-\u003e_iHead \u003d this-\u003e_rx_buffer-\u003e_iTail;\n  (**(code **)(*(int *)this + 0x14))();\n  *(int *)((((uint)(int)this-\u003e_dwIrq \u003e\u003e 5) + 0x20) * 4 + -0x1fff1f00) \u003d\n       1 \u003c\u003c (uint)(byte)(this-\u003e_dwIrq \u0026 0x1f);\n  pmc_disable_periph_clk(this-\u003e_dwId);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "pmc_disable_periph_clk"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UARTClass": {
      "entrypoint": "0x000814e4",
      "current_name": "UARTClass",
      "code": "\n/* DWARF original prototype: UARTClass *  UARTClass(UARTClass * this, Uart * pUart, IRQn_Type dwIrq,\n   uint32_t dwId, RingBuffer * pRx_buffer, RingBuffer * pTx_buffer) */\n\nUARTClass * __thiscall\nUARTClass::UARTClass\n          (UARTClass *this,Uart *pUart,IRQn_Type dwIrq,uint32_t dwId,RingBuffer *pRx_buffer,\n          RingBuffer *pTx_buffer)\n\n{\n  *(undefined4 *)\u0026this-\u003efield_0x4 \u003d 0;\n  *(undefined4 *)\u0026this-\u003efield_0x8 \u003d 1000;\n  this-\u003e_pUart \u003d pUart;\n  *(undefined ***)this \u003d \u0026PTR_write_1_000857a8;\n  this-\u003e_dwIrq \u003d dwIrq;\n  this-\u003e_rx_buffer \u003d pRx_buffer;\n  this-\u003e_dwId \u003d dwId;\n  this-\u003e_tx_buffer \u003d pTx_buffer;\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "USARTClass",
        "_GLOBAL__sub_I_g_APinDescription"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "IrqHandler": {
      "entrypoint": "0x00081580",
      "current_name": "IrqHandler",
      "code": "\n/* DWARF original prototype: void  IrqHandler(UARTClass * this) */\n\nvoid __thiscall UARTClass::IrqHandler(UARTClass *this)\n\n{\n  RingBuffer *pRVar1;\n  uint32_t status;\n  RoReg RVar2;\n  \n  RVar2 \u003d this-\u003e_pUart-\u003eUART_SR;\n  if ((int)(RVar2 \u003c\u003c 0x1f) \u003c 0) {\n    RingBuffer::store_char(this-\u003e_rx_buffer,(uint8_t)this-\u003e_pUart-\u003eUART_RHR);\n  }\n  if ((int)(RVar2 \u003c\u003c 0x1e) \u003c 0) {\n    pRVar1 \u003d this-\u003e_tx_buffer;\n    if (pRVar1-\u003e_iTail !\u003d pRVar1-\u003e_iHead) {\n      this-\u003e_pUart-\u003eUART_THR \u003d (uint)pRVar1-\u003e_aucBuffer[pRVar1-\u003e_iTail];\n      pRVar1-\u003e_iTail \u003d pRVar1-\u003e_iTail + 1U \u0026 0x7f;\n      return;\n    }\n    this-\u003e_pUart-\u003eUART_IDR \u003d 2;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "USART1_Handler",
        "UART_Handler",
        "USART0_Handler",
        "USART3_Handler"
      ],
      "called": [
        "store_char"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "USARTClass": {
      "entrypoint": "0x000815d4",
      "current_name": "USARTClass",
      "code": "\n/* DWARF original prototype: USARTClass *  USARTClass(USARTClass * this, Usart * pUsart, IRQn_Type\n   dwIrq, uint32_t dwId, RingBuffer * pRx_buffer, RingBuffer * pTx_buffer) */\n\nUSARTClass * __thiscall\nUSARTClass::USARTClass\n          (USARTClass *this,Usart *pUsart,IRQn_Type dwIrq,uint32_t dwId,RingBuffer *pRx_buffer,\n          RingBuffer *pTx_buffer)\n\n{\n  UARTClass::UARTClass(\u0026this-\u003esuper_UARTClass,(Uart *)pUsart,dwIrq,dwId,pRx_buffer,pTx_buffer);\n  *(undefined ***)\u0026this-\u003esuper_UARTClass \u003d \u0026PTR_write_1_000857d8;\n  this-\u003e_pUsart \u003d pUsart;\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "_GLOBAL__sub_I_g_APinDescription"
      ],
      "called": [
        "UARTClass"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "makeWord": {
      "entrypoint": "0x000815f8",
      "current_name": "makeWord",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint16_t makeWord(uint8_t h,uint8_t l)\n\n{\n  return CONCAT11(h,l);\n}\n\n",
      "renaming": {},
      "calling": [
        "get_FC3"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "~String": {
      "entrypoint": "0x000815fe",
      "current_name": "~String",
      "code": "\n/* DWARF original prototype: void *  ~String(String * this, int __in_chrg) */\n\nvoid * __thiscall String::~String(String *this,int __in_chrg)\n\n{\n  free(this-\u003ebuffer);\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "free"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "invalidate": {
      "entrypoint": "0x0008160c",
      "current_name": "invalidate",
      "code": "\n/* DWARF original prototype: void  invalidate(String * this) */\n\nvoid __thiscall String::invalidate(String *this)\n\n{\n  if (this-\u003ebuffer !\u003d (char *)0x0) {\n    free(this-\u003ebuffer);\n  }\n  this-\u003ebuffer \u003d (char *)0x0;\n  this-\u003elen \u003d 0;\n  this-\u003ecapacity \u003d 0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy"
      ],
      "called": [
        "free"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "changeBuffer": {
      "entrypoint": "0x00081622",
      "current_name": "changeBuffer",
      "code": "\n/* DWARF original prototype: uchar  changeBuffer(String * this, uint maxStrLen) */\n\nuchar __thiscall String::changeBuffer(String *this,uint maxStrLen)\n\n{\n  char *pcVar1;\n  char *newbuffer;\n  \n  pcVar1 \u003d (char *)realloc(this-\u003ebuffer,maxStrLen + 1);\n  if (pcVar1 !\u003d (char *)0x0) {\n    this-\u003ebuffer \u003d pcVar1;\n    this-\u003ecapacity \u003d maxStrLen;\n    pcVar1 \u003d (char *)0x1;\n  }\n  return (uchar)pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "reserve"
      ],
      "called": [
        "realloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "reserve": {
      "entrypoint": "0x0008163a",
      "current_name": "reserve",
      "code": "\n/* DWARF original prototype: uchar  reserve(String * this, uint size) */\n\nuchar __thiscall String::reserve(String *this,uint size)\n\n{\n  uchar uVar1;\n  \n  if ((this-\u003ebuffer \u003d\u003d (char *)0x0) || (this-\u003ecapacity \u003c size)) {\n    uVar1 \u003d changeBuffer(this,size);\n    if (uVar1 \u003d\u003d \u0027\\0\u0027) {\n      return \u0027\\0\u0027;\n    }\n    if (this-\u003elen \u003d\u003d 0) {\n      *this-\u003ebuffer \u003d \u0027\\0\u0027;\n    }\n  }\n  return \u0027\\x01\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy"
      ],
      "called": [
        "changeBuffer"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "copy": {
      "entrypoint": "0x0008165c",
      "current_name": "copy",
      "code": "\n/* DWARF original prototype: String *  copy(String * this, char * cstr, uint length) */\n\nint __thiscall String::copy(String *this,EVP_PKEY_CTX *dst,EVP_PKEY_CTX *src)\n\n{\n  uchar uVar1;\n  \n  uVar1 \u003d reserve(this,(uint)src);\n  if (uVar1 \u003d\u003d \u0027\\0\u0027) {\n    invalidate(this);\n  }\n  else {\n    this-\u003elen \u003d (uint)src;\n    strcpy(this-\u003ebuffer,(char *)dst);\n  }\n  return (int)this;\n}\n\n",
      "renaming": {},
      "calling": [
        "String"
      ],
      "called": [
        "strcpy",
        "reserve",
        "invalidate"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "String": {
      "entrypoint": "0x00081682",
      "current_name": "String",
      "code": "\n/* DWARF original prototype: String *  String(String * this, char * cstr) */\n\nString * __thiscall String::String(String *this,char *cstr)\n\n{\n  EVP_PKEY_CTX *src;\n  \n  this-\u003ebuffer \u003d (char *)0x0;\n  this-\u003ecapacity \u003d 0;\n  this-\u003elen \u003d 0;\n  if (cstr !\u003d (char *)0x0) {\n    src \u003d (EVP_PKEY_CTX *)strlen(cstr);\n    copy(this,(EVP_PKEY_CTX *)cstr,src);\n  }\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "_GLOBAL__sub_I__ZN6ModbusC2Ev"
      ],
      "called": [
        "copy",
        "strlen"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "initVariant": {
      "entrypoint": "0x000816a6",
      "current_name": "initVariant",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initVariant(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "main": {
      "entrypoint": "0x000816a8",
      "current_name": "main",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint main(void)\n\n{\n  EVP_PKEY_CTX *in_r0;\n  \n  _watchdogDefaultSetup();\n  init(in_r0);\n  initVariant();\n  delay(1);\n  setup();\n  do {\n    loop();\n    serialEventRun();\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "Reset_Handler"
      ],
      "called": [
        "loop",
        "delay",
        "setup",
        "init",
        "serialEventRun",
        "_watchdogDefaultSetup",
        "initVariant"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_watchdogDefaultSetup": {
      "entrypoint": "0x000816d4",
      "current_name": "_watchdogDefaultSetup",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _watchdogDefaultSetup(void)\n\n{\n  WDT_Disable(0x400e1a50);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "WDT_Disable"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TimeTick_Increment": {
      "entrypoint": "0x00081704",
      "current_name": "TimeTick_Increment",
      "code": "\nvoid TimeTick_Increment(void)\n\n{\n  _dwTickCount \u003d _dwTickCount + 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SysTick_Handler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "GetTickCount": {
      "entrypoint": "0x00081714",
      "current_name": "GetTickCount",
      "code": "\nundefined4 GetTickCount(void)\n\n{\n  return _dwTickCount;\n}\n\n",
      "renaming": {},
      "calling": [
        "millis"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "WDT_Disable": {
      "entrypoint": "0x00081720",
      "current_name": "WDT_Disable",
      "code": "\nvoid WDT_Disable(int param_1)\n\n{\n  *(undefined4 *)(param_1 + 4) \u003d 0x8000;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_watchdogDefaultSetup"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_frsub": {
      "entrypoint": "0x00081728",
      "current_name": "__aeabi_frsub",
      "code": "\nvoid __aeabi_frsub(uint param_1)\n\n{\n  __addsf3(param_1 ^ 0x80000000);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__addsf3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_fsub": {
      "entrypoint": "0x00081730",
      "current_name": "__aeabi_fsub",
      "code": "\nuint __aeabi_fsub(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  int iVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  bool bVar8;\n  \n  uVar3 \u003d param_2 ^ 0x80000000;\n  uVar5 \u003d param_1 \u003c\u003c 1;\n  bVar8 \u003d uVar5 \u003d\u003d 0;\n  if (!bVar8) {\n    param_4 \u003d param_2 \u003c\u003c 1;\n    bVar8 \u003d param_4 \u003d\u003d 0;\n  }\n  if (!bVar8) {\n    bVar8 \u003d uVar5 \u003d\u003d param_4;\n  }\n  iVar1 \u003d (int)uVar5 \u003e\u003e 0x18;\n  if (!bVar8) {\n    bVar8 \u003d iVar1 \u003d\u003d -1;\n  }\n  if (!bVar8) {\n    bVar8 \u003d (int)param_4 \u003e\u003e 0x18 \u003d\u003d -1;\n  }\n  if (bVar8) {\n    iVar2 \u003d (int)(param_2 \u003c\u003c 1) \u003e\u003e 0x18;\n    if (iVar1 \u003d\u003d -1 || iVar2 \u003d\u003d -1) {\n      uVar5 \u003d uVar3;\n      if (iVar1 \u003d\u003d -1) {\n        uVar5 \u003d param_1;\n      }\n      if (iVar1 !\u003d -1 || iVar2 !\u003d -1) {\n        uVar3 \u003d uVar5;\n      }\n      bVar8 \u003d (uVar5 \u0026 0x7fffff) \u003d\u003d 0;\n      if (bVar8) {\n        bVar8 \u003d (uVar3 \u0026 0x7fffff) \u003d\u003d 0;\n      }\n      if (bVar8) {\n        bVar8 \u003d uVar5 \u003d\u003d uVar3;\n      }\n      if (!bVar8) {\n        uVar5 \u003d uVar5 | 0x400000;\n      }\n      return uVar5;\n    }\n    if (((param_1 ^ uVar3) \u0026 0x7fffffff) !\u003d 0) {\n      if (uVar5 \u003d\u003d 0) {\n        param_1 \u003d uVar3;\n      }\n      return param_1;\n    }\n    if (param_1 !\u003d uVar3) {\n      return 0;\n    }\n    if ((uVar5 \u0026 0xff000000) \u003d\u003d 0) {\n      uVar3 \u003d param_1 \u003c\u003c 1;\n      if ((param_1 \u0026 0x80000000) !\u003d 0) {\n        uVar3 \u003d uVar3 | 0x80000000;\n      }\n      return uVar3;\n    }\n    if (uVar5 \u003c 0xfe000000) {\n      return param_1 + 0x800000;\n    }\n    param_1 \u003d param_1 \u0026 0x80000000;\nLAB_0008186a:\n    return param_1 | 0x7f800000;\n  }\n  uVar5 \u003d uVar5 \u003e\u003e 0x18;\n  param_4 \u003d param_4 \u003e\u003e 0x18;\n  uVar7 \u003d param_4 - uVar5;\n  bVar8 \u003d uVar7 !\u003d 0;\n  uVar6 \u003d uVar5;\n  if (bVar8 \u0026\u0026 uVar5 \u003c\u003d param_4) {\n    uVar6 \u003d uVar5 + uVar7;\n  }\n  if (bVar8 \u0026\u0026 uVar5 \u003c\u003d param_4) {\n    uVar3 \u003d uVar3 ^ param_1;\n  }\n  if (bVar8 \u0026\u0026 uVar5 \u003c\u003d param_4) {\n    param_1 \u003d param_1 ^ uVar3;\n  }\n  if (bVar8 \u0026\u0026 uVar5 \u003c\u003d param_4) {\n    uVar3 \u003d uVar3 ^ param_1;\n  }\n  if (param_4 \u003c uVar5) {\n    uVar7 \u003d -uVar7;\n  }\n  if (0x19 \u003c uVar7) {\n    return param_1;\n  }\n  uVar5 \u003d param_1 \u0026 0xffffff | 0x800000;\n  if ((param_1 \u0026 0x80000000) !\u003d 0) {\n    uVar5 \u003d -uVar5;\n  }\n  uVar4 \u003d uVar3 \u0026 0xffffff | 0x800000;\n  if ((uVar3 \u0026 0x80000000) !\u003d 0) {\n    uVar4 \u003d -uVar4;\n  }\n  if (uVar6 \u003d\u003d uVar7) {\n    uVar4 \u003d uVar4 ^ 0x800000;\n    if (uVar6 \u003d\u003d 0) {\n      uVar5 \u003d uVar5 ^ 0x800000;\n      uVar6 \u003d 1;\n    }\n    else {\n      uVar7 \u003d uVar7 - 1;\n    }\n  }\n  uVar5 \u003d uVar5 + ((int)uVar4 \u003e\u003e (uVar7 \u0026 0xff));\n  uVar4 \u003d uVar4 \u003c\u003c (0x20 - uVar7 \u0026 0xff);\n  param_1 \u003d uVar5 \u0026 0x80000000;\n  if ((int)uVar5 \u003c 0) {\n    bVar8 \u003d uVar4 !\u003d 0;\n    uVar4 \u003d -uVar4;\n    uVar5 \u003d -uVar5 - (uint)bVar8;\n  }\n  if (uVar5 \u003c 0x800000) {\n    uVar3 \u003d uVar4 \u0026 0x80000000;\n    uVar4 \u003d uVar4 \u003c\u003c 1;\n    uVar5 \u003d uVar5 * 2 + (uint)(uVar3 !\u003d 0);\n    uVar3 \u003d uVar6 - 2;\n    if ((uVar5 \u0026 0x800000) \u003d\u003d 0) {\n      uVar7 \u003d LZCOUNT(uVar5) - 8;\n      uVar5 \u003d uVar5 \u003c\u003c (uVar7 \u0026 0xff);\n      if ((int)uVar3 \u003c (int)uVar7) {\n        uVar5 \u003d uVar5 \u003e\u003e (-(uVar3 - uVar7) \u0026 0xff);\n      }\n      else {\n        uVar5 \u003d uVar5 + (uVar3 - uVar7) * 0x800000;\n      }\n      return uVar5 | param_1;\n    }\n  }\n  else {\n    uVar3 \u003d uVar6 - 1;\n    if (0xffffff \u003c uVar5) {\n      uVar3 \u003d uVar5 \u0026 1;\n      uVar5 \u003d uVar5 \u003e\u003e 1;\n      uVar4 \u003d (uint)(uVar3 !\u003d 0) \u003c\u003c 0x1f | uVar4 \u003e\u003e 1;\n      uVar3 \u003d uVar6;\n      if (0xfd \u003c uVar6) goto LAB_0008186a;\n    }\n  }\n  uVar5 \u003d uVar5 + uVar3 * 0x800000 + (uint)(0x7fffffff \u003c uVar4);\n  if (uVar4 \u003d\u003d 0x80000000) {\n    uVar5 \u003d uVar5 \u0026 0xfffffffe;\n  }\n  return uVar5 | param_1;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__addsf3": {
      "entrypoint": "0x00081734",
      "current_name": "__addsf3",
      "code": "\nuint __addsf3(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  int iVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  bool bVar7;\n  \n  uVar4 \u003d param_1 \u003c\u003c 1;\n  bVar7 \u003d uVar4 \u003d\u003d 0;\n  if (!bVar7) {\n    param_4 \u003d param_2 \u003c\u003c 1;\n    bVar7 \u003d param_4 \u003d\u003d 0;\n  }\n  if (!bVar7) {\n    bVar7 \u003d uVar4 \u003d\u003d param_4;\n  }\n  iVar1 \u003d (int)uVar4 \u003e\u003e 0x18;\n  if (!bVar7) {\n    bVar7 \u003d iVar1 \u003d\u003d -1;\n  }\n  if (!bVar7) {\n    bVar7 \u003d (int)param_4 \u003e\u003e 0x18 \u003d\u003d -1;\n  }\n  if (bVar7) {\n    iVar2 \u003d (int)(param_2 \u003c\u003c 1) \u003e\u003e 0x18;\n    if (iVar1 \u003d\u003d -1 || iVar2 \u003d\u003d -1) {\n      uVar4 \u003d param_2;\n      if (iVar1 \u003d\u003d -1) {\n        uVar4 \u003d param_1;\n      }\n      if (iVar1 !\u003d -1 || iVar2 !\u003d -1) {\n        param_2 \u003d uVar4;\n      }\n      bVar7 \u003d (uVar4 \u0026 0x7fffff) \u003d\u003d 0;\n      if (bVar7) {\n        bVar7 \u003d (param_2 \u0026 0x7fffff) \u003d\u003d 0;\n      }\n      if (bVar7) {\n        bVar7 \u003d uVar4 \u003d\u003d param_2;\n      }\n      if (!bVar7) {\n        uVar4 \u003d uVar4 | 0x400000;\n      }\n      return uVar4;\n    }\n    if (((param_1 ^ param_2) \u0026 0x7fffffff) !\u003d 0) {\n      if (uVar4 \u003d\u003d 0) {\n        param_1 \u003d param_2;\n      }\n      return param_1;\n    }\n    if (param_1 !\u003d param_2) {\n      return 0;\n    }\n    if ((uVar4 \u0026 0xff000000) \u003d\u003d 0) {\n      uVar4 \u003d param_1 \u003c\u003c 1;\n      if ((param_1 \u0026 0x80000000) !\u003d 0) {\n        uVar4 \u003d uVar4 | 0x80000000;\n      }\n      return uVar4;\n    }\n    if (uVar4 \u003c 0xfe000000) {\n      return param_1 + 0x800000;\n    }\n    param_1 \u003d param_1 \u0026 0x80000000;\nLAB_0008186a:\n    return param_1 | 0x7f800000;\n  }\n  uVar4 \u003d uVar4 \u003e\u003e 0x18;\n  param_4 \u003d param_4 \u003e\u003e 0x18;\n  uVar6 \u003d param_4 - uVar4;\n  bVar7 \u003d uVar6 !\u003d 0;\n  uVar5 \u003d uVar4;\n  if (bVar7 \u0026\u0026 uVar4 \u003c\u003d param_4) {\n    uVar5 \u003d uVar4 + uVar6;\n  }\n  if (bVar7 \u0026\u0026 uVar4 \u003c\u003d param_4) {\n    param_2 \u003d param_2 ^ param_1;\n  }\n  if (bVar7 \u0026\u0026 uVar4 \u003c\u003d param_4) {\n    param_1 \u003d param_1 ^ param_2;\n  }\n  if (bVar7 \u0026\u0026 uVar4 \u003c\u003d param_4) {\n    param_2 \u003d param_2 ^ param_1;\n  }\n  if (param_4 \u003c uVar4) {\n    uVar6 \u003d -uVar6;\n  }\n  if (0x19 \u003c uVar6) {\n    return param_1;\n  }\n  uVar4 \u003d param_1 \u0026 0xffffff | 0x800000;\n  if ((param_1 \u0026 0x80000000) !\u003d 0) {\n    uVar4 \u003d -uVar4;\n  }\n  uVar3 \u003d param_2 \u0026 0xffffff | 0x800000;\n  if ((param_2 \u0026 0x80000000) !\u003d 0) {\n    uVar3 \u003d -uVar3;\n  }\n  if (uVar5 \u003d\u003d uVar6) {\n    uVar3 \u003d uVar3 ^ 0x800000;\n    if (uVar5 \u003d\u003d 0) {\n      uVar4 \u003d uVar4 ^ 0x800000;\n      uVar5 \u003d 1;\n    }\n    else {\n      uVar6 \u003d uVar6 - 1;\n    }\n  }\n  uVar4 \u003d uVar4 + ((int)uVar3 \u003e\u003e (uVar6 \u0026 0xff));\n  uVar3 \u003d uVar3 \u003c\u003c (0x20 - uVar6 \u0026 0xff);\n  param_1 \u003d uVar4 \u0026 0x80000000;\n  if ((int)uVar4 \u003c 0) {\n    bVar7 \u003d uVar3 !\u003d 0;\n    uVar3 \u003d -uVar3;\n    uVar4 \u003d -uVar4 - (uint)bVar7;\n  }\n  if (uVar4 \u003c 0x800000) {\n    uVar6 \u003d uVar3 \u0026 0x80000000;\n    uVar3 \u003d uVar3 \u003c\u003c 1;\n    uVar4 \u003d uVar4 * 2 + (uint)(uVar6 !\u003d 0);\n    uVar6 \u003d uVar5 - 2;\n    if ((uVar4 \u0026 0x800000) \u003d\u003d 0) {\n      uVar5 \u003d LZCOUNT(uVar4) - 8;\n      uVar4 \u003d uVar4 \u003c\u003c (uVar5 \u0026 0xff);\n      if ((int)uVar6 \u003c (int)uVar5) {\n        uVar4 \u003d uVar4 \u003e\u003e (-(uVar6 - uVar5) \u0026 0xff);\n      }\n      else {\n        uVar4 \u003d uVar4 + (uVar6 - uVar5) * 0x800000;\n      }\n      return uVar4 | param_1;\n    }\n  }\n  else {\n    uVar6 \u003d uVar5 - 1;\n    if (0xffffff \u003c uVar4) {\n      uVar6 \u003d uVar4 \u0026 1;\n      uVar4 \u003d uVar4 \u003e\u003e 1;\n      uVar3 \u003d (uint)(uVar6 !\u003d 0) \u003c\u003c 0x1f | uVar3 \u003e\u003e 1;\n      uVar6 \u003d uVar5;\n      if (0xfd \u003c uVar5) goto LAB_0008186a;\n    }\n  }\n  uVar4 \u003d uVar4 + uVar6 * 0x800000 + (uint)(0x7fffffff \u003c uVar3);\n  if (uVar3 \u003d\u003d 0x80000000) {\n    uVar4 \u003d uVar4 \u0026 0xfffffffe;\n  }\n  return uVar4 | param_1;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop",
        "__aeabi_frsub"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__floatunsisf": {
      "entrypoint": "0x00081894",
      "current_name": "__floatunsisf",
      "code": "\nuint __floatunsisf(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  \n  if (param_1 \u003d\u003d 0) {\n    return 0;\n  }\n  uVar1 \u003d LZCOUNT(param_1);\n  uVar2 \u003d uVar1 - 8;\n  iVar3 \u003d uVar2 * -0x800000 + 0x4a800000;\n  if (7 \u003c uVar1) {\n    uVar4 \u003d 0 \u003c\u003c (uVar2 \u0026 0xff);\n    uVar1 \u003d iVar3 + (param_1 \u003c\u003c (uVar2 \u0026 0xff)) +\n            (0U \u003e\u003e (0x20 - uVar2 \u0026 0xff)) + (uint)(0x7fffffff \u003c uVar4);\n    if (uVar4 \u003d\u003d 0x80000000) {\n      uVar1 \u003d uVar1 \u0026 0xfffffffe;\n    }\n    return uVar1;\n  }\n  uVar2 \u003d param_1 \u003c\u003c uVar1 + 0x18;\n  uVar1 \u003d iVar3 + ((param_1 \u003e\u003e (0x20 - (uVar1 + 0x18) \u0026 0xff)) - ((int)uVar2 \u003e\u003e 0x1f));\n  if ((uVar2 \u0026 0x7fffffff) \u003d\u003d 0) {\n    uVar1 \u003d uVar1 \u0026 ~(uVar2 \u003e\u003e 0x1f);\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__floatsisf": {
      "entrypoint": "0x0008189c",
      "current_name": "__floatsisf",
      "code": "\nuint __floatsisf(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  \n  uVar3 \u003d param_1 \u0026 0x80000000;\n  if ((int)uVar3 \u003c 0) {\n    param_1 \u003d -param_1;\n  }\n  if (param_1 \u003d\u003d 0) {\n    return 0;\n  }\n  uVar1 \u003d LZCOUNT(param_1);\n  uVar2 \u003d uVar1 - 8;\n  iVar4 \u003d ((uVar3 | 0x4b000000) - 0x800000) + uVar2 * -0x800000;\n  if (7 \u003c uVar1) {\n    uVar1 \u003d 0 \u003c\u003c (uVar2 \u0026 0xff);\n    uVar3 \u003d iVar4 + (param_1 \u003c\u003c (uVar2 \u0026 0xff)) +\n            (0U \u003e\u003e (0x20 - uVar2 \u0026 0xff)) + (uint)(0x7fffffff \u003c uVar1);\n    if (uVar1 \u003d\u003d 0x80000000) {\n      uVar3 \u003d uVar3 \u0026 0xfffffffe;\n    }\n    return uVar3;\n  }\n  uVar2 \u003d param_1 \u003c\u003c uVar1 + 0x18;\n  uVar3 \u003d iVar4 + ((param_1 \u003e\u003e (0x20 - (uVar1 + 0x18) \u0026 0xff)) - ((int)uVar2 \u003e\u003e 0x1f));\n  if ((uVar2 \u0026 0x7fffffff) \u003d\u003d 0) {\n    uVar3 \u003d uVar3 \u0026 ~(uVar2 \u003e\u003e 0x1f);\n  }\n  return uVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_ul2f": {
      "entrypoint": "0x000818b8",
      "current_name": "__aeabi_ul2f",
      "code": "\nuint __aeabi_ul2f(uint param_1,uint param_2)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  \n  if ((param_1 | param_2) \u003d\u003d 0) {\n    return param_1;\n  }\n  uVar1 \u003d param_1;\n  uVar2 \u003d param_2;\n  if (param_2 \u003d\u003d 0) {\n    uVar1 \u003d 0;\n    uVar2 \u003d param_1;\n  }\n  iVar5 \u003d 0x5b000000;\n  if (param_2 \u003d\u003d 0) {\n    iVar5 \u003d 0x4b000000;\n  }\n  uVar3 \u003d LZCOUNT(uVar2);\n  uVar4 \u003d uVar3 - 8;\n  iVar5 \u003d iVar5 + -0x800000 + uVar4 * -0x800000;\n  if (uVar3 \u003c 8) {\n    uVar4 \u003d uVar2 \u003c\u003c uVar3 + 0x18;\n    uVar2 \u003d iVar5 + ((uVar2 \u003e\u003e (0x20 - (uVar3 + 0x18) \u0026 0xff)) - ((int)uVar4 \u003e\u003e 0x1f));\n    if ((uVar1 | uVar4 \u003c\u003c 1) \u003d\u003d 0) {\n      uVar2 \u003d uVar2 \u0026 ~(uVar4 \u003e\u003e 0x1f);\n    }\n    return uVar2;\n  }\n  uVar3 \u003d uVar1 \u003c\u003c (uVar4 \u0026 0xff);\n  uVar2 \u003d iVar5 + (uVar2 \u003c\u003c (uVar4 \u0026 0xff)) +\n          (uVar1 \u003e\u003e (0x20 - uVar4 \u0026 0xff)) + (uint)(0x7fffffff \u003c uVar3);\n  if (uVar3 \u003d\u003d 0x80000000) {\n    uVar2 \u003d uVar2 \u0026 0xfffffffe;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_l2f": {
      "entrypoint": "0x000818c8",
      "current_name": "__aeabi_l2f",
      "code": "\nuint __aeabi_l2f(uint param_1,uint param_2)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  bool bVar7;\n  \n  if ((param_1 | param_2) \u003d\u003d 0) {\n    return param_1;\n  }\n  uVar5 \u003d param_2 \u0026 0x80000000;\n  if ((int)uVar5 \u003c 0) {\n    bVar7 \u003d param_1 !\u003d 0;\n    param_1 \u003d -param_1;\n    param_2 \u003d -param_2 - (uint)bVar7;\n  }\n  uVar2 \u003d param_1;\n  uVar1 \u003d param_2;\n  if (param_2 \u003d\u003d 0) {\n    uVar2 \u003d 0;\n    uVar1 \u003d param_1;\n  }\n  uVar5 \u003d uVar5 | 0x5b000000;\n  if (param_2 \u003d\u003d 0) {\n    uVar5 \u003d uVar5 + 0xf0000000;\n  }\n  uVar3 \u003d LZCOUNT(uVar1);\n  uVar4 \u003d uVar3 - 8;\n  iVar6 \u003d (uVar5 - 0x800000) + uVar4 * -0x800000;\n  if (uVar3 \u003c 8) {\n    uVar4 \u003d uVar1 \u003c\u003c uVar3 + 0x18;\n    uVar5 \u003d iVar6 + ((uVar1 \u003e\u003e (0x20 - (uVar3 + 0x18) \u0026 0xff)) - ((int)uVar4 \u003e\u003e 0x1f));\n    if ((uVar2 | uVar4 \u003c\u003c 1) \u003d\u003d 0) {\n      uVar5 \u003d uVar5 \u0026 ~(uVar4 \u003e\u003e 0x1f);\n    }\n    return uVar5;\n  }\n  uVar3 \u003d uVar2 \u003c\u003c (uVar4 \u0026 0xff);\n  uVar5 \u003d iVar6 + (uVar1 \u003c\u003c (uVar4 \u0026 0xff)) +\n          (uVar2 \u003e\u003e (0x20 - uVar4 \u0026 0xff)) + (uint)(0x7fffffff \u003c uVar3);\n  if (uVar3 \u003d\u003d 0x80000000) {\n    uVar5 \u003d uVar5 \u0026 0xfffffffe;\n  }\n  return uVar5;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_fmul": {
      "entrypoint": "0x00081944",
      "current_name": "__aeabi_fmul",
      "code": "\nuint __aeabi_fmul(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  longlong lVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  uint uVar8;\n  bool bVar9;\n  bool bVar10;\n  \n  uVar3 \u003d param_1 \u003e\u003e 0x17 \u0026 0xff;\n  bVar9 \u003d uVar3 \u003d\u003d 0;\n  if (!bVar9) {\n    param_4 \u003d param_2 \u003e\u003e 0x17 \u0026 0xff;\n    bVar9 \u003d param_4 \u003d\u003d 0;\n  }\n  if (!bVar9) {\n    bVar9 \u003d uVar3 \u003d\u003d 0xff;\n  }\n  if (!bVar9) {\n    bVar9 \u003d param_4 \u003d\u003d 0xff;\n  }\n  if (bVar9) {\n    param_4 \u003d param_2 \u003e\u003e 0x17 \u0026 0xff;\n    if (uVar3 \u003d\u003d 0xff || param_4 \u003d\u003d 0xff) {\n      bVar9 \u003d param_1 \u003d\u003d 0 || param_1 \u003d\u003d 0x80000000;\n      uVar2 \u003d param_2;\n      if (param_1 !\u003d 0 \u0026\u0026 param_1 !\u003d 0x80000000) {\n        bVar9 \u003d param_2 \u003d\u003d 0;\n        uVar2 \u003d param_1;\n      }\n      if (!bVar9) {\n        bVar9 \u003d param_2 \u003d\u003d 0x80000000;\n      }\n      uVar8 \u003d uVar2;\n      if (((bVar9) || ((uVar3 \u003d\u003d 0xff \u0026\u0026 ((uVar2 \u0026 0x7fffff) !\u003d 0)))) ||\n         ((param_4 \u003d\u003d 0xff \u0026\u0026 (uVar8 \u003d param_2, (param_2 \u0026 0x7fffff) !\u003d 0)))) {\n        return uVar8 | 0x7fc00000;\n      }\n      uVar2 \u003d uVar2 ^ param_2;\n      goto LAB_00081a94;\n    }\n    bVar9 \u003d (param_1 \u0026 0x7fffffff) \u003d\u003d 0;\n    if (!bVar9) {\n      bVar9 \u003d (param_2 \u0026 0x7fffffff) \u003d\u003d 0;\n    }\n    if (bVar9) {\n      return (param_1 ^ param_2) \u0026 0x80000000;\n    }\n    bVar9 \u003d uVar3 \u003d\u003d 0;\n    uVar2 \u003d param_1 \u0026 0x80000000;\n    while( true ) {\n      if (bVar9) {\n        param_1 \u003d param_1 \u003c\u003c 1;\n        bVar9 \u003d (param_1 \u0026 0x800000) \u003d\u003d 0;\n      }\n      if (!bVar9) break;\n      uVar3 \u003d uVar3 - 1;\n    }\n    param_1 \u003d param_1 | uVar2;\n    bVar9 \u003d param_4 \u003d\u003d 0;\n    uVar2 \u003d param_2 \u0026 0x80000000;\n    while( true ) {\n      if (bVar9) {\n        param_2 \u003d param_2 \u003c\u003c 1;\n        bVar9 \u003d (param_2 \u0026 0x800000) \u003d\u003d 0;\n      }\n      if (!bVar9) break;\n      param_4 \u003d param_4 - 1;\n    }\n    param_2 \u003d param_2 | uVar2;\n  }\n  iVar4 \u003d uVar3 + param_4;\n  uVar8 \u003d param_1 ^ param_2;\n  uVar3 \u003d param_1 \u003c\u003c 9;\n  bVar9 \u003d uVar3 \u003d\u003d 0;\n  if (!bVar9) {\n    param_2 \u003d param_2 \u003c\u003c 9;\n    bVar9 \u003d param_2 \u003d\u003d 0;\n  }\n  if (bVar9) {\n    if (uVar3 \u003d\u003d 0) {\n      param_2 \u003d param_2 \u003c\u003c 9;\n    }\n    uVar2 \u003d uVar8 \u0026 0x80000000 | param_1 \u0026 0x7fffff | param_2 \u003e\u003e 9;\n    bVar10 \u003d SBORROW4(iVar4,0x7f);\n    iVar5 \u003d iVar4 + -0x7f;\n    bVar9 \u003d iVar5 \u003d\u003d 0;\n    iVar7 \u003d iVar5;\n    if (!bVar9 \u0026\u0026 0x7e \u003c iVar4) {\n      bVar10 \u003d SBORROW4(0xff,iVar5);\n      iVar7 \u003d 0xff - iVar5;\n      bVar9 \u003d iVar5 \u003d\u003d 0xff;\n    }\n    if (!bVar9 \u0026\u0026 iVar7 \u003c 0 \u003d\u003d bVar10) {\n      uVar2 \u003d uVar2 | iVar5 * 0x800000;\n    }\n    if (!bVar9 \u0026\u0026 iVar7 \u003c 0 \u003d\u003d bVar10) {\n      return uVar2;\n    }\n    uVar2 \u003d uVar2 | 0x800000;\n    uVar6 \u003d 0;\n    bVar10 \u003d SBORROW4(iVar5,1);\n    uVar8 \u003d iVar4 - 0x80;\n    bVar9 \u003d uVar8 \u003d\u003d 0;\n    uVar3 \u003d uVar8;\n  }\n  else {\n    lVar1 \u003d (ulonglong)(uVar3 \u003e\u003e 5 | 0x8000000) * (ulonglong)(param_2 \u003e\u003e 5 | 0x8000000);\n    uVar6 \u003d (uint)lVar1;\n    uVar2 \u003d (uint)((ulonglong)lVar1 \u003e\u003e 0x20);\n    bVar9 \u003d uVar2 \u003c 0x800000;\n    if (bVar9) {\n      uVar2 \u003d uVar2 \u003c\u003c 1;\n    }\n    if (bVar9) {\n      uVar2 \u003d uVar2 | uVar6 \u003e\u003e 0x1f;\n      uVar6 \u003d uVar6 \u003c\u003c 1;\n    }\n    uVar2 \u003d uVar8 \u0026 0x80000000 | uVar2;\n    uVar8 \u003d (iVar4 + -0x7f) - (uint)bVar9;\n    bVar10 \u003d SBORROW4(uVar8,0xfd);\n    bVar9 \u003d uVar8 \u003d\u003d 0xfd;\n    uVar3 \u003d uVar8 - 0xfd;\n    if (uVar8 \u003c 0xfe) {\n      uVar2 \u003d uVar2 + uVar8 * 0x800000 + (uint)(0x7fffffff \u003c uVar6);\n      if (uVar6 \u003d\u003d 0x80000000) {\n        uVar2 \u003d uVar2 \u0026 0xfffffffe;\n      }\n      return uVar2;\n    }\n  }\n  if (bVar9 || (int)uVar3 \u003c 0 !\u003d bVar10) {\n    bVar9 \u003d (int)(uVar8 + 0x19) \u003c 0;\n    if (uVar8 \u003d\u003d 0xffffffe7 || bVar9 !\u003d SCARRY4(uVar8,0x19)) {\n      uVar2 \u003d uVar2 \u0026 0x80000000;\n    }\n    if (uVar8 !\u003d 0xffffffe7 \u0026\u0026 bVar9 \u003d\u003d SCARRY4(uVar8,0x19)) {\n      uVar3 \u003d (uVar2 \u003c\u003c 1) \u003e\u003e (-uVar8 \u0026 0xff);\n      uVar8 \u003d uVar2 \u003c\u003c (uVar8 + 0x20 \u0026 0xff);\n      uVar3 \u003d ((uint)((uVar2 \u0026 0x80000000) !\u003d 0) \u003c\u003c 0x1f | uVar3 \u003e\u003e 1) + (uint)((byte)uVar3 \u0026 1);\n      if ((uVar6 | uVar8 \u003c\u003c 1) \u003d\u003d 0) {\n        uVar3 \u003d uVar3 \u0026 ~(uVar8 \u003e\u003e 0x1f);\n      }\n      return uVar3;\n    }\n    return uVar2;\n  }\nLAB_00081a94:\n  return uVar2 \u0026 0x80000000 | 0x7f800000;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_fdiv": {
      "entrypoint": "0x00081aac",
      "current_name": "__aeabi_fdiv",
      "code": "\nuint __aeabi_fdiv(uint param_1,uint param_2,undefined4 param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  bool bVar7;\n  bool bVar8;\n  bool bVar9;\n  \n  uVar2 \u003d param_1 \u003e\u003e 0x17 \u0026 0xff;\n  bVar7 \u003d uVar2 \u003d\u003d 0;\n  if (!bVar7) {\n    param_4 \u003d param_2 \u003e\u003e 0x17 \u0026 0xff;\n    bVar7 \u003d param_4 \u003d\u003d 0;\n  }\n  if (!bVar7) {\n    bVar7 \u003d uVar2 \u003d\u003d 0xff;\n  }\n  if (!bVar7) {\n    bVar7 \u003d param_4 \u003d\u003d 0xff;\n  }\n  if (bVar7) {\n    param_4 \u003d param_2 \u003e\u003e 0x17 \u0026 0xff;\n    uVar6 \u003d param_1;\n    if (uVar2 \u003d\u003d 0xff) {\n      if (((param_1 \u0026 0x7fffff) !\u003d 0) || (uVar6 \u003d param_2, param_4 \u003d\u003d 0xff)) {\nLAB_00081aa2:\n        return uVar6 | 0x7fc00000;\n      }\n    }\n    else {\n      if (param_4 \u003d\u003d 0xff) {\n        uVar6 \u003d param_2;\n        if ((param_2 \u0026 0x7fffff) \u003d\u003d 0) {\nLAB_00081a58:\n          return (param_1 ^ param_2) \u0026 0x80000000;\n        }\n        goto LAB_00081aa2;\n      }\n      bVar7 \u003d (param_1 \u0026 0x7fffffff) \u003d\u003d 0;\n      if (!bVar7) {\n        bVar7 \u003d (param_2 \u0026 0x7fffffff) \u003d\u003d 0;\n      }\n      if (!bVar7) {\n        bVar7 \u003d uVar2 \u003d\u003d 0;\n        uVar6 \u003d param_1 \u0026 0x80000000;\n        while( true ) {\n          if (bVar7) {\n            param_1 \u003d param_1 \u003c\u003c 1;\n            bVar7 \u003d (param_1 \u0026 0x800000) \u003d\u003d 0;\n          }\n          if (!bVar7) break;\n          uVar2 \u003d uVar2 - 1;\n        }\n        param_1 \u003d param_1 | uVar6;\n        bVar7 \u003d param_4 \u003d\u003d 0;\n        uVar6 \u003d param_2 \u0026 0x80000000;\n        while( true ) {\n          if (bVar7) {\n            param_2 \u003d param_2 \u003c\u003c 1;\n            bVar7 \u003d (param_2 \u0026 0x800000) \u003d\u003d 0;\n          }\n          if (!bVar7) break;\n          param_4 \u003d param_4 - 1;\n        }\n        param_2 \u003d param_2 | uVar6;\n        goto LAB_00081ac4;\n      }\n      if ((param_1 \u0026 0x7fffffff) \u003d\u003d 0) {\n        if ((param_2 \u0026 0x7fffffff) !\u003d 0) goto LAB_00081a58;\n        goto LAB_00081aa2;\n      }\n    }\n    param_1 \u003d param_1 ^ param_2;\n  }\n  else {\nLAB_00081ac4:\n    iVar3 \u003d uVar2 - param_4;\n    if (param_2 \u003c\u003c 9 \u003d\u003d 0) {\n      param_1 \u003d (param_1 ^ param_2) \u0026 0x80000000 | param_1 \u0026 0x7fffff;\n      bVar9 \u003d SCARRY4(iVar3,0x7f);\n      iVar5 \u003d iVar3 + 0x7f;\n      bVar7 \u003d iVar5 \u003c 0;\n      bVar8 \u003d iVar5 \u003d\u003d 0;\n      if (!bVar8 \u0026\u0026 bVar7 \u003d\u003d bVar9) {\n        bVar9 \u003d SBORROW4(0xff,iVar5);\n        bVar7 \u003d 0xff - iVar5 \u003c 0;\n        bVar8 \u003d iVar5 \u003d\u003d 0xff;\n      }\n      if (!bVar8 \u0026\u0026 bVar7 \u003d\u003d bVar9) {\n        param_1 \u003d param_1 | iVar5 * 0x800000;\n      }\n      if (!bVar8 \u0026\u0026 bVar7 \u003d\u003d bVar9) {\n        return param_1;\n      }\n      param_1 \u003d param_1 | 0x800000;\n      uVar2 \u003d 0;\n      bVar8 \u003d SBORROW4(iVar5,1);\n      uVar4 \u003d iVar3 + 0x7e;\n      bVar7 \u003d uVar4 \u003d\u003d 0;\n      uVar6 \u003d uVar4;\n    }\n    else {\n      uVar1 \u003d (param_2 \u003c\u003c 9) \u003e\u003e 4 | 0x10000000;\n      uVar2 \u003d (param_1 \u003c\u003c 9) \u003e\u003e 4 | 0x10000000;\n      param_1 \u003d (param_1 ^ param_2) \u0026 0x80000000;\n      bVar7 \u003d uVar1 \u003c\u003d uVar2;\n      if (!bVar7) {\n        uVar2 \u003d uVar2 \u003c\u003c 1;\n      }\n      uVar4 \u003d iVar3 + 0x7d + (uint)bVar7;\n      uVar6 \u003d 0x800000;\n      do {\n        if (uVar1 \u003c\u003d uVar2) {\n          uVar2 \u003d uVar2 - uVar1;\n          param_1 \u003d param_1 | uVar6;\n        }\n        bVar7 \u003d uVar1 \u003e\u003e 1 \u003c\u003d uVar2;\n        if (bVar7) {\n          uVar2 \u003d uVar2 - (uVar1 \u003e\u003e 1);\n        }\n        if (bVar7) {\n          param_1 \u003d param_1 | uVar6 \u003e\u003e 1;\n        }\n        bVar7 \u003d uVar1 \u003e\u003e 2 \u003c\u003d uVar2;\n        if (bVar7) {\n          uVar2 \u003d uVar2 - (uVar1 \u003e\u003e 2);\n        }\n        if (bVar7) {\n          param_1 \u003d param_1 | uVar6 \u003e\u003e 2;\n        }\n        bVar7 \u003d uVar1 \u003e\u003e 3 \u003c\u003d uVar2;\n        if (bVar7) {\n          uVar2 \u003d uVar2 - (uVar1 \u003e\u003e 3);\n        }\n        if (bVar7) {\n          param_1 \u003d param_1 | uVar6 \u003e\u003e 3;\n        }\n        uVar2 \u003d uVar2 * 0x10;\n        bVar7 \u003d uVar2 \u003d\u003d 0;\n        if (!bVar7) {\n          uVar6 \u003d uVar6 \u003e\u003e 4;\n          bVar7 \u003d uVar6 \u003d\u003d 0;\n        }\n      } while (!bVar7);\n      bVar8 \u003d SBORROW4(uVar4,0xfd);\n      bVar7 \u003d uVar4 \u003d\u003d 0xfd;\n      uVar6 \u003d uVar4 - 0xfd;\n      if (uVar4 \u003c 0xfe) {\n        param_1 \u003d param_1 + uVar4 * 0x800000 + (uint)(uVar1 \u003c\u003d uVar2);\n        if (uVar2 - uVar1 \u003d\u003d 0) {\n          param_1 \u003d param_1 \u0026 0xfffffffe;\n        }\n        return param_1;\n      }\n    }\n    if (bVar7 || (int)uVar6 \u003c 0 !\u003d bVar8) {\n      bVar7 \u003d (int)(uVar4 + 0x19) \u003c 0;\n      if (uVar4 \u003d\u003d 0xffffffe7 || bVar7 !\u003d SCARRY4(uVar4,0x19)) {\n        param_1 \u003d param_1 \u0026 0x80000000;\n      }\n      if (uVar4 \u003d\u003d 0xffffffe7 || bVar7 !\u003d SCARRY4(uVar4,0x19)) {\n        return param_1;\n      }\n      uVar6 \u003d (param_1 \u003c\u003c 1) \u003e\u003e (-uVar4 \u0026 0xff);\n      uVar4 \u003d param_1 \u003c\u003c (uVar4 + 0x20 \u0026 0xff);\n      uVar6 \u003d ((uint)((param_1 \u0026 0x80000000) !\u003d 0) \u003c\u003c 0x1f | uVar6 \u003e\u003e 1) + (uint)((byte)uVar6 \u0026 1);\n      if ((uVar2 | uVar4 \u003c\u003c 1) \u003d\u003d 0) {\n        uVar6 \u003d uVar6 \u0026 ~(uVar4 \u003e\u003e 0x1f);\n      }\n      return uVar6;\n    }\n  }\n  return param_1 \u0026 0x80000000 | 0x7f800000;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__gesf2": {
      "entrypoint": "0x00081be4",
      "current_name": "__gesf2",
      "code": "\nuint __gesf2(uint param_1,uint param_2)\n\n{\n  bool bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  bool bVar5;\n  \n  uVar2 \u003d param_1 * 2;\n  uVar3 \u003d param_2 * 2;\n  if (((int)uVar2 \u003e\u003e 0x18 \u003d\u003d -1 || (int)uVar3 \u003e\u003e 0x18 \u003d\u003d -1) \u0026\u0026\n     ((((int)uVar2 \u003e\u003e 0x18 \u003d\u003d -1 \u0026\u0026 ((param_1 \u0026 0x7fffff) !\u003d 0)) ||\n      (((int)uVar3 \u003e\u003e 0x18 \u003d\u003d -1 \u0026\u0026 ((param_2 \u0026 0x7fffff) !\u003d 0)))))) {\n    return 0xffffffff;\n  }\n  uVar4 \u003d uVar2 | param_2 \u0026 0x7fffffff;\n  bVar5 \u003d uVar4 \u003d\u003d 0;\n  if (!bVar5) {\n    uVar4 \u003d param_1 ^ param_2;\n    bVar5 \u003d uVar4 \u003d\u003d 0;\n  }\n  bVar1 \u003d -1 \u003c (int)uVar4;\n  if (bVar1) {\n    param_1 \u003d uVar2 + param_2 * -2;\n    bVar5 \u003d param_1 \u003d\u003d 0;\n  }\n  if ((bVar1 \u0026\u0026 uVar3 \u003c\u003d uVar2) \u0026\u0026 !bVar5) {\n    param_1 \u003d (int)param_2 \u003e\u003e 0x1f;\n  }\n  if (!bVar1 || uVar3 \u003e uVar2) {\n    param_1 \u003d ~((int)param_2 \u003e\u003e 0x1f);\n  }\n  if (!bVar5) {\n    param_1 \u003d param_1 | 1;\n  }\n  return param_1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__ltsf2": {
      "entrypoint": "0x00081bec",
      "current_name": "__ltsf2",
      "code": "\nuint __ltsf2(uint param_1,uint param_2)\n\n{\n  bool bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  bool bVar5;\n  \n  uVar2 \u003d param_1 * 2;\n  uVar3 \u003d param_2 * 2;\n  if (((int)uVar2 \u003e\u003e 0x18 \u003d\u003d -1 || (int)uVar3 \u003e\u003e 0x18 \u003d\u003d -1) \u0026\u0026\n     ((((int)uVar2 \u003e\u003e 0x18 \u003d\u003d -1 \u0026\u0026 ((param_1 \u0026 0x7fffff) !\u003d 0)) ||\n      (((int)uVar3 \u003e\u003e 0x18 \u003d\u003d -1 \u0026\u0026 ((param_2 \u0026 0x7fffff) !\u003d 0)))))) {\n    return 1;\n  }\n  uVar4 \u003d uVar2 | param_2 \u0026 0x7fffffff;\n  bVar5 \u003d uVar4 \u003d\u003d 0;\n  if (!bVar5) {\n    uVar4 \u003d param_1 ^ param_2;\n    bVar5 \u003d uVar4 \u003d\u003d 0;\n  }\n  bVar1 \u003d -1 \u003c (int)uVar4;\n  if (bVar1) {\n    param_1 \u003d uVar2 + param_2 * -2;\n    bVar5 \u003d param_1 \u003d\u003d 0;\n  }\n  if ((bVar1 \u0026\u0026 uVar3 \u003c\u003d uVar2) \u0026\u0026 !bVar5) {\n    param_1 \u003d (int)param_2 \u003e\u003e 0x1f;\n  }\n  if (!bVar1 || uVar3 \u003e uVar2) {\n    param_1 \u003d ~((int)param_2 \u003e\u003e 0x1f);\n  }\n  if (!bVar5) {\n    param_1 \u003d param_1 | 1;\n  }\n  return param_1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__cmpsf2": {
      "entrypoint": "0x00081bf4",
      "current_name": "__cmpsf2",
      "code": "\nuint __cmpsf2(uint param_1,uint param_2)\n\n{\n  bool bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  bool bVar5;\n  \n  uVar2 \u003d param_1 * 2;\n  uVar3 \u003d param_2 * 2;\n  if (((int)uVar2 \u003e\u003e 0x18 \u003d\u003d -1 || (int)uVar3 \u003e\u003e 0x18 \u003d\u003d -1) \u0026\u0026\n     ((((int)uVar2 \u003e\u003e 0x18 \u003d\u003d -1 \u0026\u0026 ((param_1 \u0026 0x7fffff) !\u003d 0)) ||\n      (((int)uVar3 \u003e\u003e 0x18 \u003d\u003d -1 \u0026\u0026 ((param_2 \u0026 0x7fffff) !\u003d 0)))))) {\n    return 1;\n  }\n  uVar4 \u003d uVar2 | param_2 \u0026 0x7fffffff;\n  bVar5 \u003d uVar4 \u003d\u003d 0;\n  if (!bVar5) {\n    uVar4 \u003d param_1 ^ param_2;\n    bVar5 \u003d uVar4 \u003d\u003d 0;\n  }\n  bVar1 \u003d -1 \u003c (int)uVar4;\n  if (bVar1) {\n    param_1 \u003d uVar2 + param_2 * -2;\n    bVar5 \u003d param_1 \u003d\u003d 0;\n  }\n  if ((bVar1 \u0026\u0026 uVar3 \u003c\u003d uVar2) \u0026\u0026 !bVar5) {\n    param_1 \u003d (int)param_2 \u003e\u003e 0x1f;\n  }\n  if (!bVar1 || uVar3 \u003e uVar2) {\n    param_1 \u003d ~((int)param_2 \u003e\u003e 0x1f);\n  }\n  if (!bVar5) {\n    param_1 \u003d param_1 | 1;\n  }\n  return param_1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_cfcmpeq"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_cfrcmple": {
      "entrypoint": "0x00081c54",
      "current_name": "__aeabi_cfrcmple",
      "code": "\nvoid __aeabi_cfrcmple(undefined4 param_1,undefined4 param_2)\n\n{\n  __aeabi_cfcmpeq(param_2,param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_fcmpgt",
        "__aeabi_fcmpge"
      ],
      "called": [
        "__aeabi_cfcmpeq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_cfcmpeq": {
      "entrypoint": "0x00081c5c",
      "current_name": "__aeabi_cfcmpeq",
      "code": "\nundefined8 __aeabi_cfcmpeq(undefined4 param_1,undefined4 param_2)\n\n{\n  __cmpsf2();\n  return CONCAT44(param_2,param_1);\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_fcmpeq",
        "__aeabi_fcmplt",
        "__aeabi_fcmple",
        "__aeabi_cfrcmple"
      ],
      "called": [
        "__cmpsf2"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_fcmpeq": {
      "entrypoint": "0x00081c6c",
      "current_name": "__aeabi_fcmpeq",
      "code": "\nbool __aeabi_fcmpeq(void)\n\n{\n  char in_ZR;\n  \n  __aeabi_cfcmpeq();\n  return in_ZR !\u003d \u0027\\0\u0027;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__aeabi_cfcmpeq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_fcmplt": {
      "entrypoint": "0x00081c80",
      "current_name": "__aeabi_fcmplt",
      "code": "\nbool __aeabi_fcmplt(void)\n\n{\n  char in_CY;\n  \n  __aeabi_cfcmpeq();\n  return in_CY \u003d\u003d \u0027\\0\u0027;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__aeabi_cfcmpeq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_fcmple": {
      "entrypoint": "0x00081c94",
      "current_name": "__aeabi_fcmple",
      "code": "\nbool __aeabi_fcmple(void)\n\n{\n  undefined in_ZR;\n  undefined in_CY;\n  \n  __aeabi_cfcmpeq();\n  return !(bool)in_CY || (bool)in_ZR;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "__aeabi_cfcmpeq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_fcmpge": {
      "entrypoint": "0x00081ca8",
      "current_name": "__aeabi_fcmpge",
      "code": "\nbool __aeabi_fcmpge(void)\n\n{\n  undefined in_ZR;\n  undefined in_CY;\n  \n  __aeabi_cfrcmple();\n  return !(bool)in_CY || (bool)in_ZR;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "__aeabi_cfrcmple"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_fcmpgt": {
      "entrypoint": "0x00081cbc",
      "current_name": "__aeabi_fcmpgt",
      "code": "\nbool __aeabi_fcmpgt(void)\n\n{\n  char in_CY;\n  \n  __aeabi_cfrcmple();\n  return in_CY \u003d\u003d \u0027\\0\u0027;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__aeabi_cfrcmple"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_f2iz": {
      "entrypoint": "0x00081cd0",
      "current_name": "__aeabi_f2iz",
      "code": "\nuint __aeabi_f2iz(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  if (param_1 \u003c\u003c 1 \u003c 0x7f000000) {\n    return 0;\n  }\n  uVar1 \u003d (param_1 \u003c\u003c 1) \u003e\u003e 0x18;\n  uVar2 \u003d 0x9e - uVar1;\n  if (uVar1 \u003c 0x9f \u0026\u0026 uVar2 !\u003d 0) {\n    uVar1 \u003d (param_1 \u003c\u003c 8 | 0x80000000) \u003e\u003e (uVar2 \u0026 0xff);\n    if ((param_1 \u0026 0x80000000) !\u003d 0) {\n      uVar1 \u003d -uVar1;\n    }\n    return uVar1;\n  }\n  if ((uVar2 \u003d\u003d 0xffffff9f) \u0026\u0026 ((param_1 \u0026 0x7fffff) !\u003d 0)) {\n    return 0;\n  }\n  param_1 \u003d param_1 \u0026 0x80000000;\n  if (param_1 \u003d\u003d 0) {\n    param_1 \u003d 0x7fffffff;\n  }\n  return param_1;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__fixunssfsi": {
      "entrypoint": "0x00081d1c",
      "current_name": "__fixunssfsi",
      "code": "\nuint __fixunssfsi(uint param_1)\n\n{\n  uint uVar1;\n  \n  if (((param_1 \u0026 0x80000000) !\u003d 0) || (param_1 \u003c\u003c 1 \u003c 0x7f000000)) {\n    return 0;\n  }\n  uVar1 \u003d 0x9e - ((param_1 \u003c\u003c 1) \u003e\u003e 0x18);\n  if (-1 \u003c (int)uVar1) {\n    return (param_1 \u003c\u003c 8 | 0x80000000) \u003e\u003e (uVar1 \u0026 0xff);\n  }\n  if ((uVar1 \u003d\u003d 0xffffff9f) \u0026\u0026 ((param_1 \u0026 0x7fffff) !\u003d 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_atexit": {
      "entrypoint": "0x00081d5c",
      "current_name": "__aeabi_atexit",
      "code": "\nvoid __aeabi_atexit(undefined4 param_1,undefined4 param_2)\n\n{\n  __cxa_atexit(param_2,param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_GLOBAL__sub_I__ZN6ModbusC2Ev"
      ],
      "called": [
        "__cxa_atexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__cxa_atexit": {
      "entrypoint": "0x00081d68",
      "current_name": "__cxa_atexit",
      "code": "\nvoid __cxa_atexit(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  __register_exitproc(2,param_1,param_2,param_3);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_atexit"
      ],
      "called": [
        "__register_exitproc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__libc_init_array": {
      "entrypoint": "0x00081d7c",
      "current_name": "__libc_init_array",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00081d88) */\n/* WARNING: Removing unreachable block (ram,0x00081d8c) */\n/* WARNING: Removing unreachable block (ram,0x00081db8) */\n\nvoid __libc_init_array(void)\n\n{\n  int iVar1;\n  code **ppcVar2;\n  \n  _init();\n  ppcVar2 \u003d (code **)0x85860;\n  iVar1 \u003d 0;\n  do {\n    iVar1 \u003d iVar1 + 1;\n    ppcVar2 \u003d ppcVar2 + 1;\n    (**ppcVar2)();\n  } while (iVar1 !\u003d 4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "init"
      ],
      "called": [
        "_init",
        "frame_dummy",
        "register_fini"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "iprintf": {
      "entrypoint": "0x00081dcc",
      "current_name": "iprintf",
      "code": "\nvoid iprintf(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  uStack_c \u003d param_2;\n  uStack_8 \u003d param_3;\n  uStack_4 \u003d param_4;\n  _vfiprintf_r(_impure_ptr,*(undefined4 *)(_impure_ptr + 8),param_1,\u0026uStack_c);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_exit"
      ],
      "called": [
        "_vfiprintf_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "malloc": {
      "entrypoint": "0x00081df4",
      "current_name": "malloc",
      "code": "\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d (void *)_malloc_r(_impure_ptr,__size);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__register_exitproc"
      ],
      "called": [
        "_malloc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "free": {
      "entrypoint": "0x00081e04",
      "current_name": "free",
      "code": "\nvoid free(void *__ptr)\n\n{\n  _free_r(_impure_ptr,__ptr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "invalidate",
        "~String"
      ],
      "called": [
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_malloc_r": {
      "entrypoint": "0x00081e14",
      "current_name": "_malloc_r",
      "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * _malloc_r(undefined4 *param_1,uint param_2)\n\n{\n  undefined1 *puVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  undefined4 *puVar9;\n  undefined1 *puVar10;\n  undefined1 *puVar11;\n  undefined1 *puVar12;\n  uint uVar13;\n  undefined4 *puVar14;\n  undefined4 *puVar15;\n  undefined1 *puVar16;\n  \n  if (param_2 + 0xb \u003c 0x17) {\n    uVar13 \u003d 0x10;\n    if (0x10 \u003c param_2) goto LAB_00081e7a;\n  }\n  else {\n    uVar13 \u003d param_2 + 0xb \u0026 0xfffffff8;\n    if (((int)uVar13 \u003c 0) || (uVar13 \u003c param_2)) {\nLAB_00081e7a:\n      *param_1 \u003d 0xc;\n      return (int *)0x0;\n    }\n  }\n  __malloc_lock(param_1);\n  puVar14 \u003d DAT_20070474;\n  if (uVar13 \u003c 0x1f8) {\n    puVar12 \u003d *(undefined1 **)((int)\u0026DAT_20070470 + uVar13);\n    if ((puVar12 !\u003d \u0026__malloc_av_ + uVar13) ||\n       (puVar11 \u003d puVar12 + 8, puVar12 \u003d *(undefined1 **)(puVar12 + 0x14), puVar11 !\u003d puVar12)) {\n      uVar8 \u003d *(uint *)(puVar12 + 4);\n      iVar5 \u003d *(int *)(puVar12 + 0xc);\n      uVar13 \u003d *(uint *)(puVar12 + (uVar8 \u0026 0xfffffffc) + 4);\n      iVar2 \u003d *(int *)(puVar12 + 8);\n      *(int *)(iVar2 + 0xc) \u003d iVar5;\n      *(int *)(iVar5 + 8) \u003d iVar2;\n      *(uint *)(puVar12 + (uVar8 \u0026 0xfffffffc) + 4) \u003d uVar13 | 1;\n      __malloc_unlock(param_1);\n      return (int *)(puVar12 + 8);\n    }\n    uVar8 \u003d (uVar13 \u003e\u003e 3) + 2;\n  }\n  else {\n    uVar8 \u003d uVar13 \u003e\u003e 9;\n    if (uVar8 \u003d\u003d 0) {\n      iVar5 \u003d 0x7e;\n      iVar2 \u003d 0x3f;\n    }\n    else if (uVar8 \u003c 5) {\n      iVar2 \u003d (uVar13 \u003e\u003e 6) + 0x38;\n      iVar5 \u003d iVar2 * 2;\n    }\n    else if (uVar8 \u003c 0x15) {\n      iVar2 \u003d uVar8 + 0x5b;\n      iVar5 \u003d iVar2 * 2;\n    }\n    else if (uVar8 \u003c 0x55) {\n      iVar2 \u003d (uVar13 \u003e\u003e 0xc) + 0x6e;\n      iVar5 \u003d iVar2 * 2;\n    }\n    else if (uVar8 \u003c 0x155) {\n      iVar2 \u003d (uVar13 \u003e\u003e 0xf) + 0x77;\n      iVar5 \u003d iVar2 * 2;\n    }\n    else if (uVar8 \u003c 0x555) {\n      iVar2 \u003d (uVar13 \u003e\u003e 0x12) + 0x7c;\n      iVar5 \u003d iVar2 * 2;\n    }\n    else {\n      iVar5 \u003d 0xfc;\n      iVar2 \u003d 0x7e;\n    }\n    for (puVar12 \u003d (undefined1 *)(\u0026DAT_20070470)[iVar5]; \u0026__malloc_av_ + iVar5 * 4 !\u003d puVar12;\n        puVar12 \u003d *(undefined1 **)(puVar12 + 0xc)) {\n      uVar8 \u003d *(uint *)(puVar12 + 4) \u0026 0xfffffffc;\n      if (0xf \u003c (int)(uVar8 - uVar13)) {\n        iVar2 \u003d iVar2 + -1;\n        break;\n      }\n      if (-1 \u003c (int)(uVar8 - uVar13)) {\n        uVar13 \u003d *(uint *)(puVar12 + uVar8 + 4);\n        iVar5 \u003d *(int *)(puVar12 + 0xc);\n        iVar2 \u003d *(int *)(puVar12 + 8);\n        *(int *)(iVar2 + 0xc) \u003d iVar5;\n        *(int *)(iVar5 + 8) \u003d iVar2;\n        *(uint *)(puVar12 + uVar8 + 4) \u003d uVar13 | 1;\n        __malloc_unlock(param_1);\n        return (int *)(puVar12 + 8);\n      }\n    }\n    uVar8 \u003d iVar2 + 1;\n  }\n  uVar3 \u003d DAT_20070468;\n  if ((undefined1 **)DAT_20070474 !\u003d \u0026DAT_2007046c) {\n    uVar3 \u003d DAT_20070474[1];\n    uVar4 \u003d uVar3 \u0026 0xfffffffc;\n    uVar6 \u003d uVar4 - uVar13;\n    if (0xf \u003c (int)uVar6) {\n      puVar15 \u003d (undefined4 *)(uVar13 + (int)DAT_20070474);\n      DAT_20070474[1] \u003d uVar13 | 1;\n      DAT_20070474 \u003d puVar15;\n      DAT_20070478 \u003d puVar15;\n      puVar15[3] \u003d \u0026DAT_2007046c;\n      puVar15[2] \u003d \u0026DAT_2007046c;\n      puVar15[1] \u003d uVar6 | 1;\n      *(uint *)((int)puVar15 + uVar6) \u003d uVar6;\n      __malloc_unlock(param_1);\n      return puVar14 + 2;\n    }\n    DAT_20070478 \u003d \u0026DAT_2007046c;\n    DAT_20070474 \u003d \u0026DAT_2007046c;\n    if (-1 \u003c (int)uVar6) {\n      *(uint *)((int)puVar14 + uVar4 + 4) \u003d *(uint *)((int)puVar14 + uVar4 + 4) | 1;\n      __malloc_unlock(param_1);\n      return puVar14 + 2;\n    }\n    if (uVar4 \u003c 0x200) {\n      uVar4 \u003d uVar3 \u0026 0xfffffff8;\n      iVar2 \u003d *(int *)((int)\u0026DAT_2007046c + uVar4);\n      uVar3 \u003d 1 \u003c\u003c ((int)(uVar3 \u003e\u003e 3) \u003e\u003e 2 \u0026 0xffU) | DAT_20070468;\n      puVar14[2] \u003d iVar2;\n      puVar14[3] \u003d \u0026__malloc_av_ + uVar4;\n      DAT_20070468 \u003d uVar3;\n      *(undefined4 **)((int)\u0026DAT_2007046c + uVar4) \u003d puVar14;\n      *(undefined4 **)(iVar2 + 0xc) \u003d puVar14;\n    }\n    else {\n      uVar6 \u003d uVar3 \u003e\u003e 9;\n      if (uVar6 \u003c 5) {\n        iVar5 \u003d (uVar3 \u003e\u003e 6) + 0x38;\n        iVar2 \u003d iVar5 * 2;\n      }\n      else if (uVar6 \u003c 0x15) {\n        iVar5 \u003d uVar6 + 0x5b;\n        iVar2 \u003d iVar5 * 2;\n      }\n      else if (uVar6 \u003c 0x55) {\n        iVar5 \u003d (uVar3 \u003e\u003e 0xc) + 0x6e;\n        iVar2 \u003d iVar5 * 2;\n      }\n      else if (uVar6 \u003c 0x155) {\n        iVar5 \u003d (uVar3 \u003e\u003e 0xf) + 0x77;\n        iVar2 \u003d iVar5 * 2;\n      }\n      else if (uVar6 \u003c 0x555) {\n        iVar5 \u003d (uVar3 \u003e\u003e 0x12) + 0x7c;\n        iVar2 \u003d iVar5 * 2;\n      }\n      else {\n        iVar2 \u003d 0xfc;\n        iVar5 \u003d 0x7e;\n      }\n      puVar12 \u003d (\u0026DAT_2007046c)[iVar2];\n      if (puVar12 \u003d\u003d \u0026__malloc_av_ + iVar2 * 4) {\n        DAT_20070468 \u003d DAT_20070468 | 1 \u003c\u003c (iVar5 \u003e\u003e 2 \u0026 0xffU);\n        puVar11 \u003d puVar12;\n      }\n      else {\n        do {\n          puVar11 \u003d puVar12;\n          if ((*(uint *)(puVar12 + 4) \u0026 0xfffffffc) \u003c\u003d uVar4) break;\n          puVar12 \u003d *(undefined1 **)(puVar12 + 8);\n          puVar11 \u003d puVar12;\n        } while (\u0026__malloc_av_ + iVar2 * 4 !\u003d puVar12);\n        puVar12 \u003d *(undefined1 **)(puVar11 + 0xc);\n      }\n      uVar3 \u003d DAT_20070468;\n      puVar14[3] \u003d puVar12;\n      puVar14[2] \u003d puVar11;\n      *(undefined4 **)(puVar12 + 8) \u003d puVar14;\n      *(undefined4 **)(puVar11 + 0xc) \u003d puVar14;\n    }\n  }\n  puVar12 \u003d DAT_2007046c;\n  uVar4 \u003d 1 \u003c\u003c ((int)uVar8 \u003e\u003e 2 \u0026 0xffU);\n  if (uVar4 \u003c\u003d uVar3) {\n    if ((uVar3 \u0026 uVar4) \u003d\u003d 0) {\n      uVar8 \u003d uVar8 \u0026 0xfffffffc;\n      do {\n        uVar4 \u003d uVar4 \u003c\u003c 1;\n        uVar8 \u003d uVar8 + 4;\n      } while ((uVar3 \u0026 uVar4) \u003d\u003d 0);\n    }\n    do {\n      puVar15 \u003d (undefined4 *)(\u0026__malloc_av_ + uVar8 * 8);\n      puVar14 \u003d puVar15;\n      uVar3 \u003d uVar8;\n      do {\n        for (puVar9 \u003d (undefined4 *)puVar14[3]; puVar14 !\u003d puVar9; puVar9 \u003d (undefined4 *)puVar9[3])\n        {\n          uVar6 \u003d puVar9[1] \u0026 0xfffffffc;\n          uVar7 \u003d uVar6 - uVar13;\n          if (0xf \u003c (int)uVar7) {\n            iVar5 \u003d puVar9[2];\n            iVar2 \u003d puVar9[3];\n            puVar14 \u003d (undefined4 *)(uVar13 + (int)puVar9);\n            puVar9[1] \u003d uVar13 | 1;\n            *(int *)(iVar5 + 0xc) \u003d iVar2;\n            *(int *)(iVar2 + 8) \u003d iVar5;\n            DAT_20070474 \u003d puVar14;\n            DAT_20070478 \u003d puVar14;\n            puVar14[3] \u003d \u0026DAT_2007046c;\n            puVar14[2] \u003d \u0026DAT_2007046c;\n            puVar14[1] \u003d uVar7 | 1;\n            *(uint *)((int)puVar14 + uVar7) \u003d uVar7;\n            __malloc_unlock(param_1);\n            return puVar9 + 2;\n          }\n          if (-1 \u003c (int)uVar7) {\n            iVar2 \u003d puVar9[2];\n            iVar5 \u003d puVar9[3];\n            *(uint *)((int)puVar9 + uVar6 + 4) \u003d *(uint *)((int)puVar9 + uVar6 + 4) | 1;\n            *(int *)(iVar2 + 0xc) \u003d iVar5;\n            *(int *)(iVar5 + 8) \u003d iVar2;\n            __malloc_unlock(param_1);\n            return puVar9 + 2;\n          }\n        }\n        uVar3 \u003d uVar3 + 1;\n        puVar14 \u003d puVar14 + 2;\n      } while ((uVar3 \u0026 3) !\u003d 0);\n      do {\n        uVar6 \u003d uVar8 \u0026 3;\n        puVar14 \u003d puVar15 + -2;\n        uVar8 \u003d uVar8 - 1;\n        if (uVar6 \u003d\u003d 0) {\n          DAT_20070468 \u003d DAT_20070468 \u0026 ~uVar4;\n          break;\n        }\n        puVar15 \u003d (undefined4 *)*puVar15;\n      } while (puVar15 \u003d\u003d puVar14);\n      uVar4 \u003d uVar4 * 2;\n      if ((DAT_20070468 \u003c\u003d uVar4 \u0026\u0026 uVar4 - DAT_20070468 !\u003d 0) || (uVar8 \u003d uVar3, uVar4 \u003d\u003d 0))\n      break;\n      for (; (DAT_20070468 \u0026 uVar4) \u003d\u003d 0; uVar4 \u003d uVar4 \u003c\u003c 1) {\n        uVar8 \u003d uVar8 + 4;\n      }\n    } while( true );\n  }\n  uVar8 \u003d *(uint *)(DAT_2007046c + 4) \u0026 0xfffffffc;\n  if ((uVar13 \u003c\u003d uVar8) \u0026\u0026 (uVar3 \u003d uVar8 - uVar13, puVar11 \u003d DAT_2007046c, 0xf \u003c (int)uVar3))\n  goto LAB_0008211e;\n  puVar16 \u003d DAT_2007046c + uVar8;\n  if (__malloc_sbrk_base \u003d\u003d (undefined1 *)0xffffffff) {\n    uVar3 \u003d uVar13 + __malloc_top_pad + 0x10;\n  }\n  else {\n    uVar3 \u003d uVar13 + __malloc_top_pad + 0x100f \u0026 0xfffff000;\n  }\n  puVar11 \u003d (undefined1 *)_sbrk_r(param_1,uVar3);\n  if ((puVar11 \u003d\u003d (undefined1 *)0xffffffff) || ((puVar11 \u003c puVar16 \u0026\u0026 (puVar12 !\u003d \u0026__malloc_av_))))\n  {\n    uVar8 \u003d *(uint *)(DAT_2007046c + 4) \u0026 0xfffffffc;\n    puVar11 \u003d DAT_2007046c;\n  }\n  else {\n    puVar10 \u003d __malloc_current_mallinfo + uVar3;\n    __malloc_current_mallinfo \u003d puVar10;\n    if ((puVar16 \u003d\u003d puVar11) \u0026\u0026 (((uint)puVar16 \u0026 0xfff) \u003d\u003d 0)) {\n      *(uint *)(DAT_2007046c + 4) \u003d uVar3 + uVar8 | 1;\n    }\n    else {\n      puVar1 \u003d puVar11;\n      if (__malloc_sbrk_base !\u003d (undefined1 *)0xffffffff) {\n        puVar1 \u003d __malloc_sbrk_base;\n        __malloc_current_mallinfo \u003d puVar10 + ((int)puVar11 - (int)puVar16);\n      }\n      __malloc_sbrk_base \u003d puVar1;\n      uVar4 \u003d (uint)puVar11 \u0026 7;\n      if (uVar4 \u003d\u003d 0) {\n        iVar2 \u003d 0x1000;\n      }\n      else {\n        puVar11 \u003d puVar11 + (8 - uVar4);\n        iVar2 \u003d 0x1008 - uVar4;\n      }\n      iVar2 \u003d iVar2 - ((uint)(puVar11 + uVar3) \u0026 0xfff);\n      iVar5 \u003d _sbrk_r(param_1,iVar2);\n      if (iVar5 \u003d\u003d -1) {\n        uVar3 \u003d 1;\n        iVar2 \u003d 0;\n      }\n      else {\n        uVar3 \u003d (iVar5 - (int)puVar11) + iVar2 | 1;\n      }\n      puVar10 \u003d __malloc_current_mallinfo + iVar2;\n      DAT_2007046c \u003d puVar11;\n      __malloc_current_mallinfo \u003d puVar10;\n      *(uint *)(puVar11 + 4) \u003d uVar3;\n      if (puVar12 !\u003d \u0026__malloc_av_) {\n        if (uVar8 \u003c 0x10) {\n          *(undefined4 *)(puVar11 + 4) \u003d 1;\n          uVar8 \u003d 0;\n          goto LAB_00082108;\n        }\n        uVar8 \u003d uVar8 - 0xc \u0026 0xfffffff8;\n        *(uint *)(puVar12 + 4) \u003d uVar8 | *(uint *)(puVar12 + 4) \u0026 1;\n        *(undefined4 *)(puVar12 + uVar8 + 4) \u003d 5;\n        *(undefined4 *)(puVar12 + uVar8 + 8) \u003d 5;\n        if (0xf \u003c uVar8) {\n          _free_r(param_1,puVar12 + 8);\n          puVar10 \u003d __malloc_current_mallinfo;\n        }\n      }\n    }\n    if (__malloc_max_sbrked_mem \u003c puVar10) {\n      __malloc_max_sbrked_mem \u003d puVar10;\n    }\n    if (__malloc_max_total_mem \u003c puVar10) {\n      __malloc_max_total_mem \u003d puVar10;\n    }\n    uVar8 \u003d *(uint *)(DAT_2007046c + 4) \u0026 0xfffffffc;\n    puVar11 \u003d DAT_2007046c;\n  }\nLAB_00082108:\n  uVar3 \u003d uVar8 - uVar13;\n  if ((uVar8 \u003c uVar13) || ((int)uVar3 \u003c 0x10)) {\n    __malloc_unlock(param_1);\n    return (int *)0x0;\n  }\nLAB_0008211e:\n  DAT_2007046c \u003d puVar11 + uVar13;\n  *(uint *)(puVar11 + 4) \u003d uVar13 | 1;\n  *(uint *)(DAT_2007046c + 4) \u003d uVar3 | 1;\n  __malloc_unlock(param_1);\n  return (int *)(puVar11 + 8);\n}\n\n",
      "renaming": {},
      "calling": [
        "__smakebuf_r",
        "_realloc_r",
        "__sfvwrite_r",
        "malloc"
      ],
      "called": [
        "__malloc_lock",
        "__malloc_unlock",
        "_sbrk_r",
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memcpy": {
      "entrypoint": "0x0008234c",
      "current_name": "memcpy",
      "code": "\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  undefined *puVar1;\n  undefined4 *puVar2;\n  undefined4 *puVar3;\n  undefined *puVar4;\n  undefined4 *puVar5;\n  undefined *puVar6;\n  uint uVar7;\n  uint uVar8;\n  bool bVar9;\n  \n  puVar3 \u003d (undefined4 *)__dest;\n  if ((((uint)__src | (uint)__dest) \u0026 3) !\u003d 0) {\n    if (__n \u003c 8) {\n      uVar8 \u003d __n - 4;\n      puVar1 \u003d (undefined *)__dest;\n      if (3 \u003c __n) {\n        do {\n          puVar6 \u003d (undefined *)__src;\n          puVar4 \u003d puVar1;\n          bVar9 \u003d uVar8 !\u003d 0;\n          uVar8 \u003d uVar8 - 1;\n          *puVar4 \u003d *puVar6;\n          puVar1 \u003d puVar4 + 1;\n          __src \u003d puVar6 + 1;\n        } while (bVar9);\n        puVar4[1] \u003d puVar6[1];\n        puVar4[2] \u003d puVar6[2];\n        puVar4[3] \u003d puVar6[3];\n        return __dest;\n      }\n      goto LAB_000823d0;\n    }\n    if ((((uint)__src \u0026 3) !\u003d 0) \u0026\u0026 (((uint)__dest \u0026 3) !\u003d 0)) {\n      uVar8 \u003d 4 - ((uint)__dest \u0026 3);\n      __n \u003d __n - uVar8;\n      puVar2 \u003d (undefined4 *)__dest;\n      puVar5 \u003d (undefined4 *)__src;\n                    /* WARNING: Load size is inaccurate */\n      if (((uint)__dest \u0026 1) !\u003d 0) {\n        puVar5 \u003d (undefined4 *)((int)__src + 1);\n        puVar2 \u003d (undefined4 *)((int)__dest + 1);\n        *(undefined *)__dest \u003d *__src;\n      }\n      puVar3 \u003d puVar2;\n      __src \u003d puVar5;\n      if ((uVar8 \u0026 2) !\u003d 0) {\n        __src \u003d (void *)((int)puVar5 + 2);\n        puVar3 \u003d (undefined4 *)((int)puVar2 + 2);\n        *(undefined2 *)puVar2 \u003d *(undefined2 *)puVar5;\n      }\n    }\n  }\n  while (0x3f \u003c __n) {\n                    /* WARNING: Load size is inaccurate */\n    *puVar3 \u003d *__src;\n    puVar3[1] \u003d *(undefined4 *)((int)__src + 4);\n    puVar3[2] \u003d *(undefined4 *)((int)__src + 8);\n    puVar3[3] \u003d *(undefined4 *)((int)__src + 0xc);\n    puVar3[4] \u003d *(undefined4 *)((int)__src + 0x10);\n    puVar3[5] \u003d *(undefined4 *)((int)__src + 0x14);\n    puVar3[6] \u003d *(undefined4 *)((int)__src + 0x18);\n    puVar3[7] \u003d *(undefined4 *)((int)__src + 0x1c);\n    puVar3[8] \u003d *(undefined4 *)((int)__src + 0x20);\n    puVar3[9] \u003d *(undefined4 *)((int)__src + 0x24);\n    puVar3[10] \u003d *(undefined4 *)((int)__src + 0x28);\n    puVar3[0xb] \u003d *(undefined4 *)((int)__src + 0x2c);\n    puVar3[0xc] \u003d *(undefined4 *)((int)__src + 0x30);\n    puVar3[0xd] \u003d *(undefined4 *)((int)__src + 0x34);\n    puVar3[0xe] \u003d *(undefined4 *)((int)__src + 0x38);\n    puVar3[0xf] \u003d *(undefined4 *)((int)__src + 0x3c);\n    puVar3 \u003d puVar3 + 0x10;\n    __src \u003d (undefined4 *)((int)__src + 0x40);\n    __n \u003d __n - 0x40;\n  }\n  uVar7 \u003d __n - 0x10;\n  if (0xffffffcf \u003c __n - 0x40) {\n    do {\n                    /* WARNING: Load size is inaccurate */\n      *puVar3 \u003d *__src;\n      puVar3[1] \u003d *(undefined4 *)((int)__src + 4);\n      puVar3[2] \u003d *(undefined4 *)((int)__src + 8);\n      puVar3[3] \u003d *(undefined4 *)((int)__src + 0xc);\n      puVar3 \u003d puVar3 + 4;\n      __src \u003d (void *)((int)__src + 0x10);\n      bVar9 \u003d 0xf \u003c uVar7;\n      uVar7 \u003d uVar7 - 0x10;\n    } while (bVar9);\n  }\n  uVar8 \u003d uVar7 + 0xc;\n  puVar5 \u003d puVar3;\n  puVar2 \u003d (undefined4 *)__src;\n  if (0xfffffff3 \u003c uVar7) {\n    do {\n      __src \u003d puVar2 + 1;\n      *puVar5 \u003d *puVar2;\n      bVar9 \u003d 3 \u003c uVar8;\n      uVar8 \u003d uVar8 - 4;\n      puVar3 \u003d puVar5 + 1;\n      puVar5 \u003d puVar5 + 1;\n      puVar2 \u003d (undefined4 *)__src;\n    } while (bVar9);\n  }\nLAB_000823d0:\n  if (uVar8 + 4 !\u003d 0) {\n    puVar2 \u003d puVar3;\n    puVar5 \u003d (undefined4 *)__src;\n                    /* WARNING: Load size is inaccurate */\n    if ((uVar8 \u0026 1) !\u003d 0) {\n      puVar5 \u003d (undefined4 *)((int)__src + 1);\n      puVar2 \u003d (undefined4 *)((int)puVar3 + 1);\n      *(undefined *)puVar3 \u003d *__src;\n    }\n    if ((uVar8 + 4 \u0026 2) !\u003d 0) {\n      *(undefined2 *)puVar2 \u003d *(undefined2 *)puVar5;\n    }\n  }\n  return __dest;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfvwrite_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memmove": {
      "entrypoint": "0x00082438",
      "current_name": "memmove",
      "code": "\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined4 *puVar3;\n  undefined4 *puVar4;\n  undefined *puVar5;\n  uint uVar6;\n  undefined *puVar7;\n  uint uVar8;\n  \n  if ((__src \u003c __dest) \u0026\u0026 (puVar5 \u003d (undefined *)((int)__src + __n), __dest \u003c puVar5)) {\n    puVar7 \u003d (undefined *)((int)__dest + __n);\n    iVar1 \u003d __n - 1;\n    if (__n !\u003d 0) {\n      do {\n        puVar5 \u003d puVar5 + -1;\n        iVar1 \u003d iVar1 + -1;\n        puVar7 \u003d puVar7 + -1;\n        *puVar7 \u003d *puVar5;\n      } while (iVar1 !\u003d -1);\n    }\n    return __dest;\n  }\n  puVar2 \u003d (undefined4 *)__dest;\n  if (__n \u003c 0x10) {\n    if (__n \u003d\u003d 0) {\n      return __dest;\n    }\n  }\n  else if ((((uint)__dest | (uint)__src) \u0026 3) \u003d\u003d 0) {\n    puVar3 \u003d (undefined4 *)__src;\n    do {\n      puVar4 \u003d puVar2 + 4;\n      *puVar2 \u003d *puVar3;\n      puVar2[1] \u003d puVar3[1];\n      puVar2[2] \u003d puVar3[2];\n      puVar2[3] \u003d puVar3[3];\n      puVar2 \u003d puVar4;\n      puVar3 \u003d puVar3 + 4;\n    } while (puVar4 !\u003d (undefined4 *)((int)__dest + (__n - 0x10 \u0026 0xfffffff0) + 0x10));\n    uVar8 \u003d __n \u0026 0xf;\n    iVar1 \u003d ((__n - 0x10 \u003e\u003e 4) + 1) * 0x10;\n    __src \u003d (void *)((int)__src + iVar1);\n    puVar2 \u003d (undefined4 *)(iVar1 + (int)__dest);\n    uVar6 \u003d uVar8;\n    puVar3 \u003d puVar2;\n    puVar4 \u003d (undefined4 *)__src;\n    if (3 \u003c uVar8) {\n      do {\n        uVar6 \u003d uVar6 - 4;\n        *puVar3 \u003d *puVar4;\n        puVar3 \u003d puVar3 + 1;\n        puVar4 \u003d puVar4 + 1;\n      } while (3 \u003c uVar6);\n      iVar1 \u003d (uVar8 - 4 \u0026 0xfffffffc) + 4;\n      puVar2 \u003d (undefined4 *)((int)puVar2 + iVar1);\n      __src \u003d (void *)((int)__src + iVar1);\n      uVar8 \u003d __n \u0026 3;\n    }\n    __n \u003d uVar8;\n    if (__n \u003d\u003d 0) {\n      return __dest;\n    }\n  }\n  puVar3 \u003d puVar2;\n  do {\n                    /* WARNING: Load size is inaccurate */\n    puVar4 \u003d (undefined4 *)((int)puVar3 + 1);\n    *(undefined *)puVar3 \u003d *__src;\n    __src \u003d (undefined4 *)((int)__src + 1);\n    puVar3 \u003d puVar4;\n  } while (puVar4 !\u003d (undefined4 *)(__n + (int)puVar2));\n  return __dest;\n}\n\n",
      "renaming": {},
      "calling": [
        "_realloc_r",
        "__sfvwrite_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memset": {
      "entrypoint": "0x00082504",
      "current_name": "memset",
      "code": "\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  uint *puVar1;\n  uint *puVar2;\n  uint *puVar3;\n  uint uVar4;\n  uint uVar5;\n  bool bVar6;\n  \n  puVar2 \u003d (uint *)__s;\n  if (((uint)__s \u0026 3) !\u003d 0) {\n    bVar6 \u003d __n \u003d\u003d 0;\n    puVar1 \u003d (uint *)__s;\n    __n \u003d __n - 1;\n    if (bVar6) {\n      return __s;\n    }\n    while( true ) {\n      puVar2 \u003d (uint *)((int)puVar1 + 1);\n      *(char *)puVar1 \u003d (char)__c;\n      if (((uint)puVar2 \u0026 3) \u003d\u003d 0) break;\n      bVar6 \u003d __n \u003d\u003d 0;\n      puVar1 \u003d puVar2;\n      __n \u003d __n - 1;\n      if (bVar6) {\n        return __s;\n      }\n    }\n  }\n  if (3 \u003c __n) {\n    uVar4 \u003d __c \u0026 0xffU | (__c \u0026 0xffU) \u003c\u003c 8;\n    uVar4 \u003d uVar4 | uVar4 \u003c\u003c 0x10;\n    uVar5 \u003d __n;\n    puVar1 \u003d puVar2;\n    if (0xf \u003c __n) {\n      uVar5 \u003d __n - 0x10;\n      do {\n        *puVar1 \u003d uVar4;\n        puVar1[1] \u003d uVar4;\n        puVar1[2] \u003d uVar4;\n        puVar1[3] \u003d uVar4;\n        puVar1 \u003d puVar1 + 4;\n      } while (puVar1 !\u003d (uint *)((int)puVar2 + (uVar5 \u0026 0xfffffff0) + 0x10));\n      __n \u003d __n \u0026 0xf;\n      puVar2 \u003d puVar2 + ((uVar5 \u003e\u003e 4) + 1) * 4;\n      uVar5 \u003d __n;\n      puVar1 \u003d puVar2;\n      if (__n \u003c 4) goto LAB_00082580;\n    }\n    do {\n      __n \u003d __n - 4;\n      *puVar2 \u003d uVar4;\n      puVar2 \u003d puVar2 + 1;\n    } while (3 \u003c __n);\n    puVar2 \u003d (uint *)((int)puVar1 + (uVar5 - 4 \u0026 0xfffffffc) + 4);\n    __n \u003d uVar5 \u0026 3;\n  }\nLAB_00082580:\n  if (__n !\u003d 0) {\n    puVar1 \u003d puVar2;\n    do {\n      puVar3 \u003d (uint *)((int)puVar1 + 1);\n      *(char *)puVar1 \u003d (char)__c;\n      puVar1 \u003d puVar3;\n    } while (puVar3 !\u003d (uint *)(__n + (int)puVar2));\n  }\n  return __s;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sinit",
        "RingBuffer"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__malloc_lock": {
      "entrypoint": "0x00082598",
      "current_name": "__malloc_lock",
      "code": "\nvoid __malloc_lock(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_malloc_r",
        "_realloc_r",
        "_free_r",
        "_malloc_trim_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__malloc_unlock": {
      "entrypoint": "0x0008259c",
      "current_name": "__malloc_unlock",
      "code": "\nvoid __malloc_unlock(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_malloc_r",
        "_realloc_r",
        "_free_r",
        "_malloc_trim_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "realloc": {
      "entrypoint": "0x000825a0",
      "current_name": "realloc",
      "code": "\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d (void *)_realloc_r(_impure_ptr,__ptr,__size);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "changeBuffer"
      ],
      "called": [
        "_realloc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_realloc_r": {
      "entrypoint": "0x000825b0",
      "current_name": "_realloc_r",
      "code": "\nint * _realloc_r(undefined4 *param_1,int *param_2,uint param_3)\n\n{\n  int iVar1;\n  int *piVar2;\n  uint uVar3;\n  size_t sVar4;\n  uint uVar5;\n  int iVar6;\n  int *piVar7;\n  uint uVar8;\n  uint uVar9;\n  int *piVar10;\n  \n  if (param_2 \u003d\u003d (int *)0x0) {\n    piVar2 \u003d (int *)_malloc_r(param_1,param_3);\n    return piVar2;\n  }\n  __malloc_lock();\n  uVar5 \u003d param_2[-1];\n  uVar8 \u003d uVar5 \u0026 0xfffffffc;\n  piVar2 \u003d param_2 + -2;\n  if (param_3 + 0xb \u003c 0x17) {\n    uVar9 \u003d 0x10;\n  }\n  else {\n    uVar9 \u003d param_3 + 0xb \u0026 0xfffffff8;\n    if ((int)uVar9 \u003c 0) goto LAB_0008267c;\n  }\n  if (uVar9 \u003c param_3) {\nLAB_0008267c:\n    *param_1 \u003d 0xc;\n    return (int *)0x0;\n  }\n  if ((int)uVar8 \u003c (int)uVar9) {\n    iVar1 \u003d (int)piVar2 + uVar8;\n    if (DAT_2007046c \u003d\u003d iVar1) {\n      uVar3 \u003d *(uint *)(DAT_2007046c + 4) \u0026 0xfffffffc;\n      iVar1 \u003d DAT_2007046c;\n      if ((int)(uVar9 + 0x10) \u003c\u003d (int)(uVar3 + uVar8)) {\n        DAT_2007046c \u003d (int)piVar2 + uVar9;\n        *(uint *)(DAT_2007046c + 4) \u003d (uVar3 + uVar8) - uVar9 | 1;\n        param_2[-1] \u003d uVar9 | param_2[-1] \u0026 1U;\n        __malloc_unlock(param_1);\n        return param_2;\n      }\n    }\n    else if ((*(uint *)((*(uint *)(iVar1 + 4) \u0026 0xfffffffe) + iVar1 + 4) \u0026 1) \u003d\u003d 0) {\n      uVar3 \u003d *(uint *)(iVar1 + 4) \u0026 0xfffffffc;\n      if ((int)uVar9 \u003c\u003d (int)(uVar3 + uVar8)) {\n        iVar6 \u003d *(int *)(iVar1 + 0xc);\n        iVar1 \u003d *(int *)(iVar1 + 8);\n        *(int *)(iVar1 + 0xc) \u003d iVar6;\n        *(int *)(iVar6 + 8) \u003d iVar1;\n        uVar8 \u003d uVar3 + uVar8;\n        goto LAB_0008268c;\n      }\n    }\n    else {\n      uVar3 \u003d 0;\n      iVar1 \u003d 0;\n    }\n    if (-1 \u003c (int)(uVar5 \u003c\u003c 0x1f)) {\n      piVar10 \u003d (int *)((int)piVar2 - param_2[-2]);\n      uVar5 \u003d (piVar10[1] \u0026 0xfffffffcU) + uVar8;\n      if (iVar1 !\u003d 0) {\n        if (iVar1 \u003d\u003d DAT_2007046c) {\n          if ((int)(uVar9 + 0x10) \u003c\u003d (int)(uVar3 + uVar5)) {\n            piVar2 \u003d piVar10 + 2;\n            iVar1 \u003d *piVar2;\n            iVar6 \u003d piVar10[3];\n            sVar4 \u003d uVar8 - 4;\n            *(int *)(iVar1 + 0xc) \u003d iVar6;\n            *(int *)(iVar6 + 8) \u003d iVar1;\n            if (sVar4 \u003c 0x25) {\n              piVar7 \u003d piVar2;\n              if (0x13 \u003c sVar4) {\n                piVar10[2] \u003d *param_2;\n                piVar10[3] \u003d param_2[1];\n                if (sVar4 \u003c 0x1c) {\n                  param_2 \u003d param_2 + 2;\n                  piVar7 \u003d piVar10 + 4;\n                }\n                else {\n                  piVar10[4] \u003d param_2[2];\n                  piVar10[5] \u003d param_2[3];\n                  if (sVar4 \u003d\u003d 0x24) {\n                    piVar10[6] \u003d param_2[4];\n                    piVar7 \u003d param_2 + 5;\n                    param_2 \u003d param_2 + 6;\n                    piVar10[7] \u003d *piVar7;\n                    piVar7 \u003d piVar10 + 8;\n                  }\n                  else {\n                    param_2 \u003d param_2 + 4;\n                    piVar7 \u003d piVar10 + 6;\n                  }\n                }\n              }\n              *piVar7 \u003d *param_2;\n              piVar7[1] \u003d param_2[1];\n              piVar7[2] \u003d param_2[2];\n            }\n            else {\n              memmove(piVar2,param_2,sVar4);\n            }\n            DAT_2007046c \u003d (int)piVar10 + uVar9;\n            *(uint *)(DAT_2007046c + 4) \u003d (uVar3 + uVar5) - uVar9 | 1;\n            piVar10[1] \u003d uVar9 | piVar10[1] \u0026 1U;\n            __malloc_unlock(param_1);\n            return piVar2;\n          }\n        }\n        else {\n          uVar3 \u003d uVar3 + uVar5;\n          if ((int)uVar9 \u003c\u003d (int)uVar3) {\n            iVar6 \u003d *(int *)(iVar1 + 0xc);\n            iVar1 \u003d *(int *)(iVar1 + 8);\n            *(int *)(iVar1 + 0xc) \u003d iVar6;\n            *(int *)(iVar6 + 8) \u003d iVar1;\n            piVar7 \u003d piVar10 + 2;\n            iVar1 \u003d *piVar7;\n            iVar6 \u003d piVar10[3];\n            sVar4 \u003d uVar8 - 4;\n            *(int *)(iVar1 + 0xc) \u003d iVar6;\n            *(int *)(iVar6 + 8) \u003d iVar1;\n            uVar8 \u003d uVar3;\n            if (sVar4 \u003c 0x25) {\n              piVar2 \u003d piVar7;\n              if (0x13 \u003c sVar4) {\n                piVar10[2] \u003d *param_2;\n                piVar10[3] \u003d param_2[1];\n                if (sVar4 \u003c 0x1c) {\n                  param_2 \u003d param_2 + 2;\n                  piVar2 \u003d piVar10 + 4;\n                }\n                else {\n                  piVar10[4] \u003d param_2[2];\n                  piVar10[5] \u003d param_2[3];\n                  if (sVar4 \u003d\u003d 0x24) {\n                    piVar10[6] \u003d param_2[4];\n                    piVar2 \u003d param_2 + 5;\n                    param_2 \u003d param_2 + 6;\n                    piVar10[7] \u003d *piVar2;\n                    piVar2 \u003d piVar10 + 8;\n                  }\n                  else {\n                    param_2 \u003d param_2 + 4;\n                    piVar2 \u003d piVar10 + 6;\n                  }\n                }\n              }\n              *piVar2 \u003d *param_2;\n              piVar2[1] \u003d param_2[1];\n              piVar2[2] \u003d param_2[2];\n              uVar5 \u003d piVar10[1];\n              piVar2 \u003d piVar10;\n              param_2 \u003d piVar7;\n            }\n            else {\n              memmove(piVar7,param_2,sVar4);\n              uVar5 \u003d piVar10[1];\n              piVar2 \u003d piVar10;\n              param_2 \u003d piVar7;\n            }\n            goto LAB_0008268c;\n          }\n        }\n      }\n      if ((int)uVar9 \u003c\u003d (int)uVar5) {\n        piVar7 \u003d piVar10 + 2;\n        iVar1 \u003d *piVar7;\n        iVar6 \u003d piVar10[3];\n        sVar4 \u003d uVar8 - 4;\n        *(int *)(iVar1 + 0xc) \u003d iVar6;\n        *(int *)(iVar6 + 8) \u003d iVar1;\n        uVar8 \u003d uVar5;\n        if (sVar4 \u003c 0x25) {\n          piVar2 \u003d piVar7;\n          if (0x13 \u003c sVar4) {\n            piVar10[2] \u003d *param_2;\n            piVar10[3] \u003d param_2[1];\n            if (sVar4 \u003c 0x1c) {\n              param_2 \u003d param_2 + 2;\n              piVar2 \u003d piVar10 + 4;\n            }\n            else {\n              piVar10[4] \u003d param_2[2];\n              piVar10[5] \u003d param_2[3];\n              if (sVar4 \u003d\u003d 0x24) {\n                piVar10[6] \u003d param_2[4];\n                piVar2 \u003d param_2 + 5;\n                param_2 \u003d param_2 + 6;\n                piVar10[7] \u003d *piVar2;\n                piVar2 \u003d piVar10 + 8;\n              }\n              else {\n                param_2 \u003d param_2 + 4;\n                piVar2 \u003d piVar10 + 6;\n              }\n            }\n          }\n          *piVar2 \u003d *param_2;\n          piVar2[1] \u003d param_2[1];\n          piVar2[2] \u003d param_2[2];\n          uVar5 \u003d piVar10[1];\n          piVar2 \u003d piVar10;\n          param_2 \u003d piVar7;\n        }\n        else {\n          memmove(piVar7,param_2,sVar4);\n          uVar5 \u003d piVar10[1];\n          piVar2 \u003d piVar10;\n          param_2 \u003d piVar7;\n        }\n        goto LAB_0008268c;\n      }\n    }\n    piVar10 \u003d (int *)_malloc_r(param_1,param_3);\n    if (piVar10 \u003d\u003d (int *)0x0) goto LAB_000826a4;\n    uVar5 \u003d param_2[-1];\n    if (piVar10 + -2 !\u003d (int *)((uVar5 \u0026 0xfffffffe) + (int)piVar2)) {\n      sVar4 \u003d uVar8 - 4;\n      if (sVar4 \u003c 0x25) {\n        piVar2 \u003d param_2;\n        piVar7 \u003d piVar10;\n        if (0x13 \u003c sVar4) {\n          *piVar10 \u003d *param_2;\n          piVar10[1] \u003d param_2[1];\n          if (sVar4 \u003c 0x1c) {\n            piVar2 \u003d param_2 + 2;\n            piVar7 \u003d piVar10 + 2;\n          }\n          else {\n            piVar10[2] \u003d param_2[2];\n            piVar10[3] \u003d param_2[3];\n            if (sVar4 \u003d\u003d 0x24) {\n              piVar10[4] \u003d param_2[4];\n              piVar10[5] \u003d param_2[5];\n              piVar2 \u003d param_2 + 6;\n              piVar7 \u003d piVar10 + 6;\n            }\n            else {\n              piVar2 \u003d param_2 + 4;\n              piVar7 \u003d piVar10 + 4;\n            }\n          }\n        }\n        *piVar7 \u003d *piVar2;\n        piVar7[1] \u003d piVar2[1];\n        piVar7[2] \u003d piVar2[2];\n      }\n      else {\n        memmove(piVar10,param_2,sVar4);\n      }\n      _free_r(param_1,param_2);\n      goto LAB_000826a4;\n    }\n    uVar8 \u003d uVar8 + (piVar10[-1] \u0026 0xfffffffcU);\n  }\nLAB_0008268c:\n  uVar3 \u003d uVar8 - uVar9;\n  piVar10 \u003d param_2;\n  if (uVar3 \u003c 0x10) {\n    piVar2[1] \u003d uVar5 \u0026 1 | uVar8;\n    *(uint *)((int)piVar2 + uVar8 + 4) \u003d *(uint *)((int)piVar2 + uVar8 + 4) | 1;\n  }\n  else {\n    piVar2[1] \u003d uVar5 \u0026 1 | uVar9;\n    *(uint *)((int)piVar2 + uVar9 + 4) \u003d uVar3 | 1;\n    *(uint *)((int)piVar2 + uVar3 + uVar9 + 4) \u003d *(uint *)((int)piVar2 + uVar3 + uVar9 + 4) | 1;\n    _free_r(param_1,(int)piVar2 + uVar9 + 8);\n  }\nLAB_000826a4:\n  __malloc_unlock(param_1);\n  return piVar10;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfvwrite_r",
        "realloc"
      ],
      "called": [
        "__malloc_lock",
        "_malloc_r",
        "memmove",
        "__malloc_unlock",
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_sbrk_r": {
      "entrypoint": "0x00082970",
      "current_name": "_sbrk_r",
      "code": "\nvoid _sbrk_r(int *param_1,intptr_t param_2)\n\n{\n  void *pvVar1;\n  \n  errno \u003d 0;\n  pvVar1 \u003d _sbrk(param_2);\n  if ((pvVar1 \u003d\u003d (void *)0xffffffff) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_malloc_r",
        "_malloc_trim_r"
      ],
      "called": [
        "_sbrk"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strcpy": {
      "entrypoint": "0x00082994",
      "current_name": "strcpy",
      "code": "\nchar * strcpy(char *__dest,char *__src)\n\n{\n  char cVar1;\n  ushort uVar2;\n  uint *puVar3;\n  uint *puVar4;\n  uint uVar5;\n  uint uVar6;\n  uint *puVar7;\n  uint *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  \n  pcVar9 \u003d __dest;\n  if ((((uint)__dest ^ (uint)__src) \u0026 3) !\u003d 0) {\n    do {\n      cVar1 \u003d *__src;\n      *pcVar9 \u003d cVar1;\n      __src \u003d __src + 1;\n      pcVar9 \u003d pcVar9 + 1;\n    } while (cVar1 !\u003d \u0027\\0\u0027);\n    return __dest;\n  }\n  puVar8 \u003d (uint *)__dest;\n  if (((uint)__src \u0026 3) !\u003d 0) {\n    puVar4 \u003d (uint *)__src;\n    if (((uint)__src \u0026 1) !\u003d 0) {\n      puVar4 \u003d (uint *)(__src + 1);\n      cVar1 \u003d *__src;\n      puVar8 \u003d (uint *)(__dest + 1);\n      *__dest \u003d cVar1;\n      if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n        return __dest;\n      }\n    }\n    __src \u003d (char *)puVar4;\n    if (((uint)puVar4 \u0026 2) !\u003d 0) {\n      __src \u003d (char *)((int)puVar4 + 2);\n      uVar2 \u003d *(ushort *)puVar4;\n      bVar10 \u003d (uVar2 \u0026 0xff) \u003d\u003d 0;\n      if (bVar10) {\n        *(char *)puVar8 \u003d (char)uVar2;\n      }\n      else {\n        *(ushort *)puVar8 \u003d uVar2;\n        bVar10 \u003d (uVar2 \u0026 0xff00) \u003d\u003d 0;\n        puVar8 \u003d (uint *)((int)puVar8 + 2);\n      }\n      if (bVar10) {\n        return __dest;\n      }\n    }\n  }\n  uVar5 \u003d *(uint *)__src;\n  puVar4 \u003d (uint *)((int)__src + 4);\n  puVar7 \u003d puVar8;\n  if (((uint)__src \u0026 4) !\u003d 0) {\n    if ((uVar5 + 0xfefefeff \u0026 ~uVar5 \u0026 0x80808080) !\u003d 0) goto LAB_000829f8;\n    puVar7 \u003d puVar8 + 1;\n    *puVar8 \u003d uVar5;\n    puVar4 \u003d (uint *)((int)__src + 8);\n    uVar5 \u003d *(uint *)((int)__src + 4);\n  }\n  while( true ) {\n    puVar3 \u003d puVar4 + 1;\n    uVar6 \u003d *puVar4;\n    puVar8 \u003d puVar7;\n    if ((uVar5 + 0xfefefeff \u0026 ~uVar5 \u0026 0x80808080) !\u003d 0) break;\n    puVar8 \u003d puVar7 + 1;\n    *puVar7 \u003d uVar5;\n    uVar5 \u003d uVar6;\n    if ((uVar6 + 0xfefefeff \u0026 ~uVar6 \u0026 0x80808080) !\u003d 0) break;\n    puVar4 \u003d puVar4 + 2;\n    uVar5 \u003d *puVar3;\n    puVar7 \u003d puVar7 + 2;\n    *puVar8 \u003d uVar6;\n  }\nLAB_000829f8:\n  do {\n    *(char *)puVar8 \u003d (char)uVar5;\n    uVar6 \u003d uVar5 \u0026 0xff;\n    uVar5 \u003d uVar5 \u003e\u003e 8 | uVar5 \u003c\u003c 0x18;\n    puVar8 \u003d (uint *)((int)puVar8 + 1);\n  } while (uVar6 !\u003d 0);\n  return __dest;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strlen": {
      "entrypoint": "0x00082a50",
      "current_name": "strlen",
      "code": "\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  uint *puVar2;\n  uint uVar3;\n  bool bVar4;\n  \n  puVar2 \u003d (uint *)((uint)__s \u0026 0xfffffffc);\n  sVar1 \u003d -((uint)__s \u0026 3);\n  uVar3 \u003d *puVar2;\n  if (((uint)__s \u0026 3) !\u003d 0) {\n    uVar3 \u003d uVar3 | 0xffffffffU \u003e\u003e ((sVar1 + 4 \u0026 0x1f) \u003c\u003c 3);\n  }\n  while (puVar2 \u003d puVar2 + 1, (uVar3 + 0xfefefeff \u0026 ~uVar3 \u0026 0x80808080) \u003d\u003d 0) {\n    sVar1 \u003d sVar1 + 4;\n    uVar3 \u003d *puVar2;\n  }\n  bVar4 \u003d (uVar3 \u0026 0xff) \u003d\u003d 0;\n  if (!bVar4) {\n    sVar1 \u003d sVar1 + 1;\n    bVar4 \u003d (uVar3 \u0026 0xff00) \u003d\u003d 0;\n  }\n  if (!bVar4) {\n    sVar1 \u003d sVar1 + 1;\n    bVar4 \u003d (uVar3 \u0026 0xff0000) \u003d\u003d 0;\n  }\n  if (!bVar4) {\n    sVar1 \u003d sVar1 + 1;\n  }\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_vfiprintf_r",
        "String"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "kill": {
      "entrypoint": "0x00082ab0",
      "current_name": "kill",
      "code": "\nint kill(__pid_t __pid,int __sig)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d _kill_r(_impure_ptr,__pid,__sig);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_kill_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sprint_r.part.0": {
      "entrypoint": "0x00082ac0",
      "current_name": "__sprint_r.part.0",
      "code": "\nint __sprint_r_part_0(undefined4 param_1,int param_2,int **param_3)\n\n{\n  int *piVar1;\n  int iVar2;\n  int *piVar3;\n  uint uVar4;\n  undefined4 *puVar5;\n  uint uVar6;\n  uint uVar7;\n  \n  if (-1 \u003c *(int *)(param_2 + 100) \u003c\u003c 0x12) {\n    iVar2 \u003d __sfvwrite_r();\n    param_3[2] \u003d (int *)0x0;\n    param_3[1] \u003d (int *)0x0;\n    return iVar2;\n  }\n  piVar3 \u003d param_3[2];\n  piVar1 \u003d *param_3;\n  while (piVar3 !\u003d (int *)0x0) {\n    uVar6 \u003d piVar1[1];\n    uVar7 \u003d uVar6 \u003e\u003e 2;\n    if (uVar7 !\u003d 0) {\n      puVar5 \u003d (undefined4 *)(*piVar1 + -4);\n      uVar4 \u003d 0;\n      do {\n        puVar5 \u003d puVar5 + 1;\n        iVar2 \u003d _fputwc_r(param_1,*puVar5,param_2);\n        uVar4 \u003d uVar4 + 1;\n        if (iVar2 \u003d\u003d -1) goto LAB_00082b00;\n      } while (uVar7 !\u003d uVar4);\n      piVar3 \u003d param_3[2];\n    }\n    piVar3 \u003d (int *)((int)piVar3 - (uVar6 \u0026 0xfffffffc));\n    param_3[2] \u003d piVar3;\n    piVar1 \u003d piVar1 + 2;\n  }\n  iVar2 \u003d 0;\nLAB_00082b00:\n  param_3[2] \u003d (int *)0x0;\n  param_3[1] \u003d (int *)0x0;\n  return iVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "_vfiprintf_r"
      ],
      "called": [
        "__sfvwrite_r",
        "_fputwc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_vfiprintf_r": {
      "entrypoint": "0x00082b38",
      "current_name": "_vfiprintf_r",
      "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nint _vfiprintf_r(int param_1,int param_2,int *******param_3,int **param_4)\n\n{\n  bool bVar1;\n  bool bVar2;\n  bool bVar3;\n  char cVar4;\n  bool bVar5;\n  void *pvVar6;\n  int ********ppppppppiVar7;\n  int *piVar8;\n  int iVar9;\n  char cVar10;\n  int *******pppppppiVar11;\n  uint uVar12;\n  int **ppiVar13;\n  uint uVar14;\n  uint uVar15;\n  int iVar16;\n  int ********ppppppppiVar17;\n  int iVar18;\n  int *******pppppppiVar19;\n  int *piVar20;\n  int *******pppppppiVar21;\n  uint uVar22;\n  int *piVar23;\n  int *******pppppppiVar24;\n  undefined4 uVar25;\n  int ********__s;\n  bool bVar26;\n  longlong lVar27;\n  int *******local_dc;\n  int *******local_d4;\n  int **local_c8;\n  int local_c4;\n  char *local_c0;\n  char local_a1;\n  undefined local_a0;\n  undefined local_9f;\n  int ********local_9c;\n  int local_98;\n  int *******local_94;\n  undefined local_90;\n  char cStack_6a;\n  undefined local_69;\n  undefined local_68 [4];\n  int *******local_64 [16];\n  \n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x38) \u003d\u003d 0)) {\n    __sinit();\n  }\n  uVar14 \u003d (uint)*(ushort *)(param_2 + 0xc);\n  if (-1 \u003c (int)((uint)*(ushort *)(param_2 + 0xc) \u003c\u003c 0x12)) {\n    uVar14 \u003d uVar14 | 0x2000;\n    *(short *)(param_2 + 0xc) \u003d (short)uVar14;\n    *(uint *)(param_2 + 100) \u003d *(uint *)(param_2 + 100) \u0026 0xffffdfff;\n  }\n  if (((int)(uVar14 \u003c\u003c 0x1c) \u003c 0) \u0026\u0026 (*(int *)(param_2 + 0x10) !\u003d 0)) {\n    if ((uVar14 \u0026 0x1a) !\u003d 10) goto LAB_00082b8a;\n  }\n  else {\n    iVar9 \u003d __swsetup_r(param_1,param_2);\n    if (iVar9 !\u003d 0) {\n      return -1;\n    }\n    if ((*(ushort *)(param_2 + 0xc) \u0026 0x1a) !\u003d 10) goto LAB_00082b8a;\n  }\n  if (-1 \u003c *(short *)(param_2 + 0xe)) {\n    iVar9 \u003d __sbprintf(param_1,param_2,param_3,param_4);\n    return iVar9;\n  }\nLAB_00082b8a:\n  local_c0 \u003d (char *)0x0;\n  local_94 \u003d (int *******)0x0;\n  local_98 \u003d 0;\n  local_c4 \u003d 0;\n  ppppppppiVar7 \u003d (int ********)local_68;\n  local_c8 \u003d param_4;\n  local_9c \u003d (int ********)local_68;\nLAB_00082b9e:\n  pppppppiVar11 \u003d param_3;\n  if ((*(char *)param_3 !\u003d \u0027\\0\u0027) \u0026\u0026 (*(char *)param_3 !\u003d \u0027%\u0027)) {\n    do {\n      pppppppiVar11 \u003d (int *******)((int)pppppppiVar11 + 1);\n      if (*(char *)pppppppiVar11 \u003d\u003d \u0027\\0\u0027) break;\n    } while (*(char *)pppppppiVar11 !\u003d \u0027%\u0027);\n    pppppppiVar21 \u003d (int *******)((int)pppppppiVar11 - (int)param_3);\n    if (pppppppiVar21 !\u003d (int *******)0x0) {\n      local_98 \u003d local_98 + 1;\n      local_94 \u003d (int *******)((int)local_94 + (int)pppppppiVar21);\n      *ppppppppiVar7 \u003d param_3;\n      ppppppppiVar7[1] \u003d pppppppiVar21;\n      if (local_98 \u003c 8) {\n        ppppppppiVar7 \u003d ppppppppiVar7 + 2;\n      }\n      else {\n        if (local_94 \u003d\u003d (int *******)0x0) {\n          local_c4 \u003d local_c4 + (int)pppppppiVar21;\n          local_98 \u003d 0;\n          ppppppppiVar7 \u003d (int ********)local_68;\n          goto LAB_00082bee;\n        }\n        iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n        ppppppppiVar7 \u003d (int ********)local_68;\n        if (iVar9 !\u003d 0) goto LAB_000833de;\n      }\n      local_c4 \u003d local_c4 + (int)pppppppiVar21;\n    }\n  }\nLAB_00082bee:\n  if (*(char *)pppppppiVar11 !\u003d \u0027\\0\u0027) {\n    local_a1 \u003d \u0027\\0\u0027;\n    uVar15 \u003d (uint)*(byte *)((int)pppppppiVar11 + 1);\n    uVar14 \u003d 0;\n    bVar5 \u003d false;\n    bVar2 \u003d false;\n    bVar1 \u003d false;\n    bVar3 \u003d false;\n    bVar26 \u003d false;\n    pppppppiVar21 \u003d (int *******)0x0;\n    local_d4 \u003d (int *******)0xffffffff;\n    param_3 \u003d (int *******)((int)pppppppiVar11 + 1);\nLAB_00082c12:\n    param_3 \u003d (int *******)((int)param_3 + 1);\nLAB_00082c16:\n    switch(uVar15) {\n    case 0x20:\n      goto switchD_00082c20_caseD_20;\n    default:\n      if (uVar15 !\u003d 0) {\n        local_dc \u003d (int *******)0x1;\n        local_d4 \u003d (int *******)0x1;\n        __s \u003d (int ********)\u0026local_90;\n        local_90 \u003d (char)uVar15;\n        goto LAB_00083012;\n      }\n      goto LAB_000833d0;\n    case 0x23:\n      bVar3 \u003d true;\n      uVar15 \u003d (uint)*(byte *)param_3;\n      goto LAB_00082c12;\n    case 0x2a:\n      pppppppiVar21 \u003d (int *******)*local_c8;\n      local_c8 \u003d local_c8 + 1;\n      if ((int)pppppppiVar21 \u003c 0) {\n        pppppppiVar21 \u003d (int *******)-(int)pppppppiVar21;\n        goto switchD_00082c20_caseD_2d;\n      }\n      uVar15 \u003d (uint)*(byte *)param_3;\n      goto LAB_00082c12;\n    case 0x2b:\n      uVar15 \u003d (uint)*(byte *)param_3;\n      local_a1 \u003d \u0027+\u0027;\n      goto LAB_00082c12;\n    case 0x2d:\nswitchD_00082c20_caseD_2d:\n      uVar14 \u003d uVar14 | 4;\n      uVar15 \u003d (uint)*(byte *)param_3;\n      goto LAB_00082c12;\n    case 0x2e:\n      uVar15 \u003d (uint)*(byte *)param_3;\n      pppppppiVar11 \u003d (int *******)((int)param_3 + 1);\n      if (uVar15 \u003d\u003d 0x2a) {\n        uVar15 \u003d (uint)*(byte *)((int)param_3 + 1);\n        local_d4 \u003d (int *******)*local_c8;\n        local_c8 \u003d local_c8 + 1;\n        param_3 \u003d pppppppiVar11;\n        if ((int)local_d4 \u003c 0) {\n          local_d4 \u003d (int *******)0xffffffff;\n        }\n        goto LAB_00082c12;\n      }\n      uVar12 \u003d uVar15 - 0x30;\n      if (uVar12 \u003c 10) {\n        uVar22 \u003d 0;\n        do {\n          param_3 \u003d (int *******)((int)pppppppiVar11 + 1);\n          uVar15 \u003d (uint)*(byte *)pppppppiVar11;\n          uVar22 \u003d uVar12 + uVar22 * 10;\n          uVar12 \u003d uVar15 - 0x30;\n          pppppppiVar11 \u003d param_3;\n        } while (uVar12 \u003c 10);\n        local_d4 \u003d (int *******)(uVar22 | (int)uVar22 \u003e\u003e 0x1f);\n      }\n      else {\n        local_d4 \u003d (int *******)0x0;\n        param_3 \u003d pppppppiVar11;\n      }\n      goto LAB_00082c16;\n    case 0x30:\n      uVar14 \u003d uVar14 | 0x80;\n      uVar15 \u003d (uint)*(byte *)param_3;\n      goto LAB_00082c12;\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n      goto switchD_00082c20_caseD_31;\n    case 0x44:\n      bVar2 \u003d true;\n      if (bVar1 \u003d\u003d false) goto LAB_00083028;\nLAB_00082e98:\n      local_c8 \u003d (int **)((int)local_c8 + 7U \u0026 0xfffffff8);\n      piVar20 \u003d *local_c8;\n      piVar23 \u003d local_c8[1];\n      local_c8 \u003d local_c8 + 2;\n      goto LAB_00082eac;\n    case 0x4f:\n      bVar2 \u003d true;\n      if (bVar1 !\u003d false) goto LAB_00082d42;\nLAB_00082f2a:\n      iVar9 \u003d (uint)bVar2 \u003c\u003c 4;\n      iVar16 \u003d (uint)bVar1 \u003c\u003c 5;\n      if ((bVar2 \u003d\u003d 0) \u0026\u0026 (iVar16 \u003d (uint)bVar26 \u003c\u003c 6, bVar26 !\u003d 0)) {\n        piVar20 \u003d (int *)(uint)*(ushort *)local_c8;\n        local_c8 \u003d local_c8 + 1;\n        piVar23 \u003d (int *)0x0;\n      }\n      else {\n        iVar9 \u003d iVar16;\n        piVar20 \u003d *local_c8;\n        local_c8 \u003d local_c8 + 1;\n        piVar23 \u003d (int *)0x0;\n      }\n      break;\n    case 0x55:\n      bVar2 \u003d true;\n      if (bVar1 !\u003d false) goto LAB_00082e62;\nLAB_00082f7c:\n      if ((bVar2) || (bVar26 \u003d\u003d false)) {\n        iVar9 \u003d 1;\n        piVar20 \u003d *local_c8;\n        local_c8 \u003d local_c8 + 1;\n        piVar23 \u003d (int *)0x0;\n      }\n      else {\n        piVar23 \u003d (int *)0x0;\n        piVar20 \u003d (int *)(uint)*(ushort *)local_c8;\n        local_c8 \u003d local_c8 + 1;\n        iVar9 \u003d 1;\n      }\n      break;\n    case 0x58:\n      local_c0 \u003d \"0123456789ABCDEF\";\n      if (bVar1 \u003d\u003d false) goto LAB_00083196;\nLAB_00082fb6:\n      ppiVar13 \u003d (int **)((int)local_c8 + 7U \u0026 0xfffffff8);\n      local_c8 \u003d ppiVar13 + 2;\n      piVar20 \u003d *ppiVar13;\n      piVar23 \u003d ppiVar13[1];\n      goto LAB_00082fca;\n    case 99:\n      piVar20 \u003d *local_c8;\n      local_c8 \u003d local_c8 + 1;\n      local_dc \u003d (int *******)0x1;\n      local_90 \u003d SUB41(piVar20,0);\n      local_d4 \u003d (int *******)0x1;\n      __s \u003d (int ********)\u0026local_90;\n      goto LAB_00083012;\n    case 100:\n    case 0x69:\n      if (bVar1 !\u003d false) goto LAB_00082e98;\nLAB_00083028:\n      if ((bVar2 \u003d\u003d false) \u0026\u0026 (bVar26 !\u003d false)) {\n        piVar20 \u003d (int *)(int)*(short *)local_c8;\n        local_c8 \u003d local_c8 + 1;\n        piVar23 \u003d (int *)((int)piVar20 \u003e\u003e 0x1f);\n      }\n      else {\n        piVar20 \u003d *local_c8;\n        local_c8 \u003d local_c8 + 1;\n        piVar23 \u003d (int *)((int)piVar20 \u003e\u003e 0x1f);\n      }\nLAB_00082eac:\n      if ((int)piVar23 \u003c 0) {\n        bVar26 \u003d piVar20 !\u003d (int *)0x0;\n        piVar20 \u003d (int *)-(int)piVar20;\n        piVar23 \u003d (int *)(-(int)piVar23 - (uint)bVar26);\n        local_a1 \u003d \u0027-\u0027;\n        cVar4 \u003d \u0027-\u0027;\n        iVar9 \u003d 1;\n        goto LAB_00082d6a;\n      }\n      if (-1 \u003c (int)local_d4) {\n        uVar14 \u003d uVar14 \u0026 0xffffff7f;\n      }\n      bVar5 \u003d false;\n      uVar15 \u003d (uint)piVar20 | (uint)piVar23;\n      iVar9 \u003d 1;\n      cVar4 \u003d local_a1;\n      goto joined_r0x00082d78;\n    case 0x68:\n      bVar26 \u003d true;\n      uVar15 \u003d (uint)*(byte *)param_3;\n      goto LAB_00082c12;\n    case 0x6c:\n      uVar15 \u003d (uint)*(byte *)param_3;\n      if (uVar15 \u003d\u003d 0x6c) {\n        bVar1 \u003d true;\n        uVar15 \u003d (uint)*(byte *)((int)param_3 + 1);\n        param_3 \u003d (int *******)((int)param_3 + 1);\n      }\n      else {\n        bVar2 \u003d true;\n      }\n      goto LAB_00082c12;\n    case 0x6e:\n      if (bVar1 \u003d\u003d false) {\n        if (bVar2 \u003d\u003d false) {\n          if (bVar26) {\n            piVar20 \u003d *local_c8;\n            local_c8 \u003d local_c8 + 1;\n            *(short *)piVar20 \u003d (short)local_c4;\n          }\n          else {\n            piVar20 \u003d *local_c8;\n            local_c8 \u003d local_c8 + 1;\n            *piVar20 \u003d local_c4;\n          }\n        }\n        else {\n          piVar20 \u003d *local_c8;\n          local_c8 \u003d local_c8 + 1;\n          *piVar20 \u003d local_c4;\n        }\n      }\n      else {\n        piVar20 \u003d *local_c8;\n        local_c8 \u003d local_c8 + 1;\n        *piVar20 \u003d local_c4;\n        piVar20[1] \u003d local_c4 \u003e\u003e 0x1f;\n      }\n      goto LAB_00082b9e;\n    case 0x6f:\n      if (bVar1 \u003d\u003d false) goto LAB_00082f2a;\nLAB_00082d42:\n      ppiVar13 \u003d (int **)((int)local_c8 + 7U \u0026 0xfffffff8);\n      local_c8 \u003d ppiVar13 + 2;\n      piVar20 \u003d *ppiVar13;\n      piVar23 \u003d ppiVar13[1];\n      iVar9 \u003d 0;\n      break;\n    case 0x70:\n      piVar20 \u003d *local_c8;\n      local_c8 \u003d local_c8 + 1;\n      local_9f \u003d 0x78;\n      bVar5 \u003d true;\n      piVar23 \u003d (int *)0x0;\n      local_a0 \u003d 0x30;\n      local_c0 \u003d \"0123456789abcdef\";\n      iVar9 \u003d 2;\n      break;\n    case 0x71:\n      bVar1 \u003d true;\n      uVar15 \u003d (uint)*(byte *)param_3;\n      goto LAB_00082c12;\n    case 0x73:\n      __s \u003d (int ********)*local_c8;\n      local_a1 \u003d \u0027\\0\u0027;\n      local_c8 \u003d local_c8 + 1;\n      if (__s !\u003d (int ********)0x0) {\n        if ((int)local_d4 \u003c 0) {\n          local_d4 \u003d (int *******)strlen((char *)__s);\n          pppppppiVar11 \u003d (int *******)0x0;\n          cVar4 \u003d local_a1;\n        }\n        else {\n          pvVar6 \u003d memchr(__s,0,(size_t)local_d4);\n          cVar4 \u003d local_a1;\n          if (pvVar6 \u003d\u003d (void *)0x0) {\n            pppppppiVar11 \u003d (int *******)0x0;\n          }\n          else {\n            pppppppiVar19 \u003d (int *******)((int)pvVar6 - (int)__s);\n            if ((int)local_d4 \u003c\u003d (int)(int *******)((int)pvVar6 - (int)__s)) {\n              pppppppiVar19 \u003d local_d4;\n            }\n            pppppppiVar11 \u003d (int *******)0x0;\n            local_d4 \u003d pppppppiVar19;\n          }\n        }\n        goto LAB_00082da0;\n      }\n      if ((int *******)0x5 \u003c local_d4) {\n        local_d4 \u003d (int *******)0x6;\n      }\n      local_dc \u003d (int *******)((uint)local_d4 \u0026 ~((int)local_d4 \u003e\u003e 0x1f));\n      __s \u003d (int ********)\u0026UNK_00085840;\nLAB_00083012:\n      local_a1 \u003d \u0027\\0\u0027;\n      pppppppiVar11 \u003d (int *******)0x0;\n      goto LAB_00082dba;\n    case 0x75:\n      if (!bVar1) goto LAB_00082f7c;\nLAB_00082e62:\n      ppiVar13 \u003d (int **)((int)local_c8 + 7U \u0026 0xfffffff8);\n      local_c8 \u003d ppiVar13 + 2;\n      piVar20 \u003d *ppiVar13;\n      piVar23 \u003d ppiVar13[1];\n      iVar9 \u003d 1;\n      break;\n    case 0x78:\n      local_c0 \u003d \"0123456789abcdef\";\n      if (bVar1 !\u003d false) goto LAB_00082fb6;\nLAB_00083196:\n      if ((bVar2 \u003d\u003d false) \u0026\u0026 (bVar26 !\u003d false)) {\n        piVar23 \u003d (int *)0x0;\n        piVar20 \u003d (int *)(uint)*(ushort *)local_c8;\n        local_c8 \u003d local_c8 + 1;\n      }\n      else {\n        piVar20 \u003d *local_c8;\n        local_c8 \u003d local_c8 + 1;\n        piVar23 \u003d (int *)0x0;\n      }\nLAB_00082fca:\n      if ((bVar3) \u0026\u0026 (((uint)piVar20 | (uint)piVar23) !\u003d 0)) {\n        bVar5 \u003d true;\n        local_a0 \u003d 0x30;\n        iVar9 \u003d 2;\n        local_9f \u003d (char)uVar15;\n      }\n      else {\n        iVar9 \u003d 2;\n      }\n    }\n    local_a1 \u003d \u0027\\0\u0027;\n    cVar4 \u003d \u0027\\0\u0027;\nLAB_00082d6a:\n    if (-1 \u003c (int)local_d4) {\n      uVar14 \u003d uVar14 \u0026 0xffffff7f;\n    }\n    uVar15 \u003d (uint)piVar20 | (uint)piVar23;\njoined_r0x00082d78:\n    lVar27 \u003d CONCAT44(piVar23,piVar20);\n    pppppppiVar11 \u003d local_d4;\n    if ((uVar15 \u003d\u003d 0) \u0026\u0026 (local_d4 \u003d\u003d (int *******)0x0)) {\n      __s \u003d (int ********)local_68;\n      if ((iVar9 !\u003d 0) || (!bVar3)) goto LAB_00082da0;\n      __s \u003d (int ********)(\u0026cStack_6a + 1);\n      local_69 \u003d \u00270\u0027;\n      goto LAB_00082d9a;\n    }\n    if (iVar9 \u003d\u003d 1) {\n      if (piVar23 !\u003d (int *)0x0 || (int *)0x9 \u003c piVar20) {\n        ppppppppiVar17 \u003d (int ********)(\u0026cStack_6a + 1);\n        do {\n          __s \u003d ppppppppiVar17;\n          uVar25 \u003d (undefined4)((ulonglong)lVar27 \u003e\u003e 0x20);\n          cVar10 \u003d \u0027\\n\u0027;\n          __aeabi_uldivmod((int)lVar27,uVar25,10,0);\n          *(char *)__s \u003d cVar10 + \u00270\u0027;\n          lVar27 \u003d __aeabi_uldivmod((int)lVar27,uVar25,10,0);\n          ppppppppiVar17 \u003d (int ********)((int)__s + -1);\n        } while (lVar27 !\u003d 0);\n        local_d4 \u003d (int *******)((int)local_68 - (int)__s);\n        goto LAB_00082da0;\n      }\n      local_69 \u003d (char)piVar20 + \u00270\u0027;\n      __s \u003d (int ********)(\u0026cStack_6a + 1);\n      goto LAB_0008351e;\n    }\n    ppppppppiVar17 \u003d (int ********)(\u0026cStack_6a + 1);\n    if (iVar9 !\u003d 2) goto LAB_0008337e;\n    do {\n      __s \u003d ppppppppiVar17;\n      uVar15 \u003d (uint)piVar20 \u0026 0xf;\n      piVar20 \u003d (int *)((uint)piVar20 \u003e\u003e 4 | (int)piVar23 \u003c\u003c 0x1c);\n      piVar23 \u003d (int *)((uint)piVar23 \u003e\u003e 4);\n      *(char *)__s \u003d local_c0[uVar15];\n      ppppppppiVar17 \u003d (int ********)((int)__s + -1);\n    } while (((uint)piVar20 | (uint)piVar23) !\u003d 0);\n    local_d4 \u003d (int *******)((int)local_68 - (int)__s);\n    goto LAB_00082da0;\n  }\nLAB_000833d0:\n  if (local_94 !\u003d (int *******)0x0) {\n    __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n  }\nLAB_000833de:\n  if ((int)((uint)*(ushort *)(param_2 + 0xc) \u003c\u003c 0x19) \u003c 0) {\n    return -1;\n  }\n  return local_c4;\nLAB_0008337e:\n  do {\n    __s \u003d ppppppppiVar17;\n    piVar8 \u003d (int *)((uint)piVar20 \u003e\u003e 3 | (int)piVar23 \u003c\u003c 0x1d);\n    piVar23 \u003d (int *)((uint)piVar23 \u003e\u003e 3);\n    iVar9 \u003d ((uint)piVar20 \u0026 7) + 0x30;\n    *(char *)__s \u003d (char)iVar9;\n    ppppppppiVar17 \u003d (int ********)((int)__s + -1);\n    piVar20 \u003d piVar8;\n  } while (((uint)piVar8 | (uint)piVar23) !\u003d 0);\n  if (bVar3) {\n    if (iVar9 \u003d\u003d 0x30) {\nLAB_00082d9a:\n      local_d4 \u003d (int *******)((int)local_68 - (int)__s);\n    }\n    else {\n      *(undefined *)((int)__s + -1) \u003d 0x30;\n      __s \u003d ppppppppiVar17;\n      local_d4 \u003d (int *******)((int)local_68 - (int)ppppppppiVar17);\n    }\n  }\n  else {\nLAB_0008351e:\n    local_d4 \u003d (int *******)((int)local_68 - (int)__s);\n  }\nLAB_00082da0:\n  local_dc \u003d local_d4;\n  if ((int)local_d4 \u003c (int)pppppppiVar11) {\n    local_dc \u003d pppppppiVar11;\n  }\n  if (cVar4 !\u003d \u0027\\0\u0027) {\n    local_dc \u003d (int *******)((int)local_dc + 1);\n  }\nLAB_00082dba:\n  if (bVar5) {\n    local_dc \u003d (int *******)((int)local_dc + 2);\n  }\n  if ((uVar14 \u003d\u003d 0) \u0026\u0026\n     (pppppppiVar19 \u003d (int *******)((int)pppppppiVar21 - (int)local_dc), 0 \u003c (int)pppppppiVar19)) {\n    if ((int)pppppppiVar19 \u003c 0x11) {\n      local_98 \u003d local_98 + 1;\n    }\n    else {\n      do {\n        pppppppiVar24 \u003d pppppppiVar19;\n        iVar9 \u003d local_98 + 1;\n        local_94 \u003d local_94 + 4;\n        *ppppppppiVar7 \u003d (int *******)0x85808;\n        ppppppppiVar7[1] \u003d (int *******)0x10;\n        if (iVar9 \u003c 8) {\n          iVar16 \u003d local_98 + 2;\n          ppppppppiVar7 \u003d ppppppppiVar7 + 2;\n          local_98 \u003d iVar9;\n        }\n        else if (local_94 \u003d\u003d (int *******)0x0) {\n          iVar16 \u003d 1;\n          ppppppppiVar7 \u003d (int ********)local_68;\n          local_98 \u003d 0;\n        }\n        else {\n          local_98 \u003d iVar9;\n          iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n          if (iVar9 !\u003d 0) goto LAB_000833de;\n          iVar16 \u003d local_98 + 1;\n          ppppppppiVar7 \u003d (int ********)local_68;\n        }\n        pppppppiVar19 \u003d pppppppiVar24 + -4;\n      } while (0x10 \u003c (int)pppppppiVar19);\n      pppppppiVar19 \u003d pppppppiVar24 + -4;\n      local_98 \u003d iVar16;\n    }\n    local_94 \u003d (int *******)((int)local_94 + (int)pppppppiVar19);\n    *ppppppppiVar7 \u003d (int *******)0x85808;\n    ppppppppiVar7[1] \u003d pppppppiVar19;\n    if (local_98 \u003c 8) {\n      iVar9 \u003d local_98 + 1;\n      ppppppppiVar7 \u003d ppppppppiVar7 + 2;\n    }\n    else if (local_94 \u003d\u003d (int *******)0x0) {\n      iVar9 \u003d 1;\n      local_98 \u003d 0;\n      ppppppppiVar7 \u003d (int ********)local_68;\n    }\n    else {\n      iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n      if (iVar9 !\u003d 0) goto LAB_000833de;\n      iVar9 \u003d local_98 + 1;\n      ppppppppiVar7 \u003d (int ********)local_68;\n    }\n  }\n  else {\n    iVar9 \u003d local_98 + 1;\n  }\n  iVar16 \u003d iVar9;\n  if (local_a1 !\u003d \u0027\\0\u0027) {\n    local_94 \u003d (int *******)((int)local_94 + 1);\n    iVar16 \u003d 1;\n    *ppppppppiVar7 \u003d (int *******)\u0026local_a1;\n    ppppppppiVar7[1] \u003d (int *******)0x1;\n    local_98 \u003d iVar9;\n    if (iVar9 \u003c 8) {\n      iVar16 \u003d iVar9 + 1;\n      ppppppppiVar7 \u003d ppppppppiVar7 + 2;\n    }\n    else if (local_94 \u003d\u003d (int *******)0x0) {\n      local_98 \u003d 0;\n      ppppppppiVar7 \u003d (int ********)local_68;\n    }\n    else {\n      iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n      if (iVar9 !\u003d 0) goto LAB_000833de;\n      iVar16 \u003d local_98 + 1;\n      ppppppppiVar7 \u003d (int ********)local_68;\n    }\n  }\n  iVar9 \u003d iVar16;\n  iVar18 \u003d local_98;\n  if (bVar5) {\n    local_94 \u003d (int *******)((int)local_94 + 2);\n    *ppppppppiVar7 \u003d (int *******)\u0026local_a0;\n    ppppppppiVar7[1] \u003d (int *******)0x2;\n    if (iVar16 \u003c 8) {\n      iVar9 \u003d iVar16 + 1;\n      iVar18 \u003d iVar16;\n      ppppppppiVar7 \u003d ppppppppiVar7 + 2;\n    }\n    else if (local_94 \u003d\u003d (int *******)0x0) {\n      iVar9 \u003d 1;\n      iVar18 \u003d 0;\n      ppppppppiVar7 \u003d (int ********)local_68;\n    }\n    else {\n      local_98 \u003d iVar16;\n      iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n      if (iVar9 !\u003d 0) goto LAB_000833de;\n      iVar9 \u003d local_98 + 1;\n      iVar18 \u003d local_98;\n      ppppppppiVar7 \u003d (int ********)local_68;\n    }\n  }\n  local_98 \u003d iVar18;\n  if ((uVar14 \u003d\u003d 0x80) \u0026\u0026\n     (pppppppiVar19 \u003d (int *******)((int)pppppppiVar21 - (int)local_dc), 0 \u003c (int)pppppppiVar19)) {\n    if (0x10 \u003c (int)pppppppiVar19) {\n      do {\n        while( true ) {\n          pppppppiVar24 \u003d pppppppiVar19;\n          local_98 \u003d iVar18 + 1;\n          local_94 \u003d local_94 + 4;\n          *ppppppppiVar7 \u003d (int *******)\u0026zeroes_6718;\n          ppppppppiVar7[1] \u003d (int *******)0x10;\n          if (7 \u003c local_98) break;\n          iVar9 \u003d iVar18 + 2;\n          ppppppppiVar7 \u003d ppppppppiVar7 + 2;\nLAB_0008348e:\n          iVar18 \u003d local_98;\n          pppppppiVar19 \u003d pppppppiVar24 + -4;\n          if ((int)(pppppppiVar24 + -4) \u003c 0x11) goto LAB_000834b4;\n        }\n        if (local_94 !\u003d (int *******)0x0) {\n          iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n          if (iVar9 \u003d\u003d 0) {\n            iVar9 \u003d local_98 + 1;\n            ppppppppiVar7 \u003d (int ********)local_68;\n            goto LAB_0008348e;\n          }\n          goto LAB_000833de;\n        }\n        iVar9 \u003d 1;\n        iVar18 \u003d 0;\n        pppppppiVar19 \u003d pppppppiVar24 + -4;\n        ppppppppiVar7 \u003d (int ********)local_68;\n      } while (0x10 \u003c (int)(pppppppiVar24 + -4));\nLAB_000834b4:\n      pppppppiVar19 \u003d pppppppiVar24 + -4;\n    }\n    local_94 \u003d (int *******)((int)local_94 + (int)pppppppiVar19);\n    *ppppppppiVar7 \u003d (int *******)\u0026zeroes_6718;\n    ppppppppiVar7[1] \u003d pppppppiVar19;\n    local_98 \u003d iVar9;\n    if (iVar9 \u003c 8) {\n      iVar9 \u003d iVar9 + 1;\n      ppppppppiVar7 \u003d ppppppppiVar7 + 2;\n    }\n    else if (local_94 \u003d\u003d (int *******)0x0) {\n      iVar9 \u003d 1;\n      local_98 \u003d 0;\n      ppppppppiVar7 \u003d (int ********)local_68;\n    }\n    else {\n      iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n      if (iVar9 !\u003d 0) goto LAB_000833de;\n      iVar9 \u003d local_98 + 1;\n      ppppppppiVar7 \u003d (int ********)local_68;\n    }\n  }\n  pppppppiVar11 \u003d (int *******)((int)pppppppiVar11 - (int)local_d4);\n  ppppppppiVar17 \u003d (int ********)local_68;\n  if ((int)pppppppiVar11 \u003c 1) {\nLAB_000832c6:\n    local_94 \u003d (int *******)((int)local_94 + (int)local_d4);\n    *ppppppppiVar7 \u003d (int *******)__s;\n    ppppppppiVar7[1] \u003d local_d4;\n    local_d4 \u003d local_94;\n    local_98 \u003d iVar9;\n    if (iVar9 \u003c 8) goto LAB_0008345a;\n    if (local_94 \u003d\u003d (int *******)0x0) {\n      local_98 \u003d 0;\n    }\n    else {\n      iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n      if (iVar9 !\u003d 0) goto LAB_000833de;\n    }\n  }\n  else {\n    iVar16 \u003d local_98;\n    if (0x10 \u003c (int)pppppppiVar11) {\n      do {\n        while( true ) {\n          pppppppiVar19 \u003d pppppppiVar11;\n          local_98 \u003d iVar16 + 1;\n          local_94 \u003d local_94 + 4;\n          *ppppppppiVar7 \u003d (int *******)\u0026zeroes_6718;\n          ppppppppiVar7[1] \u003d (int *******)0x10;\n          if (7 \u003c local_98) break;\n          iVar9 \u003d iVar16 + 2;\n          ppppppppiVar7 \u003d ppppppppiVar7 + 2;\nLAB_00083282:\n          iVar16 \u003d local_98;\n          pppppppiVar11 \u003d pppppppiVar19 + -4;\n          if ((int)(pppppppiVar19 + -4) \u003c 0x11) goto LAB_000832aa;\n        }\n        if (local_94 !\u003d (int *******)0x0) {\n          iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n          if (iVar9 \u003d\u003d 0) {\n            iVar9 \u003d local_98 + 1;\n            ppppppppiVar7 \u003d (int ********)local_68;\n            goto LAB_00083282;\n          }\n          goto LAB_000833de;\n        }\n        iVar9 \u003d 1;\n        ppppppppiVar7 \u003d (int ********)local_68;\n        iVar16 \u003d 0;\n        pppppppiVar11 \u003d pppppppiVar19 + -4;\n      } while (0x10 \u003c (int)(pppppppiVar19 + -4));\nLAB_000832aa:\n      pppppppiVar11 \u003d pppppppiVar19 + -4;\n    }\n    local_94 \u003d (int *******)((int)local_94 + (int)pppppppiVar11);\n    *ppppppppiVar7 \u003d (int *******)\u0026zeroes_6718;\n    ppppppppiVar7[1] \u003d pppppppiVar11;\n    if (iVar9 \u003c 8) {\n      iVar9 \u003d iVar9 + 1;\n      ppppppppiVar7 \u003d ppppppppiVar7 + 2;\n      goto LAB_000832c6;\n    }\n    if (local_94 !\u003d (int *******)0x0) {\n      local_98 \u003d iVar9;\n      iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n      if (iVar9 !\u003d 0) goto LAB_000833de;\n      iVar9 \u003d local_98 + 1;\n      ppppppppiVar7 \u003d (int ********)local_68;\n      goto LAB_000832c6;\n    }\n    local_64[0] \u003d local_d4;\n    local_98 \u003d 1;\n    ppppppppiVar7 \u003d (int ********)local_68;\n    local_68 \u003d (undefined  [4])__s;\nLAB_0008345a:\n    ppppppppiVar17 \u003d ppppppppiVar7 + 2;\n    local_94 \u003d local_d4;\n  }\n  if (((uVar14 \u0026 4) !\u003d 0) \u0026\u0026\n     (pppppppiVar11 \u003d (int *******)((int)pppppppiVar21 - (int)local_dc), 0 \u003c (int)pppppppiVar11)) {\n    iVar9 \u003d local_98;\n    if ((int)pppppppiVar11 \u003c 0x11) {\n      iVar16 \u003d local_98 + 1;\n    }\n    else {\n      do {\n        while( true ) {\n          local_98 \u003d iVar9 + 1;\n          local_94 \u003d local_94 + 4;\n          *ppppppppiVar17 \u003d (int *******)0x85808;\n          ppppppppiVar17[1] \u003d (int *******)0x10;\n          if (7 \u003c local_98) break;\n          iVar16 \u003d iVar9 + 2;\n          ppppppppiVar17 \u003d ppppppppiVar17 + 2;\nLAB_00083316:\n          pppppppiVar11 \u003d pppppppiVar11 + -4;\n          iVar9 \u003d local_98;\n          if ((int)pppppppiVar11 \u003c 0x11) goto LAB_0008333e;\n        }\n        if (local_94 !\u003d (int *******)0x0) {\n          iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n          if (iVar9 \u003d\u003d 0) {\n            iVar16 \u003d local_98 + 1;\n            ppppppppiVar17 \u003d (int ********)local_68;\n            goto LAB_00083316;\n          }\n          goto LAB_000833de;\n        }\n        pppppppiVar11 \u003d pppppppiVar11 + -4;\n        iVar16 \u003d 1;\n        iVar9 \u003d 0;\n        ppppppppiVar17 \u003d (int ********)local_68;\n      } while (0x10 \u003c (int)pppppppiVar11);\n    }\nLAB_0008333e:\n    local_94 \u003d (int *******)((int)local_94 + (int)pppppppiVar11);\n    *ppppppppiVar17 \u003d (int *******)0x85808;\n    ppppppppiVar17[1] \u003d pppppppiVar11;\n    local_98 \u003d iVar16;\n    if (7 \u003c iVar16) {\n      if (local_94 \u003d\u003d (int *******)0x0) {\n        if ((int)local_dc \u003c (int)pppppppiVar21) {\n          local_dc \u003d pppppppiVar21;\n        }\n        local_c4 \u003d local_c4 + (int)local_dc;\n        goto LAB_00083422;\n      }\n      iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n      if (iVar9 !\u003d 0) goto LAB_000833de;\n    }\n  }\n  if ((int)local_dc \u003c (int)pppppppiVar21) {\n    local_dc \u003d pppppppiVar21;\n  }\n  local_c4 \u003d local_c4 + (int)local_dc;\n  if ((local_94 !\u003d (int *******)0x0) \u0026\u0026\n     (iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c), iVar9 !\u003d 0)) goto LAB_000833de;\nLAB_00083422:\n  local_98 \u003d 0;\n  ppppppppiVar7 \u003d (int ********)local_68;\n  goto LAB_00082b9e;\nswitchD_00082c20_caseD_31:\n  uVar12 \u003d uVar15 - 0x30;\n  pppppppiVar21 \u003d (int *******)0x0;\n  pppppppiVar11 \u003d param_3;\n  do {\n    param_3 \u003d (int *******)((int)pppppppiVar11 + 1);\n    uVar15 \u003d (uint)*(byte *)pppppppiVar11;\n    pppppppiVar21 \u003d (int *******)(uVar12 + (int)pppppppiVar21 * 10);\n    uVar12 \u003d uVar15 - 0x30;\n    pppppppiVar11 \u003d param_3;\n  } while (uVar12 \u003c 10);\n  goto LAB_00082c16;\nswitchD_00082c20_caseD_20:\n  uVar15 \u003d (uint)*(byte *)param_3;\n  if (local_a1 \u003d\u003d \u0027\\0\u0027) {\n    local_a1 \u003d \u0027 \u0027;\n  }\n  goto LAB_00082c12;\n}\n\n",
      "renaming": {},
      "calling": [
        "iprintf",
        "__sbprintf"
      ],
      "called": [
        "__swsetup_r",
        "__sprint_r.part.0",
        "__sinit",
        "memchr",
        "__aeabi_uldivmod",
        "strlen",
        "__sbprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sbprintf": {
      "entrypoint": "0x0008378c",
      "current_name": "__sbprintf",
      "code": "\nint __sbprintf(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined *local_488 [2];\n  undefined4 local_480;\n  ushort local_47c;\n  undefined2 local_47a;\n  undefined *local_478;\n  undefined4 local_474;\n  undefined4 local_470;\n  undefined4 local_46c;\n  undefined4 local_464;\n  undefined4 local_424;\n  undefined auStack_420 [1024];\n  \n  local_424 \u003d *(undefined4 *)(param_2 + 100);\n  local_46c \u003d *(undefined4 *)(param_2 + 0x1c);\n  local_47a \u003d *(undefined2 *)(param_2 + 0xe);\n  local_464 \u003d *(undefined4 *)(param_2 + 0x24);\n  local_488[0] \u003d auStack_420;\n  local_47c \u003d *(ushort *)(param_2 + 0xc) \u0026 0xfffd;\n  local_480 \u003d 0x400;\n  local_474 \u003d 0x400;\n  local_470 \u003d 0;\n  local_478 \u003d local_488[0];\n  iVar1 \u003d _vfiprintf_r(param_1,local_488);\n  if ((-1 \u003c iVar1) \u0026\u0026 (iVar2 \u003d _fflush_r(param_1,local_488), iVar2 !\u003d 0)) {\n    iVar1 \u003d -1;\n  }\n  if ((int)((uint)local_47c \u003c\u003c 0x19) \u003c 0) {\n    *(ushort *)(param_2 + 0xc) \u003d *(ushort *)(param_2 + 0xc) | 0x40;\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_vfiprintf_r"
      ],
      "called": [
        "_vfiprintf_r",
        "_fflush_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__swsetup_r": {
      "entrypoint": "0x00083808",
      "current_name": "__swsetup_r",
      "code": "\nundefined4 __swsetup_r(undefined4 *param_1,int *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  uint uVar3;\n  ushort uVar4;\n  \n  if ((_impure_ptr !\u003d 0) \u0026\u0026 (*(int *)(_impure_ptr + 0x38) \u003d\u003d 0)) {\n    __sinit();\n  }\n  uVar4 \u003d *(ushort *)(param_2 + 3);\n  uVar3 \u003d (uint)uVar4;\n  if ((int)(uVar3 \u003c\u003c 0x1c) \u003c 0) {\n    iVar2 \u003d param_2[4];\n  }\n  else {\n    if (-1 \u003c (int)(uVar3 \u003c\u003c 0x1b)) {\n      *param_1 \u003d 9;\n      *(ushort *)(param_2 + 3) \u003d uVar4 | 0x40;\n      return 0xffffffff;\n    }\n    if ((int)(uVar3 \u003c\u003c 0x1d) \u003c 0) {\n      if ((int *)param_2[0xc] !\u003d (int *)0x0) {\n        if ((int *)param_2[0xc] !\u003d param_2 + 0x10) {\n          _free_r(param_1);\n          uVar4 \u003d *(ushort *)(param_2 + 3);\n        }\n        param_2[0xc] \u003d 0;\n      }\n      iVar2 \u003d param_2[4];\n      uVar4 \u003d uVar4 \u0026 0xffdb;\n      *param_2 \u003d iVar2;\n      param_2[1] \u003d 0;\n    }\n    else {\n      iVar2 \u003d param_2[4];\n    }\n    *(ushort *)(param_2 + 3) \u003d uVar4 | 8;\n    uVar3 \u003d (uint)(uVar4 | 8);\n  }\n  if ((iVar2 \u003d\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x280) !\u003d 0x200)) {\n    __smakebuf_r(param_1,param_2);\n    uVar3 \u003d (uint)*(ushort *)(param_2 + 3);\n    iVar2 \u003d param_2[4];\n  }\n  if ((uVar3 \u0026 1) \u003d\u003d 0) {\n    iVar1 \u003d 0;\n    if (-1 \u003c (int)(uVar3 \u003c\u003c 0x1e)) {\n      iVar1 \u003d param_2[5];\n    }\n    param_2[2] \u003d iVar1;\n  }\n  else {\n    param_2[6] \u003d -param_2[5];\n    param_2[2] \u003d 0;\n  }\n  if ((iVar2 \u003d\u003d 0) \u0026\u0026 ((int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x18) \u003c 0)) {\n    *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x40;\n    return 0xffffffff;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swbuf_r",
        "_vfiprintf_r",
        "__sfvwrite_r"
      ],
      "called": [
        "__smakebuf_r",
        "__sinit",
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__register_exitproc": {
      "entrypoint": "0x000838cc",
      "current_name": "__register_exitproc",
      "code": "\nundefined4 __register_exitproc(int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 *puVar1;\n  uint uVar2;\n  uint uVar3;\n  \n  if (DAT_20070180 \u003d\u003d (undefined4 *)0x0) {\n    DAT_20070180 \u003d (undefined4 *)\u0026DAT_20070184;\n  }\n  uVar2 \u003d DAT_20070180[1];\n  puVar1 \u003d DAT_20070180;\n  if (0x1f \u003c (int)uVar2) {\n    puVar1 \u003d (undefined4 *)malloc(400);\n    if (puVar1 \u003d\u003d (undefined4 *)0x0) {\n      return 0xffffffff;\n    }\n    *puVar1 \u003d DAT_20070180;\n    puVar1[1] \u003d 0;\n    uVar2 \u003d 0;\n    DAT_20070180 \u003d puVar1;\n    puVar1[0x62] \u003d 0;\n    puVar1[99] \u003d 0;\n  }\n  if (param_1 !\u003d 0) {\n    uVar3 \u003d 1 \u003c\u003c (uVar2 \u0026 0xff);\n    puVar1[uVar2 + 0x22] \u003d param_3;\n    puVar1[0x62] \u003d puVar1[0x62] | uVar3;\n    puVar1[uVar2 + 0x42] \u003d param_4;\n    if (param_1 \u003d\u003d 2) {\n      puVar1[99] \u003d uVar3 | puVar1[99];\n    }\n  }\n  puVar1[1] \u003d uVar2 + 1;\n  puVar1[uVar2 + 2] \u003d param_2;\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__cxa_atexit",
        "atexit"
      ],
      "called": [
        "malloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "register_fini": {
      "entrypoint": "0x00083974",
      "current_name": "register_fini",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00083978) */\n\nvoid register_fini(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_init_array"
      ],
      "called": [
        "atexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "atexit": {
      "entrypoint": "0x00083988",
      "current_name": "atexit",
      "code": "\nint atexit(__func *__func)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d __register_exitproc(0,__func,0,0);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "register_fini"
      ],
      "called": [
        "__register_exitproc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sflush_r": {
      "entrypoint": "0x00083994",
      "current_name": "__sflush_r",
      "code": "\nundefined4 __sflush_r(int *param_1,int *param_2)\n\n{\n  int *piVar1;\n  int iVar2;\n  ushort uVar3;\n  uint uVar4;\n  int iVar5;\n  code *pcVar6;\n  int iVar7;\n  \n  uVar3 \u003d *(ushort *)(param_2 + 3);\n  if ((int)((uint)uVar3 \u003c\u003c 0x1c) \u003c 0) {\n    iVar7 \u003d param_2[4];\n    if (iVar7 \u003d\u003d 0) {\n      return 0;\n    }\n    iVar2 \u003d *param_2;\n    if ((uVar3 \u0026 3) \u003d\u003d 0) {\n      iVar5 \u003d param_2[5];\n    }\n    else {\n      iVar5 \u003d 0;\n    }\n    *param_2 \u003d iVar7;\n    iVar2 \u003d iVar2 - iVar7;\n    param_2[2] \u003d iVar5;\n    do {\n      if (iVar2 \u003c 1) {\n        return 0;\n      }\n      iVar5 \u003d (*(code *)param_2[9])(param_1,param_2[7],iVar7,iVar2);\n      iVar2 \u003d iVar2 - iVar5;\n      iVar7 \u003d iVar7 + iVar5;\n    } while (0 \u003c iVar5);\nLAB_00083a54:\n    *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x40;\n    return 0xffffffff;\n  }\n  *(ushort *)(param_2 + 3) \u003d uVar3 | 0x800;\n  if ((param_2[1] \u003c 1) \u0026\u0026 (param_2[0xf] \u003c 1)) {\n    return 0;\n  }\n  pcVar6 \u003d (code *)param_2[10];\n  if (pcVar6 \u003d\u003d (code *)0x0) {\n    return 0;\n  }\n  uVar4 \u003d (uint)(uVar3 | 0x800);\n  iVar7 \u003d *param_1;\n  *param_1 \u003d 0;\n  if ((uVar3 \u0026 0x1000) \u003d\u003d 0) {\n    iVar2 \u003d (*pcVar6)(param_1,param_2[7],uVar4 \u0026 0x1000,1);\n    if ((iVar2 \u003d\u003d -1) \u0026\u0026 (iVar5 \u003d *param_1, iVar5 !\u003d 0)) {\n      if ((iVar5 \u003d\u003d 0x1d) || (iVar5 \u003d\u003d 0x16)) {\n        *param_1 \u003d iVar7;\n        return 0;\n      }\n      goto LAB_00083a54;\n    }\n    uVar4 \u003d (uint)*(ushort *)(param_2 + 3);\n    pcVar6 \u003d (code *)param_2[10];\n  }\n  else {\n    iVar2 \u003d param_2[0x14];\n  }\n  if (((int)(uVar4 \u003c\u003c 0x1d) \u003c 0) \u0026\u0026 (iVar2 \u003d iVar2 - param_2[1], param_2[0xc] !\u003d 0)) {\n    iVar2 \u003d iVar2 - param_2[0xf];\n  }\n  iVar2 \u003d (*pcVar6)(param_1,param_2[7],iVar2,0);\n  if (iVar2 \u003d\u003d -1) {\n    iVar5 \u003d *param_1;\n    if (iVar5 !\u003d 0) {\n      if ((iVar5 !\u003d 0x1d) \u0026\u0026 (iVar5 !\u003d 0x16)) {\n        *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x40;\n        return 0xffffffff;\n      }\n      *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xf7ff;\n      *param_2 \u003d param_2[4];\n      param_2[1] \u003d 0;\n      goto LAB_00083a00;\n    }\n    uVar3 \u003d *(ushort *)(param_2 + 3) \u0026 0xf7ff;\n    param_2[1] \u003d 0;\n    *(ushort *)(param_2 + 3) \u003d uVar3;\n    *param_2 \u003d param_2[4];\n  }\n  else {\n    uVar3 \u003d *(ushort *)(param_2 + 3) \u0026 0xf7ff;\n    *param_2 \u003d param_2[4];\n    *(ushort *)(param_2 + 3) \u003d uVar3;\n    param_2[1] \u003d 0;\n  }\n  if ((int)((uint)uVar3 \u003c\u003c 0x13) \u003c 0) {\n    param_2[0x14] \u003d iVar2;\n  }\nLAB_00083a00:\n  piVar1 \u003d (int *)param_2[0xc];\n  *param_1 \u003d iVar7;\n  if (piVar1 \u003d\u003d (int *)0x0) {\n    return 0;\n  }\n  if (piVar1 !\u003d param_2 + 0x10) {\n    _free_r(param_1);\n  }\n  param_2[0xc] \u003d 0;\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fflush_r"
      ],
      "called": [
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fflush_r": {
      "entrypoint": "0x00083adc",
      "current_name": "_fflush_r",
      "code": "\nvoid _fflush_r(int param_1,int param_2)\n\n{\n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x38) \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (*(short *)(param_2 + 0xc) \u003d\u003d 0) {\n    return;\n  }\n  __sflush_r(param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swbuf_r",
        "_fclose_r",
        "__sfvwrite_r",
        "__sbprintf"
      ],
      "called": [
        "__sflush_r",
        "__sinit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_cleanup_r": {
      "entrypoint": "0x00083b08",
      "current_name": "_cleanup_r",
      "code": "\nvoid _cleanup_r(undefined4 param_1)\n\n{\n  _fwalk(param_1,0x846a5);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_fwalk"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sinit": {
      "entrypoint": "0x00083b14",
      "current_name": "__sinit",
      "code": "\nvoid __sinit(int param_1)\n\n{\n  undefined4 *puVar1;\n  undefined4 *puVar2;\n  \n  if (*(int *)(param_1 + 0x38) \u003d\u003d 0) {\n    puVar1 \u003d *(undefined4 **)(param_1 + 4);\n    *(undefined4 *)(param_1 + 0x3c) \u003d 0x83b09;\n    *(undefined4 *)(param_1 + 0x2e4) \u003d 3;\n    *(int *)(param_1 + 0x2e8) \u003d param_1 + 0x2ec;\n    *(undefined4 *)(param_1 + 0x2e0) \u003d 0;\n    *(undefined2 *)(puVar1 + 3) \u003d 4;\n    *puVar1 \u003d 0;\n    puVar1[1] \u003d 0;\n    puVar1[2] \u003d 0;\n    puVar1[0x19] \u003d 0;\n    *(undefined2 *)((int)puVar1 + 0xe) \u003d 0;\n    puVar1[4] \u003d 0;\n    puVar1[5] \u003d 0;\n    puVar1[6] \u003d 0;\n    memset(puVar1 + 0x17,0,8);\n    puVar2 \u003d *(undefined4 **)(param_1 + 8);\n    puVar1[7] \u003d puVar1;\n    puVar1[8] \u003d 0x84441;\n    puVar1[9] \u003d 0x84465;\n    puVar1[10] \u003d 0x8449d;\n    puVar1[0xb] \u003d 0x844bd;\n    *(undefined2 *)((int)puVar2 + 0xe) \u003d 1;\n    *(undefined2 *)(puVar2 + 3) \u003d 9;\n    *puVar2 \u003d 0;\n    puVar2[1] \u003d 0;\n    puVar2[2] \u003d 0;\n    puVar2[0x19] \u003d 0;\n    puVar2[4] \u003d 0;\n    puVar2[5] \u003d 0;\n    puVar2[6] \u003d 0;\n    memset(puVar2 + 0x17,0,8);\n    puVar1 \u003d *(undefined4 **)(param_1 + 0xc);\n    puVar2[7] \u003d puVar2;\n    puVar2[8] \u003d 0x84441;\n    puVar2[9] \u003d 0x84465;\n    puVar2[10] \u003d 0x8449d;\n    puVar2[0xb] \u003d 0x844bd;\n    *(undefined2 *)(puVar1 + 3) \u003d 0x12;\n    *(undefined2 *)((int)puVar1 + 0xe) \u003d 2;\n    *puVar1 \u003d 0;\n    puVar1[1] \u003d 0;\n    puVar1[2] \u003d 0;\n    puVar1[0x19] \u003d 0;\n    puVar1[4] \u003d 0;\n    puVar1[5] \u003d 0;\n    puVar1[6] \u003d 0;\n    memset(puVar1 + 0x17,0,8);\n    puVar1[7] \u003d puVar1;\n    puVar1[8] \u003d 0x84441;\n    puVar1[9] \u003d 0x84465;\n    puVar1[10] \u003d 0x8449d;\n    puVar1[0xb] \u003d 0x844bd;\n    *(undefined4 *)(param_1 + 0x38) \u003d 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swsetup_r",
        "__swbuf_r",
        "_fclose_r",
        "_vfiprintf_r",
        "_fflush_r"
      ],
      "called": [
        "memset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfp_lock_acquire": {
      "entrypoint": "0x00083c08",
      "current_name": "__sfp_lock_acquire",
      "code": "\nvoid __sfp_lock_acquire(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fclose_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfp_lock_release": {
      "entrypoint": "0x00083c0c",
      "current_name": "__sfp_lock_release",
      "code": "\nvoid __sfp_lock_release(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fclose_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__libc_fini_array": {
      "entrypoint": "0x00083c10",
      "current_name": "__libc_fini_array",
      "code": "\nvoid __libc_fini_array(void)\n\n{\n  int iVar1;\n  code **ppcVar2;\n  \n  iVar1 \u003d 1;\n  ppcVar2 \u003d (code **)\u0026__fini_array_end;\n  do {\n    iVar1 \u003d iVar1 + -1;\n    ppcVar2 \u003d ppcVar2 + -1;\n    (**ppcVar2)();\n  } while (iVar1 !\u003d 0);\n  _fini();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_fini",
        "__do_global_dtors_aux"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fputwc_r": {
      "entrypoint": "0x00083c40",
      "current_name": "_fputwc_r",
      "code": "\nuint _fputwc_r(undefined4 param_1,uint param_2,byte **param_3)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  byte *pbVar4;\n  uint uVar5;\n  byte local_1c;\n  byte abStack_1b [3];\n  \n  if (-1 \u003c (int)((uint)*(ushort *)(param_3 + 3) \u003c\u003c 0x12)) {\n    *(ushort *)(param_3 + 3) \u003d *(ushort *)(param_3 + 3) | 0x2000;\n    param_3[0x19] \u003d (byte *)((uint)param_3[0x19] | 0x2000);\n  }\n  iVar1 \u003d __locale_mb_cur_max();\n  if ((iVar1 \u003d\u003d 1) \u0026\u0026 (param_2 - 1 \u003c 0xff)) {\n    uVar3 \u003d param_2 \u0026 0xff;\n    local_1c \u003d (byte)uVar3;\n    uVar2 \u003d 1;\n  }\n  else {\n    uVar2 \u003d _wcrtomb_r(param_1,\u0026local_1c,param_2,param_3 + 0x17);\n    if (uVar2 \u003d\u003d 0xffffffff) {\n      *(ushort *)(param_3 + 3) \u003d *(ushort *)(param_3 + 3) | 0x40;\n      return 0xffffffff;\n    }\n    if (uVar2 \u003d\u003d 0) {\n      return param_2;\n    }\n    uVar3 \u003d (uint)local_1c;\n  }\n  uVar5 \u003d 0;\n  do {\n    pbVar4 \u003d param_3[2] + -1;\n    param_3[2] \u003d pbVar4;\n    if ((int)pbVar4 \u003c 0) {\n      if ((int)param_3[6] \u003c\u003d (int)pbVar4) {\n        **param_3 \u003d (byte)uVar3;\n        pbVar4 \u003d *param_3;\n        uVar3 \u003d (uint)*pbVar4;\n        if (uVar3 !\u003d 10) goto LAB_00083c90;\n      }\n      iVar1 \u003d __swbuf_r(param_1,uVar3,param_3);\n      if (iVar1 \u003d\u003d -1) {\n        return 0xffffffff;\n      }\n    }\n    else {\n      **param_3 \u003d (byte)uVar3;\n      pbVar4 \u003d *param_3;\nLAB_00083c90:\n      *param_3 \u003d pbVar4 + 1;\n    }\n    if (uVar2 \u003c\u003d uVar5 + 1) {\n      return param_2;\n    }\n    uVar3 \u003d (uint)abStack_1b[uVar5];\n    uVar5 \u003d uVar5 + 1;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "__sprint_r.part.0"
      ],
      "called": [
        "__swbuf_r",
        "_wcrtomb_r",
        "__locale_mb_cur_max"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_malloc_trim_r": {
      "entrypoint": "0x00083d00",
      "current_name": "_malloc_trim_r",
      "code": "\nundefined4 _malloc_trim_r(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  int iVar3;\n  \n  __malloc_lock();\n  uVar2 \u003d *(uint *)(DAT_2007046c + 4) \u0026 0xfffffffc;\n  iVar3 \u003d ((uVar2 - param_2) + 0xfef \u0026 0xfffff000) - 0x1000;\n  if (0xfff \u003c iVar3) {\n    iVar1 \u003d _sbrk_r(param_1,0);\n    if (iVar1 \u003d\u003d DAT_2007046c + uVar2) {\n      iVar1 \u003d _sbrk_r(param_1,-iVar3);\n      if (iVar1 !\u003d -1) {\n        __malloc_current_mallinfo \u003d __malloc_current_mallinfo - iVar3;\n        *(uint *)(DAT_2007046c + 4) \u003d uVar2 - iVar3 | 1;\n        __malloc_unlock(param_1);\n        return 1;\n      }\n      iVar3 \u003d _sbrk_r(param_1,0);\n      if (0xf \u003c iVar3 - DAT_2007046c) {\n        __malloc_current_mallinfo \u003d iVar3 - __malloc_sbrk_base;\n        *(uint *)(DAT_2007046c + 4) \u003d iVar3 - DAT_2007046c | 1;\n      }\n    }\n  }\n  __malloc_unlock(param_1);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_free_r"
      ],
      "called": [
        "__malloc_lock",
        "__malloc_unlock",
        "_sbrk_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_free_r": {
      "entrypoint": "0x00083d9c",
      "current_name": "_free_r",
      "code": "\nvoid _free_r(undefined4 param_1,int param_2)\n\n{\n  undefined4 *puVar1;\n  bool bVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  undefined1 *puVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  int iVar9;\n  uint uVar10;\n  \n  if (param_2 \u003d\u003d 0) {\n    return;\n  }\n  __malloc_lock();\n  uVar3 \u003d *(uint *)(param_2 + -4);\n  iVar9 \u003d param_2 + -8;\n  uVar7 \u003d uVar3 \u0026 0xfffffffe;\n  iVar5 \u003d iVar9 + uVar7;\n  uVar10 \u003d *(uint *)(iVar5 + 4) \u0026 0xfffffffc;\n  if (DAT_2007046c \u003d\u003d iVar5) {\n    uVar10 \u003d uVar10 + uVar7;\n    if (-1 \u003c (int)(uVar3 \u003c\u003c 0x1f)) {\n      iVar9 \u003d iVar9 - *(int *)(param_2 + -8);\n      iVar4 \u003d *(int *)(iVar9 + 0xc);\n      iVar5 \u003d *(int *)(iVar9 + 8);\n      uVar10 \u003d uVar10 + *(int *)(param_2 + -8);\n      *(int *)(iVar5 + 0xc) \u003d iVar4;\n      *(int *)(iVar4 + 8) \u003d iVar5;\n    }\n    uVar3 \u003d __malloc_trim_threshold;\n    *(uint *)(iVar9 + 4) \u003d uVar10 | 1;\n    DAT_2007046c \u003d iVar9;\n    if (uVar3 \u003c\u003d uVar10) {\n      _malloc_trim_r(param_1,__malloc_top_pad);\n    }\n  }\n  else {\n    *(uint *)(iVar5 + 4) \u003d uVar10;\n    if ((uVar3 \u0026 1) \u003d\u003d 0) {\n      iVar9 \u003d iVar9 - *(int *)(param_2 + -8);\n      puVar1 \u003d *(undefined4 **)(iVar9 + 8);\n      uVar7 \u003d uVar7 + *(int *)(param_2 + -8);\n      if (puVar1 \u003d\u003d \u0026DAT_2007046c) {\n        bVar2 \u003d true;\n      }\n      else {\n        iVar4 \u003d *(int *)(iVar9 + 0xc);\n        puVar1[3] \u003d iVar4;\n        *(undefined4 **)(iVar4 + 8) \u003d puVar1;\n        bVar2 \u003d false;\n      }\n    }\n    else {\n      bVar2 \u003d false;\n    }\n    if (-1 \u003c *(int *)(iVar5 + uVar10 + 4) \u003c\u003c 0x1f) {\n      uVar7 \u003d uVar7 + uVar10;\n      puVar1 \u003d *(undefined4 **)(iVar5 + 8);\n      if ((!bVar2) \u0026\u0026 (puVar1 \u003d\u003d \u0026DAT_2007046c)) {\n        DAT_20070474 \u003d iVar9;\n        DAT_20070478 \u003d iVar9;\n        *(int **)(iVar9 + 0xc) \u003d \u0026DAT_2007046c;\n        *(int **)(iVar9 + 8) \u003d \u0026DAT_2007046c;\n        *(uint *)(iVar9 + 4) \u003d uVar7 | 1;\n        *(uint *)(iVar9 + uVar7) \u003d uVar7;\n        goto LAB_00083e30;\n      }\n      iVar5 \u003d *(int *)(iVar5 + 0xc);\n      puVar1[3] \u003d iVar5;\n      *(undefined4 **)(iVar5 + 8) \u003d puVar1;\n    }\n    *(uint *)(iVar9 + 4) \u003d uVar7 | 1;\n    *(uint *)(iVar9 + uVar7) \u003d uVar7;\n    if (!bVar2) {\n      if (uVar7 \u003c 0x200) {\n        uVar3 \u003d uVar7 \u0026 0xfffffff8;\n        iVar5 \u003d *(int *)((int)\u0026DAT_2007046c + uVar3);\n        DAT_20070468 \u003d DAT_20070468 | 1 \u003c\u003c ((int)(uVar7 \u003e\u003e 3) \u003e\u003e 2 \u0026 0xffU);\n        *(int *)(iVar9 + 8) \u003d iVar5;\n        *(undefined1 **)(iVar9 + 0xc) \u003d \u0026__malloc_av_ + uVar3;\n        *(int *)((int)\u0026DAT_2007046c + uVar3) \u003d iVar9;\n        *(int *)(iVar5 + 0xc) \u003d iVar9;\n        __malloc_unlock(param_1);\n        return;\n      }\n      uVar3 \u003d uVar7 \u003e\u003e 9;\n      if (uVar3 \u003c 5) {\n        iVar5 \u003d (uVar7 \u003e\u003e 6) + 0x38;\n        iVar4 \u003d iVar5 * 2;\n      }\n      else if (uVar3 \u003c 0x15) {\n        iVar5 \u003d uVar3 + 0x5b;\n        iVar4 \u003d iVar5 * 2;\n      }\n      else if (uVar3 \u003c 0x55) {\n        iVar5 \u003d (uVar7 \u003e\u003e 0xc) + 0x6e;\n        iVar4 \u003d iVar5 * 2;\n      }\n      else if (uVar3 \u003c 0x155) {\n        iVar5 \u003d (uVar7 \u003e\u003e 0xf) + 0x77;\n        iVar4 \u003d iVar5 * 2;\n      }\n      else if (uVar3 \u003c 0x555) {\n        iVar5 \u003d (uVar7 \u003e\u003e 0x12) + 0x7c;\n        iVar4 \u003d iVar5 * 2;\n      }\n      else {\n        iVar4 \u003d 0xfc;\n        iVar5 \u003d 0x7e;\n      }\n      puVar6 \u003d (undefined1 *)(\u0026DAT_2007046c)[iVar4];\n      if (puVar6 \u003d\u003d \u0026__malloc_av_ + iVar4 * 4) {\n        DAT_20070468 \u003d DAT_20070468 | 1 \u003c\u003c (iVar5 \u003e\u003e 2 \u0026 0xffU);\n        puVar8 \u003d puVar6;\n      }\n      else {\n        do {\n          if ((*(uint *)(puVar6 + 4) \u0026 0xfffffffc) \u003c\u003d uVar7) break;\n          puVar6 \u003d *(undefined1 **)(puVar6 + 8);\n        } while (\u0026__malloc_av_ + iVar4 * 4 !\u003d puVar6);\n        puVar8 \u003d *(undefined1 **)(puVar6 + 0xc);\n      }\n      *(undefined1 **)(iVar9 + 0xc) \u003d puVar8;\n      *(undefined1 **)(iVar9 + 8) \u003d puVar6;\n      *(int *)(puVar8 + 8) \u003d iVar9;\n      *(int *)(puVar6 + 0xc) \u003d iVar9;\n    }\n  }\nLAB_00083e30:\n  __malloc_unlock(param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swsetup_r",
        "_malloc_r",
        "__sflush_r",
        "_realloc_r",
        "_fclose_r",
        "__sfvwrite_r",
        "free"
      ],
      "called": [
        "__malloc_lock",
        "__malloc_unlock",
        "_malloc_trim_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfvwrite_r": {
      "entrypoint": "0x00083f34",
      "current_name": "__sfvwrite_r",
      "code": "\nundefined4 __sfvwrite_r(undefined4 *param_1,void **param_2,undefined4 *param_3)\n\n{\n  void **ppvVar1;\n  int iVar2;\n  void *pvVar3;\n  void *pvVar4;\n  void *pvVar5;\n  void *pvVar6;\n  ushort uVar7;\n  uint uVar8;\n  int iVar9;\n  void **ppvVar10;\n  void *pvVar11;\n  void *pvVar12;\n  void *__n;\n  size_t __n_00;\n  void *local_2c;\n  \n  if (param_3[2] !\u003d 0) {\n    uVar7 \u003d *(ushort *)(param_2 + 3);\n    uVar8 \u003d (uint)uVar7;\n    if (((int)(uVar8 \u003c\u003c 0x1c) \u003c 0) \u0026\u0026 (param_2[4] !\u003d (void *)0x0)) {\n      ppvVar10 \u003d (void **)*param_3;\n    }\n    else {\n      iVar2 \u003d __swsetup_r(param_1,param_2);\n      if (iVar2 !\u003d 0) {\n        return 0xffffffff;\n      }\n      uVar7 \u003d *(ushort *)(param_2 + 3);\n      uVar8 \u003d (uint)uVar7;\n      ppvVar10 \u003d (void **)*param_3;\n    }\n    if ((uVar7 \u0026 2) \u003d\u003d 0) {\n      pvVar5 \u003d (void *)(uVar8 \u0026 2);\n      pvVar12 \u003d pvVar5;\n      pvVar11 \u003d pvVar5;\n      local_2c \u003d pvVar5;\n      if ((uVar8 \u0026 1) \u003d\u003d 0) {\n        pvVar5 \u003d (void *)0x0;\n        pvVar12 \u003d (void *)0x0;\n        while( true ) {\n          while (pvVar5 \u003d\u003d (void *)0x0) {\n            pvVar12 \u003d *ppvVar10;\n            ppvVar1 \u003d ppvVar10 + 1;\n            ppvVar10 \u003d ppvVar10 + 2;\n            pvVar5 \u003d *ppvVar1;\n          }\n          pvVar11 \u003d param_2[2];\n          if ((int)(uVar8 \u003c\u003c 0x16) \u003c 0) {\n            if (pvVar5 \u003c pvVar11) {\n              pvVar3 \u003d *param_2;\n              pvVar11 \u003d pvVar5;\n            }\n            else if ((uVar8 \u0026 0x480) \u003d\u003d 0) {\n              pvVar3 \u003d *param_2;\n            }\n            else {\n              __n_00 \u003d (int)*param_2 - (int)param_2[4];\n              pvVar11 \u003d (void *)(__n_00 + 1 + (int)pvVar5);\n              pvVar3 \u003d (void *)(((int)param_2[5] * 3) / 2);\n              if (pvVar11 \u003c\u003d pvVar3) {\n                pvVar11 \u003d pvVar3;\n              }\n              if ((int)(uVar8 \u003c\u003c 0x15) \u003c 0) {\n                pvVar4 \u003d (void *)_malloc_r(param_1,pvVar11);\n                if (pvVar4 \u003d\u003d (void *)0x0) {\n                  *param_1 \u003d 0xc;\n                  uVar7 \u003d *(ushort *)(param_2 + 3);\n                  goto LAB_00084030;\n                }\n                memcpy(pvVar4,param_2[4],__n_00);\n                *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xfb7f | 0x80;\n              }\n              else {\n                pvVar4 \u003d (void *)_realloc_r(param_1);\n                if (pvVar4 \u003d\u003d (void *)0x0) {\n                  _free_r(param_1,param_2[4]);\n                  uVar7 \u003d *(ushort *)(param_2 + 3) \u0026 0xff7f;\n                  *param_1 \u003d 0xc;\n                  goto LAB_00084030;\n                }\n              }\n              pvVar3 \u003d (void *)((int)pvVar4 + __n_00);\n              param_2[4] \u003d pvVar4;\n              param_2[5] \u003d pvVar11;\n              *param_2 \u003d pvVar3;\n              param_2[2] \u003d (void *)((int)pvVar11 - __n_00);\n              pvVar11 \u003d pvVar5;\n            }\n            memmove(pvVar3,pvVar12,(size_t)pvVar11);\n            param_2[2] \u003d (void *)((int)param_2[2] - (int)pvVar11);\n            *param_2 \u003d (void *)((int)*param_2 + (int)pvVar11);\n            pvVar11 \u003d pvVar5;\n          }\n          else if ((param_2[4] \u003c *param_2) || (pvVar3 \u003d param_2[5], pvVar5 \u003c pvVar3)) {\n            if (pvVar5 \u003c pvVar11) {\n              pvVar11 \u003d pvVar5;\n            }\n            memmove(*param_2,pvVar12,(size_t)pvVar11);\n            pvVar3 \u003d param_2[2];\n            param_2[2] \u003d (void *)((int)pvVar3 - (int)pvVar11);\n            *param_2 \u003d (void *)((int)*param_2 + (int)pvVar11);\n            if (((void *)((int)pvVar3 - (int)pvVar11) \u003d\u003d (void *)0x0) \u0026\u0026\n               (iVar2 \u003d _fflush_r(param_1,param_2), iVar2 !\u003d 0)) goto LAB_0008402e;\n          }\n          else {\n            pvVar11 \u003d (void *)0x7fffffff;\n            if (pvVar5 \u003c (void *)0x7fffffff) {\n              pvVar11 \u003d pvVar5;\n            }\n            pvVar11 \u003d (void *)(*(code *)param_2[9])\n                                        (param_1,param_2[7],pvVar12,\n                                         ((uint)pvVar11 / (uint)pvVar3) * (int)pvVar3);\n            if ((int)pvVar11 \u003c 1) goto LAB_0008402e;\n          }\n          iVar2 \u003d param_3[2];\n          pvVar12 \u003d (void *)((int)pvVar12 + (int)pvVar11);\n          pvVar5 \u003d (void *)((int)pvVar5 - (int)pvVar11);\n          param_3[2] \u003d iVar2 - (int)pvVar11;\n          if (iVar2 - (int)pvVar11 \u003d\u003d 0) break;\n          uVar8 \u003d (uint)*(ushort *)(param_2 + 3);\n        }\n      }\n      else {\n        do {\n          while (pvVar5 \u003d\u003d (void *)0x0) {\n            pvVar11 \u003d *ppvVar10;\n            pvVar5 \u003d ppvVar10[1];\n            local_2c \u003d (void *)0x0;\n            ppvVar10 \u003d ppvVar10 + 2;\n          }\n          if (local_2c \u003d\u003d (void *)0x0) {\n            pvVar12 \u003d memchr(pvVar11,10,(size_t)pvVar5);\n            if (pvVar12 \u003d\u003d (void *)0x0) {\n              pvVar12 \u003d (void *)((int)pvVar5 + 1);\n              local_2c \u003d (void *)0x1;\n            }\n            else {\n              pvVar12 \u003d (void *)((int)pvVar12 + (1 - (int)pvVar11));\n              local_2c \u003d (void *)0x1;\n            }\n          }\n          pvVar4 \u003d *param_2;\n          pvVar3 \u003d pvVar12;\n          if (pvVar5 \u003c\u003d pvVar12) {\n            pvVar3 \u003d pvVar5;\n          }\n          pvVar6 \u003d param_2[5];\n          if ((param_2[4] \u003c pvVar4) \u0026\u0026\n             (__n \u003d (void *)((int)param_2[2] + (int)pvVar6), (int)__n \u003c (int)pvVar3)) {\n            memmove(pvVar4,pvVar11,(size_t)__n);\n            *param_2 \u003d (void *)((int)*param_2 + (int)__n);\n            iVar2 \u003d _fflush_r(param_1,param_2);\n            if (iVar2 !\u003d 0) goto LAB_0008402e;\n          }\n          else if ((int)pvVar3 \u003c (int)pvVar6) {\n            memmove(pvVar4,pvVar11,(size_t)pvVar3);\n            param_2[2] \u003d (void *)((int)param_2[2] - (int)pvVar3);\n            *param_2 \u003d (void *)((int)pvVar3 + (int)*param_2);\n            __n \u003d pvVar3;\n          }\n          else {\n            __n \u003d (void *)(*(code *)param_2[9])(param_1,param_2[7],pvVar11,pvVar6);\n            if ((int)__n \u003c 1) goto LAB_0008402e;\n          }\n          pvVar12 \u003d (void *)((int)pvVar12 - (int)__n);\n          if (pvVar12 \u003d\u003d (void *)0x0) {\n            iVar2 \u003d _fflush_r(param_1,param_2);\n            if (iVar2 !\u003d 0) goto LAB_0008402e;\n            local_2c \u003d (void *)0x0;\n          }\n          iVar2 \u003d param_3[2];\n          pvVar11 \u003d (void *)((int)pvVar11 + (int)__n);\n          pvVar5 \u003d (void *)((int)pvVar5 - (int)__n);\n          param_3[2] \u003d iVar2 - (int)__n;\n        } while (iVar2 - (int)__n !\u003d 0);\n      }\n    }\n    else {\n      pvVar12 \u003d (void *)0x0;\n      pvVar5 \u003d (void *)0x0;\n      do {\n        while( true ) {\n          pvVar11 \u003d pvVar5;\n          if ((void *)0x7ffffbff \u003c pvVar5) {\n            pvVar11 \u003d (void *)0x7ffffc00;\n          }\n          if (pvVar5 !\u003d (void *)0x0) break;\n          pvVar12 \u003d *ppvVar10;\n          pvVar5 \u003d ppvVar10[1];\n          ppvVar10 \u003d ppvVar10 + 2;\n        }\n        iVar2 \u003d (*(code *)param_2[9])(param_1,param_2[7],pvVar12,pvVar11);\n        if (iVar2 \u003c 1) {\nLAB_0008402e:\n          uVar7 \u003d *(ushort *)(param_2 + 3);\nLAB_00084030:\n          *(ushort *)(param_2 + 3) \u003d uVar7 | 0x40;\n          return 0xffffffff;\n        }\n        iVar9 \u003d param_3[2];\n        pvVar12 \u003d (void *)((int)pvVar12 + iVar2);\n        pvVar5 \u003d (void *)((int)pvVar5 - iVar2);\n        param_3[2] \u003d iVar9 - iVar2;\n      } while (iVar9 - iVar2 !\u003d 0);\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sprint_r.part.0"
      ],
      "called": [
        "__swsetup_r",
        "_malloc_r",
        "memmove",
        "memcpy",
        "_realloc_r",
        "memchr",
        "_fflush_r",
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fwalk": {
      "entrypoint": "0x00084248",
      "current_name": "_fwalk",
      "code": "\nuint _fwalk(int param_1,code *param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  int iVar3;\n  uint uVar4;\n  int *piVar5;\n  \n  piVar5 \u003d (int *)(param_1 + 0x2e0);\n  if (piVar5 !\u003d (int *)0x0) {\n    uVar4 \u003d 0;\n    do {\n      iVar2 \u003d piVar5[2];\n      iVar3 \u003d piVar5[1] + -1;\n      if (-1 \u003c iVar3) {\n        do {\n          iVar3 \u003d iVar3 + -1;\n          if ((1 \u003c *(ushort *)(iVar2 + 0xc)) \u0026\u0026 (*(short *)(iVar2 + 0xe) !\u003d -1)) {\n            uVar1 \u003d (*param_2)(iVar2);\n            uVar4 \u003d uVar4 | uVar1;\n          }\n          iVar2 \u003d iVar2 + 0x68;\n        } while (iVar3 !\u003d -1);\n      }\n      piVar5 \u003d (int *)*piVar5;\n    } while (piVar5 !\u003d (int *)0x0);\n    return uVar4;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_cleanup_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__locale_charset": {
      "entrypoint": "0x00084290",
      "current_name": "__locale_charset",
      "code": "\nchar * __locale_charset(void)\n\n{\n  return lc_ctype_charset;\n}\n\n",
      "renaming": {},
      "calling": [
        "_wcrtomb_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__locale_mb_cur_max": {
      "entrypoint": "0x00084298",
      "current_name": "__locale_mb_cur_max",
      "code": "\nundefined4 __locale_mb_cur_max(void)\n\n{\n  return __mb_cur_max;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fputwc_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__smakebuf_r": {
      "entrypoint": "0x000842a4",
      "current_name": "__smakebuf_r",
      "code": "\nvoid __smakebuf_r(int param_1,int *param_2)\n\n{\n  ushort uVar1;\n  int iVar2;\n  int iVar3;\n  uint uVar4;\n  bool bVar5;\n  undefined auStack_54 [4];\n  uint local_50;\n  \n  uVar1 \u003d *(ushort *)(param_2 + 3);\n  uVar4 \u003d (uint)uVar1;\n  if ((int)(uVar4 \u003c\u003c 0x1e) \u003c 0) {\n    *param_2 \u003d (int)param_2 + 0x43;\n    param_2[4] \u003d (int)param_2 + 0x43;\n    param_2[5] \u003d 1;\n    return;\n  }\n  if (-1 \u003c *(short *)((int)param_2 + 0xe)) {\n    iVar2 \u003d _fstat_r(param_1,(int)*(short *)((int)param_2 + 0xe),auStack_54);\n    if (-1 \u003c iVar2) {\n      bVar5 \u003d (local_50 \u0026 0xf000) \u003d\u003d 0x2000;\n      if (((local_50 \u0026 0xf000) \u003d\u003d 0x8000) \u0026\u0026 (param_2[10] \u003d\u003d 0x8449d)) {\n        iVar2 \u003d 0x400;\n        *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x400;\n        param_2[0x13] \u003d 0x400;\n      }\n      else {\n        iVar2 \u003d 0x400;\n        *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x800;\n      }\n      goto LAB_00084300;\n    }\n    uVar1 \u003d *(ushort *)(param_2 + 3);\n    uVar4 \u003d (uint)uVar1;\n  }\n  *(ushort *)(param_2 + 3) \u003d uVar1 | 0x800;\n  if ((uVar4 \u0026 0x80) \u003d\u003d 0) {\n    iVar2 \u003d 0x400;\n  }\n  else {\n    iVar2 \u003d 0x40;\n  }\n  bVar5 \u003d false;\nLAB_00084300:\n  iVar3 \u003d _malloc_r(param_1,iVar2);\n  uVar1 \u003d *(ushort *)(param_2 + 3);\n  if (iVar3 \u003d\u003d 0) {\n    if (-1 \u003c (int)((uint)uVar1 \u003c\u003c 0x16)) {\n      *(ushort *)(param_2 + 3) \u003d uVar1 | 2;\n      *param_2 \u003d (int)param_2 + 0x43;\n      param_2[4] \u003d (int)param_2 + 0x43;\n      param_2[5] \u003d 1;\n    }\n  }\n  else {\n    *(undefined4 *)(param_1 + 0x3c) \u003d 0x83b09;\n    *(ushort *)(param_2 + 3) \u003d uVar1 | 0x80;\n    *param_2 \u003d iVar3;\n    param_2[4] \u003d iVar3;\n    param_2[5] \u003d iVar2;\n    if ((bVar5) \u0026\u0026 (iVar2 \u003d _isatty_r(param_1,(int)*(short *)((int)param_2 + 0xe)), iVar2 !\u003d 0)) {\n      *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 1;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swsetup_r"
      ],
      "called": [
        "_isatty_r",
        "_malloc_r",
        "_fstat_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memchr": {
      "entrypoint": "0x00084384",
      "current_name": "memchr",
      "code": "\nvoid * memchr(void *__s,int __c,size_t __n)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uint *puVar4;\n  uint uVar5;\n  bool bVar6;\n  \n  uVar1 \u003d __c \u0026 0xff;\n  if (((uint)__s \u0026 3) \u003d\u003d 0) {\nLAB_000843b4:\n    if (3 \u003c __n) {\n      uVar5 \u003d uVar1 | uVar1 \u003c\u003c 8;\n      puVar4 \u003d (uint *)__s;\n      do {\n        uVar2 \u003d *puVar4 ^ (uVar5 | uVar5 \u003c\u003c 0x10);\n        __s \u003d puVar4;\n        if ((uVar2 + 0xfefefeff \u0026 ~uVar2 \u0026 0x80808080) !\u003d 0) break;\n        __n \u003d __n - 4;\n        __s \u003d puVar4 + 1;\n        puVar4 \u003d puVar4 + 1;\n      } while (3 \u003c __n);\n    }\n    if (__n \u003d\u003d 0) {\n      __s \u003d (uint *)0x0;\n    }\n    else {\n                    /* WARNING: Load size is inaccurate */\n      if (*__s !\u003d uVar1) {\n        iVar3 \u003d 0;\n        do {\n          __s \u003d (void *)((int)__s + 1);\n          bVar6 \u003d iVar3 \u003d\u003d __n - 1;\n          iVar3 \u003d iVar3 + 1;\n          if (bVar6) goto LAB_000843dc;\n                    /* WARNING: Load size is inaccurate */\n        } while (*__s !\u003d uVar1);\n      }\n    }\n  }\n  else if (__n \u003d\u003d 0) {\nLAB_000843dc:\n    __s \u003d (uint *)0x0;\n  }\n  else {\n                    /* WARNING: Load size is inaccurate */\n    if (*__s !\u003d uVar1) {\n      puVar4 \u003d (uint *)((int)__s + 1);\n      __n \u003d __n - 1;\n      do {\n        __s \u003d puVar4;\n        if (((uint)__s \u0026 3) \u003d\u003d 0) goto LAB_000843b4;\n        if (__n \u003d\u003d 0) goto LAB_000843dc;\n                    /* WARNING: Load size is inaccurate */\n        puVar4 \u003d (uint *)((int)__s + 1);\n        __n \u003d __n - 1;\n      } while (*__s !\u003d uVar1);\n    }\n  }\n  return __s;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfvwrite_r",
        "_vfiprintf_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_kill_r": {
      "entrypoint": "0x00084418",
      "current_name": "_kill_r",
      "code": "\nvoid _kill_r(int *param_1,int param_2,int param_3)\n\n{\n  errno \u003d 0;\n  _kill(param_2,param_3);\n  if ((param_2 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "kill"
      ],
      "called": [
        "_kill"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sread": {
      "entrypoint": "0x00084440",
      "current_name": "__sread",
      "code": "\nvoid __sread(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d _read_r(param_1,(int)*(short *)(param_2 + 0xe));\n  if (-1 \u003c iVar1) {\n    *(int *)(param_2 + 0x50) \u003d *(int *)(param_2 + 0x50) + iVar1;\n    return;\n  }\n  *(ushort *)(param_2 + 0xc) \u003d *(ushort *)(param_2 + 0xc) \u0026 0xefff;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_read_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__swrite": {
      "entrypoint": "0x00084464",
      "current_name": "__swrite",
      "code": "\nvoid __swrite(undefined4 param_1,int param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  ushort uVar1;\n  \n  uVar1 \u003d *(ushort *)(param_2 + 0xc);\n  if ((int)((uint)uVar1 \u003c\u003c 0x17) \u003c 0) {\n    _lseek_r(param_1,(int)*(short *)(param_2 + 0xe),0,2);\n    uVar1 \u003d *(ushort *)(param_2 + 0xc);\n  }\n  *(ushort *)(param_2 + 0xc) \u003d uVar1 \u0026 0xefff;\n  _write_r(param_1,(int)*(short *)(param_2 + 0xe),param_3,param_4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_lseek_r",
        "_write_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sseek": {
      "entrypoint": "0x0008449c",
      "current_name": "__sseek",
      "code": "\nvoid __sseek(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  ushort uVar2;\n  \n  iVar1 \u003d _lseek_r(param_1,(int)*(short *)(param_2 + 0xe));\n  if (iVar1 \u003d\u003d -1) {\n    uVar2 \u003d *(ushort *)(param_2 + 0xc) \u0026 0xefff;\n  }\n  else {\n    uVar2 \u003d *(ushort *)(param_2 + 0xc) | 0x1000;\n  }\n  if (iVar1 !\u003d -1) {\n    *(int *)(param_2 + 0x50) \u003d iVar1;\n  }\n  *(ushort *)(param_2 + 0xc) \u003d uVar2;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_lseek_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sclose": {
      "entrypoint": "0x000844bc",
      "current_name": "__sclose",
      "code": "\nvoid __sclose(undefined4 param_1,int param_2)\n\n{\n  _close_r(param_1,(int)*(short *)(param_2 + 0xe));\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_close_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__swbuf_r": {
      "entrypoint": "0x000844c4",
      "current_name": "__swbuf_r",
      "code": "\nuint __swbuf_r(int param_1,uint param_2,undefined4 *param_3,undefined4 param_4)\n\n{\n  ushort uVar1;\n  uint uVar2;\n  undefined *puVar3;\n  int iVar4;\n  \n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x38) \u003d\u003d 0)) {\n    __sinit();\n  }\n  uVar1 \u003d *(ushort *)(param_3 + 3);\n  uVar2 \u003d (uint)uVar1;\n  param_3[2] \u003d param_3[6];\n  if ((-1 \u003c (int)(uVar2 \u003c\u003c 0x1c)) || (iVar4 \u003d param_3[4], iVar4 \u003d\u003d 0)) {\n    iVar4 \u003d __swsetup_r(param_1,param_3,uVar1,uVar2,param_4);\n    if (iVar4 !\u003d 0) {\n      return 0xffffffff;\n    }\n    uVar1 \u003d *(ushort *)(param_3 + 3);\n    iVar4 \u003d param_3[4];\n    uVar2 \u003d (uint)uVar1;\n  }\n  param_2 \u003d param_2 \u0026 0xff;\n  if ((int)(uVar2 \u003c\u003c 0x12) \u003c 0) {\n    puVar3 \u003d (undefined *)*param_3;\n    iVar4 \u003d (int)puVar3 - iVar4;\n    if (iVar4 \u003c (int)param_3[5]) {\nLAB_000844f6:\n      iVar4 \u003d iVar4 + 1;\n      goto LAB_000844f8;\n    }\n  }\n  else {\n    param_3[0x19] \u003d param_3[0x19] \u0026 0xffffdfff;\n    puVar3 \u003d (undefined *)*param_3;\n    *(ushort *)(param_3 + 3) \u003d uVar1 | 0x2000;\n    iVar4 \u003d (int)puVar3 - iVar4;\n    if (iVar4 \u003c (int)param_3[5]) goto LAB_000844f6;\n  }\n  iVar4 \u003d _fflush_r(param_1,param_3);\n  if (iVar4 !\u003d 0) {\n    return 0xffffffff;\n  }\n  puVar3 \u003d (undefined *)*param_3;\n  iVar4 \u003d 1;\nLAB_000844f8:\n  param_3[2] \u003d param_3[2] + -1;\n  *param_3 \u003d puVar3 + 1;\n  *puVar3 \u003d (char)param_2;\n  if (((param_3[5] \u003d\u003d iVar4) ||\n      (((int)((uint)*(ushort *)(param_3 + 3) \u003c\u003c 0x1f) \u003c 0 \u0026\u0026 (param_2 \u003d\u003d 10)))) \u0026\u0026\n     (iVar4 \u003d _fflush_r(param_1,param_3), iVar4 !\u003d 0)) {\n    return 0xffffffff;\n  }\n  return param_2;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fputwc_r"
      ],
      "called": [
        "__swsetup_r",
        "__sinit",
        "_fflush_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_wcrtomb_r": {
      "entrypoint": "0x0008456c",
      "current_name": "_wcrtomb_r",
      "code": "\nvoid _wcrtomb_r(undefined4 *param_1,int param_2,undefined4 param_3,undefined4 *param_4)\n\n{\n  code *pcVar1;\n  undefined4 uVar2;\n  int iVar3;\n  undefined auStack_24 [12];\n  \n  pcVar1 \u003d __wctomb;\n  if (param_2 \u003d\u003d 0) {\n    uVar2 \u003d __locale_charset();\n    iVar3 \u003d (*pcVar1)(param_1,auStack_24,0,uVar2,param_4);\n  }\n  else {\n    uVar2 \u003d __locale_charset();\n    iVar3 \u003d (*pcVar1)(param_1,param_2,param_3,uVar2,param_4);\n  }\n  if (iVar3 \u003d\u003d -1) {\n    *param_4 \u003d 0;\n    *param_1 \u003d 0x8a;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fputwc_r"
      ],
      "called": [
        "__locale_charset",
        "__ascii_wctomb"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__ascii_wctomb": {
      "entrypoint": "0x000845bc",
      "current_name": "__ascii_wctomb",
      "code": "\nundefined4 __ascii_wctomb(undefined4 *param_1,undefined *param_2,uint param_3)\n\n{\n  if (param_2 \u003d\u003d (undefined *)0x0) {\n    return 0;\n  }\n  if (param_3 \u003c 0x100) {\n    *param_2 \u003d (char)param_3;\n    return 1;\n  }\n  *param_1 \u003d 0x8a;\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "_wcrtomb_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_write_r": {
      "entrypoint": "0x000845d8",
      "current_name": "_write_r",
      "code": "\nvoid _write_r(int *param_1,int param_2,char *param_3,int param_4)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _write(param_2,param_3,param_4);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swrite"
      ],
      "called": [
        "_write"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_close_r": {
      "entrypoint": "0x00084600",
      "current_name": "_close_r",
      "code": "\nvoid _close_r(int *param_1,int param_2)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _close(param_2);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sclose"
      ],
      "called": [
        "_close"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fclose_r": {
      "entrypoint": "0x00084624",
      "current_name": "_fclose_r",
      "code": "\nundefined4 _fclose_r(int param_1,int param_2)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  \n  if (param_2 !\u003d 0) {\n    if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x38) \u003d\u003d 0)) {\n      __sinit();\n    }\n    if (*(short *)(param_2 + 0xc) !\u003d 0) {\n      uVar1 \u003d _fflush_r(param_1,param_2);\n      if ((*(code **)(param_2 + 0x2c) !\u003d (code *)0x0) \u0026\u0026\n         (iVar2 \u003d (**(code **)(param_2 + 0x2c))(param_1,*(undefined4 *)(param_2 + 0x1c)), iVar2 \u003c 0)\n         ) {\n        uVar1 \u003d 0xffffffff;\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) \u003c\u003c 0x18) \u003c 0) {\n        _free_r(param_1,*(undefined4 *)(param_2 + 0x10));\n      }\n      if (*(int *)(param_2 + 0x30) !\u003d 0) {\n        if (*(int *)(param_2 + 0x30) !\u003d param_2 + 0x40) {\n          _free_r(param_1);\n        }\n        *(undefined4 *)(param_2 + 0x30) \u003d 0;\n      }\n      if (*(int *)(param_2 + 0x44) !\u003d 0) {\n        _free_r(param_1);\n        *(undefined4 *)(param_2 + 0x44) \u003d 0;\n      }\n      __sfp_lock_acquire();\n      *(undefined2 *)(param_2 + 0xc) \u003d 0;\n      __sfp_lock_release();\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "fclose"
      ],
      "called": [
        "__sinit",
        "__sfp_lock_release",
        "__sfp_lock_acquire",
        "_fflush_r",
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fclose": {
      "entrypoint": "0x000846a4",
      "current_name": "fclose",
      "code": "\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d _fclose_r(_impure_ptr,__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_fclose_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fstat_r": {
      "entrypoint": "0x000846b4",
      "current_name": "_fstat_r",
      "code": "\nvoid _fstat_r(int *param_1,int param_2,stat *param_3)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _fstat(param_2,param_3);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__smakebuf_r"
      ],
      "called": [
        "_fstat"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_isatty_r": {
      "entrypoint": "0x000846dc",
      "current_name": "_isatty_r",
      "code": "\nvoid _isatty_r(int *param_1,int param_2)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _isatty(param_2);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__smakebuf_r"
      ],
      "called": [
        "_isatty"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_lseek_r": {
      "entrypoint": "0x00084700",
      "current_name": "_lseek_r",
      "code": "\nvoid _lseek_r(int *param_1,int param_2,__off_t param_3,int param_4)\n\n{\n  __off_t _Var1;\n  \n  errno \u003d 0;\n  _Var1 \u003d _lseek(param_2,param_3,param_4);\n  if ((_Var1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sseek",
        "__swrite"
      ],
      "called": [
        "_lseek"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_read_r": {
      "entrypoint": "0x00084728",
      "current_name": "_read_r",
      "code": "\nvoid _read_r(int *param_1,int param_2,char *param_3,int param_4)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _read(param_2,param_3,param_4);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sread"
      ],
      "called": [
        "_read"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_uldivmod": {
      "entrypoint": "0x00084750",
      "current_name": "__aeabi_uldivmod",
      "code": "\nvoid __aeabi_uldivmod(int param_1,int param_2,int param_3,int param_4)\n\n{\n  if ((param_4 \u003d\u003d 0) \u0026\u0026 (param_3 \u003d\u003d 0)) {\n    if (param_2 !\u003d 0 || param_1 !\u003d 0) {\n      param_1 \u003d -1;\n    }\n    __aeabi_idiv0(param_1);\n    return;\n  }\n  __gnu_uldivmod_helper();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_vfiprintf_r"
      ],
      "called": [
        "__aeabi_idiv0",
        "__gnu_uldivmod_helper"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__gnu_ldivmod_helper": {
      "entrypoint": "0x0008477c",
      "current_name": "__gnu_ldivmod_helper",
      "code": "\nvoid __gnu_ldivmod_helper\n               (uint param_1,int param_2,undefined4 param_3,undefined4 param_4,int *param_5)\n\n{\n  uint uVar1;\n  longlong lVar2;\n  \n  lVar2 \u003d __divdi3();\n  lVar2 \u003d lVar2 * CONCAT44(param_4,param_3);\n  uVar1 \u003d (uint)lVar2;\n  *param_5 \u003d param_1 - uVar1;\n  param_5[1] \u003d (param_2 - (int)((ulonglong)lVar2 \u003e\u003e 0x20)) - (uint)(param_1 \u003c uVar1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__divdi3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__gnu_uldivmod_helper": {
      "entrypoint": "0x000847ac",
      "current_name": "__gnu_uldivmod_helper",
      "code": "\nvoid __gnu_uldivmod_helper\n               (uint param_1,int param_2,undefined4 param_3,undefined4 param_4,int *param_5)\n\n{\n  uint uVar1;\n  longlong lVar2;\n  \n  lVar2 \u003d __udivdi3();\n  lVar2 \u003d lVar2 * CONCAT44(param_4,param_3);\n  uVar1 \u003d (uint)lVar2;\n  *param_5 \u003d param_1 - uVar1;\n  param_5[1] \u003d (param_2 - (int)((ulonglong)lVar2 \u003e\u003e 0x20)) - (uint)(param_1 \u003c uVar1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_uldivmod"
      ],
      "called": [
        "__udivdi3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_idiv0": {
      "entrypoint": "0x000847dc",
      "current_name": "__aeabi_idiv0",
      "code": "\nvoid __aeabi_idiv0(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_uldivmod"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__divdi3": {
      "entrypoint": "0x000847e0",
      "current_name": "__divdi3",
      "code": "\nundefined8 __divdi3(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  longlong lVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  \n  if ((int)param_2 \u003c 0) {\n    bVar13 \u003d param_1 !\u003d 0;\n    param_1 \u003d -param_1;\n    param_2 \u003d -param_2 - (uint)bVar13;\n    uVar9 \u003d 0xffffffff;\n  }\n  else {\n    uVar9 \u003d 0;\n  }\n  if ((int)param_4 \u003c 0) {\n    uVar9 \u003d ~uVar9;\n    bVar13 \u003d param_3 !\u003d 0;\n    param_3 \u003d -param_3;\n    param_4 \u003d -param_4 - (uint)bVar13;\n  }\n  if (param_4 \u003d\u003d 0) {\n    if (param_2 \u003c param_3) {\n      iVar6 \u003d LZCOUNT(param_3);\n      if (iVar6 !\u003d 0) {\n        uVar3 \u003d param_1 \u003e\u003e (0x20U - iVar6 \u0026 0xff);\n        param_3 \u003d param_3 \u003c\u003c iVar6;\n        param_1 \u003d param_1 \u003c\u003c iVar6;\n        param_2 \u003d param_2 \u003c\u003c iVar6 | uVar3;\n      }\n      uVar2 \u003d param_3 \u003e\u003e 0x10;\n      uVar4 \u003d param_2 / uVar2;\n      uVar7 \u003d (param_3 \u0026 0xffff) * uVar4;\n      uVar10 \u003d param_1 \u003e\u003e 0x10 | (param_2 - uVar2 * uVar4) * 0x10000;\n      uVar3 \u003d uVar4;\n      if (uVar10 \u003c\u003d uVar7 \u0026\u0026 uVar7 - uVar10 !\u003d 0) {\n        bVar13 \u003d CARRY4(uVar10,param_3);\n        uVar10 \u003d uVar10 + param_3;\n        uVar3 \u003d uVar4 - 1;\n        if ((bVar13 \u003d\u003d false) \u0026\u0026 (uVar10 \u003c\u003d uVar7 \u0026\u0026 uVar7 - uVar10 !\u003d 0)) {\n          uVar3 \u003d uVar4 - 2;\n          uVar10 \u003d uVar10 + param_3;\n        }\n      }\n      uVar8 \u003d (uVar10 - uVar7) / uVar2;\n      uVar4 \u003d (param_3 \u0026 0xffff) * uVar8;\n      uVar7 \u003d param_1 \u0026 0xffff | ((uVar10 - uVar7) - uVar2 * uVar8) * 0x10000;\n      uVar2 \u003d uVar8;\n      if (uVar7 \u003c\u003d uVar4 \u0026\u0026 uVar4 - uVar7 !\u003d 0) {\n        uVar2 \u003d uVar8 - 1;\n        if ((CARRY4(uVar7,param_3) \u003d\u003d false) \u0026\u0026\n           (uVar7 + param_3 \u003c\u003d uVar4 \u0026\u0026 uVar4 - (uVar7 + param_3) !\u003d 0)) {\n          uVar2 \u003d uVar8 - 2;\n        }\n      }\n      uVar2 \u003d uVar2 | uVar3 \u003c\u003c 0x10;\n      uVar3 \u003d 0;\n    }\n    else {\n      if (param_3 \u003d\u003d 0) {\n        param_3 \u003d 1 / 0;\n      }\n      iVar6 \u003d LZCOUNT(param_3);\n      if (iVar6 \u003d\u003d 0) {\n        param_2 \u003d param_2 - param_3;\n        uVar4 \u003d param_3 \u003e\u003e 0x10;\n        uVar12 \u003d param_3 \u0026 0xffff;\n        uVar3 \u003d 1;\n      }\n      else {\n        param_3 \u003d param_3 \u003c\u003c iVar6;\n        uVar3 \u003d param_2 \u003e\u003e (0x20U - iVar6 \u0026 0xff);\n        uVar4 \u003d param_3 \u003e\u003e 0x10;\n        uVar10 \u003d uVar3 / uVar4;\n        uVar12 \u003d param_3 \u0026 0xffff;\n        uVar7 \u003d uVar12 * uVar10;\n        uVar8 \u003d param_1 \u003e\u003e (0x20U - iVar6 \u0026 0xff) | param_2 \u003c\u003c iVar6;\n        uVar3 \u003d uVar8 \u003e\u003e 0x10 | (uVar3 - uVar4 * uVar10) * 0x10000;\n        param_1 \u003d param_1 \u003c\u003c iVar6;\n        uVar2 \u003d uVar10;\n        if (uVar3 \u003c\u003d uVar7 \u0026\u0026 uVar7 - uVar3 !\u003d 0) {\n          bVar13 \u003d CARRY4(uVar3,param_3);\n          uVar3 \u003d uVar3 + param_3;\n          uVar2 \u003d uVar10 - 1;\n          if ((bVar13 \u003d\u003d false) \u0026\u0026 (uVar3 \u003c\u003d uVar7 \u0026\u0026 uVar7 - uVar3 !\u003d 0)) {\n            uVar2 \u003d uVar10 - 2;\n            uVar3 \u003d uVar3 + param_3;\n          }\n        }\n        uVar5 \u003d (uVar3 - uVar7) / uVar4;\n        uVar10 \u003d uVar12 * uVar5;\n        param_2 \u003d uVar8 \u0026 0xffff | ((uVar3 - uVar7) - uVar4 * uVar5) * 0x10000;\n        uVar3 \u003d uVar5;\n        if (param_2 \u003c\u003d uVar10 \u0026\u0026 uVar10 - param_2 !\u003d 0) {\n          bVar13 \u003d CARRY4(param_2,param_3);\n          param_2 \u003d param_2 + param_3;\n          uVar3 \u003d uVar5 - 1;\n          if ((bVar13 \u003d\u003d false) \u0026\u0026 (param_2 \u003c\u003d uVar10 \u0026\u0026 uVar10 - param_2 !\u003d 0)) {\n            uVar3 \u003d uVar5 - 2;\n            param_2 \u003d param_2 + param_3;\n          }\n        }\n        param_2 \u003d param_2 - uVar10;\n        uVar3 \u003d uVar3 | uVar2 \u003c\u003c 0x10;\n      }\n      uVar2 \u003d param_2 / uVar4;\n      uVar10 \u003d uVar12 * uVar2;\n      uVar8 \u003d param_1 \u003e\u003e 0x10 | (param_2 - uVar4 * uVar2) * 0x10000;\n      uVar7 \u003d uVar2;\n      if (uVar8 \u003c\u003d uVar10 \u0026\u0026 uVar10 - uVar8 !\u003d 0) {\n        bVar13 \u003d CARRY4(uVar8,param_3);\n        uVar8 \u003d uVar8 + param_3;\n        uVar7 \u003d uVar2 - 1;\n        if ((bVar13 \u003d\u003d false) \u0026\u0026 (uVar8 \u003c\u003d uVar10 \u0026\u0026 uVar10 - uVar8 !\u003d 0)) {\n          uVar7 \u003d uVar2 - 2;\n          uVar8 \u003d uVar8 + param_3;\n        }\n      }\n      uVar5 \u003d (uVar8 - uVar10) / uVar4;\n      uVar12 \u003d uVar12 * uVar5;\n      uVar4 \u003d param_1 \u0026 0xffff | ((uVar8 - uVar10) - uVar4 * uVar5) * 0x10000;\n      uVar2 \u003d uVar5;\n      if (uVar4 \u003c\u003d uVar12 \u0026\u0026 uVar12 - uVar4 !\u003d 0) {\n        uVar2 \u003d uVar5 - 1;\n        if ((CARRY4(uVar4,param_3) \u003d\u003d false) \u0026\u0026\n           (uVar4 + param_3 \u003c\u003d uVar12 \u0026\u0026 uVar12 - (uVar4 + param_3) !\u003d 0)) {\n          uVar2 \u003d uVar5 - 2;\n        }\n      }\n      uVar2 \u003d uVar2 | uVar7 \u003c\u003c 0x10;\n    }\n  }\n  else if (param_2 \u003c param_4) {\n    uVar3 \u003d 0;\n    uVar2 \u003d 0;\n  }\n  else {\n    iVar6 \u003d LZCOUNT(param_4);\n    if (iVar6 \u003d\u003d 0) {\n      if ((param_4 \u003c param_2) || (param_3 \u003c\u003d param_1)) {\n        uVar3 \u003d 0;\n        uVar2 \u003d 1;\n      }\n      else {\n        uVar2 \u003d 0;\n        uVar3 \u003d 0;\n      }\n    }\n    else {\n      uVar3 \u003d 0x20 - iVar6;\n      uVar4 \u003d param_2 \u003e\u003e (uVar3 \u0026 0xff);\n      uVar12 \u003d param_3 \u003e\u003e (uVar3 \u0026 0xff) | param_4 \u003c\u003c iVar6;\n      uVar10 \u003d uVar12 \u003e\u003e 0x10;\n      uVar2 \u003d uVar4 / uVar10;\n      uVar8 \u003d (uVar12 \u0026 0xffff) * uVar2;\n      uVar7 \u003d param_2 \u003c\u003c iVar6 | param_1 \u003e\u003e (uVar3 \u0026 0xff);\n      uVar4 \u003d uVar7 \u003e\u003e 0x10 | (uVar4 - uVar10 * uVar2) * 0x10000;\n      uVar3 \u003d uVar2;\n      if (uVar4 \u003c\u003d uVar8 \u0026\u0026 uVar8 - uVar4 !\u003d 0) {\n        bVar13 \u003d CARRY4(uVar4,uVar12);\n        uVar4 \u003d uVar4 + uVar12;\n        uVar3 \u003d uVar2 - 1;\n        if ((bVar13 \u003d\u003d false) \u0026\u0026 (uVar4 \u003c\u003d uVar8 \u0026\u0026 uVar8 - uVar4 !\u003d 0)) {\n          uVar3 \u003d uVar2 - 2;\n          uVar4 \u003d uVar4 + uVar12;\n        }\n      }\n      uVar5 \u003d (uVar4 - uVar8) / uVar10;\n      uVar11 \u003d (uVar12 \u0026 0xffff) * uVar5;\n      uVar4 \u003d uVar7 \u0026 0xffff | ((uVar4 - uVar8) - uVar10 * uVar5) * 0x10000;\n      uVar2 \u003d uVar5;\n      if (uVar4 \u003c\u003d uVar11 \u0026\u0026 uVar11 - uVar4 !\u003d 0) {\n        bVar13 \u003d CARRY4(uVar4,uVar12);\n        uVar4 \u003d uVar4 + uVar12;\n        uVar2 \u003d uVar5 - 1;\n        if ((bVar13 \u003d\u003d false) \u0026\u0026 (uVar4 \u003c\u003d uVar11 \u0026\u0026 uVar11 - uVar4 !\u003d 0)) {\n          uVar2 \u003d uVar5 - 2;\n          uVar4 \u003d uVar4 + uVar12;\n        }\n      }\n      uVar2 \u003d uVar2 | uVar3 \u003c\u003c 0x10;\n      lVar1 \u003d (ulonglong)uVar2 * (ulonglong)(param_3 \u003c\u003c iVar6);\n      uVar7 \u003d (uint)((ulonglong)lVar1 \u003e\u003e 0x20);\n      uVar3 \u003d 0;\n      if ((uVar4 - uVar11 \u003c uVar7) ||\n         ((uVar4 - uVar11 \u003d\u003d uVar7 \u0026\u0026 (param_1 \u003c\u003c iVar6 \u003c (uint)lVar1)))) {\n        uVar2 \u003d uVar2 - 1;\n        uVar3 \u003d 0;\n      }\n    }\n  }\n  if (uVar9 !\u003d 0) {\n    bVar13 \u003d uVar2 !\u003d 0;\n    uVar2 \u003d -uVar2;\n    uVar3 \u003d -uVar3 - (uint)bVar13;\n  }\n  return CONCAT44(uVar3,uVar2);\n}\n\n",
      "renaming": {},
      "calling": [
        "__gnu_ldivmod_helper"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__udivdi3": {
      "entrypoint": "0x00084a80",
      "current_name": "__udivdi3",
      "code": "\nulonglong __udivdi3(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  longlong lVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  int iVar10;\n  bool bVar11;\n  \n  if (param_4 \u003d\u003d 0) {\n    if (param_3 \u003c\u003d param_2) {\n      if (param_3 \u003d\u003d 0) {\n        param_3 \u003d 1 / 0;\n      }\n      iVar10 \u003d LZCOUNT(param_3);\n      if (iVar10 \u003d\u003d 0) {\n        param_2 \u003d param_2 - param_3;\n        uVar3 \u003d param_3 \u003e\u003e 0x10;\n        uVar5 \u003d param_3 \u0026 0xffff;\n        uVar2 \u003d 1;\n      }\n      else {\n        param_3 \u003d param_3 \u003c\u003c iVar10;\n        uVar8 \u003d param_2 \u003e\u003e (0x20U - iVar10 \u0026 0xff);\n        uVar3 \u003d param_3 \u003e\u003e 0x10;\n        uVar9 \u003d uVar8 / uVar3;\n        uVar5 \u003d param_3 \u0026 0xffff;\n        uVar2 \u003d uVar5 * uVar9;\n        uVar6 \u003d param_1 \u003e\u003e (0x20U - iVar10 \u0026 0xff) | param_2 \u003c\u003c iVar10;\n        uVar4 \u003d uVar6 \u003e\u003e 0x10 | (uVar8 - uVar3 * uVar9) * 0x10000;\n        param_1 \u003d param_1 \u003c\u003c iVar10;\n        uVar8 \u003d uVar9;\n        if (uVar4 \u003c\u003d uVar2 \u0026\u0026 uVar2 - uVar4 !\u003d 0) {\n          bVar11 \u003d CARRY4(uVar4,param_3);\n          uVar4 \u003d uVar4 + param_3;\n          uVar8 \u003d uVar9 - 1;\n          if ((bVar11 \u003d\u003d false) \u0026\u0026 (uVar4 \u003c\u003d uVar2 \u0026\u0026 uVar2 - uVar4 !\u003d 0)) {\n            uVar8 \u003d uVar9 - 2;\n            uVar4 \u003d uVar4 + param_3;\n          }\n        }\n        uVar7 \u003d (uVar4 - uVar2) / uVar3;\n        uVar9 \u003d uVar5 * uVar7;\n        param_2 \u003d uVar6 \u0026 0xffff | ((uVar4 - uVar2) - uVar3 * uVar7) * 0x10000;\n        uVar2 \u003d uVar7;\n        if (param_2 \u003c\u003d uVar9 \u0026\u0026 uVar9 - param_2 !\u003d 0) {\n          bVar11 \u003d CARRY4(param_2,param_3);\n          param_2 \u003d param_2 + param_3;\n          uVar2 \u003d uVar7 - 1;\n          if ((bVar11 \u003d\u003d false) \u0026\u0026 (param_2 \u003c\u003d uVar9 \u0026\u0026 uVar9 - param_2 !\u003d 0)) {\n            uVar2 \u003d uVar7 - 2;\n            param_2 \u003d param_2 + param_3;\n          }\n        }\n        param_2 \u003d param_2 - uVar9;\n        uVar2 \u003d uVar2 | uVar8 \u003c\u003c 0x10;\n      }\n      uVar9 \u003d param_2 / uVar3;\n      uVar4 \u003d uVar5 * uVar9;\n      uVar6 \u003d param_1 \u003e\u003e 0x10 | (param_2 - uVar3 * uVar9) * 0x10000;\n      uVar8 \u003d uVar9;\n      if (uVar6 \u003c\u003d uVar4 \u0026\u0026 uVar4 - uVar6 !\u003d 0) {\n        bVar11 \u003d CARRY4(uVar6,param_3);\n        uVar6 \u003d uVar6 + param_3;\n        uVar8 \u003d uVar9 - 1;\n        if ((bVar11 \u003d\u003d false) \u0026\u0026 (uVar6 \u003c\u003d uVar4 \u0026\u0026 uVar4 - uVar6 !\u003d 0)) {\n          uVar8 \u003d uVar9 - 2;\n          uVar6 \u003d uVar6 + param_3;\n        }\n      }\n      uVar9 \u003d (uVar6 - uVar4) / uVar3;\n      uVar5 \u003d uVar5 * uVar9;\n      uVar6 \u003d param_1 \u0026 0xffff | ((uVar6 - uVar4) - uVar3 * uVar9) * 0x10000;\n      uVar3 \u003d uVar9;\n      if (uVar6 \u003c\u003d uVar5 \u0026\u0026 uVar5 - uVar6 !\u003d 0) {\n        uVar3 \u003d uVar9 - 1;\n        if ((CARRY4(uVar6,param_3) \u003d\u003d false) \u0026\u0026\n           (uVar6 + param_3 \u003c\u003d uVar5 \u0026\u0026 uVar5 - (uVar6 + param_3) !\u003d 0)) {\n          uVar3 \u003d uVar9 - 2;\n        }\n      }\n      return CONCAT44(uVar2,uVar3 | uVar8 \u003c\u003c 0x10);\n    }\n    iVar10 \u003d LZCOUNT(param_3);\n    if (iVar10 !\u003d 0) {\n      uVar8 \u003d param_1 \u003e\u003e (0x20U - iVar10 \u0026 0xff);\n      param_3 \u003d param_3 \u003c\u003c iVar10;\n      param_1 \u003d param_1 \u003c\u003c iVar10;\n      param_2 \u003d uVar8 | param_2 \u003c\u003c iVar10;\n    }\n    uVar2 \u003d param_3 \u003e\u003e 0x10;\n    uVar3 \u003d param_2 / uVar2;\n    uVar5 \u003d (param_3 \u0026 0xffff) * uVar3;\n    uVar9 \u003d param_1 \u003e\u003e 0x10 | (param_2 - uVar2 * uVar3) * 0x10000;\n    uVar8 \u003d uVar3;\n    if (uVar9 \u003c\u003d uVar5 \u0026\u0026 uVar5 - uVar9 !\u003d 0) {\n      bVar11 \u003d CARRY4(uVar9,param_3);\n      uVar9 \u003d uVar9 + param_3;\n      uVar8 \u003d uVar3 - 1;\n      if ((bVar11 \u003d\u003d false) \u0026\u0026 (uVar9 \u003c\u003d uVar5 \u0026\u0026 uVar5 - uVar9 !\u003d 0)) {\n        uVar8 \u003d uVar3 - 2;\n        uVar9 \u003d uVar9 + param_3;\n      }\n    }\n    uVar6 \u003d (uVar9 - uVar5) / uVar2;\n    uVar3 \u003d (param_3 \u0026 0xffff) * uVar6;\n    uVar5 \u003d param_1 \u0026 0xffff | ((uVar9 - uVar5) - uVar2 * uVar6) * 0x10000;\n    uVar2 \u003d uVar6;\n    if (uVar5 \u003c\u003d uVar3 \u0026\u0026 uVar3 - uVar5 !\u003d 0) {\n      uVar2 \u003d uVar6 - 1;\n      if ((CARRY4(uVar5,param_3) \u003d\u003d false) \u0026\u0026\n         (uVar5 + param_3 \u003c\u003d uVar3 \u0026\u0026 uVar3 - (uVar5 + param_3) !\u003d 0)) {\n        uVar2 \u003d uVar6 - 2;\n      }\n    }\n    uVar2 \u003d uVar2 | uVar8 \u003c\u003c 0x10;\n  }\n  else {\n    if (param_2 \u003c param_4) {\n      return 0;\n    }\n    iVar10 \u003d LZCOUNT(param_4);\n    if (iVar10 \u003d\u003d 0) {\n      if ((param_4 \u003c param_2) || (param_3 \u003c\u003d param_1)) {\n        return 1;\n      }\n      uVar2 \u003d 0;\n    }\n    else {\n      uVar2 \u003d 0x20 - iVar10;\n      uVar8 \u003d param_2 \u003e\u003e (uVar2 \u0026 0xff);\n      uVar3 \u003d param_4 \u003c\u003c iVar10 | param_3 \u003e\u003e (uVar2 \u0026 0xff);\n      uVar5 \u003d uVar3 \u003e\u003e 0x10;\n      uVar4 \u003d uVar8 / uVar5;\n      uVar9 \u003d (uVar3 \u0026 0xffff) * uVar4;\n      uVar6 \u003d param_1 \u003e\u003e (uVar2 \u0026 0xff) | param_2 \u003c\u003c iVar10;\n      uVar2 \u003d uVar6 \u003e\u003e 0x10 | (uVar8 - uVar5 * uVar4) * 0x10000;\n      uVar8 \u003d uVar4;\n      if (uVar2 \u003c\u003d uVar9 \u0026\u0026 uVar9 - uVar2 !\u003d 0) {\n        bVar11 \u003d CARRY4(uVar2,uVar3);\n        uVar2 \u003d uVar2 + uVar3;\n        uVar8 \u003d uVar4 - 1;\n        if ((bVar11 \u003d\u003d false) \u0026\u0026 (uVar2 \u003c\u003d uVar9 \u0026\u0026 uVar9 - uVar2 !\u003d 0)) {\n          uVar8 \u003d uVar4 - 2;\n          uVar2 \u003d uVar2 + uVar3;\n        }\n      }\n      uVar4 \u003d (uVar2 - uVar9) / uVar5;\n      uVar7 \u003d (uVar3 \u0026 0xffff) * uVar4;\n      uVar5 \u003d uVar6 \u0026 0xffff | ((uVar2 - uVar9) - uVar5 * uVar4) * 0x10000;\n      uVar2 \u003d uVar4;\n      if (uVar5 \u003c\u003d uVar7 \u0026\u0026 uVar7 - uVar5 !\u003d 0) {\n        bVar11 \u003d CARRY4(uVar5,uVar3);\n        uVar5 \u003d uVar5 + uVar3;\n        uVar2 \u003d uVar4 - 1;\n        if ((bVar11 \u003d\u003d false) \u0026\u0026 (uVar5 \u003c\u003d uVar7 \u0026\u0026 uVar7 - uVar5 !\u003d 0)) {\n          uVar2 \u003d uVar4 - 2;\n          uVar5 \u003d uVar5 + uVar3;\n        }\n      }\n      uVar2 \u003d uVar2 | uVar8 \u003c\u003c 0x10;\n      lVar1 \u003d (ulonglong)uVar2 * (ulonglong)(param_3 \u003c\u003c iVar10);\n      uVar8 \u003d (uint)((ulonglong)lVar1 \u003e\u003e 0x20);\n      if ((uVar5 - uVar7 \u003c uVar8) || ((uVar5 - uVar7 \u003d\u003d uVar8 \u0026\u0026 (param_1 \u003c\u003c iVar10 \u003c (uint)lVar1)))\n         ) {\n        uVar2 \u003d uVar2 - 1;\n      }\n    }\n  }\n  return (ulonglong)uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "__gnu_uldivmod_helper"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_init": {
      "entrypoint": "0x00085858",
      "current_name": "_init",
      "code": "\nvoid _init(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_init_array"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fini": {
      "entrypoint": "0x00085874",
      "current_name": "_fini",
      "code": "\nvoid _fini(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_fini_array"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "banzai": {
      "entrypoint": "0x20070000",
      "current_name": "banzai",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid banzai(void)\n\n{\n  disableIRQinterrupts();\n  do {\n  } while (-1 \u003c *(int *)(DAT_2007001c + 8) \u003c\u003c 0x1f);\n  *(undefined4 *)(DAT_2007001c + 4) \u003d DAT_20070020;\n  do {\n  } while (-1 \u003c *(int *)(DAT_2007001c + 8) \u003c\u003c 0x1f);\n  *DAT_20070028 \u003d DAT_20070024;\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "Reset_Handler",
        "tickReset"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    }
  },
  "layers": [],
  "locked_functions": [],
  "used_tokens": 0
}