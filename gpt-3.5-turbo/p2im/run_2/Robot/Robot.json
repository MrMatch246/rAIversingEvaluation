{
    "functions": {
        "FUN_08000110": {
            "entrypoint": "0x08000110",
            "current_name": "initialize_flag_08000110",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800011c) */\n\nundefined4 initializeFlag_08000110(undefined4 input)\n\n{\n  if ((char)DAT_200009c8 == '\\0') {\n    DAT_200009c8._0_1_ = '\\x01';\n  }\n  return input;\n}\n\n",
            "renaming": {
                "FUN_08000110": "initialize_flag_08000110",
                "param_1": "input"
            },
            "calling": [],
            "called": [
                "FUN_08009e68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000134": {
            "entrypoint": "0x08000134",
            "current_name": "concatenate_integers_08000134",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800013a) */\n\nundefined8 concatenate_integers_08000134(undefined4 first_integer,undefined4 second_integer)\n\n{\n  return CONCAT44(second_integer,first_integer);\n}\n\n",
            "renaming": {
                "FUN_08000134": "concatenate_integers_08000134",
                "param_1": "first_integer",
                "param_2": "second_integer"
            },
            "calling": [
                "FUN_08005d20"
            ],
            "called": [
                "FUN_08009e68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000158": {
            "entrypoint": "0x08000158",
            "current_name": "perform_arithmetic_operations_08000158",
            "code": "\nulonglong performArithmeticOperations_08000158(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int shiftAmount1;\n  byte carryFlag;\n  uint result1;\n  uint result2;\n  uint result3;\n  uint temp1;\n  uint temp2;\n  int shiftAmount2;\n  uint result4;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  \n  temp1 = input4 ^ 0x80000000;\n  result4 = input2 << 1;\n  input4 = input4 << 1;\n  flag1 = ((input2 ^ temp1) & 0x7fffffff) == 0;\n  flag2 = flag1 && input1 == input3;\n  if (!flag1 || input1 != input3) {\n    flag2 = (result4 | input1) == 0;\n  }\n  if (!flag2) {\n    flag2 = (input4 | input3) == 0;\n  }\n  shiftAmount2 = (int)result4 >> 0x15;\n  if (!flag2) {\n    flag2 = shiftAmount2 == -1;\n  }\n  shiftAmount1 = (int)input4 >> 0x15;\n  if (!flag2) {\n    flag2 = shiftAmount1 == -1;\n  }\n  if (flag2) {\n    if (shiftAmount2 == -1 || shiftAmount1 == -1) {\n      result4 = temp1;\n      temp4 = input3;\n      if (shiftAmount2 == -1) {\n        result4 = input2;\n        temp4 = input1;\n      }\n      if (shiftAmount2 != -1 || shiftAmount1 != -1) {\n        input3 = temp4;\n        temp1 = result4;\n      }\n      flag2 = (temp4 | result4 << 0xc) == 0;\n      if (flag2) {\n        flag2 = (input3 | temp1 << 0xc) == 0;\n      }\n      if (flag2) {\n        flag2 = result4 == temp1;\n      }\n      if (!flag2) {\n        result4 = result4 | 0x80000;\n      }\n      return CONCAT44(result4,temp4);\n    }\n    if (((input2 ^ temp1) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((result4 | input1) == 0) {\n        input1 = input3;\n        input2 = temp1;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != temp1) {\n      return 0;\n    }\n    if (result4 >> 0x15 == 0) {\n      flag2 = (input1 & 0x80000000) != 0;\n      temp1 = input2 * 2 + (uint)flag2;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)flag2)) {\n        temp1 = temp1 | 0x80000000;\n      }\n      return CONCAT44(temp1,input1 << 1);\n    }\n    if (result4 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  result4 = result4 >> 0x15;\n  input4 = input4 >> 0x15;\n  temp4 = input4 - result4;\n  flag2 = temp4 != 0;\n  if (input4 < result4) {\n    temp4 = -temp4;\n  }\n  temp3 = input1;\n  temp2 = input2;\n  if (flag2 && result4 <= input4) {\n    result4 = result4 + temp4;\n    temp3 = input3;\n    temp2 = temp1;\n    input3 = input1;\n    temp1 = input2;\n  }\n  if (0x36 < temp4) {\n    return CONCAT44(temp2,temp3);\n  }\n  result2 = temp2 & 0xfffff | 0x100000;\n  if ((temp2 & 0x80000000) != 0) {\n    flag2 = temp3 != 0;\n    temp3 = -temp3;\n    result2 = -result2 - (uint)flag2;\n  }\n  temp2 = temp1 & 0xfffff | 0x100000;\n  if ((temp1 & 0x80000000) != 0) {\n    flag2 = input3 != 0;\n    input3 = -input3;\n    temp2 = -temp2 - (uint)flag2;\n  }\n  if (result4 == temp4) {\n    temp2 = temp2 ^ 0x100000;\n    if (result4 == 0) {\n      result2 = result2 ^ 0x100000;\n      result4 = 1;\n    }\n    else {\n      temp4 = temp4 - 1;\n    }\n  }\n  temp1 = -temp4 + 0x20;\n  if ((int)temp4 < 0x21) {\n    temp5 = input3 << (temp1 & 0xff);\n    input3 = input3 >> (temp4 & 0xff);\n    result1 = temp3 + input3;\n    result3 = temp2 << (temp1 & 0xff);\n    temp1 = result1 + result3;\n    result2 = result2 + CARRY4(temp3,input3) + ((int)temp2 >> (temp4 & 0xff)) +\n            (uint)CARRY4(result1,result3);\n  }\n  else {\n    temp5 = temp2 << (-temp4 + 0x40 & 0xff);\n    if (input3 != 0) {\n      temp5 = temp5 | 2;\n    }\n    temp2 = (int)temp2 >> (temp4 - 0x20 & 0xff);\n    temp1 = temp3 + temp2;\n    result2 = result2 + ((int)temp2 >> 0x1f) + (uint)CARRY4(temp3,temp2);\n  }\n  input2 = result2 & 0x80000000;\n  temp4 = result2;\n  if ((int)result2 < 0) {\n    flag2 = temp5 == 0;\n    temp5 = -temp5;\n    temp4 = -temp1;\n    temp1 = -(uint)!flag2 - temp1;\n    temp4 = -(uint)(flag2 <= temp4) - result2;\n  }\n  if (0xfffff < temp4) {\n    temp3 = result4 - 1;\n    if (0x1fffff < temp4) {\n      temp3 = temp4 & 1;\n      temp4 = temp4 >> 1;\n      carryFlag = (byte)temp1;\n      temp1 = (uint)(temp3 != 0) << 0x1f | temp1 >> 1;\n      temp5 = (uint)(carryFlag & 1) << 0x1f | temp5 >> 1;\n      temp3 = result4;\n      if (0xffbfffff < result4 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    flag2 = 0x7fffffff < temp5;\n    if (temp5 == 0x80000000) {\n      flag2 = (temp1 & 1) != 0;\n    }\n    return CONCAT44(temp4 + temp3 * 0x100000 + (uint)CARRY4(temp1,(uint)flag2) | input2,\n                    temp1 + flag2);\n  }\n  flag1 = (temp5 & 0x80000000) != 0;\n  temp5 = temp5 << 1;\n  temp3 = temp1 * 2;\n  flag2 = CARRY4(temp1,temp1);\n  temp1 = temp1 * 2 + (uint)flag1;\n  temp4 = temp4 * 2 + (uint)(flag2 || CARRY4(temp3,(uint)flag1));\n  temp3 = result4 - 2;\n  if ((temp4 & 0x100000) != 0) goto LAB_08000268;\n  temp2 = temp1;\n  result4 = temp4;\n  if (temp4 == 0) {\n    temp2 = 0;\n    result4 = temp1;\n  }\n  shiftAmount2 = LZCOUNT(result4);\n  if (temp4 == 0) {\n    shiftAmount2 = shiftAmount2 + 0x20;\n  }\n  temp4 = shiftAmount2 - 0xb;\n  flag3 = SBORROW4(temp4,0x20);\n  temp1 = shiftAmount2 - 0x2b;\n  flag2 = (int)temp1 < 0;\n  flag1 = temp1 == 0;\n  if ((int)temp4 < 0x20) {\n    flag3 = SCARRY4(temp1,0xc);\n    shiftAmount2 = shiftAmount2 + -0x1f;\n    flag2 = shiftAmount2 < 0;\n    flag1 = shiftAmount2 == 0;\n    temp1 = temp4;\n    if (!flag1 && flag2 == flag3) {\n      temp2 = result4 << (temp4 & 0xff);\n      result4 = result4 >> (0xcU - shiftAmount2 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (flag1 || flag2 != flag3) {\n    temp5 = 0x20 - temp1;\n  }\n  result4 = result4 << (temp1 & 0xff);\n  if (flag1 || flag2 != flag3) {\n    result4 = result4 | temp2 >> (temp5 & 0xff);\n  }\n  if (flag1 || flag2 != flag3) {\n    temp2 = temp2 << (temp1 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)temp4 <= (int)temp3) {\n    return CONCAT44(result4 + (temp3 - temp4) * 0x100000 | input2,temp2);\n  }\n  temp1 = ~(temp3 - temp4);\n  if ((int)temp1 < 0x1f) {\n    shiftAmount2 = temp1 - 0x13;\n    if (shiftAmount2 != 0 && shiftAmount2 < 0 == SCARRY4(temp1 - 0x1f,0xc)) {\n      return CONCAT44(result2,temp2 >> (0x20 - (0xcU - shiftAmount2) & 0xff) | result4 << (0xcU - shiftAmount2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    temp1 = temp1 + 1;\n    return CONCAT44(input2 | result4 >> (temp1 & 0xff),\n                    temp2 >> (temp1 & 0xff) | result4 << (0x20 - temp1 & 0xff));\n  }\n  return CONCAT44(result2,result4 >> (temp1 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000158": "perform_arithmetic_operations_08000158",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shiftAmount1",
                "bVar2": "carryFlag",
                "uVar3": "result1",
                "uVar4": "result2",
                "uVar5": "result3",
                "uVar6": "temp1",
                "uVar7": "temp2",
                "iVar8": "shiftAmount2",
                "uVar9": "result4",
                "uVar10": "temp3",
                "uVar11": "temp4",
                "uVar12": "temp5",
                "bVar13": "flag1",
                "bVar14": "flag2",
                "bVar15": "flag3"
            },
            "calling": [
                "FUN_080059f0",
                "FUN_08004bd8",
                "FUN_08005e9c",
                "FUN_08005838",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800015c": {
            "entrypoint": "0x0800015c",
            "current_name": "calculate_result_0800015c",
            "code": "\nulonglong calculateResult_0800015c(uint num1,uint num2,uint num3,uint num4)\n\n{\n  int shiftedRightNum2;\n  byte bit;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int shiftedRightNum4;\n  uint shiftedLeftNum2;\n  uint shiftedLeftNum4;\n  uint shiftedLeftNum2WithBit;\n  uint shiftedLeftNum4WithBit;\n  uint shiftedLeftNum2WithSignBit;\n  uint shiftedLeftNum4WithSignBit;\n  bool isSameSign;\n  bool isZero;\n  bool isNegative;\n  \n  shiftedLeftNum2 = num2 << 1;\n  shiftedLeftNum2WithBit = num4 << 1;\n  isSameSign = ((num2 ^ num4) & 0x7fffffff) == 0;\n  isZero = isSameSign && num1 == num3;\n  if (!isSameSign || num1 != num3) {\n    isZero = (shiftedLeftNum2 | num1) == 0;\n  }\n  if (!isZero) {\n    isZero = (shiftedLeftNum2WithBit | num3) == 0;\n  }\n  shiftedRightNum4 = (int)shiftedLeftNum2 >> 0x15;\n  if (!isZero) {\n    isZero = shiftedRightNum4 == -1;\n  }\n  shiftedRightNum2 = (int)shiftedLeftNum2WithBit >> 0x15;\n  if (!isZero) {\n    isZero = shiftedRightNum2 == -1;\n  }\n  if (isZero) {\n    if (shiftedRightNum4 == -1 || shiftedRightNum2 == -1) {\n      shiftedLeftNum2WithBit = num4;\n      shiftedLeftNum2 = num3;\n      if (shiftedRightNum4 == -1) {\n        shiftedLeftNum2WithBit = num2;\n        shiftedLeftNum2 = num1;\n      }\n      if (shiftedRightNum4 != -1 || shiftedRightNum2 != -1) {\n        num3 = shiftedLeftNum2;\n        num4 = shiftedLeftNum2WithBit;\n      }\n      isZero = (shiftedLeftNum2 | shiftedLeftNum2WithBit << 0xc) == 0;\n      if (isZero) {\n        isZero = (num3 | num4 << 0xc) == 0;\n      }\n      if (isZero) {\n        isZero = shiftedLeftNum2WithBit == num4;\n      }\n      if (!isZero) {\n        shiftedLeftNum2WithBit = shiftedLeftNum2WithBit | 0x80000;\n      }\n      return CONCAT44(shiftedLeftNum2WithBit,shiftedLeftNum2);\n    }\n    if (((num2 ^ num4) & 0x7fffffff) != 0 || num1 != num3) {\n      if ((shiftedLeftNum2 | num1) == 0) {\n        num1 = num3;\n        num2 = num4;\n      }\n      return CONCAT44(num2,num1);\n    }\n    if (num2 != num4) {\n      return 0;\n    }\n    if (shiftedLeftNum2 >> 0x15 == 0) {\n      isZero = (num1 & 0x80000000) != 0;\n      shiftedLeftNum2WithBit = num2 * 2 + (uint)isZero;\n      if (CARRY4(num2,num2) || CARRY4(num2 * 2,(uint)isZero)) {\n        shiftedLeftNum2WithBit = shiftedLeftNum2WithBit | 0x80000000;\n      }\n      return CONCAT44(shiftedLeftNum2WithBit,num1 << 1);\n    }\n    if (shiftedLeftNum2 < 0xffc00000) {\n      return CONCAT44(num2 + 0x100000,num1);\n    }\n    num2 = num2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(num2 | 0x7ff00000) << 0x20;\n  }\n  shiftedLeftNum2 = shiftedLeftNum2 >> 0x15;\n  shiftedLeftNum2WithBit = shiftedLeftNum2WithBit >> 0x15;\n  shiftedLeftNum4WithBit = shiftedLeftNum2WithBit - shiftedLeftNum2;\n  isZero = shiftedLeftNum4WithBit != 0;\n  if (shiftedLeftNum2WithBit < shiftedLeftNum2) {\n    shiftedLeftNum4WithBit = -shiftedLeftNum4WithBit;\n  }\n  shiftedLeftNum4 = num1;\n  temp3 = num2;\n  if (isZero && shiftedLeftNum2 <= shiftedLeftNum2WithBit) {\n    shiftedLeftNum2 = shiftedLeftNum2 + shiftedLeftNum4WithBit;\n    shiftedLeftNum4 = num3;\n    temp3 = num4;\n    num3 = num1;\n    num4 = num2;\n  }\n  if (0x36 < shiftedLeftNum4WithBit) {\n    return CONCAT44(temp3,shiftedLeftNum4);\n  }\n  shiftedLeftNum2WithBit = temp3 & 0xfffff | 0x100000;\n  if ((temp3 & 0x80000000) != 0) {\n    isZero = shiftedLeftNum4 != 0;\n    shiftedLeftNum4 = -shiftedLeftNum4;\n    shiftedLeftNum2WithBit = -shiftedLeftNum2WithBit - (uint)isZero;\n  }\n  temp3 = num4 & 0xfffff | 0x100000;\n  if ((num4 & 0x80000000) != 0) {\n    isZero = num3 != 0;\n    num3 = -num3;\n    temp3 = -temp3 - (uint)isZero;\n  }\n  if (shiftedLeftNum2 == shiftedLeftNum4WithBit) {\n    temp3 = temp3 ^ 0x100000;\n    if (shiftedLeftNum2 == 0) {\n      shiftedLeftNum2WithBit = shiftedLeftNum2WithBit ^ 0x100000;\n      shiftedLeftNum2 = 1;\n    }\n    else {\n      shiftedLeftNum4WithBit = shiftedLeftNum4WithBit - 1;\n    }\n  }\n  shiftedLeftNum4WithSignBit = -shiftedLeftNum4WithBit + 0x20;\n  if ((int)shiftedLeftNum4WithBit < 0x21) {\n    shiftedLeftNum2WithSignBit = num3 << (shiftedLeftNum4WithSignBit & 0xff);\n    num3 = num3 >> (shiftedLeftNum4WithBit & 0xff);\n    temp1 = shiftedLeftNum4 + num3;\n    temp2 = temp3 << (shiftedLeftNum4WithSignBit & 0xff);\n    shiftedLeftNum4WithSignBit = temp1 + temp2;\n    shiftedLeftNum2WithBit = shiftedLeftNum2WithBit + CARRY4(shiftedLeftNum4,num3) + ((int)temp3 >> (shiftedLeftNum4WithBit & 0xff)) +\n            (uint)CARRY4(temp1,temp2);\n  }\n  else {\n    shiftedLeftNum2WithSignBit = temp3 << (-shiftedLeftNum4WithBit + 0x40 & 0xff);\n    if (num3 != 0) {\n      shiftedLeftNum2WithSignBit = shiftedLeftNum2WithSignBit | 2;\n    }\n    temp3 = (int)temp3 >> (shiftedLeftNum4WithBit - 0x20 & 0xff);\n    shiftedLeftNum4WithSignBit = shiftedLeftNum4 + temp3;\n    shiftedLeftNum2WithBit = shiftedLeftNum2WithBit + ((int)temp3 >> 0x1f) + (uint)CARRY4(shiftedLeftNum4,temp3);\n  }\n  num2 = shiftedLeftNum2WithBit & 0x80000000;\n  shiftedLeftNum4WithBit = shiftedLeftNum2WithBit;\n  if ((int)shiftedLeftNum2WithBit < 0) {\n    isZero = shiftedLeftNum2WithSignBit == 0;\n    shiftedLeftNum2WithSignBit = -shiftedLeftNum2WithSignBit;\n    shiftedLeftNum4WithBit = -shiftedLeftNum4WithSignBit;\n    shiftedLeftNum4WithSignBit = -(uint)!isZero - shiftedLeftNum4WithSignBit;\n    shiftedLeftNum4WithBit = -(uint)(isZero <= shiftedLeftNum4WithBit) - shiftedLeftNum2WithBit;\n  }\n  if (0xfffff < shiftedLeftNum4WithBit) {\n    shiftedLeftNum4 = shiftedLeftNum2 - 1;\n    if (0x1fffff < shiftedLeftNum4WithBit) {\n      shiftedLeftNum2WithBit = shiftedLeftNum4WithBit & 1;\n      shiftedLeftNum4WithBit = shiftedLeftNum4WithBit >> 1;\n      bit = (byte)shiftedLeftNum4WithSignBit;\n      shiftedLeftNum4WithSignBit = (uint)(shiftedLeftNum2WithBit != 0) << 0x1f | shiftedLeftNum4WithSignBit >> 1;\n      shiftedLeftNum2WithSignBit = (uint)(bit & 1) << 0x1f | shiftedLeftNum2WithSignBit >> 1;\n      shiftedLeftNum4 = shiftedLeftNum2;\n      if (0xffbfffff < shiftedLeftNum2 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    isZero = 0x7fffffff < shiftedLeftNum2WithSignBit;\n    if (shiftedLeftNum2WithSignBit == 0x80000000) {\n      isZero = (shiftedLeftNum4WithSignBit & 1) != 0;\n    }\n    return CONCAT44(shiftedLeftNum4WithBit + shiftedLeftNum4 * 0x100000 + (uint)CARRY4(shiftedLeftNum4WithSignBit,(uint)isZero) | num2,\n                    shiftedLeftNum4WithSignBit + isZero);\n  }\n  isSameSign = (shiftedLeftNum2WithSignBit & 0x80000000) != 0;\n  shiftedLeftNum2WithSignBit = shiftedLeftNum2WithSignBit << 1;\n  shiftedLeftNum4 = shiftedLeftNum4WithSignBit * 2;\n  isZero = CARRY4(shiftedLeftNum4WithSignBit,shiftedLeftNum4WithSignBit);\n  shiftedLeftNum4WithSignBit = shiftedLeftNum4WithSignBit * 2 + (uint)isSameSign;\n  shiftedLeftNum4WithBit = shiftedLeftNum4WithBit * 2 + (uint)(isZero || CARRY4(shiftedLeftNum4,(uint)isSameSign));\n  shiftedLeftNum4 = shiftedLeftNum2 - 2;\n  if ((shiftedLeftNum4WithBit & 0x100000) != 0) goto LAB_08000268;\n  temp3 = shiftedLeftNum4WithSignBit;\n  shiftedLeftNum2 = shiftedLeftNum4WithBit;\n  if (shiftedLeftNum4WithBit == 0) {\n    temp3 = 0;\n    shiftedLeftNum2 = shiftedLeftNum4WithSignBit;\n  }\n  shiftedRightNum4 = LZCOUNT(shiftedLeftNum2);\n  if (shiftedLeftNum4WithBit == 0) {\n    shiftedRightNum4 = shiftedRightNum4 + 0x20;\n  }\n  shiftedLeftNum4WithSignBit = shiftedRightNum4 - 0xb;\n  isNegative = SBORROW4(shiftedLeftNum4WithSignBit,0x20);\n  shiftedLeftNum4WithBit = shiftedRightNum4 - 0x2b;\n  isZero = (int)shiftedLeftNum4WithBit < 0;\n  isSameSign = shiftedLeftNum4WithBit == 0;\n  if ((int)shiftedLeftNum4WithSignBit < 0x20) {\n    isNegative = SCARRY4(shiftedLeftNum4WithBit,0xc);\n    shiftedRightNum4 = shiftedRightNum4 + -0x1f;\n    isZero = shiftedRightNum4 < 0;\n    isSameSign = shiftedRightNum4 == 0;\n    shiftedLeftNum4WithBit = shiftedLeftNum4WithSignBit;\n    if (!isSameSign && isZero == isNegative) {\n      temp3 = shiftedLeftNum2 << (shiftedLeftNum4WithSignBit & 0xff);\n      shiftedLeftNum2 = shiftedLeftNum2 >> (0xcU - shiftedRightNum4 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isSameSign || isZero != isNegative) {\n    shiftedLeftNum2WithSignBit = 0x20 - shiftedLeftNum4WithBit;\n  }\n  shiftedLeftNum2 = shiftedLeftNum2 << (shiftedLeftNum4WithBit & 0xff);\n  if (isSameSign || isZero != isNegative) {\n    shiftedLeftNum2 = shiftedLeftNum2 | temp3 >> (shiftedLeftNum2WithSignBit & 0xff);\n  }\n  if (isSameSign || isZero != isNegative) {\n    temp3 = temp3 << (shiftedLeftNum4WithBit & 0xff);\n  }\nLAB_080002e0:\n  if ((int)shiftedLeftNum4WithSignBit <= (int)shiftedLeftNum4) {\n    return CONCAT44(shiftedLeftNum2 + (shiftedLeftNum4 - shiftedLeftNum4WithSignBit) * 0x100000 | num2,temp3);\n  }\n  shiftedLeftNum4WithBit = ~(shiftedLeftNum4 - shiftedLeftNum4WithSignBit);\n  if ((int)shiftedLeftNum4WithBit < 0x1f) {\n    shiftedRightNum4 = shiftedLeftNum4WithBit - 0x13;\n    if (shiftedRightNum4 != 0 && shiftedRightNum4 < 0 == SCARRY4(shiftedLeftNum4WithBit - 0x1f,0xc)) {\n      return CONCAT44(shiftedLeftNum2WithBit,temp3 >> (0x20 - (0xcU - shiftedRightNum4) & 0xff) | shiftedLeftNum2 << (0xcU - shiftedRightNum4 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    shiftedLeftNum4WithBit = shiftedLeftNum4WithBit + 1;\n    return CONCAT44(num2 | shiftedLeftNum2 >> (shiftedLeftNum4WithBit & 0xff),\n                    temp3 >> (shiftedLeftNum4WithBit & 0xff) | shiftedLeftNum2 << (0x20 - shiftedLeftNum4WithBit & 0xff));\n  }\n  return CONCAT44(shiftedLeftNum2WithBit,shiftedLeftNum2 >> (shiftedLeftNum4WithBit - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800015c": "calculate_result_0800015c",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "num3",
                "param_4": "num4",
                "iVar1": "shiftedRightNum2",
                "bVar2": "bit",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "iVar6": "shiftedRightNum4",
                "uVar7": "shiftedLeftNum2",
                "uVar8": "shiftedLeftNum4",
                "uVar9": "shiftedLeftNum2WithBit",
                "uVar10": "shiftedLeftNum4WithBit",
                "uVar11": "shiftedLeftNum2WithSignBit",
                "uVar12": "shiftedLeftNum4WithSignBit",
                "bVar13": "isSameSign",
                "bVar14": "isZero",
                "bVar15": "isNegative"
            },
            "calling": [
                "FUN_080059f0",
                "FUN_08004bd8",
                "FUN_08005838",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003d4": {
            "entrypoint": "0x080003d4",
            "current_name": "reverse_bits_and_shift_080003d4",
            "code": "\nulonglong reverseBitsAndShift_080003d4(uint input)\n\n{\n  uint result1;\n  uint result2;\n  int bitCount;\n  uint shiftAmount;\n  uint temp;\n  bool isNegative;\n  bool isZero;\n  bool isNegativeOverflow;\n  \n  if (input == 0) {\n    return 0;\n  }\n  result1 = 0;\n  bitCount = LZCOUNT(input);\n  shiftAmount = bitCount + 0x15;\n  isNegativeOverflow = SBORROW4(shiftAmount,0x20);\n  result2 = bitCount - 0xb;\n  isNegative = (int)result2 < 0;\n  isZero = result2 == 0;\n  if (shiftAmount < 0x20) {\n    isNegativeOverflow = SCARRY4(result2,0xc);\n    isNegative = false;\n    isZero = bitCount + 1 == 0;\n    result2 = shiftAmount;\n    if (!isZero && isNegativeOverflow == false) {\n      result1 = input << shiftAmount;\n      input = input >> (0xcU - (bitCount + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isZero || isNegative != isNegativeOverflow) {\n    temp = 0x20 - result2;\n  }\n  input = input << (result2 & 0xff);\n  if (isZero || isNegative != isNegativeOverflow) {\n    input = input | 0U >> (temp & 0xff);\n  }\n  if (isZero || isNegative != isNegativeOverflow) {\n    result1 = 0 << (result2 & 0xff);\n  }\nLAB_080002e0:\n  if (shiftAmount < 0x433) {\n    return CONCAT44(input + (0x432 - shiftAmount) * 0x100000,result1);\n  }\n  result2 = ~(0x432 - shiftAmount);\n  if (0x1e < (int)result2) {\n    return (ulonglong)(input >> (result2 - 0x1f & 0xff));\n  }\n  bitCount = result2 - 0x13;\n  if (bitCount == 0 || bitCount < 0 != SCARRY4(result2 - 0x1f,0xc)) {\n    result2 = result2 + 1;\n    return CONCAT44(input >> (result2 & 0xff),\n                    result1 >> (result2 & 0xff) | input << (0x20 - result2 & 0xff));\n  }\n  return (ulonglong)(result1 >> (0x20 - (0xcU - bitCount) & 0xff) | input << (0xcU - bitCount & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080003d4": "reverse_bits_and_shift_080003d4",
                "param_1": "input",
                "uVar1": "result1",
                "uVar2": "result2",
                "iVar3": "bitCount",
                "uVar4": "shiftAmount",
                "in_r12": "temp",
                "bVar5": "isNegative",
                "bVar6": "isZero",
                "bVar7": "isNegativeOverflow"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003f4": {
            "entrypoint": "0x080003f4",
            "current_name": "calculate_shifted_value_080003f4",
            "code": "\nulonglong calculate_shifted_value_080003f4(uint input)\n\n{\n  uint result;\n  uint absolute_value;\n  uint shift_amount;\n  int leading_zeros;\n  uint adjusted_shift;\n  uint input_sign;\n  uint shift_mask;\n  bool negative_shift;\n  bool zero_shift;\n  bool carry_flag;\n  \n  if (input == 0) {\n    return 0;\n  }\n  input_sign = input & 0x80000000;\n  absolute_value = input;\n  if ((int)input_sign < 0) {\n    absolute_value = -input;\n  }\n  result = 0;\n  leading_zeros = count_leading_zeros(absolute_value);\n  adjusted_shift = leading_zeros + 0x15;\n  carry_flag = subtract_carry_flag(adjusted_shift,0x20);\n  shift_amount = leading_zeros - 0xb;\n  negative_shift = (int)shift_amount < 0;\n  zero_shift = shift_amount == 0;\n  if (adjusted_shift < 0x20) {\n    carry_flag = subtract_overflow_flag(shift_amount,0xc);\n    negative_shift = false;\n    zero_shift = leading_zeros + 1 == 0;\n    shift_amount = adjusted_shift;\n    if (!zero_shift && carry_flag == false) {\n      result = absolute_value << adjusted_shift;\n      absolute_value = absolute_value >> (0xcU - (leading_zeros + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (zero_shift || negative_shift != carry_flag) {\n    shift_mask = 0x20 - shift_amount;\n  }\n  absolute_value = absolute_value << (shift_amount & 0xff);\n  if (zero_shift || negative_shift != carry_flag) {\n    absolute_value = absolute_value | 0U >> (shift_mask & 0xff);\n  }\n  if (zero_shift || negative_shift != carry_flag) {\n    result = 0 << (shift_amount & 0xff);\n  }\nLAB_080002e0:\n  if (adjusted_shift < 0x433) {\n    return CONCAT44(absolute_value + (0x432 - adjusted_shift) * 0x100000 | input_sign,result);\n  }\n  shift_amount = ~(0x432 - adjusted_shift);\n  if (0x1e < (int)shift_amount) {\n    return CONCAT44(input,absolute_value >> (shift_amount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leading_zeros = shift_amount - 0x13;\n  if (leading_zeros == 0 || leading_zeros < 0 != subtract_overflow_flag(shift_amount - 0x1f,0xc)) {\n    shift_amount = shift_amount + 1;\n    return CONCAT44(input_sign | absolute_value >> (shift_amount & 0xff),\n                    result >> (shift_amount & 0xff) | absolute_value << (0x20 - shift_amount & 0xff));\n  }\n  return CONCAT44(input,result >> (0x20 - (0xcU - leading_zeros) & 0xff) | absolute_value << (0xcU - leading_zeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_080003f4": "calculate_shifted_value_080003f4",
                "param_1": "input",
                "uVar1": "result",
                "uVar2": "absolute_value",
                "uVar3": "shift_amount",
                "iVar4": "leading_zeros",
                "uVar5": "adjusted_shift",
                "uVar6": "input_sign",
                "in_r12": "shift_mask",
                "bVar7": "negative_shift",
                "bVar8": "zero_shift",
                "bVar9": "carry_flag",
                "LZCOUNT": "count_leading_zeros",
                "SBORROW4": "subtract_carry_flag",
                "SCARRY4": "subtract_overflow_flag"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000418": {
            "entrypoint": "0x08000418",
            "current_name": "calculate_shifted_value_08000418",
            "code": "\nulonglong calculateShiftedValue_08000418(uint input,undefined4 parameter2,undefined4 parameter3,uint parameter4)\n\n{\n  uint shiftedInput;\n  uint temporaryValue;\n  uint combinedValue;\n  uint shiftAmount;\n  uint shiftedInputScaled;\n  int shiftedAmount;\n  uint adjustedAmount;\n  uint remainder;\n  bool isShiftedAmountZero;\n  bool isParam4Zero;\n  bool overflow;\n  \n  shiftedInputScaled = input << 1;\n  isParam4Zero = shiftedInputScaled == 0;\n  shiftedInput = (uint)((input & 0x80000000) != 0) << 0x1f;\n  shiftAmount = (uint)((int)shiftedInputScaled >> 3) >> 1;\n  combinedValue = shiftedInput | shiftAmount;\n  input = input << 0x1d;\n  if (!isParam4Zero) {\n    parameter4 = shiftedInputScaled & 0xff000000;\n    isParam4Zero = parameter4 == 0;\n  }\n  if (!isParam4Zero) {\n    isParam4Zero = parameter4 == 0xff000000;\n  }\n  if (!isParam4Zero) {\n    return CONCAT44(combinedValue,input) ^ 0x3800000000000000;\n  }\n  if ((shiftedInputScaled & 0xffffff) == 0) {\n    return CONCAT44(combinedValue,input);\n  }\n  if (parameter4 == 0xff000000) {\n    return CONCAT44(combinedValue,input) | 0x8000000000000;\n  }\n  temporaryValue = input;\n  shiftedInputScaled = shiftAmount;\n  if (shiftAmount == 0) {\n    temporaryValue = 0;\n    shiftedInputScaled = input;\n  }\n  shiftedAmount = LZCOUNT(shiftedInputScaled);\n  if (shiftAmount == 0) {\n    shiftedAmount = shiftedAmount + 0x20;\n  }\n  adjustedAmount = shiftedAmount - 0xb;\n  overflow = SBORROW4(adjustedAmount,0x20);\n  shiftAmount = shiftedAmount - 0x2b;\n  isParam4Zero = (int)shiftAmount < 0;\n  isShiftedAmountZero = shiftAmount == 0;\n  if ((int)adjustedAmount < 0x20) {\n    overflow = SCARRY4(shiftAmount,0xc);\n    shiftedAmount = shiftedAmount + -0x1f;\n    isParam4Zero = shiftedAmount < 0;\n    isShiftedAmountZero = shiftedAmount == 0;\n    shiftAmount = adjustedAmount;\n    if (!isShiftedAmountZero && isParam4Zero == overflow) {\n      temporaryValue = shiftedInputScaled << (adjustedAmount & 0xff);\n      shiftedInputScaled = shiftedInputScaled >> (0xcU - shiftedAmount & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isShiftedAmountZero || isParam4Zero != overflow) {\n    remainder = 0x20 - shiftAmount;\n  }\n  shiftedInputScaled = shiftedInputScaled << (shiftAmount & 0xff);\n  if (isShiftedAmountZero || isParam4Zero != overflow) {\n    shiftedInputScaled = shiftedInputScaled | temporaryValue >> (remainder & 0xff);\n  }\n  if (isShiftedAmountZero || isParam4Zero != overflow) {\n    temporaryValue = temporaryValue << (shiftAmount & 0xff);\n  }\nLAB_080002e0:\n  if ((int)adjustedAmount < 0x381) {\n    return CONCAT44(shiftedInputScaled + (0x380 - adjustedAmount) * 0x100000 | shiftedInput,temporaryValue);\n  }\n  shiftAmount = ~(0x380 - adjustedAmount);\n  if (0x1e < (int)shiftAmount) {\n    return CONCAT44(combinedValue,shiftedInputScaled >> (shiftAmount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  shiftedAmount = shiftAmount - 0x13;\n  if (shiftedAmount == 0 || shiftedAmount < 0 != SCARRY4(shiftAmount - 0x1f,0xc)) {\n    shiftAmount = shiftAmount + 1;\n    return CONCAT44(shiftedInput | shiftedInputScaled >> (shiftAmount & 0xff),\n                    temporaryValue >> (shiftAmount & 0xff) | shiftedInputScaled << (0x20 - shiftAmount & 0xff));\n  }\n  return CONCAT44(combinedValue,temporaryValue >> (0x20 - (0xcU - shiftedAmount) & 0xff) | shiftedInputScaled << (0xcU - shiftedAmount & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000418": "calculate_shifted_value_08000418",
                "param_1": "input",
                "param_2": "parameter2",
                "param_3": "parameter3",
                "param_4": "parameter4",
                "uVar1": "shiftedInput",
                "uVar2": "temporaryValue",
                "uVar3": "combinedValue",
                "uVar4": "shiftAmount",
                "uVar5": "shiftedInputScaled",
                "iVar6": "shiftedAmount",
                "uVar7": "adjustedAmount",
                "in_r12": "remainder",
                "bVar8": "isShiftedAmountZero",
                "bVar9": "isParam4Zero",
                "bVar10": "overflow"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_08004bd8",
                "FUN_08004d78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004c8": {
            "entrypoint": "0x080004c8",
            "current_name": "calculate_result_080004c8",
            "code": "\nulonglong calculate_result_080004c8(undefined4 input1,uint input2,uint input3,uint input4)\n\n{\n  ulonglong temp1;\n  longlong temp2;\n  uint temp3;\n  uint temp4;\n  int temp5;\n  uint temp6;\n  uint temp7;\n  uint temp8;\n  uint temp9;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  ulonglong result;\n  \n  result = CONCAT44(input2,input1);\n  temp8 = 0x7ff;\n  temp4 = input2 >> 0x14 & 0x7ff;\n  flag1 = temp4 == 0;\n  if (!flag1) {\n    temp7 = input4 >> 0x14 & 0x7ff;\n    flag1 = temp7 == 0;\n  }\n  if (!flag1) {\n    flag1 = temp4 == 0x7ff;\n  }\n  if (!flag1) {\n    flag1 = temp7 == 0x7ff;\n  }\n  if (flag1) {\n    result = calculate_bitwise_result_080006a4();\n  }\n  temp3 = (uint)(result >> 0x20);\n  temp5 = temp4 + temp7;\n  temp4 = temp3 ^ input4;\n  temp3 = temp3 & ~(temp8 << 0x15);\n  input4 = input4 & ~(temp8 << 0x15);\n  flag1 = ((uint)result | temp3 << 0xc) == 0;\n  if (!flag1) {\n    flag1 = (input3 | input4 << 0xc) == 0;\n  }\n  temp3 = temp3 | 0x100000;\n  input4 = input4 | 0x100000;\n  if (flag1) {\n    input3 = (uint)result | input3;\n    input4 = (temp4 & 0x80000000 | temp3) ^ input4;\n    temp4 = temp8 >> 1;\n    flag3 = SBORROW4(temp5,temp4);\n    temp6 = temp5 - temp4;\n    flag1 = temp6 == 0;\n    temp3 = temp6;\n    if (!flag1 && (int)temp4 <= temp5) {\n      flag3 = SBORROW4(temp8,temp6);\n      temp3 = temp8 - temp6;\n      flag1 = temp8 == temp6;\n    }\n    if (!flag1 && (int)temp3 < 0 == flag3) {\n      input4 = input4 | temp6 * 0x100000;\n    }\n    if (!flag1 && (int)temp3 < 0 == flag3) {\n      return CONCAT44(input4,input3);\n    }\n    input4 = input4 | 0x100000;\n    temp8 = 0;\n    flag3 = SBORROW4(temp6,1);\n    temp6 = temp6 - 1;\n    flag1 = temp6 == 0;\n    temp4 = temp6;\n  }\n  else {\n    temp1 = (result & 0xffffffff) * (ulonglong)input3;\n    result = (result & 0xffffffff) * (ulonglong)input4 +\n             (ulonglong)temp3 * (ulonglong)input3 + (temp1 >> 0x20);\n    temp9 = (uint)result;\n    temp2 = (ulonglong)temp3 * (ulonglong)input4 + (result >> 0x20);\n    temp8 = (uint)temp2;\n    temp3 = (uint)((ulonglong)temp2 >> 0x20);\n    if ((int)temp1 != 0) {\n      temp9 = temp9 | 1;\n    }\n    temp6 = (temp5 + -0x3ff) - (uint)(temp3 < 0x200);\n    if (temp3 < 0x200) {\n      flag1 = (temp9 & 0x80000000) != 0;\n      temp9 = temp9 << 1;\n      temp2 = CONCAT44(temp3 * 2 + (uint)(CARRY4(temp8,temp8) || CARRY4(temp8 * 2,(uint)flag1)),\n                       temp8 * 2 + (uint)flag1);\n    }\n    input4 = temp4 & 0x80000000 | (int)((ulonglong)temp2 >> 0x20) << 0xb | (uint)temp2 >> 0x15;\n    input3 = (uint)temp2 << 0xb | temp9 >> 0x15;\n    temp8 = temp9 * 0x800;\n    flag2 = 0xfc < temp6;\n    flag3 = SBORROW4(temp6,0xfd);\n    temp3 = temp6 - 0xfd;\n    flag1 = temp3 == 0;\n    temp4 = temp3;\n    if (flag2 && !flag1) {\n      flag2 = 0x6ff < temp3;\n      flag3 = SBORROW4(temp3,0x700);\n      temp4 = temp6 - 0x7fd;\n      flag1 = temp3 == 0x700;\n    }\n    if (!flag2 || flag1) {\n      flag1 = 0x7fffffff < temp8;\n      if (temp8 == 0x80000000) {\n        flag1 = (temp9 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(input4 + temp6 * 0x100000 + (uint)CARRY4(input3,(uint)flag1),input3 + flag1\n                     );\n    }\n  }\n  if (!flag1 && (int)temp4 < 0 == flag3) {\n    return (ulonglong)(input4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag2 = SCARRY4(temp6,0x36);\n  flag1 = (int)(temp6 + 0x36) < 0;\n  flag3 = temp6 == 0xffffffca;\n  if (flag3 || flag1 != flag2) {\n    input3 = 0;\n  }\n  if (flag3 || flag1 != flag2) {\n    input4 = input4 & 0x80000000;\n  }\n  if (flag3 || flag1 != flag2) {\n    return CONCAT44(input4,input3);\n  }\n  temp4 = -temp6;\n  temp3 = temp4 - 0x20;\n  if (0x1f < (int)temp4) {\n    temp6 = input3 >> (temp3 & 0xff) | input4 << (0x20 - temp3 & 0xff);\n    temp4 = (input4 >> (temp3 & 0xff) & ~((input4 & 0x80000000) >> (temp3 & 0xff))) -\n            ((int)temp6 >> 0x1f);\n    if ((temp8 | input3 << (0x20 - temp3 & 0xff) | temp6 << 1) == 0) {\n      temp4 = temp4 & ~(temp6 >> 0x1f);\n    }\n    return CONCAT44(input4,temp4) & 0x80000000ffffffff;\n  }\n  temp5 = temp4 - 0x14;\n  if (temp5 == 0 || temp5 < 0 != SCARRY4(temp3,0xc)) {\n    temp9 = input3 << (temp6 + 0x20 & 0xff);\n    temp3 = input3 >> (temp4 & 0xff) | input4 << (temp6 + 0x20 & 0xff);\n    temp6 = temp3 + -((int)temp9 >> 0x1f);\n    if ((temp8 | temp9 << 1) == 0) {\n      temp6 = temp6 & ~(temp9 >> 0x1f);\n    }\n    return CONCAT44((input4 & 0x80000000) +\n                    ((input4 & 0x7fffffff) >> (temp4 & 0xff)) +\n                    (uint)CARRY4(temp3,-((int)temp9 >> 0x1f)),temp6);\n  }\n  temp4 = 0xc - temp5;\n  temp6 = input3 << (temp4 & 0xff);\n  temp4 = input3 >> (0x20 - temp4 & 0xff) | input4 << (temp4 & 0xff);\n  temp3 = temp4 + -((int)temp6 >> 0x1f);\n  if ((temp8 | temp6 << 1) == 0) {\n    temp3 = temp3 & ~(temp6 >> 0x1f);\n  }\n  return CONCAT44((input4 & 0x80000000) + (uint)CARRY4(temp4,-((int)temp6 >> 0x1f)),temp3);\n}\n\n",
            "renaming": {
                "FUN_080004c8": "calculate_result_080004c8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "temp1",
                "lVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "iVar5": "temp5",
                "uVar6": "temp6",
                "unaff_r5": "temp7",
                "uVar7": "temp8",
                "uVar8": "temp9",
                "bVar9": "flag1",
                "bVar10": "flag2",
                "bVar11": "flag3",
                "uVar12": "result"
            },
            "calling": [
                "FUN_080059f0",
                "FUN_08004bd8",
                "FUN_08005e9c",
                "FUN_080096e0",
                "FUN_08004d78",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080006a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006a4": {
            "entrypoint": "0x080006a4",
            "current_name": "calculate_bitwise_result_080006a4",
            "code": "\nulonglong calculate_bitwise_result_080006a4(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint bit_1;\n  uint bit_2;\n  uint bit_3;\n  uint bit_4;\n  uint bit_5;\n  bool is_zero;\n  \n  bit_3 = bit_5 & input_4 >> 0x14;\n  if (bit_2 != bit_5 && bit_3 != bit_5) {\n    is_zero = (input_1 | input_2 << 1) == 0;\n    if (!is_zero) {\n      is_zero = (input_3 | input_4 << 1) == 0;\n    }\n    if (is_zero) {\n      return (ulonglong)((input_2 ^ input_4) & 0x80000000) << 0x20;\n    }\n    if (bit_2 == 0) {\n      bit_4 = input_2 & 0x80000000;\n      do {\n        bit_1 = input_1 & 0x80000000;\n        input_1 = input_1 << 1;\n        input_2 = input_2 * 2 + (uint)(bit_1 != 0);\n      } while ((input_2 & 0x100000) == 0);\n      input_2 = input_2 | bit_4;\n      if (bit_3 != 0) {\n        return CONCAT44(input_2,input_1);\n      }\n    }\n    do {\n      bit_3 = input_3 & 0x80000000;\n      input_3 = input_3 << 1;\n      input_4 = input_4 * 2 + (uint)(bit_3 != 0);\n    } while ((input_4 & 0x100000) == 0);\n    return CONCAT44(input_2,input_1);\n  }\n  is_zero = (input_1 | input_2 << 1) == 0;\n  if (is_zero) {\n    input_2 = input_4;\n    input_1 = input_3;\n  }\n  if (!is_zero) {\n    is_zero = (input_3 | input_4 << 1) == 0;\n  }\n  bit_4 = input_2;\n  if (((!is_zero) && ((bit_2 != bit_5 || ((input_1 | input_2 << 0xc) == 0)))) &&\n     ((bit_3 != bit_5 || (input_1 = input_3, bit_4 = input_4, (input_3 | input_4 << 0xc) == 0)))) {\n    return (ulonglong)((input_2 ^ input_4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(bit_4,input_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006a4": "calculate_bitwise_result_080006a4",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "bit_1",
                "unaff_r4": "bit_2",
                "uVar2": "bit_3",
                "uVar3": "bit_4",
                "in_r12": "bit_5",
                "bVar4": "is_zero"
            },
            "calling": [
                "FUN_080004c8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800071c": {
            "entrypoint": "0x0800071c",
            "current_name": "calculate_float_value_0800071c",
            "code": "\nulonglong calculate_float_value_0800071c(undefined4 input_param_1,uint input_param_2,uint input_param_3,uint input_param_4)\n\n{\n  uint temp_var_1;\n  uint temp_var_2;\n  uint temp_var_3;\n  uint temp_var_4;\n  uint temp_var_5;\n  uint temp_var_6;\n  uint temp_var_7;\n  int temp_var_8;\n  uint temp_var_9;\n  uint unaff_r5;\n  uint temp_var_10;\n  uint temp_var_11;\n  uint temp_var_12;\n  uint temp_var_13;\n  bool temp_var_14;\n  bool temp_var_15;\n  bool temp_var_16;\n  undefined8 temp_var_17;\n  \n  temp_var_17 = CONCAT44(input_param_2,input_param_1);\n  temp_var_13 = 0x7ff;\n  temp_var_7 = input_param_2 >> 0x14 & 0x7ff;\n  temp_var_14 = temp_var_7 == 0;\n  if (!temp_var_14) {\n    unaff_r5 = input_param_4 >> 0x14 & 0x7ff;\n    temp_var_14 = unaff_r5 == 0;\n  }\n  if (!temp_var_14) {\n    temp_var_14 = temp_var_7 == 0x7ff;\n  }\n  if (!temp_var_14) {\n    temp_var_14 = unaff_r5 == 0x7ff;\n  }\n  if (temp_var_14) {\n    temp_var_17 = calculate_float_value_0800071c_0800088a();\n  }\n  temp_var_9 = (uint)((ulonglong)temp_var_17 >> 0x20);\n  temp_var_11 = (uint)temp_var_17;\n  temp_var_8 = temp_var_7 - unaff_r5;\n  if ((input_param_3 | input_param_4 << 0xc) == 0) {\n    temp_var_7 = (temp_var_9 ^ input_param_4) & 0x80000000 | temp_var_9 & 0xfffff;\n    temp_var_16 = SCARRY4(temp_var_8,temp_var_13 >> 1);\n    temp_var_9 = temp_var_8 + (temp_var_13 >> 1);\n    temp_var_14 = (int)temp_var_9 < 0;\n    temp_var_15 = temp_var_9 == 0;\n    if (!temp_var_15 && temp_var_14 == temp_var_16) {\n      temp_var_16 = SBORROW4(temp_var_13,temp_var_9);\n      temp_var_14 = (int)(temp_var_13 - temp_var_9) < 0;\n      temp_var_15 = temp_var_13 == temp_var_9;\n    }\n    if (!temp_var_15 && temp_var_14 == temp_var_16) {\n      temp_var_7 = temp_var_7 | temp_var_9 * 0x100000;\n    }\n    if (!temp_var_15 && temp_var_14 == temp_var_16) {\n      return CONCAT44(temp_var_7,temp_var_11);\n    }\n    temp_var_7 = temp_var_7 | 0x100000;\n    temp_var_13 = 0;\n    temp_var_15 = SBORROW4(temp_var_9,1);\n    temp_var_9 = temp_var_9 - 1;\n    temp_var_14 = temp_var_9 == 0;\n    temp_var_3 = temp_var_9;\n  }\n  else {\n    temp_var_3 = (input_param_4 << 0xc) >> 4 | 0x10000000 | input_param_3 >> 0x18;\n    temp_var_13 = input_param_3 << 8;\n    temp_var_10 = (temp_var_9 << 0xc) >> 4 | 0x10000000 | temp_var_11 >> 0x18;\n    temp_var_11 = temp_var_11 * 0x100;\n    temp_var_7 = (temp_var_9 ^ input_param_4) & 0x80000000;\n    temp_var_14 = temp_var_3 <= temp_var_10;\n    if (temp_var_10 == temp_var_3) {\n      temp_var_14 = temp_var_13 <= temp_var_11;\n    }\n    temp_var_8 = temp_var_8 + (uint)temp_var_14;\n    temp_var_9 = temp_var_8 + 0x3fd;\n    if (temp_var_14 == false) {\n      temp_var_3 = temp_var_3 >> 1;\n      temp_var_13 = (uint)((input_param_3 >> 0x18 & 1) != 0) << 0x1f | temp_var_13 >> 1;\n    }\n    temp_var_12 = temp_var_11 - temp_var_13;\n    temp_var_10 = (temp_var_10 - temp_var_3) - (uint)(temp_var_11 < temp_var_13);\n    temp_var_4 = temp_var_3 >> 1;\n    temp_var_1 = (uint)((temp_var_3 & 1) != 0) << 0x1f | temp_var_13 >> 1;\n    temp_var_11 = 0x100000;\n    temp_var_3 = 0x80000;\n    while( true ) {\n      temp_var_14 = temp_var_1 <= temp_var_12;\n      if (temp_var_4 < temp_var_10 || temp_var_10 - temp_var_4 < (uint)temp_var_14) {\n        temp_var_12 = temp_var_12 - temp_var_1;\n        temp_var_11 = temp_var_11 | temp_var_3;\n        temp_var_10 = (temp_var_10 - temp_var_4) - (uint)!temp_var_14;\n      }\n      temp_var_5 = temp_var_4 >> 1;\n      temp_var_1 = (uint)((temp_var_4 & 1) != 0) << 0x1f | temp_var_1 >> 1;\n      temp_var_15 = temp_var_1 <= temp_var_12;\n      temp_var_14 = temp_var_10 - temp_var_5 < (uint)temp_var_15;\n      temp_var_13 = temp_var_10;\n      if (temp_var_5 < temp_var_10 || temp_var_14) {\n        temp_var_12 = temp_var_12 - temp_var_1;\n        temp_var_13 = (temp_var_10 - temp_var_5) - (uint)!temp_var_15;\n      }\n      if (temp_var_5 < temp_var_10 || temp_var_14) {\n        temp_var_11 = temp_var_11 | temp_var_3 >> 1;\n      }\n      temp_var_10 = temp_var_4 >> 2;\n      temp_var_2 = (uint)((temp_var_5 & 1) != 0) << 0x1f | temp_var_1 >> 1;\n      temp_var_15 = temp_var_2 <= temp_var_12;\n      temp_var_14 = temp_var_13 - temp_var_10 < (uint)temp_var_15;\n      temp_var_5 = temp_var_13;\n      if (temp_var_10 < temp_var_13 || temp_var_14) {\n        temp_var_12 = temp_var_12 - temp_var_2;\n        temp_var_5 = (temp_var_13 - temp_var_10) - (uint)!temp_var_15;\n      }\n      if (temp_var_10 < temp_var_13 || temp_var_14) {\n        temp_var_11 = temp_var_11 | temp_var_3 >> 2;\n      }\n      temp_var_6 = temp_var_4 >> 3;\n      temp_var_1 = (uint)((temp_var_10 & 1) != 0) << 0x1f | temp_var_2 >> 1;\n      temp_var_15 = temp_var_1 <= temp_var_12;\n      temp_var_14 = temp_var_5 - temp_var_6 < (uint)temp_var_15;\n      temp_var_10 = temp_var_5;\n      if (temp_var_6 < temp_var_5 || temp_var_14) {\n        temp_var_12 = temp_var_12 - temp_var_1;\n        temp_var_10 = (temp_var_5 - temp_var_6) - (uint)!temp_var_15;\n      }\n      if (temp_var_6 < temp_var_5 || temp_var_14) {\n        temp_var_11 = temp_var_11 | temp_var_3 >> 3;\n      }\n      temp_var_13 = temp_var_10 | temp_var_12;\n      if (temp_var_13 == 0) break;\n      temp_var_10 = temp_var_10 << 4 | temp_var_12 >> 0x1c;\n      temp_var_12 = temp_var_12 << 4;\n      temp_var_4 = temp_var_4 & 0xfffffff8 | temp_var_1 >> 0x1d;\n      temp_var_1 = (temp_var_2 >> 1) << 3;\n      temp_var_3 = temp_var_3 >> 4;\n      if (temp_var_3 == 0) {\n        temp_var_6 = temp_var_4;\n        if ((temp_var_7 & 0x100000) != 0) goto LAB_0800083a;\n        temp_var_7 = temp_var_7 | temp_var_11;\n        temp_var_11 = 0;\n        temp_var_3 = 0x80000000;\n      }\n    }\n    if ((temp_var_7 & 0x100000) == 0) {\n      temp_var_7 = temp_var_7 | temp_var_11;\n      temp_var_11 = 0;\n    }\nLAB_0800083a:\n    temp_var_16 = 0xfc < temp_var_9;\n    temp_var_15 = SBORROW4(temp_var_9,0xfd);\n    temp_var_4 = temp_var_8 + 0x300;\n    temp_var_14 = temp_var_4 == 0;\n    temp_var_3 = temp_var_4;\n    if (temp_var_16 && !temp_var_14) {\n      temp_var_16 = 0x6ff < temp_var_4;\n      temp_var_15 = SBORROW4(temp_var_4,0x700);\n      temp_var_3 = temp_var_8 - 0x400;\n      temp_var_14 = temp_var_4 == 0x700;\n    }\n    if (!temp_var_16 || temp_var_14) {\n      temp_var_14 = temp_var_6 <= temp_var_10;\n      if (temp_var_10 == temp_var_6) {\n        temp_var_14 = temp_var_1 <= temp_var_12;\n      }\n      if (temp_var_10 == temp_var_6 && temp_var_12 == temp_var_1) {\n        temp_var_14 = (temp_var_11 & 1) != 0;\n      }\n      return CONCAT44(temp_var_7 + temp_var_9 * 0x100000 + (uint)CARRY4(temp_var_11,(uint)temp_var_14),temp_var_11 + temp_var_14);\n    }\n  }\n  if (!temp_var_14 && (int)temp_var_3 < 0 == temp_var_15) {\n    return (ulonglong)(temp_var_7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  temp_var_16 = SCARRY4(temp_var_9,0x36);\n  temp_var_14 = (int)(temp_var_9 + 0x36) < 0;\n  temp_var_15 = temp_var_9 == 0xffffffca;\n  if (temp_var_15 || temp_var_14 != temp_var_16) {\n    temp_var_11 = 0;\n  }\n  if (temp_var_15 || temp_var_14 != temp_var_16) {\n    temp_var_7 = temp_var_7 & 0x80000000;\n  }\n  if (temp_var_15 || temp_var_14 != temp_var_16) {\n    return CONCAT44(temp_var_7,temp_var_11);\n  }\n  temp_var_3 = -temp_var_9;\n  temp_var_10 = temp_var_3 - 0x20;\n  if (0x1f < (int)temp_var_3) {\n    temp_var_3 = temp_var_11 >> (temp_var_10 & 0xff) | temp_var_7 << (0x20 - temp_var_10 & 0xff);\n    temp_var_9 = (temp_var_7 >> (temp_var_10 & 0xff) & ~((temp_var_7 & 0x80000000) >> (temp_var_10 & 0xff))) -\n            ((int)temp_var_3 >> 0x1f);\n    if ((temp_var_13 | temp_var_11 << (0x20 - temp_var_10 & 0xff) | temp_var_3 << 1) == 0) {\n      temp_var_9 = temp_var_9 & ~(temp_var_3 >> 0x1f);\n    }\n    return CONCAT44(temp_var_7,temp_var_9) & 0x80000000ffffffff;\n  }\n  temp_var_8 = temp_var_3 - 0x14;\n  if (temp_var_8 != 0 && temp_var_8 < 0 == SCARRY4(temp_var_10,0xc)) {\n    temp_var_9 = 0xc - temp_var_8;\n    temp_var_3 = temp_var_11 << (temp_var_9 & 0xff);\n    temp_var_11 = temp_var_11 >> (0x20 - temp_var_9 & 0xff) | temp_var_7 << (temp_var_9 & 0xff);\n    temp_var_9 = temp_var_11 + -((int)temp_var_3 >> 0x1f);\n    if ((temp_var_13 | temp_var_3 << 1) == 0) {\n      temp_var_9 = temp_var_9 & ~(temp_var_3 >> 0x1f);\n    }\n    return CONCAT44((temp_var_7 & 0x80000000) + (uint)CARRY4(temp_var_11,-((int)temp_var_3 >> 0x1f)),temp_var_9);\n  }\n  temp_var_10 = temp_var_11 << (temp_var_9 + 0x20 & 0xff);\n  temp_var_11 = temp_var_11 >> (temp_var_3 & 0xff) | temp_var_7 << (temp_var_9 + 0x20 & 0xff);\n  temp_var_9 = temp_var_11 + -((int)temp_var_10 >> 0x1f);\n  if ((temp_var_13 | temp_var_10 << 1) == 0) {\n    temp_var_9 = temp_var_9 & ~(temp_var_10 >> 0x1f);\n  }\n  return CONCAT44((temp_var_7 & 0x80000000) +\n                  ((temp_var_7 & 0x7fffffff) >> (temp_var_3 & 0xff)) +\n                  (uint)CARRY4(temp_var_11,-((int)temp_var_10 >> 0x1f)),temp_var_9);\n}\n\n",
            "renaming": {
                "FUN_0800071c": "calculate_float_value_0800071c",
                "param_1": "input_param_1",
                "param_2": "input_param_2",
                "param_3": "input_param_3",
                "param_4": "input_param_4",
                "uVar1": "temp_var_1",
                "uVar2": "temp_var_2",
                "uVar3": "temp_var_3",
                "uVar4": "temp_var_4",
                "uVar5": "temp_var_5",
                "uVar6": "temp_var_6",
                "uVar7": "temp_var_7",
                "iVar8": "temp_var_8",
                "uVar9": "temp_var_9",
                "uVar10": "temp_var_10",
                "uVar11": "temp_var_11",
                "uVar12": "temp_var_12",
                "uVar13": "temp_var_13",
                "bVar14": "temp_var_14",
                "bVar15": "temp_var_15",
                "bVar16": "temp_var_16",
                "uVar17": "temp_var_17"
            },
            "calling": [
                "FUN_080059f0",
                "FUN_08004bd8",
                "FUN_08004d78",
                "FUN_08005838",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_0800088a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800088a": {
            "entrypoint": "0x0800088a",
            "current_name": "calculate_float_value_0800088a",
            "code": "\nulonglong calculateFloatValue_0800088a(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint bitCheck1;\n  uint register4;\n  uint bitCheck2;\n  uint temp1;\n  uint temp2;\n  bool isZero;\n  \n  bitCheck2 = temp2 & input4 >> 0x14;\n  temp1 = input2;\n  if (register4 != temp2 || bitCheck2 != temp2) {\n    if (register4 == temp2) {\n      if (((input1 | input2 << 0xc) == 0) && (input1 = input3, temp1 = input4, bitCheck2 != temp2)\n         ) {\nLAB_080006fc:\n        return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (bitCheck2 == temp2) {\n      input1 = input3;\n      temp1 = input4;\n      if ((input3 | input4 << 0xc) == 0) {\nLAB_080006c0:\n        return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      isZero = (input1 | input2 << 1) == 0;\n      if (!isZero) {\n        isZero = (input3 | input4 << 1) == 0;\n      }\n      if (!isZero) {\n        if (register4 == 0) {\n          temp1 = input2 & 0x80000000;\n          do {\n            bitCheck1 = input1 & 0x80000000;\n            input1 = input1 << 1;\n            input2 = input2 * 2 + (uint)(bitCheck1 != 0);\n          } while ((input2 & 0x100000) == 0);\n          input2 = input2 | temp1;\n          if (bitCheck2 != 0) {\n            return CONCAT44(input2,input1);\n          }\n        }\n        do {\n          temp1 = input3 & 0x80000000;\n          input3 = input3 << 1;\n          input4 = input4 * 2 + (uint)(temp1 != 0);\n        } while ((input4 & 0x100000) == 0);\n        return CONCAT44(input2,input1);\n      }\n      if ((input1 | input2 << 1) != 0) goto LAB_080006fc;\n      if ((input3 | input4 << 1) != 0) goto LAB_080006c0;\n    }\n  }\n  return CONCAT44(temp1,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_0800088a": "calculate_float_value_0800088a",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "bitCheck1",
                "unaff_r4": "register4",
                "uVar2": "bitCheck2",
                "uVar3": "temp1",
                "in_r12": "temp2",
                "bVar4": "isZero"
            },
            "calling": [
                "FUN_0800071c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008fc": {
            "entrypoint": "0x080008fc",
            "current_name": "check_params_equal_or_zero_080008fc",
            "code": "\nuint check_params_equal_or_zero_080008fc(uint first_param,uint second_param,uint third_param,uint fourth_param)\n\n{\n  uint result;\n  bool is_zero;\n  bool is_less_than;\n  \n  if (((int)(second_param << 1) >> 0x15 == -1 || (int)(fourth_param << 1) >> 0x15 == -1) &&\n     ((((int)(second_param << 1) >> 0x15 == -1 && ((first_param | second_param << 0xc) != 0)) ||\n      (((int)(fourth_param << 1) >> 0x15 == -1 && ((third_param | fourth_param << 0xc) != 0)))))) {\n    return 1;\n  }\n  is_zero = (first_param | second_param << 1) == 0;\n  if (is_zero) {\n    is_zero = (third_param | fourth_param << 1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = second_param == fourth_param;\n  }\n  if (is_zero) {\n    is_zero = first_param == third_param;\n  }\n  if (!is_zero) {\n    result = second_param ^ fourth_param;\n    is_zero = result == 0;\n    if (-1 < (int)result) {\n      is_zero = second_param == fourth_param;\n    }\n    is_less_than = -1 < (int)result && fourth_param <= second_param;\n    if (is_zero) {\n      is_less_than = third_param <= first_param;\n    }\n    fourth_param = (int)fourth_param >> 0x1f;\n    if (!is_less_than) {\n      fourth_param = ~fourth_param;\n    }\n    return fourth_param | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008fc": "check_params_equal_or_zero_080008fc",
                "param_1": "first_param",
                "param_2": "second_param",
                "param_3": "third_param",
                "param_4": "fourth_param",
                "uVar1": "result",
                "bVar2": "is_zero",
                "bVar3": "is_less_than"
            },
            "calling": [
                "FUN_08000988"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000978": {
            "entrypoint": "0x08000978",
            "current_name": "process_and_return_input_08000978",
            "code": "\nvoid process_and_return_input_08000978(undefined4 input1,undefined4 input2,undefined4 input3,undefined4 input4)\n\n{\n  process_input_08000988(input3,input4,input1,input2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000978": "process_and_return_input_08000978",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4"
            },
            "calling": [
                "FUN_080009d4",
                "FUN_080009e8"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000988": {
            "entrypoint": "0x08000988",
            "current_name": "process_input_08000988",
            "code": "\nundefined4 process_input_08000988(undefined4 input_value)\n\n{\n  check_params_equal_or_zero_080008fc();\n  return input_value;\n}\n\n",
            "renaming": {
                "FUN_08000988": "process_input_08000988",
                "param_1": "input_value"
            },
            "calling": [
                "FUN_080009ac",
                "FUN_080009c0",
                "FUN_08000978",
                "FUN_08000998"
            ],
            "called": [
                "FUN_080008fc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "process_input_and_check_flag_08000998",
            "code": "\nbool process_input_and_check_flag_08000998(void)\n\n{\n  char is_flag_set;\n  \n  process_input_08000988();\n  return is_flag_set != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000998": "process_input_and_check_flag_08000998",
                "in_ZR": "is_flag_set"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009ac": {
            "entrypoint": "0x080009ac",
            "current_name": "is_input_processed_080009ac",
            "code": "\nbool is_input_processed_080009ac(void)\n\n{\n  char input_character;\n  \n  process_input_08000988();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009ac": "is_input_processed_080009ac",
                "in_CY": "input_character"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c0": {
            "entrypoint": "0x080009c0",
            "current_name": "check_input_conditions_080009c0",
            "code": "\nbool check_input_conditions_080009c0(void)\n\n{\n  undefined zero_flag;\n  undefined carry_flag;\n  \n  process_input_08000988();\n  return !(bool)carry_flag || (bool)zero_flag;\n}\n\n",
            "renaming": {
                "FUN_080009c0": "check_input_conditions_080009c0",
                "in_ZR": "zero_flag",
                "in_CY": "carry_flag"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009d4": {
            "entrypoint": "0x080009d4",
            "current_name": "check_input_and_return_result_080009d4",
            "code": "\nbool check_input_and_return_result_080009d4(void)\n\n{\n  undefined zero_flag;\n  undefined carry_flag;\n  \n  process_and_return_input_08000978();\n  return !(bool)carry_flag || (bool)zero_flag;\n}\n\n",
            "renaming": {
                "FUN_080009d4": "check_input_and_return_result_080009d4",
                "in_ZR": "zero_flag",
                "in_CY": "carry_flag"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08000978"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009e8": {
            "entrypoint": "0x080009e8",
            "current_name": "check_input_is_empty_080009e8",
            "code": "\nbool check_input_is_empty_080009e8(void)\n\n{\n  char input_character;\n  \n  process_and_return_input_08000978();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009e8": "check_input_is_empty_080009e8",
                "in_CY": "input_character"
            },
            "calling": [
                "FUN_080059f0",
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08000978"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009fc": {
            "entrypoint": "0x080009fc",
            "current_name": "calculate_float_value_080009fc",
            "code": "\nuint calculateFloatValue_080009fc(uint inputValue1,uint inputValue2)\n\n{\n  uint result;\n  uint multipliedValue;\n  uint newValue;\n  uint conditionValue;\n  bool isZero;\n  bool isLessThan;\n  \n  multipliedValue = inputValue2 * 2;\n  isLessThan = multipliedValue < 0x70000000;\n  newValue = multipliedValue + 0x90000000;\n  result = newValue;\n  if (!isLessThan) {\n    conditionValue = multipliedValue + 0x8fe00000;\n    result = conditionValue;\n  }\n  isZero = result == 0;\n  if (!isLessThan && newValue >= 0x200000) {\n    isZero = conditionValue == 0x1fc00000;\n  }\n  if (((isLessThan || newValue < 0x200000) || 0x1fc00000 < conditionValue) || isZero) {\n    if ((inputValue2 & 0x40000000) != 0) {\n      if (((int)multipliedValue >> 0x15 == -1) && ((inputValue1 | inputValue2 << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return inputValue2 & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(multipliedValue + 0x92e00000) < 0 != SCARRY4(newValue,0x2e00000)) {\n      return inputValue2 & 0x80000000;\n    }\n    multipliedValue = 0x18 - (multipliedValue + 0x92e00000 >> 0x15);\n    result = inputValue1 >> (multipliedValue & 0xff);\n    if (inputValue1 << (0x20 - multipliedValue & 0xff) != 0) {\n      result = result | 1;\n    }\n    newValue = inputValue2 & 0x1fffff | 0x100000;\n    inputValue1 = result | newValue << (0x20 - multipliedValue & 0xff);\n    newValue = (newValue >> (multipliedValue & 0xff)) << 1;\n  }\n  result = (inputValue2 & 0x80000000 | inputValue1 >> 0x1d) + newValue * 4 + (uint)(0x7fffffff < inputValue1 * 8);\n  if (inputValue1 * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080009fc": "calculate_float_value_080009fc",
                "param_1": "inputValue1",
                "param_2": "inputValue2",
                "uVar1": "result",
                "uVar2": "multipliedValue",
                "uVar3": "newValue",
                "in_r12": "conditionValue",
                "bVar4": "isZero",
                "bVar5": "isLessThan"
            },
            "calling": [
                "FUN_08004bd8",
                "FUN_08004d78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa4": {
            "entrypoint": "0x08000aa4",
            "current_name": "calculate_floating_point_08000aa4",
            "code": "\nuint calculateFloatingPoint_08000aa4(uint exponent,uint significand,undefined4 undefined,uint mode)\n\n{\n  int exponent_1;\n  int exponent_2;\n  uint result_1;\n  uint result_2;\n  uint overflow_check_1;\n  uint overflow_check_2;\n  uint difference;\n  bool is_equal;\n  \n  result_1 = significand ^ 0x80000000;\n  overflow_check_1 = exponent << 1;\n  is_equal = overflow_check_1 == 0;\n  if (!is_equal) {\n    mode = significand << 1;\n    is_equal = mode == 0;\n  }\n  if (!is_equal) {\n    is_equal = overflow_check_1 == mode;\n  }\n  exponent_1 = (int)overflow_check_1 >> 0x18;\n  if (!is_equal) {\n    is_equal = exponent_1 == -1;\n  }\n  if (!is_equal) {\n    is_equal = (int)mode >> 0x18 == -1;\n  }\n  if (is_equal) {\n    exponent_2 = (int)(significand << 1) >> 0x18;\n    if (exponent_1 == -1 || exponent_2 == -1) {\n      overflow_check_1 = result_1;\n      if (exponent_1 == -1) {\n        overflow_check_1 = exponent;\n      }\n      if (exponent_1 != -1 || exponent_2 != -1) {\n        result_1 = overflow_check_1;\n      }\n      is_equal = (overflow_check_1 & 0x7fffff) == 0;\n      if (is_equal) {\n        is_equal = (result_1 & 0x7fffff) == 0;\n      }\n      if (is_equal) {\n        is_equal = overflow_check_1 == result_1;\n      }\n      if (!is_equal) {\n        overflow_check_1 = overflow_check_1 | 0x400000;\n      }\n      return overflow_check_1;\n    }\n    if (((exponent ^ result_1) & 0x7fffffff) != 0) {\n      if (overflow_check_1 == 0) {\n        exponent = result_1;\n      }\n      return exponent;\n    }\n    if (exponent != result_1) {\n      return 0;\n    }\n    if ((overflow_check_1 & 0xff000000) == 0) {\n      result_1 = exponent << 1;\n      if ((exponent & 0x80000000) != 0) {\n        result_1 = result_1 | 0x80000000;\n      }\n      return result_1;\n    }\n    if (overflow_check_1 < 0xfe000000) {\n      return exponent + 0x800000;\n    }\n    exponent = exponent & 0x80000000;\nLAB_08000bde:\n    return exponent | 0x7f800000;\n  }\n  overflow_check_1 = overflow_check_1 >> 0x18;\n  mode = mode >> 0x18;\n  difference = mode - overflow_check_1;\n  is_equal = difference != 0;\n  overflow_check_2 = overflow_check_1;\n  if (is_equal && overflow_check_1 <= mode) {\n    overflow_check_2 = overflow_check_1 + difference;\n  }\n  if (is_equal && overflow_check_1 <= mode) {\n    result_1 = result_1 ^ exponent;\n  }\n  if (is_equal && overflow_check_1 <= mode) {\n    exponent = exponent ^ result_1;\n  }\n  if (is_equal && overflow_check_1 <= mode) {\n    result_1 = result_1 ^ exponent;\n  }\n  if (mode < overflow_check_1) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return exponent;\n  }\n  overflow_check_1 = exponent & 0xffffff | 0x800000;\n  if ((exponent & 0x80000000) != 0) {\n    overflow_check_1 = -overflow_check_1;\n  }\n  result_2 = result_1 & 0xffffff | 0x800000;\n  if ((result_1 & 0x80000000) != 0) {\n    result_2 = -result_2;\n  }\n  if (overflow_check_2 == difference) {\n    result_2 = result_2 ^ 0x800000;\n    if (overflow_check_2 == 0) {\n      overflow_check_1 = overflow_check_1 ^ 0x800000;\n      overflow_check_2 = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  overflow_check_1 = overflow_check_1 + ((int)result_2 >> (difference & 0xff));\n  result_2 = result_2 << (0x20 - difference & 0xff);\n  exponent = overflow_check_1 & 0x80000000;\n  if ((int)overflow_check_1 < 0) {\n    is_equal = result_2 != 0;\n    result_2 = -result_2;\n    overflow_check_1 = -overflow_check_1 - (uint)is_equal;\n  }\n  if (overflow_check_1 < 0x800000) {\n    result_1 = result_2 & 0x80000000;\n    result_2 = result_2 << 1;\n    overflow_check_1 = overflow_check_1 * 2 + (uint)(result_1 != 0);\n    result_1 = overflow_check_2 - 2;\n    if ((overflow_check_1 & 0x800000) == 0) {\n      difference = LZCOUNT(overflow_check_1) - 8;\n      overflow_check_1 = overflow_check_1 << (difference & 0xff);\n      if ((int)result_1 < (int)difference) {\n        overflow_check_1 = overflow_check_1 >> (-(result_1 - difference) & 0xff);\n      }\n      else {\n        overflow_check_1 = overflow_check_1 + (result_1 - difference) * 0x800000;\n      }\n      return overflow_check_1 | exponent;\n    }\n  }\n  else {\n    result_1 = overflow_check_2 - 1;\n    if (0xffffff < overflow_check_1) {\n      result_1 = overflow_check_1 & 1;\n      overflow_check_1 = overflow_check_1 >> 1;\n      result_2 = (uint)(result_1 != 0) << 0x1f | result_2 >> 1;\n      result_1 = overflow_check_2;\n      if (0xfd < overflow_check_2) goto LAB_08000bde;\n    }\n  }\n  overflow_check_1 = overflow_check_1 + result_1 * 0x800000 + (uint)(0x7fffffff < result_2);\n  if (result_2 == 0x80000000) {\n    overflow_check_1 = overflow_check_1 & 0xfffffffe;\n  }\n  return overflow_check_1 | exponent;\n}\n\n",
            "renaming": {
                "FUN_08000aa4": "calculate_floating_point_08000aa4",
                "param_1": "exponent",
                "param_2": "significand",
                "param_3": "undefined",
                "param_4": "mode",
                "iVar1": "exponent_1",
                "iVar2": "exponent_2",
                "uVar3": "result_1",
                "uVar4": "result_2",
                "uVar5": "overflow_check_1",
                "uVar6": "overflow_check_2",
                "uVar7": "difference",
                "bVar8": "is_equal"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_08004bd8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa8": {
            "entrypoint": "0x08000aa8",
            "current_name": "perform_arithmetic_operation_08000aa8",
            "code": "\nuint performArithmeticOperation_08000aa8(uint operand1,uint operand2,undefined4 parameter3,uint parameter4)\n\n{\n  int iVar1;\n  int iVar2;\n  uint result;\n  uint shiftedOperand1;\n  uint temp1;\n  uint difference;\n  bool isEqual;\n  \n  shiftedOperand1 = operand1 << 1;\n  isEqual = shiftedOperand1 == 0;\n  if (!isEqual) {\n    parameter4 = operand2 << 1;\n    isEqual = parameter4 == 0;\n  }\n  if (!isEqual) {\n    isEqual = shiftedOperand1 == parameter4;\n  }\n  iVar1 = (int)shiftedOperand1 >> 0x18;\n  if (!isEqual) {\n    isEqual = iVar1 == -1;\n  }\n  if (!isEqual) {\n    isEqual = (int)parameter4 >> 0x18 == -1;\n  }\n  if (isEqual) {\n    iVar2 = (int)(operand2 << 1) >> 0x18;\n    if (iVar1 == -1 || iVar2 == -1) {\n      shiftedOperand1 = operand2;\n      if (iVar1 == -1) {\n        shiftedOperand1 = operand1;\n      }\n      if (iVar1 != -1 || iVar2 != -1) {\n        operand2 = shiftedOperand1;\n      }\n      isEqual = (shiftedOperand1 & 0x7fffff) == 0;\n      if (isEqual) {\n        isEqual = (operand2 & 0x7fffff) == 0;\n      }\n      if (isEqual) {\n        isEqual = shiftedOperand1 == operand2;\n      }\n      if (!isEqual) {\n        shiftedOperand1 = shiftedOperand1 | 0x400000;\n      }\n      return shiftedOperand1;\n    }\n    if (((operand1 ^ operand2) & 0x7fffffff) != 0) {\n      if (shiftedOperand1 == 0) {\n        operand1 = operand2;\n      }\n      return operand1;\n    }\n    if (operand1 != operand2) {\n      return 0;\n    }\n    if ((shiftedOperand1 & 0xff000000) == 0) {\n      shiftedOperand1 = operand1 << 1;\n      if ((operand1 & 0x80000000) != 0) {\n        shiftedOperand1 = shiftedOperand1 | 0x80000000;\n      }\n      return shiftedOperand1;\n    }\n    if (shiftedOperand1 < 0xfe000000) {\n      return operand1 + 0x800000;\n    }\n    operand1 = operand1 & 0x80000000;\nLAB_08000bde:\n    return operand1 | 0x7f800000;\n  }\n  shiftedOperand1 = shiftedOperand1 >> 0x18;\n  parameter4 = parameter4 >> 0x18;\n  difference = parameter4 - shiftedOperand1;\n  isEqual = difference != 0;\n  temp1 = shiftedOperand1;\n  if (isEqual && shiftedOperand1 <= parameter4) {\n    temp1 = shiftedOperand1 + difference;\n  }\n  if (isEqual && shiftedOperand1 <= parameter4) {\n    operand2 = operand2 ^ operand1;\n  }\n  if (isEqual && shiftedOperand1 <= parameter4) {\n    operand1 = operand1 ^ operand2;\n  }\n  if (isEqual && shiftedOperand1 <= parameter4) {\n    operand2 = operand2 ^ operand1;\n  }\n  if (parameter4 < shiftedOperand1) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return operand1;\n  }\n  shiftedOperand1 = operand1 & 0xffffff | 0x800000;\n  if ((operand1 & 0x80000000) != 0) {\n    shiftedOperand1 = -shiftedOperand1;\n  }\n  result = operand2 & 0xffffff | 0x800000;\n  if ((operand2 & 0x80000000) != 0) {\n    result = -result;\n  }\n  if (temp1 == difference) {\n    result = result ^ 0x800000;\n    if (temp1 == 0) {\n      shiftedOperand1 = shiftedOperand1 ^ 0x800000;\n      temp1 = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  shiftedOperand1 = shiftedOperand1 + ((int)result >> (difference & 0xff));\n  result = result << (0x20 - difference & 0xff);\n  operand1 = shiftedOperand1 & 0x80000000;\n  if ((int)shiftedOperand1 < 0) {\n    isEqual = result != 0;\n    result = -result;\n    shiftedOperand1 = -shiftedOperand1 - (uint)isEqual;\n  }\n  if (shiftedOperand1 < 0x800000) {\n    difference = result & 0x80000000;\n    result = result << 1;\n    shiftedOperand1 = shiftedOperand1 * 2 + (uint)(difference != 0);\n    difference = temp1 - 2;\n    if ((shiftedOperand1 & 0x800000) == 0) {\n      temp1 = LZCOUNT(shiftedOperand1) - 8;\n      shiftedOperand1 = shiftedOperand1 << (temp1 & 0xff);\n      if ((int)difference < (int)temp1) {\n        shiftedOperand1 = shiftedOperand1 >> (-(difference - temp1) & 0xff);\n      }\n      else {\n        shiftedOperand1 = shiftedOperand1 + (difference - temp1) * 0x800000;\n      }\n      return shiftedOperand1 | operand1;\n    }\n  }\n  else {\n    difference = temp1 - 1;\n    if (0xffffff < shiftedOperand1) {\n      difference = shiftedOperand1 & 1;\n      shiftedOperand1 = shiftedOperand1 >> 1;\n      result = (uint)(difference != 0) << 0x1f | result >> 1;\n      difference = temp1;\n      if (0xfd < temp1) goto LAB_08000bde;\n    }\n  }\n  shiftedOperand1 = shiftedOperand1 + difference * 0x800000 + (uint)(0x7fffffff < result);\n  if (result == 0x80000000) {\n    shiftedOperand1 = shiftedOperand1 & 0xfffffffe;\n  }\n  return shiftedOperand1 | operand1;\n}\n\n",
            "renaming": {
                "FUN_08000aa8": "perform_arithmetic_operation_08000aa8",
                "param_1": "operand1",
                "param_2": "operand2",
                "param_3": "parameter3",
                "param_4": "parameter4",
                "uVar3": "result",
                "uVar4": "shiftedOperand1",
                "uVar5": "temp1",
                "uVar6": "difference",
                "bVar7": "isEqual"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_080049cc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c08": {
            "entrypoint": "0x08000c08",
            "current_name": "calculate_result_08000c08",
            "code": "\nuint calculateResult_08000c08(uint inputValue)\n\n{\n  uint leadingZeros;\n  uint shiftAmount;\n  int baseValue;\n  uint mask;\n  \n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZeros = LZCOUNT(inputValue);\n  shiftAmount = leadingZeros - 8;\n  baseValue = shiftAmount * -0x800000 + 0x4a800000;\n  if (7 < leadingZeros) {\n    mask = 0 << (shiftAmount & 0xff);\n    leadingZeros = baseValue + (inputValue << (shiftAmount & 0xff)) +\n            (0U >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < mask);\n    if (mask == 0x80000000) {\n      leadingZeros = leadingZeros & 0xfffffffe;\n    }\n    return leadingZeros;\n  }\n  shiftAmount = inputValue << leadingZeros + 0x18;\n  leadingZeros = baseValue + ((inputValue >> (0x20 - (leadingZeros + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n  if ((shiftAmount & 0x7fffffff) == 0) {\n    leadingZeros = leadingZeros & ~(shiftAmount >> 0x1f);\n  }\n  return leadingZeros;\n}\n\n",
            "renaming": {
                "FUN_08000c08": "calculate_result_08000c08",
                "param_1": "inputValue",
                "uVar1": "leadingZeros",
                "uVar2": "shiftAmount",
                "iVar3": "baseValue",
                "uVar4": "mask"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c10": {
            "entrypoint": "0x08000c10",
            "current_name": "compute_modified_value_08000c10",
            "code": "\nuint computeModifiedValue_08000c10(uint inputValue)\n\n{\n  uint leadingZeros;\n  uint shiftedValue;\n  uint signBit;\n  int modifiedValue;\n  \n  signBit = inputValue & 0x80000000;\n  if ((int)signBit < 0) {\n    inputValue = -inputValue;\n  }\n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZeros = LZCOUNT(inputValue);\n  shiftedValue = leadingZeros - 8;\n  modifiedValue = ((signBit | 0x4b000000) - 0x800000) + shiftedValue * -0x800000;\n  if (7 < leadingZeros) {\n    leadingZeros = 0 << (shiftedValue & 0xff);\n    signBit = modifiedValue + (inputValue << (shiftedValue & 0xff)) +\n            (0U >> (0x20 - shiftedValue & 0xff)) + (uint)(0x7fffffff < leadingZeros);\n    if (leadingZeros == 0x80000000) {\n      signBit = signBit & 0xfffffffe;\n    }\n    return signBit;\n  }\n  shiftedValue = inputValue << leadingZeros + 0x18;\n  signBit = modifiedValue + ((inputValue >> (0x20 - (leadingZeros + 0x18) & 0xff)) - ((int)shiftedValue >> 0x1f));\n  if ((shiftedValue & 0x7fffffff) == 0) {\n    signBit = signBit & ~(shiftedValue >> 0x1f);\n  }\n  return signBit;\n}\n\n",
            "renaming": {
                "FUN_08000c10": "compute_modified_value_08000c10",
                "param_1": "inputValue",
                "uVar1": "leadingZeros",
                "uVar2": "shiftedValue",
                "uVar3": "signBit",
                "iVar4": "modifiedValue"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_08004ae0",
                "FUN_080049cc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cb8": {
            "entrypoint": "0x08000cb8",
            "current_name": "calculate_float_from_integers_08000cb8",
            "code": "\nuint calculateFloatFromIntegers_08000cb8(uint inputA,uint inputB,undefined4 inputC,uint inputD)\n\n{\n  longlong tempBigInt1;\n  uint result;\n  uint tempByteA;\n  int tempInt1;\n  int tempInt2;\n  uint tempUInt1;\n  int tempInt3;\n  uint tempUInt2;\n  bool isZero;\n  bool isBorrow;\n  \n  tempByteA = inputA >> 0x17 & 0xff;\n  isZero = tempByteA == 0;\n  if (!isZero) {\n    inputD = inputB >> 0x17 & 0xff;\n    isZero = inputD == 0;\n  }\n  if (!isZero) {\n    isZero = tempByteA == 0xff;\n  }\n  if (!isZero) {\n    isZero = inputD == 0xff;\n  }\n  if (isZero) {\n    inputD = inputB >> 0x17 & 0xff;\n    if (tempByteA == 0xff || inputD == 0xff) {\n      isZero = inputA == 0 || inputA == 0x80000000;\n      result = inputB;\n      if (inputA != 0 && inputA != 0x80000000) {\n        isZero = inputB == 0;\n        result = inputA;\n      }\n      if (!isZero) {\n        isZero = inputB == 0x80000000;\n      }\n      tempUInt2 = result;\n      if (((isZero) || ((tempByteA == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((inputD == 0xff && (tempUInt2 = inputB, (inputB & 0x7fffff) != 0)))) {\n        return tempUInt2 | 0x7fc00000;\n      }\n      result = result ^ inputB;\n      goto LAB_08000e08;\n    }\n    isZero = (inputA & 0x7fffffff) == 0;\n    if (!isZero) {\n      isZero = (inputB & 0x7fffffff) == 0;\n    }\n    if (isZero) {\n      return (inputA ^ inputB) & 0x80000000;\n    }\n    isZero = tempByteA == 0;\n    result = inputA & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        inputA = inputA << 1;\n        isZero = (inputA & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      tempByteA = tempByteA - 1;\n    }\n    inputA = inputA | result;\n    isZero = inputD == 0;\n    result = inputB & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        inputB = inputB << 1;\n        isZero = (inputB & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      inputD = inputD - 1;\n    }\n    inputB = inputB | result;\n  }\n  tempInt1 = tempByteA + inputD;\n  tempUInt2 = inputA ^ inputB;\n  tempByteA = inputA << 9;\n  isZero = tempByteA == 0;\n  if (!isZero) {\n    inputB = inputB << 9;\n    isZero = inputB == 0;\n  }\n  if (isZero) {\n    if (tempByteA == 0) {\n      inputB = inputB << 9;\n    }\n    result = tempUInt2 & 0x80000000 | inputA & 0x7fffff | inputB >> 9;\n    isBorrow = SBORROW4(tempInt1,0x7f);\n    tempInt2 = tempInt1 + -0x7f;\n    isZero = tempInt2 == 0;\n    tempInt3 = tempInt2;\n    if (!isZero && 0x7e < tempInt1) {\n      isBorrow = SBORROW4(0xff,tempInt2);\n      tempInt3 = 0xff - tempInt2;\n      isZero = tempInt2 == 0xff;\n    }\n    if (!isZero && tempInt3 < 0 == isBorrow) {\n      result = result | tempInt2 * 0x800000;\n    }\n    if (!isZero && tempInt3 < 0 == isBorrow) {\n      return result;\n    }\n    result = result | 0x800000;\n    tempUInt1 = 0;\n    isBorrow = SBORROW4(tempInt2,1);\n    tempUInt2 = tempInt1 - 0x80;\n    isZero = tempUInt2 == 0;\n    tempByteA = tempUInt2;\n  }\n  else {\n    tempBigInt1 = (ulonglong)(tempByteA >> 5 | 0x8000000) * (ulonglong)(inputB >> 5 | 0x8000000);\n    tempUInt1 = (uint)tempBigInt1;\n    result = (uint)((ulonglong)tempBigInt1 >> 0x20);\n    isZero = result < 0x800000;\n    if (isZero) {\n      result = result << 1;\n    }\n    if (isZero) {\n      result = result | tempUInt1 >> 0x1f;\n      tempUInt1 = tempUInt1 << 1;\n    }\n    result = tempUInt2 & 0x80000000 | result;\n    tempUInt2 = (tempInt1 + -0x7f) - (uint)isZero;\n    isBorrow = SBORROW4(tempUInt2,0xfd);\n    isZero = tempUInt2 == 0xfd;\n    tempByteA = tempUInt2 - 0xfd;\n    if (tempUInt2 < 0xfe) {\n      result = result + tempUInt2 * 0x800000 + (uint)(0x7fffffff < tempUInt1);\n      if (tempUInt1 == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (isZero || (int)tempByteA < 0 != isBorrow) {\n    isZero = (int)(tempUInt2 + 0x19) < 0;\n    if (tempUInt2 == 0xffffffe7 || isZero != SCARRY4(tempUInt2,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (tempUInt2 != 0xffffffe7 && isZero == SCARRY4(tempUInt2,0x19)) {\n      tempByteA = (result << 1) >> (-tempUInt2 & 0xff);\n      tempUInt2 = result << (tempUInt2 + 0x20 & 0xff);\n      tempByteA = ((uint)((result & 0x80000000) != 0) << 0x1f | tempByteA >> 1) + (uint)((byte)tempByteA & 1);\n      if ((tempUInt1 | tempUInt2 << 1) == 0) {\n        tempByteA = tempByteA & ~(tempUInt2 >> 0x1f);\n      }\n      return tempByteA;\n    }\n    return result;\n  }\nLAB_08000e08:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000cb8": "calculate_float_from_integers_08000cb8",
                "param_1": "inputA",
                "param_2": "inputB",
                "param_3": "inputC",
                "param_4": "inputD",
                "lVar1": "tempBigInt1",
                "uVar2": "result",
                "uVar3": "tempByteA",
                "iVar4": "tempInt1",
                "iVar5": "tempInt2",
                "uVar6": "tempUInt1",
                "iVar7": "tempInt3",
                "uVar8": "tempUInt2",
                "bVar9": "isZero",
                "bVar10": "isBorrow"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e20": {
            "entrypoint": "0x08000e20",
            "current_name": "floating_point_addition_08000e20",
            "code": "\nuint floatingPointAddition_08000e20(uint operand1,uint operand2,undefined4 undefinedValue,uint controlBits)\n\n{\n  uint shiftedOperand2;\n  uint shiftedOperand1;\n  int difference;\n  uint shiftedDifference;\n  int shiftedSum;\n  uint result;\n  bool isZero;\n  bool carryBit;\n  bool overflowBit;\n  \n  shiftedOperand1 = operand1 >> 0x17 & 0xff;\n  isZero = shiftedOperand1 == 0;\n  if (!isZero) {\n    controlBits = operand2 >> 0x17 & 0xff;\n    isZero = controlBits == 0;\n  }\n  if (!isZero) {\n    isZero = shiftedOperand1 == 0xff;\n  }\n  if (!isZero) {\n    isZero = controlBits == 0xff;\n  }\n  if (isZero) {\n    controlBits = operand2 >> 0x17 & 0xff;\n    result = operand1;\n    if (shiftedOperand1 == 0xff) {\n      if (((operand1 & 0x7fffff) != 0) || (result = operand2, controlBits == 0xff)) {\nLAB_08000e16:\n        return result | 0x7fc00000;\n      }\n    }\n    else {\n      if (controlBits == 0xff) {\n        result = operand2;\n        if ((operand2 & 0x7fffff) == 0) {\nLAB_08000dcc:\n          return (operand1 ^ operand2) & 0x80000000;\n        }\n        goto LAB_08000e16;\n      }\n      isZero = (operand1 & 0x7fffffff) == 0;\n      if (!isZero) {\n        isZero = (operand2 & 0x7fffffff) == 0;\n      }\n      if (!isZero) {\n        isZero = shiftedOperand1 == 0;\n        result = operand1 & 0x80000000;\n        while( true ) {\n          if (isZero) {\n            operand1 = operand1 << 1;\n            isZero = (operand1 & 0x800000) == 0;\n          }\n          if (!isZero) break;\n          shiftedOperand1 = shiftedOperand1 - 1;\n        }\n        operand1 = operand1 | result;\n        isZero = controlBits == 0;\n        result = operand2 & 0x80000000;\n        while( true ) {\n          if (isZero) {\n            operand2 = operand2 << 1;\n            isZero = (operand2 & 0x800000) == 0;\n          }\n          if (!isZero) break;\n          controlBits = controlBits - 1;\n        }\n        operand2 = operand2 | result;\n        goto LAB_08000e38;\n      }\n      if ((operand1 & 0x7fffffff) == 0) {\n        if ((operand2 & 0x7fffffff) != 0) goto LAB_08000dcc;\n        goto LAB_08000e16;\n      }\n    }\n    operand1 = operand1 ^ operand2;\n  }\n  else {\nLAB_08000e38:\n    difference = shiftedOperand1 - controlBits;\n    if (operand2 << 9 == 0) {\n      operand1 = (operand1 ^ operand2) & 0x80000000 | operand1 & 0x7fffff;\n      overflowBit = SCARRY4(difference,0x7f);\n      shiftedSum = difference + 0x7f;\n      isZero = shiftedSum < 0;\n      carryBit = shiftedSum == 0;\n      if (!carryBit && isZero == overflowBit) {\n        overflowBit = SBORROW4(0xff,shiftedSum);\n        isZero = 0xff - shiftedSum < 0;\n        carryBit = shiftedSum == 0xff;\n      }\n      if (!carryBit && isZero == overflowBit) {\n        operand1 = operand1 | shiftedSum * 0x800000;\n      }\n      if (!carryBit && isZero == overflowBit) {\n        return operand1;\n      }\n      operand1 = operand1 | 0x800000;\n      shiftedOperand1 = 0;\n      carryBit = SBORROW4(shiftedSum,1);\n      shiftedDifference = difference + 0x7e;\n      isZero = shiftedDifference == 0;\n      result = shiftedDifference;\n    }\n    else {\n      shiftedOperand2 = (operand2 << 9) >> 4 | 0x10000000;\n      shiftedOperand1 = (operand1 << 9) >> 4 | 0x10000000;\n      operand1 = (operand1 ^ operand2) & 0x80000000;\n      isZero = shiftedOperand2 <= shiftedOperand1;\n      if (!isZero) {\n        shiftedOperand1 = shiftedOperand1 << 1;\n      }\n      shiftedDifference = difference + 0x7d + (uint)isZero;\n      result = 0x800000;\n      do {\n        if (shiftedOperand2 <= shiftedOperand1) {\n          shiftedOperand1 = shiftedOperand1 - shiftedOperand2;\n          operand1 = operand1 | result;\n        }\n        isZero = shiftedOperand2 >> 1 <= shiftedOperand1;\n        if (isZero) {\n          shiftedOperand1 = shiftedOperand1 - (shiftedOperand2 >> 1);\n        }\n        if (isZero) {\n          operand1 = operand1 | result >> 1;\n        }\n        isZero = shiftedOperand2 >> 2 <= shiftedOperand1;\n        if (isZero) {\n          shiftedOperand1 = shiftedOperand1 - (shiftedOperand2 >> 2);\n        }\n        if (isZero) {\n          operand1 = operand1 | result >> 2;\n        }\n        isZero = shiftedOperand2 >> 3 <= shiftedOperand1;\n        if (isZero) {\n          shiftedOperand1 = shiftedOperand1 - (shiftedOperand2 >> 3);\n        }\n        if (isZero) {\n          operand1 = operand1 | result >> 3;\n        }\n        shiftedOperand1 = shiftedOperand1 * 0x10;\n        isZero = shiftedOperand1 == 0;\n        if (!isZero) {\n          result = result >> 4;\n          isZero = result == 0;\n        }\n      } while (!isZero);\n      carryBit = SBORROW4(shiftedDifference,0xfd);\n      isZero = shiftedDifference == 0xfd;\n      result = shiftedDifference - 0xfd;\n      if (shiftedDifference < 0xfe) {\n        operand1 = operand1 + shiftedDifference * 0x800000 + (uint)(shiftedOperand2 <= shiftedOperand1);\n        if (shiftedOperand1 - shiftedOperand2 == 0) {\n          operand1 = operand1 & 0xfffffffe;\n        }\n        return operand1;\n      }\n    }\n    if (isZero || (int)result < 0 != carryBit) {\n      isZero = (int)(shiftedDifference + 0x19) < 0;\n      if (shiftedDifference == 0xffffffe7 || isZero != SCARRY4(shiftedDifference,0x19)) {\n        operand1 = operand1 & 0x80000000;\n      }\n      if (shiftedDifference == 0xffffffe7 || isZero != SCARRY4(shiftedDifference,0x19)) {\n        return operand1;\n      }\n      result = (operand1 << 1) >> (-shiftedDifference & 0xff);\n      shiftedDifference = operand1 << (shiftedDifference + 0x20 & 0xff);\n      result = ((uint)((operand1 & 0x80000000) != 0) << 0x1f | result >> 1) + (uint)((byte)result & 1);\n      if ((shiftedOperand1 | shiftedDifference << 1) == 0) {\n        result = result & ~(shiftedDifference >> 0x1f);\n      }\n      return result;\n    }\n  }\n  return operand1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000e20": "floating_point_addition_08000e20",
                "param_1": "operand1",
                "param_2": "operand2",
                "param_3": "undefinedValue",
                "param_4": "controlBits",
                "uVar1": "shiftedOperand2",
                "uVar2": "shiftedOperand1",
                "iVar3": "difference",
                "uVar4": "shiftedDifference",
                "iVar5": "shiftedSum",
                "uVar6": "result",
                "bVar7": "isZero",
                "bVar8": "carryBit",
                "bVar9": "overflowBit"
            },
            "calling": [
                "FUN_080049cc",
                "FUN_08004d78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f68": {
            "entrypoint": "0x08000f68",
            "current_name": "calculate_overflow_08000f68",
            "code": "\nuint calculate_overflow_08000f68(uint input_1,uint input_2)\n\n{\n  bool is_overflow;\n  uint double_input_1;\n  uint double_input_2;\n  uint combined_inputs;\n  bool is_zero;\n  \n  double_input_1 = input_1 * 2;\n  double_input_2 = input_2 * 2;\n  if (((int)double_input_1 >> 0x18 == -1 || (int)double_input_2 >> 0x18 == -1) &&\n     ((((int)double_input_1 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)double_input_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    result 1;\n  }\n  combined_inputs = double_input_1 | input_2 & 0x7fffffff;\n  is_zero = combined_inputs == 0;\n  if (!is_zero) {\n    combined_inputs = input_1 ^ input_2;\n    is_zero = combined_inputs == 0;\n  }\n  is_overflow = -1 < (int)combined_inputs;\n  if (is_overflow) {\n    input_1 = double_input_1 + input_2 * -2;\n    is_zero = input_1 == 0;\n  }\n  if ((is_overflow && double_input_2 <= double_input_1) && !is_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_overflow || double_input_2 > double_input_1) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_1 = input_1 | 1;\n  }\n  result input_1;\n}\n\n",
            "renaming": {
                "FUN_08000f68": "calculate_overflow_08000f68",
                "param_1": "input_1",
                "param_2": "input_2",
                "bVar1": "is_overflow",
                "uVar2": "double_input_1",
                "uVar3": "double_input_2",
                "uVar4": "combined_inputs",
                "bVar5": "is_zero",
                "return": "result"
            },
            "calling": [
                "FUN_08000fd0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fc8": {
            "entrypoint": "0x08000fc8",
            "current_name": "concatenate_parameters_08000fc8",
            "code": "\nvoid concatenateParameters_08000fc8(undefined4 targetParam,undefined4 sourceParam)\n\n{\n  concatenate_parameters_08000fd0(sourceParam,targetParam);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fc8": "concatenate_parameters_08000fc8",
                "param_1": "targetParam",
                "param_2": "sourceParam"
            },
            "calling": [
                "FUN_08001030"
            ],
            "called": [
                "FUN_08000fd0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fd0": {
            "entrypoint": "0x08000fd0",
            "current_name": "concatenate_parameters_08000fd0",
            "code": "\nundefined8 concatenateParameters_08000fd0(undefined4 firstParameter,undefined4 secondParameter)\n\n{\n  calculateOverflow();\n  return joinParameters(secondParameter,firstParameter);\n}\n\n",
            "renaming": {
                "FUN_08000fd0": "concatenate_parameters_08000fd0",
                "param_1": "firstParameter",
                "param_2": "secondParameter",
                "calculate_overflow_08000f68": "calculateOverflow",
                "CONCAT44": "joinParameters"
            },
            "calling": [
                "FUN_08000fc8",
                "FUN_08000ff4"
            ],
            "called": [
                "FUN_08000f68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ff4": {
            "entrypoint": "0x08000ff4",
            "current_name": "check_if_concatenation_is_empty_08000ff4",
            "code": "\nbool check_if_concatenation_is_empty_08000ff4(void)\n\n{\n  char input_character;\n  \n  concatenate_parameters_08000fd0();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000ff4": "check_if_concatenation_is_empty_08000ff4",
                "in_CY": "input_character"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08000fd0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001030": {
            "entrypoint": "0x08001030",
            "current_name": "check_if_concatenated_parameters_are_empty_08001030",
            "code": "\nbool check_if_concatenated_parameters_are_empty_08001030(void)\n\n{\n  char input_character;\n  \n  concatenate_parameters_08000fc8();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001030": "check_if_concatenated_parameters_are_empty_08001030",
                "in_CY": "input_character"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08000fc8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001044": {
            "entrypoint": "0x08001044",
            "current_name": "check_validity_08001044",
            "code": "\nuint checkValidity_08001044(uint input)\n\n{\n  uint result;\n  \n  if (((input & 0x80000000) != 0) || (input << 1 < 0x7f000000)) {\n    return 0;\n  }\n  result = 0x9e - ((input << 1) >> 0x18);\n  if (-1 < (int)result) {\n    return (input << 8 | 0x80000000) >> (result & 0xff);\n  }\n  if ((result == 0xffffff9f) && ((input & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08001044": "check_validity_08001044",
                "param_1": "input",
                "uVar1": "result"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001084": {
            "entrypoint": "0x08001084",
            "current_name": "copy_memory_08001084",
            "code": "\nundefined4 * copyMemory_08001084(undefined4 *destination,undefined4 *source,uint size)\n\n{\n  undefined4 *destPtr;\n  undefined4 *destPtrTmp;\n  undefined4 *srcPtr;\n  uint remainingSize1;\n  uint remainingSize2;\n  bool condition;\n  \n  destPtrTmp = destination;\n  if ((((uint)source | (uint)destination) & 3) != 0) {\n    if (size < 8) {\n      remainingSize2 = size - 4;\n      if (3 < size) {\n        do {\n          destPtr = source;\n          srcPtr = destPtrTmp;\n          condition = remainingSize2 != 0;\n          remainingSize2 = remainingSize2 - 1;\n          *(undefined *)srcPtr = *(undefined *)destPtr;\n          destPtrTmp = (undefined4 *)((int)srcPtr + 1);\n          source = (undefined4 *)((int)destPtr + 1);\n        } while (condition);\n        *(undefined *)(undefined4 *)((int)srcPtr + 1) =\n             *(undefined *)(undefined4 *)((int)destPtr + 1);\n        *(undefined *)((int)srcPtr + 2) = *(undefined *)((int)destPtr + 2);\n        *(undefined *)((int)srcPtr + 3) = *(undefined *)((int)destPtr + 3);\n        return destination;\n      }\n      goto LAB_08001108;\n    }\n    if ((((uint)source & 3) != 0) && (((uint)destination & 3) != 0)) {\n      remainingSize2 = 4 - ((uint)destination & 3);\n      size = size - remainingSize2;\n      destPtr = destination;\n      srcPtr = source;\n      if (((uint)destination & 1) != 0) {\n        srcPtr = (undefined4 *)((int)source + 1);\n        destPtr = (undefined4 *)((int)destination + 1);\n        *(undefined *)destination = *(undefined *)source;\n      }\n      destPtrTmp = destPtr;\n      source = srcPtr;\n      if ((remainingSize2 & 2) != 0) {\n        source = (undefined4 *)((int)srcPtr + 2);\n        destPtrTmp = (undefined4 *)((int)destPtr + 2);\n        *(undefined2 *)destPtr = *(undefined2 *)srcPtr;\n      }\n    }\n  }\n  while (0x3f < size) {\n    *destPtrTmp = *source;\n    destPtrTmp[1] = source[1];\n    destPtrTmp[2] = source[2];\n    destPtrTmp[3] = source[3];\n    destPtrTmp[4] = source[4];\n    destPtrTmp[5] = source[5];\n    destPtrTmp[6] = source[6];\n    destPtrTmp[7] = source[7];\n    destPtrTmp[8] = source[8];\n    destPtrTmp[9] = source[9];\n    destPtrTmp[10] = source[10];\n    destPtrTmp[0xb] = source[0xb];\n    destPtrTmp[0xc] = source[0xc];\n    destPtrTmp[0xd] = source[0xd];\n    destPtrTmp[0xe] = source[0xe];\n    destPtrTmp[0xf] = source[0xf];\n    destPtrTmp = destPtrTmp + 0x10;\n    source = source + 0x10;\n    size = size - 0x40;\n  }\n  remainingSize1 = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n      *destPtrTmp = *source;\n      destPtrTmp[1] = source[1];\n      destPtrTmp[2] = source[2];\n      destPtrTmp[3] = source[3];\n      destPtrTmp = destPtrTmp + 4;\n      source = source + 4;\n      condition = 0xf < remainingSize1;\n      remainingSize1 = remainingSize1 - 0x10;\n    } while (condition);\n  }\n  remainingSize2 = remainingSize1 + 0xc;\n  srcPtr = destPtrTmp;\n  destPtr = source;\n  if (0xfffffff3 < remainingSize1) {\n    do {\n      source = destPtr + 1;\n      *srcPtr = *destPtr;\n      condition = 3 < remainingSize2;\n      remainingSize2 = remainingSize2 - 4;\n      destPtrTmp = srcPtr + 1;\n      srcPtr = srcPtr + 1;\n      destPtr = source;\n    } while (condition);\n  }\nLAB_08001108:\n  if (remainingSize2 + 4 != 0) {\n    destPtr = destPtrTmp;\n    srcPtr = source;\n    if ((remainingSize2 & 1) != 0) {\n      srcPtr = (undefined4 *)((int)source + 1);\n      destPtr = (undefined4 *)((int)destPtrTmp + 1);\n      *(undefined *)destPtrTmp = *(undefined *)source;\n    }\n    if ((remainingSize2 + 4 & 2) != 0) {\n      *(undefined2 *)destPtr = *(undefined2 *)srcPtr;\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08001084": "copy_memory_08001084",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "size",
                "puVar1": "destPtr",
                "puVar2": "destPtrTmp",
                "puVar3": "srcPtr",
                "uVar4": "remainingSize1",
                "uVar5": "remainingSize2",
                "bVar6": "condition"
            },
            "calling": [
                "FUN_08009120",
                "FUN_080097cc",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001170": {
            "entrypoint": "0x08001170",
            "current_name": "is_valid_input_08001170",
            "code": "\nundefined4 is_valid_input_08001170(uint input_1,int input_2,uint input_3,int input_4)\n\n{\n  if ((((input_2 << 1) >> 0x15 != -1) || ((input_1 | input_2 << 0xc) == 0)) &&\n     (((input_4 << 1) >> 0x15 != -1 || ((input_3 | input_4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08001170": "is_valid_input_08001170",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800119c": {
            "entrypoint": "0x0800119c",
            "current_name": "calculate_value_0800119c",
            "code": "\nuint calculate_value_0800119c(uint input_value1,uint input_value2)\n\n{\n  uint result;\n  int modified_param2;\n  uint shifted_value;\n  \n  modified_param2 = input_value2 * 2 + 0x200000;\n  if (input_value2 * 2 < 0xffe00000) {\n    if (-1 < modified_param2) {\n      return 0;\n    }\n    result = modified_param2 >> 0x15;\n    shifted_value = -result - 0x3e1;\n    if (result < 0xfffffc20 && shifted_value != 0) {\n      result = (input_value2 << 0xb | 0x80000000 | input_value1 >> 0x15) >> (shifted_value & 0xff);\n      if ((input_value2 & 0x80000000) != 0) {\n        result = -result;\n      }\n      return result;\n    }\n  }\n  else if ((input_value1 | input_value2 << 0xc) != 0) {\n    return 0;\n  }\n  input_value2 = input_value2 & 0x80000000;\n  if (input_value2 == 0) {\n    input_value2 = 0x7fffffff;\n  }\n  return input_value2;\n}\n\n",
            "renaming": {
                "FUN_0800119c": "calculate_value_0800119c",
                "param_1": "input_value1",
                "param_2": "input_value2",
                "uVar1": "result",
                "iVar2": "modified_param2",
                "uVar3": "shifted_value"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011ec": {
            "entrypoint": "0x080011ec",
            "current_name": "calculate_result_080011ec",
            "code": "\nundefined8 calculate_result_080011ec(int input_1,int input_2,int input_3,int input_4)\n\n{\n  undefined8 result;\n  \n  if ((input_4 == 0) && (input_3 == 0)) {\n    if (input_2 != 0 || input_1 != 0) {\n      input_2 = -1;\n      input_1 = -1;\n    }\n    return CONCAT44(input_2,input_1);\n  }\n  result = calculate_quotient_remainder_0800121c();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080011ec": "calculate_result_080011ec",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "result"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_0800121c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800121c": {
            "entrypoint": "0x0800121c",
            "current_name": "calculate_quotient_remainder_0800121c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080014b2) */\n\nundefined8 calculate_quotient_remainder_0800121c(uint dividend,uint divisor,uint high_divisor,uint base,uint *remainder_address)\n\n{\n  code *software_udf;\n  ulonglong product;\n  uint quotient;\n  uint quotient1;\n  uint product1;\n  int shift;\n  uint quotient2;\n  uint divisor_shifted;\n  uint temp1;\n  uint *puVar9;\n  uint temp2;\n  uint temp3;\n  uint product2;\n  bool carry;\n  undefined8 result;\n  \n  if (base == 0) {\n    if (divisor < high_divisor) {\n      shift = LZCOUNT(high_divisor);\n      divisor_shifted = high_divisor;\n      if (shift != 0) {\n        divisor_shifted = high_divisor << shift;\n        divisor = dividend >> (0x20U - shift & 0xff) | divisor << shift;\n        dividend = dividend << shift;\n      }\n      temp3 = divisor_shifted >> 0x10;\n      temp1 = divisor / temp3;\n      temp2 = temp1 * (divisor_shifted & 0xffff);\n      quotient2 = dividend >> 0x10 | (divisor - temp3 * temp1) * 0x10000;\n      quotient1 = temp1;\n      if (quotient2 <= temp2 && temp2 - quotient2 != 0) {\n        carry = CARRY4(divisor_shifted,quotient2);\n        quotient2 = divisor_shifted + quotient2;\n        quotient1 = temp1 - 1;\n        if ((carry == false) && (quotient2 <= temp2 && temp2 - quotient2 != 0)) {\n          quotient1 = temp1 - 2;\n          quotient2 = quotient2 + divisor_shifted;\n        }\n      }\n      quotient = (quotient2 - temp2) / temp3;\n      product1 = quotient * (divisor_shifted & 0xffff);\n      temp1 = dividend & 0xffff | ((quotient2 - temp2) - temp3 * quotient) * 0x10000;\n      quotient2 = quotient;\n      if (temp1 <= product1 && product1 - temp1 != 0) {\n        carry = CARRY4(divisor_shifted,temp1);\n        temp1 = divisor_shifted + temp1;\n        quotient2 = quotient - 1;\n        if ((carry == false) && (temp1 <= product1 && product1 - temp1 != 0)) {\n          quotient2 = quotient - 2;\n          temp1 = temp1 + divisor_shifted;\n        }\n      }\n      quotient2 = quotient2 | quotient1 << 0x10;\n      puVar9 = (uint *)0x0;\n      temp1 = temp1 - product1;\n    }\n    else {\n      if (high_divisor == 0) {\n                    /* WARNING: Treating indirect jump as call */\n        software_udf = (code *)software_udf(0xff,0x8001302);\n        result = (*software_udf)();\n        return result;\n      }\n      shift = LZCOUNT(high_divisor);\n      if (shift == 0) {\n        puVar9 = (uint *)0x1;\n        divisor = divisor - high_divisor;\n        temp3 = high_divisor >> 0x10;\n        quotient = high_divisor & 0xffff;\n        divisor_shifted = high_divisor;\n      }\n      else {\n        divisor_shifted = high_divisor << shift;\n        quotient2 = divisor >> (0x20U - shift & 0xff);\n        temp3 = divisor_shifted >> 0x10;\n        temp2 = quotient2 / temp3;\n        quotient = divisor_shifted & 0xffff;\n        product1 = temp2 * quotient;\n        temp1 = dividend >> (0x20U - shift & 0xff) | divisor << shift;\n        quotient1 = temp1 >> 0x10 | (quotient2 - temp3 * temp2) * 0x10000;\n        dividend = dividend << shift;\n        quotient2 = temp2;\n        if (quotient1 <= product1 && product1 - quotient1 != 0) {\n          carry = CARRY4(divisor_shifted,quotient1);\n          quotient1 = divisor_shifted + quotient1;\n          quotient2 = temp2 - 1;\n          if ((carry == false) && (quotient1 <= product1 && product1 - quotient1 != 0)) {\n            quotient2 = temp2 - 2;\n            quotient1 = quotient1 + divisor_shifted;\n          }\n        }\n        temp2 = (quotient1 - product1) / temp3;\n        product2 = temp2 * quotient;\n        divisor = temp1 & 0xffff | ((quotient1 - product1) - temp3 * temp2) * 0x10000;\n        quotient1 = temp2;\n        if (divisor <= product2 && product2 - divisor != 0) {\n          carry = CARRY4(divisor_shifted,divisor);\n          divisor = divisor_shifted + divisor;\n          quotient1 = temp2 - 1;\n          if ((carry == false) && (divisor <= product2 && product2 - divisor != 0)) {\n            quotient1 = temp2 - 2;\n            divisor = divisor + divisor_shifted;\n          }\n        }\n        divisor = divisor - product2;\n        puVar9 = (uint *)(quotient1 | quotient2 << 0x10);\n      }\n      temp2 = divisor / temp3;\n      quotient2 = quotient * temp2;\n      temp1 = dividend >> 0x10 | (divisor - temp3 * temp2) * 0x10000;\n      quotient1 = temp2;\n      if (temp1 <= quotient2 && quotient2 - temp1 != 0) {\n        carry = CARRY4(divisor_shifted,temp1);\n        temp1 = divisor_shifted + temp1;\n        quotient1 = temp2 - 1;\n        if ((carry == false) && (temp1 <= quotient2 && quotient2 - temp1 != 0)) {\n          quotient1 = temp2 - 2;\n          temp1 = temp1 + divisor_shifted;\n        }\n      }\n      temp2 = (temp1 - quotient2) / temp3;\n      quotient = quotient * temp2;\n      temp1 = dividend & 0xffff | ((temp1 - quotient2) - temp3 * temp2) * 0x10000;\n      quotient2 = temp2;\n      if (temp1 <= quotient && quotient - temp1 != 0) {\n        carry = CARRY4(divisor_shifted,temp1);\n        temp1 = divisor_shifted + temp1;\n        quotient2 = temp2 - 1;\n        if ((carry == false) && (temp1 <= quotient && quotient - temp1 != 0)) {\n          quotient2 = temp2 - 2;\n          temp1 = temp1 + divisor_shifted;\n        }\n      }\n      temp1 = temp1 - quotient;\n      quotient2 = quotient2 | quotient1 << 0x10;\n    }\n    if (remainder_address != (uint *)0x0) {\n      *remainder_address = temp1 >> LZCOUNT(high_divisor);\n      remainder_address[1] = 0;\n    }\n  }\n  else {\n    puVar9 = remainder_address;\n    if (divisor < base) {\n      if (remainder_address != (uint *)0x0) {\n        *remainder_address = dividend;\n        remainder_address[1] = divisor;\n        return 0;\n      }\n      quotient2 = 0;\n    }\n    else {\n      shift = LZCOUNT(base);\n      if (shift == 0) {\n        if ((base < divisor) || (high_divisor <= dividend)) {\n          carry = dividend < high_divisor;\n          dividend = dividend - high_divisor;\n          divisor = (divisor - base) - (uint)carry;\n          quotient2 = 1;\n        }\n        else {\n          quotient2 = 0;\n        }\n        puVar9 = (uint *)0x0;\n        if (remainder_address != (uint *)0x0) {\n          *remainder_address = dividend;\n          remainder_address[1] = divisor;\n        }\n      }\n      else {\n        temp1 = 0x20 - shift;\n        quotient = high_divisor >> (temp1 & 0xff) | base << shift;\n        divisor_shifted = divisor >> (temp1 & 0xff);\n        product1 = quotient >> 0x10;\n        temp2 = divisor_shifted / product1;\n        temp3 = temp2 * (quotient & 0xffff);\n        quotient2 = divisor << shift | dividend >> (temp1 & 0xff);\n        quotient1 = quotient2 >> 0x10 | (divisor_shifted - product1 * temp2) * 0x10000;\n        dividend = dividend << shift;\n        divisor_shifted = temp2;\n        if (quotient1 <= temp3 && temp3 - quotient1 != 0) {\n          carry = CARRY4(quotient,quotient1);\n          quotient1 = quotient + quotient1;\n          divisor_shifted = temp2 - 1;\n          if ((carry == false) && (quotient1 <= temp3 && temp3 - quotient1 != 0)) {\n            divisor_shifted = temp2 - 2;\n            quotient1 = quotient1 + quotient;\n          }\n        }\n        temp2 = (quotient1 - temp3) / product1;\n        product2 = temp2 * (quotient & 0xffff);\n        quotient1 = quotient2 & 0xffff | ((quotient1 - temp3) - product1 * temp2) * 0x10000;\n        quotient2 = temp2;\n        if (quotient1 <= product2 && product2 - quotient1 != 0) {\n          carry = CARRY4(quotient,quotient1);\n          quotient1 = quotient + quotient1;\n          quotient2 = temp2 - 1;\n          if ((carry == false) && (quotient1 <= product2 && product2 - quotient1 != 0)) {\n            quotient2 = temp2 - 2;\n            quotient1 = quotient1 + quotient;\n          }\n        }\n        quotient2 = quotient2 | divisor_shifted << 0x10;\n        product = (ulonglong)quotient2 * (ulonglong)(high_divisor << shift);\n        if (CONCAT44(quotient1 - product2,dividend) < product) {\n          quotient2 = quotient2 - 1;\n          product = product - CONCAT44(quotient,high_divisor << shift);\n        }\n        if (remainder_address != (uint *)0x0) {\n          divisor_shifted = ((quotient1 - product2) - (int)(product >> 0x20)) - (uint)(dividend < (uint)product);\n          *remainder_address = divisor_shifted << (temp1 & 0xff) | dividend - (uint)product >> shift;\n          remainder_address[1] = divisor_shifted >> shift;\n          puVar9 = (uint *)0x0;\n        }\n      }\n    }\n  }\n  return CONCAT44(puVar9,quotient2);\n}\n\n",
            "renaming": {
                "FUN_0800121c": "calculate_quotient_remainder_0800121c",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "high_divisor",
                "param_4": "base",
                "param_5": "remainder_address",
                "UNRECOVERED_JUMPTABLE": "software_udf",
                "uVar1": "product",
                "uVar2": "quotient",
                "uVar3": "quotient1",
                "uVar4": "product1",
                "iVar5": "shift",
                "uVar6": "quotient2",
                "uVar7": "divisor_shifted",
                "uVar8": "temp1",
                "uVar10": "temp2",
                "uVar11": "temp3",
                "uVar12": "product2",
                "bVar13": "carry",
                "uVar14": "result"
            },
            "calling": [
                "FUN_080011ec"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014f0": {
            "entrypoint": "0x080014f0",
            "current_name": "initialize_system_080014f0",
            "code": "\n\n\nundefined4 initializeSystem_080014f0(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  setRegisterValue(3);\n  updateValue(0xf);\n  FUNC_08002d8a();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080014f0": "initialize_system_080014f0",
                "set_register_value_08001714": "setRegisterValue",
                "update_value_0800151c": "updateValue"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_0800151c",
                "FUN_08002d8a",
                "FUN_08001714"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800151c": {
            "entrypoint": "0x0800151c",
            "current_name": "update_value_0800151c",
            "code": "\nundefined4 updateValue_0800151c(uint inputValue)\n\n{\n  int updateResult;\n  undefined4 returnValue;\n  \n  updateResult = update_value_08001762((int)((ulonglong)DAT_20000018 / (1000 / (ulonglong)DAT_20000004)));\n  if (updateResult == 0) {\n    if (inputValue < 0x10) {\n      set_byte_value_with_bitwise_operations_0800172a(0xffffffff,inputValue,0);\n      returnValue = 0;\n      DAT_20000000 = inputValue;\n    }\n    else {\n      returnValue = 1;\n    }\n  }\n  else {\n    returnValue = 1;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_0800151c": "update_value_0800151c",
                "param_1": "inputValue",
                "iVar1": "updateResult",
                "uVar2": "returnValue"
            },
            "calling": [
                "FUN_080014f0",
                "FUN_08003260"
            ],
            "called": [
                "FUN_0800172a",
                "FUN_08001762"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800157c": {
            "entrypoint": "0x0800157c",
            "current_name": "add_data_to_global_variable_0800157c",
            "code": "\nvoid addDataToGlobalVariable_0800157c(void)\n\n{\n  DAT_20000a48 = DAT_20000a48 + (uint)DAT_20000004;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800157c": "add_data_to_global_variable_0800157c"
            },
            "calling": [
                "FUN_08005704"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015a0": {
            "entrypoint": "0x080015a0",
            "current_name": "get_data_from_memory_080015a0",
            "code": "\nundefined4 get_data_from_memory_080015a0(void)\n\n{\n  return DAT_20000a48;\n}\n\n",
            "renaming": {
                "FUN_080015a0": "get_data_from_memory_080015a0"
            },
            "calling": [
                "FUN_08004436",
                "FUN_08001ccc",
                "FUN_08002c2e",
                "FUN_080027f4",
                "FUN_08002ca8",
                "FUN_08002bb4",
                "FUN_08002ad8",
                "FUN_08004f2c",
                "FUN_08002d98",
                "FUN_08003260",
                "FUN_08002640",
                "FUN_08001f6c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b4": {
            "entrypoint": "0x080015b4",
            "current_name": "set_register_value_080015b4",
            "code": "\n\n\nvoid setRegisterValue_080015b4(uint inputParam)\n\n{\n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | (inputParam & 7) << 8 | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b4": "set_register_value_080015b4",
                "param_1": "inputParam"
            },
            "calling": [
                "FUN_08001714"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015fc": {
            "entrypoint": "0x080015fc",
            "current_name": "get_shifted_and_masked_bits_080015fc",
            "code": "\n\n\nuint getShiftedAndMaskedBits_080015fc(void)\n\n{\n  return _DAT_e000ed0c >> 8 & 7;\n}\n\n",
            "renaming": {
                "FUN_080015fc": "get_shifted_and_masked_bits_080015fc"
            },
            "calling": [
                "FUN_0800172a"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001618": {
            "entrypoint": "0x08001618",
            "current_name": "set_byte_value_08001618",
            "code": "\nvoid setByteValue_08001618(byte byteValue,uint value)\n\n{\n  if ((char)byteValue < '\\0') {\n    *(char *)((byteValue & 0xf) + 0xe000ed14) = (char)((value & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)byteValue + -0x1fff1c00) = (char)((value & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001618": "set_byte_value_08001618",
                "param_1": "byteValue",
                "param_2": "value"
            },
            "calling": [
                "FUN_0800172a",
                "FUN_080016d0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800166c": {
            "entrypoint": "0x0800166c",
            "current_name": "apply_bitwise_operations_0800166c",
            "code": "\nuint applyBitwiseOperations_0800166c(uint input_1,uint input_2,uint input_3)\n\n{\n  uint unusedBits;\n  \n  input_1 = input_1 & 7;\n  unusedBits = 7 - input_1;\n  if (3 < unusedBits) {\n    unusedBits = 4;\n  }\n  if (input_1 + 4 < 7) {\n    input_1 = 0;\n  }\n  else {\n    input_1 = input_1 - 3;\n  }\n  return input_3 & ~(-1 << (input_1 & 0xff)) |\n         (~(-1 << (unusedBits & 0xff)) & input_2) << (input_1 & 0xff);\n}\n\n",
            "renaming": {
                "FUN_0800166c": "apply_bitwise_operations_0800166c",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "uVar1": "unusedBits"
            },
            "calling": [
                "FUN_0800172a"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016d0": {
            "entrypoint": "0x080016d0",
            "current_name": "check_and_update_value_080016d0",
            "code": "\n\n\nbool checkAndUpdateValue_080016d0(int value)\n\n{\n  bool isValidValue;\n  \n  isValidValue = value - 1U < 0x1000000;\n  if (isValidValue) {\n    _DAT_e000e014 = value + -1;\n    set_byte_value_08001618(0xffffffff,0xf);\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n  }\n  return !isValidValue;\n}\n\n",
            "renaming": {
                "FUN_080016d0": "check_and_update_value_080016d0",
                "param_1": "value",
                "bVar1": "isValidValue"
            },
            "calling": [
                "FUN_08001762"
            ],
            "called": [
                "FUN_08001618"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001714": {
            "entrypoint": "0x08001714",
            "current_name": "set_register_value_08001714",
            "code": "\nvoid set_register_value_08001714(undefined4 register_value)\n\n{\n  set_register_value_08001714_080015b4(register_value);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001714": "set_register_value_08001714",
                "param_1": "register_value"
            },
            "calling": [
                "FUN_080014f0"
            ],
            "called": [
                "FUN_080015b4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800172a": {
            "entrypoint": "0x0800172a",
            "current_name": "set_byte_value_with_bitwise_operations_0800172a",
            "code": "\nvoid setByteValueWithBitwiseOperations_0800172a(char value,undefined4 param2,undefined4 param3)\n\n{\n  undefined4 shiftedAndMaskedBits;\n  \n  shiftedAndMaskedBits = getShiftedAndMaskedBits();\n  shiftedAndMaskedBits = applyBitwiseOperations(shiftedAndMaskedBits,param2,param3);\n  setByteValue((int)value,shiftedAndMaskedBits);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800172a": "set_byte_value_with_bitwise_operations_0800172a",
                "param_1": "value",
                "param_2": "param2",
                "param_3": "param3",
                "uVar1": "shiftedAndMaskedBits",
                "get_shifted_and_masked_bits_080015fc": "getShiftedAndMaskedBits",
                "apply_bitwise_operations_0800166c": "applyBitwiseOperations",
                "set_byte_value_08001618": "setByteValue"
            },
            "calling": [
                "FUN_0800151c",
                "FUN_080052a0"
            ],
            "called": [
                "FUN_08001618",
                "FUN_080015fc",
                "FUN_0800166c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001762": {
            "entrypoint": "0x08001762",
            "current_name": "update_value_08001762",
            "code": "\nundefined4 update_value_08001762(undefined4 input_value)\n\n{\n  undefined4 updated_value;\n  \n  updated_value = check_and_update_value_08001762_080016d0(input_value);\n  return updated_value;\n}\n\n",
            "renaming": {
                "FUN_08001762": "update_value_08001762",
                "param_1": "input_value",
                "uVar1": "updated_value"
            },
            "calling": [
                "FUN_0800151c",
                "FUN_080052a0"
            ],
            "called": [
                "FUN_080016d0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800177c": {
            "entrypoint": "0x0800177c",
            "current_name": "set_register_bits_0800177c",
            "code": "\n\n\nvoid setRegisterBits_0800177c(int bitPosition)\n\n{\n  if (bitPosition == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800177c": "set_register_bits_0800177c",
                "param_1": "bitPosition"
            },
            "calling": [
                "FUN_080052a0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017b4": {
            "entrypoint": "0x080017b4",
            "current_name": "calculate_pitch_and_update_data_080017b4",
            "code": "\nvoid calculate_pitch_and_update_data_080017b4(void)\n\n{\n  calculate_and_update(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080017b4": "calculate_pitch_and_update_data_080017b4",
                "calculate_pitch_and_update_data_08004f78": "calculate_and_update"
            },
            "calling": [
                "FUN_08005704"
            ],
            "called": [
                "FUN_08004f78"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017c4": {
            "entrypoint": "0x080017c4",
            "current_name": "update_bitwise_operations_080017c4",
            "code": "\n\n\nvoid updateBitwiseOperations_080017c4(uint *flagsArray,uint *inputArray)\n\n{\n  uint bitMask;\n  uint flagCheck;\n  uint opcode;\n  uint *flagsPointer;\n  int index;\n  uint newValue;\n  uint counter;\n  \n  newValue = 0;\n  counter = 0;\n  do {\n    if (0xf < counter) {\n      return;\n    }\n    bitMask = 1 << (counter & 0xff);\n    flagCheck = *inputArray & bitMask;\n    if (flagCheck == bitMask) {\n      opcode = inputArray[1];\n      if (opcode == 0x12) {\n        newValue = inputArray[3] + 0xc;\n      }\n      else if (opcode < 0x13) {\n        if (opcode == 2) {\n          newValue = inputArray[3] + 8;\n        }\n        else if (opcode < 3) {\n          if (opcode == 0) goto LAB_08001882;\n          if (opcode == 1) {\n            newValue = inputArray[3];\n          }\n        }\n        else if (opcode == 3) {\n          newValue = 0;\n        }\n        else if (opcode == 0x11) {\n          newValue = inputArray[3] + 4;\n        }\n      }\n      else if (opcode == 0x10210000) {\nLAB_08001882:\n        if (inputArray[2] == 0) {\n          newValue = 4;\n        }\n        else if (inputArray[2] == 1) {\n          newValue = 8;\n          flagsArray[4] = bitMask;\n        }\n        else {\n          newValue = 8;\n          flagsArray[5] = bitMask;\n        }\n      }\n      else if (opcode < 0x10210001) {\n        if ((opcode == 0x10110000) || (opcode == 0x10120000)) goto LAB_08001882;\n      }\n      else if (((opcode == 0x10310000) || (opcode == 0x10320000)) || (opcode == 0x10220000))\n      goto LAB_08001882;\n      if (flagCheck < 0x100) {\n        bitMask = counter << 2;\n        flagsPointer = flagsArray;\n      }\n      else {\n        flagsPointer = flagsArray + 1;\n        bitMask = (counter - 8) * 4;\n      }\n      *flagsPointer = *flagsPointer & ~(0xf << (bitMask & 0xff)) | newValue << (bitMask & 0xff);\n      if ((inputArray[1] & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        if (flagsArray == (uint *)0x40010800) {\n          index = 0;\n        }\n        else if (flagsArray == (uint *)0x40010c00) {\n          index = 1;\n        }\n        else if (flagsArray == (uint *)0x40011000) {\n          index = 2;\n        }\n        else if (flagsArray == (uint *)0x40011400) {\n          index = 3;\n        }\n        else {\n          index = 4;\n        }\n        *(uint *)(((counter >> 2) + 2) * 4 + 0x40010000) =\n             index << ((counter & 3) << 2) |\n             ~(0xf << ((counter & 3) << 2)) & *(uint *)(((counter >> 2) + 2) * 4 + 0x40010000);\n        if ((inputArray[1] & 0x10000) == 0) {\n          _DAT_40010400 = ~flagCheck & _DAT_40010400;\n        }\n        else {\n          _DAT_40010400 = flagCheck | _DAT_40010400;\n        }\n        if ((inputArray[1] & 0x20000) == 0) {\n          _DAT_40010404 = ~flagCheck & _DAT_40010404;\n        }\n        else {\n          _DAT_40010404 = flagCheck | _DAT_40010404;\n        }\n        if ((inputArray[1] & 0x100000) == 0) {\n          _DAT_40010408 = ~flagCheck & _DAT_40010408;\n        }\n        else {\n          _DAT_40010408 = flagCheck | _DAT_40010408;\n        }\n        if ((inputArray[1] & 0x200000) == 0) {\n          _DAT_4001040c = ~flagCheck & _DAT_4001040c;\n        }\n        else {\n          _DAT_4001040c = flagCheck | _DAT_4001040c;\n        }\n      }\n    }\n    counter = counter + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080017c4": "update_bitwise_operations_080017c4",
                "param_1": "flagsArray",
                "param_2": "inputArray",
                "uVar1": "bitMask",
                "uVar2": "flagCheck",
                "uVar3": "opcode",
                "puVar4": "flagsPointer",
                "iVar5": "index",
                "local_10": "newValue",
                "local_c": "counter"
            },
            "calling": [
                "FUN_08005680",
                "FUN_080055f4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a80": {
            "entrypoint": "0x08001a80",
            "current_name": "update_data_08001a80",
            "code": "\nvoid updateData_08001a80(int dataAddress,ushort newValue,char isShifted)\n\n{\n  if (isShifted == '\\0') {\n    *(unsignedInt *)(dataAddress + 0x10) = (unsignedInt)newValue << 0x10;\n  }\n  else {\n    *(unsignedInt *)(dataAddress + 0x10) = (unsignedInt)newValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a80": "update_data_08001a80",
                "param_1": "dataAddress",
                "param_2": "newValue",
                "param_3": "isShifted",
                "uint": "unsignedInt"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_080055f4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "calculate_param_values_08001ab0",
            "code": "\nundefined4 calculateParamValues_08001ab0(uint **parameters)\n\n{\n  uint result;\n  char isValid;\n  undefined4 returnValue;\n  uint value;\n  bool isZero;\n  \n  if (parameters == (uint **)0x0) {\n    returnValue = 1;\n  }\n  else {\n    if (*(char *)((int)parameters + 0x3d) == '\\0') {\n      *(undefined *)(parameters + 0xf) = 0;\n      FUNC_08001cb8(parameters);\n    }\n    *(undefined *)((int)parameters + 0x3d) = 0x24;\n    **parameters = **parameters & 0xfffffffe;\n    result = extracted_memory_address_08003518();\n    if (parameters[1] < (uint *)0x186a1) {\n      value = result;\n      if (result < 2000000) {\n        value = 1;\n      }\n      isValid = (char)value;\n      if (1999999 < result) {\n        isValid = '\\0';\n      }\n    }\n    else {\n      value = result;\n      if (result < 4000000) {\n        value = 1;\n      }\n      isValid = (char)value;\n      if (3999999 < result) {\n        isValid = '\\0';\n      }\n    }\n    if (isValid == '\\0') {\n      value = result / 1000000;\n      (*parameters)[1] = value;\n      if ((uint *)0x186a0 < parameters[1]) {\n        value = (value * 300) / 1000;\n      }\n      (*parameters)[8] = value + 1;\n      if (parameters[1] < (uint *)0x186a1) {\n        result = (result - 1) / (uint)((int)parameters[1] << 1) + 1 & 0xfff;\n        if (result < 4) {\n          result = 4;\n        }\n      }\n      else {\n        if (parameters[2] == (uint *)0x0) {\n          value = (result - 1) / (uint)((int)parameters[1] * 3) + 1 & 0xfff;\n          isZero = value == 0;\n          if (isZero) {\n            value = 1;\n          }\n          isValid = (char)value;\n          if (!isZero) {\n            isValid = '\\0';\n          }\n        }\n        else {\n          value = (result - 1) / (uint)((int)parameters[1] * 0x19) + 1 & 0xfff;\n          isZero = value == 0;\n          if (isZero) {\n            value = 1;\n          }\n          isValid = (char)value;\n          if (!isZero) {\n            isValid = '\\0';\n          }\n        }\n        if (isValid == '\\0') {\n          if (parameters[2] == (uint *)0x0) {\n            result = (result - 1) / (uint)((int)parameters[1] * 3) + 1 & 0xfff | 0x8000;\n          }\n          else {\n            result = (result - 1) / (uint)((int)parameters[1] * 0x19) + 1 & 0xfff | 0xc000;\n          }\n        }\n        else {\n          result = 1;\n        }\n      }\n      (*parameters)[7] = result;\n      **parameters = (uint)parameters[8] | (uint)parameters[7];\n      (*parameters)[2] = (uint)parameters[3] | (uint)parameters[4];\n      (*parameters)[3] = (uint)parameters[6] | (uint)parameters[5];\n      **parameters = **parameters | 1;\n      parameters[0x10] = (uint *)0x0;\n      *(undefined *)((int)parameters + 0x3d) = 0x20;\n      parameters[0xc] = (uint *)0x0;\n      *(undefined *)((int)parameters + 0x3e) = 0;\n      returnValue = 0;\n    }\n    else {\n      returnValue = 1;\n    }\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "calculate_param_values_08001ab0",
                "param_1": "parameters",
                "uVar1": "result",
                "cVar2": "isValid",
                "uVar3": "returnValue",
                "uVar4": "value",
                "bVar5": "isZero"
            },
            "calling": [
                "FUN_08005348"
            ],
            "called": [
                "FUN_08003518",
                "FUN_08001cb8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cb8": {
            "entrypoint": "0x08001cb8",
            "current_name": "FUNC_08001cb8",
            "code": "\nvoid FUNC_08001cb8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cb8": "FUNC_08001cb8"
            },
            "calling": [
                "FUN_08001ab0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001ccc": {
            "entrypoint": "0x08001ccc",
            "current_name": "process_data_08001ccc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001d5e) */\n/* WARNING: Removing unreachable block (ram,0x08001d70) */\n/* WARNING: Removing unreachable block (ram,0x08001d72) */\n/* WARNING: Removing unreachable block (ram,0x08001d74) */\n\nundefined4\nprocessData_08001ccc(uint **data,undefined2 value1,undefined2 value2,undefined2 value3,uint *flags,\n            undefined2 value4,undefined4 result)\n\n{\n  int dataFromMemory;\n  int loopVar;\n  undefined4 returnValue;\n  uint *ptr;\n  \n  dataFromMemory = getDataFromMemory();\n  if (*(char *)((int)data + 0x3d) == ' ') {\n    do {\n      if ((~(*data)[6] & 2) != 0) {\n        loopVar = 0;\n        goto LAB_08001d9c;\n      }\n      loopVar = getDataFromMemory();\n    } while ((uint)(loopVar - dataFromMemory) < 0x1a);\n    data[0xc] = (uint *)0x0;\n    *(undefined *)((int)data + 0x3d) = 0x20;\n    *(undefined *)((int)data + 0x3e) = 0;\n    *(undefined *)(data + 0xf) = 0;\n    loopVar = 3;\nLAB_08001d9c:\n    if (loopVar == 0) {\n      if (*(char *)(data + 0xf) == '\\x01') {\n        returnValue = 2;\n      }\n      else {\n        *(undefined *)(data + 0xf) = 1;\n        if ((**data & 1) != 1) {\n          **data = **data | 1;\n        }\n        **data = **data & 0xfffff7ff;\n        *(undefined *)((int)data + 0x3d) = 0x21;\n        *(undefined *)((int)data + 0x3e) = 0x40;\n        data[0x10] = (uint *)0x0;\n        data[9] = flags;\n        *(undefined2 *)((int)data + 0x2a) = value4;\n        data[0xb] = (uint *)0xffff0000;\n        *(undefined2 *)(data + 10) = *(undefined2 *)((int)data + 0x2a);\n        loopVar = processData_08001ccc(data,value1,value2,value3,result,dataFromMemory);\n        if (loopVar == 0) {\n          while (*(short *)(data + 10) != 0) {\n            loopVar = checkFlagAndData(data,result,dataFromMemory);\n            if (loopVar != 0) {\n              if (data[0x10] == (uint *)0x4) {\n                **data = **data | 0x200;\n                return 1;\n              }\n              return 3;\n            }\n            ptr = data[9];\n            data[9] = (uint *)((int)ptr + 1);\n            (*data)[4] = (uint)*(byte *)ptr;\n            *(short *)(data + 10) = *(short *)(data + 10) + -1;\n            *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n            if ((((*data)[5] & 4) == 4) && (*(short *)(data + 10) != 0)) {\n              ptr = data[9];\n              data[9] = (uint *)((int)ptr + 1);\n              (*data)[4] = (uint)*(byte *)ptr;\n              *(short *)(data + 10) = *(short *)(data + 10) + -1;\n              *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n            }\n          }\n          dataFromMemory = checkFlagAndUpdate(data,result,dataFromMemory);\n          if (dataFromMemory == 0) {\n            **data = **data | 0x200;\n            *(undefined *)((int)data + 0x3d) = 0x20;\n            *(undefined *)((int)data + 0x3e) = 0;\n            *(undefined *)(data + 0xf) = 0;\n            returnValue = 0;\n          }\n          else if (data[0x10] == (uint *)0x4) {\n            **data = **data | 0x200;\n            returnValue = 1;\n          }\n          else {\n            returnValue = 3;\n          }\n        }\n        else if (data[0x10] == (uint *)0x4) {\n          *(undefined *)(data + 0xf) = 0;\n          returnValue = 1;\n        }\n        else {\n          *(undefined *)(data + 0xf) = 0;\n          returnValue = 3;\n        }\n      }\n    }\n    else {\n      returnValue = 2;\n    }\n  }\n  else {\n    returnValue = 2;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08001ccc": "process_data_08001ccc",
                "param_1": "data",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3",
                "param_5": "flags",
                "param_6": "value4",
                "param_7": "result",
                "iVar1": "dataFromMemory",
                "iVar2": "loopVar",
                "uVar3": "returnValue",
                "puVar4": "ptr",
                "get_data_from_memory_080015a0": "getDataFromMemory",
                "process_data_08002640": "processData",
                "check_flag_and_data_08002bb4": "checkFlagAndData",
                "check_flag_and_update_08002c2e": "checkFlagAndUpdate"
            },
            "calling": [
                "FUN_08004ea4"
            ],
            "called": [
                "FUN_08002c2e",
                "FUN_08002bb4",
                "FUN_080015a0",
                "FUN_08002640"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f6c": {
            "entrypoint": "0x08001f6c",
            "current_name": "process_data_08001f6c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080024e6) */\n/* WARNING: Removing unreachable block (ram,0x080024f8) */\n/* WARNING: Removing unreachable block (ram,0x080024fa) */\n/* WARNING: Removing unreachable block (ram,0x080024fc) */\n/* WARNING: Removing unreachable block (ram,0x08002000) */\n/* WARNING: Removing unreachable block (ram,0x08002012) */\n/* WARNING: Removing unreachable block (ram,0x08002014) */\n/* WARNING: Removing unreachable block (ram,0x08002016) */\n/* WARNING: Removing unreachable block (ram,0x080023f4) */\n/* WARNING: Removing unreachable block (ram,0x08002406) */\n/* WARNING: Removing unreachable block (ram,0x08002408) */\n/* WARNING: Removing unreachable block (ram,0x0800240a) */\n/* WARNING: Removing unreachable block (ram,0x080022d6) */\n/* WARNING: Removing unreachable block (ram,0x080022e8) */\n/* WARNING: Removing unreachable block (ram,0x080022ea) */\n/* WARNING: Removing unreachable block (ram,0x080022ec) */\n\nundefined4\nprocessData_08001f6c(uint **data_ptr,undefined2 param_2,undefined2 param_3,undefined2 param_4,uint *data,\n            undefined2 param_6,uint param_7)\n\n{\n  int initial_value;\n  uint var1;\n  int var2;\n  undefined4 result;\n  uint *ptr;\n  \n  initial_value = getDataFromMemory();\n  if (*(char *)((int)data_ptr + 0x3d) == ' ') {\n    do {\n      if ((~(*data_ptr)[6] & 2) != 0) {\n        var2 = 0;\n        goto LAB_08002040;\n      }\n      var2 = getDataFromMemory();\n    } while ((uint)(var2 - initial_value) < 0x1a);\n    data_ptr[0xc] = (uint *)0x0;\n    *(undefined *)((int)data_ptr + 0x3d) = 0x20;\n    *(undefined *)((int)data_ptr + 0x3e) = 0;\n    *(undefined *)(data_ptr + 0xf) = 0;\n    var2 = 3;\nLAB_08002040:\n    if (var2 == 0) {\n      if (*(char *)(data_ptr + 0xf) == '\\x01') {\n        result = 2;\n      }\n      else {\n        *(undefined *)(data_ptr + 0xf) = 1;\n        if ((**data_ptr & 1) != 1) {\n          **data_ptr = **data_ptr | 1;\n        }\n        **data_ptr = **data_ptr & 0xfffff7ff;\n        *(undefined *)((int)data_ptr + 0x3d) = 0x22;\n        *(undefined *)((int)data_ptr + 0x3e) = 0x40;\n        data_ptr[0x10] = (uint *)0x0;\n        data_ptr[9] = data;\n        *(undefined2 *)((int)data_ptr + 0x2a) = param_6;\n        data_ptr[0xb] = (uint *)0xffff0000;\n        *(undefined2 *)(data_ptr + 10) = *(undefined2 *)((int)data_ptr + 0x2a);\n        var2 = setFlagAndCheckPermissions(data_ptr,param_2,param_3,param_4,param_7,initial_value);\n        if (var2 == 0) {\n          if (*(short *)(data_ptr + 10) == 0) {\n            **data_ptr = **data_ptr | 0x200;\n          }\n          else if (*(short *)(data_ptr + 10) == 1) {\n            **data_ptr = **data_ptr & 0xfffffbff;\n            disableIRQinterrupts();\n            **data_ptr = **data_ptr | 0x200;\n            enableIRQinterrupts();\n          }\n          else if (*(short *)(data_ptr + 10) == 2) {\n            **data_ptr = **data_ptr | 0x800;\n            disableIRQinterrupts();\n            **data_ptr = **data_ptr & 0xfffffbff;\n            enableIRQinterrupts();\n          }\n          else {\n            **data_ptr = **data_ptr | 0x400;\n          }\n          while (*(short *)(data_ptr + 10) != 0) {\n            if (*(ushort *)(data_ptr + 10) < 4) {\n              if (*(short *)(data_ptr + 10) == 1) {\n                var2 = processData_08001f6c2(data_ptr,param_7,initial_value);\n                if (var2 != 0) {\n                  if (data_ptr[0x10] == (uint *)0x20) {\n                    return 3;\n                  }\n                  return 1;\n                }\n                var1 = (*data_ptr)[4];\n                ptr = data_ptr[9];\n                data_ptr[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)var1;\n                *(short *)(data_ptr + 10) = *(short *)(data_ptr + 10) + -1;\n                *(short *)((int)data_ptr + 0x2a) = *(short *)((int)data_ptr + 0x2a) + -1;\n              }\n              else if (*(short *)(data_ptr + 10) == 2) {\n                do {\n                  if ((~(*data_ptr)[5] & 4) == 0) {\n                    var2 = 0;\n                    goto LAB_080022fa;\n                  }\n                } while ((param_7 == 0xffffffff) ||\n                        ((param_7 != 0 && (var2 = getDataFromMemory(), (uint)(var2 - initial_value) <= param_7)\n                         )));\n                data_ptr[0xc] = (uint *)0x0;\n                *(undefined *)((int)data_ptr + 0x3d) = 0x20;\n                *(undefined *)((int)data_ptr + 0x3e) = 0;\n                *(undefined *)(data_ptr + 0xf) = 0;\n                var2 = 3;\nLAB_080022fa:\n                if (var2 != 0) {\n                  return 3;\n                }\n                disableIRQinterrupts();\n                **data_ptr = **data_ptr | 0x200;\n                var1 = (*data_ptr)[4];\n                ptr = data_ptr[9];\n                data_ptr[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)var1;\n                *(short *)(data_ptr + 10) = *(short *)(data_ptr + 10) + -1;\n                *(short *)((int)data_ptr + 0x2a) = *(short *)((int)data_ptr + 0x2a) + -1;\n                enableIRQinterrupts();\n                var1 = (*data_ptr)[4];\n                ptr = data_ptr[9];\n                data_ptr[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)var1;\n                *(short *)(data_ptr + 10) = *(short *)(data_ptr + 10) + -1;\n                *(short *)((int)data_ptr + 0x2a) = *(short *)((int)data_ptr + 0x2a) + -1;\n              }\n              else {\n                do {\n                  if ((~(*data_ptr)[5] & 4) == 0) {\n                    var2 = 0;\n                    goto LAB_08002418;\n                  }\n                } while ((param_7 == 0xffffffff) ||\n                        ((param_7 != 0 && (var2 = getDataFromMemory(), (uint)(var2 - initial_value) <= param_7)\n                         )));\n                data_ptr[0xc] = (uint *)0x0;\n                *(undefined *)((int)data_ptr + 0x3d) = 0x20;\n                *(undefined *)((int)data_ptr + 0x3e) = 0;\n                *(undefined *)(data_ptr + 0xf) = 0;\n                var2 = 3;\nLAB_08002418:\n                if (var2 != 0) {\n                  return 3;\n                }\n                **data_ptr = **data_ptr & 0xfffffbff;\n                disableIRQinterrupts();\n                var1 = (*data_ptr)[4];\n                ptr = data_ptr[9];\n                data_ptr[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)var1;\n                *(short *)(data_ptr + 10) = *(short *)(data_ptr + 10) + -1;\n                *(short *)((int)data_ptr + 0x2a) = *(short *)((int)data_ptr + 0x2a) + -1;\n                do {\n                  if ((~(*data_ptr)[5] & 4) == 0) {\n                    var2 = 0;\n                    goto LAB_0800250a;\n                  }\n                } while ((param_7 == 0xffffffff) ||\n                        ((param_7 != 0 && (var2 = getDataFromMemory(), (uint)(var2 - initial_value) <= param_7)\n                         )));\n                data_ptr[0xc] = (uint *)0x0;\n                *(undefined *)((int)data_ptr + 0x3d) = 0x20;\n                *(undefined *)((int)data_ptr + 0x3e) = 0;\n                *(undefined *)(data_ptr + 0xf) = 0;\n                var2 = 3;\nLAB_0800250a:\n                if (var2 != 0) {\n                  return 3;\n                }\n                **data_ptr = **data_ptr | 0x200;\n                var1 = (*data_ptr)[4];\n                ptr = data_ptr[9];\n                data_ptr[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)var1;\n                *(short *)(data_ptr + 10) = *(short *)(data_ptr + 10) + -1;\n                *(short *)((int)data_ptr + 0x2a) = *(short *)((int)data_ptr + 0x2a) + -1;\n                enableIRQinterrupts();\n                var1 = (*data_ptr)[4];\n                ptr = data_ptr[9];\n                data_ptr[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)var1;\n                *(short *)(data_ptr + 10) = *(short *)(data_ptr + 10) + -1;\n                *(short *)((int)data_ptr + 0x2a) = *(short *)((int)data_ptr + 0x2a) + -1;\n              }\n            }\n            else {\n              var2 = processData_08001f6c2(data_ptr,param_7,initial_value);\n              if (var2 != 0) {\n                if (data_ptr[0x10] == (uint *)0x20) {\n                  return 3;\n                }\n                return 1;\n              }\n              var1 = (*data_ptr)[4];\n              ptr = data_ptr[9];\n              data_ptr[9] = (uint *)((int)ptr + 1);\n              *(char *)ptr = (char)var1;\n              *(short *)(data_ptr + 10) = *(short *)(data_ptr + 10) + -1;\n              *(short *)((int)data_ptr + 0x2a) = *(short *)((int)data_ptr + 0x2a) + -1;\n              if (((*data_ptr)[5] & 4) == 4) {\n                var1 = (*data_ptr)[4];\n                ptr = data_ptr[9];\n                data_ptr[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)var1;\n                *(short *)(data_ptr + 10) = *(short *)(data_ptr + 10) + -1;\n                *(short *)((int)data_ptr + 0x2a) = *(short *)((int)data_ptr + 0x2a) + -1;\n              }\n            }\n          }\n          *(undefined *)((int)data_ptr + 0x3d) = 0x20;\n          *(undefined *)((int)data_ptr + 0x3e) = 0;\n          *(undefined *)(data_ptr + 0xf) = 0;\n          result = 0;\n        }\n        else if (data_ptr[0x10] == (uint *)0x4) {\n          *(undefined *)(data_ptr + 0xf) = 0;\n          result = 1;\n        }\n        else {\n          *(undefined *)(data_ptr + 0xf) = 0;\n          result = 3;\n        }\n      }\n    }\n    else {\n      result = 2;\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001f6c": "process_data_08001f6c",
                "param_1": "data_ptr",
                "param_5": "data",
                "iVar1": "initial_value",
                "uVar2": "var1",
                "iVar3": "var2",
                "uVar4": "result",
                "puVar5": "ptr",
                "get_data_from_memory_080015a0": "getDataFromMemory",
                "set_flag_and_check_permissions_080027f4": "setFlagAndCheckPermissions",
                "process_data_08002ca8": "processData2"
            },
            "calling": [
                "FUN_08004ee8"
            ],
            "called": [
                "FUN_08002ca8",
                "FUN_080027f4",
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002640": {
            "entrypoint": "0x08002640",
            "current_name": "process_data_08002640",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080026e8) */\n/* WARNING: Removing unreachable block (ram,0x080026fa) */\n/* WARNING: Removing unreachable block (ram,0x080026fc) */\n/* WARNING: Removing unreachable block (ram,0x080026fe) */\n\nundefined4\nprocessData_08002640(uint **data,byte flag,undefined2 value,short mode,uint limit,int offset)\n\n{\n  int result;\n  undefined4 returnValue;\n  \n  **data = **data | 0x100;\n  do {\n    if ((~(*data)[5] & 1) == 0) {\n      result = 0;\n      goto LAB_0800270a;\n    }\n  } while ((limit == 0xffffffff) ||\n          ((limit != 0 && (result = get_data_from_memory_080015a0(), (uint)(result - offset) <= limit))));\n  data[0xc] = (uint *)0x0;\n  *(undefined *)((int)data + 0x3d) = 0x20;\n  *(undefined *)((int)data + 0x3e) = 0;\n  *(undefined *)(data + 0xf) = 0;\n  result = 3;\nLAB_0800270a:\n  if (result == 0) {\n    (*data)[4] = flag & 0xfe;\n    result = check_permissions_08002ad8(data,0x10002,limit,offset);\n    if (result == 0) {\n      result = check_flag_and_data_08002bb4(data,limit,offset,(*data)[6]);\n      if (result == 0) {\n        if (mode == 1) {\n          (*data)[4] = (uint)(byte)value;\n        }\n        else {\n          (*data)[4] = (uint)(byte)((ushort)value >> 8);\n          result = check_flag_and_data_08002bb4(data,limit,offset);\n          if (result != 0) {\n            if (data[0x10] == (uint *)0x4) {\n              **data = **data | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*data)[4] = (uint)(byte)value;\n        }\n        returnValue = 0;\n      }\n      else if (data[0x10] == (uint *)0x4) {\n        **data = **data | 0x200;\n        returnValue = 1;\n      }\n      else {\n        returnValue = 3;\n      }\n    }\n    else if (data[0x10] == (uint *)0x4) {\n      returnValue = 1;\n    }\n    else {\n      returnValue = 3;\n    }\n  }\n  else {\n    returnValue = 3;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08002640": "process_data_08002640",
                "param_1": "data",
                "param_2": "flag",
                "param_3": "value",
                "param_4": "mode",
                "param_5": "limit",
                "param_6": "offset",
                "iVar1": "result",
                "uVar2": "returnValue"
            },
            "calling": [
                "FUN_08001ccc"
            ],
            "called": [
                "FUN_08002bb4",
                "FUN_08002ad8",
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080027f4": {
            "entrypoint": "0x080027f4",
            "current_name": "set_flag_and_check_permissions_080027f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080028ae) */\n/* WARNING: Removing unreachable block (ram,0x080028c0) */\n/* WARNING: Removing unreachable block (ram,0x080028c2) */\n/* WARNING: Removing unreachable block (ram,0x080028c4) */\n/* WARNING: Removing unreachable block (ram,0x08002a6c) */\n/* WARNING: Removing unreachable block (ram,0x08002a7e) */\n/* WARNING: Removing unreachable block (ram,0x08002a80) */\n/* WARNING: Removing unreachable block (ram,0x08002a82) */\n\nundefined4\nset_flag_and_check_permissions_080027f4(uint **ptr,byte flag,undefined2 value,short flag_type,uint max_value,int current_value)\n\n{\n  int result;\n  undefined4 ret_value;\n  \n  **ptr = **ptr | 0x400;\n  **ptr = **ptr | 0x100;\n  do {\n    if ((~(*ptr)[5] & 1) == 0) {\n      result = 0;\n      goto LAB_080028d2;\n    }\n  } while ((max_value == 0xffffffff) ||\n          ((max_value != 0 && (result = get_data_from_memory_080015a0(), (uint)(result - current_value) <= max_value))));\n  ptr[0xc] = (uint *)0x0;\n  *(undefined *)((int)ptr + 0x3d) = 0x20;\n  *(undefined *)((int)ptr + 0x3e) = 0;\n  *(undefined *)(ptr + 0xf) = 0;\n  result = 3;\nLAB_080028d2:\n  if (result == 0) {\n    (*ptr)[4] = flag & 0xfe;\n    result = check_permissions_08002ad8(ptr,0x10002,max_value,current_value);\n    if (result == 0) {\n      result = check_flag_and_data_08002bb4(ptr,max_value,current_value,(*ptr)[6]);\n      if (result == 0) {\n        if (flag_type == 1) {\n          (*ptr)[4] = (uint)(byte)value;\n        }\n        else {\n          (*ptr)[4] = (uint)(byte)((ushort)value >> 8);\n          result = check_flag_and_data_08002bb4(ptr,max_value,current_value);\n          if (result != 0) {\n            if (ptr[0x10] == (uint *)0x4) {\n              **ptr = **ptr | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*ptr)[4] = (uint)(byte)value;\n        }\n        result = check_flag_and_data_08002bb4(ptr,max_value,current_value);\n        if (result == 0) {\n          **ptr = **ptr | 0x100;\n          do {\n            if ((~(*ptr)[5] & 1) == 0) {\n              result = 0;\n              goto LAB_08002a90;\n            }\n          } while ((max_value == 0xffffffff) ||\n                  ((max_value != 0 && (result = get_data_from_memory_080015a0(), (uint)(result - current_value) <= max_value))));\n          ptr[0xc] = (uint *)0x0;\n          *(undefined *)((int)ptr + 0x3d) = 0x20;\n          *(undefined *)((int)ptr + 0x3e) = 0;\n          *(undefined *)(ptr + 0xf) = 0;\n          result = 3;\nLAB_08002a90:\n          if (result == 0) {\n            (*ptr)[4] = (uint)(flag | 1);\n            result = check_permissions_08002ad8(ptr,0x10002,max_value,current_value);\n            if (result == 0) {\n              ret_value = 0;\n            }\n            else if (ptr[0x10] == (uint *)0x4) {\n              ret_value = 1;\n            }\n            else {\n              ret_value = 3;\n            }\n          }\n          else {\n            ret_value = 3;\n          }\n        }\n        else if (ptr[0x10] == (uint *)0x4) {\n          **ptr = **ptr | 0x200;\n          ret_value = 1;\n        }\n        else {\n          ret_value = 3;\n        }\n      }\n      else if (ptr[0x10] == (uint *)0x4) {\n        **ptr = **ptr | 0x200;\n        ret_value = 1;\n      }\n      else {\n        ret_value = 3;\n      }\n    }\n    else if (ptr[0x10] == (uint *)0x4) {\n      ret_value = 1;\n    }\n    else {\n      ret_value = 3;\n    }\n  }\n  else {\n    ret_value = 3;\n  }\n  return ret_value;\n}\n\n",
            "renaming": {
                "FUN_080027f4": "set_flag_and_check_permissions_080027f4",
                "param_1": "ptr",
                "param_2": "flag",
                "param_3": "value",
                "param_4": "flag_type",
                "param_5": "max_value",
                "param_6": "current_value",
                "iVar1": "result",
                "uVar2": "ret_value"
            },
            "calling": [
                "FUN_08001f6c"
            ],
            "called": [
                "FUN_08002bb4",
                "FUN_08002ad8",
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad8": {
            "entrypoint": "0x08002ad8",
            "current_name": "check_permissions_08002ad8",
            "code": "\nundefined4 checkPermissions_08002ad8(uint **permissionMatrix,uint permissionFlag,uint maxAllowedSize,int currentSize)\n\n{\n  int dataOffset;\n  char hasPermission;\n  uint permissionValue;\n  bool hasValue;\n  \n  do {\n    if ((permissionFlag >> 0x10 & 0xff) == 1) {\n      permissionValue = permissionFlag & ~(*permissionMatrix)[5] & 0xffff;\n      hasValue = permissionValue != 0;\n      if (hasValue) {\n        permissionValue = 1;\n      }\n      hasPermission = (char)permissionValue;\n      if (!hasValue) {\n        hasPermission = '\\0';\n      }\n    }\n    else {\n      permissionValue = permissionFlag & ~(*permissionMatrix)[6] & 0xffff;\n      hasValue = permissionValue != 0;\n      if (hasValue) {\n        permissionValue = 1;\n      }\n      hasPermission = (char)permissionValue;\n      if (!hasValue) {\n        hasPermission = '\\0';\n      }\n    }\n    if (hasPermission == '\\0') {\n      return 0;\n    }\n    if (((*permissionMatrix)[5] & 0x400) == 0x400) {\n      **permissionMatrix = **permissionMatrix | 0x200;\n      (*permissionMatrix)[5] = 0xfffffbff;\n      permissionMatrix[0x10] = (uint *)0x4;\n      permissionMatrix[0xc] = (uint *)0x0;\n      *(undefined *)((int)permissionMatrix + 0x3d) = 0x20;\n      *(undefined *)(permissionMatrix + 0xf) = 0;\n      return 1;\n    }\n  } while ((maxAllowedSize == 0xffffffff) ||\n          ((maxAllowedSize != 0 && (dataOffset = get_data_from_memory_080015a0(), (uint)(dataOffset - currentSize) <= maxAllowedSize))));\n  permissionMatrix[0xc] = (uint *)0x0;\n  *(undefined *)((int)permissionMatrix + 0x3d) = 0x20;\n  *(undefined *)(permissionMatrix + 0xf) = 0;\n  return 3;\n}\n\n",
            "renaming": {
                "FUN_08002ad8": "check_permissions_08002ad8",
                "param_1": "permissionMatrix",
                "param_2": "permissionFlag",
                "param_3": "maxAllowedSize",
                "param_4": "currentSize",
                "iVar1": "dataOffset",
                "cVar2": "hasPermission",
                "uVar3": "permissionValue",
                "bVar4": "hasValue"
            },
            "calling": [
                "FUN_080027f4",
                "FUN_08002640"
            ],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002bb4": {
            "entrypoint": "0x08002bb4",
            "current_name": "check_flag_and_data_08002bb4",
            "code": "\nundefined4 check_flag_and_data_08002bb4(int *flag_data,uint flag_mask,int offset)\n\n{\n  int flag_status;\n  \n  while( true ) {\n    if ((*(uint *)(*flag_data + 0x14) & 0x80) == 0x80) {\n      return 0;\n    }\n    flag_status = check_flag_status(flag_data);\n    if (flag_status != 0) break;\n    if ((flag_mask != 0xffffffff) &&\n       ((flag_mask == 0 || (flag_status = get_memory_data(), flag_mask < (uint)(flag_status - offset))))) {\n      flag_data[0x10] = flag_data[0x10] | 0x20;\n      flag_data[0xc] = 0;\n      *(undefined *)((int)flag_data + 0x3d) = 0x20;\n      *(undefined *)(flag_data + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002bb4": "check_flag_and_data_08002bb4",
                "param_1": "flag_data",
                "param_2": "flag_mask",
                "param_3": "offset",
                "iVar1": "flag_status",
                "check_flag_status_08002d3c": "check_flag_status",
                "get_data_from_memory_080015a0": "get_memory_data"
            },
            "calling": [
                "FUN_08001ccc",
                "FUN_080027f4",
                "FUN_08002640"
            ],
            "called": [
                "FUN_080015a0",
                "FUN_08002d3c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c2e": {
            "entrypoint": "0x08002c2e",
            "current_name": "check_flag_and_update_08002c2e",
            "code": "\nundefined4 check_flag_and_update_08002c2e(int *flag_ptr,uint data_length,int start_index)\n\n{\n  int flag_status;\n  \n  while( true ) {\n    if ((*(uint *)(*flag_ptr + 0x14) & 4) == 4) {\n      return 0;\n    }\n    flag_status = check_flag_status(flag_ptr);\n    if (flag_status != 0) break;\n    if ((data_length != 0xffffffff) &&\n       ((data_length == 0 || (flag_status = get_memory_data(), data_length < (uint)(flag_status - start_index))))) {\n      flag_ptr[0x10] = flag_ptr[0x10] | 0x20;\n      flag_ptr[0xc] = 0;\n      *(undefined *)((int)flag_ptr + 0x3d) = 0x20;\n      *(undefined *)(flag_ptr + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002c2e": "check_flag_and_update_08002c2e",
                "param_1": "flag_ptr",
                "param_2": "data_length",
                "param_3": "start_index",
                "iVar1": "flag_status",
                "check_flag_status_08002d3c": "check_flag_status",
                "get_data_from_memory_080015a0": "get_memory_data"
            },
            "calling": [
                "FUN_08001ccc"
            ],
            "called": [
                "FUN_080015a0",
                "FUN_08002d3c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca8": {
            "entrypoint": "0x08002ca8",
            "current_name": "process_data_08002ca8",
            "code": "\nundefined4 processData_08002ca8(int *dataPointer,uint dataSize,int offset)\n\n{\n  int dataLength;\n  \n  while( true ) {\n    if ((*(uint *)(*dataPointer + 0x14) & 0x40) == 0x40) {\n      return 0;\n    }\n    if ((*(uint *)(*dataPointer + 0x14) & 0x10) == 0x10) break;\n    if ((dataSize == 0) || (dataLength = get_data_from_memory_080015a0(), dataSize < (uint)(dataLength - offset))) {\n      dataPointer[0x10] = dataPointer[0x10] | 0x20;\n      *(undefined *)((int)dataPointer + 0x3d) = 0x20;\n      *(undefined *)(dataPointer + 0xf) = 0;\n      return 3;\n    }\n  }\n  *(undefined4 *)(*dataPointer + 0x14) = 0xffffffef;\n  dataPointer[0x10] = 0;\n  dataPointer[0xc] = 0;\n  *(undefined *)((int)dataPointer + 0x3d) = 0x20;\n  *(undefined *)(dataPointer + 0xf) = 0;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002ca8": "process_data_08002ca8",
                "param_1": "dataPointer",
                "param_2": "dataSize",
                "param_3": "offset",
                "iVar1": "dataLength"
            },
            "calling": [
                "FUN_08001f6c"
            ],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d3c": {
            "entrypoint": "0x08002d3c",
            "current_name": "check_flag_status_08002d3c",
            "code": "\nbool checkFlagStatus_08002d3c(int *flagPtr)\n\n{\n  bool isFlagSet;\n  \n  isFlagSet = (*(uint *)(*flagPtr + 0x14) & 0x400) == 0x400;\n  if (isFlagSet) {\n    *(undefined4 *)(*flagPtr + 0x14) = 0xfffffbff;\n    errorCode = 4;\n    counter = 0;\n    *(undefined *)((int)flagPtr + 0x3d) = 0x20;\n    *(undefined *)(flagPtr + 0xf) = 0;\n  }\n  return isFlagSet;\n}\n\n",
            "renaming": {
                "FUN_08002d3c": "check_flag_status_08002d3c",
                "param_1": "flagPtr",
                "bVar1": "isFlagSet",
                "param_1[0x10]": "errorCode",
                "param_1[0xc]": "counter"
            },
            "calling": [
                "FUN_08002c2e",
                "FUN_08002bb4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d8a": {
            "entrypoint": "0x08002d8a",
            "current_name": "FUNC_08002d8a",
            "code": "\nvoid FUNC_08002d8a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d8a": "FUNC_08002d8a"
            },
            "calling": [
                "FUN_080014f0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d98": {
            "entrypoint": "0x08002d98",
            "current_name": "process_flags_08002d98",
            "code": "\n\n\nundefined4 processFlags_08002d98(uint *flags)\n\n{\n  int startValue;\n  int currentValue;\n  undefined4 resultCode;\n  bool isFlagSet;\n  \n  if ((*flags & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0x10000)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (flags[1] == 0)) {\n        return 1;\n      }\n    }\n    else {\n      if (flags[1] == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (flags[1] == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (flags[1] == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (flags[1] == 0) {\n        startValue = get_data_from_memory_080015a0();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          currentValue = get_data_from_memory_080015a0();\n          if (100 < (uint)(currentValue - startValue)) {\n            return 3;\n          }\n        }\n      }\n      else {\n        startValue = get_data_from_memory_080015a0();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          currentValue = get_data_from_memory_080015a0();\n          if (100 < (uint)(currentValue - startValue)) {\n            return 3;\n          }\n        }\n      }\n    }\n  }\n  if ((*flags & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (flags[4] != 1)) {\n        return 1;\n      }\n      _DAT_40021000 = flags[5] << 3 | _DAT_40021000 & 0xffffff07;\n    }\n    else if (flags[4] == 0) {\n      _DAT_42420000 = 0;\n      startValue = get_data_from_memory_080015a0();\n      while ((_DAT_40021000 & 2) != 0) {\n        currentValue = get_data_from_memory_080015a0();\n        if (2 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      startValue = get_data_from_memory_080015a0();\n      while ((_DAT_40021000 & 2) == 0) {\n        currentValue = get_data_from_memory_080015a0();\n        if (2 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n      _DAT_40021000 = flags[5] << 3 | _DAT_40021000 & 0xffffff07;\n    }\n  }\n  if ((*flags & 8) != 0) {\n    if (flags[6] == 0) {\n      _DAT_42420480 = 0;\n      startValue = get_data_from_memory_080015a0();\n      while ((_DAT_40021024 & 2) != 0) {\n        currentValue = get_data_from_memory_080015a0();\n        if (2 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      startValue = get_data_from_memory_080015a0();\n      while ((_DAT_40021024 & 2) == 0) {\n        currentValue = get_data_from_memory_080015a0();\n        if (2 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n      delay_function_08003568(1);\n    }\n  }\n  if ((*flags & 4) != 0) {\n    isFlagSet = (_DAT_4002101c & 0x10000000) == 0;\n    if (isFlagSet) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startValue = get_data_from_memory_080015a0();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentValue = get_data_from_memory_080015a0();\n        if (100 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n    }\n    if (flags[3] == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (flags[3] == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (flags[3] == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (flags[3] == 0) {\n      startValue = get_data_from_memory_080015a0();\n      while ((_DAT_40021020 & 2) != 0) {\n        currentValue = get_data_from_memory_080015a0();\n        if (5000 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      startValue = get_data_from_memory_080015a0();\n      while ((_DAT_40021020 & 2) == 0) {\n        currentValue = get_data_from_memory_080015a0();\n        if (5000 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n    }\n    if (isFlagSet) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if (flags[7] == 0) {\nLAB_0800324a:\n    resultCode = 0;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    resultCode = 1;\n  }\n  else if (flags[7] == 2) {\n    _DAT_42420060 = 0;\n    startValue = get_data_from_memory_080015a0();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if (flags[8] == 0x10000) {\n          _DAT_40021004 = flags[2] | _DAT_40021004 & 0xfffdffff;\n        }\n        _DAT_40021004 = flags[9] | flags[8] | _DAT_40021004 & 0xffc2ffff;\n        _DAT_42420060 = 1;\n        startValue = get_data_from_memory_080015a0();\n        while ((_DAT_40021000 & 0x2000000) == 0) {\n          currentValue = get_data_from_memory_080015a0();\n          if (2 < (uint)(currentValue - startValue)) {\n            return 3;\n          }\n        }\n        goto LAB_0800324a;\n      }\n      currentValue = get_data_from_memory_080015a0();\n    } while ((uint)(currentValue - startValue) < 3);\n    resultCode = 3;\n  }\n  else {\n    _DAT_42420060 = 0;\n    startValue = get_data_from_memory_080015a0();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) goto LAB_0800324a;\n      currentValue = get_data_from_memory_080015a0();\n    } while ((uint)(currentValue - startValue) < 3);\n    resultCode = 3;\n  }\n  return resultCode;\n}\n\n",
            "renaming": {
                "FUN_08002d98": "process_flags_08002d98",
                "param_1": "flags",
                "iVar1": "startValue",
                "iVar2": "currentValue",
                "uVar3": "resultCode",
                "bVar4": "isFlagSet"
            },
            "calling": [
                "FUN_080052a0"
            ],
            "called": [
                "FUN_08003568",
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003260": {
            "entrypoint": "0x08003260",
            "current_name": "calculate_execution_time_08003260",
            "code": "\n\n\nundefined4 calculate_execution_time_08003260(uint *execution_params,uint num_executions)\n\n{\n  int data_from_memory;\n  int current_data;\n  uint execution_time;\n  undefined4 result;\n  \n  if (((_DAT_40022000 & 7) < num_executions) &&\n     (_DAT_40022000 = num_executions | _DAT_40022000 & 0xfffffff8, num_executions != (num_executions & 7))) {\n    result = 1;\n  }\n  else {\n    if ((*execution_params & 2) != 0) {\n      _DAT_40021004 = execution_params[2] | _DAT_40021004 & 0xffffff0f;\n    }\n    if ((*execution_params & 1) == 0) {\nLAB_08003394:\n      if ((num_executions < (_DAT_40022000 & 7)) &&\n         (_DAT_40022000 = num_executions | _DAT_40022000 & 0xfffffff8, num_executions != (num_executions & 7))) {\n        result = 1;\n      }\n      else {\n        if ((*execution_params & 4) != 0) {\n          _DAT_40021004 = execution_params[3] | _DAT_40021004 & 0xfffff8ff;\n        }\n        if ((*execution_params & 8) != 0) {\n          _DAT_40021004 = execution_params[4] << 3 | _DAT_40021004 & 0xffffc7ff;\n        }\n        execution_time = calculate_execution_time_08003260_08003440();\n        DAT_20000018 = execution_time >> (&DAT_08009eb0)[_DAT_40021004 >> 4 & 0xf];\n        update_value_0800151c(0xf);\n        result = 0;\n      }\n    }\n    else {\n      if (execution_params[1] == 1) {\n        if ((_DAT_40021000 & 0x20000) == 0) {\n          return 1;\n        }\n      }\n      else if ((execution_params[1] != 2) && ((_DAT_40021000 & 2) == 0)) {\n        return 1;\n      }\n      _DAT_40021004 = execution_params[1] | _DAT_40021004 & 0xfffffffc;\n      data_from_memory = get_data_from_memory_080015a0();\n      if (execution_params[1] == 1) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 4) goto LAB_08003394;\n          current_data = get_data_from_memory_080015a0();\n        } while ((uint)(current_data - data_from_memory) < 0x1389);\n        result = 3;\n      }\n      else if (execution_params[1] == 2) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 8) goto LAB_08003394;\n          current_data = get_data_from_memory_080015a0();\n        } while ((uint)(current_data - data_from_memory) < 0x1389);\n        result = 3;\n      }\n      else {\n        do {\n          if ((_DAT_40021004 & 0xc) == 0) goto LAB_08003394;\n          current_data = get_data_from_memory_080015a0();\n        } while ((uint)(current_data - data_from_memory) < 0x1389);\n        result = 3;\n      }\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003260": "calculate_execution_time_08003260",
                "param_1": "execution_params",
                "param_2": "num_executions",
                "iVar1": "data_from_memory",
                "iVar2": "current_data",
                "uVar3": "execution_time",
                "uVar4": "result"
            },
            "calling": [
                "FUN_080052a0"
            ],
            "called": [
                "FUN_0800151c",
                "FUN_080015a0",
                "FUN_08003440"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003440": {
            "entrypoint": "0x08003440",
            "current_name": "calculate_execution_time_08003440",
            "code": "\n\n\nuint calculateExecutionTime_08003440(void)\n\n{\n  undefined2 configValue;\n  undefined4 constantA;\n  undefined4 constantB;\n  undefined4 constantC;\n  undefined4 constantD;\n  uint timeDelay;\n  undefined4 executionTime;\n  uint registerValue;\n  uint result;\n  uint temp;\n  \n  constantA = 0x5040302;\n  constantB = 0x9080706;\n  constantC = 0xd0c0b0a;\n  constantD = 0x10100f0e;\n  configValue = 0x201;\n  executionTime = 0;\n  temp = 0;\n  timeDelay = 0;\n  result = 0;\n  registerValue = _DAT_40021004;\n  if ((_DAT_40021004 & 0xc) == 4) {\n    result = 8000000;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    timeDelay = (uint)*(byte *)((int)&constantA + (_DAT_40021004 >> 0x12 & 0xf));\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      temp = timeDelay * 4000000;\n    }\n    else {\n      temp = (timeDelay * 8000000) / (uint)*(byte *)((int)&configValue + (_DAT_40021004 >> 0x11 & 1))\n      ;\n    }\n    result = temp;\n  }\n  else {\n    result = 8000000;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003440": "calculate_execution_time_08003440",
                "local_30": "configValue",
                "local_2c": "constantA",
                "uStack_28": "constantB",
                "uStack_24": "constantC",
                "uStack_20": "constantD",
                "local_1c": "timeDelay",
                "local_18": "executionTime",
                "local_14": "registerValue",
                "local_10": "result",
                "local_c": "temp"
            },
            "calling": [
                "FUN_08003260"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003504": {
            "entrypoint": "0x08003504",
            "current_name": "get_memory_address_08003504",
            "code": "\nundefined4 getMemoryAddress_08003504(void)\n\n{\n  return DAT_20000018;\n}\n\n",
            "renaming": {
                "FUN_08003504": "get_memory_address_08003504"
            },
            "calling": [
                "FUN_08003518",
                "FUN_080052a0",
                "FUN_08003540"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003518": {
            "entrypoint": "0x08003518",
            "current_name": "extracted_memory_address_08003518",
            "code": "\n\n\nuint extracted_memory_address_08003518(void)\n\n{\n  uint memory_address;\n  \n  memory_address = get_memory_address();\n  return memory_address >> *(signed_byte *)((int)&DAT_08009ec0 + (_DAT_40021004 >> 8 & 7));\n}\n\n",
            "renaming": {
                "FUN_08003518": "extracted_memory_address_08003518",
                "uVar1": "memory_address",
                "get_memory_address_08003504": "get_memory_address",
                "sbyte": "signed_byte"
            },
            "calling": [
                "FUN_08001ab0",
                "FUN_080046ec"
            ],
            "called": [
                "FUN_08003504"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003540": {
            "entrypoint": "0x08003540",
            "current_name": "get_shifted_memory_address_08003540",
            "code": "\n\n\nuint get_shifted_memory_address_08003540(void)\n\n{\n  uint memory_address;\n  \n  memory_address = get_memory_address_08003504();\n  return memory_address >> *(bit_offset *)((int)&DAT_08009ec0 + (_DAT_40021004 >> 0xb & 7));\n}\n\n",
            "renaming": {
                "FUN_08003540": "get_shifted_memory_address_08003540",
                "uVar1": "memory_address",
                "sbyte": "bit_offset"
            },
            "calling": [
                "FUN_080046ec"
            ],
            "called": [
                "FUN_08003504"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003568": {
            "entrypoint": "0x08003568",
            "current_name": "delay_function_08003568",
            "code": "\nvoid delayFunction_08003568(int duration)\n\n{\n  bool isCounterNonZero;\n  int counter;\n  \n  counter = duration * (DAT_20000018 / 8000);\n  do {\n    isCounterNonZero = counter != 0;\n    counter = counter + -1;\n  } while (isCounterNonZero);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003568": "delay_function_08003568",
                "param_1": "duration",
                "local_c": "counter",
                "bVar1": "isCounterNonZero"
            },
            "calling": [
                "FUN_08002d98"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035a4": {
            "entrypoint": "0x080035a4",
            "current_name": "validate_and_update_data_080035a4",
            "code": "\nundefined4 validate_and_update_data_080035a4(undefined4 *data_array)\n\n{\n  undefined4 result;\n  \n  if (data_array == (undefined4 *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)data_array + 0x3d) == '\\0') {\n      *(undefined *)(data_array + 0xf) = 0;\n      FUNC_080035fa(data_array);\n    }\n    *(undefined *)((int)data_array + 0x3d) = 2;\n    update_memory(*data_array,data_array + 1);\n    *(undefined *)((int)data_array + 0x3d) = 1;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080035a4": "validate_and_update_data_080035a4",
                "param_1": "data_array",
                "uVar1": "result",
                "update_memory_08003c94": "update_memory"
            },
            "calling": [
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "called": [
                "FUN_080035fa",
                "FUN_08003c94"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fa": {
            "entrypoint": "0x080035fa",
            "current_name": "FUNC_080035fa",
            "code": "\nvoid FUNC_080035fa(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fa": "FUNC_080035fa"
            },
            "calling": [
                "FUN_080035a4"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800360c": {
            "entrypoint": "0x0800360c",
            "current_name": "set_flags_0800360c",
            "code": "\nundefined4 setFlags_0800360c(uint **ptrArray)\n\n{\n  (*ptrArray)[3] = (*ptrArray)[3] | 1;\n  **ptrArray = **ptrArray | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800360c": "set_flags_0800360c",
                "param_1": "ptrArray"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003640": {
            "entrypoint": "0x08003640",
            "current_name": "process_data_08003640",
            "code": "\nundefined4 processData_08003640(undefined4 *data)\n\n{\n  undefined4 result;\n  \n  if (data == (undefined4 *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)data + 0x3d) == '\\0') {\n      *(undefined *)(data + 0xf) = 0;\n      FUNC_08003696(data);\n    }\n    *(undefined *)((int)data + 0x3d) = 2;\n    updateMemory(*data,data + 1);\n    *(undefined *)((int)data + 0x3d) = 1;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003640": "process_data_08003640",
                "param_1": "data",
                "uVar1": "result",
                "update_memory_08003c94": "updateMemory"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [
                "FUN_08003696",
                "FUN_08003c94"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003696": {
            "entrypoint": "0x08003696",
            "current_name": "FUNC_08003696",
            "code": "\nvoid FUNC_08003696(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003696": "FUNC_08003696"
            },
            "calling": [
                "FUN_08003640"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080036a8": {
            "entrypoint": "0x080036a8",
            "current_name": "update_and_set_bits_080036a8",
            "code": "\nundefined4 update_and_set_bits_080036a8(uint **ptr_array,undefined4 value)\n\n{\n  update_bits_080041ea(*ptr_array,value,1);\n  if (*ptr_array == (uint *)0x40012c00) {\n    (*ptr_array)[0x11] = (*ptr_array)[0x11] | 0x8000;\n  }\n  **ptr_array = **ptr_array | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080036a8": "update_and_set_bits_080036a8",
                "param_1": "ptr_array",
                "param_2": "value"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_080041ea"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036f8": {
            "entrypoint": "0x080036f8",
            "current_name": "process_flags_080036f8",
            "code": "\nvoid process_flags_080036f8(int *input_data)\n\n{\n  if (((*(unsigned_int *)(*input_data + 0x10) & 2) == 2) && ((*(unsigned_int *)(*input_data + 0xc) & 2) == 2)) {\n    *(unknown4 *)(*input_data + 0x10) = 0xfffffffd;\n    *(unknown *)(input_data + 7) = 1;\n    if ((*(unsigned_int *)(*input_data + 0x18) & 3) == 0) {\n      FUNC_08003c4a(input_data);\n      FUNC_08003c6e(input_data);\n    }\n    else {\n      FUNC_08003c5c(input_data);\n    }\n    *(unknown *)(input_data + 7) = 0;\n  }\n  if (((*(unsigned_int *)(*input_data + 0x10) & 4) == 4) && ((*(unsigned_int *)(*input_data + 0xc) & 4) == 4)) {\n    *(unknown4 *)(*input_data + 0x10) = 0xfffffffb;\n    *(unknown *)(input_data + 7) = 2;\n    if ((*(unsigned_int *)(*input_data + 0x18) & 0x300) == 0) {\n      FUNC_08003c4a(input_data);\n      FUNC_08003c6e(input_data);\n    }\n    else {\n      FUNC_08003c5c(input_data);\n    }\n    *(unknown *)(input_data + 7) = 0;\n  }\n  if (((*(unsigned_int *)(*input_data + 0x10) & 8) == 8) && ((*(unsigned_int *)(*input_data + 0xc) & 8) == 8)) {\n    *(unknown4 *)(*input_data + 0x10) = 0xfffffff7;\n    *(unknown *)(input_data + 7) = 4;\n    if ((*(unsigned_int *)(*input_data + 0x1c) & 3) == 0) {\n      FUNC_08003c4a(input_data);\n      FUNC_08003c6e(input_data);\n    }\n    else {\n      FUNC_08003c5c(input_data);\n    }\n    *(unknown *)(input_data + 7) = 0;\n  }\n  if (((*(unsigned_int *)(*input_data + 0x10) & 0x10) == 0x10) && ((*(unsigned_int *)(*input_data + 0xc) & 0x10) == 0x10))\n  {\n    *(unknown4 *)(*input_data + 0x10) = 0xffffffef;\n    *(unknown *)(input_data + 7) = 8;\n    if ((*(unsigned_int *)(*input_data + 0x1c) & 0x300) == 0) {\n      FUNC_08003c4a(input_data);\n      FUNC_08003c6e(input_data);\n    }\n    else {\n      FUNC_08003c5c(input_data);\n    }\n    *(unknown *)(input_data + 7) = 0;\n  }\n  if (((*(unsigned_int *)(*input_data + 0x10) & 1) == 1) && ((*(unsigned_int *)(*input_data + 0xc) & 1) == 1)) {\n    *(unknown4 *)(*input_data + 0x10) = 0xfffffffe;\n    calculate_pitch_and_update_data(input_data);\n  }\n  if (((*(unsigned_int *)(*input_data + 0x10) & 0x80) == 0x80) && ((*(unsigned_int *)(*input_data + 0xc) & 0x80) == 0x80))\n  {\n    *(unknown4 *)(*input_data + 0x10) = 0xffffff7f;\n    FUNC_08004378(input_data);\n  }\n  if (((*(unsigned_int *)(*input_data + 0x10) & 0x40) == 0x40) && ((*(unsigned_int *)(*input_data + 0xc) & 0x40) == 0x40))\n  {\n    *(unknown4 *)(*input_data + 0x10) = 0xffffffbf;\n    FUNC_08003c80(input_data);\n  }\n  if (((*(unsigned_int *)(*input_data + 0x10) & 0x20) == 0x20) && ((*(unsigned_int *)(*input_data + 0xc) & 0x20) == 0x20))\n  {\n    *(unknown4 *)(*input_data + 0x10) = 0xffffffdf;\n    FUNC_08004366(input_data);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080036f8": "process_flags_080036f8",
                "param_1": "input_data",
                "uint": "unsigned_int",
                "undefined": "unknown",
                "undefined4": "unknown4",
                "calculate_pitch_and_update_data_08004f78": "calculate_pitch_and_update_data"
            },
            "calling": [
                "FUN_08005714"
            ],
            "called": [
                "FUN_08004f78",
                "FUN_08003c6e",
                "FUN_08004378",
                "FUN_08003c4a",
                "FUN_08004366",
                "FUN_08003c80",
                "FUN_08003c5c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003908": {
            "entrypoint": "0x08003908",
            "current_name": "update_flag_and_value_08003908",
            "code": "\nundefined4 update_flag_and_value_08003908(int *data_array,int param_value,undefined4 operation_code)\n\n{\n  undefined4 result;\n  \n  if (*(char *)(data_array + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(data_array + 0xf) = 1;\n    *(undefined *)((int)data_array + 0x3d) = 2;\n    switch(operation_code) {\n    case 0:\n      set_flags_and_values_08003d60(*data_array,param_value);\n      *(uint *)(*data_array + 0x18) = *(uint *)(*data_array + 0x18) | 8;\n      *(uint *)(*data_array + 0x18) = *(uint *)(*data_array + 0x18) & 0xfffffffb;\n      *(uint *)(*data_array + 0x18) = *(uint *)(param_value + 0x10) | *(uint *)(*data_array + 0x18);\n      break;\n    case 4:\n      modify_parameters_08003e38(*data_array,param_value);\n      *(uint *)(*data_array + 0x18) = *(uint *)(*data_array + 0x18) | 0x800;\n      *(uint *)(*data_array + 0x18) = *(uint *)(*data_array + 0x18) & 0xfffffbff;\n      *(uint *)(*data_array + 0x18) = *(int *)(param_value + 0x10) << 8 | *(uint *)(*data_array + 0x18);\n      break;\n    case 8:\n      update_function_08003f18(*data_array,param_value);\n      *(uint *)(*data_array + 0x1c) = *(uint *)(*data_array + 0x1c) | 8;\n      *(uint *)(*data_array + 0x1c) = *(uint *)(*data_array + 0x1c) & 0xfffffffb;\n      *(uint *)(*data_array + 0x1c) = *(uint *)(param_value + 0x10) | *(uint *)(*data_array + 0x1c);\n      break;\n    case 0xc:\n      update_data_08003ff8(*data_array,param_value);\n      *(uint *)(*data_array + 0x1c) = *(uint *)(*data_array + 0x1c) | 0x800;\n      *(uint *)(*data_array + 0x1c) = *(uint *)(*data_array + 0x1c) & 0xfffffbff;\n      *(uint *)(*data_array + 0x1c) = *(int *)(param_value + 0x10) << 8 | *(uint *)(*data_array + 0x1c);\n    }\n    *(undefined *)((int)data_array + 0x3d) = 1;\n    *(undefined *)(data_array + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003908": "update_flag_and_value_08003908",
                "param_1": "data_array",
                "param_2": "param_value",
                "param_3": "operation_code",
                "uVar1": "result"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [
                "FUN_08003ff8",
                "FUN_08003d60",
                "FUN_08003f18",
                "FUN_08003e38"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a94": {
            "entrypoint": "0x08003a94",
            "current_name": "update_settings_08003a94",
            "code": "\nundefined4 updateSettings_08003a94(int *settings,uint *config)\n\n{\n  undefined4 returnValue;\n  uint configValue;\n  \n  if (*(char *)(settings + 0xf) == '\\x01') {\n    returnValue = 2;\n  }\n  else {\n    *(undefined *)(settings + 0xf) = 1;\n    *(undefined *)((int)settings + 0x3d) = 2;\n    *(uint *)(*settings + 8) = *(uint *)(*settings + 8) & 0xffff0088;\n    configValue = *config;\n    if (configValue == 0x40) {\n      update_parameters_080040a0(*settings,config[1],config[3]);\n      update_bit_mask_0800416a(*settings,0x40);\n    }\n    else if (configValue < 0x41) {\n      if (configValue == 0x10) {\n        update_bit_mask_0800416a(*settings,0x10);\n      }\n      else if (configValue < 0x11) {\n        if (configValue == 0) {\n          update_bit_mask_0800416a(*settings,0);\n        }\n      }\n      else if (configValue == 0x20) {\n        update_bit_mask_0800416a(*settings,0x20);\n      }\n      else if (configValue == 0x30) {\n        update_bit_mask_0800416a(*settings,0x30);\n      }\n    }\n    else if (configValue == 0x70) {\n      update_parameter_080041a8(*settings,config[2],config[1],config[3]);\n      *(uint *)(*settings + 8) = *(uint *)(*settings + 8) & 0xffffff88 | 0x77;\n    }\n    else if (configValue < 0x71) {\n      if (configValue == 0x50) {\n        update_parameters_080040a0(*settings,config[1],config[3]);\n        update_bit_mask_0800416a(*settings,0x50);\n      }\n      else if (configValue == 0x60) {\n        update_flags_08004104(*settings,config[1],config[3]);\n        update_bit_mask_0800416a(*settings,0x60);\n      }\n    }\n    else if (configValue == 0x1000) {\n      *(uint *)(*settings + 8) = *(uint *)(*settings + 8) & 0xfffffff8;\n    }\n    else if (configValue == 0x2000) {\n      update_parameter_080041a8(*settings,config[2],config[1],config[3]);\n      *(uint *)(*settings + 8) = *(uint *)(*settings + 8) | 0x4000;\n    }\n    *(undefined *)((int)settings + 0x3d) = 1;\n    *(undefined *)(settings + 0xf) = 0;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08003a94": "update_settings_08003a94",
                "param_1": "settings",
                "param_2": "config",
                "uVar1": "returnValue",
                "uVar2": "configValue"
            },
            "calling": [
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "called": [
                "FUN_08004104",
                "FUN_080040a0",
                "FUN_0800416a",
                "FUN_080041a8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c4a": {
            "entrypoint": "0x08003c4a",
            "current_name": "FUNC_08003c4a",
            "code": "\nvoid FUNC_08003c4a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c4a": "FUNC_08003c4a"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c5c": {
            "entrypoint": "0x08003c5c",
            "current_name": "FUNC_08003c5c",
            "code": "\nvoid FUNC_08003c5c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c5c": "FUNC_08003c5c"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c6e": {
            "entrypoint": "0x08003c6e",
            "current_name": "FUNC_08003c6e",
            "code": "\nvoid FUNC_08003c6e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c6e": "FUNC_08003c6e"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c80": {
            "entrypoint": "0x08003c80",
            "current_name": "FUNC_08003c80",
            "code": "\nvoid FUNC_08003c80(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c80": "FUNC_08003c80"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c94": {
            "entrypoint": "0x08003c94",
            "current_name": "update_memory_08003c94",
            "code": "\nvoid updateMemory_08003c94(uint *memoryAddress,uint *newData)\n\n{\n  uint currentData;\n  \n  currentData = *memoryAddress;\n  if ((((memoryAddress == (uint *)0x40012c00) || (memoryAddress == (uint *)0x40000000)) ||\n      (memoryAddress == (uint *)0x40000400)) || (memoryAddress == (uint *)0x40000800)) {\n    currentData = newData[1] | currentData & 0xffffff8f;\n  }\n  if (((memoryAddress == (uint *)0x40012c00) || (memoryAddress == (uint *)0x40000000)) ||\n     ((memoryAddress == (uint *)0x40000400 || (memoryAddress == (uint *)0x40000800)))) {\n    currentData = newData[3] | currentData & 0xfffffcff;\n  }\n  *memoryAddress = newData[5] | currentData & 0xffffff7f;\n  memoryAddress[0xb] = newData[2];\n  memoryAddress[10] = *newData;\n  if (memoryAddress == (uint *)0x40012c00) {\n    specialData = newData[4];\n  }\n  memoryAddress[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c94": "update_memory_08003c94",
                "param_1": "memoryAddress",
                "param_2": "newData",
                "local_c": "currentData",
                "uRam40012c30": "specialData"
            },
            "calling": [
                "FUN_08003640",
                "FUN_080035a4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d60": {
            "entrypoint": "0x08003d60",
            "current_name": "set_flags_and_values_08003d60",
            "code": "\nvoid setFlagsAndValues_08003d60(int address,uint *values)\n\n{\n  uint variable1;\n  uint variable2;\n  uint localVariable;\n  \n  *(uint *)(address + 0x20) = *(uint *)(address + 0x20) & 0xfffffffe;\n  localVariable = *(uint *)(address + 4);\n  variable1 = *values;\n  variable2 = values[2] | *(uint *)(address + 0x20) & 0xfffffffd;\n  if (address == 0x40012c00) {\n    variable2 = (values[3] | variable2 & 0xfffffff7) & 0xfffffffb;\n    localVariable = values[6] | values[5] | localVariable & 0xfffffcff;\n  }\n  *(uint *)(address + 4) = localVariable;\n  *(uint *)(address + 0x18) = variable1 | *(uint *)(address + 0x18) & 0xffffff8c;\n  *(uint *)(address + 0x34) = values[1];\n  *(uint *)(address + 0x20) = variable2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003d60": "set_flags_and_values_08003d60",
                "param_1": "address",
                "param_2": "values",
                "uVar1": "variable1",
                "uVar2": "variable2",
                "local_10": "localVariable"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e38": {
            "entrypoint": "0x08003e38",
            "current_name": "modify_parameters_08003e38",
            "code": "\nvoid modifyParameters_08003e38(int baseAddress,int *parameters)\n\n{\n  int value1;\n  uint value2;\n  uint value3;\n  \n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & 0xffffffef;\n  value3 = *(uint *)(baseAddress + 4);\n  value1 = *parameters;\n  value2 = parameters[2] << 4 | *(uint *)(baseAddress + 0x20) & 0xffffffdf;\n  if (baseAddress == 0x40012c00) {\n    value2 = (parameters[3] << 4 | value2 & 0xffffff7f) & 0xffffffbf;\n    value3 = parameters[6] << 2 | parameters[5] << 2 | value3 & 0xfffff3ff;\n  }\n  *(uint *)(baseAddress + 4) = value3;\n  *(uint *)(baseAddress + 0x18) = value1 << 8 | *(uint *)(baseAddress + 0x18) & 0xffff8cff;\n  *(int *)(baseAddress + 0x38) = parameters[1];\n  *(uint *)(baseAddress + 0x20) = value2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e38": "modify_parameters_08003e38",
                "param_1": "baseAddress",
                "param_2": "parameters",
                "iVar1": "value1",
                "uVar2": "value2",
                "local_10": "value3"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f18": {
            "entrypoint": "0x08003f18",
            "current_name": "update_function_08003f18",
            "code": "\nvoid updateFunction_08003f18(int functionBaseAddress,uint *parameters)\n\n{\n  uint value1;\n  uint value2;\n  uint localValue;\n  \n  *(uint *)(functionBaseAddress + 0x20) = *(uint *)(functionBaseAddress + 0x20) & 0xfffffeff;\n  localValue = *(uint *)(functionBaseAddress + 4);\n  value1 = *parameters;\n  value2 = parameters[2] << 8 | *(uint *)(functionBaseAddress + 0x20) & 0xfffffdff;\n  if (functionBaseAddress == 0x40012c00) {\n    value2 = (parameters[3] << 8 | value2 & 0xfffff7ff) & 0xfffffbff;\n    localValue = parameters[6] << 4 | parameters[5] << 4 | localValue & 0xffffcfff;\n  }\n  *(uint *)(functionBaseAddress + 4) = localValue;\n  *(uint *)(functionBaseAddress + 0x1c) = value1 | *(uint *)(functionBaseAddress + 0x1c) & 0xffffff8c;\n  *(uint *)(functionBaseAddress + 0x3c) = parameters[1];\n  *(uint *)(functionBaseAddress + 0x20) = value2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f18": "update_function_08003f18",
                "param_1": "functionBaseAddress",
                "param_2": "parameters",
                "uVar1": "value1",
                "uVar2": "value2",
                "local_10": "localValue"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ff8": {
            "entrypoint": "0x08003ff8",
            "current_name": "update_data_08003ff8",
            "code": "\nvoid updateData_08003ff8(int dataAddress,int *paramArray)\n\n{\n  int paramValue1;\n  int paramValue2;\n  uint value;\n  \n  *(uint *)(dataAddress + 0x20) = *(uint *)(dataAddress + 0x20) & 0xffffefff;\n  value = *(uint *)(dataAddress + 4);\n  paramValue1 = *paramArray;\n  paramValue2 = paramArray[2];\n  if (dataAddress == 0x40012c00) {\n    value = paramArray[5] << 6 | value & 0xffffbfff;\n  }\n  *(uint *)(dataAddress + 4) = value;\n  *(uint *)(dataAddress + 0x1c) = paramValue1 << 8 | *(uint *)(dataAddress + 0x1c) & 0xffff8cff;\n  *(int *)(dataAddress + 0x40) = paramArray[1];\n  *(uint *)(dataAddress + 0x20) = paramValue2 << 0xc | *(uint *)(dataAddress + 0x20) & 0xffffdfff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ff8": "update_data_08003ff8",
                "param_1": "dataAddress",
                "param_2": "paramArray",
                "local_c": "value",
                "iVar1": "paramValue1",
                "iVar2": "paramValue2"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040a0": {
            "entrypoint": "0x080040a0",
            "current_name": "update_parameters_080040a0",
            "code": "\nvoid update_parameters_080040a0(int input_ptr,uint bitmask,int value)\n\n{\n  uint temp_var;\n  \n  temp_var = *(uint *)(input_ptr + 0x20);\n  *(uint *)(input_ptr + 0x20) = *(uint *)(input_ptr + 0x20) & 0xfffffffe;\n  *(uint *)(input_ptr + 0x18) = value << 4 | *(uint *)(input_ptr + 0x18) & 0xffffff0f;\n  *(uint *)(input_ptr + 0x20) = bitmask | temp_var & 0xfffffff5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040a0": "update_parameters_080040a0",
                "param_1": "input_ptr",
                "param_2": "bitmask",
                "param_3": "value",
                "uVar1": "temp_var"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004104": {
            "entrypoint": "0x08004104",
            "current_name": "update_flags_08004104",
            "code": "\nvoid updateFlags_08004104(int baseAddress,int value1,int value2)\n\n{\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & 0xffffffef;\n  *(uint *)(baseAddress + 0x18) = value2 << 0xc | *(uint *)(baseAddress + 0x18) & 0xffff0fff;\n  *(uint *)(baseAddress + 0x20) = value1 << 4 | *(uint *)(baseAddress + 0x20) & 0xffffff5f;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004104": "update_flags_08004104",
                "param_1": "baseAddress",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800416a": {
            "entrypoint": "0x0800416a",
            "current_name": "update_bit_mask_0800416a",
            "code": "\nvoid updateBitMask_0800416a(int baseAddress,ushort newBits)\n\n{\n  *(uint *)(baseAddress + 8) = *(uint *)(baseAddress + 8) & 0xffffff8f | (uint)(newBits | 7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800416a": "update_bit_mask_0800416a",
                "param_1": "baseAddress",
                "param_2": "newBits"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041a8": {
            "entrypoint": "0x080041a8",
            "current_name": "update_parameter_080041a8",
            "code": "\nvoid updateParameter_080041a8(int ptr_buffer,uint value_1,uint value_2,int value_3)\n\n{\n  *(uint *)(ptr_buffer + 8) = value_1 | value_3 << 8 | value_2 | *(uint *)(ptr_buffer + 8) & 0xffff00ff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041a8": "update_parameter_080041a8",
                "param_1": "ptr_buffer",
                "param_2": "value_1",
                "param_3": "value_2",
                "param_4": "value_3"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041ea": {
            "entrypoint": "0x080041ea",
            "current_name": "update_bits_080041ea",
            "code": "\nvoid updateBits_080041ea(int baseAddress,uint bitPosition,int newValue)\n\n{\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & ~(1 << (bitPosition & 0xff));\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) | newValue << (bitPosition & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041ea": "update_bits_080041ea",
                "param_1": "baseAddress",
                "param_2": "bitPosition",
                "param_3": "newValue"
            },
            "calling": [
                "FUN_080036a8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800422e": {
            "entrypoint": "0x0800422e",
            "current_name": "set_flag_based_on_condition_0800422e",
            "code": "\nundefined4 setFlagBasedOnCondition_0800422e(int *flagArray,uint *data)\n\n{\n  undefined4 returnValue;\n  \n  if (*(char *)(flagArray + 0xf) == '\\x01') {\n    returnValue = 2;\n  }\n  else {\n    *(undefined *)(flagArray + 0xf) = 1;\n    *(uint *)(*flagArray + 0x44) =\n         data[6] |\n         (data[6] |\n         (data[5] |\n         (data[4] |\n         (*data | (data[1] | (data[2] | data[3] & 0xfffffcff) & 0xfffffbff) & 0xfffff7ff\n         ) & 0xffffefff) & 0xffffdfff) & 0xffffbfff) & 0xffff7fff;\n    *(undefined *)(flagArray + 0xf) = 0;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_0800422e": "set_flag_based_on_condition_0800422e",
                "param_1": "flagArray",
                "param_2": "data",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042de": {
            "entrypoint": "0x080042de",
            "current_name": "update_flags_and_return_result_080042de",
            "code": "\nundefined4 updateFlagsAndReturnResult_080042de(int *inputArray,uint *flagsArray)\n\n{\n  undefined4 result;\n  \n  if (*(char *)(inputArray + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(inputArray + 0xf) = 1;\n    *(undefined *)((int)inputArray + 0x3d) = 2;\n    *(uint *)(*inputArray + 4) = *(uint *)(*inputArray + 4) & 0xffffff8f;\n    *(uint *)(*inputArray + 4) = *flagsArray | *(uint *)(*inputArray + 4);\n    *(uint *)(*inputArray + 8) = *(uint *)(*inputArray + 8) & 0xffffff7f;\n    *(uint *)(*inputArray + 8) = flag2 | *(uint *)(*inputArray + 8);\n    *(undefined *)((int)inputArray + 0x3d) = 1;\n    *(undefined *)(inputArray + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080042de": "update_flags_and_return_result_080042de",
                "param_1": "inputArray",
                "param_2": "flagsArray",
                "uVar1": "result",
                "param_2[1]": "flag2"
            },
            "calling": [
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004366": {
            "entrypoint": "0x08004366",
            "current_name": "FUNC_08004366",
            "code": "\nvoid FUNC_08004366(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004366": "FUNC_08004366"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004378": {
            "entrypoint": "0x08004378",
            "current_name": "FUNC_08004378",
            "code": "\nvoid FUNC_08004378(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004378": "FUNC_08004378"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800438a": {
            "entrypoint": "0x0800438a",
            "current_name": "initialize_memory_0800438a",
            "code": "\nundefined4 initializeMemory_0800438a(int *memory)\n\n{\n  undefined4 result;\n  \n  if (memory == (int *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)memory + 0x39) == '\\0') {\n      *(undefined *)(memory + 0xe) = 0;\n      FUNC_08004424(memory);\n    }\n    *(undefined *)((int)memory + 0x39) = 0x24;\n    *(uint *)(*memory + 0xc) = *(uint *)(*memory + 0xc) & 0xffffdfff;\n    updateMemoryInfo(memory);\n    *(uint *)(*memory + 0x10) = *(uint *)(*memory + 0x10) & 0xffffb7ff;\n    *(uint *)(*memory + 0x14) = *(uint *)(*memory + 0x14) & 0xffffffd5;\n    *(uint *)(*memory + 0xc) = *(uint *)(*memory + 0xc) | 0x2000;\n    counter = 0;\n    *(undefined *)((int)memory + 0x39) = 0x20;\n    *(undefined *)((int)memory + 0x3a) = 0x20;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800438a": "initialize_memory_0800438a",
                "param_1": "memory",
                "uVar1": "result",
                "update_memory_info_080046ec": "updateMemoryInfo",
                "param_1[0xf]": "counter"
            },
            "calling": [
                "FUN_08005598"
            ],
            "called": [
                "FUN_08004424",
                "FUN_080046ec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004424": {
            "entrypoint": "0x08004424",
            "current_name": "FUNC_08004424",
            "code": "\nvoid FUNC_08004424(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004424": "FUNC_08004424"
            },
            "calling": [
                "FUN_0800438a"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004436": {
            "entrypoint": "0x08004436",
            "current_name": "process_data_08004436",
            "code": "\nundefined4 processData_08004436(uint **data,ushort *buffer,short bufferSize,uint maxDataSize)\n\n{\n  int result;\n  int getDataResult;\n  undefined4 returnValue;\n  ushort *dataPtr;\n  \n  if (*(char *)((int)data + 0x39) == ' ') {\n    if ((buffer == (ushort *)0x0) || (bufferSize == 0)) {\n      returnValue = 1;\n    }\n    else if (*(char *)(data + 0xe) == '\\x01') {\n      returnValue = 2;\n    }\n    else {\n      *(undefined *)(data + 0xe) = 1;\n      data[0xf] = (uint *)0x0;\n      *(undefined *)((int)data + 0x39) = 0x21;\n      result = get_data_from_memory_080015a0();\n      *(short *)(data + 9) = bufferSize;\n      *(short *)((int)data + 0x26) = bufferSize;\n      dataPtr = buffer;\n      while (*(short *)((int)data + 0x26) != 0) {\n        *(short *)((int)data + 0x26) = *(short *)((int)data + 0x26) + -1;\n        if (data[2] == (uint *)0x1000) {\n          do {\n            if ((**data & 0x80) == 0x80) {\n              getDataResult = 0;\n              goto LAB_0800454c;\n            }\n          } while ((maxDataSize == 0xffffffff) ||\n                  ((maxDataSize != 0 && (getDataResult = get_data_from_memory_080015a0(), (uint)(getDataResult - result) <= maxDataSize))));\n          (*data)[3] = (*data)[3] & 0xfffffe5f;\n          (*data)[5] = (*data)[5] & 0xfffffffe;\n          *(undefined *)((int)data + 0x39) = 0x20;\n          *(undefined *)((int)data + 0x3a) = 0x20;\n          *(undefined *)(data + 0xe) = 0;\n          getDataResult = 3;\nLAB_0800454c:\n          if (getDataResult != 0) {\n            return 3;\n          }\n          (*data)[1] = *dataPtr & 0x1ff;\n          if (data[4] == (uint *)0x0) {\n            dataPtr = dataPtr + 1;\n          }\n          else {\n            dataPtr = (ushort *)((int)dataPtr + 1);\n          }\n        }\n        else {\n          do {\n            if ((**data & 0x80) == 0x80) {\n              getDataResult = 0;\n              goto LAB_08004614;\n            }\n          } while ((maxDataSize == 0xffffffff) ||\n                  ((maxDataSize != 0 && (getDataResult = get_data_from_memory_080015a0(), (uint)(getDataResult - result) <= maxDataSize))));\n          (*data)[3] = (*data)[3] & 0xfffffe5f;\n          (*data)[5] = (*data)[5] & 0xfffffffe;\n          *(undefined *)((int)data + 0x39) = 0x20;\n          *(undefined *)((int)data + 0x3a) = 0x20;\n          *(undefined *)(data + 0xe) = 0;\n          getDataResult = 3;\nLAB_08004614:\n          if (getDataResult != 0) {\n            return 3;\n          }\n          (*data)[1] = (uint)*(byte *)dataPtr;\n          dataPtr = (ushort *)((int)dataPtr + 1);\n        }\n      }\n      do {\n        if ((**data & 0x40) == 0x40) {\n          result = 0;\n          goto LAB_080046c6;\n        }\n      } while ((maxDataSize == 0xffffffff) ||\n              ((maxDataSize != 0 && (getDataResult = get_data_from_memory_080015a0(), (uint)(getDataResult - result) <= maxDataSize))));\n      (*data)[3] = (*data)[3] & 0xfffffe5f;\n      (*data)[5] = (*data)[5] & 0xfffffffe;\n      *(undefined *)((int)data + 0x39) = 0x20;\n      *(undefined *)((int)data + 0x3a) = 0x20;\n      *(undefined *)(data + 0xe) = 0;\n      result = 3;\nLAB_080046c6:\n      if (result == 0) {\n        *(undefined *)((int)data + 0x39) = 0x20;\n        *(undefined *)(data + 0xe) = 0;\n        returnValue = 0;\n      }\n      else {\n        returnValue = 3;\n      }\n    }\n  }\n  else {\n    returnValue = 2;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08004436": "process_data_08004436",
                "param_1": "data",
                "param_2": "buffer",
                "param_3": "bufferSize",
                "param_4": "maxDataSize",
                "iVar1": "result",
                "iVar2": "getDataResult",
                "uVar3": "returnValue",
                "local_58": "dataPtr"
            },
            "calling": [
                "FUN_08004f3c"
            ],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046ec": {
            "entrypoint": "0x080046ec",
            "current_name": "update_memory_info_080046ec",
            "code": "\nvoid updateMemoryInfo_080046ec(int *memoryInfo)\n\n{\n  ulonglong shiftedAddress;\n  int address1;\n  int value1;\n  uint value2;\n  int value3;\n  undefined8 extractedAddress;\n  \n  *(uint *)(*memoryInfo + 0x10) = memoryInfo[3] | *(uint *)(*memoryInfo + 0x10) & 0xffffcfff;\n  *(uint *)(*memoryInfo + 0xc) =\n       *(uint *)(*memoryInfo + 0xc) & 0xffffe9f3 | memoryInfo[5] | memoryInfo[2] | memoryInfo[4];\n  *(uint *)(*memoryInfo + 0x14) = memoryInfo[6] | *(uint *)(*memoryInfo + 0x14) & 0xfffffcff;\n  if (*memoryInfo == 0x40013800) {\n    extractedAddress = get_shifted_memory_address_08003540();\n    shiftedAddress = (ulonglong)(uint)((int)extractedAddress * 0x19) / (ulonglong)(uint)(memoryInfo[1] << 2);\n    address1 = get_shifted_memory_address_08003540((int)extractedAddress,(int)((ulonglong)extractedAddress >> 0x20),(int)(shiftedAddress * 0x51eb851f));\n    value1 = memoryInfo[1];\n    extractedAddress = get_shifted_memory_address_08003540();\n    value2 = ((uint)(address1 * 0x19) / (uint)(value1 << 2) +\n            (int)(((ulonglong)(uint)((int)extractedAddress * 0x19) / (ulonglong)(uint)(memoryInfo[1] << 2)) / 100)\n            * -100) * 0x10 + 0x32;\n    address1 = get_shifted_memory_address_08003540((int)extractedAddress,(int)((ulonglong)extractedAddress >> 0x20),value2 * 0x51eb851f);\n    value3 = memoryInfo[1];\n    value1 = get_shifted_memory_address_08003540();\n    *(uint *)(*memoryInfo + 8) =\n         ((((uint)(address1 * 0x19) / (uint)(value3 << 2) +\n           (int)(((ulonglong)(uint)(value1 * 0x19) / (ulonglong)(uint)(memoryInfo[1] << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) + (int)(shiftedAddress / 100) * 0x10 + (value2 / 100 & 0xf0);\n  }\n  else {\n    extractedAddress = extracted_memory_address_08003518();\n    shiftedAddress = (ulonglong)(uint)((int)extractedAddress * 0x19) / (ulonglong)(uint)(memoryInfo[1] << 2);\n    address1 = extracted_memory_address_08003518((int)extractedAddress,(int)((ulonglong)extractedAddress >> 0x20),(int)(shiftedAddress * 0x51eb851f));\n    value1 = memoryInfo[1];\n    extractedAddress = extracted_memory_address_08003518();\n    value2 = ((uint)(address1 * 0x19) / (uint)(value1 << 2) +\n            (int)(((ulonglong)(uint)((int)extractedAddress * 0x19) / (ulonglong)(uint)(memoryInfo[1] << 2)) / 100)\n            * -100) * 0x10 + 0x32;\n    address1 = extracted_memory_address_08003518((int)extractedAddress,(int)((ulonglong)extractedAddress >> 0x20),value2 * 0x51eb851f);\n    value3 = memoryInfo[1];\n    value1 = extracted_memory_address_08003518();\n    *(uint *)(*memoryInfo + 8) =\n         ((((uint)(address1 * 0x19) / (uint)(value3 << 2) +\n           (int)(((ulonglong)(uint)(value1 * 0x19) / (ulonglong)(uint)(memoryInfo[1] << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) + (int)(shiftedAddress / 100) * 0x10 + (value2 / 100 & 0xf0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046ec": "update_memory_info_080046ec",
                "param_1": "memoryInfo",
                "uVar1": "shiftedAddress",
                "iVar2": "address1",
                "iVar3": "value1",
                "uVar4": "value2",
                "iVar5": "value3",
                "uVar6": "extractedAddress"
            },
            "calling": [
                "FUN_0800438a"
            ],
            "called": [
                "FUN_08003518",
                "FUN_08003540"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800491c": {
            "entrypoint": "0x0800491c",
            "current_name": "initialize_parameters_0800491c",
            "code": "\nvoid initializeParameters_0800491c(undefined4 *parameters)\n\n{\n  undefined zero;\n  undefined value;\n  undefined array [5];\n  \n  zero = 0;\n  (*DAT_20000a54)(0xd0,0x6b,&zero,1);\n  value = 0x10;\n  (*DAT_20000a54)(0xd0,0x1c,&value,1);\n  array[0] = 8;\n  (*DAT_20000a54)(0xd0,0x1b,array,1);\n  *parameters = 0;\n  parameters[1] = 0;\n  parameters[2] = 0;\n  parameters[3] = 0;\n  parameters[4] = 0;\n  parameters[5] = 0;\n  parameters[6] = 0;\n  parameters[7] = 0;\n  parameters[8] = 0;\n  parameters[9] = 0;\n  parameters[10] = 0;\n  calculate_results_080049cc(parameters);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800491c": "initialize_parameters_0800491c",
                "param_1": "parameters",
                "local_13": "zero",
                "local_12": "value",
                "local_11": "array"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_080049cc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049cc": {
            "entrypoint": "0x080049cc",
            "current_name": "calculate_results_080049cc",
            "code": "\nvoid calculateResults_080049cc(int inputData)\n\n{\n  undefined4 modifiedValue;\n  undefined4 result2;\n  undefined4 result1;\n  undefined4 currentTime;\n  int iterationCount;\n  int iterationIndex;\n  undefined4 sum1;\n  undefined4 sum2;\n  undefined4 sum3;\n  undefined4 sum4;\n  \n  iterationCount = 1;\n  sum4 = 0;\n  sum3 = 0;\n  sum2 = 0;\n  sum1 = 0;\n  currentTime = (*DAT_20000a50)();\n  iterationIndex = 0;\n  while( true ) {\n    if (iterationCount <= iterationIndex) break;\n    result1 = 0;\n    result2 = 0;\n    initialize_data_08004ae0(inputData);\n    calculate_result_08004d78(inputData,&result1,&result2);\n    sum2 = perform_arithmetic_operation_08000aa8(sum2,result1);\n    sum1 = perform_arithmetic_operation_08000aa8(sum1,result2);\n    sum4 = perform_arithmetic_operation_08000aa8(sum4,*(undefined4 *)(inputData + 0x10));\n    sum3 = perform_arithmetic_operation_08000aa8(sum3,*(undefined4 *)(inputData + 0x14));\n    currentTime = (*DAT_20000a50)();\n    iterationIndex = iterationIndex + 1;\n  }\n  modifiedValue = compute_modified_value_08000c10(iterationCount);\n  modifiedValue = floating_point_addition_08000e20(sum4,modifiedValue);\n  *(undefined4 *)(inputData + 0x1c) = modifiedValue;\n  modifiedValue = compute_modified_value_08000c10(iterationCount);\n  modifiedValue = floating_point_addition_08000e20(sum3,modifiedValue);\n  *(undefined4 *)(inputData + 0x20) = modifiedValue;\n  modifiedValue = compute_modified_value_08000c10(iterationCount);\n  modifiedValue = floating_point_addition_08000e20(sum2,modifiedValue);\n  *(undefined4 *)(inputData + 0x24) = modifiedValue;\n  modifiedValue = compute_modified_value_08000c10(iterationCount);\n  modifiedValue = floating_point_addition_08000e20(sum1,modifiedValue);\n  *(undefined4 *)(inputData + 0x28) = modifiedValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080049cc": "calculate_results_080049cc",
                "param_1": "inputData",
                "uVar1": "modifiedValue",
                "local_2c": "result2",
                "local_28": "result1",
                "local_24": "currentTime",
                "local_20": "iterationCount",
                "local_1c": "iterationIndex",
                "local_18": "sum1",
                "local_14": "sum2",
                "local_10": "sum3",
                "local_c": "sum4"
            },
            "calling": [
                "FUN_0800491c"
            ],
            "called": [
                "FUN_08000e20",
                "FUN_08000aa8",
                "FUN_08004ae0",
                "FUN_08004d78",
                "FUN_08000c10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ae0": {
            "entrypoint": "0x08004ae0",
            "current_name": "initialize_data_08004ae0",
            "code": "\nvoid initializeData_08004ae0(undefined4 *data)\n\n{\n  undefined4 modifiedValue;\n  undefined temp_1;\n  undefined temp_2;\n  undefined temp_3;\n  undefined temp_4;\n  undefined temp_5;\n  undefined temp_6;\n  undefined temp_7;\n  undefined temp_8;\n  undefined temp_9;\n  undefined temp_10;\n  undefined temp_11;\n  undefined temp_12;\n  undefined temp_13;\n  undefined temp_14;\n  short modified_1;\n  short modified_2;\n  short modified_3;\n  short modified_4;\n  short modified_5;\n  short modified_6;\n  \n  (*DAT_20000a4c)(0xd0,0x3b,&temp_1,0xe);\n  modified_6 = CONCAT11(temp_3,temp_4);\n  modified_5 = CONCAT11(temp_5,temp_6);\n  modified_4 = CONCAT11(temp_7,temp_8);\n  modified_3 = CONCAT11(temp_9,temp_10);\n  modified_2 = CONCAT11(temp_11,temp_12);\n  modified_1 = CONCAT11(temp_13,temp_14);\n  modifiedValue = computeModifiedValue((int)CONCAT11(temp_1,temp_2));\n  *data = modifiedValue;\n  modifiedValue = computeModifiedValue((int)modified_6);\n  data[1] = modifiedValue;\n  modifiedValue = computeModifiedValue((int)modified_5);\n  data[2] = modifiedValue;\n  modifiedValue = computeModifiedValue((int)modified_4);\n  data[3] = modifiedValue;\n  modifiedValue = computeModifiedValue((int)modified_3);\n  data[4] = modifiedValue;\n  modifiedValue = computeModifiedValue((int)modified_2);\n  data[5] = modifiedValue;\n  modifiedValue = computeModifiedValue((int)modified_1);\n  data[6] = modifiedValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ae0": "initialize_data_08004ae0",
                "param_1": "data",
                "uVar1": "modifiedValue",
                "local_2c": "temp_1",
                "local_2b": "temp_2",
                "local_2a": "temp_3",
                "local_29": "temp_4",
                "local_28": "temp_5",
                "local_27": "temp_6",
                "local_26": "temp_7",
                "local_25": "temp_8",
                "local_24": "temp_9",
                "local_23": "temp_10",
                "local_22": "temp_11",
                "local_21": "temp_12",
                "local_20": "temp_13",
                "local_1f": "temp_14",
                "local_1e": "modified_1",
                "local_1c": "modified_2",
                "local_1a": "modified_3",
                "local_18": "modified_4",
                "local_16": "modified_5",
                "local_14": "modified_6",
                "compute_modified_value_08000c10": "computeModifiedValue"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_080049cc"
            ],
            "called": [
                "FUN_08000c10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bd8": {
            "entrypoint": "0x08004bd8",
            "current_name": "calculate_and_update_result_08004bd8",
            "code": "\nvoid calculate_and_update_result_08004bd8(int input_data,undefined4 *output_data)\n\n{\n  undefined4 result_1;\n  undefined8 result_2;\n  undefined8 result_3;\n  \n  result_1 = calculate_floating_point_08000aa4(*(undefined4 *)(input_data + 0x10),*(undefined4 *)(input_data + 0x1c));\n  result_2 = calculate_shifted_value_08000418(DAT_200009e4);\n  result_3 = calculate_shifted_value_08000418(result_1);\n  result_3 = calculate_result_080004c8((int)result_3,(int)((ulonglong)result_3 >> 0x20),0x83f5c366,0x3f340215);\n  result_2 = calculate_result_0800015c((int)result_2,(int)((ulonglong)result_2 >> 0x20),(int)result_3,\n                       (int)((ulonglong)result_3 >> 0x20));\n  DAT_200009e4 = calculate_float_value_080009fc((int)result_2,(int)((ulonglong)result_2 >> 0x20));\n  result_2 = calculate_shifted_value_08000418(*(undefined4 *)(input_data + 4));\n  result_2 = calculate_float_value_0800071c((int)result_2,(int)((ulonglong)result_2 >> 0x20),0,0x40b00000);\n  result_3 = calculate_shifted_value_08000418(*(undefined4 *)(input_data + 8));\n  result_3 = calculate_float_value_0800071c((int)result_3,(int)((ulonglong)result_3 >> 0x20),0,0x40b00000);\n  result_2 = thunk_calculate_float_value_08005838((int)result_2,(int)((ulonglong)result_2 >> 0x20),(int)result_3,\n                             (int)((ulonglong)result_3 >> 0x20));\n  result_2 = calculate_result_080004c8((int)result_2,(int)((ulonglong)result_2 >> 0x20),0,0x40668000);\n  result_2 = calculate_float_value_0800071c((int)result_2,(int)((ulonglong)result_2 >> 0x20),0x54442d18,0x400921fb);\n  result_3 = calculate_shifted_value_08000418(*(undefined4 *)(input_data + 0x24));\n  result_2 = perform_arithmetic_operations_08000158((int)result_2,(int)((ulonglong)result_2 >> 0x20),(int)result_3,\n                       (int)((ulonglong)result_3 >> 0x20));\n  result_2 = calculate_result_0800015c((int)result_2,(int)((ulonglong)result_2 >> 0x20),0,0x40568000);\n  result_1 = calculate_float_value_080009fc((int)result_2,(int)((ulonglong)result_2 >> 0x20));\n  if (DAT_20000005 == '\\0') {\n    result_2 = calculate_shifted_value_08000418(DAT_200009e4);\n    result_2 = calculate_result_080004c8((int)result_2,(int)((ulonglong)result_2 >> 0x20),0x9999999a,0x3fe99999);\n    result_3 = calculate_shifted_value_08000418(result_1);\n    result_3 = calculate_result_080004c8((int)result_3,(int)((ulonglong)result_3 >> 0x20),0x9999999a,0x3fc99999);\n    result_2 = calculate_result_0800015c((int)result_2,(int)((ulonglong)result_2 >> 0x20),(int)result_3,\n                         (int)((ulonglong)result_3 >> 0x20));\n    DAT_200009e4 = calculate_float_value_080009fc((int)result_2,(int)((ulonglong)result_2 >> 0x20));\n  }\n  else {\n    DAT_20000005 = '\\0';\n    DAT_200009e4 = result_1;\n  }\n  *output_data = DAT_200009e4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bd8": "calculate_and_update_result_08004bd8",
                "param_1": "input_data",
                "param_2": "output_data",
                "uVar1": "result_1",
                "uVar2": "result_2",
                "uVar3": "result_3"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_080004c8",
                "FUN_08000158",
                "FUN_080009fc",
                "thunk_FUN_08005838",
                "FUN_08000418",
                "FUN_0800015c",
                "FUN_0800071c",
                "FUN_08000aa4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d78": {
            "entrypoint": "0x08004d78",
            "current_name": "calculate_result_08004d78",
            "code": "\nvoid calculateResult_08004d78(undefined4 *inputValues,undefined4 *outputValue1,undefined4 *outputValue2)\n\n{\n  undefined4 shiftedValue1;\n  undefined4 shiftedValue2;\n  undefined4 shiftedValue3;\n  undefined8 resultValue1;\n  undefined8 resultValue2;\n  \n  shiftedValue1 = floating_point_addition_08000e20(*inputValues,0x45800000);\n  shiftedValue2 = floating_point_addition_08000e20(inputValues[1],0x45800000);\n  shiftedValue3 = floating_point_addition_08000e20(inputValues[2],0x45800000);\n  resultValue1 = calculate_shifted_value_08000418(shiftedValue2);\n  resultValue2 = calculate_shifted_value_08000418(shiftedValue3);\n  resultValue1 = thunk_calculate_float_value_08005838((int)resultValue1,(int)((ulonglong)resultValue1 >> 0x20),(int)resultValue2,\n                             (int)((ulonglong)resultValue2 >> 0x20));\n  resultValue1 = calculate_result_080004c8((int)resultValue1,(int)((ulonglong)resultValue1 >> 0x20),0,0x40668000);\n  resultValue1 = calculate_float_value_0800071c((int)resultValue1,(int)((ulonglong)resultValue1 >> 0x20),0x54442d18,0x400921fb);\n  shiftedValue2 = calculate_float_value_080009fc((int)resultValue1,(int)((ulonglong)resultValue1 >> 0x20));\n  resultValue1 = calculate_shifted_value_08000418(shiftedValue1);\n  resultValue2 = calculate_shifted_value_08000418(shiftedValue3);\n  resultValue1 = thunk_calculate_float_value_08005838((int)resultValue1,(int)((ulonglong)resultValue1 >> 0x20),(int)resultValue2,\n                             (int)((ulonglong)resultValue2 >> 0x20));\n  resultValue1 = calculate_result_080004c8((int)resultValue1,(int)((ulonglong)resultValue1 >> 0x20),0,0x40668000);\n  resultValue1 = calculate_float_value_0800071c((int)resultValue1,(int)((ulonglong)resultValue1 >> 0x20),0x54442d18,0x400921fb);\n  shiftedValue1 = calculate_float_value_080009fc((int)resultValue1,(int)((ulonglong)resultValue1 >> 0x20));\n  *outputValue1 = shiftedValue2;\n  *outputValue2 = shiftedValue1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d78": "calculate_result_08004d78",
                "param_1": "inputValues",
                "param_2": "outputValue1",
                "param_3": "outputValue2",
                "uVar1": "shiftedValue1",
                "uVar2": "shiftedValue2",
                "uVar3": "shiftedValue3",
                "uVar4": "resultValue1",
                "uVar5": "resultValue2"
            },
            "calling": [
                "FUN_080049cc"
            ],
            "called": [
                "FUN_080004c8",
                "FUN_080009fc",
                "FUN_08000e20",
                "thunk_FUN_08005838",
                "FUN_08000418",
                "FUN_0800071c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e6c": {
            "entrypoint": "0x08004e6c",
            "current_name": "send_software_interrupt_08004e6c",
            "code": "\nvoid sendSoftwareInterrupt_08004e6c(void)\n\n{\n  software_interrupt(0x3f);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e6c": "send_software_interrupt_08004e6c"
            },
            "calling": [
                "FUN_08004e74"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e74": {
            "entrypoint": "0x08004e74",
            "current_name": "send_interrupt_08004e74",
            "code": "\nundefined4 send_interrupt_08004e74(undefined4 input_param)\n\n{\n  undefined4 result;\n  \n  if (DAT_200009f0 == 0) {\n    result = send_software_interrupt_08004e6c(1,input_param,0);\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004e74": "send_interrupt_08004e74",
                "param_1": "input_param",
                "uVar1": "result"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08004e6c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ea4": {
            "entrypoint": "0x08004ea4",
            "current_name": "process_data_wrapper_08004ea4",
            "code": "\nvoid process_data_wrapper_08004ea4(undefined input_param1,undefined input_param2,undefined4 count,undefined2 flag)\n\n{\n  process_data_08001ccc(&DAT_20000a88,input_param1,input_param2,1,count,flag,DAT_20000008);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ea4": "process_data_wrapper_08004ea4",
                "param_1": "input_param1",
                "param_2": "input_param2",
                "param_3": "count",
                "param_4": "flag"
            },
            "calling": [],
            "called": [
                "FUN_08001ccc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee8": {
            "entrypoint": "0x08004ee8",
            "current_name": "process_data_wrapper_08004ee8",
            "code": "\nvoid process_data_wrapper_08004ee8(undefined data1,undefined data2,undefined4 size,undefined2 flags)\n\n{\n  process_data_08001f6c(&DAT_20000a88,data1,data2,1,size,flags,DAT_20000008);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ee8": "process_data_wrapper_08004ee8",
                "param_1": "data1",
                "param_2": "data2",
                "param_3": "size",
                "param_4": "flags"
            },
            "calling": [],
            "called": [
                "FUN_08001f6c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f2c": {
            "entrypoint": "0x08004f2c",
            "current_name": "retrieve_data_from_memory_08004f2c",
            "code": "\nundefined4 retrieve_data_from_memory_08004f2c(void)\n\n{\n  undefined4 data;\n  \n  data = get_data_from_memory();\n  return data;\n}\n\n",
            "renaming": {
                "FUN_08004f2c": "retrieve_data_from_memory_08004f2c",
                "uVar1": "data",
                "get_data_from_memory_080015a0": "get_data_from_memory"
            },
            "calling": [],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "process_and_send_data_08004f3c",
            "code": "\nvoid process_and_send_data_08004f3c(undefined4 data_location,undefined2 data_size)\n\n{\n  process_data_08004436(&DAT_20000adc,data_location,data_size,0x32);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "process_and_send_data_08004f3c",
                "param_1": "data_location",
                "param_2": "data_size"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08004436"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f60": {
            "entrypoint": "0x08004f60",
            "current_name": "initialize_memory_08004f60",
            "code": "\nvoid initializeMemory_08004f60(void)\n\n{\n  clearMemory(&DAT_20000ba8,0,0x40);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f60": "initialize_memory_08004f60",
                "memset_aligned_08005d68": "clearMemory"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08005d68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f78": {
            "entrypoint": "0x08004f78",
            "current_name": "calculate_pitch_and_update_data_08004f78",
            "code": "\nvoid calculatePitchAndUpdateData_08004f78(void)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  byte local_11;\n  \n  initializeData(&DAT_20000a5c);\n  calculateAndUpdateResult(&DAT_20000a5c,&DAT_20000ba0);\n  initializeMemory();\n  uVar5 = calculateShiftedValue(DAT_20000ba0);\n  initializeMemoryWithFormat(&DAT_20000ba8,\"Pitch: %f\\n\",(int)uVar5,(int)((ulonglong)uVar5 >> 0x20));\n  uVar1 = getByteAlignment(&DAT_20000ba8);\n  processAndSendData(&DAT_20000ba8,uVar1);\n  DAT_200009f8 = calculateFloatingPoint(DAT_20000014,DAT_20000ba0);\n  DAT_20000be8 = calculateFloatFromIntegers(DAT_20000a00,DAT_200009f8);\n  uVar1 = calculateFloatFromIntegers(DAT_20000a04,DAT_200009f8);\n  DAT_20000b5c = performArithmeticOperation(uVar1,DAT_20000b5c);\n  uVar1 = computeModifiedValue(DAT_20000010);\n  iVar2 = checkIfConcatenationIsEmpty(uVar1,DAT_20000b5c);\n  if (iVar2 == 0) {\n    uVar1 = computeModifiedValue(DAT_200009f4);\n    iVar2 = checkIfConcatenatedParametersAreEmpty(uVar1,DAT_20000b5c);\n    if (iVar2 != 0) {\n      DAT_20000b5c = calculateResult(DAT_200009f4);\n    }\n  }\n  else {\n    DAT_20000b5c = calculateResult(DAT_20000010);\n  }\n  uVar4 = DAT_20000a08 ^ 0x80000000;\n  uVar1 = calculateFloatingPoint(DAT_200009f8,DAT_200009fc);\n  DAT_20000a58 = calculateFloatFromIntegers(uVar4,uVar1);\n  uVar1 = performArithmeticOperation(DAT_20000be8,DAT_20000b5c);\n  uVar1 = performArithmeticOperation(uVar1,DAT_20000a58);\n  uVar3 = computeModifiedValue(DAT_20000010);\n  iVar2 = checkIfConcatenatedParametersAreEmpty(uVar1,uVar3);\n  if (iVar2 == 0) {\n    uVar3 = computeModifiedValue(DAT_200009f4);\n    iVar2 = checkIfConcatenationIsEmpty(uVar1,uVar3);\n    if (iVar2 == 0) {\n      local_11 = checkValidity(uVar1);\n    }\n    else {\n      local_11 = DAT_200009f4;\n    }\n  }\n  else {\n    local_11 = DAT_20000010;\n  }\n  DAT_200009fc = DAT_200009f8;\n  iVar2 = checkIfConcatenatedParametersAreEmpty(DAT_200009f8,0);\n  updateData(0x40010800,2,iVar2 != 0);\n  iVar2 = checkIfConcatenatedParametersAreEmpty(DAT_200009f8,0);\n  updateData(0x40010800,4,iVar2 == 0);\n  iVar2 = checkIfConcatenatedParametersAreEmpty(DAT_200009f8,0);\n  updateData(0x40010800,8,iVar2 != 0);\n  iVar2 = checkIfConcatenatedParametersAreEmpty(DAT_200009f8,0);\n  updateData(0x40010800,0x10,iVar2 == 0);\n  *(uint *)(DAT_20000b1c + 0x34) = (uint)local_11;\n  *(uint *)(DAT_20000b1c + 0x40) = (uint)local_11;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f78": "calculate_pitch_and_update_data_08004f78",
                "initialize_data_08004ae0": "initializeData",
                "calculate_and_update_result_08004bd8": "calculateAndUpdateResult",
                "initialize_memory_08004f60": "initializeMemory",
                "calculate_shifted_value_08000418": "calculateShiftedValue",
                "initialize_memory_08005dfc": "initializeMemoryWithFormat",
                "get_byte_alignment_08005e40": "getByteAlignment",
                "process_and_send_data_08004f3c": "processAndSendData",
                "calculate_floating_point_08000aa4": "calculateFloatingPoint",
                "calculate_float_from_integers_08000cb8": "calculateFloatFromIntegers",
                "perform_arithmetic_operation_08000aa8": "performArithmeticOperation",
                "compute_modified_value_08000c10": "computeModifiedValue",
                "check_if_concatenation_is_empty_08000ff4": "checkIfConcatenationIsEmpty",
                "check_if_concatenated_parameters_are_empty_08001030": "checkIfConcatenatedParametersAreEmpty",
                "calculate_result_08000c08": "calculateResult",
                "check_validity_08001044": "checkValidity",
                "update_data_08001a80": "updateData"
            },
            "calling": [
                "FUN_080017b4",
                "FUN_080036f8"
            ],
            "called": [
                "FUN_08004bd8",
                "FUN_08005e40",
                "FUN_08000418",
                "FUN_08000ff4",
                "FUN_08001030",
                "FUN_08004ae0",
                "FUN_08000c10",
                "FUN_08000cb8",
                "FUN_08005dfc",
                "FUN_08001044",
                "FUN_08001a80",
                "FUN_08000c08",
                "FUN_08000aa8",
                "FUN_08004f60",
                "FUN_08000aa4",
                "FUN_08004f3c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005224": {
            "entrypoint": "0x08005224",
            "current_name": "initialize_systems_08005224",
            "code": "\nvoid initialize_systems_08005224(void)\n\n{\n  initialize_system_1();\n  initialize_system_2();\n  initialize_data_1();\n  initialize_data_2();\n  initialize_memory();\n  initialize_data_3();\n  initialize_data_4();\n  DAT_20000a54 = 0x8004ea5;\n  DAT_20000a4c = 0x8004ee9;\n  DAT_20000a50 = 0x8004f2d;\n  update_and_set_bits(&DAT_20000b1c,0);\n  update_and_set_bits(&DAT_20000b1c,0xc);\n  initialize_parameters(&DAT_20000a5c);\n  set_flags(&DAT_20000b60);\n  send_interrupt(0);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005224": "initialize_systems_08005224",
                "initialize_system_080014f0": "initialize_system_1",
                "initialize_system_080052a0": "initialize_system_2",
                "initialize_data_080055f4": "initialize_data_1",
                "initialize_data_08005348": "initialize_data_2",
                "initialize_memory_08005598": "initialize_memory",
                "initialize_data_08005500": "initialize_data_3",
                "initialize_data_080053b0": "initialize_data_4",
                "update_and_set_bits_080036a8": "update_and_set_bits",
                "initialize_parameters_0800491c": "initialize_parameters",
                "set_flags_0800360c": "set_flags",
                "send_interrupt_08004e74": "send_interrupt"
            },
            "calling": [
                "entry"
            ],
            "called": [
                "FUN_080053b0",
                "FUN_0800360c",
                "FUN_080014f0",
                "FUN_08005500",
                "FUN_08005598",
                "FUN_080052a0",
                "FUN_0800491c",
                "FUN_080036a8",
                "FUN_08005348",
                "FUN_080055f4",
                "FUN_08004e74"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052a0": {
            "entrypoint": "0x080052a0",
            "current_name": "initialize_system_080052a0",
            "code": "\nvoid initializeSystem_080052a0(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined4 flag1;\n  undefined4 flag2;\n  undefined4 flag3;\n  undefined4 flag4;\n  undefined4 flag5;\n  undefined4 flag6;\n  undefined4 flag7;\n  undefined4 flag8;\n  undefined4 flag9;\n  undefined4 flag10;\n  undefined4 flag11;\n  undefined4 flag12;\n  \n  flag6 = 1;\n  flag7 = 0x10000;\n  flag8 = 0;\n  flag9 = 1;\n  flag10 = 2;\n  flag11 = 0x10000;\n  flag12 = 0x1c0000;\n  iVar1 = process_flags_08002d98(&flag6);\n  if (iVar1 != 0) {\n    wait_forever_08005674(\"../src/main.c\",0x151);\n  }\n  flag1 = 0xf;\n  flag2 = 2;\n  flag3 = 0x80;\n  flag4 = 0;\n  flag5 = 0;\n  iVar1 = calculate_execution_time_08003260(&flag1,2);\n  if (iVar1 != 0) {\n    wait_forever_08005674(\"../src/main.c\",0x15e);\n  }\n  uVar2 = get_memory_address_08003504();\n  update_value_08001762((uint)uVar2 / 1000,(int)((ulonglong)uVar2 >> 0x20),(uint)uVar2 * 0x10624dd3);\n  set_register_bits_0800177c(4);\n  set_byte_value_with_bitwise_operations_0800172a(0xffffffff,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052a0": "initialize_system_080052a0",
                "local_44": "flag1",
                "local_40": "flag2",
                "local_3c": "flag3",
                "local_38": "flag4",
                "local_34": "flag5",
                "local_30": "flag6",
                "local_2c": "flag7",
                "local_28": "flag8",
                "local_20": "flag9",
                "local_14": "flag10",
                "local_10": "flag11",
                "local_c": "flag12"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08003504",
                "FUN_0800172a",
                "FUN_08005674",
                "FUN_08002d98",
                "FUN_08003260",
                "FUN_08001762",
                "FUN_0800177c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005348": {
            "entrypoint": "0x08005348",
            "current_name": "initialize_data_08005348",
            "code": "\nvoid initializeData_08005348(void)\n\n{\n  int iVar1;\n  \n  DAT_20000a88 = 0x40005400;\n  DAT_20000a8c = 400000;\n  DAT_20000a90 = 0;\n  DAT_20000a94 = 0;\n  DAT_20000a98 = 0x4000;\n  DAT_20000a9c = 0;\n  DAT_20000aa0 = 0;\n  DAT_20000aa4 = 0;\n  DAT_20000aa8 = 0;\n  iVar1 = calculateParamValues(&DAT_20000a88);\n  if (iVar1 != 0) {\n    waitForCompletion(\"../src/main.c\",0x17a);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005348": "initialize_data_08005348",
                "calculate_param_values_08001ab0": "calculateParamValues",
                "wait_forever_08005674": "waitForCompletion"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08001ab0",
                "FUN_08005674"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053b0": {
            "entrypoint": "0x080053b0",
            "current_name": "initialize_data_080053b0",
            "code": "\nvoid initializeData_080053b0(void)\n\n{\n  int iVar1;\n  undefined4 flag1;\n  undefined4 flag2;\n  undefined4 flag3;\n  undefined4 flag4;\n  undefined4 flag5;\n  undefined4 flag6;\n  undefined4 flag7;\n  undefined4 flag8;\n  undefined4 flag9;\n  undefined4 flag10;\n  undefined4 flag11;\n  undefined4 flag12;\n  undefined4 flag13;\n  undefined4 flag14;\n  undefined4 result;\n  undefined4 resultValidation;\n  undefined4 settings [4];\n  \n  DAT_20000b1c = 0x40012c00;\n  DAT_20000b20 = 0x708;\n  DAT_20000b24 = 0;\n  DAT_20000b28 = 100;\n  DAT_20000b2c = 0;\n  DAT_20000b30 = 0;\n  DAT_20000b34 = 0;\n  iVar1 = validateAndUpdateData(&DAT_20000b1c);\n  if (iVar1 != 0) {\n    waitForever(\"../src/main.c\",399);\n  }\n  settings[0] = 0x1000;\n  iVar1 = updateSettings(&DAT_20000b1c,settings);\n  if (iVar1 != 0) {\n    waitForever(\"../src/main.c\",0x194);\n  }\n  iVar1 = processData(&DAT_20000b1c);\n  if (iVar1 != 0) {\n    waitForever(\"../src/main.c\",0x198);\n  }\n  result = 0;\n  resultValidation = 0;\n  iVar1 = updateFlagsAndReturnResult(&DAT_20000b1c,&result);\n  if (iVar1 != 0) {\n    waitForever(\"../src/main.c\",0x19f);\n  }\n  flag8 = 0x60;\n  flag9 = 0;\n  flag10 = 0;\n  flag11 = 0;\n  flag12 = 0;\n  flag13 = 0;\n  flag14 = 0;\n  iVar1 = updateFlagAndValue(&DAT_20000b1c,&flag8,0);\n  if (iVar1 != 0) {\n    waitForever(\"../src/main.c\",0x1ab);\n  }\n  iVar1 = updateFlagAndValue(&DAT_20000b1c,&flag8,0xc);\n  if (iVar1 != 0) {\n    waitForever(\"../src/main.c\",0x1b0);\n  }\n  flag1 = 0;\n  flag2 = 0;\n  flag3 = 0;\n  flag4 = 0;\n  flag5 = 0;\n  flag6 = 0x2000;\n  flag7 = 0;\n  iVar1 = setFlagBasedOnCondition(&DAT_20000b1c,&flag1);\n  if (iVar1 != 0) {\n    waitForever(\"../src/main.c\",0x1bc);\n  }\n  updateBitwiseOperationParameters(&DAT_20000b1c);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053b0": "initialize_data_080053b0",
                "local_58": "flag1",
                "local_54": "flag2",
                "local_50": "flag3",
                "local_4c": "flag4",
                "local_48": "flag5",
                "local_44": "flag6",
                "local_40": "flag7",
                "local_3c": "flag8",
                "local_38": "flag9",
                "local_34": "flag10",
                "local_30": "flag11",
                "local_2c": "flag12",
                "local_28": "flag13",
                "local_24": "flag14",
                "local_20": "result",
                "local_1c": "resultValidation",
                "local_18": "settings",
                "validate_and_update_data_080035a4": "validateAndUpdateData",
                "wait_forever_08005674": "waitForever",
                "update_settings_08003a94": "updateSettings",
                "process_data_08003640": "processData",
                "update_flags_and_return_result_080042de": "updateFlagsAndReturnResult",
                "update_flag_and_value_08003908": "updateFlagAndValue",
                "set_flag_based_on_condition_0800422e": "setFlagBasedOnCondition",
                "update_bitwise_operation_parameters_08005680": "updateBitwiseOperationParameters"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08003a94",
                "FUN_08003908",
                "FUN_0800422e",
                "FUN_08003640",
                "FUN_080035a4",
                "FUN_08005674",
                "FUN_08005680",
                "FUN_080042de"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005500": {
            "entrypoint": "0x08005500",
            "current_name": "initialize_data_08005500",
            "code": "\nvoid initializeData_08005500(void)\n\n{\n  int validationResult;\n  undefined4 memorySize;\n  undefined4 count;\n  undefined4 settingsArray [4];\n  \n  DAT_20000b60 = 0x40000000;\n  DAT_20000b64 = 36000;\n  DAT_20000b68 = 0;\n  DAT_20000b6c = 0x14;\n  DAT_20000b70 = 0;\n  DAT_20000b78 = 0;\n  validationResult = validateAndUpdateData(&DAT_20000b60);\n  if (validationResult != 0) {\n    waitForever(\"../src/main.c\",0x1d0);\n  }\n  settingsArray[0] = 0x1000;\n  validationResult = updateSettings(&DAT_20000b60,settingsArray);\n  if (validationResult != 0) {\n    waitForever(\"../src/main.c\",0x1d5);\n  }\n  memorySize = 0x20;\n  count = 0;\n  validationResult = updateFlagsAndReturnResult(&DAT_20000b60,&memorySize);\n  if (validationResult != 0) {\n    waitForever(\"../src/main.c\",0x1dc);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005500": "initialize_data_08005500",
                "local_20": "memorySize",
                "local_1c": "count",
                "local_18": "settingsArray",
                "iVar1": "validationResult",
                "validate_and_update_data_080035a4": "validateAndUpdateData",
                "wait_forever_08005674": "waitForever",
                "update_settings_08003a94": "updateSettings",
                "update_flags_and_return_result_080042de": "updateFlagsAndReturnResult"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08003a94",
                "FUN_080035a4",
                "FUN_08005674",
                "FUN_080042de"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005598": {
            "entrypoint": "0x08005598",
            "current_name": "initialize_memory_08005598",
            "code": "\nvoid initializeMemory_08005598(void)\n\n{\n  int result;\n  \n  DAT_20000adc = 0x40013800;\n  DAT_20000ae0 = 0x1c200;\n  DAT_20000ae4 = 0;\n  DAT_20000ae8 = 0;\n  DAT_20000aec = 0;\n  DAT_20000af0 = 0xc;\n  DAT_20000af4 = 0;\n  DAT_20000af8 = 0;\n  result = initializeMemory_08005598Function(&DAT_20000adc);\n  if (result != 0) {\n    waitForeverFunction(\"../src/main.c\",0x1ed);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005598": "initialize_memory_08005598",
                "iVar1": "result",
                "initialize_memory_0800438a": "initializeMemoryFunction",
                "wait_forever_08005674": "waitForeverFunction"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_0800438a",
                "FUN_08005674"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055f4": {
            "entrypoint": "0x080055f4",
            "current_name": "initialize_data_080055f4",
            "code": "\n\n\nvoid initializeData_080055f4(void)\n\n{\n  undefined4 dataSize;\n  undefined4 dataFlag;\n  undefined4 dataValue;\n  \n  _DAT_40021018 = _DAT_40021018 | 0x2c;\n  update_data_08001a80(0x40010800,0x1e,0,_DAT_40021018 & 8);\n  dataSize = 0x1e;\n  dataFlag = 1;\n  dataValue = 2;\n  update_bitwise_operations_080017c4(0x40010800,&dataSize);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055f4": "initialize_data_080055f4",
                "local_18": "dataSize",
                "local_14": "dataFlag",
                "local_c": "dataValue"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08001a80",
                "FUN_080017c4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005674": {
            "entrypoint": "0x08005674",
            "current_name": "wait_forever_08005674",
            "code": "\nvoid waitForever_08005674(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005674": "wait_forever_08005674"
            },
            "calling": [
                "FUN_080053b0",
                "FUN_08005500",
                "FUN_080052a0",
                "FUN_08005598",
                "FUN_08005348"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005680": {
            "entrypoint": "0x08005680",
            "current_name": "update_bitwise_operation_parameters_08005680",
            "code": "\nvoid updateBitwiseOperationParameters_08005680(int *parameter_array)\n\n{\n  undefined4 bitwise_operation_value;\n  undefined4 bitwise_operation_param1;\n  undefined4 bitwise_operation_param2;\n  \n  if (*parameter_array == 0x40012c00) {\n    bitwise_operation_value = 0x900;\n    bitwise_operation_param1 = 2;\n    bitwise_operation_param2 = 2;\n    update_bitwise_operations_080017c4(0x40010800,&bitwise_operation_value);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005680": "update_bitwise_operation_parameters_08005680",
                "param_1": "parameter_array",
                "local_18": "bitwise_operation_value",
                "local_14": "bitwise_operation_param1",
                "local_c": "bitwise_operation_param2"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [
                "FUN_080017c4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005704": {
            "entrypoint": "0x08005704",
            "current_name": "update_global_data_and_calculate_pitch_08005704",
            "code": "\nvoid update_global_data_and_calculate_pitch_08005704(void)\n\n{\n  addDataToGlobalVariable();\n  calculatePitchAndUpdateData();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005704": "update_global_data_and_calculate_pitch_08005704",
                "add_data_to_global_variable_0800157c": "addDataToGlobalVariable",
                "calculate_pitch_and_update_data_080017b4": "calculatePitchAndUpdateData"
            },
            "calling": [],
            "called": [
                "FUN_080017b4",
                "FUN_0800157c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "initialize_flags_08005714",
            "code": "\nvoid initialize_flags_08005714(void)\n\n{\n  process_flags_080036f8(&DAT_20000b60);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005714": "initialize_flags_08005714"
            },
            "calling": [],
            "called": [
                "FUN_080036f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005728": {
            "entrypoint": "0x08005728",
            "current_name": "update_data_based_on_condition_08005728",
            "code": "\nundefined * updateDataBasedOnCondition_08005728(int inputSize)\n\n{\n  undefined4 *dataPointer;\n  undefined *returnValue;\n  undefined stackArray [4];\n  int tempSize;\n  undefined *originalDataPointer;\n  \n  if (DAT_20000a10 == (undefined *)0x0) {\n    DAT_20000a10 = &DAT_20000c18;\n  }\n  originalDataPointer = DAT_20000a10;\n  if (stackArray < DAT_20000a10 + inputSize) {\n    tempSize = inputSize;\n    dataPointer = (undefined4 *)getDataValue();\n    *dataPointer = 0xc;\n    returnValue = (undefined *)0xffffffff;\n  }\n  else {\n    returnValue = DAT_20000a10;\n    DAT_20000a10 = DAT_20000a10 + inputSize;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08005728": "update_data_based_on_condition_08005728",
                "param_1": "inputSize",
                "puVar1": "dataPointer",
                "puVar2": "returnValue",
                "auStack_18": "stackArray",
                "local_14": "tempSize",
                "local_c": "originalDataPointer",
                "get_data_value_08005d14": "getDataValue"
            },
            "calling": [
                "FUN_08009744"
            ],
            "called": [
                "FUN_08005d14"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005780": {
            "entrypoint": "0x08005780",
            "current_name": "initialize_registers_08005780",
            "code": "\n\n\nvoid initializeRegisters_08005780(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005780": "initialize_registers_08005780"
            },
            "calling": [
                "entry"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "entry": {
            "entrypoint": "0x080057e8",
            "current_name": "entry",
            "code": "\nvoid entry(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  code *UNRECOVERED_JUMPTABLE;\n  \n  for (iVar1 = 0; (undefined4 *)(iVar1 + 0x20000000) < &DAT_200009c8; iVar1 = iVar1 + 4) {\n    *(undefined4 *)(iVar1 + 0x20000000) = *(undefined4 *)(iVar1 + 0x800a1a4);\n  }\n  for (puVar2 = &DAT_200009c8; puVar2 < &DAT_20000c14; puVar2 = puVar2 + 1) {\n    *puVar2 = 0;\n  }\n  initialize_registers_08005780();\n  execute_multiple_functions_08005d20();\n  UNRECOVERED_JUMPTABLE = (code *)0x800581a;\n  initialize_systems_08005224();\n                    /* WARNING: Could not recover jumptable at 0x0800581a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "FUN_08005d20",
                "FUN_08005780",
                "FUN_08005224"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_08005838": {
            "entrypoint": "0x08005834",
            "current_name": "calculate_float_value_thunk_08005838",
            "code": "\nuint calculate_float_value_thunk_08005838(uint input_value1,uint input_value2,uint input_value3,uint input_value4)\n\n{\n  int difference;\n  undefined4 result_upper;\n  uint flag;\n  uint normalized_param_4;\n  uint normalized_param_2;\n  undefined8 result;\n  \n  normalized_param_4 = input_value4 & 0x7fffffff;\n  if ((0x7ff00000 < (normalized_param_4 | (-input_value3 | input_value3) >> 0x1f)) ||\n     (normalized_param_2 = input_value2 & 0x7fffffff, 0x7ff00000 < (normalized_param_2 | (-input_value1 | input_value1) >> 0x1f))) {\n    normalized_param_4 = calculate_result(input_value3,input_value4,input_value1,input_value2);\n    return normalized_param_4;\n  }\n  if ((input_value4 + 0xc0100000 | input_value3) == 0) {\n    normalized_param_4 = calculate_special_result();\n    return normalized_param_4;\n  }\n  flag = (int)input_value4 >> 0x1e & 2U | input_value2 >> 0x1f;\n  if ((normalized_param_2 | input_value1) == 0) {\n    if (flag == 2) {\n      return 0x54442d18;\n    }\n    if (flag != 3) {\n      return input_value1;\n    }\n  }\n  else if ((normalized_param_4 | input_value3) != 0) {\n    if (normalized_param_4 == 0x7ff00000) {\n      if (normalized_param_2 == 0x7ff00000) {\n        if (flag == 2) {\n          return 0x7f3321d2;\n        }\n        if (flag == 3) {\n          return 0x7f3321d2;\n        }\n        if (flag == 1) {\n          return 0x54442d18;\n        }\n        return 0x54442d18;\n      }\n      if (flag == 2) {\n        return 0x54442d18;\n      }\n      if (flag != 3) {\n        if (flag != 1) {\n          return 0;\n        }\n        return 0;\n      }\n    }\n    else if (normalized_param_2 != 0x7ff00000) {\n      difference = (int)(normalized_param_2 - normalized_param_4) >> 0x14;\n      if (difference < 0x3d) {\n        if (((int)input_value4 < 0) && (difference + 0x3c < 0 != SCARRY4(difference,0x3c))) {\n          result = 0;\n        }\n        else {\n          calculate_float_value_thunk_08005838_with_param(input_value1,input_value2,input_value3,input_value4,input_value4);\n          FUNC_08005d0c();\n          result = calculate_special_result();\n        }\n      }\n      else {\n        result = 0x3ff921fb54442d18;\n      }\n      result_upper = (undefined4)((ulonglong)result >> 0x20);\n      normalized_param_4 = (uint)result;\n      if (flag == 1) {\n        return normalized_param_4;\n      }\n      if (flag == 2) {\n        result = perform_arithmetic_operations(normalized_param_4,result_upper,0x33145c07,0x3ca1a626);\n        normalized_param_4 = perform_arithmetic_operations(0x54442d18,0x400921fb,(int)result,(int)((ulonglong)result >> 0x20));\n        return normalized_param_4;\n      }\n      if (flag != 0) {\n        result = perform_arithmetic_operations(normalized_param_4,result_upper,0x33145c07,0x3ca1a626);\n        normalized_param_4 = perform_arithmetic_operations((int)result,(int)((ulonglong)result >> 0x20),0x54442d18,0x400921fb);\n        return normalized_param_4;\n      }\n      return normalized_param_4;\n    }\n  }\n  return 0x54442d18;\n}\n\n",
            "renaming": {
                "thunk_FUN_08005838": "calculate_float_value_thunk_08005838",
                "param_1": "input_value1",
                "param_2": "input_value2",
                "param_3": "input_value3",
                "param_4": "input_value4",
                "iVar1": "difference",
                "uVar2": "result_upper",
                "uVar3": "flag",
                "uVar4": "normalized_param_4",
                "uVar5": "normalized_param_2",
                "uVar6": "result",
                "calculate_result_0800015c": "calculate_result",
                "calculate_result_080059f0": "calculate_special_result",
                "calculate_float_value_0800071c": "calculate_float_value_with_param",
                "perform_arithmetic_operations_08000158": "perform_arithmetic_operations"
            },
            "calling": [
                "FUN_08004bd8",
                "FUN_08004d78"
            ],
            "called": [
                "FUN_08005838"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005838": {
            "entrypoint": "0x08005838",
            "current_name": "calculate_float_value_08005838",
            "code": "\nuint calculateFloatValue_08005838(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int temp1;\n  undefined4 temp2;\n  uint flag;\n  uint modifiedInput4;\n  uint modifiedInput2;\n  undefined8 result;\n  \n  modifiedInput4 = input4 & 0x7fffffff;\n  if ((0x7ff00000 < (modifiedInput4 | (-input3 | input3) >> 0x1f)) ||\n     (modifiedInput2 = input2 & 0x7fffffff, 0x7ff00000 < (modifiedInput2 | (-input1 | input1) >> 0x1f))) {\n    modifiedInput4 = calculate_result_0800015c(input3,input4,input1,input2);\n    return modifiedInput4;\n  }\n  if ((input4 + 0xc0100000 | input3) == 0) {\n    modifiedInput4 = calculate_result_080059f0();\n    return modifiedInput4;\n  }\n  flag = (int)input4 >> 0x1e & 2U | input2 >> 0x1f;\n  if ((modifiedInput2 | input1) == 0) {\n    if (flag == 2) {\n      return 0x54442d18;\n    }\n    if (flag != 3) {\n      return input1;\n    }\n  }\n  else if ((modifiedInput4 | input3) != 0) {\n    if (modifiedInput4 == 0x7ff00000) {\n      if (modifiedInput2 == 0x7ff00000) {\n        if (flag == 2) {\n          return 0x7f3321d2;\n        }\n        if (flag == 3) {\n          return 0x7f3321d2;\n        }\n        if (flag == 1) {\n          return 0x54442d18;\n        }\n        return 0x54442d18;\n      }\n      if (flag == 2) {\n        return 0x54442d18;\n      }\n      if (flag != 3) {\n        if (flag != 1) {\n          return 0;\n        }\n        return 0;\n      }\n    }\n    else if (modifiedInput2 != 0x7ff00000) {\n      temp1 = (int)(modifiedInput2 - modifiedInput4) >> 0x14;\n      if (temp1 < 0x3d) {\n        if (((int)input4 < 0) && (temp1 + 0x3c < 0 != SCARRY4(temp1,0x3c))) {\n          result = 0;\n        }\n        else {\n          calculate_float_value_0800071c(input1,input2,input3,input4,input4);\n          FUNC_08005d0c();\n          result = calculate_result_080059f0();\n        }\n      }\n      else {\n        result = 0x3ff921fb54442d18;\n      }\n      temp2 = (undefined4)((ulonglong)result >> 0x20);\n      modifiedInput4 = (uint)result;\n      if (flag == 1) {\n        return modifiedInput4;\n      }\n      if (flag == 2) {\n        result = perform_arithmetic_operations_08000158(modifiedInput4,temp2,0x33145c07,0x3ca1a626);\n        modifiedInput4 = perform_arithmetic_operations_08000158(0x54442d18,0x400921fb,(int)result,(int)((ulonglong)result >> 0x20));\n        return modifiedInput4;\n      }\n      if (flag != 0) {\n        result = perform_arithmetic_operations_08000158(modifiedInput4,temp2,0x33145c07,0x3ca1a626);\n        modifiedInput4 = perform_arithmetic_operations_08000158((int)result,(int)((ulonglong)result >> 0x20),0x54442d18,0x400921fb);\n        return modifiedInput4;\n      }\n      return modifiedInput4;\n    }\n  }\n  return 0x54442d18;\n}\n\n",
            "renaming": {
                "FUN_08005838": "calculate_float_value_08005838",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "flag",
                "uVar4": "modifiedInput4",
                "uVar5": "modifiedInput2",
                "uVar6": "result"
            },
            "calling": [
                "thunk_FUN_08005838"
            ],
            "called": [
                "FUN_08000158",
                "FUN_080059f0",
                "FUN_08005d0c",
                "FUN_0800015c",
                "FUN_0800071c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f0": {
            "entrypoint": "0x080059f0",
            "current_name": "calculate_result_080059f0",
            "code": "\nundefined8 calculate_result_080059f0(int input_1,uint input_2,undefined4 input_3,undefined4 input_4)\n\n{\n  undefined4 result_1;\n  undefined4 result_2;\n  undefined4 result_3;\n  undefined4 result_4;\n  undefined4 result_5;\n  undefined4 result_6;\n  uint positive_input_2;\n  int case_value;\n  undefined8 temp_result;\n  undefined8 final_result;\n  \n  final_result = CONCAT44(input_2,input_1);\n  positive_input_2 = input_2 & 0x7fffffff;\n  if (positive_input_2 < 0x44100000) {\n    if (positive_input_2 < 0x3fdc0000) {\n      if (positive_input_2 < 0x3e200000) {\n        temp_result = calculate_result_080059f0_0800015c(input_1,input_2,0x8800759c,0x7e37e43c,input_4);\n        case_value = check_input_is_empty_080009e8((int)temp_result,(int)((ulonglong)temp_result >> 0x20),0,0x3ff00000);\n        if (case_value != 0) {\n          return CONCAT44(input_2,input_1);\n        }\n      }\n      case_value = -1;\n    }\n    else {\n      final_result = FUNC_08005d0c();\n      result_4 = (undefined4)((ulonglong)final_result >> 0x20);\n      result_1 = (undefined4)final_result;\n      if (positive_input_2 < 0x3ff30000) {\n        if (positive_input_2 < 0x3fe60000) {\n          final_result = calculate_result_080059f0_0800015c(result_1,result_4,result_1,result_4);\n          final_result = perform_arithmetic_operations_08000158((int)final_result,(int)((ulonglong)final_result >> 0x20),0,0x3ff00000);\n          temp_result = calculate_result_080059f0_0800015c(result_1,result_4,0,0x40000000);\n          final_result = calculate_float_value_0800071c((int)final_result,(int)((ulonglong)final_result >> 0x20),(int)temp_result,\n                                (int)((ulonglong)temp_result >> 0x20));\n          case_value = 0;\n        }\n        else {\n          final_result = perform_arithmetic_operations_08000158(result_1,result_4,0,0x3ff00000);\n          temp_result = calculate_result_080059f0_0800015c(result_1,result_4,0,0x3ff00000);\n          final_result = calculate_float_value_0800071c((int)final_result,(int)((ulonglong)final_result >> 0x20),(int)temp_result,\n                                (int)((ulonglong)temp_result >> 0x20));\n          case_value = 1;\n        }\n      }\n      else if (positive_input_2 < 0x40038000) {\n        final_result = perform_arithmetic_operations_08000158(result_1,result_4,0,0x3ff80000);\n        temp_result = calculate_result_080059f0_080004c8(result_1,result_4,0,0x3ff80000);\n        temp_result = calculate_result_080059f0_0800015c((int)temp_result,(int)((ulonglong)temp_result >> 0x20),0,0x3ff00000);\n        final_result = calculate_float_value_0800071c((int)final_result,(int)((ulonglong)final_result >> 0x20),(int)temp_result,\n                              (int)((ulonglong)temp_result >> 0x20));\n        case_value = 2;\n      }\n      else {\n        final_result = calculate_float_value_0800071c(0,0xbff00000,result_1,result_4);\n        case_value = 3;\n      }\n    }\n    result_6 = (undefined4)((ulonglong)final_result >> 0x20);\n    result_5 = (undefined4)final_result;\n    final_result = calculate_result_080059f0_080004c8(result_5,result_6,result_5,result_6);\n    result_2 = (undefined4)((ulonglong)final_result >> 0x20);\n    result_1 = (undefined4)final_result;\n    final_result = calculate_result_080059f0_080004c8(result_1,result_2,result_1,result_2);\n    result_3 = (undefined4)((ulonglong)final_result >> 0x20);\n    result_4 = (undefined4)final_result;\n    final_result = calculate_result_080059f0_080004c8(result_4,result_3,0xe322da11,0x3f90ad3a);\n    final_result = calculate_result_080059f0_0800015c((int)final_result,(int)((ulonglong)final_result >> 0x20),0x24760deb,0x3fa97b4b);\n    final_result = calculate_result_080059f0_080004c8((int)final_result,(int)((ulonglong)final_result >> 0x20),result_4,result_3);\n    final_result = calculate_result_080059f0_0800015c((int)final_result,(int)((ulonglong)final_result >> 0x20),0xa0d03d51,0x3fb10d66);\n    final_result = calculate_result_080059f0_080004c8((int)final_result,(int)((ulonglong)final_result >> 0x20),result_4,result_3);\n    final_result = calculate_result_080059f0_0800015c((int)final_result,(int)((ulonglong)final_result >> 0x20),0xc54c206e,0x3fb745cd);\n    final_result = calculate_result_080059f0_080004c8((int)final_result,(int)((ulonglong)final_result >> 0x20),result_4,result_3);\n    final_result = calculate_result_080059f0_0800015c((int)final_result,(int)((ulonglong)final_result >> 0x20),0x920083ff,0x3fc24924);\n    final_result = calculate_result_080059f0_080004c8((int)final_result,(int)((ulonglong)final_result >> 0x20),result_4,result_3);\n    final_result = calculate_result_080059f0_0800015c((int)final_result,(int)((ulonglong)final_result >> 0x20),0x5555550d,0x3fd55555);\n    final_result = calculate_result_080059f0_080004c8((int)final_result,(int)((ulonglong)final_result >> 0x20),result_1,result_2);\n    temp_result = calculate_result_080059f0_080004c8(result_4,result_3,0x2c6a6c2f,0xbfa2b444);\n    temp_result = perform_arithmetic_operations_08000158((int)temp_result,(int)((ulonglong)temp_result >> 0x20),0x52defd9a,0x3fadde2d);\n    temp_result = calculate_result_080059f0_080004c8((int)temp_result,(int)((ulonglong)temp_result >> 0x20),result_4,result_3);\n    temp_result = perform_arithmetic_operations_08000158((int)temp_result,(int)((ulonglong)temp_result >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    temp_result = calculate_result_080059f0_080004c8((int)temp_result,(int)((ulonglong)temp_result >> 0x20),result_4,result_3);\n    temp_result = perform_arithmetic_operations_08000158((int)temp_result,(int)((ulonglong)temp_result >> 0x20),0xfe231671,0x3fbc71c6);\n    temp_result = calculate_result_080059f0_080004c8((int)temp_result,(int)((ulonglong)temp_result >> 0x20),result_4,result_3);\n    temp_result = perform_arithmetic_operations_08000158((int)temp_result,(int)((ulonglong)temp_result >> 0x20),0x9998ebc4,0x3fc99999);\n    temp_result = calculate_result_080059f0_080004c8((int)temp_result,(int)((ulonglong)temp_result >> 0x20),result_4,result_3);\n    final_result = calculate_result_080059f0_0800015c((int)final_result,(int)((ulonglong)final_result >> 0x20),(int)temp_result,\n                          (int)((ulonglong)temp_result >> 0x20));\n    final_result = calculate_result_080059f0_080004c8((int)final_result,(int)((ulonglong)final_result >> 0x20),result_5,result_6);\n    result_1 = (undefined4)((ulonglong)final_result >> 0x20);\n    if (case_value == -1) {\n      final_result = perform_arithmetic_operations_08000158(result_5,result_6,(int)final_result,result_1);\n      return final_result;\n    }\n    case_value = case_value * 8;\n    final_result = perform_arithmetic_operations_08000158((int)final_result,result_1,*(undefined4 *)(&UNK_08009ee8 + case_value),\n                          *(undefined4 *)(&UNK_08009eec + case_value));\n    final_result = perform_arithmetic_operations_08000158((int)final_result,(int)((ulonglong)final_result >> 0x20),result_5,result_6);\n    final_result = perform_arithmetic_operations_08000158(*(undefined4 *)(&UNK_08009ec8 + case_value),\n                          *(undefined4 *)(&UNK_08009ecc + case_value),(int)final_result,\n                          (int)((ulonglong)final_result >> 0x20));\n    if ((int)input_2 < 0) {\n      return CONCAT44((int)((ulonglong)final_result >> 0x20) + -0x80000000,(int)final_result);\n    }\n  }\n  else {\n    if ((positive_input_2 < 0x7ff00001) && ((positive_input_2 != 0x7ff00000 || (input_1 == 0)))) {\n      result_1 = 0xbff921fb;\n      if (0 < (int)input_2) {\n        result_1 = 0x3ff921fb;\n      }\n      return CONCAT44(result_1,0x54442d18);\n    }\n    final_result = calculate_result_080059f0_0800015c(input_1,input_2,input_1,input_2,input_4);\n  }\n  return final_result;\n}\n\n",
            "renaming": {
                "FUN_080059f0": "calculate_result_080059f0",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "result_1",
                "uVar2": "result_2",
                "uVar3": "result_3",
                "uVar4": "result_4",
                "uVar5": "result_5",
                "uVar6": "result_6",
                "uVar7": "positive_input_2",
                "iVar8": "case_value",
                "uVar9": "temp_result",
                "uVar10": "final_result"
            },
            "calling": [
                "FUN_08005838"
            ],
            "called": [
                "FUN_080004c8",
                "FUN_08000158",
                "FUN_080009e8",
                "FUN_08005d0c",
                "FUN_0800015c",
                "FUN_0800071c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d0c": {
            "entrypoint": "0x08005d0c",
            "current_name": "FUNC_08005d0c",
            "code": "\nvoid FUNC_08005d0c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d0c": "FUNC_08005d0c"
            },
            "calling": [
                "FUN_080059f0",
                "FUN_08005838"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005d14": {
            "entrypoint": "0x08005d14",
            "current_name": "get_data_value_08005d14",
            "code": "\nundefined4 get_data_value_08005d14(void)\n\n{\n  return DAT_2000001c;\n}\n\n",
            "renaming": {
                "FUN_08005d14": "get_data_value_08005d14"
            },
            "calling": [
                "FUN_08005728"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d20": {
            "entrypoint": "0x08005d20",
            "current_name": "execute_multiple_functions_08005d20",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005d2c) */\n/* WARNING: Removing unreachable block (ram,0x08005d2e) */\n\nvoid executeMultipleFunctions_08005d20(void)\n\n{\n  int iterationCounter;\n  code **functionPointerArray;\n  \n  FUNC_08009e68();\n  iterationCounter = 0;\n  functionPointerArray = (code **)&DAT_0800a198;\n  do {\n    iterationCounter = iterationCounter + 1;\n    (**functionPointerArray)();\n    functionPointerArray = functionPointerArray + 1;\n  } while (iterationCounter != 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d20": "execute_multiple_functions_08005d20",
                "iVar1": "iterationCounter",
                "ppcVar2": "functionPointerArray"
            },
            "calling": [
                "entry"
            ],
            "called": [
                "FUN_08000134",
                "FUN_08009e68",
                "FUN_080078a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d68": {
            "entrypoint": "0x08005d68",
            "current_name": "memset_aligned_08005d68",
            "code": "\nvoid memset_aligned_08005d68(undefined4 *ptr,undefined value,uint size)\n\n{\n  undefined4 *temp_ptr1;\n  undefined4 *temp_ptr2;\n  uint temp_size;\n  undefined4 fill_value;\n  bool is_zero_size;\n  \n  if (((uint)ptr & 3) != 0) {\n    temp_size = size - 1;\n    temp_ptr1 = ptr;\n    if (size == 0) {\n      return;\n    }\n    while( true ) {\n      ptr = (undefined4 *)((int)temp_ptr1 + 1);\n      *(undefined *)temp_ptr1 = value;\n      size = temp_size;\n      if (((uint)ptr & 3) == 0) break;\n      is_zero_size = temp_size == 0;\n      temp_size = temp_size - 1;\n      temp_ptr1 = ptr;\n      if (is_zero_size) {\n        return;\n      }\n    }\n  }\n  if (3 < size) {\n    fill_value = CONCAT22(CONCAT11(value,value),CONCAT11(value,value));\n    temp_size = size;\n    temp_ptr1 = ptr;\n    if (0xf < size) {\n      temp_size = size - 0x10;\n      temp_ptr1 = ptr + 4;\n      do {\n        temp_ptr1[-4] = fill_value;\n        temp_ptr1[-3] = fill_value;\n        temp_ptr1[-2] = fill_value;\n        temp_ptr1[-1] = fill_value;\n        temp_ptr1 = temp_ptr1 + 4;\n      } while (temp_ptr1 != (undefined4 *)((int)ptr + (temp_size & 0xfffffff0) + 0x20));\n      size = size & 0xf;\n      ptr = ptr + ((temp_size >> 4) + 1) * 4;\n      temp_size = size;\n      temp_ptr1 = ptr;\n      if (size < 4) goto LAB_08005de4;\n    }\n    do {\n      size = size - 4;\n      *ptr = fill_value;\n      ptr = ptr + 1;\n    } while (3 < size);\n    ptr = (undefined4 *)((int)temp_ptr1 + (temp_size - 4 & 0xfffffffc) + 4);\n    size = temp_size & 3;\n  }\nLAB_08005de4:\n  if (size != 0) {\n    temp_ptr1 = ptr;\n    do {\n      temp_ptr2 = (undefined4 *)((int)temp_ptr1 + 1);\n      *(undefined *)temp_ptr1 = value;\n      temp_ptr1 = temp_ptr2;\n    } while ((undefined4 *)(size + (int)ptr) != temp_ptr2);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d68": "memset_aligned_08005d68",
                "param_1": "ptr",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "temp_ptr1",
                "puVar2": "temp_ptr2",
                "uVar3": "temp_size",
                "uVar4": "fill_value",
                "bVar5": "is_zero_size"
            },
            "calling": [
                "FUN_08004f60",
                "FUN_08009980"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005dfc": {
            "entrypoint": "0x08005dfc",
            "current_name": "initialize_memory_08005dfc",
            "code": "\nvoid initializeMemory_08005dfc(undefined *inputPointer,undefined4 size,undefined4 resultPtr,undefined4 extraData)\n\n{\n  undefined *localPointers [2];\n  undefined4 pointerMaxValue1;\n  undefined4 constantValue;\n  undefined *currentPointer;\n  undefined4 pointerMaxValue2;\n  undefined4 resultValue;\n  undefined4 extraDataValue;\n  \n  pointerMaxValue2 = 0x7fffffff;\n  pointerMaxValue1 = 0x7fffffff;\n  constantValue = 0xffff0208;\n  localPointers[0] = inputPointer;\n  currentPointer = inputPointer;\n  resultValue = resultPtr;\n  extraDataValue = extraData;\n  FUNC_08005e9c(DAT_2000001c,localPointers,size,&resultValue);\n  *localPointers[0] = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005dfc": "initialize_memory_08005dfc",
                "param_1": "inputPointer",
                "param_2": "size",
                "param_3": "resultPtr",
                "param_4": "extraData",
                "local_80": "localPointers",
                "local_78": "pointerMaxValue1",
                "uStack_74": "constantValue",
                "local_70": "currentPointer",
                "local_6c": "pointerMaxValue2",
                "uStack_8": "resultValue",
                "uStack_4": "extraDataValue"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08005e9c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e40": {
            "entrypoint": "0x08005e40",
            "current_name": "get_byte_alignment_08005e40",
            "code": "\nint getByteAlignment_08005e40(uint inputValue)\n\n{\n  int alignmentOffset;\n  uint *pointer;\n  uint value;\n  \n  pointer = (uint *)(inputValue & 0xfffffffc);\n  alignmentOffset = -(inputValue & 3);\n  value = *pointer;\n  if ((inputValue & 3) != 0) {\n    value = value | 0xffffffffU >> ((alignmentOffset + 4U & 0x1f) << 3);\n  }\n  while( true ) {\n    pointer = pointer + 1;\n    value = value + 0xfefefeff & ~value & 0x80808080;\n    if (value != 0) break;\n    value = *pointer;\n    alignmentOffset = alignmentOffset + 4;\n  }\n  return alignmentOffset + (0x1fU - leadingZeroBitsCount(value & -value) >> 3);\n}\n\n",
            "renaming": {
                "FUN_08005e40": "get_byte_alignment_08005e40",
                "param_1": "inputValue",
                "iVar1": "alignmentOffset",
                "puVar2": "pointer",
                "uVar3": "value",
                "LZCOUNT": "leadingZeroBitsCount"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e9c": {
            "entrypoint": "0x08005e9c",
            "current_name": "FUNC_08005e9c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nbyte * FUNC_08005e9c(undefined4 *param_1,int *param_2,int *param_3,int **param_4)\n\n{\n  byte bVar1;\n  int **ppiVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char cVar6;\n  byte bVar7;\n  int iVar8;\n  int *piVar9;\n  undefined4 uVar10;\n  int **ppiVar11;\n  undefined uVar12;\n  ushort uVar13;\n  int **ppiVar14;\n  byte **ppbVar15;\n  int *piVar16;\n  int **ppiVar17;\n  char *pcVar18;\n  uint uVar19;\n  undefined *puVar20;\n  int *piVar21;\n  int *piVar22;\n  int *piVar23;\n  int *piVar24;\n  int *piVar25;\n  byte *pbVar26;\n  int *piVar27;\n  int *piVar28;\n  undefined4 *puVar29;\n  byte *pbVar30;\n  bool bVar31;\n  longlong lVar32;\n  undefined8 uVar33;\n  undefined8 uVar34;\n  undefined4 local_188;\n  int *piStack_184;\n  int **local_180;\n  undefined *puStack_17c;\n  int **local_178;\n  undefined4 *local_16c;\n  int *local_168;\n  byte *local_164;\n  int *local_160;\n  int *local_15c;\n  char *local_158;\n  int **local_154;\n  undefined8 local_150;\n  int *local_148;\n  int *local_144;\n  int *local_140;\n  int **local_13c;\n  int *local_138;\n  int *local_134;\n  int *local_130;\n  uint local_12c;\n  undefined4 local_128;\n  undefined4 local_124;\n  undefined4 local_120;\n  char *local_11c;\n  int *local_118;\n  int *local_114;\n  int *local_110;\n  int *local_10c;\n  byte *local_108;\n  int *local_104;\n  int *local_100;\n  int *local_fc;\n  byte local_f5;\n  undefined2 local_f4;\n  int *local_f0;\n  undefined auStack_ec [4];\n  char local_e8;\n  undefined local_e7;\n  char local_e6 [6];\n  int *local_e0;\n  byte abStack_dc [4];\n  int **local_d8;\n  int *local_d4;\n  int *local_d0;\n  int *local_cc [16];\n  undefined local_8c;\n  byte bStack_2a;\n  undefined local_29;\n  int iStack_28;\n  \n  local_16c = param_1;\n  local_160 = param_2;\n  local_154 = param_4;\n  ppiVar2 = (int **)get_adjusted_value_08008ad4();\n  local_114 = *ppiVar2;\n  local_118 = (int *)get_byte_alignment_08005e40(local_114);\n  if (((int)((uint)*(ushort *)(param_2 + 3) << 0x18) < 0) && (param_2[4] == 0)) {\n    iVar3 = allocate_memory_08008af8(local_16c,0x40);\n    *local_160 = iVar3;\n    local_160[4] = iVar3;\n    if (iVar3 == 0) {\n      *local_16c = 0xc;\n      return (byte *)0xffffffff;\n    }\n    local_160[5] = 0x40;\n  }\n  local_128 = 0;\n  local_138 = (int *)0x0;\n  local_12c = 0;\n  local_d4 = (int *)0x0;\n  local_d0 = (int *)0x0;\n  local_11c = (char *)0x0;\n  local_10c = (int *)0x0;\n  local_108 = (byte *)0x0;\n  local_104 = (int *)0x0;\n  local_110 = (int *)0x0;\n  local_164 = (byte *)0x0;\n  local_124 = 0;\n  local_120 = 0;\n  ppiVar2 = local_cc;\n  bVar1 = *(byte *)param_3;\n  local_d8 = ppiVar2;\njoined_r0x08005ef2:\n  if (bVar1 != 0) {\n    piVar28 = param_3;\n    if (bVar1 != 0x25) {\n      do {\n        piVar28 = (int *)((int)piVar28 + 1);\n        if (*(byte *)piVar28 == 0) break;\n      } while (*(byte *)piVar28 != 0x25);\n      piVar27 = (int *)((int)piVar28 - (int)param_3);\n      if (piVar27 != (int *)0x0) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)piVar27);\n        *ppiVar2 = param_3;\n        *(int **)((int)ppiVar2 + 4) = piVar27;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = (int **)((int)ppiVar2 + 8);\n        }\n        else {\n          iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800604a;\n          ppiVar2 = local_cc;\n        }\n        local_164 = local_164 + (int)piVar27;\n      }\n      if (*(byte *)piVar28 == 0) goto LAB_08006216;\n    }\n    piVar27 = (int *)0xffffffff;\n    piVar25 = (int *)0x0;\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    local_15c = (int *)0x0;\n    local_f5 = 0;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4a:\n    puVar29 = local_16c;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4e:\n    switch(piVar24) {\n    case (int *)0x20:\n      goto switchD_08005f58_caseD_20;\n    default:\n      if (piVar24 == (int *)0x0) goto LAB_08006216;\n      piVar16 = (int *)0x0;\n      local_168 = (int *)0x1;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_158 = (char *)0x1;\n      piVar23 = (int *)&local_8c;\n      piVar22 = piVar16;\n      local_8c = (char)piVar24;\n      goto LAB_08006298;\n    case (int *)0x23:\n      piVar25 = (int *)((uint)piVar25 | 1);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x27:\n      iVar3 = get_adjusted_value_08008ad4(local_16c);\n      local_110 = *(int **)(iVar3 + 4);\n      piVar24 = (int *)get_byte_alignment_08005e40(local_110);\n      local_104 = piVar24;\n      iVar3 = get_adjusted_value_08008ad4(puVar29);\n      local_108 = *(byte **)(iVar3 + 8);\n      if (piVar24 == (int *)0x0) goto switchD_08005f58_caseD_74;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if ((local_108 != (byte *)0x0) && (*local_108 != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 0x400);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2a:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      local_15c = *local_154;\n      local_154 = local_154 + 1;\n      if ((int)local_15c < 0) {\n        local_15c = (int *)-(int)local_15c;\n        goto LAB_08006602;\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2b:\n      local_f5 = 0x2b;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x2d:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\nLAB_08006602:\n      piVar25 = (int *)((uint)piVar25 | 4);\n      goto LAB_08005f4a;\n    case (int *)0x2e:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x2a) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar27 = (int *)((uint)*local_154 | (int)*local_154 >> 0x1f);\n        local_154 = local_154 + 1;\n        piVar28 = (int *)((int)piVar28 + 1);\n        goto LAB_08005f4a;\n      }\n      piVar27 = (int *)0x0;\n      piVar28 = (int *)((int)piVar28 + 1);\n      while (piVar24 + -0xc < (int *)0xa) {\n        piVar27 = (int *)((int)(piVar24 + -0xc) + (int)piVar27 * 10);\n        piVar24 = (int *)(uint)*(byte *)piVar28;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      goto LAB_08005f4e;\n    case (int *)0x30:\n      piVar25 = (int *)((uint)piVar25 | 0x80);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x31:\n    case (int *)0x32:\n    case (int *)0x33:\n    case (int *)0x34:\n    case (int *)0x35:\n    case (int *)0x36:\n    case (int *)0x37:\n    case (int *)0x38:\n    case (int *)0x39:\n      goto switchD_08005f58_caseD_31;\n    case (int *)0x41:\n    case (int *)0x45:\n    case (int *)0x46:\n    case (int *)0x47:\n    case (int *)0x61:\n    case (int *)0x65:\n    case (int *)0x66:\n    case (int *)0x67:\n      puVar29 = (undefined4 *)((int)local_154 + 7U & 0xfffffff8);\n      uVar10 = *puVar29;\n      local_12c = puVar29[1];\n      local_168 = (int *)(local_12c & 0x7fffffff);\n      local_154 = (int **)(puVar29 + 2);\n      local_128 = uVar10;\n      iVar3 = is_valid_input_08001170(uVar10,local_168,0xffffffff,0x7fefffff);\n      if ((iVar3 == 0) && (iVar3 = check_input_conditions_080009c0(uVar10,local_168,0xffffffff,0x7fefffff), iVar3 == 0)\n         ) {\n        iVar3 = is_input_processed_080009ac(local_128,local_12c,local_124,local_120);\n        if (iVar3 == 0) {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        else {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        piVar23 = (int *)&UNK_08009f10;\n        piVar27 = (int *)&UNK_08009f0c;\nLAB_08006524:\n        local_148 = (int *)0x0;\n        local_168 = (int *)0x3;\n        if (piVar24 < (int *)0x48) {\n          piVar23 = piVar27;\n        }\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar25 = (int *)((uint)piVar25 & 0xffffff7f);\n        local_158 = (char *)0x3;\n        local_13c = (int **)0x0;\n        piVar22 = (int *)0x0;\n        goto LAB_08006538;\n      }\n      iVar3 = is_valid_input_08001170(local_128,local_12c,local_128,local_12c);\n      if (iVar3 != 0) {\n        if ((int)local_12c < 0) {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        else {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        piVar23 = (int *)&UNK_08009f18;\n        piVar27 = (int *)&UNK_08009f14;\n        goto LAB_08006524;\n      }\n      if (piVar24 == (int *)0x61) {\n        uVar12 = 0x78;\nLAB_08007224:\n        local_f4 = CONCAT11(uVar12,0x30);\n        if ((int)piVar27 < 100) {\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          local_148 = (int *)0x0;\n          param_3 = (int *)&local_8c;\n          piVar25 = (int *)((uint)piVar25 | 2);\n        }\n        else {\n          param_3 = (int *)allocate_memory_08008af8(local_16c,(byte *)((int)piVar27 + 1));\n          if (param_3 == (int *)0x0) {\n            uVar13 = *(ushort *)(local_160 + 3) | 0x40;\n            *(ushort *)(local_160 + 3) = uVar13;\n            goto LAB_0800604e;\n          }\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          piVar25 = (int *)((uint)piVar25 | 2);\n          local_148 = param_3;\n        }\nLAB_0800724a:\n        if ((int)local_12c < 0) {\nLAB_08007414:\n          local_144 = (int *)0x2d;\n          uVar19 = local_12c + 0x80000000;\n        }\n        else {\n          local_144 = (int *)0x0;\n          uVar19 = local_12c;\n        }\n        local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n        piVar22 = piVar27;\n        local_158 = (char *)local_128;\n        if (piVar24 == (int *)0x61) {\n          uVar33 = calculate_float_080096e0(local_128,uVar19,&local_f0);\n          local_150 = calculate_result_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = process_input_and_check_flag_08000998((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                               local_120);\n          if (iVar3 != 0) {\n            local_f0 = (int *)0x1;\n          }\n          local_158 = \"0123456789abcdef\";\n          local_13c = ppiVar2;\n          local_138 = piVar28;\n          local_134 = piVar24;\n          local_130 = piVar27;\n          local_100 = piVar25;\n          local_fc = param_3;\n          pcVar18 = local_158;\n          uVar33 = local_150;\n          goto LAB_080072ba;\n        }\n        if (piVar24 == (int *)0x41) {\n          uVar33 = calculate_float_080096e0(local_128,uVar19,&local_f0);\n          local_150 = calculate_result_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = process_input_and_check_flag_08000998((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                               local_120);\n          if (iVar3 == 0) {\n            local_158 = \"0123456789ABCDEF\";\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar27;\n            local_100 = piVar25;\n            local_fc = param_3;\n            pcVar18 = local_158;\n            uVar33 = local_150;\n          }\n          else {\n            local_f0 = (int *)0x1;\n            local_158 = \"0123456789ABCDEF\";\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar27;\n            local_100 = piVar25;\n            local_fc = param_3;\n            pcVar18 = local_158;\n            uVar33 = local_150;\n          }\n          goto LAB_080072ba;\n        }\n      }\n      else {\n        if (piVar24 == (int *)0x41) {\n          uVar12 = 0x58;\n          goto LAB_08007224;\n        }\n        local_140 = (int *)((uint)piVar25 | 0x100);\n        local_148 = (int *)0x0;\n        if (piVar27 == (int *)0xffffffff) {\n          piVar27 = (int *)0x6;\n          goto LAB_0800724a;\n        }\n        if (((uint)piVar24 & 0xffffffdf) == 0x47) {\n          if (piVar27 == (int *)0x0) {\n            piVar27 = (int *)0x1;\n            local_148 = (int *)0x0;\n          }\n          goto LAB_0800724a;\n        }\n        if ((int)local_12c < 0) goto LAB_08007414;\n        local_144 = (int *)0x0;\n        uVar19 = local_12c;\n      }\n      local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n      piStack_184 = piVar27;\n      local_158 = (char *)local_128;\n      if (piVar24 == (int *)0x66) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)convert_floating_point_to_decimal_string_080079e8(local_16c,local_180,local_128,uVar19);\n        piVar22 = (int *)((int)piVar23 + (int)piVar27);\n        local_150._0_4_ = piVar27;\nLAB_0800764c:\n        if ((*(byte *)piVar23 == 0x30) &&\n           (iVar3 = process_input_and_check_flag_08000998(local_158,uVar19,local_124,local_120), iVar3 == 0)) {\n          local_f0 = (int *)(1 - (int)(int *)local_150);\n        }\n        piVar22 = (int *)((int)piVar22 + (int)local_f0);\n      }\n      else if (piVar24 == (int *)0x46) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)convert_floating_point_to_decimal_string_080079e8(local_16c,local_180,local_128,uVar19);\n        local_150._0_4_ = piVar27;\nLAB_08007760:\n        piVar22 = (int *)((int)piVar23 + (int)(int *)local_150);\n        if (piVar24 == (int *)0x46) goto LAB_0800764c;\n      }\n      else {\n        local_178 = &local_e0;\n        local_150._0_4_ = piVar27;\n        if (local_168 == (int *)0x45) {\n          local_150._0_4_ = (int *)((int)piVar27 + 1);\n        }\n        local_188 = 2;\n        piStack_184 = (int *)local_150;\n        local_180 = &local_f0;\n        puStack_17c = auStack_ec;\n        piVar23 = (int *)convert_floating_point_to_decimal_string_080079e8(local_16c,local_180,local_128,uVar19);\n        piVar16 = local_e0;\n        if (piVar24 == (int *)0x67) {\n          if (((uint)piVar25 & 1) == 0) goto LAB_08006ca6;\n        }\n        else if (piVar24 == (int *)0x47) {\n          if (((uint)piVar25 & 1) != 0) goto LAB_08007760;\n          goto LAB_08006ca6;\n        }\n        piVar22 = (int *)((int)(int *)local_150 + (int)piVar23);\n      }\n      iVar3 = process_input_and_check_flag_08000998(local_158,uVar19,local_124,local_120);\n      piVar16 = piVar22;\n      if (iVar3 == 0) {\n        for (; piVar16 = local_e0, local_e0 < piVar22; local_e0 = (int *)((int)local_e0 + 1)) {\n          *(byte *)local_e0 = 0x30;\n        }\n      }\nLAB_08006ca6:\n      local_138 = (int *)((int)piVar16 - (int)piVar23);\n      goto LAB_08006cb0;\n    case (int *)0x43:\n    case (int *)0x63:\n      piVar16 = (int *)0x0;\n      piVar27 = *local_154;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      piVar22 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_154 = local_154 + 1;\n      local_168 = (int *)0x1;\n      local_158 = (char *)0x1;\n      local_8c = SUB41(piVar27,0);\n      piVar23 = (int *)&local_8c;\n      goto LAB_08006298;\n    case (int *)0x44:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080065a8;\nLAB_080060ec:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_08006102;\n    case (int *)0x4c:\n      piVar25 = (int *)((uint)piVar25 | 8);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x4f:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n    case (int *)0x6f:\n      if (((uint)piVar25 & 0x20) == 0) {\n        ppiVar14 = local_154 + 1;\n        if (((uint)piVar25 & 0x10) == 0) {\n          if (((uint)piVar25 & 0x40) == 0) {\n            if (((uint)piVar25 & 0x200) == 0) goto LAB_08006be2;\n            piVar22 = (int *)(uint)*(byte *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n          else {\n            piVar22 = (int *)(uint)*(ushort *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n        }\n        else {\nLAB_08006be2:\n          piVar22 = *local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\n        ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n        piVar22 = *ppiVar14;\n        piVar16 = ppiVar14[1];\n        local_154 = ppiVar14 + 2;\n      }\n      iVar3 = 0;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n      break;\n    case (int *)0x53:\n    case (int *)0x73:\n      local_f5 = 0;\n      piVar23 = *local_154;\n      ppiVar14 = local_154 + 1;\n      if (piVar23 == (int *)0x0) {\n        if ((int *)0x5 < piVar27) {\n          piVar27 = (int *)0x6;\n        }\n        piVar23 = (int *)&UNK_08009f44;\n        piVar16 = (int *)0x0;\n        local_148 = (int *)0x0;\n        local_13c = (int **)0x0;\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar22 = (int *)0x0;\n        local_168 = piVar27;\n        local_158 = (char *)piVar27;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (piVar27 == (int *)0xffffffff) {\n          local_158 = (char *)get_byte_alignment_08005e40(piVar23);\n        }\n        else {\n          iVar3 = find_byte_sequence_0800901c(piVar23,0,piVar27);\n          if (iVar3 == 0) {\n            piVar16 = (int *)(uint)local_f5;\n            local_148 = (int *)0x0;\n            local_13c = (int **)0x0;\n            local_134 = (int *)0x0;\n            local_130 = (int *)0x0;\n            piVar22 = (int *)0x0;\n            local_168 = piVar27;\n            local_158 = (char *)piVar27;\n            local_154 = ppiVar14;\n            goto LAB_08006538;\n          }\n          local_158 = (char *)(iVar3 - (int)piVar23);\n        }\n        local_148 = (int *)0x0;\n        local_13c = (int **)0x0;\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar16 = (int *)(uint)local_f5;\n        piVar22 = (int *)0x0;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        local_154 = ppiVar14;\n      }\n      goto LAB_08006538;\n    case (int *)0x55:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080066c0;\nLAB_0800618a:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      iVar3 = 1;\n      local_154 = ppiVar14 + 2;\n      break;\n    case (int *)0x58:\n      local_11c = \"0123456789ABCDEF\";\n      if (((uint)piVar25 & 0x20) == 0) goto LAB_08006696;\nLAB_080061ac:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_080061be;\n    case (int *)0x64:\n    case (int *)0x69:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_080060ec;\nLAB_080065a8:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bcc:\n        piVar22 = *local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(int)*(short *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bcc;\n        piVar22 = (int *)(int)*(char *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\nLAB_08006102:\n      if ((int)piVar16 < 0) {\n        bVar31 = piVar22 != (int *)0x0;\n        piVar22 = (int *)-(int)piVar22;\n        piVar16 = (int *)(-(int)piVar16 - (uint)bVar31);\n        local_f5 = 0x2d;\n      }\n      if (piVar27 != (int *)0xffffffff) {\n        iVar3 = 1;\n        iVar8 = 1;\n        piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n        if (((uint)piVar22 | (uint)piVar16) == 0) goto LAB_080060a4;\n        goto LAB_08006130;\n      }\n      piVar21 = piVar25;\n      if (piVar16 != (int *)0x0 || (int *)0x9 < piVar22) goto LAB_08006f16;\n      goto LAB_0800698a;\n    case (int *)0x68:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x68) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar25 = (int *)((uint)piVar25 | 0x200);\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      else {\n        piVar25 = (int *)((uint)piVar25 | 0x40);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x6a:\n    case (int *)0x71:\n      piVar25 = (int *)((uint)piVar25 | 0x20);\n    case (int *)0x74:\n    case (int *)0x7a:\nswitchD_08005f58_caseD_74:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x6c:\n      goto switchD_08005f58_caseD_6c;\n    case (int *)0x6e:\n      ppiVar14 = local_154 + 1;\n      ppbVar15 = (byte **)*local_154;\n      local_154 = ppiVar14;\n      if (((uint)piVar25 & 0x20) != 0) {\n        *ppbVar15 = local_164;\n        ppbVar15[1] = (byte *)((int)local_164 >> 0x1f);\n        goto LAB_0800620e;\n      }\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) != 0) {\n          *(short *)ppbVar15 = (short)local_164;\n          goto LAB_0800620e;\n        }\n        if (((uint)piVar25 & 0x200) != 0) {\n          *(char *)ppbVar15 = (char)local_164;\n          goto LAB_0800620e;\n        }\n      }\n      *ppbVar15 = local_164;\n      goto LAB_0800620e;\n    case (int *)0x70:\n      local_f4 = 0x7830;\n      piVar22 = *local_154;\n      local_11c = \"0123456789abcdef\";\n      piVar25 = (int *)((uint)piVar25 | 2);\n      piVar16 = (int *)0x0;\n      iVar3 = 2;\n      piVar24 = (int *)0x78;\n      local_154 = local_154 + 1;\n      break;\n    case (int *)0x75:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_0800618a;\nLAB_080066c0:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bf2:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(uint)*(ushort *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bf2;\n        piVar22 = (int *)(uint)*(byte *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      break;\n    case (int *)0x78:\n      local_11c = \"0123456789abcdef\";\n      if (((uint)piVar25 & 0x20) != 0) goto LAB_080061ac;\nLAB_08006696:\n      ppiVar14 = local_154 + 1;\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) == 0) {\n          if (((uint)piVar25 & 0x200) == 0) goto LAB_08006bbc;\n          piVar22 = (int *)(uint)*(byte *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n        else {\n          piVar22 = (int *)(uint)*(ushort *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\nLAB_08006bbc:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        local_154 = ppiVar14;\n      }\nLAB_080061be:\n      if ((((uint)piVar25 & 1) != 0) && (((uint)piVar22 | (uint)piVar16) != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 2);\n        local_f4 = CONCAT11((char)piVar24,0x30);\n      }\n      iVar3 = 2;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n    }\n    local_f5 = 0;\n    if (piVar27 == (int *)0xffffffff) {\n      if (iVar3 != 1) goto LAB_08006136;\nLAB_08006980:\n      piVar21 = piVar25;\n      if (piVar16 == (int *)0x0 && piVar22 < (int *)0xa) goto LAB_0800698a;\nLAB_08006f16:\n      lVar32 = CONCAT44(piVar16,piVar22);\n      piVar23 = (int *)(&bStack_2a + 2);\n      piVar22 = (int *)0x0;\n      pbVar26 = local_108;\n      local_168 = piVar23;\n      local_158 = (char *)ppiVar2;\n      local_150._0_4_ = piVar25;\n      local_148 = piVar24;\n      do {\n        iVar3 = (int)((ulonglong)lVar32 >> 0x20);\n        uVar19 = (uint)lVar32;\n        cVar6 = '\\n';\n        calculate_result_080011ec(uVar19,iVar3,10,0);\n        *(byte *)((int)piVar23 + -1) = cVar6 + 0x30;\n        piVar22 = (int *)((int)piVar22 + 1);\n        piVar23 = (int *)((int)piVar23 + -1);\n        if ((((((uint)piVar25 & 0x400) != 0) && (piVar22 == (int *)(uint)*pbVar26)) &&\n            (piVar22 != (int *)0xff)) && (iVar3 != 0 || 9 < uVar19)) {\n          piVar23 = (int *)((int)piVar23 - (int)local_104);\n          copy_and_filter_bytes_08009768(piVar23,local_110,local_104);\n          if (pbVar26[1] == 0) {\n            piVar22 = (int *)0x0;\n          }\n          else {\n            pbVar26 = pbVar26 + 1;\n            piVar22 = (int *)0x0;\n          }\n        }\n        lVar32 = calculate_result_080011ec(uVar19,iVar3,10,0);\n      } while (lVar32 != 0);\n      piVar24 = local_148;\n      piVar25 = (int *)local_150;\n      ppiVar2 = (int **)local_158;\n      local_158 = (char *)((int)local_168 - (int)piVar23);\n      local_138 = piVar22;\n      local_108 = pbVar26;\n    }\n    else {\n      piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n      iVar8 = iVar3;\n      if (((uint)piVar22 | (uint)piVar16) == 0) {\nLAB_080060a4:\n        if (piVar27 == (int *)0x0) {\n          if (iVar3 == 0) {\n            local_158 = (char *)((uint)piVar25 & 1);\n            if ((int *)local_158 == (int *)0x0) {\n              piVar23 = (int *)(&bStack_2a + 2);\n              piVar25 = piVar21;\n            }\n            else {\n              piVar23 = (int *)(&bStack_2a + 1);\n              local_29 = '0';\n              piVar25 = piVar21;\n            }\n          }\n          else {\n            piVar23 = (int *)(&bStack_2a + 2);\n            piVar25 = piVar21;\n            local_158 = (char *)piVar27;\n          }\n        }\n        else {\n          piVar25 = piVar21;\n          if (iVar3 != 1) goto LAB_08006136;\nLAB_0800698a:\n          local_29 = (char)piVar22 + '0';\n          piVar23 = (int *)(&bStack_2a + 1);\n          local_158 = (char *)0x1;\n          piVar25 = piVar21;\n        }\n      }\n      else {\nLAB_08006130:\n        iVar3 = iVar8;\n        piVar25 = piVar21;\n        if (iVar8 == 1) goto LAB_08006980;\nLAB_08006136:\n        if (iVar3 == 2) {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = (int *)((uint)piVar22 >> 4 | (int)piVar16 << 0x1c);\n            piVar16 = (int *)((uint)piVar16 >> 4);\n            piVar23 = (int *)((int)piVar23 + -1);\n            *(char *)piVar23 = local_11c[(uint)piVar22 & 0xf];\n            piVar22 = piVar21;\n          } while (((uint)piVar21 | (uint)piVar16) != 0);\n        }\n        else {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = piVar23;\n            piVar9 = (int *)((uint)piVar22 >> 3 | (int)piVar16 << 0x1d);\n            piVar16 = (int *)((uint)piVar16 >> 3);\n            iVar3 = ((uint)piVar22 & 7) + 0x30;\n            *(byte *)((int)piVar21 + -1) = (byte)iVar3;\n            piVar23 = (int *)((int)piVar21 + -1);\n            piVar22 = piVar9;\n          } while (((uint)piVar9 | (uint)piVar16) != 0);\n          if ((((uint)piVar25 & 1) != 0) && (iVar3 != 0x30)) {\n            piVar23 = (int *)((int)piVar21 + -2);\n            *(byte *)((int)piVar21 + -2) = 0x30;\n            local_158 = (char *)(&bStack_2a + (2 - (int)piVar23));\n            goto LAB_0800675a;\n          }\n        }\n        local_158 = (char *)(&bStack_2a + (2 - (int)piVar23));\n      }\n    }\nLAB_0800675a:\n    local_148 = (int *)0x0;\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = piVar27;\n    local_168 = (int *)local_158;\n    if ((int)local_158 < (int)piVar27) {\n      local_168 = piVar27;\n    }\n    goto LAB_08006538;\n  }\nLAB_08006216:\n  piVar28 = local_160;\n  if (local_d0 == (int *)0x0) {\nLAB_0800604a:\n    uVar13 = *(ushort *)(local_160 + 3);\n  }\n  else {\n    copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n    uVar13 = *(ushort *)(piVar28 + 3);\n  }\nLAB_0800604e:\n  if ((uVar13 & 0x40) != 0) {\n    local_164 = (byte *)0xffffffff;\n  }\n  return local_164;\nswitchD_08005f58_caseD_6c:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (piVar24 == (int *)0x6c) {\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    piVar25 = (int *)((uint)piVar25 | 0x20);\n    piVar28 = (int *)((int)piVar28 + 1);\n  }\n  else {\n    piVar25 = (int *)((uint)piVar25 | 0x10);\n  }\n  goto LAB_08005f4a;\n  while( true ) {\n    iVar8 = process_input_and_check_flag_08000998((int)uVar33,uVar10,local_124,local_120);\n    if (iVar8 != 0) break;\nLAB_080072ba:\n    piVar16 = param_3;\n    piVar22 = (int *)((int)piVar22 + -1);\n    uVar33 = calculate_result_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x40300000);\n    iVar3 = calculate_value_0800119c();\n    uVar34 = calculate_shifted_value_080003f4();\n    uVar33 = perform_arithmetic_operations_08000158((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),(int)uVar34,\n                          (int)((ulonglong)uVar34 >> 0x20));\n    uVar10 = (undefined4)((ulonglong)uVar33 >> 0x20);\n    param_3 = (int *)((int)piVar16 + 1);\n    *(char *)piVar16 = pcVar18[iVar3];\n    if (piVar22 == (int *)0xffffffff) break;\n  }\n  piVar23 = local_fc;\n  piVar25 = local_100;\n  piVar27 = local_130;\n  piVar24 = local_134;\n  piVar28 = local_138;\n  ppiVar2 = local_13c;\n  local_13c = (int **)piVar22;\n  local_134 = piVar16;\n  local_150 = uVar33;\n  iVar8 = check_input_is_empty_080009e8((int)uVar33,uVar10,0,0x3fe00000);\n  if (iVar8 == 0) {\n    iVar8 = process_input_and_check_flag_08000998((int *)local_150,local_150._4_4_,0,0x3fe00000);\n    if ((iVar8 != 0) && (iVar3 << 0x1f < 0)) goto LAB_0800748a;\n    if (-1 < (int)local_13c) {\n      piVar16 = (int *)((byte *)((int)local_13c + 1) + (int)param_3);\n      piVar22 = param_3;\n      do {\n        param_3 = (int *)((int)piVar22 + 1);\n        *(byte *)piVar22 = 0x30;\n        piVar22 = param_3;\n      } while (piVar16 != param_3);\n    }\n  }\n  else {\nLAB_0800748a:\n    bVar1 = local_158[0xf];\n    bVar7 = *(byte *)piVar16;\n    piVar22 = param_3;\n    local_e0 = local_134;\n    while (bVar1 == bVar7) {\n      *(byte *)((int)piVar22 + -1) = 0x30;\n      bVar7 = *(byte *)((int)local_e0 + -1);\n      piVar22 = local_e0;\n      local_e0 = (int *)((int)local_e0 + -1);\n    }\n    if (bVar7 == 0x39) {\n      bVar7 = local_158[10];\n    }\n    else {\n      bVar7 = bVar7 + 1;\n    }\n    *(byte *)((int)piVar22 + -1) = bVar7;\n  }\n  local_138 = (int *)((int)param_3 - (int)piVar23);\nLAB_08006cb0:\n  local_134 = local_f0;\n  if (local_168 == (int *)0x47) {\n    if (((int)((int)local_f0 + 3) < 0 == SCARRY4((int)local_f0,3)) &&\n       ((int)local_f0 <= (int)piVar27)) {\n      if ((int)local_f0 < (int)local_138) {\n        local_158 = (char *)((int)local_138 + (int)local_118);\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074f8;\n        }\n        local_158 = (char *)((int)local_158 + (1 - (int)local_f0));\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        piVar24 = (int *)0x67;\n      }\n      else {\n        if ((int)piVar25 << 0x1f < 0) {\n          local_158 = (char *)((int)local_f0 + (int)local_118);\n        }\n        else {\n          local_158 = (char *)local_f0;\n        }\n        if (-1 < (int)piVar25 << 0x15) {\n          piVar24 = (int *)0x67;\n          goto LAB_0800754a;\n        }\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074fc;\n        }\n        piVar24 = (int *)0x67;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_080073d6;\n    }\n    piVar24 = (int *)((int)piVar24 + -2);\n    local_168 = (int *)((uint)piVar24 & 0xffffffdf);\nLAB_08006cc4:\n    local_e8 = (char)piVar24;\n    if (local_168 == (int *)0x41) {\n      local_e8 = local_e8 + '\\x0f';\n    }\n    piVar27 = (int *)((int)local_f0 + -1);\n    if ((int)piVar27 < 0) {\n      local_e7 = 0x2d;\n      local_f0 = (int *)(1 - (int)local_f0);\n    }\n    else {\n      local_e7 = 0x2b;\n      local_f0 = piVar27;\n    }\n    if ((int)local_f0 < 10) {\n      if (local_168 == (int *)0x41) {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n      else {\n        local_e6[0] = 0x30;\n        pcVar18 = (char *)((int)&local_e8 + 3);\n      }\n      *pcVar18 = (char)local_f0 + '0';\n      pcVar18 = pcVar18 + 1;\n    }\n    else {\n      pbVar30 = abStack_dc + 3;\n      pbVar26 = pbVar30;\n      do {\n        pbVar5 = pbVar26;\n        piVar22 = (int *)((uint)local_f0 / 10);\n        pbVar5[-1] = (char)local_f0 + (char)piVar22 * -10 + 0x30;\n        pbVar26 = pbVar5 + -1;\n        local_f0 = piVar22;\n      } while ((int *)0x9 < piVar22);\n      uVar19 = (uint)(piVar22 + 0xc) & 0xff;\n      pbVar5[-2] = (byte)uVar19;\n      if (pbVar5 + -2 < pbVar30) {\n        pbVar5 = pbVar26;\n        puVar20 = (undefined *)((int)&local_e8 + 2);\n        while( true ) {\n          *puVar20 = (char)uVar19;\n          if (pbVar30 == pbVar5) break;\n          uVar19 = (uint)*pbVar5;\n          pbVar5 = pbVar5 + 1;\n          puVar20 = puVar20 + 1;\n        }\n        pcVar18 = (char *)(((int)&local_188 * 2 - (int)pbVar26) + 0x152);\n      }\n      else {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n    }\n    local_10c = (int *)(pcVar18 + -(int)&local_e8);\n    local_158 = (char *)((int)local_10c + (int)local_138);\n    if ((1 < (int)local_138) || ((int)piVar25 << 0x1f < 0)) {\n      local_158 = (char *)((int)local_158 + (int)local_118);\n    }\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    piVar25 = (int *)((uint)piVar25 & 0xfffffbff | 0x100);\n    local_f0 = piVar27;\n  }\n  else {\n    if (local_168 != (int *)0x46) goto LAB_08006cc4;\n    if ((int)local_f0 < 1) {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_168 = (int *)0x1;\n        local_158 = (char *)0x1;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)((byte *)((int)local_118 + 1) + (int)piVar27);\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\nLAB_080073d6:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      piVar25 = local_140;\n    }\n    else {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)local_f0;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)((byte *)((int)local_f0 + (int)local_118) + (int)piVar27);\n      }\nLAB_080074f8:\n      if (-1 < (int)piVar25 << 0x15) {\nLAB_0800754a:\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        goto LAB_080073d6;\n      }\nLAB_080074fc:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      uVar19 = (uint)*local_108;\n      while (uVar19 != 0xff) {\n        while( true ) {\n          if ((int)local_134 <= (int)uVar19) goto LAB_08007524;\n          uVar4 = (uint)local_108[1];\n          local_134 = (int *)((int)local_134 - uVar19);\n          if (uVar4 == 0) break;\n          local_108 = local_108 + 1;\n          local_130 = (int *)((int)local_130 + 1);\n          uVar19 = uVar4;\n          if (uVar4 == 0xff) goto LAB_08007524;\n        }\n        local_13c = (int **)((int)local_13c + 1);\n      }\nLAB_08007524:\n      local_158 = (char *)((int)local_158 + (int)local_104 * ((int)local_130 + (int)local_13c));\n      local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      piVar25 = local_140;\n    }\n  }\n  if (local_144 == (int *)0x0) {\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = (int *)0x0;\nLAB_08006538:\n    if (piVar16 != (int *)0x0) goto LAB_0800653e;\n  }\n  else {\n    piVar16 = (int *)0x2d;\n    piVar22 = (int *)0x0;\n    local_f5 = 0x2d;\nLAB_0800653e:\n    local_168 = (int *)((int)local_168 + 1);\n  }\nLAB_08006298:\n  piVar27 = local_160;\n  puVar29 = local_16c;\n  local_150._0_4_ = (int *)((uint)piVar25 & 2);\n  if ((int *)local_150 != (int *)0x0) {\n    local_168 = (int *)((int)local_168 + 2);\n  }\n  local_144 = (int *)((uint)piVar25 & 0x84);\n  if ((local_144 == (int *)0x0) &&\n     (piVar21 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar21)) {\n    if (0x10 < (int)piVar21) {\n      piVar16 = (int *)0x10;\n      local_100 = piVar24;\n      do {\n        piVar9 = piVar21;\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = piVar16;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n          piVar24 = local_100;\n        }\n        else {\n          local_140 = piVar16;\n          iVar3 = copy_and_update_memory_080097cc(puVar29,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = local_140;\n          piVar24 = local_100;\n        }\n        piVar21 = piVar9 + -4;\n        local_100 = piVar24;\n      } while (0x10 < (int)piVar21);\n      piVar21 = piVar9 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar21);\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar21;\n    if ((int)local_d4 < 8) {\n      piVar16 = (int *)(uint)local_f5;\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar16 = (int *)(uint)local_f5;\n    }\n  }\n  if (piVar16 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 1);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f5;\n    ppiVar2[1] = (int *)0x1;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  if ((int *)local_150 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 2);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f4;\n    ppiVar2[1] = (int *)0x2;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  if ((local_144 == (int *)0x80) &&\n     (piVar16 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar16)) {\n    if (0x10 < (int)piVar16) {\n      do {\n        while( true ) {\n          piVar21 = piVar16;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = copy_and_update_memory_080097cc(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = piVar21 + -4;\n          if ((int)(piVar21 + -4) < 0x11) goto LAB_08006882;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar16 = piVar21 + -4;\n      } while (0x10 < (int)(piVar21 + -4));\nLAB_08006882:\n      piVar16 = piVar21 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar16);\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar16;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  piVar22 = (int *)((int)piVar22 - (int)local_158);\n  if (0 < (int)piVar22) {\n    if (0x10 < (int)piVar22) {\n      do {\n        while( true ) {\n          piVar16 = piVar22;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = copy_and_update_memory_080097cc(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar22 = piVar16 + -4;\n          if ((int)(piVar16 + -4) < 0x11) goto LAB_080063d2;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar22 = piVar16 + -4;\n      } while (0x10 < (int)(piVar16 + -4));\nLAB_080063d2:\n      piVar22 = piVar16 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar22);\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar22;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_d0;\n  if (((uint)piVar25 & 0x100) == 0) {\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)local_158);\n    *ppiVar2 = piVar23;\n    ppiVar2[1] = (int *)local_158;\n    if ((int)local_d4 < 8) {\nLAB_0800640e:\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\n    else {\nLAB_08006a20:\n      iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else if ((int)piVar24 < 0x66) {\n    local_158 = (char *)((int)local_d0 + 1);\n    piVar27 = (int *)((int)local_d4 + 1);\n    ppiVar14 = ppiVar2 + 2;\n    local_d0 = (int *)local_158;\n    if (((int)local_138 < 2) && (((uint)piVar25 & 1) == 0)) {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)piVar27 < 8) {\n        local_150._0_4_ = (int *)((int)local_d4 + 2);\n        ppiVar2 = ppiVar2 + 4;\n      }\n      else {\n        local_d4 = piVar27;\n        iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        local_150._0_4_ = (int *)((int)local_d4 + 1);\n        ppiVar14 = local_cc;\n        local_158 = (char *)local_d0;\n        ppiVar2 = local_cc + 2;\n      }\n    }\n    else {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      local_d4 = piVar27;\n      if (7 < (int)piVar27) {\n        iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar14 = local_cc;\n        local_158 = (char *)local_d0;\n      }\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_158 = (char *)((int)local_158 + (int)local_118);\n      *ppiVar14 = local_114;\n      ppiVar14[1] = local_118;\n      local_d0 = (int *)local_158;\n      if ((int)local_d4 < 8) {\n        ppiVar17 = ppiVar14 + 2;\n      }\n      else {\n        iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar17 = local_cc;\n      }\n      piVar24 = local_d4;\n      local_150._0_4_ = (int *)((int)local_d4 + 1);\n      piVar22 = (int *)((int)local_138 + -1);\n      ppiVar11 = ppiVar17 + 2;\n      local_158 = (char *)local_d0;\n      local_144 = (int *)local_150;\n      iVar3 = process_input_and_check_flag_08000998(local_128,local_12c,local_124,local_120);\n      piVar27 = local_160;\n      puVar29 = local_16c;\n      if (iVar3 == 0) {\n        local_158 = (char *)((int)local_158 + (int)piVar22);\n        *ppiVar17 = (int *)((int)piVar23 + 1);\n        ppiVar17[1] = piVar22;\n        local_d0 = (int *)local_158;\n        if ((int)(int *)local_150 < 8) {\n          local_150._0_4_ = (int *)((int)piVar24 + 2);\n          ppiVar14 = ppiVar11;\n          ppiVar2 = ppiVar17 + 4;\n        }\n        else {\nLAB_08006d9c:\n          local_158 = (char *)local_d0;\n          local_d4 = (int *)local_150;\n          iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          local_150._0_4_ = (int *)((int)local_d4 + 1);\n          local_158 = (char *)local_d0;\n          ppiVar14 = local_cc;\n          ppiVar2 = local_cc + 2;\n        }\n      }\n      else {\n        ppiVar14 = ppiVar17;\n        ppiVar2 = ppiVar11;\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)local_158;\n          local_d4 = local_144;\n          if (0x10 < (int)piVar22) {\n            while( true ) {\n              local_d0 = local_d0 + 4;\n              *ppiVar17 = (int *)0x8009f60;\n              ppiVar17[1] = (int *)0x10;\n              if ((int)local_d4 < 8) {\n                ppiVar17 = ppiVar17 + 2;\n              }\n              else {\n                iVar3 = copy_and_update_memory_080097cc(puVar29,piVar27,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar17 = local_cc;\n              }\n              piVar22 = piVar22 + -4;\n              if ((int)piVar22 < 0x11) break;\n              local_d4 = (int *)((int)local_d4 + 1);\n            }\n            local_150._0_4_ = (int *)((int)local_d4 + 1);\n            ppiVar11 = ppiVar17 + 2;\n            local_158 = (char *)local_d0;\n          }\n          *ppiVar17 = (int *)0x8009f60;\n          ppiVar17[1] = piVar22;\n          local_158 = (char *)((int)local_158 + (int)piVar22);\n          local_d0 = (int *)local_158;\n          if (7 < (int)(int *)local_150) goto LAB_08006d9c;\n          local_150._0_4_ = (int *)((int)(int *)local_150 + 1);\n          ppiVar2 = ppiVar11 + 2;\n          ppiVar14 = ppiVar11;\n        }\n      }\n    }\n    ppiVar14[1] = local_10c;\n    local_d0 = (int *)((int)local_158 + (int)local_10c);\n    local_d4 = (int *)local_150;\n    *ppiVar14 = (int *)&local_e8;\n    piVar27 = local_d0;\n    if (7 < (int)(int *)local_150) {\n      iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else {\n    iVar3 = process_input_and_check_flag_08000998(local_128,local_12c,local_124,local_120);\n    if (iVar3 == 0) {\n      if ((int)local_f0 < 1) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)piVar27 + 1);\n        *ppiVar2 = (int *)&DAT_08009f4c;\n        ppiVar2[1] = (int *)0x1;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        if (((local_f0 != (int *)0x0) || (local_138 != (int *)0x0)) ||\n           (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)local_d0 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n          }\n          puVar29 = local_16c;\n          if ((int)local_f0 < 0) {\n            piVar27 = (int *)-(int)local_f0;\n            if ((int)(local_f0 + 4) < 0 != SCARRY4((int)local_f0,0x10)) {\n              do {\n                local_d4 = (int *)((int)local_d4 + 1);\n                local_d0 = local_d0 + 4;\n                *ppiVar2 = (int *)0x8009f60;\n                ppiVar2[1] = (int *)0x10;\n                if ((int)local_d4 < 8) {\n                  ppiVar2 = ppiVar2 + 2;\n                }\n                else {\n                  iVar3 = copy_and_update_memory_080097cc(puVar29,local_160,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  ppiVar2 = local_cc;\n                }\n                piVar27 = piVar27 + -4;\n              } while (0x10 < (int)piVar27);\n            }\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)local_d0 + (int)piVar27);\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = piVar27;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\n          local_d0 = (int *)((int)local_d0 + (int)local_138);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = local_138;\n          goto joined_r0x08006a1c;\n        }\n      }\n      else {\n        piVar24 = local_134;\n        if ((int)local_138 <= (int)local_134) {\n          piVar24 = local_138;\n        }\n        if (0 < (int)piVar24) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar24);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = piVar24;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        piVar22 = local_134;\n        if (-1 < (int)piVar24) {\n          piVar22 = (int *)((int)local_134 - (int)piVar24);\n        }\n        if (0 < (int)piVar22) {\n          for (; 0x10 < (int)piVar22; piVar22 = piVar22 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = piVar27 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_update_memory_080097cc(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n          }\n          local_d4 = (int *)((int)local_d4 + 1);\n          piVar27 = (int *)((int)piVar27 + (int)piVar22);\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar22;\n          local_d0 = piVar27;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar22 = local_104;\n        piVar24 = local_160;\n        puVar29 = local_16c;\n        piVar16 = (int *)((int)local_134 + (int)piVar23);\n        if (((uint)piVar25 & 0x400) != 0) {\n          local_158 = (char *)((int)piVar23 + (int)local_138);\n          pbVar26 = local_108;\n          local_150._0_4_ = piVar28;\n          local_144 = piVar25;\n          local_140 = piVar23;\n          if (local_130 == (int *)0x0) goto LAB_08007176;\nLAB_080070ba:\n          if (local_13c != (int **)0x0) goto LAB_0800717e;\n          pbVar26 = pbVar26 + -1;\n          local_130 = (int *)((int)local_130 + -1);\n          do {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)piVar27 + (int)piVar22);\n            *ppiVar2 = local_110;\n            ppiVar2[1] = piVar22;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_update_memory_080097cc(puVar29,piVar24,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = (int *)(uint)*pbVar26;\n            piVar28 = (int *)((int)local_158 - (int)piVar16);\n            if ((int)piVar27 <= (int)(int *)((int)local_158 - (int)piVar16)) {\n              piVar28 = piVar27;\n            }\n            if (0 < (int)piVar28) {\n              local_d0 = (int *)((int)local_d0 + (int)piVar28);\n              local_d4 = (int *)((int)local_d4 + 1);\n              *ppiVar2 = piVar16;\n              ppiVar2[1] = piVar28;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = copy_and_update_memory_080097cc(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar2 = local_cc;\n                piVar27 = (int *)(uint)*pbVar26;\n              }\n            }\n            piVar25 = piVar27;\n            if (-1 < (int)piVar28) {\n              piVar25 = (int *)((int)piVar27 - (int)piVar28);\n            }\n            if (0 < (int)piVar25) {\n              for (; 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n                while( true ) {\n                  local_d4 = (int *)((int)local_d4 + 1);\n                  local_d0 = local_d0 + 4;\n                  *ppiVar2 = (int *)0x8009f60;\n                  ppiVar2[1] = (int *)0x10;\n                  if ((int)local_d4 < 8) break;\n                  iVar3 = copy_and_update_memory_080097cc(puVar29,piVar24,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  piVar25 = piVar25 + -4;\n                  ppiVar2 = local_cc;\n                  if ((int)piVar25 < 0x11) goto LAB_08007156;\n                }\n                ppiVar2 = ppiVar2 + 2;\n              }\nLAB_08007156:\n              local_d4 = (int *)((int)local_d4 + 1);\n              local_d0 = (int *)((int)local_d0 + (int)piVar25);\n              *ppiVar2 = (int *)0x8009f60;\n              ppiVar2[1] = piVar25;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = copy_and_update_memory_080097cc(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = local_cc;\n              }\n            }\n            piVar16 = (int *)((int)piVar16 + (int)piVar27);\n            piVar27 = local_d0;\n            if (local_130 != (int *)0x0) goto LAB_080070ba;\nLAB_08007176:\n            if (local_13c == (int **)0x0) {\n              piVar23 = local_140;\n              piVar25 = local_144;\n              piVar28 = (int *)local_150;\n              local_108 = pbVar26;\n              if ((int *)((int)local_140 + (int)local_138) <= piVar16) {\n                piVar16 = (int *)((int)local_140 + (int)local_138);\n              }\n              break;\n            }\nLAB_0800717e:\n            local_13c = (int **)((int)local_13c + -1);\n          } while( true );\n        }\n        if (((int)local_f0 < (int)local_138) || (((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)piVar27 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar24 = (int *)((int)local_138 - (int)local_f0);\n        piVar22 = (int *)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16);\n        if ((int)piVar24 <= (int)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16)) {\n          piVar22 = piVar24;\n        }\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar22);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar16;\n          ppiVar2[1] = piVar22;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar24 = (int *)((int)local_138 - (int)local_f0);\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        if (-1 < (int)piVar22) {\n          piVar24 = (int *)((int)piVar24 - (int)piVar22);\n        }\n        if (0 < (int)piVar24) {\n          for (; local_d0 = piVar27, 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_update_memory_080097cc(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n          }\n          goto LAB_08007014;\n        }\n      }\n    }\n    else {\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_d0 = (int *)((int)piVar27 + 1);\n      *ppiVar2 = (int *)&DAT_08009f4c;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)local_d4 < 8) {\n        ppiVar2 = ppiVar2 + 2;\n      }\n      else {\n        iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar2 = local_cc;\n      }\n      if (((int)local_f0 < (int)local_138) || (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)local_118);\n        *ppiVar2 = local_114;\n        ppiVar2[1] = local_118;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        piVar22 = local_160;\n        puVar29 = local_16c;\n        piVar24 = (int *)((int)local_138 + -1);\n        piVar27 = local_d0;\n        if (0 < (int)piVar24) {\n          for (; 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_update_memory_080097cc(puVar29,piVar22,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\nLAB_08007014:\n          local_d0 = (int *)((int)local_d0 + (int)piVar24);\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar24;\njoined_r0x08006a1c:\n          local_d4 = (int *)((int)local_d4 + 1);\n          if (7 < (int)local_d4) goto LAB_08006a20;\n          goto LAB_0800640e;\n        }\n      }\n    }\n  }\n  piVar24 = local_160;\n  puVar29 = local_16c;\n  if ((((uint)piVar25 & 4) != 0) &&\n     (piVar25 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar25)) {\n    for (; local_d0 = piVar27, 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n      while( true ) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = (int *)0x10;\n        if ((int)local_d4 < 8) break;\n        iVar3 = copy_and_update_memory_080097cc(puVar29,piVar24,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        piVar25 = piVar25 + -4;\n        ppiVar2 = local_cc;\n        if ((int)piVar25 < 0x11) goto LAB_0800647a;\n      }\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\nLAB_0800647a:\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar25);\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar25;\n    piVar27 = local_d0;\n    if ((7 < (int)local_d4) &&\n       (iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8), piVar27 = local_d0, iVar3 != 0))\n    goto LAB_0800603e;\n  }\n  piVar24 = local_15c;\n  if ((int)local_15c < (int)local_168) {\n    piVar24 = local_168;\n  }\n  local_164 = local_164 + (int)piVar24;\n  if ((piVar27 == (int *)0x0) || (iVar3 = copy_and_update_memory_080097cc(local_16c,local_160,&local_d8), iVar3 == 0))\n  {\n    local_d4 = (int *)0x0;\n    if (local_148 != (int *)0x0) {\n      initialize_memory_080088ec(local_16c,local_148);\n    }\n    ppiVar2 = local_cc;\nLAB_0800620e:\n    bVar1 = *(byte *)piVar28;\n    param_3 = piVar28;\n    goto joined_r0x08005ef2;\n  }\nLAB_0800603e:\n  if (local_148 != (int *)0x0) {\n    initialize_memory_080088ec(local_16c,local_148);\n  }\n  goto LAB_0800604a;\nswitchD_08005f58_caseD_31:\n  local_15c = (int *)0x0;\n  piVar16 = piVar24 + -0xc;\n  piVar22 = piVar28;\n  do {\n    piVar28 = (int *)((int)piVar22 + 1);\n    piVar24 = (int *)(uint)*(byte *)piVar22;\n    local_15c = (int *)((int)piVar16 + (int)local_15c * 10);\n    piVar16 = piVar24 + -0xc;\n    piVar22 = piVar28;\n  } while (piVar16 < (int *)0xa);\n  goto LAB_08005f4e;\nswitchD_08005f58_caseD_20:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (local_f5 == 0) {\n    local_f5 = 0x20;\n  }\n  goto LAB_08005f4a;\n}\n\n",
            "renaming": {
                "FUN_08005e9c": "FUNC_08005e9c"
            },
            "calling": [
                "FUN_08005dfc"
            ],
            "called": [
                "FUN_080004c8",
                "FUN_08005e40",
                "FUN_0800119c",
                "FUN_080011ec",
                "FUN_080009c0",
                "FUN_08008ad4",
                "FUN_080003f4",
                "FUN_08000998",
                "FUN_08001170",
                "FUN_08008af8",
                "FUN_08000158",
                "FUN_08009768",
                "FUN_080009e8",
                "FUN_0800901c",
                "FUN_080009ac",
                "FUN_080097cc",
                "FUN_080096e0",
                "FUN_080088ec",
                "FUN_080079e8"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078a0": {
            "entrypoint": "0x080078a0",
            "current_name": "FUNC_080078a0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080078a4) */\n\nvoid FUNC_080078a0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080078a0": "FUNC_080078a0"
            },
            "calling": [
                "FUN_08005d20"
            ],
            "called": [
                "FUN_080098c0"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078c0": {
            "entrypoint": "0x080078c0",
            "current_name": "calculate_array_division_080078c0",
            "code": "\nuint calculateArrayDivision_080078c0(int array1,int array2)\n\n{\n  uint result;\n  uint *ptr1;\n  int carry;\n  int length;\n  int index;\n  uint quotient;\n  uint *ptr2;\n  uint *ptr3;\n  uint *ptr4;\n  uint temp;\n  uint *ptr5;\n  uint *ptr6;\n  \n  length = *(int *)(array2 + 0x10);\n  if (*(int *)(array1 + 0x10) < length) {\n    return 0;\n  }\n  index = length + -1;\n  ptr2 = (uint *)(array2 + 0x14);\n  ptr3 = (uint *)(array1 + 0x14);\n  quotient = ptr3[index] / (ptr2[index] + 1);\n  ptr4 = ptr2 + index;\n  if (quotient != 0) {\n    result = 0;\n    carry = 0;\n    ptr1 = ptr3;\n    ptr5 = ptr2;\n    do {\n      ptr6 = ptr5 + 1;\n      result = quotient * (*ptr5 & 0xffff) + result;\n      temp = quotient * (*ptr5 >> 0x10) + (result >> 0x10);\n      result = (carry - (result & 0xffff)) + (*ptr1 & 0xffff);\n      carry = ((*ptr1 >> 0x10) - (temp & 0xffff)) + ((int)result >> 0x10);\n      *ptr1 = result & 0xffff | carry * 0x10000;\n      carry = carry >> 0x10;\n      result = temp >> 0x10;\n      ptr1 = ptr1 + 1;\n      ptr5 = ptr6;\n    } while (ptr6 <= ptr4);\n    if (ptr3[index] == 0) {\n      if ((ptr3 < ptr3 + length + -2) && (ptr3[length + -2] == 0)) {\n        ptr1 = ptr3 + length + -3;\n        do {\n          index = index + -1;\n          if (ptr1 <= ptr3) break;\n          result = *ptr1;\n          ptr1 = ptr1 + -1;\n        } while (result == 0);\n      }\n      *(int *)(array1 + 0x10) = index;\n    }\n  }\n  length = compare_arrays_080094f8();\n  if (-1 < length) {\n    length = 0;\n    quotient = quotient + 1;\n    ptr1 = ptr3;\n    do {\n      ptr5 = ptr2 + 1;\n      result = (length - (*ptr2 & 0xffff)) + (*ptr1 & 0xffff);\n      length = ((*ptr1 >> 0x10) - (*ptr2 >> 0x10)) + ((int)result >> 0x10);\n      *ptr1 = result & 0xffff | length * 0x10000;\n      length = length >> 0x10;\n      ptr1 = ptr1 + 1;\n      ptr2 = ptr5;\n    } while (ptr5 <= ptr4);\n    if (ptr3[index] == 0) {\n      if ((ptr3 < ptr3 + index + -1) && (ptr3[index + -1] == 0)) {\n        ptr2 = ptr3 + index + -2;\n        do {\n          index = index + -1;\n          if (ptr2 <= ptr3) break;\n          result = *ptr2;\n          ptr2 = ptr2 + -1;\n        } while (result == 0);\n      }\n      *(int *)(array1 + 0x10) = index;\n    }\n  }\n  return quotient;\n}\n\n",
            "renaming": {
                "FUN_080078c0": "calculate_array_division_080078c0",
                "param_1": "array1",
                "param_2": "array2",
                "uVar1": "result",
                "puVar2": "ptr1",
                "iVar3": "carry",
                "iVar4": "length",
                "iVar5": "index",
                "uVar6": "quotient",
                "puVar7": "ptr2",
                "puVar8": "ptr3",
                "puVar9": "ptr4",
                "uVar10": "temp",
                "puVar11": "ptr5",
                "puVar12": "ptr6"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080094f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080079e8": {
            "entrypoint": "0x080079e8",
            "current_name": "convert_floating_point_to_decimal_string_080079e8",
            "code": "\nchar * convertFloatingPointToDecimalString_080079e8(int input,undefined4 unknown,uint exponent,uint sign,uint format,\n                   uint precision,int *status,uint *flags,char **output)\n\n{\n  bool hasInfinity;\n  bool hasNaN;\n  bool rightAlign;\n  char digit;\n  byte leadingDigit;\n  undefined4 mantissa;\n  int shift;\n  int count;\n  int result;\n  char *pcVar10;\n  uint other;\n  undefined4 temp1;\n  undefined4 temp2;\n  int compressedLength;\n  int adjustedLength;\n  undefined4 temp3;\n  uint temp4;\n  uint temp5;\n  int shift;\n  char *pcVar20;\n  char *pcVar21;\n  undefined4 *puVar22;\n  undefined4 temp7;\n  int digitValue;\n  bool hasNaN5;\n  undefined8 temp8;\n  undefined8 temp9;\n  undefined8 temp10;\n  uint outputBuffer;\n  uint floatRepresentation;\n  uint floatClass;\n  int digitIndex;\n  uint formatPrecision;\n  int shiftAmount;\n  int leadingZeroes;\n  uint leadingSpace;\n  uint leadingDigits;\n  uint leadingDigitsMask;\n  uint inputLength;\n  uint compressedMantissaLength;\n  int extendedMantissa;\n  int compressedMantissa [2];\n  \n  compressedLength = *(int *)(input + 0x40);\n  if (compressedLength != 0) {\n    temp5 = *(uint *)(input + 0x44);\n    *(uint *)(compressedLength + 4) = temp5;\n    *(int *)(compressedLength + 8) = 1 << (temp5 & 0xff);\n    update_data_0800910c(input,compressedLength);\n    *(undefined4 *)(input + 0x40) = 0;\n  }\n  hasNaN5 = (int)sign < 0;\n  temp5 = sign;\n  if (hasNaN5) {\n    temp5 = sign & 0x7fffffff;\n  }\n  *flags = (uint)hasNaN5;\n  floatRepresentation = sign;\n  if (hasNaN5) {\n    floatRepresentation = temp5;\n  }\n  temp4 = floatRepresentation;\n  if ((~temp5 & 0x7ff00000) == 0) {\n    *status = 9999;\n    if ((exponent == 0) && ((temp5 & 0xfffff) == 0)) {\n      pcVar10 = \"Infinity\";\n      if (output == (char **)0x0) {\n        return pcVar10;\n      }\n      pcVar21 = \"\";\n    }\n    else {\n      pcVar10 = \"NaN\";\n      if (output == (char **)0x0) {\n        return pcVar10;\n      }\n      pcVar21 = \"\";\n    }\n    *output = pcVar21;\n    return pcVar10;\n  }\n  temp8 = process_input_and_check_flag_08000998(exponent,floatRepresentation,0,0);\n  if ((int)temp8 != 0) {\n    *status = 1;\n    if (output != (char **)0x0) {\n      *output = \"\";\n      return \"0\";\n    }\n    return \"0\";\n  }\n  mantissa = decompress_data_08009630(input,(int)((ulonglong)temp8 >> 0x20),exponent,floatRepresentation,compressedMantissa,&extendedMantissa)\n  ;\n  compressedLength = extendedMantissa;\n  if (temp5 >> 0x14 == 0) {\n    shift = compressedMantissa[0] + extendedMantissa;\n    adjustedLength = shift + 0x432;\n    if (adjustedLength < 0x21) {\n      temp5 = exponent << (0x20U - adjustedLength & 0xff);\n    }\n    else {\n      temp5 = exponent >> (shift + 0x412U & 0xff) | temp5 << (0x40U - adjustedLength & 0xff);\n    }\n    temp8 = reverse_bits_and_shift_080003d4(temp5);\n    shift = shift + -1;\n    hasNaN5 = true;\n    other = (int)((ulonglong)temp8 >> 0x20) + 0xfe100000;\n    temp5 = (uint)temp8;\n  }\n  else {\n    shift = (temp5 >> 0x14) - 0x3ff;\n    other = floatRepresentation & 0xfffff | 0x3ff00000;\n    hasNaN5 = false;\n    temp5 = exponent;\n  }\n  temp8 = perform_arithmetic_operations_08000158(temp5,other,0,0x3ff80000);\n  temp8 = calculate_result_080004c8((int)temp8,(int)((ulonglong)temp8 >> 0x20),0x636f4361,0x3fd287a7);\n  temp8 = calculate_result_0800015c((int)temp8,(int)((ulonglong)temp8 >> 0x20),0x8b60c8b3,0x3fc68a28);\n  temp9 = calculate_shifted_value_080003f4(shift);\n  temp9 = calculate_result_080004c8((int)temp9,(int)((ulonglong)temp9 >> 0x20),0x509f79fb,0x3fd34413);\n  temp8 = calculate_result_0800015c((int)temp8,(int)((ulonglong)temp8 >> 0x20),(int)temp9,\n                        (int)((ulonglong)temp9 >> 0x20));\n  temp2 = (undefined4)((ulonglong)temp8 >> 0x20);\n  floatClass = calculate_value_0800119c();\n  adjustedLength = is_input_processed_080009ac((int)temp8,temp2,0,0);\n  if (adjustedLength != 0) {\n    temp9 = calculate_shifted_value_080003f4(floatClass);\n    adjustedLength = process_input_and_check_flag_08000998((int)temp9,(int)((ulonglong)temp9 >> 0x20),(int)temp8,temp2);\n    if (adjustedLength == 0) {\n      floatClass = floatClass - 1;\n    }\n  }\n  if (floatClass < 0x17) {\n    adjustedLength = check_input_is_empty_080009e8(*(undefined4 *)(&DAT_08009fa8 + floatClass * 8),\n                          *(undefined4 *)(&DAT_08009fac + floatClass * 8),exponent,floatRepresentation);\n    if (adjustedLength == 0) {\n      hasNaN = false;\n    }\n    else {\n      floatClass = floatClass - 1;\n      hasNaN = false;\n    }\n  }\n  else {\n    hasNaN = true;\n  }\n  adjustedLength = (compressedLength - shift) + -1;\n  if (adjustedLength < 0) {\n    digitIndex = 1 - (compressedLength - shift);\n    adjustedLength = 0;\n  }\n  else {\n    digitIndex = 0;\n  }\n  if ((int)floatClass < 0) {\n    leadingSpace = 0;\n    digitIndex = digitIndex - floatClass;\n    leadingZeroes = -floatClass;\n  }\n  else {\n    adjustedLength = adjustedLength + floatClass;\n    leadingSpace = floatClass;\n    leadingZeroes = 0;\n  }\n  if (9 < format) {\n    inputLength = 0xffffffff;\n    hasInfinity = true;\n    formatPrecision = 0xffffffff;\n    rightAlign = true;\n    format = 0;\n    precision = 0;\n    goto LAB_08007c24;\n  }\n  hasInfinity = (int)format < 6;\n  if (!hasInfinity) {\n    format = format - 4;\n  }\n  switch(format) {\n  case 2:\n    rightAlign = false;\n    break;\n  case 3:\n    rightAlign = false;\n    goto LAB_08008300;\n  case 4:\n    rightAlign = true;\n    break;\n  case 5:\n    rightAlign = true;\nLAB_08008300:\n    inputLength = floatClass + precision;\n    formatPrecision = inputLength + 1;\n    temp5 = formatPrecision;\n    if ((int)formatPrecision < 1) {\n      temp5 = 1;\n    }\n    goto LAB_08008314;\n  default:\n    *(undefined4 *)(input + 0x44) = 0;\n    pcVar10 = (char *)initialize_memory_080090c0(input,0);\n    inputLength = 0xffffffff;\n    formatPrecision = 0xffffffff;\n    precision = 0;\n    *(char **)(input + 0x40) = pcVar10;\n    rightAlign = true;\n    goto LAB_08007e36;\n  }\n  if ((int)precision < 1) {\n    inputLength = 1;\n    precision = 1;\n    formatPrecision = 1;\nLAB_08007c24:\n    *(undefined4 *)(input + 0x44) = 0;\n    other = inputLength;\n  }\n  else {\n    inputLength = precision;\n    formatPrecision = precision;\n    temp5 = precision;\nLAB_08008314:\n    *(undefined4 *)(input + 0x44) = 0;\n    other = formatPrecision;\n    if (0x17 < (int)temp5) {\n      shift = 4;\n      compressedLength = 1;\n      do {\n        shift = compressedLength;\n        shift = shift * 2;\n        compressedLength = shift + 1;\n      } while (shift + 0x14U <= temp5);\n      *(int *)(input + 0x44) = shift;\n    }\n  }\n  pcVar10 = (char *)initialize_memory_080090c0(input);\n  *(char **)(input + 0x40) = pcVar10;\n  if ((other < 0xf) && (hasInfinity)) {\n    if ((int)floatClass < 1) {\n      if (floatClass == 0) {\n        compressedLength = 2;\n        outputBuffer = exponent;\n      }\n      else {\n        compressedLength = (-floatClass & 0xf) * 8;\n        temp8 = calculate_result_080004c8(exponent,floatRepresentation,*(undefined4 *)(&DAT_08009fa8 + compressedLength),\n                              *(undefined4 *)(&DAT_08009fac + compressedLength));\n        floatRepresentation = (uint)((ulonglong)temp8 >> 0x20);\n        outputBuffer = (uint)temp8;\n        shift = (int)-floatClass >> 4;\n        if (shift == 0) {\n          compressedLength = 2;\n        }\n        else {\n          hasInfinity = false;\n          compressedLength = 2;\n          puVar22 = &DAT_08009f80;\n          do {\n            if (shift << 0x1f < 0) {\n              temp8 = calculate_result_080004c8((int)temp8,(int)((ulonglong)temp8 >> 0x20),*puVar22,puVar22[1]\n                                   );\n              hasInfinity = true;\n              compressedLength = compressedLength + 1;\n            }\n            shift = shift >> 1;\n            puVar22 = puVar22 + 2;\n          } while (shift != 0);\n          if (hasInfinity) {\n            outputBuffer = (uint)temp8;\n            floatRepresentation = (uint)((ulonglong)temp8 >> 0x20);\n          }\n        }\n      }\n    }\n    else {\n      temp5 = (int)floatClass >> 4;\n      temp9 = *(undefined8 *)(&DAT_08009fa8 + (floatClass & 0xf) * 8);\n      temp8 = *(undefined8 *)(&DAT_08009fa8 + (floatClass & 0xf) * 8);\n      if ((int)(temp5 << 0x1b) < 0) {\n        temp10 = calculate_float_value_0800071c(exponent,floatRepresentation,0x7f73bf3c,0x75154fdd);\n        leadingDigitsMask = (uint)((ulonglong)temp10 >> 0x20);\n        leadingDigits = (uint)temp10;\n        compressedLength = 3;\n        temp5 = temp5 & 0xf;\n      }\n      else {\n        compressedLength = 2;\n        leadingDigitsMask = floatRepresentation;\n        leadingDigits = exponent;\n      }\n      if (temp5 != 0) {\n        puVar22 = &DAT_08009f80;\n        do {\n          if ((int)(temp5 << 0x1f) < 0) {\n            temp8 = calculate_result_080004c8((int)temp8,(int)((ulonglong)temp8 >> 0x20),*puVar22,puVar22[1]);\n            compressedLength = compressedLength + 1;\n          }\n          temp5 = (int)temp5 >> 1;\n          puVar22 = puVar22 + 2;\n          temp9 = temp8;\n        } while (temp5 != 0);\n      }\n      floatRepresentation = (uint)((ulonglong)temp9 >> 0x20);\n      outputBuffer = (uint)temp9;\n      temp8 = calculate_float_value_0800071c(leadingDigits,leadingDigitsMask,outputBuffer,floatRepresentation);\n      outputBuffer = (uint)temp8;\n      floatRepresentation = (uint)((ulonglong)temp8 >> 0x20);\n    }\n    temp8 = CONCAT44(floatRepresentation,outputBuffer);\n    if ((hasNaN) && (shift = is_input_processed_080009ac(outputBuffer,floatRepresentation,0,0x3ff00000), shift != 0)) {\n      if (formatPrecision == 0) {\n        temp8 = calculate_shifted_value_080003f4(compressedLength);\n        temp8 = calculate_result_080004c8((int)temp8,(int)((ulonglong)temp8 >> 0x20),outputBuffer,floatRepresentation);\n        temp8 = calculate_result_0800015c((int)temp8,(int)((ulonglong)temp8 >> 0x20),0,0x401c0000);\n        temp2 = (undefined4)temp8;\n        compressedLength = (int)((ulonglong)temp8 >> 0x20) + -0x3400000;\n        goto LAB_0800852e;\n      }\n      if (0 < (int)inputLength) {\n        temp8 = calculate_result_080004c8(outputBuffer,floatRepresentation,0,0x40240000);\n        temp9 = calculate_shifted_value_080003f4(compressedLength + 1);\n        temp9 = calculate_result_080004c8((int)temp9,(int)((ulonglong)temp9 >> 0x20),(int)temp8,\n                              (int)((ulonglong)temp8 >> 0x20));\n        temp9 = calculate_result_0800015c((int)temp9,(int)((ulonglong)temp9 >> 0x20),0,0x401c0000);\n        temp2 = (undefined4)temp9;\n        leadingDigits = inputLength;\n        compressedMantissaLength = floatClass - 1;\n        compressedLength = (int)((ulonglong)temp9 >> 0x20) + -0x3400000;\n        goto LAB_08007cfa;\n      }\n      goto LAB_08007e36;\n    }\n    temp9 = calculate_shifted_value_080003f4(compressedLength);\n    temp9 = calculate_result_080004c8((int)temp9,(int)((ulonglong)temp9 >> 0x20),outputBuffer,floatRepresentation);\n    temp9 = calculate_result_0800015c((int)temp9,(int)((ulonglong)temp9 >> 0x20),0,0x401c0000);\n    temp2 = (undefined4)temp9;\n    compressedLength = (int)((ulonglong)temp9 >> 0x20) + -0x3400000;\n    if (formatPrecision != 0) {\n      compressedMantissaLength = floatClass;\n      leadingDigits = formatPrecision;\nLAB_08007cfa:\n      floatRepresentation = (uint)((ulonglong)temp8 >> 0x20);\n      outputBuffer = (uint)temp8;\n      digit = calculate_value_0800119c(outputBuffer,floatRepresentation);\n      digit = digit + '0';\n      temp3 = (&DAT_08009fa0)[leadingDigits * 2];\n      temp1 = (&DAT_08009fa4)[leadingDigits * 2];\n      temp8 = calculate_shifted_value_080003f4();\n      temp8 = perform_arithmetic_operations_08000158(outputBuffer,floatRepresentation,(int)temp8,(int)((ulonglong)temp8 >> 0x20));\n      temp7 = (undefined4)((ulonglong)temp8 >> 0x20);\n      pcVar21 = pcVar10 + 1;\n      if (rightAlign) {\n        temp9 = calculate_float_value_0800071c(0,0x3fe00000,temp3,temp1);\n        temp9 = perform_arithmetic_operations_08000158((int)temp9,(int)((ulonglong)temp9 >> 0x20),temp2,compressedLength);\n        temp2 = (undefined4)((ulonglong)temp9 >> 0x20);\n        *pcVar10 = digit;\n        compressedLength = check_input_is_empty_080009e8((int)temp9,temp2,(int)temp8,temp7);\n        if (compressedLength != 0) {\nLAB_08008784:\n          floatClass = compressedMantissaLength;\n          goto LAB_08008294;\n        }\n        temp10 = perform_arithmetic_operations_08000158(0,0x3ff00000,(int)temp8,temp7);\n        compressedLength = check_input_is_empty_080009e8((int)temp9,temp2,(int)temp10,(int)((ulonglong)temp10 >> 0x20));\n        if (compressedLength == 0) {\n          if (leadingDigits != 1) {\n            pcVar20 = pcVar21;\n            do {\n              temp9 = calculate_result_080004c8((int)temp9,(int)((ulonglong)temp9 >> 0x20),0,0x40240000);\n              temp2 = (undefined4)((ulonglong)temp9 >> 0x20);\n              temp8 = calculate_result_080004c8((int)temp8,(int)((ulonglong)temp8 >> 0x20),0,0x40240000);\n              digit = calculate_value_0800119c();\n              temp10 = calculate_shifted_value_080003f4();\n              temp8 = perform_arithmetic_operations_08000158((int)temp8,(int)((ulonglong)temp8 >> 0x20),(int)temp10,\n                                    (int)((ulonglong)temp10 >> 0x20));\n              temp3 = (undefined4)((ulonglong)temp8 >> 0x20);\n              digit = digit + '0';\n              pcVar21 = pcVar20 + 1;\n              *pcVar20 = digit;\n              compressedLength = is_input_processed_080009ac((int)temp8,temp3,(int)temp9,temp2);\n              if (compressedLength != 0) {\n                floatClass = compressedMantissaLength;\n                goto LAB_08008294;\n              }\n              temp10 = perform_arithmetic_operations_08000158(0,0x3ff00000,(int)temp8,temp3);\n              compressedLength = is_input_processed_080009ac((int)temp10,(int)((ulonglong)temp10 >> 0x20),(int)temp9,temp2)\n              ;\n              if (compressedLength != 0) goto LAB_08008798;\n              pcVar20 = pcVar21;\n            } while (pcVar21 != pcVar10 + leadingDigits);\n          }\n          goto LAB_08007e36;\n        }\nLAB_08008798:\n        floatClass = compressedMantissaLength;\n      }\n      else {\n        temp9 = calculate_result_080004c8(temp2,compressedLength,temp3,temp1);\n        temp2 = (undefined4)((ulonglong)temp9 >> 0x20);\n        *pcVar10 = digit;\n        if (leadingDigits != 1) {\n          pcVar20 = pcVar21;\n          do {\n            temp8 = calculate_result_080004c8((int)temp8,(int)((ulonglong)temp8 >> 0x20),0,0x40240000);\n            digit = calculate_value_0800119c();\n            temp10 = calculate_shifted_value_080003f4();\n            temp8 = perform_arithmetic_operations_08000158((int)temp8,(int)((ulonglong)temp8 >> 0x20),(int)temp10,\n                                  (int)((ulonglong)temp10 >> 0x20));\n            pcVar21 = pcVar20 + 1;\n            *pcVar20 = digit + '0';\n            pcVar20 = pcVar21;\n          } while (pcVar21 != pcVar10 + leadingDigits);\n        }\n        temp3 = (undefined4)((ulonglong)temp8 >> 0x20);\n        temp10 = calculate_result_0800015c((int)temp9,temp2,0,0x3fe00000);\n        compressedLength = is_input_processed_080009ac((int)temp10,(int)((ulonglong)temp10 >> 0x20),(int)temp8,temp3);\n        if (compressedLength == 0) {\n          temp9 = perform_arithmetic_operations_08000158(0,0x3fe00000,(int)temp9,temp2);\n          compressedLength = check_input_is_empty_080009e8((int)temp9,(int)((ulonglong)temp9 >> 0x20),(int)temp8,temp3);\n          pcVar20 = pcVar21;\n          if (compressedLength == 0) goto LAB_08007e36;\n          do {\n            pcVar21 = pcVar20;\n            pcVar20 = pcVar21 + -1;\n          } while (pcVar21[-1] == '0');\n          goto LAB_08008784;\n        }\n        floatClass = compressedMantissaLength;\n        digit = pcVar21[-1];\n      }\n      goto LAB_08007f7c;\n    }\nLAB_0800852e:\n    temp8 = perform_arithmetic_operations_08000158(outputBuffer,floatRepresentation,0,0x40140000);\n    temp3 = (undefined4)((ulonglong)temp8 >> 0x20);\n    shift = check_input_is_empty_080009e8((int)temp8,temp3,temp2,compressedLength);\n    if (shift == 0) {\n      compressedLength = is_input_processed_080009ac((int)temp8,temp3,temp2,compressedLength + -0x80000000);\n      if (compressedLength == 0) goto LAB_08007e36;\n      shift = 0;\n      compressedLength = 0;\n      pcVar21 = pcVar10;\n      goto LAB_080084f0;\n    }\n    adjustedLength = 0;\n    shift = 0;\nLAB_08008406:\n    *pcVar10 = '1';\n    floatClass = floatClass + 1;\n    pcVar21 = pcVar10 + 1;\n    shift = shift;\n    compressedLength = adjustedLength;\nLAB_08008416:\n    update_data_0800910c(input,compressedLength);\n    if (shift == 0) goto LAB_08008294;\n  }\n  else {\nLAB_08007e36:\n    pcVar21 = pcVar10;\n    if ((-1 < compressedMantissa[0]) && ((int)floatClass < 0xf)) {\n      temp2 = *(undefined4 *)(&DAT_08009fa8 + floatClass * 8);\n      temp3 = *(undefined4 *)(&DAT_08009fac + floatClass * 8);\n      if ((-1 < (int)precision) || (0 < (int)formatPrecision)) {\n        calculate_float_value_0800071c(exponent,temp4,temp2,temp3);\n        leadingDigit = calculate_value_0800119c();\n        temp8 = calculate_shifted_value_080003f4();\n        temp8 = calculate_result_080004c8((int)temp8,(int)((ulonglong)temp8 >> 0x20),temp2,temp3);\n        temp8 = perform_arithmetic_operations_08000158(exponent,temp4,(int)temp8,(int)((ulonglong)temp8 >> 0x20));\n        *pcVar10 = leadingDigit + 0x30;\n        pcVar21 = pcVar10 + 1;\n        if (formatPrecision != 1) {\n          temp8 = calculate_result_080004c8((int)temp8,(int)((ulonglong)temp8 >> 0x20),0,0x40240000);\n          compressedLength = process_input_and_check_flag_08000998((int)temp8,(int)((ulonglong)temp8 >> 0x20),0,0);\n          while (compressedLength == 0) {\n            temp7 = (undefined4)((ulonglong)temp8 >> 0x20);\n            calculate_float_value_0800071c((int)temp8,temp7,temp2,temp3);\n            leadingDigit = calculate_value_0800119c();\n            temp9 = calculate_shifted_value_080003f4();\n            temp9 = calculate_result_080004c8((int)temp9,(int)((ulonglong)temp9 >> 0x20),temp2,temp3);\n            temp8 = perform_arithmetic_operations_08000158((int)temp8,temp7,(int)temp9,(int)((ulonglong)temp9 >> 0x20));\n            pcVar20 = pcVar21 + 1;\n            *pcVar21 = leadingDigit + 0x30;\n            pcVar21 = pcVar20;\n            if (formatPrecision == (int)pcVar20 - (int)pcVar10) goto LAB_08007f3a;\n            temp8 = calculate_result_080004c8((int)temp8,(int)((ulonglong)temp8 >> 0x20),0,0x40240000);\n            compressedLength = process_input_and_check_flag_08000998((int)temp8,(int)((ulonglong)temp8 >> 0x20),0,0);\n          }\n          goto LAB_08008294;\n        }\nLAB_08007f3a:\n        temp8 = calculate_result_0800015c((int)temp8,(int)((ulonglong)temp8 >> 0x20));\n        temp7 = (undefined4)((ulonglong)temp8 >> 0x20);\n        compressedLength = check_input_is_empty_080009e8((int)temp8,temp7,temp2,temp3);\n        if ((compressedLength == 0) &&\n           ((compressedLength = process_input_and_check_flag_08000998((int)temp8,temp7,temp2,temp3), compressedLength == 0 ||\n            ((leadingDigit & 1) == 0)))) goto LAB_08008294;\n        digit = pcVar21[-1];\nLAB_08007f7c:\n        while (pcVar20 = pcVar21 + -1, digit == '9') {\n          if (pcVar10 == pcVar20) {\n            *pcVar10 = '0';\n            digit = pcVar21[-1];\n            floatClass = floatClass + 1;\n            pcVar20 = pcVar10;\n            break;\n          }\n          digit = pcVar21[-2];\n          pcVar21 = pcVar20;\n        }\n        *pcVar20 = digit + '\\x01';\n        goto LAB_08008294;\n      }\n      if (formatPrecision == 0) {\n        temp8 = calculate_result_080004c8(temp2,temp3,0,0x40140000);\n        result = check_input_and_return_result_080009d4((int)temp8,(int)((ulonglong)temp8 >> 0x20),exponent,temp4);\n        shift = 0;\n        adjustedLength = 0;\n        shift = 0;\n        compressedLength = 0;\n        if (result == 0) goto LAB_08008406;\n      }\n      else {\n        shift = 0;\n        compressedLength = 0;\n      }\nLAB_080084f0:\n      floatClass = ~precision;\n      pcVar10 = pcVar21;\n      goto LAB_08008416;\n    }\n    compressedLength = leadingZeroes;\n    if (rightAlign) {\n      if ((int)format < 2) {\n        if (hasNaN5) {\n          shiftAmount = digitIndex;\n          digitIndex = digitIndex + compressedMantissa[0] + 0x433;\n          adjustedLength = adjustedLength + compressedMantissa[0] + 0x433;\n        }\n        else {\n          shiftAmount = digitIndex;\n          digitIndex = digitIndex + (0x36 - extendedMantissa);\n          adjustedLength = adjustedLength + (0x36 - extendedMantissa);\n        }\n      }\n      else {\n        shift = formatPrecision - 1;\n        if (leadingZeroes < shift) {\n          leadingSpace = leadingSpace + (shift - leadingZeroes);\n          compressedLength = 0;\n          leadingZeroes = shift;\n        }\n        else {\n          compressedLength = leadingZeroes - shift;\n        }\n        if ((int)formatPrecision < 0) {\n          shiftAmount = digitIndex - formatPrecision;\n        }\n        else {\n          adjustedLength = adjustedLength + formatPrecision;\n          shiftAmount = digitIndex;\n          digitIndex = digitIndex + formatPrecision;\n        }\n      }\n      shift = initialize_memory_and_set_values_08009244(input,1);\n    }\n    else {\n      shiftAmount = digitIndex;\n      shift = 0;\n    }\n    if ((0 < shiftAmount) && (0 < adjustedLength)) {\n      shift = shiftAmount;\n      if (adjustedLength <= shiftAmount) {\n        shift = adjustedLength;\n      }\n      adjustedLength = adjustedLength - shift;\n      digitIndex = digitIndex - shift;\n      shiftAmount = shiftAmount - shift;\n    }\n    if (leadingZeroes != 0) {\n      if (rightAlign) {\n        temp2 = mantissa;\n        if (compressedLength != 0) {\n          shift = process_data_080093a4(input,shift,compressedLength);\n          temp2 = initialize_memory_08009258(input,shift,mantissa);\n          update_data_0800910c(input,mantissa);\n          mantissa = temp2;\n          if (leadingZeroes - compressedLength == 0) goto LAB_08008062;\n        }\n        mantissa = process_data_080093a4(input,temp2,leadingZeroes - compressedLength);\n      }\n      else {\n        mantissa = process_data_080093a4(input,mantissa,leadingZeroes);\n      }\n    }\nLAB_08008062:\n    compressedLength = initialize_memory_and_set_values_08009244(input,1);\n    if (leadingSpace == 0) {\n      if (((int)format < 2) && (exponent == 0)) {\nLAB_0800835a:\n        if ((temp4 & 0xfffff) == 0) {\n          temp4 = temp4 & 0x7ff00000;\n          if (temp4 != 0) {\n            adjustedLength = adjustedLength + 1;\n            digitIndex = digitIndex + 1;\n            temp4 = 1;\n          }\n        }\n        else {\n          temp4 = 0;\n        }\n        hasNaN5 = leadingSpace != 0;\n        temp5 = exponent;\n        leadingSpace = temp4;\n        if (hasNaN5) goto LAB_080082d4;\n      }\n      shift = 1;\n    }\n    else {\n      temp8 = process_data_080093a4(input,compressedLength);\n      compressedLength = (int)temp8;\n      if (((int)format < 2) && (exponent == 0)) goto LAB_0800835a;\n      leadingSpace = 0;\n      temp5 = (uint)((ulonglong)temp8 >> 0x20);\nLAB_080082d4:\n      shift = count_leading_zeros_080091a4(*(undefined4 *)(compressedLength + *(int *)(compressedLength + 0x10) * 4 + 0x10),temp5);\n      shift = 0x20 - shift;\n    }\n    temp5 = shift + adjustedLength & 0x1f;\n    if (temp5 == 0) {\n      shift = 0x1c;\nLAB_08008096:\n      adjustedLength = adjustedLength + shift;\n      digitIndex = digitIndex + shift;\n      shiftAmount = shiftAmount + shift;\n    }\n    else {\n      if (4 < (int)(0x20 - temp5)) {\n        shift = 0x1c - temp5;\n        goto LAB_08008096;\n      }\n      if (0x20 - temp5 != 4) {\n        shift = 0x3c - temp5;\n        goto LAB_08008096;\n      }\n    }\n    if (0 < digitIndex) {\n      mantissa = initialize_memory_08009444(input,mantissa,digitIndex);\n    }\n    if (0 < adjustedLength) {\n      compressedLength = initialize_memory_08009444(input,compressedLength,adjustedLength);\n    }\n    pcVar20 = pcVar10;\n    if ((hasNaN) && (adjustedLength = compare_arrays_080094f8(mantissa,compressedLength), adjustedLength < 0)) {\n      floatClass = floatClass - 1;\n      mantissa = transform_data_08009120(input,mantissa,10,0);\n      if (rightAlign) {\n        shift = transform_data_08009120(input,shift,10,0);\n        if ((0 < (int)inputLength) || ((int)format < 3)) {\n          formatPrecision = inputLength;\n          goto LAB_080080de;\n        }\n      }\n      else if ((0 < (int)inputLength) || ((int)format < 3)) {\n        formatPrecision = inputLength;\n        goto LAB_0800820a;\n      }\n      formatPrecision = inputLength;\nLAB_080084e8:\n      if (formatPrecision == 0) {\n        adjustedLength = transform_data_08009120(input,compressedLength,5);\n        result = compare_arrays_080094f8(mantissa,adjustedLength);\n        shift = shift;\n        compressedLength = adjustedLength;\n        if (0 < result) goto LAB_08008406;\n      }\n      goto LAB_080084f0;\n    }\n    if (((int)formatPrecision < 1) && (2 < (int)format)) goto LAB_080084e8;\n    if (rightAlign) {\nLAB_080080de:\n      outputBuffer = shift;\n      if (0 < shiftAmount) {\n        outputBuffer = initialize_memory_08009444(input,shift,shiftAmount);\n      }\n      shift = outputBuffer;\n      if (leadingSpace != 0) {\n        shift = initialize_memory_080090c0(input,*(undefined4 *)(outputBuffer + 4));\n        copy_memory_08001084(shift + 0xc,outputBuffer + 0xc,(*(int *)(outputBuffer + 0x10) + 2) * 4);\n        shift = initialize_memory_08009444(input,shift,1);\n      }\nLAB_08008108:\n      adjustedLength = calculate_array_division_080078c0(mantissa,compressedLength);\n      shift = compare_arrays_080094f8(mantissa,outputBuffer);\n      result = reverse_and_initialize_memory_08009530(input,compressedLength,shift);\n      digitValue = adjustedLength + 0x30;\n      if (*(int *)(result + 0xc) == 0) {\n        count = compare_arrays_080094f8(mantissa);\n        update_data_0800910c(input,result);\n        if ((count != 0) || (format != 0)) goto LAB_0800815a;\n        if ((exponent & 1) != 0) {\n          count = 0;\n          goto LAB_0800815a;\n        }\n        if (digitValue != 0x39) {\n          if (0 < shift) goto LAB_0800874c;\n          goto LAB_080085a4;\n        }\nLAB_08008752:\n        pcVar21 = pcVar20 + 1;\n        digit = '9';\n        *pcVar20 = '9';\n        goto LAB_08008268;\n      }\n      update_data_0800910c(input,result);\n      count = 1;\nLAB_0800815a:\n      if ((shift < 0) || (((shift == 0 && (format == 0)) && ((exponent & 1) == 0)))) {\n        if (0 < count) {\n          mantissa = initialize_memory_08009444(input,mantissa,1);\n          shift = compare_arrays_080094f8(mantissa,compressedLength);\n          if ((0 < shift) || ((shift == 0 && (adjustedLength << 0x1f < 0)))) {\n            if (digitValue == 0x39) goto LAB_08008752;\nLAB_0800874c:\n            digitValue = adjustedLength + 0x31;\n          }\n        }\nLAB_080085a4:\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)digitValue;\n        goto LAB_08008274;\n      }\n      pcVar21 = pcVar20 + 1;\n      if (0 < count) {\n        if (digitValue == 0x39) goto LAB_08008752;\n        *pcVar20 = (char)adjustedLength + '1';\n        goto LAB_08008274;\n      }\n      *pcVar20 = (char)digitValue;\n      if (pcVar10 + (formatPrecision - 1) != pcVar20) {\n        mantissa = transform_data_08009120(input,mantissa,10,0);\n        pcVar20 = pcVar21;\n        if (outputBuffer == shift) {\n          outputBuffer = transform_data_08009120(input,outputBuffer,10,0);\n          shift = outputBuffer;\n        }\n        else {\n          outputBuffer = transform_data_08009120(input,outputBuffer,10,0);\n          shift = transform_data_08009120(input,shift,10,0);\n        }\n        goto LAB_08008108;\n      }\n    }\n    else {\nLAB_0800820a:\n      while( true ) {\n        digitValue = calculate_array_division_080078c0(mantissa,compressedLength);\n        digitValue = digitValue + 0x30;\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)digitValue;\n        if ((int)formatPrecision <= (int)pcVar21 - (int)pcVar10) break;\n        mantissa = transform_data_08009120(input,mantissa,10,0);\n        pcVar20 = pcVar21;\n      }\n      outputBuffer = 0;\n    }\n    mantissa = initialize_memory_08009444(input,mantissa,1);\n    adjustedLength = compare_arrays_080094f8(mantissa,compressedLength);\n    digit = pcVar21[-1];\n    if ((0 < adjustedLength) || ((adjustedLength == 0 && (digitValue << 0x1f < 0)))) {\nLAB_08008268:\n      do {\n        pcVar20 = pcVar21 + -1;\n        if (digit != '9') goto code_r0x08008270;\n        if (pcVar10 == pcVar20) {\n          *pcVar10 = '1';\n          floatClass = floatClass + 1;\n          goto LAB_08008274;\n        }\n        digit = pcVar21[-2];\n        pcVar21 = pcVar20;\n      } while( true );\n    }\n    while (digit == '0') {\n      digit = pcVar21[-2];\n      pcVar21 = pcVar21 + -1;\n    }\nLAB_08008274:\n    update_data_0800910c(input,compressedLength);\n    if (shift == 0) goto LAB_08008294;\n    if ((outputBuffer != 0) && (outputBuffer != shift)) {\n      update_data_0800910c(input);\n    }\n  }\n  update_data_0800910c(input,shift);\nLAB_08008294:\n  update_data_0800910c(input,mantissa);\n  *pcVar21 = '\\0';\n  *status = floatClass + 1;\n  if (output == (char **)0x0) {\n    return pcVar10;\n  }\n  *output = pcVar21;\n  return pcVar10;\ncode_r0x08008270:\n  *pcVar20 = digit + '\\x01';\n  goto LAB_08008274;\n}\n\n",
            "renaming": {
                "FUN_080079e8": "convert_floating_point_to_decimal_string_080079e8",
                "param_1": "input",
                "param_2": "unknown",
                "param_3": "exponent",
                "param_4": "sign",
                "param_5": "format",
                "param_6": "precision",
                "param_7": "status",
                "param_8": "flags",
                "param_9": "output",
                "bVar1": "hasInfinity",
                "bVar2": "hasNaN",
                "bVar3": "rightAlign",
                "cVar4": "digit",
                "bVar5": "leadingDigit",
                "uVar6": "mantissa",
                "iVar7": "shift",
                "iVar8": "count",
                "iVar9": "result",
                "iVar14": "compressedLength",
                "iVar15": "adjustedLength",
                "iVar19": "shift",
                "iVar24": "digitValue",
                "uVar11": "other",
                "uVar12": "temp1",
                "uVar13": "temp2",
                "uVar16": "temp3",
                "uVar17": "temp4",
                "uVar18": "temp5",
                "uVar23": "temp7",
                "uVar26": "temp8",
                "uVar27": "temp9",
                "uVar28": "temp10",
                "local_80": "outputBuffer",
                "local_7c": "floatRepresentation",
                "local_74": "floatClass",
                "local_70": "digitIndex",
                "local_68": "formatPrecision",
                "local_60": "shiftAmount",
                "local_5c": "leadingZeroes",
                "local_58": "leadingSpace",
                "local_48": "leadingDigits",
                "uStack_44": "leadingDigitsMask",
                "local_38": "inputLength",
                "local_34": "compressedMantissaLength",
                "local_30": "extendedMantissa",
                "local_2c": "compressedMantissa"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_080009d4",
                "FUN_080004c8",
                "FUN_08009244",
                "FUN_08009530",
                "FUN_08009630",
                "FUN_0800119c",
                "FUN_080091a4",
                "FUN_080090c0",
                "FUN_0800015c",
                "FUN_080003f4",
                "FUN_08000998",
                "FUN_080094f8",
                "FUN_08000158",
                "FUN_08009120",
                "FUN_080009e8",
                "FUN_080093a4",
                "FUN_080078c0",
                "FUN_080003d4",
                "FUN_080009ac",
                "FUN_0800910c",
                "FUN_08001084",
                "FUN_08009258",
                "FUN_08009444",
                "FUN_0800071c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800884c": {
            "entrypoint": "0x0800884c",
            "current_name": "initialize_and_update_data_0800884c",
            "code": "\nundefined4 initialize_and_update_data_0800884c(undefined4 data_1,int value)\n\n{\n  int result_1;\n  int result_2;\n  uint masked_value;\n  \n  initialize_data_080090a8();\n  masked_value = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  result_2 = ((0xfef - value) + masked_value & 0xfffff000) - 0x1000;\n  if (0xfff < result_2) {\n    result_1 = update_data_conditionally_08009744(data_1,0);\n    if (result_1 == DAT_20000454 + masked_value) {\n      result_1 = update_data_conditionally_08009744(data_1,-result_2);\n      if (result_1 != -1) {\n        DAT_20000a14 = DAT_20000a14 - result_2;\n        *(uint *)(DAT_20000454 + 4) = masked_value - result_2 | 1;\n        initialize_data_080090b4(data_1);\n        return 1;\n      }\n      result_2 = update_data_conditionally_08009744(data_1,0);\n      if (0xf < result_2 - DAT_20000454) {\n        DAT_20000a14 = result_2 - DAT_20000854;\n        *(uint *)(DAT_20000454 + 4) = result_2 - DAT_20000454 | 1;\n      }\n    }\n  }\n  initialize_data_080090b4(data_1);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800884c": "initialize_and_update_data_0800884c",
                "param_1": "data_1",
                "param_2": "value",
                "iVar1": "result_1",
                "iVar2": "result_2",
                "uVar3": "masked_value"
            },
            "calling": [
                "FUN_080088ec"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_08009744",
                "FUN_080090b4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080088ec": {
            "entrypoint": "0x080088ec",
            "current_name": "initialize_memory_080088ec",
            "code": "\nvoid initialize_memory_080088ec(undefined4 param_1,int size,undefined4 param_3,undefined4 param_4)\n\n{\n  int index;\n  uint *current_block;\n  uint *next_block;\n  undefined *temp_ptr;\n  uint block_size;\n  uint next_block_size;\n  undefined *prev_block;\n  undefined *prev_next_ptr;\n  undefined4 *loop_var;\n  int temp_var;\n  uint block_status;\n  uint next_block_status;\n  \n  if (size == 0) {\n    return;\n  }\n  initialize_data_080090a8();\n  block_status = *(uint *)(size + -4);\n  current_block = (uint *)(size + -8);\n  block_size = block_status & 0xfffffffe;\n  next_block = (uint *)((int)current_block + block_size);\n  next_block_size = next_block[1] & 0xfffffffc;\n  if (DAT_20000454 == next_block) {\n    block_size = block_size + next_block_size;\n    if ((block_status & 1) == 0) {\n      current_block = (uint *)((int)current_block - *(int *)(size + -8));\n      next_block_size = current_block[2];\n      block_status = current_block[3];\n      block_size = block_size + *(int *)(size + -8);\n      *(uint *)(next_block_size + 0xc) = block_status;\n      *(uint *)(block_status + 8) = next_block_size;\n    }\n    next_block_size = DAT_20000858;\n    current_block[1] = block_size | 1;\n    DAT_20000454 = current_block;\n    if (next_block_size <= block_size) {\n      initialize_and_update_data_0800884c(param_1,DAT_20000a44);\n    }\nLAB_080089f0:\n    initialize_data_080090b4(param_1);\n    return;\n  }\n  next_block[1] = next_block_size;\n  if ((block_status & 1) == 0) {\n    current_block = (uint *)((int)current_block - *(int *)(size + -8));\n    loop_var = (undefined4 *)current_block[2];\n    block_size = block_size + *(int *)(size + -8);\n    block_status = *(uint *)((int)next_block + next_block_size + 4) & 1;\n    if ((uint **)loop_var == &DAT_20000454) {\n      if (block_status == 0) {\n        block_status = next_block[2];\n        next_block_status = next_block[3];\n        block_size = block_size + next_block_size;\n        *(uint *)(block_status + 0xc) = next_block_status;\n        *(uint *)(next_block_status + 8) = block_status;\n        current_block[1] = block_size | 1;\n        *(uint *)((int)current_block + block_size) = block_size;\n      }\n      else {\n        current_block[1] = block_size | 1;\n        *next_block = block_size;\n      }\n      goto LAB_080089f0;\n    }\n    next_block_status = current_block[3];\n    loop_var[3] = next_block_status;\n    *(undefined4 **)(next_block_status + 8) = loop_var;\n  }\n  else {\n    block_status = *(uint *)((int)next_block + next_block_size + 4) & 1;\n  }\n  if (block_status == 0) {\n    loop_var = (undefined4 *)next_block[2];\n    block_size = block_size + next_block_size;\n    if ((uint **)loop_var == &DAT_20000454) {\n      DAT_2000045c = current_block;\n      DAT_20000460 = current_block;\n      current_block[2] = (uint)&DAT_20000454;\n      current_block[3] = (uint)&DAT_20000454;\n      current_block[1] = block_size | 1;\n      *(uint *)((int)current_block + block_size) = block_size;\n      goto LAB_080089f0;\n    }\n    next_block_size = next_block[3];\n    loop_var[3] = next_block_size;\n    *(undefined4 **)(next_block_size + 8) = loop_var;\n    current_block[1] = block_size | 1;\n    *(uint *)((int)current_block + block_size) = block_size;\n  }\n  else {\n    current_block[1] = block_size | 1;\n    *(uint *)((int)current_block + block_size) = block_size;\n  }\n  if (block_size < 0x200) {\n    temp_var = (block_size >> 3) + 1;\n    block_size = 1 << ((int)(block_size >> 3) >> 2 & 0xffU) | (uint)DAT_20000450;\n    next_block_size = *(uint *)(&DAT_2000044c + temp_var * 8);\n    current_block[2] = next_block_size;\n    current_block[3] = (uint)(&DAT_20000444 + temp_var * 8);\n    DAT_20000450 = (undefined *)block_size;\n    *(uint **)(&DAT_2000044c + temp_var * 8) = current_block;\n    *(uint **)(next_block_size + 0xc) = current_block;\n    initialize_data_080090b4(param_1,current_block,block_size,param_4);\n    return;\n  }\n  next_block_size = block_size >> 9;\n  if (next_block_size < 5) {\n    temp_var = ((block_size >> 6) + 0x39) * 8;\n    index = (block_size >> 6) + 0x38;\n  }\n  else if (next_block_size < 0x15) {\n    temp_var = (next_block_size + 0x5c) * 8;\n    index = next_block_size + 0x5b;\n  }\n  else if (next_block_size < 0x55) {\n    temp_var = ((block_size >> 0xc) + 0x6f) * 8;\n    index = (block_size >> 0xc) + 0x6e;\n  }\n  else if (next_block_size < 0x155) {\n    temp_var = ((block_size >> 0xf) + 0x78) * 8;\n    index = (block_size >> 0xf) + 0x77;\n  }\n  else if (next_block_size < 0x555) {\n    temp_var = ((block_size >> 0x12) + 0x7d) * 8;\n    index = (block_size >> 0x12) + 0x7c;\n  }\n  else {\n    temp_var = 0x3f8;\n    index = 0x7e;\n  }\n  temp_ptr = *(undefined **)(&DAT_2000044c + temp_var);\n  prev_block = &DAT_20000444 + temp_var;\n  if (prev_block == temp_ptr) {\n    temp_ptr = (undefined *)(1 << (index >> 2 & 0xffU) | (uint)DAT_20000450);\n    prev_next_ptr = prev_block;\n    DAT_20000450 = temp_ptr;\n  }\n  else {\n    do {\n      prev_next_ptr = temp_ptr;\n      if ((*(uint *)(temp_ptr + 4) & 0xfffffffc) <= block_size) break;\n      temp_ptr = *(undefined **)(temp_ptr + 8);\n      prev_next_ptr = prev_block;\n    } while (prev_block != temp_ptr);\n    prev_block = *(undefined **)(prev_next_ptr + 0xc);\n  }\n  current_block[2] = (uint)prev_next_ptr;\n  current_block[3] = (uint)prev_block;\n  *(uint **)(prev_block + 8) = current_block;\n  *(uint **)(prev_next_ptr + 0xc) = current_block;\n  initialize_data_080090b4(param_1,current_block,temp_ptr,param_4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080088ec": "initialize_memory_080088ec",
                "param_2": "size",
                "iVar1": "index",
                "puVar2": "current_block",
                "puVar3": "next_block",
                "puVar4": "temp_ptr",
                "uVar5": "block_size",
                "uVar6": "next_block_size",
                "puVar7": "prev_block",
                "puVar8": "prev_next_ptr",
                "puVar9": "loop_var",
                "iVar10": "temp_var",
                "uVar11": "block_status",
                "uVar12": "next_block_status"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_08009adc",
                "FUN_080097cc",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_080090b4",
                "FUN_0800884c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ad4": {
            "entrypoint": "0x08008ad4",
            "current_name": "get_adjusted_value_08008ad4",
            "code": "\nint getAdjustedValue_08008ad4(void)\n\n{\n  int value;\n  \n  value = *(int *)(DAT_2000001c + 0x34);\n  if (value == 0) {\n    value = 0x2000085c;\n  }\n  return value + 0xf0;\n}\n\n",
            "renaming": {
                "FUN_08008ad4": "get_adjusted_value_08008ad4",
                "iVar1": "value"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008af0": {
            "entrypoint": "0x08008af0",
            "current_name": "FUNC_08008af0",
            "code": "\nvoid FUNC_08008af0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af0": "FUNC_08008af0"
            },
            "calling": [
                "FUN_080090a8",
                "FUN_080098c0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af4": {
            "entrypoint": "0x08008af4",
            "current_name": "FUNC_08008af4",
            "code": "\nvoid FUNC_08008af4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af4": "FUNC_08008af4"
            },
            "calling": [
                "FUN_080098c0",
                "FUN_080090b4"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af8": {
            "entrypoint": "0x08008af8",
            "current_name": "allocate_memory_08008af8",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocate_memory_08008af8(undefined4 *result,uint size)\n\n{\n  undefined *newPtr1;\n  uint newVar2;\n  uint newVar3;\n  int newVar4;\n  undefined *newPtr5;\n  uint newVar6;\n  uint newVar7;\n  undefined4 *newPtr8;\n  undefined *newPtr9;\n  undefined *newPtr10;\n  int *newPtr11;\n  uint newSize;\n  uint newVar13;\n  int newVar14;\n  undefined4 *newPtr15;\n  undefined4 *newPtr16;\n  \n  newSize = size + 0xb;\n  if (newSize < 0x17) {\n    if (0x10 < size) goto LAB_08008c7a;\n    initializeData1();\n    newVar13 = 0x10;\n    newVar4 = 0x18;\n    newSize = 2;\nLAB_08008b18:\n    newPtr10 = *(undefined **)((int)&DAT_20000450 + newVar4);\n    if ((newPtr10 != &DAT_20000444 + newVar4) ||\n       (newPtr10 = *(undefined **)((int)&DAT_20000458 + newVar4), &DAT_2000044c + newVar4 != newPtr10)) {\n      newVar4 = *(int *)(newPtr10 + 0xc);\n      newPtr5 = newPtr10 + (*(uint *)(newPtr10 + 4) & 0xfffffffc);\n      newSize = *(uint *)(newPtr5 + 4);\nLAB_08008b34:\n      newVar14 = *(int *)(newPtr10 + 8);\n      *(int *)(newVar14 + 0xc) = newVar4;\n      *(int *)(newVar4 + 8) = newVar14;\n      *(uint *)(newPtr5 + 4) = newSize | 1;\n      initializeData2(result);\n      return (int *)(newPtr10 + 8);\n    }\n    newSize = newSize + 2;\n  }\n  else {\n    newVar13 = newSize & 0xfffffff8;\n    if (((int)newVar13 < 0) || (newVar13 < size)) {\nLAB_08008c7a:\n      *result = 0xc;\n      return (int *)0x0;\n    }\n    initializeData1();\n    if (newVar13 < 0x1f8) {\n      newSize = newSize >> 3;\n      newVar4 = newVar13 + 8;\n      goto LAB_08008b18;\n    }\n    newVar2 = newSize >> 9;\n    if (newVar2 == 0) {\n      newVar4 = 0x200;\n      newVar6 = 0x40;\n      newVar2 = 0x3f;\n    }\n    else if (newVar2 < 5) {\n      newVar6 = (newSize >> 6) + 0x39;\n      newVar2 = (newSize >> 6) + 0x38;\n      newVar4 = newVar6 * 8;\n    }\n    else if (newVar2 < 0x15) {\n      newVar6 = newVar2 + 0x5c;\n      newVar2 = newVar2 + 0x5b;\n      newVar4 = newVar6 * 8;\n    }\n    else if (newVar2 < 0x55) {\n      newVar6 = (newSize >> 0xc) + 0x6f;\n      newVar2 = (newSize >> 0xc) + 0x6e;\n      newVar4 = newVar6 * 8;\n    }\n    else if (newVar2 < 0x155) {\n      newVar6 = (newSize >> 0xf) + 0x78;\n      newVar2 = (newSize >> 0xf) + 0x77;\n      newVar4 = newVar6 * 8;\n    }\n    else if (newVar2 < 0x555) {\n      newVar6 = (newSize >> 0x12) + 0x7d;\n      newVar2 = (newSize >> 0x12) + 0x7c;\n      newVar4 = newVar6 * 8;\n    }\n    else {\n      newVar4 = 0x3f8;\n      newVar6 = 0x7f;\n      newVar2 = 0x7e;\n    }\n    for (newPtr10 = *(undefined **)((int)&DAT_20000450 + newVar4); newSize = newVar6,\n        &DAT_20000444 + newVar4 != newPtr10; newPtr10 = *(undefined **)(newPtr10 + 0xc)) {\n      newVar14 = (*(uint *)(newPtr10 + 4) & 0xfffffffc) - newVar13;\n      newSize = newVar2;\n      if (0xf < newVar14) break;\n      if (-1 < newVar14) {\n        newPtr5 = newPtr10 + (*(uint *)(newPtr10 + 4) & 0xfffffffc);\n        newSize = *(uint *)(newPtr5 + 4);\n        newVar4 = *(int *)(newPtr10 + 0xc);\n        goto LAB_08008b34;\n      }\n    }\n  }\n  newPtr15 = DAT_2000045c;\n  if ((undefined **)DAT_2000045c == &DAT_20000454) {\n    newVar6 = 1 << ((int)newSize >> 2 & 0xffU);\n    newVar2 = DAT_20000450;\n    if (newVar6 <= DAT_20000450) goto LAB_08008c06;\n  }\n  else {\n    newVar6 = DAT_2000045c[1];\n    newVar7 = newVar6 & 0xfffffffc;\n    newVar2 = newVar7 - newVar13;\n    if (0xf < (int)newVar2) {\n      newPtr16 = (undefined4 *)(newVar13 + (int)DAT_2000045c);\n      DAT_2000045c[1] = newVar13 | 1;\n      DAT_2000045c = newPtr16;\n      DAT_20000460 = newPtr16;\n      newPtr16[2] = &DAT_20000454;\n      newPtr16[3] = &DAT_20000454;\n      newPtr16[1] = newVar2 | 1;\n      *(uint *)((int)newPtr15 + newVar7) = newVar2;\n      initializeData2(result);\n      return newPtr15 + 2;\n    }\n    DAT_2000045c = &DAT_20000454;\n    DAT_20000460 = &DAT_20000454;\n    if (-1 < (int)newVar2) {\n      *(uint *)((int)newPtr15 + newVar7 + 4) = *(uint *)((int)newPtr15 + newVar7 + 4) | 1;\n      initializeData2(result);\n      return newPtr15 + 2;\n    }\n    if (newVar7 < 0x200) {\n      newVar4 = (newVar6 >> 3) + 1;\n      newVar14 = *(int *)(&DAT_2000044c + newVar4 * 8);\n      newVar2 = 1 << ((int)(newVar6 >> 3) >> 2 & 0xffU) | DAT_20000450;\n      newPtr15[2] = newVar14;\n      newPtr15[3] = &DAT_20000444 + newVar4 * 8;\n      DAT_20000450 = newVar2;\n      *(undefined4 **)(&DAT_2000044c + newVar4 * 8) = newPtr15;\n      *(undefined4 **)(newVar14 + 0xc) = newPtr15;\n    }\n    else {\n      newVar2 = newVar6 >> 9;\n      if (newVar2 < 5) {\n        newVar4 = ((newVar6 >> 6) + 0x39) * 8;\n        newVar14 = (newVar6 >> 6) + 0x38;\n      }\n      else if (newVar2 < 0x15) {\n        newVar4 = (newVar2 + 0x5c) * 8;\n        newVar14 = newVar2 + 0x5b;\n      }\n      else if (newVar2 < 0x55) {\n        newVar4 = ((newVar6 >> 0xc) + 0x6f) * 8;\n        newVar14 = (newVar6 >> 0xc) + 0x6e;\n      }\n      else if (newVar2 < 0x155) {\n        newVar4 = ((newVar6 >> 0xf) + 0x78) * 8;\n        newVar14 = (newVar6 >> 0xf) + 0x77;\n      }\n      else if (newVar2 < 0x555) {\n        newVar4 = ((newVar6 >> 0x12) + 0x7d) * 8;\n        newVar14 = (newVar6 >> 0x12) + 0x7c;\n      }\n      else {\n        newVar4 = 0x3f8;\n        newVar14 = 0x7e;\n      }\n      newPtr10 = *(undefined **)(&DAT_2000044c + newVar4);\n      newPtr5 = &DAT_20000444 + newVar4;\n      if (newPtr5 == newPtr10) {\n        DAT_20000450 = 1 << (newVar14 >> 2 & 0xffU) | DAT_20000450;\n      }\n      else {\n        do {\n          if ((*(uint *)(newPtr10 + 4) & 0xfffffffc) <= newVar7) break;\n          newPtr10 = *(undefined **)(newPtr10 + 8);\n        } while (newPtr5 != newPtr10);\n        newPtr5 = *(undefined **)(newPtr10 + 0xc);\n      }\n      newVar2 = DAT_20000450;\n      newPtr15[2] = newPtr10;\n      newPtr15[3] = newPtr5;\n      *(undefined4 **)(newPtr5 + 8) = newPtr15;\n      *(undefined4 **)(newPtr10 + 0xc) = newPtr15;\n    }\n    newVar6 = 1 << ((int)newSize >> 2 & 0xffU);\n    if (newVar6 <= newVar2) {\nLAB_08008c06:\n      if ((newVar6 & newVar2) == 0) {\n        newSize = newSize & 0xfffffffc;\n        do {\n          newVar6 = newVar6 << 1;\n          newSize = newSize + 4;\n        } while ((newVar6 & newVar2) == 0);\n      }\n      do {\n        newPtr16 = (undefined4 *)(&DAT_2000044c + newSize * 8);\n        newVar2 = newSize;\n        newPtr15 = newPtr16;\n        do {\n          for (newPtr8 = (undefined4 *)newPtr15[3]; newPtr15 != newPtr8;\n              newPtr8 = (undefined4 *)newPtr8[3]) {\n            newVar7 = newPtr8[1] & 0xfffffffc;\n            newVar3 = newVar7 - newVar13;\n            if (0xf < (int)newVar3) {\n              newVar14 = newPtr8[2];\n              newVar4 = newPtr8[3];\n              newPtr15 = (undefined4 *)(newVar13 + (int)newPtr8);\n              newPtr8[1] = newVar13 | 1;\n              *(int *)(newVar14 + 0xc) = newVar4;\n              *(int *)(newVar4 + 8) = newVar14;\n              DAT_2000045c = newPtr15;\n              DAT_20000460 = newPtr15;\n              newPtr15[2] = &DAT_20000454;\n              newPtr15[3] = &DAT_20000454;\n              newPtr15[1] = newVar3 | 1;\n              *(uint *)((int)newPtr8 + newVar7) = newVar3;\n              initializeData2(result);\n              return newPtr8 + 2;\n            }\n            if (-1 < (int)newVar3) {\n              newVar4 = newPtr8[3];\n              newVar14 = newPtr8[2];\n              *(uint *)((int)newPtr8 + newVar7 + 4) = *(uint *)((int)newPtr8 + newVar7 + 4) | 1;\n              *(int *)(newVar14 + 0xc) = newVar4;\n              *(int *)(newVar4 + 8) = newVar14;\n              initializeData2(result);\n              return newPtr8 + 2;\n            }\n          }\n          newVar2 = newVar2 + 1;\n          newPtr15 = newPtr15 + 2;\n        } while ((newVar2 & 3) != 0);\n        do {\n          newVar7 = newSize & 3;\n          newPtr15 = newPtr16 + -2;\n          newSize = newSize - 1;\n          if (newVar7 == 0) {\n            DAT_20000450 = DAT_20000450 & ~newVar6;\n            break;\n          }\n          newPtr16 = (undefined4 *)*newPtr16;\n        } while (newPtr16 == newPtr15);\n        newVar6 = newVar6 * 2;\n        if ((DAT_20000450 <= newVar6 && newVar6 - DAT_20000450 != 0) || (newSize = newVar2, newVar6 == 0))\n        break;\n        for (; (newVar6 & DAT_20000450) == 0; newVar6 = newVar6 << 1) {\n          newSize = newSize + 4;\n        }\n      } while( true );\n    }\n  }\n  newPtr10 = DAT_20000454;\n  newSize = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  if ((newVar13 <= newSize) && (newVar2 = newSize - newVar13, 0xf < (int)newVar2)) goto LAB_08008dac;\n  if (DAT_20000854 == (undefined *)0xffffffff) {\n    newVar2 = newVar13 + DAT_20000a44 + 0x10;\n  }\n  else {\n    newVar2 = newVar13 + DAT_20000a44 + 0x100f & 0xfffff000;\n  }\n  newPtr5 = (undefined *)updateDataConditionally(result,newVar2);\n  if (newPtr5 == (undefined *)0xffffffff) {\nLAB_08008ed8:\n    newSize = *(uint *)(DAT_20000454 + 4);\n  }\n  else {\n    newPtr1 = newPtr10 + newSize;\n    if (newPtr1 < newPtr5 || newPtr1 == newPtr5) {\n      newPtr9 = DAT_20000a14 + newVar2;\n      if ((newPtr1 != newPtr5) || (((uint)newPtr1 & 0xfff) != 0)) goto LAB_08008d02;\n      DAT_20000a14 = newPtr9;\n      *(uint *)(DAT_20000454 + 4) = newSize + newVar2 | 1;\n    }\n    else {\n      if (newPtr10 != &DAT_2000044c) goto LAB_08008ed8;\nLAB_08008d02:\n      DAT_20000a14 = DAT_20000a14 + newVar2;\n      newPtr9 = newPtr5;\n      if (DAT_20000854 != (undefined *)0xffffffff) {\n        DAT_20000a14 = DAT_20000a14 + ((int)newPtr5 - (int)newPtr1);\n        newPtr9 = DAT_20000854;\n      }\n      DAT_20000854 = newPtr9;\n      newVar6 = (uint)newPtr5 & 7;\n      if (newVar6 == 0) {\n        newVar4 = 0x1000;\n      }\n      else {\n        newPtr5 = newPtr5 + (8 - newVar6);\n        newVar4 = 0x1008 - newVar6;\n      }\n      newVar4 = newVar4 - ((uint)(newPtr5 + newVar2) & 0xfff);\n      newVar14 = updateDataConditionally(result,newVar4);\n      if (newVar14 == -1) {\n        newVar2 = 1;\n        newVar4 = 0;\n      }\n      else {\n        newVar2 = (newVar14 - (int)newPtr5) + newVar4 | 1;\n      }\n      newPtr9 = DAT_20000a14 + newVar4;\n      DAT_20000454 = newPtr5;\n      DAT_20000a14 = newPtr9;\n      *(uint *)(newPtr5 + 4) = newVar2;\n      if (newPtr10 != &DAT_2000044c) {\n        if (newSize < 0x10) {\n          *(undefined4 *)(newPtr5 + 4) = 1;\n          goto LAB_08008eee;\n        }\n        newSize = newSize - 0xc & 0xfffffff8;\n        *(uint *)(newPtr10 + 4) = *(uint *)(newPtr10 + 4) & 1 | newSize;\n        *(undefined4 *)(newPtr10 + newSize + 4) = 5;\n        *(undefined4 *)(newPtr10 + newSize + 8) = 5;\n        if (0xf < newSize) {\n          initializeMemory(result,newPtr10 + 8);\n          newPtr9 = DAT_20000a14;\n        }\n      }\n    }\n    if (DAT_20000a3c < newPtr9) {\n      DAT_20000a3c = newPtr9;\n    }\n    newSize = *(uint *)(DAT_20000454 + 4);\n    if (DAT_20000a40 < newPtr9) {\n      DAT_20000a40 = newPtr9;\n    }\n  }\n  newVar2 = (newSize & 0xfffffffc) - newVar13;\n  if ((newVar13 <= (newSize & 0xfffffffc)) && (0xf < (int)newVar2)) {\nLAB_08008dac:\n    newPtr10 = DAT_20000454 + newVar13;\n    *(uint *)(DAT_20000454 + 4) = newVar13 | 1;\n    newPtr11 = (int *)(DAT_20000454 + 8);\n    DAT_20000454 = newPtr10;\n    *(uint *)(newPtr10 + 4) = newVar2 | 1;\n    initializeData2(result);\n    return newPtr11;\n  }\nLAB_08008eee:\n  initializeData2(result);\n  return (int *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08008af8": "allocate_memory_08008af8",
                "param_1": "result",
                "param_2": "size",
                "uVar12": "newSize",
                "puVar1": "newPtr1",
                "uVar2": "newVar2",
                "uVar3": "newVar3",
                "iVar4": "newVar4",
                "puVar5": "newPtr5",
                "uVar6": "newVar6",
                "uVar7": "newVar7",
                "puVar8": "newPtr8",
                "puVar9": "newPtr9",
                "puVar10": "newPtr10",
                "piVar11": "newPtr11",
                "uVar13": "newVar13",
                "iVar14": "newVar14",
                "puVar15": "newPtr15",
                "puVar16": "newPtr16",
                "initialize_data_080090a8": "initializeData1",
                "initialize_data_080090b4": "initializeData2",
                "update_data_conditionally_08009744": "updateDataConditionally",
                "initialize_memory_080088ec": "initializeMemory"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_08009adc",
                "FUN_080097cc",
                "FUN_08009980"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_08009744",
                "FUN_080090b4",
                "FUN_080088ec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800901c": {
            "entrypoint": "0x0800901c",
            "current_name": "find_byte_sequence_0800901c",
            "code": "\nuint * find_byte_sequence_0800901c(uint *input_array,uint byte_to_find,uint array_size)\n\n{\n  uint temp;\n  uint combined_value;\n  uint *current_ptr;\n  uint masked_byte;\n  bool is_empty;\n  \n  masked_byte = byte_to_find & 0xff;\n  if (((uint)input_array & 3) == 0) {\nLAB_0800904a:\n    if (3 < array_size) {\n      combined_value = (byte_to_find & 0xff) << 8 | masked_byte;\n      current_ptr = input_array;\n      do {\n        temp = *current_ptr ^ (combined_value | combined_value << 0x10);\n        input_array = current_ptr + 1;\n        if ((temp + 0xfefefeff & ~temp & 0x80808080) != 0) goto LAB_08009050;\n        array_size = array_size - 4;\n        current_ptr = input_array;\n      } while (3 < array_size);\n    }\n    current_ptr = input_array;\n    if (array_size == 0) {\n      input_array = (uint *)0x0;\n    }\n    else {\nLAB_08009050:\n      input_array = current_ptr;\n      if (*(byte *)input_array != masked_byte) {\n        current_ptr = (uint *)(array_size + (int)input_array);\n        do {\n          input_array = (uint *)((int)input_array + 1);\n          if (current_ptr == input_array) goto LAB_0800906c;\n        } while (*(byte *)input_array != masked_byte);\n      }\n    }\n  }\n  else {\n    combined_value = array_size - 1;\n    if (array_size == 0) {\nLAB_0800906c:\n      input_array = (uint *)0x0;\n    }\n    else if (*(byte *)input_array != masked_byte) {\n      current_ptr = (uint *)((int)input_array + 1);\n      do {\n        input_array = current_ptr;\n        array_size = combined_value;\n        if (((uint)input_array & 3) == 0) goto LAB_0800904a;\n        is_empty = combined_value == 0;\n        combined_value = combined_value - 1;\n        if (is_empty) goto LAB_0800906c;\n        current_ptr = (uint *)((int)input_array + 1);\n      } while (*(byte *)input_array != masked_byte);\n    }\n  }\n  return input_array;\n}\n\n",
            "renaming": {
                "FUN_0800901c": "find_byte_sequence_0800901c",
                "param_1": "input_array",
                "param_2": "byte_to_find",
                "param_3": "array_size",
                "uVar1": "temp",
                "uVar2": "combined_value",
                "puVar3": "current_ptr",
                "uVar4": "masked_byte",
                "bVar5": "is_empty"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090a8": {
            "entrypoint": "0x080090a8",
            "current_name": "initialize_data_080090a8",
            "code": "\nvoid initialize_data_080090a8(void)\n\n{\n  FUNC_08008af0(&DAT_20000bfc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090a8": "initialize_data_080090a8"
            },
            "calling": [
                "FUN_08009adc",
                "FUN_080088ec",
                "FUN_0800884c",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_08008af0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090b4": {
            "entrypoint": "0x080090b4",
            "current_name": "initialize_data_080090b4",
            "code": "\nvoid initializeData_080090b4(void)\n\n{\n  FUNC_08008af4(&DAT_20000bfc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090b4": "initialize_data_080090b4"
            },
            "calling": [
                "FUN_08009adc",
                "FUN_080088ec",
                "FUN_0800884c",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_08008af4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090c0": {
            "entrypoint": "0x080090c0",
            "current_name": "initialize_memory_080090c0",
            "code": "\nundefined4 * initializeMemory_080090c0(int memoryPointer,uint index)\n\n{\n  undefined4 *pointer;\n  int dataOffset;\n  \n  dataOffset = *(int *)(memoryPointer + 0x4c);\n  if (dataOffset == 0) {\n    dataOffset = allocate_and_initialize_memory_08009980(memoryPointer,4,0x21);\n    *(int *)(memoryPointer + 0x4c) = dataOffset;\n    if (dataOffset == 0) {\n      return (undefined4 *)0x0;\n    }\n  }\n  pointer = *(undefined4 **)(dataOffset + index * 4);\n  if (pointer == (undefined4 *)0x0) {\n    dataOffset = 1 << (index & 0xff);\n    pointer = (undefined4 *)allocate_and_initialize_memory_08009980(memoryPointer,1,(dataOffset + 5) * 4);\n    if (pointer == (undefined4 *)0x0) {\n      return (undefined4 *)0x0;\n    }\n    pointer[1] = index;\n    pointer[2] = dataOffset;\n  }\n  else {\n    *(undefined4 *)(dataOffset + index * 4) = *pointer;\n  }\n  pointer[3] = 0;\n  pointer[4] = 0;\n  return pointer;\n}\n\n",
            "renaming": {
                "FUN_080090c0": "initialize_memory_080090c0",
                "param_1": "memoryPointer",
                "param_2": "index",
                "puVar1": "pointer",
                "iVar2": "dataOffset"
            },
            "calling": [
                "FUN_08009244",
                "FUN_08009530",
                "FUN_08009630",
                "FUN_08009120",
                "FUN_080093a4",
                "FUN_08009258",
                "FUN_08009444",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08009980"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800910c": {
            "entrypoint": "0x0800910c",
            "current_name": "update_data_0800910c",
            "code": "\nvoid updateData_0800910c(int data,undefined4 *newData)\n\n{\n  int dataOffset;\n  \n  if (newData != (undefined4 *)0x0) {\n    dataOffset = *(int *)(data + 0x4c);\n    *newData = *(undefined4 *)(dataOffset + newData[1] * 4);\n    *(undefined4 **)(dataOffset + newData[1] * 4) = newData;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800910c": "update_data_0800910c",
                "param_1": "data",
                "param_2": "newData",
                "iVar1": "dataOffset"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009120": {
            "entrypoint": "0x08009120",
            "current_name": "transform_data_08009120",
            "code": "\nundefined4 * transformData_08009120(int inputSize,undefined4 *inputArray,int multiplier,uint initialValue)\n\n{\n  undefined4 *outputArray;\n  uint carry;\n  int arraySize;\n  uint *sourceArray;\n  int counter;\n  \n  counter = 0;\n  arraySize = inputArray[4];\n  sourceArray = inputArray + 5;\n  do {\n    counter = counter + 1;\n    initialValue = multiplier * (*sourceArray & 0xffff) + initialValue;\n    carry = multiplier * (*sourceArray >> 0x10) + (initialValue >> 0x10);\n    *sourceArray = (initialValue & 0xffff) + carry * 0x10000;\n    initialValue = carry >> 0x10;\n    sourceArray = sourceArray + 1;\n  } while (counter < arraySize);\n  outputArray = inputArray;\n  if (initialValue != 0) {\n    if ((int)inputArray[2] <= arraySize) {\n      outputArray = (undefined4 *)initialize_memory_080090c0(inputSize,inputArray[1] + 1);\n      copy_memory_08001084(outputArray + 3,inputArray + 3,(inputArray[4] + 2) * 4);\n      counter = *(int *)(inputSize + 0x4c);\n      *inputArray = *(undefined4 *)(counter + inputArray[1] * 4);\n      *(undefined4 **)(counter + inputArray[1] * 4) = inputArray;\n    }\n    outputArray[arraySize + 5] = initialValue;\n    outputArray[4] = arraySize + 1;\n  }\n  return outputArray;\n}\n\n",
            "renaming": {
                "FUN_08009120": "transform_data_08009120",
                "param_1": "inputSize",
                "param_2": "inputArray",
                "param_3": "multiplier",
                "param_4": "initialValue",
                "puVar1": "outputArray",
                "uVar2": "carry",
                "iVar3": "arraySize",
                "puVar4": "sourceArray",
                "iVar5": "counter"
            },
            "calling": [
                "FUN_080093a4",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08001084",
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091a4": {
            "entrypoint": "0x080091a4",
            "current_name": "count_leading_zeros_080091a4",
            "code": "\nint countLeadingZeros_080091a4(uint input)\n\n{\n  int leadingZerosCount;\n  \n  if ((input & 0xffff0000) == 0) {\n    input = input << 0x10;\n    leadingZerosCount = 0x10;\n  }\n  else {\n    leadingZerosCount = 0;\n  }\n  if ((input & 0xff000000) == 0) {\n    input = input << 8;\n    leadingZerosCount = leadingZerosCount + 8;\n  }\n  if ((input & 0xf0000000) == 0) {\n    input = input << 4;\n    leadingZerosCount = leadingZerosCount + 4;\n  }\n  if ((input & 0xc0000000) == 0) {\n    input = input << 2;\n    leadingZerosCount = leadingZerosCount + 2;\n  }\n  if (-1 < (int)input) {\n    if ((int)(input << 1) < 0) {\n      return leadingZerosCount + 1;\n    }\n    leadingZerosCount = 0x20;\n  }\n  return leadingZerosCount;\n}\n\n",
            "renaming": {
                "FUN_080091a4": "count_leading_zeros_080091a4",
                "param_1": "input",
                "iVar1": "leadingZerosCount"
            },
            "calling": [
                "FUN_08009630",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091e4": {
            "entrypoint": "0x080091e4",
            "current_name": "count_trailing_zeros_080091e4",
            "code": "\nint countTrailingZeros_080091e4(uint *num)\n\n{\n  int count;\n  uint temp;\n  \n  temp = *num;\n  if ((temp & 7) == 0) {\n    if ((temp & 0xffff) == 0) {\n      temp = temp >> 0x10;\n      count = 0x10;\n    }\n    else {\n      count = 0;\n    }\n    if ((temp & 0xff) == 0) {\n      temp = temp >> 8;\n      count = count + 8;\n    }\n    if ((temp & 0xf) == 0) {\n      temp = temp >> 4;\n      count = count + 4;\n    }\n    if ((temp & 3) == 0) {\n      temp = temp >> 2;\n      count = count + 2;\n    }\n    if (-1 < (int)(temp << 0x1f)) {\n      temp = temp >> 1;\n      if (temp == 0) {\n        return 0x20;\n      }\n      count = count + 1;\n    }\n    *num = temp;\n    return count;\n  }\n  if ((int)(temp << 0x1f) < 0) {\n    return 0;\n  }\n  if (-1 < (int)(temp << 0x1e)) {\n    *num = temp >> 2;\n    return 2;\n  }\n  *num = temp >> 1;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080091e4": "count_trailing_zeros_080091e4",
                "param_1": "num",
                "iVar1": "count",
                "uVar2": "temp"
            },
            "calling": [
                "FUN_08009630"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009244": {
            "entrypoint": "0x08009244",
            "current_name": "initialize_memory_and_set_values_08009244",
            "code": "\nvoid initializeMemoryAndSetValues_08009244(undefined4 memorySize,undefined4 parameterValue)\n\n{\n  int memoryPtr;\n  \n  memoryPtr = initialize_memory_080090c0(memorySize,1);\n  *(undefined4 *)(memoryPtr + 0x10) = 1;\n  *(undefined4 *)(memoryPtr + 0x14) = parameterValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009244": "initialize_memory_and_set_values_08009244",
                "param_1": "memorySize",
                "param_2": "parameterValue",
                "iVar1": "memoryPtr"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009258": {
            "entrypoint": "0x08009258",
            "current_name": "initialize_memory_08009258",
            "code": "\nvoid initializeMemory_08009258(undefined4 param1,int input1,int input2)\n\n{\n  uint *ptr1;\n  uint *ptr2;\n  int temp1;\n  uint temp2;\n  uint *ptr3;\n  uint temp3;\n  uint *ptr4;\n  uint temp4;\n  int temp5;\n  int temp6;\n  uint temp7;\n  int temp8;\n  int temp9;\n  uint *ptr5;\n  uint *ptr6;\n  uint *ptr7;\n  uint *ptr8;\n  uint *ptr9;\n  \n  temp8 = *(int *)(input1 + 0x10);\n  temp5 = *(int *)(input2 + 0x10);\n  temp6 = temp5;\n  temp9 = input1;\n  if (temp8 < temp5) {\n    temp6 = temp8;\n    temp8 = temp5;\n    temp9 = input2;\n    input2 = input1;\n  }\n  temp5 = temp8 + temp6;\n  temp1 = *(int *)(temp9 + 4);\n  if (*(int *)(temp9 + 8) < temp5) {\n    temp1 = temp1 + 1;\n  }\n  temp1 = initialize_memory_080090c0(param1,temp1);\n  ptr9 = (uint *)(temp1 + 0x14);\n  ptr8 = ptr9 + temp5;\n  for (ptr3 = ptr9; ptr3 < ptr8; ptr3 = ptr3 + 1) {\n    *ptr3 = 0;\n  }\n  temp3 = input2 + 0x14;\n  temp7 = temp3 + temp6 * 4;\n  ptr3 = (uint *)(temp9 + 0x14);\n  if (temp3 < temp7) {\n    ptr4 = (uint *)(temp3 + ((temp7 - input2) - 0x15 & 0xfffffffc));\n    ptr7 = (uint *)(input2 + 0x10);\n    do {\n      while( true ) {\n        ptr7 = ptr7 + 1;\n        temp3 = *ptr7 & 0xffff;\n        if (temp3 != 0) break;\n        temp3 = *ptr7 >> 0x10;\n        if (temp3 == 0) goto LAB_080092d2;\nLAB_0800932c:\n        temp4 = *ptr9;\n        temp2 = 0;\n        ptr1 = ptr3;\n        ptr5 = ptr9;\n        temp7 = temp4;\n        do {\n          ptr6 = ptr5;\n          temp2 = temp2 + temp3 * *(ushort *)ptr1 + (temp7 >> 0x10);\n          *ptr6 = temp4 & 0xffff | temp2 * 0x10000;\n          ptr2 = ptr1 + 1;\n          temp7 = ptr6[1];\n          temp4 = temp3 * (*ptr1 >> 0x10) + (temp7 & 0xffff) + (temp2 >> 0x10);\n          temp2 = temp4 >> 0x10;\n          ptr1 = ptr2;\n          ptr5 = ptr6 + 1;\n        } while (ptr2 < ptr3 + temp8);\n        ptr6[1] = temp4;\n        ptr9 = ptr9 + 1;\n        if (ptr4 == ptr7) goto LAB_0800937a;\n      }\n      temp7 = 0;\n      ptr1 = ptr9;\n      ptr5 = ptr3;\n      do {\n        ptr2 = ptr1;\n        ptr6 = ptr5 + 1;\n        temp4 = temp3 * (*ptr5 & 0xffff) + (*ptr2 & 0xffff) + temp7;\n        temp2 = temp3 * (*ptr5 >> 0x10) + (*ptr2 >> 0x10) + (temp4 >> 0x10);\n        temp7 = temp2 >> 0x10;\n        *ptr2 = temp4 & 0xffff | temp2 * 0x10000;\n        ptr1 = ptr2 + 1;\n        ptr5 = ptr6;\n      } while (ptr6 < ptr3 + temp8);\n      ptr2[1] = temp7;\n      temp3 = *ptr7 >> 0x10;\n      if (temp3 != 0) goto LAB_0800932c;\nLAB_080092d2:\n      ptr9 = ptr9 + 1;\n    } while (ptr4 != ptr7);\n  }\nLAB_0800937a:\n  if (0 < temp5) {\n    temp3 = ptr8[-1];\n    ptr8 = ptr8 + -1;\n    while ((temp3 == 0 && (temp5 = temp5 + -1, temp5 != 0))) {\n      ptr8 = ptr8 + -1;\n      temp3 = *ptr8;\n    }\n  }\n  *(int *)(temp1 + 0x10) = temp5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009258": "initialize_memory_08009258",
                "param_1": "param1",
                "param_2": "input1",
                "param_3": "input2",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "iVar3": "temp1",
                "uVar4": "temp2",
                "puVar5": "ptr3",
                "uVar6": "temp3",
                "puVar7": "ptr4",
                "uVar8": "temp4",
                "iVar9": "temp5",
                "iVar10": "temp6",
                "uVar11": "temp7",
                "iVar12": "temp8",
                "iVar13": "temp9",
                "puVar14": "ptr5",
                "puVar15": "ptr6",
                "puVar16": "ptr7",
                "puVar17": "ptr8",
                "puVar18": "ptr9"
            },
            "calling": [
                "FUN_080093a4",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080093a4": {
            "entrypoint": "0x080093a4",
            "current_name": "process_data_080093a4",
            "code": "\nundefined4 * process_data_080093a4(int data_ptr,undefined4 *output_ptr,uint data_size)\n\n{\n  int index;\n  int num_iterations;\n  undefined4 *temp_ptr;\n  undefined4 *memory_ptr;\n  \n  if ((data_size & 3) != 0) {\n    output_ptr = (undefined4 *)\n              transform_data_08009120(data_ptr,output_ptr,*(undefined4 *)(&DAT_0800a070 + ((data_size & 3) - 1) * 4),\n                           0);\n  }\n  num_iterations = (int)data_size >> 2;\n  if (num_iterations != 0) {\n    memory_ptr = *(undefined4 **)(data_ptr + 0x48);\n    if (memory_ptr == (undefined4 *)0x0) {\n      memory_ptr = (undefined4 *)initialize_memory_080090c0(data_ptr,1);\n      memory_ptr[4] = 1;\n      memory_ptr[5] = 0x271;\n      *(undefined4 **)(data_ptr + 0x48) = memory_ptr;\n      *memory_ptr = 0;\n    }\n    temp_ptr = output_ptr;\n    if (num_iterations << 0x1f < 0) goto LAB_080093d2;\nLAB_080093c4:\n    num_iterations = num_iterations >> 1;\n    temp_ptr = memory_ptr;\n    if (num_iterations != 0) {\n      while( true ) {\n        memory_ptr = (undefined4 *)*temp_ptr;\n        if (memory_ptr == (undefined4 *)0x0) {\n          memory_ptr = (undefined4 *)initialize_memory_08009258(data_ptr,temp_ptr,temp_ptr);\n          *temp_ptr = memory_ptr;\n          *memory_ptr = 0;\n        }\n        temp_ptr = output_ptr;\n        if (-1 < num_iterations << 0x1f) break;\nLAB_080093d2:\n        output_ptr = (undefined4 *)initialize_memory_08009258(data_ptr,temp_ptr,memory_ptr);\n        if (temp_ptr == (undefined4 *)0x0) break;\n        index = *(int *)(data_ptr + 0x4c);\n        num_iterations = num_iterations >> 1;\n        *temp_ptr = *(undefined4 *)(index + temp_ptr[1] * 4);\n        *(undefined4 **)(index + temp_ptr[1] * 4) = temp_ptr;\n        temp_ptr = memory_ptr;\n        if (num_iterations == 0) {\n          return output_ptr;\n        }\n      }\n      goto LAB_080093c4;\n    }\n  }\n  return output_ptr;\n}\n\n",
            "renaming": {
                "FUN_080093a4": "process_data_080093a4",
                "param_1": "data_ptr",
                "param_2": "output_ptr",
                "param_3": "data_size",
                "iVar1": "index",
                "iVar2": "num_iterations",
                "puVar3": "temp_ptr",
                "puVar4": "memory_ptr"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08009120",
                "FUN_08009258",
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009444": {
            "entrypoint": "0x08009444",
            "current_name": "initialize_memory_08009444",
            "code": "\nvoid initializeMemory_08009444(int input,undefined4 *parameters,uint size)\n\n{\n  int temp1;\n  int temp2;\n  int temp3;\n  undefined4 temp4;\n  int offset;\n  int temp5;\n  uint *destPointer;\n  uint *srcPointer;\n  uint *tempPointer2;\n  uint *tempPointer3;\n  int shiftAmount;\n  int size;\n  uint shiftedBits;\n  uint *tempPointer1;\n  \n  offset = parameters[4];\n  shiftAmount = (int)size >> 5;\n  size = shiftAmount + offset + 1;\n  temp3 = parameters[1];\n  temp2 = parameters[2];\n  if ((int)parameters[2] < size) {\n    do {\n      temp5 = temp2 * 2;\n      temp1 = temp2 * -2;\n      temp3 = temp3 + 1;\n      temp2 = temp5;\n    } while (size != temp5 && size + temp1 < 0 == SBORROW4(size,temp5));\n  }\n  temp2 = initializeMemory_08009444Block(input,temp3);\n  destPointer = (uint *)(temp2 + 0x14);\n  if (0 < shiftAmount) {\n    tempPointer3 = destPointer + shiftAmount;\n    srcPointer = destPointer;\n    do {\n      tempPointer1 = srcPointer + 1;\n      *srcPointer = 0;\n      destPointer = tempPointer3;\n      srcPointer = tempPointer1;\n    } while (tempPointer1 != tempPointer3);\n  }\n  temp3 = parameters[4];\n  srcPointer = parameters + 5;\n  size = size & 0x1f;\n  if (size == 0) {\n    destPointer = destPointer + -1;\n    tempPointer3 = srcPointer;\n    do {\n      tempPointer1 = tempPointer3 + 1;\n      destPointer = destPointer + 1;\n      *destPointer = *tempPointer3;\n      tempPointer3 = tempPointer1;\n    } while (tempPointer1 < srcPointer + temp3);\n  }\n  else {\n    shiftedBits = 0;\n    tempPointer3 = srcPointer;\n    do {\n      tempPointer1 = destPointer;\n      *tempPointer1 = *tempPointer3 << size | shiftedBits;\n      tempPointer2 = tempPointer3 + 1;\n      shiftedBits = *tempPointer3 >> (0x20 - size & 0xff);\n      destPointer = tempPointer1 + 1;\n      tempPointer3 = tempPointer2;\n    } while (tempPointer2 < srcPointer + temp3);\n    tempPointer1[1] = shiftedBits;\n    if (shiftedBits != 0) {\n      size = shiftAmount + offset + 2;\n    }\n  }\n  offset = *(int *)(input + 0x4c);\n  temp3 = parameters[1];\n  temp4 = *(undefined4 *)(offset + temp3 * 4);\n  *(int *)(temp2 + 0x10) = size + -1;\n  *parameters = temp4;\n  *(undefined4 **)(offset + temp3 * 4) = parameters;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009444": "initialize_memory_08009444",
                "param_1": "input",
                "param_2": "parameters",
                "param_3": "size",
                "iVar1": "temp1",
                "iVar2": "temp2",
                "iVar3": "temp3",
                "uVar4": "temp4",
                "iVar5": "offset",
                "iVar6": "temp5",
                "puVar7": "destPointer",
                "puVar8": "srcPointer",
                "puVar9": "tempPointer1",
                "puVar10": "tempPointer2",
                "puVar11": "tempPointer3",
                "iVar12": "shiftAmount",
                "iVar13": "size",
                "uVar14": "shiftedBits",
                "initialize_memory_080090c0": "initializeMemoryBlock"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080094f8": {
            "entrypoint": "0x080094f8",
            "current_name": "compare_arrays_080094f8",
            "code": "\nint compareArrays_080094f8(int array1,int array2)\n\n{\n  int difference;\n  uint *ptr2;\n  int length;\n  uint *ptr1;\n  \n  length = *(int *)(array2 + 0x10);\n  difference = *(int *)(array1 + 0x10) - length;\n  if (difference == 0) {\n    ptr2 = (uint *)(array2 + 0x14 + length * 4);\n    ptr1 = (uint *)(array1 + 0x14) + length;\n    do {\n      ptr1 = ptr1 + -1;\n      ptr2 = ptr2 + -1;\n      if (*ptr1 != *ptr2) {\n        if (*ptr2 <= *ptr1) {\n          return 1;\n        }\n        return -1;\n      }\n    } while ((uint *)(array1 + 0x14) < ptr1);\n  }\n  return difference;\n}\n\n",
            "renaming": {
                "FUN_080094f8": "compare_arrays_080094f8",
                "param_1": "array1",
                "param_2": "array2",
                "iVar1": "difference",
                "iVar3": "length",
                "puVar2": "ptr2",
                "puVar4": "ptr1"
            },
            "calling": [
                "FUN_080078c0",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009530": {
            "entrypoint": "0x08009530",
            "current_name": "reverse_and_initialize_memory_08009530",
            "code": "\nvoid reverseAndInitializeMemory_08009530(undefined4 inputFlag,uint *array1,uint *array2,undefined4 value)\n\n{\n  int memoryHandle;\n  uint *array1LastElemAddr;\n  uint array1Size;\n  uint tempValue;\n  undefined4 isEqual;\n  uint *memoryDest;\n  uint *array1Elem;\n  uint *array2Elem;\n  uint *array2ElemTemp;\n  uint *array1Iter;\n  int carry;\n  uint *array2Iter;\n  uint array2Size;\n  uint *array1ElemTemp;\n  \n  array1LastElemAddr = (uint *)array2[4];\n  array1Iter = array1 + 5;\n  array2Iter = array2 + 5;\n  array1Elem = array1Iter;\n  array2Elem = array1;\n  if ((uint *)array1[4] == array1LastElemAddr) {\n    memoryDest = array1Iter + (int)array1LastElemAddr;\n    array1LastElemAddr = array2Iter + (int)array1LastElemAddr;\n    while( true ) {\n      memoryDest = memoryDest + -1;\n      array1LastElemAddr = array1LastElemAddr + -1;\n      if (*memoryDest != *array1LastElemAddr) break;\n      if (memoryDest <= array1Iter) {\n        carry = initialize_memory_080090c0(inputFlag,0,memoryDest,array1LastElemAddr,value);\n        *(undefined4 *)(carry + 0x10) = 1;\n        *(undefined4 *)(carry + 0x14) = 0;\n        return;\n      }\n    }\n    isEqual = 0;\n    if (*array1LastElemAddr <= *memoryDest) goto LAB_08009578;\n  }\n  else if (-1 < (int)(uint *)array1[4] - (int)array1LastElemAddr) {\n    isEqual = 0;\n    memoryDest = array2;\n    goto LAB_08009578;\n  }\n  isEqual = 1;\n  memoryDest = array1Iter;\n  array1LastElemAddr = array1;\n  array1Elem = array2Iter;\n  array2Elem = array2;\n  array2 = array1;\n  array2Iter = array1Iter;\nLAB_08009578:\n  memoryHandle = initialize_memory_080090c0(inputFlag,array2Elem[1],memoryDest,array1LastElemAddr,value);\n  carry = 0;\n  array2Size = array2Elem[4];\n  array1Size = array2[4];\n  *(undefined4 *)(memoryHandle + 0xc) = isEqual;\n  array1Iter = array1Elem + array2Size;\n  array1LastElemAddr = (uint *)(memoryHandle + 0x14);\n  array2Elem = array2Iter;\n  do {\n    array1ElemTemp = array1Elem + 1;\n    array2ElemTemp = array2Elem + 1;\n    tempValue = ((*array1Elem & 0xffff) + carry) - (*array2Elem & 0xffff);\n    carry = ((*array1Elem >> 0x10) - (*array2Elem >> 0x10)) + ((int)tempValue >> 0x10);\n    tempValue = tempValue & 0xffff | carry * 0x10000;\n    memoryDest = array1LastElemAddr + 1;\n    *array1LastElemAddr = tempValue;\n    carry = carry >> 0x10;\n    array1LastElemAddr = memoryDest;\n    array1Elem = array1ElemTemp;\n    array2Elem = array2ElemTemp;\n  } while (array2ElemTemp < array2Iter + array1Size);\n  array1LastElemAddr = array1ElemTemp;\n  array1Elem = memoryDest;\n  if (array1ElemTemp < array1Iter) {\n    do {\n      array2Elem = array1LastElemAddr + 1;\n      array1Size = (*array1LastElemAddr & 0xffff) + carry;\n      carry = ((int)array1Size >> 0x10) + (*array1LastElemAddr >> 0x10);\n      tempValue = array1Size & 0xffff | carry * 0x10000;\n      *array1Elem = tempValue;\n      carry = carry >> 0x10;\n      array1LastElemAddr = array2Elem;\n      array1Elem = array1Elem + 1;\n    } while (array2Elem < array1Iter);\n    memoryDest = (uint *)((int)memoryDest + ((int)array1Iter + ~(uint)array1ElemTemp & 0xfffffffc) + 4);\n  }\n  memoryDest = memoryDest + -1;\n  while (tempValue == 0) {\n    memoryDest = memoryDest + -1;\n    array2Size = array2Size - 1;\n    tempValue = *memoryDest;\n  }\n  *(uint *)(memoryHandle + 0x10) = array2Size;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009530": "reverse_and_initialize_memory_08009530",
                "param_1": "inputFlag",
                "param_2": "array1",
                "param_3": "array2",
                "param_4": "value",
                "iVar1": "memoryHandle",
                "puVar2": "array1LastElemAddr",
                "uVar3": "array1Size",
                "uVar4": "tempValue",
                "uVar5": "isEqual",
                "puVar6": "memoryDest",
                "puVar7": "array1Elem",
                "puVar8": "array1ElemTemp",
                "puVar9": "array2Elem",
                "puVar10": "array2ElemTemp",
                "puVar11": "array1Iter",
                "puVar13": "array2Iter",
                "iVar12": "carry",
                "uVar14": "array2Size"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009630": {
            "entrypoint": "0x08009630",
            "current_name": "decompress_data_08009630",
            "code": "\nint decompress_data_08009630(undefined4 memory_start,undefined4 param_size,uint source_data,uint source_size,int *output_data,\n                int *output_size)\n\n{\n  int memory_handle;\n  uint bit_offset;\n  int trailing_zeros;\n  int count_type;\n  uint shifted_data;\n  uint count_type_flag;\n  undefined8 leading_zeros;\n  uint src_data_temp;\n  uint src_size_temp;\n  \n  memory_handle = initialize_memory_080090c0(memory_start,1);\n  count_type_flag = (source_size << 1) >> 0x15;\n  src_size_temp = source_size & 0xfffff;\n  if (count_type_flag != 0) {\n    src_size_temp = src_size_temp | 0x100000;\n  }\n  if (source_data == 0) {\n    trailing_zeros = count_trailing_zeros_080091e4(&src_size_temp);\n    count_type = 1;\n    bit_offset = trailing_zeros + 0x20;\n    *(undefined4 *)(memory_handle + 0x10) = 1;\n    *(uint *)(memory_handle + 0x14) = src_size_temp;\n  }\n  else {\n    src_data_temp = source_data;\n    bit_offset = count_trailing_zeros_080091e4(&src_data_temp);\n    if (bit_offset == 0) {\n      *(uint *)(memory_handle + 0x14) = src_data_temp;\n    }\n    else {\n      shifted_data = src_size_temp << (0x20 - bit_offset & 0xff);\n      src_size_temp = src_size_temp >> (bit_offset & 0xff);\n      *(uint *)(memory_handle + 0x14) = shifted_data | src_data_temp;\n    }\n    if (src_size_temp == 0) {\n      count_type = 1;\n    }\n    else {\n      count_type = 2;\n    }\n    *(uint *)(memory_handle + 0x18) = src_size_temp;\n    *(int *)(memory_handle + 0x10) = count_type;\n  }\n  if (count_type_flag == 0) {\n    *output_data = bit_offset - 0x432;\n    leading_zeros = count_leading_zeros_080091a4(*(undefined4 *)(memory_handle + count_type * 4 + 0x10));\n    *output_size = (int)((ulonglong)leading_zeros >> 0x20) * 0x20 - (int)leading_zeros;\n    return memory_handle;\n  }\n  *output_data = (count_type_flag - 0x433) + bit_offset;\n  *output_size = 0x35 - bit_offset;\n  return memory_handle;\n}\n\n",
            "renaming": {
                "FUN_08009630": "decompress_data_08009630",
                "param_1": "memory_start",
                "param_2": "param_size",
                "param_3": "source_data",
                "param_4": "source_size",
                "param_5": "output_data",
                "param_6": "output_size",
                "iVar1": "memory_handle",
                "uVar2": "bit_offset",
                "iVar3": "trailing_zeros",
                "iVar4": "count_type",
                "uVar5": "shifted_data",
                "uVar6": "count_type_flag",
                "uVar7": "leading_zeros",
                "local_20": "src_data_temp",
                "local_1c": "src_size_temp"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080091e4",
                "FUN_080091a4",
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080096e0": {
            "entrypoint": "0x080096e0",
            "current_name": "calculate_float_080096e0",
            "code": "\nundefined8 calculate_float_080096e0(uint input_float1,uint input_float2,int *output_integer,undefined4 input_constant)\n\n{\n  int result_code;\n  uint normalized_float2;\n  undefined8 concatenated_floats;\n  \n  concatenated_floats = CONCAT44(input_float2,input_float1);\n  result_code = 0;\n  normalized_float2 = input_float2 & 0x7fffffff;\n  *output_integer = 0;\n  if ((normalized_float2 < 0x7ff00000) && ((normalized_float2 | input_float1) != 0)) {\n    if (normalized_float2 < 0x100000) {\n      concatenated_floats = calculate_result_080004c8(input_float1,input_float2,0,0x43500000,input_constant);\n      result_code = -0x36;\n      normalized_float2 = (uint)((ulonglong)concatenated_floats >> 0x20) & 0x7fffffff;\n    }\n    input_float1 = (uint)concatenated_floats;\n    input_float2 = (uint)((ulonglong)concatenated_floats >> 0x20) & 0x800fffff | 0x3fe00000;\n    *output_integer = ((int)normalized_float2 >> 0x14) + -0x3fe + result_code;\n  }\n  return CONCAT44(input_float2,input_float1);\n}\n\n",
            "renaming": {
                "FUN_080096e0": "calculate_float_080096e0",
                "param_1": "input_float1",
                "param_2": "input_float2",
                "param_3": "output_integer",
                "param_4": "input_constant",
                "iVar1": "result_code",
                "uVar2": "normalized_float2",
                "uVar3": "concatenated_floats"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_080004c8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009744": {
            "entrypoint": "0x08009744",
            "current_name": "update_data_conditionally_08009744",
            "code": "\nvoid updateDataConditionally_08009744(int *outputParam,undefined4 inputParam)\n\n{\n  int conditionResult;\n  \n  DAT_20000c10 = 0;\n  conditionResult = update_data_based_on_condition_08005728(inputParam);\n  if ((conditionResult == -1) && (DAT_20000c10 != 0)) {\n    *outputParam = DAT_20000c10;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009744": "update_data_conditionally_08009744",
                "param_1": "outputParam",
                "param_2": "inputParam",
                "iVar1": "conditionResult"
            },
            "calling": [
                "FUN_0800884c",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_08005728"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009768": {
            "entrypoint": "0x08009768",
            "current_name": "copy_and_filter_bytes_08009768",
            "code": "\nvoid copy_and_filter_bytes_08009768(uint *src_ptr,uint *dest_ptr,uint size)\n\n{\n  char current_byte;\n  uint *src_ptr_temp;\n  uint *dest_ptr_temp;\n  uint current_word;\n  \n  if (((((uint)src_ptr | (uint)dest_ptr) & 3) == 0) &&\n     (dest_ptr_temp = src_ptr, src_ptr_temp = dest_ptr, 3 < size)) {\n    do {\n      dest_ptr = src_ptr_temp + 1;\n      current_word = *src_ptr_temp;\n      src_ptr = dest_ptr_temp;\n      if ((current_word + 0xfefefeff & ~current_word & 0x80808080) != 0) goto LAB_0800979c;\n      size = size - 4;\n      src_ptr = dest_ptr_temp + 1;\n      *dest_ptr_temp = current_word;\n      dest_ptr_temp = src_ptr;\n      src_ptr_temp = dest_ptr;\n    } while (3 < size);\n  }\n  src_ptr_temp = dest_ptr;\n  if (size != 0) {\nLAB_0800979c:\n    current_byte = *(char *)src_ptr_temp;\n    *(char *)src_ptr = current_byte;\n    while( true ) {\n      src_ptr = (uint *)((int)src_ptr + 1);\n      size = size - 1;\n      if (current_byte == '\\0') break;\n      if (size == 0) {\n        return;\n      }\n      src_ptr_temp = (uint *)((int)src_ptr_temp + 1);\n      current_byte = *(char *)src_ptr_temp;\n      *(char *)src_ptr = current_byte;\n    }\n    if (size != 0) {\n      src_ptr_temp = src_ptr;\n      do {\n        dest_ptr_temp = (uint *)((int)src_ptr_temp + 1);\n        *(char *)src_ptr_temp = '\\0';\n        src_ptr_temp = dest_ptr_temp;\n      } while (dest_ptr_temp != (uint *)(size + (int)src_ptr));\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009768": "copy_and_filter_bytes_08009768",
                "param_1": "src_ptr",
                "param_2": "dest_ptr",
                "param_3": "size",
                "cVar1": "current_byte",
                "puVar2": "src_ptr_temp",
                "puVar3": "dest_ptr_temp",
                "uVar4": "current_word"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080097cc": {
            "entrypoint": "0x080097cc",
            "current_name": "copy_and_update_memory_080097cc",
            "code": "\nundefined4 copy_and_update_memory_080097cc(undefined4 *destination,int *source,int *data)\n\n{\n  int destination_ptr;\n  uint source_length;\n  int allocated_memory_ptr;\n  int offset;\n  uint allocated_memory_size;\n  uint data_length;\n  undefined4 *current_data_ptr;\n  undefined4 *next_data_ptr;\n  undefined4 current_data_element;\n  \n  if (data[2] != 0) {\n    destination_ptr = *source;\n    allocated_memory_size = source[2];\n    next_data_ptr = (undefined4 *)*data;\n    do {\n      do {\n        current_data_ptr = next_data_ptr + 2;\n        current_data_element = *next_data_ptr;\n        data_length = next_data_ptr[1];\n        next_data_ptr = current_data_ptr;\n      } while (data_length == 0);\n      source_length = data_length;\n      if ((allocated_memory_size <= data_length) && (source_length = allocated_memory_size, (*(ushort *)(source + 3) & 0x480) != 0)) {\n        offset = destination_ptr - source[4];\n        allocated_memory_size = (source[5] * 3) / 2;\n        source_length = data_length + 1 + offset;\n        if (allocated_memory_size < source_length) {\n          allocated_memory_size = source_length;\n        }\n        if ((int)((uint)*(ushort *)(source + 3) << 0x15) < 0) {\n          allocated_memory_ptr = allocate_memory_08008af8(destination,allocated_memory_size);\n          if (allocated_memory_ptr == 0) {\nLAB_08009896:\n            *destination = 0xc;\n            *(ushort *)(source + 3) = *(ushort *)(source + 3) | 0x40;\n            data[1] = 0;\n            data[2] = 0;\n            return 0xffffffff;\n          }\n          copy_memory_08001084(allocated_memory_ptr,source[4],offset);\n          *(ushort *)(source + 3) = *(ushort *)(source + 3) & 0xfb7f | 0x80;\n        }\n        else {\n          allocated_memory_ptr = allocate_or_initialize_memory_08009adc(destination);\n          if (allocated_memory_ptr == 0) {\n            initialize_memory_080088ec(destination,source[4]);\n            goto LAB_08009896;\n          }\n        }\n        destination_ptr = allocated_memory_ptr + offset;\n        source[5] = allocated_memory_size;\n        source[4] = allocated_memory_ptr;\n        *source = destination_ptr;\n        source[2] = allocated_memory_size - offset;\n        source_length = data_length;\n      }\n      copy_memory_08009a18(destination_ptr,current_data_element,source_length);\n      offset = data[2];\n      allocated_memory_size = source[2] - source_length;\n      destination_ptr = *source + source_length;\n      source[2] = allocated_memory_size;\n      *source = destination_ptr;\n      data[2] = offset - data_length;\n    } while (offset - data_length != 0);\n  }\n  data[1] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080097cc": "copy_and_update_memory_080097cc",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "data",
                "iVar1": "destination_ptr",
                "uVar2": "source_length",
                "iVar3": "allocated_memory_ptr",
                "iVar4": "offset",
                "uVar5": "allocated_memory_size",
                "uVar6": "data_length",
                "puVar7": "current_data_ptr",
                "puVar8": "next_data_ptr",
                "uVar9": "current_data_element"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_08009a18",
                "FUN_08001084",
                "FUN_08009adc",
                "FUN_080088ec",
                "FUN_08008af8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080098c0": {
            "entrypoint": "0x080098c0",
            "current_name": "update_data_080098c0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08009906) */\n/* WARNING: Removing unreachable block (ram,0x08009912) */\n\nundefined4 updateData_080098c0(int condition,undefined4 data1,undefined4 data2,undefined4 data3)\n\n{\n  undefined *pointer;\n  undefined4 returnValue;\n  uint bitMask;\n  uint counter;\n  \n  FUNC_08008af0(DAT_20000448);\n  if (DAT_20000168 == (undefined *)0x0) {\n    DAT_20000168 = &DAT_2000016c;\n  }\n  pointer = DAT_20000168;\n  counter = *(uint *)(DAT_20000168 + 4);\n  if ((int)counter < 0x20) {\n    if (condition != 0) {\n      *(undefined4 *)(DAT_20000168 + counter * 4 + 0x88) = data2;\n      bitMask = 1 << (counter & 0xff);\n      *(uint *)(pointer + 0x188) = *(uint *)(pointer + 0x188) | bitMask;\n      *(undefined4 *)(pointer + counter * 4 + 0x108) = data3;\n      if (condition == 2) {\n        *(uint *)(pointer + 0x18c) = bitMask | *(uint *)(pointer + 0x18c);\n      }\n    }\n    *(uint *)(pointer + 4) = counter + 1;\n    returnValue = DAT_20000448;\n    *(undefined4 *)(pointer + (counter + 2) * 4) = data1;\n    FUNC_08008af4(returnValue);\n    returnValue = 0;\n  }\n  else {\n    FUNC_08008af4(DAT_20000448);\n    returnValue = 0xffffffff;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080098c0": "update_data_080098c0",
                "param_1": "condition",
                "param_2": "data1",
                "param_3": "data2",
                "param_4": "data3",
                "puVar1": "pointer",
                "uVar2": "returnValue",
                "uVar3": "bitMask",
                "uVar4": "counter"
            },
            "calling": [
                "FUN_080078a0"
            ],
            "called": [
                "FUN_08008af4",
                "FUN_08008af0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009980": {
            "entrypoint": "0x08009980",
            "current_name": "allocate_and_initialize_memory_08009980",
            "code": "\nundefined4 * allocate_and_initialize_memory_08009980(undefined4 size_of_element,int num_of_elements,int element_size)\n\n{\n  undefined4 *allocated_memory;\n  uint adjusted_size;\n  undefined4 *initialized_memory;\n  \n  allocated_memory = (undefined4 *)allocate_memory_08008af8(size_of_element,element_size * num_of_elements);\n  if (allocated_memory == (undefined4 *)0x0) {\n    return (undefined4 *)0x0;\n  }\n  adjusted_size = (allocated_memory[-1] & 0xfffffffc) - 4;\n  if (adjusted_size < 0x25) {\n    initialized_memory = allocated_memory;\n    if (0x13 < adjusted_size) {\n      *allocated_memory = 0;\n      allocated_memory[1] = 0;\n      if (0x1b < adjusted_size) {\n        allocated_memory[2] = 0;\n        allocated_memory[3] = 0;\n        if (adjusted_size == 0x24) {\n          allocated_memory[4] = 0;\n          allocated_memory[5] = 0;\n          initialized_memory = allocated_memory + 6;\n        }\n        else {\n          initialized_memory = allocated_memory + 4;\n        }\n        *initialized_memory = 0;\n        initialized_memory[1] = 0;\n        initialized_memory[2] = 0;\n        return allocated_memory;\n      }\n      initialized_memory = allocated_memory + 2;\n    }\n    *initialized_memory = 0;\n    initialized_memory[1] = 0;\n    initialized_memory[2] = 0;\n    return allocated_memory;\n  }\n  memset_aligned_08005d68(allocated_memory,0);\n  return allocated_memory;\n}\n\n",
            "renaming": {
                "FUN_08009980": "allocate_and_initialize_memory_08009980",
                "param_1": "size_of_element",
                "param_2": "num_of_elements",
                "param_3": "element_size",
                "puVar1": "allocated_memory",
                "uVar2": "adjusted_size",
                "puVar3": "initialized_memory"
            },
            "calling": [
                "FUN_080090c0"
            ],
            "called": [
                "FUN_08005d68",
                "FUN_08008af8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009a18": {
            "entrypoint": "0x08009a18",
            "current_name": "copy_memory_08009a18",
            "code": "\nvoid copyMemory_08009a18(undefined4 *destPtr,undefined4 *srcPtr,uint size)\n\n{\n  undefined4 *destPtrTemp;\n  undefined4 *srcPtrTemp;\n  int loopCounter;\n  undefined *destByte;\n  undefined4 *srcByte;\n  uint remainingSize;\n  uint alignedSize;\n  \n  if ((srcPtr < destPtr) && (srcPtrTemp = (undefined4 *)((int)srcPtr + size), destPtr < srcPtrTemp)) {\n    destByte = (undefined *)((int)destPtr + size);\n    if (size != 0) {\n      do {\n        srcPtrTemp = (undefined4 *)((int)srcPtrTemp + -1);\n        destByte = destByte + -1;\n        *destByte = *(undefined *)srcPtrTemp;\n      } while (srcPtr != srcPtrTemp);\n    }\n  }\n  else {\n    alignedSize = size;\n    if (0xf < size) {\n      if ((((uint)destPtr | (uint)srcPtr) & 3) != 0) goto LAB_08009abc;\n      srcPtrTemp = srcPtr + 4;\n      destPtrTemp = destPtr + 4;\n      do {\n        srcByte = srcPtrTemp + 4;\n        destPtrTemp[-4] = srcPtrTemp[-4];\n        destPtrTemp[-3] = srcPtrTemp[-3];\n        destPtrTemp[-2] = srcPtrTemp[-2];\n        destPtrTemp[-1] = srcPtrTemp[-1];\n        srcPtrTemp = srcByte;\n        destPtrTemp = destPtrTemp + 4;\n      } while (srcByte != (undefined4 *)((int)srcPtr + (size - 0x10 & 0xfffffff0) + 0x20));\n      loopCounter = (size - 0x10 >> 4) + 1;\n      alignedSize = size & 0xf;\n      srcPtr = srcPtr + loopCounter * 4;\n      destPtr = destPtr + loopCounter * 4;\n      if (3 < alignedSize) {\n        srcPtrTemp = destPtr + -1;\n        remainingSize = alignedSize;\n        destPtrTemp = srcPtr;\n        do {\n          remainingSize = remainingSize - 4;\n          srcPtrTemp = srcPtrTemp + 1;\n          *srcPtrTemp = *destPtrTemp;\n          destPtrTemp = destPtrTemp + 1;\n        } while (3 < remainingSize);\n        loopCounter = (alignedSize - 4 & 0xfffffffc) + 4;\n        destPtr = (undefined4 *)((int)destPtr + loopCounter);\n        srcPtr = (undefined4 *)((int)srcPtr + loopCounter);\n        alignedSize = size & 3;\n      }\n    }\n    size = alignedSize;\n    if (alignedSize != 0) {\nLAB_08009abc:\n      destByte = (undefined *)((int)destPtr + -1);\n      srcPtrTemp = srcPtr;\n      do {\n        destPtrTemp = (undefined4 *)((int)srcPtrTemp + 1);\n        destByte = destByte + 1;\n        *destByte = *(undefined *)srcPtrTemp;\n        srcPtrTemp = destPtrTemp;\n      } while (destPtrTemp != (undefined4 *)(size + (int)srcPtr));\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009a18": "copy_memory_08009a18",
                "param_1": "destPtr",
                "param_2": "srcPtr",
                "param_3": "size",
                "puVar1": "destPtrTemp",
                "puVar2": "srcPtrTemp",
                "iVar3": "loopCounter",
                "puVar4": "destByte",
                "puVar5": "srcByte",
                "uVar6": "remainingSize",
                "uVar7": "alignedSize"
            },
            "calling": [
                "FUN_08009adc",
                "FUN_080097cc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009adc": {
            "entrypoint": "0x08009adc",
            "current_name": "allocate_or_initialize_memory_08009adc",
            "code": "\nint * allocateOrInitializeMemory_08009adc(undefined4 *paramPtr,int *dataPtr,uint size)\n\n{\n  int *memoryPtr;\n  int tempVar1;\n  int *tempPtr1;\n  uint tempVar2;\n  int tempVar3;\n  uint dataSize;\n  int *tempPtr2;\n  uint alignedSize;\n  uint alignedDataSize;\n  uint totalSize;\n  int endPtr;\n  \n  if (dataPtr == (int *)0x0) {\n    tempPtr1 = (int *)allocate_memory_08008af8(paramPtr,size);\n    return tempPtr1;\n  }\n  initialize_data_080090a8();\n  dataSize = dataPtr[-1];\n  alignedDataSize = dataSize & 0xfffffffc;\n  tempPtr1 = dataPtr + -2;\n  if (size + 0xb < 0x17) {\n    alignedSize = 0x10;\n  }\n  else {\n    alignedSize = size + 0xb & 0xfffffff8;\n    if ((int)alignedSize < 0) goto LAB_08009b8e;\n  }\n  if (alignedSize < size) {\nLAB_08009b8e:\n    *paramPtr = 0xc;\n    return (int *)0x0;\n  }\n  endPtr = (int)tempPtr1 + alignedDataSize;\n  totalSize = alignedDataSize;\n  if ((int)alignedDataSize < (int)alignedSize) {\n    if (DAT_20000454 == endPtr) {\n      endPtr = (*(uint *)(DAT_20000454 + 4) & 0xfffffffc) + alignedDataSize;\n      if ((int)(alignedSize + 0x10) <= endPtr) {\n        DAT_20000454 = (int)tempPtr1 + alignedSize;\n        *(uint *)(DAT_20000454 + 4) = endPtr - alignedSize | 1;\n        dataPtr[-1] = alignedSize | dataPtr[-1] & 1U;\n        initialize_data_080090b4(paramPtr);\n        return dataPtr;\n      }\n      if (-1 < (int)(dataSize << 0x1f)) {\n        memoryPtr = (int *)((int)tempPtr1 - dataPtr[-2]);\n        dataSize = memoryPtr[1] & 0xfffffffc;\n        if ((int)(alignedSize + 0x10) <= (int)(endPtr + dataSize)) {\n          tempVar3 = memoryPtr[3];\n          tempPtr1 = memoryPtr + 2;\n          tempVar1 = *tempPtr1;\n          alignedDataSize = alignedDataSize - 4;\n          *(int *)(tempVar1 + 0xc) = tempVar3;\n          *(int *)(tempVar3 + 8) = tempVar1;\n          if (alignedDataSize < 0x25) {\n            tempVar1 = *dataPtr;\n            tempPtr2 = tempPtr1;\n            if (0x13 < alignedDataSize) {\n              memoryPtr[2] = tempVar1;\n              memoryPtr[3] = dataPtr[1];\n              tempVar1 = dataPtr[2];\n              if (alignedDataSize < 0x1c) {\n                dataPtr = dataPtr + 2;\n                tempPtr2 = memoryPtr + 4;\n              }\n              else {\n                memoryPtr[4] = tempVar1;\n                memoryPtr[5] = dataPtr[3];\n                tempVar1 = dataPtr[4];\n                if (alignedDataSize == 0x24) {\n                  memoryPtr[6] = tempVar1;\n                  memoryPtr[7] = dataPtr[5];\n                  tempVar1 = dataPtr[6];\n                  dataPtr = dataPtr + 6;\n                  tempPtr2 = memoryPtr + 8;\n                }\n                else {\n                  dataPtr = dataPtr + 4;\n                  tempPtr2 = memoryPtr + 6;\n                }\n              }\n            }\n            *tempPtr2 = tempVar1;\n            tempPtr2[1] = dataPtr[1];\n            tempPtr2[2] = dataPtr[2];\n          }\n          else {\n            copy_memory_08009a18(tempPtr1,dataPtr);\n          }\n          DAT_20000454 = (int)memoryPtr + alignedSize;\n          *(uint *)(DAT_20000454 + 4) = (endPtr + dataSize) - alignedSize | 1;\n          memoryPtr[1] = alignedSize | memoryPtr[1] & 1U;\n          initialize_data_080090b4(paramPtr);\n          return tempPtr1;\n        }\nLAB_08009bb0:\n        totalSize = alignedDataSize + dataSize;\n        if ((int)alignedSize <= (int)totalSize) {\n          tempVar3 = memoryPtr[3];\n          tempPtr2 = memoryPtr + 2;\n          tempVar1 = *tempPtr2;\n          *(int *)(tempVar1 + 0xc) = tempVar3;\n          endPtr = (int)memoryPtr + totalSize;\n          *(int *)(tempVar3 + 8) = tempVar1;\n          tempPtr1 = memoryPtr;\n          if (alignedDataSize - 4 < 0x25) goto LAB_08009bd0;\nLAB_08009d4c:\n          copy_memory_08009a18(tempPtr2,dataPtr);\n          dataPtr = tempPtr2;\n          goto LAB_08009c00;\n        }\n      }\n    }\n    else {\n      if (-1 < *(int *)((*(uint *)(endPtr + 4) & 0xfffffffe) + endPtr + 4) << 0x1f) {\n        tempVar2 = *(uint *)(endPtr + 4) & 0xfffffffc;\n        totalSize = alignedDataSize + tempVar2;\n        if ((int)totalSize < (int)alignedSize) {\n          if ((int)(dataSize << 0x1f) < 0) goto LAB_08009b36;\n          memoryPtr = (int *)((int)tempPtr1 - dataPtr[-2]);\n          dataSize = memoryPtr[1] & 0xfffffffc;\n          totalSize = tempVar2 + dataSize + alignedDataSize;\n          if ((int)totalSize < (int)alignedSize) goto LAB_08009bb0;\n          tempVar1 = *(int *)(endPtr + 8);\n          endPtr = *(int *)(endPtr + 0xc);\n          *(int *)(tempVar1 + 0xc) = endPtr;\n          *(int *)(endPtr + 8) = tempVar1;\n          tempPtr2 = memoryPtr + 2;\n          tempVar1 = *tempPtr2;\n          tempVar3 = memoryPtr[3];\n          *(int *)(tempVar1 + 0xc) = tempVar3;\n          endPtr = (int)memoryPtr + totalSize;\n          *(int *)(tempVar3 + 8) = tempVar1;\n          tempPtr1 = memoryPtr;\n          if (0x24 < alignedDataSize - 4) goto LAB_08009d4c;\nLAB_08009bd0:\n          alignedDataSize = alignedDataSize - 4;\n          tempVar1 = *dataPtr;\n          memoryPtr = tempPtr2;\n          if (0x13 < alignedDataSize) {\n            tempPtr1[2] = tempVar1;\n            tempPtr1[3] = dataPtr[1];\n            tempVar1 = dataPtr[2];\n            if (alignedDataSize < 0x1c) {\n              dataPtr = dataPtr + 2;\n              memoryPtr = tempPtr1 + 4;\n            }\n            else {\n              tempPtr1[4] = tempVar1;\n              tempPtr1[5] = dataPtr[3];\n              tempVar1 = dataPtr[4];\n              if (alignedDataSize == 0x24) {\n                tempPtr1[6] = tempVar1;\n                tempPtr1[7] = dataPtr[5];\n                tempVar1 = dataPtr[6];\n                dataPtr = dataPtr + 6;\n                memoryPtr = tempPtr1 + 8;\n              }\n              else {\n                dataPtr = dataPtr + 4;\n                memoryPtr = tempPtr1 + 6;\n              }\n            }\n          }\n          *memoryPtr = tempVar1;\n          memoryPtr[1] = dataPtr[1];\n          memoryPtr[2] = dataPtr[2];\n          dataPtr = tempPtr2;\n        }\n        else {\n          tempVar1 = *(int *)(endPtr + 8);\n          tempVar3 = *(int *)(endPtr + 0xc);\n          *(int *)(tempVar1 + 0xc) = tempVar3;\n          endPtr = (int)tempPtr1 + totalSize;\n          *(int *)(tempVar3 + 8) = tempVar1;\n        }\n        goto LAB_08009c00;\n      }\n      if (-1 < (int)(dataSize << 0x1f)) {\n        memoryPtr = (int *)((int)tempPtr1 - dataPtr[-2]);\n        dataSize = memoryPtr[1] & 0xfffffffc;\n        goto LAB_08009bb0;\n      }\n    }\nLAB_08009b36:\n    memoryPtr = (int *)allocate_memory_08008af8(paramPtr,size);\n    if (memoryPtr != (int *)0x0) {\n      if ((int *)((dataPtr[-1] & 0xfffffffeU) + (int)tempPtr1) == memoryPtr + -2) {\n        totalSize = alignedDataSize + (memoryPtr[-1] & 0xfffffffcU);\n        endPtr = (int)tempPtr1 + totalSize;\n        goto LAB_08009c00;\n      }\n      alignedDataSize = alignedDataSize - 4;\n      if (alignedDataSize < 0x25) {\n        endPtr = *dataPtr;\n        tempPtr1 = dataPtr;\n        tempPtr2 = memoryPtr;\n        if (0x13 < alignedDataSize) {\n          *memoryPtr = endPtr;\n          memoryPtr[1] = dataPtr[1];\n          if (alignedDataSize < 0x1c) {\n            endPtr = dataPtr[2];\n            tempPtr1 = dataPtr + 2;\n            tempPtr2 = memoryPtr + 2;\n          }\n          else {\n            memoryPtr[2] = dataPtr[2];\n            memoryPtr[3] = dataPtr[3];\n            if (alignedDataSize == 0x24) {\n              memoryPtr[4] = dataPtr[4];\n              memoryPtr[5] = dataPtr[5];\n              endPtr = dataPtr[6];\n              tempPtr1 = dataPtr + 6;\n              tempPtr2 = memoryPtr + 6;\n            }\n            else {\n              endPtr = dataPtr[4];\n              tempPtr1 = dataPtr + 4;\n              tempPtr2 = memoryPtr + 4;\n            }\n          }\n        }\n        *tempPtr2 = endPtr;\n        tempPtr2[1] = tempPtr1[1];\n        tempPtr2[2] = tempPtr1[2];\n      }\n      else {\n        copy_memory_08009a18(memoryPtr,dataPtr);\n      }\n      initialize_memory_080088ec(paramPtr,dataPtr);\n    }\n    initialize_data_080090b4(paramPtr);\n    dataPtr = memoryPtr;\n  }\n  else {\nLAB_08009c00:\n    if (totalSize - alignedSize < 0x10) {\n      tempPtr1[1] = tempPtr1[1] & 1U | totalSize;\n      *(uint *)(endPtr + 4) = *(uint *)(endPtr + 4) | 1;\n    }\n    else {\n      tempPtr1[1] = tempPtr1[1] & 1U | alignedSize;\n      *(uint *)((int)tempPtr1 + alignedSize + 4) = totalSize - alignedSize | 1;\n      *(uint *)(endPtr + 4) = *(uint *)(endPtr + 4) | 1;\n      initialize_memory_080088ec(paramPtr,(int)tempPtr1 + alignedSize + 8);\n    }\n    initialize_data_080090b4(paramPtr);\n  }\n  return dataPtr;\n}\n\n",
            "renaming": {
                "FUN_08009adc": "allocate_or_initialize_memory_08009adc",
                "param_1": "paramPtr",
                "param_2": "dataPtr",
                "param_3": "size",
                "piVar1": "memoryPtr",
                "iVar2": "tempVar1",
                "piVar3": "tempPtr1",
                "uVar4": "tempVar2",
                "iVar5": "tempVar3",
                "uVar6": "dataSize",
                "piVar7": "tempPtr2",
                "uVar8": "alignedSize",
                "uVar9": "alignedDataSize",
                "uVar10": "totalSize",
                "iVar11": "endPtr"
            },
            "calling": [
                "FUN_080097cc"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_08009a18",
                "FUN_080090b4",
                "FUN_080088ec",
                "FUN_08008af8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e68": {
            "entrypoint": "0x08009e68",
            "current_name": "FUNC_08009e68",
            "code": "\nvoid FUNC_08009e68(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e68": "FUNC_08009e68"
            },
            "calling": [
                "FUN_08005d20",
                "FUN_08000134",
                "FUN_08000110"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08009e74": {
            "entrypoint": "0x08009e74",
            "current_name": "FUNC_08009e74",
            "code": "\nvoid FUNC_08009e74(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e74": "FUNC_08009e74"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 151147,
    "layers": [
        [
            "FUN_08000110",
            "FUN_08000134",
            "FUN_08000158",
            "FUN_0800015c",
            "FUN_080003d4",
            "FUN_080003f4",
            "FUN_08000418",
            "FUN_080006a4",
            "FUN_0800088a",
            "FUN_080008fc",
            "FUN_080009fc",
            "FUN_08000aa4",
            "FUN_08000aa8",
            "FUN_08000c08",
            "FUN_08000c10",
            "FUN_08000cb8",
            "FUN_08000e20",
            "FUN_08000f68",
            "FUN_08001044",
            "FUN_08001084",
            "FUN_08001170",
            "FUN_0800119c",
            "FUN_0800121c",
            "FUN_0800157c",
            "FUN_080015a0",
            "FUN_080015b4",
            "FUN_080015fc",
            "FUN_08001618",
            "FUN_0800166c",
            "FUN_0800177c",
            "FUN_080017c4",
            "FUN_08001a80",
            "FUN_08002d3c",
            "FUN_08003440",
            "FUN_08003504",
            "FUN_08003568",
            "FUN_0800360c",
            "FUN_08003c94",
            "FUN_08003d60",
            "FUN_08003e38",
            "FUN_08003f18",
            "FUN_08003ff8",
            "FUN_080040a0",
            "FUN_08004104",
            "FUN_0800416a",
            "FUN_080041a8",
            "FUN_080041ea",
            "FUN_0800422e",
            "FUN_080042de",
            "FUN_08004e6c",
            "FUN_08005674",
            "FUN_08005780",
            "FUN_08005d14",
            "FUN_08005d20",
            "FUN_08005d68",
            "FUN_08005dfc",
            "FUN_08005e40",
            "FUN_08008ad4",
            "FUN_0800901c",
            "FUN_080090a8",
            "FUN_080090b4",
            "FUN_0800910c",
            "FUN_080091a4",
            "FUN_080091e4",
            "FUN_080094f8",
            "FUN_08009768",
            "FUN_080098c0",
            "FUN_08009a18"
        ],
        [
            "FUN_080004c8",
            "FUN_0800071c",
            "FUN_08000988",
            "FUN_08000fd0",
            "FUN_080011ec",
            "FUN_080016d0",
            "FUN_08001714",
            "FUN_0800172a",
            "FUN_08002ad8",
            "FUN_08002bb4",
            "FUN_08002c2e",
            "FUN_08002ca8",
            "FUN_08002d98",
            "FUN_08003518",
            "FUN_08003540",
            "FUN_080035a4",
            "FUN_08003640",
            "FUN_080036a8",
            "FUN_08003908",
            "FUN_08003a94",
            "FUN_08004436",
            "FUN_08004ae0",
            "FUN_08004e74",
            "FUN_08004f2c",
            "FUN_08004f60",
            "FUN_080055f4",
            "FUN_08005680",
            "FUN_08005728",
            "FUN_080078c0"
        ],
        [
            "FUN_08000978",
            "FUN_08000998",
            "FUN_080009ac",
            "FUN_080009c0",
            "FUN_08000fc8",
            "FUN_08000ff4",
            "FUN_08001762",
            "FUN_08001ab0",
            "FUN_08002640",
            "FUN_080027f4",
            "FUN_080046ec",
            "FUN_08004f3c",
            "FUN_080053b0",
            "FUN_08005500",
            "FUN_080096e0",
            "FUN_08009744"
        ],
        [
            "FUN_080009d4",
            "FUN_080009e8",
            "FUN_08001030",
            "FUN_0800151c",
            "FUN_08001ccc",
            "FUN_08001f6c",
            "FUN_0800438a",
            "FUN_08005348",
            "FUN_0800884c"
        ],
        [
            "FUN_080014f0",
            "FUN_08003260",
            "FUN_08004ea4",
            "FUN_08004ee8",
            "FUN_08005598",
            "FUN_080059f0",
            "FUN_080088ec"
        ],
        [
            "FUN_080052a0",
            "thunk_FUN_08005838",
            "FUN_08005838",
            "FUN_08008af8"
        ],
        [
            "FUN_08004bd8",
            "FUN_08004d78",
            "FUN_08009980",
            "FUN_08009adc"
        ],
        [
            "FUN_080049cc",
            "FUN_08004f78",
            "FUN_080090c0",
            "FUN_080097cc"
        ],
        [
            "FUN_080017b4",
            "FUN_080036f8",
            "FUN_0800491c",
            "FUN_08009120",
            "FUN_08009244",
            "FUN_08009258",
            "FUN_08009444",
            "FUN_08009530",
            "FUN_08009630"
        ],
        [
            "FUN_08005224",
            "FUN_08005704",
            "FUN_08005714",
            "FUN_080093a4"
        ],
        [
            "FUN_080079e8"
        ]
    ],
    "locked_functions": []
}