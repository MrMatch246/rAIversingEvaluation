{
    "functions": {
        "FUN_08000110": {
            "entrypoint": "0x08000110",
            "current_name": "initialize_completed_flag_08000110",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800011c) */\n\nundefined4 initializeCompletedFlag_08000110(undefined4 input)\n\n{\n  if ((char)completionFlag == '\\0') {\n    completionFlag._0_1_ = '\\x01';\n  }\n  return input;\n}\n\n",
            "renaming": {
                "FUN_08000110": "initialize_completed_flag_08000110",
                "param_1": "input",
                "completed_8655": "completionFlag"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000134": {
            "entrypoint": "0x08000134",
            "current_name": "concatenate_values_08000134",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800013a) */\n\nundefined8 concatenate_values_08000134(undefined4 value1,undefined4 value2)\n\n{\n  return CONCAT44(value2,value1);\n}\n\n",
            "renaming": {
                "FUN_08000134": "concatenate_values_08000134",
                "param_1": "value1",
                "param_2": "value2"
            },
            "calling": [
                "__libc_init_array",
                "__libc_fini_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000150": {
            "entrypoint": "0x08000150",
            "current_name": "add_with_offset_08000150",
            "code": "\nvoid addWithOffset_08000150(undefined4 result,uint input)\n\n{\n  addDouble(result,input ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000150": "add_with_offset_08000150",
                "param_1": "result",
                "param_2": "input",
                "__aeabi_dadd": "addDouble"
            },
            "calling": [],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000158": {
            "entrypoint": "0x08000158",
            "current_name": "calculate_xor_value_08000158",
            "code": "\nulonglong calculate_xor_value_08000158(uint input_value1,uint input_value2,uint input_value3,uint input_value4)\n\n{\n  int shift_amount1;\n  byte carry_value;\n  uint temp_value1;\n  uint shifted_input1;\n  uint shifted_input2;\n  uint shifted_input3;\n  uint shifted_input4;\n  int shift_amount2;\n  uint result1;\n  uint result2;\n  uint result3;\n  uint result4;\n  bool is_equal1;\n  bool is_equal2;\n  bool is_equal3;\n  \n  shifted_input3 = input_value4 ^ 0x80000000;\n  result1 = input_value2 << 1;\n  input_value4 = input_value4 << 1;\n  is_equal1 = ((input_value2 ^ shifted_input3) & 0x7fffffff) == 0;\n  is_equal2 = is_equal1 && input_value1 == input_value3;\n  if (!is_equal1 || input_value1 != input_value3) {\n    is_equal2 = (result1 | input_value1) == 0;\n  }\n  if (!is_equal2) {\n    is_equal2 = (input_value4 | input_value3) == 0;\n  }\n  shift_amount2 = (int)result1 >> 0x15;\n  if (!is_equal2) {\n    is_equal2 = shift_amount2 == -1;\n  }\n  shift_amount1 = (int)input_value4 >> 0x15;\n  if (!is_equal2) {\n    is_equal2 = shift_amount1 == -1;\n  }\n  if (is_equal2) {\n    if (shift_amount2 == -1 || shift_amount1 == -1) {\n      result1 = shifted_input3;\n      result3 = input_value3;\n      if (shift_amount2 == -1) {\n        result1 = input_value2;\n        result3 = input_value1;\n      }\n      if (shift_amount2 != -1 || shift_amount1 != -1) {\n        input_value3 = result3;\n        shifted_input3 = result1;\n      }\n      is_equal2 = (result3 | result1 << 0xc) == 0;\n      if (is_equal2) {\n        is_equal2 = (input_value3 | shifted_input3 << 0xc) == 0;\n      }\n      if (is_equal2) {\n        is_equal2 = result1 == shifted_input3;\n      }\n      if (!is_equal2) {\n        result1 = result1 | 0x80000;\n      }\n      return CONCAT44(result1,result3);\n    }\n    if (((input_value2 ^ shifted_input3) & 0x7fffffff) != 0 || input_value1 != input_value3) {\n      if ((result1 | input_value1) == 0) {\n        input_value1 = input_value3;\n        input_value2 = shifted_input3;\n      }\n      return CONCAT44(input_value2,input_value1);\n    }\n    if (input_value2 != shifted_input3) {\n      return 0;\n    }\n    if (result1 >> 0x15 == 0) {\n      is_equal2 = (input_value1 & 0x80000000) != 0;\n      shifted_input3 = input_value2 * 2 + (uint)is_equal2;\n      if (CARRY4(input_value2,input_value2) || CARRY4(input_value2 * 2,(uint)is_equal2)) {\n        shifted_input3 = shifted_input3 | 0x80000000;\n      }\n      return CONCAT44(shifted_input3,input_value1 << 1);\n    }\n    if (result1 < 0xffc00000) {\n      return CONCAT44(input_value2 + 0x100000,input_value1);\n    }\n    input_value2 = input_value2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(input_value2 | 0x7ff00000) << 0x20;\n  }\n  result1 = result1 >> 0x15;\n  input_value4 = input_value4 >> 0x15;\n  result3 = input_value4 - result1;\n  is_equal2 = result3 != 0;\n  if (input_value4 < result1) {\n    result3 = -result3;\n  }\n  result2 = input_value1;\n  shifted_input4 = input_value2;\n  if (is_equal2 && result1 <= input_value4) {\n    result1 = result1 + result3;\n    result2 = input_value3;\n    shifted_input4 = shifted_input3;\n    input_value3 = input_value1;\n    shifted_input3 = input_value2;\n  }\n  if (0x36 < result3) {\n    return CONCAT44(shifted_input4,result2);\n  }\n  shifted_input1 = shifted_input4 & 0xfffff | 0x100000;\n  if ((shifted_input4 & 0x80000000) != 0) {\n    is_equal2 = result2 != 0;\n    result2 = -result2;\n    shifted_input1 = -shifted_input1 - (uint)is_equal2;\n  }\n  shifted_input4 = shifted_input3 & 0xfffff | 0x100000;\n  if ((shifted_input3 & 0x80000000) != 0) {\n    is_equal2 = input_value3 != 0;\n    input_value3 = -input_value3;\n    shifted_input4 = -shifted_input4 - (uint)is_equal2;\n  }\n  if (result1 == result3) {\n    shifted_input4 = shifted_input4 ^ 0x100000;\n    if (result1 == 0) {\n      shifted_input1 = shifted_input1 ^ 0x100000;\n      result1 = 1;\n    }\n    else {\n      result3 = result3 - 1;\n    }\n  }\n  shifted_input3 = -result3 + 0x20;\n  if ((int)result3 < 0x21) {\n    result4 = input_value3 << (shifted_input3 & 0xff);\n    input_value3 = input_value3 >> (result3 & 0xff);\n    temp_value1 = result2 + input_value3;\n    shifted_input2 = shifted_input4 << (shifted_input3 & 0xff);\n    shifted_input3 = temp_value1 + shifted_input2;\n    shifted_input1 = shifted_input1 + CARRY4(result2,input_value3) + ((int)shifted_input4 >> (result3 & 0xff)) +\n            (uint)CARRY4(temp_value1,shifted_input2);\n  }\n  else {\n    result4 = shifted_input4 << (-result3 + 0x40 & 0xff);\n    if (input_value3 != 0) {\n      result4 = result4 | 2;\n    }\n    shifted_input4 = (int)shifted_input4 >> (result3 - 0x20 & 0xff);\n    shifted_input3 = result2 + shifted_input4;\n    shifted_input1 = shifted_input1 + ((int)shifted_input4 >> 0x1f) + (uint)CARRY4(result2,shifted_input4);\n  }\n  input_value2 = shifted_input1 & 0x80000000;\n  result3 = shifted_input1;\n  if ((int)shifted_input1 < 0) {\n    is_equal2 = result4 == 0;\n    result4 = -result4;\n    result3 = -shifted_input3;\n    shifted_input3 = -(uint)!is_equal2 - shifted_input3;\n    result3 = -(uint)(is_equal2 <= result3) - shifted_input1;\n  }\n  if (0xfffff < result3) {\n    result2 = result1 - 1;\n    if (0x1fffff < result3) {\n      result2 = result3 & 1;\n      result3 = result3 >> 1;\n      carry_value = (byte)shifted_input3;\n      shifted_input3 = (uint)(result2 != 0) << 0x1f | shifted_input3 >> 1;\n      result4 = (uint)(carry_value & 1) << 0x1f | result4 >> 1;\n      result2 = result1;\n      if (0xffbfffff < result1 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    is_equal2 = 0x7fffffff < result4;\n    if (result4 == 0x80000000) {\n      is_equal2 = (shifted_input3 & 1) != 0;\n    }\n    return CONCAT44(result3 + result2 * 0x100000 + (uint)CARRY4(shifted_input3,(uint)is_equal2) | input_value2,\n                    shifted_input3 + is_equal2);\n  }\n  is_equal1 = (result4 & 0x80000000) != 0;\n  result4 = result4 << 1;\n  result2 = shifted_input3 * 2;\n  is_equal2 = CARRY4(shifted_input3,shifted_input3);\n  shifted_input3 = shifted_input3 * 2 + (uint)is_equal1;\n  result3 = result3 * 2 + (uint)(is_equal2 || CARRY4(result2,(uint)is_equal1));\n  result2 = result1 - 2;\n  if ((result3 & 0x100000) != 0) goto LAB_08000268;\n  shifted_input4 = shifted_input3;\n  result1 = result3;\n  if (result3 == 0) {\n    shifted_input4 = 0;\n    result1 = shifted_input3;\n  }\n  shift_amount2 = LZCOUNT(result1);\n  if (result3 == 0) {\n    shift_amount2 = shift_amount2 + 0x20;\n  }\n  result3 = shift_amount2 - 0xb;\n  is_equal3 = SBORROW4(result3,0x20);\n  shifted_input3 = shift_amount2 - 0x2b;\n  is_equal2 = (int)shifted_input3 < 0;\n  is_equal1 = shifted_input3 == 0;\n  if ((int)result3 < 0x20) {\n    is_equal3 = SCARRY4(shifted_input3,0xc);\n    shift_amount2 = shift_amount2 + -0x1f;\n    is_equal2 = shift_amount2 < 0;\n    is_equal1 = shift_amount2 == 0;\n    shifted_input3 = result3;\n    if (!is_equal1 && is_equal2 == is_equal3) {\n      shifted_input4 = result1 << (result3 & 0xff);\n      result1 = result1 >> (0xcU - shift_amount2 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_equal1 || is_equal2 != is_equal3) {\n    result4 = 0x20 - shifted_input3;\n  }\n  result1 = result1 << (shifted_input3 & 0xff);\n  if (is_equal1 || is_equal2 != is_equal3) {\n    result1 = result1 | shifted_input4 >> (result4 & 0xff);\n  }\n  if (is_equal1 || is_equal2 != is_equal3) {\n    shifted_input4 = shifted_input4 << (shifted_input3 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)result3 <= (int)result2) {\n    return CONCAT44(result1 + (result2 - result3) * 0x100000 | input_value2,shifted_input4);\n  }\n  shifted_input3 = ~(result2 - result3);\n  if ((int)shifted_input3 < 0x1f) {\n    shift_amount2 = shifted_input3 - 0x13;\n    if (shift_amount2 != 0 && shift_amount2 < 0 == SCARRY4(shifted_input3 - 0x1f,0xc)) {\n      return CONCAT44(shifted_input1,shifted_input4 >> (0x20 - (0xcU - shift_amount2) & 0xff) | result1 << (0xcU - shift_amount2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    shifted_input3 = shifted_input3 + 1;\n    return CONCAT44(input_value2 | result1 >> (shifted_input3 & 0xff),\n                    shifted_input4 >> (shifted_input3 & 0xff) | result1 << (0x20 - shifted_input3 & 0xff));\n  }\n  return CONCAT44(shifted_input1,result1 >> (shifted_input3 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000158": "calculate_xor_value_08000158",
                "param_1": "input_value1",
                "param_2": "input_value2",
                "param_3": "input_value3",
                "param_4": "input_value4",
                "iVar1": "shift_amount1",
                "bVar2": "carry_value",
                "uVar3": "temp_value1",
                "uVar4": "shifted_input1",
                "uVar5": "shifted_input2",
                "uVar6": "shifted_input3",
                "uVar7": "shifted_input4",
                "iVar8": "shift_amount2",
                "uVar9": "result1",
                "uVar10": "result2",
                "uVar11": "result3",
                "uVar12": "result4",
                "bVar13": "is_equal1",
                "bVar14": "is_equal2",
                "bVar15": "is_equal3"
            },
            "calling": [
                "_svfprintf_r",
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800015c": {
            "entrypoint": "0x0800015c",
            "current_name": "calculate_sum_product_0800015c",
            "code": "\nulonglong calculateSumProduct_0800015c(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int shiftValue1;\n  byte carry;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int shiftValue2;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  uint temp8;\n  uint temp9;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  \n  temp4 = input2 << 1;\n  temp6 = input4 << 1;\n  flag1 = ((input2 ^ input4) & 0x7fffffff) == 0;\n  flag2 = flag1 && input1 == input3;\n  if (!flag1 || input1 != input3) {\n    flag2 = (temp4 | input1) == 0;\n  }\n  if (!flag2) {\n    flag2 = (temp6 | input3) == 0;\n  }\n  shiftValue2 = (int)temp4 >> 0x15;\n  if (!flag2) {\n    flag2 = shiftValue2 == -1;\n  }\n  shiftValue1 = (int)temp6 >> 0x15;\n  if (!flag2) {\n    flag2 = shiftValue1 == -1;\n  }\n  if (flag2) {\n    if (shiftValue2 == -1 || shiftValue1 == -1) {\n      temp6 = input4;\n      temp4 = input3;\n      if (shiftValue2 == -1) {\n        temp6 = input2;\n        temp4 = input1;\n      }\n      if (shiftValue2 != -1 || shiftValue1 != -1) {\n        input3 = temp4;\n        input4 = temp6;\n      }\n      flag2 = (temp4 | temp6 << 0xc) == 0;\n      if (flag2) {\n        flag2 = (input3 | input4 << 0xc) == 0;\n      }\n      if (flag2) {\n        flag2 = temp6 == input4;\n      }\n      if (!flag2) {\n        temp6 = temp6 | 0x80000;\n      }\n      return CONCAT44(temp6,temp4);\n    }\n    if (((input2 ^ input4) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((temp4 | input1) == 0) {\n        input1 = input3;\n        input2 = input4;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != input4) {\n      return 0;\n    }\n    if (temp4 >> 0x15 == 0) {\n      flag2 = (input1 & 0x80000000) != 0;\n      temp6 = input2 * 2 + (uint)flag2;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)flag2)) {\n        temp6 = temp6 | 0x80000000;\n      }\n      return CONCAT44(temp6,input1 << 1);\n    }\n    if (temp4 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  temp4 = temp4 >> 0x15;\n  temp6 = temp6 >> 0x15;\n  temp7 = temp6 - temp4;\n  flag2 = temp7 != 0;\n  if (temp6 < temp4) {\n    temp7 = -temp7;\n  }\n  temp5 = input1;\n  temp3 = input2;\n  if (flag2 && temp4 <= temp6) {\n    temp4 = temp4 + temp7;\n    temp5 = input3;\n    temp3 = input4;\n    input3 = input1;\n    input4 = input2;\n  }\n  if (0x36 < temp7) {\n    return CONCAT44(temp3,temp5);\n  }\n  temp6 = temp3 & 0xfffff | 0x100000;\n  if ((temp3 & 0x80000000) != 0) {\n    flag2 = temp5 != 0;\n    temp5 = -temp5;\n    temp6 = -temp6 - (uint)flag2;\n  }\n  temp3 = input4 & 0xfffff | 0x100000;\n  if ((input4 & 0x80000000) != 0) {\n    flag2 = input3 != 0;\n    input3 = -input3;\n    temp3 = -temp3 - (uint)flag2;\n  }\n  if (temp4 == temp7) {\n    temp3 = temp3 ^ 0x100000;\n    if (temp4 == 0) {\n      temp6 = temp6 ^ 0x100000;\n      temp4 = 1;\n    }\n    else {\n      temp7 = temp7 - 1;\n    }\n  }\n  temp9 = -temp7 + 0x20;\n  if ((int)temp7 < 0x21) {\n    temp8 = input3 << (temp9 & 0xff);\n    input3 = input3 >> (temp7 & 0xff);\n    temp1 = temp5 + input3;\n    temp2 = temp3 << (temp9 & 0xff);\n    temp9 = temp1 + temp2;\n    temp6 = temp6 + CARRY4(temp5,input3) + ((int)temp3 >> (temp7 & 0xff)) +\n            (uint)CARRY4(temp1,temp2);\n  }\n  else {\n    temp8 = temp3 << (-temp7 + 0x40 & 0xff);\n    if (input3 != 0) {\n      temp8 = temp8 | 2;\n    }\n    temp3 = (int)temp3 >> (temp7 - 0x20 & 0xff);\n    temp9 = temp5 + temp3;\n    temp6 = temp6 + ((int)temp3 >> 0x1f) + (uint)CARRY4(temp5,temp3);\n  }\n  input2 = temp6 & 0x80000000;\n  temp7 = temp6;\n  if ((int)temp6 < 0) {\n    flag2 = temp8 == 0;\n    temp8 = -temp8;\n    temp7 = -temp9;\n    temp9 = -(uint)!flag2 - temp9;\n    temp7 = -(uint)(flag2 <= temp7) - temp6;\n  }\n  if (0xfffff < temp7) {\n    temp5 = temp4 - 1;\n    if (0x1fffff < temp7) {\n      temp6 = temp7 & 1;\n      temp7 = temp7 >> 1;\n      carry = (byte)temp9;\n      temp9 = (uint)(temp6 != 0) << 0x1f | temp9 >> 1;\n      temp8 = (uint)(carry & 1) << 0x1f | temp8 >> 1;\n      temp5 = temp4;\n      if (0xffbfffff < temp4 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    flag2 = 0x7fffffff < temp8;\n    if (temp8 == 0x80000000) {\n      flag2 = (temp9 & 1) != 0;\n    }\n    return CONCAT44(temp7 + temp5 * 0x100000 + (uint)CARRY4(temp9,(uint)flag2) | input2,\n                    temp9 + flag2);\n  }\n  flag1 = (temp8 & 0x80000000) != 0;\n  temp8 = temp8 << 1;\n  temp5 = temp9 * 2;\n  flag2 = CARRY4(temp9,temp9);\n  temp9 = temp9 * 2 + (uint)flag1;\n  temp7 = temp7 * 2 + (uint)(flag2 || CARRY4(temp5,(uint)flag1));\n  temp5 = temp4 - 2;\n  if ((temp7 & 0x100000) != 0) goto LAB_08000268;\n  temp3 = temp9;\n  temp4 = temp7;\n  if (temp7 == 0) {\n    temp3 = 0;\n    temp4 = temp9;\n  }\n  shiftValue2 = LZCOUNT(temp4);\n  if (temp7 == 0) {\n    shiftValue2 = shiftValue2 + 0x20;\n  }\n  temp9 = shiftValue2 - 0xb;\n  flag3 = SBORROW4(temp9,0x20);\n  temp7 = shiftValue2 - 0x2b;\n  flag2 = (int)temp7 < 0;\n  flag1 = temp7 == 0;\n  if ((int)temp9 < 0x20) {\n    flag3 = SCARRY4(temp7,0xc);\n    shiftValue2 = shiftValue2 + -0x1f;\n    flag2 = shiftValue2 < 0;\n    flag1 = shiftValue2 == 0;\n    temp7 = temp9;\n    if (!flag1 && flag2 == flag3) {\n      temp3 = temp4 << (temp9 & 0xff);\n      temp4 = temp4 >> (0xcU - shiftValue2 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (flag1 || flag2 != flag3) {\n    temp8 = 0x20 - temp7;\n  }\n  temp4 = temp4 << (temp7 & 0xff);\n  if (flag1 || flag2 != flag3) {\n    temp4 = temp4 | temp3 >> (temp8 & 0xff);\n  }\n  if (flag1 || flag2 != flag3) {\n    temp3 = temp3 << (temp7 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)temp9 <= (int)temp5) {\n    return CONCAT44(temp4 + (temp5 - temp9) * 0x100000 | input2,temp3);\n  }\n  temp7 = ~(temp5 - temp9);\n  if ((int)temp7 < 0x1f) {\n    shiftValue2 = temp7 - 0x13;\n    if (shiftValue2 != 0 && shiftValue2 < 0 == SCARRY4(temp7 - 0x1f,0xc)) {\n      return CONCAT44(temp6,temp3 >> (0x20 - (0xcU - shiftValue2) & 0xff) | temp4 << (0xcU - shiftValue2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    temp7 = temp7 + 1;\n    return CONCAT44(input2 | temp4 >> (temp7 & 0xff),\n                    temp3 >> (temp7 & 0xff) | temp4 << (0x20 - temp7 & 0xff));\n  }\n  return CONCAT44(temp6,temp4 >> (temp7 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800015c": "calculate_sum_product_0800015c",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shiftValue1",
                "bVar2": "carry",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "iVar6": "shiftValue2",
                "uVar7": "temp4",
                "uVar8": "temp5",
                "uVar9": "temp6",
                "uVar10": "temp7",
                "uVar11": "temp8",
                "uVar12": "temp9",
                "bVar13": "flag1",
                "bVar14": "flag2",
                "bVar15": "flag3"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "__aeabi_drsub",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003d4": {
            "entrypoint": "0x080003d4",
            "current_name": "truncate_and_shift_080003d4",
            "code": "\nulonglong truncateAndShift_080003d4(uint input)\n\n{\n  uint shiftedResult;\n  uint shiftAmount;\n  int leadingZerosCount;\n  uint finalShiftAmount;\n  uint remainingBits;\n  bool isNegative;\n  bool isZero;\n  bool overflowFlag;\n  \n  if (input == 0) {\n    return 0;\n  }\n  shiftedResult = 0;\n  leadingZerosCount = LZCOUNT(input);\n  finalShiftAmount = leadingZerosCount + 0x15;\n  overflowFlag = SBORROW4(finalShiftAmount,0x20);\n  shiftAmount = leadingZerosCount - 0xb;\n  isNegative = (int)shiftAmount < 0;\n  isZero = shiftAmount == 0;\n  if (finalShiftAmount < 0x20) {\n    overflowFlag = SCARRY4(shiftAmount,0xc);\n    isNegative = false;\n    isZero = leadingZerosCount + 1 == 0;\n    shiftAmount = finalShiftAmount;\n    if (!isZero && overflowFlag == false) {\n      shiftedResult = input << finalShiftAmount;\n      input = input >> (0xcU - (leadingZerosCount + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isZero || isNegative != overflowFlag) {\n    remainingBits = 0x20 - shiftAmount;\n  }\n  input = input << (shiftAmount & 0xff);\n  if (isZero || isNegative != overflowFlag) {\n    input = input | 0U >> (remainingBits & 0xff);\n  }\n  if (isZero || isNegative != overflowFlag) {\n    shiftedResult = 0 << (shiftAmount & 0xff);\n  }\nLAB_080002e0:\n  if (finalShiftAmount < 0x433) {\n    return CONCAT44(input + (0x432 - finalShiftAmount) * 0x100000,shiftedResult);\n  }\n  shiftAmount = ~(0x432 - finalShiftAmount);\n  if (0x1e < (int)shiftAmount) {\n    return (ulonglong)(input >> (shiftAmount - 0x1f & 0xff));\n  }\n  leadingZerosCount = shiftAmount - 0x13;\n  if (leadingZerosCount == 0 || leadingZerosCount < 0 != SCARRY4(shiftAmount - 0x1f,0xc)) {\n    shiftAmount = shiftAmount + 1;\n    return CONCAT44(input >> (shiftAmount & 0xff),\n                    shiftedResult >> (shiftAmount & 0xff) | input << (0x20 - shiftAmount & 0xff));\n  }\n  return (ulonglong)(shiftedResult >> (0x20 - (0xcU - leadingZerosCount) & 0xff) | input << (0xcU - leadingZerosCount & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080003d4": "truncate_and_shift_080003d4",
                "param_1": "input",
                "uVar1": "shiftedResult",
                "uVar2": "shiftAmount",
                "iVar3": "leadingZerosCount",
                "uVar4": "finalShiftAmount",
                "in_r12": "remainingBits",
                "bVar5": "isNegative",
                "bVar6": "isZero",
                "bVar7": "overflowFlag"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003f4": {
            "entrypoint": "0x080003f4",
            "current_name": "calculate_shifted_value_080003f4",
            "code": "\nulonglong calculate_shifted_value_080003f4(uint input_num)\n\n{\n  uint shift_count;\n  uint absolute_num;\n  uint shift_amount;\n  int leading_zeros;\n  uint adjusted_shift;\n  uint is_negative;\n  uint unused_var;\n  bool cond_1;\n  bool cond_2;\n  bool cond_3;\n  \n  if (input_num == 0) {\n    return 0;\n  }\n  is_negative = input_num & 0x80000000;\n  absolute_num = input_num;\n  if ((int)is_negative < 0) {\n    absolute_num = -input_num;\n  }\n  shift_count = 0;\n  leading_zeros = LZCOUNT(absolute_num);\n  adjusted_shift = leading_zeros + 0x15;\n  cond_3 = SBORROW4(adjusted_shift,0x20);\n  shift_amount = leading_zeros - 0xb;\n  cond_1 = (int)shift_amount < 0;\n  cond_2 = shift_amount == 0;\n  if (adjusted_shift < 0x20) {\n    cond_3 = SCARRY4(shift_amount,0xc);\n    cond_1 = false;\n    cond_2 = leading_zeros + 1 == 0;\n    shift_amount = adjusted_shift;\n    if (!cond_2 && cond_3 == false) {\n      shift_count = absolute_num << adjusted_shift;\n      absolute_num = absolute_num >> (0xcU - (leading_zeros + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (cond_2 || cond_1 != cond_3) {\n    unused_var = 0x20 - shift_amount;\n  }\n  absolute_num = absolute_num << (shift_amount & 0xff);\n  if (cond_2 || cond_1 != cond_3) {\n    absolute_num = absolute_num | 0U >> (unused_var & 0xff);\n  }\n  if (cond_2 || cond_1 != cond_3) {\n    shift_count = 0 << (shift_amount & 0xff);\n  }\nLAB_080002e0:\n  if (adjusted_shift < 0x433) {\n    return CONCAT44(absolute_num + (0x432 - adjusted_shift) * 0x100000 | is_negative,shift_count);\n  }\n  shift_amount = ~(0x432 - adjusted_shift);\n  if (0x1e < (int)shift_amount) {\n    return CONCAT44(input_num,absolute_num >> (shift_amount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leading_zeros = shift_amount - 0x13;\n  if (leading_zeros == 0 || leading_zeros < 0 != SCARRY4(shift_amount - 0x1f,0xc)) {\n    shift_amount = shift_amount + 1;\n    return CONCAT44(is_negative | absolute_num >> (shift_amount & 0xff),\n                    shift_count >> (shift_amount & 0xff) | absolute_num << (0x20 - shift_amount & 0xff));\n  }\n  return CONCAT44(input_num,shift_count >> (0x20 - (0xcU - leading_zeros) & 0xff) | absolute_num << (0xcU - leading_zeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_080003f4": "calculate_shifted_value_080003f4",
                "param_1": "input_num",
                "uVar1": "shift_count",
                "uVar2": "absolute_num",
                "uVar3": "shift_amount",
                "iVar4": "leading_zeros",
                "uVar5": "adjusted_shift",
                "uVar6": "is_negative",
                "in_r12": "unused_var",
                "bVar7": "cond_1",
                "bVar8": "cond_2",
                "bVar9": "cond_3"
            },
            "calling": [
                "_svfprintf_r",
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000418": {
            "entrypoint": "0x08000418",
            "current_name": "convert_unsigned_to_hex_string_08000418",
            "code": "\nulonglong convertUnsignedToHexString_08000418(uint inputValue,undefined4 unused1,undefined4 unused2,uint unused3)\n\n{\n  uint msbBitShifted;\n  uint shiftedInput;\n  uint outputHighBits;\n  uint shiftedValue;\n  uint shiftedInputValue;\n  int shiftCount;\n  uint tempValue;\n  uint remainingBits;\n  bool isShiftCountNegative;\n  bool isValueZero;\n  bool isShiftRequired;\n  \n  shiftedInputValue = inputValue << 1;\n  isValueZero = shiftedInputValue == 0;\n  msbBitShifted = (uint)((inputValue & 0x80000000) != 0) << 0x1f;\n  shiftedValue = (uint)((int)shiftedInputValue >> 3) >> 1;\n  outputHighBits = msbBitShifted | shiftedValue;\n  inputValue = inputValue << 0x1d;\n  if (!isValueZero) {\n    unused3 = shiftedInputValue & 0xff000000;\n    isValueZero = unused3 == 0;\n  }\n  if (!isValueZero) {\n    isValueZero = unused3 == 0xff000000;\n  }\n  if (!isValueZero) {\n    return CONCAT44(outputHighBits,inputValue) ^ 0x3800000000000000;\n  }\n  if ((shiftedInputValue & 0xffffff) == 0) {\n    return CONCAT44(outputHighBits,inputValue);\n  }\n  if (unused3 == 0xff000000) {\n    return CONCAT44(outputHighBits,inputValue) | 0x8000000000000;\n  }\n  shiftedInput = inputValue;\n  shiftedInputValue = shiftedValue;\n  if (shiftedValue == 0) {\n    shiftedInput = 0;\n    shiftedInputValue = inputValue;\n  }\n  shiftCount = LZCOUNT(shiftedInputValue);\n  if (shiftedValue == 0) {\n    shiftCount = shiftCount + 0x20;\n  }\n  tempValue = shiftCount - 0xb;\n  isShiftRequired = SBORROW4(tempValue,0x20);\n  shiftedValue = shiftCount - 0x2b;\n  isValueZero = (int)shiftedValue < 0;\n  isShiftCountNegative = shiftedValue == 0;\n  if ((int)tempValue < 0x20) {\n    isShiftRequired = SCARRY4(shiftedValue,0xc);\n    shiftCount = shiftCount + -0x1f;\n    isValueZero = shiftCount < 0;\n    isShiftCountNegative = shiftCount == 0;\n    shiftedValue = tempValue;\n    if (!isShiftCountNegative && isValueZero == isShiftRequired) {\n      shiftedInput = shiftedInputValue << (tempValue & 0xff);\n      shiftedInputValue = shiftedInputValue >> (0xcU - shiftCount & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isShiftCountNegative || isValueZero != isShiftRequired) {\n    remainingBits = 0x20 - shiftedValue;\n  }\n  shiftedInputValue = shiftedInputValue << (shiftedValue & 0xff);\n  if (isShiftCountNegative || isValueZero != isShiftRequired) {\n    shiftedInputValue = shiftedInputValue | shiftedInput >> (remainingBits & 0xff);\n  }\n  if (isShiftCountNegative || isValueZero != isShiftRequired) {\n    shiftedInput = shiftedInput << (shiftedValue & 0xff);\n  }\nLAB_080002e0:\n  if ((int)tempValue < 0x381) {\n    return CONCAT44(shiftedInputValue + (0x380 - tempValue) * 0x100000 | msbBitShifted,shiftedInput);\n  }\n  shiftedValue = ~(0x380 - tempValue);\n  if (0x1e < (int)shiftedValue) {\n    return CONCAT44(outputHighBits,shiftedInputValue >> (shiftedValue - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  shiftCount = shiftedValue - 0x13;\n  if (shiftCount == 0 || shiftCount < 0 != SCARRY4(shiftedValue - 0x1f,0xc)) {\n    shiftedValue = shiftedValue + 1;\n    return CONCAT44(msbBitShifted | shiftedInputValue >> (shiftedValue & 0xff),\n                    shiftedInput >> (shiftedValue & 0xff) | shiftedInputValue << (0x20 - shiftedValue & 0xff));\n  }\n  return CONCAT44(outputHighBits,shiftedInput >> (0x20 - (0xcU - shiftCount) & 0xff) | shiftedInputValue << (0xcU - shiftCount & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000418": "convert_unsigned_to_hex_string_08000418",
                "param_1": "inputValue",
                "param_2": "unused1",
                "param_3": "unused2",
                "param_4": "unused3",
                "uVar1": "msbBitShifted",
                "uVar2": "shiftedInput",
                "uVar3": "outputHighBits",
                "uVar4": "shiftedValue",
                "uVar5": "shiftedInputValue",
                "iVar6": "shiftCount",
                "uVar7": "tempValue",
                "in_r12": "remainingBits",
                "bVar8": "isShiftCountNegative",
                "bVar9": "isValueZero",
                "bVar10": "isShiftRequired"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800045c": {
            "entrypoint": "0x0800045c",
            "current_name": "calculate_shifted_sum_0800045c",
            "code": "\nulonglong calculate_shifted_sum_0800045c(uint input1,uint input2)\n\n{\n  byte bit1;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int count;\n  uint shift;\n  int shifted_count;\n  uint shifted_input2;\n  bool carry;\n  bool carry2;\n  bool subtraction;\n  \n  if ((input1 | input2) == 0) {\n    return CONCAT44(input2,input1);\n  }\n  shifted_count = 0x432;\n  shifted_input2 = input2 >> 0x16;\n  if (shifted_input2 != 0) {\n    shifted_count = 3;\n    if (input2 >> 0x19 != 0) {\n      shifted_count = 6;\n    }\n    if (input2 >> 0x1c != 0) {\n      shifted_count = shifted_count + 3;\n    }\n    temp3 = shifted_count - ((int)input2 >> 0x1f);\n    shifted_input2 = input1 << (0x20 - temp3 & 0xff);\n    input1 = input1 >> (temp3 & 0xff) | input2 << (0x20 - temp3 & 0xff);\n    input2 = input2 >> (temp3 & 0xff);\n    shifted_count = temp3 + 0x432;\n  }\n  if (0xfffff < input2) {\n    if (0x1fffff < input2) {\n      temp3 = input2 & 1;\n      input2 = input2 >> 1;\n      bit1 = (byte)input1;\n      input1 = (uint)(temp3 != 0) << 0x1f | input1 >> 1;\n      shifted_input2 = (uint)(bit1 & 1) << 0x1f | shifted_input2 >> 1;\n      shifted_count = shifted_count + 1;\n      if (0xffbfffff < (uint)(shifted_count * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_08000268:\n    carry2 = 0x7fffffff < shifted_input2;\n    if (shifted_input2 == 0x80000000) {\n      carry2 = (input1 & 1) != 0;\n    }\n    return CONCAT44(input2 + shifted_count * 0x100000 + (uint)CARRY4(input1,(uint)carry2),input1 + carry2\n                   );\n  }\n  carry = (shifted_input2 & 0x80000000) != 0;\n  shifted_input2 = shifted_input2 << 1;\n  temp3 = input1 * 2;\n  carry2 = CARRY4(input1,input1);\n  input1 = input1 * 2 + (uint)carry;\n  input2 = input2 * 2 + (uint)(carry2 || CARRY4(temp3,(uint)carry));\n  shifted_count = shifted_count + -1;\n  if ((input2 & 0x100000) != 0) goto LAB_08000268;\n  temp1 = input1;\n  temp3 = input2;\n  if (input2 == 0) {\n    temp1 = 0;\n    temp3 = input1;\n  }\n  count = LZCOUNT(temp3);\n  if (input2 == 0) {\n    count = count + 0x20;\n  }\n  shift = count - 0xb;\n  subtraction = SBORROW4(shift,0x20);\n  temp2 = count - 0x2b;\n  carry2 = (int)temp2 < 0;\n  carry = temp2 == 0;\n  if ((int)shift < 0x20) {\n    subtraction = SCARRY4(temp2,0xc);\n    count = count + -0x1f;\n    carry2 = count < 0;\n    carry = count == 0;\n    temp2 = shift;\n    if (!carry && carry2 == subtraction) {\n      temp1 = temp3 << (shift & 0xff);\n      temp3 = temp3 >> (0xcU - count & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (carry || carry2 != subtraction) {\n    shifted_input2 = 0x20 - temp2;\n  }\n  temp3 = temp3 << (temp2 & 0xff);\n  if (carry || carry2 != subtraction) {\n    temp3 = temp3 | temp1 >> (shifted_input2 & 0xff);\n  }\n  if (carry || carry2 != subtraction) {\n    temp1 = temp1 << (temp2 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)shift <= shifted_count) {\n    return CONCAT44(temp3 + (shifted_count - shift) * 0x100000,temp1);\n  }\n  shifted_input2 = ~(shifted_count - shift);\n  if (0x1e < (int)shifted_input2) {\n    return (ulonglong)(temp3 >> (shifted_input2 - 0x1f & 0xff));\n  }\n  shifted_count = shifted_input2 - 0x13;\n  if (shifted_count == 0 || shifted_count < 0 != SCARRY4(shifted_input2 - 0x1f,0xc)) {\n    shifted_input2 = shifted_input2 + 1;\n    return CONCAT44(temp3 >> (shifted_input2 & 0xff),temp1 >> (shifted_input2 & 0xff) | temp3 << (0x20 - shifted_input2 & 0xff)\n                   );\n  }\n  return (ulonglong)(temp1 >> (0x20 - (0xcU - shifted_count) & 0xff) | temp3 << (0xcU - shifted_count & 0xff));\n}\n\n",
            "renaming": {
                "FUN_0800045c": "calculate_shifted_sum_0800045c",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "bit1",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "iVar5": "count",
                "uVar6": "shift",
                "iVar7": "shifted_count",
                "uVar8": "shifted_input2",
                "bVar9": "carry",
                "bVar10": "carry2",
                "bVar11": "subtraction"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800046c": {
            "entrypoint": "0x0800046c",
            "current_name": "calculate_shifted_sum_0800046c",
            "code": "\nulonglong calculateShiftedSum_0800046c(uint number1,uint number2)\n\n{\n  byte bit1;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int shiftCount;\n  uint temp4;\n  int constant1;\n  uint signBit;\n  uint shiftedNum1;\n  bool carryFlag;\n  bool overflowFlag;\n  bool subtractionBorrow;\n  \n  if ((number1 | number2) == 0) {\n    return CONCAT44(number2,number1);\n  }\n  signBit = number2 & 0x80000000;\n  temp2 = number2;\n  if ((int)signBit < 0) {\n    overflowFlag = number1 != 0;\n    number1 = -number1;\n    temp2 = -number2 - (uint)overflowFlag;\n  }\n  constant1 = 0x432;\n  shiftedNum1 = temp2 >> 0x16;\n  if (shiftedNum1 != 0) {\n    constant1 = 3;\n    if (temp2 >> 0x19 != 0) {\n      constant1 = 6;\n    }\n    if (temp2 >> 0x1c != 0) {\n      constant1 = constant1 + 3;\n    }\n    temp3 = constant1 - ((int)temp2 >> 0x1f);\n    shiftedNum1 = number1 << (0x20 - temp3 & 0xff);\n    number1 = number1 >> (temp3 & 0xff) | temp2 << (0x20 - temp3 & 0xff);\n    temp2 = temp2 >> (temp3 & 0xff);\n    constant1 = temp3 + 0x432;\n  }\n  if (0xfffff < temp2) {\n    if (0x1fffff < temp2) {\n      temp3 = temp2 & 1;\n      temp2 = temp2 >> 1;\n      bit1 = (byte)number1;\n      number1 = (uint)(temp3 != 0) << 0x1f | number1 >> 1;\n      shiftedNum1 = (uint)(bit1 & 1) << 0x1f | shiftedNum1 >> 1;\n      constant1 = constant1 + 1;\n      if (0xffbfffff < (uint)(constant1 * 0x200000)) {\n        return (ulonglong)(signBit | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_08000268:\n    overflowFlag = 0x7fffffff < shiftedNum1;\n    if (shiftedNum1 == 0x80000000) {\n      overflowFlag = (number1 & 1) != 0;\n    }\n    return CONCAT44(temp2 + constant1 * 0x100000 + (uint)CARRY4(number1,(uint)overflowFlag) | signBit,\n                    number1 + overflowFlag);\n  }\n  carryFlag = (shiftedNum1 & 0x80000000) != 0;\n  shiftedNum1 = shiftedNum1 << 1;\n  temp3 = number1 * 2;\n  overflowFlag = CARRY4(number1,number1);\n  number1 = number1 * 2 + (uint)carryFlag;\n  temp2 = temp2 * 2 + (uint)(overflowFlag || CARRY4(temp3,(uint)carryFlag));\n  constant1 = constant1 + -1;\n  if ((temp2 & 0x100000) != 0) goto LAB_08000268;\n  temp1 = number1;\n  temp3 = temp2;\n  if (temp2 == 0) {\n    temp1 = 0;\n    temp3 = number1;\n  }\n  shiftCount = LZCOUNT(temp3);\n  if (temp2 == 0) {\n    shiftCount = shiftCount + 0x20;\n  }\n  temp4 = shiftCount - 0xb;\n  subtractionBorrow = SBORROW4(temp4,0x20);\n  temp2 = shiftCount - 0x2b;\n  overflowFlag = (int)temp2 < 0;\n  carryFlag = temp2 == 0;\n  if ((int)temp4 < 0x20) {\n    subtractionBorrow = SCARRY4(temp2,0xc);\n    shiftCount = shiftCount + -0x1f;\n    overflowFlag = shiftCount < 0;\n    carryFlag = shiftCount == 0;\n    temp2 = temp4;\n    if (!carryFlag && overflowFlag == subtractionBorrow) {\n      temp1 = temp3 << (temp4 & 0xff);\n      temp3 = temp3 >> (0xcU - shiftCount & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (carryFlag || overflowFlag != subtractionBorrow) {\n    shiftedNum1 = 0x20 - temp2;\n  }\n  temp3 = temp3 << (temp2 & 0xff);\n  if (carryFlag || overflowFlag != subtractionBorrow) {\n    temp3 = temp3 | temp1 >> (shiftedNum1 & 0xff);\n  }\n  if (carryFlag || overflowFlag != subtractionBorrow) {\n    temp1 = temp1 << (temp2 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)temp4 <= constant1) {\n    return CONCAT44(temp3 + (constant1 - temp4) * 0x100000 | signBit,temp1);\n  }\n  temp2 = ~(constant1 - temp4);\n  if (0x1e < (int)temp2) {\n    return CONCAT44(number2,temp3 >> (temp2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  constant1 = temp2 - 0x13;\n  if (constant1 == 0 || constant1 < 0 != SCARRY4(temp2 - 0x1f,0xc)) {\n    temp2 = temp2 + 1;\n    return CONCAT44(signBit | temp3 >> (temp2 & 0xff),\n                    temp1 >> (temp2 & 0xff) | temp3 << (0x20 - temp2 & 0xff));\n  }\n  return CONCAT44(number2,temp1 >> (0x20 - (0xcU - constant1) & 0xff) | temp3 << (0xcU - constant1 & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800046c": "calculate_shifted_sum_0800046c",
                "param_1": "number1",
                "param_2": "number2",
                "bVar1": "bit1",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "iVar5": "shiftCount",
                "uVar6": "temp4",
                "iVar7": "constant1",
                "uVar8": "signBit",
                "uVar9": "shiftedNum1",
                "bVar10": "carryFlag",
                "bVar11": "overflowFlag",
                "bVar12": "subtractionBorrow"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004c8": {
            "entrypoint": "0x080004c8",
            "current_name": "calculate_checksum_080004c8",
            "code": "\nulonglong calculateChecksum_080004c8(undefined4 input1,uint input2,uint input3,uint input4)\n\n{\n  ulonglong product1;\n  longlong temp1;\n  uint temp2;\n  uint temp3;\n  int sum;\n  uint num1;\n  uint unaff_r5;\n  uint num2;\n  uint num3;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  ulonglong result;\n  \n  result = CONCAT44(input2,input1);\n  num2 = 0x7ff;\n  temp3 = input2 >> 0x14 & 0x7ff;\n  condition1 = temp3 == 0;\n  if (!condition1) {\n    unaff_r5 = input4 >> 0x14 & 0x7ff;\n    condition1 = unaff_r5 == 0;\n  }\n  if (!condition1) {\n    condition1 = temp3 == 0x7ff;\n  }\n  if (!condition1) {\n    condition1 = unaff_r5 == 0x7ff;\n  }\n  if (condition1) {\n    result = extract_bit_range_080006a4();\n  }\n  temp2 = (uint)(result >> 0x20);\n  sum = temp3 + unaff_r5;\n  temp3 = temp2 ^ input4;\n  temp2 = temp2 & ~(num2 << 0x15);\n  input4 = input4 & ~(num2 << 0x15);\n  condition1 = ((uint)result | temp2 << 0xc) == 0;\n  if (!condition1) {\n    condition1 = (input3 | input4 << 0xc) == 0;\n  }\n  temp2 = temp2 | 0x100000;\n  input4 = input4 | 0x100000;\n  if (condition1) {\n    input3 = (uint)result | input3;\n    input4 = (temp3 & 0x80000000 | temp2) ^ input4;\n    temp3 = num2 >> 1;\n    condition3 = SBORROW4(sum,temp3);\n    num1 = sum - temp3;\n    condition1 = num1 == 0;\n    temp2 = num1;\n    if (!condition1 && (int)temp3 <= sum) {\n      condition3 = SBORROW4(num2,num1);\n      temp2 = num2 - num1;\n      condition1 = num2 == num1;\n    }\n    if (!condition1 && (int)temp2 < 0 == condition3) {\n      input4 = input4 | num1 * 0x100000;\n    }\n    if (!condition1 && (int)temp2 < 0 == condition3) {\n      return CONCAT44(input4,input3);\n    }\n    input4 = input4 | 0x100000;\n    num2 = 0;\n    condition3 = SBORROW4(num1,1);\n    num1 = num1 - 1;\n    condition1 = num1 == 0;\n    temp3 = num1;\n  }\n  else {\n    product1 = (result & 0xffffffff) * (ulonglong)input3;\n    result = (result & 0xffffffff) * (ulonglong)input4 +\n             (ulonglong)temp2 * (ulonglong)input3 + (product1 >> 0x20);\n    num3 = (uint)result;\n    temp1 = (ulonglong)temp2 * (ulonglong)input4 + (result >> 0x20);\n    num2 = (uint)temp1;\n    temp2 = (uint)((ulonglong)temp1 >> 0x20);\n    if ((int)product1 != 0) {\n      num3 = num3 | 1;\n    }\n    num1 = (sum + -0x3ff) - (uint)(temp2 < 0x200);\n    if (temp2 < 0x200) {\n      condition1 = (num3 & 0x80000000) != 0;\n      num3 = num3 << 1;\n      temp1 = CONCAT44(temp2 * 2 + (uint)(CARRY4(num2,num2) || CARRY4(num2 * 2,(uint)condition1)),\n                       num2 * 2 + (uint)condition1);\n    }\n    input4 = temp3 & 0x80000000 | (int)((ulonglong)temp1 >> 0x20) << 0xb | (uint)temp1 >> 0x15;\n    input3 = (uint)temp1 << 0xb | num3 >> 0x15;\n    num2 = num3 * 0x800;\n    condition2 = 0xfc < num1;\n    condition3 = SBORROW4(num1,0xfd);\n    temp2 = num1 - 0xfd;\n    condition1 = temp2 == 0;\n    temp3 = temp2;\n    if (condition2 && !condition1) {\n      condition2 = 0x6ff < temp2;\n      condition3 = SBORROW4(temp2,0x700);\n      temp3 = num1 - 0x7fd;\n      condition1 = temp2 == 0x700;\n    }\n    if (!condition2 || condition1) {\n      condition1 = 0x7fffffff < num2;\n      if (num2 == 0x80000000) {\n        condition1 = (num3 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(input4 + num1 * 0x100000 + (uint)CARRY4(input3,(uint)condition1),input3 + condition1\n                     );\n    }\n  }\n  if (!condition1 && (int)temp3 < 0 == condition3) {\n    return (ulonglong)(input4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  condition2 = SCARRY4(num1,0x36);\n  condition1 = (int)(num1 + 0x36) < 0;\n  condition3 = num1 == 0xffffffca;\n  if (condition3 || condition1 != condition2) {\n    input3 = 0;\n  }\n  if (condition3 || condition1 != condition2) {\n    input4 = input4 & 0x80000000;\n  }\n  if (condition3 || condition1 != condition2) {\n    return CONCAT44(input4,input3);\n  }\n  temp3 = -num1;\n  temp2 = temp3 - 0x20;\n  if (0x1f < (int)temp3) {\n    num1 = input3 >> (temp2 & 0xff) | input4 << (0x20 - temp2 & 0xff);\n    temp3 = (input4 >> (temp2 & 0xff) & ~((input4 & 0x80000000) >> (temp2 & 0xff))) -\n            ((int)num1 >> 0x1f);\n    if ((num2 | input3 << (0x20 - temp2 & 0xff) | num1 << 1) == 0) {\n      temp3 = temp3 & ~(num1 >> 0x1f);\n    }\n    return CONCAT44(input4,temp3) & 0x80000000ffffffff;\n  }\n  sum = temp3 - 0x14;\n  if (sum == 0 || sum < 0 != SCARRY4(temp2,0xc)) {\n    num3 = input3 << (num1 + 0x20 & 0xff);\n    temp2 = input3 >> (temp3 & 0xff) | input4 << (num1 + 0x20 & 0xff);\n    num1 = temp2 + -((int)num3 >> 0x1f);\n    if ((num2 | num3 << 1) == 0) {\n      num1 = num1 & ~(num3 >> 0x1f);\n    }\n    return CONCAT44((input4 & 0x80000000) +\n                    ((input4 & 0x7fffffff) >> (temp3 & 0xff)) +\n                    (uint)CARRY4(temp2,-((int)num3 >> 0x1f)),num1);\n  }\n  temp3 = 0xc - sum;\n  num1 = input3 << (temp3 & 0xff);\n  temp3 = input3 >> (0x20 - temp3 & 0xff) | input4 << (temp3 & 0xff);\n  temp2 = temp3 + -((int)num1 >> 0x1f);\n  if ((num2 | num1 << 1) == 0) {\n    temp2 = temp2 & ~(num1 >> 0x1f);\n  }\n  return CONCAT44((input4 & 0x80000000) + (uint)CARRY4(temp3,-((int)num1 >> 0x1f)),temp2);\n}\n\n",
            "renaming": {
                "FUN_080004c8": "calculate_checksum_080004c8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "product1",
                "lVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "iVar5": "sum",
                "uVar6": "num1",
                "uVar7": "num2",
                "uVar8": "num3",
                "bVar9": "condition1",
                "bVar10": "condition2",
                "bVar11": "condition3",
                "uVar12": "result"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "_svfprintf_r",
                "atan",
                "_dtoa_r",
                "frexp",
                "mpu6050_calc_pitch"
            ],
            "called": [
                "FUN_080006a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006a4": {
            "entrypoint": "0x080006a4",
            "current_name": "extract_bit_range_080006a4",
            "code": "\nulonglong extract_bit_range_080006a4(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint bit1;\n  uint bit2;\n  uint bit3;\n  uint bit4;\n  uint bit5;\n  bool is_zero;\n  \n  bit3 = bit5 & input4 >> 0x14;\n  if (bit2 != bit5 && bit3 != bit5) {\n    is_zero = (input1 | input2 << 1) == 0;\n    if (!is_zero) {\n      is_zero = (input3 | input4 << 1) == 0;\n    }\n    if (is_zero) {\n      return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n    }\n    if (bit2 == 0) {\n      bit4 = input2 & 0x80000000;\n      do {\n        bit1 = input1 & 0x80000000;\n        input1 = input1 << 1;\n        input2 = input2 * 2 + (uint)(bit1 != 0);\n      } while ((input2 & 0x100000) == 0);\n      input2 = input2 | bit4;\n      if (bit3 != 0) {\n        return CONCAT44(input2,input1);\n      }\n    }\n    do {\n      bit3 = input3 & 0x80000000;\n      input3 = input3 << 1;\n      input4 = input4 * 2 + (uint)(bit3 != 0);\n    } while ((input4 & 0x100000) == 0);\n    return CONCAT44(input2,input1);\n  }\n  is_zero = (input1 | input2 << 1) == 0;\n  if (is_zero) {\n    input2 = input4;\n    input1 = input3;\n  }\n  if (!is_zero) {\n    is_zero = (input3 | input4 << 1) == 0;\n  }\n  bit4 = input2;\n  if (((!is_zero) && ((bit2 != bit5 || ((input1 | input2 << 0xc) == 0)))) &&\n     ((bit3 != bit5 || (input1 = input3, bit4 = input4, (input3 | input4 << 0xc) == 0)))) {\n    return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(bit4,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006a4": "extract_bit_range_080006a4",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "bit1",
                "unaff_r4": "bit2",
                "uVar2": "bit3",
                "uVar3": "bit4",
                "in_r12": "bit5",
                "bVar4": "is_zero"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800071c": {
            "entrypoint": "0x0800071c",
            "current_name": "calculate_double_0800071c",
            "code": "\nulonglong calculateDouble_0800071c(undefined4 paramA,uint paramB,uint paramC,uint paramD)\n\n{\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  int temp8;\n  uint temp9;\n  uint unaff_r5;\n  uint temp10;\n  uint temp11;\n  uint temp12;\n  uint temp13;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  undefined8 combinedParams;\n  \n  combinedParams = CONCAT44(paramB,paramA);\n  temp13 = 0x7ff;\n  temp7 = paramB >> 0x14 & 0x7ff;\n  flag1 = temp7 == 0;\n  if (!flag1) {\n    unaff_r5 = paramD >> 0x14 & 0x7ff;\n    flag1 = unaff_r5 == 0;\n  }\n  if (!flag1) {\n    flag1 = temp7 == 0x7ff;\n  }\n  if (!flag1) {\n    flag1 = unaff_r5 == 0x7ff;\n  }\n  if (flag1) {\n    combinedParams = convert_to_double_0800088a();\n  }\n  temp9 = (uint)((ulonglong)combinedParams >> 0x20);\n  temp11 = (uint)combinedParams;\n  temp8 = temp7 - unaff_r5;\n  if ((paramC | paramD << 0xc) == 0) {\n    temp7 = (temp9 ^ paramD) & 0x80000000 | temp9 & 0xfffff;\n    flag3 = SCARRY4(temp8,temp13 >> 1);\n    temp9 = temp8 + (temp13 >> 1);\n    flag1 = (int)temp9 < 0;\n    flag2 = temp9 == 0;\n    if (!flag2 && flag1 == flag3) {\n      flag3 = SBORROW4(temp13,temp9);\n      flag1 = (int)(temp13 - temp9) < 0;\n      flag2 = temp13 == temp9;\n    }\n    if (!flag2 && flag1 == flag3) {\n      temp7 = temp7 | temp9 * 0x100000;\n    }\n    if (!flag2 && flag1 == flag3) {\n      return CONCAT44(temp7,temp11);\n    }\n    temp7 = temp7 | 0x100000;\n    temp13 = 0;\n    flag2 = SBORROW4(temp9,1);\n    temp9 = temp9 - 1;\n    flag1 = temp9 == 0;\n    temp3 = temp9;\n  }\n  else {\n    temp3 = (paramD << 0xc) >> 4 | 0x10000000 | paramC >> 0x18;\n    temp13 = paramC << 8;\n    temp10 = (temp9 << 0xc) >> 4 | 0x10000000 | temp11 >> 0x18;\n    temp11 = temp11 * 0x100;\n    temp7 = (temp9 ^ paramD) & 0x80000000;\n    flag1 = temp3 <= temp10;\n    if (temp10 == temp3) {\n      flag1 = temp13 <= temp11;\n    }\n    temp8 = temp8 + (uint)flag1;\n    temp9 = temp8 + 0x3fd;\n    if (flag1 == false) {\n      temp3 = temp3 >> 1;\n      temp13 = (uint)((paramC >> 0x18 & 1) != 0) << 0x1f | temp13 >> 1;\n    }\n    temp12 = temp11 - temp13;\n    temp10 = (temp10 - temp3) - (uint)(temp11 < temp13);\n    temp4 = temp3 >> 1;\n    temp1 = (uint)((temp3 & 1) != 0) << 0x1f | temp13 >> 1;\n    temp11 = 0x100000;\n    temp3 = 0x80000;\n    while( true ) {\n      flag1 = temp1 <= temp12;\n      if (temp4 < temp10 || temp10 - temp4 < (uint)flag1) {\n        temp12 = temp12 - temp1;\n        temp11 = temp11 | temp3;\n        temp10 = (temp10 - temp4) - (uint)!flag1;\n      }\n      temp5 = temp4 >> 1;\n      temp1 = (uint)((temp4 & 1) != 0) << 0x1f | temp1 >> 1;\n      flag2 = temp1 <= temp12;\n      flag1 = temp10 - temp5 < (uint)flag2;\n      temp13 = temp10;\n      if (temp5 < temp10 || flag1) {\n        temp12 = temp12 - temp1;\n        temp13 = (temp10 - temp5) - (uint)!flag2;\n      }\n      if (temp5 < temp10 || flag1) {\n        temp11 = temp11 | temp3 >> 1;\n      }\n      temp10 = temp4 >> 2;\n      temp2 = (uint)((temp5 & 1) != 0) << 0x1f | temp1 >> 1;\n      flag2 = temp2 <= temp12;\n      flag1 = temp13 - temp10 < (uint)flag2;\n      temp5 = temp13;\n      if (temp10 < temp13 || flag1) {\n        temp12 = temp12 - temp2;\n        temp5 = (temp13 - temp10) - (uint)!flag2;\n      }\n      if (temp10 < temp13 || flag1) {\n        temp11 = temp11 | temp3 >> 2;\n      }\n      temp6 = temp4 >> 3;\n      temp1 = (uint)((temp10 & 1) != 0) << 0x1f | temp2 >> 1;\n      flag2 = temp1 <= temp12;\n      flag1 = temp5 - temp6 < (uint)flag2;\n      temp10 = temp5;\n      if (temp6 < temp5 || flag1) {\n        temp12 = temp12 - temp1;\n        temp10 = (temp5 - temp6) - (uint)!flag2;\n      }\n      if (temp6 < temp5 || flag1) {\n        temp11 = temp11 | temp3 >> 3;\n      }\n      temp13 = temp10 | temp12;\n      if (temp13 == 0) break;\n      temp10 = temp10 << 4 | temp12 >> 0x1c;\n      temp12 = temp12 << 4;\n      temp4 = temp4 & 0xfffffff8 | temp1 >> 0x1d;\n      temp1 = (temp2 >> 1) << 3;\n      temp3 = temp3 >> 4;\n      if (temp3 == 0) {\n        temp6 = temp4;\n        if ((temp7 & 0x100000) != 0) goto LAB_0800083a;\n        temp7 = temp7 | temp11;\n        temp11 = 0;\n        temp3 = 0x80000000;\n      }\n    }\n    if ((temp7 & 0x100000) == 0) {\n      temp7 = temp7 | temp11;\n      temp11 = 0;\n    }\nLAB_0800083a:\n    flag3 = 0xfc < temp9;\n    flag2 = SBORROW4(temp9,0xfd);\n    temp4 = temp8 + 0x300;\n    flag1 = temp4 == 0;\n    temp3 = temp4;\n    if (flag3 && !flag1) {\n      flag3 = 0x6ff < temp4;\n      flag2 = SBORROW4(temp4,0x700);\n      temp3 = temp8 - 0x400;\n      flag1 = temp4 == 0x700;\n    }\n    if (!flag3 || flag1) {\n      flag1 = temp6 <= temp10;\n      if (temp10 == temp6) {\n        flag1 = temp1 <= temp12;\n      }\n      if (temp10 == temp6 && temp12 == temp1) {\n        flag1 = (temp11 & 1) != 0;\n      }\n      return CONCAT44(temp7 + temp9 * 0x100000 + (uint)CARRY4(temp11,(uint)flag1),temp11 + flag1);\n    }\n  }\n  if (!flag1 && (int)temp3 < 0 == flag2) {\n    return (ulonglong)(temp7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag3 = SCARRY4(temp9,0x36);\n  flag1 = (int)(temp9 + 0x36) < 0;\n  flag2 = temp9 == 0xffffffca;\n  if (flag2 || flag1 != flag3) {\n    temp11 = 0;\n  }\n  if (flag2 || flag1 != flag3) {\n    temp7 = temp7 & 0x80000000;\n  }\n  if (flag2 || flag1 != flag3) {\n    return CONCAT44(temp7,temp11);\n  }\n  temp3 = -temp9;\n  temp10 = temp3 - 0x20;\n  if (0x1f < (int)temp3) {\n    temp3 = temp11 >> (temp10 & 0xff) | temp7 << (0x20 - temp10 & 0xff);\n    temp9 = (temp7 >> (temp10 & 0xff) & ~((temp7 & 0x80000000) >> (temp10 & 0xff))) -\n            ((int)temp3 >> 0x1f);\n    if ((temp13 | temp11 << (0x20 - temp10 & 0xff) | temp3 << 1) == 0) {\n      temp9 = temp9 & ~(temp3 >> 0x1f);\n    }\n    return CONCAT44(temp7,temp9) & 0x80000000ffffffff;\n  }\n  temp8 = temp3 - 0x14;\n  if (temp8 != 0 && temp8 < 0 == SCARRY4(temp10,0xc)) {\n    temp9 = 0xc - temp8;\n    temp3 = temp11 << (temp9 & 0xff);\n    temp11 = temp11 >> (0x20 - temp9 & 0xff) | temp7 << (temp9 & 0xff);\n    temp9 = temp11 + -((int)temp3 >> 0x1f);\n    if ((temp13 | temp3 << 1) == 0) {\n      temp9 = temp9 & ~(temp3 >> 0x1f);\n    }\n    return CONCAT44((temp7 & 0x80000000) + (uint)CARRY4(temp11,-((int)temp3 >> 0x1f)),temp9);\n  }\n  temp10 = temp11 << (temp9 + 0x20 & 0xff);\n  temp11 = temp11 >> (temp3 & 0xff) | temp7 << (temp9 + 0x20 & 0xff);\n  temp9 = temp11 + -((int)temp10 >> 0x1f);\n  if ((temp13 | temp10 << 1) == 0) {\n    temp9 = temp9 & ~(temp10 >> 0x1f);\n  }\n  return CONCAT44((temp7 & 0x80000000) +\n                  ((temp7 & 0x7fffffff) >> (temp3 & 0xff)) +\n                  (uint)CARRY4(temp11,-((int)temp10 >> 0x1f)),temp9);\n}\n\n",
            "renaming": {
                "FUN_0800071c": "calculate_double_0800071c",
                "param_1": "paramA",
                "param_2": "paramB",
                "param_3": "paramC",
                "param_4": "paramD",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "uVar6": "temp6",
                "uVar7": "temp7",
                "iVar8": "temp8",
                "uVar9": "temp9",
                "uVar10": "temp10",
                "uVar11": "temp11",
                "uVar12": "temp12",
                "uVar13": "temp13",
                "bVar14": "flag1",
                "bVar15": "flag2",
                "bVar16": "flag3",
                "uVar17": "combinedParams"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch"
            ],
            "called": [
                "FUN_0800088a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800088a": {
            "entrypoint": "0x0800088a",
            "current_name": "convert_to_double_0800088a",
            "code": "\nulonglong convertToDouble_0800088a(uint firstInt,uint secondInt,uint thirdUint,uint fourthUint)\n\n{\n  uint tempVar1;\n  uint tempVar2;\n  uint tempVar3;\n  uint tempVar4;\n  uint constant;\n  bool isZero;\n  \n  tempVar3 = constant & fourthUint >> 0x14;\n  tempVar4 = secondInt;\n  if (tempVar2 != constant || tempVar3 != constant) {\n    if (tempVar2 == constant) {\n      if (((firstInt | secondInt << 0xc) == 0) && (firstInt = thirdUint, tempVar4 = fourthUint, tempVar3 != constant)\n         ) {\nLAB_080006fc:\n        return (ulonglong)((secondInt ^ fourthUint) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (tempVar3 == constant) {\n      firstInt = thirdUint;\n      tempVar4 = fourthUint;\n      if ((thirdUint | fourthUint << 0xc) == 0) {\nLAB_080006c0:\n        return (ulonglong)((secondInt ^ fourthUint) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      isZero = (firstInt | secondInt << 1) == 0;\n      if (!isZero) {\n        isZero = (thirdUint | fourthUint << 1) == 0;\n      }\n      if (!isZero) {\n        if (tempVar2 == 0) {\n          tempVar4 = secondInt & 0x80000000;\n          do {\n            tempVar1 = firstInt & 0x80000000;\n            firstInt = firstInt << 1;\n            secondInt = secondInt * 2 + (uint)(tempVar1 != 0);\n          } while ((secondInt & 0x100000) == 0);\n          secondInt = secondInt | tempVar4;\n          if (tempVar3 != 0) {\n            return CONCAT44(secondInt,firstInt);\n          }\n        }\n        do {\n          tempVar4 = thirdUint & 0x80000000;\n          thirdUint = thirdUint << 1;\n          fourthUint = fourthUint * 2 + (uint)(tempVar4 != 0);\n        } while ((fourthUint & 0x100000) == 0);\n        return CONCAT44(secondInt,firstInt);\n      }\n      if ((firstInt | secondInt << 1) != 0) goto LAB_080006fc;\n      if ((thirdUint | fourthUint << 1) != 0) goto LAB_080006c0;\n    }\n  }\n  return CONCAT44(tempVar4,firstInt) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_0800088a": "convert_to_double_0800088a",
                "param_1": "firstInt",
                "param_2": "secondInt",
                "param_3": "thirdUint",
                "param_4": "fourthUint",
                "uVar1": "tempVar1",
                "unaff_r4": "tempVar2",
                "uVar2": "tempVar3",
                "uVar3": "tempVar4",
                "in_r12": "constant",
                "bVar4": "isZero"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008ec": {
            "entrypoint": "0x080008ec",
            "current_name": "check_equality_080008ec",
            "code": "\nuint check_equality_080008ec(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint xor_result;\n  bool is_zero;\n  bool comparison_result;\n  \n  if (((int)(param_2 << 1) >> 0x15 == -1 || (int)(param_4 << 1) >> 0x15 == -1) &&\n     ((((int)(param_2 << 1) >> 0x15 == -1 && ((param_1 | param_2 << 0xc) != 0)) ||\n      (((int)(param_4 << 1) >> 0x15 == -1 && ((param_3 | param_4 << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  is_zero = (param_1 | param_2 << 1) == 0;\n  if (is_zero) {\n    is_zero = (param_3 | param_4 << 1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = param_2 == param_4;\n  }\n  if (is_zero) {\n    is_zero = param_1 == param_3;\n  }\n  if (!is_zero) {\n    xor_result = param_2 ^ param_4;\n    is_zero = xor_result == 0;\n    if (-1 < (int)xor_result) {\n      is_zero = param_2 == param_4;\n    }\n    comparison_result = -1 < (int)xor_result && param_4 <= param_2;\n    if (is_zero) {\n      comparison_result = param_3 <= param_1;\n    }\n    param_4 = (int)param_4 >> 0x1f;\n    if (!comparison_result) {\n      param_4 = ~param_4;\n    }\n    return param_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008ec": "check_equality_080008ec",
                "uVar1": "xor_result",
                "bVar2": "is_zero",
                "bVar3": "comparison_result"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008f4": {
            "entrypoint": "0x080008f4",
            "current_name": "check_equality_and_bounds_080008f4",
            "code": "\nuint checkEqualityAndBounds_080008f4(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint result;\n  bool isZero;\n  bool isNegative;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (value1 | value2 << 1) == 0;\n  if (isZero) {\n    isZero = (value3 | value4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = value2 == value4;\n  }\n  if (isZero) {\n    isZero = value1 == value3;\n  }\n  if (!isZero) {\n    result = value2 ^ value4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = value2 == value4;\n    }\n    isNegative = -1 < (int)result && value4 <= value2;\n    if (isZero) {\n      isNegative = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!isNegative) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008f4": "check_equality_and_bounds_080008f4",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isNegative"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008fc": {
            "entrypoint": "0x080008fc",
            "current_name": "FUNC_080008fc",
            "code": "\nuint FUNC_080008fc(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  uint uVar1;\n  bool bVar2;\n  bool bVar3;\n  \n  if (((int)(param_2 << 1) >> 0x15 == -1 || (int)(param_4 << 1) >> 0x15 == -1) &&\n     ((((int)(param_2 << 1) >> 0x15 == -1 && ((param_1 | param_2 << 0xc) != 0)) ||\n      (((int)(param_4 << 1) >> 0x15 == -1 && ((param_3 | param_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  bVar2 = (param_1 | param_2 << 1) == 0;\n  if (bVar2) {\n    bVar2 = (param_3 | param_4 << 1) == 0;\n  }\n  if (!bVar2) {\n    bVar2 = param_2 == param_4;\n  }\n  if (bVar2) {\n    bVar2 = param_1 == param_3;\n  }\n  if (!bVar2) {\n    uVar1 = param_2 ^ param_4;\n    bVar2 = uVar1 == 0;\n    if (-1 < (int)uVar1) {\n      bVar2 = param_2 == param_4;\n    }\n    bVar3 = -1 < (int)uVar1 && param_4 <= param_2;\n    if (bVar2) {\n      bVar3 = param_3 <= param_1;\n    }\n    param_4 = (int)param_4 >> 0x1f;\n    if (!bVar3) {\n      param_4 = ~param_4;\n    }\n    return param_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008fc": "FUNC_080008fc"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000978": {
            "entrypoint": "0x08000978",
            "current_name": "compare_and_assign_08000978",
            "code": "\nvoid compareAndAssign_08000978(undefined4 result,undefined4 unused,undefined4 value1,undefined4 value2)\n\n{\n  __aeabi_cdcmpeq(value1,value2,result,unused);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000978": "compare_and_assign_08000978",
                "param_1": "result",
                "param_2": "unused",
                "param_3": "value1",
                "param_4": "value2"
            },
            "calling": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000988": {
            "entrypoint": "0x08000988",
            "current_name": "convert_to_float_08000988",
            "code": "\nundefined4 convertToFloat_08000988(undefined4 input)\n\n{\n  convertToFloat_08000988Internal();\n  return input;\n}\n\n",
            "renaming": {
                "FUN_08000988": "convert_to_float_08000988",
                "param_1": "input",
                "__nedf2": "convertToFloatInternal"
            },
            "calling": [
                "__aeabi_dcmpeq",
                "__aeabi_cdrcmple",
                "__aeabi_dcmple",
                "__aeabi_dcmplt"
            ],
            "called": [
                "__nedf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "check_comp_08000998",
            "code": "\nbool check_comp_08000998(void)\n\n{\n  char input_character;\n  \n  __aeabi_cdcmpeq();\n  return input_character != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000998": "check_comp_08000998",
                "in_ZR": "input_character"
            },
            "calling": [
                "_svfprintf_r",
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009ac": {
            "entrypoint": "0x080009ac",
            "current_name": "check_if_carry_is_zero_080009ac",
            "code": "\nbool check_if_carry_is_zero_080009ac(void)\n\n{\n  char carry_flag;\n  \n  __aeabi_cdcmpeq();\n  return carry_flag == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009ac": "check_if_carry_is_zero_080009ac",
                "in_CY": "carry_flag"
            },
            "calling": [
                "_svfprintf_r",
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c0": {
            "entrypoint": "0x080009c0",
            "current_name": "check_equality_080009c0",
            "code": "\nbool check_equality_080009c0(void)\n\n{\n  undefined is_zero;\n  undefined carry_flag;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)carry_flag || (bool)is_zero;\n}\n\n",
            "renaming": {
                "FUN_080009c0": "check_equality_080009c0",
                "in_ZR": "is_zero",
                "in_CY": "carry_flag"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009d4": {
            "entrypoint": "0x080009d4",
            "current_name": "is_less_than_or_equal_080009d4",
            "code": "\nbool isLessThanOrEqual_080009d4(void)\n\n{\n  undefined zeroResult;\n  undefined carryFlag;\n  \n  __aeabi_cdrcmple();\n  return !(bool)carryFlag || (bool)zeroResult;\n}\n\n",
            "renaming": {
                "FUN_080009d4": "is_less_than_or_equal_080009d4",
                "in_ZR": "zeroResult",
                "in_CY": "carryFlag"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009e8": {
            "entrypoint": "0x080009e8",
            "current_name": "is_input_null_080009e8",
            "code": "\nbool is_input_null_080009e8(void)\n\n{\n  char input_character;\n  \n  __aeabi_cdrcmple();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009e8": "is_input_null_080009e8",
                "in_CY": "input_character"
            },
            "calling": [
                "_svfprintf_r",
                "atan",
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009fc": {
            "entrypoint": "0x080009fc",
            "current_name": "calculate_floating_point_value_080009fc",
            "code": "\nuint calculateFloatingPointValue_080009fc(uint value1,uint value2)\n\n{\n  uint result;\n  uint value2Times2;\n  uint modifiedValue2;\n  uint tempVar;\n  bool isZero;\n  bool isLessThan70000000;\n  \n  value2Times2 = value2 * 2;\n  isLessThan70000000 = value2Times2 < 0x70000000;\n  modifiedValue2 = value2Times2 + 0x90000000;\n  result = modifiedValue2;\n  if (!isLessThan70000000) {\n    tempVar = value2Times2 + 0x8fe00000;\n    result = tempVar;\n  }\n  isZero = result == 0;\n  if (!isLessThan70000000 && modifiedValue2 >= 0x200000) {\n    isZero = tempVar == 0x1fc00000;\n  }\n  if (((isLessThan70000000 || modifiedValue2 < 0x200000) || 0x1fc00000 < tempVar) || isZero) {\n    if ((value2 & 0x40000000) != 0) {\n      if (((int)value2Times2 >> 0x15 == -1) && ((value1 | value2 << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return value2 & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(value2Times2 + 0x92e00000) < 0 != SCARRY4(modifiedValue2,0x2e00000)) {\n      return value2 & 0x80000000;\n    }\n    value2Times2 = 0x18 - (value2Times2 + 0x92e00000 >> 0x15);\n    result = value1 >> (value2Times2 & 0xff);\n    if (value1 << (0x20 - value2Times2 & 0xff) != 0) {\n      result = result | 1;\n    }\n    modifiedValue2 = value2 & 0x1fffff | 0x100000;\n    value1 = result | modifiedValue2 << (0x20 - value2Times2 & 0xff);\n    modifiedValue2 = (modifiedValue2 >> (value2Times2 & 0xff)) << 1;\n  }\n  result = (value2 & 0x80000000 | value1 >> 0x1d) + modifiedValue2 * 4 + (uint)(0x7fffffff < value1 * 8);\n  if (value1 * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080009fc": "calculate_floating_point_value_080009fc",
                "param_1": "value1",
                "param_2": "value2",
                "uVar1": "result",
                "uVar2": "value2Times2",
                "uVar3": "modifiedValue2",
                "in_r12": "tempVar",
                "bVar4": "isZero",
                "bVar5": "isLessThan70000000"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a9c": {
            "entrypoint": "0x08000a9c",
            "current_name": "convert_to_negative_float_08000a9c",
            "code": "\nvoid convertToNegativeFloat_08000a9c(uint floatValue)\n\n{\n  addSignedFloat(floatValue ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000a9c": "convert_to_negative_float_08000a9c",
                "param_1": "floatValue",
                "__addsf3": "addSignedFloat"
            },
            "calling": [],
            "called": [
                "__addsf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa4": {
            "entrypoint": "0x08000aa4",
            "current_name": "perform_arithmetic_operation_08000aa4",
            "code": "\nuint performArithmeticOperation_08000aa4(uint inputValue1,uint inputValue2,undefined4 param3,uint param4)\n\n{\n  int shiftedValue1;\n  int shiftedValue2;\n  uint tempValue1;\n  uint tempValue2;\n  uint shiftedInput1;\n  uint updatedShiftedInput1;\n  uint difference;\n  bool isConditionMet;\n  \n  tempValue1 = inputValue2 ^ 0x80000000;\n  shiftedInput1 = inputValue1 << 1;\n  isConditionMet = shiftedInput1 == 0;\n  if (!isConditionMet) {\n    param4 = inputValue2 << 1;\n    isConditionMet = param4 == 0;\n  }\n  if (!isConditionMet) {\n    isConditionMet = shiftedInput1 == param4;\n  }\n  shiftedValue1 = (int)shiftedInput1 >> 0x18;\n  if (!isConditionMet) {\n    isConditionMet = shiftedValue1 == -1;\n  }\n  if (!isConditionMet) {\n    isConditionMet = (int)param4 >> 0x18 == -1;\n  }\n  if (isConditionMet) {\n    shiftedValue2 = (int)(inputValue2 << 1) >> 0x18;\n    if (shiftedValue1 == -1 || shiftedValue2 == -1) {\n      shiftedInput1 = tempValue1;\n      if (shiftedValue1 == -1) {\n        shiftedInput1 = inputValue1;\n      }\n      if (shiftedValue1 != -1 || shiftedValue2 != -1) {\n        tempValue1 = shiftedInput1;\n      }\n      isConditionMet = (shiftedInput1 & 0x7fffff) == 0;\n      if (isConditionMet) {\n        isConditionMet = (tempValue1 & 0x7fffff) == 0;\n      }\n      if (isConditionMet) {\n        isConditionMet = shiftedInput1 == tempValue1;\n      }\n      if (!isConditionMet) {\n        shiftedInput1 = shiftedInput1 | 0x400000;\n      }\n      return shiftedInput1;\n    }\n    if (((inputValue1 ^ tempValue1) & 0x7fffffff) != 0) {\n      if (shiftedInput1 == 0) {\n        inputValue1 = tempValue1;\n      }\n      return inputValue1;\n    }\n    if (inputValue1 != tempValue1) {\n      return 0;\n    }\n    if ((shiftedInput1 & 0xff000000) == 0) {\n      tempValue1 = inputValue1 << 1;\n      if ((inputValue1 & 0x80000000) != 0) {\n        tempValue1 = tempValue1 | 0x80000000;\n      }\n      return tempValue1;\n    }\n    if (shiftedInput1 < 0xfe000000) {\n      return inputValue1 + 0x800000;\n    }\n    inputValue1 = inputValue1 & 0x80000000;\nLAB_08000bde:\n    return inputValue1 | 0x7f800000;\n  }\n  shiftedInput1 = shiftedInput1 >> 0x18;\n  param4 = param4 >> 0x18;\n  difference = param4 - shiftedInput1;\n  isConditionMet = difference != 0;\n  updatedShiftedInput1 = shiftedInput1;\n  if (isConditionMet && shiftedInput1 <= param4) {\n    updatedShiftedInput1 = shiftedInput1 + difference;\n  }\n  if (isConditionMet && shiftedInput1 <= param4) {\n    tempValue1 = tempValue1 ^ inputValue1;\n  }\n  if (isConditionMet && shiftedInput1 <= param4) {\n    inputValue1 = inputValue1 ^ tempValue1;\n  }\n  if (isConditionMet && shiftedInput1 <= param4) {\n    tempValue1 = tempValue1 ^ inputValue1;\n  }\n  if (param4 < shiftedInput1) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return inputValue1;\n  }\n  shiftedInput1 = inputValue1 & 0xffffff | 0x800000;\n  if ((inputValue1 & 0x80000000) != 0) {\n    shiftedInput1 = -shiftedInput1;\n  }\n  tempValue2 = tempValue1 & 0xffffff | 0x800000;\n  if ((tempValue1 & 0x80000000) != 0) {\n    tempValue2 = -tempValue2;\n  }\n  if (updatedShiftedInput1 == difference) {\n    tempValue2 = tempValue2 ^ 0x800000;\n    if (updatedShiftedInput1 == 0) {\n      shiftedInput1 = shiftedInput1 ^ 0x800000;\n      updatedShiftedInput1 = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  shiftedInput1 = shiftedInput1 + ((int)tempValue2 >> (difference & 0xff));\n  tempValue2 = tempValue2 << (0x20 - difference & 0xff);\n  inputValue1 = shiftedInput1 & 0x80000000;\n  if ((int)shiftedInput1 < 0) {\n    isConditionMet = tempValue2 != 0;\n    tempValue2 = -tempValue2;\n    shiftedInput1 = -shiftedInput1 - (uint)isConditionMet;\n  }\n  if (shiftedInput1 < 0x800000) {\n    tempValue1 = tempValue2 & 0x80000000;\n    tempValue2 = tempValue2 << 1;\n    shiftedInput1 = shiftedInput1 * 2 + (uint)(tempValue1 != 0);\n    tempValue1 = updatedShiftedInput1 - 2;\n    if ((shiftedInput1 & 0x800000) == 0) {\n      difference = LZCOUNT(shiftedInput1) - 8;\n      shiftedInput1 = shiftedInput1 << (difference & 0xff);\n      if ((int)tempValue1 < (int)difference) {\n        shiftedInput1 = shiftedInput1 >> (-(tempValue1 - difference) & 0xff);\n      }\n      else {\n        shiftedInput1 = shiftedInput1 + (tempValue1 - difference) * 0x800000;\n      }\n      return shiftedInput1 | inputValue1;\n    }\n  }\n  else {\n    tempValue1 = updatedShiftedInput1 - 1;\n    if (0xffffff < shiftedInput1) {\n      tempValue1 = shiftedInput1 & 1;\n      shiftedInput1 = shiftedInput1 >> 1;\n      tempValue2 = (uint)(tempValue1 != 0) << 0x1f | tempValue2 >> 1;\n      tempValue1 = updatedShiftedInput1;\n      if (0xfd < updatedShiftedInput1) goto LAB_08000bde;\n    }\n  }\n  shiftedInput1 = shiftedInput1 + tempValue1 * 0x800000 + (uint)(0x7fffffff < tempValue2);\n  if (tempValue2 == 0x80000000) {\n    shiftedInput1 = shiftedInput1 & 0xfffffffe;\n  }\n  return shiftedInput1 | inputValue1;\n}\n\n",
            "renaming": {
                "FUN_08000aa4": "perform_arithmetic_operation_08000aa4",
                "param_1": "inputValue1",
                "param_2": "inputValue2",
                "param_3": "param3",
                "param_4": "param4",
                "iVar1": "shiftedValue1",
                "iVar2": "shiftedValue2",
                "uVar3": "tempValue1",
                "uVar4": "tempValue2",
                "uVar5": "shiftedInput1",
                "uVar6": "updatedShiftedInput1",
                "uVar7": "difference",
                "bVar8": "isConditionMet"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa8": {
            "entrypoint": "0x08000aa8",
            "current_name": "calculate_float_08000aa8",
            "code": "\nuint calculate_float_08000aa8(uint input_1,uint input_2,undefined4 input_3,uint input_4)\n\n{\n  int shifted_input_1;\n  int shifted_input_2;\n  uint shifted_output_1;\n  uint shifted_output_2;\n  uint temp_output_1;\n  uint temp_output_2;\n  bool flag;\n  \n  shifted_output_2 = input_1 << 1;\n  flag = shifted_output_2 == 0;\n  if (!flag) {\n    input_4 = input_2 << 1;\n    flag = input_4 == 0;\n  }\n  if (!flag) {\n    flag = shifted_output_2 == input_4;\n  }\n  shifted_input_1 = (int)shifted_output_2 >> 0x18;\n  if (!flag) {\n    flag = shifted_input_1 == -1;\n  }\n  if (!flag) {\n    flag = (int)input_4 >> 0x18 == -1;\n  }\n  if (flag) {\n    shifted_input_2 = (int)(input_2 << 1) >> 0x18;\n    if (shifted_input_1 == -1 || shifted_input_2 == -1) {\n      shifted_output_2 = input_2;\n      if (shifted_input_1 == -1) {\n        shifted_output_2 = input_1;\n      }\n      if (shifted_input_1 != -1 || shifted_input_2 != -1) {\n        input_2 = shifted_output_2;\n      }\n      flag = (shifted_output_2 & 0x7fffff) == 0;\n      if (flag) {\n        flag = (input_2 & 0x7fffff) == 0;\n      }\n      if (flag) {\n        flag = shifted_output_2 == input_2;\n      }\n      if (!flag) {\n        shifted_output_2 = shifted_output_2 | 0x400000;\n      }\n      return shifted_output_2;\n    }\n    if (((input_1 ^ input_2) & 0x7fffffff) != 0) {\n      if (shifted_output_2 == 0) {\n        input_1 = input_2;\n      }\n      return input_1;\n    }\n    if (input_1 != input_2) {\n      return 0;\n    }\n    if ((shifted_output_2 & 0xff000000) == 0) {\n      shifted_output_2 = input_1 << 1;\n      if ((input_1 & 0x80000000) != 0) {\n        shifted_output_2 = shifted_output_2 | 0x80000000;\n      }\n      return shifted_output_2;\n    }\n    if (shifted_output_2 < 0xfe000000) {\n      return input_1 + 0x800000;\n    }\n    input_1 = input_1 & 0x80000000;\nLAB_08000bde:\n    return input_1 | 0x7f800000;\n  }\n  shifted_output_2 = shifted_output_2 >> 0x18;\n  input_4 = input_4 >> 0x18;\n  temp_output_2 = input_4 - shifted_output_2;\n  flag = temp_output_2 != 0;\n  temp_output_1 = shifted_output_2;\n  if (flag && shifted_output_2 <= input_4) {\n    temp_output_1 = shifted_output_2 + temp_output_2;\n  }\n  if (flag && shifted_output_2 <= input_4) {\n    input_2 = input_2 ^ input_1;\n  }\n  if (flag && shifted_output_2 <= input_4) {\n    input_1 = input_1 ^ input_2;\n  }\n  if (flag && shifted_output_2 <= input_4) {\n    input_2 = input_2 ^ input_1;\n  }\n  if (input_4 < shifted_output_2) {\n    temp_output_2 = -temp_output_2;\n  }\n  if (0x19 < temp_output_2) {\n    return input_1;\n  }\n  shifted_output_2 = input_1 & 0xffffff | 0x800000;\n  if ((input_1 & 0x80000000) != 0) {\n    shifted_output_2 = -shifted_output_2;\n  }\n  shifted_output_1 = input_2 & 0xffffff | 0x800000;\n  if ((input_2 & 0x80000000) != 0) {\n    shifted_output_1 = -shifted_output_1;\n  }\n  if (temp_output_1 == temp_output_2) {\n    shifted_output_1 = shifted_output_1 ^ 0x800000;\n    if (temp_output_1 == 0) {\n      shifted_output_2 = shifted_output_2 ^ 0x800000;\n      temp_output_1 = 1;\n    }\n    else {\n      temp_output_2 = temp_output_2 - 1;\n    }\n  }\n  shifted_output_2 = shifted_output_2 + ((int)shifted_output_1 >> (temp_output_2 & 0xff));\n  shifted_output_1 = shifted_output_1 << (0x20 - temp_output_2 & 0xff);\n  input_1 = shifted_output_2 & 0x80000000;\n  if ((int)shifted_output_2 < 0) {\n    flag = shifted_output_1 != 0;\n    shifted_output_1 = -shifted_output_1;\n    shifted_output_2 = -shifted_output_2 - (uint)flag;\n  }\n  if (shifted_output_2 < 0x800000) {\n    temp_output_2 = shifted_output_1 & 0x80000000;\n    shifted_output_1 = shifted_output_1 << 1;\n    shifted_output_2 = shifted_output_2 * 2 + (uint)(temp_output_2 != 0);\n    temp_output_2 = temp_output_1 - 2;\n    if ((shifted_output_2 & 0x800000) == 0) {\n      temp_output_1 = LZCOUNT(shifted_output_2) - 8;\n      shifted_output_2 = shifted_output_2 << (temp_output_1 & 0xff);\n      if ((int)temp_output_2 < (int)temp_output_1) {\n        shifted_output_2 = shifted_output_2 >> (-(temp_output_2 - temp_output_1) & 0xff);\n      }\n      else {\n        shifted_output_2 = shifted_output_2 + (temp_output_2 - temp_output_1) * 0x800000;\n      }\n      return shifted_output_2 | input_1;\n    }\n  }\n  else {\n    temp_output_2 = temp_output_1 - 1;\n    if (0xffffff < shifted_output_2) {\n      temp_output_2 = shifted_output_2 & 1;\n      shifted_output_2 = shifted_output_2 >> 1;\n      shifted_output_1 = (uint)(temp_output_2 != 0) << 0x1f | shifted_output_1 >> 1;\n      temp_output_2 = temp_output_1;\n      if (0xfd < temp_output_1) goto LAB_08000bde;\n    }\n  }\n  shifted_output_2 = shifted_output_2 + temp_output_2 * 0x800000 + (uint)(0x7fffffff < shifted_output_1);\n  if (shifted_output_1 == 0x80000000) {\n    shifted_output_2 = shifted_output_2 & 0xfffffffe;\n  }\n  return shifted_output_2 | input_1;\n}\n\n",
            "renaming": {
                "FUN_08000aa8": "calculate_float_08000aa8",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "iVar1": "shifted_input_1",
                "iVar2": "shifted_input_2",
                "uVar3": "shifted_output_1",
                "uVar4": "shifted_output_2",
                "uVar5": "temp_output_1",
                "uVar6": "temp_output_2",
                "bVar7": "flag"
            },
            "calling": [
                "__aeabi_frsub",
                "mpu6050_calibrate",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c08": {
            "entrypoint": "0x08000c08",
            "current_name": "count_shifted_sum_08000c08",
            "code": "\nuint countShiftedSum_08000c08(uint number)\n\n{\n  uint shiftedPartialSum;\n  uint shiftedSum;\n  int baseValue;\n  uint shiftedNumber;\n  \n  if (number == 0) {\n    return 0;\n  }\n  shiftedPartialSum = LZCOUNT(number);\n  shiftedSum = shiftedPartialSum - 8;\n  baseValue = shiftedSum * -0x800000 + 0x4a800000;\n  if (7 < shiftedPartialSum) {\n    shiftedNumber = 0 << (shiftedSum & 0xff);\n    shiftedPartialSum = baseValue + (number << (shiftedSum & 0xff)) +\n            (0U >> (0x20 - shiftedSum & 0xff)) + (uint)(0x7fffffff < shiftedNumber);\n    if (shiftedNumber == 0x80000000) {\n      shiftedPartialSum = shiftedPartialSum & 0xfffffffe;\n    }\n    return shiftedPartialSum;\n  }\n  shiftedSum = number << shiftedPartialSum + 0x18;\n  shiftedPartialSum = baseValue + ((number >> (0x20 - (shiftedPartialSum + 0x18) & 0xff)) - ((int)shiftedSum >> 0x1f));\n  if ((shiftedSum & 0x7fffffff) == 0) {\n    shiftedPartialSum = shiftedPartialSum & ~(shiftedSum >> 0x1f);\n  }\n  return shiftedPartialSum;\n}\n\n",
            "renaming": {
                "FUN_08000c08": "count_shifted_sum_08000c08",
                "param_1": "number",
                "uVar1": "shiftedPartialSum",
                "uVar2": "shiftedSum",
                "iVar3": "baseValue",
                "uVar4": "shiftedNumber"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c10": {
            "entrypoint": "0x08000c10",
            "current_name": "calculate_offset_08000c10",
            "code": "\nuint calculateOffset_08000c10(uint input)\n\n{\n  uint leadingZeros;\n  uint shiftValue;\n  uint signBit;\n  int offset;\n  \n  signBit = input & 0x80000000;\n  if ((int)signBit < 0) {\n    input = -input;\n  }\n  if (input == 0) {\n    return 0;\n  }\n  leadingZeros = LZCOUNT(input);\n  shiftValue = leadingZeros - 8;\n  offset = ((signBit | 0x4b000000) - 0x800000) + shiftValue * -0x800000;\n  if (7 < leadingZeros) {\n    leadingZeros = 0 << (shiftValue & 0xff);\n    signBit = offset + (input << (shiftValue & 0xff)) +\n            (0U >> (0x20 - shiftValue & 0xff)) + (uint)(0x7fffffff < leadingZeros);\n    if (leadingZeros == 0x80000000) {\n      signBit = signBit & 0xfffffffe;\n    }\n    return signBit;\n  }\n  shiftValue = input << leadingZeros + 0x18;\n  signBit = offset + ((input >> (0x20 - (leadingZeros + 0x18) & 0xff)) - ((int)shiftValue >> 0x1f));\n  if ((shiftValue & 0x7fffffff) == 0) {\n    signBit = signBit & ~(shiftValue >> 0x1f);\n  }\n  return signBit;\n}\n\n",
            "renaming": {
                "FUN_08000c10": "calculate_offset_08000c10",
                "param_1": "input",
                "uVar1": "leadingZeros",
                "uVar2": "shiftValue",
                "uVar3": "signBit",
                "iVar4": "offset"
            },
            "calling": [
                "mpu6050_update",
                "mpu6050_calibrate",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c2c": {
            "entrypoint": "0x08000c2c",
            "current_name": "calculate_modified_value_08000c2c",
            "code": "\nuint calculateModifiedValue_08000c2c(uint originalValue,uint modifier)\n\n{\n  uint originalValueCopy;\n  uint modifierCopy;\n  uint shiftedBitsCount;\n  uint shiftedBitsMinusEight;\n  int constant;\n  \n  if ((originalValue | modifier) == 0) {\n    return originalValue;\n  }\n  originalValueCopy = originalValue;\n  modifierCopy = modifier;\n  if (modifier == 0) {\n    originalValueCopy = 0;\n    modifierCopy = originalValue;\n  }\n  constant = 0x5b000000;\n  if (modifier == 0) {\n    constant = 0x4b000000;\n  }\n  shiftedBitsCount = LZCOUNT(modifierCopy);\n  shiftedBitsMinusEight = shiftedBitsCount - 8;\n  constant = constant + -0x800000 + shiftedBitsMinusEight * -0x800000;\n  if (shiftedBitsCount < 8) {\n    shiftedBitsMinusEight = modifierCopy << shiftedBitsCount + 0x18;\n    modifierCopy = constant + ((modifierCopy >> (0x20 - (shiftedBitsCount + 0x18) & 0xff)) - ((int)shiftedBitsMinusEight >> 0x1f));\n    if ((originalValueCopy | shiftedBitsMinusEight << 1) == 0) {\n      modifierCopy = modifierCopy & ~(shiftedBitsMinusEight >> 0x1f);\n    }\n    return modifierCopy;\n  }\n  shiftedBitsCount = originalValueCopy << (shiftedBitsMinusEight & 0xff);\n  modifierCopy = constant + (modifierCopy << (shiftedBitsMinusEight & 0xff)) +\n          (originalValueCopy >> (0x20 - shiftedBitsMinusEight & 0xff)) + (uint)(0x7fffffff < shiftedBitsCount);\n  if (shiftedBitsCount == 0x80000000) {\n    modifierCopy = modifierCopy & 0xfffffffe;\n  }\n  return modifierCopy;\n}\n\n",
            "renaming": {
                "FUN_08000c2c": "calculate_modified_value_08000c2c",
                "param_1": "originalValue",
                "param_2": "modifier",
                "uVar1": "originalValueCopy",
                "uVar2": "modifierCopy",
                "uVar3": "shiftedBitsCount",
                "uVar4": "shiftedBitsMinusEight",
                "iVar5": "constant"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c3c": {
            "entrypoint": "0x08000c3c",
            "current_name": "calculate_08000c3c",
            "code": "\nuint calculate_08000c3c(uint input1,uint input2)\n\n{\n  uint temp1;\n  uint temp2;\n  uint count;\n  uint shift;\n  uint sign_bit;\n  int offset;\n  bool is_input1_nonzero;\n  \n  if ((input1 | input2) == 0) {\n    return input1;\n  }\n  sign_bit = input2 & 0x80000000;\n  if ((int)sign_bit < 0) {\n    is_input1_nonzero = input1 != 0;\n    input1 = -input1;\n    input2 = -input2 - (uint)is_input1_nonzero;\n  }\n  temp2 = input1;\n  temp1 = input2;\n  if (input2 == 0) {\n    temp2 = 0;\n    temp1 = input1;\n  }\n  sign_bit = sign_bit | 0x5b000000;\n  if (input2 == 0) {\n    sign_bit = sign_bit + 0xf0000000;\n  }\n  count = countLeadingZeroes(temp1);\n  shift = count - 8;\n  offset = (sign_bit - 0x800000) + shift * -0x800000;\n  if (count < 8) {\n    shift = temp1 << count + 0x18;\n    sign_bit = offset + ((temp1 >> (0x20 - (count + 0x18) & 0xff)) - ((int)shift >> 0x1f));\n    if ((temp2 | shift << 1) == 0) {\n      sign_bit = sign_bit & ~(shift >> 0x1f);\n    }\n    return sign_bit;\n  }\n  count = temp2 << (shift & 0xff);\n  sign_bit = offset + (temp1 << (shift & 0xff)) +\n          (temp2 >> (0x20 - shift & 0xff)) + (uint)(0x7fffffff < count);\n  if (count == 0x80000000) {\n    sign_bit = sign_bit & 0xfffffffe;\n  }\n  return sign_bit;\n}\n\n",
            "renaming": {
                "FUN_08000c3c": "calculate_08000c3c",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "count",
                "uVar4": "shift",
                "uVar5": "sign_bit",
                "iVar6": "offset",
                "bVar7": "is_input1_nonzero",
                "LZCOUNT": "countLeadingZeroes"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cb8": {
            "entrypoint": "0x08000cb8",
            "current_name": "calculate_floating_point_08000cb8",
            "code": "\nuint calculate_floating_point_08000cb8(uint value_1,uint value_2,undefined4 param_3,uint param_4)\n\n{\n  longlong temp_result;\n  uint result;\n  uint value_1_shifted;\n  int sum_shifted_values;\n  int shift_distance;\n  uint result_temp;\n  int loop_iterations;\n  uint result_mask;\n  bool is_condition_met;\n  bool is_borrow;\n  \n  value_1_shifted = value_1 >> 0x17 & 0xff;\n  is_condition_met = value_1_shifted == 0;\n  if (!is_condition_met) {\n    param_4 = value_2 >> 0x17 & 0xff;\n    is_condition_met = param_4 == 0;\n  }\n  if (!is_condition_met) {\n    is_condition_met = value_1_shifted == 0xff;\n  }\n  if (!is_condition_met) {\n    is_condition_met = param_4 == 0xff;\n  }\n  if (is_condition_met) {\n    param_4 = value_2 >> 0x17 & 0xff;\n    if (value_1_shifted == 0xff || param_4 == 0xff) {\n      is_condition_met = value_1 == 0 || value_1 == 0x80000000;\n      result = value_2;\n      if (value_1 != 0 && value_1 != 0x80000000) {\n        is_condition_met = value_2 == 0;\n        result = value_1;\n      }\n      if (!is_condition_met) {\n        is_condition_met = value_2 == 0x80000000;\n      }\n      result_mask = result;\n      if (((is_condition_met) || ((value_1_shifted == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((param_4 == 0xff && (result_mask = value_2, (value_2 & 0x7fffff) != 0)))) {\n        return result_mask | 0x7fc00000;\n      }\n      result = result ^ value_2;\n      goto LAB_08000e08;\n    }\n    is_condition_met = (value_1 & 0x7fffffff) == 0;\n    if (!is_condition_met) {\n      is_condition_met = (value_2 & 0x7fffffff) == 0;\n    }\n    if (is_condition_met) {\n      return (value_1 ^ value_2) & 0x80000000;\n    }\n    is_condition_met = value_1_shifted == 0;\n    result = value_1 & 0x80000000;\n    while( true ) {\n      if (is_condition_met) {\n        value_1 = value_1 << 1;\n        is_condition_met = (value_1 & 0x800000) == 0;\n      }\n      if (!is_condition_met) break;\n      value_1_shifted = value_1_shifted - 1;\n    }\n    value_1 = value_1 | result;\n    is_condition_met = param_4 == 0;\n    result = value_2 & 0x80000000;\n    while( true ) {\n      if (is_condition_met) {\n        value_2 = value_2 << 1;\n        is_condition_met = (value_2 & 0x800000) == 0;\n      }\n      if (!is_condition_met) break;\n      param_4 = param_4 - 1;\n    }\n    value_2 = value_2 | result;\n  }\n  sum_shifted_values = value_1_shifted + param_4;\n  result_mask = value_1 ^ value_2;\n  value_1_shifted = value_1 << 9;\n  is_condition_met = value_1_shifted == 0;\n  if (!is_condition_met) {\n    value_2 = value_2 << 9;\n    is_condition_met = value_2 == 0;\n  }\n  if (is_condition_met) {\n    if (value_1_shifted == 0) {\n      value_2 = value_2 << 9;\n    }\n    result = result_mask & 0x80000000 | value_1 & 0x7fffff | value_2 >> 9;\n    is_borrow = SBORROW4(sum_shifted_values,0x7f);\n    shift_distance = sum_shifted_values + -0x7f;\n    is_condition_met = shift_distance == 0;\n    loop_iterations = shift_distance;\n    if (!is_condition_met && 0x7e < sum_shifted_values) {\n      is_borrow = SBORROW4(0xff,shift_distance);\n      loop_iterations = 0xff - shift_distance;\n      is_condition_met = shift_distance == 0xff;\n    }\n    if (!is_condition_met && loop_iterations < 0 == is_borrow) {\n      result = result | shift_distance * 0x800000;\n    }\n    if (!is_condition_met && loop_iterations < 0 == is_borrow) {\n      return result;\n    }\n    result = result | 0x800000;\n    result_temp = 0;\n    is_borrow = SBORROW4(shift_distance,1);\n    result_mask = sum_shifted_values - 0x80;\n    is_condition_met = result_mask == 0;\n    value_1_shifted = result_mask;\n  }\n  else {\n    temp_result = (ulonglong)(value_1_shifted >> 5 | 0x8000000) * (ulonglong)(value_2 >> 5 | 0x8000000);\n    result_temp = (uint)temp_result;\n    result = (uint)((ulonglong)temp_result >> 0x20);\n    is_condition_met = result < 0x800000;\n    if (is_condition_met) {\n      result = result << 1;\n    }\n    if (is_condition_met) {\n      result = result | result_temp >> 0x1f;\n      result_temp = result_temp << 1;\n    }\n    result = result_mask & 0x80000000 | result;\n    result_mask = (sum_shifted_values + -0x7f) - (uint)is_condition_met;\n    is_borrow = SBORROW4(result_mask,0xfd);\n    is_condition_met = result_mask == 0xfd;\n    value_1_shifted = result_mask - 0xfd;\n    if (result_mask < 0xfe) {\n      result = result + result_mask * 0x800000 + (uint)(0x7fffffff < result_temp);\n      if (result_temp == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (is_condition_met || (int)value_1_shifted < 0 != is_borrow) {\n    is_condition_met = (int)(result_mask + 0x19) < 0;\n    if (result_mask == 0xffffffe7 || is_condition_met != SCARRY4(result_mask,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (result_mask != 0xffffffe7 && is_condition_met == SCARRY4(result_mask,0x19)) {\n      value_1_shifted = (result << 1) >> (-result_mask & 0xff);\n      result_mask = result << (result_mask + 0x20 & 0xff);\n      value_1_shifted = ((uint)((result & 0x80000000) != 0) << 0x1f | value_1_shifted >> 1) + (uint)((byte)value_1_shifted & 1);\n      if ((result_temp | result_mask << 1) == 0) {\n        value_1_shifted = value_1_shifted & ~(result_mask >> 0x1f);\n      }\n      return value_1_shifted;\n    }\n    return result;\n  }\nLAB_08000e08:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000cb8": "calculate_floating_point_08000cb8",
                "param_1": "value_1",
                "param_2": "value_2",
                "uVar2": "result",
                "uVar3": "value_1_shifted",
                "iVar4": "sum_shifted_values",
                "iVar5": "shift_distance",
                "iVar7": "loop_iterations",
                "uVar6": "result_temp",
                "uVar8": "result_mask",
                "bVar9": "is_condition_met",
                "bVar10": "is_borrow",
                "lVar1": "temp_result"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e20": {
            "entrypoint": "0x08000e20",
            "current_name": "calculate_floating_point_08000e20",
            "code": "\nuint calculateFloatingPoint_08000e20(uint value1,uint value2,undefined4 param3,uint param4)\n\n{\n  uint bitMask1;\n  uint bitMask2;\n  int difference;\n  uint tempVar;\n  int tempVar2;\n  uint result;\n  bool checkFlag1;\n  bool checkFlag2;\n  bool checkFlag3;\n  \n  bitMask2 = value1 >> 0x17 & 0xff;\n  checkFlag1 = bitMask2 == 0;\n  if (!checkFlag1) {\n    param4 = value2 >> 0x17 & 0xff;\n    checkFlag1 = param4 == 0;\n  }\n  if (!checkFlag1) {\n    checkFlag1 = bitMask2 == 0xff;\n  }\n  if (!checkFlag1) {\n    checkFlag1 = param4 == 0xff;\n  }\n  if (checkFlag1) {\n    param4 = value2 >> 0x17 & 0xff;\n    result = value1;\n    if (bitMask2 == 0xff) {\n      if (((value1 & 0x7fffff) != 0) || (result = value2, param4 == 0xff)) {\nLAB_08000e16:\n        return result | 0x7fc00000;\n      }\n    }\n    else {\n      if (param4 == 0xff) {\n        result = value2;\n        if ((value2 & 0x7fffff) == 0) {\nLAB_08000dcc:\n          return (value1 ^ value2) & 0x80000000;\n        }\n        goto LAB_08000e16;\n      }\n      checkFlag1 = (value1 & 0x7fffffff) == 0;\n      if (!checkFlag1) {\n        checkFlag1 = (value2 & 0x7fffffff) == 0;\n      }\n      if (!checkFlag1) {\n        checkFlag1 = bitMask2 == 0;\n        result = value1 & 0x80000000;\n        while( true ) {\n          if (checkFlag1) {\n            value1 = value1 << 1;\n            checkFlag1 = (value1 & 0x800000) == 0;\n          }\n          if (!checkFlag1) break;\n          bitMask2 = bitMask2 - 1;\n        }\n        value1 = value1 | result;\n        checkFlag1 = param4 == 0;\n        result = value2 & 0x80000000;\n        while( true ) {\n          if (checkFlag1) {\n            value2 = value2 << 1;\n            checkFlag1 = (value2 & 0x800000) == 0;\n          }\n          if (!checkFlag1) break;\n          param4 = param4 - 1;\n        }\n        value2 = value2 | result;\n        goto LAB_08000e38;\n      }\n      if ((value1 & 0x7fffffff) == 0) {\n        if ((value2 & 0x7fffffff) != 0) goto LAB_08000dcc;\n        goto LAB_08000e16;\n      }\n    }\n    value1 = value1 ^ value2;\n  }\n  else {\nLAB_08000e38:\n    difference = bitMask2 - param4;\n    if (value2 << 9 == 0) {\n      value1 = (value1 ^ value2) & 0x80000000 | value1 & 0x7fffff;\n      checkFlag3 = SCARRY4(difference,0x7f);\n      tempVar2 = difference + 0x7f;\n      checkFlag1 = tempVar2 < 0;\n      checkFlag2 = tempVar2 == 0;\n      if (!checkFlag2 && checkFlag1 == checkFlag3) {\n        checkFlag3 = SBORROW4(0xff,tempVar2);\n        checkFlag1 = 0xff - tempVar2 < 0;\n        checkFlag2 = tempVar2 == 0xff;\n      }\n      if (!checkFlag2 && checkFlag1 == checkFlag3) {\n        value1 = value1 | tempVar2 * 0x800000;\n      }\n      if (!checkFlag2 && checkFlag1 == checkFlag3) {\n        return value1;\n      }\n      value1 = value1 | 0x800000;\n      bitMask2 = 0;\n      checkFlag2 = SBORROW4(tempVar2,1);\n      tempVar = difference + 0x7e;\n      checkFlag1 = tempVar == 0;\n      result = tempVar;\n    }\n    else {\n      bitMask1 = (value2 << 9) >> 4 | 0x10000000;\n      bitMask2 = (value1 << 9) >> 4 | 0x10000000;\n      value1 = (value1 ^ value2) & 0x80000000;\n      checkFlag1 = bitMask1 <= bitMask2;\n      if (!checkFlag1) {\n        bitMask2 = bitMask2 << 1;\n      }\n      tempVar = difference + 0x7d + (uint)checkFlag1;\n      result = 0x800000;\n      do {\n        if (bitMask1 <= bitMask2) {\n          bitMask2 = bitMask2 - bitMask1;\n          value1 = value1 | result;\n        }\n        checkFlag1 = bitMask1 >> 1 <= bitMask2;\n        if (checkFlag1) {\n          bitMask2 = bitMask2 - (bitMask1 >> 1);\n        }\n        if (checkFlag1) {\n          value1 = value1 | result >> 1;\n        }\n        checkFlag1 = bitMask1 >> 2 <= bitMask2;\n        if (checkFlag1) {\n          bitMask2 = bitMask2 - (bitMask1 >> 2);\n        }\n        if (checkFlag1) {\n          value1 = value1 | result >> 2;\n        }\n        checkFlag1 = bitMask1 >> 3 <= bitMask2;\n        if (checkFlag1) {\n          bitMask2 = bitMask2 - (bitMask1 >> 3);\n        }\n        if (checkFlag1) {\n          value1 = value1 | result >> 3;\n        }\n        bitMask2 = bitMask2 * 0x10;\n        checkFlag1 = bitMask2 == 0;\n        if (!checkFlag1) {\n          result = result >> 4;\n          checkFlag1 = result == 0;\n        }\n      } while (!checkFlag1);\n      checkFlag2 = SBORROW4(tempVar,0xfd);\n      checkFlag1 = tempVar == 0xfd;\n      result = tempVar - 0xfd;\n      if (tempVar < 0xfe) {\n        value1 = value1 + tempVar * 0x800000 + (uint)(bitMask1 <= bitMask2);\n        if (bitMask2 - bitMask1 == 0) {\n          value1 = value1 & 0xfffffffe;\n        }\n        return value1;\n      }\n    }\n    if (checkFlag1 || (int)result < 0 != checkFlag2) {\n      checkFlag1 = (int)(tempVar + 0x19) < 0;\n      if (tempVar == 0xffffffe7 || checkFlag1 != SCARRY4(tempVar,0x19)) {\n        value1 = value1 & 0x80000000;\n      }\n      if (tempVar == 0xffffffe7 || checkFlag1 != SCARRY4(tempVar,0x19)) {\n        return value1;\n      }\n      result = (value1 << 1) >> (-tempVar & 0xff);\n      tempVar = value1 << (tempVar + 0x20 & 0xff);\n      result = ((uint)((value1 & 0x80000000) != 0) << 0x1f | result >> 1) + (uint)((byte)result & 1);\n      if ((bitMask2 | tempVar << 1) == 0) {\n        result = result & ~(tempVar >> 0x1f);\n      }\n      return result;\n    }\n  }\n  return value1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000e20": "calculate_floating_point_08000e20",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "bitMask1",
                "uVar2": "bitMask2",
                "iVar3": "difference",
                "uVar4": "tempVar",
                "iVar5": "tempVar2",
                "uVar6": "result",
                "bVar7": "checkFlag1",
                "bVar8": "checkFlag2",
                "bVar9": "checkFlag3"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_calibrate"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f58": {
            "entrypoint": "0x08000f58",
            "current_name": "calculate_result_08000f58",
            "code": "\nuint calculate_result_08000f58(uint input_1,uint input_2)\n\n{\n  bool is_negative_difference;\n  uint doubled_input_1;\n  uint doubled_input_2;\n  uint combined_inputs;\n  bool is_zero;\n  \n  doubled_input_1 = input_1 * 2;\n  doubled_input_2 = input_2 * 2;\n  if (((int)doubled_input_1 >> 0x18 == -1 || (int)doubled_input_2 >> 0x18 == -1) &&\n     ((((int)doubled_input_1 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)doubled_input_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 0xffffffff;\n  }\n  combined_inputs = doubled_input_1 | input_2 & 0x7fffffff;\n  is_zero = combined_inputs == 0;\n  if (!is_zero) {\n    combined_inputs = input_1 ^ input_2;\n    is_zero = combined_inputs == 0;\n  }\n  is_negative_difference = -1 < (int)combined_inputs;\n  if (is_negative_difference) {\n    input_1 = doubled_input_1 + input_2 * -2;\n    is_zero = input_1 == 0;\n  }\n  if ((is_negative_difference && doubled_input_2 <= doubled_input_1) && !is_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_negative_difference || doubled_input_2 > doubled_input_1) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "renaming": {
                "FUN_08000f58": "calculate_result_08000f58",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar2": "doubled_input_1",
                "uVar3": "doubled_input_2",
                "uVar4": "combined_inputs",
                "bVar1": "is_negative_difference",
                "bVar5": "is_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f60": {
            "entrypoint": "0x08000f60",
            "current_name": "calculate_result_08000f60",
            "code": "\nuint calculate_result_08000f60(uint input_1,uint input_2)\n\n{\n  bool is_negative;\n  uint input_1_times_two;\n  uint input_2_times_two;\n  uint combined_values;\n  bool is_zero;\n  \n  input_1_times_two = input_1 * 2;\n  input_2_times_two = input_2 * 2;\n  if (((int)input_1_times_two >> 0x18 == -1 || (int)input_2_times_two >> 0x18 == -1) &&\n     ((((int)input_1_times_two >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)input_2_times_two >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined_values = input_1_times_two | input_2 & 0x7fffffff;\n  is_zero = combined_values == 0;\n  if (!is_zero) {\n    combined_values = input_1 ^ input_2;\n    is_zero = combined_values == 0;\n  }\n  is_negative = -1 < (int)combined_values;\n  if (is_negative) {\n    input_1 = input_1_times_two + input_2 * -2;\n    is_zero = input_1 == 0;\n  }\n  if ((is_negative && input_2_times_two <= input_1_times_two) && !is_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_negative || input_2_times_two > input_1_times_two) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "renaming": {
                "FUN_08000f60": "calculate_result_08000f60",
                "param_1": "input_1",
                "param_2": "input_2",
                "bVar1": "is_negative",
                "uVar2": "input_1_times_two",
                "uVar3": "input_2_times_two",
                "uVar4": "combined_values",
                "bVar5": "is_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f68": {
            "entrypoint": "0x08000f68",
            "current_name": "calculate_result_08000f68",
            "code": "\nuint calculate_result_08000f68(uint input_1,uint input_2)\n\n{\n  bool is_negative;\n  uint double_input_1;\n  uint double_input_2;\n  uint combined_input;\n  bool is_zero;\n  \n  double_input_1 = input_1 * 2;\n  double_input_2 = input_2 * 2;\n  if (((int)double_input_1 >> 0x18 == -1 || (int)double_input_2 >> 0x18 == -1) &&\n     ((((int)double_input_1 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)double_input_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined_input = double_input_1 | input_2 & 0x7fffffff;\n  is_zero = combined_input == 0;\n  if (!is_zero) {\n    combined_input = input_1 ^ input_2;\n    is_zero = combined_input == 0;\n  }\n  is_negative = -1 < (int)combined_input;\n  if (is_negative) {\n    input_1 = double_input_1 + input_2 * -2;\n    is_zero = input_1 == 0;\n  }\n  if ((is_negative && double_input_2 <= double_input_1) && !is_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_negative || double_input_2 > double_input_1) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "renaming": {
                "FUN_08000f68": "calculate_result_08000f68",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar2": "double_input_1",
                "uVar3": "double_input_2",
                "uVar4": "combined_input",
                "bVar1": "is_negative",
                "bVar5": "is_zero"
            },
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fc8": {
            "entrypoint": "0x08000fc8",
            "current_name": "compare_floating_point_values_08000fc8",
            "code": "\nvoid compareFloatingPointValues_08000fc8(undefined4 value1,undefined4 value2)\n\n{\n  __aeabi_cfcmpeq(value2,value1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fc8": "compare_floating_point_values_08000fc8",
                "param_1": "value1",
                "param_2": "value2"
            },
            "calling": [
                "__aeabi_fcmpgt",
                "__aeabi_fcmpge"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fd0": {
            "entrypoint": "0x08000fd0",
            "current_name": "concatenate_parameters_08000fd0",
            "code": "\nundefined8 concatenateParameters_08000fd0(undefined4 firstParameter,undefined4 secondParameter)\n\n{\n  __cmpsf2();\n  return CONCAT44(secondParameter,firstParameter);\n}\n\n",
            "renaming": {
                "FUN_08000fd0": "concatenate_parameters_08000fd0",
                "param_1": "firstParameter",
                "param_2": "secondParameter"
            },
            "calling": [
                "__aeabi_fcmplt",
                "__aeabi_cfrcmple",
                "__aeabi_fcmple",
                "__aeabi_fcmpeq"
            ],
            "called": [
                "__cmpsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fe0": {
            "entrypoint": "0x08000fe0",
            "current_name": "check_equality_08000fe0",
            "code": "\nbool check_equality_08000fe0(void)\n\n{\n  char input_char;\n  \n  __aeabi_cfcmpeq();\n  return input_char != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000fe0": "check_equality_08000fe0",
                "in_ZR": "input_char"
            },
            "calling": [],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ff4": {
            "entrypoint": "0x08000ff4",
            "current_name": "is_zero_string_08000ff4",
            "code": "\nbool is_zero_string_08000ff4(void)\n\n{\n  char input_character;\n  \n  __aeabi_cfcmpeq();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000ff4": "is_zero_string_08000ff4",
                "in_CY": "input_character"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001008": {
            "entrypoint": "0x08001008",
            "current_name": "compare_floating_point_numbers_08001008",
            "code": "\nbool compareFloatingPointNumbers_08001008(void)\n\n{\n  undefined isZeroResult;\n  undefined isCarrySet;\n  \n  __aeabi_cfcmpeq();\n  return !(bool)isCarrySet || (bool)isZeroResult;\n}\n\n",
            "renaming": {
                "FUN_08001008": "compare_floating_point_numbers_08001008",
                "in_ZR": "isZeroResult",
                "in_CY": "isCarrySet"
            },
            "calling": [],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800101c": {
            "entrypoint": "0x0800101c",
            "current_name": "evaluate_condition_0800101c",
            "code": "\nbool evaluate_condition_0800101c(void)\n\n{\n  undefined is_zero_result;\n  undefined carry_flag;\n  \n  __aeabi_cfrcmple();\n  return !(bool)carry_flag || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_0800101c": "evaluate_condition_0800101c",
                "in_ZR": "is_zero_result",
                "in_CY": "carry_flag"
            },
            "calling": [],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001030": {
            "entrypoint": "0x08001030",
            "current_name": "check_if_null_08001030",
            "code": "\nbool check_if_null_08001030(void)\n\n{\n  char input_character;\n  \n  __aeabi_cfrcmple();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001030": "check_if_null_08001030",
                "in_CY": "input_character"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001044": {
            "entrypoint": "0x08001044",
            "current_name": "calculate_unsigned_value_08001044",
            "code": "\nuint calculateUnsignedValue_08001044(uint input)\n\n{\n  uint shiftAmount;\n  \n  if (((input & 0x80000000) != 0) || (input << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shiftAmount = 0x9e - ((input << 1) >> 0x18);\n  if (-1 < (int)shiftAmount) {\n    return (input << 8 | 0x80000000) >> (shiftAmount & 0xff);\n  }\n  if ((shiftAmount == 0xffffff9f) && ((input & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08001044": "calculate_unsigned_value_08001044",
                "param_1": "input",
                "uVar1": "shiftAmount"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001084": {
            "entrypoint": "0x08001084",
            "current_name": "memcpy_32bit_aligned_08001084",
            "code": "\nvoid * memcpy_32bit_aligned_08001084(void *destination,void *source,size_t size)\n\n{\n  undefined *dest_ptr;\n  undefined4 *dest_ptr_4byte_aligned;\n  undefined4 *dest_4byte_aligned;\n  undefined *dest_ptr_8byte_aligned;\n  undefined4 *src_4byte_aligned;\n  undefined *src_ptr_8byte_aligned;\n  uint remainder_size;\n  uint adjusted_size;\n  bool is_adjusted_size_less;\n  \n  dest_4byte_aligned = (undefined4 *)destination;\n  if ((((uint)source | (uint)destination) & 3) != 0) {\n    if (size < 8) {\n      adjusted_size = size - 4;\n      dest_ptr = (undefined *)destination;\n      if (3 < size) {\n        do {\n          src_ptr_8byte_aligned = (undefined *)source;\n          dest_ptr_8byte_aligned = dest_ptr;\n          is_adjusted_size_less = adjusted_size != 0;\n          adjusted_size = adjusted_size - 1;\n          *dest_ptr_8byte_aligned = *src_ptr_8byte_aligned;\n          dest_ptr = dest_ptr_8byte_aligned + 1;\n          source = src_ptr_8byte_aligned + 1;\n        } while (is_adjusted_size_less);\n        dest_ptr_8byte_aligned[1] = src_ptr_8byte_aligned[1];\n        dest_ptr_8byte_aligned[2] = src_ptr_8byte_aligned[2];\n        dest_ptr_8byte_aligned[3] = src_ptr_8byte_aligned[3];\n        return destination;\n      }\n      goto copy_remaining_bytes;\n    }\n    if ((((uint)source & 3) != 0) && (((uint)destination & 3) != 0)) {\n      adjusted_size = 4 - ((uint)destination & 3);\n      size = size - adjusted_size;\n      dest_ptr_4byte_aligned = (undefined4 *)destination;\n      src_4byte_aligned = (undefined4 *)source;\n                    /* WARNING: Load size is inaccurate */\n      if (((uint)destination & 1) != 0) {\n        src_4byte_aligned = (undefined4 *)((int)source + 1);\n        dest_ptr_4byte_aligned = (undefined4 *)((int)destination + 1);\n        *(undefined *)destination = *source;\n      }\n      dest_4byte_aligned = dest_ptr_4byte_aligned;\n      source = src_4byte_aligned;\n      if ((adjusted_size & 2) != 0) {\n        source = (void *)((int)src_4byte_aligned + 2);\n        dest_4byte_aligned = (undefined4 *)((int)dest_ptr_4byte_aligned + 2);\n        *(undefined2 *)dest_ptr_4byte_aligned = *(undefined2 *)src_4byte_aligned;\n      }\n    }\n  }\n  while (0x3f < size) {\n                    /* WARNING: Load size is inaccurate */\n    *dest_4byte_aligned = *source;\n    dest_4byte_aligned[1] = *(undefined4 *)((int)source + 4);\n    dest_4byte_aligned[2] = *(undefined4 *)((int)source + 8);\n    dest_4byte_aligned[3] = *(undefined4 *)((int)source + 0xc);\n    dest_4byte_aligned[4] = *(undefined4 *)((int)source + 0x10);\n    dest_4byte_aligned[5] = *(undefined4 *)((int)source + 0x14);\n    dest_4byte_aligned[6] = *(undefined4 *)((int)source + 0x18);\n    dest_4byte_aligned[7] = *(undefined4 *)((int)source + 0x1c);\n    dest_4byte_aligned[8] = *(undefined4 *)((int)source + 0x20);\n    dest_4byte_aligned[9] = *(undefined4 *)((int)source + 0x24);\n    dest_4byte_aligned[10] = *(undefined4 *)((int)source + 0x28);\n    dest_4byte_aligned[0xb] = *(undefined4 *)((int)source + 0x2c);\n    dest_4byte_aligned[0xc] = *(undefined4 *)((int)source + 0x30);\n    dest_4byte_aligned[0xd] = *(undefined4 *)((int)source + 0x34);\n    dest_4byte_aligned[0xe] = *(undefined4 *)((int)source + 0x38);\n    dest_4byte_aligned[0xf] = *(undefined4 *)((int)source + 0x3c);\n    dest_4byte_aligned = dest_4byte_aligned + 0x10;\n    source = (undefined4 *)((int)source + 0x40);\n    size = size - 0x40;\n  }\n  remainder_size = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n                    /* WARNING: Load size is inaccurate */\n      *dest_4byte_aligned = *source;\n      dest_4byte_aligned[1] = *(undefined4 *)((int)source + 4);\n      dest_4byte_aligned[2] = *(undefined4 *)((int)source + 8);\n      dest_4byte_aligned[3] = *(undefined4 *)((int)source + 0xc);\n      dest_4byte_aligned = dest_4byte_aligned + 4;\n      source = (void *)((int)source + 0x10);\n      is_adjusted_size_less = 0xf < remainder_size;\n      remainder_size = remainder_size - 0x10;\n    } while (is_adjusted_size_less);\n  }\n  adjusted_size = remainder_size + 0xc;\n  src_4byte_aligned = dest_4byte_aligned;\n  dest_ptr_4byte_aligned = (undefined4 *)source;\n  if (0xfffffff3 < remainder_size) {\n    do {\n      source = dest_ptr_4byte_aligned + 1;\n      *src_4byte_aligned = *dest_ptr_4byte_aligned;\n      is_adjusted_size_less = 3 < adjusted_size;\n      adjusted_size = adjusted_size - 4;\n      dest_4byte_aligned = src_4byte_aligned + 1;\n      src_4byte_aligned = src_4byte_aligned + 1;\n      dest_ptr_4byte_aligned = (undefined4 *)source;\n    } while (is_adjusted_size_less);\n  }\ncopy_remaining_bytes:\n  if (adjusted_size + 4 != 0) {\n    dest_ptr_4byte_aligned = dest_4byte_aligned;\n    src_4byte_aligned = (undefined4 *)source;\n                    /* WARNING: Load size is inaccurate */\n    if ((adjusted_size & 1) != 0) {\n      src_4byte_aligned = (undefined4 *)((int)source + 1);\n      dest_ptr_4byte_aligned = (undefined4 *)((int)dest_4byte_aligned + 1);\n      *(undefined *)dest_4byte_aligned = *source;\n    }\n    if ((adjusted_size + 4 & 2) != 0) {\n      *(undefined2 *)dest_ptr_4byte_aligned = *(undefined2 *)src_4byte_aligned;\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08001084": "memcpy_32bit_aligned_08001084",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "puVar1": "dest_ptr",
                "puVar2": "dest_ptr_4byte_aligned",
                "puVar3": "dest_4byte_aligned",
                "puVar4": "dest_ptr_8byte_aligned",
                "puVar5": "src_4byte_aligned",
                "puVar6": "src_ptr_8byte_aligned",
                "uVar7": "remainder_size",
                "uVar8": "adjusted_size",
                "bVar9": "is_adjusted_size_less",
                "LAB_08001108": "copy_remaining_bytes"
            },
            "calling": [
                "__ssprint_r",
                "_dtoa_r",
                "__multadd"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001170": {
            "entrypoint": "0x08001170",
            "current_name": "is_valid_parameters_08001170",
            "code": "\nundefined4 is_valid_parameters_08001170(uint input1,int input2,uint input3,int input4)\n\n{\n  if ((((input2 << 1) >> 0x15 != -1) || ((input1 | input2 << 0xc) == 0)) &&\n     (((input4 << 1) >> 0x15 != -1 || ((input3 | input4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08001170": "is_valid_parameters_08001170",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800119c": {
            "entrypoint": "0x0800119c",
            "current_name": "calculate_inverse_0800119c",
            "code": "\nuint calculate_inverse_0800119c(uint input_value,uint multiplier)\n\n{\n  uint result;\n  int shifted_multiplier;\n  uint temp_value;\n  \n  shifted_multiplier = multiplier * 2 + 0x200000;\n  if (multiplier * 2 < 0xffe00000) {\n    if (-1 < shifted_multiplier) {\n      return 0;\n    }\n    result = shifted_multiplier >> 0x15;\n    temp_value = -result - 0x3e1;\n    if (result < 0xfffffc20 && temp_value != 0) {\n      result = (multiplier << 0xb | 0x80000000 | input_value >> 0x15) >> (temp_value & 0xff);\n      if ((multiplier & 0x80000000) != 0) {\n        result = -result;\n      }\n      return result;\n    }\n  }\n  else if ((input_value | multiplier << 0xc) != 0) {\n    return 0;\n  }\n  multiplier = multiplier & 0x80000000;\n  if (multiplier == 0) {\n    multiplier = 0x7fffffff;\n  }\n  return multiplier;\n}\n\n",
            "renaming": {
                "FUN_0800119c": "calculate_inverse_0800119c",
                "param_1": "input_value",
                "param_2": "multiplier",
                "uVar1": "result",
                "iVar2": "shifted_multiplier",
                "uVar3": "temp_value"
            },
            "calling": [
                "_svfprintf_r",
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011ec": {
            "entrypoint": "0x080011ec",
            "current_name": "divide_or_throw_error_080011ec",
            "code": "\nvoid divideOrThrowError_080011ec(int dividend,int divisor,int quotient,int remainder)\n\n{\n  if ((remainder == 0) && (quotient == 0)) {\n    if (divisor != 0 || dividend != 0) {\n      divisor = -1;\n      dividend = -1;\n    }\n    __aeabi_idiv0(dividend,divisor);\n    return;\n  }\n  __udivmoddi4();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080011ec": "divide_or_throw_error_080011ec",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__udivmoddi4",
                "__aeabi_idiv0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800121c": {
            "entrypoint": "0x0800121c",
            "current_name": "calculate_division_remainder_0800121c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080014b2) */\n\nundefined8 calculateDivisionRemainder_0800121c(uint dividend,uint dividend_high,uint divisor,uint divisor_high,uint *quotient_and_remainder)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  ulonglong result;\n  uint quotient;\n  uint rem;\n  uint uVar4;\n  int shift_amount;\n  uint quotient_low;\n  uint divisor_high_shifted;\n  uint rem_high;\n  uint *ptemp;\n  uint quotient_high;\n  uint partial_quotient;\n  uint partial_remainder;\n  bool carry;\n  undefined8 returnValue;\n  \n  if (divisor_high == 0) {\n    if (dividend_high < divisor) {\n      shift_amount = LZCOUNT(divisor);\n      divisor_high_shifted = divisor;\n      if (shift_amount != 0) {\n        divisor_high_shifted = divisor << shift_amount;\n        dividend_high = dividend >> (0x20U - shift_amount & 0xff) | dividend_high << shift_amount;\n        dividend = dividend << shift_amount;\n      }\n      partial_quotient = divisor_high_shifted >> 0x10;\n      rem_high = dividend_high / partial_quotient;\n      quotient_high = rem_high * (divisor_high_shifted & 0xffff);\n      quotient_low = dividend >> 0x10 | (dividend_high - partial_quotient * rem_high) * 0x10000;\n      rem = rem_high;\n      if (quotient_low <= quotient_high && quotient_high - quotient_low != 0) {\n        carry = CARRY4(divisor_high_shifted,quotient_low);\n        quotient_low = divisor_high_shifted + quotient_low;\n        rem = rem_high - 1;\n        if ((carry == false) && (quotient_low <= quotient_high && quotient_high - quotient_low != 0)) {\n          rem = rem_high - 2;\n          quotient_low = quotient_low + divisor_high_shifted;\n        }\n      }\n      quotient = (quotient_low - quotient_high) / partial_quotient;\n      uVar4 = quotient * (divisor_high_shifted & 0xffff);\n      rem_high = dividend & 0xffff | ((quotient_low - quotient_high) - partial_quotient * quotient) * 0x10000;\n      quotient_low = quotient;\n      if (rem_high <= uVar4 && uVar4 - rem_high != 0) {\n        carry = CARRY4(divisor_high_shifted,rem_high);\n        rem_high = divisor_high_shifted + rem_high;\n        quotient_low = quotient - 1;\n        if ((carry == false) && (rem_high <= uVar4 && uVar4 - rem_high != 0)) {\n          quotient_low = quotient - 2;\n          rem_high = rem_high + divisor_high_shifted;\n        }\n      }\n      quotient_low = quotient_low | rem << 0x10;\n      ptemp = (uint *)0x0;\n      rem_high = rem_high - uVar4;\n    }\n    else {\n      if (divisor == 0) {\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x8001302);\n        returnValue = (*UNRECOVERED_JUMPTABLE)();\n        return returnValue;\n      }\n      shift_amount = LZCOUNT(divisor);\n      if (shift_amount == 0) {\n        ptemp = (uint *)0x1;\n        dividend_high = dividend_high - divisor;\n        partial_quotient = divisor >> 0x10;\n        quotient = divisor & 0xffff;\n        divisor_high_shifted = divisor;\n      }\n      else {\n        divisor_high_shifted = divisor << shift_amount;\n        quotient_low = dividend_high >> (0x20U - shift_amount & 0xff);\n        partial_quotient = divisor_high_shifted >> 0x10;\n        quotient_high = quotient_low / partial_quotient;\n        quotient = divisor_high_shifted & 0xffff;\n        uVar4 = quotient_high * quotient;\n        rem_high = dividend >> (0x20U - shift_amount & 0xff) | dividend_high << shift_amount;\n        rem = rem_high >> 0x10 | (quotient_low - partial_quotient * quotient_high) * 0x10000;\n        dividend = dividend << shift_amount;\n        quotient_low = quotient_high;\n        if (rem <= uVar4 && uVar4 - rem != 0) {\n          carry = CARRY4(divisor_high_shifted,rem);\n          rem = divisor_high_shifted + rem;\n          quotient_low = quotient_high - 1;\n          if ((carry == false) && (rem <= uVar4 && uVar4 - rem != 0)) {\n            quotient_low = quotient_high - 2;\n            rem = rem + divisor_high_shifted;\n          }\n        }\n        quotient_high = (rem - uVar4) / partial_quotient;\n        partial_remainder = quotient_high * quotient;\n        dividend_high = rem_high & 0xffff | ((rem - uVar4) - partial_quotient * quotient_high) * 0x10000;\n        rem = quotient_high;\n        if (dividend_high <= partial_remainder && partial_remainder - dividend_high != 0) {\n          carry = CARRY4(divisor_high_shifted,dividend_high);\n          dividend_high = divisor_high_shifted + dividend_high;\n          rem = quotient_high - 1;\n          if ((carry == false) && (dividend_high <= partial_remainder && partial_remainder - dividend_high != 0)) {\n            rem = quotient_high - 2;\n            dividend_high = dividend_high + divisor_high_shifted;\n          }\n        }\n        dividend_high = dividend_high - partial_remainder;\n        ptemp = (uint *)(rem | quotient_low << 0x10);\n      }\n      quotient_high = dividend_high / partial_quotient;\n      quotient_low = quotient * quotient_high;\n      rem_high = dividend >> 0x10 | (dividend_high - partial_quotient * quotient_high) * 0x10000;\n      rem = quotient_high;\n      if (rem_high <= quotient_low && quotient_low - rem_high != 0) {\n        carry = CARRY4(divisor_high_shifted,rem_high);\n        rem_high = divisor_high_shifted + rem_high;\n        rem = quotient_high - 1;\n        if ((carry == false) && (rem_high <= quotient_low && quotient_low - rem_high != 0)) {\n          rem = quotient_high - 2;\n          rem_high = rem_high + divisor_high_shifted;\n        }\n      }\n      quotient_high = (rem_high - quotient_low) / partial_quotient;\n      quotient = quotient * quotient_high;\n      rem_high = dividend & 0xffff | ((rem_high - quotient_low) - partial_quotient * quotient_high) * 0x10000;\n      quotient_low = quotient_high;\n      if (rem_high <= quotient && quotient - rem_high != 0) {\n        carry = CARRY4(divisor_high_shifted,rem_high);\n        rem_high = divisor_high_shifted + rem_high;\n        quotient_low = quotient_high - 1;\n        if ((carry == false) && (rem_high <= quotient && quotient - rem_high != 0)) {\n          quotient_low = quotient_high - 2;\n          rem_high = rem_high + divisor_high_shifted;\n        }\n      }\n      rem_high = rem_high - quotient;\n      quotient_low = quotient_low | rem << 0x10;\n    }\n    if (quotient_and_remainder != (uint *)0x0) {\n      *quotient_and_remainder = rem_high >> LZCOUNT(divisor);\n      quotient_and_remainder[1] = 0;\n    }\n  }\n  else {\n    ptemp = quotient_and_remainder;\n    if (dividend_high < divisor_high) {\n      if (quotient_and_remainder != (uint *)0x0) {\n        *quotient_and_remainder = dividend;\n        quotient_and_remainder[1] = dividend_high;\n        return 0;\n      }\n      quotient_low = 0;\n    }\n    else {\n      shift_amount = LZCOUNT(divisor_high);\n      if (shift_amount == 0) {\n        if ((divisor_high < dividend_high) || (divisor <= dividend)) {\n          carry = dividend < divisor;\n          dividend = dividend - divisor;\n          dividend_high = (dividend_high - divisor_high) - (uint)carry;\n          quotient_low = 1;\n        }\n        else {\n          quotient_low = 0;\n        }\n        ptemp = (uint *)0x0;\n        if (quotient_and_remainder != (uint *)0x0) {\n          *quotient_and_remainder = dividend;\n          quotient_and_remainder[1] = dividend_high;\n        }\n      }\n      else {\n        rem_high = 0x20 - shift_amount;\n        quotient = divisor >> (rem_high & 0xff) | divisor_high << shift_amount;\n        divisor_high_shifted = dividend_high >> (rem_high & 0xff);\n        uVar4 = quotient >> 0x10;\n        quotient_high = divisor_high_shifted / uVar4;\n        partial_quotient = quotient_high * (quotient & 0xffff);\n        quotient_low = dividend_high << shift_amount | dividend >> (rem_high & 0xff);\n        rem = quotient_low >> 0x10 | (divisor_high_shifted - uVar4 * quotient_high) * 0x10000;\n        dividend = dividend << shift_amount;\n        divisor_high_shifted = quotient_high;\n        if (rem <= partial_quotient && partial_quotient - rem != 0) {\n          carry = CARRY4(quotient,rem);\n          rem = quotient + rem;\n          divisor_high_shifted = quotient_high - 1;\n          if ((carry == false) && (rem <= partial_quotient && partial_quotient - rem != 0)) {\n            divisor_high_shifted = quotient_high - 2;\n            rem = rem + quotient;\n          }\n        }\n        quotient_high = (rem - partial_quotient) / uVar4;\n        partial_remainder = quotient_high * (quotient & 0xffff);\n        rem = quotient_low & 0xffff | ((rem - partial_quotient) - uVar4 * quotient_high) * 0x10000;\n        quotient_low = quotient_high;\n        if (rem <= partial_remainder && partial_remainder - rem != 0) {\n          carry = CARRY4(quotient,rem);\n          rem = quotient + rem;\n          quotient_low = quotient_high - 1;\n          if ((carry == false) && (rem <= partial_remainder && partial_remainder - rem != 0)) {\n            quotient_low = quotient_high - 2;\n            rem = rem + quotient;\n          }\n        }\n        quotient_low = quotient_low | divisor_high_shifted << 0x10;\n        result = (ulonglong)quotient_low * (ulonglong)(divisor << shift_amount);\n        if (CONCAT44(rem - partial_remainder,dividend) < result) {\n          quotient_low = quotient_low - 1;\n          result = result - CONCAT44(quotient,divisor << shift_amount);\n        }\n        if (quotient_and_remainder != (uint *)0x0) {\n          divisor_high_shifted = ((rem - partial_remainder) - (int)(result >> 0x20)) - (uint)(dividend < (uint)result);\n          *quotient_and_remainder = divisor_high_shifted << (rem_high & 0xff) | dividend - (uint)result >> shift_amount;\n          quotient_and_remainder[1] = divisor_high_shifted >> shift_amount;\n          ptemp = (uint *)0x0;\n        }\n      }\n    }\n  }\n  return CONCAT44(ptemp,quotient_low);\n}\n\n",
            "renaming": {
                "FUN_0800121c": "calculate_division_remainder_0800121c",
                "param_1": "dividend",
                "param_2": "dividend_high",
                "param_3": "divisor",
                "param_4": "divisor_high",
                "param_5": "quotient_and_remainder",
                "uVar1": "result",
                "uVar2": "quotient",
                "uVar3": "rem",
                "iVar5": "shift_amount",
                "uVar6": "quotient_low",
                "uVar7": "divisor_high_shifted",
                "uVar8": "rem_high",
                "uVar9": "temp",
                "uVar10": "quotient_high",
                "uVar11": "partial_quotient",
                "uVar12": "partial_remainder",
                "bVar13": "carry",
                "uVar14": "returnValue"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014ec": {
            "entrypoint": "0x080014ec",
            "current_name": "FUNC_080014ec",
            "code": "\nvoid FUNC_080014ec(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080014ec": "FUNC_080014ec"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080014f0": {
            "entrypoint": "0x080014f0",
            "current_name": "initialize_system_080014f0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nSystemStatus initializeSystem_080014f0(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  setInterruptPriorityGrouping(3);\n  initializeTick(0xf);\n  initializePeriph();\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080014f0": "initialize_system_080014f0",
                "HAL_StatusTypeDef": "SystemStatus",
                "HAL_NVIC_SetPriorityGrouping": "setInterruptPriorityGrouping",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializePeriph"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_MspInit",
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800151c": {
            "entrypoint": "0x0800151c",
            "current_name": "configure_sys_tick_0800151c",
            "code": "\nHAL_StatusTypeDef configureSysTick_0800151c(uint32_t priority)\n\n{\n  uint32_t systickConfigStatus;\n  HAL_StatusTypeDef status;\n  uint32_t localPriority;\n  \n  systickConfigStatus = HAL_SYSTICK_Config((uint32_t)((ulonglong)SystemCoreClock / (1000 / (ulonglong)uwTickFreq))\n                            );\n  if (systickConfigStatus == 0) {\n    if (priority < 0x10) {\n      HAL_NVIC_SetPriority(SysTick_IRQn,priority,0);\n      status = HAL_OK;\n      uwTickPrio = priority;\n    }\n    else {\n      status = HAL_ERROR;\n    }\n  }\n  else {\n    status = HAL_ERROR;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800151c": "configure_sys_tick_0800151c",
                "TickPriority": "priority",
                "uVar1": "systickConfigStatus",
                "HVar2": "status",
                "TickPriority_local": "localPriority"
            },
            "calling": [
                "HAL_Init",
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800157c": {
            "entrypoint": "0x0800157c",
            "current_name": "increment_tick_0800157c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid incrementTick_0800157c(void)\n\n{\n  currentTick = currentTick + tickFrequency;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800157c": "increment_tick_0800157c",
                "uwTick": "currentTick",
                "uwTickFreq": "tickFrequency"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015a0": {
            "entrypoint": "0x080015a0",
            "current_name": "get_system_tick_080015a0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemTick_080015a0(void)\n\n{\n  return systemTick;\n}\n\n",
            "renaming": {
                "FUN_080015a0": "get_system_tick_080015a0",
                "uwTick": "systemTick"
            },
            "calling": [
                "I2C_RequestMemoryRead",
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "HAL_I2C_Mem_Write",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_I2C_Mem_Read",
                "I2C_WaitOnBTFFlagUntilTimeout",
                "HAL_RCC_OscConfig",
                "I2C_WaitOnTXEFlagUntilTimeout",
                "I2C_RequestMemoryWrite",
                "_get_ms_tick",
                "HAL_UART_Transmit",
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b4": {
            "entrypoint": "0x080015b4",
            "current_name": "configure_priority_group_080015b4",
            "code": "\n\n\nvoid configurePriorityGroup_080015b4(uint32_t newPriorityGroup)\n\n{\n  uint32_t localPriorityGroup;\n  uint32_t registerValue;\n  uint32_t temporaryPriorityGroup;\n  \n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | (newPriorityGroup & 7) << 8 | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b4": "configure_priority_group_080015b4",
                "PriorityGroup": "newPriorityGroup",
                "PriorityGroup_local": "localPriorityGroup",
                "reg_value": "registerValue",
                "PriorityGroupTmp": "temporaryPriorityGroup"
            },
            "calling": [
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015fc": {
            "entrypoint": "0x080015fc",
            "current_name": "get_bits_from_register_080015fc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_bits_from_register_080015fc(void)\n\n{\n  return _DAT_e000ed0c >> 8 & 7;\n}\n\n",
            "renaming": {
                "FUN_080015fc": "get_bits_from_register_080015fc"
            },
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001618": {
            "entrypoint": "0x08001618",
            "current_name": "set_interrupt_priority_08001618",
            "code": "\nvoid setInterruptPriority_08001618(interruptNumber_Type interruptNumber,uint32_t interruptPriority)\n\n{\n  uint32_t localPriority;\n  interruptNumber_Type localInterruptNumber;\n  \n  if (interruptNumber < WWDG_interruptNumber) {\n    *(char *)(((byte)interruptNumber & 0xf) + 0xe000ed14) = (char)((interruptPriority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interruptNumber + -0x1fff1c00) = (char)((interruptPriority & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001618": "set_interrupt_priority_08001618",
                "IRQn": "interruptNumber",
                "priority": "interruptPriority",
                "priority_local": "localPriority",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "HAL_NVIC_SetPriority",
                "SysTick_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800166c": {
            "entrypoint": "0x0800166c",
            "current_name": "calculate_priority_0800166c",
            "code": "\nuint32_t calculatePriority_0800166c(uint32_t priorityGroup,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint groupBits;\n  uint remainingBits;\n  uint32_t calculatedSubPriority;\n  uint32_t calculatedPreemptPriority;\n  uint32_t calculatedPriorityGroup;\n  uint32_t subPriorityBits;\n  uint32_t preemptPriorityBits;\n  uint32_t temporaryPriorityGroup;\n  \n  groupBits = priorityGroup & 7;\n  remainingBits = 7 - groupBits;\n  if (3 < remainingBits) {\n    remainingBits = 4;\n  }\n  if (groupBits + 4 < 7) {\n    groupBits = 0;\n  }\n  else {\n    groupBits = groupBits - 3;\n  }\n  return subPriority & ~(-1 << (groupBits & 0xff)) |\n         (~(-1 << (remainingBits & 0xff)) & preemptPriority) << (groupBits & 0xff);\n}\n\n",
            "renaming": {
                "FUN_0800166c": "calculate_priority_0800166c",
                "PriorityGroup": "priorityGroup",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "SubPriority_local": "calculatedSubPriority",
                "PreemptPriority_local": "calculatedPreemptPriority",
                "PriorityGroup_local": "calculatedPriorityGroup",
                "SubPriorityBits": "subPriorityBits",
                "PreemptPriorityBits": "preemptPriorityBits",
                "PriorityGroupTmp": "temporaryPriorityGroup",
                "uVar1": "groupBits",
                "uVar2": "remainingBits"
            },
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016d0": {
            "entrypoint": "0x080016d0",
            "current_name": "check_ticks_valid_080016d0",
            "code": "\n\n\nuint32_t checkTicksValid_080016d0(uint32_t ticks)\n\n{\n  bool isTicksValid;\n  uint32_t validTicks;\n  \n  isTicksValid = ticks - 1 < 0x1000000;\n  if (isTicksValid) {\n    _DAT_e000e014 = ticks - 1;\n    NVIC_SetPriority(SysTick_IRQn,0xf);\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n  }\n  return (uint)!isTicksValid;\n}\n\n",
            "renaming": {
                "FUN_080016d0": "check_ticks_valid_080016d0",
                "bVar1": "isTicksValid",
                "ticks_local": "validTicks"
            },
            "calling": [
                "HAL_SYSTICK_Config"
            ],
            "called": [
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001714": {
            "entrypoint": "0x08001714",
            "current_name": "set_priority_group_08001714",
            "code": "\nvoid setPriorityGroup_08001714(uint32_t priorityGroup)\n\n{\n  uint32_t localPriorityGroup;\n  \n  NVIC_SetpriorityGrouping(priorityGroup);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001714": "set_priority_group_08001714",
                "PriorityGroup": "priorityGroup",
                "PriorityGroup_local": "localPriorityGroup"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [
                "NVIC_SetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800172a": {
            "entrypoint": "0x0800172a",
            "current_name": "set_irq_priority_0800172a",
            "code": "\nvoid setIRQPriority_0800172a(IRQNumber_Type IRQNumber,uint32_t PreemptionPriority,uint32_t SubPriority)\n\n{\n  uint32_t priorityGrouping;\n  uint32_t localSubPriority;\n  uint32_t localPreemptionPriority;\n  IRQNumber_Type localIRQNumber;\n  uint32_t priorityGroup;\n  \n  priorityGrouping = NVIC_GetPriorityGrouping();\n  priorityGrouping = NVIC_EncodePriority(priorityGrouping,PreemptionPriority,SubPriority);\n  NVIC_SetPriority(IRQNumber,priorityGrouping);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800172a": "set_irq_priority_0800172a",
                "IRQn": "IRQNumber",
                "PreemptPriority": "PreemptionPriority",
                "uVar1": "priorityGrouping",
                "SubPriority_local": "localSubPriority",
                "PreemptPriority_local": "localPreemptionPriority",
                "IRQn_local": "localIRQNumber",
                "prioritygroup": "priorityGroup"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [
                "NVIC_EncodePriority",
                "NVIC_GetPriorityGrouping",
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001762": {
            "entrypoint": "0x08001762",
            "current_name": "configure_sys_tick_timer_08001762",
            "code": "\nuint32_t configureSysTickTimer_08001762(uint32_t ticksNumber)\n\n{\n  uint32_t configResult;\n  uint32_t localTicksNumber;\n  \n  configResult = SysTick_Config(ticksNumber);\n  return configResult;\n}\n\n",
            "renaming": {
                "FUN_08001762": "configure_sys_tick_timer_08001762",
                "TicksNumb": "ticksNumber",
                "uVar1": "configResult",
                "TicksNumb_local": "localTicksNumber"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [
                "SysTick_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800177c": {
            "entrypoint": "0x0800177c",
            "current_name": "configure_clock_source_0800177c",
            "code": "\n\n\nvoid configureClockSource_0800177c(uint32_t source)\n\n{\n  uint32_t localSource;\n  \n  if (source == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800177c": "configure_clock_source_0800177c",
                "CLKSource": "source",
                "CLKSource_local": "localSource"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017b4": {
            "entrypoint": "0x080017b4",
            "current_name": "update_timer_callback_080017b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateTimerCallback_080017b4(void)\n\n{\n  handlePeriodElapsed((timerHandle *)0x0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080017b4": "update_timer_callback_080017b4",
                "TIM_HandleTypeDef": "timerHandle",
                "HAL_TIM_PeriodElapsedCallback": "handlePeriodElapsed"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017c4": {
            "entrypoint": "0x080017c4",
            "current_name": "configure_gpio_080017c4",
            "code": "\n\n\nvoid configureGPIO_080017c4(GPIO_TypeDef *gpioPort,gpioConfigTypeDef *gpioConfig)\n\n{\n  uint bitMask;\n  uint pinVal;\n  uint modeVal;\n  GPIO_TypeDef *gpioReg;\n  int portNum;\n  gpioConfigTypeDef *local_gpioConfig;\n  GPIO_TypeDef *local_gpioPort;\n  uint32_t tempReg;\n  uint32_t *configReg;\n  uint32_t regOffset;\n  uint32_t tempVal;\n  uint32_t ioCurrent;\n  uint32_t ioPosition;\n  uint32_t configVal;\n  uint32_t posVal;\n  \n  configVal = 0;\n  posVal = 0;\n  do {\n    if (0xf < posVal) {\n      return;\n    }\n    bitMask = 1 << (posVal & 0xff);\n    pinVal = gpioConfig->Pin & bitMask;\n    if (pinVal == bitMask) {\n      modeVal = gpioConfig->Mode;\n      if (modeVal == 0x12) {\n        configVal = gpioConfig->Speed + 0xc;\n      }\n      else if (modeVal < 0x13) {\n        if (modeVal == 2) {\n          configVal = gpioConfig->Speed + 8;\n        }\n        else if (modeVal < 3) {\n          if (modeVal == 0) goto LAB_08001882;\n          if (modeVal == 1) {\n            configVal = gpioConfig->Speed;\n          }\n        }\n        else if (modeVal == 3) {\n          configVal = 0;\n        }\n        else if (modeVal == 0x11) {\n          configVal = gpioConfig->Speed + 4;\n        }\n      }\n      else if (modeVal == 0x10210000) {\nLAB_08001882:\n        if (gpioConfig->Pull == 0) {\n          configVal = 4;\n        }\n        else if (gpioConfig->Pull == 1) {\n          configVal = 8;\n          gpioPort->BSRR = bitMask;\n        }\n        else {\n          configVal = 8;\n          gpioPort->BRR = bitMask;\n        }\n      }\n      else if (modeVal < 0x10210001) {\n        if ((modeVal == 0x10110000) || (modeVal == 0x10120000)) goto LAB_08001882;\n      }\n      else if (((modeVal == 0x10310000) || (modeVal == 0x10320000)) || (modeVal == 0x10220000))\n      goto LAB_08001882;\n      if (pinVal < 0x100) {\n        bitMask = posVal << 2;\n        gpioReg = gpioPort;\n      }\n      else {\n        gpioReg = (GPIO_TypeDef *)&gpioPort->CRH;\n        bitMask = (posVal - 8) * 4;\n      }\n      gpioReg->CRL = gpioReg->CRL & ~(0xf << (bitMask & 0xff)) | configVal << (bitMask & 0xff);\n      if ((gpioConfig->Mode & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        if (gpioPort == (GPIO_TypeDef *)0x40010800) {\n          portNum = 0;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40010c00) {\n          portNum = 1;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40011000) {\n          portNum = 2;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40011400) {\n          portNum = 3;\n        }\n        else {\n          portNum = 4;\n        }\n        *(uint *)(((posVal >> 2) + 2) * 4 + 0x40010000) =\n             portNum << ((posVal & 3) << 2) |\n             ~(0xf << ((posVal & 3) << 2)) & *(uint *)(((posVal >> 2) + 2) * 4 + 0x40010000);\n        if ((gpioConfig->Mode & 0x10000) == 0) {\n          _DAT_40010400 = ~pinVal & _DAT_40010400;\n        }\n        else {\n          _DAT_40010400 = pinVal | _DAT_40010400;\n        }\n        if ((gpioConfig->Mode & 0x20000) == 0) {\n          _DAT_40010404 = ~pinVal & _DAT_40010404;\n        }\n        else {\n          _DAT_40010404 = pinVal | _DAT_40010404;\n        }\n        if ((gpioConfig->Mode & 0x100000) == 0) {\n          _DAT_40010408 = ~pinVal & _DAT_40010408;\n        }\n        else {\n          _DAT_40010408 = pinVal | _DAT_40010408;\n        }\n        if ((gpioConfig->Mode & 0x200000) == 0) {\n          _DAT_4001040c = ~pinVal & _DAT_4001040c;\n        }\n        else {\n          _DAT_4001040c = pinVal | _DAT_4001040c;\n        }\n      }\n    }\n    posVal = posVal + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080017c4": "configure_gpio_080017c4",
                "GPIOx": "gpioPort",
                "GPIO_Init": "gpioConfig",
                "uVar1": "bitMask",
                "uVar2": "pinVal",
                "uVar3": "modeVal",
                "pGVar4": "gpioReg",
                "iVar5": "portNum",
                "GPIO_Init_local": "local_gpioConfig",
                "GPIOx_local": "local_gpioPort",
                "tmpreg": "tempReg",
                "configregister": "configReg",
                "registeroffset": "regOffset",
                "temp": "tempVal",
                "iocurrent": "ioCurrent",
                "ioposition": "ioPosition",
                "config": "configVal",
                "position": "posVal"
            },
            "calling": [
                "MX_GPIO_Init",
                "HAL_TIM_MspPostInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a80": {
            "entrypoint": "0x08001a80",
            "current_name": "set_pin_state_08001a80",
            "code": "\nvoid setPinState_08001a80(GPIO_TypeDef *gpio,uint16_t pin,pinState state)\n\n{\n  pinState localState;\n  uint16_t localPin;\n  GPIO_TypeDef *localGpio;\n  \n  if (state == GPIO_PIN_RESET) {\n    gpio->BSRR = (uint)pin << 0x10;\n  }\n  else {\n    gpio->BSRR = (uint)pin;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a80": "set_pin_state_08001a80",
                "GPIOx": "gpio",
                "GPIO_Pin": "pin",
                "PinState": "state",
                "PinState_local": "localState",
                "GPIO_Pin_local": "localPin",
                "GPIOx_local": "localGpio"
            },
            "calling": [
                "MX_GPIO_Init",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "initialize_i2_c_08001ab0",
            "code": "\nHAL_StatusTypeDef initializeI2C_08001ab0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t pclk1Freq;\n  char clockSpeedValid;\n  HAL_StatusTypeDef status;\n  uint32_t pclk1;\n  uint riseTime;\n  bool isZero;\n  I2C_HandleTypeDef *localI2CHandle;\n  uint32_t pclk1Freq;\n  uint32_t clockSpeedRange;\n  \n  if (i2cHandle == (I2C_HandleTypeDef *)0x0) {\n    status = HAL_ERROR;\n  }\n  else {\n    if (i2cHandle->State == HAL_I2C_STATE_RESET) {\n      i2cHandle->Lock = HAL_UNLOCKED;\n      HAL_I2C_MspInit(i2cHandle);\n    }\n    i2cHandle->State = HAL_I2C_STATE_BUSY;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n    pclk1Freq = HAL_RCC_GetPCLK1Freq();\n    if ((i2cHandle->Init).ClockSpeed < 0x186a1) {\n      pclk1 = pclk1Freq;\n      if (pclk1Freq < 2000000) {\n        pclk1 = 1;\n      }\n      clockSpeedValid = (char)pclk1;\n      if (1999999 < pclk1Freq) {\n        clockSpeedValid = '\\0';\n      }\n    }\n    else {\n      pclk1 = pclk1Freq;\n      if (pclk1Freq < 4000000) {\n        pclk1 = 1;\n      }\n      clockSpeedValid = (char)pclk1;\n      if (3999999 < pclk1Freq) {\n        clockSpeedValid = '\\0';\n      }\n    }\n    if (clockSpeedValid == '\\0') {\n      riseTime = pclk1Freq / 1000000;\n      i2cHandle->Instance->CR2 = riseTime;\n      if (100000 < (i2cHandle->Init).ClockSpeed) {\n        riseTime = (riseTime * 300) / 1000;\n      }\n      i2cHandle->Instance->TRISE = riseTime + 1;\n      if ((i2cHandle->Init).ClockSpeed < 0x186a1) {\n        pclk1Freq = (pclk1Freq - 1) / ((i2cHandle->Init).ClockSpeed << 1) + 1 & 0xfff;\n        if (pclk1Freq < 4) {\n          pclk1Freq = 4;\n        }\n      }\n      else {\n        if ((i2cHandle->Init).DutyCycle == 0) {\n          riseTime = (pclk1Freq - 1) / ((i2cHandle->Init).ClockSpeed * 3) + 1 & 0xfff;\n          isZero = riseTime == 0;\n          if (isZero) {\n            riseTime = 1;\n          }\n          clockSpeedValid = (char)riseTime;\n          if (!isZero) {\n            clockSpeedValid = '\\0';\n          }\n        }\n        else {\n          riseTime = (pclk1Freq - 1) / ((i2cHandle->Init).ClockSpeed * 0x19) + 1 & 0xfff;\n          isZero = riseTime == 0;\n          if (isZero) {\n            riseTime = 1;\n          }\n          clockSpeedValid = (char)riseTime;\n          if (!isZero) {\n            clockSpeedValid = '\\0';\n          }\n        }\n        if (clockSpeedValid == '\\0') {\n          if ((i2cHandle->Init).DutyCycle == 0) {\n            pclk1Freq = (pclk1Freq - 1) / ((i2cHandle->Init).ClockSpeed * 3) + 1 & 0xfff | 0x8000;\n          }\n          else {\n            pclk1Freq = (pclk1Freq - 1) / ((i2cHandle->Init).ClockSpeed * 0x19) + 1 & 0xfff | 0xc000;\n          }\n        }\n        else {\n          pclk1Freq = 1;\n        }\n      }\n      i2cHandle->Instance->CCR = pclk1Freq;\n      i2cHandle->Instance->CR1 = (i2cHandle->Init).NoStretchMode | (i2cHandle->Init).GeneralCallMode;\n      i2cHandle->Instance->OAR1 = (i2cHandle->Init).OwnAddress1 | (i2cHandle->Init).AddressingMode;\n      i2cHandle->Instance->OAR2 = (i2cHandle->Init).OwnAddress2 | (i2cHandle->Init).DualAddressMode;\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      status = HAL_OK;\n    }\n    else {\n      status = HAL_ERROR;\n    }\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "initialize_i2_c_08001ab0",
                "hi2c": "i2cHandle",
                "uVar1": "pclk1Freq",
                "cVar2": "clockSpeedValid",
                "HVar3": "status",
                "uVar4": "pclk1",
                "uVar5": "riseTime",
                "bVar6": "isZero",
                "hi2c_local": "localI2CHandle",
                "pclk1": "pclk1Freq",
                "freqrange": "clockSpeedRange"
            },
            "calling": [
                "MX_I2C1_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_I2C_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cb8": {
            "entrypoint": "0x08001cb8",
            "current_name": "initialize_i2_c_interface_08001cb8",
            "code": "\nvoid initializeI2CInterface_08001cb8(I2C_HandleTypeDef *i2cInterface)\n\n{\n  I2C_HandleTypeDef *localI2CInterface;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cb8": "initialize_i2_c_interface_08001cb8",
                "hi2c": "i2cInterface",
                "hi2c_local": "localI2CInterface"
            },
            "calling": [
                "HAL_I2C_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ccc": {
            "entrypoint": "0x08001ccc",
            "current_name": "write_memory_08001ccc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001d5e) */\n/* WARNING: Removing unreachable block (ram,0x08001d70) */\n/* WARNING: Removing unreachable block (ram,0x08001d72) */\n/* WARNING: Removing unreachable block (ram,0x08001d74) */\n\nHAL_StatusTypeDef\nwriteMemory_08001ccc(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint8_t *data,uint16_t dataSize,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t tickStart;\n  uint32_t currentTick;\n  int loopVariable;\n  byte *bufferPointer;\n  uint16_t localMemAddressSize;\n  uint16_t localMemoryAddress;\n  uint16_t localDeviceAddress;\n  I2C_HandleTypeDef *localI2CHandle;\n  uint32_t localTickStart;\n  \n  tickStart = HAL_GetTick();\n  if (i2cHandle->State == HAL_I2C_STATE_READY) {\n    do {\n      if ((~i2cHandle->Instance->SR2 & 2) != 0) {\n        loopVariable = 0;\n        goto LAB_08001d9c;\n      }\n      currentTick = HAL_GetTick();\n    } while (currentTick - tickStart < 0x1a);\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    i2cHandle->Lock = HAL_UNLOCKED;\n    loopVariable = 3;\nLAB_08001d9c:\n    if (loopVariable == 0) {\n      if (i2cHandle->Lock == HAL_LOCKED) {\n        status = HAL_BUSY;\n      }\n      else {\n        i2cHandle->Lock = HAL_LOCKED;\n        if ((i2cHandle->Instance->CR1 & 1) != 1) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n        }\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n        i2cHandle->State = HAL_I2C_STATE_BUSY_TX;\n        i2cHandle->Mode = HAL_I2C_MODE_MEM;\n        i2cHandle->ErrorCode = 0;\n        i2cHandle->pBuffPtr = data;\n        i2cHandle->XferCount = dataSize;\n        i2cHandle->XferOptions = 0xffff0000;\n        i2cHandle->XferdataSize = i2cHandle->XferCount;\n        status = I2C_RequestMemoryWrite(i2cHandle,deviceAddress,memoryAddress,memoryAddressSize,timeout,tickStart);\n        if (status == HAL_OK) {\n          while (i2cHandle->XferdataSize != 0) {\n            status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n            if (status != HAL_OK) {\n              if (i2cHandle->ErrorCode == 4) {\n                i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n                return HAL_ERROR;\n              }\n              return HAL_TIMEOUT;\n            }\n            bufferPointer = i2cHandle->pBuffPtr;\n            i2cHandle->pBuffPtr = bufferPointer + 1;\n            i2cHandle->Instance->DR = (uint)*bufferPointer;\n            i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n            i2cHandle->XferCount = i2cHandle->XferCount - 1;\n            if (((i2cHandle->Instance->SR1 & 4) == 4) && (i2cHandle->XferdataSize != 0)) {\n              bufferPointer = i2cHandle->pBuffPtr;\n              i2cHandle->pBuffPtr = bufferPointer + 1;\n              i2cHandle->Instance->DR = (uint)*bufferPointer;\n              i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n              i2cHandle->XferCount = i2cHandle->XferCount - 1;\n            }\n          }\n          status = I2C_WaitOnBTFFlagUntiltimeout(i2cHandle,timeout,tickStart);\n          if (status == HAL_OK) {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n            i2cHandle->State = HAL_I2C_STATE_READY;\n            i2cHandle->Mode = HAL_I2C_MODE_NONE;\n            i2cHandle->Lock = HAL_UNLOCKED;\n            status = HAL_OK;\n          }\n          else if (i2cHandle->ErrorCode == 4) {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n            status = HAL_ERROR;\n          }\n          else {\n            status = HAL_TIMEOUT;\n          }\n        }\n        else if (i2cHandle->ErrorCode == 4) {\n          i2cHandle->Lock = HAL_UNLOCKED;\n          status = HAL_ERROR;\n        }\n        else {\n          i2cHandle->Lock = HAL_UNLOCKED;\n          status = HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      status = HAL_BUSY;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001ccc": "write_memory_08001ccc",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "pData": "data",
                "Size": "dataSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "tickStart",
                "uVar2": "currentTick",
                "iVar3": "loopVariable",
                "pbVar4": "bufferPointer",
                "MemAddSize_local": "localMemAddressSize",
                "MemAddress_local": "localMemoryAddress",
                "DevAddress_local": "localDeviceAddress",
                "hi2c_local": "localI2CHandle",
                "tickstart": "localTickStart"
            },
            "calling": [
                "_i2c_write_reg"
            ],
            "called": [
                "I2C_WaitOnBTFFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnTXEFlagUntilTimeout",
                "I2C_RequestMemoryWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f6c": {
            "entrypoint": "0x08001f6c",
            "current_name": "read_from_memory_08001f6c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080024e6) */\n/* WARNING: Removing unreachable block (ram,0x080024f8) */\n/* WARNING: Removing unreachable block (ram,0x080024fa) */\n/* WARNING: Removing unreachable block (ram,0x080024fc) */\n/* WARNING: Removing unreachable block (ram,0x08002000) */\n/* WARNING: Removing unreachable block (ram,0x08002012) */\n/* WARNING: Removing unreachable block (ram,0x08002014) */\n/* WARNING: Removing unreachable block (ram,0x08002016) */\n/* WARNING: Removing unreachable block (ram,0x080023f4) */\n/* WARNING: Removing unreachable block (ram,0x08002406) */\n/* WARNING: Removing unreachable block (ram,0x08002408) */\n/* WARNING: Removing unreachable block (ram,0x0800240a) */\n/* WARNING: Removing unreachable block (ram,0x080022d6) */\n/* WARNING: Removing unreachable block (ram,0x080022e8) */\n/* WARNING: Removing unreachable block (ram,0x080022ea) */\n/* WARNING: Removing unreachable block (ram,0x080022ec) */\n\nHAL_StatusTypeDef\nreadFromMemory_08001f6c(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint8_t *data,uint16_t size,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t tickStart;\n  uint32_t elapsedTime;\n  int result;\n  uint8_t *bufferPtr;\n  uint16_t localMemAddSize;\n  uint16_t localMemAddress;\n  uint16_t localDevAddress;\n  I2C_HandleTypeDef *localI2CHandle;\n  uint32_t tempRegister3;\n  uint32_t tempRegister2;\n  uint32_t tempRegister1;\n  uint32_t tempRegister;\n  uint32_t startTick;\n  \n  tickStart = HAL_GetTick();\n  if (i2cHandle->State == HAL_I2C_STATE_READY) {\n    do {\n      if ((~i2cHandle->Instance->SR2 & 2) != 0) {\n        result = 0;\n        goto LAB_08002040;\n      }\n      elapsedTime = HAL_GetTick();\n    } while (elapsedTime - tickStart < 0x1a);\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    i2cHandle->Lock = HAL_UNLOCKED;\n    result = 3;\nLAB_08002040:\n    if (result == 0) {\n      if (i2cHandle->Lock == HAL_LOCKED) {\n        status = HAL_BUSY;\n      }\n      else {\n        i2cHandle->Lock = HAL_LOCKED;\n        if ((i2cHandle->Instance->CR1 & 1) != 1) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n        }\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n        i2cHandle->State = HAL_I2C_STATE_BUSY_RX;\n        i2cHandle->Mode = HAL_I2C_MODE_MEM;\n        i2cHandle->ErrorCode = 0;\n        i2cHandle->pBuffPtr = data;\n        i2cHandle->XferCount = size;\n        i2cHandle->XferOptions = 0xffff0000;\n        i2cHandle->Xfersize = i2cHandle->XferCount;\n        status = I2C_RequestMemoryRead(i2cHandle,deviceAddress,memoryAddress,memoryAddressSize,timeout,tickStart);\n        if (status == HAL_OK) {\n          if (i2cHandle->Xfersize == 0) {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n          }\n          else if (i2cHandle->Xfersize == 1) {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n            disableIRQinterrupts();\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n            enableIRQinterrupts();\n          }\n          else if (i2cHandle->Xfersize == 2) {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x800;\n            disableIRQinterrupts();\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n            enableIRQinterrupts();\n          }\n          else {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n          }\n          while (i2cHandle->Xfersize != 0) {\n            if (i2cHandle->Xfersize < 4) {\n              if (i2cHandle->Xfersize == 1) {\n                status = I2C_WaitOnRXNEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n                if (status != HAL_OK) {\n                  if (i2cHandle->ErrorCode == 0x20) {\n                    return HAL_TIMEOUT;\n                  }\n                  return HAL_ERROR;\n                }\n                elapsedTime = i2cHandle->Instance->DR;\n                bufferPtr = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = bufferPtr + 1;\n                *bufferPtr = (uint8_t)elapsedTime;\n                i2cHandle->Xfersize = i2cHandle->Xfersize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              }\n              else if (i2cHandle->Xfersize == 2) {\n                do {\n                  if ((~i2cHandle->Instance->SR1 & 4) == 0) {\n                    result = 0;\n                    goto LAB_080022fa;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (elapsedTime = HAL_GetTick(), elapsedTime - tickStart <= timeout))));\n                i2cHandle->PreviousState = 0;\n                i2cHandle->State = HAL_I2C_STATE_READY;\n                i2cHandle->Mode = HAL_I2C_MODE_NONE;\n                i2cHandle->Lock = HAL_UNLOCKED;\n                result = 3;\nLAB_080022fa:\n                if (result != 0) {\n                  return HAL_TIMEOUT;\n                }\n                disableIRQinterrupts();\n                i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n                elapsedTime = i2cHandle->Instance->DR;\n                bufferPtr = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = bufferPtr + 1;\n                *bufferPtr = (uint8_t)elapsedTime;\n                i2cHandle->Xfersize = i2cHandle->Xfersize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n                enableIRQinterrupts();\n                elapsedTime = i2cHandle->Instance->DR;\n                bufferPtr = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = bufferPtr + 1;\n                *bufferPtr = (uint8_t)elapsedTime;\n                i2cHandle->Xfersize = i2cHandle->Xfersize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              }\n              else {\n                do {\n                  if ((~i2cHandle->Instance->SR1 & 4) == 0) {\n                    result = 0;\n                    goto LAB_08002418;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (elapsedTime = HAL_GetTick(), elapsedTime - tickStart <= timeout))));\n                i2cHandle->PreviousState = 0;\n                i2cHandle->State = HAL_I2C_STATE_READY;\n                i2cHandle->Mode = HAL_I2C_MODE_NONE;\n                i2cHandle->Lock = HAL_UNLOCKED;\n                result = 3;\nLAB_08002418:\n                if (result != 0) {\n                  return HAL_TIMEOUT;\n                }\n                i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n                disableIRQinterrupts();\n                elapsedTime = i2cHandle->Instance->DR;\n                bufferPtr = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = bufferPtr + 1;\n                *bufferPtr = (uint8_t)elapsedTime;\n                i2cHandle->Xfersize = i2cHandle->Xfersize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n                do {\n                  if ((~i2cHandle->Instance->SR1 & 4) == 0) {\n                    result = 0;\n                    goto LAB_0800250a;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (elapsedTime = HAL_GetTick(), elapsedTime - tickStart <= timeout))));\n                i2cHandle->PreviousState = 0;\n                i2cHandle->State = HAL_I2C_STATE_READY;\n                i2cHandle->Mode = HAL_I2C_MODE_NONE;\n                i2cHandle->Lock = HAL_UNLOCKED;\n                result = 3;\nLAB_0800250a:\n                if (result != 0) {\n                  return HAL_TIMEOUT;\n                }\n                i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n                elapsedTime = i2cHandle->Instance->DR;\n                bufferPtr = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = bufferPtr + 1;\n                *bufferPtr = (uint8_t)elapsedTime;\n                i2cHandle->Xfersize = i2cHandle->Xfersize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n                enableIRQinterrupts();\n                elapsedTime = i2cHandle->Instance->DR;\n                bufferPtr = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = bufferPtr + 1;\n                *bufferPtr = (uint8_t)elapsedTime;\n                i2cHandle->Xfersize = i2cHandle->Xfersize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              }\n            }\n            else {\n              status = I2C_WaitOnRXNEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n              if (status != HAL_OK) {\n                if (i2cHandle->ErrorCode == 0x20) {\n                  return HAL_TIMEOUT;\n                }\n                return HAL_ERROR;\n              }\n              elapsedTime = i2cHandle->Instance->DR;\n              bufferPtr = i2cHandle->pBuffPtr;\n              i2cHandle->pBuffPtr = bufferPtr + 1;\n              *bufferPtr = (uint8_t)elapsedTime;\n              i2cHandle->Xfersize = i2cHandle->Xfersize - 1;\n              i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              if ((i2cHandle->Instance->SR1 & 4) == 4) {\n                elapsedTime = i2cHandle->Instance->DR;\n                bufferPtr = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = bufferPtr + 1;\n                *bufferPtr = (uint8_t)elapsedTime;\n                i2cHandle->Xfersize = i2cHandle->Xfersize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              }\n            }\n          }\n          i2cHandle->State = HAL_I2C_STATE_READY;\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          i2cHandle->Lock = HAL_UNLOCKED;\n          status = HAL_OK;\n        }\n        else if (i2cHandle->ErrorCode == 4) {\n          i2cHandle->Lock = HAL_UNLOCKED;\n          status = HAL_ERROR;\n        }\n        else {\n          i2cHandle->Lock = HAL_UNLOCKED;\n          status = HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      status = HAL_BUSY;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001f6c": "read_from_memory_08001f6c",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "tickStart",
                "uVar2": "elapsedTime",
                "iVar3": "result",
                "puVar4": "bufferPtr",
                "MemAddSize_local": "localMemAddSize",
                "MemAddress_local": "localMemAddress",
                "DevAddress_local": "localDevAddress",
                "hi2c_local": "localI2CHandle",
                "tmpreg_3": "tempRegister3",
                "tmpreg_2": "tempRegister2",
                "tmpreg_1": "tempRegister1",
                "tmpreg": "tempRegister",
                "tickstart": "startTick"
            },
            "calling": [
                "_i2c_read_reg"
            ],
            "called": [
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "I2C_RequestMemoryRead",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002640": {
            "entrypoint": "0x08002640",
            "current_name": "configure_i2_c_08002640",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080026e8) */\n/* WARNING: Removing unreachable block (ram,0x080026fa) */\n/* WARNING: Removing unreachable block (ram,0x080026fc) */\n/* WARNING: Removing unreachable block (ram,0x080026fe) */\n\nHAL_StatusTypeDef\nconfigureI2C_08002640(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint32_t timeout,uint32_t tickStart)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t currentTick;\n  int loopCount;\n  uint16_t localMemoryAddressSize;\n  uint16_t localMemoryAddress;\n  uint16_t localDeviceAddress;\n  I2C_HandleTypeDef *localI2CHandle;\n  uint32_t temporaryRegister;\n  \n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n  do {\n    if ((~i2cHandle->Instance->SR1 & 1) == 0) {\n      loopCount = 0;\n      goto LAB_0800270a;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - tickStart <= timeout))));\n  i2cHandle->PreviousState = 0;\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  loopCount = 3;\nLAB_0800270a:\n  if (loopCount == 0) {\n    i2cHandle->Instance->DR = (byte)deviceAddress & 0xfe;\n    status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout,tickStart);\n    if (status == HAL_OK) {\n      status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n      if (status == HAL_OK) {\n        if (memoryAddressSize == 1) {\n          i2cHandle->Instance->DR = (uint)(byte)memoryAddress;\n        }\n        else {\n          i2cHandle->Instance->DR = (uint)(byte)(memoryAddress >> 8);\n          status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n          if (status != HAL_OK) {\n            if (i2cHandle->ErrorCode == 4) {\n              i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n              return HAL_ERROR;\n            }\n            return HAL_TIMEOUT;\n          }\n          i2cHandle->Instance->DR = (uint)(byte)memoryAddress;\n        }\n        status = HAL_OK;\n      }\n      else if (i2cHandle->ErrorCode == 4) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        status = HAL_ERROR;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n    else if (i2cHandle->ErrorCode == 4) {\n      status = HAL_ERROR;\n    }\n    else {\n      status = HAL_TIMEOUT;\n    }\n  }\n  else {\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002640": "configure_i2_c_08002640",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "Timeout": "timeout",
                "Tickstart": "tickStart",
                "HVar1": "status",
                "uVar2": "currentTick",
                "iVar3": "loopCount",
                "MemAddSize_local": "localMemoryAddressSize",
                "MemAddress_local": "localMemoryAddress",
                "DevAddress_local": "localDeviceAddress",
                "hi2c_local": "localI2CHandle",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080027f4": {
            "entrypoint": "0x080027f4",
            "current_name": "read_from_i2_c_device_080027f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080028ae) */\n/* WARNING: Removing unreachable block (ram,0x080028c0) */\n/* WARNING: Removing unreachable block (ram,0x080028c2) */\n/* WARNING: Removing unreachable block (ram,0x080028c4) */\n/* WARNING: Removing unreachable block (ram,0x08002a6c) */\n/* WARNING: Removing unreachable block (ram,0x08002a7e) */\n/* WARNING: Removing unreachable block (ram,0x08002a80) */\n/* WARNING: Removing unreachable block (ram,0x08002a82) */\n\nHAL_StatusTypeDef\nreadFromI2CDevice_080027f4(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint32_t timeout,uint32_t tickStart)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t timeDiff;\n  int loopVar;\n  uint16_t localMemoryAddressSize;\n  uint16_t localMemoryAddress;\n  uint16_t localDeviceAddress;\n  I2C_HandleTypeDef *localI2CHandle;\n  uint32_t temporaryRegister;\n  \n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n  do {\n    if ((~i2cHandle->Instance->SR1 & 1) == 0) {\n      loopVar = 0;\n      goto LAB_080028d2;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (timeDiff = HAL_GetTick(), timeDiff - tickStart <= timeout))));\n  i2cHandle->PreviousState = 0;\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  loopVar = 3;\nLAB_080028d2:\n  if (loopVar == 0) {\n    i2cHandle->Instance->DR = (byte)deviceAddress & 0xfe;\n    status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout,tickStart);\n    if (status == HAL_OK) {\n      status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n      if (status == HAL_OK) {\n        if (memoryAddressSize == 1) {\n          i2cHandle->Instance->DR = (uint)(byte)memoryAddress;\n        }\n        else {\n          i2cHandle->Instance->DR = (uint)(byte)(memoryAddress >> 8);\n          status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n          if (status != HAL_OK) {\n            if (i2cHandle->ErrorCode == 4) {\n              i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n              return HAL_ERROR;\n            }\n            return HAL_TIMEOUT;\n          }\n          i2cHandle->Instance->DR = (uint)(byte)memoryAddress;\n        }\n        status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n        if (status == HAL_OK) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n          do {\n            if ((~i2cHandle->Instance->SR1 & 1) == 0) {\n              loopVar = 0;\n              goto LAB_08002a90;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (timeDiff = HAL_GetTick(), timeDiff - tickStart <= timeout))));\n          i2cHandle->PreviousState = 0;\n          i2cHandle->State = HAL_I2C_STATE_READY;\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          i2cHandle->Lock = HAL_UNLOCKED;\n          loopVar = 3;\nLAB_08002a90:\n          if (loopVar == 0) {\n            i2cHandle->Instance->DR = (uint)(byte)((byte)deviceAddress | 1);\n            status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout,tickStart);\n            if (status == HAL_OK) {\n              status = HAL_OK;\n            }\n            else if (i2cHandle->ErrorCode == 4) {\n              status = HAL_ERROR;\n            }\n            else {\n              status = HAL_TIMEOUT;\n            }\n          }\n          else {\n            status = HAL_TIMEOUT;\n          }\n        }\n        else if (i2cHandle->ErrorCode == 4) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n          status = HAL_ERROR;\n        }\n        else {\n          status = HAL_TIMEOUT;\n        }\n      }\n      else if (i2cHandle->ErrorCode == 4) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        status = HAL_ERROR;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n    else if (i2cHandle->ErrorCode == 4) {\n      status = HAL_ERROR;\n    }\n    else {\n      status = HAL_TIMEOUT;\n    }\n  }\n  else {\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080027f4": "read_from_i2_c_device_080027f4",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "Timeout": "timeout",
                "Tickstart": "tickStart",
                "HVar1": "status",
                "uVar2": "timeDiff",
                "iVar3": "loopVar",
                "MemAddSize_local": "localMemoryAddressSize",
                "MemAddress_local": "localMemoryAddress",
                "DevAddress_local": "localDeviceAddress",
                "hi2c_local": "localI2CHandle",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad8": {
            "entrypoint": "0x08002ad8",
            "current_name": "check_i2_c_status_08002ad8",
            "code": "\nHAL_StatusTypeDef\ncheckI2CStatus_08002ad8(I2C_HandleTypeDef *i2c_handle,uint32_t status_flag,uint32_t timeout,uint32_t start_tick)\n\n{\n  uint32_t tick_difference;\n  char result_character;\n  uint status_value;\n  bool is_status_nonzero;\n  uint32_t local_start_tick;\n  uint32_t local_timeout;\n  uint32_t local_status_flag;\n  I2C_HandleTypeDef *local_i2c_handle;\n  \n  do {\n    if ((status_flag >> 0x10 & 0xff) == 1) {\n      status_value = status_flag & ~i2c_handle->Instance->SR1 & 0xffff;\n      is_status_nonzero = status_value != 0;\n      if (is_status_nonzero) {\n        status_value = 1;\n      }\n      result_character = (char)status_value;\n      if (!is_status_nonzero) {\n        result_character = '\\0';\n      }\n    }\n    else {\n      status_value = status_flag & ~i2c_handle->Instance->SR2 & 0xffff;\n      is_status_nonzero = status_value != 0;\n      if (is_status_nonzero) {\n        status_value = 1;\n      }\n      result_character = (char)status_value;\n      if (!is_status_nonzero) {\n        result_character = '\\0';\n      }\n    }\n    if (result_character == '\\0') {\n      return HAL_OK;\n    }\n    if ((i2c_handle->Instance->SR1 & 0x400) == 0x400) {\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n      i2c_handle->Instance->SR1 = 0xfffffbff;\n      i2c_handle->ErrorCode = 4;\n      i2c_handle->PreviousState = 0;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      return HAL_ERROR;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (tick_difference = HAL_GetTick(), tick_difference - start_tick <= timeout))));\n  i2c_handle->PreviousState = 0;\n  i2c_handle->State = HAL_I2C_STATE_READY;\n  i2c_handle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08002ad8": "check_i2_c_status_08002ad8",
                "hi2c": "i2c_handle",
                "Flag": "status_flag",
                "Timeout": "timeout",
                "Tickstart": "start_tick",
                "uVar1": "tick_difference",
                "cVar2": "result_character",
                "uVar3": "status_value",
                "bVar4": "is_status_nonzero",
                "Tickstart_local": "local_start_tick",
                "Timeout_local": "local_timeout",
                "Flag_local": "local_status_flag",
                "hi2c_local": "local_i2c_handle"
            },
            "calling": [
                "I2C_RequestMemoryRead",
                "I2C_RequestMemoryWrite"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002bb4": {
            "entrypoint": "0x08002bb4",
            "current_name": "wait_for_i2_c_acknowledge_08002bb4",
            "code": "\nHAL_StatusTypeDef waitForI2CAcknowledge_08002bb4(I2C_HandleTypeDef *i2cHandle,uint32_t timeout,uint32_t tickStart)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t currentTick;\n  uint32_t localTickStart;\n  uint32_t localTimeout;\n  I2C_HandleTypeDef *localI2CHandle;\n  \n  while( true ) {\n    if ((i2cHandle->Instance->SR1 & 0x80) == 0x80) {\n      return HAL_OK;\n    }\n    status = I2C_IsAcknowledgeFailed(i2cHandle);\n    if (status != HAL_OK) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (currentTick = HAL_GetTick(), timeout < currentTick - tickStart)))) {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 0x20;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002bb4": "wait_for_i2_c_acknowledge_08002bb4",
                "hi2c": "i2cHandle",
                "Timeout": "timeout",
                "Tickstart": "tickStart",
                "HVar1": "status",
                "uVar2": "currentTick",
                "Tickstart_local": "localTickStart",
                "Timeout_local": "localTimeout",
                "hi2c_local": "localI2CHandle"
            },
            "calling": [
                "I2C_RequestMemoryRead",
                "HAL_I2C_Mem_Write",
                "I2C_RequestMemoryWrite"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_IsAcknowledgeFailed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c2e": {
            "entrypoint": "0x08002c2e",
            "current_name": "check_i2_c_acknowledge_08002c2e",
            "code": "\nHAL_StatusTypeDef checkI2CAcknowledge_08002c2e(I2C_HandleTypeDef *i2cHandle,uint32_t timeout,uint32_t tickStart)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t currentTick;\n  uint32_t localTickStart;\n  uint32_t localTimeout;\n  I2C_HandleTypeDef *localI2CHandle;\n  \n  while( true ) {\n    if ((i2cHandle->Instance->SR1 & 4) == 4) {\n      return HAL_OK;\n    }\n    status = I2C_IsAcknowledgeFailed(i2cHandle);\n    if (status != HAL_OK) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (currentTick = HAL_GetTick(), timeout < currentTick - tickStart)))) {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 0x20;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002c2e": "check_i2_c_acknowledge_08002c2e",
                "hi2c": "i2cHandle",
                "Timeout": "timeout",
                "Tickstart": "tickStart",
                "HVar1": "status",
                "uVar2": "currentTick",
                "Tickstart_local": "localTickStart",
                "Timeout_local": "localTimeout",
                "hi2c_local": "localI2CHandle"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_IsAcknowledgeFailed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca8": {
            "entrypoint": "0x08002ca8",
            "current_name": "check_i2_c_status_08002ca8",
            "code": "\nHAL_StatusTypeDef check_I2C_status_08002ca8(I2C_HandleTypeDef *i2c_handle,uint32_t timeout,uint32_t tick_start)\n\n{\n  uint32_t tick_diff;\n  uint32_t tick_start_local;\n  uint32_t timeout_local;\n  I2C_HandleTypeDef *i2c_handle_local;\n  \n  while( true ) {\n    if ((i2c_handle->Instance->SR1 & 0x40) == 0x40) {\n      return HAL_OK;\n    }\n    if ((i2c_handle->Instance->SR1 & 0x10) == 0x10) break;\n    if ((timeout == 0) || (tick_diff = HAL_GetTick(), timeout < tick_diff - tick_start)) {\n      i2c_handle->ErrorCode = i2c_handle->ErrorCode | 0x20;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  i2c_handle->Instance->SR1 = 0xffffffef;\n  i2c_handle->ErrorCode = 0;\n  i2c_handle->PreviousState = 0;\n  i2c_handle->State = HAL_I2C_STATE_READY;\n  i2c_handle->Lock = HAL_UNLOCKED;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002ca8": "check_i2_c_status_08002ca8",
                "hi2c": "i2c_handle",
                "Timeout": "timeout",
                "Tickstart": "tick_start",
                "uVar1": "tick_diff",
                "Tickstart_local": "tick_start_local",
                "Timeout_local": "timeout_local",
                "hi2c_local": "i2c_handle_local"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d3c": {
            "entrypoint": "0x08002d3c",
            "current_name": "check_and_clear_busy_flag_08002d3c",
            "code": "\nHAL_StatusTypeDef check_and_clear_busy_flag_08002d3c(I2C_HandleTypeDef *i2c_handle)\n\n{\n  bool flag_set;\n  I2C_HandleTypeDef *local_i2c_handle;\n  \n  flag_set = (i2c_handle->Instance->SR1 & 0x400) == 0x400;\n  if (flag_set) {\n    i2c_handle->Instance->SR1 = 0xfffffbff;\n    i2c_handle->ErrorCode = 4;\n    i2c_handle->PreviousState = 0;\n    i2c_handle->State = HAL_I2C_STATE_READY;\n    i2c_handle->Lock = HAL_UNLOCKED;\n  }\n  return flag_set;\n}\n\n",
            "renaming": {
                "FUN_08002d3c": "check_and_clear_busy_flag_08002d3c",
                "hi2c": "i2c_handle",
                "bVar1": "flag_set",
                "hi2c_local": "local_i2c_handle"
            },
            "calling": [
                "I2C_WaitOnBTFFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d8a": {
            "entrypoint": "0x08002d8a",
            "current_name": "FUNC_08002d8a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002d8a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d8a": "FUNC_08002d8a"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d98": {
            "entrypoint": "0x08002d98",
            "current_name": "configure_oscillators_08002d98",
            "code": "\n\n\nHAL_StatusTypeDef configureOscillators_08002d98(RCC_OscInitTypeDef *oscInitConfig)\n\n{\n  uint32_t startTick;\n  uint32_t currentTick;\n  HAL_StatusTypeDef status;\n  bool isSet;\n  RCC_OscInitTypeDef *localOscInitConfig;\n  uint32_t temporaryRegister;\n  uint32_t tickStart;\n  FlagStatus powerClockChanged;\n  \n  if ((oscInitConfig->OscillatorType & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0x10000)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (oscInitConfig->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      if (oscInitConfig->HSEState == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (oscInitConfig->HSEState == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (oscInitConfig->HSEState == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (oscInitConfig->HSEState == 0) {\n        startTick = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          currentTick = HAL_GetTick();\n          if (100 < currentTick - startTick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        startTick = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          currentTick = HAL_GetTick();\n          if (100 < currentTick - startTick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((oscInitConfig->OscillatorType & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (oscInitConfig->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      _DAT_40021000 = oscInitConfig->HSICalibrationValue << 3 | _DAT_40021000 & 0xffffff07;\n    }\n    else if (oscInitConfig->HSIState == 0) {\n      _DAT_42420000 = 0;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021000 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021000 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40021000 = oscInitConfig->HSICalibrationValue << 3 | _DAT_40021000 & 0xffffff07;\n    }\n  }\n  if ((oscInitConfig->OscillatorType & 8) != 0) {\n    if (oscInitConfig->LSIState == 0) {\n      _DAT_42420480 = 0;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021024 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021024 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((oscInitConfig->OscillatorType & 4) != 0) {\n    isSet = (_DAT_4002101c & 0x10000000) == 0;\n    if (isSet) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTick = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTick = HAL_GetTick();\n        if (100 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (oscInitConfig->LSEState == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (oscInitConfig->LSEState == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (oscInitConfig->LSEState == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (oscInitConfig->LSEState == 0) {\n      startTick = HAL_GetTick();\n      while ((_DAT_40021020 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (5000 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      startTick = HAL_GetTick();\n      while ((_DAT_40021020 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (5000 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (isSet) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if ((oscInitConfig->PLL).PLLState == 0) {\nLAB_0800324a:\n    status = HAL_OK;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    status = HAL_ERROR;\n  }\n  else if ((oscInitConfig->PLL).PLLState == 2) {\n    _DAT_42420060 = 0;\n    startTick = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if ((oscInitConfig->PLL).PLLSource == 0x10000) {\n          _DAT_40021004 = oscInitConfig->HSEPredivValue | _DAT_40021004 & 0xfffdffff;\n        }\n        _DAT_40021004 =\n             (oscInitConfig->PLL).PLLMUL | (oscInitConfig->PLL).PLLSource |\n             _DAT_40021004 & 0xffc2ffff;\n        _DAT_42420060 = 1;\n        startTick = HAL_GetTick();\n        while ((_DAT_40021000 & 0x2000000) == 0) {\n          currentTick = HAL_GetTick();\n          if (2 < currentTick - startTick) {\n            return HAL_TIMEOUT;\n          }\n        }\n        goto LAB_0800324a;\n      }\n      currentTick = HAL_GetTick();\n    } while (currentTick - startTick < 3);\n    status = HAL_TIMEOUT;\n  }\n  else {\n    _DAT_42420060 = 0;\n    startTick = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) goto LAB_0800324a;\n      currentTick = HAL_GetTick();\n    } while (currentTick - startTick < 3);\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002d98": "configure_oscillators_08002d98",
                "RCC_OscInitStruct": "oscInitConfig",
                "uVar1": "startTick",
                "uVar2": "currentTick",
                "HVar3": "status",
                "bVar4": "isSet",
                "RCC_OscInitStruct_local": "localOscInitConfig",
                "tmpreg": "temporaryRegister",
                "tickstart": "tickStart",
                "pwrclkchanged": "powerClockChanged"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003260": {
            "entrypoint": "0x08003260",
            "current_name": "configure_clock_08003260",
            "code": "\n\n\nHAL_StatusTypeDef configureClock_08003260(RCC_ClkInitTypeDef *clockInitStruct,uint32_t latency)\n\n{\n  uint32_t sysClockFreq;\n  uint32_t currentTick;\n  HAL_StatusTypeDef status;\n  uint32_t localLatency;\n  RCC_ClkInitTypeDef *localClockInitStruct;\n  uint32_t startTick;\n  \n  if (((_DAT_40022000 & 7) < latency) &&\n     (_DAT_40022000 = latency | _DAT_40022000 & 0xfffffff8, latency != (latency & 7))) {\n    status = HAL_ERROR;\n  }\n  else {\n    if ((clockInitStruct->ClockType & 2) != 0) {\n      _DAT_40021004 = clockInitStruct->AHBCLKDivider | _DAT_40021004 & 0xffffff0f;\n    }\n    if ((clockInitStruct->ClockType & 1) == 0) {\nLAB_08003394:\n      if ((latency < (_DAT_40022000 & 7)) &&\n         (_DAT_40022000 = latency | _DAT_40022000 & 0xfffffff8, latency != (latency & 7))) {\n        status = HAL_ERROR;\n      }\n      else {\n        if ((clockInitStruct->ClockType & 4) != 0) {\n          _DAT_40021004 = clockInitStruct->APB1CLKDivider | _DAT_40021004 & 0xfffff8ff;\n        }\n        if ((clockInitStruct->ClockType & 8) != 0) {\n          _DAT_40021004 = clockInitStruct->APB2CLKDivider << 3 | _DAT_40021004 & 0xffffc7ff;\n        }\n        sysClockFreq = HAL_RCC_GetSysClockFreq();\n        SystemCoreClock = sysClockFreq >> \"\"[_DAT_40021004 >> 4 & 0xf];\n        HAL_InitTick(0xf);\n        status = HAL_OK;\n      }\n    }\n    else {\n      if (clockInitStruct->SYSCLKSource == 1) {\n        if ((_DAT_40021000 & 0x20000) == 0) {\n          return HAL_ERROR;\n        }\n      }\n      else if ((clockInitStruct->SYSCLKSource != 2) && ((_DAT_40021000 & 2) == 0)) {\n        return HAL_ERROR;\n      }\n      _DAT_40021004 = clockInitStruct->SYSCLKSource | _DAT_40021004 & 0xfffffffc;\n      sysClockFreq = HAL_GetTick();\n      if (clockInitStruct->SYSCLKSource == 1) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 4) goto LAB_08003394;\n          currentTick = HAL_GetTick();\n        } while (currentTick - sysClockFreq < 0x1389);\n        status = HAL_TIMEOUT;\n      }\n      else if (clockInitStruct->SYSCLKSource == 2) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 8) goto LAB_08003394;\n          currentTick = HAL_GetTick();\n        } while (currentTick - sysClockFreq < 0x1389);\n        status = HAL_TIMEOUT;\n      }\n      else {\n        do {\n          if ((_DAT_40021004 & 0xc) == 0) goto LAB_08003394;\n          currentTick = HAL_GetTick();\n        } while (currentTick - sysClockFreq < 0x1389);\n        status = HAL_TIMEOUT;\n      }\n    }\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003260": "configure_clock_08003260",
                "RCC_ClkInitStruct": "clockInitStruct",
                "FLatency": "latency",
                "uVar1": "sysClockFreq",
                "uVar2": "currentTick",
                "HVar3": "status",
                "FLatency_local": "localLatency",
                "RCC_ClkInitStruct_local": "localClockInitStruct",
                "tickstart": "startTick"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_GetTick",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003440": {
            "entrypoint": "0x08003440",
            "current_name": "get_sysclock_frequency_08003440",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_sysclock_frequency_08003440(void)\n\n{\n  uint8_t prediv_factor_table [2];\n  uint8_t pllmul_factor_table [16];\n  uint32_t pllmul;\n  uint32_t prediv;\n  uint32_t tmp_reg;\n  uint32_t sys_clock_freq;\n  uint32_t pll_clk;\n  \n  pllmul_factor_table[0] = '\\x02';\n  pllmul_factor_table[1] = '\\x03';\n  pllmul_factor_table[2] = '\\x04';\n  pllmul_factor_table[3] = '\\x05';\n  pllmul_factor_table[4] = '\\x06';\n  pllmul_factor_table[5] = '\\a';\n  pllmul_factor_table[6] = '\\b';\n  pllmul_factor_table[7] = '\\t';\n  pllmul_factor_table[8] = '\\n';\n  pllmul_factor_table[9] = '\\v';\n  pllmul_factor_table[10] = '\\f';\n  pllmul_factor_table[11] = '\\r';\n  pllmul_factor_table[12] = '\\x0e';\n  pllmul_factor_table[13] = '\\x0f';\n  pllmul_factor_table[14] = '\\x10';\n  pllmul_factor_table[15] = '\\x10';\n  prediv_factor_table[0] = '\\x01';\n  prediv_factor_table[1] = '\\x02';\n  if ((_DAT_40021004 & 0xc) == 4) {\n    sys_clock_freq = 8000000;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      pll_clk = (uint)pllmul_factor_table[_DAT_40021004 >> 0x12 & 0xf] * 4000000;\n    }\n    else {\n      pll_clk = ((uint)pllmul_factor_table[_DAT_40021004 >> 0x12 & 0xf] * 8000000) /\n               (uint)prediv_factor_table[_DAT_40021004 >> 0x11 & 1];\n    }\n    sys_clock_freq = pll_clk;\n  }\n  else {\n    sys_clock_freq = 8000000;\n  }\n  return sys_clock_freq;\n}\n\n",
            "renaming": {
                "FUN_08003440": "get_sysclock_frequency_08003440",
                "aPredivFactorTable": "prediv_factor_table",
                "aPLLMULFactorTable": "pllmul_factor_table",
                "tmpreg": "tmp_reg",
                "sysclockfreq": "sys_clock_freq",
                "pllclk": "pll_clk"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003504": {
            "entrypoint": "0x08003504",
            "current_name": "get_system_core_clock_08003504",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_08003504(void)\n\n{\n  return systemClock;\n}\n\n",
            "renaming": {
                "FUN_08003504": "get_system_core_clock_08003504",
                "SystemCoreClock": "systemClock"
            },
            "calling": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003518": {
            "entrypoint": "0x08003518",
            "current_name": "get_hclk_frequency_08003518",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_HCLK_frequency_08003518(void)\n\n{\n  uint32_t freq;\n  \n  freq = HAL_RCC_GetHCLKFreq();\n  return freq >> \"\"[_DAT_40021004 >> 8 & 7];\n}\n\n",
            "renaming": {
                "FUN_08003518": "get_hclk_frequency_08003518",
                "uVar1": "freq"
            },
            "calling": [
                "UART_SetConfig",
                "HAL_I2C_Init"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003540": {
            "entrypoint": "0x08003540",
            "current_name": "get_adjusted_hclk_freq_08003540",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getAdjustedHCLKFreq_08003540(void)\n\n{\n  uint32_t hclkFreq;\n  \n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  return hclkFreq >> \"\"[_DAT_40021004 >> 0xb & 7];\n}\n\n",
            "renaming": {
                "FUN_08003540": "get_adjusted_hclk_freq_08003540",
                "uVar1": "hclkFreq"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003568": {
            "entrypoint": "0x08003568",
            "current_name": "delay_function_08003568",
            "code": "\nvoid delayFunction_08003568(uint32_t inputDelay)\n\n{\n  bool isDelayNotZero;\n  uint32_t localDelay;\n  uint32_t calculatedDelay;\n  \n  calculatedDelay = inputDelay * (SystemCoreClock / 8000);\n  do {\n    isDelayNotZero = calculatedDelay != 0;\n    calculatedDelay = calculatedDelay - 1;\n  } while (isDelayNotZero);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003568": "delay_function_08003568",
                "mdelay": "inputDelay",
                "mdelay_local": "localDelay",
                "Delay": "calculatedDelay",
                "bVar1": "isDelayNotZero"
            },
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035a4": {
            "entrypoint": "0x080035a4",
            "current_name": "initialize_timer_080035a4",
            "code": "\nHAL_StatusTypeDef initializeTimer_080035a4(TIM_HandleTypeDef *timerHandle)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_HandleTypeDef *localTimerHandle;\n  \n  if (timerHandle == (TIM_HandleTypeDef *)0x0) {\n    status = HAL_ERROR;\n  }\n  else {\n    if (timerHandle->State == HAL_TIM_STATE_RESET) {\n      timerHandle->Lock = HAL_UNLOCKED;\n      HAL_TIM_Base_MspInit(timerHandle);\n    }\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    TIM_Base_SetConfig(timerHandle->Instance,&timerHandle->Init);\n    timerHandle->State = HAL_TIM_STATE_READY;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080035a4": "initialize_timer_080035a4",
                "htim": "timerHandle",
                "HVar1": "status",
                "htim_local": "localTimerHandle"
            },
            "calling": [
                "MX_TIM2_Init",
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_TIM_Base_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fa": {
            "entrypoint": "0x080035fa",
            "current_name": "initialize_timer_080035fa",
            "code": "\nvoid initialize_timer_080035fa(TIM_HandleTypeDef *timer)\n\n{\n  TIM_HandleTypeDef *local_timer;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fa": "initialize_timer_080035fa",
                "htim": "timer",
                "htim_local": "local_timer"
            },
            "calling": [
                "HAL_TIM_Base_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800360c": {
            "entrypoint": "0x0800360c",
            "current_name": "enable_timer_interrupt_0800360c",
            "code": "\nHAL_StatusTypeDef enableTimerInterrupt_0800360c(TIM_HandleTypeDef *timerHandle)\n\n{\n  TIM_HandleTypeDef *localTimerHandle;\n  \n  timerHandle->Instance->DIER = timerHandle->Instance->DIER | 1;\n  timerHandle->Instance->CR1 = timerHandle->Instance->CR1 | 1;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800360c": "enable_timer_interrupt_0800360c",
                "htim": "timerHandle",
                "htim_local": "localTimerHandle"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003640": {
            "entrypoint": "0x08003640",
            "current_name": "initialize_timer_08003640",
            "code": "\nHAL_StatusTypeDef initializeTimer_08003640(TIM_HandleTypeDef *timerHandle)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_HandleTypeDef *localTimerHandle;\n  \n  if (timerHandle == (TIM_HandleTypeDef *)0x0) {\n    status = HAL_ERROR;\n  }\n  else {\n    if (timerHandle->State == HAL_TIM_STATE_RESET) {\n      timerHandle->Lock = HAL_UNLOCKED;\n      HAL_TIM_PWM_MspInit(timerHandle);\n    }\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    TIM_Base_SetConfig(timerHandle->Instance,&timerHandle->Init);\n    timerHandle->State = HAL_TIM_STATE_READY;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003640": "initialize_timer_08003640",
                "htim": "timerHandle",
                "HVar1": "status",
                "htim_local": "localTimerHandle"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_TIM_PWM_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003696": {
            "entrypoint": "0x08003696",
            "current_name": "initialize_timer_08003696",
            "code": "\nvoid initialize_timer_08003696(timer_handler *htim)\n\n{\n  timer_handler *local_timer_handler;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003696": "initialize_timer_08003696",
                "TIM_HandleTypeDef": "timer_handler",
                "htim_local": "local_timer_handler"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036a8": {
            "entrypoint": "0x080036a8",
            "current_name": "configure_timer_channel_080036a8",
            "code": "\nHAL_StatusTypeDef configureTimerChannel_080036a8(TIM_HandleTypeDef *timer,uint32_t channel)\n\n{\n  uint32_t localChannel;\n  TIM_HandleTypeDef *localTimer;\n  \n  TIM_CCxchannelCmd(timer->Instance,channel,1);\n  if (timer->Instance == (TIM_TypeDef *)0x40012c00) {\n    timer->Instance->BDTR = timer->Instance->BDTR | 0x8000;\n  }\n  timer->Instance->CR1 = timer->Instance->CR1 | 1;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080036a8": "configure_timer_channel_080036a8",
                "htim": "timer",
                "Channel": "channel",
                "Channel_local": "localChannel",
                "htim_local": "localTimer"
            },
            "calling": [
                "main"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036f8": {
            "entrypoint": "0x080036f8",
            "current_name": "process_tim_interrupts_080036f8",
            "code": "\nvoid process_TIM_interrupts_080036f8(TIM_HandleTypeDef *tim_handle)\n\n{\n  TIM_HandleTypeDef *local_tim_handle;\n  \n  if (((tim_handle->Instance->SR & 2) == 2) && ((tim_handle->Instance->DIER & 2) == 2)) {\n    tim_handle->Instance->SR = 0xfffffffd;\n    tim_handle->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n    if ((tim_handle->Instance->CCMR1 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(tim_handle);\n      HAL_TIM_PWM_PulseFinishedCallback(tim_handle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(tim_handle);\n    }\n    tim_handle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  if (((tim_handle->Instance->SR & 4) == 4) && ((tim_handle->Instance->DIER & 4) == 4)) {\n    tim_handle->Instance->SR = 0xfffffffb;\n    tim_handle->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n    if ((tim_handle->Instance->CCMR1 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(tim_handle);\n      HAL_TIM_PWM_PulseFinishedCallback(tim_handle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(tim_handle);\n    }\n    tim_handle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  if (((tim_handle->Instance->SR & 8) == 8) && ((tim_handle->Instance->DIER & 8) == 8)) {\n    tim_handle->Instance->SR = 0xfffffff7;\n    tim_handle->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n    if ((tim_handle->Instance->CCMR2 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(tim_handle);\n      HAL_TIM_PWM_PulseFinishedCallback(tim_handle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(tim_handle);\n    }\n    tim_handle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  if (((tim_handle->Instance->SR & 0x10) == 0x10) && ((tim_handle->Instance->DIER & 0x10) == 0x10)) {\n    tim_handle->Instance->SR = 0xffffffef;\n    tim_handle->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n    if ((tim_handle->Instance->CCMR2 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(tim_handle);\n      HAL_TIM_PWM_PulseFinishedCallback(tim_handle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(tim_handle);\n    }\n    tim_handle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  if (((tim_handle->Instance->SR & 1) == 1) && ((tim_handle->Instance->DIER & 1) == 1)) {\n    tim_handle->Instance->SR = 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(tim_handle);\n  }\n  if (((tim_handle->Instance->SR & 0x80) == 0x80) && ((tim_handle->Instance->DIER & 0x80) == 0x80)) {\n    tim_handle->Instance->SR = 0xffffff7f;\n    HAL_TIMEx_BreakCallback(tim_handle);\n  }\n  if (((tim_handle->Instance->SR & 0x40) == 0x40) && ((tim_handle->Instance->DIER & 0x40) == 0x40)) {\n    tim_handle->Instance->SR = 0xffffffbf;\n    HAL_TIM_TriggerCallback(tim_handle);\n  }\n  if (((tim_handle->Instance->SR & 0x20) == 0x20) && ((tim_handle->Instance->DIER & 0x20) == 0x20)) {\n    tim_handle->Instance->SR = 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(tim_handle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080036f8": "process_tim_interrupts_080036f8",
                "htim": "tim_handle",
                "htim_local": "local_tim_handle"
            },
            "calling": [
                "TIM2_IRQHandler"
            ],
            "called": [
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIMEx_BreakCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003908": {
            "entrypoint": "0x08003908",
            "current_name": "configure_timer_channel_08003908",
            "code": "\nHAL_StatusTypeDef configureTimerChannel_08003908(TIM_HandleTypeDef *timerHandle,TIM_OC_InitTypeDef *timerConfig,uint32_t channel)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t localChannel;\n  TIM_OC_InitTypeDef *localConfig;\n  TIM_HandleTypeDef *localTimerHandle;\n  \n  if (timerHandle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    timerHandle->Lock = HAL_LOCKED;\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    switch(channel) {\n    case 0:\n      TIM_OC1_SetConfig(timerHandle->Instance,timerConfig);\n      timerHandle->Instance->CCMR1 = timerHandle->Instance->CCMR1 | 8;\n      timerHandle->Instance->CCMR1 = timerHandle->Instance->CCMR1 & 0xfffffffb;\n      timerHandle->Instance->CCMR1 = timerConfig->OCFastMode | timerHandle->Instance->CCMR1;\n      break;\n    case 4:\n      TIM_OC2_SetConfig(timerHandle->Instance,timerConfig);\n      timerHandle->Instance->CCMR1 = timerHandle->Instance->CCMR1 | 0x800;\n      timerHandle->Instance->CCMR1 = timerHandle->Instance->CCMR1 & 0xfffffbff;\n      timerHandle->Instance->CCMR1 = timerConfig->OCFastMode << 8 | timerHandle->Instance->CCMR1;\n      break;\n    case 8:\n      TIM_OC3_SetConfig(timerHandle->Instance,timerConfig);\n      timerHandle->Instance->CCMR2 = timerHandle->Instance->CCMR2 | 8;\n      timerHandle->Instance->CCMR2 = timerHandle->Instance->CCMR2 & 0xfffffffb;\n      timerHandle->Instance->CCMR2 = timerConfig->OCFastMode | timerHandle->Instance->CCMR2;\n      break;\n    case 0xc:\n      TIM_OC4_SetConfig(timerHandle->Instance,timerConfig);\n      timerHandle->Instance->CCMR2 = timerHandle->Instance->CCMR2 | 0x800;\n      timerHandle->Instance->CCMR2 = timerHandle->Instance->CCMR2 & 0xfffffbff;\n      timerHandle->Instance->CCMR2 = timerConfig->OCFastMode << 8 | timerHandle->Instance->CCMR2;\n    }\n    timerHandle->State = HAL_TIM_STATE_READY;\n    timerHandle->Lock = HAL_UNLOCKED;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003908": "configure_timer_channel_08003908",
                "htim": "timerHandle",
                "sConfig": "timerConfig",
                "Channel": "channel",
                "HVar1": "status",
                "Channel_local": "localChannel",
                "sConfig_local": "localConfig",
                "htim_local": "localTimerHandle"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "TIM_OC4_SetConfig",
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC2_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a94": {
            "entrypoint": "0x08003a94",
            "current_name": "configure_timer_clock_08003a94",
            "code": "\nHAL_StatusTypeDef configureTimerClock_08003a94(TIM_HandleTypeDef *timerHandle,TIM_ClockConfigTypeDef *clockConfig)\n\n{\n  HAL_StatusTypeDef status;\n  uint clockSource;\n  TIM_ClockConfigTypeDef *localClockConfig;\n  TIM_HandleTypeDef *localTimerHandle;\n  uint32_t tmpSMCR;\n  \n  if (timerHandle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    timerHandle->Lock = HAL_LOCKED;\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    timerHandle->Instance->SMCR = timerHandle->Instance->SMCR & 0xffff0088;\n    clockSource = clockConfig->ClockSource;\n    if (clockSource == 0x40) {\n      TIM_TI1_ConfigInputStage\n                (timerHandle->Instance,clockConfig->ClockPolarity,clockConfig->ClockFilter);\n      TIM_ITRx_SetConfig(timerHandle->Instance,0x40);\n    }\n    else if (clockSource < 0x41) {\n      if (clockSource == 0x10) {\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x10);\n      }\n      else if (clockSource < 0x11) {\n        if (clockSource == 0) {\n          TIM_ITRx_SetConfig(timerHandle->Instance,0);\n        }\n      }\n      else if (clockSource == 0x20) {\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x20);\n      }\n      else if (clockSource == 0x30) {\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x30);\n      }\n    }\n    else if (clockSource == 0x70) {\n      TIM_ETR_SetConfig(timerHandle->Instance,clockConfig->ClockPrescaler,\n                        clockConfig->ClockPolarity,clockConfig->ClockFilter);\n      timerHandle->Instance->SMCR = timerHandle->Instance->SMCR & 0xffffff88 | 0x77;\n    }\n    else if (clockSource < 0x71) {\n      if (clockSource == 0x50) {\n        TIM_TI1_ConfigInputStage\n                  (timerHandle->Instance,clockConfig->ClockPolarity,clockConfig->ClockFilter)\n        ;\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x50);\n      }\n      else if (clockSource == 0x60) {\n        TIM_TI2_ConfigInputStage\n                  (timerHandle->Instance,clockConfig->ClockPolarity,clockConfig->ClockFilter)\n        ;\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x60);\n      }\n    }\n    else if (clockSource == 0x1000) {\n      timerHandle->Instance->SMCR = timerHandle->Instance->SMCR & 0xfffffff8;\n    }\n    else if (clockSource == 0x2000) {\n      TIM_ETR_SetConfig(timerHandle->Instance,clockConfig->ClockPrescaler,\n                        clockConfig->ClockPolarity,clockConfig->ClockFilter);\n      timerHandle->Instance->SMCR = timerHandle->Instance->SMCR | 0x4000;\n    }\n    timerHandle->State = HAL_TIM_STATE_READY;\n    timerHandle->Lock = HAL_UNLOCKED;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003a94": "configure_timer_clock_08003a94",
                "htim": "timerHandle",
                "sClockSourceConfig": "clockConfig",
                "HVar1": "status",
                "uVar2": "clockSource",
                "sClockSourceConfig_local": "localClockConfig",
                "htim_local": "localTimerHandle",
                "tmpsmcr": "tmpSMCR"
            },
            "calling": [
                "MX_TIM2_Init",
                "MX_TIM1_Init"
            ],
            "called": [
                "TIM_ETR_SetConfig",
                "TIM_TI2_ConfigInputStage",
                "TIM_TI1_ConfigInputStage",
                "TIM_ITRx_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c4a": {
            "entrypoint": "0x08003c4a",
            "current_name": "initialize_timer_08003c4a",
            "code": "\nvoid initializeTimer_08003c4a(TIM_HandleTypeDef *timerHandle)\n\n{\n  TIM_HandleTypeDef *localTimerHandle;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c4a": "initialize_timer_08003c4a",
                "htim": "timerHandle",
                "htim_local": "localTimerHandle"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c5c": {
            "entrypoint": "0x08003c5c",
            "current_name": "initialize_timer_08003c5c",
            "code": "\nvoid initializeTimer_08003c5c(TIM_HandleTypeDef *timerInstance)\n\n{\n  TIM_HandleTypeDef *timerInstance_local;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c5c": "initialize_timer_08003c5c",
                "htim": "timerInstance"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c6e": {
            "entrypoint": "0x08003c6e",
            "current_name": "handle_tim_interrupt_08003c6e",
            "code": "\nvoid handle_tim_interrupt_08003c6e(TIM_HandleTypeDef *tim_handler)\n\n{\n  TIM_HandleTypeDef *local_tim_handler;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c6e": "handle_tim_interrupt_08003c6e",
                "htim": "tim_handler",
                "htim_local": "local_tim_handler"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c80": {
            "entrypoint": "0x08003c80",
            "current_name": "init_timer_08003c80",
            "code": "\nvoid initTimer_08003c80(TIM_HandleTypeDef *timer)\n\n{\n  TIM_HandleTypeDef *localTimer;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c80": "init_timer_08003c80",
                "htim": "timer",
                "htim_local": "localTimer"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c94": {
            "entrypoint": "0x08003c94",
            "current_name": "initialize_timer_08003c94",
            "code": "\nvoid initializeTimer_08003c94(TIM_TypeDef *timer,TIM_Base_InitTypeDef *timerConfig)\n\n{\n  TIM_Base_InitTypeDef *localTimerConfig;\n  TIM_TypeDef *localTimer;\n  uint32_t controlRegister1;\n  \n  controlRegister1 = timer->CR1;\n  if ((((timer == (TIM_TypeDef *)0x40012c00) || (timer == (TIM_TypeDef *)0x40000000)) ||\n      (timer == (TIM_TypeDef *)0x40000400)) || (timer == (TIM_TypeDef *)0x40000800)) {\n    controlRegister1 = timerConfig->CounterMode | controlRegister1 & 0xffffff8f;\n  }\n  if (((timer == (TIM_TypeDef *)0x40012c00) || (timer == (TIM_TypeDef *)0x40000000)) ||\n     ((timer == (TIM_TypeDef *)0x40000400 || (timer == (TIM_TypeDef *)0x40000800)))) {\n    controlRegister1 = timerConfig->ClockDivision | controlRegister1 & 0xfffffcff;\n  }\n  timer->CR1 = timerConfig->AutoReloadPreload | controlRegister1 & 0xffffff7f;\n  timer->ARR = timerConfig->Period;\n  timer->PSC = timerConfig->Prescaler;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    uRam40012c30 = timerConfig->RepetitionCounter;\n  }\n  timer->EGR = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c94": "initialize_timer_08003c94",
                "TIMx": "timer",
                "Structure": "timerConfig",
                "Structure_local": "localTimerConfig",
                "TIMx_local": "localTimer",
                "tmpcr1": "controlRegister1"
            },
            "calling": [
                "HAL_TIM_PWM_Init",
                "HAL_TIM_Base_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d60": {
            "entrypoint": "0x08003d60",
            "current_name": "configure_timer_oc_08003d60",
            "code": "\nvoid configureTimerOC_08003d60(TIM_TypeDef *timer,TIM_OC_InitTypeDef *ocConfig)\n\n{\n  uint ocMode;\n  uint32_t ocPolarityAndCCER;\n  TIM_OC_InitTypeDef *ocConfigCopy;\n  TIM_TypeDef *timerCopy;\n  uint32_t tmpCCMRx;\n  uint32_t tmpCR2;\n  uint32_t tmpCCER;\n  \n  timer->CCER = timer->CCER & 0xfffffffe;\n  tmpCR2 = timer->CR2;\n  ocMode = ocConfig->OCMode;\n  ocPolarityAndCCER = ocConfig->OCPolarity | timer->CCER & 0xfffffffd;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    ocPolarityAndCCER = (ocConfig->OCNPolarity | ocPolarityAndCCER & 0xfffffff7) & 0xfffffffb;\n    tmpCR2 = ocConfig->OCNIdleState | ocConfig->OCIdleState | tmpCR2 & 0xfffffcff;\n  }\n  timer->CR2 = tmpCR2;\n  timer->CCMR1 = ocMode | timer->CCMR1 & 0xffffff8c;\n  timer->CCR1 = ocConfig->Pulse;\n  timer->CCER = ocPolarityAndCCER;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003d60": "configure_timer_oc_08003d60",
                "TIMx": "timer",
                "OC_Config": "ocConfig",
                "uVar1": "ocMode",
                "uVar2": "ocPolarityAndCCER",
                "OC_Config_local": "ocConfigCopy",
                "TIMx_local": "timerCopy",
                "tmpccmrx": "tmpCCMRx",
                "tmpcr2": "tmpCR2",
                "tmpccer": "tmpCCER"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e38": {
            "entrypoint": "0x08003e38",
            "current_name": "configurate_timer_output_channel_08003e38",
            "code": "\nvoid configurateTimerOutputChannel_08003e38(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputChannelConfig)\n\n{\n  uint32_t ocModeValue;\n  uint32_t ccerValue;\n  TIM_OC_InitTypeDef *localOutputChannelConfig;\n  TIM_TypeDef *localTimer;\n  uint32_t temporaryCcmrx;\n  uint32_t temporaryCr2;\n  uint32_t temporaryCcer;\n  \n  timer->CCER = timer->CCER & 0xffffffef;\n  temporaryCr2 = timer->CR2;\n  ocModeValue = outputChannelConfig->OCMode;\n  ccerValue = outputChannelConfig->OCPolarity << 4 | timer->CCER & 0xffffffdf;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    ccerValue = (outputChannelConfig->OCNPolarity << 4 | ccerValue & 0xffffff7f) & 0xffffffbf;\n    temporaryCr2 = outputChannelConfig->OCNIdleState << 2 | outputChannelConfig->OCIdleState << 2 | temporaryCr2 & 0xfffff3ff;\n  }\n  timer->CR2 = temporaryCr2;\n  timer->CCMR1 = ocModeValue << 8 | timer->CCMR1 & 0xffff8cff;\n  timer->CCR2 = outputChannelConfig->Pulse;\n  timer->CCER = ccerValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e38": "configurate_timer_output_channel_08003e38",
                "TIMx": "timer",
                "OC_Config": "outputChannelConfig",
                "OC_Config_local": "localOutputChannelConfig",
                "TIMx_local": "localTimer",
                "tmpccmrx": "temporaryCcmrx",
                "tmpcr2": "temporaryCr2",
                "tmpccer": "temporaryCcer",
                "uVar1": "ocModeValue",
                "uVar2": "ccerValue"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f18": {
            "entrypoint": "0x08003f18",
            "current_name": "configure_tim_oc_08003f18",
            "code": "\nvoid configure_TIM_OC_08003f18(TIM_TypeDef *timer,TIM_OC_InitTypeDef *oc_config)\n\n{\n  uint oc_mode;\n  uint32_t oc_polarity;\n  TIM_OC_InitTypeDef *oc_config_local;\n  TIM_TypeDef *timer_local;\n  uint32_t tmp_ccmrx;\n  uint32_t tmp_cr2;\n  uint32_t tmp_ccer;\n  \n  timer->CCER = timer->CCER & 0xfffffeff;\n  tmp_cr2 = timer->CR2;\n  oc_mode = oc_config->OCMode;\n  oc_polarity = oc_config->OCPolarity << 8 | timer->CCER & 0xfffffdff;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    oc_polarity = (oc_config->OCNPolarity << 8 | oc_polarity & 0xfffff7ff) & 0xfffffbff;\n    tmp_cr2 = oc_config->OCNIdleState << 4 | oc_config->OCIdleState << 4 | tmp_cr2 & 0xffffcfff;\n  }\n  timer->CR2 = tmp_cr2;\n  timer->CCMR2 = oc_mode | timer->CCMR2 & 0xffffff8c;\n  timer->CCR3 = oc_config->Pulse;\n  timer->CCER = oc_polarity;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f18": "configure_tim_oc_08003f18",
                "TIMx": "timer",
                "OC_Config": "oc_config",
                "OC_Config_local": "oc_config_local",
                "TIMx_local": "timer_local",
                "tmpccmrx": "tmp_ccmrx",
                "tmpcr2": "tmp_cr2",
                "tmpccer": "tmp_ccer",
                "uVar1": "oc_mode",
                "uVar2": "oc_polarity"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ff8": {
            "entrypoint": "0x08003ff8",
            "current_name": "configure_timer_output_compare_08003ff8",
            "code": "\nvoid configureTimerOutputCompare_08003ff8(TIM_TypeDef *timerInstance,TIM_OC_InitTypeDef *outputCompareConfig)\n\n{\n  uint32_t outputCompareMode;\n  uint32_t outputComparePolarity;\n  TIM_OC_InitTypeDef *localOutputCompareConfig;\n  TIM_TypeDef *localTimerInstance;\n  uint32_t tempCCER;\n  uint32_t tempCCMRX;\n  uint32_t tempCR2;\n  \n  timerInstance->CCER = timerInstance->CCER & 0xffffefff;\n  tempCR2 = timerInstance->CR2;\n  outputCompareMode = outputCompareConfig->OCMode;\n  outputComparePolarity = outputCompareConfig->OCPolarity;\n  if (timerInstance == (TIM_TypeDef *)0x40012c00) {\n    tempCR2 = outputCompareConfig->OCIdleState << 6 | tempCR2 & 0xffffbfff;\n  }\n  timerInstance->CR2 = tempCR2;\n  timerInstance->CCMR2 = outputCompareMode << 8 | timerInstance->CCMR2 & 0xffff8cff;\n  timerInstance->CCR4 = outputCompareConfig->Pulse;\n  timerInstance->CCER = outputComparePolarity << 0xc | timerInstance->CCER & 0xffffdfff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ff8": "configure_timer_output_compare_08003ff8",
                "TIMx": "timerInstance",
                "OC_Config": "outputCompareConfig",
                "OC_Config_local": "localOutputCompareConfig",
                "TIMx_local": "localTimerInstance",
                "tmpccer": "tempCCER",
                "tmpccmrx": "tempCCMRX",
                "tmpcr2": "tempCR2",
                "uVar1": "outputCompareMode",
                "uVar2": "outputComparePolarity"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040a0": {
            "entrypoint": "0x080040a0",
            "current_name": "configure_input_capture_080040a0",
            "code": "\nvoid configureInputCapture_080040a0(TIM_TypeDef *timer,uint32_t inputCapturePolarity,uint32_t inputCaptureFilter)\n\n{\n  uint ccerValue;\n  uint32_t localInputCaptureFilter;\n  uint32_t localInputCapturePolarity;\n  TIM_TypeDef *localTimer;\n  uint32_t tmpCCER;\n  uint32_t tmpCCMR1;\n  \n  ccerValue = timer->CCER;\n  timer->CCER = timer->CCER & 0xfffffffe;\n  timer->CCMR1 = inputCaptureFilter << 4 | timer->CCMR1 & 0xffffff0f;\n  timer->CCER = inputCapturePolarity | ccerValue & 0xfffffff5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040a0": "configure_input_capture_080040a0",
                "TIMx": "timer",
                "TIM_ICPolarity": "inputCapturePolarity",
                "TIM_ICFilter": "inputCaptureFilter",
                "uVar1": "ccerValue",
                "TIM_ICFilter_local": "localInputCaptureFilter",
                "TIM_ICPolarity_local": "localInputCapturePolarity",
                "TIMx_local": "localTimer",
                "tmpccer": "tmpCCER",
                "tmpccmr1": "tmpCCMR1"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004104": {
            "entrypoint": "0x08004104",
            "current_name": "configure_input_capture_08004104",
            "code": "\nvoid configureInputCapture_08004104(TIM_TypeDef *timer,uint32_t polarity,uint32_t filter)\n\n{\n  uint32_t localFilter;\n  uint32_t localPolarity;\n  TIM_TypeDef *localTimer;\n  uint32_t temporaryCCER;\n  uint32_t temporaryCCMR1;\n  \n  timer->CCER = timer->CCER & 0xffffffef;\n  timer->CCMR1 = filter << 0xc | timer->CCMR1 & 0xffff0fff;\n  timer->CCER = polarity << 4 | timer->CCER & 0xffffff5f;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004104": "configure_input_capture_08004104",
                "TIMx": "timer",
                "TIM_ICPolarity": "polarity",
                "TIM_ICFilter": "filter",
                "TIM_ICFilter_local": "localFilter",
                "TIM_ICPolarity_local": "localPolarity",
                "TIMx_local": "localTimer",
                "tmpccer": "temporaryCCER",
                "tmpccmr1": "temporaryCCMR1"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800416a": {
            "entrypoint": "0x0800416a",
            "current_name": "set_input_trigger_source_0800416a",
            "code": "\nvoid setInputTriggerSource_0800416a(TIM_TypeDef *timer,uint16_t triggerSource)\n\n{\n  uint16_t localTriggerSource;\n  TIM_TypeDef *localTimer;\n  uint32_t temporarySmcr;\n  \n  timer->SMCR = timer->SMCR & 0xffffff8f | (uint)(triggerSource | 7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800416a": "set_input_trigger_source_0800416a",
                "TIMx": "timer",
                "InputTriggerSource": "triggerSource",
                "InputTriggerSource_local": "localTriggerSource",
                "TIMx_local": "localTimer",
                "tmpsmcr": "temporarySmcr"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041a8": {
            "entrypoint": "0x080041a8",
            "current_name": "configure_external_trigger_080041a8",
            "code": "\nvoid configureExternalTrigger_080041a8(TIM_TypeDef *timer,uint32_t externalTriggerPrescaler,uint32_t externalTriggerPolarity,\n                 uint32_t externalTriggerFilter)\n\n{\n  uint32_t localExternalTriggerFilter;\n  uint32_t localExternalTriggerPolarity;\n  uint32_t localExternalTriggerPrescaler;\n  TIM_TypeDef *localTimer;\n  uint32_t temporarySMCR;\n  \n  timer->SMCR = externalTriggerPrescaler | externalTriggerFilter << 8 | externalTriggerPolarity |\n               timer->SMCR & 0xffff00ff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041a8": "configure_external_trigger_080041a8",
                "TIMx": "timer",
                "TIM_ExtTRGPrescaler": "externalTriggerPrescaler",
                "TIM_ExtTRGPolarity": "externalTriggerPolarity",
                "ExtTRGFilter": "externalTriggerFilter",
                "ExtTRGFilter_local": "localExternalTriggerFilter",
                "TIM_ExtTRGPolarity_local": "localExternalTriggerPolarity",
                "TIM_ExtTRGPrescaler_local": "localExternalTriggerPrescaler",
                "TIMx_local": "localTimer",
                "tmpsmcr": "temporarySMCR"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041ea": {
            "entrypoint": "0x080041ea",
            "current_name": "configure_timer_channel_080041ea",
            "code": "\nvoid configureTimerChannel_080041ea(TIM_TypeDef *timer,uint32_t channelNumber,uint32_t channelState)\n\n{\n  uint32_t localChannelState;\n  uint32_t localChannel;\n  TIM_TypeDef *localTimer;\n  uint32_t temporary;\n  \n  timer->CCER = timer->CCER & ~(1 << (channelNumber & 0xff));\n  timer->CCER = timer->CCER | channelState << (channelNumber & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041ea": "configure_timer_channel_080041ea",
                "TIMx": "timer",
                "Channel": "channelNumber",
                "ChannelState": "channelState",
                "ChannelState_local": "localChannelState",
                "Channel_local": "localChannel",
                "TIMx_local": "localTimer",
                "tmp": "temporary"
            },
            "calling": [
                "HAL_TIM_PWM_Start"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800422e": {
            "entrypoint": "0x0800422e",
            "current_name": "configure_break_dead_time_0800422e",
            "code": "\nHAL_StatusTypeDef\nconfigureBreakDeadTime_0800422e(TIM_HandleTypeDef *timerHandle,TIM_BreakDeadTimeConfigTypeDef *breakDeadTimeConfig)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_BreakDeadTimeConfigTypeDef *configLocal;\n  TIM_HandleTypeDef *timerLocal;\n  uint32_t tmpBDTR;\n  \n  if (timerHandle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    timerHandle->Lock = HAL_LOCKED;\n    timerHandle->Instance->BDTR =\n         breakDeadTimeConfig->AutomaticOutput |\n         (breakDeadTimeConfig->AutomaticOutput |\n         (breakDeadTimeConfig->BreakPolarity |\n         (breakDeadTimeConfig->BreakState |\n         (breakDeadTimeConfig->OffStateRunMode |\n         (breakDeadTimeConfig->OffStateIDLEMode |\n         (breakDeadTimeConfig->LockLevel | breakDeadTimeConfig->DeadTime & 0xfffffcff) &\n         0xfffffbff) & 0xfffff7ff) & 0xffffefff) & 0xffffdfff) & 0xffffbfff) & 0xffff7fff;\n    timerHandle->Lock = HAL_UNLOCKED;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800422e": "configure_break_dead_time_0800422e",
                "htim": "timerHandle",
                "sBreakDeadTimeConfig": "breakDeadTimeConfig",
                "HVar1": "status",
                "sBreakDeadTimeConfig_local": "configLocal",
                "htim_local": "timerLocal",
                "tmpbdtr": "tmpBDTR"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042de": {
            "entrypoint": "0x080042de",
            "current_name": "configure_master_timer_080042de",
            "code": "\nHAL_StatusTypeDef configureMasterTimer_080042de(TIM_HandleTypeDef *timerHandle,TIM_MasterConfigTypeDef *masterConfig)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_MasterConfigTypeDef *localMasterConfig;\n  TIM_HandleTypeDef *localTimerHandle;\n  \n  if (timerHandle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    timerHandle->Lock = HAL_LOCKED;\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    timerHandle->Instance->CR2 = timerHandle->Instance->CR2 & 0xffffff8f;\n    timerHandle->Instance->CR2 = masterConfig->MasterOutputTrigger | timerHandle->Instance->CR2;\n    timerHandle->Instance->SMCR = timerHandle->Instance->SMCR & 0xffffff7f;\n    timerHandle->Instance->SMCR = masterConfig->MasterSlaveMode | timerHandle->Instance->SMCR;\n    timerHandle->State = HAL_TIM_STATE_READY;\n    timerHandle->Lock = HAL_UNLOCKED;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080042de": "configure_master_timer_080042de",
                "htim": "timerHandle",
                "sMasterConfig": "masterConfig",
                "HVar1": "status",
                "sMasterConfig_local": "localMasterConfig",
                "htim_local": "localTimerHandle"
            },
            "calling": [
                "MX_TIM2_Init",
                "MX_TIM1_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004366": {
            "entrypoint": "0x08004366",
            "current_name": "initialize_timer_08004366",
            "code": "\nvoid initialize_timer_08004366(TIM_HandleTypeDef *timer)\n\n{\n  TIM_HandleTypeDef *local_timer;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08004366": "initialize_timer_08004366",
                "htim": "timer",
                "htim_local": "local_timer"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004378": {
            "entrypoint": "0x08004378",
            "current_name": "initialize_timer_08004378",
            "code": "\nvoid initializeTimer_08004378(TIM_HandleTypeDef *timer)\n\n{\n  TIM_HandleTypeDef *localTimer;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08004378": "initialize_timer_08004378",
                "htim": "timer",
                "htim_local": "localTimer"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800438a": {
            "entrypoint": "0x0800438a",
            "current_name": "initialize_uart_0800438a",
            "code": "\nHAL_StatusTypeDef initializeUART_0800438a(UART_HandleTypeDef *uartHandle)\n\n{\n  HAL_StatusTypeDef status;\n  UART_HandleTypeDef *localUartHandle;\n  \n  if (uartHandle == (UART_HandleTypeDef *)0x0) {\n    status = HAL_ERROR;\n  }\n  else {\n    if (uartHandle->gState == HAL_UART_STATE_RESET) {\n      uartHandle->Lock = HAL_UNLOCKED;\n      HAL_UART_MspInit(uartHandle);\n    }\n    uartHandle->gState = HAL_UART_STATE_BUSY;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xffffdfff;\n    UART_SetConfig(uartHandle);\n    uartHandle->Instance->CR2 = uartHandle->Instance->CR2 & 0xffffb7ff;\n    uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xffffffd5;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x2000;\n    uartHandle->ErrorCode = 0;\n    uartHandle->gState = HAL_UART_STATE_READY;\n    uartHandle->RxState = HAL_UART_STATE_READY;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800438a": "initialize_uart_0800438a",
                "huart": "uartHandle",
                "HVar1": "status",
                "huart_local": "localUartHandle"
            },
            "calling": [
                "MX_USART1_UART_Init"
            ],
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004424": {
            "entrypoint": "0x08004424",
            "current_name": "initialize_uart_08004424",
            "code": "\nvoid initialize_UART_08004424(UART_HandleTypeDef *uart_handle)\n\n{\n  UART_HandleTypeDef *uart_handle_local;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08004424": "initialize_uart_08004424",
                "huart": "uart_handle"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004436": {
            "entrypoint": "0x08004436",
            "current_name": "transmit_uart_data_08004436",
            "code": "\nHAL_StatusTypeDef\ntransmitUARTData_08004436(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t size,uint32_t timeout)\n\n{\n  uint32_t startTime;\n  uint32_t currentTime;\n  HAL_StatusTypeDef status;\n  int errorFlag;\n  uint32_t localTimeout;\n  uint16_t localSize;\n  uint8_t *localData;\n  UART_HandleTypeDef *localUartHandle;\n  uint16_t *temporary;\n  uint32_t tickStart;\n  \n  if (uartHandle->gState == HAL_UART_STATE_READY) {\n    if ((data == (uint8_t *)0x0) || (size == 0)) {\n      status = HAL_ERROR;\n    }\n    else if (uartHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      uartHandle->Lock = HAL_LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n      startTime = HAL_GetTick();\n      uartHandle->TxXfersize = size;\n      uartHandle->TxXferCount = size;\n      localData = data;\n      while (uartHandle->TxXferCount != 0) {\n        uartHandle->TxXferCount = uartHandle->TxXferCount - 1;\n        if ((uartHandle->Init).WordLength == 0x1000) {\n          do {\n            if ((uartHandle->Instance->SR & 0x80) == 0x80) {\n              errorFlag = 0;\n              goto LAB_0800454c;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (currentTime = HAL_GetTick(), currentTime - startTime <= timeout))));\n          uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffe5f;\n          uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n          uartHandle->gState = HAL_UART_STATE_READY;\n          uartHandle->RxState = HAL_UART_STATE_READY;\n          uartHandle->Lock = HAL_UNLOCKED;\n          errorFlag = 3;\nLAB_0800454c:\n          if (errorFlag != 0) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = *(ushort *)localData & 0x1ff;\n          if ((uartHandle->Init).Parity == 0) {\n            localData = localData + 2;\n          }\n          else {\n            localData = localData + 1;\n          }\n        }\n        else {\n          do {\n            if ((uartHandle->Instance->SR & 0x80) == 0x80) {\n              errorFlag = 0;\n              goto LAB_08004614;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (currentTime = HAL_GetTick(), currentTime - startTime <= timeout))));\n          uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffe5f;\n          uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n          uartHandle->gState = HAL_UART_STATE_READY;\n          uartHandle->RxState = HAL_UART_STATE_READY;\n          uartHandle->Lock = HAL_UNLOCKED;\n          errorFlag = 3;\nLAB_08004614:\n          if (errorFlag != 0) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = (uint)*localData;\n          localData = localData + 1;\n        }\n      }\n      do {\n        if ((uartHandle->Instance->SR & 0x40) == 0x40) {\n          errorFlag = 0;\n          goto LAB_080046c6;\n        }\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (currentTime = HAL_GetTick(), currentTime - startTime <= timeout))));\n      uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffe5f;\n      uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n      uartHandle->gState = HAL_UART_STATE_READY;\n      uartHandle->RxState = HAL_UART_STATE_READY;\n      uartHandle->Lock = HAL_UNLOCKED;\n      errorFlag = 3;\nLAB_080046c6:\n      if (errorFlag == 0) {\n        uartHandle->gState = HAL_UART_STATE_READY;\n        uartHandle->Lock = HAL_UNLOCKED;\n        status = HAL_OK;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08004436": "transmit_uart_data_08004436",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "uVar1": "startTime",
                "uVar2": "currentTime",
                "HVar3": "status",
                "iVar4": "errorFlag",
                "Timeout_local": "localTimeout",
                "Size_local": "localSize",
                "pData_local": "localData",
                "huart_local": "localUartHandle",
                "tmp": "temporary",
                "tickstart": "tickStart"
            },
            "calling": [
                "uart_print"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046ec": {
            "entrypoint": "0x080046ec",
            "current_name": "configure_uart_080046ec",
            "code": "\nvoid configure_UART_080046ec(UART_HandleTypeDef *uart_handle)\n\n{\n  uint32_t peripheral_clk_freq;\n  uint32_t peripheral_clk_freq;\n  uint32_t peripheral_clk_freq;\n  uint32_t peripheral_clk_freq;\n  uint32_t peripheral_clk_freq;\n  uint32_t baud_rate;\n  uint32_t baud_rate;\n  uint32_t baud_rate;\n  uint32_t baud_rate;\n  UART_HandleTypeDef *local_uart_handle;\n  uint32_t temporary_register;\n  \n  uart_handle->Instance->CR2 = (uart_handle->Init).StopBits | uart_handle->Instance->CR2 & 0xffffcfff;\n  uart_handle->Instance->CR1 =\n       uart_handle->Instance->CR1 & 0xffffe9f3 |\n       (uart_handle->Init).Mode | (uart_handle->Init).WordLength | (uart_handle->Init).Parity;\n  uart_handle->Instance->CR3 = (uart_handle->Init).HwFlowCtl | uart_handle->Instance->CR3 & 0xfffffcff;\n  if (uart_handle->Instance == (USART_TypeDef *)0x40013800) {\n    peripheral_clk_freq = HAL_RCC_GetPCLK2Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    peripheral_clk_freq = HAL_RCC_GetPCLK2Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    peripheral_clk_freq = HAL_RCC_GetPCLK2Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    peripheral_clk_freq = HAL_RCC_GetPCLK2Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    peripheral_clk_freq = HAL_RCC_GetPCLK2Freq();\n    uart_handle->Instance->BRR =\n         ((((peripheral_clk_freq * 0x19) / (baud_rate << 2) +\n           (int)(((ulonglong)(peripheral_clk_freq * 0x19) / (ulonglong)((uart_handle->Init).BaudRate << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) +\n         (int)(((ulonglong)(peripheral_clk_freq * 0x19) / (ulonglong)(baud_rate << 2)) / 100) * 0x10 +\n         ((((peripheral_clk_freq * 0x19) / (baud_rate << 2) +\n           (int)(((ulonglong)(peripheral_clk_freq * 0x19) / (ulonglong)(baud_rate << 2)) / 100) * -100) * 0x10 + 0x32)\n          / 100 & 0xf0);\n  }\n  else {\n    peripheral_clk_freq = HAL_RCC_GetPCLK1Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    peripheral_clk_freq = HAL_RCC_GetPCLK1Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    peripheral_clk_freq = HAL_RCC_GetPCLK1Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    peripheral_clk_freq = HAL_RCC_GetPCLK1Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    peripheral_clk_freq = HAL_RCC_GetPCLK1Freq();\n    uart_handle->Instance->BRR =\n         ((((peripheral_clk_freq * 0x19) / (baud_rate << 2) +\n           (int)(((ulonglong)(peripheral_clk_freq * 0x19) / (ulonglong)((uart_handle->Init).BaudRate << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) +\n         (int)(((ulonglong)(peripheral_clk_freq * 0x19) / (ulonglong)(baud_rate << 2)) / 100) * 0x10 +\n         ((((peripheral_clk_freq * 0x19) / (baud_rate << 2) +\n           (int)(((ulonglong)(peripheral_clk_freq * 0x19) / (ulonglong)(baud_rate << 2)) / 100) * -100) * 0x10 + 0x32)\n          / 100 & 0xf0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046ec": "configure_uart_080046ec",
                "huart": "uart_handle",
                "uVar1": "peripheral_clk_freq",
                "uVar2": "peripheral_clk_freq",
                "uVar3": "peripheral_clk_freq",
                "uVar4": "peripheral_clk_freq",
                "uVar5": "peripheral_clk_freq",
                "uVar6": "baud_rate",
                "uVar7": "baud_rate",
                "uVar8": "baud_rate",
                "uVar9": "baud_rate",
                "huart_local": "local_uart_handle",
                "tmpreg": "temporary_register"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800491c": {
            "entrypoint": "0x0800491c",
            "current_name": "initialize_mpu6050_0800491c",
            "code": "\nvoid initializeMPU6050_0800491c(Mpu6050 *mpu6050Data)\n\n{\n  Mpu6050 *mpu6050Data_local;\n  uint8_t resetValue;\n  uint8_t configValue;\n  uint8_t regValueArray [5];\n  \n  resetValue = '\\0';\n  (*I2C_Write_Reg)(0xd0,'k',&resetValue,1);\n  configValue = '\\x10';\n  (*I2C_Write_Reg)(0xd0,'\\x1c',&configValue,1);\n  regValueArray[0] = '\\b';\n  (*I2C_Write_Reg)(0xd0,'\\x1b',regValueArray,1);\n  mpu6050Data->accX = 0.0;\n  mpu6050Data->accY = 0.0;\n  mpu6050Data->accZ = 0.0;\n  mpu6050Data->temp = 0.0;\n  mpu6050Data->gyroX = 0.0;\n  mpu6050Data->gyroY = 0.0;\n  mpu6050Data->gyroZ = 0.0;\n  mpu6050Data->offset_gyroX = 0.0;\n  mpu6050Data->offset_gyroY = 0.0;\n  mpu6050Data->offset_acc_pitch = 0.0;\n  mpu6050Data->offset_acc_roll = 0.0;\n  mpu6050Data_calibrate(mpu6050Data);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800491c": "initialize_mpu6050_0800491c",
                "mpu6050": "mpu6050Data",
                "local_13": "resetValue",
                "local_12": "configValue",
                "local_11": "regValueArray"
            },
            "calling": [
                "main"
            ],
            "called": [
                "mpu6050_calibrate"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049cc": {
            "entrypoint": "0x080049cc",
            "current_name": "calculate_offsets_080049cc",
            "code": "\nvocountd calculateOffsets_080049cc(Mpu6050 *sensor)\n\n{\n  undefcountned4 sampleValue;\n  float divisionResult;\n  Mpu6050 *sensor_local;\n  float accelerationRoll;\n  float accelerationPitch;\n  ucountnt32_t currentTimestamp;\n  countnt numberOfSamples;\n  countnt count;\n  float accumulatorRoll;\n  float accumulatorPitch;\n  float accumulatorGyroY;\n  float accumulatorGyroX;\n  \n  numberOfSamples = 1;\n  accumulatorGyroX = 0.0;\n  accumulatorGyroY = 0.0;\n  accumulatorPitch = 0.0;\n  accumulatorRoll = 0.0;\n  currentTimestamp = (*getMillisecondsTick)();\n  count = 0;\n  whcountle( true ) {\n    countf (numberOfSamples <= count) break;\n    accelerationPitch = 0.0;\n    accelerationRoll = 0.0;\n    sensor_update(sensor);\n    sensor_calc_accelerationPitch_roll(sensor,&accelerationPitch,&accelerationRoll);\n    accumulatorPitch = (float)__addsf3(accumulatorPitch,accelerationPitch);\n    accumulatorRoll = (float)__addsf3(accumulatorRoll,accelerationRoll);\n    accumulatorGyroX = (float)__addsf3(accumulatorGyroX,sensor->gyroX);\n    accumulatorGyroY = (float)__addsf3(accumulatorGyroY,sensor->gyroY);\n    currentTimestamp = (*getMillisecondsTick)();\n    count = count + 1;\n  }\n  sampleValue = __floatscountsf(numberOfSamples);\n  divisionResult = (float)__aeabcount_fdcountv(accumulatorGyroX,sampleValue);\n  sensor->accumulatorGyroX = divisionResult;\n  sampleValue = __floatscountsf(numberOfSamples);\n  divisionResult = (float)__aeabcount_fdcountv(accumulatorGyroY,sampleValue);\n  sensor->accumulatorGyroY = divisionResult;\n  sampleValue = __floatscountsf(numberOfSamples);\n  divisionResult = (float)__aeabcount_fdcountv(accumulatorPitch,sampleValue);\n  sensor->offset_accelerationPitch = divisionResult;\n  sampleValue = __floatscountsf(numberOfSamples);\n  divisionResult = (float)__aeabcount_fdcountv(accumulatorRoll,sampleValue);\n  sensor->offset_accelerationRoll = divisionResult;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080049cc": "calculate_offsets_080049cc",
                "mpu6050": "sensor",
                "acc_roll": "accelerationRoll",
                "acc_pitch": "accelerationPitch",
                "now": "currentTimestamp",
                "num_samples": "numberOfSamples",
                "i": "count",
                "offset_accRoll": "accumulatorRoll",
                "offset_accPitch": "accumulatorPitch",
                "offset_gyroY": "accumulatorGyroY",
                "offset_gyroX": "accumulatorGyroX",
                "Get_ms_tick": "getMillisecondsTick",
                "uVar1": "sampleValue",
                "fVar2": "divisionResult"
            },
            "calling": [
                "mpu6050_init"
            ],
            "called": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_update",
                "__addsf3",
                "__aeabi_fdiv",
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ae0": {
            "entrypoint": "0x08004ae0",
            "current_name": "extract_data_from_mpu6050_08004ae0",
            "code": "\nvoid extractDataFromMpu6050_08004ae0(Mpu6050 *sensor)\n\n{\n  floatemperature fVar1;\n  Mpu6050 *sensor_local;\n  uintemperature8_temperature rawData [14];\n  intemperature16_temperature gyroZ;\n  intemperature16_temperature gyroY;\n  intemperature16_temperature gyroX;\n  intemperature16_temperature temperature;\n  intemperature16_temperature accZ;\n  intemperature16_temperature accY;\n  intemperature16_temperature accX;\n  \n  (*readRegister)(0xd0,';',rawData,0xe);\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[0],rawData[1]));\n  sensor->accX = fVar1;\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[2],rawData[3]));\n  sensor->accY = fVar1;\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[4],rawData[5]));\n  sensor->accZ = fVar1;\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[6],rawData[7]));\n  sensor->temperatureemp = fVar1;\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[8],rawData[9]));\n  sensor->gyroYroX = fVar1;\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[10],rawData[11]));\n  sensor->gyroYroY = fVar1;\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[12],rawData[13]));\n  sensor->gyroYroZ = fVar1;\n  retemperatureurn;\n}\n\n",
            "renaming": {
                "FUN_08004ae0": "extract_data_from_mpu6050_08004ae0",
                "mpu6050": "sensor",
                "raw": "rawData",
                "gz": "gyroZ",
                "gy": "gyroY",
                "gx": "gyroX",
                "t": "temperature",
                "az": "accZ",
                "ay": "accY",
                "ax": "accX",
                "I2C_Read_Reg": "readRegister"
            },
            "calling": [
                "mpu6050_calibrate",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bd8": {
            "entrypoint": "0x08004bd8",
            "current_name": "calculate_pitch_08004bd8",
            "code": "\nvoid calculate_pitch_08004bd8(Mpu6050 *accelerometer,float *result_pitch)\n\n{\n  undefined4 gyro_offset;\n  float adjusted_pitch;\n  undefined8 temp1;\n  undefined8 temp2;\n  float *local_pitch;\n  Mpu6050 *local_accelerometer;\n  float accelerometer_pitch;\n  float gyro_x_value;\n  \n  gyro_offset = __aeabi_fsub(accelerometer->gyroX,accelerometer->offset_gyroX);\n  temp1 = __aeabi_f2d(accelerometer_calc_result_pitch::total_result_pitch);\n  temp2 = __aeabi_f2d(gyro_offset);\n  temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0x83f5c366,0x3f340215);\n  temp1 = __aeabi_dadd((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                       (int)((ulonglong)temp2 >> 0x20));\n  accelerometer_calc_result_pitch::total_result_pitch = (float)__truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  temp1 = __aeabi_f2d(accelerometer->accY);\n  temp1 = __divdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40b00000);\n  temp2 = __aeabi_f2d(accelerometer->accZ);\n  temp2 = __divdf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0,0x40b00000);\n  temp1 = atan2((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                (int)((ulonglong)temp2 >> 0x20));\n  temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40668000);\n  temp1 = __divdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x54442d18,0x400921fb);\n  temp2 = __aeabi_f2d(accelerometer->offset_accelerometer_pitch);\n  temp1 = __subdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                   (int)((ulonglong)temp2 >> 0x20));\n  temp1 = __aeabi_dadd((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40568000);\n  adjusted_pitch = (float)__truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  if (accelerometer_calc_result_pitch::first_run == false) {\n    temp1 = __aeabi_f2d(accelerometer_calc_result_pitch::total_result_pitch);\n    temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x9999999a,0x3fe99999);\n    temp2 = __aeabi_f2d(adjusted_pitch);\n    temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0x9999999a,0x3fc99999);\n    temp1 = __aeabi_dadd((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                         (int)((ulonglong)temp2 >> 0x20));\n    accelerometer_calc_result_pitch::total_result_pitch =\n         (float)__truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  }\n  else {\n    accelerometer_calc_result_pitch::first_run = false;\n    accelerometer_calc_result_pitch::total_result_pitch = adjusted_pitch;\n  }\n  *result_pitch = accelerometer_calc_result_pitch::total_result_pitch;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bd8": "calculate_pitch_08004bd8",
                "mpu6050": "accelerometer",
                "pitch": "result_pitch",
                "uVar1": "gyro_offset",
                "fVar2": "adjusted_pitch",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "pitch_local": "local_pitch",
                "mpu6050_local": "local_accelerometer",
                "acc_pitch": "accelerometer_pitch",
                "gyro_x": "gyro_x_value"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_f2d",
                "__aeabi_dadd",
                "__muldf3",
                "__truncdfsf2",
                "__subdf3",
                "__aeabi_fsub",
                "__divdf3",
                "atan2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d78": {
            "entrypoint": "0x08004d78",
            "current_name": "calculate_pitch_and_roll_08004d78",
            "code": "\nvoid calculatePitchAndRoll_08004d78(Mpu6050 *sensorData,float *pitchValue,float *rollValue)\n\n{\n  undefined4 divX;\n  undefined4 divY;\n  undefined4 divZ;\n  float pitchAngle;\n  float rollAngle;\n  undefined8 atanResult;\n  undefined8 atanResult2;\n  float *rollLocal;\n  float *pitchLocal;\n  Mpu6050 *sensorDataLocal;\n  float accelerationRoll;\n  float accelerationPitch;\n  float accelerationZ;\n  float accelerationY;\n  float accelerationX;\n  \n  divX = __aeabi_fdiv(sensorData->accX,0x45800000);\n  divY = __aeabi_fdiv(sensorData->accY,0x45800000);\n  divZ = __aeabi_fdiv(sensorData->accZ,0x45800000);\n  atanResult = __aeabi_f2d(divY);\n  atanResult2 = __aeabi_f2d(divZ);\n  atanResult = atan2((int)atanResult,(int)((ulonglong)atanResult >> 0x20),(int)atanResult2,\n                (int)((ulonglong)atanResult2 >> 0x20));\n  atanResult = __muldf3((int)atanResult,(int)((ulonglong)atanResult >> 0x20),0,0x40668000);\n  atanResult = __divdf3((int)atanResult,(int)((ulonglong)atanResult >> 0x20),0x54442d18,0x400921fb);\n  pitchAngle = (float)__truncdfsf2((int)atanResult,(int)((ulonglong)atanResult >> 0x20));\n  atanResult = __aeabi_f2d(divX);\n  atanResult2 = __aeabi_f2d(divZ);\n  atanResult = atan2((int)atanResult,(int)((ulonglong)atanResult >> 0x20),(int)atanResult2,\n                (int)((ulonglong)atanResult2 >> 0x20));\n  atanResult = __muldf3((int)atanResult,(int)((ulonglong)atanResult >> 0x20),0,0x40668000);\n  atanResult = __divdf3((int)atanResult,(int)((ulonglong)atanResult >> 0x20),0x54442d18,0x400921fb);\n  rollAngle = (float)__truncdfsf2((int)atanResult,(int)((ulonglong)atanResult >> 0x20));\n  *pitchValue = pitchAngle;\n  *rollValue = rollAngle;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d78": "calculate_pitch_and_roll_08004d78",
                "mpu6050": "sensorData",
                "pitch": "pitchValue",
                "roll": "rollValue",
                "fVar4": "pitchAngle",
                "fVar5": "rollAngle",
                "uVar1": "divX",
                "uVar2": "divY",
                "uVar3": "divZ",
                "uVar6": "atanResult",
                "uVar7": "atanResult2",
                "roll_local": "rollLocal",
                "pitch_local": "pitchLocal",
                "mpu6050_local": "sensorDataLocal",
                "acc_roll": "accelerationRoll",
                "acc_pitch": "accelerationPitch",
                "acc_z": "accelerationZ",
                "acc_y": "accelerationY",
                "acc_x": "accelerationX"
            },
            "calling": [
                "mpu6050_calibrate"
            ],
            "called": [
                "__aeabi_fdiv",
                "__aeabi_f2d",
                "__muldf3",
                "__truncdfsf2",
                "atan2",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e6c": {
            "entrypoint": "0x08004e6c",
            "current_name": "execute_system_call_08004e6c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_system_call_08004e6c(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_08004e6c": "execute_system_call_08004e6c"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e74": {
            "entrypoint": "0x08004e74",
            "current_name": "get_afl_call_result_08004e74",
            "code": "\nint getAflCallResult_08004e74(int ticks)\n\n{\n  uint32_t aflCallResult;\n  int localTicks;\n  \n  if (noHyperCall == 0) {\n    aflCallResult = aflCall(1,ticks,0);\n  }\n  else {\n    aflCallResult = 0;\n  }\n  return aflCallResult;\n}\n\n",
            "renaming": {
                "FUN_08004e74": "get_afl_call_result_08004e74",
                "uVar1": "aflCallResult",
                "ticks_local": "localTicks"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ea4": {
            "entrypoint": "0x08004ea4",
            "current_name": "write_data_to_i2_c_device_08004ea4",
            "code": "\nvoid writeDataToI2CDevice_08004ea4(uint8_t deviceAddress,uint8_t registerAddress,uint8_t *dataBuffer,uint16_t dataLength)\n\n{\n  uint8_t *localData;\n  uint16_t localDataLength;\n  uint8_t localRegister;\n  uint8_t localAddress;\n  \n  HAL_I2C_Mem_Write(&hi2c1,(ushort)deviceAddress,(ushort)registerAddress,1,dataBuffer,dataLength,I2C_TIMEOUT);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ea4": "write_data_to_i2_c_device_08004ea4",
                "addr": "deviceAddress",
                "reg": "registerAddress",
                "data": "dataBuffer",
                "len": "dataLength",
                "data_local": "localData",
                "len_local": "localDataLength",
                "reg_local": "localRegister",
                "addr_local": "localAddress"
            },
            "calling": [],
            "called": [
                "HAL_I2C_Mem_Write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee8": {
            "entrypoint": "0x08004ee8",
            "current_name": "read_i2_c_data_08004ee8",
            "code": "\nvoid readI2CData_08004ee8(uint8_t address,uint8_t register,uint8_t *dataBuffer,uint16_t dataLength)\n\n{\n  uint8_t *localData;\n  uint16_t localDataLength;\n  uint8_t localRegister;\n  uint8_t localAddress;\n  \n  HAL_I2C_Mem_Read(&hi2c1,(ushort)address,(ushort)register,1,dataBuffer,dataLength,I2C_TIMEOUT);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ee8": "read_i2_c_data_08004ee8",
                "addr": "address",
                "reg": "register",
                "data": "dataBuffer",
                "len": "dataLength",
                "data_local": "localData",
                "len_local": "localDataLength",
                "reg_local": "localRegister",
                "addr_local": "localAddress"
            },
            "calling": [],
            "called": [
                "HAL_I2C_Mem_Read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f2c": {
            "entrypoint": "0x08004f2c",
            "current_name": "get_system_time_08004f2c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemTime_08004f2c(void)\n\n{\n  uint32_t systemTime;\n  \n  systemTime = HAL_GetTick();\n  return systemTime;\n}\n\n",
            "renaming": {
                "FUN_08004f2c": "get_system_time_08004f2c",
                "uVar1": "systemTime"
            },
            "calling": [],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "transmit_string_08004f3c",
            "code": "\nvoid transmitString_08004f3c(char *string,uint32_t length)\n\n{\n  uint32_t localLength;\n  char *localString;\n  \n  HAL_UART_Transmit(&huart1,(uint8_t *)string,(uint16_t)length,0x32);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "transmit_string_08004f3c",
                "str": "string",
                "len": "length",
                "len_local": "localLength",
                "str_local": "localString"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "HAL_UART_Transmit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f60": {
            "entrypoint": "0x08004f60",
            "current_name": "initialize_string_buffer_08004f60",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeStringBuffer_08004f60(void)\n\n{\n  memset(buffer,0,0x40);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f60": "initialize_string_buffer_08004f60",
                "strbuf": "buffer"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f78": {
            "entrypoint": "0x08004f78",
            "current_name": "pid_controller_08004f78",
            "code": "\nvoid pidController_08004f78(TXWKNproportionalTermCSMWEM_HandleTypeDef *FBproportionalTermLZFGWCY)\n\n{\n  size_t stringLength;\n  undefined4 ZproportionalTermEAOSHGDY;\n  int WproportionalTermJZZNNNFE;\n  undefined4 SGGYXFYproportionalTermDF;\n  uint KZXWKNproportionalTermCSMWELYproportionalTermZRFK;\n  undefined8 tempVar5;\n  TXWKNproportionalTermCSMWEM_HandleTypeDef *EproportionalTermXXWKNproportionalTermCSMWESMREZE;\n  float SWCWZXWKNproportionalTermCSMWEVBSW;\n  uint8_t UXOJXWKNproportionalTermCSMWEOWLXJ;\n  \n  sensor_update(&sensor);\n  sensor_calc_pitchAngle(&sensor,&pitchAngle);\n  flush_VAZQproportionalTermproportionalTermVSWV();\n  tempVar5 = __aeabi_f2d(pitchAngle);\n  sprintf(VAZQproportionalTermproportionalTermVSWV,\"proportionalTermitch: %f\\n\",(int)tempVar5,(int)((ulonglong)tempVar5 >> 0x20));\n  stringLength = strstringLength(VAZQproportionalTermproportionalTermVSWV);\n  uart_print(VAZQproportionalTermproportionalTermVSWV,stringLength);\n  QKDGXWKNproportionalTermCSMWEBGQCR = (float)__aeabi_fsub(JXAXYRproportionalTermDVQ,pitchAngle);\n  proportionalTerm = (float)__aeabi_fmul(Kp,QKDGXWKNproportionalTermCSMWEBGQCR);\n  ZproportionalTermEAOSHGDY = __aeabi_fmul(integralGain,QKDGXWKNproportionalTermCSMWEBGQCR);\n  XWKNproportionalTermCSMWE = (float)__addsf3(ZproportionalTermEAOSHGDY,XWKNproportionalTermCSMWE);\n  ZproportionalTermEAOSHGDY = __floatsisf(KXWKNproportionalTermCSMWEOMOXTGYZ);\n  WproportionalTermJZZNNNFE = __aeabi_fcmplt(ZproportionalTermEAOSHGDY,XWKNproportionalTermCSMWE);\n  if (WproportionalTermJZZNNNFE == 0) {\n    ZproportionalTermEAOSHGDY = __floatsisf(TVXWKNproportionalTermCSMWEBUproportionalTermRKON);\n    WproportionalTermJZZNNNFE = __aeabi_fcmpgt(ZproportionalTermEAOSHGDY,XWKNproportionalTermCSMWE);\n    if (WproportionalTermJZZNNNFE != 0) {\n      XWKNproportionalTermCSMWE = (float)__floatunsisf(TVXWKNproportionalTermCSMWEBUproportionalTermRKON);\n    }\n  }\n  else {\n    XWKNproportionalTermCSMWE = (float)__floatunsisf(KXWKNproportionalTermCSMWEOMOXTGYZ);\n  }\n  KZXWKNproportionalTermCSMWELYproportionalTermZRFK = (uint)WDRDNMTBXWKNproportionalTermCSMWEY ^ 0x80000000;\n  ZproportionalTermEAOSHGDY = __aeabi_fsub(QKDGXWKNproportionalTermCSMWEBGQCR,XWKNproportionalTermCSMWETCRRRXWKNproportionalTermCSMWERHXWKNproportionalTermCSMWE);\n  D = (float)__aeabi_fmul(KZXWKNproportionalTermCSMWELYproportionalTermZRFK,ZproportionalTermEAOSHGDY);\n  ZproportionalTermEAOSHGDY = __addsf3(proportionalTerm,XWKNproportionalTermCSMWE);\n  ZproportionalTermEAOSHGDY = __addsf3(ZproportionalTermEAOSHGDY,D);\n  SGGYXFYproportionalTermDF = __floatsisf(KXWKNproportionalTermCSMWEOMOXTGYZ);\n  WproportionalTermJZZNNNFE = __aeabi_fcmpgt(ZproportionalTermEAOSHGDY,SGGYXFYproportionalTermDF);\n  if (WproportionalTermJZZNNNFE == 0) {\n    SGGYXFYproportionalTermDF = __floatsisf(TVXWKNproportionalTermCSMWEBUproportionalTermRKON);\n    WproportionalTermJZZNNNFE = __aeabi_fcmplt(ZproportionalTermEAOSHGDY,SGGYXFYproportionalTermDF);\n    if (WproportionalTermJZZNNNFE == 0) {\n      UXOJXWKNproportionalTermCSMWEOWLXJ = __fixunssfsi(ZproportionalTermEAOSHGDY);\n    }\n    else {\n      UXOJXWKNproportionalTermCSMWEOWLXJ = TVXWKNproportionalTermCSMWEBUproportionalTermRKON;\n    }\n  }\n  else {\n    UXOJXWKNproportionalTermCSMWEOWLXJ = KXWKNproportionalTermCSMWEOMOXTGYZ;\n  }\n  XWKNproportionalTermCSMWETCRRRXWKNproportionalTermCSMWERHXWKNproportionalTermCSMWE = QKDGXWKNproportionalTermCSMWEBGQCR;\n  WproportionalTermJZZNNNFE = __aeabi_fcmpgt(QKDGXWKNproportionalTermCSMWEBGQCR,0);\n  HAL_GproportionalTermXWKNproportionalTermCSMWEO_WriteproportionalTermin((GproportionalTermXWKNproportionalTermCSMWEO_TypeDef *)0x40010800,2,WproportionalTermJZZNNNFE != 0);\n  WproportionalTermJZZNNNFE = __aeabi_fcmpgt(QKDGXWKNproportionalTermCSMWEBGQCR,0);\n  HAL_GproportionalTermXWKNproportionalTermCSMWEO_WriteproportionalTermin((GproportionalTermXWKNproportionalTermCSMWEO_TypeDef *)0x40010800,4,WproportionalTermJZZNNNFE == 0);\n  WproportionalTermJZZNNNFE = __aeabi_fcmpgt(QKDGXWKNproportionalTermCSMWEBGQCR,0);\n  HAL_GproportionalTermXWKNproportionalTermCSMWEO_WriteproportionalTermin((GproportionalTermXWKNproportionalTermCSMWEO_TypeDef *)0x40010800,8,WproportionalTermJZZNNNFE != 0);\n  WproportionalTermJZZNNNFE = __aeabi_fcmpgt(QKDGXWKNproportionalTermCSMWEBGQCR,0);\n  HAL_GproportionalTermXWKNproportionalTermCSMWEO_WriteproportionalTermin((GproportionalTermXWKNproportionalTermCSMWEO_TypeDef *)0x40010800,0x10,WproportionalTermJZZNNNFE == 0);\n  (FBproportionalTermLZFGWCY1.XWKNproportionalTermCSMWEnstance)->CCR1 = (uint)UXOJXWKNproportionalTermCSMWEOWLXJ;\n  (FBproportionalTermLZFGWCY1.XWKNproportionalTermCSMWEnstance)->CCR4 = (uint)UXOJXWKNproportionalTermCSMWEOWLXJ;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f78": "pid_controller_08004f78",
                "htim": "timer",
                "len": "stringLength",
                "uVar1": "tempVar1",
                "iVar2": "tempVar2",
                "uVar3": "tempVar3",
                "uVar4": "tempVar4",
                "uVar5": "tempVar5",
                "htim_local": "localTimer",
                "pid_pwm": "pidPwm",
                "out_pwm": "outputPwm",
                "mpu6050": "sensor",
                "pitch": "pitchAngle",
                "strbuf": "stringBuffer",
                "error": "errorValue",
                "setpoint": "desiredPitch",
                "P": "proportionalTerm",
                "Ki": "integralGain",
                "I": "integralTerm",
                "maxPwm": "maximumPwm",
                "minPwm": "minimumPwm",
                "Kd": "derivativeGain",
                "lastError": "previousError"
            },
            "calling": [
                "HAL_TIM_IRQHandler",
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [
                "mpu6050_update",
                "__floatsisf",
                "__aeabi_fcmpgt",
                "uart_print",
                "__aeabi_fmul",
                "mpu6050_calc_pitch",
                "__addsf3",
                "HAL_GPIO_WritePin",
                "__aeabi_f2d",
                "flush_strbuf",
                "__aeabi_fcmplt",
                "strlen",
                "__floatunsisf",
                "__aeabi_fsub",
                "__fixunssfsi",
                "sprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005224": {
            "entrypoint": "0x08005224",
            "current_name": "initialize_system_08005224",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint initializeSystem_08005224(void)\n\n{\n  initializeHardware();\n  configureSystemClock();\n  initializeGPIO();\n  initializeI2C1();\n  initializeUSART1_UART();\n  initializeTIM2();\n  initializeTIM1();\n  writeRegI2C = _i2c_write_reg + 1;\n  readRegI2C = _i2c_read_reg + 1;\n  getMsTick = _get_ms_tick + 1;\n  startPWMTimer(&htim1,0);\n  startPWMTimer(&htim1,0xc);\n  initializeMPU6050(&mpu6050);\n  startBaseTimerWithInterrupt(&htim2);\n  startForkServer(0);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005224": "initialize_system_08005224",
                "HAL_Init": "initializeHardware",
                "SystemClock_Config": "configureSystemClock",
                "MX_GPIO_Init": "initializeGPIO",
                "MX_I2C1_Init": "initializeI2C1",
                "MX_USART1_UART_Init": "initializeUSART1_UART",
                "MX_TIM2_Init": "initializeTIM2",
                "MX_TIM1_Init": "initializeTIM1",
                "I2C_Write_Reg": "writeRegI2C",
                "I2C_Read_Reg": "readRegI2C",
                "Get_ms_tick": "getMsTick",
                "HAL_TIM_PWM_Start": "startPWMTimer",
                "mpu6050_init": "initializeMPU6050",
                "HAL_TIM_Base_Start_IT": "startBaseTimerWithInterrupt",
                "startForkserver": "startForkServer"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "HAL_TIM_PWM_Start",
                "MX_GPIO_Init",
                "MX_TIM2_Init",
                "MX_USART1_UART_Init",
                "HAL_TIM_Base_Start_IT",
                "startForkserver",
                "SystemClock_Config",
                "HAL_Init",
                "MX_TIM1_Init",
                "MX_I2C1_Init",
                "mpu6050_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052a0": {
            "entrypoint": "0x080052a0",
            "current_name": "initialize_clock_080052a0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeClock_080052a0(void)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t HCLKFreq;\n  RCC_ClkInitTypeDef clockInitStruct;\n  RCC_OscInitTypeDef oscInitStruct;\n  \n  oscInitStruct.OscillatorType = 1;\n  oscInitStruct.HSEState = 0x10000;\n  oscInitStruct.HSEPredivValue = 0;\n  oscInitStruct.HSIState = 1;\n  oscInitStruct.PLL.PLLState = 2;\n  oscInitStruct.PLL.PLLSource = 0x10000;\n  oscInitStruct.PLL.PLLMUL = 0x1c0000;\n  status = HAL_RCC_OscConfig(&oscInitStruct);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x151);\n  }\n  clockInitStruct.ClockType = 0xf;\n  clockInitStruct.SYSCLKSource = 2;\n  clockInitStruct.AHBCLKDivider = 0x80;\n  clockInitStruct.APB1CLKDivider = 0;\n  clockInitStruct.APB2CLKDivider = 0;\n  status = HAL_RCC_ClockConfig(&clockInitStruct,2);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x15e);\n  }\n  HCLKFreq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(HCLKFreq / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052a0": "initialize_clock_080052a0",
                "RCC_ClkInitStruct": "clockInitStruct",
                "RCC_OscInitStruct": "oscInitStruct",
                "HVar1": "status",
                "uVar2": "HCLKFreq"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_NVIC_SetPriority",
                "_Error_Handler",
                "HAL_RCC_OscConfig",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_Config",
                "HAL_RCC_ClockConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005348": {
            "entrypoint": "0x08005348",
            "current_name": "initialize_i2_c_08005348",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeI2C_08005348(void)\n\n{\n  I2C_Status status;\n  \n  i2cHandle.i2cInstance = (I2C_TypeDef *)0x40005400;\n  i2cHandle.Init.i2cClockSpeed = 400000;\n  i2cHandle.Init.i2cDutyCycle = 0;\n  i2cHandle.Init.i2cOwnAddress1 = 0;\n  i2cHandle.Init.i2cAddressingMode = 0x4000;\n  i2cHandle.Init.i2cDualAddressMode = 0;\n  i2cHandle.Init.i2cOwnAddress2 = 0;\n  i2cHandle.Init.i2cGeneralCallMode = 0;\n  i2cHandle.Init.i2cNoStretchMode = 0;\n  status = HAL_I2C_Init(&i2cHandle);\n  if (status != HAL_OK) {\n    handleError(\"../src/main.c\",0x17a);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005348": "initialize_i2_c_08005348",
                "HAL_StatusTypeDef": "I2C_Status",
                "HVar1": "status",
                "hi2c1": "i2cHandle",
                "Instance": "i2cInstance",
                "ClockSpeed": "i2cClockSpeed",
                "DutyCycle": "i2cDutyCycle",
                "OwnAddress1": "i2cOwnAddress1",
                "AddressingMode": "i2cAddressingMode",
                "DualAddressMode": "i2cDualAddressMode",
                "OwnAddress2": "i2cOwnAddress2",
                "GeneralCallMode": "i2cGeneralCallMode",
                "NoStretchMode": "i2cNoStretchMode",
                "_Error_Handler": "handleError"
            },
            "calling": [
                "main"
            ],
            "called": [
                "_Error_Handler",
                "HAL_I2C_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053b0": {
            "entrypoint": "0x080053b0",
            "current_name": "initialize_timer_080053b0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimer_080053b0(void)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_BreakDeadTimeConfigTypeDef breakDeadTimeConfig;\n  TIM_OC_InitTypeDef ocConfig;\n  TIM_MasterConfigTypeDef masterConfig;\n  TIM_ClockConfigTypeDef clockSourceConfig;\n  \n  htim1.Instance = (TIM_TypeDef *)0x40012c00;\n  htim1.Init.Prescaler = 0x708;\n  htim1.Init.CounterMode = 0;\n  htim1.Init.Period = 100;\n  htim1.Init.ClockDivision = 0;\n  htim1.Init.RepetitionCounter = 0;\n  htim1.Init.AutoReloadPreload = 0;\n  status = HAL_TIM_Base_Init(&htim1);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",399);\n  }\n  clockSourceConfig.ClockSource = 0x1000;\n  status = HAL_TIM_ConfigClockSource(&htim1,&clockSourceConfig);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x194);\n  }\n  status = HAL_TIM_PWM_Init(&htim1);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x198);\n  }\n  masterConfig.MasterOutputTrigger = 0;\n  masterConfig.MasterSlaveMode = 0;\n  status = HAL_TIMEx_MasterConfigSynchronization(&htim1,&masterConfig);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x19f);\n  }\n  ocConfig.OCMode = 0x60;\n  ocConfig.Pulse = 0;\n  ocConfig.OCPolarity = 0;\n  ocConfig.OCNPolarity = 0;\n  ocConfig.OCFastMode = 0;\n  ocConfig.OCIdleState = 0;\n  ocConfig.OCNIdleState = 0;\n  status = HAL_TIM_PWM_ConfigChannel(&htim1,&ocConfig,0);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1ab);\n  }\n  status = HAL_TIM_PWM_ConfigChannel(&htim1,&ocConfig,0xc);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1b0);\n  }\n  breakDeadTimeConfig.OffStateRunMode = 0;\n  breakDeadTimeConfig.OffStateIDLEMode = 0;\n  breakDeadTimeConfig.LockLevel = 0;\n  breakDeadTimeConfig.DeadTime = 0;\n  breakDeadTimeConfig.BreakState = 0;\n  breakDeadTimeConfig.BreakPolarity = 0x2000;\n  breakDeadTimeConfig.AutomaticOutput = 0;\n  status = HAL_TIMEx_ConfigBreakDeadTime(&htim1,&breakDeadTimeConfig);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1bc);\n  }\n  HAL_TIM_MspPostInit(&htim1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053b0": "initialize_timer_080053b0",
                "HVar1": "status",
                "sBreakDeadTimeConfig": "breakDeadTimeConfig",
                "sConfigOC": "ocConfig",
                "sMasterConfig": "masterConfig",
                "sClockSourceConfig": "clockSourceConfig"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_TIMEx_MasterConfigSynchronization",
                "HAL_TIM_PWM_Init",
                "_Error_Handler",
                "HAL_TIM_MspPostInit",
                "HAL_TIMEx_ConfigBreakDeadTime",
                "HAL_TIM_ConfigClockSource",
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_Base_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005500": {
            "entrypoint": "0x08005500",
            "current_name": "initialize_timer_08005500",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimer_08005500(void)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_MasterConfigTypeDef masterConfig;\n  TIM_ClockConfigTypeDef clockConfig;\n  \n  htim2.Instance = (TIM_TypeDef *)0x40000000;\n  htim2.Init.Prescaler = 36000;\n  htim2.Init.CounterMode = 0;\n  htim2.Init.Period = 0x14;\n  htim2.Init.ClockDivision = 0;\n  htim2.Init.AutoReloadPreload = 0;\n  status = HAL_TIM_Base_Init(&htim2);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1d0);\n  }\n  clockConfig.ClockSource = 0x1000;\n  status = HAL_TIM_ConfigClockSource(&htim2,&clockConfig);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1d5);\n  }\n  masterConfig.MasterOutputTrigger = 0x20;\n  masterConfig.MasterSlaveMode = 0;\n  status = HAL_TIMEx_MasterConfigSynchronization(&htim2,&masterConfig);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1dc);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005500": "initialize_timer_08005500",
                "HVar1": "status",
                "sMasterConfig": "masterConfig",
                "sClockSourceConfig": "clockConfig"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_TIMEx_MasterConfigSynchronization",
                "_Error_Handler",
                "HAL_TIM_ConfigClockSource",
                "HAL_TIM_Base_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005598": {
            "entrypoint": "0x08005598",
            "current_name": "initialize_uart_08005598",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_UART_08005598(void)\n\n{\n  HAL_StatusTypeDef status;\n  \n  UART_handle.Instance = (USART_type *)0x40013800;\n  UART_config.baud_rate = 0x1c200;\n  UART_config.word_length = 0;\n  UART_config.stop_bits = 0;\n  UART_config.parity = 0;\n  UART_config.mode = 0xc;\n  UART_config.hw_flow_control = 0;\n  UART_config.over_sampling = 0;\n  status = initialize_UART_08005598_HAL(&UART_handle);\n  if (status != HAL_OK) {\n    handle_error(\"../src/main.c\",0x1ed);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005598": "initialize_uart_08005598",
                "huart1": "UART_handle",
                "HVar1": "status",
                "USART_TypeDef": "USART_type",
                "huart1.Init.BaudRate": "UART_config.baud_rate",
                "huart1.Init.WordLength": "UART_config.word_length",
                "huart1.Init.StopBits": "UART_config.stop_bits",
                "huart1.Init.Parity": "UART_config.parity",
                "huart1.Init.Mode": "UART_config.mode",
                "huart1.Init.HwFlowCtl": "UART_config.hw_flow_control",
                "huart1.Init.OverSampling": "UART_config.over_sampling",
                "HAL_UART_Init": "initialize_UART_HAL",
                "_Error_Handler": "handle_error"
            },
            "calling": [
                "main"
            ],
            "called": [
                "_Error_Handler",
                "HAL_UART_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055f4": {
            "entrypoint": "0x080055f4",
            "current_name": "initialize_gpio_080055f4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_GPIO_080055f4(void)\n\n{\n  uint32_t register_value_2;\n  uint32_t register_value_1;\n  uint32_t register_value;\n  GPIO_InitTypeDef gpio_config;\n  \n  _DAT_40021018 = _DAT_40021018 | 0x2c;\n  set_GPIO_Pin((GPIO_TypeDef *)0x40010800,0x1e,pin_reset);\n  pin_number_to_configure = 0x1e;\n  pin_mode = 1;\n  pin_speed = 2;\n  initialize_GPIO_080055f4_pin((GPIO_TypeDef *)0x40010800,&gpio_config);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055f4": "initialize_gpio_080055f4",
                "tmpreg_2": "register_value_2",
                "tmpreg_1": "register_value_1",
                "tmpreg": "register_value",
                "GPIO_InitStruct": "gpio_config",
                "HAL_GPIO_WritePin": "set_GPIO_Pin",
                "GPIO_PIN_RESET": "pin_reset",
                "GPIO_InitStruct.Pin": "pin_number_to_configure",
                "GPIO_InitStruct.Mode": "pin_mode",
                "GPIO_InitStruct.Speed": "pin_speed",
                "HAL_GPIO_Init": "initialize_GPIO_pin"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_GPIO_WritePin",
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005674": {
            "entrypoint": "0x08005674",
            "current_name": "infinite_loop_08005674",
            "code": "\nvoid infiniteLoop_08005674(char *filePtr,int lineNum)\n\n{\n  int localLine;\n  char *localFile;\n  \n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005674": "infinite_loop_08005674",
                "file": "filePtr",
                "line": "lineNum",
                "line_local": "localLine",
                "file_local": "localFile"
            },
            "calling": [
                "MX_TIM2_Init",
                "MX_USART1_UART_Init",
                "SystemClock_Config",
                "MX_TIM1_Init",
                "MX_I2C1_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005680": {
            "entrypoint": "0x08005680",
            "current_name": "initialize_tim_gpio_08005680",
            "code": "\nvoid initialize_TIM_gpio_08005680(TIM_HandleTypeDef *tim_handle)\n\n{\n  TIM_HandleTypeDef *local_tim_handle;\n  GPIO_InitTypeDef gpio_init_struct;\n  \n  if (tim_handle->Instance == (TIM_TypeDef *)0x40012c00) {\n    gpio_init_struct.Pin = 0x900;\n    gpio_init_struct.Mode = 2;\n    gpio_init_struct.Speed = 2;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40010800,&gpio_init_struct);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005680": "initialize_tim_gpio_08005680",
                "htim": "tim_handle",
                "htim_local": "local_tim_handle",
                "GPIO_InitStruct": "gpio_init_struct"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056bc": {
            "entrypoint": "0x080056bc",
            "current_name": "FUNC_080056bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080056bc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056bc": "FUNC_080056bc"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080056c8": {
            "entrypoint": "0x080056c8",
            "current_name": "infinite_loop_080056c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_080056c8(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080056c8": "infinite_loop_080056c8"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056ce": {
            "entrypoint": "0x080056ce",
            "current_name": "infinite_loop_080056ce",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_080056ce(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080056ce": "infinite_loop_080056ce"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056d4": {
            "entrypoint": "0x080056d4",
            "current_name": "endless_loop_080056d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid endlessLoop_080056d4(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080056d4": "endless_loop_080056d4"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056da": {
            "entrypoint": "0x080056da",
            "current_name": "infinite_loop_080056da",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_080056da(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080056da": "infinite_loop_080056da"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056e0": {
            "entrypoint": "0x080056e0",
            "current_name": "FUNC_080056e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080056e0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056e0": "FUNC_080056e0"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080056ec": {
            "entrypoint": "0x080056ec",
            "current_name": "FUNC_080056ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080056ec(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056ec": "FUNC_080056ec"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080056f8": {
            "entrypoint": "0x080056f8",
            "current_name": "FUNC_080056f8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080056f8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056f8": "FUNC_080056f8"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005704": {
            "entrypoint": "0x08005704",
            "current_name": "update_system_tick_08005704",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateSystemTick_08005704(void)\n\n{\n  incrementTick();\n  handleSysTickInterrupt();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005704": "update_system_tick_08005704",
                "HAL_IncTick": "incrementTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTickInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_IncTick",
                "HAL_SYSTICK_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "handle_tim2_irq_handler_08005714",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_TIM2_IRQHandler_08005714(void)\n\n{\n  HAL_TIM_IRQHandler(&timer2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005714": "handle_tim2_irq_handler_08005714",
                "&htim2": "&timer2"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005728": {
            "entrypoint": "0x08005728",
            "current_name": "allocate_memory_08005728",
            "code": "\nvoid * allocate_memory_08005728(intptr_t delta)\n\n{\n  undefined4 *error_ptr;\n  char *memory_ptr;\n  char buffer [4];\n  int increment;\n  char *previous_heap_end;\n  \n  if (_sbrk::heap_end == (char *)0x0) {\n    _sbrk::heap_end = &end;\n  }\n  previous_heap_end = _sbrk::heap_end;\n  if (buffer < _sbrk::heap_end + delta) {\n    increment = delta;\n    error_ptr = (undefined4 *)__errno();\n    *error_ptr = 0xc;\n    memory_ptr = (char *)0xffffffff;\n  }\n  else {\n    memory_ptr = _sbrk::heap_end;\n    _sbrk::heap_end = _sbrk::heap_end + delta;\n  }\n  return memory_ptr;\n}\n\n",
            "renaming": {
                "FUN_08005728": "allocate_memory_08005728",
                "__delta": "delta",
                "puVar1": "error_ptr",
                "pcVar2": "memory_ptr",
                "acStack_18": "buffer",
                "incr_local": "increment",
                "prev_heap_end": "previous_heap_end"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [
                "__errno"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005780": {
            "entrypoint": "0x08005780",
            "current_name": "initialize_memory_08005780",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeMemory_08005780(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005780": "initialize_memory_08005780"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057e8": {
            "entrypoint": "0x080057e8",
            "current_name": "initialize_system_080057e8",
            "code": "\nvoid initializeSystem_080057e8(void)\n\n{\n  int index;\n  undefined4 *ptr;\n  code *jumpTable;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &completed_8655; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&__fini_array_end + index);\n  }\n  for (ptr = &completed_8655; ptr < &_ebss; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x800581a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x0800581a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080057e8": "initialize_system_080057e8",
                "iVar1": "index",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "main",
                "__libc_init_array",
                "SystemInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005830": {
            "entrypoint": "0x08005830",
            "current_name": "infinite_loop_08005830",
            "code": "\nvoid infiniteLoop_08005830(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005830": "infinite_loop_08005830"
            },
            "calling": [
                "USBWakeUp_IRQHandler"
            ],
            "called": [
                "USBWakeUp_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005834": {
            "entrypoint": "0x08005834",
            "current_name": "FUN_08005834",
            "code": "\nvoid __ieee754_atan2(uint param_1,uint param_2,uint param_3,uint param_4,double param_5)\n\n{\n  int iVar1;\n  undefined4 unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  \n  uVar3 = param_4 & 0x7fffffff;\n  if (((uVar3 | (-param_3 | param_3) >> 0x1f) < 0x7ff00001) &&\n     (uVar4 = param_2 & 0x7fffffff, (uVar4 | (-param_1 | param_1) >> 0x1f) < 0x7ff00001)) {\n    if ((param_4 + 0xc0100000 | param_3) == 0) {\n      atan(param_5);\n      return;\n    }\n    uVar2 = (int)param_4 >> 0x1e & 2U | param_2 >> 0x1f;\n    if (((((uVar4 | param_1) != 0) && ((uVar3 | param_3) != 0)) && (uVar3 != 0x7ff00000)) &&\n       (uVar4 != 0x7ff00000)) {\n      iVar1 = (int)(uVar4 - uVar3) >> 0x14;\n      if ((iVar1 < 0x3d) && ((-1 < (int)param_4 || (iVar1 + 0x3c < 0 == SCARRY4(iVar1,0x3c))))) {\n        __divdf3(param_1,param_2);\n        fabs((double)CONCAT44(unaff_r4,param_4));\n        atan((double)CONCAT44(unaff_r4,param_4));\n      }\n      if (uVar2 != 1) {\n        if (uVar2 == 2) {\n          uVar5 = __subdf3();\n          __subdf3(0x54442d18,0x400921fb,(int)uVar5,(int)((ulonglong)uVar5 >> 0x20));\n        }\n        else if (uVar2 != 0) {\n          uVar5 = __subdf3();\n          __subdf3((int)uVar5,(int)((ulonglong)uVar5 >> 0x20),0x54442d18,0x400921fb);\n        }\n      }\n    }\n  }\n  else {\n    __aeabi_dadd(param_3,param_4,param_1,param_2);\n  }\n  return;\n}\n\n",
            "renaming": {},
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_calc_pitch"
            ],
            "called": [
                "__ieee754_atan2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005838": {
            "entrypoint": "0x08005838",
            "current_name": "calculate_arctan_08005838",
            "code": "\nvoid calculateArctan_08005838(uint x1,uint x2,uint y1,uint y2,double inputValue)\n\n{\n  int iVar1;\n  undefined4 tempVariable;\n  uint flag;\n  uint absoluteY;\n  uint absoluteX;\n  undefined8 result;\n  \n  absoluteY = y2 & 0x7fffffff;\n  if (((absoluteY | (-y1 | y1) >> 0x1f) < 0x7ff00001) &&\n     (absoluteX = x2 & 0x7fffffff, (absoluteX | (-x1 | x1) >> 0x1f) < 0x7ff00001)) {\n    if ((y2 + 0xc0100000 | y1) == 0) {\n      atan(inputValue);\n      return;\n    }\n    flag = (int)y2 >> 0x1e & 2U | x2 >> 0x1f;\n    if (((((absoluteX | x1) != 0) && ((absoluteY | y1) != 0)) && (absoluteY != 0x7ff00000)) &&\n       (absoluteX != 0x7ff00000)) {\n      iVar1 = (int)(absoluteX - absoluteY) >> 0x14;\n      if ((iVar1 < 0x3d) && ((-1 < (int)y2 || (iVar1 + 0x3c < 0 == SCARRY4(iVar1,0x3c))))) {\n        __divdf3(x1,x2);\n        fabs((double)CONCAT44(tempVariable,y2));\n        atan((double)CONCAT44(tempVariable,y2));\n      }\n      if (flag != 1) {\n        if (flag == 2) {\n          result = __subdf3();\n          __subdf3(0x54442d18,0x400921fb,(int)result,(int)((ulonglong)result >> 0x20));\n        }\n        else if (flag != 0) {\n          result = __subdf3();\n          __subdf3((int)result,(int)((ulonglong)result >> 0x20),0x54442d18,0x400921fb);\n        }\n      }\n    }\n  }\n  else {\n    __aeabi_dadd(y1,y2,x1,x2);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005838": "calculate_arctan_08005838",
                "param_1": "x1",
                "param_2": "x2",
                "param_3": "y1",
                "param_4": "y2",
                "param_5": "inputValue",
                "unaff_r4": "tempVariable",
                "uVar2": "flag",
                "uVar3": "absoluteY",
                "uVar4": "absoluteX",
                "uVar5": "result"
            },
            "calling": [
                "atan2"
            ],
            "called": [
                "fabs",
                "atan",
                "__aeabi_dadd",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f0": {
            "entrypoint": "0x080059f0",
            "current_name": "calculate_square_root_080059f0",
            "code": "\ndouble calculate_square_root_080059f0(double input_value)\n\n{\n  int temp_var_1;\n  undefined4 temp_var_2;\n  undefined4 temp_var_3;\n  uint temp_var_4;\n  undefined4 temp_var_5;\n  undefined4 temp_var_6;\n  undefined4 temp_var_7;\n  undefined4 temp_var_8;\n  undefined4 temp_var_9;\n  undefined4 temp_var_10;\n  undefined4 temp_var_11;\n  uint temp_var_12;\n  int loop_index;\n  double initial_result;\n  double final_result;\n  double temp_result_1;\n  undefined8 temp_result_2;\n  undefined8 temp_result_3;\n  \n  temp_result_2 = CONCAT44(temp_var_4,temp_var_1);\n  temp_var_12 = temp_var_4 & 0x7fffffff;\n  if (temp_var_12 < 0x44100000) {\n    if (temp_var_12 < 0x3fdc0000) {\n      if (temp_var_12 < 0x3e200000) {\n        temp_result_3 = __aeabi_dadd(temp_var_1,temp_var_4,0x8800759c,0x7e37e43c);\n        loop_index = __aeabi_dcmpgt((int)temp_result_3,(int)((ulonglong)temp_result_3 >> 0x20),0,0x3ff00000);\n        if (loop_index != 0) {\n          return temp_result_1;\n        }\n      }\n      loop_index = -1;\n    }\n    else {\n      fabs((double)CONCAT44(temp_var_9,temp_var_8));\n      if (temp_var_12 < 0x3ff30000) {\n        if (temp_var_12 < 0x3fe60000) {\n          temp_result_2 = __aeabi_dadd();\n          temp_result_2 = __subdf3((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),0,0x3ff00000);\n          temp_result_3 = __aeabi_dadd(temp_var_1,temp_var_7,0,0x40000000);\n          temp_result_2 = __divdf3((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),(int)temp_result_3,\n                            (int)((ulonglong)temp_result_3 >> 0x20));\n          loop_index = 0;\n        }\n        else {\n          temp_result_2 = __subdf3();\n          temp_result_3 = __aeabi_dadd(temp_var_1,temp_var_7,0,0x3ff00000);\n          temp_result_2 = __divdf3((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),(int)temp_result_3,\n                            (int)((ulonglong)temp_result_3 >> 0x20));\n          loop_index = 1;\n        }\n      }\n      else if (temp_var_12 < 0x40038000) {\n        temp_result_2 = __subdf3();\n        temp_result_3 = __muldf3(temp_var_1,temp_var_7,0,0x3ff80000);\n        temp_result_3 = __aeabi_dadd((int)temp_result_3,(int)((ulonglong)temp_result_3 >> 0x20),0,0x3ff00000);\n        temp_result_2 = __divdf3((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),(int)temp_result_3,\n                          (int)((ulonglong)temp_result_3 >> 0x20));\n        loop_index = 2;\n      }\n      else {\n        temp_result_2 = __divdf3(0,0xbff00000,temp_var_1,temp_var_7);\n        loop_index = 3;\n      }\n    }\n    temp_var_11 = (undefined4)((ulonglong)temp_result_2 >> 0x20);\n    temp_var_10 = (undefined4)temp_result_2;\n    temp_result_2 = __muldf3(temp_var_10,temp_var_11,temp_var_10,temp_var_11);\n    temp_var_5 = (undefined4)((ulonglong)temp_result_2 >> 0x20);\n    temp_var_2 = (undefined4)temp_result_2;\n    temp_result_2 = __muldf3(temp_var_2,temp_var_5,temp_var_2,temp_var_5);\n    temp_var_6 = (undefined4)((ulonglong)temp_result_2 >> 0x20);\n    temp_var_3 = (undefined4)temp_result_2;\n    temp_result_2 = __muldf3(temp_var_3,temp_var_6,0xe322da11,0x3f90ad3a);\n    temp_result_2 = __aeabi_dadd((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),0x24760deb,0x3fa97b4b);\n    temp_result_2 = __muldf3((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),temp_var_3,temp_var_6);\n    temp_result_2 = __aeabi_dadd((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),0xa0d03d51,0x3fb10d66);\n    temp_result_2 = __muldf3((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),temp_var_3,temp_var_6);\n    temp_result_2 = __aeabi_dadd((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),0xc54c206e,0x3fb745cd);\n    temp_result_2 = __muldf3((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),temp_var_3,temp_var_6);\n    temp_result_2 = __aeabi_dadd((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),0x920083ff,0x3fc24924);\n    temp_result_2 = __muldf3((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),temp_var_3,temp_var_6);\n    temp_result_2 = __aeabi_dadd((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),0x5555550d,0x3fd55555);\n    temp_result_2 = __muldf3((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),temp_var_2,temp_var_5);\n    temp_result_3 = __muldf3(temp_var_3,temp_var_6,0x2c6a6c2f,0xbfa2b444);\n    temp_result_3 = __subdf3((int)temp_result_3,(int)((ulonglong)temp_result_3 >> 0x20),0x52defd9a,0x3fadde2d);\n    temp_result_3 = __muldf3((int)temp_result_3,(int)((ulonglong)temp_result_3 >> 0x20),temp_var_3,temp_var_6);\n    temp_result_3 = __subdf3((int)temp_result_3,(int)((ulonglong)temp_result_3 >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    temp_result_3 = __muldf3((int)temp_result_3,(int)((ulonglong)temp_result_3 >> 0x20),temp_var_3,temp_var_6);\n    temp_result_3 = __subdf3((int)temp_result_3,(int)((ulonglong)temp_result_3 >> 0x20),0xfe231671,0x3fbc71c6);\n    temp_result_3 = __muldf3((int)temp_result_3,(int)((ulonglong)temp_result_3 >> 0x20),temp_var_3,temp_var_6);\n    temp_result_3 = __subdf3((int)temp_result_3,(int)((ulonglong)temp_result_3 >> 0x20),0x9998ebc4,0x3fc99999);\n    temp_result_3 = __muldf3((int)temp_result_3,(int)((ulonglong)temp_result_3 >> 0x20),temp_var_3,temp_var_6);\n    temp_result_2 = __aeabi_dadd((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),(int)temp_result_3,\n                          (int)((ulonglong)temp_result_3 >> 0x20));\n    temp_result_2 = __muldf3((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),temp_var_10,temp_var_11);\n    temp_var_2 = (undefined4)((ulonglong)temp_result_2 >> 0x20);\n    if (loop_index == -1) {\n      final_result = (double)__subdf3(temp_var_10,temp_var_11,(int)temp_result_2,temp_var_2);\n      return final_result;\n    }\n    loop_index = loop_index * 8;\n    temp_result_2 = __subdf3((int)temp_result_2,temp_var_2,*(undefined4 *)(&atanlo + loop_index),\n                      *(undefined4 *)(&UNK_08009eec + loop_index));\n    temp_result_2 = __subdf3((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),temp_var_10,temp_var_11);\n    final_result = (double)__subdf3(*(undefined4 *)(&atanhi + loop_index),*(undefined4 *)(&UNK_08009ecc + loop_index)\n                             ,(int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20));\n    if ((int)temp_var_4 < 0) {\n      return final_result;\n    }\n  }\n  else {\n    if ((temp_var_12 < 0x7ff00001) && ((temp_var_12 != 0x7ff00000 || (temp_var_1 == 0)))) {\n      return initial_result;\n    }\n    final_result = (double)__aeabi_dadd();\n  }\n  return final_result;\n}\n\n",
            "renaming": {
                "FUN_080059f0": "calculate_square_root_080059f0",
                "__x": "input_value",
                "in_r0": "temp_var_1",
                "uVar1": "temp_var_2",
                "uVar2": "temp_var_3",
                "in_r1": "temp_var_4",
                "uVar3": "temp_var_5",
                "uVar4": "temp_var_6",
                "extraout_r1": "temp_var_7",
                "in_r3": "temp_var_8",
                "unaff_r4": "temp_var_9",
                "uVar5": "temp_var_10",
                "uVar6": "temp_var_11",
                "uVar7": "temp_var_12",
                "iVar8": "loop_index",
                "in_d0": "initial_result",
                "dVar9": "final_result",
                "extraout_d0": "temp_result_1",
                "uVar10": "temp_result_2",
                "uVar11": "temp_result_3"
            },
            "calling": [
                "__ieee754_atan2"
            ],
            "called": [
                "__aeabi_dcmpgt",
                "fabs",
                "__aeabi_dadd",
                "__muldf3",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d0c": {
            "entrypoint": "0x08005d0c",
            "current_name": "calculate_square_08005d0c",
            "code": "\ndouble calculate_square_08005d0c(double input_value)\n\n{\n  double result;\n  \n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005d0c": "calculate_square_08005d0c",
                "__x": "input_value",
                "in_d0": "result"
            },
            "calling": [
                "atan",
                "__ieee754_atan2"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d14": {
            "entrypoint": "0x08005d14",
            "current_name": "get_impure_pointer_08005d14",
            "code": "\nundefined4 getImpurePointer_08005d14(void)\n\n{\n  return impurePtr;\n}\n\n",
            "renaming": {
                "FUN_08005d14": "get_impure_pointer_08005d14",
                "_impure_ptr": "impurePtr"
            },
            "calling": [
                "_sbrk"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d20": {
            "entrypoint": "0x08005d20",
            "current_name": "initialize_preinit_array_08005d20",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005d2c) */\n/* WARNING: Removing unreachable block (ram,0x08005d2e) */\n\nvoid initializePreinitArray_08005d20(EVP_PKEY_CTX *pkeyContext)\n\n{\n  int iterationCounter;\n  code **functionPointerArray;\n  \n  _init(pkeyContext);\n  iterationCounter = 0;\n  functionPointerArray = (code **)&__preinit_array_end;\n  do {\n    iterationCounter = iterationCounter + 1;\n    (**functionPointerArray)();\n    functionPointerArray = functionPointerArray + 1;\n  } while (iterationCounter != 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d20": "initialize_preinit_array_08005d20",
                "param_1": "pkeyContext",
                "iVar1": "iterationCounter",
                "ppcVar2": "functionPointerArray"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "_init",
                "register_fini",
                "frame_dummy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d68": {
            "entrypoint": "0x08005d68",
            "current_name": "memset_bytes_08005d68",
            "code": "\nvoid * memset_bytes_08005d68(void *buffer,int value,size_t length)\n\n{\n  uint *dst;\n  uint *src;\n  uint *next;\n  uint remaining;\n  uint pattern;\n  bool is_done;\n  \n  src = (uint *)buffer;\n  if (((uint)buffer & 3) != 0) {\n    remaining = length - 1;\n    dst = (uint *)buffer;\n    if (length == 0) {\n      return buffer;\n    }\n    while( true ) {\n      src = (uint *)((int)dst + 1);\n      *(char *)dst = (char)value;\n      length = remaining;\n      if (((uint)src & 3) == 0) break;\n      is_done = remaining == 0;\n      remaining = remaining - 1;\n      dst = src;\n      if (is_done) {\n        return buffer;\n      }\n    }\n  }\n  if (3 < length) {\n    pattern = value & 0xffU | (value & 0xffU) << 8;\n    pattern = pattern | pattern << 0x10;\n    remaining = length;\n    dst = src;\n    if (0xf < length) {\n      remaining = length - 0x10;\n      dst = src + 4;\n      do {\n        dst[-4] = pattern;\n        dst[-3] = pattern;\n        dst[-2] = pattern;\n        dst[-1] = pattern;\n        dst = dst + 4;\n      } while (dst != (uint *)((int)src + (remaining & 0xfffffff0) + 0x20));\n      length = length & 0xf;\n      src = src + ((remaining >> 4) + 1) * 4;\n      remaining = length;\n      dst = src;\n      if (length < 4) goto LAB_08005de4;\n    }\n    do {\n      length = length - 4;\n      *src = pattern;\n      src = src + 1;\n    } while (3 < length);\n    src = (uint *)((int)dst + (remaining - 4 & 0xfffffffc) + 4);\n    length = remaining & 3;\n  }\nLAB_08005de4:\n  if (length != 0) {\n    dst = src;\n    do {\n      next = (uint *)((int)dst + 1);\n      *(char *)dst = (char)value;\n      dst = next;\n    } while ((uint *)(length + (int)src) != next);\n  }\n  return buffer;\n}\n\n",
            "renaming": {
                "FUN_08005d68": "memset_bytes_08005d68",
                "__s": "buffer",
                "__c": "value",
                "__n": "length",
                "puVar1": "dst",
                "puVar2": "src",
                "puVar3": "next",
                "uVar4": "remaining",
                "uVar5": "pattern",
                "bVar6": "is_done"
            },
            "calling": [
                "flush_strbuf",
                "_calloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005dfc": {
            "entrypoint": "0x08005dfc",
            "current_name": "format_and_print_08005dfc",
            "code": "\nint formatAndPrint_08005dfc(char *outputString,char *formatString,...)\n\n{\n  int result;\n  undefined4 param1;\n  undefined4 param2;\n  char *stringArray [2];\n  undefined4 maxStringLength;\n  undefined4 constantValue;\n  char *currentString;\n  undefined4 maxArraySize;\n  undefined4 stackParam1;\n  undefined4 stackParam2;\n  \n  maxArraySize = 0x7fffffff;\n  maxStringLength = 0x7fffffff;\n  constantValue = 0xffff0208;\n  stringArray[0] = outputString;\n  currentString = outputString;\n  stackParam1 = param1;\n  stackParam2 = param2;\n  result = _svfprintf_r(_impure_ptr,stringArray,formatString,&stackParam1);\n  *stringArray[0] = '\\0';\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005dfc": "format_and_print_08005dfc",
                "__s": "outputString",
                "__format": "formatString",
                "iVar1": "result",
                "in_r2": "param1",
                "in_r3": "param2",
                "local_80": "stringArray",
                "local_78": "maxStringLength",
                "uStack_74": "constantValue",
                "local_70": "currentString",
                "local_6c": "maxArraySize",
                "uStack_8": "stackParam1",
                "uStack_4": "stackParam2"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "_svfprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e40": {
            "entrypoint": "0x08005e40",
            "current_name": "calculate_string_length_08005e40",
            "code": "\nsize_t calculate_string_length_08005e40(char *input_string)\n\n{\n  int alignment_offset;\n  uint *aligned_pointer;\n  uint current_word;\n  \n  aligned_pointer = (uint *)((uint)input_string & 0xfffffffc);\n  alignment_offset = -((uint)input_string & 3);\n  current_word = *aligned_pointer;\n  if (((uint)input_string & 3) != 0) {\n    current_word = current_word | 0xffffffffU >> ((alignment_offset + 4U & 0x1f) << 3);\n  }\n  while( true ) {\n    aligned_pointer = aligned_pointer + 1;\n    current_word = current_word + 0xfefefeff & ~current_word & 0x80808080;\n    if (current_word != 0) break;\n    current_word = *aligned_pointer;\n    alignment_offset = alignment_offset + 4;\n  }\n  return alignment_offset + (0x1fU - leading_zero_count(current_word & -current_word) >> 3);\n}\n\n",
            "renaming": {
                "FUN_08005e40": "calculate_string_length_08005e40",
                "__s": "input_string",
                "iVar1": "alignment_offset",
                "puVar2": "aligned_pointer",
                "uVar3": "current_word",
                "LZCOUNT": "leading_zero_count"
            },
            "calling": [
                "_svfprintf_r",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e9c": {
            "entrypoint": "0x08005e9c",
            "current_name": "FUNC_08005e9c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nbyte * FUNC_08005e9c(undefined4 *param_1,int *param_2,int *param_3,int **param_4)\n\n{\n  byte bVar1;\n  int **ppiVar2;\n  int *piVar3;\n  int iVar4;\n  void *pvVar5;\n  int iVar6;\n  undefined4 uVar7;\n  undefined4 uVar8;\n  byte *pbVar9;\n  char cVar10;\n  byte bVar11;\n  int *piVar12;\n  int **ppiVar13;\n  undefined uVar14;\n  ushort uVar15;\n  int *__s;\n  int **ppiVar16;\n  byte **ppbVar17;\n  int *piVar18;\n  int *piVar19;\n  int **ppiVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *pbVar23;\n  int *piVar24;\n  uint uVar25;\n  uint uVar26;\n  int *piVar27;\n  int *piVar28;\n  byte *pbVar29;\n  bool bVar30;\n  longlong lVar31;\n  undefined8 uVar32;\n  undefined8 uVar33;\n  undefined4 in_stack_fffffe78;\n  int *in_stack_fffffe7c;\n  int *local_168;\n  byte *local_164;\n  int *local_15c;\n  char *local_158;\n  int **local_154;\n  int *local_150;\n  int *local_148;\n  int local_144;\n  uint local_140;\n  int local_13c;\n  int *local_138;\n  int *local_134;\n  int local_130;\n  int *local_12c;\n  int *local_128;\n  char *local_11c;\n  int *local_110;\n  int *local_10c;\n  byte *local_108;\n  int *local_104;\n  byte local_f5;\n  undefined2 local_f4;\n  int *local_f0 [2];\n  undefined4 local_e8;\n  int *local_e0;\n  byte abStack_dc [4];\n  int **local_d8;\n  int local_d4;\n  byte *local_d0;\n  int *local_cc [16];\n  undefined local_8c;\n  byte bStack_2a;\n  undefined local_29;\n  int iStack_28;\n  \n  ppiVar2 = (int **)_localeconv_r();\n  __s = *ppiVar2;\n  piVar3 = (int *)strlen((char *)__s);\n  if (((int)((uint)*(ushort *)(param_2 + 3) << 0x18) < 0) && (param_2[4] == 0)) {\n    iVar4 = _malloc_r(param_1,0x40);\n    *param_2 = iVar4;\n    param_2[4] = iVar4;\n    if (iVar4 == 0) {\n      *param_1 = 0xc;\n      return (byte *)0xffffffff;\n    }\n    param_2[5] = 0x40;\n  }\n  local_128 = (int *)0x0;\n  local_138 = (int *)0x0;\n  local_12c = (int *)0x0;\n  local_d4 = 0;\n  local_d0 = (byte *)0x0;\n  local_11c = (char *)0x0;\n  local_10c = (int *)0x0;\n  local_108 = (byte *)0x0;\n  local_104 = (int *)0x0;\n  local_110 = (int *)0x0;\n  local_164 = (byte *)0x0;\n  ppiVar2 = local_cc;\n  bVar1 = *(byte *)param_3;\n  local_d8 = ppiVar2;\n  local_154 = param_4;\njoined_r0x08005ef2:\n  if (bVar1 != 0) {\n    piVar28 = param_3;\n    if (bVar1 != 0x25) {\n      do {\n        piVar28 = (int *)((int)piVar28 + 1);\n        if (*(byte *)piVar28 == 0) break;\n      } while (*(byte *)piVar28 != 0x25);\n      piVar27 = (int *)((int)piVar28 - (int)param_3);\n      if (piVar27 != (int *)0x0) {\n        local_d4 = local_d4 + 1;\n        local_d0 = (byte *)((int)local_d0 + (int)piVar27);\n        *ppiVar2 = param_3;\n        *(int **)((int)ppiVar2 + 4) = piVar27;\n        if (local_d4 < 8) {\n          ppiVar2 = (int **)((int)ppiVar2 + 8);\n        }\n        else {\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800604a;\n          ppiVar2 = local_cc;\n        }\n        local_164 = (byte *)((int)local_164 + (int)piVar27);\n      }\n      if (*(byte *)piVar28 == 0) goto LAB_08006216;\n    }\n    piVar27 = (int *)0xffffffff;\n    uVar26 = 0;\n    uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n    local_15c = (int *)0x0;\n    local_f5 = 0;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4a:\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4e:\n    local_158 = (char *)piVar27;\n    switch(uVar25) {\n    case 0x20:\n      goto switchD_08005f58_caseD_20;\n    default:\n      if (uVar25 == 0) goto LAB_08006216;\n      piVar18 = (int *)0x0;\n      local_168 = (int *)0x1;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      local_13c = 0;\n      local_134 = (int *)0x0;\n      local_130 = 0;\n      local_158 = (char *)0x1;\n      param_3 = (int *)&local_8c;\n      piVar24 = piVar18;\n      local_8c = (char)uVar25;\n      goto LAB_08006298;\n    case 0x23:\n      uVar26 = uVar26 | 1;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x27:\n      iVar4 = _localeconv_r(param_1);\n      local_110 = *(int **)(iVar4 + 4);\n      local_104 = (int *)strlen((char *)local_110);\n      iVar4 = _localeconv_r(param_1);\n      local_108 = *(byte **)(iVar4 + 8);\n      if (local_104 == (int *)0x0) goto switchD_08005f58_caseD_74;\n      uVar25 = (uint)*(byte *)piVar28;\n      if ((local_108 != (byte *)0x0) && (*local_108 != 0)) {\n        uVar26 = uVar26 | 0x400;\n      }\n      goto LAB_08005f4a;\n    case 0x2a:\n      uVar25 = (uint)*(byte *)piVar28;\n      local_15c = *local_154;\n      local_154 = local_154 + 1;\n      if ((int)local_15c < 0) {\n        local_15c = (int *)-(int)local_15c;\n        goto LAB_08006602;\n      }\n      goto LAB_08005f4a;\n    case 0x2b:\n      local_f5 = 0x2b;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x2d:\n      uVar25 = (uint)*(byte *)piVar28;\nLAB_08006602:\n      uVar26 = uVar26 | 4;\n      goto LAB_08005f4a;\n    case 0x2e:\n      uVar25 = (uint)*(byte *)piVar28;\n      if (uVar25 == 0x2a) {\n        uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n        piVar27 = (int *)((uint)*local_154 | (int)*local_154 >> 0x1f);\n        local_154 = local_154 + 1;\n        piVar28 = (int *)((int)piVar28 + 1);\n        goto LAB_08005f4a;\n      }\n      piVar27 = (int *)0x0;\n      piVar28 = (int *)((int)piVar28 + 1);\n      while (uVar25 - 0x30 < 10) {\n        piVar27 = (int *)((uVar25 - 0x30) + (int)piVar27 * 10);\n        uVar25 = (uint)*(byte *)piVar28;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      goto LAB_08005f4e;\n    case 0x30:\n      uVar26 = uVar26 | 0x80;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n      goto switchD_08005f58_caseD_31;\n    case 0x41:\n    case 0x45:\n    case 0x46:\n    case 0x47:\n    case 0x61:\n    case 0x65:\n    case 0x66:\n    case 0x67:\n      local_154 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      local_128 = *local_154;\n      local_12c = local_154[1];\n      local_154 = local_154 + 2;\n      iVar4 = __unorddf2(local_128,(uint)local_12c & 0x7fffffff,0xffffffff,0x7fefffff);\n      if ((iVar4 == 0) &&\n         (iVar4 = __aeabi_dcmple(local_128,(uint)local_12c & 0x7fffffff,0xffffffff,0x7fefffff),\n         iVar4 == 0)) {\n        iVar4 = __aeabi_dcmplt(local_128,local_12c,0,0);\n        if (iVar4 == 0) {\n          piVar18 = (int *)(uint)local_f5;\n        }\n        else {\n          piVar18 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        param_3 = (int *)&UNK_08009f10;\n        piVar27 = (int *)&UNK_08009f0c;\nLAB_08006524:\n        local_148 = (int *)0x0;\n        local_168 = (int *)0x3;\n        if (uVar25 < 0x48) {\n          param_3 = piVar27;\n        }\n        local_134 = (int *)0x0;\n        local_130 = 0;\n        local_140 = uVar26 & 0xffffff7f;\n        local_158 = (char *)0x3;\n        local_13c = 0;\n        piVar24 = (int *)0x0;\n        goto LAB_08006538;\n      }\n      iVar4 = __unorddf2(local_128,local_12c,local_128,local_12c);\n      if (iVar4 != 0) {\n        if ((int)local_12c < 0) {\n          piVar18 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        else {\n          piVar18 = (int *)(uint)local_f5;\n        }\n        param_3 = (int *)&UNK_08009f18;\n        piVar27 = (int *)&UNK_08009f14;\n        goto LAB_08006524;\n      }\n      piVar24 = local_12c;\n      if (uVar25 == 0x61) {\n        uVar14 = 0x78;\nLAB_08007224:\n        local_f4 = CONCAT11(uVar14,0x30);\n        if ((int)piVar27 < 100) {\n          local_140 = uVar26 | 0x102;\n          local_148 = (int *)0x0;\n          param_3 = (int *)&local_8c;\n          uVar26 = uVar26 | 2;\n        }\n        else {\n          param_3 = (int *)_malloc_r(param_1,(byte *)((int)piVar27 + 1));\n          if (param_3 == (int *)0x0) {\n            uVar15 = *(ushort *)(param_2 + 3) | 0x40;\n            *(ushort *)(param_2 + 3) = uVar15;\n            goto LAB_0800604e;\n          }\n          local_140 = uVar26 | 0x102;\n          uVar26 = uVar26 | 2;\n          local_148 = param_3;\n        }\nLAB_0800724a:\n        if ((int)local_12c < 0) {\nLAB_08007414:\n          local_144 = 0x2d;\n          piVar24 = local_12c + -0x20000000;\n        }\n        else {\n          local_144 = 0;\n        }\n        if (uVar25 == 0x61) {\n          frexp((double)CONCAT44(in_stack_fffffe7c,in_stack_fffffe78),local_128);\n          uVar32 = __muldf3();\n          iVar4 = __aeabi_dcmpeq((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),0,0);\n          if (iVar4 != 0) {\n            local_f0[0] = (int *)0x1;\n          }\n          local_158 = \"0123456789abcdef\";\n          local_138 = param_3;\n          piVar24 = piVar27;\n          goto LAB_080072ba;\n        }\n        if (uVar25 == 0x41) {\n          frexp((double)CONCAT44(in_stack_fffffe7c,in_stack_fffffe78),local_128);\n          uVar32 = __muldf3();\n          iVar4 = __aeabi_dcmpeq((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),0,0);\n          if (iVar4 == 0) {\n            local_158 = \"0123456789ABCDEF\";\n            local_138 = param_3;\n            piVar24 = piVar27;\n          }\n          else {\n            local_f0[0] = (int *)0x1;\n            local_158 = \"0123456789ABCDEF\";\n            local_138 = param_3;\n            piVar24 = piVar27;\n          }\n          goto LAB_080072ba;\n        }\n      }\n      else {\n        if (uVar25 == 0x41) {\n          uVar14 = 0x58;\n          goto LAB_08007224;\n        }\n        local_140 = uVar26 | 0x100;\n        local_148 = (int *)0x0;\n        if (piVar27 == (int *)0xffffffff) {\n          piVar27 = (int *)0x6;\n          goto LAB_0800724a;\n        }\n        if ((uVar25 & 0xffffffdf) == 0x47) {\n          if (piVar27 == (int *)0x0) {\n            piVar27 = (int *)0x1;\n            local_148 = (int *)0x0;\n          }\n          goto LAB_0800724a;\n        }\n        if ((int)local_12c < 0) goto LAB_08007414;\n        local_144 = 0;\n      }\n      local_168 = (int *)(uVar25 & 0xffffffdf);\n      in_stack_fffffe7c = piVar27;\n      local_150 = piVar27;\n      if (uVar25 == 0x66) {\n        in_stack_fffffe78 = 3;\n        param_3 = (int *)_dtoa_r(param_1,local_f0,local_128,piVar24);\n        piVar18 = (int *)((int)param_3 + (int)piVar27);\nLAB_0800764c:\n        if ((*(byte *)param_3 == 0x30) &&\n           (iVar4 = __aeabi_dcmpeq(local_128,piVar24,0,0), iVar4 == 0)) {\n          local_f0[0] = (int *)(1 - (int)local_150);\n        }\n        piVar18 = (int *)((int)piVar18 + (int)local_f0[0]);\n      }\n      else if (uVar25 == 0x46) {\n        in_stack_fffffe78 = 3;\n        param_3 = (int *)_dtoa_r(param_1,local_f0,local_128,piVar24);\nLAB_08007760:\n        piVar18 = (int *)((int)param_3 + (int)local_150);\n        if (uVar25 == 0x46) goto LAB_0800764c;\n      }\n      else {\n        if (local_168 == (int *)0x45) {\n          local_150 = (int *)((int)piVar27 + 1);\n        }\n        in_stack_fffffe78 = 2;\n        in_stack_fffffe7c = local_150;\n        param_3 = (int *)_dtoa_r(param_1,local_f0,local_128,piVar24);\n        local_138 = local_e0;\n        if (uVar25 == 0x67) {\n          if ((uVar26 & 1) == 0) goto LAB_08006ca6;\n        }\n        else if (uVar25 == 0x47) {\n          if ((uVar26 & 1) != 0) goto LAB_08007760;\n          goto LAB_08006ca6;\n        }\n        piVar18 = (int *)((int)local_150 + (int)param_3);\n      }\n      iVar4 = __aeabi_dcmpeq(local_128,piVar24,0,0);\n      local_138 = piVar18;\n      if (iVar4 == 0) {\n        for (; local_138 = local_e0, local_e0 < piVar18; local_e0 = (int *)((int)local_e0 + 1)) {\n          *(byte *)local_e0 = 0x30;\n        }\n      }\nLAB_08006ca6:\n      local_138 = (int *)((int)local_138 - (int)param_3);\n      goto LAB_08006cb0;\n    case 0x43:\n    case 99:\n      piVar18 = (int *)0x0;\n      piVar27 = *local_154;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      piVar24 = (int *)0x0;\n      local_13c = 0;\n      local_134 = (int *)0x0;\n      local_130 = 0;\n      local_154 = local_154 + 1;\n      local_168 = (int *)0x1;\n      local_158 = (char *)0x1;\n      local_8c = SUB41(piVar27,0);\n      param_3 = (int *)&local_8c;\n      goto LAB_08006298;\n    case 0x44:\n      uVar26 = uVar26 | 0x10;\n      if ((int)(uVar26 << 0x1a) < 0) goto LAB_080060ec;\nLAB_080065a8:\n      ppiVar16 = local_154 + 1;\n      if ((int)(uVar26 << 0x1b) < 0) {\nLAB_08006bcc:\n        piVar24 = *local_154;\n        piVar18 = (int *)((int)piVar24 >> 0x1f);\n        local_154 = ppiVar16;\n      }\n      else if ((int)(uVar26 << 0x19) < 0) {\n        piVar24 = (int *)(int)*(short *)local_154;\n        piVar18 = (int *)((int)piVar24 >> 0x1f);\n        local_154 = ppiVar16;\n      }\n      else {\n        if (-1 < (int)(uVar26 << 0x16)) goto LAB_08006bcc;\n        piVar24 = (int *)(int)*(char *)local_154;\n        piVar18 = (int *)((int)piVar24 >> 0x1f);\n        local_154 = ppiVar16;\n      }\n      goto LAB_08006102;\n    case 0x4c:\n      uVar26 = uVar26 | 8;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x4f:\n      uVar26 = uVar26 | 0x10;\n    case 0x6f:\n      if ((uVar26 & 0x20) == 0) {\n        ppiVar16 = local_154 + 1;\n        if ((uVar26 & 0x10) == 0) {\n          if ((uVar26 & 0x40) == 0) {\n            if ((uVar26 & 0x200) == 0) goto LAB_08006be2;\n            piVar24 = (int *)(uint)*(byte *)local_154;\n            piVar18 = (int *)0x0;\n            local_154 = ppiVar16;\n          }\n          else {\n            piVar24 = (int *)(uint)*(ushort *)local_154;\n            piVar18 = (int *)0x0;\n            local_154 = ppiVar16;\n          }\n        }\n        else {\nLAB_08006be2:\n          piVar24 = *local_154;\n          piVar18 = (int *)0x0;\n          local_154 = ppiVar16;\n        }\n      }\n      else {\n        ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n        piVar24 = *ppiVar16;\n        piVar18 = ppiVar16[1];\n        local_154 = ppiVar16 + 2;\n      }\n      iVar4 = 0;\n      uVar26 = uVar26 & 0xfffffbff;\n      break;\n    case 0x53:\n    case 0x73:\n      local_f5 = 0;\n      param_3 = *local_154;\n      local_154 = local_154 + 1;\n      local_140 = uVar26;\n      if (param_3 == (int *)0x0) {\n        if ((int *)0x5 < piVar27) {\n          piVar27 = (int *)0x6;\n        }\n        param_3 = (int *)&UNK_08009f44;\n        piVar18 = (int *)0x0;\n        local_148 = (int *)0x0;\n        local_13c = 0;\n        local_134 = (int *)0x0;\n        local_130 = 0;\n        piVar24 = (int *)0x0;\n        local_168 = piVar27;\n        local_158 = (char *)piVar27;\n      }\n      else {\n        if (piVar27 == (int *)0xffffffff) {\n          local_158 = (char *)strlen((char *)param_3);\n        }\n        else {\n          pvVar5 = memchr(param_3,0,(size_t)piVar27);\n          if (pvVar5 == (void *)0x0) {\n            piVar18 = (int *)(uint)local_f5;\n            local_148 = (int *)0x0;\n            local_13c = 0;\n            local_134 = (int *)0x0;\n            local_130 = 0;\n            piVar24 = (int *)0x0;\n            local_168 = piVar27;\n            goto LAB_08006538;\n          }\n          local_158 = (char *)((int)pvVar5 - (int)param_3);\n        }\n        local_148 = (int *)0x0;\n        local_13c = 0;\n        local_134 = (int *)0x0;\n        local_130 = 0;\n        piVar18 = (int *)(uint)local_f5;\n        piVar24 = (int *)0x0;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_08006538;\n    case 0x55:\n      uVar26 = uVar26 | 0x10;\n      if ((int)(uVar26 << 0x1a) < 0) goto LAB_0800618a;\nLAB_080066c0:\n      ppiVar16 = local_154 + 1;\n      if ((int)(uVar26 << 0x1b) < 0) {\nLAB_08006bf2:\n        piVar24 = *local_154;\n        piVar18 = (int *)0x0;\n        iVar4 = 1;\n        local_154 = ppiVar16;\n      }\n      else if ((int)(uVar26 << 0x19) < 0) {\n        piVar24 = (int *)(uint)*(ushort *)local_154;\n        piVar18 = (int *)0x0;\n        iVar4 = 1;\n        local_154 = ppiVar16;\n      }\n      else {\n        if (-1 < (int)(uVar26 << 0x16)) goto LAB_08006bf2;\n        piVar24 = (int *)(uint)*(byte *)local_154;\n        piVar18 = (int *)0x0;\n        iVar4 = 1;\n        local_154 = ppiVar16;\n      }\n      break;\n    case 0x58:\n      local_11c = \"0123456789ABCDEF\";\n      if ((uVar26 & 0x20) != 0) goto LAB_080061ac;\nLAB_08006696:\n      ppiVar16 = local_154 + 1;\n      if ((uVar26 & 0x10) == 0) {\n        if ((uVar26 & 0x40) == 0) {\n          if ((uVar26 & 0x200) == 0) goto LAB_08006bbc;\n          piVar24 = (int *)(uint)*(byte *)local_154;\n          piVar18 = (int *)0x0;\n          local_154 = ppiVar16;\n        }\n        else {\n          piVar24 = (int *)(uint)*(ushort *)local_154;\n          piVar18 = (int *)0x0;\n          local_154 = ppiVar16;\n        }\n      }\n      else {\nLAB_08006bbc:\n        piVar24 = *local_154;\n        piVar18 = (int *)0x0;\n        local_154 = ppiVar16;\n      }\n      goto LAB_080061be;\n    case 100:\n    case 0x69:\n      if (-1 < (int)(uVar26 << 0x1a)) goto LAB_080065a8;\nLAB_080060ec:\n      ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar24 = *ppiVar16;\n      piVar18 = ppiVar16[1];\n      local_154 = ppiVar16 + 2;\nLAB_08006102:\n      if ((int)piVar18 < 0) {\n        bVar30 = piVar24 != (int *)0x0;\n        piVar24 = (int *)-(int)piVar24;\n        piVar18 = (int *)(-(int)piVar18 - (uint)bVar30);\n        local_f5 = 0x2d;\n      }\n      if (piVar27 != (int *)0xffffffff) {\n        iVar4 = 1;\n        iVar6 = 1;\n        local_140 = uVar26 & 0xffffff7f;\n        if (((uint)piVar24 | (uint)piVar18) == 0) goto LAB_080060a4;\n        goto LAB_08006130;\n      }\n      local_140 = uVar26;\n      if (piVar18 != (int *)0x0 || (int *)0x9 < piVar24) goto LAB_08006f16;\n      goto LAB_0800698a;\n    case 0x68:\n      uVar25 = (uint)*(byte *)piVar28;\n      if (uVar25 == 0x68) {\n        uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n        uVar26 = uVar26 | 0x200;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      else {\n        uVar26 = uVar26 | 0x40;\n      }\n      goto LAB_08005f4a;\n    case 0x6a:\n    case 0x71:\n      uVar26 = uVar26 | 0x20;\n    case 0x74:\n    case 0x7a:\nswitchD_08005f58_caseD_74:\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x6c:\n      goto switchD_08005f58_caseD_6c;\n    case 0x6e:\n      ppiVar16 = local_154 + 1;\n      ppbVar17 = (byte **)*local_154;\n      local_154 = ppiVar16;\n      if ((uVar26 & 0x20) != 0) {\n        *ppbVar17 = local_164;\n        ppbVar17[1] = (byte *)((int)local_164 >> 0x1f);\n        goto LAB_0800620e;\n      }\n      if ((uVar26 & 0x10) == 0) {\n        if ((uVar26 & 0x40) != 0) {\n          *(short *)ppbVar17 = (short)local_164;\n          goto LAB_0800620e;\n        }\n        if ((uVar26 & 0x200) != 0) {\n          *(char *)ppbVar17 = (char)local_164;\n          goto LAB_0800620e;\n        }\n      }\n      *ppbVar17 = local_164;\n      goto LAB_0800620e;\n    case 0x70:\n      local_f4 = 0x7830;\n      piVar24 = *local_154;\n      local_11c = \"0123456789abcdef\";\n      uVar26 = uVar26 | 2;\n      piVar18 = (int *)0x0;\n      iVar4 = 2;\n      uVar25 = 0x78;\n      local_154 = local_154 + 1;\n      break;\n    case 0x75:\n      if (-1 < (int)(uVar26 << 0x1a)) goto LAB_080066c0;\nLAB_0800618a:\n      ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar24 = *ppiVar16;\n      piVar18 = ppiVar16[1];\n      iVar4 = 1;\n      local_154 = ppiVar16 + 2;\n      break;\n    case 0x78:\n      local_11c = \"0123456789abcdef\";\n      if ((uVar26 & 0x20) == 0) goto LAB_08006696;\nLAB_080061ac:\n      ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar24 = *ppiVar16;\n      piVar18 = ppiVar16[1];\n      local_154 = ppiVar16 + 2;\nLAB_080061be:\n      if (((uVar26 & 1) != 0) && (((uint)piVar24 | (uint)piVar18) != 0)) {\n        uVar26 = uVar26 | 2;\n        local_f4 = CONCAT11((char)uVar25,0x30);\n      }\n      iVar4 = 2;\n      uVar26 = uVar26 & 0xfffffbff;\n    }\n    local_f5 = 0;\n    if (piVar27 == (int *)0xffffffff) {\n      local_140 = uVar26;\n      if (iVar4 != 1) goto LAB_08006136;\nLAB_08006980:\n      local_140 = uVar26;\n      if (piVar18 == (int *)0x0 && piVar24 < (int *)0xa) goto LAB_0800698a;\nLAB_08006f16:\n      lVar31 = CONCAT44(piVar18,piVar24);\n      local_138 = (int *)0x0;\n      param_3 = (int *)(&bStack_2a + 2);\n      do {\n        iVar4 = (int)((ulonglong)lVar31 >> 0x20);\n        uVar26 = (uint)lVar31;\n        cVar10 = '\\n';\n        __aeabi_uldivmod(uVar26,iVar4,10,0);\n        *(byte *)((int)param_3 + -1) = cVar10 + 0x30;\n        local_138 = (int *)((int)local_138 + 1);\n        param_3 = (int *)((int)param_3 + -1);\n        if (((((local_140 & 0x400) != 0) && (local_138 == (int *)(uint)*local_108)) &&\n            (local_138 != (int *)0xff)) && (iVar4 != 0 || 9 < uVar26)) {\n          param_3 = (int *)((int)param_3 - (int)local_104);\n          strncpy((char *)param_3,(char *)local_110,(size_t)local_104);\n          if (local_108[1] == 0) {\n            local_138 = (int *)0x0;\n          }\n          else {\n            local_108 = local_108 + 1;\n            local_138 = (int *)0x0;\n          }\n        }\n        lVar31 = __aeabi_uldivmod(uVar26,iVar4,10,0);\n      } while (lVar31 != 0);\n      local_158 = (char *)((int)(&bStack_2a + 2) - (int)param_3);\n    }\n    else {\n      local_140 = uVar26 & 0xffffff7f;\n      iVar6 = iVar4;\n      if (((uint)piVar24 | (uint)piVar18) == 0) {\nLAB_080060a4:\n        if (piVar27 == (int *)0x0) {\n          if (iVar4 == 0) {\n            local_158 = (char *)(uVar26 & 1);\n            if ((int *)local_158 == (int *)0x0) {\n              param_3 = (int *)(&bStack_2a + 2);\n            }\n            else {\n              param_3 = (int *)(&bStack_2a + 1);\n              local_29 = '0';\n            }\n          }\n          else {\n            param_3 = (int *)(&bStack_2a + 2);\n          }\n        }\n        else {\n          if (iVar4 != 1) goto LAB_08006136;\nLAB_0800698a:\n          local_29 = (char)piVar24 + '0';\n          param_3 = (int *)(&bStack_2a + 1);\n          local_158 = (char *)0x1;\n        }\n      }\n      else {\nLAB_08006130:\n        iVar4 = iVar6;\n        uVar26 = local_140;\n        if (iVar6 == 1) goto LAB_08006980;\nLAB_08006136:\n        if (iVar4 == 2) {\n          param_3 = (int *)(&bStack_2a + 2);\n          do {\n            piVar19 = (int *)((uint)piVar24 >> 4 | (int)piVar18 << 0x1c);\n            piVar18 = (int *)((uint)piVar18 >> 4);\n            param_3 = (int *)((int)param_3 + -1);\n            *(char *)param_3 = local_11c[(uint)piVar24 & 0xf];\n            piVar24 = piVar19;\n          } while (((uint)piVar19 | (uint)piVar18) != 0);\n        }\n        else {\n          param_3 = (int *)(&bStack_2a + 2);\n          do {\n            piVar19 = param_3;\n            piVar12 = (int *)((uint)piVar24 >> 3 | (int)piVar18 << 0x1d);\n            piVar18 = (int *)((uint)piVar18 >> 3);\n            iVar4 = ((uint)piVar24 & 7) + 0x30;\n            *(byte *)((int)piVar19 + -1) = (byte)iVar4;\n            param_3 = (int *)((int)piVar19 + -1);\n            piVar24 = piVar12;\n          } while (((uint)piVar12 | (uint)piVar18) != 0);\n          if (((local_140 & 1) != 0) && (iVar4 != 0x30)) {\n            param_3 = (int *)((int)piVar19 + -2);\n            local_158 = (char *)(&bStack_2a + (2 - (int)param_3));\n            *(byte *)((int)piVar19 + -2) = 0x30;\n            goto LAB_0800675a;\n          }\n        }\n        local_158 = (char *)(&bStack_2a + (2 - (int)param_3));\n      }\n    }\nLAB_0800675a:\n    local_148 = (int *)0x0;\n    local_13c = 0;\n    local_134 = (int *)0x0;\n    local_130 = 0;\n    piVar18 = (int *)(uint)local_f5;\n    piVar24 = piVar27;\n    local_168 = (int *)local_158;\n    if ((int)local_158 < (int)piVar27) {\n      local_168 = piVar27;\n    }\n    goto LAB_08006538;\n  }\nLAB_08006216:\n  if (local_d0 == (byte *)0x0) {\nLAB_0800604a:\n    uVar15 = *(ushort *)(param_2 + 3);\n  }\n  else {\n    __ssprint_r(param_1,param_2,&local_d8);\n    uVar15 = *(ushort *)(param_2 + 3);\n  }\nLAB_0800604e:\n  if ((uVar15 & 0x40) != 0) {\n    local_164 = (byte *)0xffffffff;\n  }\n  return local_164;\nswitchD_08005f58_caseD_6c:\n  uVar25 = (uint)*(byte *)piVar28;\n  if (uVar25 == 0x6c) {\n    uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n    uVar26 = uVar26 | 0x20;\n    piVar28 = (int *)((int)piVar28 + 1);\n  }\n  else {\n    uVar26 = uVar26 | 0x10;\n  }\n  goto LAB_08005f4a;\n  while (iVar6 = __aeabi_dcmpeq(uVar7,uVar8,0,0), iVar6 == 0) {\nLAB_080072ba:\n    piVar18 = piVar24;\n    piVar19 = local_138;\n    piVar24 = (int *)((int)piVar18 + -1);\n    uVar32 = __muldf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),0,0x40300000);\n    iVar4 = __aeabi_d2iz();\n    uVar33 = __aeabi_i2d();\n    uVar32 = __subdf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),(int)uVar33,\n                      (int)((ulonglong)uVar33 >> 0x20));\n    uVar8 = (undefined4)((ulonglong)uVar32 >> 0x20);\n    uVar7 = (undefined4)uVar32;\n    local_138 = (int *)((int)piVar19 + 1);\n    *(char *)piVar19 = local_158[iVar4];\n    if (piVar24 == (int *)0xffffffff) break;\n  }\n  iVar6 = __aeabi_dcmpgt(uVar7,uVar8,0,0x3fe00000);\n  if ((iVar6 == 0) &&\n     ((iVar6 = __aeabi_dcmpeq(uVar7,uVar8,0,0x3fe00000), iVar6 == 0 || (-1 < iVar4 << 0x1f)))) {\n    if (-1 < (int)piVar24) {\n      piVar18 = (int *)((int)piVar18 + (int)local_138);\n      piVar24 = local_138;\n      do {\n        local_138 = (int *)((int)piVar24 + 1);\n        *(byte *)piVar24 = 0x30;\n        piVar24 = local_138;\n      } while (piVar18 != local_138);\n    }\n  }\n  else {\n    bVar1 = local_158[0xf];\n    bVar11 = *(byte *)piVar19;\n    piVar24 = local_138;\n    local_e0 = piVar19;\n    while (bVar1 == bVar11) {\n      *(byte *)((int)piVar24 + -1) = 0x30;\n      bVar11 = *(byte *)((int)local_e0 + -1);\n      piVar24 = local_e0;\n      local_e0 = (int *)((int)local_e0 + -1);\n    }\n    if (bVar11 == 0x39) {\n      bVar11 = local_158[10];\n    }\n    else {\n      bVar11 = bVar11 + 1;\n    }\n    *(byte *)((int)piVar24 + -1) = bVar11;\n  }\n  local_138 = (int *)((int)local_138 - (int)param_3);\nLAB_08006cb0:\n  local_168 = (int *)(uVar25 & 0xffffffdf);\n  local_134 = local_f0[0];\n  if (local_168 == (int *)0x47) {\n    if (((int)((int)local_f0[0] + 3) < 0 == SCARRY4((int)local_f0[0],3)) &&\n       ((int)local_f0[0] <= (int)piVar27)) {\n      if ((int)local_f0[0] < (int)local_138) {\n        local_158 = (char *)((int)local_138 + (int)piVar3);\n        if (0 < (int)local_f0[0]) {\n          uVar25 = 0x67;\n          goto LAB_080074f8;\n        }\n        local_158 = (char *)((int)local_158 + (1 - (int)local_f0[0]));\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        uVar25 = 0x67;\n      }\n      else {\n        if ((int)(uVar26 << 0x1f) < 0) {\n          local_158 = (char *)((int)local_f0[0] + (int)piVar3);\n        }\n        else {\n          local_158 = (char *)local_f0[0];\n        }\n        if (-1 < (int)(uVar26 << 0x15)) {\n          uVar25 = 0x67;\n          goto LAB_0800754a;\n        }\n        if (0 < (int)local_f0[0]) {\n          uVar25 = 0x67;\n          goto LAB_080074fc;\n        }\n        uVar25 = 0x67;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_080073d6;\n    }\n    uVar25 = uVar25 - 2;\n    local_168 = (int *)(uVar25 & 0xffffffdf);\nLAB_08006cc4:\n    local_e8._0_1_ = (char)uVar25;\n    if (local_168 == (int *)0x41) {\n      local_e8._0_1_ = (char)local_e8 + '\\x0f';\n    }\n    piVar27 = (int *)((int)local_f0[0] + -1);\n    if ((int)piVar27 < 0) {\n      local_e8._1_1_ = 0x2d;\n      local_f0[0] = (int *)(1 - (int)local_f0[0]);\n    }\n    else {\n      local_e8._1_1_ = 0x2b;\n      local_f0[0] = piVar27;\n    }\n    if ((int)local_f0[0] < 10) {\n      if (local_168 == (int *)0x41) {\n        pcVar21 = (char *)((int)&local_e8 + 2);\n      }\n      else {\n        local_e8._2_1_ = 0x30;\n        pcVar21 = (char *)((int)&local_e8 + 3);\n      }\n      *pcVar21 = (char)local_f0[0] + '0';\n      pcVar21 = pcVar21 + 1;\n    }\n    else {\n      pbVar29 = abStack_dc + 3;\n      pbVar23 = pbVar29;\n      do {\n        pbVar9 = pbVar23;\n        piVar24 = (int *)((uint)local_f0[0] / 10);\n        pbVar9[-1] = (char)local_f0[0] + (char)piVar24 * -10 + 0x30;\n        pbVar23 = pbVar9 + -1;\n        local_f0[0] = piVar24;\n      } while ((int *)0x9 < piVar24);\n      uVar22 = (uint)(piVar24 + 0xc) & 0xff;\n      pbVar9[-2] = (byte)uVar22;\n      if (pbVar9 + -2 < pbVar29) {\n        pbVar9 = pbVar23;\n        pcVar21 = (char *)((int)&local_e8 + 2);\n        while( true ) {\n          *pcVar21 = (char)uVar22;\n          if (pbVar29 == pbVar9) break;\n          uVar22 = (uint)*pbVar9;\n          pbVar9 = pbVar9 + 1;\n          pcVar21 = pcVar21 + 1;\n        }\n        pcVar21 = (char *)(((int)&stack0xfffffe78 * 2 - (int)pbVar23) + 0x152);\n      }\n      else {\n        pcVar21 = (char *)((int)&local_e8 + 2);\n      }\n    }\n    local_10c = (int *)(pcVar21 + -(int)&local_e8);\n    local_158 = (char *)((int)local_10c + (int)local_138);\n    if ((1 < (int)local_138) || ((int)(uVar26 << 0x1f) < 0)) {\n      local_158 = (char *)((int)local_158 + (int)piVar3);\n    }\n    local_13c = 0;\n    local_134 = (int *)0x0;\n    local_130 = 0;\n    local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    local_140 = uVar26 & 0xfffffbff | 0x100;\n    local_f0[0] = piVar27;\n  }\n  else {\n    if (local_168 != (int *)0x46) goto LAB_08006cc4;\n    if ((int)local_f0[0] < 1) {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)(uVar26 << 0x1f))) {\n        uVar25 = 0x66;\n        local_168 = (int *)0x1;\n        local_158 = (char *)0x1;\n      }\n      else {\n        uVar25 = 0x66;\n        local_158 = (char *)((byte *)((int)piVar3 + 1) + (int)piVar27);\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\nLAB_080073d6:\n      local_13c = 0;\n      local_130 = 0;\n    }\n    else {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)(uVar26 << 0x1f))) {\n        uVar25 = 0x66;\n        local_158 = (char *)local_f0[0];\n      }\n      else {\n        uVar25 = 0x66;\n        local_158 = (char *)((byte *)((int)local_f0[0] + (int)piVar3) + (int)piVar27);\n      }\nLAB_080074f8:\n      if (-1 < (int)(uVar26 << 0x15)) {\nLAB_0800754a:\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        goto LAB_080073d6;\n      }\nLAB_080074fc:\n      local_13c = 0;\n      local_130 = 0;\n      uVar26 = (uint)*local_108;\n      while (uVar26 != 0xff) {\n        while( true ) {\n          if ((int)local_134 <= (int)uVar26) goto LAB_08007524;\n          uVar22 = (uint)local_108[1];\n          local_134 = (int *)((int)local_134 - uVar26);\n          if (uVar22 == 0) break;\n          local_108 = local_108 + 1;\n          local_130 = local_130 + 1;\n          uVar26 = uVar22;\n          if (uVar22 == 0xff) goto LAB_08007524;\n        }\n        local_13c = local_13c + 1;\n      }\nLAB_08007524:\n      local_158 = (char *)((int)local_104 * (local_130 + local_13c) + (int)local_158);\n      local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    }\n  }\n  if (local_144 == 0) {\n    piVar18 = (int *)(uint)local_f5;\n    piVar24 = (int *)0x0;\nLAB_08006538:\n    uVar26 = local_140;\n    if (piVar18 != (int *)0x0) goto LAB_0800653e;\n  }\n  else {\n    piVar18 = (int *)0x2d;\n    piVar24 = (int *)0x0;\n    local_f5 = 0x2d;\nLAB_0800653e:\n    local_168 = (int *)((int)local_168 + 1);\n    uVar26 = local_140;\n  }\nLAB_08006298:\n  if ((uVar26 & 2) != 0) {\n    local_168 = (int *)((int)local_168 + 2);\n  }\n  if (((uVar26 & 0x84) == 0) &&\n     (piVar27 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar27)) {\n    if (0x10 < (int)piVar27) {\n      do {\n        piVar18 = piVar27;\n        local_d4 = local_d4 + 1;\n        local_d0 = local_d0 + 0x10;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = (int *)0x10;\n        if (local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        piVar27 = piVar18 + -4;\n      } while (0x10 < (int)piVar27);\n      piVar27 = piVar18 + -4;\n    }\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)piVar27;\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar27;\n    if (local_d4 < 8) {\n      piVar18 = (int *)(uint)local_f5;\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar18 = (int *)(uint)local_f5;\n    }\n  }\n  if (piVar18 != (int *)0x0) {\n    local_d0 = local_d0 + 1;\n    local_d4 = local_d4 + 1;\n    *ppiVar2 = (int *)&local_f5;\n    ppiVar2[1] = (int *)0x1;\n    if (local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  if ((uVar26 & 2) != 0) {\n    local_d0 = local_d0 + 2;\n    local_d4 = local_d4 + 1;\n    *ppiVar2 = (int *)&local_f4;\n    ppiVar2[1] = (int *)0x2;\n    if (local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  if (((uVar26 & 0x84) == 0x80) &&\n     (piVar27 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar27)) {\n    if (0x10 < (int)piVar27) {\n      do {\n        while( true ) {\n          piVar18 = piVar27;\n          local_d4 = local_d4 + 1;\n          local_d0 = local_d0 + 0x10;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if (local_d4 < 8) break;\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar27 = piVar18 + -4;\n          if ((int)(piVar18 + -4) < 0x11) goto LAB_08006882;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar27 = piVar18 + -4;\n      } while (0x10 < (int)(piVar18 + -4));\nLAB_08006882:\n      piVar27 = piVar18 + -4;\n    }\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)piVar27;\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar27;\n    if (local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar24 = (int *)((int)piVar24 - (int)local_158);\n  if (0 < (int)piVar24) {\n    if (0x10 < (int)piVar24) {\n      do {\n        while( true ) {\n          piVar27 = piVar24;\n          local_d4 = local_d4 + 1;\n          local_d0 = local_d0 + 0x10;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if (local_d4 < 8) break;\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar24 = piVar27 + -4;\n          if ((int)(piVar27 + -4) < 0x11) goto LAB_080063d2;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar24 = piVar27 + -4;\n      } while (0x10 < (int)(piVar27 + -4));\nLAB_080063d2:\n      piVar24 = piVar27 + -4;\n    }\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)piVar24;\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar24;\n    if (local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  pbVar23 = local_d0;\n  if ((uVar26 & 0x100) == 0) {\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)local_158;\n    *ppiVar2 = param_3;\n    ppiVar2[1] = (int *)local_158;\n    if (local_d4 < 8) {\nLAB_0800640e:\n      ppiVar2 = ppiVar2 + 2;\n      pbVar23 = local_d0;\n    }\n    else {\nLAB_08006a20:\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      pbVar23 = local_d0;\n    }\n  }\n  else if ((int)uVar25 < 0x66) {\n    local_158 = (char *)(local_d0 + 1);\n    iVar4 = local_d4 + 1;\n    ppiVar16 = ppiVar2 + 2;\n    local_d0 = (byte *)local_158;\n    if (((int)local_138 < 2) && ((uVar26 & 1) == 0)) {\n      *ppiVar2 = param_3;\n      ppiVar2[1] = (int *)0x1;\n      if (iVar4 < 8) {\n        local_150 = (int *)(local_d4 + 2);\n        ppiVar2 = ppiVar2 + 4;\n      }\n      else {\n        local_d4 = iVar4;\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        local_150 = (int *)(local_d4 + 1);\n        ppiVar16 = local_cc;\n        local_158 = (char *)local_d0;\n        ppiVar2 = local_cc + 2;\n      }\n    }\n    else {\n      *ppiVar2 = param_3;\n      ppiVar2[1] = (int *)0x1;\n      local_d4 = iVar4;\n      if (7 < iVar4) {\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        ppiVar16 = local_cc;\n        local_158 = (char *)local_d0;\n      }\n      local_d4 = local_d4 + 1;\n      local_d0 = (byte *)(local_158 + (int)piVar3);\n      *ppiVar16 = __s;\n      ppiVar16[1] = piVar3;\n      if (local_d4 < 8) {\n        ppiVar20 = ppiVar16 + 2;\n      }\n      else {\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        ppiVar20 = local_cc;\n      }\n      local_158 = (char *)local_d0;\n      iVar4 = local_d4;\n      local_150 = (int *)(local_d4 + 1);\n      piVar27 = (int *)((int)local_138 + -1);\n      ppiVar13 = ppiVar20 + 2;\n      iVar6 = __aeabi_dcmpeq(local_128,local_12c,0,0);\n      local_d4 = (int)local_150;\n      if (iVar6 == 0) {\n        local_158 = (char *)((byte *)local_158 + (int)piVar27);\n        *ppiVar20 = (int *)((int)param_3 + 1);\n        ppiVar20[1] = piVar27;\n        local_d0 = (byte *)local_158;\n        if ((int)local_150 < 8) {\n          local_150 = (int *)(iVar4 + 2);\n          ppiVar16 = ppiVar13;\n          ppiVar2 = ppiVar20 + 4;\n        }\n        else {\nLAB_08006d9c:\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          local_150 = (int *)(local_d4 + 1);\n          local_158 = (char *)local_d0;\n          ppiVar16 = local_cc;\n          ppiVar2 = local_cc + 2;\n        }\n      }\n      else {\n        ppiVar16 = ppiVar20;\n        ppiVar2 = ppiVar13;\n        if (0 < (int)piVar27) {\n          if (0x10 < (int)piVar27) {\n            while( true ) {\n              local_d0 = (byte *)local_158 + 0x10;\n              *ppiVar20 = (int *)0x8009f60;\n              ppiVar20[1] = (int *)0x10;\n              if (local_d4 < 8) {\n                ppiVar20 = ppiVar20 + 2;\n              }\n              else {\n                iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                if (iVar4 != 0) goto LAB_0800603e;\n                ppiVar20 = local_cc;\n              }\n              piVar27 = piVar27 + -4;\n              local_158 = (char *)local_d0;\n              if ((int)piVar27 < 0x11) break;\n              local_d4 = local_d4 + 1;\n            }\n            local_150 = (int *)(local_d4 + 1);\n            ppiVar13 = ppiVar20 + 2;\n          }\n          *ppiVar20 = (int *)0x8009f60;\n          ppiVar20[1] = piVar27;\n          local_158 = local_158 + (int)piVar27;\n          local_d4 = (int)local_150;\n          local_d0 = (byte *)local_158;\n          if (7 < (int)local_150) goto LAB_08006d9c;\n          local_150 = (int *)((int)local_150 + 1);\n          ppiVar2 = ppiVar13 + 2;\n          ppiVar16 = ppiVar13;\n        }\n      }\n    }\n    ppiVar16[1] = local_10c;\n    local_d0 = (byte *)(local_158 + (int)local_10c);\n    local_d4 = (int)local_150;\n    *ppiVar16 = &local_e8;\n    pbVar23 = local_d0;\n    if (7 < (int)local_150) {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      pbVar23 = local_d0;\n    }\n  }\n  else {\n    iVar4 = __aeabi_dcmpeq(local_128,local_12c,0,0);\n    if (iVar4 == 0) {\n      if ((int)local_f0[0] < 1) {\n        local_d4 = local_d4 + 1;\n        local_d0 = pbVar23 + 1;\n        *ppiVar2 = (int *)&DAT_08009f4c;\n        ppiVar2[1] = (int *)0x1;\n        if (local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        if (((local_f0[0] != (int *)0x0) || (local_138 != (int *)0x0)) ||\n           (pbVar23 = local_d0, (uVar26 & 1) != 0)) {\n          local_d4 = local_d4 + 1;\n          local_d0 = local_d0 + (int)piVar3;\n          *ppiVar2 = __s;\n          ppiVar2[1] = piVar3;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n          }\n          if ((int)local_f0[0] < 0) {\n            piVar27 = (int *)-(int)local_f0[0];\n            if ((int)(local_f0[0] + 4) < 0 != SCARRY4((int)local_f0[0],0x10)) {\n              do {\n                local_d4 = local_d4 + 1;\n                local_d0 = local_d0 + 0x10;\n                *ppiVar2 = (int *)0x8009f60;\n                ppiVar2[1] = (int *)0x10;\n                if (local_d4 < 8) {\n                  ppiVar2 = ppiVar2 + 2;\n                }\n                else {\n                  iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                  if (iVar4 != 0) goto LAB_0800603e;\n                  ppiVar2 = local_cc;\n                }\n                piVar27 = piVar27 + -4;\n              } while (0x10 < (int)piVar27);\n            }\n            local_d4 = local_d4 + 1;\n            local_d0 = local_d0 + (int)piVar27;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = piVar27;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\n          local_d0 = local_d0 + (int)local_138;\n          *ppiVar2 = param_3;\n          ppiVar2[1] = local_138;\n          goto joined_r0x08006a1c;\n        }\n      }\n      else {\n        piVar27 = local_134;\n        if ((int)local_138 <= (int)local_134) {\n          piVar27 = local_138;\n        }\n        if (0 < (int)piVar27) {\n          local_d0 = pbVar23 + (int)piVar27;\n          local_d4 = local_d4 + 1;\n          *ppiVar2 = param_3;\n          ppiVar2[1] = piVar27;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            pbVar23 = local_d0;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            pbVar23 = local_d0;\n          }\n        }\n        piVar24 = local_134;\n        if (-1 < (int)piVar27) {\n          piVar24 = (int *)((int)local_134 - (int)piVar27);\n        }\n        if (0 < (int)piVar24) {\n          for (; 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + 0x10;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            pbVar23 = local_d0;\n          }\n          local_d4 = local_d4 + 1;\n          pbVar23 = pbVar23 + (int)piVar24;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar24;\n          local_d0 = pbVar23;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            pbVar23 = local_d0;\n          }\n        }\n        local_134 = (int *)((int)local_134 + (int)param_3);\n        if ((uVar26 & 0x400) != 0) {\n          if (local_130 == 0) goto LAB_08007176;\nLAB_080070ba:\n          if (local_13c != 0) goto LAB_0800717e;\n          local_108 = local_108 + -1;\n          local_130 = local_130 + -1;\n          do {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + (int)local_104;\n            *ppiVar2 = local_110;\n            ppiVar2[1] = local_104;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar24 = (int *)(uint)*local_108;\n            piVar27 = (int *)((byte *)((int)param_3 + (int)local_138) + -(int)local_134);\n            if ((int)piVar24 <= (int)((byte *)((int)param_3 + (int)local_138) + -(int)local_134)) {\n              piVar27 = piVar24;\n            }\n            if (0 < (int)piVar27) {\n              local_d0 = local_d0 + (int)piVar27;\n              local_d4 = local_d4 + 1;\n              *ppiVar2 = local_134;\n              ppiVar2[1] = piVar27;\n              if (local_d4 < 8) {\n                piVar24 = (int *)(uint)*local_108;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                if (iVar4 != 0) goto LAB_0800603e;\n                ppiVar2 = local_cc;\n                piVar24 = (int *)(uint)*local_108;\n              }\n            }\n            piVar18 = piVar24;\n            if (-1 < (int)piVar27) {\n              piVar18 = (int *)((int)piVar24 - (int)piVar27);\n            }\n            if (0 < (int)piVar18) {\n              for (; 0x10 < (int)piVar18; piVar18 = piVar18 + -4) {\n                while( true ) {\n                  local_d4 = local_d4 + 1;\n                  local_d0 = local_d0 + 0x10;\n                  *ppiVar2 = (int *)0x8009f60;\n                  ppiVar2[1] = (int *)0x10;\n                  if (local_d4 < 8) break;\n                  iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                  if (iVar4 != 0) goto LAB_0800603e;\n                  piVar18 = piVar18 + -4;\n                  ppiVar2 = local_cc;\n                  if ((int)piVar18 < 0x11) goto LAB_08007156;\n                }\n                ppiVar2 = ppiVar2 + 2;\n              }\nLAB_08007156:\n              local_d4 = local_d4 + 1;\n              local_d0 = local_d0 + (int)piVar18;\n              *ppiVar2 = (int *)0x8009f60;\n              ppiVar2[1] = piVar18;\n              if (local_d4 < 8) {\n                piVar24 = (int *)(uint)*local_108;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                if (iVar4 != 0) goto LAB_0800603e;\n                piVar24 = (int *)(uint)*local_108;\n                ppiVar2 = local_cc;\n              }\n            }\n            local_134 = (int *)((int)local_134 + (int)piVar24);\n            pbVar23 = local_d0;\n            if (local_130 != 0) goto LAB_080070ba;\nLAB_08007176:\n            if (local_13c == 0) {\n              if ((int *)((int)param_3 + (int)local_138) <= local_134) {\n                local_134 = (int *)((int)param_3 + (int)local_138);\n              }\n              break;\n            }\nLAB_0800717e:\n            local_13c = local_13c + -1;\n          } while( true );\n        }\n        if (((int)local_f0[0] < (int)local_138) || ((uVar26 & 1) != 0)) {\n          local_d4 = local_d4 + 1;\n          local_d0 = pbVar23 + (int)piVar3;\n          *ppiVar2 = __s;\n          ppiVar2[1] = piVar3;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            pbVar23 = local_d0;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            pbVar23 = local_d0;\n          }\n        }\n        piVar27 = (int *)((int)local_138 - (int)local_f0[0]);\n        piVar24 = (int *)((byte *)((int)param_3 + (int)local_138) + -(int)local_134);\n        if ((int)piVar27 <= (int)((byte *)((int)param_3 + (int)local_138) + -(int)local_134)) {\n          piVar24 = piVar27;\n        }\n        if (0 < (int)piVar24) {\n          local_d0 = pbVar23 + (int)piVar24;\n          local_d4 = local_d4 + 1;\n          *ppiVar2 = local_134;\n          ppiVar2[1] = piVar24;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            pbVar23 = local_d0;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = (int *)((int)local_138 - (int)local_f0[0]);\n            pbVar23 = local_d0;\n          }\n        }\n        if (-1 < (int)piVar24) {\n          piVar27 = (int *)((int)piVar27 - (int)piVar24);\n        }\n        if (0 < (int)piVar27) {\n          for (; 0x10 < (int)piVar27; piVar27 = piVar27 + -4) {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + 0x10;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            pbVar23 = local_d0;\n          }\n          goto LAB_08007014;\n        }\n      }\n    }\n    else {\n      local_d4 = local_d4 + 1;\n      local_d0 = pbVar23 + 1;\n      *ppiVar2 = (int *)&DAT_08009f4c;\n      ppiVar2[1] = (int *)0x1;\n      if (local_d4 < 8) {\n        ppiVar2 = ppiVar2 + 2;\n      }\n      else {\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        ppiVar2 = local_cc;\n      }\n      if (((int)local_f0[0] < (int)local_138) || (pbVar23 = local_d0, (uVar26 & 1) != 0)) {\n        local_d4 = local_d4 + 1;\n        local_d0 = local_d0 + (int)piVar3;\n        *ppiVar2 = __s;\n        ppiVar2[1] = piVar3;\n        if (local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        piVar27 = (int *)((int)local_138 + -1);\n        pbVar23 = local_d0;\n        if (0 < (int)piVar27) {\n          for (; 0x10 < (int)piVar27; piVar27 = piVar27 + -4) {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + 0x10;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            pbVar23 = local_d0;\n          }\nLAB_08007014:\n          local_d0 = pbVar23 + (int)piVar27;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar27;\njoined_r0x08006a1c:\n          local_d4 = local_d4 + 1;\n          if (7 < local_d4) goto LAB_08006a20;\n          goto LAB_0800640e;\n        }\n      }\n    }\n  }\n  if (((uVar26 & 4) != 0) && (piVar27 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar27))\n  {\n    for (; local_d0 = pbVar23, 0x10 < (int)piVar27; piVar27 = piVar27 + -4) {\n      while( true ) {\n        local_d4 = local_d4 + 1;\n        local_d0 = local_d0 + 0x10;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = (int *)0x10;\n        if (local_d4 < 8) break;\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        piVar27 = piVar27 + -4;\n        ppiVar2 = local_cc;\n        if ((int)piVar27 < 0x11) goto LAB_0800647a;\n      }\n      ppiVar2 = ppiVar2 + 2;\n      pbVar23 = local_d0;\n    }\nLAB_0800647a:\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)piVar27;\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar27;\n    pbVar23 = local_d0;\n    if ((7 < local_d4) &&\n       (iVar4 = __ssprint_r(param_1,param_2,&local_d8), pbVar23 = local_d0, iVar4 != 0))\n    goto LAB_0800603e;\n  }\n  if ((int)local_15c < (int)local_168) {\n    local_15c = local_168;\n  }\n  local_164 = local_164 + (int)local_15c;\n  if ((pbVar23 == (byte *)0x0) || (iVar4 = __ssprint_r(param_1,param_2,&local_d8), iVar4 == 0)) {\n    local_d4 = 0;\n    if (local_148 != (int *)0x0) {\n      _free_r(param_1,local_148);\n    }\n    ppiVar2 = local_cc;\nLAB_0800620e:\n    bVar1 = *(byte *)piVar28;\n    param_3 = piVar28;\n    goto joined_r0x08005ef2;\n  }\nLAB_0800603e:\n  if (local_148 != (int *)0x0) {\n    _free_r(param_1,local_148);\n  }\n  goto LAB_0800604a;\nswitchD_08005f58_caseD_31:\n  local_15c = (int *)0x0;\n  uVar22 = uVar25 - 0x30;\n  piVar24 = piVar28;\n  do {\n    piVar28 = (int *)((int)piVar24 + 1);\n    uVar25 = (uint)*(byte *)piVar24;\n    local_15c = (int *)(uVar22 + (int)local_15c * 10);\n    uVar22 = uVar25 - 0x30;\n    piVar24 = piVar28;\n  } while (uVar22 < 10);\n  goto LAB_08005f4e;\nswitchD_08005f58_caseD_20:\n  uVar25 = (uint)*(byte *)piVar28;\n  if (local_f5 == 0) {\n    local_f5 = 0x20;\n  }\n  goto LAB_08005f4a;\n}\n\n",
            "renaming": {
                "FUN_08005e9c": "FUNC_08005e9c"
            },
            "calling": [
                "sprintf"
            ],
            "called": [
                "__ssprint_r",
                "__aeabi_dcmpgt",
                "__aeabi_uldivmod",
                "_dtoa_r",
                "_localeconv_r",
                "__aeabi_dcmpeq",
                "__aeabi_dcmple",
                "__unorddf2",
                "frexp",
                "__aeabi_dcmplt",
                "__subdf3",
                "strncpy",
                "__aeabi_i2d",
                "_malloc_r",
                "strlen",
                "_free_r",
                "__muldf3",
                "__aeabi_d2iz",
                "memchr"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078a0": {
            "entrypoint": "0x080078a0",
            "current_name": "FUNC_080078a0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080078a4) */\n\nvoid FUNC_080078a0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080078a0": "FUNC_080078a0"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "atexit"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078b4": {
            "entrypoint": "0x080078b4",
            "current_name": "register_exit_procedure_080078b4",
            "code": "\nint registerExitProcedure_080078b4(functionPointer *functionPointer)\n\n{\n  int exitProcReturnValue;\n  \n  exitProcReturnValue = __register_exitproc(0,functionPointer,0);\n  return exitProcReturnValue;\n}\n\n",
            "renaming": {
                "FUN_080078b4": "register_exit_procedure_080078b4",
                "__func": "functionPointer",
                "iVar1": "exitProcReturnValue"
            },
            "calling": [
                "register_fini"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080078c0": {
            "entrypoint": "0x080078c0",
            "current_name": "calculate_division_080078c0",
            "code": "\nuint calculateDivision_080078c0(int numerator,int denominator)\n\n{\n  uint temp1;\n  uint *numeratorPtr;\n  int quotient;\n  int denominatorSize;\n  int index;\n  uint result;\n  uint *denominatorPtr;\n  uint *numeratorPtr2;\n  uint *denominatorPtr2;\n  uint temp2;\n  uint *denominatorPtr3;\n  uint *denominatorPtr4;\n  \n  denominatorSize = *(int *)(denominator + 0x10);\n  if (*(int *)(numerator + 0x10) < denominatorSize) {\n    return 0;\n  }\n  index = denominatorSize + -1;\n  denominatorPtr = (uint *)(denominator + 0x14);\n  numeratorPtr2 = (uint *)(numerator + 0x14);\n  result = numeratorPtr2[index] / (denominatorPtr[index] + 1);\n  denominatorPtr2 = denominatorPtr + index;\n  if (result != 0) {\n    temp1 = 0;\n    quotient = 0;\n    numeratorPtr = numeratorPtr2;\n    denominatorPtr3 = denominatorPtr;\n    do {\n      denominatorPtr4 = denominatorPtr3 + 1;\n      temp1 = result * (*denominatorPtr3 & 0xffff) + temp1;\n      temp2 = result * (*denominatorPtr3 >> 0x10) + (temp1 >> 0x10);\n      temp1 = (quotient - (temp1 & 0xffff)) + (*numeratorPtr & 0xffff);\n      quotient = ((*numeratorPtr >> 0x10) - (temp2 & 0xffff)) + ((int)temp1 >> 0x10);\n      *numeratorPtr = temp1 & 0xffff | quotient * 0x10000;\n      quotient = quotient >> 0x10;\n      temp1 = temp2 >> 0x10;\n      numeratorPtr = numeratorPtr + 1;\n      denominatorPtr3 = denominatorPtr4;\n    } while (denominatorPtr4 <= denominatorPtr2);\n    if (numeratorPtr2[index] == 0) {\n      if ((numeratorPtr2 < numeratorPtr2 + denominatorSize + -2) && (numeratorPtr2[denominatorSize + -2] == 0)) {\n        numeratorPtr = numeratorPtr2 + denominatorSize + -3;\n        do {\n          index = index + -1;\n          if (numeratorPtr <= numeratorPtr2) break;\n          temp1 = *numeratorPtr;\n          numeratorPtr = numeratorPtr + -1;\n        } while (temp1 == 0);\n      }\n      *(int *)(numerator + 0x10) = index;\n    }\n  }\n  denominatorSize = __mcmp();\n  if (-1 < denominatorSize) {\n    denominatorSize = 0;\n    result = result + 1;\n    numeratorPtr = numeratorPtr2;\n    do {\n      denominatorPtr3 = denominatorPtr + 1;\n      temp1 = (denominatorSize - (*denominatorPtr & 0xffff)) + (*numeratorPtr & 0xffff);\n      denominatorSize = ((*numeratorPtr >> 0x10) - (*denominatorPtr >> 0x10)) + ((int)temp1 >> 0x10);\n      *numeratorPtr = temp1 & 0xffff | denominatorSize * 0x10000;\n      denominatorSize = denominatorSize >> 0x10;\n      numeratorPtr = numeratorPtr + 1;\n      denominatorPtr = denominatorPtr3;\n    } while (denominatorPtr3 <= denominatorPtr2);\n    if (numeratorPtr2[index] == 0) {\n      if ((numeratorPtr2 < numeratorPtr2 + index + -1) && (numeratorPtr2[index + -1] == 0)) {\n        denominatorPtr = numeratorPtr2 + index + -2;\n        do {\n          index = index + -1;\n          if (denominatorPtr <= numeratorPtr2) break;\n          temp1 = *denominatorPtr;\n          denominatorPtr = denominatorPtr + -1;\n        } while (temp1 == 0);\n      }\n      *(int *)(numerator + 0x10) = index;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080078c0": "calculate_division_080078c0",
                "param_1": "numerator",
                "param_2": "denominator",
                "iVar3": "quotient",
                "iVar4": "denominatorSize",
                "iVar5": "index",
                "uVar1": "temp1",
                "uVar6": "result",
                "uVar10": "temp2",
                "puVar2": "numeratorPtr",
                "puVar7": "denominatorPtr",
                "puVar8": "numeratorPtr2",
                "puVar9": "denominatorPtr2",
                "puVar11": "denominatorPtr3",
                "puVar12": "denominatorPtr4"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__mcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080079e8": {
            "entrypoint": "0x080079e8",
            "current_name": "format_number_to_string_080079e8",
            "code": "\nchar * formatNumberToString_080079e8(int number,undefined4 param_2,uint integerPart,uint fractionalPart,uint minIntegerDigits,\n                   uint minFractionalDigits,int *formattedStringLength,uint *isNegative,char **formattedString)\n\n{\n  bool bVar1;\n  bool bVar2;\n  bool bVar3;\n  char cVar4;\n  byte bVar5;\n  undefined4 uVar6;\n  int iVar7;\n  int iVar8;\n  int iVar9;\n  char *pcVar10;\n  uint uVar11;\n  undefined4 uVar12;\n  undefined4 uVar13;\n  int iVar14;\n  int iVar15;\n  undefined4 uVar16;\n  uint uVar17;\n  uint uVar18;\n  int iVar19;\n  char *pcVar20;\n  char *pcVar21;\n  undefined4 *puVar22;\n  undefined4 uVar23;\n  int iVar24;\n  bool bVar25;\n  undefined8 uVar26;\n  undefined8 uVar27;\n  undefined8 uVar28;\n  uint local_80;\n  uint local_7c;\n  uint local_74;\n  int local_70;\n  uint local_68;\n  int local_60;\n  int local_5c;\n  uint local_58;\n  uint local_48;\n  uint uStack_44;\n  uint local_38;\n  uint local_34;\n  int local_30;\n  int local_2c [2];\n  \n  iVar14 = *(int *)(number + 0x40);\n  if (iVar14 != 0) {\n    uVar18 = *(uint *)(number + 0x44);\n    *(uint *)(iVar14 + 4) = uVar18;\n    *(int *)(iVar14 + 8) = 1 << (uVar18 & 0xff);\n    _Bfree(number,iVar14);\n    *(undefined4 *)(number + 0x40) = 0;\n  }\n  bVar25 = (int)fractionalPart < 0;\n  uVar18 = fractionalPart;\n  if (bVar25) {\n    uVar18 = fractionalPart & 0x7fffffff;\n  }\n  *isNegative = (uint)bVar25;\n  local_7c = fractionalPart;\n  if (bVar25) {\n    local_7c = uVar18;\n  }\n  uVar17 = local_7c;\n  if ((~uVar18 & 0x7ff00000) == 0) {\n    *formattedStringLength = 9999;\n    if ((integerPart == 0) && ((uVar18 & 0xfffff) == 0)) {\n      pcVar10 = \"Infinity\";\n      if (formattedString == (char **)0x0) {\n        return pcVar10;\n      }\n      pcVar21 = \"\";\n    }\n    else {\n      pcVar10 = \"NaN\";\n      if (formattedString == (char **)0x0) {\n        return pcVar10;\n      }\n      pcVar21 = \"\";\n    }\n    *formattedString = pcVar21;\n    return pcVar10;\n  }\n  uVar26 = __aeabi_dcmpeq(integerPart,local_7c,0,0);\n  if ((int)uVar26 != 0) {\n    *formattedStringLength = 1;\n    if (formattedString != (char **)0x0) {\n      *formattedString = \"\";\n      return \"0\";\n    }\n    return \"0\";\n  }\n  uVar6 = __d2b(number,(int)((ulonglong)uVar26 >> 0x20),integerPart,local_7c,local_2c,&local_30);\n  iVar14 = local_30;\n  if (uVar18 >> 0x14 == 0) {\n    iVar19 = local_2c[0] + local_30;\n    iVar15 = iVar19 + 0x432;\n    if (iVar15 < 0x21) {\n      uVar18 = integerPart << (0x20U - iVar15 & 0xff);\n    }\n    else {\n      uVar18 = integerPart >> (iVar19 + 0x412U & 0xff) | uVar18 << (0x40U - iVar15 & 0xff);\n    }\n    uVar26 = __floatunsidf(uVar18);\n    iVar19 = iVar19 + -1;\n    bVar25 = true;\n    uVar11 = (int)((ulonglong)uVar26 >> 0x20) + 0xfe100000;\n    uVar18 = (uint)uVar26;\n  }\n  else {\n    iVar19 = (uVar18 >> 0x14) - 0x3ff;\n    uVar11 = local_7c & 0xfffff | 0x3ff00000;\n    bVar25 = false;\n    uVar18 = integerPart;\n  }\n  uVar26 = __subdf3(uVar18,uVar11,0,0x3ff80000);\n  uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0x636f4361,0x3fd287a7);\n  uVar26 = __aeabi_dadd((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0x8b60c8b3,0x3fc68a28);\n  uVar27 = __aeabi_i2d(iVar19);\n  uVar27 = __muldf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),0x509f79fb,0x3fd34413);\n  uVar26 = __aeabi_dadd((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),(int)uVar27,\n                        (int)((ulonglong)uVar27 >> 0x20));\n  uVar13 = (undefined4)((ulonglong)uVar26 >> 0x20);\n  local_74 = __aeabi_d2iz();\n  iVar15 = __aeabi_dcmplt((int)uVar26,uVar13,0,0);\n  if (iVar15 != 0) {\n    uVar27 = __aeabi_i2d(local_74);\n    iVar15 = __aeabi_dcmpeq((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,uVar13);\n    if (iVar15 == 0) {\n      local_74 = local_74 - 1;\n    }\n  }\n  if (local_74 < 0x17) {\n    iVar15 = __aeabi_dcmpgt(*(undefined4 *)(&__mprec_tens + local_74 * 8),\n                            *(undefined4 *)(&DAT_08009fac + local_74 * 8),integerPart,local_7c);\n    if (iVar15 == 0) {\n      bVar2 = false;\n    }\n    else {\n      local_74 = local_74 - 1;\n      bVar2 = false;\n    }\n  }\n  else {\n    bVar2 = true;\n  }\n  iVar15 = (iVar14 - iVar19) + -1;\n  if (iVar15 < 0) {\n    local_70 = 1 - (iVar14 - iVar19);\n    iVar15 = 0;\n  }\n  else {\n    local_70 = 0;\n  }\n  if ((int)local_74 < 0) {\n    local_58 = 0;\n    local_70 = local_70 - local_74;\n    local_5c = -local_74;\n  }\n  else {\n    iVar15 = iVar15 + local_74;\n    local_58 = local_74;\n    local_5c = 0;\n  }\n  if (9 < minIntegerDigits) {\n    local_38 = 0xffffffff;\n    bVar1 = true;\n    local_68 = 0xffffffff;\n    bVar3 = true;\n    minIntegerDigits = 0;\n    minFractionalDigits = 0;\n    goto LAB_08007c24;\n  }\n  bVar1 = (int)minIntegerDigits < 6;\n  if (!bVar1) {\n    minIntegerDigits = minIntegerDigits - 4;\n  }\n  switch(minIntegerDigits) {\n  case 2:\n    bVar3 = false;\n    break;\n  case 3:\n    bVar3 = false;\n    goto LAB_08008300;\n  case 4:\n    bVar3 = true;\n    break;\n  case 5:\n    bVar3 = true;\nLAB_08008300:\n    local_38 = local_74 + minFractionalDigits;\n    local_68 = local_38 + 1;\n    uVar18 = local_68;\n    if ((int)local_68 < 1) {\n      uVar18 = 1;\n    }\n    goto LAB_08008314;\n  default:\n    *(undefined4 *)(number + 0x44) = 0;\n    pcVar10 = (char *)_Balloc(number,0);\n    local_38 = 0xffffffff;\n    local_68 = 0xffffffff;\n    minFractionalDigits = 0;\n    *(char **)(number + 0x40) = pcVar10;\n    bVar3 = true;\n    goto LAB_08007e36;\n  }\n  if ((int)minFractionalDigits < 1) {\n    local_38 = 1;\n    minFractionalDigits = 1;\n    local_68 = 1;\nLAB_08007c24:\n    *(undefined4 *)(number + 0x44) = 0;\n    uVar11 = local_38;\n  }\n  else {\n    local_38 = minFractionalDigits;\n    local_68 = minFractionalDigits;\n    uVar18 = minFractionalDigits;\nLAB_08008314:\n    *(undefined4 *)(number + 0x44) = 0;\n    uVar11 = local_68;\n    if (0x17 < (int)uVar18) {\n      iVar19 = 4;\n      iVar14 = 1;\n      do {\n        iVar7 = iVar14;\n        iVar19 = iVar19 * 2;\n        iVar14 = iVar7 + 1;\n      } while (iVar19 + 0x14U <= uVar18);\n      *(int *)(number + 0x44) = iVar7;\n    }\n  }\n  pcVar10 = (char *)_Balloc(number);\n  *(char **)(number + 0x40) = pcVar10;\n  if ((uVar11 < 0xf) && (bVar1)) {\n    if ((int)local_74 < 1) {\n      if (local_74 == 0) {\n        iVar14 = 2;\n        local_80 = integerPart;\n      }\n      else {\n        iVar14 = (-local_74 & 0xf) * 8;\n        uVar26 = __muldf3(integerPart,local_7c,*(undefined4 *)(&__mprec_tens + iVar14),\n                          *(undefined4 *)(&DAT_08009fac + iVar14));\n        local_7c = (uint)((ulonglong)uVar26 >> 0x20);\n        local_80 = (uint)uVar26;\n        iVar19 = (int)-local_74 >> 4;\n        if (iVar19 == 0) {\n          iVar14 = 2;\n        }\n        else {\n          bVar1 = false;\n          iVar14 = 2;\n          puVar22 = &__mprec_bigtens;\n          do {\n            if (iVar19 << 0x1f < 0) {\n              uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),*puVar22,puVar22[1]);\n              bVar1 = true;\n              iVar14 = iVar14 + 1;\n            }\n            iVar19 = iVar19 >> 1;\n            puVar22 = puVar22 + 2;\n          } while (iVar19 != 0);\n          if (bVar1) {\n            local_80 = (uint)uVar26;\n            local_7c = (uint)((ulonglong)uVar26 >> 0x20);\n          }\n        }\n      }\n    }\n    else {\n      uVar18 = (int)local_74 >> 4;\n      uVar27 = *(undefined8 *)(&__mprec_tens + (local_74 & 0xf) * 8);\n      uVar26 = *(undefined8 *)(&__mprec_tens + (local_74 & 0xf) * 8);\n      if ((int)(uVar18 << 0x1b) < 0) {\n        uVar28 = __divdf3(integerPart,local_7c,0x7f73bf3c,0x75154fdd);\n        uStack_44 = (uint)((ulonglong)uVar28 >> 0x20);\n        local_48 = (uint)uVar28;\n        iVar14 = 3;\n        uVar18 = uVar18 & 0xf;\n      }\n      else {\n        iVar14 = 2;\n        uStack_44 = local_7c;\n        local_48 = integerPart;\n      }\n      if (uVar18 != 0) {\n        puVar22 = &__mprec_bigtens;\n        do {\n          if ((int)(uVar18 << 0x1f) < 0) {\n            uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),*puVar22,puVar22[1]);\n            iVar14 = iVar14 + 1;\n          }\n          uVar18 = (int)uVar18 >> 1;\n          puVar22 = puVar22 + 2;\n          uVar27 = uVar26;\n        } while (uVar18 != 0);\n      }\n      local_7c = (uint)((ulonglong)uVar27 >> 0x20);\n      local_80 = (uint)uVar27;\n      uVar26 = __divdf3(local_48,uStack_44,local_80,local_7c);\n      local_80 = (uint)uVar26;\n      local_7c = (uint)((ulonglong)uVar26 >> 0x20);\n    }\n    uVar26 = CONCAT44(local_7c,local_80);\n    if ((bVar2) && (iVar19 = __aeabi_dcmplt(local_80,local_7c,0,0x3ff00000), iVar19 != 0)) {\n      if (local_68 == 0) {\n        uVar26 = __aeabi_i2d(iVar14);\n        uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),local_80,local_7c);\n        uVar26 = __aeabi_dadd((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0x401c0000);\n        uVar13 = (undefined4)uVar26;\n        iVar14 = (int)((ulonglong)uVar26 >> 0x20) + -0x3400000;\n        goto LAB_0800852e;\n      }\n      if (0 < (int)local_38) {\n        uVar26 = __muldf3(local_80,local_7c,0,0x40240000);\n        uVar27 = __aeabi_i2d(iVar14 + 1);\n        uVar27 = __muldf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,\n                          (int)((ulonglong)uVar26 >> 0x20));\n        uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),0,0x401c0000);\n        uVar13 = (undefined4)uVar27;\n        local_48 = local_38;\n        local_34 = local_74 - 1;\n        iVar14 = (int)((ulonglong)uVar27 >> 0x20) + -0x3400000;\n        goto LAB_08007cfa;\n      }\n      goto LAB_08007e36;\n    }\n    uVar27 = __aeabi_i2d(iVar14);\n    uVar27 = __muldf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),local_80,local_7c);\n    uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),0,0x401c0000);\n    uVar13 = (undefined4)uVar27;\n    iVar14 = (int)((ulonglong)uVar27 >> 0x20) + -0x3400000;\n    if (local_68 != 0) {\n      local_34 = local_74;\n      local_48 = local_68;\nLAB_08007cfa:\n      local_7c = (uint)((ulonglong)uVar26 >> 0x20);\n      local_80 = (uint)uVar26;\n      cVar4 = __aeabi_d2iz(local_80,local_7c);\n      cVar4 = cVar4 + '0';\n      uVar16 = (&DAT_08009fa0)[local_48 * 2];\n      uVar12 = (&DAT_08009fa4)[local_48 * 2];\n      uVar26 = __aeabi_i2d();\n      uVar26 = __subdf3(local_80,local_7c,(int)uVar26,(int)((ulonglong)uVar26 >> 0x20));\n      uVar23 = (undefined4)((ulonglong)uVar26 >> 0x20);\n      pcVar21 = pcVar10 + 1;\n      if (bVar3) {\n        uVar27 = __divdf3(0,0x3fe00000,uVar16,uVar12);\n        uVar27 = __subdf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),uVar13,iVar14);\n        uVar13 = (undefined4)((ulonglong)uVar27 >> 0x20);\n        *pcVar10 = cVar4;\n        iVar14 = __aeabi_dcmpgt((int)uVar27,uVar13,(int)uVar26,uVar23);\n        if (iVar14 != 0) {\nLAB_08008784:\n          local_74 = local_34;\n          goto LAB_08008294;\n        }\n        uVar28 = __subdf3(0,0x3ff00000,(int)uVar26,uVar23);\n        iVar14 = __aeabi_dcmpgt((int)uVar27,uVar13,(int)uVar28,(int)((ulonglong)uVar28 >> 0x20));\n        if (iVar14 == 0) {\n          if (local_48 != 1) {\n            pcVar20 = pcVar21;\n            do {\n              uVar27 = __muldf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),0,0x40240000);\n              uVar13 = (undefined4)((ulonglong)uVar27 >> 0x20);\n              uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0x40240000);\n              cVar4 = __aeabi_d2iz();\n              uVar28 = __aeabi_i2d();\n              uVar26 = __subdf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),(int)uVar28,\n                                (int)((ulonglong)uVar28 >> 0x20));\n              uVar16 = (undefined4)((ulonglong)uVar26 >> 0x20);\n              cVar4 = cVar4 + '0';\n              pcVar21 = pcVar20 + 1;\n              *pcVar20 = cVar4;\n              iVar14 = __aeabi_dcmplt((int)uVar26,uVar16,(int)uVar27,uVar13);\n              if (iVar14 != 0) {\n                local_74 = local_34;\n                goto LAB_08008294;\n              }\n              uVar28 = __subdf3(0,0x3ff00000,(int)uVar26,uVar16);\n              iVar14 = __aeabi_dcmplt((int)uVar28,(int)((ulonglong)uVar28 >> 0x20),(int)uVar27,\n                                      uVar13);\n              if (iVar14 != 0) goto LAB_08008798;\n              pcVar20 = pcVar21;\n            } while (pcVar21 != pcVar10 + local_48);\n          }\n          goto LAB_08007e36;\n        }\nLAB_08008798:\n        local_74 = local_34;\n      }\n      else {\n        uVar27 = __muldf3(uVar13,iVar14,uVar16,uVar12);\n        uVar13 = (undefined4)((ulonglong)uVar27 >> 0x20);\n        *pcVar10 = cVar4;\n        if (local_48 != 1) {\n          pcVar20 = pcVar21;\n          do {\n            uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0x40240000);\n            cVar4 = __aeabi_d2iz();\n            uVar28 = __aeabi_i2d();\n            uVar26 = __subdf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),(int)uVar28,\n                              (int)((ulonglong)uVar28 >> 0x20));\n            pcVar21 = pcVar20 + 1;\n            *pcVar20 = cVar4 + '0';\n            pcVar20 = pcVar21;\n          } while (pcVar21 != pcVar10 + local_48);\n        }\n        uVar16 = (undefined4)((ulonglong)uVar26 >> 0x20);\n        uVar28 = __aeabi_dadd((int)uVar27,uVar13,0,0x3fe00000);\n        iVar14 = __aeabi_dcmplt((int)uVar28,(int)((ulonglong)uVar28 >> 0x20),(int)uVar26,uVar16);\n        if (iVar14 == 0) {\n          uVar27 = __subdf3(0,0x3fe00000,(int)uVar27,uVar13);\n          iVar14 = __aeabi_dcmpgt((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,uVar16);\n          pcVar20 = pcVar21;\n          if (iVar14 == 0) goto LAB_08007e36;\n          do {\n            pcVar21 = pcVar20;\n            pcVar20 = pcVar21 + -1;\n          } while (pcVar21[-1] == '0');\n          goto LAB_08008784;\n        }\n        local_74 = local_34;\n        cVar4 = pcVar21[-1];\n      }\n      goto LAB_08007f7c;\n    }\nLAB_0800852e:\n    uVar26 = __subdf3(local_80,local_7c,0,0x40140000);\n    uVar16 = (undefined4)((ulonglong)uVar26 >> 0x20);\n    iVar19 = __aeabi_dcmpgt((int)uVar26,uVar16,uVar13,iVar14);\n    if (iVar19 == 0) {\n      iVar14 = __aeabi_dcmplt((int)uVar26,uVar16,uVar13,iVar14 + -0x80000000);\n      if (iVar14 == 0) goto LAB_08007e36;\n      iVar19 = 0;\n      iVar14 = 0;\n      pcVar21 = pcVar10;\n      goto LAB_080084f0;\n    }\n    iVar15 = 0;\n    iVar7 = 0;\nLAB_08008406:\n    *pcVar10 = '1';\n    local_74 = local_74 + 1;\n    pcVar21 = pcVar10 + 1;\n    iVar19 = iVar7;\n    iVar14 = iVar15;\nLAB_08008416:\n    _Bfree(number,iVar14);\n    if (iVar19 == 0) goto LAB_08008294;\n  }\n  else {\nLAB_08007e36:\n    pcVar21 = pcVar10;\n    if ((-1 < local_2c[0]) && ((int)local_74 < 0xf)) {\n      uVar13 = *(undefined4 *)(&__mprec_tens + local_74 * 8);\n      uVar16 = *(undefined4 *)(&DAT_08009fac + local_74 * 8);\n      if ((-1 < (int)minFractionalDigits) || (0 < (int)local_68)) {\n        __divdf3(integerPart,uVar17,uVar13,uVar16);\n        bVar5 = __aeabi_d2iz();\n        uVar26 = __aeabi_i2d();\n        uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),uVar13,uVar16);\n        uVar26 = __subdf3(integerPart,uVar17,(int)uVar26,(int)((ulonglong)uVar26 >> 0x20));\n        *pcVar10 = bVar5 + 0x30;\n        pcVar21 = pcVar10 + 1;\n        if (local_68 != 1) {\n          uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0x40240000);\n          iVar14 = __aeabi_dcmpeq((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0);\n          while (iVar14 == 0) {\n            uVar23 = (undefined4)((ulonglong)uVar26 >> 0x20);\n            __divdf3((int)uVar26,uVar23,uVar13,uVar16);\n            bVar5 = __aeabi_d2iz();\n            uVar27 = __aeabi_i2d();\n            uVar27 = __muldf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),uVar13,uVar16);\n            uVar26 = __subdf3((int)uVar26,uVar23,(int)uVar27,(int)((ulonglong)uVar27 >> 0x20));\n            pcVar20 = pcVar21 + 1;\n            *pcVar21 = bVar5 + 0x30;\n            pcVar21 = pcVar20;\n            if (local_68 == (int)pcVar20 - (int)pcVar10) goto LAB_08007f3a;\n            uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0x40240000);\n            iVar14 = __aeabi_dcmpeq((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0);\n          }\n          goto LAB_08008294;\n        }\nLAB_08007f3a:\n        uVar26 = __aeabi_dadd((int)uVar26,(int)((ulonglong)uVar26 >> 0x20));\n        uVar23 = (undefined4)((ulonglong)uVar26 >> 0x20);\n        iVar14 = __aeabi_dcmpgt((int)uVar26,uVar23,uVar13,uVar16);\n        if ((iVar14 == 0) &&\n           ((iVar14 = __aeabi_dcmpeq((int)uVar26,uVar23,uVar13,uVar16), iVar14 == 0 ||\n            ((bVar5 & 1) == 0)))) goto LAB_08008294;\n        cVar4 = pcVar21[-1];\nLAB_08007f7c:\n        while (pcVar20 = pcVar21 + -1, cVar4 == '9') {\n          if (pcVar10 == pcVar20) {\n            *pcVar10 = '0';\n            cVar4 = pcVar21[-1];\n            local_74 = local_74 + 1;\n            pcVar20 = pcVar10;\n            break;\n          }\n          cVar4 = pcVar21[-2];\n          pcVar21 = pcVar20;\n        }\n        *pcVar20 = cVar4 + '\\x01';\n        goto LAB_08008294;\n      }\n      if (local_68 == 0) {\n        uVar26 = __muldf3(uVar13,uVar16,0,0x40140000);\n        iVar9 = __aeabi_dcmpge((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),integerPart,uVar17);\n        iVar19 = 0;\n        iVar15 = 0;\n        iVar7 = 0;\n        iVar14 = 0;\n        if (iVar9 == 0) goto LAB_08008406;\n      }\n      else {\n        iVar19 = 0;\n        iVar14 = 0;\n      }\nLAB_080084f0:\n      local_74 = ~minFractionalDigits;\n      pcVar10 = pcVar21;\n      goto LAB_08008416;\n    }\n    iVar14 = local_5c;\n    if (bVar3) {\n      if ((int)minIntegerDigits < 2) {\n        if (bVar25) {\n          local_60 = local_70;\n          local_70 = local_70 + local_2c[0] + 0x433;\n          iVar15 = iVar15 + local_2c[0] + 0x433;\n        }\n        else {\n          local_60 = local_70;\n          local_70 = local_70 + (0x36 - local_30);\n          iVar15 = iVar15 + (0x36 - local_30);\n        }\n      }\n      else {\n        iVar19 = local_68 - 1;\n        if (local_5c < iVar19) {\n          local_58 = local_58 + (iVar19 - local_5c);\n          iVar14 = 0;\n          local_5c = iVar19;\n        }\n        else {\n          iVar14 = local_5c - iVar19;\n        }\n        if ((int)local_68 < 0) {\n          local_60 = local_70 - local_68;\n        }\n        else {\n          iVar15 = iVar15 + local_68;\n          local_60 = local_70;\n          local_70 = local_70 + local_68;\n        }\n      }\n      iVar19 = __i2b(number,1);\n    }\n    else {\n      local_60 = local_70;\n      iVar19 = 0;\n    }\n    if ((0 < local_60) && (0 < iVar15)) {\n      iVar7 = local_60;\n      if (iVar15 <= local_60) {\n        iVar7 = iVar15;\n      }\n      iVar15 = iVar15 - iVar7;\n      local_70 = local_70 - iVar7;\n      local_60 = local_60 - iVar7;\n    }\n    if (local_5c != 0) {\n      if (bVar3) {\n        uVar13 = uVar6;\n        if (iVar14 != 0) {\n          iVar19 = __pow5mult(number,iVar19,iVar14);\n          uVar13 = __multiply(number,iVar19,uVar6);\n          _Bfree(number,uVar6);\n          uVar6 = uVar13;\n          if (local_5c - iVar14 == 0) goto LAB_08008062;\n        }\n        uVar6 = __pow5mult(number,uVar13,local_5c - iVar14);\n      }\n      else {\n        uVar6 = __pow5mult(number,uVar6,local_5c);\n      }\n    }\nLAB_08008062:\n    iVar14 = __i2b(number,1);\n    if (local_58 == 0) {\n      if (((int)minIntegerDigits < 2) && (integerPart == 0)) {\nLAB_0800835a:\n        if ((uVar17 & 0xfffff) == 0) {\n          uVar17 = uVar17 & 0x7ff00000;\n          if (uVar17 != 0) {\n            iVar15 = iVar15 + 1;\n            local_70 = local_70 + 1;\n            uVar17 = 1;\n          }\n        }\n        else {\n          uVar17 = 0;\n        }\n        bVar25 = local_58 != 0;\n        uVar18 = integerPart;\n        local_58 = uVar17;\n        if (bVar25) goto LAB_080082d4;\n      }\n      iVar7 = 1;\n    }\n    else {\n      uVar26 = __pow5mult(number,iVar14);\n      iVar14 = (int)uVar26;\n      if (((int)minIntegerDigits < 2) && (integerPart == 0)) goto LAB_0800835a;\n      local_58 = 0;\n      uVar18 = (uint)((ulonglong)uVar26 >> 0x20);\nLAB_080082d4:\n      iVar7 = __hi0bits(*(undefined4 *)(iVar14 + *(int *)(iVar14 + 0x10) * 4 + 0x10),uVar18);\n      iVar7 = 0x20 - iVar7;\n    }\n    uVar18 = iVar7 + iVar15 & 0x1f;\n    if (uVar18 == 0) {\n      iVar7 = 0x1c;\nLAB_08008096:\n      iVar15 = iVar15 + iVar7;\n      local_70 = local_70 + iVar7;\n      local_60 = local_60 + iVar7;\n    }\n    else {\n      if (4 < (int)(0x20 - uVar18)) {\n        iVar7 = 0x1c - uVar18;\n        goto LAB_08008096;\n      }\n      if (0x20 - uVar18 != 4) {\n        iVar7 = 0x3c - uVar18;\n        goto LAB_08008096;\n      }\n    }\n    if (0 < local_70) {\n      uVar6 = __lshift(number,uVar6,local_70);\n    }\n    if (0 < iVar15) {\n      iVar14 = __lshift(number,iVar14,iVar15);\n    }\n    pcVar20 = pcVar10;\n    if ((bVar2) && (iVar15 = __mcmp(uVar6,iVar14), iVar15 < 0)) {\n      local_74 = local_74 - 1;\n      uVar6 = __multadd(number,uVar6,10,0);\n      if (bVar3) {\n        iVar19 = __multadd(number,iVar19,10,0);\n        if ((0 < (int)local_38) || ((int)minIntegerDigits < 3)) {\n          local_68 = local_38;\n          goto LAB_080080de;\n        }\n      }\n      else if ((0 < (int)local_38) || ((int)minIntegerDigits < 3)) {\n        local_68 = local_38;\n        goto LAB_0800820a;\n      }\n      local_68 = local_38;\nLAB_080084e8:\n      if (local_68 == 0) {\n        iVar15 = __multadd(number,iVar14,5);\n        iVar9 = __mcmp(uVar6,iVar15);\n        iVar7 = iVar19;\n        iVar14 = iVar15;\n        if (0 < iVar9) goto LAB_08008406;\n      }\n      goto LAB_080084f0;\n    }\n    if (((int)local_68 < 1) && (2 < (int)minIntegerDigits)) goto LAB_080084e8;\n    if (bVar3) {\nLAB_080080de:\n      local_80 = iVar19;\n      if (0 < local_60) {\n        local_80 = __lshift(number,iVar19,local_60);\n      }\n      iVar19 = local_80;\n      if (local_58 != 0) {\n        iVar19 = _Balloc(number,*(undefined4 *)(local_80 + 4));\n        memcpy((void *)(iVar19 + 0xc),(void *)(local_80 + 0xc),(*(int *)(local_80 + 0x10) + 2) * 4);\n        iVar19 = __lshift(number,iVar19,1);\n      }\nLAB_08008108:\n      iVar15 = quorem(uVar6,iVar14);\n      iVar7 = __mcmp(uVar6,local_80);\n      iVar9 = __mdiff(number,iVar14,iVar19);\n      iVar24 = iVar15 + 0x30;\n      if (*(int *)(iVar9 + 0xc) == 0) {\n        iVar8 = __mcmp(uVar6);\n        _Bfree(number,iVar9);\n        if ((iVar8 != 0) || (minIntegerDigits != 0)) goto LAB_0800815a;\n        if ((integerPart & 1) != 0) {\n          iVar8 = 0;\n          goto LAB_0800815a;\n        }\n        if (iVar24 != 0x39) {\n          if (0 < iVar7) goto LAB_0800874c;\n          goto LAB_080085a4;\n        }\nLAB_08008752:\n        pcVar21 = pcVar20 + 1;\n        cVar4 = '9';\n        *pcVar20 = '9';\n        goto LAB_08008268;\n      }\n      _Bfree(number,iVar9);\n      iVar8 = 1;\nLAB_0800815a:\n      if ((iVar7 < 0) || (((iVar7 == 0 && (minIntegerDigits == 0)) && ((integerPart & 1) == 0)))) {\n        if (0 < iVar8) {\n          uVar6 = __lshift(number,uVar6,1);\n          iVar7 = __mcmp(uVar6,iVar14);\n          if ((0 < iVar7) || ((iVar7 == 0 && (iVar15 << 0x1f < 0)))) {\n            if (iVar24 == 0x39) goto LAB_08008752;\nLAB_0800874c:\n            iVar24 = iVar15 + 0x31;\n          }\n        }\nLAB_080085a4:\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)iVar24;\n        goto LAB_08008274;\n      }\n      pcVar21 = pcVar20 + 1;\n      if (0 < iVar8) {\n        if (iVar24 == 0x39) goto LAB_08008752;\n        *pcVar20 = (char)iVar15 + '1';\n        goto LAB_08008274;\n      }\n      *pcVar20 = (char)iVar24;\n      if (pcVar10 + (local_68 - 1) != pcVar20) {\n        uVar6 = __multadd(number,uVar6,10,0);\n        pcVar20 = pcVar21;\n        if (local_80 == iVar19) {\n          local_80 = __multadd(number,local_80,10,0);\n          iVar19 = local_80;\n        }\n        else {\n          local_80 = __multadd(number,local_80,10,0);\n          iVar19 = __multadd(number,iVar19,10,0);\n        }\n        goto LAB_08008108;\n      }\n    }\n    else {\nLAB_0800820a:\n      while( true ) {\n        iVar24 = quorem(uVar6,iVar14);\n        iVar24 = iVar24 + 0x30;\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)iVar24;\n        if ((int)local_68 <= (int)pcVar21 - (int)pcVar10) break;\n        uVar6 = __multadd(number,uVar6,10,0);\n        pcVar20 = pcVar21;\n      }\n      local_80 = 0;\n    }\n    uVar6 = __lshift(number,uVar6,1);\n    iVar15 = __mcmp(uVar6,iVar14);\n    cVar4 = pcVar21[-1];\n    if ((0 < iVar15) || ((iVar15 == 0 && (iVar24 << 0x1f < 0)))) {\nLAB_08008268:\n      do {\n        pcVar20 = pcVar21 + -1;\n        if (cVar4 != '9') goto code_r0x08008270;\n        if (pcVar10 == pcVar20) {\n          *pcVar10 = '1';\n          local_74 = local_74 + 1;\n          goto LAB_08008274;\n        }\n        cVar4 = pcVar21[-2];\n        pcVar21 = pcVar20;\n      } while( true );\n    }\n    while (cVar4 == '0') {\n      cVar4 = pcVar21[-2];\n      pcVar21 = pcVar21 + -1;\n    }\nLAB_08008274:\n    _Bfree(number,iVar14);\n    if (iVar19 == 0) goto LAB_08008294;\n    if ((local_80 != 0) && (local_80 != iVar19)) {\n      _Bfree(number);\n    }\n  }\n  _Bfree(number,iVar19);\nLAB_08008294:\n  _Bfree(number,uVar6);\n  *pcVar21 = '\\0';\n  *formattedStringLength = local_74 + 1;\n  if (formattedString == (char **)0x0) {\n    return pcVar10;\n  }\n  *formattedString = pcVar21;\n  return pcVar10;\ncode_r0x08008270:\n  *pcVar20 = cVar4 + '\\x01';\n  goto LAB_08008274;\n}\n\n",
            "renaming": {
                "FUN_080079e8": "format_number_to_string_080079e8",
                "param_1": "number",
                "param_3": "integerPart",
                "param_4": "fractionalPart",
                "param_5": "minIntegerDigits",
                "param_6": "minFractionalDigits",
                "param_7": "formattedStringLength",
                "param_8": "isNegative",
                "param_9": "formattedString"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_dcmpgt",
                "__multiply",
                "__aeabi_dcmpge",
                "__d2b",
                "quorem",
                "__hi0bits",
                "__aeabi_dcmpeq",
                "__aeabi_dadd",
                "__multadd",
                "__i2b",
                "__floatunsidf",
                "memcpy",
                "__aeabi_dcmplt",
                "__subdf3",
                "__aeabi_i2d",
                "__lshift",
                "__mdiff",
                "__muldf3",
                "__aeabi_d2iz",
                "_Bfree",
                "_Balloc",
                "__mcmp",
                "__pow5mult",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008818": {
            "entrypoint": "0x08008818",
            "current_name": "execute_global_destructors_08008818",
            "code": "\nvoid execute_global_destructors_08008818(void)\n\n{\n  int loop_counter;\n  code **ptr_to_destructor;\n  \n  loop_counter = 1;\n  ptr_to_destructor = (code **)&ptr_to_global_dtors_aux_fini_array_entry;\n  do {\n    loop_counter = loop_counter + -1;\n    (**ptr_to_destructor)();\n    ptr_to_destructor = ptr_to_destructor + -1;\n  } while (loop_counter != 0);\n  _fini();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008818": "execute_global_destructors_08008818",
                "iVar1": "loop_counter",
                "ppcVar2": "ptr_to_destructor",
                "__do_global_dtors_aux_fini_array_entry": "ptr_to_global_dtors_aux_fini_array_entry"
            },
            "calling": [],
            "called": [
                "_fini",
                "__do_global_dtors_aux",
                "frame_dummy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800884c": {
            "entrypoint": "0x0800884c",
            "current_name": "allocate_memory_0800884c",
            "code": "\nundefined4 allocateMemory_0800884c(undefined4 param,int size)\n\n{\n  int allocatedAddress;\n  int newBlockAddress;\n  uint currentBlock;\n  \n  lockMemoryAllocation();\n  currentBlock = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  newBlockAddress = ((0xfef - size) + currentBlock & 0xfffff000) - 0x1000;\n  if (0xfff < newBlockAddress) {\n    allocatedAddress = adjustHeapAllocation(param,0);\n    if (allocatedAddress == DAT_20000454 + currentBlock) {\n      allocatedAddress = adjustHeapAllocation(param,-newBlockAddress);\n      if (allocatedAddress != -1) {\n        currentAllocationInfo = currentAllocationInfo - newBlockAddress;\n        *(uint *)(DAT_20000454 + 4) = currentBlock - newBlockAddress | 1;\n        unlockMemoryAllocation(param);\n        return 1;\n      }\n      newBlockAddress = adjustHeapAllocation(param,0);\n      if (0xf < newBlockAddress - DAT_20000454) {\n        currentAllocationInfo = newBlockAddress - heapBase;\n        *(uint *)(DAT_20000454 + 4) = newBlockAddress - DAT_20000454 | 1;\n      }\n    }\n  }\n  unlockMemoryAllocation(param);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800884c": "allocate_memory_0800884c",
                "param_1": "param",
                "param_2": "size",
                "iVar1": "allocatedAddress",
                "iVar2": "newBlockAddress",
                "uVar3": "currentBlock",
                "__malloc_lock": "lockMemoryAllocation",
                "_sbrk_r": "adjustHeapAllocation",
                "__malloc_current_mallinfo": "currentAllocationInfo",
                "__malloc_unlock": "unlockMemoryAllocation",
                "__malloc_sbrk_base": "heapBase"
            },
            "calling": [
                "_free_r"
            ],
            "called": [
                "_sbrk_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080088ec": {
            "entrypoint": "0x080088ec",
            "current_name": "trim_and_unlock_memory_080088ec",
            "code": "\nvoid trimAndUnlockMemory_080088ec(undefined4 memory_lock_flag,int memory_address,undefined4 param_3,undefined4 param_4)\n\n{\n  int index;\n  uint *current_ptr;\n  uint *next_ptr;\n  undefined *temp_ptr;\n  uint total_size;\n  uint chunk_size;\n  undefined *first_ptr;\n  undefined *last_ptr;\n  undefined4 *ptr_to_dat_20000454;\n  int size_index;\n  uint tag;\n  uint another_temp;\n  \n  if (memory_address == 0) {\n    return;\n  }\n  __malloc_lock();\n  tag = *(uint *)(memory_address + -4);\n  current_ptr = (uint *)(memory_address + -8);\n  total_size = tag & 0xfffffffe;\n  next_ptr = (uint *)((int)current_ptr + total_size);\n  chunk_size = next_ptr[1] & 0xfffffffc;\n  if (DAT_20000454 == next_ptr) {\n    total_size = total_size + chunk_size;\n    if ((tag & 1) == 0) {\n      current_ptr = (uint *)((int)current_ptr - *(int *)(memory_address + -8));\n      chunk_size = current_ptr[2];\n      tag = current_ptr[3];\n      total_size = total_size + *(int *)(memory_address + -8);\n      *(uint *)(chunk_size + 0xc) = tag;\n      *(uint *)(tag + 8) = chunk_size;\n    }\n    chunk_size = __malloc_trim_threshold;\n    current_ptr[1] = total_size | 1;\n    DAT_20000454 = current_ptr;\n    if (chunk_size <= total_size) {\n      _malloc_trim_r(memory_lock_flag,__malloc_top_pad);\n    }\nLAB_080089f0:\n    __malloc_unlock(memory_lock_flag);\n    return;\n  }\n  next_ptr[1] = chunk_size;\n  if ((tag & 1) == 0) {\n    current_ptr = (uint *)((int)current_ptr - *(int *)(memory_address + -8));\n    ptr_to_dat_20000454 = (undefined4 *)current_ptr[2];\n    total_size = total_size + *(int *)(memory_address + -8);\n    tag = *(uint *)((int)next_ptr + chunk_size + 4) & 1;\n    if ((uint **)ptr_to_dat_20000454 == &DAT_20000454) {\n      if (tag == 0) {\n        tag = next_ptr[2];\n        another_temp = next_ptr[3];\n        total_size = total_size + chunk_size;\n        *(uint *)(tag + 0xc) = another_temp;\n        *(uint *)(another_temp + 8) = tag;\n        current_ptr[1] = total_size | 1;\n        *(uint *)((int)current_ptr + total_size) = total_size;\n      }\n      else {\n        current_ptr[1] = total_size | 1;\n        *next_ptr = total_size;\n      }\n      goto LAB_080089f0;\n    }\n    another_temp = current_ptr[3];\n    ptr_to_dat_20000454[3] = another_temp;\n    *(undefined4 **)(another_temp + 8) = ptr_to_dat_20000454;\n  }\n  else {\n    tag = *(uint *)((int)next_ptr + chunk_size + 4) & 1;\n  }\n  if (tag == 0) {\n    ptr_to_dat_20000454 = (undefined4 *)next_ptr[2];\n    total_size = total_size + chunk_size;\n    if ((uint **)ptr_to_dat_20000454 == &DAT_20000454) {\n      DAT_2000045c = current_ptr;\n      DAT_20000460 = current_ptr;\n      current_ptr[2] = (uint)&DAT_20000454;\n      current_ptr[3] = (uint)&DAT_20000454;\n      current_ptr[1] = total_size | 1;\n      *(uint *)((int)current_ptr + total_size) = total_size;\n      goto LAB_080089f0;\n    }\n    chunk_size = next_ptr[3];\n    ptr_to_dat_20000454[3] = chunk_size;\n    *(undefined4 **)(chunk_size + 8) = ptr_to_dat_20000454;\n    current_ptr[1] = total_size | 1;\n    *(uint *)((int)current_ptr + total_size) = total_size;\n  }\n  else {\n    current_ptr[1] = total_size | 1;\n    *(uint *)((int)current_ptr + total_size) = total_size;\n  }\n  if (total_size < 0x200) {\n    size_index = (total_size >> 3) + 1;\n    total_size = 1 << ((int)(total_size >> 3) >> 2 & 0xffU) | (uint)DAT_20000450;\n    chunk_size = *(uint *)(&__malloc_av_ + size_index * 8);\n    current_ptr[2] = chunk_size;\n    current_ptr[3] = (uint)(&DAT_20000444 + size_index * 8);\n    DAT_20000450 = (undefined *)total_size;\n    *(uint **)(&__malloc_av_ + size_index * 8) = current_ptr;\n    *(uint **)(chunk_size + 0xc) = current_ptr;\n    __malloc_unlock(memory_lock_flag,current_ptr,total_size,param_4);\n    return;\n  }\n  chunk_size = total_size >> 9;\n  if (chunk_size < 5) {\n    size_index = ((total_size >> 6) + 0x39) * 8;\n    index = (total_size >> 6) + 0x38;\n  }\n  else if (chunk_size < 0x15) {\n    size_index = (chunk_size + 0x5c) * 8;\n    index = chunk_size + 0x5b;\n  }\n  else if (chunk_size < 0x55) {\n    size_index = ((total_size >> 0xc) + 0x6f) * 8;\n    index = (total_size >> 0xc) + 0x6e;\n  }\n  else if (chunk_size < 0x155) {\n    size_index = ((total_size >> 0xf) + 0x78) * 8;\n    index = (total_size >> 0xf) + 0x77;\n  }\n  else if (chunk_size < 0x555) {\n    size_index = ((total_size >> 0x12) + 0x7d) * 8;\n    index = (total_size >> 0x12) + 0x7c;\n  }\n  else {\n    size_index = 0x3f8;\n    index = 0x7e;\n  }\n  temp_ptr = *(undefined **)(&__malloc_av_ + size_index);\n  first_ptr = &DAT_20000444 + size_index;\n  if (first_ptr == temp_ptr) {\n    temp_ptr = (undefined *)(1 << (index >> 2 & 0xffU) | (uint)DAT_20000450);\n    last_ptr = first_ptr;\n    DAT_20000450 = temp_ptr;\n  }\n  else {\n    do {\n      last_ptr = temp_ptr;\n      if ((*(uint *)(temp_ptr + 4) & 0xfffffffc) <= total_size) break;\n      temp_ptr = *(undefined **)(temp_ptr + 8);\n      last_ptr = first_ptr;\n    } while (first_ptr != temp_ptr);\n    first_ptr = *(undefined **)(last_ptr + 0xc);\n  }\n  current_ptr[2] = (uint)last_ptr;\n  current_ptr[3] = (uint)first_ptr;\n  *(uint **)(first_ptr + 8) = current_ptr;\n  *(uint **)(last_ptr + 0xc) = current_ptr;\n  __malloc_unlock(memory_lock_flag,current_ptr,temp_ptr,param_4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080088ec": "trim_and_unlock_memory_080088ec",
                "param_1": "memory_lock_flag",
                "param_2": "memory_address",
                "iVar1": "index",
                "puVar2": "current_ptr",
                "puVar3": "next_ptr",
                "puVar4": "temp_ptr",
                "uVar5": "total_size",
                "uVar6": "chunk_size",
                "puVar7": "first_ptr",
                "puVar8": "last_ptr",
                "puVar9": "ptr_to_dat_20000454",
                "iVar10": "size_index",
                "uVar11": "tag",
                "uVar12": "another_temp"
            },
            "calling": [
                "__ssprint_r",
                "_svfprintf_r",
                "_malloc_r",
                "_realloc_r"
            ],
            "called": [
                "__malloc_unlock",
                "_malloc_trim_r",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ad4": {
            "entrypoint": "0x08008ad4",
            "current_name": "get_current_locale_08008ad4",
            "code": "\nundefined1 * get_current_locale_08008ad4(void)\n\n{\n  undefined1 *current_locale_ptr;\n  \n  current_locale_ptr = *(undefined1 **)(ptr_to_impure_data + 0x34);\n  if (current_locale_ptr == (undefined1 *)0x0) {\n    current_locale_ptr = global_locale_address;\n  }\n  return current_locale_ptr + 0xf0;\n}\n\n",
            "renaming": {
                "FUN_08008ad4": "get_current_locale_08008ad4",
                "puVar1": "current_locale_ptr",
                "_impure_ptr": "ptr_to_impure_data",
                "&__global_locale": "global_locale_address"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008af0": {
            "entrypoint": "0x08008af0",
            "current_name": "FUNC_08008af0",
            "code": "\nvoid FUNC_08008af0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af0": "FUNC_08008af0"
            },
            "calling": [
                "__register_exitproc",
                "__malloc_lock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af4": {
            "entrypoint": "0x08008af4",
            "current_name": "FUNC_08008af4",
            "code": "\nvoid FUNC_08008af4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af4": "FUNC_08008af4"
            },
            "calling": [
                "__register_exitproc",
                "__malloc_unlock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af8": {
            "entrypoint": "0x08008af8",
            "current_name": "allocate_memory_08008af8",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocate_memory_08008af8(undefined4 *base_ptr,uint size)\n\n{\n  undefined1 *ptr1;\n  undefined1 *ptr2;\n  uint var3;\n  uint var4;\n  int var5;\n  undefined *ptr6;\n  uint var7;\n  uint var8;\n  undefined4 *ptr9;\n  undefined1 *ptr10;\n  undefined *ptr11;\n  int *result_ptr;\n  uint var13;\n  uint var14;\n  int var15;\n  undefined4 *ptr16;\n  undefined1 *ptr17;\n  undefined4 *ptr18;\n  \n  var13 = size + 0xb;\n  if (var13 < 0x17) {\n    if (0x10 < size) goto LAB_08008c7a;\n    __malloc_lock();\n    var14 = 0x10;\n    var5 = 0x18;\n    var13 = 2;\nLAB_08008b18:\n    ptr11 = *(undefined **)((int)&DAT_20000450 + var5);\n    if ((ptr11 != &DAT_20000444 + var5) ||\n       (ptr11 = *(undefined **)((int)&DAT_20000458 + var5), &__malloc_av_ + var5 != ptr11)) {\n      var5 = *(int *)(ptr11 + 0xc);\n      ptr6 = ptr11 + (*(uint *)(ptr11 + 4) & 0xfffffffc);\n      var13 = *(uint *)(ptr6 + 4);\nLAB_08008b34:\n      var15 = *(int *)(ptr11 + 8);\n      *(int *)(var15 + 0xc) = var5;\n      *(int *)(var5 + 8) = var15;\n      *(uint *)(ptr6 + 4) = var13 | 1;\n      __malloc_unlock(base_ptr);\n      return (int *)(ptr11 + 8);\n    }\n    var13 = var13 + 2;\n  }\n  else {\n    var14 = var13 & 0xfffffff8;\n    if (((int)var14 < 0) || (var14 < size)) {\nLAB_08008c7a:\n      *base_ptr = 0xc;\n      return (int *)0x0;\n    }\n    __malloc_lock();\n    if (var14 < 0x1f8) {\n      var13 = var13 >> 3;\n      var5 = var14 + 8;\n      goto LAB_08008b18;\n    }\n    var3 = var13 >> 9;\n    if (var3 == 0) {\n      var5 = 0x200;\n      var7 = 0x40;\n      var3 = 0x3f;\n    }\n    else if (var3 < 5) {\n      var7 = (var13 >> 6) + 0x39;\n      var3 = (var13 >> 6) + 0x38;\n      var5 = var7 * 8;\n    }\n    else if (var3 < 0x15) {\n      var7 = var3 + 0x5c;\n      var3 = var3 + 0x5b;\n      var5 = var7 * 8;\n    }\n    else if (var3 < 0x55) {\n      var7 = (var13 >> 0xc) + 0x6f;\n      var3 = (var13 >> 0xc) + 0x6e;\n      var5 = var7 * 8;\n    }\n    else if (var3 < 0x155) {\n      var7 = (var13 >> 0xf) + 0x78;\n      var3 = (var13 >> 0xf) + 0x77;\n      var5 = var7 * 8;\n    }\n    else if (var3 < 0x555) {\n      var7 = (var13 >> 0x12) + 0x7d;\n      var3 = (var13 >> 0x12) + 0x7c;\n      var5 = var7 * 8;\n    }\n    else {\n      var5 = 0x3f8;\n      var7 = 0x7f;\n      var3 = 0x7e;\n    }\n    for (ptr11 = *(undefined **)((int)&DAT_20000450 + var5); var13 = var7,\n        &DAT_20000444 + var5 != ptr11; ptr11 = *(undefined **)(ptr11 + 0xc)) {\n      var15 = (*(uint *)(ptr11 + 4) & 0xfffffffc) - var14;\n      var13 = var3;\n      if (0xf < var15) break;\n      if (-1 < var15) {\n        ptr6 = ptr11 + (*(uint *)(ptr11 + 4) & 0xfffffffc);\n        var13 = *(uint *)(ptr6 + 4);\n        var5 = *(int *)(ptr11 + 0xc);\n        goto LAB_08008b34;\n      }\n    }\n  }\n  ptr16 = DAT_2000045c;\n  if ((undefined1 **)DAT_2000045c == &DAT_20000454) {\n    var7 = 1 << ((int)var13 >> 2 & 0xffU);\n    var3 = DAT_20000450;\n    if (var7 <= DAT_20000450) goto LAB_08008c06;\n  }\n  else {\n    var7 = DAT_2000045c[1];\n    var8 = var7 & 0xfffffffc;\n    var3 = var8 - var14;\n    if (0xf < (int)var3) {\n      ptr18 = (undefined4 *)(var14 + (int)DAT_2000045c);\n      DAT_2000045c[1] = var14 | 1;\n      DAT_2000045c = ptr18;\n      DAT_20000460 = ptr18;\n      ptr18[2] = &DAT_20000454;\n      ptr18[3] = &DAT_20000454;\n      ptr18[1] = var3 | 1;\n      *(uint *)((int)ptr16 + var8) = var3;\n      __malloc_unlock(base_ptr);\n      return ptr16 + 2;\n    }\n    DAT_2000045c = &DAT_20000454;\n    DAT_20000460 = &DAT_20000454;\n    if (-1 < (int)var3) {\n      *(uint *)((int)ptr16 + var8 + 4) = *(uint *)((int)ptr16 + var8 + 4) | 1;\n      __malloc_unlock(base_ptr);\n      return ptr16 + 2;\n    }\n    if (var8 < 0x200) {\n      var5 = (var7 >> 3) + 1;\n      var15 = *(int *)(&__malloc_av_ + var5 * 8);\n      var3 = 1 << ((int)(var7 >> 3) >> 2 & 0xffU) | DAT_20000450;\n      ptr16[2] = var15;\n      ptr16[3] = &DAT_20000444 + var5 * 8;\n      DAT_20000450 = var3;\n      *(undefined4 **)(&__malloc_av_ + var5 * 8) = ptr16;\n      *(undefined4 **)(var15 + 0xc) = ptr16;\n    }\n    else {\n      var3 = var7 >> 9;\n      if (var3 < 5) {\n        var5 = ((var7 >> 6) + 0x39) * 8;\n        var15 = (var7 >> 6) + 0x38;\n      }\n      else if (var3 < 0x15) {\n        var5 = (var3 + 0x5c) * 8;\n        var15 = var3 + 0x5b;\n      }\n      else if (var3 < 0x55) {\n        var5 = ((var7 >> 0xc) + 0x6f) * 8;\n        var15 = (var7 >> 0xc) + 0x6e;\n      }\n      else if (var3 < 0x155) {\n        var5 = ((var7 >> 0xf) + 0x78) * 8;\n        var15 = (var7 >> 0xf) + 0x77;\n      }\n      else if (var3 < 0x555) {\n        var5 = ((var7 >> 0x12) + 0x7d) * 8;\n        var15 = (var7 >> 0x12) + 0x7c;\n      }\n      else {\n        var5 = 0x3f8;\n        var15 = 0x7e;\n      }\n      ptr11 = *(undefined **)(&__malloc_av_ + var5);\n      ptr6 = &DAT_20000444 + var5;\n      if (ptr6 == ptr11) {\n        DAT_20000450 = 1 << (var15 >> 2 & 0xffU) | DAT_20000450;\n      }\n      else {\n        do {\n          if ((*(uint *)(ptr11 + 4) & 0xfffffffc) <= var8) break;\n          ptr11 = *(undefined **)(ptr11 + 8);\n        } while (ptr6 != ptr11);\n        ptr6 = *(undefined **)(ptr11 + 0xc);\n      }\n      var3 = DAT_20000450;\n      ptr16[2] = ptr11;\n      ptr16[3] = ptr6;\n      *(undefined4 **)(ptr6 + 8) = ptr16;\n      *(undefined4 **)(ptr11 + 0xc) = ptr16;\n    }\n    var7 = 1 << ((int)var13 >> 2 & 0xffU);\n    if (var7 <= var3) {\nLAB_08008c06:\n      if ((var7 & var3) == 0) {\n        var13 = var13 & 0xfffffffc;\n        do {\n          var7 = var7 << 1;\n          var13 = var13 + 4;\n        } while ((var7 & var3) == 0);\n      }\n      do {\n        ptr18 = (undefined4 *)(&__malloc_av_ + var13 * 8);\n        var3 = var13;\n        ptr16 = ptr18;\n        do {\n          for (ptr9 = (undefined4 *)ptr16[3]; ptr16 != ptr9;\n              ptr9 = (undefined4 *)ptr9[3]) {\n            var8 = ptr9[1] & 0xfffffffc;\n            var4 = var8 - var14;\n            if (0xf < (int)var4) {\n              var15 = ptr9[2];\n              var5 = ptr9[3];\n              ptr16 = (undefined4 *)(var14 + (int)ptr9);\n              ptr9[1] = var14 | 1;\n              *(int *)(var15 + 0xc) = var5;\n              *(int *)(var5 + 8) = var15;\n              DAT_2000045c = ptr16;\n              DAT_20000460 = ptr16;\n              ptr16[2] = &DAT_20000454;\n              ptr16[3] = &DAT_20000454;\n              ptr16[1] = var4 | 1;\n              *(uint *)((int)ptr9 + var8) = var4;\n              __malloc_unlock(base_ptr);\n              return ptr9 + 2;\n            }\n            if (-1 < (int)var4) {\n              var5 = ptr9[3];\n              var15 = ptr9[2];\n              *(uint *)((int)ptr9 + var8 + 4) = *(uint *)((int)ptr9 + var8 + 4) | 1;\n              *(int *)(var15 + 0xc) = var5;\n              *(int *)(var5 + 8) = var15;\n              __malloc_unlock(base_ptr);\n              return ptr9 + 2;\n            }\n          }\n          var3 = var3 + 1;\n          ptr16 = ptr16 + 2;\n        } while ((var3 & 3) != 0);\n        do {\n          var8 = var13 & 3;\n          ptr16 = ptr18 + -2;\n          var13 = var13 - 1;\n          if (var8 == 0) {\n            DAT_20000450 = DAT_20000450 & ~var7;\n            break;\n          }\n          ptr18 = (undefined4 *)*ptr18;\n        } while (ptr18 == ptr16);\n        var7 = var7 * 2;\n        if ((DAT_20000450 <= var7 && var7 - DAT_20000450 != 0) || (var13 = var3, var7 == 0))\n        break;\n        for (; (var7 & DAT_20000450) == 0; var7 = var7 << 1) {\n          var13 = var13 + 4;\n        }\n      } while( true );\n    }\n  }\n  ptr17 = DAT_20000454;\n  var13 = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  if ((var14 <= var13) && (var3 = var13 - var14, 0xf < (int)var3)) goto LAB_08008dac;\n  if (__malloc_sbrk_base == (undefined1 *)0xffffffff) {\n    var3 = var14 + __malloc_top_pad + 0x10;\n  }\n  else {\n    var3 = var14 + __malloc_top_pad + 0x100f & 0xfffff000;\n  }\n  ptr1 = (undefined1 *)_sbrk_r(base_ptr,var3);\n  if (ptr1 == (undefined1 *)0xffffffff) {\nLAB_08008ed8:\n    var13 = *(uint *)(DAT_20000454 + 4);\n  }\n  else {\n    ptr2 = ptr17 + var13;\n    if (ptr2 < ptr1 || ptr2 == ptr1) {\n      ptr10 = __malloc_current_mallinfo + var3;\n      if ((ptr2 != ptr1) || (((uint)ptr2 & 0xfff) != 0)) goto LAB_08008d02;\n      __malloc_current_mallinfo = ptr10;\n      *(uint *)(DAT_20000454 + 4) = var13 + var3 | 1;\n    }\n    else {\n      if (ptr17 != &__malloc_av_) goto LAB_08008ed8;\nLAB_08008d02:\n      __malloc_current_mallinfo = __malloc_current_mallinfo + var3;\n      ptr10 = ptr1;\n      if (__malloc_sbrk_base != (undefined1 *)0xffffffff) {\n        __malloc_current_mallinfo = __malloc_current_mallinfo + ((int)ptr1 - (int)ptr2);\n        ptr10 = __malloc_sbrk_base;\n      }\n      __malloc_sbrk_base = ptr10;\n      var7 = (uint)ptr1 & 7;\n      if (var7 == 0) {\n        var5 = 0x1000;\n      }\n      else {\n        ptr1 = ptr1 + (8 - var7);\n        var5 = 0x1008 - var7;\n      }\n      var5 = var5 - ((uint)(ptr1 + var3) & 0xfff);\n      var15 = _sbrk_r(base_ptr,var5);\n      if (var15 == -1) {\n        var3 = 1;\n        var5 = 0;\n      }\n      else {\n        var3 = (var15 - (int)ptr1) + var5 | 1;\n      }\n      ptr10 = __malloc_current_mallinfo + var5;\n      DAT_20000454 = ptr1;\n      __malloc_current_mallinfo = ptr10;\n      *(uint *)(ptr1 + 4) = var3;\n      if (ptr17 != &__malloc_av_) {\n        if (var13 < 0x10) {\n          *(undefined4 *)(ptr1 + 4) = 1;\n          goto LAB_08008eee;\n        }\n        var13 = var13 - 0xc & 0xfffffff8;\n        *(uint *)(ptr17 + 4) = *(uint *)(ptr17 + 4) & 1 | var13;\n        *(undefined4 *)(ptr17 + var13 + 4) = 5;\n        *(undefined4 *)(ptr17 + var13 + 8) = 5;\n        if (0xf < var13) {\n          _free_r(base_ptr,ptr17 + 8);\n          ptr10 = __malloc_current_mallinfo;\n        }\n      }\n    }\n    if (__malloc_max_sbrked_mem < ptr10) {\n      __malloc_max_sbrked_mem = ptr10;\n    }\n    var13 = *(uint *)(DAT_20000454 + 4);\n    if (__malloc_max_total_mem < ptr10) {\n      __malloc_max_total_mem = ptr10;\n    }\n  }\n  var3 = (var13 & 0xfffffffc) - var14;\n  if ((var14 <= (var13 & 0xfffffffc)) && (0xf < (int)var3)) {\nLAB_08008dac:\n    ptr17 = DAT_20000454 + var14;\n    *(uint *)(DAT_20000454 + 4) = var14 | 1;\n    result_ptr = (int *)(DAT_20000454 + 8);\n    DAT_20000454 = ptr17;\n    *(uint *)(ptr17 + 4) = var3 | 1;\n    __malloc_unlock(base_ptr);\n    return result_ptr;\n  }\nLAB_08008eee:\n  __malloc_unlock(base_ptr);\n  return (int *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08008af8": "allocate_memory_08008af8",
                "param_1": "base_ptr",
                "param_2": "size",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "uVar3": "var3",
                "uVar4": "var4",
                "iVar5": "var5",
                "puVar6": "ptr6",
                "uVar7": "var7",
                "uVar8": "var8",
                "puVar9": "ptr9",
                "puVar10": "ptr10",
                "puVar11": "ptr11",
                "piVar12": "result_ptr",
                "uVar13": "var13",
                "uVar14": "var14",
                "iVar15": "var15",
                "puVar16": "ptr16",
                "puVar17": "ptr17",
                "puVar18": "ptr18"
            },
            "calling": [
                "__ssprint_r",
                "_svfprintf_r",
                "_realloc_r",
                "_calloc_r"
            ],
            "called": [
                "_free_r",
                "_sbrk_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800901c": {
            "entrypoint": "0x0800901c",
            "current_name": "find_byte_sequence_0800901c",
            "code": "\nvoid * find_byte_sequence_0800901c(void *data,int byte_to_find,size_t length)\n\n{\n  uint temp1;\n  uint temp2;\n  uint *ptr;\n  uint byte_mask;\n  bool is_match;\n  \n  byte_mask = byte_to_find & 0xff;\n  if (((uint)data & 3) == 0) {\nLAB_0800904a:\n    if (3 < length) {\n      temp2 = (byte_to_find & 0xffU) << 8 | byte_mask;\n      ptr = (uint *)data;\n      do {\n        temp1 = *ptr ^ (temp2 | temp2 << 0x10);\n        data = ptr + 1;\n        if ((temp1 + 0xfefefeff & ~temp1 & 0x80808080) != 0) goto LAB_08009050;\n        length = length - 4;\n        ptr = (uint *)data;\n      } while (3 < length);\n    }\n    ptr = (uint *)data;\n    if (length == 0) {\n      data = (uint *)0x0;\n    }\n    else {\nLAB_08009050:\n      data = ptr;\n                    /* WARNING: Load size is inaccurate */\n      if (*data != byte_mask) {\n        ptr = (uint *)(length + (int)data);\n        do {\n          data = (void *)((int)data + 1);\n          if (ptr == (uint *)data) goto LAB_0800906c;\n                    /* WARNING: Load size is inaccurate */\n        } while (*data != byte_mask);\n      }\n    }\n  }\n  else {\n    temp2 = length - 1;\n    if (length == 0) {\nLAB_0800906c:\n      data = (uint *)0x0;\n    }\n    else {\n                    /* WARNING: Load size is inaccurate */\n      if (*data != byte_mask) {\n        ptr = (uint *)((int)data + 1);\n        do {\n          data = ptr;\n          length = temp2;\n          if (((uint)data & 3) == 0) goto LAB_0800904a;\n          is_match = temp2 == 0;\n          temp2 = temp2 - 1;\n          if (is_match) goto LAB_0800906c;\n                    /* WARNING: Load size is inaccurate */\n          ptr = (uint *)((int)data + 1);\n        } while (*data != byte_mask);\n      }\n    }\n  }\n  return data;\n}\n\n",
            "renaming": {
                "FUN_0800901c": "find_byte_sequence_0800901c",
                "__s": "data",
                "__c": "byte_to_find",
                "__n": "length",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "puVar3": "ptr",
                "uVar4": "byte_mask",
                "bVar5": "is_match"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090a8": {
            "entrypoint": "0x080090a8",
            "current_name": "acquire_malloc_lock_080090a8",
            "code": "\nvoid acquire_malloc_lock_080090a8(void)\n\n{\n  acquire_recursive_lock(&malloc_recursive_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090a8": "acquire_malloc_lock_080090a8",
                "__retarget_lock_acquire_recursive": "acquire_recursive_lock",
                "__lock___malloc_recursive_mutex": "malloc_recursive_mutex"
            },
            "calling": [
                "_malloc_r",
                "_free_r",
                "_malloc_trim_r",
                "_realloc_r"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090b4": {
            "entrypoint": "0x080090b4",
            "current_name": "release_recursive_lock_080090b4",
            "code": "\nvoid releaseRecursiveLock_080090b4(void)\n\n{\n  __retarget_lock_release_recursive(&__lock___malloc_recursive_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090b4": "release_recursive_lock_080090b4"
            },
            "calling": [
                "_malloc_r",
                "_free_r",
                "_malloc_trim_r",
                "_realloc_r"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090c0": {
            "entrypoint": "0x080090c0",
            "current_name": "allocate_or_update_buffer_080090c0",
            "code": "\nundefined4 * allocateOrUpdateBuffer_080090c0(int bufferAddress,uint index)\n\n{\n  undefined4 *oldValue;\n  int currentBuffer;\n  \n  currentBuffer = *(int *)(bufferAddress + 0x4c);\n  if (currentBuffer == 0) {\n    currentBuffer = _calloc_r(bufferAddress,4,0x21);\n    *(int *)(bufferAddress + 0x4c) = currentBuffer;\n    if (currentBuffer == 0) {\n      return (undefined4 *)0x0;\n    }\n  }\n  oldValue = *(undefined4 **)(currentBuffer + index * 4);\n  if (oldValue == (undefined4 *)0x0) {\n    currentBuffer = 1 << (index & 0xff);\n    oldValue = (undefined4 *)_calloc_r(bufferAddress,1,(currentBuffer + 5) * 4);\n    if (oldValue == (undefined4 *)0x0) {\n      return (undefined4 *)0x0;\n    }\n    oldValue[1] = index;\n    oldValue[2] = currentBuffer;\n  }\n  else {\n    *(undefined4 *)(currentBuffer + index * 4) = *oldValue;\n  }\n  oldValue[3] = 0;\n  oldValue[4] = 0;\n  return oldValue;\n}\n\n",
            "renaming": {
                "FUN_080090c0": "allocate_or_update_buffer_080090c0",
                "param_1": "bufferAddress",
                "param_2": "index",
                "puVar1": "oldValue",
                "iVar2": "currentBuffer"
            },
            "calling": [
                "__multiply",
                "__lshift",
                "_dtoa_r",
                "__d2b",
                "__mdiff",
                "__multadd",
                "__i2b",
                "__pow5mult"
            ],
            "called": [
                "_calloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800910c": {
            "entrypoint": "0x0800910c",
            "current_name": "extract_value_and_swap_0800910c",
            "code": "\nvoid extractValueAndSwap_0800910c(int inputPointer,undefined4 *outputPointer)\n\n{\n  int dataPointer;\n  \n  if (outputPointer != (undefined4 *)0x0) {\n    dataPointer = *(int *)(inputPointer + 0x4c);\n    *outputPointer = *(undefined4 *)(dataPointer + outputPointer[1] * 4);\n    *(undefined4 **)(dataPointer + outputPointer[1] * 4) = outputPointer;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800910c": "extract_value_and_swap_0800910c",
                "param_1": "inputPointer",
                "param_2": "outputPointer",
                "iVar1": "dataPointer"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009120": {
            "entrypoint": "0x08009120",
            "current_name": "calculate_checksum_08009120",
            "code": "\nundefined4 * calculateChecksum_08009120(int size,undefined4 *buffer,int multiplier,uint initialChecksum)\n\n{\n  undefined4 *updatedBuffer;\n  uint tempChecksum;\n  int bufferLength;\n  uint *currentValue;\n  int iterationCount;\n  \n  iterationCount = 0;\n  bufferLength = buffer[4];\n  currentValue = buffer + 5;\n  do {\n    iterationCount = iterationCount + 1;\n    initialChecksum = multiplier * (*currentValue & 0xffff) + initialChecksum;\n    tempChecksum = multiplier * (*currentValue >> 0x10) + (initialChecksum >> 0x10);\n    *currentValue = (initialChecksum & 0xffff) + tempChecksum * 0x10000;\n    initialChecksum = tempChecksum >> 0x10;\n    currentValue = currentValue + 1;\n  } while (iterationCount < bufferLength);\n  updatedBuffer = buffer;\n  if (initialChecksum != 0) {\n    if ((int)buffer[2] <= bufferLength) {\n      updatedBuffer = (undefined4 *)_Balloc(size,buffer[1] + 1);\n      memcpy(updatedBuffer + 3,buffer + 3,(buffer[4] + 2) * 4);\n      iterationCount = *(int *)(size + 0x4c);\n      *buffer = *(undefined4 *)(iterationCount + buffer[1] * 4);\n      *(undefined4 **)(iterationCount + buffer[1] * 4) = buffer;\n    }\n    updatedBuffer[bufferLength + 5] = initialChecksum;\n    updatedBuffer[4] = bufferLength + 1;\n  }\n  return updatedBuffer;\n}\n\n",
            "renaming": {
                "FUN_08009120": "calculate_checksum_08009120",
                "param_1": "size",
                "param_2": "buffer",
                "param_3": "multiplier",
                "param_4": "initialChecksum",
                "puVar1": "updatedBuffer",
                "uVar2": "tempChecksum",
                "iVar3": "bufferLength",
                "puVar4": "currentValue",
                "iVar5": "iterationCount"
            },
            "calling": [
                "_dtoa_r",
                "__pow5mult"
            ],
            "called": [
                "memcpy",
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091a4": {
            "entrypoint": "0x080091a4",
            "current_name": "count_leading_zeros_080091a4",
            "code": "\nint countLeadingZeros_080091a4(uint input)\n\n{\n  int leadingZeros;\n  \n  if ((input & 0xffff0000) == 0) {\n    input = input << 0x10;\n    leadingZeros = 0x10;\n  }\n  else {\n    leadingZeros = 0;\n  }\n  if ((input & 0xff000000) == 0) {\n    input = input << 8;\n    leadingZeros = leadingZeros + 8;\n  }\n  if ((input & 0xf0000000) == 0) {\n    input = input << 4;\n    leadingZeros = leadingZeros + 4;\n  }\n  if ((input & 0xc0000000) == 0) {\n    input = input << 2;\n    leadingZeros = leadingZeros + 2;\n  }\n  if (-1 < (int)input) {\n    if ((int)(input << 1) < 0) {\n      return leadingZeros + 1;\n    }\n    leadingZeros = 0x20;\n  }\n  return leadingZeros;\n}\n\n",
            "renaming": {
                "FUN_080091a4": "count_leading_zeros_080091a4",
                "param_1": "input",
                "iVar1": "leadingZeros"
            },
            "calling": [
                "_dtoa_r",
                "__d2b"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091e4": {
            "entrypoint": "0x080091e4",
            "current_name": "count_leading_zeros_080091e4",
            "code": "\nint countLeadingZeros_080091e4(uint *number)\n\n{\n  int leadingZeros;\n  uint value;\n  \n  value = *number;\n  if ((value & 7) == 0) {\n    if ((value & 0xffff) == 0) {\n      value = value >> 0x10;\n      leadingZeros = 0x10;\n    }\n    else {\n      leadingZeros = 0;\n    }\n    if ((value & 0xff) == 0) {\n      value = value >> 8;\n      leadingZeros = leadingZeros + 8;\n    }\n    if ((value & 0xf) == 0) {\n      value = value >> 4;\n      leadingZeros = leadingZeros + 4;\n    }\n    if ((value & 3) == 0) {\n      value = value >> 2;\n      leadingZeros = leadingZeros + 2;\n    }\n    if (-1 < (int)(value << 0x1f)) {\n      value = value >> 1;\n      if (value == 0) {\n        return 0x20;\n      }\n      leadingZeros = leadingZeros + 1;\n    }\n    *number = value;\n    return leadingZeros;\n  }\n  if ((int)(value << 0x1f) < 0) {\n    return 0;\n  }\n  if (-1 < (int)(value << 0x1e)) {\n    *number = value >> 2;\n    return 2;\n  }\n  *number = value >> 1;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080091e4": "count_leading_zeros_080091e4",
                "param_1": "number",
                "iVar1": "leadingZeros",
                "uVar2": "value"
            },
            "calling": [
                "__d2b"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009244": {
            "entrypoint": "0x08009244",
            "current_name": "allocate_and_initialize_08009244",
            "code": "\nvoid allocateAndInitialize_08009244(undefined4 size,undefined4 value)\n\n{\n  int allocatedPtr;\n  \n  allocatedPtr = _Balloc(size,1);\n  *(undefined4 *)(allocatedPtr + 0x10) = 1;\n  *(undefined4 *)(allocatedPtr + 0x14) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009244": "allocate_and_initialize_08009244",
                "param_1": "size",
                "param_2": "value",
                "iVar1": "allocatedPtr"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009258": {
            "entrypoint": "0x08009258",
            "current_name": "calculate_checksum_08009258",
            "code": "\nvoid calculateChecksum_08009258(undefined4 parameter1,int inputData1,int inputData2)\n\n{\n  uint *ptr1;\n  uint *ptr2;\n  int size;\n  uint temp1;\n  uint *ptr3;\n  uint startOffset;\n  uint *ptr4;\n  uint temp2;\n  int dataSize1;\n  int dataSize2;\n  uint endOffset;\n  int tempSize1;\n  int tempSize2;\n  uint *ptr5;\n  uint *ptr6;\n  uint *ptr7;\n  uint *ptr8;\n  uint *ptr9;\n  \n  tempSize1 = *(int *)(inputData1 + 0x10);\n  dataSize1 = *(int *)(inputData2 + 0x10);\n  dataSize2 = dataSize1;\n  tempSize2 = inputData1;\n  if (tempSize1 < dataSize1) {\n    dataSize2 = tempSize1;\n    tempSize1 = dataSize1;\n    tempSize2 = inputData2;\n    inputData2 = inputData1;\n  }\n  dataSize1 = tempSize1 + dataSize2;\n  size = *(int *)(tempSize2 + 4);\n  if (*(int *)(tempSize2 + 8) < dataSize1) {\n    size = size + 1;\n  }\n  size = _Balloc(parameter1,size);\n  ptr9 = (uint *)(size + 0x14);\n  ptr8 = ptr9 + dataSize1;\n  for (ptr3 = ptr9; ptr3 < ptr8; ptr3 = ptr3 + 1) {\n    *ptr3 = 0;\n  }\n  startOffset = inputData2 + 0x14;\n  endOffset = startOffset + dataSize2 * 4;\n  ptr3 = (uint *)(tempSize2 + 0x14);\n  if (startOffset < endOffset) {\n    ptr4 = (uint *)(startOffset + ((endOffset - inputData2) - 0x15 & 0xfffffffc));\n    ptr7 = (uint *)(inputData2 + 0x10);\n    do {\n      while( true ) {\n        ptr7 = ptr7 + 1;\n        startOffset = *ptr7 & 0xffff;\n        if (startOffset != 0) break;\n        startOffset = *ptr7 >> 0x10;\n        if (startOffset == 0) goto LAB_080092d2;\nLAB_0800932c:\n        temp2 = *ptr9;\n        temp1 = 0;\n        ptr1 = ptr3;\n        ptr5 = ptr9;\n        endOffset = temp2;\n        do {\n          ptr6 = ptr5;\n          temp1 = temp1 + startOffset * *(ushort *)ptr1 + (endOffset >> 0x10);\n          *ptr6 = temp2 & 0xffff | temp1 * 0x10000;\n          ptr2 = ptr1 + 1;\n          endOffset = ptr6[1];\n          temp2 = startOffset * (*ptr1 >> 0x10) + (endOffset & 0xffff) + (temp1 >> 0x10);\n          temp1 = temp2 >> 0x10;\n          ptr1 = ptr2;\n          ptr5 = ptr6 + 1;\n        } while (ptr2 < ptr3 + tempSize1);\n        ptr6[1] = temp2;\n        ptr9 = ptr9 + 1;\n        if (ptr4 == ptr7) goto LAB_0800937a;\n      }\n      endOffset = 0;\n      ptr1 = ptr9;\n      ptr5 = ptr3;\n      do {\n        ptr2 = ptr1;\n        ptr6 = ptr5 + 1;\n        temp2 = startOffset * (*ptr5 & 0xffff) + (*ptr2 & 0xffff) + endOffset;\n        temp1 = startOffset * (*ptr5 >> 0x10) + (*ptr2 >> 0x10) + (temp2 >> 0x10);\n        endOffset = temp1 >> 0x10;\n        *ptr2 = temp2 & 0xffff | temp1 * 0x10000;\n        ptr1 = ptr2 + 1;\n        ptr5 = ptr6;\n      } while (ptr6 < ptr3 + tempSize1);\n      ptr2[1] = endOffset;\n      startOffset = *ptr7 >> 0x10;\n      if (startOffset != 0) goto LAB_0800932c;\nLAB_080092d2:\n      ptr9 = ptr9 + 1;\n    } while (ptr4 != ptr7);\n  }\nLAB_0800937a:\n  if (0 < dataSize1) {\n    startOffset = ptr8[-1];\n    ptr8 = ptr8 + -1;\n    while ((startOffset == 0 && (dataSize1 = dataSize1 + -1, dataSize1 != 0))) {\n      ptr8 = ptr8 + -1;\n      startOffset = *ptr8;\n    }\n  }\n  *(int *)(size + 0x10) = dataSize1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009258": "calculate_checksum_08009258",
                "param_1": "parameter1",
                "param_2": "inputData1",
                "param_3": "inputData2",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "iVar3": "size",
                "uVar4": "temp1",
                "puVar5": "ptr3",
                "uVar6": "startOffset",
                "puVar7": "ptr4",
                "uVar8": "temp2",
                "iVar9": "dataSize1",
                "iVar10": "dataSize2",
                "uVar11": "endOffset",
                "iVar12": "tempSize1",
                "iVar13": "tempSize2",
                "puVar14": "ptr5",
                "puVar15": "ptr6",
                "puVar16": "ptr7",
                "puVar17": "ptr8",
                "puVar18": "ptr9"
            },
            "calling": [
                "_dtoa_r",
                "__pow5mult"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080093a4": {
            "entrypoint": "0x080093a4",
            "current_name": "reverse_binary_080093a4",
            "code": "\nundefined4 * reverseBinary_080093a4(int inputData,undefined4 *result,uint size)\n\n{\n  int temp1;\n  int temp2;\n  undefined4 *tempPtr1;\n  undefined4 *tempPtr2;\n  \n  if ((size & 3) != 0) {\n    result = (undefined4 *)\n              __multadd(inputData,result,*(undefined4 *)(&p05_6092 + ((size & 3) - 1) * 4),0);\n  }\n  temp2 = (int)size >> 2;\n  if (temp2 != 0) {\n    tempPtr2 = *(undefined4 **)(inputData + 0x48);\n    if (tempPtr2 == (undefined4 *)0x0) {\n      tempPtr2 = (undefined4 *)_Balloc(inputData,1);\n      tempPtr2[4] = 1;\n      tempPtr2[5] = 0x271;\n      *(undefined4 **)(inputData + 0x48) = tempPtr2;\n      *tempPtr2 = 0;\n    }\n    tempPtr1 = result;\n    if (temp2 << 0x1f < 0) goto LAB_080093d2;\nLAB_080093c4:\n    temp2 = temp2 >> 1;\n    tempPtr1 = tempPtr2;\n    if (temp2 != 0) {\n      while( true ) {\n        tempPtr2 = (undefined4 *)*tempPtr1;\n        if (tempPtr2 == (undefined4 *)0x0) {\n          tempPtr2 = (undefined4 *)__multiply(inputData,tempPtr1,tempPtr1);\n          *tempPtr1 = tempPtr2;\n          *tempPtr2 = 0;\n        }\n        tempPtr1 = result;\n        if (-1 < temp2 << 0x1f) break;\nLAB_080093d2:\n        result = (undefined4 *)__multiply(inputData,tempPtr1,tempPtr2);\n        if (tempPtr1 == (undefined4 *)0x0) break;\n        temp1 = *(int *)(inputData + 0x4c);\n        temp2 = temp2 >> 1;\n        *tempPtr1 = *(undefined4 *)(temp1 + tempPtr1[1] * 4);\n        *(undefined4 **)(temp1 + tempPtr1[1] * 4) = tempPtr1;\n        tempPtr1 = tempPtr2;\n        if (temp2 == 0) {\n          return result;\n        }\n      }\n      goto LAB_080093c4;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080093a4": "reverse_binary_080093a4",
                "param_1": "inputData",
                "param_2": "result",
                "param_3": "size",
                "iVar1": "temp1",
                "iVar2": "temp2",
                "puVar3": "tempPtr1",
                "puVar4": "tempPtr2"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__multiply",
                "__multadd",
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009444": {
            "entrypoint": "0x08009444",
            "current_name": "convert_bits_08009444",
            "code": "\nvoid convertBits_08009444(int dstSize,undefined4 *srcData,uint srcSize)\n\n{\n  int shift;\n  int multiplier;\n  int dstSizeAllocated;\n  undefined4 originalValue;\n  int srcSizeAllocated;\n  int currentSize;\n  uint *dstData;\n  uint *srcDataPtr;\n  uint *srcDataPtrIter;\n  uint *srcDataPtrEnd;\n  int sizeDiv;\n  int shiftedSizeDiv;\n  uint carryBits;\n  uint *dstDataPtr;\n  \n  srcSizeAllocated = srcData[4];\n  sizeDiv = (int)srcSize >> 5;\n  shiftedSizeDiv = sizeDiv + srcSizeAllocated + 1;\n  dstSizeAllocated = srcData[1];\n  multiplier = srcData[2];\n  if ((int)srcData[2] < shiftedSizeDiv) {\n    do {\n      currentSize = multiplier * 2;\n      shift = multiplier * -2;\n      dstSizeAllocated = dstSizeAllocated + 1;\n      multiplier = currentSize;\n    } while (shiftedSizeDiv != currentSize && shiftedSizeDiv + shift < 0 == SBORROW4(shiftedSizeDiv,currentSize));\n  }\n  multiplier = _Balloc(dstSize,dstSizeAllocated);\n  dstData = (uint *)(multiplier + 0x14);\n  if (0 < sizeDiv) {\n    srcDataPtrEnd = dstData + sizeDiv;\n    srcDataPtr = dstData;\n    do {\n      dstDataPtr = srcDataPtr + 1;\n      *srcDataPtr = 0;\n      dstData = srcDataPtrEnd;\n      srcDataPtr = dstDataPtr;\n    } while (dstDataPtr != srcDataPtrEnd);\n  }\n  dstSizeAllocated = srcData[4];\n  srcDataPtr = srcData + 5;\n  srcSize = srcSize & 0x1f;\n  if (srcSize == 0) {\n    dstData = dstData + -1;\n    srcDataPtrEnd = srcDataPtr;\n    do {\n      dstDataPtr = srcDataPtrEnd + 1;\n      dstData = dstData + 1;\n      *dstData = *srcDataPtrEnd;\n      srcDataPtrEnd = dstDataPtr;\n    } while (dstDataPtr < srcDataPtr + dstSizeAllocated);\n  }\n  else {\n    carryBits = 0;\n    srcDataPtrEnd = srcDataPtr;\n    do {\n      dstDataPtr = dstData;\n      *dstDataPtr = *srcDataPtrEnd << srcSize | carryBits;\n      srcDataPtrIter = srcDataPtrEnd + 1;\n      carryBits = *srcDataPtrEnd >> (0x20 - srcSize & 0xff);\n      dstData = dstDataPtr + 1;\n      srcDataPtrEnd = srcDataPtrIter;\n    } while (srcDataPtrIter < srcDataPtr + dstSizeAllocated);\n    dstDataPtr[1] = carryBits;\n    if (carryBits != 0) {\n      shiftedSizeDiv = sizeDiv + srcSizeAllocated + 2;\n    }\n  }\n  srcSizeAllocated = *(int *)(dstSize + 0x4c);\n  dstSizeAllocated = srcData[1];\n  originalValue = *(undefined4 *)(srcSizeAllocated + dstSizeAllocated * 4);\n  *(int *)(multiplier + 0x10) = shiftedSizeDiv + -1;\n  *srcData = originalValue;\n  *(undefined4 **)(srcSizeAllocated + dstSizeAllocated * 4) = srcData;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009444": "convert_bits_08009444",
                "param_1": "dstSize",
                "param_2": "srcData",
                "param_3": "srcSize",
                "iVar1": "shift",
                "iVar2": "multiplier",
                "iVar3": "dstSizeAllocated",
                "uVar4": "originalValue",
                "iVar5": "srcSizeAllocated",
                "iVar6": "currentSize",
                "puVar7": "dstData",
                "puVar8": "srcDataPtr",
                "puVar9": "dstDataPtr",
                "puVar10": "srcDataPtrIter",
                "puVar11": "srcDataPtrEnd",
                "iVar12": "sizeDiv",
                "iVar13": "shiftedSizeDiv",
                "uVar14": "carryBits"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080094f8": {
            "entrypoint": "0x080094f8",
            "current_name": "compare_arrays_080094f8",
            "code": "\nint compare_arrays_080094f8(int array1_start,int array2_start)\n\n{\n  int array_size_difference;\n  uint *array2_current_ptr;\n  int array2_size;\n  uint *array1_current_ptr;\n  \n  array2_size = *(int *)(array2_start + 0x10);\n  array_size_difference = *(int *)(array1_start + 0x10) - array2_size;\n  if (array_size_difference == 0) {\n    array2_current_ptr = (uint *)(array2_start + 0x14 + array2_size * 4);\n    array1_current_ptr = (uint *)(array1_start + 0x14) + array2_size;\n    do {\n      array1_current_ptr = array1_current_ptr + -1;\n      array2_current_ptr = array2_current_ptr + -1;\n      if (*array1_current_ptr != *array2_current_ptr) {\n        if (*array2_current_ptr <= *array1_current_ptr) {\n          return 1;\n        }\n        return -1;\n      }\n    } while ((uint *)(array1_start + 0x14) < array1_current_ptr);\n  }\n  return array_size_difference;\n}\n\n",
            "renaming": {
                "FUN_080094f8": "compare_arrays_080094f8",
                "param_1": "array1_start",
                "param_2": "array2_start",
                "iVar1": "array_size_difference",
                "iVar3": "array2_size",
                "puVar2": "array2_current_ptr",
                "puVar4": "array1_current_ptr"
            },
            "calling": [
                "_dtoa_r",
                "quorem"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009530": {
            "entrypoint": "0x08009530",
            "current_name": "reverse_and_allocate_08009530",
            "code": "\nvoid reverseAndAllocate_08009530(undefined4 param1,uint *input1,uint *input2,undefined4 param4)\n\n{\n  int allocatedVar1;\n  uint *pointer1;\n  uint size1;\n  uint size2;\n  undefined4 flag;\n  uint *ptr1;\n  uint *ptr2;\n  uint *ptr3;\n  uint *tmpPtr2;\n  uint *tmpPtr3;\n  int iterationVar;\n  uint *ptr6;\n  uint size3;\n  uint *tmpPtr1;\n  \n  pointer1 = (uint *)input2[4];\n  tmpPtr3 = input1 + 5;\n  ptr6 = input2 + 5;\n  ptr2 = tmpPtr3;\n  ptr3 = input1;\n  if ((uint *)input1[4] == pointer1) {\n    ptr1 = tmpPtr3 + (int)pointer1;\n    pointer1 = ptr6 + (int)pointer1;\n    while( true ) {\n      ptr1 = ptr1 + -1;\n      pointer1 = pointer1 + -1;\n      if (*ptr1 != *pointer1) break;\n      if (ptr1 <= tmpPtr3) {\n        iterationVar = _Balloc(param1,0,ptr1,pointer1,param4);\n        *(undefined4 *)(iterationVar + 0x10) = 1;\n        *(undefined4 *)(iterationVar + 0x14) = 0;\n        return;\n      }\n    }\n    flag = 0;\n    if (*pointer1 <= *ptr1) goto LAB_08009578;\n  }\n  else if (-1 < (int)(uint *)input1[4] - (int)pointer1) {\n    flag = 0;\n    ptr1 = input2;\n    goto LAB_08009578;\n  }\n  flag = 1;\n  ptr1 = tmpPtr3;\n  pointer1 = input1;\n  ptr2 = ptr6;\n  ptr3 = input2;\n  input2 = input1;\n  ptr6 = tmpPtr3;\nLAB_08009578:\n  allocatedVar1 = _Balloc(param1,ptr3[1],ptr1,pointer1,param4);\n  iterationVar = 0;\n  size3 = ptr3[4];\n  size1 = input2[4];\n  *(undefined4 *)(allocatedVar1 + 0xc) = flag;\n  tmpPtr3 = ptr2 + size3;\n  pointer1 = (uint *)(allocatedVar1 + 0x14);\n  ptr3 = ptr6;\n  do {\n    tmpPtr1 = ptr2 + 1;\n    tmpPtr2 = ptr3 + 1;\n    size2 = ((*ptr2 & 0xffff) + iterationVar) - (*ptr3 & 0xffff);\n    iterationVar = ((*ptr2 >> 0x10) - (*ptr3 >> 0x10)) + ((int)size2 >> 0x10);\n    size2 = size2 & 0xffff | iterationVar * 0x10000;\n    ptr1 = pointer1 + 1;\n    *pointer1 = size2;\n    iterationVar = iterationVar >> 0x10;\n    pointer1 = ptr1;\n    ptr2 = tmpPtr1;\n    ptr3 = tmpPtr2;\n  } while (tmpPtr2 < ptr6 + size1);\n  pointer1 = tmpPtr1;\n  ptr2 = ptr1;\n  if (tmpPtr1 < tmpPtr3) {\n    do {\n      ptr3 = pointer1 + 1;\n      size1 = (*pointer1 & 0xffff) + iterationVar;\n      iterationVar = ((int)size1 >> 0x10) + (*pointer1 >> 0x10);\n      size2 = size1 & 0xffff | iterationVar * 0x10000;\n      *ptr2 = size2;\n      iterationVar = iterationVar >> 0x10;\n      pointer1 = ptr3;\n      ptr2 = ptr2 + 1;\n    } while (ptr3 < tmpPtr3);\n    ptr1 = (uint *)((int)ptr1 + ((int)tmpPtr3 + ~(uint)tmpPtr1 & 0xfffffffc) + 4);\n  }\n  ptr1 = ptr1 + -1;\n  while (size2 == 0) {\n    ptr1 = ptr1 + -1;\n    size3 = size3 - 1;\n    size2 = *ptr1;\n  }\n  *(uint *)(allocatedVar1 + 0x10) = size3;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009530": "reverse_and_allocate_08009530",
                "param_1": "param1",
                "param_2": "input1",
                "param_3": "input2",
                "param_4": "param4",
                "iVar1": "allocatedVar1",
                "puVar2": "pointer1",
                "uVar3": "size1",
                "uVar4": "size2",
                "uVar5": "flag",
                "puVar6": "ptr1",
                "puVar7": "ptr2",
                "puVar9": "ptr3",
                "puVar10": "tmpPtr2",
                "puVar11": "tmpPtr3",
                "iVar12": "iterationVar",
                "puVar13": "ptr6",
                "uVar14": "size3",
                "puVar8": "tmpPtr1"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009630": {
            "entrypoint": "0x08009630",
            "current_name": "decode_data_08009630",
            "code": "\nint decodeData_08009630(undefined4 input1,undefined4 input2,uint mask1,uint mask2,int *output1,\n                int *output2)\n\n{\n  int result;\n  uint shiftAmount;\n  int bits1;\n  int bits2;\n  uint shiftedMask;\n  uint temp;\n  undefined8 highBits;\n  uint tempMask;\n  uint combinedMask;\n  \n  result = _Balloc(input1,1);\n  temp = (mask2 << 1) >> 0x15;\n  combinedMask = mask2 & 0xfffff;\n  if (temp != 0) {\n    combinedMask = combinedMask | 0x100000;\n  }\n  if (mask1 == 0) {\n    bits1 = __lo0bits(&combinedMask);\n    bits2 = 1;\n    shiftAmount = bits1 + 0x20;\n    *(undefined4 *)(result + 0x10) = 1;\n    *(uint *)(result + 0x14) = combinedMask;\n  }\n  else {\n    tempMask = mask1;\n    shiftAmount = __lo0bits(&tempMask);\n    if (shiftAmount == 0) {\n      *(uint *)(result + 0x14) = tempMask;\n    }\n    else {\n      shiftedMask = combinedMask << (0x20 - shiftAmount & 0xff);\n      combinedMask = combinedMask >> (shiftAmount & 0xff);\n      *(uint *)(result + 0x14) = shiftedMask | tempMask;\n    }\n    if (combinedMask == 0) {\n      bits2 = 1;\n    }\n    else {\n      bits2 = 2;\n    }\n    *(uint *)(result + 0x18) = combinedMask;\n    *(int *)(result + 0x10) = bits2;\n  }\n  if (temp == 0) {\n    *output1 = shiftAmount - 0x432;\n    highBits = __hi0bits(*(undefined4 *)(result + bits2 * 4 + 0x10));\n    *output2 = (int)((ulonglong)highBits >> 0x20) * 0x20 - (int)highBits;\n    return result;\n  }\n  *output1 = (temp - 0x433) + shiftAmount;\n  *output2 = 0x35 - shiftAmount;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009630": "decode_data_08009630",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "mask1",
                "param_4": "mask2",
                "param_5": "output1",
                "param_6": "output2",
                "iVar1": "result",
                "uVar2": "shiftAmount",
                "iVar3": "bits1",
                "iVar4": "bits2",
                "uVar5": "shiftedMask",
                "uVar6": "temp",
                "uVar7": "highBits",
                "local_20": "tempMask",
                "local_1c": "combinedMask"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__hi0bits",
                "__lo0bits",
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080096e0": {
            "entrypoint": "0x080096e0",
            "current_name": "calculate_exponent_080096e0",
            "code": "\ndouble calculateExponent_080096e0(double inputValue,int *exponent)\n\n{\n  uint temp1;\n  uint temp2;\n  int *result;\n  int iteration;\n  uint absoluteValue;\n  double outputValue;\n  \n  iteration = 0;\n  absoluteValue = temp1 & 0x7fffffff;\n  *result = 0;\n  if ((absoluteValue < 0x7ff00000) && ((absoluteValue | (uint)exponent) != 0)) {\n    if (absoluteValue < 0x100000) {\n      outputValue = (double)__muldf3(exponent,temp1,0,0x43500000);\n      iteration = -0x36;\n      absoluteValue = temp2 & 0x7fffffff;\n    }\n    *result = ((int)absoluteValue >> 0x14) + -0x3fe + iteration;\n  }\n  return outputValue;\n}\n\n",
            "renaming": {
                "FUN_080096e0": "calculate_exponent_080096e0",
                "__x": "inputValue",
                "__exponent": "exponent",
                "in_r1": "temp1",
                "extraout_r1": "temp2",
                "in_r2": "result",
                "iVar1": "iteration",
                "uVar2": "absoluteValue",
                "in_d0": "outputValue"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__muldf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009744": {
            "entrypoint": "0x08009744",
            "current_name": "allocate_memory_08009744",
            "code": "\nvoid allocate_memory_08009744(int *error_code,intptr_t allocation_size)\n\n{\n  void *allocated_memory;\n  \n  errno = 0;\n  allocated_memory = _sbrk(allocation_size);\n  if ((allocated_memory == (void *)0xffffffff) && (errno != 0)) {\n    *error_code = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009744": "allocate_memory_08009744",
                "param_1": "error_code",
                "param_2": "allocation_size",
                "pvVar1": "allocated_memory"
            },
            "calling": [
                "_malloc_r",
                "_malloc_trim_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009768": {
            "entrypoint": "0x08009768",
            "current_name": "copy_string_08009768",
            "code": "\nchar * copy_string_08009768(char *destination,char *source,size_t size)\n\n{\n  char current_char;\n  uint *source_ptr;\n  uint *destination_ptr;\n  uint *temp_ptr;\n  uint current_uint;\n  \n  destination_ptr = (uint *)destination;\n  if (((((uint)destination | (uint)source) & 3) == 0) && (source_ptr = (uint *)source, 3 < size)) {\n    do {\n      source = (char *)(source_ptr + 1);\n      current_uint = *source_ptr;\n      if ((current_uint + 0xfefefeff & ~current_uint & 0x80808080) != 0) goto LAB_0800979c;\n      size = size - 4;\n      source_ptr = destination_ptr + 1;\n      *destination_ptr = current_uint;\n      destination_ptr = source_ptr;\n      source_ptr = (uint *)source;\n    } while (3 < size);\n  }\n  source_ptr = (uint *)source;\n  if (size != 0) {\nLAB_0800979c:\n    current_char = *(char *)source_ptr;\n    *(char *)destination_ptr = current_char;\n    while( true ) {\n      destination_ptr = (uint *)((int)destination_ptr + 1);\n      size = size - 1;\n      if (current_char == '\\0') break;\n      if (size == 0) {\n        return destination;\n      }\n      source_ptr = (uint *)((int)source_ptr + 1);\n      current_char = *(char *)source_ptr;\n      *(char *)destination_ptr = current_char;\n    }\n    if (size != 0) {\n      source_ptr = destination_ptr;\n      do {\n        temp_ptr = (uint *)((int)source_ptr + 1);\n        *(char *)source_ptr = '\\0';\n        source_ptr = temp_ptr;\n      } while (temp_ptr != (uint *)(size + (int)destination_ptr));\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08009768": "copy_string_08009768",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "cVar1": "current_char",
                "puVar2": "source_ptr",
                "puVar3": "destination_ptr",
                "puVar4": "temp_ptr",
                "uVar5": "current_uint"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080097cc": {
            "entrypoint": "0x080097cc",
            "current_name": "reallocate_and_move_memory_080097cc",
            "code": "\nundefined4 reallocate_and_move_memory_080097cc(undefined4 *errorCode,void **buffer,int *sizes)\n\n{\n  void *oldBuffer;\n  void *newBuffer;\n  int sizeDifference;\n  void *bufferSize;\n  void *copySize;\n  void **nextElement;\n  void **currentElement;\n  void *source;\n  size_t numBytes;\n  \n  if (sizes[2] != 0) {\n    oldBuffer = *buffer;\n    bufferSize = buffer[2];\n    currentElement = (void **)*sizes;\n    do {\n      do {\n        nextElement = currentElement + 2;\n        source = *currentElement;\n        copySize = currentElement[1];\n        currentElement = nextElement;\n      } while (copySize == (void *)0x0);\n      newBuffer = copySize;\n      if ((bufferSize <= copySize) && (newBuffer = bufferSize, (*(ushort *)(buffer + 3) & 0x480) != 0)) {\n        numBytes = (int)oldBuffer - (int)buffer[4];\n        bufferSize = (void *)(((int)buffer[5] * 3) / 2);\n        oldBuffer = (void *)((int)copySize + numBytes + 1);\n        if (bufferSize < oldBuffer) {\n          bufferSize = oldBuffer;\n        }\n        if ((int)((uint)*(ushort *)(buffer + 3) << 0x15) < 0) {\n          newBuffer = (void *)allocateMemory(errorCode,bufferSize);\n          if (newBuffer == (void *)0x0) {\nLAB_08009896:\n            *errorCode = 0xc;\n            *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) | 0x40;\n            sizes[1] = 0;\n            sizes[2] = 0;\n            return 0xffffffff;\n          }\n          memcpy(newBuffer,buffer[4],numBytes);\n          *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) & 0xfb7f | 0x80;\n        }\n        else {\n          newBuffer = (void *)reallocateMemory(errorCode);\n          if (newBuffer == (void *)0x0) {\n            freeMemory(errorCode,buffer[4]);\n            goto LAB_08009896;\n          }\n        }\n        oldBuffer = (void *)((int)newBuffer + numBytes);\n        buffer[5] = bufferSize;\n        buffer[4] = newBuffer;\n        *buffer = oldBuffer;\n        buffer[2] = (void *)((int)bufferSize - numBytes);\n        newBuffer = copySize;\n      }\n      memmove(oldBuffer,source,(size_t)newBuffer);\n      sizeDifference = sizes[2];\n      bufferSize = (void *)((int)buffer[2] - (int)newBuffer);\n      oldBuffer = (void *)((int)*buffer + (int)newBuffer);\n      buffer[2] = bufferSize;\n      *buffer = oldBuffer;\n      sizes[2] = sizeDifference - (int)copySize;\n    } while (sizeDifference - (int)copySize != 0);\n  }\n  sizes[1] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080097cc": "reallocate_and_move_memory_080097cc",
                "param_1": "errorCode",
                "param_2": "buffer",
                "param_3": "sizes",
                "pvVar1": "oldBuffer",
                "pvVar2": "newBuffer",
                "iVar3": "sizeDifference",
                "pvVar4": "bufferSize",
                "pvVar5": "copySize",
                "ppvVar6": "nextElement",
                "ppvVar7": "currentElement",
                "__src": "source",
                "__n": "numBytes",
                "_malloc_r": "allocateMemory",
                "_realloc_r": "reallocateMemory",
                "_free_r": "freeMemory"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "_malloc_r",
                "memmove",
                "_free_r",
                "memcpy",
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080098c0": {
            "entrypoint": "0x080098c0",
            "current_name": "update_atexit_list_080098c0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08009906) */\n/* WARNING: Removing unreachable block (ram,0x08009912) */\n\nundefined4 update_atexit_list_080098c0(int operation,undefined4 callback_function,undefined4 param_1_value,undefined4 param_2_value)\n\n{\n  undefined *current_entry;\n  undefined4 result;\n  uint bit_mask;\n  uint entry_count;\n  \n  __retarget_lock_acquire_recursive(__atexit_recursive_mutex);\n  if (DAT_20000168 == (undefined *)0x0) {\n    DAT_20000168 = &DAT_2000016c;\n  }\n  current_entry = DAT_20000168;\n  entry_count = *(uint *)(DAT_20000168 + 4);\n  if ((int)entry_count < 0x20) {\n    if (operation != 0) {\n      *(undefined4 *)(DAT_20000168 + entry_count * 4 + 0x88) = param_1_value;\n      bit_mask = 1 << (entry_count & 0xff);\n      *(uint *)(current_entry + 0x188) = *(uint *)(current_entry + 0x188) | bit_mask;\n      *(undefined4 *)(current_entry + entry_count * 4 + 0x108) = param_2_value;\n      if (operation == 2) {\n        *(uint *)(current_entry + 0x18c) = bit_mask | *(uint *)(current_entry + 0x18c);\n      }\n    }\n    *(uint *)(current_entry + 4) = entry_count + 1;\n    result = __atexit_recursive_mutex;\n    *(undefined4 *)(current_entry + (entry_count + 2) * 4) = callback_function;\n    __retarget_lock_release_recursive(result);\n    result = 0;\n  }\n  else {\n    __retarget_lock_release_recursive(__atexit_recursive_mutex);\n    result = 0xffffffff;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080098c0": "update_atexit_list_080098c0",
                "param_1": "operation",
                "param_2": "callback_function",
                "param_3": "param_1_value",
                "param_4": "param_2_value",
                "puVar1": "current_entry",
                "uVar2": "result",
                "uVar3": "bit_mask",
                "uVar4": "entry_count"
            },
            "calling": [
                "atexit"
            ],
            "called": [
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009980": {
            "entrypoint": "0x08009980",
            "current_name": "allocate_and_initialize_array_08009980",
            "code": "\nundefined4 * allocate_and_initialize_array_08009980(undefined4 element_size,int num_rows,int num_columns)\n\n{\n  undefined4 *array_ptr;\n  size_t array_size;\n  undefined4 *temp_ptr;\n  \n  array_ptr = (undefined4 *)_malloc_r(element_size,num_columns * num_rows);\n  if (array_ptr == (undefined4 *)0x0) {\n    return (undefined4 *)0x0;\n  }\n  array_size = (array_ptr[-1] & 0xfffffffc) - 4;\n  if (array_size < 0x25) {\n    temp_ptr = array_ptr;\n    if (0x13 < array_size) {\n      *array_ptr = 0;\n      array_ptr[1] = 0;\n      if (0x1b < array_size) {\n        array_ptr[2] = 0;\n        array_ptr[3] = 0;\n        if (array_size == 0x24) {\n          array_ptr[4] = 0;\n          array_ptr[5] = 0;\n          temp_ptr = array_ptr + 6;\n        }\n        else {\n          temp_ptr = array_ptr + 4;\n        }\n        *temp_ptr = 0;\n        temp_ptr[1] = 0;\n        temp_ptr[2] = 0;\n        return array_ptr;\n      }\n      temp_ptr = array_ptr + 2;\n    }\n    *temp_ptr = 0;\n    temp_ptr[1] = 0;\n    temp_ptr[2] = 0;\n    return array_ptr;\n  }\n  memset(array_ptr,0,array_size);\n  return array_ptr;\n}\n\n",
            "renaming": {
                "FUN_08009980": "allocate_and_initialize_array_08009980",
                "param_1": "element_size",
                "param_2": "num_rows",
                "param_3": "num_columns",
                "__s": "array_ptr",
                "__n": "array_size",
                "puVar1": "temp_ptr"
            },
            "calling": [
                "_Balloc"
            ],
            "called": [
                "memset",
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080099ec": {
            "entrypoint": "0x080099ec",
            "current_name": "extract_byte_and_check_080099ec",
            "code": "\nuint extract_byte_and_check_080099ec(undefined4 status,uint *output,byte *input,int length)\n\n{\n  uint result;\n  uint stack_output;\n  \n  if (output == (uint *)0x0) {\n    output = &stack_output;\n  }\n  if (input == (byte *)0x0) {\n    return 0;\n  }\n  if (length == 0) {\n    result = 0xfffffffe;\n  }\n  else {\n    *output = (uint)*input;\n    result = (uint)*input;\n    if (result != 0) {\n      result = 1;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080099ec": "extract_byte_and_check_080099ec",
                "param_1": "status",
                "param_2": "output",
                "param_3": "input",
                "param_4": "length",
                "uVar1": "result",
                "uStack_4": "stack_output"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009a18": {
            "entrypoint": "0x08009a18",
            "current_name": "memcpy_reverse_08009a18",
            "code": "\nvoid * memcpy_reverse_08009a18(void *dest,void *src,size_t size)\n\n{\n  undefined4 *dest_ptr;\n  undefined *src_ptr;\n  int i;\n  void *dest_start;\n  undefined *src_end;\n  int src_index;\n  uint loop_count;\n  int dest_index;\n  uint remaining_size;\n  undefined4 *src_ptr_temp;\n  \n  if ((src < dest) && (src_ptr = (undefined *)((int)src + size), dest < src_ptr)) {\n    src_end = (undefined *)((int)dest + size);\n    if (size != 0) {\n      do {\n        src_ptr = src_ptr + -1;\n        src_end = src_end + -1;\n        *src_end = *src_ptr;\n      } while ((undefined *)src != src_ptr);\n    }\n  }\n  else {\n    remaining_size = size;\n    dest_start = dest;\n    if (0xf < size) {\n      if ((((uint)dest | (uint)src) & 3) != 0) goto LAB_08009abc;\n      i = (int)src + 0x10;\n      dest_index = (int)dest + 0x10;\n      do {\n        src_index = i + 0x10;\n        *(undefined4 *)(dest_index + -0x10) = *(undefined4 *)(i + -0x10);\n        *(undefined4 *)(dest_index + -0xc) = *(undefined4 *)(i + -0xc);\n        *(undefined4 *)(dest_index + -8) = *(undefined4 *)(i + -8);\n        *(undefined4 *)(dest_index + -4) = *(undefined4 *)(i + -4);\n        i = src_index;\n        dest_index = dest_index + 0x10;\n      } while (src_index != (int)src + (size - 0x10 & 0xfffffff0) + 0x20);\n      remaining_size = size & 0xf;\n      i = ((size - 0x10 >> 4) + 1) * 0x10;\n      src = (void *)((int)src + i);\n      dest_start = (void *)(i + (int)dest);\n      if (3 < remaining_size) {\n        src_ptr_temp = (undefined4 *)((int)dest_start + -4);\n        loop_count = remaining_size;\n        dest_ptr = (undefined4 *)src;\n        do {\n          loop_count = loop_count - 4;\n          src_ptr_temp = src_ptr_temp + 1;\n          *src_ptr_temp = *dest_ptr;\n          dest_ptr = dest_ptr + 1;\n        } while (3 < loop_count);\n        i = (remaining_size - 4 & 0xfffffffc) + 4;\n        src = (void *)((int)src + i);\n        remaining_size = size & 3;\n        dest_start = (void *)((int)dest_start + i);\n      }\n    }\n    size = remaining_size;\n    if (remaining_size != 0) {\nLAB_08009abc:\n      src_ptr = (undefined *)((int)dest_start + -1);\n      src_ptr_temp = (undefined4 *)src;\n      do {\n        dest_ptr = (undefined4 *)((int)src_ptr_temp + 1);\n        src_ptr = src_ptr + 1;\n        *src_ptr = *(undefined *)src_ptr_temp;\n        src_ptr_temp = dest_ptr;\n      } while (dest_ptr != (undefined4 *)(size + (int)src));\n      return dest;\n    }\n  }\n  return dest;\n}\n\n",
            "renaming": {
                "FUN_08009a18": "memcpy_reverse_08009a18",
                "__dest": "dest",
                "__src": "src",
                "__n": "size",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr",
                "iVar3": "i",
                "pvVar4": "dest_start",
                "puVar5": "src_end",
                "iVar6": "src_index",
                "uVar7": "loop_count",
                "iVar8": "dest_index",
                "uVar9": "remaining_size",
                "puVar10": "src_ptr_temp"
            },
            "calling": [
                "__ssprint_r",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009adc": {
            "entrypoint": "0x08009adc",
            "current_name": "allocate_memory_08009adc",
            "code": "\nint * allocateMemory_08009adc(undefined4 *lock,int *ptr,uint size)\n\n{\n  int *newPtr;\n  int temp;\n  int *prevPtr;\n  uint var4;\n  int var5;\n  uint var6;\n  size_t var7;\n  int *currentPtr;\n  uint alignedSize;\n  uint var10;\n  uint var11;\n  int endPtr;\n  \n  if (ptr == (int *)0x0) {\n    prevPtr = (int *)_malloc_r(lock,size);\n    return prevPtr;\n  }\n  __malloc_lock();\n  var6 = ptr[-1];\n  var10 = var6 & 0xfffffffc;\n  prevPtr = ptr + -2;\n  if (size + 0xb < 0x17) {\n    alignedSize = 0x10;\n  }\n  else {\n    alignedSize = size + 0xb & 0xfffffff8;\n    if ((int)alignedSize < 0) goto LAB_08009b8e;\n  }\n  if (alignedSize < size) {\nLAB_08009b8e:\n    *lock = 0xc;\n    return (int *)0x0;\n  }\n  endPtr = (int)prevPtr + var10;\n  var11 = var10;\n  if ((int)var10 < (int)alignedSize) {\n    if (DAT_20000454 == endPtr) {\n      endPtr = (*(uint *)(DAT_20000454 + 4) & 0xfffffffc) + var10;\n      if ((int)(alignedSize + 0x10) <= endPtr) {\n        DAT_20000454 = (int)prevPtr + alignedSize;\n        *(uint *)(DAT_20000454 + 4) = endPtr - alignedSize | 1;\n        ptr[-1] = alignedSize | ptr[-1] & 1U;\n        __malloc_unlock(lock);\n        return ptr;\n      }\n      if (-1 < (int)(var6 << 0x1f)) {\n        newPtr = (int *)((int)prevPtr - ptr[-2]);\n        var6 = newPtr[1] & 0xfffffffc;\n        if ((int)(alignedSize + 0x10) <= (int)(endPtr + var6)) {\n          var5 = newPtr[3];\n          prevPtr = newPtr + 2;\n          temp = *prevPtr;\n          var7 = var10 - 4;\n          *(int *)(temp + 0xc) = var5;\n          *(int *)(var5 + 8) = temp;\n          if (var7 < 0x25) {\n            temp = *ptr;\n            currentPtr = prevPtr;\n            if (0x13 < var7) {\n              newPtr[2] = temp;\n              newPtr[3] = ptr[1];\n              temp = ptr[2];\n              if (var7 < 0x1c) {\n                ptr = ptr + 2;\n                currentPtr = newPtr + 4;\n              }\n              else {\n                newPtr[4] = temp;\n                newPtr[5] = ptr[3];\n                temp = ptr[4];\n                if (var7 == 0x24) {\n                  newPtr[6] = temp;\n                  newPtr[7] = ptr[5];\n                  temp = ptr[6];\n                  ptr = ptr + 6;\n                  currentPtr = newPtr + 8;\n                }\n                else {\n                  ptr = ptr + 4;\n                  currentPtr = newPtr + 6;\n                }\n              }\n            }\n            *currentPtr = temp;\n            currentPtr[1] = ptr[1];\n            currentPtr[2] = ptr[2];\n          }\n          else {\n            memmove(prevPtr,ptr,var7);\n          }\n          DAT_20000454 = (int)newPtr + alignedSize;\n          *(uint *)(DAT_20000454 + 4) = (endPtr + var6) - alignedSize | 1;\n          newPtr[1] = alignedSize | newPtr[1] & 1U;\n          __malloc_unlock(lock);\n          return prevPtr;\n        }\nLAB_08009bb0:\n        var11 = var10 + var6;\n        if ((int)alignedSize <= (int)var11) {\n          var5 = newPtr[3];\n          currentPtr = newPtr + 2;\n          temp = *currentPtr;\n          *(int *)(temp + 0xc) = var5;\n          endPtr = (int)newPtr + var11;\n          *(int *)(var5 + 8) = temp;\n          prevPtr = newPtr;\n          if (var10 - 4 < 0x25) goto LAB_08009bd0;\nLAB_08009d4c:\n          memmove(currentPtr,ptr,var10 - 4);\n          ptr = currentPtr;\n          goto LAB_08009c00;\n        }\n      }\n    }\n    else {\n      if (-1 < *(int *)((*(uint *)(endPtr + 4) & 0xfffffffe) + endPtr + 4) << 0x1f) {\n        var4 = *(uint *)(endPtr + 4) & 0xfffffffc;\n        var11 = var10 + var4;\n        if ((int)var11 < (int)alignedSize) {\n          if ((int)(var6 << 0x1f) < 0) goto LAB_08009b36;\n          newPtr = (int *)((int)prevPtr - ptr[-2]);\n          var6 = newPtr[1] & 0xfffffffc;\n          var11 = var4 + var6 + var10;\n          if ((int)var11 < (int)alignedSize) goto LAB_08009bb0;\n          temp = *(int *)(endPtr + 8);\n          endPtr = *(int *)(endPtr + 0xc);\n          *(int *)(temp + 0xc) = endPtr;\n          *(int *)(endPtr + 8) = temp;\n          currentPtr = newPtr + 2;\n          temp = *currentPtr;\n          var5 = newPtr[3];\n          *(int *)(temp + 0xc) = var5;\n          endPtr = (int)newPtr + var11;\n          *(int *)(var5 + 8) = temp;\n          prevPtr = newPtr;\n          if (0x24 < var10 - 4) goto LAB_08009d4c;\nLAB_08009bd0:\n          var10 = var10 - 4;\n          temp = *ptr;\n          newPtr = currentPtr;\n          if (0x13 < var10) {\n            prevPtr[2] = temp;\n            prevPtr[3] = ptr[1];\n            temp = ptr[2];\n            if (var10 < 0x1c) {\n              ptr = ptr + 2;\n              newPtr = prevPtr + 4;\n            }\n            else {\n              prevPtr[4] = temp;\n              prevPtr[5] = ptr[3];\n              temp = ptr[4];\n              if (var10 == 0x24) {\n                prevPtr[6] = temp;\n                prevPtr[7] = ptr[5];\n                temp = ptr[6];\n                ptr = ptr + 6;\n                newPtr = prevPtr + 8;\n              }\n              else {\n                ptr = ptr + 4;\n                newPtr = prevPtr + 6;\n              }\n            }\n          }\n          *newPtr = temp;\n          newPtr[1] = ptr[1];\n          newPtr[2] = ptr[2];\n          ptr = currentPtr;\n        }\n        else {\n          temp = *(int *)(endPtr + 8);\n          var5 = *(int *)(endPtr + 0xc);\n          *(int *)(temp + 0xc) = var5;\n          endPtr = (int)prevPtr + var11;\n          *(int *)(var5 + 8) = temp;\n        }\n        goto LAB_08009c00;\n      }\n      if (-1 < (int)(var6 << 0x1f)) {\n        newPtr = (int *)((int)prevPtr - ptr[-2]);\n        var6 = newPtr[1] & 0xfffffffc;\n        goto LAB_08009bb0;\n      }\n    }\nLAB_08009b36:\n    newPtr = (int *)_malloc_r(lock,size);\n    if (newPtr != (int *)0x0) {\n      if ((int *)((ptr[-1] & 0xfffffffeU) + (int)prevPtr) == newPtr + -2) {\n        var11 = var10 + (newPtr[-1] & 0xfffffffcU);\n        endPtr = (int)prevPtr + var11;\n        goto LAB_08009c00;\n      }\n      var7 = var10 - 4;\n      if (var7 < 0x25) {\n        endPtr = *ptr;\n        prevPtr = ptr;\n        currentPtr = newPtr;\n        if (0x13 < var7) {\n          *newPtr = endPtr;\n          newPtr[1] = ptr[1];\n          if (var7 < 0x1c) {\n            endPtr = ptr[2];\n            prevPtr = ptr + 2;\n            currentPtr = newPtr + 2;\n          }\n          else {\n            newPtr[2] = ptr[2];\n            newPtr[3] = ptr[3];\n            if (var7 == 0x24) {\n              newPtr[4] = ptr[4];\n              newPtr[5] = ptr[5];\n              endPtr = ptr[6];\n              prevPtr = ptr + 6;\n              currentPtr = newPtr + 6;\n            }\n            else {\n              endPtr = ptr[4];\n              prevPtr = ptr + 4;\n              currentPtr = newPtr + 4;\n            }\n          }\n        }\n        *currentPtr = endPtr;\n        currentPtr[1] = prevPtr[1];\n        currentPtr[2] = prevPtr[2];\n      }\n      else {\n        memmove(newPtr,ptr,var7);\n      }\n      _free_r(lock,ptr);\n    }\n    __malloc_unlock(lock);\n    ptr = newPtr;\n  }\n  else {\nLAB_08009c00:\n    if (var11 - alignedSize < 0x10) {\n      prevPtr[1] = prevPtr[1] & 1U | var11;\n      *(uint *)(endPtr + 4) = *(uint *)(endPtr + 4) | 1;\n    }\n    else {\n      prevPtr[1] = prevPtr[1] & 1U | alignedSize;\n      *(uint *)((int)prevPtr + alignedSize + 4) = var11 - alignedSize | 1;\n      *(uint *)(endPtr + 4) = *(uint *)(endPtr + 4) | 1;\n      _free_r(lock,(int)prevPtr + alignedSize + 8);\n    }\n    __malloc_unlock(lock);\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_08009adc": "allocate_memory_08009adc",
                "param_1": "lock",
                "param_2": "ptr",
                "param_3": "size",
                "piVar1": "newPtr",
                "iVar2": "temp",
                "piVar3": "prevPtr",
                "uVar4": "var4",
                "iVar5": "var5",
                "uVar6": "var6",
                "sVar7": "var7",
                "piVar8": "currentPtr",
                "uVar9": "alignedSize",
                "uVar10": "var10",
                "uVar11": "var11",
                "iVar12": "endPtr"
            },
            "calling": [
                "__ssprint_r"
            ],
            "called": [
                "_malloc_r",
                "memmove",
                "_free_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e50": {
            "entrypoint": "0x08009e50",
            "current_name": "copy_byte_to_buffer_08009e50",
            "code": "\nundefined * copyByteToBuffer_08009e50(undefined4 *buffer,undefined *destination,uint value)\n\n{\n  if (destination != (undefined *)0x0) {\n    if (value < 0x100) {\n      *destination = (char)value;\n      destination = (undefined *)0x1;\n    }\n    else {\n      destination = (undefined *)0xffffffff;\n      *buffer = 0x8a;\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08009e50": "copy_byte_to_buffer_08009e50",
                "param_1": "buffer",
                "param_2": "destination",
                "param_3": "value"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e68": {
            "entrypoint": "0x08009e68",
            "current_name": "get_context_pointer_08009e68",
            "code": "\nint getContextPointer_08009e68(EVP_PKEY_CTX *context)\n\n{\n  return (int)context;\n}\n\n",
            "renaming": {
                "FUN_08009e68": "get_context_pointer_08009e68",
                "ctx": "context"
            },
            "calling": [
                "__do_global_dtors_aux",
                "__libc_init_array",
                "frame_dummy"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e74": {
            "entrypoint": "0x08009e74",
            "current_name": "FUNC_08009e74",
            "code": "\nvoid FUNC_08009e74(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e74": "FUNC_08009e74"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 163905,
    "layers": [
        [
            "FUN_08000110",
            "FUN_08000134",
            "FUN_08000150",
            "FUN_08000158",
            "FUN_0800015c",
            "FUN_080003d4",
            "FUN_080003f4",
            "FUN_08000418",
            "FUN_0800045c",
            "FUN_0800046c",
            "FUN_080006a4",
            "FUN_0800088a",
            "FUN_080008ec",
            "FUN_080008f4",
            "FUN_080008fc",
            "FUN_08000978",
            "FUN_08000988",
            "FUN_08000998",
            "FUN_080009ac",
            "FUN_080009c0",
            "FUN_080009d4",
            "FUN_080009e8",
            "FUN_080009fc",
            "FUN_08000a9c",
            "FUN_08000aa4",
            "FUN_08000aa8",
            "FUN_08000c08",
            "FUN_08000c10",
            "FUN_08000c2c",
            "FUN_08000c3c",
            "FUN_08000cb8",
            "FUN_08000e20",
            "FUN_08000f58",
            "FUN_08000f60",
            "FUN_08000f68",
            "FUN_08000fc8",
            "FUN_08000fd0",
            "FUN_08000fe0",
            "FUN_08000ff4",
            "FUN_08001008",
            "FUN_0800101c",
            "FUN_08001030",
            "FUN_08001044",
            "FUN_08001084",
            "FUN_08001170",
            "FUN_0800119c",
            "FUN_080011ec",
            "FUN_0800121c",
            "FUN_080014f0",
            "FUN_0800151c",
            "FUN_0800157c",
            "FUN_080015a0",
            "FUN_080015b4",
            "FUN_080015fc",
            "FUN_08001618",
            "FUN_0800166c",
            "FUN_080016d0",
            "FUN_08001714",
            "FUN_0800172a",
            "FUN_08001762",
            "FUN_0800177c",
            "FUN_080017b4",
            "FUN_080017c4",
            "FUN_08001a80",
            "FUN_08001ab0",
            "FUN_08001cb8",
            "FUN_08001ccc",
            "FUN_08001f6c",
            "FUN_08002640",
            "FUN_080027f4",
            "FUN_08002ad8",
            "FUN_08002bb4",
            "FUN_08002c2e",
            "FUN_08002ca8",
            "FUN_08002d3c",
            "FUN_08002d98",
            "FUN_08003260",
            "FUN_08003440",
            "FUN_08003504",
            "FUN_08003518",
            "FUN_08003540",
            "FUN_08003568",
            "FUN_080035a4",
            "FUN_080035fa",
            "FUN_0800360c",
            "FUN_08003640",
            "FUN_08003696",
            "FUN_080036a8",
            "FUN_080036f8",
            "FUN_08003908",
            "FUN_08003a94",
            "FUN_08003c4a",
            "FUN_08003c5c",
            "FUN_08003c6e",
            "FUN_08003c80",
            "FUN_08003c94",
            "FUN_08003d60",
            "FUN_08003e38",
            "FUN_08003f18",
            "FUN_08003ff8",
            "FUN_080040a0",
            "FUN_08004104",
            "FUN_0800416a",
            "FUN_080041a8",
            "FUN_080041ea",
            "FUN_0800422e",
            "FUN_080042de",
            "FUN_08004366",
            "FUN_08004378",
            "FUN_0800438a",
            "FUN_08004424",
            "FUN_08004436",
            "FUN_080046ec",
            "FUN_0800491c",
            "FUN_080049cc",
            "FUN_08004ae0",
            "FUN_08004bd8",
            "FUN_08004d78",
            "FUN_08004e6c",
            "FUN_08004e74",
            "FUN_08004ea4",
            "FUN_08004ee8",
            "FUN_08004f2c",
            "FUN_08004f3c",
            "FUN_08004f60",
            "FUN_08004f78",
            "FUN_08005224",
            "FUN_080052a0",
            "FUN_08005348",
            "FUN_080053b0",
            "FUN_08005500",
            "FUN_08005598",
            "FUN_080055f4",
            "FUN_08005674",
            "FUN_08005680",
            "FUN_080056c8",
            "FUN_080056ce",
            "FUN_080056d4",
            "FUN_080056da",
            "FUN_08005704",
            "FUN_08005714",
            "FUN_08005728",
            "FUN_08005780",
            "FUN_080057e8",
            "FUN_08005830",
            "FUN_08005838",
            "FUN_080059f0",
            "FUN_08005d0c",
            "FUN_08005d14",
            "FUN_08005d20",
            "FUN_08005d68",
            "FUN_08005dfc",
            "FUN_08005e40",
            "FUN_080078b4",
            "FUN_080078c0",
            "FUN_080079e8",
            "FUN_08008818",
            "FUN_0800884c",
            "FUN_080088ec",
            "FUN_08008ad4",
            "FUN_08008af8",
            "FUN_0800901c",
            "FUN_080090a8",
            "FUN_080090b4",
            "FUN_080090c0",
            "FUN_0800910c",
            "FUN_08009120",
            "FUN_080091a4",
            "FUN_080091e4",
            "FUN_08009244",
            "FUN_08009258",
            "FUN_080093a4",
            "FUN_08009444",
            "FUN_080094f8",
            "FUN_08009530",
            "FUN_08009630",
            "FUN_080096e0",
            "FUN_08009744",
            "FUN_08009768",
            "FUN_080097cc",
            "FUN_080098c0",
            "FUN_08009980",
            "FUN_080099ec",
            "FUN_08009a18",
            "FUN_08009adc",
            "FUN_08009e50",
            "FUN_08009e68"
        ],
        [
            "FUN_080004c8",
            "FUN_0800071c"
        ]
    ],
    "locked_functions": []
}