{
    "functions": {
        "FUN_0800010c": {
            "entrypoint": "0x0800010c",
            "current_name": "initialize_completed_flag_0800010c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08000118) */\n\nundefined4 initializeCompletedFlag_0800010c(undefined4 inputValue)\n\n{\n  if ((char)completionFlag == '\\0') {\n    completionFlag._0_1_ = '\\x01';\n  }\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_0800010c": "initialize_completed_flag_0800010c",
                "param_1": "inputValue",
                "completed_8667": "completionFlag"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000130": {
            "entrypoint": "0x08000130",
            "current_name": "FUNC_08000130",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08000134) */\n/* WARNING: Removing unreachable block (ram,0x0800014e) */\n/* WARNING: Removing unreachable block (ram,0x08000144) */\n/* WARNING: Removing unreachable block (ram,0x08000160) */\n/* WARNING: Removing unreachable block (ram,0x08000154) */\n\n\nvoid FUNC_08000130(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000130": "FUNC_08000130"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000178": {
            "entrypoint": "0x08000178",
            "current_name": "calculate_string_length_08000178",
            "code": "\nsize_t calculateStringLength_08000178(char *inputString)\n\n{\n  char currentCharacter;\n  char *nextCharacterPointer;\n  char *currentCharacterPointer;\n  \n  currentCharacterPointer = inputString;\n  do {\n    nextCharacterPointer = currentCharacterPointer + 1;\n    currentCharacter = *currentCharacterPointer;\n    currentCharacterPointer = nextCharacterPointer;\n  } while (currentCharacter != '\\0');\n  return (size_t)(nextCharacterPointer + (-1 - (int)inputString));\n}\n\n",
            "renaming": {
                "FUN_08000178": "calculate_string_length_08000178",
                "__s": "inputString",
                "cVar1": "currentCharacter",
                "pcVar2": "nextCharacterPointer",
                "pcVar3": "currentCharacterPointer"
            },
            "calling": [
                "print",
                "printNumber"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000188": {
            "entrypoint": "0x08000188",
            "current_name": "addition_with_xor_08000188",
            "code": "\nvoid additionWithXor_08000188(undefined4 result,uint inputNumber)\n\n{\n  __aeabi_dadd(result,inputNumber ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000188": "addition_with_xor_08000188",
                "param_1": "result",
                "param_2": "inputNumber"
            },
            "calling": [],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000190": {
            "entrypoint": "0x08000190",
            "current_name": "perform_calculation_08000190",
            "code": "\nulonglong performCalculation_08000190(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int tempVar1;\n  byte tempVar2;\n  uint tempVar3;\n  uint tempVar4;\n  uint tempVar5;\n  uint tempVar6;\n  uint tempVar7;\n  int tempVar8;\n  uint tempVar9;\n  uint tempVar10;\n  uint tempVar11;\n  uint tempVar12;\n  bool tempVar13;\n  bool tempVar14;\n  bool tempVar15;\n  \n  tempVar6 = input4 ^ 0x80000000;\n  tempVar9 = input2 << 1;\n  input4 = input4 << 1;\n  tempVar13 = ((input2 ^ tempVar6) & 0x7fffffff) == 0;\n  tempVar14 = tempVar13 && input1 == input3;\n  if (!tempVar13 || input1 != input3) {\n    tempVar14 = (tempVar9 | input1) == 0;\n  }\n  if (!tempVar14) {\n    tempVar14 = (input4 | input3) == 0;\n  }\n  tempVar8 = (int)tempVar9 >> 0x15;\n  if (!tempVar14) {\n    tempVar14 = tempVar8 == -1;\n  }\n  tempVar1 = (int)input4 >> 0x15;\n  if (!tempVar14) {\n    tempVar14 = tempVar1 == -1;\n  }\n  if (tempVar14) {\n    if (tempVar8 == -1 || tempVar1 == -1) {\n      tempVar9 = tempVar6;\n      tempVar11 = input3;\n      if (tempVar8 == -1) {\n        tempVar9 = input2;\n        tempVar11 = input1;\n      }\n      if (tempVar8 != -1 || tempVar1 != -1) {\n        input3 = tempVar11;\n        tempVar6 = tempVar9;\n      }\n      tempVar14 = (tempVar11 | tempVar9 << 0xc) == 0;\n      if (tempVar14) {\n        tempVar14 = (input3 | tempVar6 << 0xc) == 0;\n      }\n      if (tempVar14) {\n        tempVar14 = tempVar9 == tempVar6;\n      }\n      if (!tempVar14) {\n        tempVar9 = tempVar9 | 0x80000;\n      }\n      return CONCAT44(tempVar9,tempVar11);\n    }\n    if (((input2 ^ tempVar6) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((tempVar9 | input1) == 0) {\n        input1 = input3;\n        input2 = tempVar6;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != tempVar6) {\n      return 0;\n    }\n    if (tempVar9 >> 0x15 == 0) {\n      tempVar14 = (input1 & 0x80000000) != 0;\n      tempVar6 = input2 * 2 + (uint)tempVar14;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)tempVar14)) {\n        tempVar6 = tempVar6 | 0x80000000;\n      }\n      return CONCAT44(tempVar6,input1 << 1);\n    }\n    if (tempVar9 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  tempVar9 = tempVar9 >> 0x15;\n  input4 = input4 >> 0x15;\n  tempVar11 = input4 - tempVar9;\n  tempVar14 = tempVar11 != 0;\n  if (input4 < tempVar9) {\n    tempVar11 = -tempVar11;\n  }\n  tempVar10 = input1;\n  tempVar7 = input2;\n  if (tempVar14 && tempVar9 <= input4) {\n    tempVar9 = tempVar9 + tempVar11;\n    tempVar10 = input3;\n    tempVar7 = tempVar6;\n    input3 = input1;\n    tempVar6 = input2;\n  }\n  if (0x36 < tempVar11) {\n    return CONCAT44(tempVar7,tempVar10);\n  }\n  tempVar4 = tempVar7 & 0xfffff | 0x100000;\n  if ((tempVar7 & 0x80000000) != 0) {\n    tempVar14 = tempVar10 != 0;\n    tempVar10 = -tempVar10;\n    tempVar4 = -tempVar4 - (uint)tempVar14;\n  }\n  tempVar7 = tempVar6 & 0xfffff | 0x100000;\n  if ((tempVar6 & 0x80000000) != 0) {\n    tempVar14 = input3 != 0;\n    input3 = -input3;\n    tempVar7 = -tempVar7 - (uint)tempVar14;\n  }\n  if (tempVar9 == tempVar11) {\n    tempVar7 = tempVar7 ^ 0x100000;\n    if (tempVar9 == 0) {\n      tempVar4 = tempVar4 ^ 0x100000;\n      tempVar9 = 1;\n    }\n    else {\n      tempVar11 = tempVar11 - 1;\n    }\n  }\n  tempVar6 = -tempVar11 + 0x20;\n  if ((int)tempVar11 < 0x21) {\n    tempVar12 = input3 << (tempVar6 & 0xff);\n    input3 = input3 >> (tempVar11 & 0xff);\n    tempVar3 = tempVar10 + input3;\n    tempVar5 = tempVar7 << (tempVar6 & 0xff);\n    tempVar6 = tempVar3 + tempVar5;\n    tempVar4 = tempVar4 + CARRY4(tempVar10,input3) + ((int)tempVar7 >> (tempVar11 & 0xff)) +\n            (uint)CARRY4(tempVar3,tempVar5);\n  }\n  else {\n    tempVar12 = tempVar7 << (-tempVar11 + 0x40 & 0xff);\n    if (input3 != 0) {\n      tempVar12 = tempVar12 | 2;\n    }\n    tempVar7 = (int)tempVar7 >> (tempVar11 - 0x20 & 0xff);\n    tempVar6 = tempVar10 + tempVar7;\n    tempVar4 = tempVar4 + ((int)tempVar7 >> 0x1f) + (uint)CARRY4(tempVar10,tempVar7);\n  }\n  input2 = tempVar4 & 0x80000000;\n  tempVar11 = tempVar4;\n  if ((int)tempVar4 < 0) {\n    tempVar14 = tempVar12 == 0;\n    tempVar12 = -tempVar12;\n    tempVar11 = -tempVar6;\n    tempVar6 = -(uint)!tempVar14 - tempVar6;\n    tempVar11 = -(uint)(tempVar14 <= tempVar11) - tempVar4;\n  }\n  if (0xfffff < tempVar11) {\n    tempVar10 = tempVar9 - 1;\n    if (0x1fffff < tempVar11) {\n      tempVar10 = tempVar11 & 1;\n      tempVar11 = tempVar11 >> 1;\n      tempVar2 = (byte)tempVar6;\n      tempVar6 = (uint)(tempVar10 != 0) << 0x1f | tempVar6 >> 1;\n      tempVar12 = (uint)(tempVar2 & 1) << 0x1f | tempVar12 >> 1;\n      tempVar10 = tempVar9;\n      if (0xffbfffff < tempVar9 * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    tempVar14 = 0x7fffffff < tempVar12;\n    if (tempVar12 == 0x80000000) {\n      tempVar14 = (tempVar6 & 1) != 0;\n    }\n    return CONCAT44(tempVar11 + tempVar10 * 0x100000 + (uint)CARRY4(tempVar6,(uint)tempVar14) | input2,\n                    tempVar6 + tempVar14);\n  }\n  tempVar13 = (tempVar12 & 0x80000000) != 0;\n  tempVar12 = tempVar12 << 1;\n  tempVar10 = tempVar6 * 2;\n  tempVar14 = CARRY4(tempVar6,tempVar6);\n  tempVar6 = tempVar6 * 2 + (uint)tempVar13;\n  tempVar11 = tempVar11 * 2 + (uint)(tempVar14 || CARRY4(tempVar10,(uint)tempVar13));\n  tempVar10 = tempVar9 - 2;\n  if ((tempVar11 & 0x100000) != 0) goto LAB_080002a0;\n  tempVar7 = tempVar6;\n  tempVar9 = tempVar11;\n  if (tempVar11 == 0) {\n    tempVar7 = 0;\n    tempVar9 = tempVar6;\n  }\n  tempVar8 = LZCOUNT(tempVar9);\n  if (tempVar11 == 0) {\n    tempVar8 = tempVar8 + 0x20;\n  }\n  tempVar11 = tempVar8 - 0xb;\n  tempVar15 = SBORROW4(tempVar11,0x20);\n  tempVar6 = tempVar8 - 0x2b;\n  tempVar14 = (int)tempVar6 < 0;\n  tempVar13 = tempVar6 == 0;\n  if ((int)tempVar11 < 0x20) {\n    tempVar15 = SCARRY4(tempVar6,0xc);\n    tempVar8 = tempVar8 + -0x1f;\n    tempVar14 = tempVar8 < 0;\n    tempVar13 = tempVar8 == 0;\n    tempVar6 = tempVar11;\n    if (!tempVar13 && tempVar14 == tempVar15) {\n      tempVar7 = tempVar9 << (tempVar11 & 0xff);\n      tempVar9 = tempVar9 >> (0xcU - tempVar8 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (tempVar13 || tempVar14 != tempVar15) {\n    tempVar12 = 0x20 - tempVar6;\n  }\n  tempVar9 = tempVar9 << (tempVar6 & 0xff);\n  if (tempVar13 || tempVar14 != tempVar15) {\n    tempVar9 = tempVar9 | tempVar7 >> (tempVar12 & 0xff);\n  }\n  if (tempVar13 || tempVar14 != tempVar15) {\n    tempVar7 = tempVar7 << (tempVar6 & 0xff);\n  }\nLAB_08000318:\n  if ((int)tempVar11 <= (int)tempVar10) {\n    return CONCAT44(tempVar9 + (tempVar10 - tempVar11) * 0x100000 | input2,tempVar7);\n  }\n  tempVar6 = ~(tempVar10 - tempVar11);\n  if ((int)tempVar6 < 0x1f) {\n    tempVar8 = tempVar6 - 0x13;\n    if (tempVar8 != 0 && tempVar8 < 0 == SCARRY4(tempVar6 - 0x1f,0xc)) {\n      return CONCAT44(tempVar4,tempVar7 >> (0x20 - (0xcU - tempVar8) & 0xff) | tempVar9 << (0xcU - tempVar8 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    tempVar6 = tempVar6 + 1;\n    return CONCAT44(input2 | tempVar9 >> (tempVar6 & 0xff),\n                    tempVar7 >> (tempVar6 & 0xff) | tempVar9 << (0x20 - tempVar6 & 0xff));\n  }\n  return CONCAT44(tempVar4,tempVar9 >> (tempVar6 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000190": "perform_calculation_08000190",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "tempVar1",
                "bVar2": "tempVar2",
                "uVar3": "tempVar3",
                "uVar4": "tempVar4",
                "uVar5": "tempVar5",
                "uVar6": "tempVar6",
                "uVar7": "tempVar7",
                "iVar8": "tempVar8",
                "uVar9": "tempVar9",
                "uVar10": "tempVar10",
                "uVar11": "tempVar11",
                "uVar12": "tempVar12",
                "bVar13": "tempVar13",
                "bVar14": "tempVar14",
                "bVar15": "tempVar15"
            },
            "calling": [
                "SetTunings",
                "Compute",
                "SetControllerDirection",
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000194": {
            "entrypoint": "0x08000194",
            "current_name": "calculate_sum_08000194",
            "code": "\nulonglong calculate_sum_08000194(uint number1,uint number2,uint number3,uint number4)\n\n{\n  int shift1;\n  byte carry;\n  uint sum1;\n  uint sum2;\n  uint temp1;\n  int shift2;\n  uint shifted_num1;\n  uint shifted_num2;\n  uint normalized_num1;\n  uint normalized_num2;\n  uint higher_bits;\n  uint lower_bits;\n  bool is_equal;\n  bool is_zero;\n  bool is_negative;\n  \n  shifted_num1 = number2 << 1;\n  normalized_num1 = number4 << 1;\n  is_equal = ((number2 ^ number4) & 0x7fffffff) == 0;\n  is_zero = is_equal && number1 == number3;\n  if (!is_equal || number1 != number3) {\n    is_zero = (shifted_num1 | number1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = (normalized_num1 | number3) == 0;\n  }\n  shift2 = (int)shifted_num1 >> 0x15;\n  if (!is_zero) {\n    is_zero = shift2 == -1;\n  }\n  shift1 = (int)normalized_num1 >> 0x15;\n  if (!is_zero) {\n    is_zero = shift1 == -1;\n  }\n  if (is_zero) {\n    if (shift2 == -1 || shift1 == -1) {\n      normalized_num1 = number4;\n      shifted_num1 = number3;\n      if (shift2 == -1) {\n        normalized_num1 = number2;\n        shifted_num1 = number1;\n      }\n      if (shift2 != -1 || shift1 != -1) {\n        number3 = shifted_num1;\n        number4 = normalized_num1;\n      }\n      is_zero = (shifted_num1 | normalized_num1 << 0xc) == 0;\n      if (is_zero) {\n        is_zero = (number3 | number4 << 0xc) == 0;\n      }\n      if (is_zero) {\n        is_zero = normalized_num1 == number4;\n      }\n      if (!is_zero) {\n        normalized_num1 = normalized_num1 | 0x80000;\n      }\n      return CONCAT44(normalized_num1,shifted_num1);\n    }\n    if (((number2 ^ number4) & 0x7fffffff) != 0 || number1 != number3) {\n      if ((shifted_num1 | number1) == 0) {\n        number1 = number3;\n        number2 = number4;\n      }\n      return CONCAT44(number2,number1);\n    }\n    if (number2 != number4) {\n      return 0;\n    }\n    if (shifted_num1 >> 0x15 == 0) {\n      is_zero = (number1 & 0x80000000) != 0;\n      normalized_num1 = number2 * 2 + (uint)is_zero;\n      if (CARRY4(number2,number2) || CARRY4(number2 * 2,(uint)is_zero)) {\n        normalized_num1 = normalized_num1 | 0x80000000;\n      }\n      return CONCAT44(normalized_num1,number1 << 1);\n    }\n    if (shifted_num1 < 0xffc00000) {\n      return CONCAT44(number2 + 0x100000,number1);\n    }\n    number2 = number2 & 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(number2 | 0x7ff00000) << 0x20;\n  }\n  shifted_num1 = shifted_num1 >> 0x15;\n  normalized_num1 = normalized_num1 >> 0x15;\n  normalized_num2 = normalized_num1 - shifted_num1;\n  is_zero = normalized_num2 != 0;\n  if (normalized_num1 < shifted_num1) {\n    normalized_num2 = -normalized_num2;\n  }\n  shifted_num2 = number1;\n  temp1 = number2;\n  if (is_zero && shifted_num1 <= normalized_num1) {\n    shifted_num1 = shifted_num1 + normalized_num2;\n    shifted_num2 = number3;\n    temp1 = number4;\n    number3 = number1;\n    number4 = number2;\n  }\n  if (0x36 < normalized_num2) {\n    return CONCAT44(temp1,shifted_num2);\n  }\n  normalized_num1 = temp1 & 0xfffff | 0x100000;\n  if ((temp1 & 0x80000000) != 0) {\n    is_zero = shifted_num2 != 0;\n    shifted_num2 = -shifted_num2;\n    normalized_num1 = -normalized_num1 - (uint)is_zero;\n  }\n  temp1 = number4 & 0xfffff | 0x100000;\n  if ((number4 & 0x80000000) != 0) {\n    is_zero = number3 != 0;\n    number3 = -number3;\n    temp1 = -temp1 - (uint)is_zero;\n  }\n  if (shifted_num1 == normalized_num2) {\n    temp1 = temp1 ^ 0x100000;\n    if (shifted_num1 == 0) {\n      normalized_num1 = normalized_num1 ^ 0x100000;\n      shifted_num1 = 1;\n    }\n    else {\n      normalized_num2 = normalized_num2 - 1;\n    }\n  }\n  lower_bits = -normalized_num2 + 0x20;\n  if ((int)normalized_num2 < 0x21) {\n    higher_bits = number3 << (lower_bits & 0xff);\n    number3 = number3 >> (normalized_num2 & 0xff);\n    sum1 = shifted_num2 + number3;\n    sum2 = temp1 << (lower_bits & 0xff);\n    lower_bits = sum1 + sum2;\n    normalized_num1 = normalized_num1 + CARRY4(shifted_num2,number3) + ((int)temp1 >> (normalized_num2 & 0xff)) +\n            (uint)CARRY4(sum1,sum2);\n  }\n  else {\n    higher_bits = temp1 << (-normalized_num2 + 0x40 & 0xff);\n    if (number3 != 0) {\n      higher_bits = higher_bits | 2;\n    }\n    temp1 = (int)temp1 >> (normalized_num2 - 0x20 & 0xff);\n    lower_bits = shifted_num2 + temp1;\n    normalized_num1 = normalized_num1 + ((int)temp1 >> 0x1f) + (uint)CARRY4(shifted_num2,temp1);\n  }\n  number2 = normalized_num1 & 0x80000000;\n  normalized_num2 = normalized_num1;\n  if ((int)normalized_num1 < 0) {\n    is_zero = higher_bits == 0;\n    higher_bits = -higher_bits;\n    normalized_num2 = -lower_bits;\n    lower_bits = -(uint)!is_zero - lower_bits;\n    normalized_num2 = -(uint)(is_zero <= normalized_num2) - normalized_num1;\n  }\n  if (0xfffff < normalized_num2) {\n    shifted_num2 = shifted_num1 - 1;\n    if (0x1fffff < normalized_num2) {\n      normalized_num1 = normalized_num2 & 1;\n      normalized_num2 = normalized_num2 >> 1;\n      carry = (byte)lower_bits;\n      lower_bits = (uint)(normalized_num1 != 0) << 0x1f | lower_bits >> 1;\n      higher_bits = (uint)(carry & 1) << 0x1f | higher_bits >> 1;\n      shifted_num2 = shifted_num1;\n      if (0xffbfffff < shifted_num1 * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    is_zero = 0x7fffffff < higher_bits;\n    if (higher_bits == 0x80000000) {\n      is_zero = (lower_bits & 1) != 0;\n    }\n    return CONCAT44(normalized_num2 + shifted_num2 * 0x100000 + (uint)CARRY4(lower_bits,(uint)is_zero) | number2,\n                    lower_bits + is_zero);\n  }\n  is_equal = (higher_bits & 0x80000000) != 0;\n  higher_bits = higher_bits << 1;\n  shifted_num2 = lower_bits * 2;\n  is_zero = CARRY4(lower_bits,lower_bits);\n  lower_bits = lower_bits * 2 + (uint)is_equal;\n  normalized_num2 = normalized_num2 * 2 + (uint)(is_zero || CARRY4(shifted_num2,(uint)is_equal));\n  shifted_num2 = shifted_num1 - 2;\n  if ((normalized_num2 & 0x100000) != 0) goto LAB_080002a0;\n  temp1 = lower_bits;\n  shifted_num1 = normalized_num2;\n  if (normalized_num2 == 0) {\n    temp1 = 0;\n    shifted_num1 = lower_bits;\n  }\n  shift2 = LZCOUNT(shifted_num1);\n  if (normalized_num2 == 0) {\n    shift2 = shift2 + 0x20;\n  }\n  lower_bits = shift2 - 0xb;\n  is_negative = SBORROW4(lower_bits,0x20);\n  normalized_num2 = shift2 - 0x2b;\n  is_zero = (int)normalized_num2 < 0;\n  is_equal = normalized_num2 == 0;\n  if ((int)lower_bits < 0x20) {\n    is_negative = SCARRY4(normalized_num2,0xc);\n    shift2 = shift2 + -0x1f;\n    is_zero = shift2 < 0;\n    is_equal = shift2 == 0;\n    normalized_num2 = lower_bits;\n    if (!is_equal && is_zero == is_negative) {\n      temp1 = shifted_num1 << (lower_bits & 0xff);\n      shifted_num1 = shifted_num1 >> (0xcU - shift2 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (is_equal || is_zero != is_negative) {\n    higher_bits = 0x20 - normalized_num2;\n  }\n  shifted_num1 = shifted_num1 << (normalized_num2 & 0xff);\n  if (is_equal || is_zero != is_negative) {\n    shifted_num1 = shifted_num1 | temp1 >> (higher_bits & 0xff);\n  }\n  if (is_equal || is_zero != is_negative) {\n    temp1 = temp1 << (normalized_num2 & 0xff);\n  }\nLAB_08000318:\n  if ((int)lower_bits <= (int)shifted_num2) {\n    return CONCAT44(shifted_num1 + (shifted_num2 - lower_bits) * 0x100000 | number2,temp1);\n  }\n  normalized_num2 = ~(shifted_num2 - lower_bits);\n  if ((int)normalized_num2 < 0x1f) {\n    shift2 = normalized_num2 - 0x13;\n    if (shift2 != 0 && shift2 < 0 == SCARRY4(normalized_num2 - 0x1f,0xc)) {\n      return CONCAT44(normalized_num1,temp1 >> (0x20 - (0xcU - shift2) & 0xff) | shifted_num1 << (0xcU - shift2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    normalized_num2 = normalized_num2 + 1;\n    return CONCAT44(number2 | shifted_num1 >> (normalized_num2 & 0xff),\n                    temp1 >> (normalized_num2 & 0xff) | shifted_num1 << (0x20 - normalized_num2 & 0xff));\n  }\n  return CONCAT44(normalized_num1,shifted_num1 >> (normalized_num2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000194": "calculate_sum_08000194",
                "param_1": "number1",
                "param_2": "number2",
                "param_3": "number3",
                "param_4": "number4",
                "iVar1": "shift1",
                "bVar2": "carry",
                "uVar3": "sum1",
                "uVar4": "sum2",
                "uVar5": "temp1",
                "iVar6": "shift2",
                "uVar7": "shifted_num1",
                "uVar8": "shifted_num2",
                "uVar9": "normalized_num1",
                "uVar10": "normalized_num2",
                "uVar11": "higher_bits",
                "uVar12": "lower_bits",
                "bVar13": "is_equal",
                "bVar14": "is_zero",
                "bVar15": "is_negative"
            },
            "calling": [
                "loop",
                "Compute",
                "__aeabi_drsub",
                "readThermocouple",
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800040c": {
            "entrypoint": "0x0800040c",
            "current_name": "reverse_and_shift_0800040c",
            "code": "\nulonglong reverse_and_shift_0800040c(uint input_num)\n\n{\n  uint shifted_num;\n  uint shift_amount;\n  int bit_count;\n  uint combined_value;\n  uint shifted_bits;\n  bool is_negative;\n  bool is_zero;\n  bool is_overflow;\n  \n  if (input_num == 0) {\n    return 0;\n  }\n  shifted_num = 0;\n  bit_count = LZCOUNT(input_num);\n  combined_value = bit_count + 0x15;\n  is_overflow = SBORROW4(combined_value,0x20);\n  shift_amount = bit_count - 0xb;\n  is_negative = (int)shift_amount < 0;\n  is_zero = shift_amount == 0;\n  if (combined_value < 0x20) {\n    is_overflow = SCARRY4(shift_amount,0xc);\n    is_negative = false;\n    is_zero = bit_count + 1 == 0;\n    shift_amount = combined_value;\n    if (!is_zero && is_overflow == false) {\n      shifted_num = input_num << combined_value;\n      input_num = input_num >> (0xcU - (bit_count + 1) & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (is_zero || is_negative != is_overflow) {\n    shifted_bits = 0x20 - shift_amount;\n  }\n  input_num = input_num << (shift_amount & 0xff);\n  if (is_zero || is_negative != is_overflow) {\n    input_num = input_num | 0U >> (shifted_bits & 0xff);\n  }\n  if (is_zero || is_negative != is_overflow) {\n    shifted_num = 0 << (shift_amount & 0xff);\n  }\nLAB_08000318:\n  if (combined_value < 0x433) {\n    return CONCAT44(input_num + (0x432 - combined_value) * 0x100000,shifted_num);\n  }\n  shift_amount = ~(0x432 - combined_value);\n  if (0x1e < (int)shift_amount) {\n    return (ulonglong)(input_num >> (shift_amount - 0x1f & 0xff));\n  }\n  bit_count = shift_amount - 0x13;\n  if (bit_count == 0 || bit_count < 0 != SCARRY4(shift_amount - 0x1f,0xc)) {\n    shift_amount = shift_amount + 1;\n    return CONCAT44(input_num >> (shift_amount & 0xff),\n                    shifted_num >> (shift_amount & 0xff) | input_num << (0x20 - shift_amount & 0xff));\n  }\n  return (ulonglong)(shifted_num >> (0x20 - (0xcU - bit_count) & 0xff) | input_num << (0xcU - bit_count & 0xff));\n}\n\n",
            "renaming": {
                "FUN_0800040c": "reverse_and_shift_0800040c",
                "param_1": "input_num",
                "uVar1": "shifted_num",
                "uVar2": "shift_amount",
                "iVar3": "bit_count",
                "uVar4": "combined_value",
                "in_r12": "shifted_bits",
                "bVar5": "is_negative",
                "bVar6": "is_zero",
                "bVar7": "is_overflow"
            },
            "calling": [
                "loop",
                "SetTunings",
                "readThermocouple",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800042c": {
            "entrypoint": "0x0800042c",
            "current_name": "shift_and_combine_bits_0800042c",
            "code": "\nulonglong shiftAndCombineBits_0800042c(uint input)\n\n{\n  uint shiftedBits;\n  uint absInput;\n  uint shiftAmount;\n  int leadingZeros;\n  uint shiftedBitsDiff;\n  uint signBit;\n  uint remainingBits;\n  bool negativeDiff;\n  bool zeroDiff;\n  bool carry;\n  \n  if (input == 0) {\n    return 0;\n  }\n  signBit = input & 0x80000000;\n  absInput = input;\n  if ((int)signBit < 0) {\n    absInput = -input;\n  }\n  shiftedBits = 0;\n  leadingZeros = countLeadingZeros(absInput);\n  shiftedBitsDiff = leadingZeros + 0x15;\n  carry = SBORROW4(shiftedBitsDiff,0x20);\n  shiftAmount = leadingZeros - 0xb;\n  negativeDiff = (int)shiftAmount < 0;\n  zeroDiff = shiftAmount == 0;\n  if (shiftedBitsDiff < 0x20) {\n    carry = signedCarry(shiftAmount,0xc);\n    negativeDiff = false;\n    zeroDiff = leadingZeros + 1 == 0;\n    shiftAmount = shiftedBitsDiff;\n    if (!zeroDiff && carry == false) {\n      shiftedBits = absInput << shiftedBitsDiff;\n      absInput = absInput >> (0xcU - (leadingZeros + 1) & 0xff);\n      goto shiftBits;\n    }\n  }\n  if (zeroDiff || negativeDiff != carry) {\n    remainingBits = 0x20 - shiftAmount;\n  }\n  absInput = absInput << (shiftAmount & 0xff);\n  if (zeroDiff || negativeDiff != carry) {\n    absInput = absInput | 0U >> (remainingBits & 0xff);\n  }\n  if (zeroDiff || negativeDiff != carry) {\n    shiftedBits = 0 << (shiftAmount & 0xff);\n  }\nshiftBits:\n  if (shiftedBitsDiff < 0x433) {\n    return CONCAT44(absInput + (0x432 - shiftedBitsDiff) * 0x100000 | signBit,shiftedBits);\n  }\n  shiftAmount = ~(0x432 - shiftedBitsDiff);\n  if (0x1e < (int)shiftAmount) {\n    return CONCAT44(input,absInput >> (shiftAmount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leadingZeros = shiftAmount - 0x13;\n  if (leadingZeros == 0 || leadingZeros < 0 != signedCarry(shiftAmount - 0x1f,0xc)) {\n    shiftAmount = shiftAmount + 1;\n    return CONCAT44(signBit | absInput >> (shiftAmount & 0xff),\n                    shiftedBits >> (shiftAmount & 0xff) | absInput << (0x20 - shiftAmount & 0xff));\n  }\n  return CONCAT44(input,shiftedBits >> (0x20 - (0xcU - leadingZeros) & 0xff) | absInput << (0xcU - leadingZeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800042c": "shift_and_combine_bits_0800042c",
                "param_1": "input",
                "uVar1": "shiftedBits",
                "uVar2": "absInput",
                "uVar3": "shiftAmount",
                "iVar4": "leadingZeros",
                "uVar5": "shiftedBitsDiff",
                "uVar6": "signBit",
                "in_r12": "remainingBits",
                "bVar7": "negativeDiff",
                "bVar8": "zeroDiff",
                "bVar9": "carry",
                "LZCOUNT": "countLeadingZeros",
                "SCARRY4": "signedCarry",
                "LAB_08000318": "shiftBits"
            },
            "calling": [
                "loop",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000450": {
            "entrypoint": "0x08000450",
            "current_name": "shift_and_xor_08000450",
            "code": "\nulonglong shiftAndXor_08000450(uint input,undefined4 value1,undefined4 value2,uint mask)\n\n{\n  uint shiftedSign;\n  uint result;\n  uint modifiedInput;\n  uint shiftCount1;\n  uint shiftedValue;\n  int bitCount;\n  uint shiftCount2;\n  uint remainingBits;\n  bool isLessThan;\n  bool isZero1;\n  bool isLessThan2;\n  \n  shiftedValue = input << 1;\n  isZero1 = shiftedValue == 0;\n  shiftedSign = (uint)((input & 0x80000000) != 0) << 0x1f;\n  shiftCount1 = (uint)((int)shiftedValue >> 3) >> 1;\n  modifiedInput = shiftedSign | shiftCount1;\n  input = input << 0x1d;\n  if (!isZero1) {\n    mask = shiftedValue & 0xff000000;\n    isZero1 = mask == 0;\n  }\n  if (!isZero1) {\n    isZero1 = mask == 0xff000000;\n  }\n  if (!isZero1) {\n    return CONCAT44(modifiedInput,input) ^ 0x3800000000000000;\n  }\n  if (shiftedValue == 0 || mask == 0xff000000) {\n    return CONCAT44(modifiedInput,input);\n  }\n  result = input;\n  shiftedValue = shiftCount1;\n  if (shiftCount1 == 0) {\n    result = 0;\n    shiftedValue = input;\n  }\n  bitCount = LZCOUNT(shiftedValue);\n  if (shiftCount1 == 0) {\n    bitCount = bitCount + 0x20;\n  }\n  shiftCount2 = bitCount - 0xb;\n  isLessThan2 = SBORROW4(shiftCount2,0x20);\n  shiftCount1 = bitCount - 0x2b;\n  isZero1 = (int)shiftCount1 < 0;\n  isLessThan = shiftCount1 == 0;\n  if ((int)shiftCount2 < 0x20) {\n    isLessThan2 = SCARRY4(shiftCount1,0xc);\n    bitCount = bitCount + -0x1f;\n    isZero1 = bitCount < 0;\n    isLessThan = bitCount == 0;\n    shiftCount1 = shiftCount2;\n    if (!isLessThan && isZero1 == isLessThan2) {\n      result = shiftedValue << (shiftCount2 & 0xff);\n      shiftedValue = shiftedValue >> (0xcU - bitCount & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (isLessThan || isZero1 != isLessThan2) {\n    remainingBits = 0x20 - shiftCount1;\n  }\n  shiftedValue = shiftedValue << (shiftCount1 & 0xff);\n  if (isLessThan || isZero1 != isLessThan2) {\n    shiftedValue = shiftedValue | result >> (remainingBits & 0xff);\n  }\n  if (isLessThan || isZero1 != isLessThan2) {\n    result = result << (shiftCount1 & 0xff);\n  }\nLAB_08000318:\n  if ((int)shiftCount2 < 0x381) {\n    return CONCAT44(shiftedValue + (0x380 - shiftCount2) * 0x100000 | shiftedSign,result);\n  }\n  shiftCount1 = ~(0x380 - shiftCount2);\n  if ((int)shiftCount1 < 0x1f) {\n    bitCount = shiftCount1 - 0x13;\n    if (bitCount != 0 && bitCount < 0 == SCARRY4(shiftCount1 - 0x1f,0xc)) {\n      return CONCAT44(modifiedInput,result >> (0x20 - (0xcU - bitCount) & 0xff) | shiftedValue << (0xcU - bitCount & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    shiftCount1 = shiftCount1 + 1;\n    return CONCAT44(shiftedSign | shiftedValue >> (shiftCount1 & 0xff),\n                    result >> (shiftCount1 & 0xff) | shiftedValue << (0x20 - shiftCount1 & 0xff));\n  }\n  return CONCAT44(modifiedInput,shiftedValue >> (shiftCount1 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000450": "shift_and_xor_08000450",
                "param_1": "input",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "mask",
                "uVar1": "shiftedSign",
                "uVar2": "result",
                "uVar3": "modifiedInput",
                "uVar4": "shiftCount1",
                "uVar5": "shiftedValue",
                "iVar6": "bitCount",
                "uVar7": "shiftCount2",
                "in_r12": "remainingBits",
                "bVar8": "isLessThan",
                "bVar9": "isZero1",
                "bVar10": "isLessThan2"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800048c": {
            "entrypoint": "0x0800048c",
            "current_name": "simplified_algorithm_0800048c",
            "code": "\nulonglong simplifiedAlgorithm_0800048c(uint input1,uint input2)\n\n{\n  byte byteVar;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int temp4;\n  uint shiftAmount;\n  int offset;\n  uint shiftedInput2;\n  bool boolVar1;\n  bool boolVar2;\n  bool boolVar3;\n  \n  if ((input1 | input2) == 0) {\n    return CONCAT44(input2,input1);\n  }\n  offset = 0x432;\n  shiftedInput2 = input2 >> 0x16;\n  if (shiftedInput2 != 0) {\n    offset = 3;\n    if (input2 >> 0x19 != 0) {\n      offset = 6;\n    }\n    if (input2 >> 0x1c != 0) {\n      offset = offset + 3;\n    }\n    temp3 = offset - ((int)input2 >> 0x1f);\n    shiftedInput2 = input1 << (0x20 - temp3 & 0xff);\n    input1 = input1 >> (temp3 & 0xff) | input2 << (0x20 - temp3 & 0xff);\n    input2 = input2 >> (temp3 & 0xff);\n    offset = temp3 + 0x432;\n  }\n  if (0xfffff < input2) {\n    if (0x1fffff < input2) {\n      temp3 = input2 & 1;\n      input2 = input2 >> 1;\n      byteVar = (byte)input1;\n      input1 = (uint)(temp3 != 0) << 0x1f | input1 >> 1;\n      shiftedInput2 = (uint)(byteVar & 1) << 0x1f | shiftedInput2 >> 1;\n      offset = offset + 1;\n      if (0xffbfffff < (uint)(offset * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_080002a0:\n    boolVar2 = 0x7fffffff < shiftedInput2;\n    if (shiftedInput2 == 0x80000000) {\n      boolVar2 = (input1 & 1) != 0;\n    }\n    return CONCAT44(input2 + offset * 0x100000 + (uint)CARRY4(input1,(uint)boolVar2),input1 + boolVar2\n                   );\n  }\n  boolVar1 = (shiftedInput2 & 0x80000000) != 0;\n  shiftedInput2 = shiftedInput2 << 1;\n  temp3 = input1 * 2;\n  boolVar2 = CARRY4(input1,input1);\n  input1 = input1 * 2 + (uint)boolVar1;\n  input2 = input2 * 2 + (uint)(boolVar2 || CARRY4(temp3,(uint)boolVar1));\n  offset = offset + -1;\n  if ((input2 & 0x100000) != 0) goto LAB_080002a0;\n  temp1 = input1;\n  temp3 = input2;\n  if (input2 == 0) {\n    temp1 = 0;\n    temp3 = input1;\n  }\n  temp4 = LZCOUNT(temp3);\n  if (input2 == 0) {\n    temp4 = temp4 + 0x20;\n  }\n  shiftAmount = temp4 - 0xb;\n  boolVar3 = SBORROW4(shiftAmount,0x20);\n  temp2 = temp4 - 0x2b;\n  boolVar2 = (int)temp2 < 0;\n  boolVar1 = temp2 == 0;\n  if ((int)shiftAmount < 0x20) {\n    boolVar3 = SCARRY4(temp2,0xc);\n    temp4 = temp4 + -0x1f;\n    boolVar2 = temp4 < 0;\n    boolVar1 = temp4 == 0;\n    temp2 = shiftAmount;\n    if (!boolVar1 && boolVar2 == boolVar3) {\n      temp1 = temp3 << (shiftAmount & 0xff);\n      temp3 = temp3 >> (0xcU - temp4 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (boolVar1 || boolVar2 != boolVar3) {\n    shiftedInput2 = 0x20 - temp2;\n  }\n  temp3 = temp3 << (temp2 & 0xff);\n  if (boolVar1 || boolVar2 != boolVar3) {\n    temp3 = temp3 | temp1 >> (shiftedInput2 & 0xff);\n  }\n  if (boolVar1 || boolVar2 != boolVar3) {\n    temp1 = temp1 << (temp2 & 0xff);\n  }\nLAB_08000318:\n  if ((int)shiftAmount <= offset) {\n    return CONCAT44(temp3 + (offset - shiftAmount) * 0x100000,temp1);\n  }\n  shiftedInput2 = ~(offset - shiftAmount);\n  if (0x1e < (int)shiftedInput2) {\n    return (ulonglong)(temp3 >> (shiftedInput2 - 0x1f & 0xff));\n  }\n  offset = shiftedInput2 - 0x13;\n  if (offset == 0 || offset < 0 != SCARRY4(shiftedInput2 - 0x1f,0xc)) {\n    shiftedInput2 = shiftedInput2 + 1;\n    return CONCAT44(temp3 >> (shiftedInput2 & 0xff),temp1 >> (shiftedInput2 & 0xff) | temp3 << (0x20 - shiftedInput2 & 0xff)\n                   );\n  }\n  return (ulonglong)(temp1 >> (0x20 - (0xcU - offset) & 0xff) | temp3 << (0xcU - offset & 0xff));\n}\n\n",
            "renaming": {
                "FUN_0800048c": "simplified_algorithm_0800048c",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "byteVar",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "iVar5": "temp4",
                "uVar6": "shiftAmount",
                "iVar7": "offset",
                "uVar8": "shiftedInput2",
                "bVar9": "boolVar1",
                "bVar10": "boolVar2",
                "bVar11": "boolVar3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800049c": {
            "entrypoint": "0x0800049c",
            "current_name": "reverse_arithmetic_operations_0800049c",
            "code": "\nulonglong reverseArithmeticOperations_0800049c(uint input1,uint input2)\n\n{\n  byte carry;\n  uint result1;\n  uint result2;\n  uint carry2;\n  int shiftAmount;\n  uint temp1;\n  int loopCount;\n  uint signBit;\n  uint carry3;\n  bool tempFlag;\n  bool tempFlag2;\n  bool tempFlag3;\n  \n  if ((input1 | input2) == 0) {\n    return CONCAT44(input2,input1);\n  }\n  signBit = input2 & 0x80000000;\n  result2 = input2;\n  if ((int)signBit < 0) {\n    tempFlag2 = input1 != 0;\n    input1 = -input1;\n    result2 = -input2 - (uint)tempFlag2;\n  }\n  loopCount = 0x432;\n  carry3 = result2 >> 0x16;\n  if (carry3 != 0) {\n    loopCount = 3;\n    if (result2 >> 0x19 != 0) {\n      loopCount = 6;\n    }\n    if (result2 >> 0x1c != 0) {\n      loopCount = loopCount + 3;\n    }\n    carry2 = loopCount - ((int)result2 >> 0x1f);\n    carry3 = input1 << (0x20 - carry2 & 0xff);\n    input1 = input1 >> (carry2 & 0xff) | result2 << (0x20 - carry2 & 0xff);\n    result2 = result2 >> (carry2 & 0xff);\n    loopCount = carry2 + 0x432;\n  }\n  if (0xfffff < result2) {\n    if (0x1fffff < result2) {\n      carry2 = result2 & 1;\n      result2 = result2 >> 1;\n      carry = (byte)input1;\n      input1 = (uint)(carry2 != 0) << 0x1f | input1 >> 1;\n      carry3 = (uint)(carry & 1) << 0x1f | carry3 >> 1;\n      loopCount = loopCount + 1;\n      if (0xffbfffff < (uint)(loopCount * 0x200000)) {\n        return (ulonglong)(signBit | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_080002a0:\n    tempFlag2 = 0x7fffffff < carry3;\n    if (carry3 == 0x80000000) {\n      tempFlag2 = (input1 & 1) != 0;\n    }\n    return CONCAT44(result2 + loopCount * 0x100000 + (uint)CARRY4(input1,(uint)tempFlag2) | signBit,\n                    input1 + tempFlag2);\n  }\n  tempFlag = (carry3 & 0x80000000) != 0;\n  carry3 = carry3 << 1;\n  carry2 = input1 * 2;\n  tempFlag2 = CARRY4(input1,input1);\n  input1 = input1 * 2 + (uint)tempFlag;\n  result2 = result2 * 2 + (uint)(tempFlag2 || CARRY4(carry2,(uint)tempFlag));\n  loopCount = loopCount + -1;\n  if ((result2 & 0x100000) != 0) goto LAB_080002a0;\n  result1 = input1;\n  carry2 = result2;\n  if (result2 == 0) {\n    result1 = 0;\n    carry2 = input1;\n  }\n  shiftAmount = LZCOUNT(carry2);\n  if (result2 == 0) {\n    shiftAmount = shiftAmount + 0x20;\n  }\n  temp1 = shiftAmount - 0xb;\n  tempFlag3 = SBORROW4(temp1,0x20);\n  result2 = shiftAmount - 0x2b;\n  tempFlag2 = (int)result2 < 0;\n  tempFlag = result2 == 0;\n  if ((int)temp1 < 0x20) {\n    tempFlag3 = SCARRY4(result2,0xc);\n    shiftAmount = shiftAmount + -0x1f;\n    tempFlag2 = shiftAmount < 0;\n    tempFlag = shiftAmount == 0;\n    result2 = temp1;\n    if (!tempFlag && tempFlag2 == tempFlag3) {\n      result1 = carry2 << (temp1 & 0xff);\n      carry2 = carry2 >> (0xcU - shiftAmount & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (tempFlag || tempFlag2 != tempFlag3) {\n    carry3 = 0x20 - result2;\n  }\n  carry2 = carry2 << (result2 & 0xff);\n  if (tempFlag || tempFlag2 != tempFlag3) {\n    carry2 = carry2 | result1 >> (carry3 & 0xff);\n  }\n  if (tempFlag || tempFlag2 != tempFlag3) {\n    result1 = result1 << (result2 & 0xff);\n  }\nLAB_08000318:\n  if ((int)temp1 <= loopCount) {\n    return CONCAT44(carry2 + (loopCount - temp1) * 0x100000 | signBit,result1);\n  }\n  result2 = ~(loopCount - temp1);\n  if (0x1e < (int)result2) {\n    return CONCAT44(input2,carry2 >> (result2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  loopCount = result2 - 0x13;\n  if (loopCount == 0 || loopCount < 0 != SCARRY4(result2 - 0x1f,0xc)) {\n    result2 = result2 + 1;\n    return CONCAT44(signBit | carry2 >> (result2 & 0xff),\n                    result1 >> (result2 & 0xff) | carry2 << (0x20 - result2 & 0xff));\n  }\n  return CONCAT44(input2,result1 >> (0x20 - (0xcU - loopCount) & 0xff) | carry2 << (0xcU - loopCount & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800049c": "reverse_arithmetic_operations_0800049c",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "carry",
                "uVar2": "result1",
                "uVar3": "result2",
                "uVar4": "carry2",
                "iVar5": "shiftAmount",
                "uVar6": "temp1",
                "iVar7": "loopCount",
                "uVar8": "signBit",
                "uVar9": "carry3",
                "bVar10": "tempFlag",
                "bVar11": "tempFlag2",
                "bVar12": "tempFlag3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004f8": {
            "entrypoint": "0x080004f8",
            "current_name": "calculate_shift_and_xor_080004f8",
            "code": "\nulonglong calculate_shift_and_xor_080004f8(undefined4 input1,uint input2,uint input3,uint input4)\n\n{\n  ulonglong result1;\n  longlong result2;\n  uint temp1;\n  uint temp2;\n  int temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  ulonglong combined;\n  \n  combined = CONCAT44(input2,input1);\n  temp6 = 0x7ff;\n  temp2 = input2 >> 0x14 & 0x7ff;\n  flag1 = temp2 == 0;\n  if (!flag1) {\n    temp5 = input4 >> 0x14 & 0x7ff;\n    flag1 = temp5 == 0;\n  }\n  if (!flag1) {\n    flag1 = temp2 == 0x7ff;\n  }\n  if (!flag1) {\n    flag1 = temp5 == 0x7ff;\n  }\n  if (flag1) {\n    combined = calculate_xor_shift_080006d4();\n  }\n  temp1 = (uint)(combined >> 0x20);\n  temp3 = temp2 + temp5;\n  temp2 = temp1 ^ input4;\n  temp1 = temp1 & ~(temp6 << 0x15);\n  input4 = input4 & ~(temp6 << 0x15);\n  flag1 = ((uint)combined | temp1 << 0xc) == 0;\n  if (!flag1) {\n    flag1 = (input3 | input4 << 0xc) == 0;\n  }\n  temp1 = temp1 | 0x100000;\n  input4 = input4 | 0x100000;\n  if (flag1) {\n    input3 = (uint)combined | input3;\n    input4 = (temp2 & 0x80000000 | temp1) ^ input4;\n    temp2 = temp6 >> 1;\n    flag3 = SBORROW4(temp3,temp2);\n    temp4 = temp3 - temp2;\n    flag1 = temp4 == 0;\n    temp1 = temp4;\n    if (!flag1 && (int)temp2 <= temp3) {\n      flag3 = SBORROW4(temp6,temp4);\n      temp1 = temp6 - temp4;\n      flag1 = temp6 == temp4;\n    }\n    if (!flag1 && (int)temp1 < 0 == flag3) {\n      input4 = input4 | temp4 * 0x100000;\n    }\n    if (!flag1 && (int)temp1 < 0 == flag3) {\n      return CONCAT44(input4,input3);\n    }\n    input4 = input4 | 0x100000;\n    temp6 = 0;\n    flag3 = SBORROW4(temp4,1);\n    temp4 = temp4 - 1;\n    flag1 = temp4 == 0;\n    temp2 = temp4;\n  }\n  else {\n    result1 = (combined & 0xffffffff) * (ulonglong)input3;\n    combined = (combined & 0xffffffff) * (ulonglong)input4 +\n             (ulonglong)temp1 * (ulonglong)input3 + (result1 >> 0x20);\n    temp7 = (uint)combined;\n    result2 = (ulonglong)temp1 * (ulonglong)input4 + (combined >> 0x20);\n    temp6 = (uint)result2;\n    temp1 = (uint)((ulonglong)result2 >> 0x20);\n    if ((int)result1 != 0) {\n      temp7 = temp7 | 1;\n    }\n    temp4 = (temp3 + -0x3ff) - (uint)(temp1 < 0x200);\n    if (temp1 < 0x200) {\n      flag1 = (temp7 & 0x80000000) != 0;\n      temp7 = temp7 << 1;\n      result2 = CONCAT44(temp1 * 2 + (uint)(CARRY4(temp6,temp6) || CARRY4(temp6 * 2,(uint)flag1)),\n                       temp6 * 2 + (uint)flag1);\n    }\n    input4 = temp2 & 0x80000000 | (int)((ulonglong)result2 >> 0x20) << 0xb | (uint)result2 >> 0x15;\n    input3 = (uint)result2 << 0xb | temp7 >> 0x15;\n    temp6 = temp7 * 0x800;\n    flag2 = 0xfc < temp4;\n    flag3 = SBORROW4(temp4,0xfd);\n    temp1 = temp4 - 0xfd;\n    flag1 = temp1 == 0;\n    temp2 = temp1;\n    if (flag2 && !flag1) {\n      flag2 = 0x6ff < temp1;\n      flag3 = SBORROW4(temp1,0x700);\n      temp2 = temp4 - 0x7fd;\n      flag1 = temp1 == 0x700;\n    }\n    if (!flag2 || flag1) {\n      flag1 = 0x7fffffff < temp6;\n      if (temp6 == 0x80000000) {\n        flag1 = (temp7 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(input4 + temp4 * 0x100000 + (uint)CARRY4(input3,(uint)flag1),input3 + flag1\n                     );\n    }\n  }\n  if (!flag1 && (int)temp2 < 0 == flag3) {\n    return (ulonglong)(input4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag2 = SCARRY4(temp4,0x36);\n  flag1 = (int)(temp4 + 0x36) < 0;\n  flag3 = temp4 == 0xffffffca;\n  if (flag3 || flag1 != flag2) {\n    input3 = 0;\n  }\n  if (flag3 || flag1 != flag2) {\n    input4 = input4 & 0x80000000;\n  }\n  if (flag3 || flag1 != flag2) {\n    return CONCAT44(input4,input3);\n  }\n  temp2 = -temp4;\n  temp1 = temp2 - 0x20;\n  if (0x1f < (int)temp2) {\n    temp4 = input3 >> (temp1 & 0xff) | input4 << (0x20 - temp1 & 0xff);\n    temp2 = (input4 >> (temp1 & 0xff) & ~((input4 & 0x80000000) >> (temp1 & 0xff))) -\n            ((int)temp4 >> 0x1f);\n    if ((temp6 | input3 << (0x20 - temp1 & 0xff) | temp4 << 1) == 0) {\n      temp2 = temp2 & ~(temp4 >> 0x1f);\n    }\n    return CONCAT44(input4,temp2) & 0x80000000ffffffff;\n  }\n  temp3 = temp2 - 0x14;\n  if (temp3 == 0 || temp3 < 0 != SCARRY4(temp1,0xc)) {\n    temp7 = input3 << (temp4 + 0x20 & 0xff);\n    temp1 = input3 >> (temp2 & 0xff) | input4 << (temp4 + 0x20 & 0xff);\n    temp4 = temp1 + -((int)temp7 >> 0x1f);\n    if ((temp6 | temp7 << 1) == 0) {\n      temp4 = temp4 & ~(temp7 >> 0x1f);\n    }\n    return CONCAT44((input4 & 0x80000000) +\n                    ((input4 & 0x7fffffff) >> (temp2 & 0xff)) +\n                    (uint)CARRY4(temp1,-((int)temp7 >> 0x1f)),temp4);\n  }\n  temp2 = 0xc - temp3;\n  temp4 = input3 << (temp2 & 0xff);\n  temp2 = input3 >> (0x20 - temp2 & 0xff) | input4 << (temp2 & 0xff);\n  temp1 = temp2 + -((int)temp4 >> 0x1f);\n  if ((temp6 | temp4 << 1) == 0) {\n    temp1 = temp1 & ~(temp4 >> 0x1f);\n  }\n  return CONCAT44((input4 & 0x80000000) + (uint)CARRY4(temp2,-((int)temp4 >> 0x1f)),temp1);\n}\n\n",
            "renaming": {
                "FUN_080004f8": "calculate_shift_and_xor_080004f8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "result1",
                "lVar2": "result2",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "iVar5": "temp3",
                "uVar6": "temp4",
                "unaff_r5": "temp5",
                "uVar7": "temp6",
                "uVar8": "temp7",
                "bVar9": "flag1",
                "bVar10": "flag2",
                "bVar11": "flag3",
                "uVar12": "combined"
            },
            "calling": [
                "SetTunings",
                "Compute",
                "readThermocouple",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [
                "FUN_080006d4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006d4": {
            "entrypoint": "0x080006d4",
            "current_name": "calculate_xor_shift_080006d4",
            "code": "\nulonglong calculate_xor_shift_080006d4(uint num1,uint num2,uint num3,uint num4)\n\n{\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  bool isZero;\n  \n  temp3 = temp5 & num4 >> 0x14;\n  if (temp2 != temp5 && temp3 != temp5) {\n    isZero = (num1 | num2 << 1) == 0;\n    if (!isZero) {\n      isZero = (num3 | num4 << 1) == 0;\n    }\n    if (isZero) {\n      return (ulonglong)((num2 ^ num4) & 0x80000000) << 0x20;\n    }\n    if (temp2 == 0) {\n      temp4 = num2 & 0x80000000;\n      do {\n        temp1 = num1 & 0x80000000;\n        num1 = num1 << 1;\n        num2 = num2 * 2 + (uint)(temp1 != 0);\n      } while ((num2 & 0x100000) == 0);\n      num2 = num2 | temp4;\n      if (temp3 != 0) {\n        return CONCAT44(num2,num1);\n      }\n    }\n    do {\n      temp3 = num3 & 0x80000000;\n      num3 = num3 << 1;\n      num4 = num4 * 2 + (uint)(temp3 != 0);\n    } while ((num4 & 0x100000) == 0);\n    return CONCAT44(num2,num1);\n  }\n  isZero = (num1 | num2 << 1) == 0;\n  if (isZero) {\n    num2 = num4;\n    num1 = num3;\n  }\n  if (!isZero) {\n    isZero = (num3 | num4 << 1) == 0;\n  }\n  temp4 = num2;\n  if (((!isZero) && ((temp2 != temp5 || ((num1 | num2 << 0xc) == 0)))) &&\n     ((temp3 != temp5 || (num1 = num3, temp4 = num4, (num3 | num4 << 0xc) == 0)))) {\n    return (ulonglong)((num2 ^ num4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(temp4,num1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006d4": "calculate_xor_shift_080006d4",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "num3",
                "param_4": "num4",
                "uVar1": "temp1",
                "unaff_r4": "temp2",
                "uVar2": "temp3",
                "uVar3": "temp4",
                "in_r12": "temp5",
                "bVar4": "isZero"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800074c": {
            "entrypoint": "0x0800074c",
            "current_name": "calculate_float_0800074c",
            "code": "\nulonglong calculateFloat_0800074c(undefined4 input1,uint input2,uint input3,uint input4)\n\n{\n  uint var1;\n  uint var2;\n  uint var3;\n  uint var4;\n  uint var5;\n  uint var6;\n  uint var7;\n  int var8;\n  uint var9;\n  uint var10;\n  uint var11;\n  uint var12;\n  uint var13;\n  uint var14;\n  bool bool1;\n  bool bool2;\n  bool bool3;\n  undefined8 result;\n  \n  result = CONCAT44(input2,input1);\n  var14 = 0x7ff;\n  var7 = input2 >> 0x14 & 0x7ff;\n  bool1 = var7 == 0;\n  if (!bool1) {\n    var10 = input4 >> 0x14 & 0x7ff;\n    bool1 = var10 == 0;\n  }\n  if (!bool1) {\n    bool1 = var7 == 0x7ff;\n  }\n  if (!bool1) {\n    bool1 = var10 == 0x7ff;\n  }\n  if (bool1) {\n    result = calculate_floating_point_080008ba();\n  }\n  var9 = (uint)((ulonglong)result >> 0x20);\n  var12 = (uint)result;\n  var8 = var7 - var10;\n  if ((input3 | input4 << 0xc) == 0) {\n    var7 = (var9 ^ input4) & 0x80000000 | var9 & 0xfffff;\n    bool3 = SCARRY4(var8,var14 >> 1);\n    var9 = var8 + (var14 >> 1);\n    bool1 = (int)var9 < 0;\n    bool2 = var9 == 0;\n    if (!bool2 && bool1 == bool3) {\n      bool3 = SBORROW4(var14,var9);\n      bool1 = (int)(var14 - var9) < 0;\n      bool2 = var14 == var9;\n    }\n    if (!bool2 && bool1 == bool3) {\n      var7 = var7 | var9 * 0x100000;\n    }\n    if (!bool2 && bool1 == bool3) {\n      return CONCAT44(var7,var12);\n    }\n    var7 = var7 | 0x100000;\n    var14 = 0;\n    bool2 = SBORROW4(var9,1);\n    var9 = var9 - 1;\n    bool1 = var9 == 0;\n    var3 = var9;\n  }\n  else {\n    var3 = (input4 << 0xc) >> 4 | 0x10000000 | input3 >> 0x18;\n    var14 = input3 << 8;\n    var11 = (var9 << 0xc) >> 4 | 0x10000000 | var12 >> 0x18;\n    var12 = var12 * 0x100;\n    var7 = (var9 ^ input4) & 0x80000000;\n    bool1 = var3 <= var11;\n    if (var11 == var3) {\n      bool1 = var14 <= var12;\n    }\n    var8 = var8 + (uint)bool1;\n    var9 = var8 + 0x3fd;\n    if (bool1 == false) {\n      var3 = var3 >> 1;\n      var14 = (uint)((input3 >> 0x18 & 1) != 0) << 0x1f | var14 >> 1;\n    }\n    var13 = var12 - var14;\n    var11 = (var11 - var3) - (uint)(var12 < var14);\n    var4 = var3 >> 1;\n    var1 = (uint)((var3 & 1) != 0) << 0x1f | var14 >> 1;\n    var12 = 0x100000;\n    var3 = 0x80000;\n    while( true ) {\n      bool1 = var1 <= var13;\n      if (var4 < var11 || var11 - var4 < (uint)bool1) {\n        var13 = var13 - var1;\n        var12 = var12 | var3;\n        var11 = (var11 - var4) - (uint)!bool1;\n      }\n      var5 = var4 >> 1;\n      var1 = (uint)((var4 & 1) != 0) << 0x1f | var1 >> 1;\n      bool2 = var1 <= var13;\n      bool1 = var11 - var5 < (uint)bool2;\n      var14 = var11;\n      if (var5 < var11 || bool1) {\n        var13 = var13 - var1;\n        var14 = (var11 - var5) - (uint)!bool2;\n      }\n      if (var5 < var11 || bool1) {\n        var12 = var12 | var3 >> 1;\n      }\n      var11 = var4 >> 2;\n      var2 = (uint)((var5 & 1) != 0) << 0x1f | var1 >> 1;\n      bool2 = var2 <= var13;\n      bool1 = var14 - var11 < (uint)bool2;\n      var5 = var14;\n      if (var11 < var14 || bool1) {\n        var13 = var13 - var2;\n        var5 = (var14 - var11) - (uint)!bool2;\n      }\n      if (var11 < var14 || bool1) {\n        var12 = var12 | var3 >> 2;\n      }\n      var6 = var4 >> 3;\n      var1 = (uint)((var11 & 1) != 0) << 0x1f | var2 >> 1;\n      bool2 = var1 <= var13;\n      bool1 = var5 - var6 < (uint)bool2;\n      var11 = var5;\n      if (var6 < var5 || bool1) {\n        var13 = var13 - var1;\n        var11 = (var5 - var6) - (uint)!bool2;\n      }\n      if (var6 < var5 || bool1) {\n        var12 = var12 | var3 >> 3;\n      }\n      var14 = var11 | var13;\n      if (var14 == 0) break;\n      var11 = var11 << 4 | var13 >> 0x1c;\n      var13 = var13 << 4;\n      var4 = var4 & 0xfffffff8 | var1 >> 0x1d;\n      var1 = (var2 >> 1) << 3;\n      var3 = var3 >> 4;\n      if (var3 == 0) {\n        var6 = var4;\n        if ((var7 & 0x100000) != 0) goto LAB_0800086a;\n        var7 = var7 | var12;\n        var12 = 0;\n        var3 = 0x80000000;\n      }\n    }\n    if ((var7 & 0x100000) == 0) {\n      var7 = var7 | var12;\n      var12 = 0;\n    }\nLAB_0800086a:\n    bool3 = 0xfc < var9;\n    bool2 = SBORROW4(var9,0xfd);\n    var4 = var8 + 0x300;\n    bool1 = var4 == 0;\n    var3 = var4;\n    if (bool3 && !bool1) {\n      bool3 = 0x6ff < var4;\n      bool2 = SBORROW4(var4,0x700);\n      var3 = var8 - 0x400;\n      bool1 = var4 == 0x700;\n    }\n    if (!bool3 || bool1) {\n      bool1 = var6 <= var11;\n      if (var11 == var6) {\n        bool1 = var1 <= var13;\n      }\n      if (var11 == var6 && var13 == var1) {\n        bool1 = (var12 & 1) != 0;\n      }\n      return CONCAT44(var7 + var9 * 0x100000 + (uint)CARRY4(var12,(uint)bool1),var12 + bool1);\n    }\n  }\n  if (!bool1 && (int)var3 < 0 == bool2) {\n    return (ulonglong)(var7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  bool3 = SCARRY4(var9,0x36);\n  bool1 = (int)(var9 + 0x36) < 0;\n  bool2 = var9 == 0xffffffca;\n  if (bool2 || bool1 != bool3) {\n    var12 = 0;\n  }\n  if (bool2 || bool1 != bool3) {\n    var7 = var7 & 0x80000000;\n  }\n  if (bool2 || bool1 != bool3) {\n    return CONCAT44(var7,var12);\n  }\n  var3 = -var9;\n  var11 = var3 - 0x20;\n  if (0x1f < (int)var3) {\n    var3 = var12 >> (var11 & 0xff) | var7 << (0x20 - var11 & 0xff);\n    var9 = (var7 >> (var11 & 0xff) & ~((var7 & 0x80000000) >> (var11 & 0xff))) -\n            ((int)var3 >> 0x1f);\n    if ((var14 | var12 << (0x20 - var11 & 0xff) | var3 << 1) == 0) {\n      var9 = var9 & ~(var3 >> 0x1f);\n    }\n    return CONCAT44(var7,var9) & 0x80000000ffffffff;\n  }\n  var8 = var3 - 0x14;\n  if (var8 != 0 && var8 < 0 == SCARRY4(var11,0xc)) {\n    var9 = 0xc - var8;\n    var3 = var12 << (var9 & 0xff);\n    var12 = var12 >> (0x20 - var9 & 0xff) | var7 << (var9 & 0xff);\n    var9 = var12 + -((int)var3 >> 0x1f);\n    if ((var14 | var3 << 1) == 0) {\n      var9 = var9 & ~(var3 >> 0x1f);\n    }\n    return CONCAT44((var7 & 0x80000000) + (uint)CARRY4(var12,-((int)var3 >> 0x1f)),var9);\n  }\n  var11 = var12 << (var9 + 0x20 & 0xff);\n  var12 = var12 >> (var3 & 0xff) | var7 << (var9 + 0x20 & 0xff);\n  var9 = var12 + -((int)var11 >> 0x1f);\n  if ((var14 | var11 << 1) == 0) {\n    var9 = var9 & ~(var11 >> 0x1f);\n  }\n  return CONCAT44((var7 & 0x80000000) +\n                  ((var7 & 0x7fffffff) >> (var3 & 0xff)) +\n                  (uint)CARRY4(var12,-((int)var11 >> 0x1f)),var9);\n}\n\n",
            "renaming": {
                "FUN_0800074c": "calculate_float_0800074c",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "var1",
                "uVar2": "var2",
                "uVar3": "var3",
                "uVar4": "var4",
                "uVar5": "var5",
                "uVar6": "var6",
                "uVar7": "var7",
                "iVar8": "var8",
                "uVar9": "var9",
                "unaff_r5": "var10",
                "uVar10": "var11",
                "uVar11": "var12",
                "uVar12": "var13",
                "uVar13": "var14",
                "bVar14": "bool1",
                "bVar15": "bool2",
                "bVar16": "bool3",
                "uVar17": "result"
            },
            "calling": [
                "SetTunings",
                "readThermocouple",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [
                "FUN_080008ba"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008ba": {
            "entrypoint": "0x080008ba",
            "current_name": "calculate_floating_point_080008ba",
            "code": "\nulonglong calculateFloatingPoint_080008ba(uint exponent1,uint significand1,uint exponent2,uint significand2)\n\n{\n  uint exponentBit1;\n  uint temp1;\n  uint maskedParam4;\n  uint temp2;\n  uint mask;\n  bool bVar4;\n  \n  maskedParam4 = mask & significand2 >> 0x14;\n  temp2 = significand1;\n  if (temp1 != mask || maskedParam4 != mask) {\n    if (temp1 == mask) {\n      if (((exponent1 | significand1 << 0xc) == 0) && (exponent1 = exponent2, temp2 = significand2, maskedParam4 != mask)\n         ) {\nLAB_0800072c:\n        return (ulonglong)((significand1 ^ significand2) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (maskedParam4 == mask) {\n      exponent1 = exponent2;\n      temp2 = significand2;\n      if ((exponent2 | significand2 << 0xc) == 0) {\nLAB_080006f0:\n        return (ulonglong)((significand1 ^ significand2) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      bVar4 = (exponent1 | significand1 << 1) == 0;\n      if (!bVar4) {\n        bVar4 = (exponent2 | significand2 << 1) == 0;\n      }\n      if (!bVar4) {\n        if (temp1 == 0) {\n          temp2 = significand1 & 0x80000000;\n          do {\n            exponentBit1 = exponent1 & 0x80000000;\n            exponent1 = exponent1 << 1;\n            significand1 = significand1 * 2 + (uint)(exponentBit1 != 0);\n          } while ((significand1 & 0x100000) == 0);\n          significand1 = significand1 | temp2;\n          if (maskedParam4 != 0) {\n            return CONCAT44(significand1,exponent1);\n          }\n        }\n        do {\n          temp2 = exponent2 & 0x80000000;\n          exponent2 = exponent2 << 1;\n          significand2 = significand2 * 2 + (uint)(temp2 != 0);\n        } while ((significand2 & 0x100000) == 0);\n        return CONCAT44(significand1,exponent1);\n      }\n      if ((exponent1 | significand1 << 1) != 0) goto LAB_0800072c;\n      if ((exponent2 | significand2 << 1) != 0) goto LAB_080006f0;\n    }\n  }\n  return CONCAT44(temp2,exponent1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080008ba": "calculate_floating_point_080008ba",
                "param_1": "exponent1",
                "param_2": "significand1",
                "param_3": "exponent2",
                "param_4": "significand2",
                "uVar1": "exponentBit1",
                "unaff_r4": "temp1",
                "uVar2": "maskedParam4",
                "uVar3": "temp2",
                "in_r12": "mask"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800091c": {
            "entrypoint": "0x0800091c",
            "current_name": "check_parameters_0800091c",
            "code": "\nuint check_parameters_0800091c(uint value_1,uint value_2,uint value_3,uint value_4)\n\n{\n  uint result;\n  bool is_zero;\n  bool is_less_than_zero;\n  \n  if (((int)(value_2 << 1) >> 0x15 == -1 || (int)(value_4 << 1) >> 0x15 == -1) &&\n     ((((int)(value_2 << 1) >> 0x15 == -1 && ((value_1 | value_2 << 0xc) != 0)) ||\n      (((int)(value_4 << 1) >> 0x15 == -1 && ((value_3 | value_4 << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  is_zero = (value_1 | value_2 << 1) == 0;\n  if (is_zero) {\n    is_zero = (value_3 | value_4 << 1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = value_2 == value_4;\n  }\n  if (is_zero) {\n    is_zero = value_1 == value_3;\n  }\n  if (!is_zero) {\n    result = value_2 ^ value_4;\n    is_zero = result == 0;\n    if (-1 < (int)result) {\n      is_zero = value_2 == value_4;\n    }\n    is_less_than_zero = -1 < (int)result && value_4 <= value_2;\n    if (is_zero) {\n      is_less_than_zero = value_3 <= value_1;\n    }\n    value_4 = (int)value_4 >> 0x1f;\n    if (!is_less_than_zero) {\n      value_4 = ~value_4;\n    }\n    return value_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800091c": "check_parameters_0800091c",
                "param_1": "value_1",
                "param_2": "value_2",
                "param_3": "value_3",
                "param_4": "value_4",
                "uVar1": "result",
                "bVar2": "is_zero",
                "bVar3": "is_less_than_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000924": {
            "entrypoint": "0x08000924",
            "current_name": "check_equality_08000924",
            "code": "\nuint checkEquality_08000924(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint result;\n  bool areValuesEqual;\n  bool isResultNegative;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  areValuesEqual = (value1 | value2 << 1) == 0;\n  if (areValuesEqual) {\n    areValuesEqual = (value3 | value4 << 1) == 0;\n  }\n  if (!areValuesEqual) {\n    areValuesEqual = value2 == value4;\n  }\n  if (areValuesEqual) {\n    areValuesEqual = value1 == value3;\n  }\n  if (!areValuesEqual) {\n    result = value2 ^ value4;\n    areValuesEqual = result == 0;\n    if (-1 < (int)result) {\n      areValuesEqual = value2 == value4;\n    }\n    isResultNegative = -1 < (int)result && value4 <= value2;\n    if (areValuesEqual) {\n      isResultNegative = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!isResultNegative) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08000924": "check_equality_08000924",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result",
                "bVar2": "areValuesEqual",
                "bVar3": "isResultNegative"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800092c": {
            "entrypoint": "0x0800092c",
            "current_name": "check_equality_and_comparison_0800092c",
            "code": "\nuint checkEqualityAndComparison_0800092c(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint result;\n  bool isZero;\n  bool isNegative;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (value1 | value2 << 1) == 0;\n  if (isZero) {\n    isZero = (value3 | value4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = value2 == value4;\n  }\n  if (isZero) {\n    isZero = value1 == value3;\n  }\n  if (!isZero) {\n    result = value2 ^ value4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = value2 == value4;\n    }\n    isNegative = -1 < (int)result && value4 <= value2;\n    if (isZero) {\n      isNegative = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!isNegative) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800092c": "check_equality_and_comparison_0800092c",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isNegative"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009a8": {
            "entrypoint": "0x080009a8",
            "current_name": "compare_floats_080009a8",
            "code": "\nvoid compareFloats_080009a8(undefined4 result,undefined4 status,undefined4 value1,undefined4 value2)\n\n{\n  __aeabi_cdcmpeq(value1,value2,result,status);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080009a8": "compare_floats_080009a8",
                "param_1": "result",
                "param_2": "status",
                "param_3": "value1",
                "param_4": "value2"
            },
            "calling": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009b8": {
            "entrypoint": "0x080009b8",
            "current_name": "calculate_080009b8",
            "code": "\nundefined4 calculate_080009b8(undefined4 input)\n\n{\n  __eqdf2();\n  return input;\n}\n\n",
            "renaming": {
                "FUN_080009b8": "calculate_080009b8",
                "param_1": "input"
            },
            "calling": [
                "__aeabi_dcmpeq",
                "__aeabi_cdrcmple",
                "__aeabi_dcmplt",
                "__aeabi_dcmple"
            ],
            "called": [
                "__eqdf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c8": {
            "entrypoint": "0x080009c8",
            "current_name": "is_zero_080009c8",
            "code": "\nbool isZero_080009c8(void)\n\n{\n  char input;\n  \n  compareFloats();\n  return input != '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009c8": "is_zero_080009c8",
                "in_ZR": "input",
                "__aeabi_cdcmpeq": "compareFloats"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009dc": {
            "entrypoint": "0x080009dc",
            "current_name": "is_cy_null_080009dc",
            "code": "\nbool is_CY_null_080009dc(void)\n\n{\n  char comparison_result;\n  \n  __aeabi_cdcmpeq();\n  return comparison_result == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009dc": "is_cy_null_080009dc",
                "in_CY": "comparison_result"
            },
            "calling": [
                "SetOutputLimits",
                "Initialize",
                "loop",
                "SetTunings",
                "Compute",
                "printFloat"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009f0": {
            "entrypoint": "0x080009f0",
            "current_name": "check_equality_and_zero_080009f0",
            "code": "\nbool checkEqualityAndZero_080009f0(void)\n\n{\n  undefined isZero;\n  undefined isCarry;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)isCarry || (bool)isZero;\n}\n\n",
            "renaming": {
                "FUN_080009f0": "check_equality_and_zero_080009f0",
                "in_ZR": "isZero",
                "in_CY": "isCarry"
            },
            "calling": [
                "loop",
                "printFloat"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a04": {
            "entrypoint": "0x08000a04",
            "current_name": "check_bounds_08000a04",
            "code": "\nbool checkBounds_08000a04(void)\n\n{\n  undefined isZero;\n  undefined isCarry;\n  \n  __aeabi_cdrcmple();\n  return !(bool)isCarry || (bool)isZero;\n}\n\n",
            "renaming": {
                "FUN_08000a04": "check_bounds_08000a04",
                "in_ZR": "isZero",
                "in_CY": "isCarry"
            },
            "calling": [
                "SetOutputLimits",
                "loop"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a18": {
            "entrypoint": "0x08000a18",
            "current_name": "is_char_null_08000a18",
            "code": "\nbool is_char_null_08000a18(void)\n\n{\n  char input_char;\n  \n  __aeabi_cdrcmple();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000a18": "is_char_null_08000a18",
                "in_CY": "input_char"
            },
            "calling": [
                "SetOutputLimits",
                "Initialize",
                "loop",
                "Compute",
                "printFloat"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a2c": {
            "entrypoint": "0x08000a2c",
            "current_name": "check_parameters_08000a2c",
            "code": "\nundefined4 check_parameters_08000a2c(uint value1,int value2,uint value3,int value4)\n\n{\n  if ((((value2 << 1) >> 0x15 != -1) || ((value1 | value2 << 0xc) == 0)) &&\n     (((value4 << 1) >> 0x15 != -1 || ((value3 | value4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08000a2c": "check_parameters_08000a2c",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4"
            },
            "calling": [
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a58": {
            "entrypoint": "0x08000a58",
            "current_name": "calculate_output_08000a58",
            "code": "\nuint calculate_output_08000a58(uint input_value_1,uint final_result)\n\n{\n  uint normalized_result;\n  int multiplied_value;\n  uint subtracted_result;\n  \n  multiplied_value = final_result * 2 + 0x200000;\n  if (final_result * 2 < 0xffe00000) {\n    if (-1 < multiplied_value) {\n      return 0;\n    }\n    normalized_result = multiplied_value >> 0x15;\n    subtracted_result = -normalized_result - 0x3e1;\n    if (normalized_result < 0xfffffc20 && subtracted_result != 0) {\n      normalized_result = (final_result << 0xb | 0x80000000 | input_value_1 >> 0x15) >> (subtracted_result & 0xff);\n      if ((final_result & 0x80000000) != 0) {\n        normalized_result = -normalized_result;\n      }\n      return normalized_result;\n    }\n  }\n  else if ((input_value_1 | final_result << 0xc) != 0) {\n    return 0;\n  }\n  final_result = final_result & 0x80000000;\n  if (final_result == 0) {\n    final_result = 0x7fffffff;\n  }\n  return final_result;\n}\n\n",
            "renaming": {
                "FUN_08000a58": "calculate_output_08000a58",
                "param_1": "input_value_1",
                "param_2": "final_result",
                "uVar1": "normalized_result",
                "iVar2": "multiplied_value",
                "uVar3": "subtracted_result"
            },
            "calling": [
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa8": {
            "entrypoint": "0x08000aa8",
            "current_name": "calculate_result_08000aa8",
            "code": "\nuint calculateResult_08000aa8(uint input1,uint input2)\n\n{\n  int tempVar1;\n  uint tempVar2;\n  \n  if ((input2 & 0x80000000) != 0) {\n    return 0;\n  }\n  tempVar1 = input2 * 2 + 0x200000;\n  if (input2 * 2 < 0xffe00000) {\n    if (-1 < tempVar1) {\n      return 0;\n    }\n    tempVar2 = -(tempVar1 >> 0x15) - 0x3e1;\n    if (-1 < (int)tempVar2) {\n      return (input2 << 0xb | 0x80000000 | input1 >> 0x15) >> (tempVar2 & 0xff);\n    }\n  }\n  else if ((input1 | input2 << 0xc) != 0) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000aa8": "calculate_result_08000aa8",
                "param_1": "input1",
                "param_2": "input2",
                "iVar1": "tempVar1",
                "uVar2": "tempVar2"
            },
            "calling": [
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ae8": {
            "entrypoint": "0x08000ae8",
            "current_name": "execute_interrupt_08000ae8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_interrupt_08000ae8(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_08000ae8": "execute_interrupt_08000ae8"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aec": {
            "entrypoint": "0x08000aec",
            "current_name": "execute_afl_call_08000aec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint executeAflCall_08000aec(int inputTicks)\n\n{\n  uint32_t aflReturnValue;\n  \n  if (noHyperCall != 0) {\n    return 0;\n  }\n  aflReturnValue = aflCall(1,inputTicks,0);\n  return aflReturnValue;\n}\n\n",
            "renaming": {
                "FUN_08000aec": "execute_afl_call_08000aec",
                "ticks": "inputTicks",
                "uVar1": "aflReturnValue"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b08": {
            "entrypoint": "0x08000b08",
            "current_name": "initialize_components_08000b08",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeComponents_08000b08(int initializeFlag,int priorityFlag)\n\n{\n  if ((initializeFlag == 1) && (priorityFlag == 0xffff)) {\n    createPIDController::createPIDController(&ovenPIDController,&inputValue,&outputValue,&targetTemperature,(double)concatenateValues(kpHigh,kpLow),\n             (double)concatenateValues(kiHigh,kiLow),(double)concatenateValues(kdHigh,kdLow),0);\n    createLCD::createLCD\n              (&lcdObject,(uint8_t)lcdRsPinValue,(uint8_t)lcdEPinValue,(uint8_t)lcdD4PinValue,(uint8_t)lcdD5PinValue,\n               (uint8_t)lcdD6PinValue,(uint8_t)lcdD7PinValue);\n    createThermocouple::createThermocouple(&thermocoupleObject,(uchar)thermocoupleSOPinValue,(uchar)thermocoupleCSPinValue,\n                       (uchar)thermocoupleCLKPinValue);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000b08": "initialize_components_08000b08",
                "__initialize_p": "initializeFlag",
                "__priority": "priorityFlag",
                "PID": "createPIDController",
                "reflowOvenPID": "ovenPIDController",
                "input": "inputValue",
                "output": "outputValue",
                "setpoint": "targetTemperature",
                "CONCAT44": "concatenateValues",
                "kp._4_4_": "kpHigh",
                "kp._0_4_": "kpLow",
                "ki._4_4_": "kiHigh",
                "ki._0_4_": "kiLow",
                "kd._4_4_": "kdHigh",
                "kd._0_4_": "kdLow",
                "LiquidCrystal": "createLCD",
                "lcd": "lcdObject",
                "lcdRsPin": "lcdRsPinValue",
                "lcdEPin": "lcdEPinValue",
                "lcdD4Pin": "lcdD4PinValue",
                "lcdD5Pin": "lcdD5PinValue",
                "lcdD6Pin": "lcdD6PinValue",
                "lcdD7Pin": "lcdD7PinValue",
                "MAX31855": "createThermocouple",
                "thermocouple": "thermocoupleObject",
                "thermocoupleSOPin": "thermocoupleSOPinValue",
                "thermocoupleCSPin": "thermocoupleCSPinValue",
                "thermocoupleCLKPin": "thermocoupleCLKPinValue"
            },
            "calling": [
                "_GLOBAL__sub_I_lcdMessagesReflowStatus"
            ],
            "called": [
                "MAX31855",
                "LiquidCrystal",
                "PID"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000bcc": {
            "entrypoint": "0x08000bcc",
            "current_name": "initialize_oven_08000bcc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeOven_08000bcc(void)\n\n{\n  digitalWrite(temperatureControlPin,0);\n  pinMode(temperatureControlPin,1);\n  digitalWrite(buzzerPin,0);\n  pinMode(buzzerPin,1);\n  digitalWrite(redLedPin,0);\n  pinMode(redLedPin,1);\n  digitalWrite(buzzerPin,1);\n  LiquidCrystal::begin(&display,'\\b','\\x02','\\0');\n  LiquidCrystal::createChar(&display,'\\0',degreeSymbol);\n  LiquidCrystal::clear(&display);\n  Print::print(&display.super_Print,\"Reflow\");\n  LiquidCrystal::setCursor(&display,'\\0','\\x01');\n  Print::print(&display.super_Print,\"Oven 1.2\");\n  digitalWrite(buzzerPin,0);\n  delay(0x9c4);\n  LiquidCrystal::clear(&display);\n  HardwareSerial::begin(&Serial2,0xe100,'\\x06');\n  digitalWrite(redLedPin,1);\n  windowSize = 2000;\n  nextCheck = millis();\n  nextRead = millis();\n  startForkserver(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000bcc": "initialize_oven_08000bcc",
                "ssrPin": "temperatureControlPin",
                "ledRedPin": "redLedPin",
                "lcd": "display",
                "degree": "degreeSymbol"
            },
            "calling": [
                "main"
            ],
            "called": [
                "begin",
                "digitalWrite",
                "startForkserver",
                "delay",
                "setCursor",
                "print",
                "begin",
                "millis",
                "createChar",
                "pinMode",
                "clear"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cbc": {
            "entrypoint": "0x08000cbc",
            "current_name": "initialize_static_data_08000cbc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_08000cbc(void)\n\n{\n  initialize_static_and_destruction(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000cbc": "initialize_static_data_08000cbc",
                "__static_initialization_and_destruction_0": "initialize_static_and_destruction"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cd0": {
            "entrypoint": "0x08000cd0",
            "current_name": "update_reflow_oven_08000cd0",
            "code": "\n/* WARNING: UnkcurrentMillisn calling convention */\n\nvoid updateReflowOven_08000cd0(void)\n\n{\n  double dVar1;\n  uint32_t currentTime;\n  MAX31855 *thermocouplePtr;\n  int redLedState;\n  ulong currentMillis;\n  int comparisonResult;\n  size_t thermocoupleReading;\n  int digits1;\n  int digits2;\n  int digits3;\n  size_t lcdCursor;\n  undefined4 constant1;\n  undefined4 constant2;\n  undefined8 elapsedTime;\n  undefined4 constant3;\n  undefined4 constant4;\n  undefined4 constant5;\n  \n  currentTime = millis();\n  if (nextRead < currentTime) {\n    nextRead = nextRead + 1000;\n    thermocouplePtr = &thermocouple;\n    MAX31855::readThermocouple(&thermocouple,CELSIUS);\n    input._0_4_ = thermocouplePtr;\n    input._4_4_ = thermocoupleReading;\n    comparisonResult = __aeabi_dcmpeq();\n    if (((comparisonResult != 0) || (comparisonResult = __aeabi_dcmpeq(thermocouplePtr,thermocoupleReading,0,0x40c38880), comparisonResult != 0)) ||\n       (comparisonResult = __aeabi_dcmpeq(thermocouplePtr,thermocoupleReading,0,0x40c38900), comparisonResult != 0)) {\n      reflowState = REFLOW_STATE_ERROR;\n      reflowStatus = REFLOW_STATUS_OFF;\n    }\n  }\n  currentTime = millis();\n  comparisonResult = ledRedPin;\n  if (nextCheck < currentTime) {\n    nextCheck = nextCheck + 1000;\n    if (reflowStatus == REFLOW_STATUS_ON) {\n      redLedState = digitalRead(ledRedPin);\n      digitalWrite(comparisonResult,(uint)(redLedState == 0));\n      timerSeconds = timerSeconds + 1;\n      Print::print((Print *)&Serial2,timerSeconds,10);\n      Print::print((Print *)&Serial2,\" \");\n      Print::print((Print *)&Serial2,(double)CONCAT44(constant3,2),digits1);\n      Print::print((Print *)&Serial2,\" \");\n      Print::print((Print *)&Serial2,(double)CONCAT44(constant3,2),digits2);\n      Print::print((Print *)&Serial2,\" \");\n      Print::println((Print *)&Serial2,(double)CONCAT44(constant3,2),digits3);\n    }\n    else {\n      digitalWrite(ledRedPin,1);\n    }\n    LiquidCrystal::clear(&lcd);\n    Print::print(&lcd.super_Print,lcdMessagesReflowStatus[reflowState]);\n    LiquidCrystal::setCursor(&lcd,'\\0','\\x01');\n    if (reflowState == REFLOW_STATE_ERROR) {\n      Print::print(&lcd.super_Print,\"TC Error!\");\n    }\n    else {\n      thermocouplePtr = input._0_4_;\n      lcdCursor = input._4_4_;\n      Print::print(&lcd.super_Print,(double)CONCAT44(constant3,2),2);\n      LiquidCrystal::write(&lcd,0,thermocouplePtr,lcdCursor);\n      Print::print(&lcd.super_Print,\"C \");\n    }\n  }\n  lcdCursor = input._4_4_;\n  thermocouplePtr = input._0_4_;\n  setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n  switch(reflowState) {\n  case REFLOW_STATE_IDLE:\n    comparisonResult = __aeabi_dcmpge(input._0_4_,input._4_4_,0,0x40490000);\n    if (comparisonResult == 0) {\n      if (switchStatus == SWITCH_1) {\n        Print::println((Print *)&Serial2,\"Time Setpoint Input Output\");\n        timerSeconds = 0;\n        windowStartTime = millis();\n        setpoint._0_4_ = 0;\n        setpoint._4_4_ = 0x4062c000;\n        dVar1 = (double)__floatsidf(windowSize);\n        PID::SetOutputLimits\n                  (&reflowOvenPID,dVar1,(double)CONCAT44(constant5,constant4));\n        PID::SetSampleTime(&reflowOvenPID,1000);\n        PID::SetMode(&reflowOvenPID,1);\n        reflowState = REFLOW_STATE_PREHEAT;\n      }\n    }\n    else {\n      reflowState = REFLOW_STATE_TOO_HOT;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_PREHEAT:\n    reflowStatus = REFLOW_STATUS_ON;\n    comparisonResult = __aeabi_dcmpge(input._0_4_,input._4_4_,0,0x4062c000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (comparisonResult != 0) {\n      currentTime = millis();\n      timerSoak = currentTime + 9000;\n      PID::SetTunings(&reflowOvenPID,0.05,250.0,(double)CONCAT44(constant2,constant1));\n      reflowState = REFLOW_STATE_SOAK;\n      setpoint = 155.0;\n    }\n    break;\n  case REFLOW_STATE_SOAK:\n    currentTime = millis();\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (timerSoak < currentTime) {\n      currentTime = millis();\n      timerSoak = currentTime + 9000;\n      setpoint = (double)__aeabi_dadd(setpoint._0_4_,setpoint._4_4_,0,0x40140000);\n      comparisonResult = __aeabi_dcmpgt(SUB84(setpoint,0),(int)((ulonglong)setpoint >> 0x20),0,0x40690000);\n      if (comparisonResult != 0) {\n        PID::SetTunings(&reflowOvenPID,0.05,350.0,(double)CONCAT44(constant2,constant1));\n        reflowState = REFLOW_STATE_REFLOW;\n        setpoint = 250.0;\n      }\n    }\n    break;\n  case REFLOW_STATE_REFLOW:\n    comparisonResult = __aeabi_dcmpge(input._0_4_,input._4_4_,0,0x406ea000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (comparisonResult != 0) {\n      PID::SetTunings(&reflowOvenPID,0.05,350.0,(double)CONCAT44(constant2,constant1));\n      reflowState = REFLOW_STATE_COOL;\n      setpoint = 100.0;\n    }\n    break;\n  case REFLOW_STATE_COOL:\n    comparisonResult = __aeabi_dcmple(input._0_4_,input._4_4_,0,0x40590000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (comparisonResult != 0) {\n      currentTime = millis();\n      buzzerPeriod = currentTime + 1000;\n      digitalWrite(buzzerPin,1);\n      reflowStatus = REFLOW_STATUS_OFF;\n      reflowState = REFLOW_STATE_COMPLETE;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_COMPLETE:\n    currentTime = millis();\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (buzzerPeriod < currentTime) {\n      digitalWrite(buzzerPin,0);\n      reflowState = REFLOW_STATE_IDLE;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_TOO_HOT:\n    comparisonResult = __aeabi_dcmplt(input._0_4_,input._4_4_,0,0x40490000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (comparisonResult != 0) {\n      reflowState = REFLOW_STATE_IDLE;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_ERROR:\n    comparisonResult = __aeabi_dcmpeq(input._0_4_,input._4_4_,0,0x40c38800);\n    if ((comparisonResult == 0) && (comparisonResult = __aeabi_dcmpeq(thermocouplePtr,lcdCursor,0,0x40c38880), comparisonResult == 0)) {\n      comparisonResult = __aeabi_dcmpeq(thermocouplePtr,lcdCursor,0,0x40c38900);\n      if (comparisonResult == 0) {\n        reflowState = REFLOW_STATE_IDLE;\n        setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n        break;\n      }\n    }\n    reflowState = REFLOW_STATE_ERROR;\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n  }\n  if ((switchStatus == SWITCH_1) && (reflowStatus == REFLOW_STATUS_ON)) {\n    reflowStatus = REFLOW_STATUS_OFF;\n    reflowState = REFLOW_STATE_IDLE;\n  }\n  if (debounceState == DEBOUNCE_STATE_CHECK) {\n    currentTime = analogRead(switchPin);\n    if (currentTime == 0) {\n      currentTime = millis();\n      if (0x32 < currentTime - lastDebounceTime) {\n        debounceState = DEBOUNCE_STATE_RELEASE;\n      }\n    }\n    else {\n      debounceState = DEBOUNCE_STATE_IDLE;\n    }\n  }\n  else if (debounceState == DEBOUNCE_STATE_IDLE) {\n    switchStatus = SWITCH_NONE;\n    currentTime = analogRead(switchPin);\n    if (currentTime == 0) {\n      lastDebounceTime = millis();\n      debounceState = DEBOUNCE_STATE_CHECK;\n    }\n  }\n  else if (debounceState == DEBOUNCE_STATE_RELEASE) {\n    currentTime = analogRead(switchPin);\n    if (currentTime != 0) {\n      switchStatus = SWITCH_1;\n      debounceState = DEBOUNCE_STATE_IDLE;\n    }\n  }\n  if (reflowStatus == REFLOW_STATUS_ON) {\n    currentTime = millis();\n    PID::Compute(&reflowOvenPID);\n    if ((uint)windowSize < currentTime - windowStartTime) {\n      windowStartTime = windowStartTime + windowSize;\n    }\n    elapsedTime = __floatunsidf(currentTime - windowStartTime);\n    comparisonResult = __aeabi_dcmplt((int)elapsedTime,(int)((ulonglong)elapsedTime >> 0x20),output._0_4_,output._4_4_);\n    if (comparisonResult == 0) {\n      digitalWrite(ssrPin,0);\n      dVar1 = setpoint;\n    }\n    else {\n      digitalWrite(ssrPin,1);\n      dVar1 = setpoint;\n    }\n  }\n  else {\n    digitalWrite(ssrPin,0);\n    dVar1 = setpoint;\n  }\n  setpoint._4_4_ = (undefined4)((ulonglong)dVar1 >> 0x20);\n  setpoint._0_4_ = SUB84(dVar1,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000cd0": "update_reflow_oven_08000cd0",
                "uVar2": "currentTime",
                "pMVar3": "thermocouplePtr",
                "iVar4": "redLedState",
                "now": "currentMillis",
                "iVar5": "comparisonResult",
                "extraout_r1": "thermocoupleReading",
                "digits": "digits1",
                "digits_00": "digits2",
                "digits_01": "digits3",
                "sVar6": "lcdCursor",
                "unaff_r4": "constant1",
                "unaff_r5": "constant2",
                "uVar7": "elapsedTime",
                "in_stack_ffffffe4": "constant3",
                "in_stack_ffffffe8": "constant4",
                "in_stack_ffffffec": "constant5"
            },
            "calling": [
                "main"
            ],
            "called": [
                "SetOutputLimits",
                "write",
                "print",
                "setCursor",
                "analogRead",
                "millis",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "print",
                "__aeabi_dcmpeq",
                "println",
                "digitalRead",
                "__aeabi_dcmpge",
                "clear",
                "__aeabi_dcmple",
                "readThermocouple",
                "digitalWrite",
                "__floatsidf",
                "print",
                "Compute",
                "SetTunings",
                "SetSampleTime",
                "SetMode",
                "__floatunsidf",
                "__aeabi_dcmplt",
                "println"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001294": {
            "entrypoint": "0x08001294",
            "current_name": "set_row_offsets_08001294",
            "code": "\n/* DWARF original prototype: void  setRowOffsets_08001294(LiquidCrystal * lcd, int offset_0, int offset_1, int offset_2,\n   int offset_3) */\n\nvoid __lcdcall LiquidCrystal::setRowOffsets_08001294(LiquidCrystal *lcd,int offset_0,int offset_1,int offset_2,int offset_3)\n\n{\n  lcd->_row_offsets[0] = (uint8_t)offset_0;\n  lcd->_row_offsets[1] = (uint8_t)offset_1;\n  lcd->_row_offsets[2] = (uint8_t)offset_2;\n  lcd->_row_offsets[3] = (uint8_t)offset_3;\n  return;\n}\n\n",
            "renaming": {
                "this": "lcd",
                "row0": "offset_0",
                "row1": "offset_1",
                "row2": "offset_2",
                "row3": "offset_3",
                "FUN_08001294": "set_row_offsets_08001294"
            },
            "calling": [
                "begin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080012a2": {
            "entrypoint": "0x080012a2",
            "current_name": "pulse_enable_080012a2",
            "code": "\n/* DWARF original prototype: void  pulseEnable_080012a2(LiquidCrystal * lcd) */\n\nvoid __lcdcall LiquidCrystal::pulseEnable_080012a2(LiquidCrystal *lcd)\n\n{\n  digitalWrite((uint)lcd->pin,0);\n  digitalWrite((uint)lcd->pin,1);\n  digitalWrite((uint)lcd->pin,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080012a2": "pulse_enable_080012a2",
                "this": "lcd",
                "_enable_pin": "pin"
            },
            "calling": [
                "write4bits",
                "write8bits"
            ],
            "called": [
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080012c0": {
            "entrypoint": "0x080012c0",
            "current_name": "write4bits_080012c0",
            "code": "\n/* DWARF original prototype: void  write4bits_080012c0(LiquidCrystal * lcd, uint8_t input) */\n\nvoid __lcdcall LiquidCrystal::write4bits_080012c0(LiquidCrystal *lcd,uint8_t input)\n\n{\n  uint bitNumber;\n  \n  for (bitNumber = 0; (int)bitNumber < 4; bitNumber = bitNumber + 1) {\n    writeDigital((uint)lcd->dataPins[bitNumber],(int)(uint)input >> (bitNumber & 0xff) & 1);\n  }\n  createPulseEnable(lcd);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080012c0": "write4bits_080012c0",
                "this": "lcd",
                "value": "input",
                "uVar1": "bitNumber",
                "digitalWrite": "writeDigital",
                "_data_pins": "dataPins",
                "pulseEnable": "createPulseEnable"
            },
            "calling": [
                "send",
                "begin"
            ],
            "called": [
                "digitalWrite",
                "pulseEnable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080012e8": {
            "entrypoint": "0x080012e8",
            "current_name": "write8bits_080012e8",
            "code": "\n/* DWARF original prototype: void  write8bits_080012e8(LiquidCrystal * lcd, uint8_t inputValue) */\n\nvoid __lcdcall LiquidCrystal::write8bits_080012e8(LiquidCrystal *lcd,uint8_t inputValue)\n\n{\n  uint bitIndex;\n  \n  for (bitIndex = 0; (int)bitIndex < 8; bitIndex = bitIndex + 1) {\n    digitalWrite((uint)lcd->_data_pins[bitIndex],(int)(uint)inputValue >> (bitIndex & 0xff) & 1);\n  }\n  pulseEnable(lcd);\n  return;\n}\n\n",
            "renaming": {
                "this": "lcd",
                "value": "inputValue",
                "uVar1": "bitIndex",
                "FUN_080012e8": "write8bits_080012e8"
            },
            "calling": [
                "send"
            ],
            "called": [
                "digitalWrite",
                "pulseEnable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001310": {
            "entrypoint": "0x08001310",
            "current_name": "send_08001310",
            "code": "\n/* DWARF original prototype: void  send_08001310(LiquidCrystal * lcd, uint8_t value, uint8_t mode) */\n\nssize_t __lcdcall\nLiquidCrystal::send_08001310(LiquidCrystal *lcd,int value,void *data,size_t size,int flags)\n\n{\n  digitalWrite((uint)lcd->rs_pin,(uint32_t)data);\n  if (lcd->rw_pin != 0xff) {\n    digitalWrite((uint)lcd->rw_pin,0);\n  }\n  if ((lcd->display_function & 0x10) == 0) {\n    write_4_bits(lcd,(uint8_t)((uint)value >> 4));\n    write_4_bits(lcd,(uint8_t)value);\n    return (ssize_t)lcd;\n  }\n  write_8_bits(lcd,(uint8_t)value);\n  return (ssize_t)lcd;\n}\n\n",
            "renaming": {
                "FUN_08001310": "send_08001310",
                "this": "lcd",
                "__fd": "value",
                "__buf": "data",
                "__n": "size",
                "__flags": "flags",
                "_rs_pin": "rs_pin",
                "_rw_pin": "rw_pin",
                "_displayfunction": "display_function",
                "write4bits": "write_4_bits",
                "write8bits": "write_8_bits"
            },
            "calling": [
                "write",
                "setCursor",
                "begin",
                "display",
                "createChar",
                "clear"
            ],
            "called": [
                "digitalWrite",
                "write4bits",
                "write8bits"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800134e": {
            "entrypoint": "0x0800134e",
            "current_name": "send_data_to_lcd_0800134e",
            "code": "\n/* DWARF original prototype: size_t  write(LiquidCrystal * this, uint8_t value) */\n\nssize_t LiquidCrystal LiquidCrystal::send_data_to_lcd_0800134e(LiquidCrystal *this,int file_descriptor,void *buffer,size_t buffer_length)\n\n{\n  send(this,file_descriptor,(void *)0x1,buffer_length,buffer_length);\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0800134e": "send_data_to_lcd_0800134e",
                "__thiscall": "LiquidCrystal",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "buffer_length"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800135a": {
            "entrypoint": "0x0800135a",
            "current_name": "clear_lcd_screen_0800135a",
            "code": "\n/* DWARF original prototype: void  clear(LiquidCrystal * lcd_object) */\n\nvoid __lcd_objectcall LiquidCrystal::clear_lcd_screen_0800135a(LiquidCrystal *lcd_object)\n\n{\n  size_t data_size;\n  \n  send(lcd_object,1,(void *)0x0,data_size,data_size);\n  return;\n}\n\n",
            "renaming": {
                "this": "lcd_object",
                "in_r3": "data_size",
                "FUN_0800135a": "clear_lcd_screen_0800135a"
            },
            "calling": [
                "setup",
                "begin",
                "loop"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001366": {
            "entrypoint": "0x08001366",
            "current_name": "set_cursor_position_08001366",
            "code": "\n/* DWARF original prototype: void  setCursor(LiquidCrystal * lcd, uint8_t column, uint8_t row) */\n\nvoid __lcdcall LiquidCrystal::setCursorPosition_08001366(LiquidCrystal *lcd,uint8_t column,uint8_t row)\n\n{\n  uint clampedRow;\n  int unusedVar;\n  \n  clampedRow = (uint)row;\n  if (3 < clampedRow) {\n    clampedRow = 3;\n  }\n  if (lcd->_numlines <= clampedRow) {\n    clampedRow = lcd->_numlines - 1 & 0xff;\n  }\n  send(lcd,(uint)(byte)(column + lcd->_row_offsets[clampedRow] | 0x80),(void *)0x0,\n       (uint)lcd->_row_offsets[clampedRow],unusedVar);\n  return;\n}\n\n",
            "renaming": {
                "this": "lcd",
                "col": "column",
                "uVar1": "clampedRow",
                "in_r3": "unusedVar",
                "FUN_08001366": "set_cursor_position_08001366"
            },
            "calling": [
                "setup",
                "loop"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800138e": {
            "entrypoint": "0x0800138e",
            "current_name": "update_display_control_and_send_0800138e",
            "code": "\n/* DWARF original prototype: void  display(LiquidCrystal * lcd) */\n\nvoid __lcdcall LiquidCrystal::updateDisplayControlAndSend_0800138e(LiquidCrystal *lcd)\n\n{\n  byte oldDisplayControl;\n  size_t size;\n  \n  oldDisplayControl = lcd->displayControl;\n  lcd->displayControl = oldDisplayControl | 4;\n  sendData(lcd,oldDisplayControl | 0xc,(void *)0x0,size,size);\n  return;\n}\n\n",
            "renaming": {
                "this": "lcd",
                "bVar1": "oldDisplayControl",
                "in_r3": "size",
                "_displaycontrol": "displayControl",
                "send": "sendData",
                "FUN_0800138e": "update_display_control_and_send_0800138e"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080013a4": {
            "entrypoint": "0x080013a4",
            "current_name": "initialize_lcd_080013a4",
            "code": "\n/* DWARF original prototype: void  begin(LiquidCrystal * lcd, uint8_t numColumns, uint8_t numLines, uint8_t\n   dotSize) */\n\nvoid __lcdcall\nLiquidCrystal::initializeLCD_080013a4(LiquidCrystal *lcd,uint8_t numColumns,uint8_t numLines,uint8_t dotSize)\n\n{\n  int rowOffset;\n  size_t numBits;\n  int counter;\n  \n  if (1 < numLines) {\n    lcd->_displayfunction = lcd->_displayfunction | 8;\n  }\n  lcd->_numnumLines = numLines;\n  rowOffset = numColumns + 0x40;\n  setRowOffsets(lcd,0,0x40,(uint)numColumns,rowOffset);\n  if ((dotSize != '\\0') && (numLines == '\\x01')) {\n    lcd->_displayfunction = lcd->_displayfunction | 4;\n  }\n  pinMode((uint)lcd->_rs_pin,1);\n  if (lcd->_rw_pin != 0xff) {\n    pinMode((uint)lcd->_rw_pin,1);\n  }\n  pinMode((uint)lcd->_enable_pin,1);\n  counter = 0;\n  while( true ) {\n    if ((lcd->_displayfunction & 0x10) == 0) {\n      numBits = 4;\n    }\n    else {\n      numBits = 8;\n    }\n    if ((int)numBits <= counter) break;\n    pinMode((uint)lcd->_data_pins[counter],1);\n    counter = counter + 1;\n  }\n  digitalWrite((uint)lcd->_rs_pin,0);\n  digitalWrite((uint)lcd->_enable_pin,0);\n  if (lcd->_rw_pin != 0xff) {\n    digitalWrite((uint)lcd->_rw_pin,0);\n  }\n  if ((lcd->_displayfunction & 0x10) == 0) {\n    write4bits(lcd,'\\x03');\n    write4bits(lcd,'\\x03');\n    write4bits(lcd,'\\x03');\n    write4bits(lcd,'\\x02');\n  }\n  else {\n    send(lcd,lcd->_displayfunction | 0x20,(void *)0x0,numBits,rowOffset);\n    send(lcd,lcd->_displayfunction | 0x20,(void *)0x0,numBits,rowOffset);\n    send(lcd,lcd->_displayfunction | 0x20,(void *)0x0,numBits,rowOffset);\n  }\n  send(lcd,lcd->_displayfunction | 0x20,(void *)0x0,numBits,rowOffset);\n  lcd->_displaycontrol = '\\x04';\n  display(lcd);\n  clear(lcd);\n  lcd->_displaymode = '\\x02';\n  send(lcd,6,(void *)0x0,2,rowOffset);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080013a4": "initialize_lcd_080013a4",
                "this": "lcd",
                "cols": "numColumns",
                "lines": "numLines",
                "dotsize": "dotSize",
                "row3": "rowOffset",
                "__n": "numBits",
                "iVar1": "counter"
            },
            "calling": [
                "setup",
                "init"
            ],
            "called": [
                "digitalWrite",
                "send",
                "display",
                "pinMode",
                "clear",
                "setRowOffsets",
                "write4bits"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014ba": {
            "entrypoint": "0x080014ba",
            "current_name": "initialize_lcd_080014ba",
            "code": "\n/* DWARF original prototype: void  init(LiquidCrystal * lcd, uint8_t fourbitmode, uint8_t rs,\n   uint8_t rw, uint8_t enable, uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3, uint8_t d4, uint8_t\n   d5, uint8_t d6, uint8_t d7) */\n\nint __lcdcall LiquidCrystal::initializeLCD_080014ba(LiquidCrystal *lcd,EVP_PKEY_CTX *context)\n\n{\n  uint8_t rs_pin;\n  uint8_t rw_pin;\n  uint8_t enable_pin;\n  uint8_t d0_pin;\n  uint8_t d1_pin;\n  uint8_t d2_pin;\n  uint8_t d3_pin;\n  uint8_t d4_pin;\n  uint8_t d5_pin;\n  uint8_t d6_pin;\n  uint8_t d7_pin;\n  \n  lcd->_rs_pin = rs_pin;\n  lcd->_rw_pin = rw_pin;\n  lcd->_enable_pin = enable_pin;\n  lcd->_data_pins[0] = d0_pin;\n  lcd->_data_pins[1] = d1_pin;\n  lcd->_data_pins[2] = d2_pin;\n  lcd->_data_pins[3] = d3_pin;\n  lcd->_data_pins[4] = d4_pin;\n  lcd->_data_pins[5] = d5_pin;\n  lcd->_data_pins[6] = d6_pin;\n  lcd->_data_pins[7] = d7_pin;\n  if (context == (EVP_PKEY_CTX *)0x0) {\n    lcd->_displayfunction = '\\x10';\n  }\n  else {\n    lcd->_displayfunction = '\\0';\n  }\n  begin(lcd,'\\x10','\\x01','\\0');\n  return (int)lcd;\n}\n\n",
            "renaming": {
                "FUN_080014ba": "initialize_lcd_080014ba",
                "this": "lcd",
                "in_r2": "rs_pin",
                "in_r3": "rw_pin",
                "in_stack_00000000": "enable_pin",
                "in_stack_00000004": "d0_pin",
                "in_stack_00000008": "d1_pin",
                "in_stack_0000000c": "d2_pin",
                "in_stack_00000010": "d3_pin",
                "in_stack_00000014": "d4_pin",
                "in_stack_00000018": "d5_pin",
                "in_stack_0000001c": "d6_pin",
                "in_stack_00000020": "d7_pin",
                "ctx": "context"
            },
            "calling": [
                "LiquidCrystal"
            ],
            "called": [
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001510": {
            "entrypoint": "0x08001510",
            "current_name": "initialize_lcd_08001510",
            "code": "\n/* DWARF original prototype: LiquidCrystal *  LiquidCrystal(LiquidCrystal * lcd, uint8_t rsPin,\n   uint8_t enablePin, uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3) */\n\nLiquidCrystal * __lcdcall\nLiquidCrystal::initializeLCD_08001510(LiquidCrystal *lcd,uint8_t rsPin,uint8_t enablePin,uint8_t d0,uint8_t d1,uint8_t d2,uint8_t d3\n          )\n\n{\n  (lcd->printSuperclass).errorFlag = 0;\n  (lcd->printSuperclass).printVptr = (_func_int_varargs **)&PTR_write_1_080073f8;\n  init(lcd,(EVP_PKEY_CTX *)0x1);\n  return lcd;\n}\n\n",
            "renaming": {
                "FUN_08001510": "initialize_lcd_08001510",
                "this": "lcd",
                "rs": "rsPin",
                "enable": "enablePin",
                "super_Print": "printSuperclass",
                "write_error": "errorFlag",
                "_vptr_Print": "printVptr"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001550": {
            "entrypoint": "0x08001550",
            "current_name": "create_char_in_lcd_08001550",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example charLocation: r0 : 0x08001574 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  createChar(LiquidCrystal * lcdObject, uint8_t charLocation, uint8_t *\n   characterMap) */\n\nvoid __lcdObjectcall LiquidCrystal::createCharInLCD_08001550(LiquidCrystal *lcdObject,uint8_t charLocation,uint8_t *characterMap)\n\n{\n  size_t sizeValue;\n  int intValue;\n  int index;\n  \n  sendToLCD(lcdObject,(charLocation & 7) << 3 | 0x40,(void *)0x0,sizeValue,intValue);\n  for (index = 0; index < 8; index = index + 1) {\n    (**(lcdObject->base_Print).virtualPrint)(lcdObject,(uint)characterMap[index]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001550": "create_char_in_lcd_08001550",
                "this": "lcdObject",
                "location": "charLocation",
                "charmap": "characterMap",
                "in_r3": "sizeValue",
                "unaff_r4": "intValue",
                "send": "sendToLCD",
                "super_Print": "base_Print",
                "_vptr_Print": "virtualPrint",
                "iVar1": "index"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800157c": {
            "entrypoint": "0x0800157c",
            "current_name": "initialize_sensor_0800157c",
            "code": "\n/* DWARF original prototype: MAX31855 *  MAX31855(MAX31855 * sensor, uchar serialOutputPin, uchar chipSelectPin, uchar clockPin) */\n\nMAX31855 * __sensorcall MAX31855::initializeSensor_0800157c(MAX31855 *sensor,uchar serialOutputPin,uchar chipSelectPin,uchar clockPin)\n\n{\n  sensor->so = serialOutputPin;\n  sensor->cs = chipSelectPin;\n  sensor->sck = clockPin;\n  setPinMode((uint)serialOutputPin,0);\n  setPinMode((uint)sensor->cs,1);\n  setPinMode((uint)sensor->sck,1);\n  writeDigital((uint)sensor->cs,1);\n  writeDigital((uint)sensor->sck,0);\n  return sensor;\n}\n\n",
            "renaming": {
                "SO": "serialOutputPin",
                "CS": "chipSelectPin",
                "SCK": "clockPin",
                "this": "sensor",
                "pinMode": "setPinMode",
                "digitalWrite": "writeDigital",
                "FUN_0800157c": "initialize_sensor_0800157c"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "digitalWrite",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b2": {
            "entrypoint": "0x080015b2",
            "current_name": "read_data_080015b2",
            "code": "\n/* DWARF original prototype: ulong  readData_080015b2(MAX31855 * sensor) */\n\nulong __sensorcall MAX31855::readData_080015b2(MAX31855 *sensor)\n\n{\n  int readBit;\n  uint bitPosition;\n  uint value;\n  \n  digitalWrite((uint)sensor->chipSelect,0);\n  value = 0;\n  for (bitPosition = 0x1f; -1 < (int)bitPosition; bitPosition = bitPosition - 1) {\n    digitalWrite((uint)sensor->clock,1);\n    readBit = digitalRead((uint)sensor->dataOut);\n    if (readBit != 0) {\n      value = value | 1 << (bitPosition & 0xff);\n    }\n    digitalWrite((uint)sensor->clock,0);\n  }\n  digitalWrite((uint)sensor->chipSelect,1);\n  return value;\n}\n\n",
            "renaming": {
                "this": "sensor",
                "cs": "chipSelect",
                "sck": "clock",
                "so": "dataOut",
                "iVar1": "readBit",
                "uVar2": "bitPosition",
                "uVar3": "value",
                "FUN_080015b2": "read_data_080015b2"
            },
            "calling": [
                "readThermocouple"
            ],
            "called": [
                "digitalWrite",
                "digitalRead"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015f8": {
            "entrypoint": "0x080015f8",
            "current_name": "calculate_temperature_080015f8",
            "code": "\n/* DWARF original prototype: double  readThermocouple(MAX31855 * thermocouple, temperatureUnit_t temperatureUnit) */\n\ndouble __thermocouplecall MAX31855::calculateTemperature_080015f8(MAX31855 *thermocouple,temperatureUnit_t temperatureUnit)\n\n{\n  ulong data;\n  ulong data;\n  uint shiftedData;\n  double defaultTemperature;\n  double defaultTemperature2;\n  double finalTemperature;\n  undefined8 convertedData;\n  \n  data = readData(thermocouple);\n  if ((data & 0x10000) == 0) {\n    shiftedData = data >> 0x12;\n    convertedData = __floatunsidf(shiftedData & 0x1fff);\n    if ((shiftedData & 0x2000) != 0) {\n      convertedData = __floatunsidf(~shiftedData & 0x1fff);\n      convertedData = __aeabi_dadd((int)convertedData,(int)((ulonglong)convertedData >> 0x20),0,0x3ff00000);\n      convertedData = CONCAT44((int)((ulonglong)convertedData >> 0x20) + -0x80000000,(int)convertedData);\n    }\n    convertedData = __muldf3((int)convertedData,(int)((ulonglong)convertedData >> 0x20),0,0x3fd00000);\n    finalTemperature = defaultTemperature2;\n    if (temperatureUnit == FAHRENHEIT) {\n      convertedData = __muldf3((int)convertedData,(int)((ulonglong)convertedData >> 0x20),0,0x40220000);\n      convertedData = __divdf3((int)convertedData,(int)((ulonglong)convertedData >> 0x20),0,0x40140000);\n      finalTemperature = (double)__aeabi_dadd((int)convertedData,(int)((ulonglong)convertedData >> 0x20),0,0x40400000);\n      return finalTemperature;\n    }\n  }\n  else {\n    shiftedData = data & 7;\n    if (shiftedData == 2) {\n      return defaultTemperature;\n    }\n    if (shiftedData == 4) {\n      return defaultTemperature;\n    }\n    finalTemperature = defaultTemperature;\n    if (shiftedData != 1) {\n      return defaultTemperature;\n    }\n  }\n  return finalTemperature;\n}\n\n",
            "renaming": {
                "FUN_080015f8": "calculate_temperature_080015f8",
                "this": "thermocouple",
                "unit": "temperatureUnit",
                "uVar1": "data",
                "uVar2": "shiftedData",
                "extraout_d0": "defaultTemperature",
                "extraout_d0_00": "defaultTemperature2",
                "dVar3": "finalTemperature",
                "uVar4": "convertedData"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "__floatunsidf",
                "__divdf3",
                "readData"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016b4": {
            "entrypoint": "0x080016b4",
            "current_name": "compute_pid_controller_080016b4",
            "code": "\n/* DWARF original prototype: bool  Compute(PIDController * controller) */\n\nbool __controllercall PIDController::computePIDController_080016b4(PIDController *controller)\n\n{\n  bool inAutoMode;\n  uint32_t currentTime;\n  ulong currentMillis;\n  int comparisonResult;\n  undefined4 tempVar4;\n  undefined4 inputVar1;\n  undefined4 outputSumVar1;\n  undefined4 outputSumVar2;\n  ulong timeChange;\n  undefined4 inputVar2;\n  undefined4 outputMaxVar1;\n  undefined4 outputMinVar1;\n  char isInAutoMode;\n  undefined4 outputMaxVar2;\n  undefined4 outputMinVar2;\n  undefined4 setpointVar1;\n  undefined8 setpointVar2;\n  undefined8 errorVar1;\n  undefined8 errorVar2;\n  double outputSum;\n  double controllerOutput;\n  double outputVar;\n  \n  isInAutoMode = controller->inAuto;\n  if ((bool)isInAutoMode != false) {\n    currentTime = millis();\n    if (currentTime - controller->lastTime < controller->SampleTime) {\n      isInAutoMode = '\\0';\n    }\n    else {\n      inputVar1 = *(undefined4 *)controller->myInput;\n      inputVar2 = *(undefined4 *)((int)controller->myInput + 4);\n      setpointVar2 = __subdf3(*(undefined4 *)controller->mySetpoint,*(undefined4 *)((int)controller->mySetpoint + 4));\n      setpointVar1 = (undefined4)((ulonglong)setpointVar2 >> 0x20);\n      errorVar1 = __subdf3(inputVar1,inputVar2,*(undefined4 *)&controller->lastInput,\n                        *(undefined4 *)((int)&controller->lastInput + 4));\n      tempVar4 = (undefined4)((ulonglong)errorVar1 >> 0x20);\n      errorVar2 = __muldf3((int)setpointVar2,setpointVar1,*(undefined4 *)&controller->ki,\n                        *(undefined4 *)((int)&controller->ki + 4));\n      outputSum = (double)__aeabi_dadd((int)errorVar2,(int)((ulonglong)errorVar2 >> 0x20),\n                                    *(undefined4 *)&controller->outputVarSum,\n                                    *(undefined4 *)((int)&controller->outputVarSum + 4));\n      controller->outputVarSum = outputSum;\n      inAutoMode = controller->pOnE;\n      if (inAutoMode == false) {\n        errorVar2 = __muldf3((int)errorVar1,tempVar4,*(undefined4 *)&controller->kp,\n                          *(undefined4 *)((int)&controller->kp + 4));\n        outputSum = (double)__subdf3(SUB84(outputSum,0),(int)((ulonglong)outputSum >> 0x20),(int)errorVar2,\n                                  (int)((ulonglong)errorVar2 >> 0x20));\n        controller->outputVarSum = outputSum;\n      }\n      outputSumVar1 = *(undefined4 *)&controller->outputVarSum;\n      outputMaxVar1 = *(undefined4 *)((int)&controller->outputVarSum + 4);\n      outputMaxVar2 = *(undefined4 *)&controller->outMax;\n      outputMinVar2 = *(undefined4 *)((int)&controller->outMax + 4);\n      outputSum = controller->outMax;\n      comparisonResult = __aeabi_dcmpgt(outputSumVar1,outputMaxVar1,outputMaxVar2,outputMinVar2);\n      if (comparisonResult == 0) {\n        outputSumVar2 = *(undefined4 *)&controller->outMin;\n        outputMinVar1 = *(undefined4 *)((int)&controller->outMin + 4);\n        comparisonResult = __aeabi_dcmplt(outputSumVar1,outputMaxVar1);\n        if (comparisonResult != 0) {\n          *(undefined4 *)&controller->outputVarSum = outputSumVar2;\n          *(undefined4 *)((int)&controller->outputVarSum + 4) = outputMinVar1;\n        }\n      }\n      else {\n        *(undefined4 *)&controller->outputVarSum = outputMaxVar2;\n        *(undefined4 *)((int)&controller->outputVarSum + 4) = outputMinVar2;\n      }\n      if (inAutoMode == false) {\n        setpointVar2 = 0;\n      }\n      else {\n        setpointVar2 = __muldf3((int)setpointVar2,setpointVar1,*(undefined4 *)&controller->kp,\n                          *(undefined4 *)((int)&controller->kp + 4));\n      }\n      outputVar._4_4_ = (undefined4)((ulonglong)setpointVar2 >> 0x20);\n      outputVar._0_4_ = (undefined4)setpointVar2;\n      setpointVar1 = *(undefined4 *)&controller->outputVarSum;\n      outputSumVar1 = *(undefined4 *)((int)&controller->outputVarSum + 4);\n      setpointVar2 = __muldf3((int)errorVar1,tempVar4,*(undefined4 *)&controller->kd,\n                        *(undefined4 *)((int)&controller->kd + 4));\n      setpointVar2 = __subdf3(setpointVar1,outputSumVar1,(int)setpointVar2,(int)((ulonglong)setpointVar2 >> 0x20));\n      controllerOutput = (double)__aeabi_dadd(outputVar._0_4_,outputVar._4_4_,(int)setpointVar2,\n                                    (int)((ulonglong)setpointVar2 >> 0x20));\n      setpointVar1 = (undefined4)((ulonglong)controllerOutput >> 0x20);\n      comparisonResult = __aeabi_dcmplt(outputMaxVar2,outputMinVar2,SUB84(controllerOutput,0),setpointVar1);\n      if (comparisonResult == 0) {\n        outputSum = controller->outMin;\n        comparisonResult = __aeabi_dcmplt(SUB84(controllerOutput,0),setpointVar1,*(undefined4 *)&controller->outMin,\n                               *(undefined4 *)((int)&controller->outMin + 4));\n        if (comparisonResult == 0) {\n          outputSum = controllerOutput;\n        }\n      }\n      *controller->myOutput = outputSum;\n      *(undefined4 *)&controller->lastInput = inputVar1;\n      *(undefined4 *)((int)&controller->lastInput + 4) = inputVar2;\n      controller->lastTime = currentTime;\n    }\n  }\n  return (bool)isInAutoMode;\n}\n\n",
            "renaming": {
                "PID": "PIDController",
                "this": "controller",
                "bVar1": "inAutoMode",
                "uVar2": "currentTime",
                "now": "currentMillis",
                "iVar3": "comparisonResult",
                "uVar4": "tempVar4",
                "uVar5": "inputVar1",
                "uVar6": "outputSumVar1",
                "uVar7": "outputSumVar2",
                "uVar8": "inputVar2",
                "uVar9": "outputMaxVar1",
                "uVar10": "outputMinVar1",
                "uVar12": "outputMaxVar2",
                "uVar13": "outputMinVar2",
                "uVar14": "setpointVar1",
                "uVar15": "setpointVar2",
                "uVar16": "errorVar1",
                "uVar17": "errorVar2",
                "dVar18": "outputSum",
                "dVar19": "controllerOutput",
                "output": "outputVar",
                "cVar11": "isInAutoMode",
                "FUN_080016b4": "compute_pid_controller_080016b4"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__muldf3",
                "__subdf3",
                "__aeabi_dadd",
                "millis",
                "__aeabi_dcmpgt",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001814": {
            "entrypoint": "0x08001814",
            "current_name": "set_tunings_08001814",
            "code": "\n/* DWARF original prototype: void  SetTunings(PID * pid, double proportionalGain, double integralGain, double derivativeGain, int controllerDirection)\n    */\n\nvoid __pidcall PID::setTunings_08001814(PID *pid,double proportionalGain,double integralGain,double derivativeGain,int controllerDirection)\n\n{\n  int isLessThanZero;\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined4 temp3;\n  undefined temp4;\n  bool isNotEqualToOne;\n  undefined8 sampleTime;\n  double temp5;\n  double temp6;\n  double temp7;\n  \n  isLessThanZero = __aeabi_dcmplt();\n  if (((isLessThanZero == 0) && (isLessThanZero = __aeabi_dcmplt(proportionalGain._0_4_,proportionalGain._4_4_,0,0), isLessThanZero == 0)) &&\n     (isLessThanZero = __aeabi_dcmplt(integralGain._0_4_,integralGain._4_4_,0,0), isLessThanZero == 0)) {\n    pid->pOn = derivativeGain._0_4_;\n    isNotEqualToOne = derivativeGain._0_4_ != 1;\n    if (isNotEqualToOne) {\n      derivativeGain._0_4_ = 0;\n    }\n    temp4 = (undefined)derivativeGain._0_4_;\n    if (!isNotEqualToOne) {\n      temp4 = true;\n    }\n    pid->pOnE = (bool)temp4;\n    *(undefined4 *)&pid->dispproportionalGain = temp2;\n    *(undefined4 *)((int)&pid->dispproportionalGain + 4) = temp3;\n    pid->dispintegralGain = proportionalGain;\n    pid->dispderivativeGain = integralGain;\n    sampleTime = __floatunsidf(pid->SampleTime);\n    sampleTime = __divdf3((int)sampleTime,(int)((ulonglong)sampleTime >> 0x20),0,0x408f4000);\n    temp1 = (undefined4)((ulonglong)sampleTime >> 0x20);\n    *(undefined4 *)&pid->kp = temp2;\n    *(undefined4 *)((int)&pid->kp + 4) = temp3;\n    temp5 = (double)__muldf3(proportionalGain._0_4_,proportionalGain._4_4_,(int)sampleTime,temp1);\n    pid->ki = temp5;\n    temp6 = (double)__divdf3(integralGain._0_4_,integralGain._4_4_,(int)sampleTime,temp1);\n    pid->kd = temp6;\n    if (pid->controllerDirection == 1) {\n      temp7 = (double)__subdf3(0,0);\n      pid->kp = temp7;\n      temp5 = (double)__subdf3(0,0,SUB84(temp5,0),(int)((ulonglong)temp5 >> 0x20));\n      pid->ki = temp5;\n      temp5 = (double)__subdf3(0,0,SUB84(temp6,0),(int)((ulonglong)temp6 >> 0x20));\n      pid->kd = temp5;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001814": "set_tunings_08001814",
                "this": "pid",
                "Kp": "proportionalGain",
                "Ki": "integralGain",
                "Kd": "derivativeGain",
                "POn": "controllerDirection",
                "iVar1": "isLessThanZero",
                "uVar2": "temp1",
                "in_r2": "temp2",
                "in_r3": "temp3",
                "uVar3": "temp4",
                "bVar4": "isNotEqualToOne",
                "uVar5": "sampleTime",
                "dVar6": "temp5",
                "dVar7": "temp6",
                "dVar8": "temp7"
            },
            "calling": [
                "PID",
                "SetTunings"
            ],
            "called": [
                "__muldf3",
                "__subdf3",
                "__floatunsidf",
                "__divdf3",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080018f8": {
            "entrypoint": "0x080018f8",
            "current_name": "set_pid_tunings_080018f8",
            "code": "\n/* DWARF original prototype: void  SetTunings(PID * pidController, double proportional, double integral, double derivative) */\n\nvoid __pidControllercall PID::setPIDTunings_080018f8(PID *pidController,double proportional,double integral,double derivative)\n\n{\n  undefined4 stackArg;\n  \n  SetTunings(pidController,proportional,integral,(double)CONCAT44(stackArg,pidController->pOn),pidController->pOn);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080018f8": "set_pid_tunings_080018f8",
                "this": "pidController",
                "Kp": "proportional",
                "Ki": "integral",
                "Kd": "derivative",
                "in_stack_ffffffec": "stackArg"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "SetTunings"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001918": {
            "entrypoint": "0x08001918",
            "current_name": "set_sample_time_08001918",
            "code": "\n/* DWARF original prototype: void  SetSampleTime(PID * pid, int newSampleTime) */\n\nvoid __pidcall PID::setSampleTime_08001918(PID *pid,int newSampleTime)\n\n{\n  undefined4 temp1;\n  undefined8 convertedSampleTime;\n  undefined8 convertedCurrentSampleTime;\n  double temp2;\n  \n  if (0 < newSampleTime) {\n    convertedSampleTime = __floatsidf(newSampleTime);\n    convertedCurrentSampleTime = __floatunsidf(pid->SampleTime);\n    convertedSampleTime = __divdf3((int)convertedSampleTime,(int)((ulonglong)convertedSampleTime >> 0x20),(int)convertedCurrentSampleTime,\n                     (int)((ulonglong)convertedCurrentSampleTime >> 0x20));\n    temp1 = (undefined4)((ulonglong)convertedSampleTime >> 0x20);\n    temp2 = (double)__muldf3((int)convertedSampleTime,temp1,*(undefined4 *)&pid->ki,\n                             *(undefined4 *)((int)&pid->ki + 4));\n    pid->ki = temp2;\n    temp2 = (double)__divdf3(*(undefined4 *)&pid->kd,*(undefined4 *)((int)&pid->kd + 4),(int)convertedSampleTime\n                             ,temp1);\n    pid->kd = temp2;\n    pid->SampleTime = newSampleTime;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001918": "set_sample_time_08001918",
                "this": "pid",
                "NewSampleTime": "newSampleTime",
                "uVar1": "temp1",
                "uVar2": "convertedSampleTime",
                "uVar3": "convertedCurrentSampleTime",
                "dVar4": "temp2"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__muldf3",
                "__floatsidf",
                "__floatunsidf",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001960": {
            "entrypoint": "0x08001960",
            "current_name": "set_output_limits_08001960",
            "code": "\n/* DWARF original prototype: void  SetOutputLimits(PID * this, double minValue, double maxValue) */\n\nvoid __thiscall PID::setOutputLimits_08001960(PID *this,double minValue,double maxValue)\n\n{\n  int comparisonResult;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  double *outputPtr;\n  undefined4 outputSum1;\n  undefined4 outputSum2;\n  undefined4 outMax1;\n  undefined4 outMax2;\n  \n  comparisonResult = __aeabi_dcmpge();\n  if (comparisonResult == 0) {\n    *(undefined4 *)&this->outminValue = in_r2;\n    *(undefined4 *)((int)&this->outminValue + 4) = in_r3;\n    this->outmaxValue = minValue;\n    if (this->inAuto != false) {\n      outputPtr = this->myOutput;\n      comparisonResult = __aeabi_dcmplt(minValue._0_4_,minValue._4_4_,*(undefined4 *)outputPtr,\n                             *(undefined4 *)((int)outputPtr + 4));\n      if (comparisonResult == 0) {\n        comparisonResult = __aeabi_dcmpgt();\n        if (comparisonResult != 0) {\n          *(undefined4 *)outputPtr = in_r2;\n          *(undefined4 *)((int)outputPtr + 4) = in_r3;\n        }\n      }\n      else {\n        *outputPtr = minValue;\n      }\n      outputSum1 = *(undefined4 *)&this->outputSum;\n      outputSum2 = *(undefined4 *)((int)&this->outputSum + 4);\n      outMax1 = *(undefined4 *)&this->outmaxValue;\n      outMax2 = *(undefined4 *)((int)&this->outmaxValue + 4);\n      comparisonResult = __aeabi_dcmpgt(outputSum1,outputSum2,outMax1,outMax2);\n      if (comparisonResult != 0) {\n        *(undefined4 *)&this->outputSum = outMax1;\n        *(undefined4 *)((int)&this->outputSum + 4) = outMax2;\n        return;\n      }\n      outMax1 = *(undefined4 *)&this->outminValue;\n      outMax2 = *(undefined4 *)((int)&this->outminValue + 4);\n      comparisonResult = __aeabi_dcmplt(outputSum1,outputSum2,outMax1,outMax2);\n      if (comparisonResult != 0) {\n        *(undefined4 *)&this->outputSum = outMax1;\n        *(undefined4 *)((int)&this->outputSum + 4) = outMax2;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001960": "set_output_limits_08001960",
                "Min": "minValue",
                "Max": "maxValue",
                "iVar1": "comparisonResult",
                "pdVar2": "outputPtr",
                "uVar3": "outputSum1",
                "uVar4": "outputSum2",
                "uVar5": "outMax1",
                "uVar6": "outMax2"
            },
            "calling": [
                "PID",
                "loop"
            ],
            "called": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080019f6": {
            "entrypoint": "0x080019f6",
            "current_name": "initialize_pid_080019f6",
            "code": "\n/* DWARF original prototype: void  Initialize(PID * pidObject) */\n\nvoid __pidObjectcall PID::initializePID_080019f6(PID *pidObject)\n\n{\n  int comparisonResult;\n  undefined4 inputValue;\n  undefined4 outputValue;\n  undefined4 outputValue2;\n  undefined4 outMaxValue;\n  \n  outputValue = *(undefined4 *)pidObject->myOutput;\n  outputValue2 = *(undefined4 *)((int)pidObject->myOutput + 4);\n  *(undefined4 *)&pidObject->outputSum = outputValue;\n  *(undefined4 *)((int)&pidObject->outputSum + 4) = outputValue2;\n  inputValue = *(undefined4 *)((int)pidObject->myInput + 4);\n  *(undefined4 *)&pidObject->lastInput = *(undefined4 *)pidObject->myInput;\n  *(undefined4 *)((int)&pidObject->lastInput + 4) = inputValue;\n  inputValue = *(undefined4 *)&pidObject->outMax;\n  outMaxValue = *(undefined4 *)((int)&pidObject->outMax + 4);\n  comparisonResult = __aeabi_dcmpgt(outputValue,outputValue2,inputValue,outMaxValue);\n  if (comparisonResult == 0) {\n    inputValue = *(undefined4 *)&pidObject->outMin;\n    outMaxValue = *(undefined4 *)((int)&pidObject->outMin + 4);\n    comparisonResult = __aeabi_dcmplt(outputValue,outputValue2,inputValue,outMaxValue);\n    if (comparisonResult != 0) {\n      *(undefined4 *)&pidObject->outputSum = inputValue;\n      *(undefined4 *)((int)&pidObject->outputSum + 4) = outMaxValue;\n    }\n    return;\n  }\n  *(undefined4 *)&pidObject->outputSum = inputValue;\n  *(undefined4 *)((int)&pidObject->outputSum + 4) = outMaxValue;\n  return;\n}\n\n",
            "renaming": {
                "this": "pidObject",
                "uVar2": "inputValue",
                "iVar1": "comparisonResult",
                "uVar3": "outputValue",
                "uVar4": "outputValue2",
                "uVar5": "outMaxValue",
                "FUN_080019f6": "initialize_pid_080019f6"
            },
            "calling": [
                "SetMode"
            ],
            "called": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a44": {
            "entrypoint": "0x08001a44",
            "current_name": "set_auto_mode_08001a44",
            "code": "\n/* DWARF original prototype: void  Setmode(PID * pid, int mode) */\n\nvoid __pidcall PID::setAutoMode_08001a44(PID *pid,int mode)\n\n{\n  bool isAuto;\n  bool setToAuto;\n  \n  if (mode == 1) {\n    setToAuto = true;\n    if (pid->autoMode == false) {\n      Initialize(pid);\n    }\n  }\n  else {\n    setToAuto = false;\n  }\n  pid->autoMode = setToAuto;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a44": "set_auto_mode_08001a44",
                "this": "pid",
                "Mode": "mode",
                "newAuto": "isAuto",
                "bVar1": "setToAuto",
                "inAuto": "autoMode"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "Initialize"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a66": {
            "entrypoint": "0x08001a66",
            "current_name": "set_controller_direction_08001a66",
            "code": "\n/* DWARF original prototype: void  SetControllernewDirection(PID * pidInstance, int newDirection) */\n\nvoid __pidInstancecall PID::setControllerDirection_08001a66(PID *pidInstance,int newDirection)\n\n{\n  double subtractedValue;\n  \n  if ((pidInstance->inAuto != false) && (pidInstance->controllernewDirection != newDirection)) {\n    subtractedValue = (double)__subdf3(0,0,*(undefined4 *)&pidInstance->kp,*(undefined4 *)((int)&pidInstance->kp + 4));\n    pidInstance->kp = subtractedValue;\n    subtractedValue = (double)__subdf3(0,0,*(undefined4 *)&pidInstance->ki,*(undefined4 *)((int)&pidInstance->ki + 4));\n    pidInstance->ki = subtractedValue;\n    subtractedValue = (double)__subdf3(0,0,*(undefined4 *)&pidInstance->kd,*(undefined4 *)((int)&pidInstance->kd + 4));\n    pidInstance->kd = subtractedValue;\n  }\n  pidInstance->controllernewDirection = newDirection;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a66": "set_controller_direction_08001a66",
                "this": "pidInstance",
                "Direction": "newDirection",
                "dVar1": "subtractedValue"
            },
            "calling": [
                "PID"
            ],
            "called": [
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "initialize_pid_08001ab0",
            "code": "\n/* DWARF original prototype: PID *  PID(PID * pidObject, double * inputArray, double * outputArray, double *\n   setpointArray, double proportionalGain, double integralGain, double derivativeGain, int proportionalOn, int controllerDirection) */\n\nPID * __pidObjectcall\nPID::initializePID_08001ab0(PID *pidObject,double *inputArray,double *outputArray,double *setpointArray,double proportionalGain,double integralGain,\n                 double derivativeGain,int proportionalOn,int controllerDirection)\n\n{\n  uint32_t uVar1;\n  int proportionalOn_00;\n  undefined4 stackValue1;\n  undefined4 stackValue2;\n  undefined4 stackValue3;\n  \n  pidObject->myoutputArray = outputArray;\n  pidObject->myinputArray = inputArray;\n  pidObject->mysetpointArray = setpointArray;\n  pidObject->inAuto = false;\n  SetoutputArrayLimits(pidObject,255.0,(double)CONCAT44(stackValue2,stackValue1));\n  pidObject->SampleTime = 100;\n  SetcontrollerDirection(pidObject,controllerDirection);\n  SetTunings(pidObject,integralGain,derivativeGain,(double)CONCAT44(stackValue3,proportionalOn),proportionalOn_00);\n  uVar1 = millis();\n  pidObject->lastTime = uVar1 - pidObject->SampleTime;\n  return pidObject;\n}\n\n",
            "renaming": {
                "this": "pidObject",
                "Input": "inputArray",
                "Output": "outputArray",
                "Setpoint": "setpointArray",
                "Kp": "proportionalGain",
                "Ki": "integralGain",
                "Kd": "derivativeGain",
                "POn": "proportionalOn",
                "ControllerDirection": "controllerDirection",
                "POn_00": "proportionalOn_00",
                "in_stack_ffffffe8": "stackValue1",
                "in_stack_ffffffec": "stackValue2",
                "in_stack_fffffff4": "stackValue3",
                "FUN_08001ab0": "initialize_pid_08001ab0"
            },
            "calling": [
                "PID"
            ],
            "called": [
                "SetOutputLimits",
                "millis",
                "SetTunings",
                "SetControllerDirection"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b18": {
            "entrypoint": "0x08001b18",
            "current_name": "initialize_pid_controller_08001b18",
            "code": "\n/* DWARF original prototype: PID *  PID(PID * controller, double * input, double * output, double *\n   setpoint, double proportionalGain, double integralGain, double derivativeGain, int controllerDirection) */\n\nPID * __controllercall\nPID::initializePIDController_08001b18(PID *controller,double *input,double *output,double *setpoint,double proportionalGain,double integralGain,\n                 double derivativeGain,int controllerDirection)\n\n{\n  PID(controller,input,output,setpoint,proportionalGain,integralGain,derivativeGain,1,controllerDirection);\n  return controller;\n}\n\n",
            "renaming": {
                "FUN_08001b18": "initialize_pid_controller_08001b18",
                "this": "controller",
                "Input": "input",
                "Output": "output",
                "Setpoint": "setpoint",
                "Kp": "proportionalGain",
                "Ki": "integralGain",
                "Kd": "derivativeGain",
                "ControllerDirection": "controllerDirection"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "PID"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b48": {
            "entrypoint": "0x08001b48",
            "current_name": "initialize_clocks_08001b48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeClocks_08001b48(void)\n\n{\n  HAL_StatusTypeDef_conflict configStatus;\n  uint32_t sysTickSource;\n  RCC_PeriphCLKInitTypeDef peripheralClockInit;\n  RCC_ClkInitTypeDef clockInit;\n  RCC_OscInitTypeDef oscillatorInit;\n  \n  oscillatorInit.type = 2;\n  oscillatorInit.hsiState = 1;\n  oscillatorInit.hsiCalibrationValue = 0x10;\n  oscillatorInit.PLLState = 2;\n  oscillatorInit.PLL.PLLSource = 0;\n  oscillatorInit.PLL.PLLMultiplier = 0x380000;\n  configStatus = HAL_RCC_OscConfig((RCC_OscInitTypeDef_conflict *)&oscillatorInit);\n  if (configStatus != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x88);\n  }\n  clockInit.clockType = 0xf;\n  clockInit.sysClockSource = 2;\n  clockInit.AHBCLKDivider = 0;\n  clockInit.APB1CLKDivider = 0x400;\n  clockInit.APB2CLKDivider = 0;\n  configStatus = HAL_RCC_ClockConfig((RCC_ClkInitTypeDef_conflict *)&clockInit,2);\n  if (configStatus != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x95);\n  }\n  peripheralClockInit.clockSelection = 2;\n  peripheralClockInit.adcClockSelection = 0x8000;\n  configStatus = HAL_RCCEx_PeriphCLKConfig((RCC_PeriphCLKInitTypeDef_conflict *)&peripheralClockInit);\n  if (configStatus != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x9c);\n  }\n  sysTickSource = HAL_RCC_GetHCLKFreq();\n  configureSysTick(sysTickSource / 1000);\n  configureSysTickClockSource(4);\n  setSysTickPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001b48": "initialize_clocks_08001b48",
                "RCC_OscInitStruct": "oscillatorInit",
                "RCC_OscInitStruct.OscillatorType": "oscillatorInit.type",
                "RCC_OscInitStruct.HSIState": "oscillatorInit.hsiState",
                "RCC_OscInitStruct.HSICalibrationValue": "oscillatorInit.hsiCalibrationValue",
                "RCC_OscInitStruct.PLL.PLLState": "oscillatorInit.PLLState",
                "RCC_OscInitStruct.PLL.PLLSource": "oscillatorInit.PLL.PLLSource",
                "RCC_OscInitStruct.PLL.PLLMUL": "oscillatorInit.PLL.PLLMultiplier",
                "HVar1": "configStatus",
                "RCC_ClkInitStruct": "clockInit",
                "RCC_ClkInitStruct.ClockType": "clockInit.clockType",
                "RCC_ClkInitStruct.SYSCLKSource": "clockInit.sysClockSource",
                "RCC_ClkInitStruct.AHBCLKDivider": "clockInit.AHBCLKDivider",
                "RCC_ClkInitStruct.APB1CLKDivider": "clockInit.APB1CLKDivider",
                "RCC_ClkInitStruct.APB2CLKDivider": "clockInit.APB2CLKDivider",
                "PeriphClkInit": "peripheralClockInit",
                "PeriphClkInit.PeriphClockSelection": "peripheralClockInit.clockSelection",
                "PeriphClkInit.AdcClockSelection": "peripheralClockInit.adcClockSelection",
                "uVar2": "sysTickSource",
                "HAL_SYSTICK_Config": "configureSysTick",
                "HAL_SYSTICK_CLKSourceConfig": "configureSysTickClockSource",
                "HAL_NVIC_SetPriority": "setSysTickPriority"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_RCCEx_PeriphCLKConfig",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_ClockConfig",
                "HAL_SYSTICK_Config",
                "_Error_Handler",
                "HAL_RCC_OscConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001be8": {
            "entrypoint": "0x08001be8",
            "current_name": "initialize_system_08001be8",
            "code": "\nvoid initializeSystem_08001be8(void)\n\n{\n  int index;\n  undefined4 *pointer;\n  code *jumptableFunction;\n  \n  for (index = 0; (undefined *)(index + 0x20000000) < &_edata; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&_sidata + index);\n  }\n  for (pointer = &completed_8667; pointer < &_ebss; pointer = pointer + 1) {\n    *pointer = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumptableFunction = (code *)0x8001c1a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08001c1a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumptableFunction)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001be8": "initialize_system_08001be8",
                "iVar1": "index",
                "puVar2": "pointer",
                "UNRECOVERED_JUMPTABLE": "jumptableFunction"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c30": {
            "entrypoint": "0x08001c30",
            "current_name": "infinite_loop_08001c30",
            "code": "\nvoid infiniteLoop_08001c30(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08001c30": "infinite_loop_08001c30"
            },
            "calling": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "called": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c32": {
            "entrypoint": "0x08001c32",
            "current_name": "initialize_context_08001c32",
            "code": "\nint initializeContext_08001c32(EVP_PKEY_CTX *context)\n\n{\n  hw_config_init();\n  return (int)context;\n}\n\n",
            "renaming": {
                "FUN_08001c32": "initialize_context_08001c32",
                "ctx": "context"
            },
            "calling": [
                "premain"
            ],
            "called": [
                "hw_config_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c3a": {
            "entrypoint": "0x08001c3a",
            "current_name": "FUNC_08001c3a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001c3a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001c3a": "FUNC_08001c3a"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001c3c": {
            "entrypoint": "0x08001c3c",
            "current_name": "configure_sys_tick_08001c3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureSysTick_08001c3c(uint32_t priority)\n\n{\n  uint32_t status;\n  \n  status = configureSysTick_08001c3cTimer((uint32_t)((ulonglong)coreClock / (1000 / (ulonglong)tickFrequency))\n                            );\n  if (status != 0) {\n    return HAL_ERROR;\n  }\n  if (0xf < priority) {\n    return HAL_ERROR;\n  }\n  setSysTickPriority(SysTickInterrupt,priority,0);\n  tickPriority = priority;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001c3c": "configure_sys_tick_08001c3c",
                "TickPriority": "priority",
                "uVar1": "status",
                "SystemCoreClock": "coreClock",
                "uwTickFreq": "tickFrequency",
                "HAL_SYSTICK_Config": "configureSysTickTimer",
                "HAL_NVIC_SetPriority": "setSysTickPriority",
                "SysTick_IRQn": "SysTickInterrupt",
                "uwTickPrio": "tickPriority"
            },
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c88": {
            "entrypoint": "0x08001c88",
            "current_name": "initialize_hal_08001c88",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_status initialize_HAL_08001c88(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  set_interrupt_priority_group(3);\n  initialize_tick(0xf);\n  initialize_low_level_system();\n  return HAL_success;\n}\n\n",
            "renaming": {
                "FUN_08001c88": "initialize_hal_08001c88",
                "HAL_StatusTypeDef_conflict": "HAL_status",
                "HAL_NVIC_SetPriorityGrouping": "set_interrupt_priority_group",
                "HAL_InitTick": "initialize_tick",
                "HAL_MspInit": "initialize_low_level_system",
                "HAL_OK": "HAL_success"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cac": {
            "entrypoint": "0x08001cac",
            "current_name": "update_tick_value_08001cac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateTickValue_08001cac(void)\n\n{\n  currentTickValue = tickFrequency + currentTickValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cac": "update_tick_value_08001cac",
                "uwTick": "currentTickValue",
                "uwTickFreq": "tickFrequency"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cc4": {
            "entrypoint": "0x08001cc4",
            "current_name": "get_time_since_last_tick_08001cc4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTimeSinceLastTick_08001cc4(void)\n\n{\n  return lastTick;\n}\n\n",
            "renaming": {
                "FUN_08001cc4": "get_time_since_last_tick_08001cc4",
                "uwTick": "lastTick"
            },
            "calling": [
                "HAL_RCCEx_PeriphCLKConfig",
                "ADC_ConversionStop_Disable",
                "HAL_ADC_PollForConversion",
                "GetCurrentMilli",
                "HAL_RCC_ClockConfig",
                "HAL_ADCEx_Calibration_Start",
                "UART_WaitOnFlagUntilTimeout",
                "HAL_UART_Transmit",
                "ADC_Enable",
                "HAL_RCC_OscConfig",
                "uart_debug_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cd0": {
            "entrypoint": "0x08001cd0",
            "current_name": "perform_adc_conversion_with_timeout_08001cd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict perform_ADC_conversion_with_timeout_08001cd0(ADC_HandleTypeDef *adc_handle,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t start_time;\n  uint32_t periph_clk_freq;\n  int conversion_time;\n  uint32_t current_time;\n  ADC_TypeDef *adc_instance;\n  uint cpu_cycles;\n  uint32_t timeout_cpu_cycles;\n  \n  timeout_cpu_cycles = 0;\n  start_time = HAL_GetTick();\n  current_time = SystemCoreClock;\n  adc_instance = adc_handle->Instance;\n  if ((adc_instance->CR2 & 0x100) == 0) {\n    if (((adc_instance->CR1 & 0x100) == 0) && ((adc_instance->SQR1 & 0xf00000) == 0)) {\n      do {\n        if ((adc_handle->Instance->SR & 2) != 0) goto LAB_08001de2;\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (current_time = HAL_GetTick(), current_time - start_time <= timeout))));\n      adc_handle->State = adc_handle->State | 4;\n      adc_handle->Lock = HAL_UNLOCKED;\n      status = HAL_TIMEOUT;\n    }\n    else {\n      periph_clk_freq = HAL_RCCEx_GetPeriphCLKFreq(2);\n      adc_instance = adc_handle->Instance;\n      if (((adc_instance->SMPR2 & 0x24924924) == 0) && ((adc_instance->SMPR1 & 0x924924) == 0)) {\n        if ((adc_instance->SMPR2 & 0x12492492) == 0) {\n          if ((adc_instance->SMPR1 & 0x492492) == 0) {\n            conversion_time = 0x14;\n          }\n          else {\n            conversion_time = 0x29;\n          }\n        }\n        else {\n          conversion_time = 0x29;\n        }\n      }\n      else if (((adc_instance->SMPR2 & 0x12492492) == 0) && ((adc_instance->SMPR1 & 0x492492) == 0)) {\n        conversion_time = 0x54;\n      }\n      else if ((adc_instance->SMPR2 & 0x249249) == 0) {\n        if ((adc_instance->SMPR1 & 0x249249) == 0) {\n          conversion_time = 0x54;\n        }\n        else {\n          conversion_time = 0xfc;\n        }\n      }\n      else {\n        conversion_time = 0xfc;\n      }\n      cpu_cycles = (current_time / periph_clk_freq) * conversion_time;\n      for (; timeout_cpu_cycles <= cpu_cycles && cpu_cycles - timeout_cpu_cycles != 0;\n          timeout_cpu_cycles = timeout_cpu_cycles + 1) {\n        if ((timeout != 0xffffffff) &&\n           ((timeout == 0 || (current_time = HAL_GetTick(), timeout < current_time - start_time)))) {\n          adc_handle->State = adc_handle->State | 4;\n          adc_handle->Lock = HAL_UNLOCKED;\n          return HAL_TIMEOUT;\n        }\n      }\nLAB_08001de2:\n      adc_handle->Instance->SR = 0xffffffed;\n      adc_handle->State = adc_handle->State | 0x200;\n      if ((adc_handle->Instance->CR2 & 0xe0000) == 0xe0000) {\n        if ((adc_handle->Init).ContinuousConvMode == 0) {\n          adc_handle->State = adc_handle->State & 0xfffffeff;\n          if ((adc_handle->State & 0x1000) == 0) {\n            adc_handle->State = adc_handle->State | 1;\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        status = HAL_OK;\n      }\n    }\n  }\n  else {\n    adc_handle->State = adc_handle->State | 0x20;\n    adc_handle->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001cd0": "perform_adc_conversion_with_timeout_08001cd0",
                "hadc": "adc_handle",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "start_time",
                "uVar3": "periph_clk_freq",
                "iVar4": "conversion_time",
                "uVar5": "current_time",
                "pAVar6": "adc_instance",
                "uVar7": "cpu_cycles",
                "Conversion_Timeout_CPU_cycles": "timeout_cpu_cycles"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e40": {
            "entrypoint": "0x08001e40",
            "current_name": "get_adc_data_08001e40",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_ADC_data_08001e40(ADC_HandleTypeDef *ZUTRNOOOdata_register)\n\n{\n  return ZUTRNOOOdata_register->adc_instance->data_register;\n}\n\n",
            "renaming": {
                "FUN_08001e40": "get_adc_data_08001e40",
                "hadc": "ADC_handle",
                "Instance": "adc_instance",
                "DR": "data_register"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e48": {
            "entrypoint": "0x08001e48",
            "current_name": "configure_adc_channel_08001e48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureADCChannel_08001e48(ADC_HandleTypeDef *adcHandle,ADC_ChannelConfTypeDef *config)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint uVar2;\n  uint32_t wait_loop_index;\n  \n  if (adcHandle->Lock == HAL_LOCKED) {\n    HVar1 = HAL_BUSY;\n  }\n  else {\n    adcHandle->Lock = HAL_LOCKED;\n    uVar2 = config->Rank;\n    if (uVar2 < 7) {\n      uVar2 = uVar2 * 5 - 5;\n      adcHandle->Instance->SQR3 =\n           config->Channel << (uVar2 & 0xff) | adcHandle->Instance->SQR3 & ~(0x1f << (uVar2 & 0xff));\n    }\n    else if (uVar2 < 0xd) {\n      uVar2 = uVar2 * 5 - 0x23;\n      adcHandle->Instance->SQR2 =\n           config->Channel << (uVar2 & 0xff) | adcHandle->Instance->SQR2 & ~(0x1f << (uVar2 & 0xff));\n    }\n    else {\n      uVar2 = uVar2 * 5 - 0x41;\n      adcHandle->Instance->SQR1 =\n           config->Channel << (uVar2 & 0xff) | adcHandle->Instance->SQR1 & ~(0x1f << (uVar2 & 0xff));\n    }\n    uVar2 = config->Channel;\n    if (uVar2 < 10) {\n      adcHandle->Instance->SMPR2 =\n           config->SamplingTime << (uVar2 * 3 & 0xff) |\n           adcHandle->Instance->SMPR2 & ~(7 << (uVar2 * 3 & 0xff));\n    }\n    else {\n      uVar2 = uVar2 * 3 - 0x1e;\n      adcHandle->Instance->SMPR1 =\n           config->SamplingTime << (uVar2 & 0xff) | adcHandle->Instance->SMPR1 & ~(7 << (uVar2 & 0xff));\n    }\n    if (config->Channel - 0x10 < 2) {\n      if (adcHandle->Instance == (ADC_TypeDef *)0x40012400) {\n        if ((uRam40012408 & 0x800000) == 0) {\n          uRam40012408 = uRam40012408 | 0x800000;\n          if (config->Channel == 0x10) {\n            for (wait_loop_index = (SystemCoreClock / 1000000) * 10; wait_loop_index != 0;\n                wait_loop_index = wait_loop_index - 1) {\n            }\n            HVar1 = HAL_OK;\n          }\n          else {\n            HVar1 = HAL_OK;\n          }\n        }\n        else {\n          HVar1 = HAL_OK;\n        }\n      }\n      else {\n        adcHandle->State = adcHandle->State | 0x20;\n        HVar1 = HAL_ERROR;\n      }\n    }\n    else {\n      HVar1 = HAL_OK;\n    }\n    adcHandle->Lock = HAL_UNLOCKED;\n  }\n  return HVar1;\n}\n\n",
            "renaming": {
                "FUN_08001e48": "configure_adc_channel_08001e48",
                "hadc": "adcHandle",
                "sConfig": "config"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f80": {
            "entrypoint": "0x08001f80",
            "current_name": "get_adc_state_08001f80",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_ADC_state_08001f80(ADC_HandleTypeDef *adc_handler)\n\n{\n  return adc_handler->adc_state;\n}\n\n",
            "renaming": {
                "FUN_08001f80": "get_adc_state_08001f80",
                "hadc": "adc_handler",
                "State": "adc_state"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f84": {
            "entrypoint": "0x08001f84",
            "current_name": "initialize_adc_08001f84",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeADC_08001f84(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t startTick;\n  uint32_t currentTick;\n  ADC_TypeDef *adcInstance;\n  uint32_t loopIndex;\n  \n  adcInstance = adcHandle->Instance;\n  if ((adcInstance->CR2 & 1) == 0) {\n    adcInstance->CR2 = adcInstance->CR2 | 1;\n    for (loopIndex = SystemCoreClock / 1000000; loopIndex != 0;\n        loopIndex = loopIndex - 1) {\n    }\n    startTick = HAL_GetTick();\n    do {\n      if ((adcHandle->Instance->CR2 & 1) != 0) {\n        return HAL_OK;\n      }\n      currentTick = HAL_GetTick();\n    } while (currentTick - startTick < 3);\n    adcHandle->State = adcHandle->State | 0x10;\n    adcHandle->ErrorCode = adcHandle->ErrorCode | 1;\n    adcHandle->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  else {\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001f84": "initialize_adc_08001f84",
                "hadc": "adcHandle",
                "HVar1": "status",
                "uVar2": "startTick",
                "uVar3": "currentTick",
                "pAVar4": "adcInstance",
                "wait_loop_index": "loopIndex"
            },
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Start"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002004": {
            "entrypoint": "0x08002004",
            "current_name": "initialize_adc_08002004",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeADC_08002004(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  ADC_TypeDef *adcInstance;\n  \n  if (adcHandle->Lock != HAL_LOCKED) {\n    adcHandle->Lock = HAL_LOCKED;\n    status = ADC_Enable(adcHandle);\n    if (status == HAL_OK) {\n      adcHandle->State = adcHandle->State & 0xfffffcfe | 0x100;\n      adcInstance = adcHandle->Instance;\n      if ((adcInstance == (ADC_TypeDef *)0x40012800) && ((_DAT_40012404 & 0xf0000) != 0)) {\n        adcHandle->State = adcHandle->State | 0x100000;\n        if ((_DAT_40012404 & 0x400) != 0) {\n          adcHandle->State = adcHandle->State & 0xffffcfff | 0x1000;\n        }\n      }\n      else {\n        adcHandle->State = adcHandle->State & 0xffefffff;\n        if ((adcInstance->CR1 & 0x400) != 0) {\n          adcHandle->State = adcHandle->State & 0xffffcfff | 0x1000;\n        }\n      }\n      if ((adcHandle->State & 0x1000) == 0) {\n        adcHandle->ErrorCode = 0;\n      }\n      else {\n        adcHandle->ErrorCode = adcHandle->ErrorCode & 0xfffffff9;\n      }\n      adcHandle->Lock = HAL_UNLOCKED;\n      adcInstance->SR = 0xfffffffd;\n      adcInstance = adcHandle->Instance;\n      if (((adcInstance->CR2 & 0xe0000) == 0xe0000) &&\n         ((adcInstance != (ADC_TypeDef *)0x40012800 || ((_DAT_40012404 & 0xf0000) == 0)))) {\n        adcInstance->CR2 = adcInstance->CR2 | 0x500000;\n      }\n      else {\n        adcInstance->CR2 = adcInstance->CR2 | 0x100000;\n      }\n    }\n    else {\n      adcHandle->Lock = HAL_UNLOCKED;\n    }\n    return status;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_08002004": "initialize_adc_08002004",
                "hadc": "adcHandle",
                "HVar1": "status",
                "pAVar2": "adcInstance"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_Enable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080020f0": {
            "entrypoint": "0x080020f0",
            "current_name": "check_adc_status_080020f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict checkADCStatus_080020f0(ADC_HandleTypeDef *adcHandle)\n\n{\n  uint32_t startTime;\n  uint32_t currentTime;\n  ADC_TypeDef *adcInstance;\n  \n  adcInstance = adcHandle->Instance;\n  if ((adcInstance->CR2 & 1) == 0) {\n    return HAL_OK;\n  }\n  adcInstance->CR2 = adcInstance->CR2 & 0xfffffffe;\n  startTime = HAL_GetTick();\n  do {\n    if ((adcHandle->Instance->CR2 & 1) == 0) {\n      return HAL_OK;\n    }\n    currentTime = HAL_GetTick();\n  } while (currentTime - startTime < 3);\n  adcHandle->State = adcHandle->State | 0x10;\n  adcHandle->ErrorCode = adcHandle->ErrorCode | 1;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_080020f0": "check_adc_status_080020f0",
                "hadc": "adcHandle",
                "uVar1": "startTime",
                "uVar2": "currentTime",
                "pAVar3": "adcInstance"
            },
            "calling": [
                "HAL_ADC_DeInit",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Stop",
                "HAL_ADC_Init"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800213c": {
            "entrypoint": "0x0800213c",
            "current_name": "initialize_adc_0800213c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeADC_0800213c(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t value;\n  uint config;\n  uint mode;\n  uint32_t continuousMode;\n  \n  if (hadc == (ADC_HandleTypeDef *)0x0) {\n    return HAL_ERROR;\n  }\n  if (hadc->State == 0) {\n    hadc->ErrorCode = 0;\n    hadc->Lock = HAL_UNLOCKED;\n    HAL_ADC_MspInit(hadc);\n  }\n  status = ADC_ConversionStop_Disable(hadc);\n  if (((hadc->State & 0x10) == 0) && (status == HAL_OK)) {\n    hadc->State = hadc->State & 0xffffeefd | 2;\n    continuousMode = (hadc->Init).ContinuousConvMode;\n    config = (hadc->Init).DataAlign | (hadc->Init).ExternalTrigConv | continuousMode << 1;\n    value = (hadc->Init).ScanConvMode;\n    if (value == 0x100) {\n      mode = 0x100;\n    }\n    else {\n      mode = 0;\n      if (value == 1) {\n        mode = 0x100;\n      }\n    }\n    if ((hadc->Init).DiscontinuousConvMode == 1) {\n      if (continuousMode == 0) {\n        mode = mode | ((hadc->Init).NbrOfDiscConversion - 1) * 0x2000 | 0x800;\n      }\n      else {\n        hadc->State = hadc->State | 0x20;\n        hadc->ErrorCode = hadc->ErrorCode | 1;\n      }\n    }\n    hadc->Instance->CR1 = mode | hadc->Instance->CR1 & 0xffff16ff;\n    hadc->Instance->CR2 = hadc->Instance->CR2 & 0xffe1f7fd | config;\n    value = (hadc->Init).ScanConvMode;\n    if ((value == 0x100) || (value == 1)) {\n      mode = ((hadc->Init).NbrOfConversion - 1) * 0x100000;\n    }\n    else {\n      mode = 0;\n    }\n    hadc->Instance->SQR1 = mode | hadc->Instance->SQR1 & 0xff0fffff;\n    if (config != (hadc->Instance->CR2 & 0xff1f0efe)) {\n      hadc->State = hadc->State & 0xffffffed | 0x10;\n      hadc->ErrorCode = hadc->ErrorCode | 1;\n      return HAL_ERROR;\n    }\n    hadc->ErrorCode = 0;\n    hadc->State = hadc->State & 0xfffffffc | 1;\n    return HAL_OK;\n  }\n  hadc->State = hadc->State | 0x10;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_0800213c": "initialize_adc_0800213c",
                "HVar1": "status",
                "uVar2": "value",
                "uVar3": "config",
                "uVar4": "mode",
                "uVar5": "continuousMode"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800224c": {
            "entrypoint": "0x0800224c",
            "current_name": "stop_adc_conversion_and_reset_0800224c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict stopADCConversionAndReset_0800224c(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  \n  if (adcHandle == (ADC_HandleTypeDef *)0x0) {\n    status = HAL_ERROR;\n  }\n  else {\n    adcHandle->State = adcHandle->State | 2;\n    status = stopADCConversionDisable(adcHandle);\n    if (status == HAL_OK) {\n      adcHandle->Instance->SR = 0xffffffe0;\n      adcHandle->Instance->CR1 = adcHandle->Instance->CR1 & 0xff3f0000;\n      adcHandle->Instance->CR2 = adcHandle->Instance->CR2 & 0xff0106f0;\n      adcHandle->Instance->SMPR1 = adcHandle->Instance->SMPR1 & 0xff000000;\n      adcHandle->Instance->SMPR2 = adcHandle->Instance->SMPR2 & 0xc0000000;\n      adcHandle->Instance->JOFR1 = adcHandle->Instance->JOFR1 & 0xfffff000;\n      adcHandle->Instance->JOFR2 = adcHandle->Instance->JOFR2 & 0xfffff000;\n      adcHandle->Instance->JOFR3 = adcHandle->Instance->JOFR3 & 0xfffff000;\n      adcHandle->Instance->JOFR4 = adcHandle->Instance->JOFR4 & 0xfffff000;\n      adcHandle->Instance->HTR = adcHandle->Instance->HTR & 0xfffff000;\n      adcHandle->Instance->LTR = adcHandle->Instance->LTR & 0xfffff000;\n      adcHandle->Instance->SQR1 = adcHandle->Instance->SQR1 & 0xff000000;\n      adcHandle->Instance->SQR1 = adcHandle->Instance->SQR1 & 0xff000000;\n      adcHandle->Instance->SQR2 = adcHandle->Instance->SQR2 & 0xc0000000;\n      adcHandle->Instance->SQR3 = adcHandle->Instance->SQR3 & 0xc0000000;\n      adcHandle->Instance->JSQR = adcHandle->Instance->JSQR & 0xffc00000;\n      adcHandle->Instance->JSQR = adcHandle->Instance->JSQR & 0xffc00000;\n      deinitializeADCPeriph(adcHandle);\n      adcHandle->ErrorCode = 0;\n      adcHandle->State = 0;\n    }\n    adcHandle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800224c": "stop_adc_conversion_and_reset_0800224c",
                "hadc": "adcHandle",
                "HVar1": "status",
                "ADC_ConversionStop_Disable": "stopADCConversionDisable",
                "HAL_ADC_MspDeInit": "deinitializeADCPeriph"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002348": {
            "entrypoint": "0x08002348",
            "current_name": "stop_disable_and_set_state_08002348",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict stopDisableAndSetState_08002348(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  \n  if (hadc->Lock == LOCKED) {\n    return BUSY;\n  }\n  hadc->Lock = LOCKED;\n  status = disableADCConversionStop(hadc);\n  if (status == HAL_OK) {\n    hadc->state = hadc->state & 0xffffeefe | 1;\n  }\n  hadc->Lock = UNLOCKED;\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002348": "stop_disable_and_set_state_08002348",
                "HVar1": "status",
                "HAL_LOCKED": "LOCKED",
                "HAL_BUSY": "BUSY",
                "HAL_UNLOCKED": "UNLOCKED",
                "ADC_ConversionStop_Disable": "disableADCConversionStop",
                "State": "state"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002384": {
            "entrypoint": "0x08002384",
            "current_name": "initialize_adc_08002384",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeADC_08002384(ADC_HandleTypeDef *adcHandler)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t peripheralClockFreq;\n  uint32_t sysClockFreq;\n  ADC_TypeDef *adcInstance;\n  uint32_t startTick;\n  uint32_t loopIndex;\n  \n  if (adcHandler->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  adcHandler->Lock = HAL_LOCKED;\n  status = ADC_ConversionStop_Disable(adcHandler);\n  if (status == HAL_OK) {\n    adcHandler->State = adcHandler->State & 0xffffeefd | 2;\n    sysClockFreq = SystemCoreClock;\n    peripheralClockFreq = HAL_RCCEx_GetPeriphCLKFreq(2);\n    for (loopIndex = sysClockFreq / peripheralClockFreq << 1; loopIndex != 0;\n        loopIndex = loopIndex - 1) {\n    }\n    ADC_Enable(adcHandler);\n    adcHandler->Instance->CR2 = adcHandler->Instance->CR2 | 8;\n    sysClockFreq = HAL_GetTick();\n    while (adcInstance = adcHandler->Instance, (adcInstance->CR2 & 8) != 0) {\n      peripheralClockFreq = HAL_GetTick();\n      if (10 < peripheralClockFreq - sysClockFreq) {\n        adcHandler->State = adcHandler->State & 0xffffffed | 0x10;\n        adcHandler->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adcInstance->CR2 = adcInstance->CR2 | 4;\n    sysClockFreq = HAL_GetTick();\n    while ((adcHandler->Instance->CR2 & 4) != 0) {\n      peripheralClockFreq = HAL_GetTick();\n      if (10 < peripheralClockFreq - sysClockFreq) {\n        adcHandler->State = adcHandler->State & 0xffffffed | 0x10;\n        adcHandler->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adcHandler->State = adcHandler->State & 0xfffffffc | 1;\n  }\n  adcHandler->Lock = HAL_UNLOCKED;\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002384": "initialize_adc_08002384",
                "hadc": "adcHandler",
                "HVar1": "status",
                "uVar2": "peripheralClockFreq",
                "uVar3": "sysClockFreq",
                "pAVar4": "adcInstance",
                "tickstart": "startTick",
                "wait_loop_index": "loopIndex"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_GetTick",
                "ADC_ConversionStop_Disable",
                "HAL_RCCEx_GetPeriphCLKFreq",
                "ADC_Enable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002470": {
            "entrypoint": "0x08002470",
            "current_name": "update_priority_group_08002470",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid updatePriorityGroup_08002470(uint32_t newPriorityGroup)\n\n{\n  uint32_t registerValue;\n  \n  _DAT_e000ed0c = (newPriorityGroup & 7) << 8 | _DAT_e000ed0c & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002470": "update_priority_group_08002470",
                "PriorityGroup": "newPriorityGroup",
                "reg_value": "registerValue"
            },
            "calling": [
                "premain",
                "HAL_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002494": {
            "entrypoint": "0x08002494",
            "current_name": "FUNC_08002494",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002494(IRQn_Type_conflict IRQn,uint32_t PreemptPriority,uint32_t SubPriority)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint32_t PriorityGroupTmp;\n  uint32_t SubPriorityBits;\n  uint32_t PreemptPriorityBits;\n  \n  uVar1 = (uint)IRQn;\n  uVar2 = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  PreemptPriorityBits = 7 - uVar2;\n  if (3 < PreemptPriorityBits) {\n    PreemptPriorityBits = 4;\n  }\n  if (uVar2 + 4 < 7) {\n    SubPriorityBits = 0;\n  }\n  else {\n    SubPriorityBits = uVar2 - 3;\n  }\n  uVar2 = (PreemptPriority & (1 << (PreemptPriorityBits & 0xff)) - 1U) << (SubPriorityBits & 0xff) |\n          (1 << (SubPriorityBits & 0xff)) - 1U & SubPriority;\n  if ((int)uVar1 < 0) {\n    *(char *)((uVar1 & 0xf) + 0xe000ed14) = (char)(uVar2 << 4);\n  }\n  else {\n    *(char *)(uVar1 + 0xe000e400) = (char)(uVar2 << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002494": "FUNC_08002494"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback",
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080024f8": {
            "entrypoint": "0x080024f8",
            "current_name": "set_irq_flag_080024f8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setIRQFlag_080024f8(interruptType IRQn)\n\n{\n  uint irqNumber;\n  \n  irqNumber = (uint)IRQn;\n  if (-1 < (int)irqNumber) {\n    *(int *)((irqNumber >> 5) * 4 + -0x1fff1f00) = 1 << (irqNumber & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080024f8": "set_irq_flag_080024f8",
                "IRQn_Type_conflict": "interruptType",
                "uVar1": "irqNumber"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002514": {
            "entrypoint": "0x08002514",
            "current_name": "set_ticks_and_flags_08002514",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t setTicksAndFlags_08002514(uint32_t ticksNumber)\n\n{\n  if (ticksNumber - 1 < 0x1000000) {\n    _DAT_e000e014 = ticksNumber - 1;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002514": "set_ticks_and_flags_08002514",
                "TicksNumb": "ticksNumber"
            },
            "calling": [
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002540": {
            "entrypoint": "0x08002540",
            "current_name": "set_interrupt_flag_08002540",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setInterruptFlag_08002540(interruptNumber_Type_conflict interruptNumber)\n\n{\n  uint irqValue;\n  \n  irqValue = (uint)interruptNumber;\n  if (-1 < (int)irqValue) {\n    *(int *)(((irqValue >> 5) + 0x60) * 4 + -0x1fff1f00) = 1 << (irqValue & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002540": "set_interrupt_flag_08002540",
                "IRQn": "interruptNumber",
                "uVar1": "irqValue"
            },
            "calling": [
                "USART2_IRQHandler",
                "USART3_IRQHandler",
                "USART1_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002560": {
            "entrypoint": "0x08002560",
            "current_name": "set_clock_source_status_08002560",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setClockSourceStatus_08002560(uint32_t source)\n\n{\n  if (source != 4) {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n    return;\n  }\n  _DAT_e000e010 = _DAT_e000e010 | 4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002560": "set_clock_source_status_08002560",
                "CLKSource": "source"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002580": {
            "entrypoint": "0x08002580",
            "current_name": "FUNC_08002580",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002580(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002580": "FUNC_08002580"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002582": {
            "entrypoint": "0x08002582",
            "current_name": "handle_sys_tick_callback_08002582",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickCallback_08002582(void)\n\n{\n  systickCallback();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002582": "handle_sys_tick_callback_08002582",
                "HAL_SYSTICK_Callback": "systickCallback"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800258c": {
            "entrypoint": "0x0800258c",
            "current_name": "initialize_dma_channel_0800258c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeDMAChannel_0800258c(DMA_HandleTypeDef *dmaHandle)\n\n{\n  DMA_Channel_TypeDef *currentChannel;\n  \n  if (dmaHandle->State != DMA_STATE_BUSY) {\n    dmaHandle->ErrorCode = 4;\n    return HAL_ERROR;\n  }\n  dmaHandle->Instance->CCR = dmaHandle->Instance->CCR & 0xfffffff1;\n  dmaHandle->Instance->CCR = dmaHandle->Instance->CCR & 0xfffffffe;\n  currentChannel = dmaHandle->Instance;\n  if (currentChannel == (DMA_Channel_TypeDef *)0x40020008) {\n    _DAT_40020004 = 1;\n  }\n  else if (currentChannel == (DMA_Channel_TypeDef *)0x4002001c) {\n    _DAT_40020004 = 0x10;\n  }\n  else if (currentChannel == (DMA_Channel_TypeDef *)0x40020030) {\n    _DAT_40020004 = 0x100;\n  }\n  else if (currentChannel == (DMA_Channel_TypeDef *)0x40020044) {\n    _DAT_40020004 = 0x1000;\n  }\n  else if (currentChannel == (DMA_Channel_TypeDef *)0x40020058) {\n    _DAT_40020004 = 0x10000;\n  }\n  else if (currentChannel == (DMA_Channel_TypeDef *)0x4002006c) {\n    _DAT_40020004 = 0x100000;\n  }\n  else {\n    _DAT_40020004 = 0x1000000;\n  }\n  dmaHandle->State = DMA_STATE_READY;\n  dmaHandle->Lock = UNLOCKED;\n  if (dmaHandle->XferAbortCallback != (abortCallbackFunction *)0x0) {\n    (*dmaHandle->XferAbortCallback)(dmaHandle);\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800258c": "initialize_dma_channel_0800258c",
                "hdma": "dmaHandle",
                "pDVar1": "currentChannel",
                "HAL_DMA_STATE_BUSY": "DMA_STATE_BUSY",
                "HAL_DMA_STATE_READY": "DMA_STATE_READY",
                "HAL_UNLOCKED": "UNLOCKED",
                "_func_void___DMA_HandleTypeDef_ptr": "abortCallbackFunction"
            },
            "calling": [
                "I2C_ITError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002624": {
            "entrypoint": "0x08002624",
            "current_name": "configure_gpio_08002624",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureGPIO_08002624(GPIO_TypeDef *gpioPort,gpioConfigTypeDef *gpioConfig)\n\n{\n  GPIO_TypeDef *gpioPtr;\n  uint bitMask;\n  uint pinMask;\n  uint bitIndex;\n  uint mode;\n  uint32_t configValue;\n  int shift;\n  uint32_t *configRegPtr;\n  int portIndex;\n  uint32_t tempReg;\n  \n  configValue = 0;\n  bitIndex = 0;\n  do {\n    if (0xf < bitIndex) {\n      return;\n    }\n    bitMask = 1 << (bitIndex & 0xff);\n    pinMask = gpioConfig->Pin & bitMask;\n    if (bitMask == pinMask) {\n      mode = gpioConfig->Mode;\n      if (mode == 0x12) {\n        configValue = gpioConfig->Speed + 0xc;\n      }\n      else if (mode < 0x13) {\n        if (mode == 2) {\n          configValue = gpioConfig->Speed + 8;\n        }\n        else if (mode < 3) {\n          if (mode == 0) goto LAB_08002776;\n          if (mode == 1) {\n            configValue = gpioConfig->Speed;\n          }\n        }\n        else if (mode == 3) {\n          configValue = 0;\n        }\n        else if (mode == 0x11) {\n          configValue = gpioConfig->Speed + 4;\n        }\n      }\n      else if (mode == 0x10210000) {\nLAB_08002776:\n        if (gpioConfig->Pull == 0) {\n          configValue = 4;\n        }\n        else if (gpioConfig->Pull == 1) {\n          gpioPort->BSRR = bitMask;\n          configValue = 8;\n        }\n        else {\n          gpioPort->BRR = bitMask;\n          configValue = 8;\n        }\n      }\n      else if (mode < 0x10210001) {\n        if ((mode == 0x10110000) || (mode == 0x10120000)) goto LAB_08002776;\n      }\n      else if ((mode == 0x10310000) || ((mode == 0x10320000 || (mode == 0x10220000))))\n      goto LAB_08002776;\n      bitMask = bitIndex;\n      gpioPtr = gpioPort;\n      if (0xff < pinMask) {\n        bitMask = bitIndex - 8;\n        gpioPtr = (GPIO_TypeDef *)&gpioPort->CRH;\n      }\n      gpioPtr->CRL = gpioPtr->CRL & ~(0xf << (bitMask << 2 & 0xff)) | configValue << (bitMask << 2 & 0xff);\n      if ((gpioConfig->Mode & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        shift = (bitIndex & 3) << 2;\n        if (gpioPort == (GPIO_TypeDef *)0x40010800) {\n          portIndex = 0;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40010c00) {\n          portIndex = 1;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40011000) {\n          portIndex = 2;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40011400) {\n          portIndex = 3;\n        }\n        else {\n          portIndex = 4;\n        }\n        *(uint *)(((bitIndex >> 2) + 2) * 4 + 0x40010000) =\n             *(uint *)(((bitIndex >> 2) + 2) * 4 + 0x40010000) & ~(0xf << shift) | portIndex << shift;\n        if ((gpioConfig->Mode & 0x10000) == 0) {\n          _DAT_40010400 = _DAT_40010400 & ~pinMask;\n        }\n        else {\n          _DAT_40010400 = _DAT_40010400 | pinMask;\n        }\n        if ((gpioConfig->Mode & 0x20000) == 0) {\n          _DAT_40010404 = _DAT_40010404 & ~pinMask;\n        }\n        else {\n          _DAT_40010404 = _DAT_40010404 | pinMask;\n        }\n        if ((gpioConfig->Mode & 0x100000) == 0) {\n          _DAT_40010408 = _DAT_40010408 & ~pinMask;\n        }\n        else {\n          _DAT_40010408 = _DAT_40010408 | pinMask;\n        }\n        if ((gpioConfig->Mode & 0x200000) == 0) {\n          _DAT_4001040c = _DAT_4001040c & ~pinMask;\n        }\n        else {\n          _DAT_4001040c = pinMask | _DAT_4001040c;\n        }\n      }\n    }\n    bitIndex = bitIndex + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08002624": "configure_gpio_08002624",
                "GPIOx": "gpioPort",
                "GPIO_Init": "gpioConfig",
                "pGVar1": "gpioPtr",
                "uVar2": "bitMask",
                "uVar3": "pinMask",
                "uVar4": "bitIndex",
                "uVar5": "mode",
                "uVar6": "configValue",
                "iVar7": "shift",
                "configregister": "configRegPtr",
                "iVar8": "portIndex",
                "tmpreg": "tempReg"
            },
            "calling": [
                "digital_io_init",
                "uart_init",
                "HAL_ADC_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002810": {
            "entrypoint": "0x08002810",
            "current_name": "check_gpio_pin_08002810",
            "code": "\n/* WARNING: Unknown calling convention */\n\npin_numberState check_gpio_pin_08002810(GPIO_TypeDef *gpio_port,uint16_t pin_number)\n\n{\n  pin_numberState pin_state;\n  \n  if (((uint)pin_number & gpio_port->IDR) == 0) {\n    pin_state = GPIO_PIN_RESET;\n    return pin_state;\n  }\n  return GPIO_PIN_SET;\n}\n\n",
            "renaming": {
                "FUN_08002810": "check_gpio_pin_08002810",
                "GPIOx": "gpio_port",
                "GPIO_Pin": "pin_number",
                "bitstatus": "pin_state"
            },
            "calling": [
                "digital_io_read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800281e": {
            "entrypoint": "0x0800281e",
            "current_name": "set_pin_state_0800281e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinState_0800281e(GPIO_TypeDef *gpio,uint16_t pin,pinState state)\n\n{\n  if (state == GPIO_PIN_RESET) {\n    gpio->BSRR = (uint)pin << 0x10;\n    return;\n  }\n  gpio->BSRR = (uint)pin;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800281e": "set_pin_state_0800281e",
                "GPIOx": "gpio",
                "GPIO_Pin": "pin",
                "PinState": "state"
            },
            "calling": [
                "digital_io_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800282c": {
            "entrypoint": "0x0800282c",
            "current_name": "check_and_update_pin_state_0800282c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid checkAndUpdatePinState_0800282c(uint16_t pin)\n\n{\n  if ((_DAT_40010414 & pin) != 0) {\n    _DAT_40010414 = (uint)pin;\n    handleExternalInterrupt(pin);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800282c": "check_and_update_pin_state_0800282c",
                "GPIO_Pin": "pin",
                "HAL_GPIO_EXTI_Callback": "handleExternalInterrupt"
            },
            "calling": [
                "EXTI4_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI15_10_IRQHandler",
                "EXTI2_IRQHandler",
                "EXTI9_5_IRQHandler",
                "EXTI0_IRQHandler",
                "EXTI1_IRQHandler"
            ],
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002848": {
            "entrypoint": "0x08002848",
            "current_name": "set_i2_c_device_address_08002848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict setI2CDeviceAddress_08002848(I2C_HandleTypeDef *i2cHandle)\n\n{\n  if (i2cHandle->Mode == I2C_MODE_MEMORY) {\n    if (i2cHandle->EventCount == 0) {\n      i2cHandle->Instance->DR = i2cHandle->Devaddress & 0xfe;\n    }\n    else {\n      i2cHandle->Instance->DR = i2cHandle->Devaddress & 0xff | 1;\n    }\n  }\n  else if ((i2cHandle->Init).AddressingMode == 0x4000) {\n    if (i2cHandle->State == I2C_STATE_BUSY_TRANSMIT) {\n      i2cHandle->Instance->DR = i2cHandle->Devaddress & 0xfe;\n    }\n    else {\n      i2cHandle->Instance->DR = i2cHandle->Devaddress & 0xff | 1;\n    }\n  }\n  else if (i2cHandle->EventCount == 0) {\n    i2cHandle->Instance->DR = (i2cHandle->Devaddress << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (i2cHandle->EventCount == 1) {\n    i2cHandle->Instance->DR = (i2cHandle->Devaddress << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return HAL_SUCCESS;\n}\n\n",
            "renaming": {
                "FUN_08002848": "set_i2_c_device_address_08002848",
                "hi2c": "i2cHandle",
                "HAL_I2C_MODE_MEM": "I2C_MODE_MEMORY",
                "HAL_I2C_STATE_BUSY_TX": "I2C_STATE_BUSY_TRANSMIT",
                "HAL_OK": "HAL_SUCCESS"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028d2": {
            "entrypoint": "0x080028d2",
            "current_name": "set_i2_c_device_address_080028d2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict setI2CDeviceAddress_080028d2(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2cHandle->Instance->DR = i2cHandle->Devaddress & 0xff;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080028d2": "set_i2_c_device_address_080028d2",
                "hi2c": "i2cHandle"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028de": {
            "entrypoint": "0x080028de",
            "current_name": "handle_i2_c_transfer_080028de",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CTransfer_080028de(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t currentXferOptions;\n  uint32_t uVar1;\n  I2C_TypeDef *i2cInstance;\n  uint32_t prevState;\n  uint32_t tmpReg;\n  uint32_t tmpReg1;\n  uint32_t tmpReg2;\n  uint32_t tmpReg3;\n  uint32_t tmpReg4;\n  uint32_t tmpReg5;\n  uint32_t tmpReg6;\n  uint32_t tmpReg7;\n  uint32_t tmpReg8;\n  uint32_t tmpReg9;\n  uint32_t tmpReg10;\n  \n  uVar1 = i2cHandle->XferOptions;\n  if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) &&\n     ((i2cHandle->EventCount != 0 || (i2cHandle->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((i2cHandle->EventCount == 0) && ((i2cHandle->Init).AddressingMode == 0xc000)) {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n      i2cHandle->EventCount = i2cHandle->EventCount + 1;\n    }\n    else {\n      if (i2cHandle->XferCount == 0) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      }\n      else if (i2cHandle->XferCount == 1) {\n        if (uVar1 == 0xffff0000) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cInstance = i2cHandle->Instance;\n          if ((i2cInstance->CR2 & 0x800) == 0) {\n            i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n          }\n          else {\n            i2cInstance->CR1 = i2cInstance->CR1 & 0xfffffbff;\n          }\n        }\n        else if (((uVar1 == 4) || (uVar1 == 8)) || (i2cHandle->PreviousState == 0x12)) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        }\n        else if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n      }\n      else if (i2cHandle->XferCount == 2) {\n        if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x800;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      else {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      i2cHandle->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080028de": "handle_i2_c_transfer_080028de",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentXferOptions",
                "pIVar2": "i2cInstance",
                "Prev_State": "prevState",
                "tmpreg": "tmpReg",
                "tmpreg_1": "tmpReg1",
                "tmpreg_2": "tmpReg2",
                "tmpreg_3": "tmpReg3",
                "tmpreg_4": "tmpReg4",
                "tmpreg_5": "tmpReg5",
                "tmpreg_6": "tmpReg6",
                "tmpreg_7": "tmpReg7",
                "tmpreg_8": "tmpReg8",
                "tmpreg_9": "tmpReg9",
                "tmpreg_10": "tmpReg10"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ab8": {
            "entrypoint": "0x08002ab8",
            "current_name": "send_byte_to_i2_c_08002ab8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict sendByteToI2C_08002ab8(I2C_HandleTypeDef *i2cHandle)\n\n{\n  byte *pbVar1;\n  \n  if (i2cHandle->transferCount != 0) {\n    pbVar1 = i2cHandle->bufferPointer;\n    i2cHandle->bufferPointer = pbVar1 + 1;\n    i2cHandle->i2cInstance->dataRegister = (uint)*pbVar1;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002ab8": "send_byte_to_i2_c_08002ab8",
                "hi2c": "i2cHandle",
                "XferCount": "transferCount",
                "pBuffPtr": "bufferPointer",
                "Instance": "i2cInstance",
                "DR": "dataRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad8": {
            "entrypoint": "0x08002ad8",
            "current_name": "read_i2_c_data_08002ad8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict read_I2C_data_08002ad8(I2C_HandleTypeDef *I2C_handle)\n\n{\n  uint8_t *buffer_temp;\n  \n  if (I2C_handle->transfer_count != 0) {\n    buffer_temp = I2C_handle->buffer_ptr;\n    I2C_handle->buffer_ptr = buffer_temp + 1;\n    *buffer_temp = (uint8_t)I2C_handle->I2C_instance->data_register;\n    I2C_handle->transfer_count = I2C_handle->transfer_count - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002ad8": "read_i2_c_data_08002ad8",
                "hi2c": "I2C_handle",
                "XferCount": "transfer_count",
                "pBuffPtr": "buffer_ptr",
                "Instance": "I2C_instance",
                "DR": "data_register",
                "puVar1": "buffer_temp"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002af8": {
            "entrypoint": "0x08002af8",
            "current_name": "configure_i2_c_08002af8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nconfigureI2C_08002af8(I2C_HandleTypeDef *handle,uint8_t *data,uint16_t size,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef *instance;\n  uint32_t tempRegister;\n  \n  if (handle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (handle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      handle->Lock = HAL_LOCKED;\n      instance = handle->Instance;\n      if ((instance->CR1 & 1) == 0) {\n        instance->CR1 = instance->CR1 | 1;\n      }\n      handle->Instance->CR1 = handle->Instance->CR1 & 0xfffff7ff;\n      handle->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      handle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      handle->ErrorCode = 0;\n      handle->pBuffPtr = data;\n      handle->XferCount = size;\n      handle->transferOptions = transferOptions;\n      handle->Xfersize = handle->XferCount;\n      handle->Lock = HAL_UNLOCKED;\n      handle->Instance->CR2 = handle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002af8": "configure_i2_c_08002af8",
                "hi2c": "handle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "instance",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002b84": {
            "entrypoint": "0x08002b84",
            "current_name": "configure_i2_c_slave_mode_08002b84",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nconfigureI2CSlaveMode_08002b84(I2C_HandleTypeDef *i2cHandle,uint8_t *dataBuffer,uint16_t dataSize,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef *i2cInstance;\n  uint32_t temporaryRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (dataBuffer == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (dataSize == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = dataBuffer;\n      i2cHandle->XferCount = dataSize;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->XferdataSize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002b84": "configure_i2_c_slave_mode_08002b84",
                "hi2c": "i2cHandle",
                "pData": "dataBuffer",
                "Size": "dataSize",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c10": {
            "entrypoint": "0x08002c10",
            "current_name": "initialize_i2_c_08002c10",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeI2C_08002c10(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2C_Struct *i2cInstance;\n  \n  if (i2cHandle->currentState != I2C_READY_STATE) {\n    return BUSY_STATE;\n  }\n  i2cHandle->currentState = I2C_LISTEN_STATE;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->controlRegister1 & 1) == 0) {\n    i2cInstance->controlRegister1 = i2cInstance->controlRegister1 | 1;\n  }\n  i2cHandle->Instance->controlRegister1 = i2cHandle->Instance->controlRegister1 | 0x400;\n  i2cHandle->Instance->controlRegister2 = i2cHandle->Instance->controlRegister2 | 0x300;\n  return OK_STATE;\n}\n\n",
            "renaming": {
                "FUN_08002c10": "initialize_i2_c_08002c10",
                "hi2c": "i2cHandle",
                "pIVar1": "i2cInstance",
                "State": "currentState",
                "HAL_I2C_STATE_READY": "I2C_READY_STATE",
                "I2C_TypeDef": "I2C_Struct",
                "CR1": "controlRegister1",
                "CR2": "controlRegister2",
                "HAL_BUSY": "BUSY_STATE",
                "HAL_OK": "OK_STATE",
                "HAL_I2C_STATE_LISTEN": "I2C_LISTEN_STATE"
            },
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c4e": {
            "entrypoint": "0x08002c4e",
            "current_name": "FUNC_08002c4e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002c4e(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c4e": "FUNC_08002c4e"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002c50": {
            "entrypoint": "0x08002c50",
            "current_name": "FUNC_08002c50",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002c50(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c50": "FUNC_08002c50"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002c52": {
            "entrypoint": "0x08002c52",
            "current_name": "FUNC_08002c52",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002c52(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c52": "FUNC_08002c52"
            },
            "calling": [
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_AF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002c54": {
            "entrypoint": "0x08002c54",
            "current_name": "transmit_data_08002c54",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_Status transmitData_08002c54(I2C_HandleTypeDef *i2cHandler)\n\n{\n  HAL_I2C_State i2cState;\n  byte *bufferPtr;\n  \n  i2cState = i2cHandler->State;\n  if (i2cHandler->XferCount != 0) {\n    bufferPtr = i2cHandler->pBuffPtr;\n    i2cHandler->pBuffPtr = bufferPtr + 1;\n    i2cHandler->Instance->DR = (uint)*bufferPtr;\n    i2cHandler->XferCount = i2cHandler->XferCount - 1;\n    if ((i2cHandler->XferCount == 0) && (i2cState == BUSY_TX_LISTEN)) {\n      i2cHandler->Instance->CR2 = i2cHandler->Instance->CR2 & 0xfffffbff;\n      i2cHandler->PreviousState = 0x21;\n      i2cHandler->State = STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(i2cHandler);\n    }\n    return HAL_SUCCESS;\n  }\n  return HAL_SUCCESS;\n}\n\n",
            "renaming": {
                "FUN_08002c54": "transmit_data_08002c54",
                "hi2c": "i2cHandler",
                "HVar1": "i2cState",
                "pbVar2": "bufferPtr",
                "HAL_StatusTypeDef_conflict": "HAL_Status",
                "HAL_I2C_StateTypeDef": "HAL_I2C_State",
                "HAL_I2C_STATE_BUSY_TX_LISTEN": "BUSY_TX_LISTEN",
                "HAL_I2C_STATE_LISTEN": "STATE_LISTEN",
                "HAL_OK": "HAL_SUCCESS"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca4": {
            "entrypoint": "0x08002ca4",
            "current_name": "FUNC_08002ca4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002ca4(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ca4": "FUNC_08002ca4"
            },
            "calling": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca6": {
            "entrypoint": "0x08002ca6",
            "current_name": "receive_data_08002ca6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict receiveData_08002ca6(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef previousState;\n  uint8_t *dataPointer;\n  \n  previousState = i2cHandle->State;\n  if (i2cHandle->XferCount != 0) {\n    dataPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = dataPointer + 1;\n    *dataPointer = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    if ((i2cHandle->XferCount == 0) && (previousState == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      i2cHandle->PreviousState = 0x22;\n      i2cHandle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002ca6": "receive_data_08002ca6",
                "hi2c": "i2cHandle",
                "HVar1": "previousState",
                "puVar2": "dataPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002cf2": {
            "entrypoint": "0x08002cf2",
            "current_name": "handle_addr_match_08002cf2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handle_addr_match_08002cf2(I2C_HandleTypeDef *i2c_handle)\n\n{\n  uint16_t address_match_code;\n  \n  if ((i2c_handle->Instance->SR2 & 0x80) == 0) {\n    address_match_code = *(uint16_t *)&(i2c_handle->Init).OwnAddress1;\n  }\n  else {\n    address_match_code = *(uint16_t *)&(i2c_handle->Init).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(i2c_handle,(i2c_handle->Instance->SR2 & 4) == 0,address_match_code);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002cf2": "handle_addr_match_08002cf2",
                "hi2c": "i2c_handle",
                "AddrMatchCode": "address_match_code"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d1c": {
            "entrypoint": "0x08002d1c",
            "current_name": "handle_i2_c_state_transition_08002d1c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CStateTransition_08002d1c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t currentState;\n  \n  if (((i2cHandle->XferOptions == 4) || (i2cHandle->XferOptions == 8)) &&\n     (i2cHandle->State == HAL_I2C_STATE_LISTEN)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandle);\n  }\n  else if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->PreviousState = 0x21;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback(i2cHandle);\n  }\n  else {\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002d1c": "handle_i2_c_state_transition_08002d1c",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "CurrentState": "currentState"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002db0": {
            "entrypoint": "0x08002db0",
            "current_name": "FUNC_08002db0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002db0(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002db0": "FUNC_08002db0"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002db2": {
            "entrypoint": "0x08002db2",
            "current_name": "handle_i2_c_state_08002db2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nImproved_HAL_StatusTypeDef handleI2CState_08002db2(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef i2cState;\n  uint32_t currentState;\n  byte *dataPtr;\n  uint32_t currentXferOptions;\n  uint32_t xferOptions;\n  \n  i2cState = i2cHandle->State;\n  xferOptions = i2cHandle->XferOptions;\n  if ((i2cHandle->XferSize == 0) && (i2cState == HAL_I2C_STATE_BUSY_TX)) {\n    if ((xferOptions == 4) || ((xferOptions == 8 || (xferOptions == 0xffff0000)))) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n        i2cHandle->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(i2cHandle);\n      }\n      else {\n        i2cHandle->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n      i2cHandle->PreviousState = 0x11;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(i2cHandle);\n    }\n  }\n  else if ((i2cState == HAL_I2C_STATE_BUSY_TX) ||\n          ((i2cHandle->Mode == HAL_I2C_MODE_MEM && (i2cState == HAL_I2C_STATE_BUSY_RX)))) {\n    if (i2cHandle->XferCount == 0) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n    }\n    else if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n      if (i2cHandle->EventCount == 0) {\n        if (i2cHandle->MemaddSize == 1) {\n          i2cHandle->Instance->DR = i2cHandle->Memaddress & 0xff;\n          i2cHandle->EventCount = i2cHandle->EventCount + 2;\n        }\n        else {\n          i2cHandle->Instance->DR = (i2cHandle->Memaddress << 0x10) >> 0x18;\n          i2cHandle->EventCount = i2cHandle->EventCount + 1;\n        }\n      }\n      else if (i2cHandle->EventCount == 1) {\n        i2cHandle->Instance->DR = i2cHandle->Memaddress & 0xff;\n        i2cHandle->EventCount = i2cHandle->EventCount + 1;\n      }\n      else if (i2cHandle->EventCount == 2) {\n        if (i2cHandle->State == HAL_I2C_STATE_BUSY_RX) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n        }\n        else if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n          dataPtr = i2cHandle->pBuffPtr;\n          i2cHandle->pBuffPtr = dataPtr + 1;\n          i2cHandle->Instance->DR = (uint)*dataPtr;\n          i2cHandle->XferCount = i2cHandle->XferCount - 1;\n        }\n      }\n    }\n    else {\n      dataPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPtr + 1;\n      i2cHandle->Instance->DR = (uint)*dataPtr;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002db2": "handle_i2_c_state_08002db2",
                "hi2c": "i2cHandle",
                "HVar1": "i2cState",
                "CurrentState": "currentState",
                "pbVar2": "dataPtr",
                "CurrentXferOptions": "currentXferOptions",
                "uVar3": "xferOptions",
                "HAL_StatusTypeDef_conflict": "Improved_HAL_StatusTypeDef"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002efc": {
            "entrypoint": "0x08002efc",
            "current_name": "handle_i2_c_transfer_08002efc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CTransfer_08002efc(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t transferOptions;\n  uint32_t unusedVariable;\n  byte *bufferPointer;\n  \n  transferOptions = i2cHandle->XferOptions;\n  if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    if (i2cHandle->XferCount == 0) {\n      if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        i2cHandle->PreviousState = 0;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(i2cHandle);\n        }\n        else {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(i2cHandle);\n        }\n      }\n      else {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->PreviousState = 0x11;\n        i2cHandle->Mode = HAL_I2C_MODE_NONE;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      bufferPointer = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPointer + 1;\n      i2cHandle->Instance->DR = (uint)*bufferPointer;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002efc": "handle_i2_c_transfer_08002efc",
                "hi2c": "i2cHandle",
                "uVar1": "transferOptions",
                "CurrentXferOptions": "unusedVariable",
                "pbVar2": "bufferPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f9a": {
            "entrypoint": "0x08002f9a",
            "current_name": "FUNC_08002f9a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002f9a(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f9a": "FUNC_08002f9a"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002f9c": {
            "entrypoint": "0x08002f9c",
            "current_name": "process_i2_c_rx_08002f9c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict processI2CRx_08002f9c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint8_t *dataPtr;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_BUSY_RX) {\n    if (i2cHandle->XferCount < 4) {\n      if (i2cHandle->XferCount - 2 < 2) {\n        if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x800;\n        }\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      }\n      else {\n        if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        dataPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = dataPtr + 1;\n        *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n        i2cHandle->XferCount = i2cHandle->XferCount - 1;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        i2cHandle->PreviousState = 0;\n        if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemRxCpltCallback(i2cHandle);\n        }\n        else {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterRxCpltCallback(i2cHandle);\n        }\n      }\n    }\n    else {\n      dataPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPtr + 1;\n      *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002f9c": "process_i2_c_rx_08002f9c",
                "hi2c": "i2cHandle",
                "puVar1": "dataPtr"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800306c": {
            "entrypoint": "0x0800306c",
            "current_name": "handle_i2_c_data_transfer_0800306c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CDataTransfer_0800306c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t transferOptions;\n  uint32_t currentTransferOptions;\n  uint8_t *bufferPointer;\n  \n  transferOptions = i2cHandle->XferOptions;\n  if (i2cHandle->transferCount == 3) {\n    if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n      i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 & 0xfffffbff;\n    }\n    bufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  else if (i2cHandle->transferCount == 2) {\n    if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n      i2cHandle->i2cInstance->controlRegister2 = i2cHandle->i2cInstance->controlRegister2 & 0xfffffcff;\n      i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 | 0x200;\n    }\n    else {\n      if (transferOptions == 2) {\n        i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 | 0x400;\n      }\n      else {\n        i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 & 0xfffffbff;\n      }\n      i2cHandle->i2cInstance->controlRegister2 = i2cHandle->i2cInstance->controlRegister2 & 0xfffffcff;\n    }\n    bufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    bufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    i2cHandle->i2cState = HAL_I2C_STATE_READY;\n    i2cHandle->previousI2CState = 0;\n    if (i2cHandle->i2cMode == HAL_I2C_MODE_MEM) {\n      i2cHandle->i2cMode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MemRxCpltCallback(i2cHandle);\n    }\n    else {\n      i2cHandle->i2cMode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MasterRxCpltCallback(i2cHandle);\n    }\n  }\n  else {\n    bufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800306c": "handle_i2_c_data_transfer_0800306c",
                "hi2c": "i2cHandle",
                "uVar1": "transferOptions",
                "CurrentXferOptions": "currentTransferOptions",
                "puVar2": "bufferPointer",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "XferCount": "transferCount",
                "Instance": "i2cInstance",
                "CR1": "controlRegister1",
                "CR2": "controlRegister2",
                "DR": "dataRegister",
                "State": "i2cState",
                "PreviousState": "previousI2CState",
                "Mode": "i2cMode"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800316a": {
            "entrypoint": "0x0800316a",
            "current_name": "FUNC_0800316a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800316a(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800316a": "FUNC_0800316a"
            },
            "calling": [
                "I2C_DMAAbort",
                "I2C_ITError"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800316c": {
            "entrypoint": "0x0800316c",
            "current_name": "handle_i2_c_state_0800316c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CState_0800316c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint8_t *dataPtr;\n  I2C_TypeDef *i2cInstance;\n  \n  if (i2cHandle->State - 0x29 < 2) {\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((i2cHandle->State != HAL_I2C_STATE_ABORT) && ((i2cHandle->Instance->CR2 & 0x800) == 0)) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n    }\n    i2cHandle->PreviousState = 0;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  }\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) == 0) {\n    if (i2cHandle->State == HAL_I2C_STATE_ABORT) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->ErrorCode = 0;\n      if ((i2cInstance->SR1 & 0x40) != 0) {\n        dataPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = dataPtr + 1;\n        *dataPtr = (uint8_t)i2cInstance->DR;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(i2cHandle);\n    }\n    else {\n      if ((i2cInstance->SR1 & 0x40) != 0) {\n        dataPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = dataPtr + 1;\n        *dataPtr = (uint8_t)i2cInstance->DR;\n      }\n      HAL_I2C_ErrorCallback(i2cHandle);\n    }\n  }\n  else {\n    i2cInstance->CR2 = i2cInstance->CR2 & 0xfffff7ff;\n    if (i2cHandle->hdmatx->State == HAL_DMA_STATE_READY) {\n      i2cHandle->hdmarx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->hdmarx);\n      if (status != HAL_OK) {\n        if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n          dataPtr = i2cHandle->pBuffPtr;\n          i2cHandle->pBuffPtr = dataPtr + 1;\n          *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n        }\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        (*i2cHandle->hdmarx->XferAbortCallback)(i2cHandle->hdmarx);\n      }\n    }\n    else {\n      i2cHandle->hdmatx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->hdmatx);\n      if (status != HAL_OK) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        (*i2cHandle->hdmatx->XferAbortCallback)(i2cHandle->hdmatx);\n      }\n    }\n  }\n  if ((i2cHandle->State == HAL_I2C_STATE_LISTEN) && ((i2cHandle->ErrorCode & 4) != 0)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800316c": "handle_i2_c_state_0800316c",
                "hi2c": "i2cHandle",
                "HVar1": "status",
                "puVar2": "dataPtr",
                "pIVar3": "i2cInstance"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "HAL_DMA_Abort_IT",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080032b4": {
            "entrypoint": "0x080032b4",
            "current_name": "process_i2_c_data_080032b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict processI2CData_080032b4(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  I2C_TypeDef *i2cInstance;\n  uint8_t *dataPtr;\n  uint32_t currentState;\n  uint32_t tempReg;\n  \n  currentState = i2cHandle->State;\n  i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) != 0) {\n    if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) || (i2cHandle->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmarx->Instance->CNDTR;\n    }\n    else {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmatx->Instance->CNDTR;\n    }\n  }\n  if (i2cHandle->XferCount != 0) {\n    if ((i2cInstance->SR1 & 4) != 0) {\n      dataPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPtr + 1;\n      *dataPtr = (uint8_t)i2cInstance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n      dataPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPtr + 1;\n      *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n  }\n  if (i2cHandle->ErrorCode == 0) {\n    if (((currentState == HAL_I2C_STATE_LISTEN) || (currentState == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (currentState == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2cHandle->XferOptions = 0xffff0000;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(i2cHandle);\n    }\n    else if ((i2cHandle->PreviousState == 0x22) || (currentState == HAL_I2C_STATE_BUSY_RX)) {\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  else {\n    I2C_ITError(i2cHandle);\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080032b4": "process_i2_c_data_080032b4",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "pIVar2": "i2cInstance",
                "puVar3": "dataPtr",
                "CurrentState": "currentState",
                "tmpreg": "tempReg"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback",
                "I2C_ITError",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033b8": {
            "entrypoint": "0x080033b8",
            "current_name": "handle_i2_c_events_080033b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvents_080033b8(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2C_TypeDef *i2cInstance;\n  uint32_t currentMode;\n  uint statusRegister1;\n  uint32_t statusRegister1ITFlags;\n  uint controlRegister2;\n  uint32_t interruptSources;\n  uint statusRegister2;\n  uint32_t sr2itflags;\n  \n  i2cInstance = i2cHandle->Instance;\n  statusRegister2 = i2cInstance->SR2;\n  statusRegister1 = i2cInstance->SR1;\n  controlRegister2 = i2cInstance->CR2;\n  if ((i2cHandle->Mode == HAL_I2C_MODE_MASTER) || (i2cHandle->Mode == HAL_I2C_MODE_MEM)) {\n    if (((statusRegister1 & 0x10001) == 0) || ((controlRegister2 & 0x200) == 0)) {\n      if (((statusRegister1 & 0x10008) == 0) || ((controlRegister2 & 0x200) == 0)) {\n        if (((statusRegister1 & 0x10002) != 0) && ((controlRegister2 & 0x200) != 0)) {\n          I2C_Master_ADDR(i2cHandle);\n        }\n      }\n      else {\n        I2C_Master_ADD10(i2cHandle);\n      }\n    }\n    else {\n      I2C_Master_SB(i2cHandle);\n    }\n    if ((statusRegister2 & 0x100004) == 0) {\n      if ((((statusRegister1 & 0x10040) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_MasterReceive_RXNE(i2cHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(i2cHandle);\n        return;\n      }\n    }\n    else {\n      if ((((statusRegister1 & 0x10080) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_MasterTransmit_TXE(i2cHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(i2cHandle);\n        return;\n      }\n    }\n  }\n  else {\n    if (((statusRegister1 & 0x10002) != 0) && ((controlRegister2 & 0x200) != 0)) {\n      I2C_Slave_ADDR(i2cHandle);\n      return;\n    }\n    if (((statusRegister1 & 0x10010) != 0) && ((controlRegister2 & 0x200) != 0)) {\n      I2C_Slave_STOPF(i2cHandle);\n      return;\n    }\n    if ((statusRegister2 & 0x100004) == 0) {\n      if ((((statusRegister1 & 0x10040) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_SlaveReceive_RXNE(i2cHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(i2cHandle);\n      }\n    }\n    else {\n      if ((((statusRegister1 & 0x10080) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_SlaveTransmit_TXE(i2cHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(i2cHandle);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033b8": "handle_i2_c_events_080033b8",
                "hi2c": "i2cHandle",
                "pIVar1": "i2cInstance",
                "CurrentMode": "currentMode",
                "uVar2": "statusRegister1",
                "sr1itflags": "statusRegister1ITFlags",
                "uVar3": "controlRegister2",
                "itsources": "interruptSources",
                "uVar4": "statusRegister2"
            },
            "calling": [
                "I2C1_EV_IRQHandler",
                "I2C2_EV_IRQHandler"
            ],
            "called": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterReceive_BTF",
                "I2C_Master_ADD10",
                "I2C_Slave_ADDR",
                "I2C_SlaveTransmit_BTF",
                "I2C_MasterReceive_RXNE",
                "I2C_SlaveTransmit_TXE",
                "I2C_Master_SB",
                "I2C_SlaveReceive_BTF",
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF",
                "I2C_Master_ADDR",
                "I2C_MasterTransmit_TXE"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003520": {
            "entrypoint": "0x08003520",
            "current_name": "handle_i2_c_interrupt_08003520",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CInterrupt_08003520(I2C_HandleTypeDef *i2cHandler)\n\n{\n  HAL_I2C_StateTypeDef i2cState;\n  I2C_TypeDef *i2cInstance;\n  uint32_t sr1InterruptFlags;\n  uint sr1Value;\n  uint32_t itsources;\n  uint cr2Value;\n  \n  i2cInstance = i2cHandler->Instance;\n  sr1Value = i2cInstance->SR1;\n  cr2Value = i2cInstance->CR2;\n  if (((sr1Value & 0x10100) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandler->ErrorCode = i2cHandler->ErrorCode | 1;\n    i2cInstance->SR1 = 0xfffffeff;\n    i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 | 0x8000;\n  }\n  if (((sr1Value & 0x10200) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandler->ErrorCode = i2cHandler->ErrorCode | 2;\n    i2cHandler->Instance->SR1 = 0xfffffdff;\n  }\n  if (((sr1Value & 0x10400) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cState = i2cHandler->State;\n    if (((i2cHandler->Mode == HAL_I2C_MODE_SLAVE) && (i2cHandler->XferCount == 0)) &&\n       (((i2cState == HAL_I2C_STATE_BUSY_TX || (i2cState == HAL_I2C_STATE_BUSY_TX_LISTEN)) ||\n        ((i2cState == HAL_I2C_STATE_LISTEN && (i2cHandler->PreviousState == 0x21)))))) {\n      I2C_Slave_AF(i2cHandler);\n    }\n    else {\n      i2cHandler->ErrorCode = i2cHandler->ErrorCode | 4;\n      if (i2cHandler->Mode == HAL_I2C_MODE_MASTER) {\n        i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 | 0x200;\n      }\n      i2cHandler->Instance->SR1 = 0xfffffbff;\n    }\n  }\n  if (((sr1Value & 0x10800) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandler->ErrorCode = i2cHandler->ErrorCode | 8;\n    i2cHandler->Instance->SR1 = 0xfffff7ff;\n  }\n  if (i2cHandler->ErrorCode != 0) {\n    I2C_ITError(i2cHandler);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003520": "handle_i2_c_interrupt_08003520",
                "hi2c": "i2cHandler",
                "HVar1": "i2cState",
                "pIVar2": "i2cInstance",
                "sr1itflags": "sr1InterruptFlags",
                "uVar3": "sr1Value",
                "uVar4": "cr2Value"
            },
            "calling": [
                "I2C1_ER_IRQHandler",
                "I2C2_ER_IRQHandler"
            ],
            "called": [
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fc": {
            "entrypoint": "0x080035fc",
            "current_name": "reset_i2_c_peripheral_080035fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetI2CPeripheral_080035fc(DMA_HandleTypeDef *dmaHandle)\n\n{\n  I2C_HandleTypeDef *i2cHandle;\n  I2C_HandleTypeDef *i2cHandle;\n  \n  i2cHandle = (I2C_HandleTypeDef *)dmaHandle->Parent;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n  i2cHandle->XferCount = 0;\n  i2cHandle->dmaHandletx->XferAbortCallback = (void_func_dmaHandle_ptr *)0x0;\n  i2cHandle->dmaHandlerx->XferAbortCallback = (void_func_dmaHandle_ptr *)0x0;\n  if (i2cHandle->State != I2C_STATE_ABORT) {\n    i2cHandle->State = I2C_STATE_READY;\n    i2cHandle->Mode = I2C_MODE_NONE;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n    handleI2CError(i2cHandle);\n    return;\n  }\n  i2cHandle->State = I2C_STATE_READY;\n  i2cHandle->Mode = I2C_MODE_NONE;\n  i2cHandle->ErrorCode = 0;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n  handleI2CAbortComplete(i2cHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fc": "reset_i2_c_peripheral_080035fc",
                "hdma": "dmaHandle",
                "hi2c_00": "i2cHandle",
                "hi2c": "i2cHandle",
                "_func_void___DMA_HandleTypeDef_ptr": "void_func_dmaHandle_ptr",
                "HAL_I2C_STATE_ABORT": "I2C_STATE_ABORT",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_I2C_MODE_NONE": "I2C_MODE_NONE",
                "HAL_I2C_ErrorCallback": "handleI2CError",
                "HAL_I2C_AbortCpltCallback": "handleI2CAbortComplete"
            },
            "calling": [],
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800365c": {
            "entrypoint": "0x0800365c",
            "current_name": "delay_execution_0800365c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid delayExecution_0800365c(uint32_t delayDuration)\n\n{\n  bool notZeroDelay;\n  uint32_t totalDelay;\n  \n  totalDelay = delayDuration * (SystemCoreClock / 8000);\n  do {\n    notZeroDelay = totalDelay != 0;\n    totalDelay = totalDelay - 1;\n  } while (notZeroDelay);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800365c": "delay_execution_0800365c",
                "mdelay": "delayDuration",
                "Delay": "totalDelay",
                "bVar1": "notZeroDelay"
            },
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003688": {
            "entrypoint": "0x08003688",
            "current_name": "configure_rcc_oscillators_08003688",
            "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureRCCOscillators_08003688(RCC_OscInitTypeDef_conflict *oscillatorConfig)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t currentTick;\n  uint32_t previousTick;\n  bool isSet;\n  uint32_t temporaryRegister;\n  \n  if ((oscillatorConfig->OscillatorType & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) != 0)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (oscillatorConfig->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      previousTick = oscillatorConfig->HSEState;\n      if (previousTick == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (previousTick == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (previousTick == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (oscillatorConfig->HSEState == 0) {\n        previousTick = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          currentTick = HAL_GetTick();\n          if (100 < currentTick - previousTick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        previousTick = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          currentTick = HAL_GetTick();\n          if (100 < currentTick - previousTick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (oscillatorConfig->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      _DAT_40021000 = _DAT_40021000 & 0xffffff07 | oscillatorConfig->HSICalibrationValue << 3;\n    }\n    else if (oscillatorConfig->HSIState == 0) {\n      _DAT_42420000 = 0;\n      previousTick = HAL_GetTick();\n      while ((_DAT_40021000 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - previousTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      previousTick = HAL_GetTick();\n      while ((_DAT_40021000 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - previousTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40021000 = _DAT_40021000 & 0xffffff07 | oscillatorConfig->HSICalibrationValue << 3;\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 8) != 0) {\n    if (oscillatorConfig->LSIState == 0) {\n      _DAT_42420480 = 0;\n      previousTick = HAL_GetTick();\n      while ((_DAT_40021024 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - previousTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      previousTick = HAL_GetTick();\n      while ((_DAT_40021024 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (2 < currentTick - previousTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 4) != 0) {\n    isSet = (_DAT_4002101c & 0x10000000) == 0;\n    if (isSet) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      previousTick = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTick = HAL_GetTick();\n        if (100 < currentTick - previousTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    previousTick = oscillatorConfig->LSEState;\n    if (previousTick == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (previousTick == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (previousTick == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (oscillatorConfig->LSEState == 0) {\n      previousTick = HAL_GetTick();\n      while ((_DAT_40021020 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (5000 < currentTick - previousTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      previousTick = HAL_GetTick();\n      while ((_DAT_40021020 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (5000 < currentTick - previousTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (isSet) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  previousTick = (oscillatorConfig->PLL).PLLState;\n  if (previousTick == 0) {\n    status = HAL_OK;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    status = HAL_ERROR;\n  }\n  else if (previousTick == 2) {\n    _DAT_42420060 = 0;\n    previousTick = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if ((oscillatorConfig->PLL).PLLSource == 0x10000) {\n          _DAT_40021004 = _DAT_40021004 & 0xfffdffff | oscillatorConfig->HSEPredivValue;\n        }\n        _DAT_40021004 =\n             _DAT_40021004 & 0xffc2ffff |\n             (oscillatorConfig->PLL).PLLSource | (oscillatorConfig->PLL).PLLMUL;\n        _DAT_42420060 = 1;\n        previousTick = HAL_GetTick();\n        do {\n          if ((_DAT_40021000 & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          currentTick = HAL_GetTick();\n        } while (currentTick - previousTick < 3);\n        return HAL_TIMEOUT;\n      }\n      currentTick = HAL_GetTick();\n    } while (currentTick - previousTick < 3);\n    status = HAL_TIMEOUT;\n  }\n  else {\n    _DAT_42420060 = 0;\n    previousTick = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      currentTick = HAL_GetTick();\n    } while (currentTick - previousTick < 3);\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003688": "configure_rcc_oscillators_08003688",
                "RCC_OscInitStruct": "oscillatorConfig",
                "HVar1": "status",
                "uVar2": "currentTick",
                "uVar3": "previousTick",
                "bVar4": "isSet",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a68": {
            "entrypoint": "0x08003a68",
            "current_name": "calculate_system_clock_frequency_08003a68",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateSystemClockFrequency_08003a68(void)\n\n{\n  uint32_t systemClockFrequency;\n  uint8_t predivFactorTable [2];\n  uint8_t pllmulFactorTable [16];\n  \n  pllmulFactorTable[12] = '\\x0e';\n  pllmulFactorTable[13] = '\\x0f';\n  pllmulFactorTable[14] = '\\x10';\n  pllmulFactorTable[15] = '\\x10';\n  pllmulFactorTable[8] = '\\n';\n  pllmulFactorTable[9] = '\\v';\n  pllmulFactorTable[10] = '\\f';\n  pllmulFactorTable[11] = '\\r';\n  pllmulFactorTable[4] = '\\x06';\n  pllmulFactorTable[5] = '\\a';\n  pllmulFactorTable[6] = '\\b';\n  pllmulFactorTable[7] = '\\t';\n  pllmulFactorTable[0] = '\\x02';\n  pllmulFactorTable[1] = '\\x03';\n  pllmulFactorTable[2] = '\\x04';\n  pllmulFactorTable[3] = '\\x05';\n  predivFactorTable[0] = '\\x01';\n  predivFactorTable[1] = '\\x02';\n  if ((_DAT_40021004 & 0xc) == 8) {\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      systemClockFrequency = (uint)pllmulFactorTable[(_DAT_40021004 << 10) >> 0x1c] * 4000000;\n    }\n    else {\n      systemClockFrequency = ((uint)pllmulFactorTable[(_DAT_40021004 << 10) >> 0x1c] * 8000000) /\n              (uint)predivFactorTable[-((int)(_DAT_40021004 << 0xe) >> 0x1f)];\n    }\n  }\n  else {\n    systemClockFrequency = 8000000;\n  }\n  return systemClockFrequency;\n}\n\n",
            "renaming": {
                "FUN_08003a68": "calculate_system_clock_frequency_08003a68",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllmulFactorTable",
                "uVar1": "systemClockFrequency"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ad4": {
            "entrypoint": "0x08003ad4",
            "current_name": "configure_clocks_08003ad4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nconfigureClocks_08003ad4(RCC_ClkInitTypeDef_conflict *RCC_ClkInitStruct,uint32_t flashLatency)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  \n  if ((_DAT_40022000 & 7) < flashLatency) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | flashLatency;\n    if (flashLatency != (flashLatency & 7)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((RCC_ClkInitStruct->ClockType & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffff0f | RCC_ClkInitStruct->AHBCLKDivider;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 1) != 0) {\n    uVar3 = RCC_ClkInitStruct->SYSCLKSource;\n    if (uVar3 == 1) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((uVar3 != 2) && ((_DAT_40021000 & 2) == 0)) {\n      return HAL_ERROR;\n    }\n    _DAT_40021004 = uVar3 | _DAT_40021004 & 0xfffffffc;\n    uVar1 = getCurrentTick();\n    if (RCC_ClkInitStruct->SYSCLKSource == 1) {\n      while ((_DAT_40021004 & 0xc) != 4) {\n        uVar2 = getCurrentTick();\n        if (5000 < uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else if (RCC_ClkInitStruct->SYSCLKSource == 2) {\n      while ((_DAT_40021004 & 0xc) != 8) {\n        uVar2 = getCurrentTick();\n        if (5000 < uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      while ((_DAT_40021004 & 0xc) != 0) {\n        uVar2 = getCurrentTick();\n        if (5000 < uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if (flashLatency < (_DAT_40022000 & 7)) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | flashLatency;\n    if (flashLatency != (flashLatency & 7)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((RCC_ClkInitStruct->ClockType & 4) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xfffff8ff | RCC_ClkInitStruct->APB1CLKDivider;\n  }\n  if ((RCC_ClkInitStruct->ClockType & 8) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffc7ff | RCC_ClkInitStruct->APB2CLKDivider << 3;\n  }\n  uVar1 = HAL_RCC_GetSysClockFreq();\n  SystemCoreClockFreq = uVar1 >> \"\"[(_DAT_40021004 << 0x18) >> 0x1c];\n  HAL_InitTick(0xf);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08003ad4": "configure_clocks_08003ad4",
                "FLatency": "flashLatency",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_GetTick()": "getCurrentTick()",
                "SystemCoreClock": "SystemCoreClockFreq"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_RCC_GetSysClockFreq",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c44": {
            "entrypoint": "0x08003c44",
            "current_name": "get_system_core_clock_08003c44",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_08003c44(void)\n\n{\n  return systemCoreClock;\n}\n\n",
            "renaming": {
                "FUN_08003c44": "get_system_core_clock_08003c44",
                "SystemCoreClock": "systemCoreClock"
            },
            "calling": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c50": {
            "entrypoint": "0x08003c50",
            "current_name": "calculate_hclk_divisor_08003c50",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateHCLKDivisor_08003c50(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 = HAL_RCC_GetHCLKFreq();\n  return uVar1 >> \"\"[(uint)(_DAT_40021004 << 0x15) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_08003c50": "calculate_hclk_divisor_08003c50"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c70": {
            "entrypoint": "0x08003c70",
            "current_name": "get_hclk_frequency_08003c70",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_HCLK_frequency_08003c70(void)\n\n{\n  uint32_t frequency;\n  \n  frequency = get_current_HCLK_frequency();\n  return frequency >> \"\"[(uint)(_DAT_40021004 << 0x12) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_08003c70": "get_hclk_frequency_08003c70",
                "uVar1": "frequency",
                "HAL_RCC_GetHCLKFreq": "get_current_HCLK_frequency"
            },
            "calling": [
                "UART_SetConfig",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c90": {
            "entrypoint": "0x08003c90",
            "current_name": "configure_periph_clocks_08003c90",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configurePeriphClocks_08003c90(RCC_PeriphCLKInitTypeDef_conflict *peripheralClockConfig)\n\n{\n  uint tempVar1;\n  uint tempVar2;\n  uint32_t currentTick;\n  uint32_t newTick;\n  bool isBitSet;\n  uint32_t temporaryRegister;\n  \n  if ((peripheralClockConfig->PeriphClockSelection & 1) != 0) {\n    isBitSet = (_DAT_4002101c & 0x10000000) == 0;\n    if (isBitSet) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      currentTick = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        newTick = HAL_GetTick();\n        if (100 < newTick - currentTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (((_DAT_40021020 & 0x300) != 0) &&\n       ((_DAT_40021020 & 0x300) != (peripheralClockConfig->RTCClockSelection & 0x300))) {\n      tempVar2 = _DAT_40021020 & 0xfffffcff;\n      _DAT_42420440 = 0;\n      tempVar1 = _DAT_40021020 & 1;\n      _DAT_40021020 = tempVar2;\n      if (tempVar1 != 0) {\n        currentTick = HAL_GetTick();\n        while ((_DAT_40021020 & 2) == 0) {\n          newTick = HAL_GetTick();\n          if (5000 < newTick - currentTick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    _DAT_40021020 = _DAT_40021020 & 0xfffffcff | peripheralClockConfig->RTCClockSelection;\n    if (isBitSet) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if ((peripheralClockConfig->PeriphClockSelection & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffff3fff | peripheralClockConfig->AdcClockSelection;\n  }\n  if ((peripheralClockConfig->PeriphClockSelection & 0x10) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffbfffff | peripheralClockConfig->UsbClockSelection;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08003c90": "configure_periph_clocks_08003c90",
                "PeriphClkInit": "peripheralClockConfig",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "uVar3": "currentTick",
                "uVar4": "newTick",
                "bVar5": "isBitSet",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003da4": {
            "entrypoint": "0x08003da4",
            "current_name": "calculate_clock_frequency_08003da4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateClockFrequency_08003da4(uint32_t peripheralClock)\n\n{\n  uint32_t frequency;\n  uint factor;\n  uint8_t predivFactorTable [2];\n  uint8_t pllMulFactorTable [16];\n  \n  pllMulFactorTable[12] = '\\x0e';\n  pllMulFactorTable[13] = '\\x0f';\n  pllMulFactorTable[14] = '\\x10';\n  pllMulFactorTable[15] = '\\x10';\n  pllMulFactorTable[8] = '\\n';\n  pllMulFactorTable[9] = '\\v';\n  pllMulFactorTable[10] = '\\f';\n  pllMulFactorTable[11] = '\\r';\n  pllMulFactorTable[4] = '\\x06';\n  pllMulFactorTable[5] = '\\a';\n  pllMulFactorTable[6] = '\\b';\n  pllMulFactorTable[7] = '\\t';\n  pllMulFactorTable[0] = '\\x02';\n  pllMulFactorTable[1] = '\\x03';\n  pllMulFactorTable[2] = '\\x04';\n  pllMulFactorTable[3] = '\\x05';\n  predivFactorTable[0] = '\\x01';\n  predivFactorTable[1] = '\\x02';\n  if (peripheralClock == 2) {\n    frequency = HAL_RCC_GetPCLK2Freq();\n    frequency = frequency / ((((_DAT_40021004 << 0x10) >> 0x1e) + 1) * 2);\n  }\n  else if (peripheralClock == 0x10) {\n    if ((_DAT_40021000 & 0x1000000) == 0) {\n      frequency = 0;\n    }\n    else {\n      if ((_DAT_40021004 & 0x10000) == 0) {\n        factor = 4000000;\n      }\n      else {\n        factor = 8000000 / predivFactorTable[-((int)(_DAT_40021004 << 0xe) >> 0x1f)];\n      }\n      frequency = factor * pllMulFactorTable[(_DAT_40021004 << 10) >> 0x1c];\n      if ((_DAT_40021004 & 0x400000) == 0) {\n        frequency = (frequency * 2) / 3;\n      }\n    }\n  }\n  else if (peripheralClock == 1) {\n    if ((_DAT_40021020 & 0x302) == 0x102) {\n      frequency = 0x8000;\n    }\n    else if (((_DAT_40021020 & 0x300) == 0x200) && ((_DAT_40021024 & 2) != 0)) {\n      frequency = 32000;\n    }\n    else if ((_DAT_40021020 & 0x300) == 0x300) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        frequency = 0;\n      }\n      else {\n        frequency = 0xf424;\n      }\n    }\n    else {\n      frequency = 0;\n    }\n  }\n  else {\n    frequency = 0;\n  }\n  return frequency;\n}\n\n",
            "renaming": {
                "FUN_08003da4": "calculate_clock_frequency_08003da4",
                "PeriphClk": "peripheralClock",
                "uVar1": "frequency",
                "uVar2": "factor",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllMulFactorTable"
            },
            "calling": [
                "HAL_ADC_PollForConversion",
                "HAL_ADCEx_Calibration_Start"
            ],
            "called": [
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ea0": {
            "entrypoint": "0x08003ea0",
            "current_name": "process_rtc_alarm_08003ea0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid process_RTC_Alarm_08003ea0(RTC_HandleTypeDef *rtc_handle)\n\n{\n  if (((rtc_handle->Instance->CRH & 2) != 0) && ((rtc_handle->Instance->CRL & 2) != 0)) {\n    handle_RTC_AlarmAEvent(rtc_handle);\n    rtc_handle->Instance->CRL = 0xfffffffd;\n  }\n  _DAT_40010414 = 0x20000;\n  rtc_handle->State = HAL_RTC_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ea0": "process_rtc_alarm_08003ea0",
                "hrtc": "rtc_handle",
                "HAL_RTC_AlarmAEventCallback": "handle_RTC_AlarmAEvent"
            },
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "called": [
                "HAL_RTC_AlarmAEventCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ed8": {
            "entrypoint": "0x08003ed8",
            "current_name": "reset_timer_08003ed8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict resetTimer_08003ed8(TIM_HandleTypeDef *timer)\n\n{\n  TimerStruct *currentTimer;\n  \n  timer->State = TIM_STATE_BUSY;\n  currentTimer = timer->Instance;\n  if (((currentTimer->CCER & 0x1111) == 0) && ((currentTimer->CCER & 0x444) == 0)) {\n    currentTimer->CR1 = currentTimer->CR1 & 0xfffffffe;\n  }\n  deinitializeTimerPWM(timer);\n  timer->State = TIM_STATE_RESET;\n  timer->Lock = UNLOCKED;\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_08003ed8": "reset_timer_08003ed8",
                "htim": "timer",
                "TIM_TypeDef": "TimerStruct",
                "pTVar1": "currentTimer",
                "HAL_TIM_STATE_BUSY": "TIM_STATE_BUSY",
                "HAL_TIM_STATE_RESET": "TIM_STATE_RESET",
                "HAL_UNLOCKED": "UNLOCKED",
                "HAL_TIM_PWM_MspDeInit": "deinitializeTimerPWM",
                "HAL_OK": "OK"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f12": {
            "entrypoint": "0x08003f12",
            "current_name": "FUNC_08003f12",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003f12(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f12": "FUNC_08003f12"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003f14": {
            "entrypoint": "0x08003f14",
            "current_name": "FUNC_08003f14",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003f14(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f14": "FUNC_08003f14"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003f16": {
            "entrypoint": "0x08003f16",
            "current_name": "FUNC_08003f16",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003f16(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f16": "FUNC_08003f16"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003f18": {
            "entrypoint": "0x08003f18",
            "current_name": "handle_timer_interrupts_08003f18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupts_08003f18(TIM_HandleTypeDef *timerHandle)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 2) != 0) && ((timerInstance->DIER & 2) != 0)) {\n    timerInstance->SR = 0xfffffffd;\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n    if ((timerHandle->Instance->CCMR1 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandle);\n    }\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 4) != 0) && ((timerInstance->DIER & 4) != 0)) {\n    timerInstance->SR = 0xfffffffb;\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n    if ((timerHandle->Instance->CCMR1 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandle);\n    }\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 8) != 0) && ((timerInstance->DIER & 8) != 0)) {\n    timerInstance->SR = 0xfffffff7;\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n    if ((timerHandle->Instance->CCMR2 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandle);\n    }\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 0x10) != 0) && ((timerInstance->DIER & 0x10) != 0)) {\n    timerInstance->SR = 0xffffffef;\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n    if ((timerHandle->Instance->CCMR2 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandle);\n    }\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 1) != 0) && ((timerInstance->DIER & 1) != 0)) {\n    timerInstance->SR = 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(timerHandle);\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 0x80) != 0) && ((timerInstance->DIER & 0x80) != 0)) {\n    timerInstance->SR = 0xffffff7f;\n    HAL_TIMEx_BreakCallback(timerHandle);\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 0x40) != 0) && ((timerInstance->DIER & 0x40) != 0)) {\n    timerInstance->SR = 0xffffffbf;\n    HAL_TIM_TriggerCallback(timerHandle);\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 0x20) != 0) && ((timerInstance->DIER & 0x20) != 0)) {\n    timerInstance->SR = 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(timerHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f18": "handle_timer_interrupts_08003f18",
                "htim": "timerHandle",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "TIM1_UP_IRQHandler",
                "TIM3_IRQHandler",
                "TIM4_IRQHandler",
                "TIM2_IRQHandler"
            ],
            "called": [
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIMEx_BreakCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_PWM_PulseFinishedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004092": {
            "entrypoint": "0x08004092",
            "current_name": "configure_output_channel_08004092",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureOutputChannel_08004092(TIM_TypeDef *timer,uint32_t channelNumber,uint32_t channelState)\n\n{\n  timer->CCER = timer->CCER & ~(1 << (channelNumber & 0xff));\n  timer->CCER = timer->CCER | channelState << (channelNumber & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004092": "configure_output_channel_08004092",
                "TIMx": "timer",
                "Channel": "channelNumber",
                "ChannelState": "channelState"
            },
            "calling": [
                "HAL_TIM_PWM_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040b0": {
            "entrypoint": "0x080040b0",
            "current_name": "reset_timer_channel_080040b0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nTimerStatus resetTimerChannel_080040b0(TIM_HandleTypeDef *timerHandle,uint32_t channelNumber)\n\n{\n  TimerType *timerInstance;\n  \n  configureTimerChannel(timerHandle->timerInstance,channelNumber,0);\n  if (((timerHandle->timerInstance == (TimerType *)0x40012c00) && ((ramData1 & 0x1111) == 0)) &&\n     ((ramData1 & 0x444) == 0)) {\n    ramData4 = ramData4 & 0xffff7fff;\n  }\n  timerInstance = timerHandle->timerInstance;\n  if (((timerInstance->captureCompareEnableRegister & 0x1111) == 0) && ((timerInstance->captureCompareEnableRegister & 0x444) == 0)) {\n    timerInstance->controlRegister1 = timerInstance->controlRegister1 & 0xfffffffe;\n  }\n  timerHandle->timerState = TimerReadyState;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080040b0": "reset_timer_channel_080040b0",
                "htim": "timerHandle",
                "Channel": "channelNumber",
                "pTVar1": "timerInstance",
                "uRam40012c20": "ramData1",
                "uRam40012c44": "ramData4",
                "HAL_StatusTypeDef_conflict": "TimerStatus",
                "TIM_CCxChannelCmd": "configureTimerChannel",
                "TIM_TypeDef": "TimerType",
                "Instance": "timerInstance",
                "CR1": "controlRegister1",
                "CCER": "captureCompareEnableRegister",
                "State": "timerState",
                "HAL_TIM_STATE_READY": "TimerReadyState"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004110": {
            "entrypoint": "0x08004110",
            "current_name": "configure_channel_state_08004110",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureChannelState_08004110(TIM_TypeDef *timer,uint32_t channel,uint32_t newState)\n\n{\n  timer->CCER = timer->CCER & ~(4 << (channel & 0xff));\n  timer->CCER = timer->CCER | newState << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004110": "configure_channel_state_08004110",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelNState": "newState"
            },
            "calling": [
                "HAL_TIMEx_PWMN_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800412c": {
            "entrypoint": "0x0800412c",
            "current_name": "disable_timer_channel_0800412c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef disableTimerChannel_0800412c(TIM_HandleTypeDef *htim,uint32_t channel)\n\n{\n  timerTypeDef *timerInstance;\n  \n  configureTimerChannelCommand(htim->instance,channel,0);\n  timerInstance = htim->instance;\n  if (((timerInstance->captureCompareEnableRegister & 0x1111) == 0) && ((timerInstance->captureCompareEnableRegister & 0x444) == 0)) {\n    timerInstance->breakAndDeadTimeRegister = timerInstance->breakAndDeadTimeRegister & 0xffff7fff;\n  }\n  timerInstance = htim->instance;\n  if (((timerInstance->captureCompareEnableRegister & 0x1111) == 0) && ((timerInstance->captureCompareEnableRegister & 0x444) == 0)) {\n    timerInstance->controlRegister1 = timerInstance->controlRegister1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800412c": "disable_timer_channel_0800412c",
                "Channel": "channel",
                "TIM_TypeDef": "timerTypeDef",
                "pTVar1": "timerInstance",
                "TIM_CCxNChannelCmd": "configureTimerChannelCommand",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "Instance": "instance",
                "CCER": "captureCompareEnableRegister",
                "BDTR": "breakAndDeadTimeRegister",
                "CR1": "controlRegister1"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004178": {
            "entrypoint": "0x08004178",
            "current_name": "FUNC_08004178",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004178(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004178": "FUNC_08004178"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800417a": {
            "entrypoint": "0x0800417a",
            "current_name": "FUNC_0800417a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800417a(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800417a": "FUNC_0800417a"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800417c": {
            "entrypoint": "0x0800417c",
            "current_name": "reset_uart_instance_0800417c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_uart_instance_0800417c(UART_HandleTypeDef *uart_handle)\n\n{\n  uart_handle->uart_instance->control_register_1 = uart_handle->uart_instance->control_register_1 & 0xfffffedf;\n  uart_handle->uart_instance->control_register_3 = uart_handle->uart_instance->control_register_3 & 0xfffffffe;\n  uart_handle->receive_state = HAL_UART_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800417c": "reset_uart_instance_0800417c",
                "huart": "uart_handle",
                "Instance": "uart_instance",
                "CR1": "control_register_1",
                "CR3": "control_register_3",
                "RxState": "receive_state"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004198": {
            "entrypoint": "0x08004198",
            "current_name": "transfer_data_08004198",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef transferData_08004198(UART_HandleTypeDef *uartHandler)\n\n{\n  uint16_t updatedCount;\n  byte *bufferPointer;\n  uint16_t *tmp;\n  \n  if (uartHandler->state != HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  if ((uartHandler->initialization).wordLength == 0x1000) {\n    uartHandler->uartInstance->dataRegister = *(ushort *)uartHandler->txBufferPointer & 0x1ff;\n    if ((uartHandler->initialization).parity == 0) {\n      uartHandler->txBufferPointer = uartHandler->txBufferPointer + 2;\n    }\n    else {\n      uartHandler->txBufferPointer = uartHandler->txBufferPointer + 1;\n    }\n  }\n  else {\n    bufferPointer = uartHandler->txBufferPointer;\n    uartHandler->txBufferPointer = bufferPointer + 1;\n    uartHandler->uartInstance->dataRegister = (uint)*bufferPointer;\n  }\n  updatedCount = uartHandler->MHUdataRegisterUKXNK - 1;\n  uartHandler->MHUdataRegisterUKXNK = updatedCount;\n  if (updatedCount == 0) {\n    uartHandler->uartInstance->controlRegister1 = uartHandler->uartInstance->controlRegister1 & 0xffffff7f;\n    uartHandler->uartInstance->controlRegister1 = uartHandler->uartInstance->controlRegister1 | 0x40;\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004198": "transfer_data_08004198",
                "huart": "uartHandler",
                "gState": "state",
                "Init": "initialization",
                "WordLength": "wordLength",
                "pTxBuffPtr": "txBufferPointer",
                "Parity": "parity",
                "Instance": "uartInstance",
                "DR": "dataRegister",
                "TxXferCount": "transferCount",
                "CR1": "controlRegister1",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "pbVar2": "bufferPointer",
                "uVar1": "updatedCount"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004204": {
            "entrypoint": "0x08004204",
            "current_name": "configure_uart_08004204",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configure_uart_08004204(UART_HandleTypeDef *uart_handle)\n\n{\n  uint32_t pclk_freq;\n  uint32_t pclk_freq;\n  uint32_t pclk_freq;\n  uint32_t pclk_freq;\n  uint32_t pclk_freq;\n  uint32_t baud_rate;\n  uint32_t baud_rate;\n  uint32_t baud_rate;\n  uint32_t baud_rate;\n  USART_TypeDef *uart_instance;\n  \n  uart_handle->Instance->CR2 = uart_handle->Instance->CR2 & 0xffffcfff | (uart_handle->Init).StopBits;\n  uart_handle->Instance->CR1 =\n       (uart_handle->Init).WordLength | (uart_handle->Init).Parity | (uart_handle->Init).Mode |\n       uart_handle->Instance->CR1 & 0xffffe9f3;\n  uart_handle->Instance->CR3 = uart_handle->Instance->CR3 & 0xfffffcff | (uart_handle->Init).HwFlowCtl;\n  uart_instance = uart_handle->Instance;\n  if (uart_instance != (USART_TypeDef *)0x40013800) {\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n    baud_rate = (uart_handle->Init).BaudRate;\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n    uart_instance->BRR = ((uint)((int)((ulonglong)\n                                 (((pclk_freq * 0x19) / (baud_rate << 2) +\n                                  (int)(((ulonglong)(pclk_freq * 0x19) /\n                                        (ulonglong)((uart_handle->Init).BaudRate << 2)) / 100) * -100) *\n                                  0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                   ((((pclk_freq * 0x19) / (baud_rate << 2) +\n                     (int)(((ulonglong)(pclk_freq * 0x19) / (ulonglong)(baud_rate << 2)) / 100) * -100) *\n                     0x10 + 0x32) / 100 & 0xf0) +\n                   (int)(((ulonglong)(pclk_freq * 0x19) / (ulonglong)(baud_rate << 2)) / 100) * 0x10;\n    return;\n  }\n  pclk_freq = HAL_RCC_GetPCLK2Freq();\n  baud_rate = (uart_handle->Init).BaudRate;\n  pclk_freq = HAL_RCC_GetPCLK2Freq();\n  baud_rate = (uart_handle->Init).BaudRate;\n  pclk_freq = HAL_RCC_GetPCLK2Freq();\n  baud_rate = (uart_handle->Init).BaudRate;\n  pclk_freq = HAL_RCC_GetPCLK2Freq();\n  baud_rate = (uart_handle->Init).BaudRate;\n  pclk_freq = HAL_RCC_GetPCLK2Freq();\n  iRam40013808 = ((uint)((int)((ulonglong)\n                               (((pclk_freq * 0x19) / (baud_rate << 2) +\n                                (int)(((ulonglong)(pclk_freq * 0x19) /\n                                      (ulonglong)((uart_handle->Init).BaudRate << 2)) / 100) * -100) *\n                                0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                 ((((pclk_freq * 0x19) / (baud_rate << 2) +\n                   (int)(((ulonglong)(pclk_freq * 0x19) / (ulonglong)(baud_rate << 2)) / 100) * -100) * 0x10\n                  + 0x32) / 100 & 0xf0) +\n                 (int)(((ulonglong)(pclk_freq * 0x19) / (ulonglong)(baud_rate << 2)) / 100) * 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004204": "configure_uart_08004204",
                "huart": "uart_handle",
                "uVar1": "pclk_freq",
                "uVar2": "pclk_freq",
                "uVar3": "pclk_freq",
                "uVar4": "pclk_freq",
                "uVar5": "pclk_freq",
                "uVar6": "baud_rate",
                "uVar7": "baud_rate",
                "uVar8": "baud_rate",
                "uVar9": "baud_rate",
                "pUVar10": "uart_instance"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080043b4": {
            "entrypoint": "0x080043b4",
            "current_name": "check_flag_status_080043b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_desiredStatusTypeDef_conflict\ncheckFlagStatus_080043b4(UART_HandleTypeDef *uartHandle,uint32_t desiredFlag,desiredFlagdesiredStatus desiredStatus,uint32_t startTick,\n            uint32_t timeout)\n\n{\n  uint32_t currentTick;\n  \n  do {\n    if (((desiredFlag & ~uartHandle->Instance->SR) == 0) != (bool)desiredStatus) {\n      return HAL_OK;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - startTick <= timeout))));\n  uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffe5f;\n  uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n  uartHandle->gState = HAL_UART_STATE_READY;\n  uartHandle->RxState = HAL_UART_STATE_READY;\n  uartHandle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_080043b4": "check_flag_status_080043b4",
                "huart": "uartHandle",
                "Flag": "desiredFlag",
                "Status": "desiredStatus",
                "Tickstart": "startTick",
                "Timeout": "timeout",
                "uVar1": "currentTick"
            },
            "calling": [
                "HAL_UART_Transmit"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004418": {
            "entrypoint": "0x08004418",
            "current_name": "FUNC_08004418",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004418(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004418": "FUNC_08004418"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800441a": {
            "entrypoint": "0x0800441a",
            "current_name": "initialize_uart_0800441a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatus initialize_UART_0800441a(UART_HandleTypeDef *uart_handle)\n\n{\n  if (uart_handle != (UART_HandleTypeDef *)0x0) {\n    if (uart_handle->global_State == STATE_RESET) {\n      uart_handle->Lock = UNLOCKED;\n      init_UART_Msp(uart_handle);\n    }\n    uart_handle->global_State = HAL_UART_STATE_BUSY;\n    uart_handle->instance->control_register_1 = uart_handle->instance->control_register_1 & 0xffffdfff;\n    set_UART_Config(uart_handle);\n    uart_handle->instance->control_register_2 = uart_handle->instance->control_register_2 & 0xffffb7ff;\n    uart_handle->instance->control_register_3 = uart_handle->instance->control_register_3 & 0xffffffd5;\n    uart_handle->instance->control_register_1 = uart_handle->instance->control_register_1 | 0x2000;\n    uart_handle->error_Code = 0;\n    uart_handle->global_State = HAL_UART_STATE_READY;\n    uart_handle->receive_State = HAL_UART_STATE_READY;\n    return OK;\n  }\n  return ERROR;\n}\n\n",
            "renaming": {
                "FUN_0800441a": "initialize_uart_0800441a",
                "huart": "uart_handle",
                "HAL_StatusTypeDef_conflict": "Status",
                "HAL_UART_STATE_RESET": "STATE_RESET",
                "HAL_UNLOCKED": "UNLOCKED",
                "HAL_UART_MspInit": "init_UART_Msp",
                "UART_SetConfig": "set_UART_Config",
                "HAL_OK": "OK",
                "HAL_ERROR": "ERROR",
                "gState": "global_State",
                "Instance": "instance",
                "CR1": "control_register_1",
                "CR2": "control_register_2",
                "CR3": "control_register_3",
                "ErrorCode": "error_Code",
                "RxState": "receive_State"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004478": {
            "entrypoint": "0x08004478",
            "current_name": "transmit_data_08004478",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\ntransmitData_08004478(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t size,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t tickStart;\n  uint16_t *temp;\n  \n  if (uartHandle->gState == HAL_UART_STATE_READY) {\n    if (data == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (uartHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      uartHandle->Lock = HAL_LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n      tickStart = HAL_GetTick();\n      uartHandle->TxXfersize = size;\n      uartHandle->TxXferCount = size;\n      while (uartHandle->TxXferCount != 0) {\n        uartHandle->TxXferCount = uartHandle->TxXferCount - 1;\n        if ((uartHandle->Init).WordLength == 0x1000) {\n          status = UART_WaitOnFlagUntiltimeout(uartHandle,0x80,RESET,tickStart,timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = *(ushort *)data & 0x1ff;\n          if ((uartHandle->Init).Parity == 0) {\n            data = (uint8_t *)((int)data + 2);\n          }\n          else {\n            data = (uint8_t *)((int)data + 1);\n          }\n        }\n        else {\n          status = UART_WaitOnFlagUntiltimeout(uartHandle,0x80,RESET,tickStart,timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = (uint)*data;\n          data = (uint8_t *)((int)data + 1);\n        }\n      }\n      status = UART_WaitOnFlagUntiltimeout(uartHandle,0x40,RESET,tickStart,timeout);\n      if (status == HAL_OK) {\n        uartHandle->gState = HAL_UART_STATE_READY;\n        uartHandle->Lock = HAL_UNLOCKED;\n        status = HAL_OK;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08004478": "transmit_data_08004478",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "tickStart",
                "tmp": "temp"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800455a": {
            "entrypoint": "0x0800455a",
            "current_name": "initialize_uart_transmission_0800455a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeUartTransmission_0800455a(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t size)\n\n{\n  if (uartHandle->gState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (data == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (size == 0) {\n    return HAL_ERROR;\n  }\n  if (uartHandle->Lock != HAL_LOCKED) {\n    uartHandle->pTxBuffPtr = data;\n    uartHandle->TxXfersize = size;\n    uartHandle->TxXferCount = size;\n    uartHandle->ErrorCode = 0;\n    uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n    uartHandle->Lock = HAL_UNLOCKED;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x80;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_0800455a": "initialize_uart_transmission_0800455a",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "size"
            },
            "calling": [
                "uart_attach_tx_callback",
                "HAL_UART_TxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045a2": {
            "entrypoint": "0x080045a2",
            "current_name": "initialize_uart_receive_080045a2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeUartReceive_080045a2(UART_HandleTypeDef *uartHandle,uint8_t *receiveBuffer,uint16_t bufferSize)\n\n{\n  if (uartHandle->RxState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (receiveBuffer == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (bufferSize == 0) {\n    return HAL_ERROR;\n  }\n  if (uartHandle->Lock != HAL_LOCKED) {\n    uartHandle->pRxBuffPtr = receiveBuffer;\n    uartHandle->RxXferbufferSize = bufferSize;\n    uartHandle->RxXferCount = bufferSize;\n    uartHandle->ErrorCode = 0;\n    uartHandle->RxState = HAL_UART_STATE_BUSY_RX;\n    uartHandle->Lock = HAL_UNLOCKED;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x100;\n    uartHandle->Instance->CR3 = uartHandle->Instance->CR3 | 1;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x20;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_080045a2": "initialize_uart_receive_080045a2",
                "huart": "uartHandle",
                "pData": "receiveBuffer",
                "Size": "bufferSize"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045fe": {
            "entrypoint": "0x080045fe",
            "current_name": "disable_tx_interrupt_080045fe",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict disableTXInterrupt_080045fe(UART_HandleTypeDef *UART_Handle)\n\n{\n  UART_Handle->UART_Instance->ControlRegister1 = UART_Handle->UART_Instance->ControlRegister1 & 0xffffffbf;\n  UART_Handle->UART_State = HAL_UART_STATE_READY;\n  transmissionCompleteCallback(UART_Handle);\n  return HAL_Success;\n}\n\n",
            "renaming": {
                "FUN_080045fe": "disable_tx_interrupt_080045fe",
                "huart": "UART_Handle",
                "Instance": "UART_Instance",
                "CR1": "ControlRegister1",
                "gState": "UART_State",
                "HAL_UART_TxCpltCallback": "transmissionCompleteCallback",
                "HAL_OK": "HAL_Success"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004618": {
            "entrypoint": "0x08004618",
            "current_name": "process_received_data_08004618",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict processReceivedData_08004618(UART_HandleTypeDef *uart)\n\n{\n  uint16_t *dataPtr;\n  byte *bytePtr;\n  uint16_t count;\n  uint8_t *bytePtr2;\n  \n  if (uart->RxState != HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  if ((uart->Init).WordLength == 0x1000) {\n    if ((uart->Init).Parity == 0) {\n      *(ushort *)uart->pRxBuffPtr = (ushort)((uart->Instance->DR << 0x17) >> 0x17);\n      uart->pRxBuffPtr = uart->pRxBuffPtr + 2;\n    }\n    else {\n      *(ushort *)uart->pRxBuffPtr = (ushort)uart->Instance->DR & 0xff;\n      uart->pRxBuffPtr = uart->pRxBuffPtr + 1;\n    }\n  }\n  else if ((uart->Init).Parity == 0) {\n    bytePtr2 = uart->pRxBuffPtr;\n    uart->pRxBuffPtr = bytePtr2 + 1;\n    *bytePtr2 = (uint8_t)uart->Instance->DR;\n  }\n  else {\n    bytePtr = uart->pRxBuffPtr;\n    uart->pRxBuffPtr = bytePtr + 1;\n    *bytePtr = (byte)uart->Instance->DR & 0x7f;\n  }\n  count = uart->RxXferCount - 1;\n  uart->RxXferCount = count;\n  if (count != 0) {\n    return HAL_OK;\n  }\n  uart->Instance->CR1 = uart->Instance->CR1 & 0xffffffdf;\n  uart->Instance->CR1 = uart->Instance->CR1 & 0xfffffeff;\n  uart->Instance->CR3 = uart->Instance->CR3 & 0xfffffffe;\n  uart->RxState = HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(uart);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08004618": "process_received_data_08004618",
                "huart": "uart",
                "tmp": "dataPtr",
                "pbVar1": "bytePtr",
                "uVar2": "count",
                "puVar3": "bytePtr2"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046b8": {
            "entrypoint": "0x080046b8",
            "current_name": "process_uart_interrupts_080046b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid process_UART_interrupts_080046b8(UART_HandleTypeDef *uart_handle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint cr1_register_value;\n  uint32_t cr1_interrupt_flags;\n  USART_TypeDef *uart_instance;\n  uint32_t cr3_interrupt_flags;\n  uint cr3_register_value;\n  uint sr_register_value;\n  uint32_t interrupt_flags;\n  \n  uart_instance = uart_handle->Instance;\n  sr_register_value = uart_instance->SR;\n  cr1_register_value = uart_instance->CR1;\n  if ((((sr_register_value & 0xf) == 0) && ((sr_register_value & 0x20) != 0)) && ((cr1_register_value & 0x20) != 0)) {\n    UART_Receive_IT(uart_handle);\n    return;\n  }\n  if (((sr_register_value & 0xf) == 0) || ((cr3_register_value = uart_instance->CR3 & 1, cr3_register_value == 0 && ((cr1_register_value & 0x120) == 0)))) {\n    if (((sr_register_value & 0x80) != 0) && ((cr1_register_value & 0x80) != 0)) {\n      UART_Transmit_IT(uart_handle);\n      return;\n    }\n    if (((sr_register_value & 0x40) != 0) && ((cr1_register_value & 0x40) != 0)) {\n      UART_EndTransmit_IT(uart_handle);\n    }\n  }\n  else {\n    if (((sr_register_value & 1) != 0) && ((cr1_register_value & 0x100) != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 1;\n    }\n    if (((sr_register_value & 4) != 0) && (cr3_register_value != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 2;\n    }\n    if (((sr_register_value & 2) != 0) && (cr3_register_value != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 4;\n    }\n    if (((sr_register_value & 8) != 0) && (cr3_register_value != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 8;\n    }\n    if (uart_handle->ErrorCode != 0) {\n      if (((sr_register_value & 0x20) != 0) && ((cr1_register_value & 0x20) != 0)) {\n        UART_Receive_IT(uart_handle);\n      }\n      if (((uart_handle->ErrorCode & 8) == 0) && ((uart_handle->Instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(uart_handle);\n        uart_handle->ErrorCode = 0;\n        return;\n      }\n      UART_EndRxTransfer(uart_handle);\n      uart_instance = uart_handle->Instance;\n      if ((uart_instance->CR3 & 0x40) == 0) {\n        HAL_UART_ErrorCallback(uart_handle);\n        return;\n      }\n      uart_instance->CR3 = uart_instance->CR3 & 0xffffffbf;\n      if (uart_handle->hdmarx == (DMA_HandleTypeDef *)0x0) {\n        HAL_UART_ErrorCallback(uart_handle);\n        return;\n      }\n      uart_handle->hdmarx->XferAbortCallback = UART_DMAAbortOnError + 1;\n      status = HAL_DMA_Abort_IT(uart_handle->hdmarx);\n      if (status != HAL_OK) {\n        (*uart_handle->hdmarx->XferAbortCallback)(uart_handle->hdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046b8": "process_uart_interrupts_080046b8",
                "huart": "uart_handle",
                "HVar1": "status",
                "uVar2": "cr1_register_value",
                "uVar4": "cr3_register_value",
                "uVar5": "sr_register_value",
                "pUVar3": "uart_instance",
                "cr1its": "cr1_interrupt_flags",
                "cr3its": "cr3_interrupt_flags",
                "isrflags": "interrupt_flags"
            },
            "calling": [
                "USART2_IRQHandler",
                "USART3_IRQHandler",
                "USART1_IRQHandler"
            ],
            "called": [
                "HAL_DMA_Abort_IT",
                "HAL_UART_ErrorCallback",
                "UART_EndRxTransfer",
                "UART_EndTransmit_IT",
                "UART_Transmit_IT",
                "UART_Receive_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047d8": {
            "entrypoint": "0x080047d8",
            "current_name": "clear_uart_errors_080047d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearUartErrors_080047d8(DMA_HandleTypeDef *dmaHandle)\n\n{\n  UART_HandleTypeDef *uartHandle;\n  UART_HandleTypeDef *uart;\n  \n  uartHandle = (UART_HandleTypeDef *)dmaHandle->Parent;\n  uartHandle->receiveTransferCount = 0;\n  uartHandle->transmitTransferCount = 0;\n  handleUartError(uartHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047d8": "clear_uart_errors_080047d8",
                "hdma": "dmaHandle",
                "huart_00": "uartHandle",
                "huart": "uart",
                "RxXferCount": "receiveTransferCount",
                "TxXferCount": "transmitTransferCount",
                "HAL_UART_ErrorCallback": "handleUartError"
            },
            "calling": [],
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047e8": {
            "entrypoint": "0x080047e8",
            "current_name": "get_uart_state_080047e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_UART_StateTypeDef get_uart_state_080047e8(UART_HandleTypeDef *uart_handle)\n\n{\n  return uart_handle->receive_state | uart_handle->general_state;\n}\n\n",
            "renaming": {
                "FUN_080047e8": "get_uart_state_080047e8",
                "huart": "uart_handle",
                "RxState": "receive_state",
                "gState": "general_state"
            },
            "calling": [
                "serial_tx_active",
                "serial_rx_active"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047f4": {
            "entrypoint": "0x080047f4",
            "current_name": "check_pin_state_080047f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool checkPinState_080047f4(PinName_conflict pin,uint32_t *pinMap)\n\n{\n  uint32_t pinIndex;\n  \n  pinIndex = pinMap[(uint)((int)pin << 0x18) >> 0x1c];\n  return (_Bool)((byte)(pinIndex >> ((int)pin & 0xfU)) & 1);\n}\n\n",
            "renaming": {
                "FUN_080047f4": "check_pin_state_080047f4",
                "map": "pinMap",
                "index": "pinIndex"
            },
            "calling": [
                "digitalWrite",
                "digitalRead",
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800480a": {
            "entrypoint": "0x0800480a",
            "current_name": "update_pin_map_0800480a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updatePinMap_0800480a(PinName_conflict pinName,uint32_t *pinMap)\n\n{\n  uint shiftedIndex;\n  uint32_t originalIndex;\n  \n  shiftedIndex = (uint)((int)pinName << 0x18) >> 0x1c;\n  pinMap[shiftedIndex] = pinMap[shiftedIndex] | 1 << ((int)pinName & 0xfU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800480a": "update_pin_map_0800480a",
                "pin": "pinName",
                "map": "pinMap",
                "uVar1": "shiftedIndex",
                "index": "originalIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004828": {
            "entrypoint": "0x08004828",
            "current_name": "clear_pin_bit_08004828",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearPinBit_08004828(PinName_conflict pinNumber,uint32_t *pinMap)\n\n{\n  uint shiftedIndex;\n  uint32_t uVarIndex;\n  \n  shiftedIndex = (uint)((int)pinNumber << 0x18) >> 0x1c;\n  pinMap[shiftedIndex] = pinMap[shiftedIndex] & ~(1 << ((int)pinNumber & 0xfU));\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004828": "clear_pin_bit_08004828",
                "pin": "pinNumber",
                "uVar1": "shiftedIndex",
                "map": "pinMap",
                "index": "uVarIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004848": {
            "entrypoint": "0x08004848",
            "current_name": "get_gpio_type_def_08004848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nGPIO_structure * get_GPIO_TypeDef_08004848(uint32_t port_index)\n\n{\n  switch(port_index) {\n  case 0:\n    return (GPIO_structure *)0x40010800;\n  case 1:\n    return (GPIO_structure *)0x40010c00;\n  case 2:\n    return (GPIO_structure *)0x40011000;\n  case 3:\n    return (GPIO_structure *)0x40011400;\n  case 4:\n    return (GPIO_structure *)0x40011800;\n  default:\n    return (GPIO_structure *)0x0;\n  }\n}\n\n",
            "renaming": {
                "FUN_08004848": "get_gpio_type_def_08004848",
                "port_idx": "port_index",
                "GPIO_TypeDef": "GPIO_structure"
            },
            "calling": [
                "digitalWrite",
                "digitalRead"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004884": {
            "entrypoint": "0x08004884",
            "current_name": "set_gpio_port_08004884",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * set_gpio_port_08004884(uint32_t port_index)\n\n{\n  GPIO_TypeDef *gpio_port;\n  uint32_t temporary_register;\n  uint32_t temporary_register_1;\n  uint32_t temporary_register_2;\n  uint32_t temporary_register_3;\n  uint32_t temporary_register_4;\n  \n  switch(port_index) {\n  case 0:\n    _DAT_40021018 = _DAT_40021018 | 4;\n    gpio_port = (GPIO_TypeDef *)0x40010800;\n    break;\n  case 1:\n    _DAT_40021018 = _DAT_40021018 | 8;\n    gpio_port = (GPIO_TypeDef *)0x40010c00;\n    break;\n  case 2:\n    _DAT_40021018 = _DAT_40021018 | 0x10;\n    gpio_port = (GPIO_TypeDef *)0x40011000;\n    break;\n  case 3:\n    _DAT_40021018 = _DAT_40021018 | 0x20;\n    gpio_port = (GPIO_TypeDef *)0x40011400;\n    break;\n  case 4:\n    _DAT_40021018 = _DAT_40021018 | 0x40;\n    gpio_port = (GPIO_TypeDef *)0x40011800;\n    break;\n  default:\n    gpio_port = (GPIO_TypeDef *)0x0;\n  }\n  return gpio_port;\n}\n\n",
            "renaming": {
                "FUN_08004884": "set_gpio_port_08004884",
                "port_idx": "port_index",
                "pGVar1": "gpio_port",
                "tmpreg": "temporary_register",
                "tmpreg_1": "temporary_register_1",
                "tmpreg_2": "temporary_register_2",
                "tmpreg_3": "temporary_register_3",
                "tmpreg_4": "temporary_register_4"
            },
            "calling": [
                "digital_io_init",
                "uart_init",
                "HAL_ADC_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800492c": {
            "entrypoint": "0x0800492c",
            "current_name": "get_pin_function_0800492c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getPinFunction_0800492c(pin pin)\n\n{\n  uint32_t returnValue;\n  uint32_t shiftedValue;\n  \n  returnValue = pinmap_shiftedValue(pin,(PinMap_conflict *)&PinMap_ADC);\n  shiftedValue = returnValue << 0xc;\n  shiftedValue = shiftedValue >> 0x1b;\n  if (0x10 < shiftedValue - 1) {\n    shiftedValue = 0;\n  }\n  return shiftedValue;\n}\n\n",
            "renaming": {
                "FUN_0800492c": "get_pin_function_0800492c",
                "PinName_conflict": "pin",
                "uVar1": "returnValue",
                "function": "shiftedValue"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004948": {
            "entrypoint": "0x08004948",
            "current_name": "determine_pin_function_08004948",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t determinePinFunction_08004948(PinName_conflict pin)\n\n{\n  uint32_t functionCode;\n  uint32_t shiftedCode;\n  \n  functionCode = pinmap_shiftedCode(pin,(PinMap_conflict *)&pinMapPWM);\n  shiftedCode = functionCode << 0xc;\n  shiftedCode = shiftedCode >> 0x1b;\n  if (shiftedCode == 3) {\n    return 8;\n  }\n  if (shiftedCode != 4) {\n    if (shiftedCode != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
            "renaming": {
                "FUN_08004948": "determine_pin_function_08004948",
                "uVar1": "functionCode",
                "PinMap_PWM": "pinMapPWM",
                "function": "shiftedCode"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004974": {
            "entrypoint": "0x08004974",
            "current_name": "initialize_adc_08004974",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeADC_08004974(ADC_HandleTypeDef *adcHandle)\n\n{\n  GPIO_TypeDef *gpioPort;\n  GPIO_TypeDef *gpioPort;\n  uint32_t tempRegister;\n  uint32_t tempRegister1;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  if (adcHandle->Instance == (ADC_TypeDef *)0x40012400) {\n    _DAT_40021018 = _DAT_40021018 | 0x200;\n  }\n  else if (adcHandle->Instance == (ADC_TypeDef *)0x40012800) {\n    _DAT_40021018 = _DAT_40021018 | 0x400;\n  }\n  gpioPort = set_GPIO_Port_Clock((uint)((int)g_current_pin << 0x18) >> 0x1c);\n  gpioInitStruct.Pin = 1 << (g_current_pin & 0xfU) & 0xffff;\n  gpioInitStruct.Mode = 3;\n  gpioInitStruct.Pull = 0;\n  HAL_GPIO_Init(gpioPort,&gpioInitStruct);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004974": "initialize_adc_08004974",
                "hadc": "adcHandle",
                "GPIOx": "gpioPort",
                "port": "gpioPort",
                "tmpreg": "tempRegister",
                "tmpreg_1": "tempRegister1",
                "GPIO_InitStruct": "gpioInitStruct"
            },
            "calling": [
                "HAL_ADC_Init"
            ],
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049f0": {
            "entrypoint": "0x080049f0",
            "current_name": "configure_adc_080049f0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureADC_080049f0(ADC_HandleTypeDef *adcHandle)\n\n{\n  if (adcHandle->Instance != (ADC_TypeDef *)0x40012400) {\n    if (adcHandle->Instance == (ADC_TypeDef *)0x40012800) {\n      _DAT_4002100c = _DAT_4002100c & 0xfffffbff;\n      _DAT_40021018 = _DAT_40021018 & 0xfffffbff;\n    }\n    return;\n  }\n  _DAT_4002100c = _DAT_4002100c & 0xfffffdff;\n  _DAT_40021018 = _DAT_40021018 & 0xfffffdff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080049f0": "configure_adc_080049f0",
                "hadc": "adcHandle"
            },
            "calling": [
                "HAL_ADC_DeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a4c": {
            "entrypoint": "0x08004a4c",
            "current_name": "get_adc_converted_value_08004a4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint16_t getADCConvertedValue_08004a4c(pin pin)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t value;\n  uint16_t convertedValue;\n  ADC_ChannelConfTypeDef channelConfig;\n  ADC_HandleTypeDef adcHandle;\n  \n  memset(&adcHandle,0,0x30);\n  channelConfig.Channel = 0;\n  channelConfig.Rank = 0;\n  channelConfig.SamplingTime = 0;\n  convertedValue = 0;\n  adcHandle.Instance = (ADC_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)&PinMap_ADC);\n  if (adcHandle.Instance == (ADC_TypeDef *)0x0) {\n    convertedValue = 0;\n  }\n  else {\n    adcHandle.Init.DataAlign = 0;\n    adcHandle.Init.ScanConvMode = 0;\n    adcHandle.Init.ContinuousConvMode = 0;\n    adcHandle.Init.DiscontinuousConvMode = 0;\n    adcHandle.Init.ExternalTrigConv = 0xe0000;\n    adcHandle.State = 0;\n    adcHandle.Init.NbrOfConversion = 1;\n    adcHandle.Init.NbrOfDiscConversion = 0;\n    g_current_pin = pin;\n    status = HAL_ADC_Init(&adcHandle);\n    if (status == HAL_OK) {\n      channelConfig.Channel = get_adc_channel(pin);\n      if (channelConfig.Channel < 0x12) {\n        channelConfig.Rank = 1;\n        channelConfig.SamplingTime = 2;\n        status = HAL_ADC_ConfigChannel(&adcHandle,&channelConfig);\n        if (status == HAL_OK) {\n          status = HAL_ADCEx_Calibration_Start(&adcHandle);\n          if (status == HAL_OK) {\n            status = HAL_ADC_Start(&adcHandle);\n            if (status == HAL_OK) {\n              status = HAL_ADC_PollForConversion(&adcHandle,10);\n              if (status == HAL_OK) {\n                value = HAL_ADC_GetState(&adcHandle);\n                if ((value & 0x200) != 0) {\n                  value = HAL_ADC_GetValue(&adcHandle);\n                  convertedValue = (uint16_t)value;\n                }\n                status = HAL_ADC_Stop(&adcHandle);\n                if (status == HAL_OK) {\n                  status = HAL_ADC_DeInit(&adcHandle);\n                  if (status != HAL_OK) {\n                    convertedValue = 0;\n                  }\n                }\n                else {\n                  convertedValue = 0;\n                }\n              }\n              else {\n                convertedValue = 0;\n              }\n            }\n            else {\n              convertedValue = 0;\n            }\n          }\n          else {\n            convertedValue = 0;\n          }\n        }\n        else {\n          convertedValue = 0;\n        }\n      }\n      else {\n        convertedValue = 0;\n      }\n    }\n    else {\n      convertedValue = 0;\n    }\n  }\n  return convertedValue;\n}\n\n",
            "renaming": {
                "FUN_08004a4c": "get_adc_converted_value_08004a4c",
                "PinName_conflict": "pin",
                "HVar1": "status",
                "uVar2": "value",
                "uhADCxConvertedValue": "convertedValue",
                "AdcChannelConf": "channelConfig",
                "AdcHandle": "adcHandle"
            },
            "calling": [
                "analogRead"
            ],
            "called": [
                "HAL_ADC_DeInit",
                "HAL_ADC_GetState",
                "get_adc_channel",
                "HAL_ADC_PollForConversion",
                "HAL_ADC_ConfigChannel",
                "HAL_ADC_GetValue",
                "memset",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Stop",
                "pinmap_peripheral",
                "HAL_ADC_Init",
                "HAL_ADC_Start"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b34": {
            "entrypoint": "0x08004b34",
            "current_name": "disable_timer_08004b34",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_timer_08004b34(TIM_HandleTypeDef *timer_handle)\n\n{\n  disable_clock(timer_handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b34": "disable_timer_08004b34",
                "htim": "timer_handle",
                "timer_disable_clock": "disable_clock"
            },
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "called": [
                "timer_disable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b3c": {
            "entrypoint": "0x08004b3c",
            "current_name": "stop_pwm_08004b3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopPWM_08004b3c(PinName_conflict pinName)\n\n{\n  uint32_t pwmChannel;\n  uint32_t timpwmChannel;\n  uint32_t functionResult;\n  TIM_HandleTypeDef timHandle;\n  \n  timHandle.Instance = (TIM_TypeDef *)pinNamemap_peripheral(pinName,(PinMap_conflict *)&PinMap_PWM);\n  if ((timHandle.Instance != (TIM_TypeDef *)0x0) &&\n     ((((pwmChannel = get_pwm_channel(pinName), pwmChannel == 0 || (pwmChannel == 4)) || (pwmChannel == 8)) ||\n      ((pwmChannel == 0xc || (pwmChannel == 0x18)))))) {\n    functionResult = pinNamemap_function(pinName,(PinMap_conflict *)&PinMap_PWM);\n    if ((functionResult & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(&timHandle,pwmChannel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(&timHandle,pwmChannel);\n    }\n    HAL_TIM_PWM_DeInit(&timHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b3c": "stop_pwm_08004b3c",
                "pin": "pinName",
                "Channel": "pwmChannel",
                "uVar1": "functionResult"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_TIM_PWM_DeInit",
                "HAL_TIM_PWM_Stop",
                "get_pwm_channel",
                "pinmap_peripheral",
                "HAL_TIMEx_PWMN_Stop",
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b94": {
            "entrypoint": "0x08004b94",
            "current_name": "get_current_tick_08004b94",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_tick_08004b94(void)\n\n{\n  uint32_t current_tick;\n  \n  current_tick = HAL_GetTick();\n  return current_tick;\n}\n\n",
            "renaming": {
                "FUN_08004b94": "get_current_tick_08004b94",
                "uVar1": "current_tick"
            },
            "calling": [
                "millis"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b9c": {
            "entrypoint": "0x08004b9c",
            "current_name": "FUNC_08004b9c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004b9c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b9c": "FUNC_08004b9c"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004b9e": {
            "entrypoint": "0x08004b9e",
            "current_name": "handle_sys_tick_08004b9e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTick_08004b9e(void)\n\n{\n  incrementTick();\n  handleSysTick_08004b9eIRQ();\n  handleNoOSSysTick();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b9e": "handle_sys_tick_08004b9e",
                "HAL_IncTick": "incrementTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTickIRQ",
                "noOsSystickHandler": "handleNoOSSysTick"
            },
            "calling": [],
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "noOsSystickHandler",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bb0": {
            "entrypoint": "0x08004bb0",
            "current_name": "configure_pin_08004bb0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_08004bb0(PinName_conflict pinName,uint32_t configurationMode,uint32_t pullType)\n\n{\n  uint pinValue;\n  GPIO_TypeDef *gpioPort;\n  GPIO_TypeDef *port;\n  uint32_t tempRegister2;\n  uint32_t tempRegister1;\n  uint32_t tempRegister;\n  GPIO_InitTypeDef gpioInitStructure;\n  \n  pinValue = (uint)pinName;\n  gpioPort = set_GPIO_Port_Clock((pinValue << 0x18) >> 0x1c);\n  gpioInitStructure.Pin = 1 << (pinValue & 0xf) & 0xffff;\n  gpioInitStructure.Speed = 3;\n  _DAT_40021018 = _DAT_40021018 | 1;\n  if ((pinValue - 0xd & 0xff) < 2) {\n    _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x4000000;\n  }\n  if (((pinValue == 0xf) || (pinValue == 0x13)) || (pinValue == 0x14)) {\n    tempRegister1 = _DAT_40010004 & 0xf8ffffff;\n    _DAT_40010004 = tempRegister1 | 0x2000000;\n  }\n  gpioInitStructure.Mode = configurationMode;\n  gpioInitStructure.Pull = pullType;\n  HAL_GPIO_Init(gpioPort,&gpioInitStructure);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bb0": "configure_pin_08004bb0",
                "pin": "pinName",
                "mode": "configurationMode",
                "pull": "pullType",
                "uVar1": "pinValue",
                "GPIOx": "gpioPort",
                "tmpreg_2": "tempRegister2",
                "tmpreg_1": "tempRegister1",
                "tmpreg": "tempRegister",
                "GPIO_InitStructure": "gpioInitStructure"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c30": {
            "entrypoint": "0x08004c30",
            "current_name": "set_pin_state_08004c30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinState_08004c30(GPIO_TypeDef *gpioPort,uint32_t pinNumber,uint32_t pinState)\n\n{\n  if (pinState == 0) {\n    HAL_GPIO_WritePin(gpioPort,(uint16_t)pinNumber,GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(gpioPort,(uint16_t)pinNumber,GPIO_PIN_SET);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c30": "set_pin_state_08004c30",
                "port": "gpioPort",
                "pin": "pinNumber",
                "val": "pinState"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c48": {
            "entrypoint": "0x08004c48",
            "current_name": "read_gpio_pin_state_08004c48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t readGPIO_PinState_08004c48(GPIO_TypeDef *GPIO_Port,uint32_t GPIO_Pin)\n\n{\n  GPIO_PinState pinState;\n  \n  pinState = HAL_GPIO_ReadPin(GPIO_Port,(uint16_t)GPIO_Pin);\n  return (uint)pinState;\n}\n\n",
            "renaming": {
                "FUN_08004c48": "read_gpio_pin_state_08004c48",
                "port": "GPIO_Port",
                "pin": "GPIO_Pin",
                "GVar1": "pinState"
            },
            "calling": [
                "digitalRead"
            ],
            "called": [
                "HAL_GPIO_ReadPin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c52": {
            "entrypoint": "0x08004c52",
            "current_name": "initialize_08004c52",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_08004c52(void)\n\n{\n  initialize_08004c52_HAL();\n  configure_system_clock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c52": "initialize_08004c52",
                "HAL_Init": "initialize_HAL",
                "SystemClock_Config": "configure_system_clock"
            },
            "calling": [
                "init"
            ],
            "called": [
                "HAL_Init",
                "SystemClock_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c5e": {
            "entrypoint": "0x08004c5e",
            "current_name": "find_peripheral_by_pin_08004c5e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * findPeripheralByPin_08004c5e(PinName_conflict desiredPin,PinMap_conflict *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->desiredPin == NotConnected) {\n      return (void *)0x0;\n    }\n    if (pinMap->desiredPin == desiredPin) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->foundPeripheral;\n}\n\n",
            "renaming": {
                "FUN_08004c5e": "find_peripheral_by_pin_08004c5e",
                "pin": "desiredPin",
                "map": "pinMap",
                "NC": "NotConnected",
                "peripheral": "foundPeripheral"
            },
            "calling": [
                "pinmap_find_peripheral",
                "pinmap_peripheral"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c78": {
            "entrypoint": "0x08004c78",
            "current_name": "find_peripheral_08004c78",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * find_peripheral_08004c78(pin pin,map *map)\n\n{\n  void *peripheral;\n  \n  if (pin != NC) {\n    peripheral = pinmap_find_peripheral_08004c78(pin,map);\n    return peripheral;\n  }\n  return (void *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08004c78": "find_peripheral_08004c78",
                "PinName_conflict": "pin",
                "PinMap_conflict": "map",
                "pvVar1": "peripheral"
            },
            "calling": [
                "uart_debug_init",
                "adc_read_value",
                "pwm_stop",
                "uart_init",
                "uart_debug_write"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c8a": {
            "entrypoint": "0x08004c8a",
            "current_name": "find_pin_name_08004c8a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nConflictingPinName findPinName_08004c8a(void *device,ConflictingPinMap *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->device == (void *)0x0) {\n      return NoConnection;\n    }\n    if (pinMap->device == device) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->pin;\n}\n\n",
            "renaming": {
                "FUN_08004c8a": "find_pin_name_08004c8a",
                "peripheral": "device",
                "map": "pinMap",
                "PinName_conflict": "ConflictingPinName",
                "PinMap_conflict": "ConflictingPinMap",
                "NC": "NoConnection"
            },
            "calling": [
                "pinmap_pin",
                "pinmap_find_pin"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ca2": {
            "entrypoint": "0x08004ca2",
            "current_name": "find_pin_in_peripheral_08004ca2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict findPinInPeripheral_08004ca2(void *peripheralPtr,PinMap *pinMapPtr)\n\n{\n  PinName_conflict foundPin;\n  \n  if (peripheralPtr != (void *)0x0) {\n    foundPin = pinpinMapPtr_find_pin(peripheralPtr,pinMapPtr);\n    return foundPin;\n  }\n  return NotConnected;\n}\n\n",
            "renaming": {
                "FUN_08004ca2": "find_pin_in_peripheral_08004ca2",
                "peripheral": "peripheralPtr",
                "PinMap_conflict": "PinMap",
                "map": "pinMapPtr",
                "PVar1": "foundPin",
                "NC": "NotConnected"
            },
            "calling": [
                "uart_debug_init",
                "HardwareSerial"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cb2": {
            "entrypoint": "0x08004cb2",
            "current_name": "find_pin_function_08004cb2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t findPinFunction_08004cb2(requestedPin pinToFind,pinMap *currentPin)\n\n{\n  while( true ) {\n    if (currentPin->pinToFind == NotConnected) {\n      return 0xffffffff;\n    }\n    if (currentPin->pinToFind == pinToFind) break;\n    currentPin = currentPin + 1;\n  }\n  return currentPin->pinFunction;\n}\n\n",
            "renaming": {
                "FUN_08004cb2": "find_pin_function_08004cb2",
                "PinName_conflict": "requestedPin",
                "PinMap_conflict": "pinMap",
                "pin": "pinToFind",
                "map": "currentPin",
                "NC": "NotConnected",
                "function": "pinFunction"
            },
            "calling": [
                "pinmap_find_function",
                "pinmap_function"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cce": {
            "entrypoint": "0x08004cce",
            "current_name": "find_pin_function_08004cce",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t find_pin_function_08004cce(PinName_conflict pin_name,PinMap_conflict *pin_map)\n\n{\n  uint32_t function_result;\n  \n  if (pin_name == NC) {\n    return 0xffffffff;\n  }\n  function_result = pin_namepin_map_find_function(pin_name,pin_map);\n  return function_result;\n}\n\n",
            "renaming": {
                "FUN_08004cce": "find_pin_function_08004cce",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "function_result"
            },
            "calling": [
                "get_adc_channel",
                "pwm_stop",
                "get_pwm_channel",
                "uart_init"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ce2": {
            "entrypoint": "0x08004ce2",
            "current_name": "validate_pin_08004ce2",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool validatePin_08004ce2(PinName_conflict current_pin,PinMap_conflict *pin_map)\n\n{\n  if (current_pin == not_connected) {\n    return false;\n  }\n  while( true ) {\n    if (pin_map->current_pin == not_connected) {\n      return false;\n    }\n    if (current_pin == pin_map->current_pin) pin_found;\n    pin_map = pin_map + 1;\n  }\n  return true;\n}\n\n",
            "renaming": {
                "FUN_08004ce2": "validate_pin_08004ce2",
                "pin": "current_pin",
                "map": "pin_map",
                "NC": "not_connected",
                "break": "pin_found"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d06": {
            "entrypoint": "0x08004d06",
            "current_name": "merge_pointers_08004d06",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * merge_pointers_08004d06(void *a,void *b)\n\n{\n  if (a != b) {\n    if (a == (void *)0x0) {\n      return b;\n    }\n    if (b == (void *)0x0) {\n      return a;\n    }\n    a = (void *)0x0;\n  }\n  return a;\n}\n\n",
            "renaming": {
                "FUN_08004d06": "merge_pointers_08004d06"
            },
            "calling": [
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d18": {
            "entrypoint": "0x08004d18",
            "current_name": "execute_rtc_user_callback_08004d18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid executeRTCUserCallback_08004d18(RTC_HandleTypeDef *rtcHandle)\n\n{\n  if (userCallback != (callbackFunctionPtr)0x0) {\n    (*userCallback)(callbackData);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d18": "execute_rtc_user_callback_08004d18",
                "hrtc": "rtcHandle",
                "RTCUserCallback": "userCallback",
                "voidCallbackPtr": "callbackFunctionPtr",
                "callbackUserData": "callbackData"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d30": {
            "entrypoint": "0x08004d30",
            "current_name": "handle_rtc_alarm_irq_08004d30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleRtcAlarmIRQ_08004d30(void)\n\n{\n  HAL_RTC_AlarmIRQHandler(&rtcHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d30": "handle_rtc_alarm_irq_08004d30",
                "&RtcHandle": "&rtcHandle"
            },
            "calling": [],
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d40": {
            "entrypoint": "0x08004d40",
            "current_name": "infinite_loop_08004d40",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08004d40(char *message,int value)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004d40": "infinite_loop_08004d40",
                "msg": "message",
                "val": "value"
            },
            "calling": [
                "_Error_Handler",
                "SystemClock_Config"
            ],
            "called": [
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d44": {
            "entrypoint": "0x08004d44",
            "current_name": "initialize_memory_08004d44",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeMemory_08004d44(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d44": "initialize_memory_08004d44"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d90": {
            "entrypoint": "0x08004d90",
            "current_name": "update_tim_register_08004d90",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid update_TIM_register_08004d90(TIM_HandleTypeDef *timer_handler)\n\n{\n  if (timer_handler->timer_instance == (TIM_TypeDef *)0x40012c00) {\n    _DAT_40021018 = _DAT_40021018 & 0xfffff7ff;\n  }\n  if (timer_handler->timer_instance == (TIM_TypeDef *)0x40000000) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffe;\n  }\n  if (timer_handler->timer_instance == (TIM_TypeDef *)0x40000400) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffd;\n  }\n  if (timer_handler->timer_instance == (TIM_TypeDef *)0x40000800) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d90": "update_tim_register_08004d90",
                "htim": "timer_handler",
                "Instance": "timer_instance"
            },
            "calling": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004df4": {
            "entrypoint": "0x08004df4",
            "current_name": "get_stimer_from_htim_08004df4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nstimer_struct * get_stimer_from_htim_08004df4(TIM_HandleTypeDef *timer_handle)\n\n{\n  return (stimer_struct *)&timer_handle[-1].lock;\n}\n\n",
            "renaming": {
                "FUN_08004df4": "get_stimer_from_htim_08004df4",
                "htim": "timer_handle",
                "stimer_t": "stimer_struct",
                "Lock": "lock"
            },
            "calling": [
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004df8": {
            "entrypoint": "0x08004df8",
            "current_name": "handle_tim_interrupt_08004df8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_TIM_interrupt_08004df8(TIM_HandleTypeDef *timer_handle)\n\n{\n  stimer_t *timer_obj;\n  stimer_t *timer_obj_pointer;\n  \n  timer_obj = get_timer_timer_obj_pointer(timer_handle);\n  if ((timer_obj->irqHandleOC != (_func_void_stimer_t_ptr_uint32_t *)0x0) &&\n     (timer_handle->Channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*timer_obj->irqHandleOC)(timer_obj,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004df8": "handle_tim_interrupt_08004df8",
                "htim": "timer_handle",
                "psVar1": "timer_obj",
                "obj": "timer_obj_pointer"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e12": {
            "entrypoint": "0x08004e12",
            "current_name": "handle_timer_interrupt_08004e12",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_timer_interrupt_08004e12(TIM_HandleTypeDef *timer_handle)\n\n{\n  stimer_t *psVar1;\n  stimer_t *obj;\n  \n  psVar1 = get_timer_obj(timer_handle);\n  if (psVar1->irqHandle != (_func_void_stimer_t_ptr *)0x0) {\n    (*psVar1->irqHandle)(psVar1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e12": "handle_timer_interrupt_08004e12",
                "htim": "timer_handle"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e20": {
            "entrypoint": "0x08004e20",
            "current_name": "handle_timer_interrupt_08004e20",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08004e20(void)\n\n{\n  if (timerHandles[0] != (TIM_HandleTypeDef *)0x0) {\n    handleTimerIRQ(timerHandles[0]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e20": "handle_timer_interrupt_08004e20",
                "timer_handles": "timerHandles",
                "HAL_TIM_IRQHandler": "handleTimerIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e34": {
            "entrypoint": "0x08004e34",
            "current_name": "handle_timer_interrupt_08004e34",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08004e34(void)\n\n{\n  if (timerHandlers[1] != (TimerHandle *)0x0) {\n    handleTimerIRQ(timerHandlers[1]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e34": "handle_timer_interrupt_08004e34",
                "timer_handles": "timerHandlers",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleTimerIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e48": {
            "entrypoint": "0x08004e48",
            "current_name": "handle_timer_interrupt_08004e48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08004e48(void)\n\n{\n  if (timerHandles[2] != (TimerHandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e48": "handle_timer_interrupt_08004e48",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandleTypeDef"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e5c": {
            "entrypoint": "0x08004e5c",
            "current_name": "handle_timers_08004e5c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimers_08004e5c(void)\n\n{\n  if (handles[3] != (TimerHandle *)0x0) {\n    handleTimerInterrupt(handles[3]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e5c": "handle_timers_08004e5c",
                "timer_handles": "handles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleTimerInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e70": {
            "entrypoint": "0x08004e70",
            "current_name": "extract_i2c_from_hi2c_08004e70",
            "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_t * extract_i2c_from_hi2c_08004e70(I2C_HandleTypeDef *i2c_handle)\n\n{\n  return (i2c_t *)&i2c_handle[-1].EventCount;\n}\n\n",
            "renaming": {
                "FUN_08004e70": "extract_i2c_from_hi2c_08004e70",
                "hi2c": "i2c_handle"
            },
            "calling": [
                "HAL_I2C_AddrCallback",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e74": {
            "entrypoint": "0x08004e74",
            "current_name": "handle_i2c_transfer_08004e74",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_i2c_transfer_08004e74(I2C_HandleTypeDef *i2c_handle,uint8_t transfer_direction,uint16_t address_match_code)\n\n{\n  i2c_t *i2c_obj;\n  i2c_t *i2c_obj_temp;\n  \n  i2c_obj = retrieve_i2c_obj(i2c_handle);\n  if ((uint)address_match_code == (i2c_handle->i2c_init).own_address) {\n    if (transfer_direction == '\\0') {\n      i2c_obj->buffer_size = '\\0';\n      i2c_obj->is_slave_mode = '\\0';\n      if (i2c_obj->slave_transmit_callback != (_func_void *)0x0) {\n        (*i2c_obj->slave_transmit_callback)();\n      }\n      transmit_data_seq\n                (i2c_handle,i2c_obj->tx_rx_buffer,(ushort)i2c_obj->buffer_size,8);\n      return;\n    }\n    i2c_obj->is_slave_mode = '\\x01';\n    receive_data_seq(i2c_handle,i2c_obj->tx_rx_buffer,0x20,8);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e74": "handle_i2c_transfer_08004e74",
                "hi2c": "i2c_handle",
                "TransferDirection": "transfer_direction",
                "AddrMatchCode": "address_match_code",
                "piVar1": "i2c_obj",
                "obj": "i2c_obj_temp",
                "get_i2c_obj": "retrieve_i2c_obj",
                "Init": "i2c_init",
                "OwnAddress1": "own_address",
                "i2cTxRxBufferSize": "buffer_size",
                "slaveMode": "is_slave_mode",
                "i2c_onSlaveTransmit": "slave_transmit_callback",
                "HAL_I2C_Slave_Sequential_Transmit_IT": "transmit_data_seq",
                "i2cTxRxBuffer": "tx_rx_buffer",
                "HAL_I2C_Slave_Sequential_Receive_IT": "receive_data_seq"
            },
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "called": [
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "HAL_I2C_Slave_Sequential_Transmit_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ec4": {
            "entrypoint": "0x08004ec4",
            "current_name": "enable_i2_c_listen_it_08004ec4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableI2CListenIT_08004ec4(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2c_t *i2cObj;\n  i2c_t *i2cObj;\n  uint transferSize;\n  \n  i2cObj = getI2CObject(i2cHandle);\n  if (((i2cObj->onSlaveReceiveCallback != (callbackFunc *)0x0) &&\n      (i2cObj->isSlaveMode == '\\x01')) &&\n     (transferSize = 0x20 - *(byte *)&(i2cObj->handle).XferSize & 0xff, transferSize != 0)) {\n    (*i2cObj->onSlaveReceiveCallback)(i2cObj->i2cTxRxBuffer,transferSize);\n  }\n  enableI2CListen(i2cHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ec4": "enable_i2_c_listen_it_08004ec4",
                "hi2c": "i2cHandle",
                "piVar1": "i2cObj",
                "obj": "i2cObj",
                "uVar2": "transferSize",
                "get_i2c_obj": "getI2CObject",
                "i2c_onSlaveReceive": "onSlaveReceiveCallback",
                "_func_void_uint8_t_ptr_int": "callbackFunc",
                "slaveMode": "isSlaveMode",
                "HAL_I2C_EnableListen_IT": "enableI2CListen"
            },
            "calling": [
                "I2C_ITError",
                "I2C_Slave_AF",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef4": {
            "entrypoint": "0x08004ef4",
            "current_name": "enable_listen_interrupt_08004ef4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableListenInterrupt_08004ef4(I2C_HandleTypeDef *I2CHandle)\n\n{\n  i2c_t *i2cObject;\n  i2c_t *i2cObjectTemp;\n  \n  i2cObject = get_i2c_i2cObjectTemp(I2CHandle);\n  if (i2cObject->isMaster == '\\0') {\n    HAL_I2C_EnableListen_IT(I2CHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef4": "enable_listen_interrupt_08004ef4",
                "hi2c": "I2CHandle",
                "piVar1": "i2cObject",
                "obj": "i2cObjectTemp"
            },
            "calling": [
                "I2C_DMAAbort",
                "I2C_ITError"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f0c": {
            "entrypoint": "0x08004f0c",
            "current_name": "handle_i2_c_event_08004f0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvent_08004f0c(void)\n\n{\n  HAL_I2C_EV_IRQHandler(handles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f0c": "handle_i2_c_event_08004f0c",
                "i2c_handles": "handles"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f1c": {
            "entrypoint": "0x08004f1c",
            "current_name": "handle_i2_c_error_interrupt_08004f1c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CErrorInterrupt_08004f1c(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c_handles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f1c": "handle_i2_c_error_interrupt_08004f1c"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f2c": {
            "entrypoint": "0x08004f2c",
            "current_name": "handle_i2_c2_event_interrupt_08004f2c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2C2EventInterrupt_08004f2c(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2c2EventInterruptHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f2c": "handle_i2_c2_event_interrupt_08004f2c",
                "I2C2_ER_IRQHandler::handle": "i2c2EventInterruptHandle"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "handle_i2_c_error_08004f3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CError_08004f3c(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c2ErrorHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "handle_i2_c_error_08004f3c",
                "I2C2_ER_IRQHandler::handle": "i2c2ErrorHandler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f4c": {
            "entrypoint": "0x08004f4c",
            "current_name": "initialize_uart_08004f4c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_UART_08004f4c(serial_t *serial_object)\n\n{\n  void *a;\n  USART_TypeDef *uart_peripheral_tx;\n  void *b;\n  USART_TypeDef *uart_peripheral_rx;\n  USART_TypeDef *merged_peripheral;\n  GPIO_TypeDef *gpio_port;\n  GPIO_TypeDef *gpio_port;\n  uint32_t pin_function;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  uint32_t tmpreg_10;\n  uint32_t tmpreg_11;\n  uint32_t tmpreg_12;\n  uint32_t tmpreg_13;\n  uint32_t tmpreg_14;\n  uint32_t tmpreg_15;\n  uint32_t tmpreg_16;\n  UART_HandleTypeDef *uart_handle;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  GPIO_InitTypeDef gpio_init_struct;\n  \n  if (serial_object != (serial_t *)0x0) {\n    a = pinmap_peripheral(serial_object->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n    b = pinmap_peripheral(serial_object->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(\"ERROR: at least one UART pin has no peripheral\\n\");\n    }\n    else {\n      merged_peripheral = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      serial_object->uart = merged_peripheral;\n      if (merged_peripheral == (USART_TypeDef *)0x0) {\n        iprintf(\"ERROR: U(S)ART pins mismatch\\n\");\n      }\n      else {\n        if (merged_peripheral == (USART_TypeDef *)0x40013800) {\n          _DAT_4002100c = _DAT_4002100c & 0xffffbfff;\n          _DAT_40021018 = _DAT_40021018 | 0x4000;\n          serial_object->index = '\\0';\n          serial_object->irq = USART1_IRQn;\n        }\n        else if (merged_peripheral == (USART_TypeDef *)0x40004400) {\n          _DAT_40021010 = _DAT_40021010 & 0xfffdffff;\n          _DAT_4002101c = _DAT_4002101c | 0x20000;\n          serial_object->index = '\\x01';\n          serial_object->irq = USART2_IRQn;\n        }\n        else if (merged_peripheral == (USART_TypeDef *)0x40004800) {\n          _DAT_40021010 = _DAT_40021010 & 0xfffbffff;\n          _DAT_4002101c = _DAT_4002101c | 0x40000;\n          serial_object->index = '\\x02';\n          serial_object->irq = USART3_IRQn;\n        }\n        gpio_port = set_GPIO_Port_Clock((uint)((int)serial_object->pin_rx << 0x18) >> 0x1c);\n        pin_function = pinmap_function(serial_object->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n        gpio_init_struct.Pin = 1 << (serial_object->pin_rx & 0xfU) & 0xffff;\n        gpio_init_struct.Mode = (pin_function >> 3 & 1) << 4 | pin_function & 7;\n        gpio_init_struct.Pull = (pin_function << 0x1a) >> 0x1e;\n        _DAT_40021018 = _DAT_40021018 | 1;\n        switch((pin_function << 0x11) >> 0x19) {\n        case 1:\n          tmpreg_13 = tmpreg_13 | 0x7000001;\n          break;\n        case 2:\n          tmpreg_13 = tmpreg_13 & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          tmpreg_13 = tmpreg_13 | 0x7000002;\n          break;\n        case 4:\n          tmpreg_13 = tmpreg_13 & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          tmpreg_13 = tmpreg_13 | 0x7000004;\n          break;\n        case 6:\n          tmpreg_13 = tmpreg_13 & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          tmpreg_13 = tmpreg_13 | 0x7000008;\n          break;\n        case 8:\n          tmpreg_13 = tmpreg_13 & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          tmpreg_13 = tmpreg_13 | 0x7000030;\n          break;\n        case 10:\n          tmpreg_4 = tmpreg_13 & 0xffffffcf;\n          tmpreg_13 = tmpreg_4 | 0x7000010;\n          break;\n        case 0xb:\n          tmpreg_5 = tmpreg_13 & 0xffffffcf;\n          tmpreg_13 = tmpreg_5 | 0x7000000;\n          break;\n        case 0xc:\n          tmpreg_13 = tmpreg_13 | 0x70000c0;\n          break;\n        case 0xd:\n          tmpreg_6 = tmpreg_13 & 0xffffff3f;\n          tmpreg_13 = tmpreg_6 | 0x7000040;\n          break;\n        case 0xe:\n          tmpreg_7 = tmpreg_13 & 0xffffff3f;\n          tmpreg_13 = tmpreg_7 | 0x7000000;\n          break;\n        case 0xf:\n          tmpreg_13 = tmpreg_13 | 0x7000300;\n          break;\n        case 0x10:\n          tmpreg_8 = tmpreg_13 & 0xfffffcff;\n          tmpreg_13 = tmpreg_8 | 0x7000200;\n          break;\n        case 0x11:\n          tmpreg_9 = tmpreg_13 & 0xfffffcff;\n          tmpreg_13 = tmpreg_9 | 0x7000100;\n          break;\n        case 0x12:\n          tmpreg_10 = tmpreg_13 & 0xfffffcff;\n          tmpreg_13 = tmpreg_10 | 0x7000000;\n          break;\n        case 0x13:\n          tmpreg_13 = tmpreg_13 | 0x7000c00;\n          break;\n        case 0x14:\n          tmpreg_11 = tmpreg_13 & 0xfffff3ff;\n          tmpreg_13 = tmpreg_11 | 0x7000800;\n          break;\n        case 0x15:\n          tmpreg_12 = tmpreg_13 & 0xfffff3ff;\n          tmpreg_13 = tmpreg_12 | 0x7000000;\n          break;\n        case 0x16:\n          tmpreg_13 = tmpreg_13 | 0x7001000;\n          break;\n        case 0x17:\n          tmpreg_13 = tmpreg_13 & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          tmpreg_13 = tmpreg_13 | 0x7008000;\n          break;\n        case 0x1c:\n          tmpreg_13 = tmpreg_13 & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          tmpreg_13 = tmpreg_13 & 0xf8ffffff;\n          break;\n        case 0x22:\n          tmpreg_14 = tmpreg_13 & 0xf8ffffff;\n          tmpreg_13 = tmpreg_14 | 0x1000000;\n          break;\n        case 0x23:\n          tmpreg_15 = tmpreg_13 & 0xf8ffffff;\n          tmpreg_13 = tmpreg_15 | 0x2000000;\n          break;\n        case 0x24:\n          tmpreg_16 = tmpreg_13 & 0xf8ffffff;\n          tmpreg_13 = tmpreg_16 | 0x4000000;\n        }\n        gpio_init_struct.Speed = 3;\n        HAL_GPIO_Init(gpio_port,&gpio_init_struct);\n        gpio_port = set_GPIO_Port_Clock((uint)((int)serial_object->pin_tx << 0x18) >> 0x1c);\n        pin_function = pinmap_function(serial_object->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n        gpio_init_struct.Pin = 1 << (serial_object->pin_tx & 0xfU) & 0xffff;\n        gpio_init_struct.Mode = (pin_function >> 3 & 1) << 4 | pin_function & 7;\n        gpio_init_struct.Pull = (pin_function << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(gpio_port,&gpio_init_struct);\n        uart_handlers[serial_object->index] = &serial_object->handle;\n        (serial_object->handle).Instance = serial_object->uart;\n        (serial_object->handle).Init.BaudRate = serial_object->baudrate;\n        (serial_object->handle).Init.WordLength = serial_object->databits;\n        (serial_object->handle).Init.StopBits = serial_object->stopbits;\n        (serial_object->handle).Init.Parity = serial_object->parity;\n        (serial_object->handle).Init.Mode = 0xc;\n        (serial_object->handle).Init.HwFlowCtl = 0;\n        (serial_object->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&serial_object->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f4c": "initialize_uart_08004f4c",
                "obj": "serial_object",
                "uart_tx": "uart_peripheral_tx",
                "uart_rx": "uart_peripheral_rx",
                "pUVar1": "merged_peripheral",
                "pGVar2": "gpio_port",
                "port": "gpio_port",
                "uVar3": "pin_function",
                "huart": "uart_handle",
                "GPIO_InitStruct": "gpio_init_struct"
            },
            "calling": [
                "begin",
                "uart_debug_init"
            ],
            "called": [
                "HAL_GPIO_Init",
                "pinmap_merge_peripheral",
                "HAL_UART_Init",
                "set_GPIO_Port_Clock",
                "pinmap_peripheral",
                "iprintf",
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005384": {
            "entrypoint": "0x08005384",
            "current_name": "initialize_serial_connection_08005384",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialConnection_08005384(void)\n\n{\n  void *peripheralMapping;\n  \n  peripheralMapping = pinmap_peripheral(PA_2,(ConflictPinMapping *)&PinMap_UART_TX);\n  if (peripheralMapping != (void *)0x0) {\n    peripheralMapping = pinmap_peripheral(PA_2,(ConflictPinMapping *)&PinMap_UART_TX);\n    debugSerial.rxPin = pinmap_pin(peripheralMapping,(ConflictPinMapping *)&PinMap_UART_RX);\n    debugSerial.txPin = PA_2;\n    debugSerial.BAUD_RATE = 0x2580;\n    debugSerial.PARITY = 0;\n    debugSerial.DATA_BITS = 0;\n    debugSerial.STOP_BITS = 0;\n    initializeUART(&debugSerial);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005384": "initialize_serial_connection_08005384",
                "pvVar1": "peripheralMapping",
                "PinMap_conflict": "ConflictPinMapping",
                "serial_debug": "debugSerial",
                "pin_rx": "rxPin",
                "pin_tx": "txPin",
                "baudrate": "BAUD_RATE",
                "parity": "PARITY",
                "databits": "DATA_BITS",
                "stopbits": "STOP_BITS",
                "uart_init": "initializeUART"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "pinmap_pin",
                "pinmap_peripheral",
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053d4": {
            "entrypoint": "0x080053d4",
            "current_name": "transmit_data_080053d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nbufferSize_t transmitData_080053d4(uint8_t *dataBuffer,uint32_t bufferSize)\n\n{\n  HAL_StatusTypeDef_conflict transmitStatus;\n  uint32_t startTicks;\n  uint32_t initialTicks;\n  void *peripheral;\n  USART_TypeDef *uartInstance;\n  uint32_t currentTicks;\n  uint uartIndex;\n  \n  startTicks = HAL_GetTick();\n  peripheral = pinmap_peripheral(PA_2,(PinMap_conflict *)&PinMap_UART_TX);\n  if (peripheral == (void *)0x0) {\n    return 0;\n  }\n  uartIndex = 0;\n  while ((uartIndex < 5 &&\n         ((uart_handlers[uartIndex] == (UART_HandleTypeDef *)0x0 ||\n          (uartInstance = (USART_TypeDef *)pinmap_peripheral(PA_2,(PinMap_conflict *)&PinMap_UART_TX),\n          uart_handlers[uartIndex]->Instance != uartInstance))))) {\n    uartIndex = uartIndex + 1 & 0xff;\n  }\n  if (4 < uartIndex) {\n    if ((4 < serial_debug.index) && (uart_debug_init(), 4 < serial_debug.index)) {\n      return 0;\n    }\n    uartIndex = (uint)serial_debug.index;\n  }\n  do {\n    transmitStatus = HAL_UART_Transmit(uart_handlers[uartIndex],dataBuffer,(uint16_t)bufferSize,1000);\n    if (transmitStatus == HAL_OK) {\n      return bufferSize;\n    }\n    currentTicks = HAL_GetTick();\n  } while (currentTicks - startTicks < 1000);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080053d4": "transmit_data_080053d4",
                "data": "dataBuffer",
                "size": "bufferSize",
                "HVar1": "transmitStatus",
                "uVar2": "startTicks",
                "pvVar3": "peripheral",
                "pUVar4": "uartInstance",
                "uVar5": "currentTicks",
                "uVar6": "uartIndex",
                "tickstart": "initialTicks"
            },
            "calling": [
                "_write"
            ],
            "called": [
                "HAL_GetTick",
                "uart_debug_init",
                "pinmap_peripheral",
                "HAL_UART_Transmit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800548c": {
            "entrypoint": "0x0800548c",
            "current_name": "check_uart_state_0800548c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_state_0800548c(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(uart_handlers[serial_object->index]);\n  return (uart_state & 0x22) == 0x22;\n}\n\n",
            "renaming": {
                "FUN_0800548c": "check_uart_state_0800548c",
                "obj": "serial_object",
                "HVar1": "uart_state"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054b0": {
            "entrypoint": "0x080054b0",
            "current_name": "check_uart_connection_080054b0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_connection_080054b0(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(handlers_array[serial_object->index]);\n  return (uart_state & 0x21) == 0x21;\n}\n\n",
            "renaming": {
                "FUN_080054b0": "check_uart_connection_080054b0",
                "obj": "serial_object",
                "HVar1": "uart_state",
                "uart_handlers": "handlers_array"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054d4": {
            "entrypoint": "0x080054d4",
            "current_name": "receive_data_080054d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint receiveData_080054d4(serial_t *serialObject,uchar *c)\n\n{\n  uint8_t isRxActive;\n  \n  if (serialObject == (serial_t *)0x0) {\n    return -1;\n  }\n  isRxActive = serial_rx_active(serialObject);\n  if (isRxActive == '\\0') {\n    *c = serialObject->recv;\n    HAL_UART_Receive_IT(uart_handlers[serialObject->index],&serialObject->recv,1);\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_080054d4": "receive_data_080054d4",
                "obj": "serialObject",
                "uVar1": "isRxActive"
            },
            "calling": [
                "_rx_complete_irq"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005510": {
            "entrypoint": "0x08005510",
            "current_name": "setup_serial_callback_08005510",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setupSerialCallback_08005510(serial_t *serialObject,_func_void_serial_t_ptr *serialCallback)\n\n{\n  byte byteValue;\n  uint8_t status;\n  \n  if (serialObject != (serial_t *)0x0) {\n    status = serial_rx_active(serialObject);\n    if (status == '\\0') {\n      byteValue = serialObject->index;\n      receiveCallback[byteValue] = serialCallback;\n      receiveCallbackObject[byteValue] = serialObject;\n      configureInterruptPriority(serialObject->irq,0,1);\n      enableInterrupt(serialObject->irq);\n      startReceivingWithInterrupt(uart_handlers[serialObject->index],&serialObject->recv,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005510": "setup_serial_callback_08005510",
                "obj": "serialObject",
                "callback": "serialCallback",
                "bVar1": "byteValue",
                "uVar2": "status",
                "rx_callback": "receiveCallback",
                "rx_callback_obj": "receiveCallbackObject",
                "HAL_NVIC_SetPriority": "configureInterruptPriority",
                "HAL_NVIC_EnableIRQ": "enableInterrupt",
                "HAL_UART_Receive_IT": "startReceivingWithInterrupt"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_UART_Receive_IT",
                "HAL_NVIC_EnableIRQ",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005568": {
            "entrypoint": "0x08005568",
            "current_name": "transmit_with_callback_08005568",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitWithCallback_08005568(serial_t *serialObject,_func_int_serial_t_ptr *callbackFunction)\n\n{\n  byte indexValue;\n  \n  if (serialObject != (serial_t *)0x0) {\n    indexValue = serialObject->index;\n    tx_callbackFunction[indexValue] = callbackFunction;\n    tx_callbackFunction_serialObject[indexValue] = serialObject;\n    HAL_NVIC_SetPriority(serialObject->irq,0,2);\n    HAL_NVIC_EnableIRQ(serialObject->irq);\n    HAL_UART_Transmit_IT(uart_handlers[serialObject->index],serialObject->tx_buff + serialObject->tx_tail,1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005568": "transmit_with_callback_08005568",
                "obj": "serialObject",
                "callback": "callbackFunction",
                "bVar1": "indexValue"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_EnableIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055bc": {
            "entrypoint": "0x080055bc",
            "current_name": "find_uart_handler_index_080055bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t find_uart_handler_index_080055bc(UART_HandleTypeDef *uart_handle)\n\n{\n  uint index;\n  \n  if (uart_handle == (UART_HandleTypeDef *)0x0) {\n    index = 5;\n  }\n  else {\n    index = 0;\n    while( true ) {\n      if (4 < index) {\n        return (uint8_t)index;\n      }\n      if (uart_handle == uart_handlers[index]) break;\n      index = index + 1 & 0xff;\n    }\n  }\n  return (uint8_t)index;\n}\n\n",
            "renaming": {
                "FUN_080055bc": "find_uart_handler_index_080055bc",
                "huart": "uart_handle",
                "uVar1": "index"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "HAL_UART_RxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055e0": {
            "entrypoint": "0x080055e0",
            "current_name": "handle_uart_rx_080055e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_uart_rx_080055e0(UART_HandleTypeDef *uart_handler)\n\n{\n  byte index_byte;\n  uint8_t index;\n  uint unsigned_index;\n  \n  index_byte = uart_index(uart_handler);\n  unsigned_index = (uint)index_byte;\n  if (unsigned_index < 5) {\n    (*rx_callback[unsigned_index])(rx_callback_obj[unsigned_index]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055e0": "handle_uart_rx_080055e0",
                "huart": "uart_handler",
                "bVar1": "index_byte",
                "uVar2": "unsigned_index"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005604": {
            "entrypoint": "0x08005604",
            "current_name": "transmit_data_over_uart_08005604",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitDataOverUART_08005604(UART_HandleTypeDef *uartHandle)\n\n{\n  byte uartIndex;\n  uint8_t serialIndex;\n  int callbackResult;\n  serial_t *currentSerialObj;\n  serial_t *callbackObj;\n  uint serialIndexAsInt;\n  \n  uartIndex = uart_serialIndex(uartHandle);\n  serialIndexAsInt = (uint)uartIndex;\n  callbackObj = tx_callback_currentSerialObj[serialIndexAsInt];\n  if ((serialIndexAsInt < 5) && (callbackResult = (*tx_callback[serialIndexAsInt])(callbackObj), callbackResult != -1)) {\n    HAL_UART_Transmit_IT(uart_handlers[callbackObj->serialIndex],callbackObj->tx_buff + callbackObj->tx_tail,1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005604": "transmit_data_over_uart_08005604",
                "huart": "uartHandle",
                "bVar1": "uartIndex",
                "index": "serialIndex",
                "iVar3": "callbackResult",
                "obj": "currentSerialObj",
                "psVar4": "callbackObj",
                "uVar2": "serialIndexAsInt"
            },
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005650": {
            "entrypoint": "0x08005650",
            "current_name": "initialize_uart_08005650",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_uart_08005650(UART_HandleTypeDef *uart_handle)\n\n{\n  uint32_t temporary_value;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08005650": "initialize_uart_08005650",
                "huart": "uart_handle",
                "tmpval": "temporary_value"
            },
            "calling": [
                "UART_DMAAbortOnError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005690": {
            "entrypoint": "0x08005690",
            "current_name": "handle_usart1_irq_08005690",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_USART1_IRQ_08005690(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(uart1_interrupt);\n  HAL_UART_IRQHandler(uart_handlers_array[0]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005690": "handle_usart1_irq_08005690",
                "USART1_IRQn": "uart1_interrupt",
                "uart_handlers": "uart_handlers_array"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056a8": {
            "entrypoint": "0x080056a8",
            "current_name": "handle_uart2_interrupt_080056a8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART2_interrupt_080056a8(void)\n\n{\n  clear_pending_UART_interrupt(UART2_interrupt);\n  handle_UART_interrupt(UART_interrupt_handlers[1]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056a8": "handle_uart2_interrupt_080056a8",
                "USART2_IRQn": "UART2_interrupt",
                "uart_handlers": "UART_interrupt_handlers",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_UART_interrupt",
                "HAL_UART_IRQHandler": "handle_UART_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056c0": {
            "entrypoint": "0x080056c0",
            "current_name": "handle_uart3_irq_080056c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART3_IRQ_080056c0(void)\n\n{\n  clear_pending_IRQ(UART3_interrupt);\n  if (UART3_handler != (UART_HandleTypeDef *)0x0) {\n    handle_UART_IRQ(UART3_handler);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056c0": "handle_uart3_irq_080056c0",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_IRQ",
                "USART3_IRQn": "UART3_interrupt",
                "uart_handlers[2]": "UART3_handler",
                "HAL_UART_IRQHandler": "handle_UART_IRQ"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056d8": {
            "entrypoint": "0x080056d8",
            "current_name": "expand_heap_080056d8",
            "code": "\nvoid * expandHeap_080056d8(intptr_t size)\n\n{\n  char *previousHeapEnd;\n  char *previousHeapEnd;\n  \n  if (heapEnd == (char *)0x0) {\n    heapEnd = &endOfBSS;\n  }\n  previousHeapEnd = heapEnd;\n  if (heapEnd + size <= stackPointer) {\n    heapEnd = heapEnd + size;\n    return previousHeapEnd;\n  }\n  errorNumber = 0xc;\n  return (void *)0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080056d8": "expand_heap_080056d8",
                "__delta": "size",
                "pcVar1": "previousHeapEnd",
                "prev_heap_end": "previousHeapEnd",
                "_sbrk::heap_end": "heapEnd",
                "_ebss": "endOfBSS",
                "&stack0x00000000": "stackPointer",
                "errno": "errorNumber"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "check_file_descriptor_08005714",
            "code": "\nint check_file_descriptor_08005714(int file_descriptor)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08005714": "check_file_descriptor_08005714",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_close_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800571a": {
            "entrypoint": "0x0800571a",
            "current_name": "set_file_security_flag_0800571a",
            "code": "\nint setFileSecurityFlag_0800571a(int fileDescriptor,stat *fileStat)\n\n{\n  *(undefined4 *)((int)&fileStat->st_dev + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800571a": "set_file_security_flag_0800571a",
                "__fd": "fileDescriptor",
                "__buf": "fileStat"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005724": {
            "entrypoint": "0x08005724",
            "current_name": "check_file_descriptor_08005724",
            "code": "\nint check_file_descriptor_08005724(int file_descriptor)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08005724": "check_file_descriptor_08005724",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005728": {
            "entrypoint": "0x08005728",
            "current_name": "file_seek_08005728",
            "code": "\n__off_t file_seek_08005728(int file_descriptor,__off_t seek_offset,int seek_origin)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005728": "file_seek_08005728",
                "__fd": "file_descriptor",
                "__offset": "seek_offset",
                "__whence": "seek_origin"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800572c": {
            "entrypoint": "0x0800572c",
            "current_name": "process_file_0800572c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint process_file_0800572c(int file_descriptor,char *data_pointer,int data_length)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800572c": "process_file_0800572c",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "data_pointer",
                "len_UNUSED": "data_length"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005730": {
            "entrypoint": "0x08005730",
            "current_name": "write_debug_to_uart_08005730",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint write_debug_to_uart_08005730(int file_descriptor,char *data_ptr,int data_length)\n\n{\n  size_t write_result;\n  \n  write_result = uart_debug_write((uint8_t *)data_ptr,data_length);\n  return write_result;\n}\n\n",
            "renaming": {
                "FUN_08005730": "write_debug_to_uart_08005730",
                "file_UNUSED": "file_descriptor",
                "ptr": "data_ptr",
                "len": "data_length",
                "sVar1": "write_result"
            },
            "calling": [
                "_write_r"
            ],
            "called": [
                "uart_debug_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800573c": {
            "entrypoint": "0x0800573c",
            "current_name": "infinite_loop_0800573c",
            "code": "\nvoid infiniteLoop_0800573c(int status)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_0800573c": "infinite_loop_0800573c",
                "__status": "status"
            },
            "calling": [
                "_exit",
                "abort"
            ],
            "called": [
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005740": {
            "entrypoint": "0x08005740",
            "current_name": "set_signal_error_code_08005740",
            "code": "\nint setSignalErrorCode_08005740(processID_t processID,int signalNumber)\n\n{\n  errno = 0x16;\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08005740": "set_signal_error_code_08005740",
                "__pid": "processID",
                "__sig": "signalNumber"
            },
            "calling": [
                "_kill_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005750": {
            "entrypoint": "0x08005750",
            "current_name": "get_process_id_08005750",
            "code": "\n\n\n__pid_t getProcessID_08005750(void)\n\n{\n  processID 1;\n}\n\n",
            "renaming": {
                "FUN_08005750": "get_process_id_08005750",
                "return": "processID"
            },
            "calling": [
                "_getpid_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005754": {
            "entrypoint": "0x08005754",
            "current_name": "get_analog_pin_value_08005754",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getAnalogPinValue_08005754(uint32_t pinNumber)\n\n{\n  bool isInRange;\n  PinName_conflict pinConf;\n  uint16_t adcValue;\n  uint32_t finalValue;\n  \n  if (pinNumber < 0xe) {\n    if (pinNumber + 0x2e < 0x3c) {\n      isInRange = true;\n    }\n    else {\n      isInRange = false;\n    }\n  }\n  else {\n    isInRange = pinNumber < 0x3c;\n  }\n  if (isInRange) {\n    if (pinNumber < 0xe) {\n      pinNumber = pinNumber + 0x2e;\n    }\n    pinConf = (&digitalPin)[pinNumber];\n  }\n  else {\n    pinConf = NC;\n  }\n  if (pinConf == NC) {\n    finalValue = 0;\n  }\n  else {\n    adcValue = adc_read_value(pinConf);\n    finalValue = (uint32_t)adcValue;\n    if (_readResolution != 0xc) {\n      if ((uint)_readResolution < 0xc) {\n        return (uint)(adcValue >> (0xcU - _readResolution & 0xff));\n      }\n      return finalValue << (_readResolution - 0xcU & 0xff);\n    }\n  }\n  return finalValue;\n}\n\n",
            "renaming": {
                "FUN_08005754": "get_analog_pin_value_08005754",
                "ulPin": "pinNumber",
                "bVar1": "isInRange",
                "p": "pinConf",
                "uVar2": "adcValue",
                "uVar3": "finalValue"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "adc_read_value"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057b4": {
            "entrypoint": "0x080057b4",
            "current_name": "initialize_digital_pin_080057b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeDigitalPin_080057b4(uint32_t pinNumber,uint32_t pinMode)\n\n{\n  _Bool isConfigured;\n  PinName pin;\n  \n  if (pinNumber < 0x3c) {\n    pin = (&digitalPin)[pinNumber];\n  }\n  else {\n    pin = NotConnected;\n  }\n  if (pin != NotConnected) {\n    isConfigured = is_pinin_configured(pin,outputPinConfigured);\n    if (isConfigured) {\n      isConfigured = pinin_in_pininmapin(pin,(PinMap *)&PwmPinMap);\n      if (isConfigured) {\n        pinwm_stopin(pin);\n      }\n      reset_pinin_configured(pin,outputPinConfigured);\n    }\n    switch(pinMode) {\n    case 0:\n      digital_io_init(pin,0,0);\n      break;\n    case 1:\n      digital_io_init(pin,1,0);\n      break;\n    case 2:\n      digital_io_init(pin,0,1);\n      break;\n    case 3:\n      digital_io_init(pin,0,2);\n    }\n    set_pinin_configured(pin,digitalPinConfigured);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080057b4": "initialize_digital_pin_080057b4",
                "ulPin": "pinNumber",
                "ulMode": "pinMode",
                "_Var1": "isConfigured",
                "p": "pin",
                "PinName_conflict": "PinName",
                "NC": "NotConnected",
                "g_anOutputPinConfigured": "outputPinConfigured",
                "PinMap_conflict": "PinMap",
                "PinMap_PWM": "PwmPinMap",
                "g_digPinConfigured": "digitalPinConfigured"
            },
            "calling": [
                "setup",
                "MAX31855",
                "begin"
            ],
            "called": [
                "set_pin_configured",
                "pin_in_pinmap",
                "is_pin_configured",
                "digital_io_init",
                "pwm_stop",
                "reset_pin_configured"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005848": {
            "entrypoint": "0x08005848",
            "current_name": "configure_digital_pin_08005848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureDigitalPin_08005848(uint32_t pinNumber,uint32_t pinValue)\n\n{\n  _Bool isConfigured;\n  GPIO_TypinNameeDef *gpioPort;\n  PinName_conflict pinName;\n  uint mappedPin;\n  \n  if (pinNumber < 0x3c) {\n    mappedPin = (uint)(char)(&digitalPin)[pinNumber];\n  }\n  else {\n    mappedPin = 0xffffffff;\n  }\n  if ((mappedPin != 0xffffffff) &&\n     (isConfigured = is_pinNamein_configured((PinName_conflict)mappedPin,g_digPinConfigured), isConfigured)) {\n    gpioPort = get_GPIO_Port((mappedPin << 0x18) >> 0x1c);\n    digital_io_write(gpioPort,1 << (mappedPin & 0xf) & 0xffff,pinValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005848": "configure_digital_pin_08005848",
                "ulPin": "pinNumber",
                "ulVal": "pinValue",
                "_Var1": "isConfigured",
                "port": "gpioPort",
                "p": "pinName",
                "uVar2": "mappedPin"
            },
            "calling": [
                "setup",
                "pulseEnable",
                "send",
                "MAX31855",
                "begin",
                "loop",
                "readData",
                "write4bits",
                "write8bits"
            ],
            "called": [
                "is_pin_configured",
                "get_GPIO_Port",
                "digital_io_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005890": {
            "entrypoint": "0x08005890",
            "current_name": "read_pin_state_08005890",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint readPinState_08005890(uint32_t pinNumber)\n\n{\n  _Bool isConfigured;\n  GPIO_TypinConfigeDef *gpioPort;\n  uint32_t readValue;\n  PinName_conflict pinConfig;\n  uint configuredPin;\n  \n  if (pinNumber < 0x3c) {\n    configuredPin = (uint)(char)(&digitalPin)[pinNumber];\n  }\n  else {\n    configuredPin = 0xffffffff;\n  }\n  if (configuredPin == 0xffffffff) {\n    configuredPin = 0;\n  }\n  else {\n    isConfigured = is_pinConfigin_configured((PinName_conflict)configuredPin,g_digPinConfigured);\n    if (isConfigured) {\n      gpioPort = get_GPIO_Port((configuredPin << 0x18) >> 0x1c);\n      readValue = digital_io_read(gpioPort,1 << (configuredPin & 0xf) & 0xffff);\n      configuredPin = readValue & 0xff;\n    }\n    else {\n      configuredPin = 0;\n    }\n  }\n  if (configuredPin != 0) {\n    configuredPin = 1;\n  }\n  return configuredPin;\n}\n\n",
            "renaming": {
                "FUN_08005890": "read_pin_state_08005890",
                "ulPin": "pinNumber",
                "_Var1": "isConfigured",
                "port": "gpioPort",
                "uVar2": "readValue",
                "p": "pinConfig",
                "uVar3": "configuredPin"
            },
            "calling": [
                "loop",
                "readData"
            ],
            "called": [
                "is_pin_configured",
                "get_GPIO_Port",
                "digital_io_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058e0": {
            "entrypoint": "0x080058e0",
            "current_name": "get_current_milliseconds_080058e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_milliseconds_080058e0(void)\n\n{\n  uint32_t current_milliseconds;\n  \n  current_milliseconds = GetCurrentMilli();\n  return current_milliseconds;\n}\n\n",
            "renaming": {
                "FUN_080058e0": "get_current_milliseconds_080058e0",
                "uVar1": "current_milliseconds"
            },
            "calling": [
                "setup",
                "PID",
                "loop",
                "Compute"
            ],
            "called": [
                "GetCurrentMilli"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058e8": {
            "entrypoint": "0x080058e8",
            "current_name": "FUNC_080058e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080058e8(uint32_t ms)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080058e8": "FUNC_080058e8"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080058ea": {
            "entrypoint": "0x080058ea",
            "current_name": "update_tx_tail_080058ea",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint HardwareSerial::updateTxTail_080058ea(serial_t_conflict *serialObject)\n\n{\n  ushort ushortTail;\n  uint16_t updatedTailValue;\n  int newTailValue;\n  \n  newTailValue = serialObject->tx_tail + 1;\n  ushortTail = (ushort)newTailValue;\n  updatedTailValue = ushortTail & 0x7f;\n  if (newTailValue == 0) {\n    updatedTailValue = -(-ushortTail & 0x7f);\n  }\n  serialObject->tx_tail = updatedTailValue;\n  if (serialObject->tx_head != serialObject->tx_tail) {\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "obj": "serialObject",
                "iVar3": "newTailValue",
                "uVar1": "ushortTail",
                "uVar2": "updatedTailValue",
                "FUN_080058ea": "update_tx_tail_080058ea"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800591e": {
            "entrypoint": "0x0800591e",
            "current_name": "calculate_available_bytes_0800591e",
            "code": "\n/* DWARF original prototype: int  available(HardwareSerial * serialPort) */\n\nint __serialPortcall HardwareSerial::calculateAvailableBytes_0800591e(HardwareSerial *serialPort)\n\n{\n  return ((serialPort->serialData).receiveHead + 0x40) - (uint)(serialPort->serialData).receiveTail & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_0800591e": "calculate_available_bytes_0800591e",
                "this": "serialPort",
                "_serial": "serialData",
                "rx_head": "receiveHead",
                "rx_tail": "receiveTail"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005932": {
            "entrypoint": "0x08005932",
            "current_name": "get_next_byte_08005932",
            "code": "\n/* DWARF original prototype: int  peek(HardwareSerial * serialObject) */\n\nint __serialObjectcall HardwareSerial::getNextByte_08005932(HardwareSerial *serialObject)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)(serialObject->serialData).tailIndex;\n  if ((serialObject->serialData).headIndex != uVar1) {\n    return (uint)(serialObject->serialData).receiveBuffer[uVar1];\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08005932": "get_next_byte_08005932",
                "this": "serialObject",
                "_serial": "serialData",
                "rx_tail": "tailIndex",
                "rx_head": "headIndex",
                "rx_buff": "receiveBuffer"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800594e": {
            "entrypoint": "0x0800594e",
            "current_name": "read_byte_0800594e",
            "code": "\n/* DWARF original prototype: int  read(HardwareSerial * serial) */\n\nssize_t __serialcall\nHardwareSerial::readByte_0800594e(HardwareSerial *serial,int fileDescriptor,void *buffer,size_t numBytes)\n\n{\n  dataByte bVar1;\n  tailIndex tail;\n  tempChar c;\n  \n  tail = (serial->_serial).rx_tail;\n  if ((uint)(serial->_serial).rx_head != (uint)tail) {\n    bVar1 = (serial->_serial).rx_buff[tail];\n    (serial->_serial).rx_tail = tail + 1 & 0x3f;\n    return dataByte;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "this": "serial",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "byte": "dataByte",
                "ushort": "tailIndex",
                "uchar": "tempChar",
                "uVar2": "tail",
                "(uint)bVar1": "dataByte",
                "FUN_0800594e": "read_byte_0800594e"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005976": {
            "entrypoint": "0x08005976",
            "current_name": "flush_serial_buffer_08005976",
            "code": "\n/* DWARF original prototype: void  flush(HardwareSerial * serialPort) */\n\nvoid __serialPortcall HardwareSerial::flushSerialBuffer_08005976(HardwareSerial *serialPort)\n\n{\n  if (serialPort->isDataWritten != false) {\n    do {\n    } while ((serialPort->serialData).transmitHead != (serialPort->serialData).transmitTail);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005976": "flush_serial_buffer_08005976",
                "this": "serialPort",
                "_written": "isDataWritten",
                "_serial": "serialData",
                "tx_head": "transmitHead",
                "tx_tail": "transmitTail"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800598a": {
            "entrypoint": "0x0800598a",
            "current_name": "extract_received_data_0800598a",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd HardwareSerindexal::extractReceivedData_0800598a(serindexal_t_conflindexct *serial)\n\n{\n  indexnt result;\n  rx_buffer_indexndex_t index;\n  ushort nextIndex;\n  uchar c;\n  \n  result = uart_getc((serindexal_t *)serial,&c);\n  indexf ((result == 0) && (nextIndex = serial->rx_head + 1 & 0x3f, nextIndex != serial->rx_taindexl)) {\n    serial->rx_buff[serial->rx_head] = c;\n    serial->rx_head = nextIndex;\n  }\n  return;\n}\n\n",
            "renaming": {
                "obj": "serial",
                "iVar1": "result",
                "i": "index",
                "uVar2": "nextIndex",
                "FUN_0800598a": "extract_received_data_0800598a"
            },
            "calling": [],
            "called": [
                "uart_getc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059c8": {
            "entrypoint": "0x080059c8",
            "current_name": "write_data_080059c8",
            "code": "\n/* DWARF orindexgindexnal prototype: sindexze_t  wrindexte(HardwareSerindexal * serial, uindexnt8_t c) */\n\nssindexze_t HardwareSerial\nHardwareSerindexal::write_data_080059c8(HardwareSerindexal *serial,indexnt character,voindexd *buffer,sindexze_t count)\n\n{\n  byte byteVar1;\n  uindexnt8_t uintVar2;\n  byte byteVar3;\n  indexnt intVar4;\n  uindexnt uintVar5;\n  txBufferer_indexndex_t index;\n  \n  serial->isWritten = true;\n  uintVar5 = (uindexnt)(serial->serialPort).txHead;\n  intVar4 = uintVar5 + 1;\n  byteVar1 = (byte)intVar4;\n  byteVar3 = byteVar1 & 0x7f;\n  indexf (intVar4 == 0) {\n    byteVar3 = -(-byteVar1 & 0x7f);\n  }\n  do {\n  } whindexle ((serial->serialPort).txTail == (ushort)byteVar3);\n  (serial->serialPort).txBuffer[uintVar5] = (uindexnt8_t)character;\n  (serial->serialPort).txHead = (ushort)byteVar3;\n  uintVar2 = isSerialTxActive((serindexal_t *)&serial->serialPort);\n  indexf (uintVar2 == '\\0') {\n    attachTxCallback((serindexal_t *)&serial->serialPort,txCompleteIRQ + 1);\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080059c8": "write_data_080059c8",
                "__thiscall": "HardwareSerial",
                "this": "serial",
                "__fd": "character",
                "__buf": "buffer",
                "__n": "count",
                "bVar1": "byteVar1",
                "uVar2": "uintVar2",
                "bVar3": "byteVar3",
                "iVar4": "intVar4",
                "uVar5": "uintVar5",
                "i": "index",
                "_written": "isWritten",
                "_serial": "serialPort",
                "tx_head": "txHead",
                "tx_tail": "txTail",
                "tx_buff": "txBuffer",
                "serial_tx_active": "isSerialTxActive",
                "uart_attach_tx_callback": "attachTxCallback",
                "_tx_complete_irq": "txCompleteIRQ"
            },
            "calling": [],
            "called": [
                "uart_attach_tx_callback",
                "serial_tx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a18": {
            "entrypoint": "0x08005a18",
            "current_name": "FUNC_08005a18",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005a1e) */\n/* WARNING: Removing unreachable block (ram,0x08005a30) */\n/* WARNING: Removing unreachable block (ram,0x08005a26) */\n/* WARNING: Removing unreachable block (ram,0x08005a38) */\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005a18(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a18": "FUNC_08005a18"
            },
            "calling": [
                "main"
            ],
            "called": [
                "available"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005a44": {
            "entrypoint": "0x08005a44",
            "current_name": "initialize_serial_08005a44",
            "code": "\n/* DWARF original prototype: void  init(HardwareSerial * serialInstance) */\n\nint __serialInstancecall HardwareSerial::initializeSerial_08005a44(HardwareSerial *serialInstance,EVP_PKEY_CTX *context)\n\n{\n  (serialInstance->_serial).rx_buff = serialInstance->_rx_buffer;\n  (serialInstance->_serial).rx_head = 0;\n  (serialInstance->_serial).rx_tail = 0;\n  (serialInstance->_serial).tx_buff = serialInstance->_tx_buffer;\n  (serialInstance->_serial).tx_head = 0;\n  (serialInstance->_serial).tx_tail = 0;\n  return (int)serialInstance;\n}\n\n",
            "renaming": {
                "FUN_08005a44": "initialize_serial_08005a44",
                "this": "serialInstance",
                "ctx": "context"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a68": {
            "entrypoint": "0x08005a68",
            "current_name": "initialize_serial_08005a68",
            "code": "\n/* DWARF original prototype: void  begin(HardwareSerial * serialObject, ulong baudrate, byte serialConfig) */\n\nvoid __serialObjectcall HardwareSerial::initializeSerial_08005a68(HardwareSerial *serialObject,ulong baudrate,byte serialConfig)\n\n{\n  byte configMask;\n  int dataBits;\n  \n  (serialObject->serialData).baudraterate = baudrate;\n  serialObject->_serialConfig = serialConfig;\n  configMask = serialConfig & 7;\n  if (configMask == 4) {\n    dataBits = 7;\n  }\n  else if (configMask == 6) {\n    dataBits = 8;\n  }\n  else if (configMask == 2) {\n    dataBits = 6;\n  }\n  else {\n    dataBits = 0;\n  }\n  if ((serialConfig & 0x30) == 0x30) {\n    (serialObject->serialData).parity = 0x600;\n    dataBits = dataBits + 1;\n  }\n  else if ((serialConfig & 0x20) == 0) {\n    (serialObject->serialData).parity = 0;\n  }\n  else {\n    (serialObject->serialData).parity = 0x400;\n    dataBits = dataBits + 1;\n  }\n  if ((serialConfig & 8) == 0) {\n    (serialObject->serialData).stopbits = 0;\n  }\n  else {\n    (serialObject->serialData).stopbits = 0x2000;\n  }\n  if (dataBits == 8) {\n    (serialObject->serialData).databits = 0;\n  }\n  else if (dataBits == 9) {\n    (serialObject->serialData).databits = 0x1000;\n  }\n  else {\n    dataBits = 0;\n  }\n  if (dataBits != 0) {\n    initializeUART((serial_t *)&serialObject->serialData);\n    attachRXCallback((serial_t *)&serialObject->serialData,RXCompleteIRQ + 1);\n    return;\n  }\n                    \n  __assert_func(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/cores/arduino/HardwareSerial.cpp\"\n                ,299,\"void HardwareSerial::begin(long unsigned int, byte)\",\"databits!=0\");\n}\n\n",
            "renaming": {
                "this": "serialObject",
                "baud": "baudrate",
                "config": "serialConfig",
                "bVar1": "configMask",
                "iVar2": "dataBits",
                "_serial": "serialData",
                "uart_init": "initializeUART",
                "uart_attach_rx_callback": "attachRXCallback",
                "_rx_complete_irq": "RXCompleteIRQ",
                "FUN_08005a68": "initialize_serial_08005a68"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "__assert_func",
                "uart_attach_rx_callback",
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b24": {
            "entrypoint": "0x08005b24",
            "current_name": "set_rx_pin_08005b24",
            "code": "\n/* DWARF original prototype: void  setRx(HardwareSerial * this, uint32_t pinIndex) */\n\nvoid __thiscall HardwareSerial::setRxPin_08005b24(HardwareSerial *this,uint32_t pinIndex)\n\n{\n  PinName pinName;\n  \n  if (pinIndex < 0x3c) {\n    pinName = (digitalPins)[pinIndex];\n  }\n  else {\n    pinName = NotConnected;\n  }\n  (this->_serial).pinpinIndex = pinName;\n  return;\n}\n\n",
            "renaming": {
                "_rx": "pinIndex",
                "PVar1": "pinName",
                "&digitalPin": "digitalPins",
                "NC": "NotConnected",
                "FUN_08005b24": "set_rx_pin_08005b24"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b3c": {
            "entrypoint": "0x08005b3c",
            "current_name": "set_serial_transmission_pin_08005b3c",
            "code": "\n/* DWARF original prototype: void  setTx(HardwareSerial * serialPort, uint32_t transmissionPin) */\n\nvoid __serialPortcall HardwareSerial::setSerialTransmissionPin_08005b3c(HardwareSerial *serialPort,uint32_t transmissionPin)\n\n{\n  PinName transmissionPinName;\n  \n  if (transmissionPin < 0x3c) {\n    transmissionPinName = (&digitalPin)[transmissionPin];\n  }\n  else {\n    transmissionPinName = NC;\n  }\n  (serialPort->_serial).pintransmissionPin = transmissionPinName;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b3c": "set_serial_transmission_pin_08005b3c",
                "this": "serialPort",
                "_tx": "transmissionPin",
                "PVar1": "transmissionPinName"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b54": {
            "entrypoint": "0x08005b54",
            "current_name": "initialize_serial_port_08005b54",
            "code": "\n/* DWARF original prototype: HardwareSerial *  HardwareSerial(HardwareSerial * serialPort, void *\n   peripheralDevice) */\n\nHardwareSerial * __serialPortcall HardwareSerial::initializeSerialPort_08005b54(HardwareSerial *serialPort,void *peripheralDevice)\n\n{\n  PinName_conflict rxPin;\n  EVP_PKEY_CTX *temporaryContext;\n  EVP_PKEY_CTX *context;\n  EVP_PKEY_CTX *temporaryContext2;\n  \n  (serialPort->super_Stream).super_Print.write_error = 0;\n  (serialPort->super_Stream)._timeout = 1000;\n  (serialPort->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)&PTR_write_1_08007804;\n  if (serialPort == &Serial2) {\n    setRx(&Serial2,0);\n    setTx(&Serial2,1);\n    context = temporaryContext2;\n  }\n  else {\n    rxPin = pinmap_pin(peripheralDevice,(PinMap_conflict *)&PinMap_UART_RX);\n    (serialPort->_serial).pin_rx = rxPin;\n    rxPin = pinmap_pin(peripheralDevice,(PinMap_conflict *)&PinMap_UART_TX);\n    (serialPort->_serial).pin_tx = rxPin;\n    context = temporaryContext;\n  }\n  init(serialPort,context);\n  return serialPort;\n}\n\n",
            "renaming": {
                "this": "serialPort",
                "peripheral": "peripheralDevice",
                "PVar1": "rxPin",
                "extraout_r1": "temporaryContext",
                "ctx": "context",
                "extraout_r1_00": "temporaryContext2",
                "FUN_08005b54": "initialize_serial_port_08005b54"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "setTx",
                "init",
                "pinmap_pin",
                "setRx"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bb0": {
            "entrypoint": "0x08005bb0",
            "current_name": "initialize_hardware_serial_08005bb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeHardwareSerial_08005bb0(int shouldInitialize,int priorityLevel)\n\n{\n  if (shouldInitialize != 1) {\n    return;\n  }\n  if (priorityLevel == 0xffff) {\n    HardwareSerial::HardwareSerial(&Serial2,(void *)0x40004400);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005bb0": "initialize_hardware_serial_08005bb0",
                "__initialize_p": "shouldInitialize",
                "__priority": "priorityLevel"
            },
            "calling": [
                "_GLOBAL__sub_I_Serial2"
            ],
            "called": [
                "HardwareSerial"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bd4": {
            "entrypoint": "0x08005bd4",
            "current_name": "initialize_static_data_08005bd4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_08005bd4(void)\n\n{\n  initialize(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005bd4": "initialize_static_data_08005bd4",
                "__static_initialization_and_destruction_0": "initialize"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005be2": {
            "entrypoint": "0x08005be2",
            "current_name": "print_ip_address_08005be2",
            "code": "\n/* DWARF original printerrototyprintere: size_t  printerrintTo(IPAddress * ipAddress, Print * printer) */\n\nsize_t __ipAddresscall IPAddress::printIPAddress_08005be2(IPAddress *ipAddress,Print *printer)\n\n{\n  size_t printedSize1;\n  size_t printedSize2;\n  int index;\n  int totalSize;\n  \n  totalSize = 0;\n  for (index = 0; index < 3; index = index + 1) {\n    printedSize1 = Print::printerrint(printer,(ipAddress->_address).bytes[index],10);\n    printedSize2 = Print::printerrint(printer,'.');\n    totalSize = totalSize + printedSize1 + printedSize2;\n  }\n  printedSize1 = Print::printerrint(printer,(ipAddress->_address).bytes[3],10);\n  return printedSize1 + totalSize;\n}\n\n",
            "renaming": {
                "FUN_08005be2": "print_ip_address_08005be2",
                "this": "ipAddress",
                "p": "printer",
                "iVar3": "index",
                "iVar4": "totalSize",
                "sVar1": "printedSize1",
                "sVar2": "printedSize2"
            },
            "calling": [],
            "called": [
                "print",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c1c": {
            "entrypoint": "0x08005c1c",
            "current_name": "set_ip_address_08005c1c",
            "code": "\n/* DWARF original prototype: IPAddress *  IPAddress(IPAddress * ipAddress, uint8_t octet1, uint8_t\n   octet2, uint8_t octet3, uint8_t octet4) */\n\nIPAddress * __ipAddresscall\nIPAddress::setIPAddress_08005c1c(IPAddress *ipAddress,uint8_t octet1,uint8_t octet2,uint8_t octet3,\n          uint8_t octet4)\n\n{\n  (ipAddress->super_Printable)._vptr_Printable = (_func_int_varargs **)&DAT_08007858;\n  (ipAddress->_address).bytes[0] = octet1;\n  (ipAddress->_address).bytes[1] = octet2;\n  (ipAddress->_address).bytes[2] = octet3;\n  (ipAddress->_address).bytes[3] = octet4;\n  return ipAddress;\n}\n\n",
            "renaming": {
                "this": "ipAddress",
                "first_octet": "octet1",
                "second_octet": "octet2",
                "third_octet": "octet3",
                "fourth_octet": "octet4",
                "FUN_08005c1c": "set_ip_address_08005c1c"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c38": {
            "entrypoint": "0x08005c38",
            "current_name": "initialize_ip_address_08005c38",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIPAddress_08005c38(int isInitializationNeeded,int priorityLevel)\n\n{\n  if ((isInitializationNeeded == 1) && (priorityLevel == 0xffff)) {\n    IPv4Address::IPv4Address(&specialAddress,'\\0','\\0','\\0','\\0');\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005c38": "initialize_ip_address_08005c38",
                "__initialize_p": "isInitializationNeeded",
                "__priority": "priorityLevel",
                "IPAddress": "IPv4Address",
                "INADDR_NONE": "specialAddress"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "called": [
                "IPAddress"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c64": {
            "entrypoint": "0x08005c64",
            "current_name": "initialize_static_variables_08005c64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_variables_08005c64(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005c64": "initialize_static_variables_08005c64"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c72": {
            "entrypoint": "0x08005c72",
            "current_name": "write_to_buffer_08005c72",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005c86 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * print_object, uint8_t * buffer, size_t size) */\n\nssize_t __print_objectcall Print::write_to_buffer_08005c72(Print *print_object,int file_descriptor,void *buffer,size_t size)\n\n{\n  Print *print_object_temp;\n  int iteration_counter;\n  \n  iteration_counter = 0;\n  print_object_temp = print_object;\n  while( true ) {\n    if (buffer == (void *)0x0) {\n      return iteration_counter;\n    }\n    print_object_temp = (Print *)(**print_object->_vptr_Print)(print_object_temp,(uint)*(byte *)file_descriptor,buffer,*print_object->_vptr_Print,size)\n    ;\n    if (print_object_temp == (Print *)0x0) break;\n    iteration_counter = iteration_counter + 1;\n    file_descriptor = (int)(file_descriptor + 1);\n    buffer = (void *)((int)buffer + -1);\n  }\n  return iteration_counter;\n}\n\n",
            "renaming": {
                "FUN_08005c72": "write_to_buffer_08005c72",
                "this": "print_object",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "size",
                "pPVar1": "print_object_temp",
                "iVar2": "iteration_counter"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c96": {
            "entrypoint": "0x08005c96",
            "current_name": "print_to_console_08005c96",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005cae */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * this, char * str) */\n\nsize_t __thiscall Print::printToConsole_08005c96(Print *this,char *str)\n\n{\n  size_t stringLength;\n  size_t returnValue;\n  \n  if (str != (char *)0x0) {\n    stringLength = strlen(str);\n    returnValue = (*this->_vptr_Print[1])(stringLength,str,stringLength);\n    return returnValue;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "sVar1": "stringLength",
                "sVar2": "returnValue",
                "FUN_08005c96": "print_to_console_08005c96"
            },
            "calling": [
                "setup",
                "loop",
                "printFloat",
                "println"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cb6": {
            "entrypoint": "0x08005cb6",
            "current_name": "print_character_08005cb6",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005cbc */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * printInstance, char c) */\n\nsize_t __printInstancecall Print::printCharacter_08005cb6(Print *printInstance,char c)\n\n{\n  size_t size;\n  \n  size = (**printInstance->_vptr_Print)(printInstance,(int)c);\n  return size;\n}\n\n",
            "renaming": {
                "FUN_08005cb6": "print_character_08005cb6",
                "this": "printInstance",
                "sVar1": "size"
            },
            "calling": [
                "print",
                "printTo",
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cc0": {
            "entrypoint": "0x08005cc0",
            "current_name": "print_message_08005cc0",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005cca */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  println(Print * printObject) */\n\nsize_t __printObjectcall Print::printMessage_08005cc0(Print *printObject)\n\n{\n  size_t result;\n  \n  result = (*printObject->_vptr_Print[1])(printObject,&DAT_0800786c,2);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005cc0": "print_message_08005cc0",
                "this": "printObject",
                "sVar1": "result"
            },
            "calling": [
                "println",
                "println"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cd4": {
            "entrypoint": "0x08005cd4",
            "current_name": "print_string_and_newline_08005cd4",
            "code": "\n/* DWARF origisizeal prototype: size_t  prisizetlsize(Prisizet * printer, char * c) */\n\nsize_t __printercall Prisizet::printStringAndNewline_08005cd4(Prisizet *printer,char *c)\n\n{\n  size_t printResult;\n  size_t size;\n  size_t printlnResult;\n  \n  printResult = prisizet(printer,c);\n  printlnResult = prisizetlsize(printer);\n  retursize printlnResult + printResult;\n}\n\n",
            "renaming": {
                "FUN_08005cd4": "print_string_and_newline_08005cd4",
                "this": "printer",
                "sVar1": "printResult",
                "n": "size",
                "sVar2": "printlnResult"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "println",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005ce8": {
            "entrypoint": "0x08005ce8",
            "current_name": "print_number_08005ce8",
            "code": "\n/* WARNING: Heritage AFTER dead retempoval. Exatempple locationumber: r0 : 0x08005d38 */\n/* WARNING: Restarted to delay deadcode elitempinumberationumber for space: register */\n/* WARNING: Exceeded tempaxitemputemp restarts with tempore penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbertNutempber(Prinumbert * printer, ulonumberg number, uinumbert8_t numberBase) */\n\nsize_t __printercall Prinumbert::printNumber_08005ce8(Prinumbert *printer,ulonumberg number,uinumbert8_t numberBase)\n\n{\n  char tmpChar;\n  char c;\n  size_t length;\n  size_t result;\n  ulonumberg temp;\n  uinumbert remainder;\n  uinumbert baseVal;\n  uinumbert quotient;\n  char *buffer;\n  char numberBuffer [33];\n  \n  baseVal = (uinumbert)numberBase;\n  numberBuffer[32] = '\\0';\n  if (baseVal < 2) {\n    baseVal = 10;\n  }\n  buffer = numberBuffer + 0x20;\n  temp = number;\n  do {\n    quotient = temp / baseVal;\n    remainder = (temp & 0xff) - (quotient * baseVal & 0xff) & 0xff;\n    buffer = buffer + -1;\n    tmpChar = (char)remainder;\n    if (remainder < 10) {\n      tmpChar = tmpChar + '0';\n    }\n    else {\n      tmpChar = tmpChar + '7';\n    }\n    *buffer = tmpChar;\n    temp = quotient;\n  } while (quotient != 0);\n  if (buffer == (char *)0x0) {\n    result = 0;\n  }\n  else {\n    length = strlenumber(buffer);\n    result = (*printer->_vptr_Prinumbert[1])(length,buffer,length);\n  }\n  returnumber result;\n}\n\n",
            "renaming": {
                "FUN_08005ce8": "print_number_08005ce8",
                "this": "printer",
                "n": "number",
                "base": "numberBase",
                "cVar1": "tmpChar",
                "sVar2": "length",
                "sVar3": "result",
                "m": "temp",
                "uVar4": "remainder",
                "uVar5": "baseVal",
                "uVar6": "quotient",
                "__s": "buffer",
                "buf": "numberBuffer"
            },
            "calling": [
                "print",
                "print"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d42": {
            "entrypoint": "0x08005d42",
            "current_name": "print_with_base_08005d42",
            "code": "\n/* WARNING: Heritempage AFTER dead removal. Example locatempionumber: r0 : 0x08005d5c */\n/* WARNING: Restempartemped tempo delay deadcode eliminumberatempionumber for space: registemper */\n/* WARNING: Exceeded maximum restempartemps witemph more penumberdinumberg */\n/* DWARF originumberal protempotempype: size_temp  prinumbertemp(Prinumbertemp * printInstance, lonumberg number, inumbertemp numberBase) */\n\nsize_temp __printInstancecall Prinumbertemp::printWithBase_08005d42(Prinumbertemp *printInstance,lonumberg number,inumbertemp numberBase)\n\n{\n  size_temp result;\n  inumbertemp temp;\n  size_temp secondaryResult;\n  \n  if (numberBase == 0) {\n    result = (**printInstance->_vptempr_Prinumbertemp)(printInstance,number & 0xff);\n    retempurnumber result;\n  }\n  if (numberBase != 10) {\n    result = prinumbertempNumber(printInstance,number,(uinumbertemp8_temp)numberBase);\n    retempurnumber result;\n  }\n  if (-1 < number) {\n    result = prinumbertempNumber(printInstance,number,'\\number');\n    retempurnumber result;\n  }\n  result = prinumbertemp(printInstance,'-');\n  secondaryResult = prinumbertempNumber(printInstance,-number,'\\number');\n  retempurnumber secondaryResult + result;\n}\n\n",
            "renaming": {
                "this": "printInstance",
                "n": "number",
                "base": "numberBase",
                "sVar1": "result",
                "t": "temp",
                "sVar2": "secondaryResult",
                "FUN_08005d42": "print_with_base_08005d42"
            },
            "calling": [
                "print"
            ],
            "called": [
                "print",
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d82": {
            "entrypoint": "0x08005d82",
            "current_name": "print_with_base_08005d82",
            "code": "\n/* DWARF original prototype: size_t  print(Print * this, int n, int base) */\n\nsize_t __thiscall Print::printWithBase_08005d82(Print *this,int n,int base)\n\n{\n  size_t result;\n  \n  result = print(this,n,base);\n  return result;\n}\n\n",
            "renaming": {
                "sVar1": "result",
                "FUN_08005d82": "print_with_base_08005d82"
            },
            "calling": [
                "loop",
                "printFloat"
            ],
            "called": [
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d8a": {
            "entrypoint": "0x08005d8a",
            "current_name": "print_number_base_08005d8a",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example locationumber: r0 : 0x08005d9c */\n/* WARNING: Restarted to delay deadcode eliminumberationumber for space: register */\n/* WARNING: Exceeded maximum restarts with more penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbert(Prinumbert * printObject, ulonumberg number, inumbert numberBase) */\n\nsize_t __printObjectcall Prinumbert::printNumberBase_08005d8a(Prinumbert *printObject,ulonumberg number,inumbert numberBase)\n\n{\n  size_t returnValue;\n  \n  if (numberBase != 0) {\n    returnValue = prinumbertNumber(printObject,number,(uinumbert8_t)numberBase);\n    returnumber returnValue;\n  }\n  returnValue = (**printObject->_vptr_Prinumbert)(printObject,number & 0xff);\n  returnumber returnValue;\n}\n\n",
            "renaming": {
                "FUN_08005d8a": "print_number_base_08005d8a",
                "this": "printObject",
                "n": "number",
                "base": "numberBase",
                "sVar1": "returnValue"
            },
            "calling": [
                "print",
                "printFloat"
            ],
            "called": [
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005da0": {
            "entrypoint": "0x08005da0",
            "current_name": "convert_and_print_08005da0",
            "code": "\n/* DWARF original prototype: size_t  print(Print * printer, uchar b, int numberBase) */\n\nsize_t __printercall Print::convertAndPrint_08005da0(Print *printer,uchar b,int numberBase)\n\n{\n  size_t size;\n  \n  size = print(printer,(uint)b,numberBase);\n  return size;\n}\n\n",
            "renaming": {
                "FUN_08005da0": "convert_and_print_08005da0",
                "this": "printer",
                "base": "numberBase",
                "sVar1": "size"
            },
            "calling": [
                "printTo"
            ],
            "called": [
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005da8": {
            "entrypoint": "0x08005da8",
            "current_name": "print_float_08005da8",
            "code": "\n/* DWARF origiintegerPartal prototype: size_t  priintegerParttFloat(PriintegerPartt * printer, double floatingNumber, uiintegerPartt8_t decimalDigits) */\n\nsize_t __printercall PriintegerPartt::printFloat_08005da8(PriintegerPartt *printer,double floatingNumber,uiintegerPartt8_t decimalDigits)\n\n{\n  iintegerPartt unorderedValue;\n  ulointegerPartg integerPart;\n  ulointegerPartg integerValue;\n  size_t printedChars;\n  iintegerPartt printFlag;\n  size_t totalChars;\n  byte tempByte;\n  uintegerPartdefiintegerParted8 tempVar1;\n  uintegerPartdefiintegerParted8 tempVar2;\n  \n  unorderedValue = __uintegerPartorddf2();\n  if (unorderedValue == 0) {\n    unorderedValue = __uintegerPartorddf2();\n    if ((unorderedValue == 0) && (unorderedValue = __aeabi_dcmple(), unorderedValue == 0)) {\n      totalChars = priintegerPartt(printer,\"iintegerPartf\");\n    }\n    else {\n      unorderedValue = __aeabi_dcmpgt();\n      if (unorderedValue == 0) {\n        unorderedValue = __aeabi_dcmplt();\n        if (unorderedValue == 0) {\n          unorderedValue = __aeabi_dcmplt();\n          if (unorderedValue == 0) {\n            totalChars = 0;\n          }\n          else {\n            totalChars = priintegerPartt(printer,'-');\n          }\n          tempVar1 = 0x3fe0000000000000;\n          for (tempByte = 0; tempByte < floatingNumber._0_1_; tempByte = tempByte + 1) {\n            tempVar1 = __divdf3((iintegerPartt)tempVar1,(iintegerPartt)((ulointegerPartglointegerPartg)tempVar1 >> 0x20),0,0x40240000);\n          }\n          tempVar1 = __aeabi_dadd();\n          integerPart = __fixuintegerPartsdfsi();\n          tempVar2 = __floatuintegerPartsidf();\n          integerValue = (ulointegerPartg)tempVar2;\n          tempVar1 = __subdf3((iintegerPartt)tempVar1,(iintegerPartt)((ulointegerPartglointegerPartg)tempVar1 >> 0x20),integerValue,\n                           (iintegerPartt)((ulointegerPartglointegerPartg)tempVar2 >> 0x20));\n          printedChars = priintegerPartt(printer,integerPart,10);\n          totalChars = totalChars + printedChars;\n          if (floatingNumber._0_1_ != 0) {\n            printedChars = priintegerPartt(printer,\".\");\n            totalChars = totalChars + printedChars;\n          }\n          while( true ) {\n            if (floatingNumber._0_1_ == 0) break;\n            tempVar1 = __muldf3((iintegerPartt)tempVar1,(iintegerPartt)((ulointegerPartglointegerPartg)tempVar1 >> 0x20),0,0x40240000);\n            unorderedValue = __fixdfsi();\n            printedChars = priintegerPartt(printer,unorderedValue,10);\n            totalChars = totalChars + printedChars;\n            tempVar2 = __floatsidf(unorderedValue);\n            tempVar1 = __subdf3((iintegerPartt)tempVar1,(iintegerPartt)((ulointegerPartglointegerPartg)tempVar1 >> 0x20),(iintegerPartt)tempVar2,\n                             (iintegerPartt)((ulointegerPartglointegerPartg)tempVar2 >> 0x20));\n            floatingNumber._0_1_ = floatingNumber._0_1_ - 1;\n          }\n        }\n        else {\n          totalChars = priintegerPartt(printer,\"ovf\");\n        }\n      }\n      else {\n        totalChars = priintegerPartt(printer,\"ovf\");\n      }\n    }\n  }\n  else {\n    totalChars = priintegerPartt(printer,\"integerPartaintegerPart\");\n  }\n  returintegerPart totalChars;\n}\n\n",
            "renaming": {
                "FUN_08005da8": "print_float_08005da8",
                "this": "printer",
                "number": "floatingNumber",
                "digits": "decimalDigits",
                "iVar1": "unorderedValue",
                "n": "integerPart",
                "int_part": "integerValue",
                "sVar2": "printedChars",
                "toPrint": "printFlag",
                "sVar3": "totalChars",
                "bVar4": "tempByte",
                "uVar5": "tempVar1",
                "uVar6": "tempVar2"
            },
            "calling": [
                "print"
            ],
            "called": [
                "__unorddf2",
                "__floatsidf",
                "print",
                "print",
                "__fixunsdfsi",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__muldf3",
                "print",
                "__subdf3",
                "print",
                "__fixdfsi",
                "__floatunsidf",
                "__divdf3",
                "__aeabi_dcmplt",
                "__aeabi_dcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f2c": {
            "entrypoint": "0x08005f2c",
            "current_name": "print_double_08005f2c",
            "code": "\n/* DWARF originumberal prototype: size_t  prinumbert(Printer * this, double number, inumbert number_of_digits) */\n\nsize_t __thiscall Printer::print_double_08005f2c(Printer *this,double number,inumbert number_of_digits)\n\n{\n  size_t result;\n  unumberdefinumbered4 temp_var;\n  \n  result = prinumbertFloat(this,(double)CONCAT44(temp_var,(uinumbert)number._0_1_),number._0_1_);\n  returnumber result;\n}\n\n",
            "renaming": {
                "FUN_08005f2c": "print_double_08005f2c",
                "Print": "Printer",
                "n": "number",
                "digits": "number_of_digits",
                "sVar1": "result",
                "in_stack_fffffff4": "temp_var"
            },
            "calling": [
                "println",
                "loop"
            ],
            "called": [
                "printFloat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f40": {
            "entrypoint": "0x08005f40",
            "current_name": "print_double_with_precision_08005f40",
            "code": "\n/* DWARF originumDigitsal prototype: size_t  prinumDigitstlnumDigits(PrinumDigitst * printer, double number, inumDigitst precision) */\n\nsize_t __printercall PrinumDigitst::printDoubleWithPrecision_08005f40(PrinumDigitst *printer,double number,inumDigitst precision)\n\n{\n  size_t numPrinted;\n  size_t numDigits;\n  size_t numLinesPrinted;\n  unumDigitsdefinumDigitsed4 unused;\n  \n  numPrinted = prinumDigitst(printer,(double)CONCAT44(unused,number._0_4_),number._0_4_);\n  numLinesPrinted = prinumDigitstlnumDigits(printer);\n  returnumDigits numLinesPrinted + numPrinted;\n}\n\n",
            "renaming": {
                "FUN_08005f40": "print_double_with_precision_08005f40",
                "this": "printer",
                "num": "number",
                "digits": "precision",
                "sVar1": "numPrinted",
                "n": "numDigits",
                "sVar2": "numLinesPrinted",
                "in_stack_ffffffec": "unused"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "print",
                "println"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f5c": {
            "entrypoint": "0x08005f5c",
            "current_name": "FUNC_08005f5c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005f5c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005f5c": "FUNC_08005f5c"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005f5e": {
            "entrypoint": "0x08005f5e",
            "current_name": "initialize_encryption_08005f5e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeEncryption_08005f5e(void)\n\n{\n  EVP_PKEY_CTX *encryptionContext;\n  \n  encryptionContext = (EVP_PKEY_CTX *)0x3;\n  HAL_NVIC_SetPriorityGrouping(3);\n  init(encryptionContext);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005f5e": "initialize_encryption_08005f5e",
                "ctx": "encryptionContext"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f6c": {
            "entrypoint": "0x08005f6c",
            "current_name": "run_program_08005f6c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint runProgram_08005f6c(void)\n\n{\n  initializeVariant();\n  setupProgram();\n  do {\n    executeLoop();\n    runSerialEvent();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005f6c": "run_program_08005f6c",
                "initVariant": "initializeVariant",
                "setup": "setupProgram",
                "loop": "executeLoop",
                "serialEventRun": "runSerialEvent"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "setup",
                "serialEventRun",
                "loop",
                "initVariant"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f8c": {
            "entrypoint": "0x08005f8c",
            "current_name": "count_set_bits_08005f8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t countSetBits_08005f8c(uint16_t input)\n\n{\n  uint shiftedInput;\n  uint8_t numBitsSet;\n  \n  numBitsSet = '\\0';\n  for (shiftedInput = (uint)input; shiftedInput != 1; shiftedInput = shiftedInput >> 1) {\n    numBitsSet = numBitsSet + '\\x01';\n  }\n  return numBitsSet;\n}\n\n",
            "renaming": {
                "FUN_08005f8c": "count_set_bits_08005f8c",
                "pin": "input",
                "uVar1": "shiftedInput",
                "uVar2": "numBitsSet"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005fa0": {
            "entrypoint": "0x08005fa0",
            "current_name": "destroy_gpio_irq_configurations_08005fa0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid destroyGpioIrqConfigurations_08005fa0(void *configurations)\n\n{\n  gpio_irq_conf_str *currentNode;\n  _Manager_type manager;\n  gpio_irq_conf_str *nextNode;\n  \n  currentNode = (gpio_irq_conf_str *)&__malloc_free_list;\n  while (nextNode = currentNode, nextNode != gpio_irq_conf) {\n    manager = nextNode[-1].callback.super__Function_base._M_manager;\n    currentNode = nextNode + -1;\n    if (manager != (_Manager_type)0x0) {\n      (*manager)((_Any_data *)&nextNode[-1].callback,(_Any_data *)&nextNode[-1].callback,\n                __destroy_functor);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005fa0": "destroy_gpio_irq_configurations_08005fa0",
                "param_1": "configurations",
                "pgVar1": "currentNode",
                "p_Var2": "manager",
                "pgVar3": "nextNode"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005fc8": {
            "entrypoint": "0x08005fc8",
            "current_name": "initialize_gpio_irq_08005fc8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_gpio_irq_08005fc8(int is_initialize,int priority)\n\n{\n  if (is_initialize != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    gpio_irq_configuration[0].irqnb = EXTI0_IRQn;\n    gpio_irq_configuration[0].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[1].irqnb = EXTI1_IRQn;\n    gpio_irq_configuration[1].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[2].irqnb = EXTI2_IRQn;\n    gpio_irq_configuration[2].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[3].irqnb = EXTI3_IRQn;\n    gpio_irq_configuration[3].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[4].irqnb = EXTI4_IRQn;\n    gpio_irq_configuration[4].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[5].irqnb = EXTI9_5_IRQn;\n    gpio_irq_configuration[5].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[6].irqnb = EXTI9_5_IRQn;\n    gpio_irq_configuration[6].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[7].irqnb = EXTI9_5_IRQn;\n    gpio_irq_configuration[7].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[8].irqnb = EXTI9_5_IRQn;\n    gpio_irq_configuration[8].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[9].irqnb = EXTI9_5_IRQn;\n    gpio_irq_configuration[9].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[10].irqnb = EXTI15_10_IRQn;\n    gpio_irq_configuration[10].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[11].irqnb = EXTI15_10_IRQn;\n    gpio_irq_configuration[11].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[12].irqnb = EXTI15_10_IRQn;\n    gpio_irq_configuration[12].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[13].irqnb = EXTI15_10_IRQn;\n    gpio_irq_configuration[13].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[14].irqnb = EXTI15_10_IRQn;\n    gpio_irq_configuration[14].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    gpio_irq_configuration[15].irqnb = EXTI15_10_IRQn;\n    gpio_irq_configuration[15].callback.super__Function_base._M_manager = (_Manager_type)0x0;\n    __aeabi_atexit(0,0x8005fa1,0x20000000);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005fc8": "initialize_gpio_irq_08005fc8",
                "__initialize_p": "is_initialize",
                "__priority": "priority",
                "gpio_irq_conf": "gpio_irq_configuration"
            },
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "called": [
                "__aeabi_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006074": {
            "entrypoint": "0x08006074",
            "current_name": "handle_gpio_exti_irq_08006074",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_EXTI_IRQ_08006074(void)\n\n{\n  handle_EXTI_IRQ(1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006074": "handle_gpio_exti_irq_08006074",
                "HAL_GPIO_EXTI_IRQHandler": "handle_EXTI_IRQ"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800607e": {
            "entrypoint": "0x0800607e",
            "current_name": "handle_interrupt_0800607e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_interrupt_0800607e(void)\n\n{\n  handle_gpio_interrupt(2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800607e": "handle_interrupt_0800607e",
                "HAL_GPIO_EXTI_IRQHandler": "handle_gpio_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006088": {
            "entrypoint": "0x08006088",
            "current_name": "handle_external_interrupt_08006088",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_08006088(void)\n\n{\n  handleGPIOInterrupt(4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006088": "handle_external_interrupt_08006088",
                "HAL_GPIO_EXTI_IRQHandler": "handleGPIOInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006092": {
            "entrypoint": "0x08006092",
            "current_name": "handle_external_interrupt_08006092",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_08006092(void)\n\n{\n  processGPIOExternalInterrupt(8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006092": "handle_external_interrupt_08006092",
                "HAL_GPIO_EXTI_IRQHandler": "processGPIOExternalInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800609c": {
            "entrypoint": "0x0800609c",
            "current_name": "handle_gpio_exti_interrupt_0800609c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_gpio_exti_interrupt_0800609c(void)\n\n{\n  handle_external_interrupt(0x10);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800609c": "handle_gpio_exti_interrupt_0800609c",
                "HAL_GPIO_EXTI_IRQHandler": "handle_external_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060a6": {
            "entrypoint": "0x080060a6",
            "current_name": "handle_exti_irq_handler_080060a6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_EXTI_IRQHandler_080060a6(void)\n\n{\n  uint loop_counter;\n  \n  for (loop_counter = 0x20; loop_counter < 0x201; loop_counter = loop_counter << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)loop_counter);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060a6": "handle_exti_irq_handler_080060a6",
                "uVar1": "loop_counter"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060bc": {
            "entrypoint": "0x080060bc",
            "current_name": "handle_gpio_interrupts_080060bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleGPIOInterrupts_080060bc(void)\n\n{\n  uint currentValue;\n  \n  for (currentValue = 0x400; currentValue < 0x8001; currentValue = currentValue << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)currentValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060bc": "handle_gpio_interrupts_080060bc",
                "uVar1": "currentValue"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060d4": {
            "entrypoint": "0x080060d4",
            "current_name": "invoke_function_080060d4",
            "code": "\n/* DWARF original prototype: invokeFunction_080060d4  operator()(function<invokeFunction_080060d4()> * functionPtr) */\n\ninvokeFunction_080060d4 __functionPtrcall std::function<invokeFunction_080060d4()>::invoke_function_080060d4(function<invokeFunction_080060d4()> *functionPtr)\n\n{\n  if ((functionPtr->super__Function_base)._M_manager != (_Manager_type)0x0) {\n    (*functionPtr->_M_invoker)((_Any_data *)functionPtr);\n    return;\n  }\n                    \n  __throw_bad_function_call();\n}\n\n",
            "renaming": {
                "this": "functionPtr",
                "void": "invokeFunction",
                "FUN_080060d4": "invoke_function_080060d4"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [
                "__throw_bad_function_call"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060e4": {
            "entrypoint": "0x080060e4",
            "current_name": "handle_gpio_pin_080060e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_Pin_080060e4(uint16_t pin)\n\n{\n  byte pin_id;\n  uint8_t interrupt_id;\n  \n  pin_id = get_pin_id(pin);\n  if (gpio_irq_conf[pin_id].callback.super__Function_base._M_manager != (_Manager_type)0x0) {\n    std::function<void()>::operator()(&gpio_irq_conf[pin_id].callback);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060e4": "handle_gpio_pin_080060e4",
                "GPIO_Pin": "pin",
                "bVar1": "pin_id",
                "irq_id": "interrupt_id"
            },
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "called": [
                "operator()",
                "get_pin_id"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006104": {
            "entrypoint": "0x08006104",
            "current_name": "initialize_static_objects_08006104",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_objects_08006104(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006104": "initialize_static_objects_08006104"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006112": {
            "entrypoint": "0x08006112",
            "current_name": "register_exit_handler_08006112",
            "code": "\nvoid registerExitHandler_08006112(undefined4 handler,undefined4 arg)\n\n{\n  __cxa_atexit(arg,handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006112": "register_exit_handler_08006112",
                "param_1": "handler",
                "param_2": "arg"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800611c": {
            "entrypoint": "0x0800611c",
            "current_name": "log_assertion_failed_0800611c",
            "code": "\nvoid logAssertionFailed_0800611c(undefined4 file,undefined4 line,char *functionName,undefined4 assertion)\n\n{\n  char *messagePrefix;\n  \n  if (functionName == (char *)0x0) {\n    functionName = \"\";\n    messagePrefix = functionName;\n  }\n  else {\n    messagePrefix = \", function: \";\n  }\n  fiprintf(*(FILE **)(_impure_ptr + 0xc),\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",\n           assertion,file,line,messagePrefix,functionName,assertion);\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_0800611c": "log_assertion_failed_0800611c",
                "param_1": "file",
                "param_2": "line",
                "param_3": "functionName",
                "param_4": "assertion",
                "pcVar1": "messagePrefix"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "fiprintf",
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006158": {
            "entrypoint": "0x08006158",
            "current_name": "shift_unsigned_value_08006158",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08006160) */\n\nlonglong shiftUnsignedValue_08006158(undefined4 input,uint value)\n\n{\n  return (ulonglong)value << 0x20;\n}\n\n",
            "renaming": {
                "FUN_08006158": "shift_unsigned_value_08006158",
                "param_1": "input",
                "param_2": "value"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006174": {
            "entrypoint": "0x08006174",
            "current_name": "print_to_file_08006174",
            "code": "\nint printToFile_08006174(FILE *fileStream,char *formatString,...)\n\n{\n  int result;\n  undefined4 uStack_8_1;\n  undefined4 uStack_4_1;\n  undefined4 uStack_8_2;\n  undefined4 uStack_4_2;\n  \n  uStack_8_2 = uStack_8_1;\n  uStack_4_2 = uStack_4_1;\n  result = formattedPrint(globalPtr,fileStream,formatString,&uStack_8_2,fileStream,&uStack_8_2);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006174": "print_to_file_08006174",
                "__stream": "fileStream",
                "__format": "formatString",
                "iVar1": "result",
                "in_r2": "uStack_8_1",
                "in_r3": "uStack_4_1",
                "uStack_8": "uStack_8_2",
                "uStack_4": "uStack_4_2",
                "_vfiprintf_r": "formattedPrint",
                "_impure_ptr": "globalPtr"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006198": {
            "entrypoint": "0x08006198",
            "current_name": "initialize_preinit_array_08006198",
            "code": "\nvoid initializePreinitArray_08006198(void)\n\n{\n  int index;\n  \n  for (index = 0; index != 0; index = index + 1) {\n    (*(code *)(&__preinit_array_end)[index])();\n  }\n  _init();\n  for (index = 0; index != 10; index = index + 1) {\n    (*(code *)(&__preinit_array_end)[index])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006198": "initialize_preinit_array_08006198",
                "iVar1": "index"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "_init",
                "premain"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080061e0": {
            "entrypoint": "0x080061e0",
            "current_name": "fill_memory_080061e0",
            "code": "\nvoid * fillMemory_080061e0(void *memory,int value,size_t size)\n\n{\n  undefined *pointer;\n  \n  for (pointer = (undefined *)memory; pointer != (undefined *)(size + (int)memory); pointer = pointer + 1) {\n    *pointer = (char)value;\n  }\n  return memory;\n}\n\n",
            "renaming": {
                "FUN_080061e0": "fill_memory_080061e0",
                "__s": "memory",
                "__c": "value",
                "__n": "size",
                "puVar1": "pointer"
            },
            "calling": [
                "std.isra.0",
                "__sfp",
                "adc_read_value",
                "__sfmoreglue"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080061f0": {
            "entrypoint": "0x080061f0",
            "current_name": "allocate_memory_080061f0",
            "code": "\nvoid allocateMemory_080061f0(undefined4 *ptrToResult,int size,undefined4 param3,undefined4 param4)\n\n{\n  int **extraOut1;\n  int **temp1;\n  int **temp2;\n  int *temp3;\n  int **temp4;\n  int **temp5;\n  \n  if (size == 0) {\n    return;\n  }\n  temp5 = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    temp5 = (int **)((int)temp5 + *(int *)(size + -4));\n  }\n  lockMalloc();\n  temp2 = (int **)&freeList;\n  if (freeList == (int **)0x0) {\n    temp5[1] = (int *)0x0;\n    temp1 = extraOut1;\n    freeList = temp5;\n  }\n  else {\n    temp2 = freeList;\n    if (temp5 < freeList) {\n      temp1 = (int **)*temp5;\n      temp2 = (int **)((int)temp5 + (int)temp1);\n      if (freeList == temp2) {\n        temp3 = *freeList;\n        freeList = (int **)freeList[1];\n        temp2 = (int **)((int)temp3 + (int)temp1);\n        *temp5 = (int *)temp2;\n      }\n      temp5[1] = (int *)freeList;\n      freeList = temp5;\n    }\n    else {\n      do {\n        temp4 = temp2;\n        temp2 = (int **)temp4[1];\n        if (temp2 == (int **)0x0) break;\n      } while (temp2 <= temp5);\n      temp1 = (int **)*temp4;\n      if ((int **)((int)temp4 + (int)temp1) == temp5) {\n        temp1 = (int **)((int)temp1 + (int)*temp5);\n        *temp4 = (int *)temp1;\n        if (temp2 == (int **)((int)temp4 + (int)temp1)) {\n          temp3 = *temp2;\n          temp2 = (int **)temp2[1];\n          temp1 = (int **)((int)temp1 + (int)temp3);\n          *temp4 = (int *)temp1;\n          temp4[1] = (int *)temp2;\n        }\n      }\n      else if (temp5 < (int **)((int)temp4 + (int)temp1)) {\n        *ptrToResult = 0xc;\n      }\n      else {\n        temp1 = (int **)((int)temp5 + (int)*temp5);\n        if (temp2 == temp1) {\n          temp3 = *temp2;\n          temp2 = (int **)temp2[1];\n          temp1 = (int **)((int)temp3 + (int)*temp5);\n          *temp5 = (int *)temp1;\n        }\n        temp5[1] = (int *)temp2;\n        temp4[1] = (int *)temp5;\n      }\n    }\n  }\n  unlockMalloc(ptrToResult,temp1,temp2,param4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080061f0": "allocate_memory_080061f0",
                "param_1": "ptrToResult",
                "param_2": "size",
                "param_3": "param3",
                "param_4": "param4",
                "extraout_r1": "extraOut1",
                "ppiVar1": "temp1",
                "ppiVar2": "temp2",
                "piVar3": "temp3",
                "ppiVar4": "temp4",
                "ppiVar5": "temp5",
                "__malloc_lock": "lockMalloc",
                "__malloc_free_list": "freeList",
                "__malloc_unlock": "unlockMalloc"
            },
            "calling": [
                "__swsetup_r",
                "__sflush_r"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006288": {
            "entrypoint": "0x08006288",
            "current_name": "allocate_memory_08006288",
            "code": "\nuint allocate_memory_08006288(undefined4 *size,uint alignment)\n\n{\n  uint *current_block;\n  int remaining_space;\n  uint *previous_block;\n  uint free_space;\n  uint *last_block;\n  uint allocated_size;\n  \n  allocated_size = (alignment + 3 & 0xfffffffc) + 8;\n  if (allocated_size < 0xc) {\n    allocated_size = 0xc;\n  }\n  if (((int)allocated_size < 0) || (allocated_size < alignment)) {\n    *size = 0xc;\n  }\n  else {\n    __malloc_lock();\n    current_block = __malloc_free_list;\n    last_block = __malloc_free_list;\n    while (previous_block = current_block, previous_block != (uint *)0x0) {\n      free_space = *previous_block - allocated_size;\n      if (-1 < (int)free_space) {\n        if (free_space < 0xc) {\n          if (last_block == previous_block) {\n            current_block = (uint *)last_block[1];\n            __malloc_free_list = current_block;\n          }\n          else {\n            current_block = (uint *)previous_block[1];\n          }\n          if (last_block != previous_block) {\n            last_block[1] = (uint)current_block;\n            last_block = previous_block;\n          }\n        }\n        else {\n          *previous_block = free_space;\n          *(uint *)((int)previous_block + free_space) = allocated_size;\n          last_block = (uint *)((int)previous_block + free_space);\n        }\n        goto LAB_080062ec;\n      }\n      last_block = previous_block;\n      current_block = (uint *)previous_block[1];\n    }\n    if (__malloc_sbrk_start == 0) {\n      __malloc_sbrk_start = _sbrk_r(size);\n    }\n    current_block = (uint *)_sbrk_r(size,allocated_size);\n    if ((current_block != (uint *)0xffffffff) &&\n       ((last_block = (uint *)((int)current_block + 3U & 0xfffffffc), current_block == last_block ||\n        (remaining_space = _sbrk_r(size,(int)last_block - (int)current_block), remaining_space != -1)))) {\n      *last_block = allocated_size;\nLAB_080062ec:\n      __malloc_unlock(size);\n      allocated_size = (int)last_block + 0xbU & 0xfffffff8;\n      remaining_space = allocated_size - (int)(last_block + 1);\n      if (remaining_space != 0) {\n        *(int *)((int)last_block + remaining_space) = -remaining_space;\n        return allocated_size;\n      }\n      return allocated_size;\n    }\n    *size = 0xc;\n    __malloc_unlock(size);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006288": "allocate_memory_08006288",
                "param_1": "size",
                "param_2": "alignment",
                "puVar1": "current_block",
                "iVar2": "remaining_space",
                "puVar3": "previous_block",
                "uVar4": "free_space",
                "puVar5": "last_block",
                "uVar6": "allocated_size"
            },
            "calling": [
                "__smakebuf_r",
                "__sfmoreglue"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock",
                "_sbrk_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006344": {
            "entrypoint": "0x08006344",
            "current_name": "write_byte_to_buffer_08006344",
            "code": "\nuint write_byte_to_buffer_08006344(undefined4 undefined_param,byte byte_to_write,byte **buffer)\n\n{\n  uint result;\n  byte *last_byte;\n  \n  last_byte = buffer[2] + -1;\n  buffer[2] = last_byte;\n  if (((int)last_byte < 0) && (((int)last_byte < (int)buffer[6] || (byte_to_write == 10)))) {\n    result = write_to_stream();\n    return result;\n  }\n  last_byte = *buffer;\n  *buffer = last_byte + 1;\n  *last_byte = byte_to_write;\n  return (uint)byte_to_write;\n}\n\n",
            "renaming": {
                "FUN_08006344": "write_byte_to_buffer_08006344",
                "param_1": "undefined_param",
                "param_2": "byte_to_write",
                "param_3": "buffer",
                "uVar1": "result",
                "pbVar2": "last_byte",
                "__swbuf_r": "write_to_stream"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__swbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006370": {
            "entrypoint": "0x08006370",
            "current_name": "write_to_stream_08006370",
            "code": "\nint writeToStream_08006370(undefined4 stream,undefined4 stream_end,undefined *data,int size)\n\n{\n  int result;\n  undefined *end_of_data;\n  int current_size;\n  \n  end_of_data = data + size;\n  current_size = size;\n  do {\n    if (data == end_of_data) {\n      return 0;\n    }\n    result = __sfputc_r(stream,*data,stream_end,size,current_size);\n    size = result + 1;\n    data = data + 1;\n  } while (size != 0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006370": "write_to_stream_08006370",
                "param_1": "stream",
                "param_2": "stream_end",
                "param_3": "data",
                "param_4": "size",
                "iVar1": "result",
                "puVar2": "end_of_data",
                "iVar3": "current_size"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006394": {
            "entrypoint": "0x08006394",
            "current_name": "print_formatted_string_08006394",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08006568) */\n\nint printFormattedString_08006394(int formatString,undefined4 *stream,byte *outputBuffer,int *numDigits)\n\n{\n  bool isDigit;\n  int numCharacters;\n  void *memPointer;\n  int *numPointer;\n  byte *charPointer;\n  byte *nextCharPointer;\n  int unusedRegister;\n  int integerValue;\n  int *numPointer;\n  uint formatFlags;\n  int precision;\n  undefined4 unusedVariable;\n  int fieldWidth;\n  int totalCharacters;\n  byte currentChar;\n  undefined defaultFill;\n  undefined spaceFill;\n  undefined plusFill;\n  undefined4 unusedVariable;\n  \n  numPointer = numDigits;\n  if ((formatString != 0) && (*(int *)(formatString + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = *(undefined4 **)(formatString + 4);\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stdout) {\n    stream = *(undefined4 **)(formatString + 8);\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stderr) {\n    stream = *(undefined4 **)(formatString + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1c)) || (stream[4] == 0)) &&\n     (integerValue = __swsetup_r(formatString,stream), integerValue != 0)) {\n    return -1;\n  }\n  totalCharacters = 0;\n  defaultFill = 0x20;\n  spaceFill = 0x30;\n  charPointer = outputBuffer;\nLAB_080063d6:\n  nextCharPointer = charPointer;\n  if (*nextCharPointer != 0) goto LAB_0800648c;\n  goto LAB_080063e0;\nLAB_0800648c:\n  charPointer = nextCharPointer + 1;\n  if (*nextCharPointer != 0x25) goto LAB_080063d6;\nLAB_080063e0:\n  integerValue = (int)nextCharPointer - (int)outputBuffer;\n  if (integerValue != 0) {\n    numCharacters = __sfputs_r(formatString,stream,outputBuffer,integerValue);\n    if (numCharacters == -1) {\nLAB_08006580:\n      if ((int)((uint)*(ushort *)(stream + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return totalCharacters;\n    }\n    totalCharacters = totalCharacters + integerValue;\n  }\n  if (*nextCharPointer == 0) goto LAB_08006580;\n  formatFlags = 0;\n  fieldWidth = 0;\n  precision = -1;\n  unusedVariable = 0;\n  plusFill = 0;\n  unusedVariable = 0;\n  charPointer = nextCharPointer + 1;\n  while( true ) {\n    memPointer = memchr(\"#-0+ \",(uint)*charPointer,5);\n    outputBuffer = charPointer + 1;\n    if (memPointer == (void *)0x0) break;\n    formatFlags = 1 << ((int)memPointer + 0xf7ff8750U & 0xff) | formatFlags;\n    charPointer = outputBuffer;\n  }\n  if ((int)(formatFlags << 0x1b) < 0) {\n    plusFill = 0x20;\n  }\n  if ((int)(formatFlags << 0x1c) < 0) {\n    plusFill = 0x2b;\n  }\n  if (*charPointer == 0x2a) {\n    numPointer = numPointer + 1;\n    integerValue = *numPointer;\n    numPointer = numPointer;\n    if (integerValue < 0) {\n      fieldWidth = -integerValue;\n      formatFlags = formatFlags | 2;\n      goto LAB_080064be;\n    }\n  }\n  else {\n    isDigit = false;\n    integerValue = fieldWidth;\n    outputBuffer = charPointer;\n    while( true ) {\n      if (9 < *outputBuffer - 0x30) break;\n      integerValue = integerValue * 10 + (*outputBuffer - 0x30);\n      isDigit = true;\n      outputBuffer = outputBuffer + 1;\n    }\n    if (!isDigit) goto LAB_080064be;\n  }\n  fieldWidth = integerValue;\nLAB_080064be:\n  if (*outputBuffer == 0x2e) {\n    if (outputBuffer[1] == 0x2a) {\n      outputBuffer = outputBuffer + 2;\n      numPointer = numPointer + 1;\n      precision = *numPointer;\n      numPointer = numPointer;\n      if (precision < 0) {\n        precision = -1;\n      }\n    }\n    else {\n      isDigit = false;\n      integerValue = 0;\n      precision = 0;\n      while( true ) {\n        outputBuffer = outputBuffer + 1;\n        if (9 < *outputBuffer - 0x30) break;\n        integerValue = integerValue * 10 + (*outputBuffer - 0x30);\n        isDigit = true;\n      }\n      if (isDigit) {\n        precision = integerValue;\n      }\n    }\n  }\n  memPointer = memchr(&DAT_080078b6,(uint)*outputBuffer,3);\n  if (memPointer != (void *)0x0) {\n    outputBuffer = outputBuffer + 1;\n    formatFlags = formatFlags | 0x40 << ((int)memPointer + 0xf7ff874aU & 0xff);\n  }\n  currentChar = *outputBuffer;\n  outputBuffer = outputBuffer + 1;\n  memPointer = memchr(\"efgEFG\",(uint)currentChar,6);\n  if (memPointer == (void *)0x0) {\n    unusedRegister = _printf_i(formatString,&formatFlags,stream,0x8006371,&numPointer);\n    if (unusedRegister == -1) goto LAB_08006580;\n  }\n  else {\n    numPointer = (int *)(((int)numPointer + 7U & 0xfffffff8) + 8);\n  }\n  totalCharacters = totalCharacters + unusedRegister;\n  charPointer = outputBuffer;\n  goto LAB_080063d6;\n}\n\n",
            "renaming": {
                "FUN_08006394": "print_formatted_string_08006394",
                "param_1": "formatString",
                "param_2": "stream",
                "param_3": "outputBuffer",
                "param_4": "numDigits",
                "bVar1": "isDigit",
                "iVar2": "numCharacters",
                "pvVar3": "memPointer",
                "piVar4": "numPointer",
                "pbVar5": "charPointer",
                "pbVar6": "nextCharPointer",
                "unaff_r9": "unusedRegister",
                "iVar7": "integerValue",
                "local_8c": "numPointer",
                "local_88": "formatFlags",
                "local_84": "precision",
                "local_80": "unusedVariable",
                "local_7c": "fieldWidth",
                "local_74": "totalCharacters",
                "local_70": "currentChar",
                "local_6f": "defaultFill",
                "local_6e": "spaceFill",
                "local_45": "plusFill",
                "local_30": "unusedVariable"
            },
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "called": [
                "memchr",
                "__swsetup_r",
                "__sfputs_r",
                "_printf_i",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080065c0": {
            "entrypoint": "0x080065c0",
            "current_name": "process_data_080065c0",
            "code": "\nundefined4\nprocess_data_080065c0(undefined4 input_data,uint *data,uint *output_length,undefined4 param_4,code *callback)\n\n{\n  int iteration;\n  int result;\n  uint max_length;\n  uint extra_length;\n  bool condition_check;\n  \n  max_length = data[4];\n  if ((int)data[4] < (int)data[2]) {\n    max_length = data[2];\n  }\n  *output_length = max_length;\n  if (*(char *)((int)data + 0x43) != '\\0') {\n    *output_length = max_length + 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *output_length = *output_length + 2;\n  }\n  if ((*data & 6) == 0) {\n    for (iteration = 0; iteration < (int)(data[3] - *output_length); iteration = iteration + 1) {\n      result = (*callback)(input_data,param_4,(int)data + 0x19,1);\n      if (result == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  max_length = (uint)*(byte *)((int)data + 0x43);\n  if (max_length != 0) {\n    max_length = 1;\n  }\n  extra_length = max_length;\n  if ((int)(*data << 0x1a) < 0) {\n    *(undefined *)((int)data + max_length + 0x43) = 0x30;\n    extra_length = max_length + 2;\n    *(undefined *)((int)data + max_length + 0x44) = *(undefined *)((int)data + 0x45);\n  }\n  iteration = (*callback)(input_data,param_4,(int)data + 0x43,extra_length);\n  if (iteration != -1) {\n    max_length = data[3];\n    condition_check = (*data & 6) != 4;\n    if (condition_check) {\n      max_length = 0;\n    }\n    extra_length = 0;\n    if (!condition_check) {\n      max_length = max_length - *output_length;\n    }\n    if (!condition_check) {\n      max_length = max_length & ~((int)max_length >> 0x1f);\n    }\n    if ((int)data[4] < (int)data[2]) {\n      max_length = max_length + (data[2] - data[4]);\n    }\n    while( true ) {\n      if (max_length == extra_length) {\n        return 0;\n      }\n      iteration = (*callback)(input_data,param_4,(int)data + 0x1a,1);\n      if (iteration == -1) break;\n      extra_length = extra_length + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080065c0": "process_data_080065c0",
                "param_1": "input_data",
                "param_2": "data",
                "param_3": "output_length",
                "param_5": "callback",
                "iVar1": "iteration",
                "iVar2": "result",
                "uVar3": "max_length",
                "uVar4": "extra_length",
                "bVar5": "condition_check"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080066b0": {
            "entrypoint": "0x080066b0",
            "current_name": "print_formatted_string_080066b0",
            "code": "\nuint print_formatted_string_080066b0(undefined4 format_string,uint *flags,undefined4 width,code *putc_func,uint **args)\n\n{\n  byte flag;\n  int result;\n  uint *arg_ptr;\n  void *ptr;\n  int index;\n  char *digits;\n  uint value;\n  uint **str_arg;\n  char **str_arg_ptr;\n  uint num;\n  uint width_adjusted;\n  char *ptr1;\n  char *str;\n  uint tmp_arr [2];\n  \n  flag = *(byte *)(flags + 6);\n  str = (char *)((int)flags + 0x43);\n  if (flag != 0x6e) {\n    if (flag < 0x6f) {\n      if (flag != 99) {\n        if (flag < 100) {\n          if (flag == 0) goto LAB_0800686a;\n          if (flag != 0x58) goto LAB_080066e0;\n          *(undefined *)((int)flags + 0x45) = 0x58;\n          digits = \"0123456789ABCDEF\";\nLAB_080067fa:\n          value = *flags;\n          arg_ptr = *args;\n          *args = arg_ptr + 1;\n          if (((value & 0x80) == 0) && ((int)(value << 0x19) < 0)) {\n            num = (uint)*(ushort *)arg_ptr;\n          }\n          else {\n            num = *arg_ptr;\n          }\n          if ((int)(value << 0x1f) < 0) {\n            *flags = value | 0x20;\n          }\n          if (num == 0) {\n            *flags = *flags & 0xffffffdf;\n          }\n          value = 0x10;\nLAB_08006790:\n          *(undefined *)((int)flags + 0x43) = 0;\n        }\n        else {\n          if ((flag != 100) && (flag != 0x69)) goto LAB_080066e0;\n          num = *flags;\n          arg_ptr = *args;\n          if ((num & 0x80) == 0) {\n            *args = arg_ptr + 1;\n            if ((num & 0x40) == 0) goto LAB_08006700;\n            num = (uint)(short)*(ushort *)arg_ptr;\n          }\n          else {\n            *args = arg_ptr + 1;\nLAB_08006700:\n            num = *arg_ptr;\n          }\n          if ((int)num < 0) {\n            num = -num;\n            *(undefined *)((int)flags + 0x43) = 0x2d;\n          }\n          digits = \"0123456789ABCDEF\";\n          value = 10;\n        }\n        width_adjusted = flags[1];\n        flags[2] = width_adjusted;\n        ptr1 = str;\n        if ((int)width_adjusted < 0) {\n          if (num != 0) goto LAB_0800682e;\nLAB_080068dc:\n          *(char *)((int)flags + 0x42) = *digits;\n          ptr1 = (char *)((int)flags + 0x42);\n        }\n        else {\n          *flags = *flags & 0xfffffffb;\n          if (num == 0) {\n            if (width_adjusted != 0) goto LAB_080068dc;\n          }\n          else {\nLAB_0800682e:\n            do {\n              width_adjusted = num / value;\n              ptr1 = ptr1 + -1;\n              *ptr1 = digits[num - value * width_adjusted];\n              num = width_adjusted;\n            } while (width_adjusted != 0);\n          }\n        }\n        if (((value == 8) && ((int)(*flags << 0x1f) < 0)) && ((int)flags[1] <= (int)flags[4]))\n        {\n          ptr1[-1] = '0';\n          ptr1 = ptr1 + -1;\n        }\n        flags[4] = (int)str - (int)ptr1;\n        str = ptr1;\n        goto LAB_080067d6;\n      }\n      arg_ptr = *args;\n      *args = arg_ptr + 1;\n      *(char *)((int)flags + 0x42) = (char)*arg_ptr;\nLAB_08006740:\n      str = (char *)((int)flags + 0x42);\n      num = 1;\n    }\n    else {\n      if (flag != 0x73) {\n        if (flag < 0x74) {\n          if (flag == 0x6f) {\nLAB_08006766:\n            num = *flags;\n            arg_ptr = *args;\n            if ((num & 0x80) == 0) {\n              *args = arg_ptr + 1;\n              if ((num & 0x40) == 0) goto LAB_08006774;\n              num = (uint)*(ushort *)arg_ptr;\n            }\n            else {\n              *args = arg_ptr + 1;\nLAB_08006774:\n              num = *arg_ptr;\n            }\n            if (flag == 0x6f) {\n              value = 8;\n            }\n            else {\n              value = 10;\n            }\n            digits = \"0123456789ABCDEF\";\n            goto LAB_08006790;\n          }\n          if (flag == 0x70) {\n            *flags = *flags | 0x20;\nLAB_08006726:\n            digits = \"0123456789abcdef\";\n            *(undefined *)((int)flags + 0x45) = 0x78;\n            goto LAB_080067fa;\n          }\n        }\n        else {\n          if (flag == 0x75) goto LAB_08006766;\n          if (flag == 0x78) goto LAB_08006726;\n        }\nLAB_080066e0:\n        *(byte *)((int)flags + 0x42) = flag;\n        goto LAB_08006740;\n      }\n      str_arg_ptr = (char **)*args;\n      *args = (uint *)(str_arg_ptr + 1);\n      str = *str_arg_ptr;\n      ptr = memchr(str,0,flags[1]);\n      if (ptr != (void *)0x0) {\n        flags[1] = (int)ptr - (int)str;\n      }\n      num = flags[1];\n    }\n    flags[4] = num;\n    *(undefined *)((int)flags + 0x43) = 0;\n    goto LAB_080067d6;\n  }\n  num = *flags;\n  str_arg = (uint **)*args;\n  value = flags[5];\n  if ((num & 0x80) == 0) {\n    *args = (uint *)(str_arg + 1);\n    arg_ptr = *str_arg;\n    if ((num & 0x40) == 0) goto LAB_08006856;\n    *(short *)arg_ptr = (short)value;\n  }\n  else {\n    *args = (uint *)(str_arg + 1);\n    arg_ptr = *str_arg;\nLAB_08006856:\n    *arg_ptr = value;\n  }\nLAB_0800686a:\n  flags[4] = 0;\nLAB_080067d6:\n  result = _printf_common(format_string,flags,tmp_arr,width,putc_func);\n  if ((result == -1) || (result = (*putc_func)(format_string,width,str,flags[4]), result == -1)) {\nLAB_080067ea:\n    num = 0xffffffff;\n  }\n  else {\n    if ((int)(*flags << 0x1e) < 0) {\n      for (result = 0; result < (int)(flags[3] - tmp_arr[0]); result = result + 1) {\n        index = (*putc_func)(format_string,width,(int)flags + 0x19,1);\n        if (index == -1) goto LAB_080067ea;\n      }\n    }\n    num = flags[3];\n    if ((int)flags[3] < (int)tmp_arr[0]) {\n      num = tmp_arr[0];\n    }\n  }\n  return num;\n}\n\n",
            "renaming": {
                "FUN_080066b0": "print_formatted_string_080066b0",
                "param_1": "format_string",
                "param_2": "flags",
                "param_3": "width",
                "param_4": "putc_func",
                "param_5": "args",
                "bVar1": "flag",
                "iVar2": "result",
                "puVar3": "arg_ptr",
                "pvVar4": "ptr",
                "iVar5": "index",
                "pcVar6": "digits",
                "uVar7": "value",
                "ppuVar8": "str_arg",
                "ppcVar9": "str_arg_ptr",
                "uVar10": "num",
                "uVar11": "width_adjusted",
                "pcVar12": "ptr1",
                "__s": "str",
                "local_24": "tmp_arr"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "memchr",
                "_printf_common"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080068f0": {
            "entrypoint": "0x080068f0",
            "current_name": "formatted_printf_080068f0",
            "code": "\nint formattedPrintf_080068f0(char *formatString,...)\n\n{\n  int impurePtr;\n  undefined4 in_r1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *format;\n  undefined4 arg1;\n  undefined4 arg2;\n  undefined4 arg3;\n  \n  impurePtr = _impure_ptr;\n  format = formatString;\n  arg1 = in_r1;\n  arg2 = in_r2;\n  arg3 = in_r3;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  impurePtr = _vfiprintf_r(impurePtr,*(undefined4 *)(impurePtr + 8),formatString,&arg1,format,&arg1);\n  return impurePtr;\n}\n\n",
            "renaming": {
                "FUN_080068f0": "formatted_printf_080068f0",
                "__format": "formatString",
                "iVar1": "impurePtr",
                "pcVar2": "format",
                "uStack_c": "arg1",
                "uStack_8": "arg2",
                "uStack_4": "arg3"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "_vfiprintf_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006920": {
            "entrypoint": "0x08006920",
            "current_name": "allocate_memory_08006920",
            "code": "\nvoid allocate_memory_08006920(int *error_code,intptr_t size)\n\n{\n  void *allocated_memory_ptr;\n  \n  errno = 0;\n  allocated_memory_ptr = _sbrk(size);\n  if ((allocated_memory_ptr == (void *)0xffffffff) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006920": "allocate_memory_08006920",
                "param_1": "error_code",
                "param_2": "size",
                "pvVar1": "allocated_memory_ptr"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006940": {
            "entrypoint": "0x08006940",
            "current_name": "process_input_08006940",
            "code": "\nuint processInput_08006940(int input,uint character,int *stream,undefined4 param)\n\n{\n  int index;\n  uint ushortVal;\n  undefined *dataPtr;\n  \n  if ((input != 0) && (*(int *)(input + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = *(int **)(input + 4);\n  }\n  else if (stream == (int *)&__sf_fake_stdout) {\n    stream = *(int **)(input + 8);\n  }\n  else if (stream == (int *)&__sf_fake_stderr) {\n    stream = *(int **)(input + 0xc);\n  }\n  stream[2] = stream[6];\n  ushortVal = (uint)*(ushort *)(stream + 3);\n  index = ushortVal << 0x1c;\n  if (((index < 0) && (ushortVal = stream[4], ushortVal != 0)) ||\n     (index = __swsetup_r(input,stream,index,ushortVal,param), index == 0)) {\n    character = character & 0xff;\n    index = *stream - stream[4];\n    if ((index < stream[5]) || (index = _fflush_r(input,stream), index == 0)) {\n      stream[2] = stream[2] + -1;\n      dataPtr = (undefined *)*stream;\n      *stream = (int)(dataPtr + 1);\n      *dataPtr = (char)character;\n      if (index + 1 != stream[5]) {\n        if (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1f)) {\n          return character;\n        }\n        if (character != 10) {\n          return character;\n        }\n      }\n      index = _fflush_r(input,stream);\n      if (index == 0) {\n        return character;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08006940": "process_input_08006940",
                "param_1": "input",
                "param_2": "character",
                "param_3": "stream",
                "param_4": "param",
                "iVar1": "index",
                "uVar2": "ushortVal",
                "puVar3": "dataPtr"
            },
            "calling": [
                "__sfputc_r"
            ],
            "called": [
                "_fflush_r",
                "__swsetup_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080069e4": {
            "entrypoint": "0x080069e4",
            "current_name": "update_and_check_status_080069e4",
            "code": "\nuint updateAndCheckStatus_080069e4(undefined4 *inputStatus,undefined4 *fileDescriptor)\n\n{\n  int impurePtr;\n  uint updatedValue;\n  ushort fileStatus;\n  \n  impurePtr = _impure_ptr;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  if (fileDescriptor == &__sf_fake_stdin) {\n    fileDescriptor = *(undefined4 **)(impurePtr + 4);\n  }\n  else if (fileDescriptor == (undefined4 *)&__sf_fake_stdout) {\n    fileDescriptor = *(undefined4 **)(impurePtr + 8);\n  }\n  else if (fileDescriptor == (undefined4 *)&__sf_fake_stderr) {\n    fileDescriptor = *(undefined4 **)(impurePtr + 0xc);\n  }\n  fileStatus = *(ushort *)(fileDescriptor + 3);\n  updatedValue = (uint)fileStatus;\n  if (-1 < (int)(updatedValue << 0x1c)) {\n    if (-1 < (int)(updatedValue << 0x1b)) {\n      *inputStatus = 9;\n      goto LAB_08006a14;\n    }\n    if ((int)(updatedValue << 0x1d) < 0) {\n      if ((undefined4 *)fileDescriptor[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)fileDescriptor[0xd] != fileDescriptor + 0x11) {\n          _free_r(inputStatus);\n        }\n        fileDescriptor[0xd] = 0;\n      }\n      *(ushort *)(fileDescriptor + 3) = *(ushort *)(fileDescriptor + 3) & 0xffdb;\n      fileDescriptor[1] = 0;\n      *fileDescriptor = fileDescriptor[4];\n    }\n    *(ushort *)(fileDescriptor + 3) = *(ushort *)(fileDescriptor + 3) | 8;\n  }\n  if ((fileDescriptor[4] == 0) && ((*(ushort *)(fileDescriptor + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(inputStatus,fileDescriptor);\n  }\n  fileStatus = *(ushort *)(fileDescriptor + 3);\n  updatedValue = fileStatus & 1;\n  if ((fileStatus & 1) == 0) {\n    if (-1 < (int)((uint)fileStatus << 0x1e)) {\n      updatedValue = fileDescriptor[5];\n    }\n    fileDescriptor[2] = updatedValue;\n  }\n  else {\n    fileDescriptor[2] = 0;\n    fileDescriptor[6] = -fileDescriptor[5];\n  }\n  if (fileDescriptor[4] == 0) {\n    fileStatus = *(ushort *)(fileDescriptor + 3);\n    updatedValue = (int)(short)fileStatus & 0x80;\n    if (updatedValue != 0) {\nLAB_08006a14:\n      *(ushort *)(fileDescriptor + 3) = fileStatus | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    updatedValue = 0;\n  }\n  return updatedValue;\n}\n\n",
            "renaming": {
                "FUN_080069e4": "update_and_check_status_080069e4",
                "param_1": "inputStatus",
                "param_2": "fileDescriptor",
                "iVar1": "impurePtr",
                "uVar2": "updatedValue",
                "uVar3": "fileStatus"
            },
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r"
            ],
            "called": [
                "__smakebuf_r",
                "_free_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ac0": {
            "entrypoint": "0x08006ac0",
            "current_name": "handle_signal_08006ac0",
            "code": "\n\n\nvoid handle_signal_08006ac0(void)\n\n{\n  raise(6);\n                    \n  _exit(1);\n}\n\n",
            "renaming": {
                "FUN_08006ac0": "handle_signal_08006ac0"
            },
            "calling": [
                "__assert_func",
                "__throw_bad_function_call"
            ],
            "called": [
                "_exit",
                "raise"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ad0": {
            "entrypoint": "0x08006ad0",
            "current_name": "process_data_08006ad0",
            "code": "\nundefined4 process_data_08006ad0(uint *data_ptr,int *info_ptr)\n\n{\n  int offset;\n  int *ptr;\n  uint value1;\n  ushort value2;\n  int value3;\n  code *function_ptr;\n  int length;\n  uint old_value;\n  bool flag;\n  \n  value2 = *(ushort *)(info_ptr + 3);\n  value1 = (uint)value2;\n  if ((int)(value1 << 0x1c) < 0) {\n    offset = info_ptr[4];\n    if (offset != 0) {\n      value3 = value1 << 0x1e;\n      flag = value3 != 0;\n      if (flag) {\n        value3 = 0;\n      }\n      length = *info_ptr;\n      if (!flag) {\n        value3 = info_ptr[5];\n      }\n      *info_ptr = offset;\n      info_ptr[2] = value3;\n      for (length = length - offset; 0 < length; length = length - value3) {\n        value3 = (*(code *)info_ptr[10])(data_ptr,info_ptr[8],offset,length);\n        if (value3 < 1) {\n          value2 = *(ushort *)(info_ptr + 3);\n          goto LAB_08006bc6;\n        }\n        offset = offset + value3;\n      }\n    }\n  }\n  else if (((0 < info_ptr[1]) || (0 < info_ptr[0x10])) &&\n          (function_ptr = (code *)info_ptr[0xb], function_ptr != (code *)0x0)) {\n    old_value = *data_ptr;\n    *data_ptr = 0;\n    if ((value2 & 0x1000) == 0) {\n      offset = (*function_ptr)(data_ptr,info_ptr[8],value1 & 0x1000,1);\n      if ((offset == -1) && (value1 = *data_ptr, value1 != 0)) {\n        if ((value1 != 0x1d) && (value1 != 0x16)) {\n          *(ushort *)(info_ptr + 3) = *(ushort *)(info_ptr + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *data_ptr = old_value;\n        return 0;\n      }\n    }\n    else {\n      offset = info_ptr[0x15];\n    }\n    if (((int)((uint)*(ushort *)(info_ptr + 3) << 0x1d) < 0) &&\n       (offset = offset - info_ptr[1], info_ptr[0xd] != 0)) {\n      offset = offset - info_ptr[0x10];\n    }\n    offset = (*(code *)info_ptr[0xb])(data_ptr,info_ptr[8],offset,0);\n    value2 = *(ushort *)(info_ptr + 3);\n    if ((offset == -1) &&\n       ((0x1d < *data_ptr || (-1 < (int)((0x20400001U >> (*data_ptr & 0xff)) << 0x1f))))) {\nLAB_08006bc6:\n      *(ushort *)(info_ptr + 3) = value2 | 0x40;\n      return 0xffffffff;\n    }\n    info_ptr[1] = 0;\n    *info_ptr = info_ptr[4];\n    if (((int)((uint)value2 << 0x13) < 0) && ((offset != -1 || (*data_ptr == 0)))) {\n      info_ptr[0x15] = offset;\n    }\n    ptr = (int *)info_ptr[0xd];\n    *data_ptr = old_value;\n    if (ptr != (int *)0x0) {\n      if (ptr != info_ptr + 0x11) {\n        _free_r(data_ptr);\n      }\n      info_ptr[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006ad0": "process_data_08006ad0",
                "param_1": "data_ptr",
                "param_2": "info_ptr",
                "iVar1": "offset",
                "piVar2": "ptr",
                "uVar3": "value1",
                "uVar4": "value2",
                "iVar5": "value3",
                "pcVar6": "function_ptr",
                "iVar7": "length",
                "uVar8": "old_value",
                "bVar9": "flag"
            },
            "calling": [
                "_fflush_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006be0": {
            "entrypoint": "0x08006be0",
            "current_name": "check_and_flush_stream_08006be0",
            "code": "\nundefined4 check_and_flush_stream_08006be0(int stream_ptr,undefined4 *stream,undefined4 data_3,undefined4 data_4)\n\n{\n  undefined4 result;\n  \n  if (stream[4] != 0) {\n    if ((stream_ptr != 0) && (*(int *)(stream_ptr + 0x18) == 0)) {\n      __sinit();\n    }\n    if (stream == &fake_stdin) {\n      stream = *(undefined4 **)(stream_ptr + 4);\n    }\n    else if (stream == (undefined4 *)&fake_stdout) {\n      stream = *(undefined4 **)(stream_ptr + 8);\n    }\n    else if (stream == (undefined4 *)&fake_stderr) {\n      stream = *(undefined4 **)(stream_ptr + 0xc);\n    }\n    if (*(short *)(stream + 3) != 0) {\n      result = __sflush_r(stream_ptr,stream,data_3,data_4);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006be0": "check_and_flush_stream_08006be0",
                "param_1": "stream_ptr",
                "param_2": "stream",
                "param_3": "data_3",
                "param_4": "data_4",
                "uVar1": "result",
                "__sf_fake_stdin": "fake_stdin",
                "__sf_fake_stdout": "fake_stdout",
                "__sf_fake_stderr": "fake_stderr"
            },
            "calling": [
                "__swbuf_r"
            ],
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c34": {
            "entrypoint": "0x08006c34",
            "current_name": "walk_reentrant_function_08006c34",
            "code": "\nvoid walk_reentrant_function_08006c34(undefined4 reentrant_param)\n\n{\n  reentrant_function(reentrant_param,0x8006be1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006c34": "walk_reentrant_function_08006c34",
                "param_1": "reentrant_param",
                "_fwalk_reent": "reentrant_function"
            },
            "calling": [],
            "called": [
                "_fwalk_reent"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c40": {
            "entrypoint": "0x08006c40",
            "current_name": "initialize_data_structure_08006c40",
            "code": "\nvoid initializeDataStructure_08006c40(undefined4 *dataStructure,undefined2 value1,undefined2 value2)\n\n{\n  *dataStructure = 0;\n  dataStructure[1] = 0;\n  dataStructure[2] = 0;\n  *(undefined2 *)(dataStructure + 3) = value1;\n  dataStructure[25] = 0;\n  *(undefined2 *)((int)dataStructure + 0xe) = value2;\n  dataStructure[4] = 0;\n  dataStructure[5] = 0;\n  dataStructure[6] = 0;\n  memset(dataStructure + 0x17,0,8);\n  dataStructure[8] = dataStructure;\n  dataStructure[9] = 0x8006f39;\n  dataStructure[10] = 0x8006f5b;\n  dataStructure[11] = 0x8006f93;\n  dataStructure[12] = 0x8006fb7;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006c40": "initialize_data_structure_08006c40",
                "param_1": "dataStructure",
                "param_2": "value1",
                "param_3": "value2",
                "param_1[1]": "dataStructure[1]",
                "param_1[2]": "dataStructure[2]",
                "param_1[0x19]": "dataStructure[25]",
                "param_1[4]": "dataStructure[4]",
                "param_1[5]": "dataStructure[5]",
                "param_1[6]": "dataStructure[6]",
                "param_1[8]": "dataStructure[8]",
                "param_1[9]": "dataStructure[9]",
                "param_1[10]": "dataStructure[10]",
                "param_1[0xb]": "dataStructure[11]",
                "param_1[0xc]": "dataStructure[12]"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c88": {
            "entrypoint": "0x08006c88",
            "current_name": "allocate_memory_08006c88",
            "code": "\nundefined4 * allocateMemory_08006c88(undefined4 size,int count)\n\n{\n  undefined4 *ptr;\n  int offset;\n  \n  offset = (count + -1) * 0x68;\n  ptr = (undefined4 *)_malloc_r(size,offset + 0x74);\n  if (ptr != (undefined4 *)0x0) {\n    *ptr = 0;\n    ptr[1] = count;\n    ptr[2] = ptr + 3;\n    memset(ptr + 3,0,offset + 0x68);\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_08006c88": "allocate_memory_08006c88",
                "param_1": "size",
                "param_2": "count",
                "puVar1": "ptr",
                "iVar2": "offset"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "_malloc_r",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006cb4": {
            "entrypoint": "0x08006cb4",
            "current_name": "initialize_data_08006cb4",
            "code": "\nvoid initializeData_08006cb4(undefined1 *dataPtr)\n\n{\n  undefined4 result;\n  undefined1 *checkPtr;\n  \n  if (*(int *)(dataPtr + 0x18) == 0) {\n    *(undefined4 *)(dataPtr + 0x48) = 0;\n    *(undefined4 *)(dataPtr + 0x4c) = 0;\n    *(undefined4 *)(dataPtr + 0x50) = 0;\n    checkPtr = &mainData;\n    *(undefined4 *)(dataPtr + 0x28) = 0x8006c35;\n    if (dataPtr == &mainData) {\n      checkPtr = (undefined1 *)0x1;\n    }\n    if (dataPtr == &mainData) {\n      *(undefined1 **)(dataPtr + 0x18) = checkPtr;\n    }\n    result = __sfp();\n    *(undefined4 *)(dataPtr + 4) = result;\n    result = __sfp(dataPtr);\n    *(undefined4 *)(dataPtr + 8) = result;\n    result = __sfp(dataPtr);\n    *(undefined4 *)(dataPtr + 0xc) = result;\n    setFlag(*(undefined4 *)(dataPtr + 4),4,0);\n    setFlag(*(undefined4 *)(dataPtr + 8),9,1);\n    setFlag(*(undefined4 *)(dataPtr + 0xc),0x12,2);\n    *(undefined4 *)(dataPtr + 0x18) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006cb4": "initialize_data_08006cb4",
                "param_1": "dataPtr",
                "uVar1": "result",
                "puVar2": "checkPtr",
                "&impure_data": "&mainData",
                "impure_data": "mainData",
                "std_isra_0": "setFlag"
            },
            "calling": [
                "_fflush_r",
                "__swbuf_r",
                "__sfp",
                "__swsetup_r",
                "iprintf",
                "_vfiprintf_r"
            ],
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d14": {
            "entrypoint": "0x08006d14",
            "current_name": "initialize_memory_08006d14",
            "code": "\nint * initializeMemory_08006d14(undefined4 *param)\n\n{\n  int *ptr;\n  int *ptr2;\n  int **ptrPtr;\n  \n  if (DAT_20000114 == 0) {\n    initializeData(&impureData);\n  }\n  ptrPtr = (int **)&DAT_20000144;\n  do {\n    ptr2 = ptrPtr[2];\n    ptr = ptrPtr[1];\n    while (ptr = (int *)((int)ptr + -1), -1 < (int)ptr) {\n      if (*(short *)(ptr2 + 3) == 0) {\n        *(undefined2 *)((int)ptr2 + 0xe) = 0xffff;\n        ptr2[0x19] = 0;\n        *(undefined2 *)(ptr2 + 3) = 1;\n        *ptr2 = 0;\n        ptr2[2] = 0;\n        ptr2[1] = 0;\n        ptr2[4] = 0;\n        ptr2[5] = 0;\n        ptr2[6] = 0;\n        memset(ptr2 + 0x17,0,8);\n        ptr2[0xd] = 0;\n        ptr2[0xe] = 0;\n        ptr2[0x12] = 0;\n        ptr2[0x13] = 0;\n        return ptr2;\n      }\n      ptr2 = ptr2 + 0x1a;\n    }\n    if (*ptrPtr == (int *)0x0) {\n      ptr = (int *)__sfmoreglue(param,4);\n      *ptrPtr = ptr;\n      if (ptr == (int *)0x0) {\n        *param = 0xc;\n        return (int *)0x0;\n      }\n    }\n    ptrPtr = (int **)*ptrPtr;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08006d14": "initialize_memory_08006d14",
                "param_1": "param",
                "piVar1": "ptr",
                "piVar2": "ptr2",
                "ppiVar3": "ptrPtr",
                "__sinit": "initializeData",
                "&impure_data": "&impureData"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset",
                "__sfmoreglue",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d8c": {
            "entrypoint": "0x08006d8c",
            "current_name": "process_elements_08006d8c",
            "code": "\nuint processElements_08006d8c(int inputPointer,code *functionPointer,undefined4 param3,undefined4 param4)\n\n{\n  uint returnValue;\n  int counter;\n  int *currentElement;\n  int elementPointer;\n  uint result;\n  int innerCounter;\n  \n  result = 0;\n  for (currentElement = (int *)(inputPointer + 0x48); currentElement != (int *)0x0; currentElement = (int *)*currentElement) {\n    elementPointer = currentElement[2];\n    innerCounter = currentElement[1];\n    while (innerCounter = innerCounter + -1, -1 < innerCounter) {\n      if ((1 < *(ushort *)(elementPointer + 0xc)) && (counter = *(short *)(elementPointer + 0xe) + 1, counter != 0)) {\n        returnValue = (*functionPointer)(inputPointer,elementPointer,param3,counter,param4);\n        result = result | returnValue;\n      }\n      elementPointer = elementPointer + 0x68;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006d8c": "process_elements_08006d8c",
                "param_1": "inputPointer",
                "param_2": "functionPointer",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "returnValue",
                "iVar2": "counter",
                "piVar3": "currentElement",
                "iVar4": "elementPointer",
                "uVar5": "result",
                "iVar6": "innerCounter"
            },
            "calling": [
                "_cleanup_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006dc8": {
            "entrypoint": "0x08006dc8",
            "current_name": "check_file_status_08006dc8",
            "code": "\nundefined4 checkFileStatus_08006dc8(undefined4 fileDescriptor,int fileMetadata,undefined4 *outputValues,uint *fileAttributes)\n\n{\n  int fileStatus;\n  undefined4 filePermission;\n  undefined temporaryStorage [4];\n  uint fileMode;\n  \n  if ((*(short *)(fileMetadata + 0xe) < 0) ||\n     (fileStatus = _fstat_r(fileDescriptor,(int)*(short *)(fileMetadata + 0xe),temporaryStorage), fileStatus < 0)) {\n    *fileAttributes = 0;\n    if ((int)((uint)*(ushort *)(fileMetadata + 0xc) << 0x18) < 0) {\n      filePermission = 0x40;\n      goto LAB_08006e08;\n    }\n  }\n  else {\n    *fileAttributes = (uint)((fileMode & 0xf000) == 0x2000);\n  }\n  filePermission = 0x400;\nLAB_08006e08:\n  *outputValues = filePermission;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006dc8": "check_file_status_08006dc8",
                "param_1": "fileDescriptor",
                "param_2": "fileMetadata",
                "param_3": "outputValues",
                "param_4": "fileAttributes",
                "iVar1": "fileStatus",
                "uVar2": "filePermission",
                "auStack_4c": "temporaryStorage",
                "local_48": "fileMode"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e10": {
            "entrypoint": "0x08006e10",
            "current_name": "decode_and_allocate_memory_08006e10",
            "code": "\nvoid decode_and_allocate_memory_08006e10(int memory_manager,int *input_data)\n\n{\n  ushort result;\n  int allocated_memory;\n  int data_length;\n  int *buffer;\n  \n  if (-1 < (int)((uint)*(ushort *)(input_data + 3) << 0x1e)) {\n    data_length = memory_manager;\n    buffer = input_data;\n    result = decode_data(memory_manager,input_data,&data_length,&buffer);\n    allocated_memory = allocate_memory(memory_manager,data_length);\n    if (allocated_memory != 0) {\n      *(undefined4 *)(memory_manager + 0x28) = 0x8006c35;\n      *input_data = allocated_memory;\n      *(ushort *)(input_data + 3) = *(ushort *)(input_data + 3) | 0x80;\n      input_data[4] = allocated_memory;\n      input_data[5] = data_length;\n      if ((buffer != (int *)0x0) &&\n         (allocated_memory = check_input_device(memory_manager,(int)*(short *)((int)input_data + 0xe)), allocated_memory != 0)) {\n        *(ushort *)(input_data + 3) = *(ushort *)(input_data + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(input_data + 3) = result | *(ushort *)(input_data + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(input_data + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(input_data + 3) = *(ushort *)(input_data + 3) & 0xfffc | 2;\n  }\n  *input_data = (int)input_data + 0x47;\n  input_data[4] = (int)input_data + 0x47;\n  input_data[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006e10": "decode_and_allocate_memory_08006e10",
                "param_1": "memory_manager",
                "param_2": "input_data",
                "uVar1": "result",
                "iVar2": "allocated_memory",
                "local_18": "data_length",
                "local_14": "buffer",
                "__swhatbuf_r": "decode_data",
                "_malloc_r": "allocate_memory",
                "_isatty_r": "check_input_device"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "_malloc_r",
                "_isatty_r",
                "__swhatbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e90": {
            "entrypoint": "0x08006e90",
            "current_name": "find_byte_in_buffer_08006e90",
            "code": "\nvoid * find_byte_in_buffer_08006e90(void *buffer,int target_byte,size_t buffer_length)\n\n{\n  byte *current_byte;\n  byte *next_byte;\n  \n  current_byte = (byte *)buffer;\n  do {\n    next_byte = current_byte;\n    if (next_byte == (byte *)(buffer_length + (int)buffer)) {\n      return (void *)0x0;\n    }\n    current_byte = next_byte + 1;\n  } while ((uint)*next_byte != (target_byte & 0xffU));\n  return next_byte;\n}\n\n",
            "renaming": {
                "FUN_08006e90": "find_byte_in_buffer_08006e90",
                "__s": "buffer",
                "__c": "target_byte",
                "__n": "buffer_length",
                "pbVar1": "current_byte",
                "pbVar2": "next_byte"
            },
            "calling": [
                "_vfiprintf_r",
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006eac": {
            "entrypoint": "0x08006eac",
            "current_name": "FUNC_08006eac",
            "code": "\nvoid FUNC_08006eac(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006eac": "FUNC_08006eac"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08006eae": {
            "entrypoint": "0x08006eae",
            "current_name": "FUNC_08006eae",
            "code": "\nvoid FUNC_08006eae(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006eae": "FUNC_08006eae"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08006eb0": {
            "entrypoint": "0x08006eb0",
            "current_name": "execute_process_08006eb0",
            "code": "\nundefined4 execute_process_08006eb0(undefined4 *output,uint command,undefined4 param1,undefined4 param2)\n\n{\n  __pid_t process_id;\n  undefined4 result;\n  int ptr_array;\n  code *function_ptr;\n  \n  if (0x1f < command) {\n    *output = 0x16;\n    return 0xffffffff;\n  }\n  ptr_array = output[0x11];\n  if ((ptr_array != 0) && (function_ptr = *(code **)(ptr_array + command * 4), function_ptr != (code *)0x0)) {\n    if (function_ptr != (code *)0x1) {\n      if (function_ptr == (code *)0xffffffff) {\n        *output = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(ptr_array + command * 4) = 0;\n      (*function_ptr)(command);\n    }\n    return 0;\n  }\n  process_id = _getpid_r();\n  result = _kill_r(output,process_id,command,param2);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006eb0": "execute_process_08006eb0",
                "param_1": "output",
                "param_2": "command",
                "param_3": "param1",
                "param_4": "param2",
                "_Var1": "process_id",
                "uVar2": "result",
                "iVar3": "ptr_array",
                "pcVar4": "function_ptr"
            },
            "calling": [
                "raise"
            ],
            "called": [
                "_kill_r",
                "_getpid_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f00": {
            "entrypoint": "0x08006f00",
            "current_name": "raise_signal_08006f00",
            "code": "\nint raise_signal_08006f00(int signal_number)\n\n{\n  int iVar1;\n  \n  iVar1 = _raise_r(pointer_to_impure,signal_number);\n  return iVar1;\n}\n\n",
            "renaming": {
                "FUN_08006f00": "raise_signal_08006f00",
                "__sig": "signal_number",
                "_impure_ptr": "pointer_to_impure"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "_raise_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f10": {
            "entrypoint": "0x08006f10",
            "current_name": "kill_process_08006f10",
            "code": "\nvoid kill_process_08006f10(int *error_code,__pid_t process_id,int signal_number)\n\n{\n  int result;\n  \n  errno = 0;\n  result = _kill(process_id,signal_number);\n  if ((result == -1) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f10": "kill_process_08006f10",
                "param_1": "error_code",
                "param_2": "process_id",
                "param_3": "signal_number",
                "iVar1": "result"
            },
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_kill"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f34": {
            "entrypoint": "0x08006f34",
            "current_name": "FUN_08006f34",
            "code": "\n\n\n__pid_t _getpid(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {},
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_getpid"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f38": {
            "entrypoint": "0x08006f38",
            "current_name": "update_data_08006f38",
            "code": "\nvoid updateData_08006f38(undefined4 fileDescriptor,int dataPointer)\n\n{\n  int readResult;\n  uint updatedValue;\n  bool isReadSuccessful;\n  \n  readResult = _read_r(fileDescriptor,(int)*(short *)(dataPointer + 0xe));\n  isReadSuccessful = -1 < readResult;\n  if (isReadSuccessful) {\n    updatedValue = *(int *)(dataPointer + 0x54) + readResult;\n  }\n  else {\n    updatedValue = *(ushort *)(dataPointer + 0xc) & 0xffffefff;\n  }\n  if (isReadSuccessful) {\n    *(uint *)(dataPointer + 0x54) = updatedValue;\n  }\n  if (!isReadSuccessful) {\n    *(short *)(dataPointer + 0xc) = (short)updatedValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f38": "update_data_08006f38",
                "param_1": "fileDescriptor",
                "param_2": "dataPointer",
                "iVar1": "readResult",
                "uVar2": "updatedValue",
                "bVar3": "isReadSuccessful"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f5a": {
            "entrypoint": "0x08006f5a",
            "current_name": "update_file_08006f5a",
            "code": "\nvoid updateFile_08006f5a(undefined4 fileDescriptor,integer dataStructPtr,undefined4 buffer,undefined4 size)\n\n{\n  if ((integer)((uinteger)*(ushort *)(dataStructPtr + 0xc) << 0x17) < 0) {\n    repositionFilePointer(fileDescriptor,(integer)*(short *)(dataStructPtr + 0xe),0,2);\n  }\n  *(ushort *)(dataStructPtr + 0xc) = *(ushort *)(dataStructPtr + 0xc) & 0xefff;\n  writeToFile(fileDescriptor,(integer)*(short *)(dataStructPtr + 0xe),buffer,size);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f5a": "update_file_08006f5a",
                "param_1": "fileDescriptor",
                "param_2": "dataStructPtr",
                "param_3": "buffer",
                "param_4": "size",
                "int": "integer",
                "_lseek_r": "repositionFilePointer",
                "_write_r": "writeToFile"
            },
            "calling": [],
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f92": {
            "entrypoint": "0x08006f92",
            "current_name": "update_file_status_08006f92",
            "code": "\nvoid updateFileStatus_08006f92(undefined4 fileDescriptor,int dataBuffer)\n\n{\n  int seekResult;\n  ushort updatedFlags;\n  bool isSeekFailed;\n  \n  seekResult = _lseek_r(fileDescriptor,(int)*(short *)(dataBuffer + 0xe));\n  isSeekFailed = seekResult == -1;\n  if (isSeekFailed) {\n    updatedFlags = *(ushort *)(dataBuffer + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(dataBuffer + 0x54) = seekResult;\n    updatedFlags = *(ushort *)(dataBuffer + 0xc) | 0x1000;\n  }\n  if (isSeekFailed) {\n    *(ushort *)(dataBuffer + 0xc) = updatedFlags;\n  }\n  if (!isSeekFailed) {\n    *(ushort *)(dataBuffer + 0xc) = updatedFlags;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f92": "update_file_status_08006f92",
                "param_1": "fileDescriptor",
                "param_2": "dataBuffer",
                "iVar1": "seekResult",
                "uVar2": "updatedFlags",
                "bVar3": "isSeekFailed"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006fb6": {
            "entrypoint": "0x08006fb6",
            "current_name": "close_file_descriptor_08006fb6",
            "code": "\nvoid closeFileDescriptor_08006fb6(undefined4 param_1,int ptr)\n\n{\n  closeFile(param_1,(int)*(short *)(ptr + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006fb6": "close_file_descriptor_08006fb6",
                "param_2": "ptr",
                "_close_r": "closeFile"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006fc0": {
            "entrypoint": "0x08006fc0",
            "current_name": "write_to_file_08006fc0",
            "code": "\nvoid writeToFile_08006fc0(int *errorNumber,int fileDescriptor,char *buffer,int count)\n\n{\n  int writeResult;\n  \n  errno = 0;\n  writeResult = _write(fileDescriptor,buffer,count);\n  if ((writeResult == -1) && (errno != 0)) {\n    *errorNumber = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006fc0": "write_to_file_08006fc0",
                "param_1": "errorNumber",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "count",
                "iVar1": "writeResult"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006fe4": {
            "entrypoint": "0x08006fe4",
            "current_name": "close_file_with_error_handling_08006fe4",
            "code": "\nvoid closeFileWithErrorHandling_08006fe4(int *errorPointer,int fileDescriptor)\n\n{\n  int closeResult;\n  \n  errno = 0;\n  closeResult = _close(fileDescriptor);\n  if ((closeResult == -1) && (errno != 0)) {\n    *errorPointer = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006fe4": "close_file_with_error_handling_08006fe4",
                "param_1": "errorPointer",
                "param_2": "fileDescriptor",
                "iVar1": "closeResult"
            },
            "calling": [
                "__sclose"
            ],
            "called": [
                "_close"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007004": {
            "entrypoint": "0x08007004",
            "current_name": "get_file_status_08007004",
            "code": "\nvoid get_file_status_08007004(int *error_code,int file_descriptor,stat *status)\n\n{\n  int result;\n  \n  errno = 0;\n  result = _fstat(file_descriptor,status);\n  if ((result == -1) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007004": "get_file_status_08007004",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "status",
                "iVar1": "result"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007028": {
            "entrypoint": "0x08007028",
            "current_name": "check_terminal_validity_08007028",
            "code": "\nvoid checkTerminalValidity_08007028(int *errorPointer,int fileDescriptor)\n\n{\n  int isTerminal;\n  \n  errorNumber = 0;\n  isTerminal = _isatty(fileDescriptor);\n  if ((isTerminal == -1) && (errorNumber != 0)) {\n    *errorPointer = errorNumber;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007028": "check_terminal_validity_08007028",
                "param_1": "errorPointer",
                "param_2": "fileDescriptor",
                "iVar1": "isTerminal",
                "errno": "errorNumber"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007048": {
            "entrypoint": "0x08007048",
            "current_name": "seek_file_and_set_error_08007048",
            "code": "\nvoid seekFileAndSetError_08007048(int *errorCode,int fileDescriptor,__off_t offset,int origin)\n\n{\n  __off_t result;\n  \n  errno = 0;\n  result = _lseek(fileDescriptor,offset,origin);\n  if ((result == -1) && (errno != 0)) {\n    *errorCode = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007048": "seek_file_and_set_error_08007048",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "param_3": "offset",
                "param_4": "origin",
                "_Var1": "result"
            },
            "calling": [
                "__swrite",
                "__sseek"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800706c": {
            "entrypoint": "0x0800706c",
            "current_name": "read_file_0800706c",
            "code": "\nvoid readFile_0800706c(int *error,int fileDescriptor,char *buffer,int count)\n\n{\n  int bytesRead;\n  \n  errno = 0;\n  bytesRead = _read(fileDescriptor,buffer,count);\n  if ((bytesRead == -1) && (errno != 0)) {\n    *error = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800706c": "read_file_0800706c",
                "param_1": "error",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "count",
                "iVar1": "bytesRead"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007090": {
            "entrypoint": "0x08007090",
            "current_name": "throw_function_call_error_08007090",
            "code": "\n\n/* std::__throw_bad_function_call() */\n\nvoid std::throwFunctionCallError_08007090(void)\n\n{\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_08007090": "throw_function_call_error_08007090"
            },
            "calling": [
                "operator()"
            ],
            "called": [
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007098": {
            "entrypoint": "0x08007098",
            "current_name": "initialize_c_type_by_name_08007098",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeCTypeByName_08007098(void)\n\n{\n  if (-1 < moneypunct<char,false>::id << 0x1f) {\n    moneypunct<char,false>::id = 1;\n  }\n  if (-1 < moneypunct<char,true>::id << 0x1f) {\n    moneypunct<char,true>::id = 1;\n  }\n  if (-1 < money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < numpunct<char>::id << 0x1f) {\n    numpunct<char>::id = 1;\n  }\n  if (-1 < num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __timepunct<char>::id << 0x1f) {\n    __timepunct<char>::id = 1;\n  }\n  if (-1 < time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < messages<char>::id << 0x1f) {\n    messages<char>::id = 1;\n  }\n  if (-1 < collate<char>::id << 0x1f) {\n    collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007098": "initialize_c_type_by_name_08007098"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800715c": {
            "entrypoint": "0x0800715c",
            "current_name": "initialize_c_type_0800715c",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeCType_0800715c(void)\n\n{\n  if (-1 < moneypunct<wchar_t,false>::id << 0x1f) {\n    moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < moneypunct<wchar_t,true>::id << 0x1f) {\n    moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < numpunct<wchar_t>::id << 0x1f) {\n    numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __timepunct<wchar_t>::id << 0x1f) {\n    __timepunct<wchar_t>::id = 1;\n  }\n  if (-1 < time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < messages<wchar_t>::id << 0x1f) {\n    messages<wchar_t>::id = 1;\n  }\n  if (-1 < collate<wchar_t>::id << 0x1f) {\n    collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800715c": "initialize_c_type_0800715c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007220": {
            "entrypoint": "0x08007220",
            "current_name": "initialize_locale_08007220",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeLocale_08007220(void)\n\n{\n  if (-1 < __cxx11::moneypunct<wchar_t,false>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<wchar_t,true>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<wchar_t>::id << 0x1f) {\n    __cxx11::numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<wchar_t>::id << 0x1f) {\n    __cxx11::messages<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::collate<wchar_t>::id << 0x1f) {\n    __cxx11::collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007220": "initialize_locale_08007220"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072a4": {
            "entrypoint": "0x080072a4",
            "current_name": "initialize_c_type_by_name_080072a4",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeCTypeByName_080072a4(void)\n\n{\n  if (-1 < __cxx11::moneypunct<char,false>::id << 0x1f) {\n    __cxx11::moneypunct<char,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<char,true>::id << 0x1f) {\n    __cxx11::moneypunct<char,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<char>::id << 0x1f) {\n    __cxx11::numpunct<char>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f\n     ) {\n    __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<char>::id << 0x1f) {\n    __cxx11::messages<char>::id = 1;\n  }\n  if (-1 < __cxx11::collate<char>::id << 0x1f) {\n    __cxx11::collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080072a4": "initialize_c_type_by_name_080072a4"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007328": {
            "entrypoint": "0x08007328",
            "current_name": "FUNC_08007328",
            "code": "\nvoid FUNC_08007328(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007328": "FUNC_08007328"
            },
            "calling": [
                "__libc_init_array",
                "__do_global_dtors_aux"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08007334": {
            "entrypoint": "0x08007334",
            "current_name": "FUNC_08007334",
            "code": "\nvoid FUNC_08007334(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007334": "FUNC_08007334"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 195048,
    "layers": [
        [
            "FUN_0800010c",
            "FUN_08000178",
            "FUN_08000188",
            "FUN_08000190",
            "FUN_08000194",
            "FUN_0800040c",
            "FUN_0800042c",
            "FUN_08000450",
            "FUN_0800048c",
            "FUN_0800049c",
            "FUN_080006d4",
            "FUN_080008ba",
            "FUN_0800091c",
            "FUN_08000924",
            "FUN_0800092c",
            "FUN_080009a8",
            "FUN_080009b8",
            "FUN_080009c8",
            "FUN_080009dc",
            "FUN_080009f0",
            "FUN_08000a04",
            "FUN_08000a18",
            "FUN_08000a2c",
            "FUN_08000a58",
            "FUN_08000aa8",
            "FUN_08000ae8",
            "FUN_08000aec",
            "FUN_08000b08",
            "FUN_08000bcc",
            "FUN_08000cbc",
            "FUN_08000cd0",
            "FUN_08001294",
            "FUN_080012a2",
            "FUN_080012c0",
            "FUN_080012e8",
            "FUN_08001310",
            "FUN_0800134e",
            "FUN_0800135a",
            "FUN_08001366",
            "FUN_0800138e",
            "FUN_080013a4",
            "FUN_080014ba",
            "FUN_08001510",
            "FUN_08001550",
            "FUN_0800157c",
            "FUN_080015b2",
            "FUN_080015f8",
            "FUN_080016b4",
            "FUN_08001814",
            "FUN_080018f8",
            "FUN_08001918",
            "FUN_08001960",
            "FUN_080019f6",
            "FUN_08001a44",
            "FUN_08001a66",
            "FUN_08001ab0",
            "FUN_08001b18",
            "FUN_08001b48",
            "FUN_08001be8",
            "FUN_08001c30",
            "FUN_08001c32",
            "FUN_08001c3c",
            "FUN_08001c88",
            "FUN_08001cac",
            "FUN_08001cc4",
            "FUN_08001cd0",
            "FUN_08001e40",
            "FUN_08001e48",
            "FUN_08001f80",
            "FUN_08001f84",
            "FUN_08002004",
            "FUN_080020f0",
            "FUN_0800213c",
            "FUN_0800224c",
            "FUN_08002348",
            "FUN_08002384",
            "FUN_08002470",
            "FUN_08002494",
            "FUN_080024f8",
            "FUN_08002514",
            "FUN_08002540",
            "FUN_08002560",
            "FUN_08002582",
            "FUN_0800258c",
            "FUN_08002624",
            "FUN_08002810",
            "FUN_0800281e",
            "FUN_0800282c",
            "FUN_08002848",
            "FUN_080028d2",
            "FUN_080028de",
            "FUN_08002ab8",
            "FUN_08002ad8",
            "FUN_08002af8",
            "FUN_08002b84",
            "FUN_08002c10",
            "FUN_08002c54",
            "FUN_08002ca6",
            "FUN_08002cf2",
            "FUN_08002d1c",
            "FUN_08002db2",
            "FUN_08002efc",
            "FUN_08002f9c",
            "FUN_0800306c",
            "FUN_0800316c",
            "FUN_080032b4",
            "FUN_080033b8",
            "FUN_08003520",
            "FUN_080035fc",
            "FUN_0800365c",
            "FUN_08003688",
            "FUN_08003a68",
            "FUN_08003ad4",
            "FUN_08003c44",
            "FUN_08003c50",
            "FUN_08003c70",
            "FUN_08003c90",
            "FUN_08003da4",
            "FUN_08003ea0",
            "FUN_08003ed8",
            "FUN_08003f18",
            "FUN_08004092",
            "FUN_080040b0",
            "FUN_08004110",
            "FUN_0800412c",
            "FUN_0800417c",
            "FUN_08004198",
            "FUN_08004204",
            "FUN_080043b4",
            "FUN_0800441a",
            "FUN_08004478",
            "FUN_0800455a",
            "FUN_080045a2",
            "FUN_080045fe",
            "FUN_08004618",
            "FUN_080046b8",
            "FUN_080047d8",
            "FUN_080047e8",
            "FUN_080047f4",
            "FUN_0800480a",
            "FUN_08004828",
            "FUN_08004848",
            "FUN_08004884",
            "FUN_0800492c",
            "FUN_08004948",
            "FUN_08004974",
            "FUN_080049f0",
            "FUN_08004a4c",
            "FUN_08004b34",
            "FUN_08004b3c",
            "FUN_08004b94",
            "FUN_08004b9e",
            "FUN_08004bb0",
            "FUN_08004c30",
            "FUN_08004c48",
            "FUN_08004c52",
            "FUN_08004c5e",
            "FUN_08004c78",
            "FUN_08004c8a",
            "FUN_08004ca2",
            "FUN_08004cb2",
            "FUN_08004cce",
            "FUN_08004ce2",
            "FUN_08004d06",
            "FUN_08004d18",
            "FUN_08004d30",
            "FUN_08004d40",
            "FUN_08004d44",
            "FUN_08004d90",
            "FUN_08004df4",
            "FUN_08004df8",
            "FUN_08004e12",
            "FUN_08004e20",
            "FUN_08004e34",
            "FUN_08004e48",
            "FUN_08004e5c",
            "FUN_08004e70",
            "FUN_08004e74",
            "FUN_08004ec4",
            "FUN_08004ef4",
            "FUN_08004f0c",
            "FUN_08004f1c",
            "FUN_08004f2c",
            "FUN_08004f3c",
            "FUN_08004f4c",
            "FUN_08005384",
            "FUN_080053d4",
            "FUN_0800548c",
            "FUN_080054b0",
            "FUN_080054d4",
            "FUN_08005510",
            "FUN_08005568",
            "FUN_080055bc",
            "FUN_080055e0",
            "FUN_08005604",
            "FUN_08005650",
            "FUN_08005690",
            "FUN_080056a8",
            "FUN_080056c0",
            "FUN_080056d8",
            "FUN_08005714",
            "FUN_0800571a",
            "FUN_08005724",
            "FUN_08005728",
            "FUN_0800572c",
            "FUN_08005730",
            "FUN_0800573c",
            "FUN_08005740",
            "FUN_08005750",
            "FUN_08005754",
            "FUN_080057b4",
            "FUN_08005848",
            "FUN_08005890",
            "FUN_080058e0",
            "FUN_080058ea",
            "FUN_0800591e",
            "FUN_08005932",
            "FUN_0800594e",
            "FUN_08005976",
            "FUN_0800598a",
            "FUN_080059c8",
            "FUN_08005a44",
            "FUN_08005a68",
            "FUN_08005b24",
            "FUN_08005b3c",
            "FUN_08005b54",
            "FUN_08005bb0",
            "FUN_08005bd4",
            "FUN_08005be2",
            "FUN_08005c1c",
            "FUN_08005c38",
            "FUN_08005c64",
            "FUN_08005c72",
            "FUN_08005c96",
            "FUN_08005cb6",
            "FUN_08005cc0",
            "FUN_08005cd4",
            "FUN_08005ce8",
            "FUN_08005d42",
            "FUN_08005d82",
            "FUN_08005d8a",
            "FUN_08005da0",
            "FUN_08005da8",
            "FUN_08005f2c",
            "FUN_08005f40",
            "FUN_08005f5e",
            "FUN_08005f6c",
            "FUN_08005f8c",
            "FUN_08005fa0",
            "FUN_08005fc8",
            "FUN_08006074",
            "FUN_0800607e",
            "FUN_08006088",
            "FUN_08006092",
            "FUN_0800609c",
            "FUN_080060a6",
            "FUN_080060bc",
            "FUN_080060d4",
            "FUN_080060e4",
            "FUN_08006104",
            "FUN_08006112",
            "FUN_0800611c",
            "FUN_08006158",
            "FUN_08006174",
            "FUN_08006198",
            "FUN_080061e0",
            "FUN_080061f0",
            "FUN_08006288",
            "FUN_08006344",
            "FUN_08006370",
            "FUN_08006394",
            "FUN_080065c0",
            "FUN_080066b0",
            "FUN_080068f0",
            "FUN_08006920",
            "FUN_08006940",
            "FUN_080069e4",
            "FUN_08006ac0",
            "FUN_08006ad0",
            "FUN_08006be0",
            "FUN_08006c34",
            "FUN_08006c40",
            "FUN_08006c88",
            "FUN_08006cb4",
            "FUN_08006d14",
            "FUN_08006d8c",
            "FUN_08006dc8",
            "FUN_08006e10",
            "FUN_08006e90",
            "FUN_08006eb0",
            "FUN_08006f00",
            "FUN_08006f10",
            "FUN_08006f38",
            "FUN_08006f5a",
            "FUN_08006f92",
            "FUN_08006fb6",
            "FUN_08006fc0",
            "FUN_08006fe4",
            "FUN_08007004",
            "FUN_08007028",
            "FUN_08007048",
            "FUN_0800706c",
            "FUN_08007090",
            "FUN_08007098",
            "FUN_0800715c",
            "FUN_08007220",
            "FUN_080072a4"
        ],
        [
            "FUN_080004f8",
            "FUN_0800074c"
        ]
    ],
    "locked_functions": []
}